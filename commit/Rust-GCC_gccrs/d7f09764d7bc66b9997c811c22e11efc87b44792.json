{"sha": "d7f09764d7bc66b9997c811c22e11efc87b44792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdmMDk3NjRkN2JjNjZiOTk5N2M4MTFjMjJlMTFlZmM4N2I0NDc5Mg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-10-03T21:10:11Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-10-03T21:10:11Z"}, "message": "Merge lto branch into trunk.\n\nFrom-SVN: r152434", "tree": {"sha": "3a9882bd235e5026410e5397a5e46a97ece50b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a9882bd235e5026410e5397a5e46a97ece50b48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7f09764d7bc66b9997c811c22e11efc87b44792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f09764d7bc66b9997c811c22e11efc87b44792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7f09764d7bc66b9997c811c22e11efc87b44792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f09764d7bc66b9997c811c22e11efc87b44792/comments", "author": null, "committer": null, "parents": [{"sha": "b06e51a0c9852e7fb7c6f589b46f6906ce48febd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06e51a0c9852e7fb7c6f589b46f6906ce48febd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06e51a0c9852e7fb7c6f589b46f6906ce48febd"}], "stats": {"total": 43876, "additions": 43534, "deletions": 342}, "files": [{"sha": "a9de26532c36796c3ed7f04428619bffde19fcfc", "filename": "ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1,3 +1,32 @@\n+2009-10-03  2009-02-05  Rafael Avila de Espindola  <espindola@google.com>\n+\n+\t* Makefile.def: all-lto-plugin depends on all-libiberty.\n+\tset bootstrap=true for lto-plugin.\n+\tAdd lto-plugin.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac (host_libs): Add lto-plugin.\n+\t* configure: Regenerate.\n+\n+\n+2009-10-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Makefile.tpl (HOST_EXPORTS): Add LIBELFLIBS and LIBELFINC.\n+\t(HOST_LIBELFLIBS): Define.\n+\t(HOST_LIBELFINC): Define.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac: Add --enable-lto.\n+\tAdd --with-libelf, --with-libelf-include and --with-libelf-lib.\n+\tIf --enable-lto is used, add 'lto' to new_enable_languages.\n+\tIf --enable-lto is used and gold is enabled, add\n+\tlto-plugin to configdirs.\n+\t* configure: Regenerate.\n+\n+2009-10-03  Simon Baldwin  <simonb@google.com>\n+\n+\t* configure.ac: If --with-system-zlib, suppress local zlib and\n+\tpass --with-system-zlib to subdir configure scripts.\n+\t* configure: Regenerate.\n+\n 2009-10-01  Loren J. Rittle <ljrittle@acm.org>\n \t    Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "52d486fdb7b088a39bd2f57a482e6162bdaa6e35", "filename": "Makefile.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -97,7 +97,8 @@ host_modules= { module= ld; bootstrap=true; };\n host_modules= { module= libcpp; bootstrap=true; };\n host_modules= { module= libdecnumber; bootstrap=true; };\n host_modules= { module= libgui; };\n-host_modules= { module= libiberty; bootstrap=true; };\n+host_modules= { module= libiberty; bootstrap=true;\n+\t        extra_configure_flags='@extra_host_libiberty_configure_flags@';};\n // We abuse missing to avoid installing anything for libiconv.\n host_modules= { module= libiconv;\n \t\textra_configure_flags='--disable-shared';\n@@ -141,6 +142,7 @@ host_modules= { module= libtermcap; no_check=true;\n                 missing=maintainer-clean; };\n host_modules= { module= utils; no_check=true; };\n host_modules= { module= gnattools; };\n+host_modules= { module= lto-plugin; bootstrap=true; };\n \n target_modules = { module= libstdc++-v3;\n \t\t   bootstrap=true;\n@@ -346,6 +348,8 @@ dependencies = { module=all-fixincludes; on=all-libiberty; };\n \n dependencies = { module=all-gnattools; on=all-target-libada; };\n \n+dependencies = { module=all-lto-plugin; on=all-libiberty; };\n+\n dependencies = { module=configure-mpfr; on=all-gmp; };\n dependencies = { module=configure-mpc; on=all-mpfr; };\n dependencies = { module=configure-ppl; on=all-gmp; };"}, {"sha": "8738cd49f30f4148550b54c88e8ef0edcad4f4b0", "filename": "Makefile.in", "status": "modified", "additions": 987, "deletions": 11, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -219,6 +219,8 @@ HOST_EXPORTS = \\\n \tPPLINC=\"$(HOST_PPLINC)\"; export PPLINC; \\\n \tCLOOGLIBS=\"$(HOST_CLOOGLIBS)\"; export CLOOGLIBS; \\\n \tCLOOGINC=\"$(HOST_CLOOGINC)\"; export CLOOGINC; \\\n+\tLIBELFLIBS=\"$(HOST_LIBELFLIBS)\" ; export LIBELFLIBS; \\\n+\tLIBELFINC=\"$(HOST_LIBELFINC)\" ; export LIBELFINC; \\\n @if gcc-bootstrap\n \t$(RPATH_ENVVAR)=`echo \"$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \\\n @endif gcc-bootstrap\n@@ -293,6 +295,10 @@ HOST_PPLINC = @pplinc@\n HOST_CLOOGLIBS = @clooglibs@\n HOST_CLOOGINC = @clooginc@\n \n+# Where to find libelf\n+HOST_LIBELFLIBS = @libelflibs@\n+HOST_LIBELFINC = @libelfinc@\n+\n # ----------------------------------------------\n # Programs producing files for the BUILD machine\n # ----------------------------------------------\n@@ -854,7 +860,8 @@ configure-host:  \\\n     maybe-configure-tk \\\n     maybe-configure-libtermcap \\\n     maybe-configure-utils \\\n-    maybe-configure-gnattools\n+    maybe-configure-gnattools \\\n+    maybe-configure-lto-plugin\n .PHONY: configure-target\n configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n@@ -1026,6 +1033,9 @@ all-host: maybe-all-tk\n all-host: maybe-all-libtermcap\n all-host: maybe-all-utils\n all-host: maybe-all-gnattools\n+@if lto-plugin-no-bootstrap\n+all-host: maybe-all-lto-plugin\n+@endif lto-plugin-no-bootstrap\n \n .PHONY: all-target\n \n@@ -1147,6 +1157,7 @@ info-host: maybe-info-tk\n info-host: maybe-info-libtermcap\n info-host: maybe-info-utils\n info-host: maybe-info-gnattools\n+info-host: maybe-info-lto-plugin\n \n .PHONY: info-target\n \n@@ -1259,6 +1270,7 @@ dvi-host: maybe-dvi-tk\n dvi-host: maybe-dvi-libtermcap\n dvi-host: maybe-dvi-utils\n dvi-host: maybe-dvi-gnattools\n+dvi-host: maybe-dvi-lto-plugin\n \n .PHONY: dvi-target\n \n@@ -1371,6 +1383,7 @@ pdf-host: maybe-pdf-tk\n pdf-host: maybe-pdf-libtermcap\n pdf-host: maybe-pdf-utils\n pdf-host: maybe-pdf-gnattools\n+pdf-host: maybe-pdf-lto-plugin\n \n .PHONY: pdf-target\n \n@@ -1483,6 +1496,7 @@ html-host: maybe-html-tk\n html-host: maybe-html-libtermcap\n html-host: maybe-html-utils\n html-host: maybe-html-gnattools\n+html-host: maybe-html-lto-plugin\n \n .PHONY: html-target\n \n@@ -1595,6 +1609,7 @@ TAGS-host: maybe-TAGS-tk\n TAGS-host: maybe-TAGS-libtermcap\n TAGS-host: maybe-TAGS-utils\n TAGS-host: maybe-TAGS-gnattools\n+TAGS-host: maybe-TAGS-lto-plugin\n \n .PHONY: TAGS-target\n \n@@ -1707,6 +1722,7 @@ install-info-host: maybe-install-info-tk\n install-info-host: maybe-install-info-libtermcap\n install-info-host: maybe-install-info-utils\n install-info-host: maybe-install-info-gnattools\n+install-info-host: maybe-install-info-lto-plugin\n \n .PHONY: install-info-target\n \n@@ -1819,6 +1835,7 @@ install-pdf-host: maybe-install-pdf-tk\n install-pdf-host: maybe-install-pdf-libtermcap\n install-pdf-host: maybe-install-pdf-utils\n install-pdf-host: maybe-install-pdf-gnattools\n+install-pdf-host: maybe-install-pdf-lto-plugin\n \n .PHONY: install-pdf-target\n \n@@ -1931,6 +1948,7 @@ install-html-host: maybe-install-html-tk\n install-html-host: maybe-install-html-libtermcap\n install-html-host: maybe-install-html-utils\n install-html-host: maybe-install-html-gnattools\n+install-html-host: maybe-install-html-lto-plugin\n \n .PHONY: install-html-target\n \n@@ -2043,6 +2061,7 @@ installcheck-host: maybe-installcheck-tk\n installcheck-host: maybe-installcheck-libtermcap\n installcheck-host: maybe-installcheck-utils\n installcheck-host: maybe-installcheck-gnattools\n+installcheck-host: maybe-installcheck-lto-plugin\n \n .PHONY: installcheck-target\n \n@@ -2155,6 +2174,7 @@ mostlyclean-host: maybe-mostlyclean-tk\n mostlyclean-host: maybe-mostlyclean-libtermcap\n mostlyclean-host: maybe-mostlyclean-utils\n mostlyclean-host: maybe-mostlyclean-gnattools\n+mostlyclean-host: maybe-mostlyclean-lto-plugin\n \n .PHONY: mostlyclean-target\n \n@@ -2267,6 +2287,7 @@ clean-host: maybe-clean-tk\n clean-host: maybe-clean-libtermcap\n clean-host: maybe-clean-utils\n clean-host: maybe-clean-gnattools\n+clean-host: maybe-clean-lto-plugin\n \n .PHONY: clean-target\n \n@@ -2379,6 +2400,7 @@ distclean-host: maybe-distclean-tk\n distclean-host: maybe-distclean-libtermcap\n distclean-host: maybe-distclean-utils\n distclean-host: maybe-distclean-gnattools\n+distclean-host: maybe-distclean-lto-plugin\n \n .PHONY: distclean-target\n \n@@ -2491,6 +2513,7 @@ maintainer-clean-host: maybe-maintainer-clean-tk\n maintainer-clean-host: maybe-maintainer-clean-libtermcap\n maintainer-clean-host: maybe-maintainer-clean-utils\n maintainer-clean-host: maybe-maintainer-clean-gnattools\n+maintainer-clean-host: maybe-maintainer-clean-lto-plugin\n \n .PHONY: maintainer-clean-target\n \n@@ -2656,7 +2679,8 @@ check-host:  \\\n     maybe-check-tk \\\n     maybe-check-libtermcap \\\n     maybe-check-utils \\\n-    maybe-check-gnattools\n+    maybe-check-gnattools \\\n+    maybe-check-lto-plugin\n \n .PHONY: check-target\n check-target:  \\\n@@ -2794,7 +2818,8 @@ install-host-nogcc:  \\\n     maybe-install-tk \\\n     maybe-install-libtermcap \\\n     maybe-install-utils \\\n-    maybe-install-gnattools\n+    maybe-install-gnattools \\\n+    maybe-install-lto-plugin\n \n .PHONY: install-host\n install-host:  \\\n@@ -2873,7 +2898,8 @@ install-host:  \\\n     maybe-install-tk \\\n     maybe-install-libtermcap \\\n     maybe-install-utils \\\n-    maybe-install-gnattools\n+    maybe-install-gnattools \\\n+    maybe-install-lto-plugin\n \n .PHONY: install-target\n install-target:  \\\n@@ -28249,7 +28275,7 @@ configure-libiberty:\n \tlibsrcdir=\"$$s/libiberty\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n-\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  --target=${target_alias} $${srcdiroption} @extra_host_libiberty_configure_flags@ \\\n \t  || exit 1\n @endif libiberty\n \n@@ -28283,7 +28309,8 @@ configure-stage1-libiberty:\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n-\t  $(STAGE1_CONFIGURE_FLAGS)\n+\t  $(STAGE1_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n .PHONY: configure-stage2-libiberty maybe-configure-stage2-libiberty\n@@ -28316,7 +28343,8 @@ configure-stage2-libiberty:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n-\t  $(STAGE2_CONFIGURE_FLAGS)\n+\t  $(STAGE2_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n .PHONY: configure-stage3-libiberty maybe-configure-stage3-libiberty\n@@ -28349,7 +28377,8 @@ configure-stage3-libiberty:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n-\t  $(STAGE3_CONFIGURE_FLAGS)\n+\t  $(STAGE3_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n .PHONY: configure-stage4-libiberty maybe-configure-stage4-libiberty\n@@ -28382,7 +28411,8 @@ configure-stage4-libiberty:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n-\t  $(STAGE4_CONFIGURE_FLAGS)\n+\t  $(STAGE4_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n .PHONY: configure-stageprofile-libiberty maybe-configure-stageprofile-libiberty\n@@ -28415,7 +28445,8 @@ configure-stageprofile-libiberty:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n-\t  $(STAGEprofile_CONFIGURE_FLAGS)\n+\t  $(STAGEprofile_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n .PHONY: configure-stagefeedback-libiberty maybe-configure-stagefeedback-libiberty\n@@ -28448,7 +28479,8 @@ configure-stagefeedback-libiberty:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n-\t  $(STAGEfeedback_CONFIGURE_FLAGS)\n+\t  $(STAGEfeedback_CONFIGURE_FLAGS) \\\n+\t  @extra_host_libiberty_configure_flags@\n @endif libiberty-bootstrap\n \n \n@@ -42970,6 +43002,872 @@ maintainer-clean-gnattools:\n \n \n \n+.PHONY: configure-lto-plugin maybe-configure-lto-plugin\n+maybe-configure-lto-plugin:\n+@if gcc-bootstrap\n+configure-lto-plugin: stage_current\n+@endif gcc-bootstrap\n+@if lto-plugin\n+maybe-configure-lto-plugin: configure-lto-plugin\n+configure-lto-plugin: \n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(HOST_EXPORTS) \\\n+\techo Configuring in $(HOST_SUBDIR)/lto-plugin; \\\n+\tcd \"$(HOST_SUBDIR)/lto-plugin\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif lto-plugin\n+\n+\n+\n+.PHONY: configure-stage1-lto-plugin maybe-configure-stage1-lto-plugin\n+maybe-configure-stage1-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stage1-lto-plugin: configure-stage1-lto-plugin\n+configure-stage1-lto-plugin:\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE1_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE1_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage 1 in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  $(STAGE1_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+.PHONY: configure-stage2-lto-plugin maybe-configure-stage2-lto-plugin\n+maybe-configure-stage2-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stage2-lto-plugin: configure-stage2-lto-plugin\n+configure-stage2-lto-plugin:\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE2_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE2_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage 2 in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE2_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+.PHONY: configure-stage3-lto-plugin maybe-configure-stage3-lto-plugin\n+maybe-configure-stage3-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stage3-lto-plugin: configure-stage3-lto-plugin\n+configure-stage3-lto-plugin:\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE3_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE3_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage 3 in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE3_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+.PHONY: configure-stage4-lto-plugin maybe-configure-stage4-lto-plugin\n+maybe-configure-stage4-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stage4-lto-plugin: configure-stage4-lto-plugin\n+configure-stage4-lto-plugin:\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE4_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE4_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage 4 in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE4_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+.PHONY: configure-stageprofile-lto-plugin maybe-configure-stageprofile-lto-plugin\n+maybe-configure-stageprofile-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stageprofile-lto-plugin: configure-stageprofile-lto-plugin\n+configure-stageprofile-lto-plugin:\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGEprofile_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage profile in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEprofile_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+.PHONY: configure-stagefeedback-lto-plugin maybe-configure-stagefeedback-lto-plugin\n+maybe-configure-stagefeedback-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-configure-stagefeedback-lto-plugin: configure-stagefeedback-lto-plugin\n+configure-stagefeedback-lto-plugin:\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/lto-plugin/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS; \\\n+\techo Configuring stage feedback in $(HOST_SUBDIR)/lto-plugin ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/lto-plugin ; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/lto-plugin/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/lto-plugin\"; \\\n+\tlibsrcdir=\"$$s/lto-plugin\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEfeedback_CONFIGURE_FLAGS)\n+@endif lto-plugin-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: all-lto-plugin maybe-all-lto-plugin\n+maybe-all-lto-plugin:\n+@if gcc-bootstrap\n+all-lto-plugin: stage_current\n+@endif gcc-bootstrap\n+@if lto-plugin\n+TARGET-lto-plugin=all\n+maybe-all-lto-plugin: all-lto-plugin\n+all-lto-plugin: configure-lto-plugin\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(TARGET-lto-plugin))\n+@endif lto-plugin\n+\n+\n+\n+.PHONY: all-stage1-lto-plugin maybe-all-stage1-lto-plugin\n+.PHONY: clean-stage1-lto-plugin maybe-clean-stage1-lto-plugin\n+maybe-all-stage1-lto-plugin:\n+maybe-clean-stage1-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stage1-lto-plugin: all-stage1-lto-plugin\n+all-stage1: all-stage1-lto-plugin\n+TARGET-stage1-lto-plugin = $(TARGET-lto-plugin)\n+all-stage1-lto-plugin: configure-stage1-lto-plugin\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE1_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE1_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n+\t\t$(TARGET-stage1-lto-plugin)\n+\n+maybe-clean-stage1-lto-plugin: clean-stage1-lto-plugin\n+clean-stage1: clean-stage1-lto-plugin\n+clean-stage1-lto-plugin:\n+\t@if [ $(current_stage) = stage1 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage1-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage1-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+.PHONY: all-stage2-lto-plugin maybe-all-stage2-lto-plugin\n+.PHONY: clean-stage2-lto-plugin maybe-clean-stage2-lto-plugin\n+maybe-all-stage2-lto-plugin:\n+maybe-clean-stage2-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stage2-lto-plugin: all-stage2-lto-plugin\n+all-stage2: all-stage2-lto-plugin\n+TARGET-stage2-lto-plugin = $(TARGET-lto-plugin)\n+all-stage2-lto-plugin: configure-stage2-lto-plugin\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE2_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n+\t\t$(TARGET-stage2-lto-plugin)\n+\n+maybe-clean-stage2-lto-plugin: clean-stage2-lto-plugin\n+clean-stage2: clean-stage2-lto-plugin\n+clean-stage2-lto-plugin:\n+\t@if [ $(current_stage) = stage2 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage2-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage2-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+.PHONY: all-stage3-lto-plugin maybe-all-stage3-lto-plugin\n+.PHONY: clean-stage3-lto-plugin maybe-clean-stage3-lto-plugin\n+maybe-all-stage3-lto-plugin:\n+maybe-clean-stage3-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stage3-lto-plugin: all-stage3-lto-plugin\n+all-stage3: all-stage3-lto-plugin\n+TARGET-stage3-lto-plugin = $(TARGET-lto-plugin)\n+all-stage3-lto-plugin: configure-stage3-lto-plugin\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE3_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n+\t\t$(TARGET-stage3-lto-plugin)\n+\n+maybe-clean-stage3-lto-plugin: clean-stage3-lto-plugin\n+clean-stage3: clean-stage3-lto-plugin\n+clean-stage3-lto-plugin:\n+\t@if [ $(current_stage) = stage3 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage3-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage3-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+.PHONY: all-stage4-lto-plugin maybe-all-stage4-lto-plugin\n+.PHONY: clean-stage4-lto-plugin maybe-clean-stage4-lto-plugin\n+maybe-all-stage4-lto-plugin:\n+maybe-clean-stage4-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stage4-lto-plugin: all-stage4-lto-plugin\n+all-stage4: all-stage4-lto-plugin\n+TARGET-stage4-lto-plugin = $(TARGET-lto-plugin)\n+all-stage4-lto-plugin: configure-stage4-lto-plugin\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE4_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n+\t\t$(TARGET-stage4-lto-plugin)\n+\n+maybe-clean-stage4-lto-plugin: clean-stage4-lto-plugin\n+clean-stage4: clean-stage4-lto-plugin\n+clean-stage4-lto-plugin:\n+\t@if [ $(current_stage) = stage4 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage4-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage4-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+.PHONY: all-stageprofile-lto-plugin maybe-all-stageprofile-lto-plugin\n+.PHONY: clean-stageprofile-lto-plugin maybe-clean-stageprofile-lto-plugin\n+maybe-all-stageprofile-lto-plugin:\n+maybe-clean-stageprofile-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stageprofile-lto-plugin: all-stageprofile-lto-plugin\n+all-stageprofile: all-stageprofile-lto-plugin\n+TARGET-stageprofile-lto-plugin = $(TARGET-lto-plugin)\n+all-stageprofile-lto-plugin: configure-stageprofile-lto-plugin\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n+\t\t$(TARGET-stageprofile-lto-plugin)\n+\n+maybe-clean-stageprofile-lto-plugin: clean-stageprofile-lto-plugin\n+clean-stageprofile: clean-stageprofile-lto-plugin\n+clean-stageprofile-lto-plugin:\n+\t@if [ $(current_stage) = stageprofile ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stageprofile-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stageprofile-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+.PHONY: all-stagefeedback-lto-plugin maybe-all-stagefeedback-lto-plugin\n+.PHONY: clean-stagefeedback-lto-plugin maybe-clean-stagefeedback-lto-plugin\n+maybe-all-stagefeedback-lto-plugin:\n+maybe-clean-stagefeedback-lto-plugin:\n+@if lto-plugin-bootstrap\n+maybe-all-stagefeedback-lto-plugin: all-stagefeedback-lto-plugin\n+all-stagefeedback: all-stagefeedback-lto-plugin\n+TARGET-stagefeedback-lto-plugin = $(TARGET-lto-plugin)\n+all-stagefeedback-lto-plugin: configure-stagefeedback-lto-plugin\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n+\t\t$(TARGET-stagefeedback-lto-plugin)\n+\n+maybe-clean-stagefeedback-lto-plugin: clean-stagefeedback-lto-plugin\n+clean-stagefeedback: clean-stagefeedback-lto-plugin\n+clean-stagefeedback-lto-plugin:\n+\t@if [ $(current_stage) = stagefeedback ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/lto-plugin/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stagefeedback-lto-plugin/Makefile ] || exit 0; \\\n+\t  $(MAKE) stagefeedback-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/lto-plugin && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif lto-plugin-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: check-lto-plugin maybe-check-lto-plugin\n+maybe-check-lto-plugin:\n+@if lto-plugin\n+maybe-check-lto-plugin: check-lto-plugin\n+\n+check-lto-plugin:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS)  check)\n+\n+@endif lto-plugin\n+\n+.PHONY: install-lto-plugin maybe-install-lto-plugin\n+maybe-install-lto-plugin:\n+@if lto-plugin\n+maybe-install-lto-plugin: install-lto-plugin\n+\n+install-lto-plugin: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS)  install)\n+\n+@endif lto-plugin\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-lto-plugin info-lto-plugin\n+maybe-info-lto-plugin:\n+@if lto-plugin\n+maybe-info-lto-plugin: info-lto-plugin\n+\n+info-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing info in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          info) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-dvi-lto-plugin dvi-lto-plugin\n+maybe-dvi-lto-plugin:\n+@if lto-plugin\n+maybe-dvi-lto-plugin: dvi-lto-plugin\n+\n+dvi-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing dvi in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          dvi) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-pdf-lto-plugin pdf-lto-plugin\n+maybe-pdf-lto-plugin:\n+@if lto-plugin\n+maybe-pdf-lto-plugin: pdf-lto-plugin\n+\n+pdf-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing pdf in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          pdf) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-html-lto-plugin html-lto-plugin\n+maybe-html-lto-plugin:\n+@if lto-plugin\n+maybe-html-lto-plugin: html-lto-plugin\n+\n+html-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing html in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          html) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-TAGS-lto-plugin TAGS-lto-plugin\n+maybe-TAGS-lto-plugin:\n+@if lto-plugin\n+maybe-TAGS-lto-plugin: TAGS-lto-plugin\n+\n+TAGS-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing TAGS in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          TAGS) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-install-info-lto-plugin install-info-lto-plugin\n+maybe-install-info-lto-plugin:\n+@if lto-plugin\n+maybe-install-info-lto-plugin: install-info-lto-plugin\n+\n+install-info-lto-plugin: \\\n+    configure-lto-plugin \\\n+    info-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-info in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-info) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-install-pdf-lto-plugin install-pdf-lto-plugin\n+maybe-install-pdf-lto-plugin:\n+@if lto-plugin\n+maybe-install-pdf-lto-plugin: install-pdf-lto-plugin\n+\n+install-pdf-lto-plugin: \\\n+    configure-lto-plugin \\\n+    pdf-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-pdf in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-pdf) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-install-html-lto-plugin install-html-lto-plugin\n+maybe-install-html-lto-plugin:\n+@if lto-plugin\n+maybe-install-html-lto-plugin: install-html-lto-plugin\n+\n+install-html-lto-plugin: \\\n+    configure-lto-plugin \\\n+    html-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-html in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-html) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-installcheck-lto-plugin installcheck-lto-plugin\n+maybe-installcheck-lto-plugin:\n+@if lto-plugin\n+maybe-installcheck-lto-plugin: installcheck-lto-plugin\n+\n+installcheck-lto-plugin: \\\n+    configure-lto-plugin \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing installcheck in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          installcheck) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-mostlyclean-lto-plugin mostlyclean-lto-plugin\n+maybe-mostlyclean-lto-plugin:\n+@if lto-plugin\n+maybe-mostlyclean-lto-plugin: mostlyclean-lto-plugin\n+\n+mostlyclean-lto-plugin: \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing mostlyclean in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          mostlyclean) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-clean-lto-plugin clean-lto-plugin\n+maybe-clean-lto-plugin:\n+@if lto-plugin\n+maybe-clean-lto-plugin: clean-lto-plugin\n+\n+clean-lto-plugin: \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing clean in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          clean) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-distclean-lto-plugin distclean-lto-plugin\n+maybe-distclean-lto-plugin:\n+@if lto-plugin\n+maybe-distclean-lto-plugin: distclean-lto-plugin\n+\n+distclean-lto-plugin: \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing distclean in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          distclean) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+.PHONY: maybe-maintainer-clean-lto-plugin maintainer-clean-lto-plugin\n+maybe-maintainer-clean-lto-plugin:\n+@if lto-plugin\n+maybe-maintainer-clean-lto-plugin: maintainer-clean-lto-plugin\n+\n+maintainer-clean-lto-plugin: \n+\t@[ -f ./lto-plugin/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing maintainer-clean in lto-plugin\" ; \\\n+\t(cd $(HOST_SUBDIR)/lto-plugin && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif lto-plugin\n+\n+\n+\n # ---------------------------------------\n # Modules which run on the target machine\n # ---------------------------------------\n@@ -53466,6 +54364,11 @@ stage1-start::\n \t  mkdir stage1-zlib; \\\n \tmv stage1-zlib zlib \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stage1-lto-plugin ] || \\\n+\t  mkdir stage1-lto-plugin; \\\n+\tmv stage1-lto-plugin lto-plugin \n+@endif lto-plugin\n \t@[ -d stage1-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stage1-$(TARGET_SUBDIR); \\\n \tmv stage1-$(TARGET_SUBDIR) $(TARGET_SUBDIR) \n@@ -53556,6 +54459,11 @@ stage1-end::\n \t  cd $(HOST_SUBDIR); mv zlib stage1-zlib  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stage1-lto-plugin  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR)  ; \\\n \tfi\n@@ -53706,6 +54614,12 @@ stage2-start::\n \tmv stage2-zlib zlib  ; \\\n \tmv stage1-zlib prev-zlib || test -f stage1-lean \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stage2-lto-plugin ] || \\\n+\t  mkdir stage2-lto-plugin; \\\n+\tmv stage2-lto-plugin lto-plugin  ; \\\n+\tmv stage1-lto-plugin prev-lto-plugin || test -f stage1-lean \n+@endif lto-plugin\n \t@[ -d stage2-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stage2-$(TARGET_SUBDIR); \\\n \tmv stage2-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \\\n@@ -53814,6 +54728,12 @@ stage2-end::\n \t  mv prev-zlib stage1-zlib ; :  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stage2-lto-plugin ; \\\n+\t  mv prev-lto-plugin stage1-lto-plugin ; :  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stage2-$(TARGET_SUBDIR)  ; \\\n \t  mv prev-$(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR) ; :  ; \\\n@@ -53988,6 +54908,12 @@ stage3-start::\n \tmv stage3-zlib zlib  ; \\\n \tmv stage2-zlib prev-zlib || test -f stage2-lean \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stage3-lto-plugin ] || \\\n+\t  mkdir stage3-lto-plugin; \\\n+\tmv stage3-lto-plugin lto-plugin  ; \\\n+\tmv stage2-lto-plugin prev-lto-plugin || test -f stage2-lean \n+@endif lto-plugin\n \t@[ -d stage3-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stage3-$(TARGET_SUBDIR); \\\n \tmv stage3-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \\\n@@ -54096,6 +55022,12 @@ stage3-end::\n \t  mv prev-zlib stage2-zlib ; :  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stage3-lto-plugin ; \\\n+\t  mv prev-lto-plugin stage2-lto-plugin ; :  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stage3-$(TARGET_SUBDIR)  ; \\\n \t  mv prev-$(TARGET_SUBDIR) stage2-$(TARGET_SUBDIR) ; :  ; \\\n@@ -54326,6 +55258,12 @@ stage4-start::\n \tmv stage4-zlib zlib  ; \\\n \tmv stage3-zlib prev-zlib || test -f stage3-lean \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stage4-lto-plugin ] || \\\n+\t  mkdir stage4-lto-plugin; \\\n+\tmv stage4-lto-plugin lto-plugin  ; \\\n+\tmv stage3-lto-plugin prev-lto-plugin || test -f stage3-lean \n+@endif lto-plugin\n \t@[ -d stage4-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stage4-$(TARGET_SUBDIR); \\\n \tmv stage4-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \\\n@@ -54434,6 +55372,12 @@ stage4-end::\n \t  mv prev-zlib stage3-zlib ; :  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stage4-lto-plugin ; \\\n+\t  mv prev-lto-plugin stage3-lto-plugin ; :  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stage4-$(TARGET_SUBDIR)  ; \\\n \t  mv prev-$(TARGET_SUBDIR) stage3-$(TARGET_SUBDIR) ; :  ; \\\n@@ -54652,6 +55596,12 @@ stageprofile-start::\n \tmv stageprofile-zlib zlib  ; \\\n \tmv stage1-zlib prev-zlib || test -f stage1-lean \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stageprofile-lto-plugin ] || \\\n+\t  mkdir stageprofile-lto-plugin; \\\n+\tmv stageprofile-lto-plugin lto-plugin  ; \\\n+\tmv stage1-lto-plugin prev-lto-plugin || test -f stage1-lean \n+@endif lto-plugin\n \t@[ -d stageprofile-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stageprofile-$(TARGET_SUBDIR); \\\n \tmv stageprofile-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \\\n@@ -54760,6 +55710,12 @@ stageprofile-end::\n \t  mv prev-zlib stage1-zlib ; :  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stageprofile-lto-plugin ; \\\n+\t  mv prev-lto-plugin stage1-lto-plugin ; :  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stageprofile-$(TARGET_SUBDIR)  ; \\\n \t  mv prev-$(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR) ; :  ; \\\n@@ -54911,6 +55867,12 @@ stagefeedback-start::\n \tmv stagefeedback-zlib zlib  ; \\\n \tmv stageprofile-zlib prev-zlib || test -f stageprofile-lean \n @endif zlib\n+@if lto-plugin\n+\t@cd $(HOST_SUBDIR); [ -d stagefeedback-lto-plugin ] || \\\n+\t  mkdir stagefeedback-lto-plugin; \\\n+\tmv stagefeedback-lto-plugin lto-plugin  ; \\\n+\tmv stageprofile-lto-plugin prev-lto-plugin || test -f stageprofile-lean \n+@endif lto-plugin\n \t@[ -d stagefeedback-$(TARGET_SUBDIR) ] || \\\n \t  mkdir stagefeedback-$(TARGET_SUBDIR); \\\n \tmv stagefeedback-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \\\n@@ -55019,6 +55981,12 @@ stagefeedback-end::\n \t  mv prev-zlib stageprofile-zlib ; :  ; \\\n \tfi\n @endif zlib\n+@if lto-plugin\n+\t@if test -d $(HOST_SUBDIR)/lto-plugin ; then \\\n+\t  cd $(HOST_SUBDIR); mv lto-plugin stagefeedback-lto-plugin ; \\\n+\t  mv prev-lto-plugin stageprofile-lto-plugin ; :  ; \\\n+\tfi\n+@endif lto-plugin\n \t@if test -d $(TARGET_SUBDIR) ; then \\\n \t  mv $(TARGET_SUBDIR) stagefeedback-$(TARGET_SUBDIR)  ; \\\n \t  mv prev-$(TARGET_SUBDIR) stageprofile-$(TARGET_SUBDIR) ; :  ; \\\n@@ -55422,6 +56390,14 @@ all-stageprofile-libcpp: maybe-all-stageprofile-intl\n all-stagefeedback-libcpp: maybe-all-stagefeedback-intl\n all-fixincludes: maybe-all-libiberty\n all-gnattools: maybe-all-target-libada\n+all-lto-plugin: maybe-all-libiberty\n+\n+all-stage1-lto-plugin: maybe-all-stage1-libiberty\n+all-stage2-lto-plugin: maybe-all-stage2-libiberty\n+all-stage3-lto-plugin: maybe-all-stage3-libiberty\n+all-stage4-lto-plugin: maybe-all-stage4-libiberty\n+all-stageprofile-lto-plugin: maybe-all-stageprofile-libiberty\n+all-stagefeedback-lto-plugin: maybe-all-stagefeedback-libiberty\n configure-mpfr: maybe-all-gmp\n \n configure-stage1-mpfr: maybe-all-stage1-gmp"}, {"sha": "45a58c56a408b667aa4a79df6a0d564b32f61cc6", "filename": "Makefile.tpl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -222,6 +222,8 @@ HOST_EXPORTS = \\\n \tPPLINC=\"$(HOST_PPLINC)\"; export PPLINC; \\\n \tCLOOGLIBS=\"$(HOST_CLOOGLIBS)\"; export CLOOGLIBS; \\\n \tCLOOGINC=\"$(HOST_CLOOGINC)\"; export CLOOGINC; \\\n+\tLIBELFLIBS=\"$(HOST_LIBELFLIBS)\" ; export LIBELFLIBS; \\\n+\tLIBELFINC=\"$(HOST_LIBELFINC)\" ; export LIBELFINC; \\\n @if gcc-bootstrap\n \t$(RPATH_ENVVAR)=`echo \"$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \\\n @endif gcc-bootstrap\n@@ -296,6 +298,10 @@ HOST_PPLINC = @pplinc@\n HOST_CLOOGLIBS = @clooglibs@\n HOST_CLOOGINC = @clooginc@\n \n+# Where to find libelf\n+HOST_LIBELFLIBS = @libelflibs@\n+HOST_LIBELFINC = @libelfinc@\n+\n # ----------------------------------------------\n # Programs producing files for the BUILD machine\n # ----------------------------------------------"}, {"sha": "76084ed5158aee0e0f88c909ad09131a0e9c4d9c", "filename": "configure", "status": "modified", "additions": 878, "deletions": 2, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -553,6 +553,42 @@ PACKAGE_URL=\n \n ac_unique_file=\"move-if-change\"\n enable_option_checking=no\n+# Factoring default headers for most tests.\n+ac_includes_default=\"\\\n+#include <stdio.h>\n+#ifdef HAVE_SYS_TYPES_H\n+# include <sys/types.h>\n+#endif\n+#ifdef HAVE_SYS_STAT_H\n+# include <sys/stat.h>\n+#endif\n+#ifdef STDC_HEADERS\n+# include <stdlib.h>\n+# include <stddef.h>\n+#else\n+# ifdef HAVE_STDLIB_H\n+#  include <stdlib.h>\n+# endif\n+#endif\n+#ifdef HAVE_STRING_H\n+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H\n+#  include <memory.h>\n+# endif\n+# include <string.h>\n+#endif\n+#ifdef HAVE_STRINGS_H\n+# include <strings.h>\n+#endif\n+#ifdef HAVE_INTTYPES_H\n+# include <inttypes.h>\n+#endif\n+#ifdef HAVE_STDINT_H\n+# include <stdint.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+# include <unistd.h>\n+#endif\"\n+\n ac_subst_vars='LTLIBOBJS\n LIBOBJS\n compare_exclusions\n@@ -637,6 +673,12 @@ CFLAGS_FOR_TARGET\n DEBUG_PREFIX_CFLAGS_FOR_TARGET\n SYSROOT_CFLAGS_FOR_TARGET\n stage1_languages\n+extra_host_libiberty_configure_flags\n+libelfinc\n+libelflibs\n+EGREP\n+GREP\n+CPP\n clooginc\n clooglibs\n pplinc\n@@ -764,6 +806,10 @@ with_cloog\n with_cloog_include\n with_cloog_lib\n enable_cloog_version_check\n+enable_lto\n+with_libelf\n+with_libelf_include\n+with_libelf_lib\n enable_stage1_languages\n enable_objc_gc\n with_build_sysroot\n@@ -787,6 +833,7 @@ CPPFLAGS\n CXX\n CXXFLAGS\n CCC\n+CPP\n AR\n AS\n DLLTOOL\n@@ -1441,6 +1488,7 @@ Optional Features:\n   --enable-build-with-cxx build with C++ compiler instead of C compiler\n   --disable-ppl-version-check    disable check for PPL version\n   --disable-cloog-version-check  disable check for CLooG version\n+  --enable-lto            enable link time optimization support\n   --enable-stage1-languages[=all]   choose additional languages to build during\n                           stage1.  Mostly useful for compiler development.\n   --enable-objc-gc        enable use of Boehm's garbage collector with the\n@@ -1495,6 +1543,11 @@ Optional Packages:\n                           plus --with-cloog-lib=PATH/lib\n   --with-cloog-include=PATH Specify directory for installed CLooG include files\n   --with-cloog-lib=PATH   Specify the directory for the installed CLooG library\n+  --with-libelf=PATH       Specify prefix directory for the installed libelf package\n+                          Equivalent to --with-libelf-include=PATH/include\n+                          plus --with-libelf-lib=PATH/lib\n+  --with-libelf-include=PATH Specify directory for installed libelf include files\n+  --with-libelf-lib=PATH   Specify the directory for the installed libelf library\n   --with-build-sysroot=SYSROOT\n                           use sysroot as the system root during the build\n   --with-debug-prefix-map='A=B C=D ...'\n@@ -1514,6 +1567,7 @@ Some influential environment variables:\n               you have headers in a nonstandard directory <include dir>\n   CXX         C++ compiler command\n   CXXFLAGS    C++ compiler flags\n+  CPP         C preprocessor\n   AR          AR for the host\n   AS          AS for the host\n   DLLTOOL     DLLTOOL for the host\n@@ -1760,6 +1814,203 @@ fi\n   return $ac_retval\n \n } # ac_fn_c_try_link\n+\n+# ac_fn_c_try_cpp LINENO\n+# ----------------------\n+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.\n+ac_fn_c_try_cpp ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { { ac_try=\"$ac_cpp conftest.$ac_ext\"\n+case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_cpp conftest.$ac_ext\") 2>conftest.err\n+  ac_status=$?\n+  if test -s conftest.err; then\n+    grep -v '^ *+' conftest.err >conftest.er1\n+    cat conftest.er1 >&5\n+    mv -f conftest.er1 conftest.err\n+  fi\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; } >/dev/null && {\n+\t test -z \"$ac_c_preproc_warn_flag$ac_c_werror_flag\" ||\n+\t test ! -s conftest.err\n+       }; then :\n+  ac_retval=0\n+else\n+  $as_echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+    ac_retval=1\n+fi\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+  return $ac_retval\n+\n+} # ac_fn_c_try_cpp\n+\n+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES\n+# -------------------------------------------------------\n+# Tests whether HEADER exists, giving a warning if it cannot be compiled using\n+# the include files in INCLUDES and setting the cache variable VAR\n+# accordingly.\n+ac_fn_c_check_header_mongrel ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+else\n+  # Is the header compilable?\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 usability\" >&5\n+$as_echo_n \"checking $2 usability... \" >&6; }\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+#include <$2>\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_header_compiler=yes\n+else\n+  ac_header_compiler=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler\" >&5\n+$as_echo \"$ac_header_compiler\" >&6; }\n+\n+# Is the header present?\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 presence\" >&5\n+$as_echo_n \"checking $2 presence... \" >&6; }\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <$2>\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+  ac_header_preproc=yes\n+else\n+  ac_header_preproc=no\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc\" >&5\n+$as_echo \"$ac_header_preproc\" >&6; }\n+\n+# So?  What about this header?\n+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((\n+  yes:no: )\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&5\n+$as_echo \"$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n+$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n+    ;;\n+  no:yes:* )\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled\" >&5\n+$as_echo \"$as_me: WARNING: $2: present but cannot be compiled\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?\" >&5\n+$as_echo \"$as_me: WARNING: $2:     check for missing prerequisite headers?\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation\" >&5\n+$as_echo \"$as_me: WARNING: $2: see the Autoconf documentation\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&5\n+$as_echo \"$as_me: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&2;}\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n+$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n+    ;;\n+esac\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  eval \"$3=\\$ac_header_compiler\"\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+fi\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_c_check_header_mongrel\n+\n+# ac_fn_c_try_run LINENO\n+# ----------------------\n+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes\n+# that executables *can* be run.\n+ac_fn_c_try_run ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { { ac_try=\"$ac_link\"\n+case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_link\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n+  { { case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_try\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }; then :\n+  ac_retval=0\n+else\n+  $as_echo \"$as_me: program exited with status $ac_status\" >&5\n+       $as_echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+       ac_retval=$ac_status\n+fi\n+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+  return $ac_retval\n+\n+} # ac_fn_c_try_run\n+\n+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES\n+# -------------------------------------------------------\n+# Tests whether HEADER exists and can be compiled using the include files in\n+# INCLUDES, setting the cache variable VAR accordingly.\n+ac_fn_c_check_header_compile ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+#include <$2>\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$3=yes\"\n+else\n+  eval \"$3=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_c_check_header_compile\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -2768,6 +3019,13 @@ if test x$with_gnu_as = xno ; then\n   noconfigdirs=\"$noconfigdirs gas\"\n fi\n \n+use_included_zlib=\n+# Make sure we don't let ZLIB be added if we didn't want it.\n+if test x$with_system_zlib = xyes ; then\n+  use_included_zlib=no\n+  noconfigdirs=\"$noconfigdirs zlib\"\n+fi\n+\n # some tools are so dependent upon X11 that if we're not building with X,\n # it's not even worth trying to configure, much less build, that tool.\n \n@@ -5667,6 +5925,602 @@ fi\n \n \n \n+# Check for LTO support.\n+# Check whether --enable-lto was given.\n+if test \"${enable_lto+set}\" = set; then :\n+  enableval=$enable_lto; enable_lto=$enableval\n+else\n+  enable_lto=yes; default_enable_lto=yes\n+fi\n+\n+\n+if test x\"$enable_lto\" = x\"yes\" ; then\n+  # Make sure that libelf.h and gelf.h are available.\n+\n+# Check whether --with-libelf was given.\n+if test \"${with_libelf+set}\" = set; then :\n+  withval=$with_libelf;\n+fi\n+\n+\n+\n+# Check whether --with-libelf_include was given.\n+if test \"${with_libelf_include+set}\" = set; then :\n+  withval=$with_libelf_include;\n+fi\n+\n+\n+\n+# Check whether --with-libelf_lib was given.\n+if test \"${with_libelf_lib+set}\" = set; then :\n+  withval=$with_libelf_lib;\n+fi\n+\n+\n+  case $with_libelf in\n+    \"\")\n+      libelflibs=\"-lelf\"\n+      libelfinc=\"-I/usr/include/libelf\"\n+      ;;\n+    *)\n+      libelflibs=\"-L$with_libelf/lib -lelf\"\n+      libelfinc=\"-I$with_libelf/include -I$with_libelf/include/libelf\"\n+      LIBS=\"$libelflibs $LIBS\"\n+      ;;\n+  esac\n+\n+  if test \"x$with_libelf_include\" != x; then\n+    libelfinc=\"-I$with_libelf_include\"\n+  fi\n+\n+  if test \"x$with_libelf_lib\" != x; then\n+    libelflibs=\"-L$with_libelf_lib -lelf\"\n+    LIBS=\"$libelflibs $LIBS\"\n+  fi\n+\n+  if test \"x$with_libelf$with_libelf_include$with_libelf_lib\" = x \\\n+     && test -d ${srcdir}/libelf; then\n+    libelflibs='-L$$r/$(HOST_SUBDIR)/libelf/.libs -L$$r/$(HOST_SUBDIR)/libelf/_libs -lelf '\n+    libelfinc='-I$$r/$(HOST_SUBDIR)/libelf/include -I$$s/libelf/include'\n+    LIBS=\"$libelflibs $LIBS\"\n+  fi\n+\n+  saved_CFLAGS=\"$CFLAGS\"\n+  saved_CPPFLAGS=\"$CPPFLAGS\"\n+  saved_LIBS=\"$LIBS\"\n+\n+  CFLAGS=\"$CFLAGS $libelfinc\"\n+  CPPFLAGS=\"$CPPFLAGS $libelfinc\"\n+  LIBS=\"$LIBS $libelflibs\"\n+\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor\" >&5\n+$as_echo_n \"checking how to run the C preprocessor... \" >&6; }\n+# On Suns, sometimes $CPP names a directory.\n+if test -n \"$CPP\" && test -d \"$CPP\"; then\n+  CPP=\n+fi\n+if test -z \"$CPP\"; then\n+  if test \"${ac_cv_prog_CPP+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      # Double quotes because CPP needs to be expanded\n+    for CPP in \"$CC -E\" \"$CC -E -traditional-cpp\" \"/lib/cpp\"\n+    do\n+      ac_preproc_ok=false\n+for ac_c_preproc_warn_flag in '' yes\n+do\n+  # Use a header file that comes with gcc, so configuring glibc\n+  # with a fresh cross-compiler works.\n+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n+  # <limits.h> exists even on freestanding compilers.\n+  # On the NeXT, cc -E runs the code through the compiler's parser,\n+  # not just through cpp. \"Syntax error\" is here to catch this case.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#ifdef __STDC__\n+# include <limits.h>\n+#else\n+# include <assert.h>\n+#endif\n+\t\t     Syntax error\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+\n+else\n+  # Broken: fails on valid input.\n+continue\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+\n+  # OK, works on sane cases.  Now check whether nonexistent headers\n+  # can be detected and how.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <ac_nonexistent.h>\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+  # Broken: success on invalid input.\n+continue\n+else\n+  # Passes both tests.\n+ac_preproc_ok=:\n+break\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+\n+done\n+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.\n+rm -f conftest.err conftest.$ac_ext\n+if $ac_preproc_ok; then :\n+  break\n+fi\n+\n+    done\n+    ac_cv_prog_CPP=$CPP\n+\n+fi\n+  CPP=$ac_cv_prog_CPP\n+else\n+  ac_cv_prog_CPP=$CPP\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CPP\" >&5\n+$as_echo \"$CPP\" >&6; }\n+ac_preproc_ok=false\n+for ac_c_preproc_warn_flag in '' yes\n+do\n+  # Use a header file that comes with gcc, so configuring glibc\n+  # with a fresh cross-compiler works.\n+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n+  # <limits.h> exists even on freestanding compilers.\n+  # On the NeXT, cc -E runs the code through the compiler's parser,\n+  # not just through cpp. \"Syntax error\" is here to catch this case.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#ifdef __STDC__\n+# include <limits.h>\n+#else\n+# include <assert.h>\n+#endif\n+\t\t     Syntax error\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+\n+else\n+  # Broken: fails on valid input.\n+continue\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+\n+  # OK, works on sane cases.  Now check whether nonexistent headers\n+  # can be detected and how.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <ac_nonexistent.h>\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+  # Broken: success on invalid input.\n+continue\n+else\n+  # Passes both tests.\n+ac_preproc_ok=:\n+break\n+fi\n+rm -f conftest.err conftest.$ac_ext\n+\n+done\n+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.\n+rm -f conftest.err conftest.$ac_ext\n+if $ac_preproc_ok; then :\n+\n+else\n+  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error \"C preprocessor \\\"$CPP\\\" fails sanity check\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }\n+fi\n+\n+ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e\" >&5\n+$as_echo_n \"checking for grep that handles long lines and -e... \" >&6; }\n+if test \"${ac_cv_path_GREP+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -z \"$GREP\"; then\n+  ac_path_GREP_found=false\n+  # Loop through the user's path and test for each of PROGNAME-LIST\n+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_prog in grep ggrep; do\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+      ac_path_GREP=\"$as_dir/$ac_prog$ac_exec_ext\"\n+      { test -f \"$ac_path_GREP\" && $as_test_x \"$ac_path_GREP\"; } || continue\n+# Check for GNU ac_path_GREP and select it if it is found.\n+  # Check for GNU $ac_path_GREP\n+case `\"$ac_path_GREP\" --version 2>&1` in\n+*GNU*)\n+  ac_cv_path_GREP=\"$ac_path_GREP\" ac_path_GREP_found=:;;\n+*)\n+  ac_count=0\n+  $as_echo_n 0123456789 >\"conftest.in\"\n+  while :\n+  do\n+    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n+    mv \"conftest.tmp\" \"conftest.in\"\n+    cp \"conftest.in\" \"conftest.nl\"\n+    $as_echo 'GREP' >> \"conftest.nl\"\n+    \"$ac_path_GREP\" -e 'GREP$' -e '-(cannot match)-' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n+    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n+    as_fn_arith $ac_count + 1 && ac_count=$as_val\n+    if test $ac_count -gt ${ac_path_GREP_max-0}; then\n+      # Best one so far, save it but keep looking for a better one\n+      ac_cv_path_GREP=\"$ac_path_GREP\"\n+      ac_path_GREP_max=$ac_count\n+    fi\n+    # 10*(2^10) chars as input seems more than enough\n+    test $ac_count -gt 10 && break\n+  done\n+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\n+esac\n+\n+      $ac_path_GREP_found && break 3\n+    done\n+  done\n+  done\n+IFS=$as_save_IFS\n+  if test -z \"$ac_cv_path_GREP\"; then\n+    as_fn_error \"no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n+  fi\n+else\n+  ac_cv_path_GREP=$GREP\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP\" >&5\n+$as_echo \"$ac_cv_path_GREP\" >&6; }\n+ GREP=\"$ac_cv_path_GREP\"\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for egrep\" >&5\n+$as_echo_n \"checking for egrep... \" >&6; }\n+if test \"${ac_cv_path_EGREP+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1\n+   then ac_cv_path_EGREP=\"$GREP -E\"\n+   else\n+     if test -z \"$EGREP\"; then\n+  ac_path_EGREP_found=false\n+  # Loop through the user's path and test for each of PROGNAME-LIST\n+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_prog in egrep; do\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+      ac_path_EGREP=\"$as_dir/$ac_prog$ac_exec_ext\"\n+      { test -f \"$ac_path_EGREP\" && $as_test_x \"$ac_path_EGREP\"; } || continue\n+# Check for GNU ac_path_EGREP and select it if it is found.\n+  # Check for GNU $ac_path_EGREP\n+case `\"$ac_path_EGREP\" --version 2>&1` in\n+*GNU*)\n+  ac_cv_path_EGREP=\"$ac_path_EGREP\" ac_path_EGREP_found=:;;\n+*)\n+  ac_count=0\n+  $as_echo_n 0123456789 >\"conftest.in\"\n+  while :\n+  do\n+    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n+    mv \"conftest.tmp\" \"conftest.in\"\n+    cp \"conftest.in\" \"conftest.nl\"\n+    $as_echo 'EGREP' >> \"conftest.nl\"\n+    \"$ac_path_EGREP\" 'EGREP$' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n+    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n+    as_fn_arith $ac_count + 1 && ac_count=$as_val\n+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then\n+      # Best one so far, save it but keep looking for a better one\n+      ac_cv_path_EGREP=\"$ac_path_EGREP\"\n+      ac_path_EGREP_max=$ac_count\n+    fi\n+    # 10*(2^10) chars as input seems more than enough\n+    test $ac_count -gt 10 && break\n+  done\n+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\n+esac\n+\n+      $ac_path_EGREP_found && break 3\n+    done\n+  done\n+  done\n+IFS=$as_save_IFS\n+  if test -z \"$ac_cv_path_EGREP\"; then\n+    as_fn_error \"no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n+  fi\n+else\n+  ac_cv_path_EGREP=$EGREP\n+fi\n+\n+   fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP\" >&5\n+$as_echo \"$ac_cv_path_EGREP\" >&6; }\n+ EGREP=\"$ac_cv_path_EGREP\"\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for ANSI C header files\" >&5\n+$as_echo_n \"checking for ANSI C header files... \" >&6; }\n+if test \"${ac_cv_header_stdc+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <float.h>\n+\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_cv_header_stdc=yes\n+else\n+  ac_cv_header_stdc=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n+if test $ac_cv_header_stdc = yes; then\n+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <string.h>\n+\n+_ACEOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  $EGREP \"memchr\" >/dev/null 2>&1; then :\n+\n+else\n+  ac_cv_header_stdc=no\n+fi\n+rm -f conftest*\n+\n+fi\n+\n+if test $ac_cv_header_stdc = yes; then\n+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <stdlib.h>\n+\n+_ACEOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  $EGREP \"free\" >/dev/null 2>&1; then :\n+\n+else\n+  ac_cv_header_stdc=no\n+fi\n+rm -f conftest*\n+\n+fi\n+\n+if test $ac_cv_header_stdc = yes; then\n+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.\n+  if test \"$cross_compiling\" = yes; then :\n+  :\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <ctype.h>\n+#include <stdlib.h>\n+#if ((' ' & 0x0FF) == 0x020)\n+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))\n+#else\n+# define ISLOWER(c) \\\n+\t\t   (('a' <= (c) && (c) <= 'i') \\\n+\t\t     || ('j' <= (c) && (c) <= 'r') \\\n+\t\t     || ('s' <= (c) && (c) <= 'z'))\n+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))\n+#endif\n+\n+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 256; i++)\n+    if (XOR (islower (i), ISLOWER (i))\n+\t|| toupper (i) != TOUPPER (i))\n+      return 2;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+\n+else\n+  ac_cv_header_stdc=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc\" >&5\n+$as_echo \"$ac_cv_header_stdc\" >&6; }\n+if test $ac_cv_header_stdc = yes; then\n+\n+$as_echo \"#define STDC_HEADERS 1\" >>confdefs.h\n+\n+fi\n+\n+# On IRIX 5.3, sys/types and inttypes.h are conflicting.\n+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \\\n+\t\t  inttypes.h stdint.h unistd.h\n+do :\n+  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n+ac_fn_c_check_header_compile \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\n+\"\n+eval as_val=\\$$as_ac_Header\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n+for ac_header in libelf.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"libelf.h\" \"ac_cv_header_libelf_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_libelf_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LIBELF_H 1\n+_ACEOF\n+ have_libelf_h=yes\n+fi\n+\n+done\n+\n+  for ac_header in gelf.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"gelf.h\" \"ac_cv_header_gelf_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_gelf_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_GELF_H 1\n+_ACEOF\n+ have_gelf_h=yes\n+fi\n+\n+done\n+\n+\n+  for ac_header in libelf/libelf.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"libelf/libelf.h\" \"ac_cv_header_libelf_libelf_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_libelf_libelf_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LIBELF_LIBELF_H 1\n+_ACEOF\n+ have_libelf_libelf_h=yes\n+fi\n+\n+done\n+\n+  for ac_header in libelf/gelf.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"libelf/gelf.h\" \"ac_cv_header_libelf_gelf_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_libelf_gelf_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LIBELF_GELF_H 1\n+_ACEOF\n+ have_libelf_gelf_h=yes\n+fi\n+\n+done\n+\n+\n+  # If we couldn't find libelf.h and the user forced it, emit an error.\n+  if test x\"$have_libelf_h\" != x\"yes\" \\\n+     && test x\"$have_libelf_libelf_h\" != x\"yes\" ; then\n+    if test x\"$default_enable_lto\" != x\"yes\" ; then\n+      as_fn_error \"LTO support requires libelf.h or libelf/libelf.h.\" \"$LINENO\" 5\n+    else\n+      enable_lto=no\n+      libelflibs=\n+      libelfinc=\n+    fi\n+  fi\n+\n+  # If we couldn't find gelf.h and the user forced it, emit an error.\n+  if test x\"$have_gelf_h\" != x\"yes\" \\\n+     && test x\"$have_libelf_gelf_h\" != x\"yes\" ; then\n+    if test x\"$default_enable_lto\" != x\"yes\" ; then\n+      as_fn_error \"LTO support requires gelf.h or libelf/gelf.h.\" \"$LINENO\" 5\n+    else\n+      enable_lto=no\n+      libelflibs=\n+      libelfinc=\n+    fi\n+  fi\n+\n+  # Check that the detected libelf has the functions we need.  We cannot\n+  # rely on just detecting the headers since they do not include\n+  # versioning information.  Add functions, if needed.\n+  if test x\"$enable_lto\" = x\"yes\" ; then\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for the correct version of libelf\" >&5\n+$as_echo_n \"checking for the correct version of libelf... \" >&6; }\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <libelf.h>\n+int\n+main ()\n+{\n+\n+      elf_errmsg (0);\n+      elf_getscn (0, 0);\n+      elf_nextscn (0, 0);\n+      elf_strptr (0, 0, 0);\n+      elf_getident (0, 0);\n+      elf_getshdrstrndx (0, 0);\n+      elf_begin (0, 0, 0);\n+      elf_ndxscn (0);\n+      elf_end (0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; };\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }; enable_lto=no; libelflibs= ; libelfinc=\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+\n+    # If we couldn't enable LTO and the user forced it, emit an error.\n+    if test x\"$enable_lto\" = x\"no\" \\\n+       && test x\"$default_enable_lto\" != x\"yes\" ; then\n+      as_fn_error \"To enable LTO, GCC requires libelf v0.8.12+.\n+Try the --with-libelf, --with-libelf-include and --with-libelf-lib options\n+to specify its location.\" \"$LINENO\" 5\n+    fi\n+  fi\n+\n+  CFLAGS=\"$saved_CFLAGS\"\n+  CPPFLAGS=\"$saved_CPPFLAGS\"\n+  LIBS=\"$saved_LIBS\"\n+\n+  # Flags needed for libelf.\n+\n+\n+fi\n+\n \n # By default, C is the only stage 1 language.\n stage1_languages=,c,\n@@ -5735,6 +6589,18 @@ if test -d ${srcdir}/gcc; then\n   done\n \n   new_enable_languages=,c,\n+\n+  # If LTO is enabled, add the LTO front end.\n+  extra_host_libiberty_configure_flags=\n+  if test \"$enable_lto\" = \"yes\" ; then\n+    new_enable_languages=\"${new_enable_languages}lto,\"\n+    if test \"${ENABLE_GOLD}\" = \"yes\" ; then\n+      configdirs=\"$configdirs lto-plugin\"\n+      extra_host_libiberty_configure_flags=--enable-shared\n+    fi\n+  fi\n+\n+\n   missing_languages=`echo \",$enable_languages,\" | sed -e s/,all,/,/ -e s/,c,/,/ `\n   potential_languages=,c,\n \n@@ -6197,7 +7063,7 @@ if test x\"${with_libs}\" != x && test x\"${with_libs}\" != xno ; then\n   fi\n fi\n \n-# Set with_gnu_as and with_gnu_ld as appropriate.\n+# Set with_gnu_as, with_gnu_ld, and with_system_zlib as appropriate.\n #\n # This is done by determining whether or not the appropriate directory\n # is available, and by checking whether or not specific configurations\n@@ -6208,7 +7074,9 @@ fi\n #\n # If the default for a toolchain is to use GNU as and ld, and you don't\n # want to do that, then you should use the --without-gnu-as and\n-# --without-gnu-ld options for the configure script.\n+# --without-gnu-ld options for the configure script.  Similarly, if\n+# the default is to use the included zlib and you don't want to do that,\n+# you should use the --with-system-zlib option for the configure script.\n \n if test x${use_gnu_as} = x &&\n    echo \" ${configdirs} \" | grep \" gas \" > /dev/null 2>&1 ; then\n@@ -6222,6 +7090,14 @@ if test x${use_gnu_ld} = x &&\n   extra_host_args=\"$extra_host_args --with-gnu-ld\"\n fi\n \n+if test x${use_included_zlib} = x &&\n+   echo \" ${configdirs} \" | grep \" zlib \" > /dev/null 2>&1 ; then\n+  :\n+else\n+  with_system_zlib=yes\n+  extra_host_args=\"$extra_host_args --with-system-zlib\"\n+fi\n+\n # If using newlib, add --with-newlib to the extra_host_args so that gcc/configure\n # can detect this case.\n "}, {"sha": "c961fe8ba98be25b2553a880550f33b5d6faa0c4", "filename": "configure.ac", "status": "modified", "additions": 152, "deletions": 2, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -260,6 +260,13 @@ if test x$with_gnu_as = xno ; then\n   noconfigdirs=\"$noconfigdirs gas\"\n fi\n \n+use_included_zlib=\n+# Make sure we don't let ZLIB be added if we didn't want it.\n+if test x$with_system_zlib = xyes ; then\n+  use_included_zlib=no\n+  noconfigdirs=\"$noconfigdirs zlib\"\n+fi\n+\n # some tools are so dependent upon X11 that if we're not building with X, \n # it's not even worth trying to configure, much less build, that tool.\n \n@@ -1611,6 +1618,127 @@ fi\n AC_SUBST(clooglibs)\n AC_SUBST(clooginc)\n \n+# Check for LTO support.\n+AC_ARG_ENABLE(lto,\n+[  --enable-lto            enable link time optimization support],\n+enable_lto=$enableval,\n+enable_lto=yes; default_enable_lto=yes)\n+\n+if test x\"$enable_lto\" = x\"yes\" ; then\n+  # Make sure that libelf.h and gelf.h are available.\n+  AC_ARG_WITH(libelf, [  --with-libelf=PATH       Specify prefix directory for the installed libelf package\n+                          Equivalent to --with-libelf-include=PATH/include\n+                          plus --with-libelf-lib=PATH/lib])\n+\n+  AC_ARG_WITH(libelf_include, [  --with-libelf-include=PATH Specify directory for installed libelf include files])\n+\n+  AC_ARG_WITH(libelf_lib, [  --with-libelf-lib=PATH   Specify the directory for the installed libelf library])\n+\n+  case $with_libelf in \n+    \"\")\n+      libelflibs=\"-lelf\"\n+      libelfinc=\"-I/usr/include/libelf\"\n+      ;;\n+    *)\n+      libelflibs=\"-L$with_libelf/lib -lelf\"\n+      libelfinc=\"-I$with_libelf/include -I$with_libelf/include/libelf\"\n+      LIBS=\"$libelflibs $LIBS\"\n+      ;;\n+  esac\n+\n+  if test \"x$with_libelf_include\" != x; then\n+    libelfinc=\"-I$with_libelf_include\"\n+  fi\n+\n+  if test \"x$with_libelf_lib\" != x; then\n+    libelflibs=\"-L$with_libelf_lib -lelf\"\n+    LIBS=\"$libelflibs $LIBS\"\n+  fi\n+\n+  if test \"x$with_libelf$with_libelf_include$with_libelf_lib\" = x \\\n+     && test -d ${srcdir}/libelf; then\n+    libelflibs='-L$$r/$(HOST_SUBDIR)/libelf/.libs -L$$r/$(HOST_SUBDIR)/libelf/_libs -lelf '\n+    libelfinc='-I$$r/$(HOST_SUBDIR)/libelf/include -I$$s/libelf/include'\n+    LIBS=\"$libelflibs $LIBS\"\n+  fi\n+\n+  saved_CFLAGS=\"$CFLAGS\"\n+  saved_CPPFLAGS=\"$CPPFLAGS\"\n+  saved_LIBS=\"$LIBS\"\n+\n+  CFLAGS=\"$CFLAGS $libelfinc\"\n+  CPPFLAGS=\"$CPPFLAGS $libelfinc\"\n+  LIBS=\"$LIBS $libelflibs\"\n+\n+  AC_CHECK_HEADERS(libelf.h, [have_libelf_h=yes])\n+  AC_CHECK_HEADERS(gelf.h, [have_gelf_h=yes])\n+\n+  AC_CHECK_HEADERS(libelf/libelf.h, [have_libelf_libelf_h=yes])\n+  AC_CHECK_HEADERS(libelf/gelf.h, [have_libelf_gelf_h=yes])\n+\n+  # If we couldn't find libelf.h and the user forced it, emit an error.\n+  if test x\"$have_libelf_h\" != x\"yes\" \\\n+     && test x\"$have_libelf_libelf_h\" != x\"yes\" ; then\n+    if test x\"$default_enable_lto\" != x\"yes\" ; then\n+      AC_MSG_ERROR([LTO support requires libelf.h or libelf/libelf.h.])\n+    else\n+      enable_lto=no\n+      libelflibs=\n+      libelfinc=\n+    fi\n+  fi\n+\n+  # If we couldn't find gelf.h and the user forced it, emit an error.\n+  if test x\"$have_gelf_h\" != x\"yes\" \\\n+     && test x\"$have_libelf_gelf_h\" != x\"yes\" ; then\n+    if test x\"$default_enable_lto\" != x\"yes\" ; then\n+      AC_MSG_ERROR([LTO support requires gelf.h or libelf/gelf.h.])\n+    else\n+      enable_lto=no\n+      libelflibs=\n+      libelfinc=\n+    fi\n+  fi\n+\n+  # Check that the detected libelf has the functions we need.  We cannot\n+  # rely on just detecting the headers since they do not include \n+  # versioning information.  Add functions, if needed.\n+  if test x\"$enable_lto\" = x\"yes\" ; then\n+    AC_MSG_CHECKING([for the correct version of libelf])\n+    AC_TRY_LINK(\n+      [#include <libelf.h>],[\n+      elf_errmsg (0);\n+      elf_getscn (0, 0);\n+      elf_nextscn (0, 0);\n+      elf_strptr (0, 0, 0);\n+      elf_getident (0, 0);\n+      elf_getshdrstrndx (0, 0);\n+      elf_begin (0, 0, 0);\n+      elf_ndxscn (0);\n+      elf_end (0);\n+      ],\n+      [AC_MSG_RESULT([yes]);],\n+      [AC_MSG_RESULT([no]); enable_lto=no; libelflibs= ; libelfinc= ]\n+    )\n+\n+    # If we couldn't enable LTO and the user forced it, emit an error.\n+    if test x\"$enable_lto\" = x\"no\" \\\n+       && test x\"$default_enable_lto\" != x\"yes\" ; then\n+      AC_MSG_ERROR([To enable LTO, GCC requires libelf v0.8.12+.\n+Try the --with-libelf, --with-libelf-include and --with-libelf-lib options\n+to specify its location.])\n+    fi\n+  fi\n+\n+  CFLAGS=\"$saved_CFLAGS\"\n+  CPPFLAGS=\"$saved_CPPFLAGS\"\n+  LIBS=\"$saved_LIBS\"\n+\n+  # Flags needed for libelf.\n+  AC_SUBST(libelflibs)\n+  AC_SUBST(libelfinc)\n+fi\n+\n \n # By default, C is the only stage 1 language.\n stage1_languages=,c,\n@@ -1679,6 +1807,18 @@ if test -d ${srcdir}/gcc; then\n   done\n \n   new_enable_languages=,c,\n+\n+  # If LTO is enabled, add the LTO front end.\n+  extra_host_libiberty_configure_flags=\n+  if test \"$enable_lto\" = \"yes\" ; then\n+    new_enable_languages=\"${new_enable_languages}lto,\"\n+    if test \"${ENABLE_GOLD}\" = \"yes\" ; then\n+      configdirs=\"$configdirs lto-plugin\"\n+      extra_host_libiberty_configure_flags=--enable-shared\n+    fi\n+  fi\n+  AC_SUBST(extra_host_libiberty_configure_flags)\n+\n   missing_languages=`echo \",$enable_languages,\" | sed -e s/,all,/,/ -e s/,c,/,/ `\n   potential_languages=,c,\n \n@@ -2088,7 +2228,7 @@ if test x\"${with_libs}\" != x && test x\"${with_libs}\" != xno ; then\n   fi\n fi\n \n-# Set with_gnu_as and with_gnu_ld as appropriate.\n+# Set with_gnu_as, with_gnu_ld, and with_system_zlib as appropriate.\n #\n # This is done by determining whether or not the appropriate directory\n # is available, and by checking whether or not specific configurations\n@@ -2099,7 +2239,9 @@ fi\n #\n # If the default for a toolchain is to use GNU as and ld, and you don't \n # want to do that, then you should use the --without-gnu-as and\n-# --without-gnu-ld options for the configure script.\n+# --without-gnu-ld options for the configure script.  Similarly, if\n+# the default is to use the included zlib and you don't want to do that,\n+# you should use the --with-system-zlib option for the configure script.\n \n if test x${use_gnu_as} = x &&\n    echo \" ${configdirs} \" | grep \" gas \" > /dev/null 2>&1 ; then\n@@ -2113,6 +2255,14 @@ if test x${use_gnu_ld} = x &&\n   extra_host_args=\"$extra_host_args --with-gnu-ld\"\n fi\n \n+if test x${use_included_zlib} = x &&\n+   echo \" ${configdirs} \" | grep \" zlib \" > /dev/null 2>&1 ; then\n+  :\n+else\n+  with_system_zlib=yes\n+  extra_host_args=\"$extra_host_args --with-system-zlib\"\n+fi\n+\n # If using newlib, add --with-newlib to the extra_host_args so that gcc/configure\n # can detect this case.\n "}, {"sha": "2dc5d3af5ade60e56c2a81d9065890e36d40e1c8", "filename": "contrib/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1,3 +1,9 @@\n+2009-10-03  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/39216\n+\t* gcc_update: Adjust file timestamps for lto-plugin.\n+\n 2009-09-10  Iain Sandoe  <iain.sandoe@sandoe-acoustics.co.uk>\n \n \tPR bootstrap/41245"}, {"sha": "3e5a842338cb212e14436c04957d06495a66cde1", "filename": "contrib/gcc_update", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -84,6 +84,9 @@ gcc/testsuite/gcc.dg/cpp/_Pragma3.c: gcc/testsuite/gcc.dg/cpp/mi1c.h\n # Similarly, without this, you will see:\n # direct2s.c:35: warning: current file is older than direct2.c\n gcc/testsuite/gcc.dg/cpp/direct2s.c: gcc/testsuite/gcc.dg/cpp/direct2.c\n+# lto-plugin\n+lto-plugin/configure: lto-plugin/configure.ac lto-plugin/aclocal.m4\n+lto-plugin/Makefile.in: lto-plugin/Makefile.am lto-plugin/aclocal.m4\n # And libraries, at last\n libbanshee/configure: libbanshee/configure.ac\n libmudflap/configure: libmudflap/configure.ac"}, {"sha": "62d725c12adcd74ef52373de6a42bf362c5b5c34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1,3 +1,454 @@\n+2009-10-03  Simon Baldwin  <simonb@google.com>\n+\t    Cary Coutant  <ccoutant@google.com>\n+\t    Rafael Espindola  <espindola@google.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Doug Kwan <dougkwan@google.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com> \n+\t    Bill Maddox  <maddox@google.com>\n+\t    Ryan Mansfield  <rmansfield@qnx.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\t    Ollie Wild  <aaw@google.com>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* lto-cgraph.c: New file.\n+\t* lto-compress.c: New file.\n+\t* lto-compress.h: New file.\n+\t* lto-opts.c: New file.\n+\t* lto-section-in.c: New file.\n+\t* lto-section-out.c: New file.\n+\t* lto-streamer-in.c: New file.\n+\t* lto-streamer-out.c: New file.\n+\t* lto-streamer.c: New file.\n+\t* lto-streamer.h: New file.\n+\t* lto-symtab.c: New file.\n+\t* lto-wpa-fixup.c: New file.\n+\t* lto-wrapper.c: New file.\n+\n+2009-10-03  Simon Baldwin  <baldwin@google.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\t    Rafael Espindola  <espindola@google.com>\n+\t    Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Doug Kwan  <dougkwan@google.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\t    Kenneth Zadeck  <zadeck@naturalbridge.com>\n+\n+\t* Makefile.in (enable_lto): New.\n+\t(site.exp): If @enable_lto@ is set to 'yes' define\n+\tENABLE_LTO.\n+\t(LINKER_PLUGIN_API_H): Define.\n+\t(LTO_SYMTAB_H): Define.\n+\t(LTO_STREAMER_H): Define.\n+\t(TREE_VECTORIZER_H): Define.\n+\t(INCLUDES): Add LIBELFINC.\n+\t(OBJS-common): Add lto-cgraph.o, lto-streamer-in.o,\n+\tlto-streamer-out.o, lto-section-in.o, lto-section-out.o,\n+\tlto-symtab.o, lto-opts.o, lto-streamer.o, lto-wpa-fixup.o,\n+\tlto-compress.o.\n+\t(MOSTLYCLEANFILES): Add lto-wrapper$(exeext)\n+\t(native): Add lto-wrapper$(exeext)\n+\t(lto-compress.o, lto-cgraph.o, lto-streamer-in.o,\n+\tlto-streamer-out.o, lto-section-in.o, lto-section-out.o,\n+\tlto-symtab.o, lto-opts.o, lto-streamer.o,\n+\tlto-wpa-fixup.o): New rules.\n+\t(gimple.o): Add dependency on LTO_HEADER_H and\n+\tLTO_SECTION_OUT_H.\n+\t(varasm.o): Add dependency on tree-iterator.h.\n+\t(cgraph.o): Add dependency on cif-code.def.\n+\t(ipa-reference.o): Add dependency on LTO_STREAMER_H.\n+\t(ipa-pure-const.o): Likewise.\n+\t(GTFILES): Add lto-symtab.c.\n+\t(install-lto-wrapper): New.\n+\t* configure.ac: If 'lto' is in enable_languages, define\n+\tENABLE_LTO and enable_lto.\n+\tIf LIBELFLIBS is set, define HAVE_libelf.\n+\t* config.in: Regenerate.\n+\n+2009-10-03  Rafael Espindola  <espindola@google.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\n+\t* cgraphunit.c (ipa_passes): Prevent lto1 from calling\n+\tipa_write_summaries.\n+\tCall execute_ipa_summary_passes for all_regular_ipa_passes and\n+\tall_lto_gen_passes.\n+\t(cgraph_optimize): Make extern.\n+\n+2009-10-03  Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* toplev.c (in_lto_p): Declare.\n+\t* collect2.c (scan_prog_file): Read all the output when reading\n+\tinformation for LTO.\n+\t(enum lto_mode_d): Declare.\n+\n+2009-10-03  Richard Guenther  <rguenther@suse.de>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\n+\t* gimple.c: Include target.h and alias.h.\n+\t(gimple_types): Declare.\n+\t(type_hash_cache): Declare.\n+\t(gimple_alloc_stat): Make extern.\n+\t(gimple_build_eh_must_not_throw): Call\n+\tgimple_eh_must_not_throw_set_fndecl.\n+\t(struct type_pair_d): Declare.\n+\t(type_pair_t): Declare.\n+\t(type_pair_hash): New.\n+\t(type_pair_eq): New.\n+\t(lookup_type_pair): New.\n+\t(gimple_force_type_merge): New.\n+\t(compare_type_names_p): New.\n+\t(compare_field_offset): New.\n+\t(gimple_types_compatible_p): New.\n+\t(struct sccs): Declare.\n+\t(next_dfs_num): Declare.\n+\t(iterative_hash_gimple_type): New.\n+\t(visit): New.\n+\t(iterative_hash_type_name): New.\n+\t(iterative_hash_gimple_type): New.\n+\t(gimple_type_hash): New.\n+\t(gimple_type_eq): New.\n+\t(gimple_register_type): New.\n+\t(print_gimple_types_stats): New.\n+\t(gimple_signed_or_unsigned_type): New.\n+\t(gimple_unsigned_type): New.\n+\t(gimple_signed_type): New.\n+\t(gimple_get_alias_set): New.\n+\t(gimple_decl_printable_name): Do not use DMGL_TYPES.\n+\t* gimple.h (gimple_alloc, gimple_alloc_stat): Declare.\n+\t(gimple_force_type_merge): Declare.\n+\t(gimple_types_compatible_p): Declare.\n+\t(gimple_register_type): Declare.\n+\t(print_gimple_types_stats): Declare.\n+\t(gimple_unsigned_type): Declare.\n+\t(gimple_signed_type): Declare.\n+\t(gimple_get_alias_set): Declare.\n+\t(gimple_eh_must_not_throw_set_fndecl): New.\n+\n+2009-10-03  Jan Hubicka  <jh@suse.cz>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* ipa-pure-const.c: Include lto-streamer.h.\n+\t(register_hooks): Factor out of ...\n+\t(generate_summary): ... here.\n+\t(pure_const_write_summary): New.\n+\t(pure_const_read_summary): New.\n+\t(pass_ipa_pure_const): Add pure_const_write_summary and\n+\tpure_const_read_summary.\n+\t* ipa-reference.c: Include lto-streamer.h.\n+\t(add_new_function): New.\n+\t(remove_node_data): New.\n+\t(duplicate_node_data): New.\n+\t(ipa_init): Guard against multiple calls.\n+\tMove hook setup from analyze_function.\n+\t(write_node_summary_p): New.\n+\t(ipa_reference_write_summary): New.\n+\t(ipa_reference_read_summary): New.\n+\t(pass_ipa_reference): Add ipa_reference_write_summary and\n+\tipa_reference_read_summary.\n+\t* cgraph.h (cgraph_local_info): Add field lto_file_data.\n+\t(struct cgraph_edge): Add fields lto_stmt_uid and\n+\tcall_stmt_cannot_inline_p.\n+\t(cgraph_optimize): Declare.\n+\t(cgraph_decide_is_function_needed): Declare.\n+\t(reset_inline_failed): Declare.\n+\t(enum LTO_cgraph_tags): Declare.\n+\t(LTO_cgraph_tag_names): Declare.\n+\t(LCC_NOT_FOUND): Define.\n+\n+2009-10-03  Doug Kwan  <dougkwan@google.com>\n+\t    Rafael Espindola  <espindola@google.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\t    Kenneth Zadeck  <zadeck@naturalbridge.com>\n+\n+\t* passes.c (all_regular_ipa_passes): New.\n+\t(all_ipa_passes): Rename to all_small_ipa_passes.\n+\t(init_optimization_passes): Init all_regular_ipa_passes.\n+\t* tree-pass.h (all_regular_ipa_passes): New.\n+\t(all_ipa_passes): Rename to all_small_ipa_passes.\n+\t* passes.c (all_lto_gen_passes): New.\n+\t(init_optimization_passes): Initialize all_lto_gen_passes.\n+\t(execute_ipa_summary_passes): Make non-static.\n+\t(ipa_write_summaries_1): New.\n+\t(ipa_write_summaries_2): New.\n+\t(ipa_write_summaries): New.\n+\t(ipa_write_summaries_of_cgraph_node_set): New.\n+\t(ipa_read_summaries_1): New.\n+\t(ipa_read_summaries): New.\n+\t(execute_ipa_pass_list): Call cgraph_process_new_functions.\n+\t(execute_regular_ipa_pass_list): Remove.\n+\t(init_optimization_passes): Schedule\n+\tpass_rebuild_cgraph_edges and pass_early_inline outside\n+\tof pass_all_early_optimizations.  Document reason.\n+\t(pass_ipa_lto_gimple_out, pass_ipa_lto_wpa_fixup,\n+\tpass_ipa_lto_finish_out): New pass.\n+\t(pass_ipa_summary_passes): Start and stop timers if the pass\n+\thas them.\n+\t(execute_all_ipa_transforms): New.\n+\t(execute_one_pass): Don't call execute_one_ipa_transform_pass.\n+\t(dump_properties, debug_properties): New.\n+\t* tree-optimize.c (gate_all_early_local_passes): Return\n+\tfalse if we are in lto1.\n+\t(tree_rest_of_compilation): Call execute_all_ipa_transforms.\n+\t* tree-pass.h (execute_all_ipa_transforms): Declare.\n+\t(pass_ipa_function_and_variable_visibility): Declare.\n+\t(pass_ipa_early_inline): Declare.\n+\t(pass_ipa_lto_gimple_out): Declare.\n+\t(pass_ipa_lto_wpa_fixup): Declare.\n+\t(pass_ipa_lto_finish_out): Declare.\n+\t(all_small_ipa_passes, all_regular_ipa_passes,\n+\tall_lto_gen_passes): Declare.\n+\t(execute_ipa_summary_passes): Declare.\n+\t(execute_all_ipa_transforms): Declare.\n+\t(ipa_write_summaries): Declare\n+\t(ipa_write_summaries_of_cgraph_node_set): Declare.\n+\t(ipa_read_summaries): Declare.\n+\n+2009-10-03  Doug Kwan  <dougkwan@google.com>\n+\t    Ollie Wild  <aaw@google.com>\n+\n+\t* ipa-prop.c (ipa_propagate_indirect_call_infos): Do\n+\tnothing in WPA.\n+\n+\t* collect2.c (LTO_MODE_NONE, LTO_MODE_LTO, LTO_MODE_WPA): New enums.\n+\t(lto_mode): New variable.\n+\t(maybe_run_lto_and_relink): Handle the -fwpa option.\n+\t(main): Handle the -fwpa option.\n+\t(maybe_unlink_list): New function.\n+\t* gcc.c (link_lto_options): Replace -flto with -fwpa.\n+\t* common.opt (flto): New flag.\n+\t* toplev.c (flag_generate_lto): Declare.\n+\n+2009-10-03  Simon Baldwin  <simonb@google.com>\n+\n+\t* common.opt (flto-compression-level): New flag.\n+\n+\t* opts.c: Include lto-opts.h.\n+\t(handle_option): Call lto_register_user_option for each\n+\tvalid option handled.\n+\t* (decode_options): Clear registered options before the options\n+\thandling loop.\n+\n+2009-10-03  Cary Coutant  <ccoutant@google.com>\n+\n+\t* collect2.c (is_elf): New function.\n+\t(scan_prog_file): Require LTO object to be in ELF format.\n+\n+2009-10-03  Rafael Espindola  <espindola@google.com>\n+\n+\t* gcc.c (LINK_COMMAND_SPEC): Use the -pass-through option to pass\n+\tlibgcc to the linker.\n+\n+\t* ipa-cp.c (cgraph_gate_cp): Return false if LTRANS is\n+\trunning.\n+\n+\t* collect2.c (maybe_run_lto_and_relink): Execute lto-wrapper.\n+\t(collect_execute): Add flags argument. Pass flags to pex_run. Update\n+\tall callers.\n+\t* collect2.h (collect_execute): Add flags argument.\n+\t* tlink.c (tlink_execute): Update call to collect_execute.\n+\t* gcc.c (main): Set the COLLECT_LTO_WRAPPER environment variable.\n+\t(use_linker_plugin): New.\n+\t(use_linker_plugin_spec_function): New.\n+\t(LINK_COMMAND_SPEC): Pass plugin options to the linker.\n+\t(linker_plugin_file_spec): New.\n+\t(lto_wrapper_spec): New.\n+\t(lto_gcc_spec): New.\n+\t(static_specs): Add linker_plugin_file, lto_wrapper and lto_gcc.\n+\t(static_spec_functions): Add use-linker-plugin.\n+\t(process_command): Handle -use-linker-plugin.\n+\t(main): Use lto_wrapper_spec instead of lto_wrapper. Set\n+\tlinker_plugin_file_spec and lto_gcc_spec.\n+\t(use_linker_plugin_spec_function): New.\n+\n+2009-10-03  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/41547\n+\tPR lto/41548\n+\t* tree.h (is_lang_specific): Include LANG_TYPE.\n+\t* tree.c (find_decls_types_r): Manually add interesting parts\n+\tof TYPE_FIELDS.  Walk BINFO_VIRTUALS.  Do not walk TYPE_METHODS.\n+\n+\t* gimple.c (type_pair_hash): Make symmetric.\n+\t(type_pair_eq): Likewise.\n+\t(lookup_type_pair): Increase initial hashtable size.\n+\t(gimple_force_type_merge): Rely on type-pair symmetry.\n+\t(visit): Remove excessive checking code.\n+\t(iterative_hash_type_name): Do not hash TYPE_NAME of\n+\tanonymous unions.\n+\t(gimple_register_type): Remove getenv calls, shrink initial\n+\thashtable size.\n+\n+\tPR middle-end/41502\n+\t* cgraphunit.c (ipa_passes): Do not remove bodies of extern\n+\tinline functions if not generating lto output.\n+\n+\tPR lto/41379\n+\t* toplev.c (finalize): In WPA mode remove the asm file.\n+\n+2009-10-03  Doug Kwan  <dougkwan@google.com>\n+\n+\t* ipa-inline.c (cgraph_mark_inline): Check\n+\tedge->call_stmt_cannot_inline_p instead of calling\n+\tgimple_call_cannot_inline_p.\n+\t(cgraph_decide_inlining): Do nothing in WPA and LTRANS.\n+\t(cgraph_gate_ipa_early_inlining): Return false if\n+\tin_lto_p is set.\n+\t(inline_generate_summary): Do nothing in LTRANS.\n+\t* cgraph.c (initialize_inline_failed): Make sure\n+\te->call_stmt exists before calling\n+\tgimple_call_cannot_inline_p.\n+\t(cgraph_create_edge): Set edge->call_stmt_cannot_inline_p.\n+\t(cgraph_clone_edge): Add argument STMT_UID.  Modify all\n+\tcallers.\n+\tUpdate new_edge->lto_stmt_uid.\n+\t* cgraphbuild.c (reset_inline_failed): New.\n+\n+\t* common.opt (fwpa): New flag.\n+\t(fltrans): New option.\n+\t* gcc.c (gcc_lto_option_t): New type.\n+\t(current_lto_option): New variable.\n+\t(lto_single_spec_function): Remove and is replaced by ..\n+\t(lto_option_spec_function): New function.\n+\t(LINK_COMMAND_SPEC): Use link_lto_option spec instead of just\n+\tpassing the -flto flag.\n+\t(cc1_options): Separate non-LTO related parts into ..\n+\t(cc1_non_lto_options): Non-LTO related options shared by all FEs.\n+\t(lto1_options): New spec for lto FE.\n+\t(link_lto_options): New spec for handling LTO flags in linker.\n+\t(invoke_lto_single): Re-format to fit in 80 column.  Replace\n+\tlto-single with lto-option.\n+\t(static_specs): Add cc1_non_lto_options, lto1_options and\n+\tlink_lto_options.\n+\t(static_spec_function): Replace lto-single with lto-option.\n+\t(process_command): Handle -flto, -fwpa and -fltran\n+\tby setting current_lto_option and not passing it to subprocess\n+\tunconditionally.\n+\n+2009-10-03  Bill Maddox  <maddox@google.com>\n+\n+\tAdd `gcc' driver support for link-time code generation (LTO).\n+\n+\t* collect2.c (enum pass): Add new literal PASS_LTOINFO.\n+\t(lto_flag, lto_objects, lto_o_file): New variables.\n+\t(struct lto_object, struct lto_object_list): New structures.\n+\t(collect_exit, handler): Remove LTO temporary output file on exit.\n+\t(add_lto_object): New function.\n+\t(maybe_run_lto_and_relink): New function. Perform link time code\n+\tgeneration and relinking for object files containing LTO information.\n+\t(main): Invoke maybe_run_lto_and_relink().\n+\t(dump_argv): New function.  For debugging, currently disabled.\n+\t(scan_prog_file): Add LTO information pass.\n+\t* gcc.c (LINK_COMMAND_SPEC): Pass `-flto' switch to linker, i.e.,\n+\tcollect2.\n+\t* toplev.c (compile_file): Emit assembler directive to create\n+\tthe `gnu_lto_v1' marker symbol when compiling with `-flto'.\n+\n+2009-10-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* c.opt: Add LTO to warn_abi and warn_psabi.\n+\n+\t* tree.c (fld_worklist_push): Rename from PUSH.\n+\tConvert to static inline function.\n+\tIgnore language-specific nodes.\n+\tUpdate all users.\n+\t(find_decls_types_r): Do not traverse the subtrees of\n+\tlanguage-specific nodes.\n+\tDo not traverse DECL_INITIAL for TYPE_DECLs.\n+\t* tree.h (is_lang_specific): New.\n+\t* langhooks.h (struct lang_hooks_for_decls): Remove\n+\tmay_need_assembler_name_p.  Update all users.\n+\n+\t* c-common.c (set_builtin_user_assembler_name): Move ...\n+\t* builtins.c (set_builtin_user_assembler_name): ... here.\n+\t(is_builtin_name): Add comment\n+\t(is_builtin_fn): New.\n+\t* except.c (output_ttype): Only call\n+\tlookup_type_for_runtime if TYPE is not a runtime type.\n+\n+\t* passes.c (register_pass): Call position_pass on\n+\tall_small_ipa_passes, all_regular_ipa_passes and\n+\tall_lto_gen_passes.\n+\t* timevar.def (TV_IPA_LTO_GIMPLE_IO): Define.\n+\t(TV_IPA_LTO_DECL_IO): Define.\n+\t(TV_IPA_LTO_CGRAPH_IO): Define.\n+\t(TV_LTO): Define.\n+\t(TV_WHOPR_WPA): Define.\n+\t(TV_WHOPR_WPA_IO): Define.\n+\t(TV_WHOPR_LTRANS): Define.\n+\t(TV_WHOPR_WPA_FIXUP): Define.\n+\t(TV_WHOPR_WPA_LTRANS_EXEC): Define.\n+\t* tree-cfg.c (tree_node_can_be_shared): Make extern.\n+\t* tree-flow.h (tree_node_can_be_shared): Declare.\n+\t* tree-inline.c (tree_can_inline_p): Check that E has a\n+\tstatement associated with it.\n+\t* tree.c (free_lang_data_in_binf): Factor out of ...\n+\t(free_lang_data_in_type): ... here.\n+\tCall RECORD_OR_UNION_TYPE_P.\n+\t(need_assembler_name_p): Ignore DECL if it does not have\n+\tTREE_PUBLIC set.\n+\tCall lang_hooks.decls.may_need_assembler_name_p if set.\n+\t(free_lang_data_in_decl): Do not clear DECL_CONTEXT for\n+\tCONST_DECLs.\n+\t(free_lang_data): Set debug_info_level to\n+\tDINFO_LEVEL_NONE.\n+\tSet write_symbols to NO_DEBUG.\n+\tSet debug_hooks to do_nothing_debug_hooks.\n+\t(gate_free_lang_data): Return true if flag_generate_lto\n+\tis set.\n+\t(walk_tree_1): Call RECORD_OR_UNION_TYPE_P.\n+\t* c-common.h (set_builtin_user_assembler_name): Move ...\n+\t* tree.h (set_builtin_user_assembler_name): ... here.\n+\n+\t* common.opt (flto-report): New flag.\n+\t* opts.c (complain_wrong_lang): Do not complain if\n+\trunning lto1.\n+\t* collect2.c (scan_prog_file): Send the error output of\n+\t'nm' to HOST_BIT_BUCKET.\n+\n+2009-10-03  Ollie Wild  <aaw@google.com>\n+\n+\t* langhooks-def.h (lhd_begin_section): New function declaration.\n+\t(lhd_write_section): New function declaration.\n+\t(lhd_end_section): New function declaration.\n+\t(LANG_HOOKS_BEGIN_SECTION): New macro.\n+\t(LANG_HOOKS_WRITE_SECTION_DATA): New macro.\n+\t(LANG_HOOKS_END_SECTION): New macro.\n+\t(LANG_HOOKS_LTO): New macro.\n+\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_LTO.\n+\t* langhooks.c (output.h): Add include.\n+\t(saved_section): New static variable.\n+\t(lhd_begin_section): New function.\n+\t(lhd_write_section_data): New function.\n+\t(lhd_end_section): New function.\n+\t* langhooks.h (struct lang_hooks_for_lto): New structure.\n+\t(struct lang_hooks): Add member lto.\n+\t* Makefile.in (langhooks.o): Add dependency on output.h.\n+\n+\t* c-opts.c (c_common_post_options): Handle -flto and -fwhopr.\n+\n+2009-10-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue):\n+\tHandle LTO.\n+\n+2009-10-03  Simon Baldwin  <simonb@google.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\t    Janis Johnson  <janis187@us.ibm.com>\n+\t    Doug Kwan  <dougkwan@google.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\t    Ramana Radhakrishnan  <ramana.r@gmail.com>\n+\t    Ollie Wild  <aaw@google.com>\n+\n+\t* doc/install.texi: Add documentation for libelf and --enable-lto.\n+\t* doc/invoke.texi: Document -fwpa, -flto, -fwhopr,\n+\t-fltrans, -flto-report, -flto-compression-level and\n+\t-use-linker-plugin.\n+\t* doc/sourcebuild.texi: Document use of zlib.\n+\tDocument lto-plugin.\n+\tAdd section for LTO Testing.\n+\n 2009-10-02  Cary Coutant  <ccoutant@google.com>\n \n \tAdd support for comdat type sections for DWARF v4.  Merge from dwarf4"}, {"sha": "490a8c41eacb020251bef51117ae015390b8f4d2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 99, "deletions": 12, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -309,6 +309,13 @@ PPLINC = @PPLINC@\n CLOOGLIBS = @CLOOGLIBS@\n CLOOGINC = @CLOOGINC@\n \n+# How to find libelf\n+LIBELFLIBS = @LIBELFLIBS@\n+LIBELFINC = @LIBELFINC@\n+\n+# Set to 'yes' if the LTO front end is enabled.\n+enable_lto = @enable_lto@\n+\n # Libs and linker option needed for plugin support\n PLUGINLIBS = @pluginlibs@\n \n@@ -407,6 +414,10 @@ PARTITION_H = $(srcdir)/../include/partition.h\n MD5_H\t    = $(srcdir)/../include/md5.h\n DWARF2_H    = $(srcdir)/../include/dwarf2.h\n \n+# Linker plugin API headers\n+LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n+LTO_SYMTAB_H = $(srcdir)/../include/lto-symtab.h\n+\n # Default native SYSTEM_HEADER_DIR, to be overridden by targets.\n NATIVE_SYSTEM_HEADER_DIR = /usr/include\n # Default cross SYSTEM_HEADER_DIR, to be overridden by targets.\n@@ -917,6 +928,9 @@ REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n EBITMAP_H = ebitmap.h sbitmap.h\n+LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n+\t\t$(CGRAPH_H) vec.h vecprim.h $(TREE_H) $(GIMPLE_H)\n+TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h $(CGRAPH_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n@@ -976,7 +990,8 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n # and the system's installed libraries.\n LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \\\n \t$(HOST_LIBS)\n-BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS)\n+BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \\\n+\t$(ZLIB) $(LIBELFLIBS)\n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n \n@@ -1005,7 +1020,7 @@ BUILD_ERRORS = build/errors.o\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n \t   -I$(srcdir)/../include @INCINTL@ \\\n \t   $(CPPINC) $(GMPINC) $(DECNUMINC) \\\n-\t   $(PPLINC) $(CLOOGINC)\n+\t   $(PPLINC) $(CLOOGINC) $(LIBELFINC)\n \n .c.o:\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)\n@@ -1215,6 +1230,16 @@ OBJS-common = \\\n \tloop-unroll.o \\\n \tloop-unswitch.o \\\n \tlower-subreg.o \\\n+\tlto-cgraph.o \\\n+\tlto-streamer-in.o \\\n+\tlto-streamer-out.o \\\n+\tlto-section-in.o \\\n+\tlto-section-out.o \\\n+\tlto-symtab.o \\\n+\tlto-opts.o \\\n+\tlto-streamer.o \\\n+\tlto-wpa-fixup.o \\\n+\tlto-compress.o \\\n \tmcf.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n@@ -1411,7 +1436,7 @@ MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \\\n  xgcc$(exeext) cpp$(exeext) cc1$(exeext) cc1*-dummy$(exeext) $(EXTRA_PASSES) \\\n  $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) \\\n- $(SPECS) collect2$(exeext) \\\n+ $(SPECS) collect2$(exeext) lto-wrapper$(exeext) \\\n  gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \\\n  *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a libgcc.mk\n \n@@ -1692,7 +1717,7 @@ rest.encap: lang.rest.encap\n # This is what is made with the host's compiler\n # whether making a cross compiler or not.\n native: config.status auto-host.h build-@POSUB@ $(LANGUAGES) \\\n-\t$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2)\n+\t$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2) lto-wrapper$(exeext)\n \n # Define the names for selecting languages in LANGUAGES.\n c: cc1$(exeext)\n@@ -1987,6 +2012,12 @@ collect2-aix.o : collect2-aix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(OBSTACK_H) collect2.h intl.h\n \n+lto-wrapper$(exeext): lto-wrapper.o intl.o $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o T$@ lto-wrapper.o intl.o $(LIBS)\n+\tmv -f T$@ $@\n+\n+lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h\n+\n # A file used by all variants of C.\n \n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2158,10 +2189,54 @@ convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \n double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n \n+# lto-compress.o needs $(ZLIBINC) added to the include flags.\n+lto-compress.o: lto-compress.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\t$(TREE_H) langhooks.h $(LTO_HEADER_H) $(LTO_SECTION_H) \\\n+\tlto-compress.h $(DIAGNOSTIC_H) errors.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(ZLIBINC) $< $(OUTPUT_OPTION)\n+\n+lto-cgraph.o: lto-cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n+   $(TM_H) $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n+   $(VARRAY_H) $(HASHTAB_H) langhooks.h $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n+   except.h $(TIMEVAR_H) output.h pointer-set.h $(LTO_STREAMER_H)\n+lto-streamer-in.o: lto-streamer-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h $(VARRAY_H) \\\n+   $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) \\\n+   $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_H) libfuncs.h $(EXCEPT_H) debug.h \\\n+   $(TIMEVAR_H) output.h $(IPA_UTILS_H) $(LTO_STREAMER_H)\n+lto-streamer-out.o : lto-streamer-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n+   $(VARRAY_H) $(HASHTAB_H) $(BASIC_BLOCK_H) tree-iterator.h \\\n+   $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) \\\n+   $(DIAGNOSTIC_H) except.h $(LTO_STREAMER_H) errors.h\n+lto-section-in.o: lto-section-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h $(VARRAY_H) \\\n+   $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) \\\n+   $(GGC_H) $(DIAGNOSTIC_H) except.h $(TIMEVAR_H) output.h \\\n+   $(LTO_STREAMER_H) lto-compress.h\n+lto-section-out.o : lto-section-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(PARAMS_H) input.h \\\n+   $(VARRAY_H) $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) \\\n+   $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) except.h pointer-set.h \\\n+   $(BITMAP_H) langhooks.h $(LTO_STREAMER_H) lto-compress.h\n+lto-symtab.o: lto-symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   toplev.h $(TREE_H) $(GIMPLE_H) $(GGC_H) $(LAMBDA_H) $(HASHTAB_H) \\\n+   $(LTO_STREAMER_H) $(LINKER_PLUGIN_API_H) gt-lto-symtab.h\n+lto-opts.o: lto-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n+   $(HASHTAB_H) $(GGC_H) $(BITMAP_H) $(FLAGS_H) opts.h options.h \\\n+   $(TARGET_H) $(TOPLEV_H) $(LTO_STREAMER_H)\n+lto-streamer.o: lto-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n+   $(TM_H) $(TREE_H) $(GIMPLE_H) $(BITMAP_H) $(LTO_STREAMER_H) $(FLAGS_H) \\\n+   $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(LTO_SYMTAB_H) $(TOPLEV_H)\n+lto-wpa-fixup.o: lto-wpa-fixup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(CGRAPH_H) \\\n+   $(FUNCTION_H) $(DIAGNOSTIC_H) $(BITMAP_H) $(TIMEVAR_H) \\\n+   $(TREE_FLOW_H) $(TREE_PASS_H) $(LTO_STREAMER_H)\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(TOPLEV_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n-   intl.h $(GIMPLE_H) $(CGRAPH_H)\n+   intl.h $(GIMPLE_H) $(CGRAPH_H) output.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n    $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) \\\n@@ -2572,7 +2647,8 @@ tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_PASS_H) tree-ssa-propagate.h\n gimple.o : gimple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(GGC_H) $(GIMPLE_H) $(TOPLEV_H) $(DIAGNOSTIC_H) gt-gimple.h \\\n-   $(TREE_FLOW_H) value-prof.h $(FLAGS_H) $(DEMANGLE_H)\n+   $(TREE_FLOW_H) value-prof.h $(FLAGS_H) $(DEMANGLE_H) \\\n+   $(TARGET_H) $(ALIAS_H)\n gimple-pretty-print.o : gimple-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(GIMPLE_H) value-prof.h\n@@ -2640,7 +2716,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) $(TREE_PASS_H) $(TREE_DUMP_H) \\\n    $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n-   gt-passes.h $(DF_H) $(PREDICT_H)\n+   gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_HEADER_H) $(LTO_SECTION_OUT_H)\n \n plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TOPLEV_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)\n@@ -2669,7 +2745,8 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n    output.h $(TOPLEV_H) xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n    $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h $(BASIC_BLOCK_H) \\\n-   $(CFGLAYOUT_H) $(CGRAPH_H) targhooks.h tree-mudflap.h $(REAL_H) tree-iterator.h\n+   $(CFGLAYOUT_H) $(CGRAPH_H) targhooks.h tree-mudflap.h $(REAL_H) \\\n+   tree-iterator.h\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(CFGLAYOUT_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n    $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n@@ -2771,7 +2848,8 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h $(TOPLEV_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n-   $(TREE_INLINE_H) $(TREE_DUMP_H) $(TREE_FLOW_H) value-prof.h $(EXCEPT_H)\n+   $(TREE_INLINE_H) $(TREE_DUMP_H) $(TREE_FLOW_H) cif-code.def \\\n+   value-prof.h $(EXCEPT_H)\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(TOPLEV_H) $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n@@ -2813,12 +2891,13 @@ ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \\\n-   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) gt-ipa-reference.h\n+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) gt-ipa-reference.h \\\n+   $(LTO_STREAMER_H)\n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) \\\n-   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H)\n+   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H) $(LTO_STREAMER_H)\n ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n@@ -3504,6 +3583,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-phinodes.c \\\n   $(srcdir)/ipa-reference.c \\\n   $(srcdir)/tree-ssa-structalias.c \\\n+  $(srcdir)/lto-symtab.c \\\n   $(srcdir)/tree-ssa-alias.h \\\n   @all_gtfiles@\n \n@@ -4145,7 +4225,7 @@ maintainer-clean:\n # broken is small.\n install: install-common $(INSTALL_HEADERS) \\\n     install-cpp install-man install-info install-@POSUB@ \\\n-    install-driver\n+    install-driver install-lto-wrapper\n \n ifeq ($(enable_plugin),yes)\n install: install-plugin\n@@ -4440,6 +4520,10 @@ install-collect2: collect2 installdirs\n # Install the driver program as $(libsubdir)/gcc for collect2.\n \t$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(libexecsubdir)/gcc$(exeext)\n \n+# Install lto-wrapper.\n+install-lto-wrapper: lto-wrapper$(exeext)\n+\t$(INSTALL_PROGRAM) lto-wrapper$(exeext) $(DESTDIR)$(libexecsubdir)/lto-wrapper$(exeext)\n+\t\n # Cancel installation by deleting the installed files.\n uninstall: lang.uninstall\n \t-rm -rf $(DESTDIR)$(libsubdir)\n@@ -4491,6 +4575,9 @@ site.exp: ./config.status Makefile\n \t  echo \"set ENABLE_PLUGIN 1\" >> ./tmp0; \\\n \t  echo \"set GMPINC \\\"$(GMPINC)\\\"\" >> ./tmp0; \\\n \tfi\n+\t@if test \"@enable_lto@\" = \"yes\" ; then \\\n+\t  echo \"set ENABLE_LTO 1\" >> ./tmp0; \\\n+\tfi\n # If newlib has been configured, we need to pass -B to gcc so it can find\n # newlib's crt0.o if it exists.  This will cause a \"path prefix not used\"\n # message if it doesn't, but the testsuite is supposed to ignore the message -"}, {"sha": "c9bc23010a1c2fb3b6dd10bc6886a477279ce3f0", "filename": "gcc/builtins.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -230,6 +230,8 @@ static tree do_mpfr_bessel_n (tree, tree, tree,\n static tree do_mpfr_remquo (tree, tree, tree);\n static tree do_mpfr_lgamma_r (tree, tree, tree);\n \n+/* Return true if NAME starts with __builtin_ or __sync_.  */\n+\n bool\n is_builtin_name (const char *name)\n {\n@@ -240,6 +242,16 @@ is_builtin_name (const char *name)\n   return false;\n }\n \n+\n+/* Return true if DECL is a function symbol representing a built-in.  */\n+\n+bool\n+is_builtin_fn (tree decl)\n+{\n+  return TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl);\n+}\n+\n+\n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n    its \"internal\" name, which normally contains the prefix \"__builtin\".  */\n@@ -13856,3 +13868,41 @@ fold_call_stmt (gimple stmt, bool ignore)\n     }\n   return NULL_TREE;\n }\n+\n+/* Look up the function in built_in_decls that corresponds to DECL\n+   and set ASMSPEC as its user assembler name.  DECL must be a\n+   function decl that declares a builtin.  */\n+\n+void\n+set_builtin_user_assembler_name (tree decl, const char *asmspec)\n+{\n+  tree builtin;\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n+\t      && asmspec != 0);\n+\n+  builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];\n+  set_user_assembler_name (builtin, asmspec);\n+  switch (DECL_FUNCTION_CODE (decl))\n+    {\n+    case BUILT_IN_MEMCPY:\n+      init_block_move_fn (asmspec);\n+      memcpy_libfunc = set_user_assembler_libfunc (\"memcpy\", asmspec);\n+      break;\n+    case BUILT_IN_MEMSET:\n+      init_block_clear_fn (asmspec);\n+      memset_libfunc = set_user_assembler_libfunc (\"memset\", asmspec);\n+      break;\n+    case BUILT_IN_MEMMOVE:\n+      memmove_libfunc = set_user_assembler_libfunc (\"memmove\", asmspec);\n+      break;\n+    case BUILT_IN_MEMCMP:\n+      memcmp_libfunc = set_user_assembler_libfunc (\"memcmp\", asmspec);\n+      break;\n+    case BUILT_IN_ABORT:\n+      abort_libfunc = set_user_assembler_libfunc (\"abort\", asmspec);\n+      break;\n+    default:\n+      break;\n+    }\n+}"}, {"sha": "bf57cb8a2df08be88154521a34a5f4e21f26bc6d", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -5032,44 +5032,6 @@ c_common_nodes_and_builtins (void)\n   memset (builtin_types, 0, sizeof (builtin_types));\n }\n \n-/* Look up the function in built_in_decls that corresponds to DECL\n-   and set ASMSPEC as its user assembler name.  DECL must be a\n-   function decl that declares a builtin.  */\n-\n-void\n-set_builtin_user_assembler_name (tree decl, const char *asmspec)\n-{\n-  tree builtin;\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n-\t      && asmspec != 0);\n-\n-  builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];\n-  set_user_assembler_name (builtin, asmspec);\n-  switch (DECL_FUNCTION_CODE (decl))\n-    {\n-    case BUILT_IN_MEMCPY:\n-      init_block_move_fn (asmspec);\n-      memcpy_libfunc = set_user_assembler_libfunc (\"memcpy\", asmspec);\n-      break;\n-    case BUILT_IN_MEMSET:\n-      init_block_clear_fn (asmspec);\n-      memset_libfunc = set_user_assembler_libfunc (\"memset\", asmspec);\n-      break;\n-    case BUILT_IN_MEMMOVE:\n-      memmove_libfunc = set_user_assembler_libfunc (\"memmove\", asmspec);\n-      break;\n-    case BUILT_IN_MEMCMP:\n-      memcmp_libfunc = set_user_assembler_libfunc (\"memcmp\", asmspec);\n-      break;\n-    case BUILT_IN_ABORT:\n-      abort_libfunc = set_user_assembler_libfunc (\"abort\", asmspec);\n-      break;\n-    default:\n-      break;\n-    }\n-}\n-\n /* The number of named compound-literals generated thus far.  */\n static GTY(()) int compound_literal_number;\n "}, {"sha": "db4f910e81b6c4f7a03ad0866b992cad4ea5b1cb", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -839,8 +839,6 @@ extern tree c_build_qualified_type (tree, int);\n    frontends.  */\n extern void c_common_nodes_and_builtins (void);\n \n-extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n-\n extern void disable_builtin_function (const char *);\n \n extern void set_compound_literal_name (tree decl);"}, {"sha": "6c2f5a59cd3b75d30d7b284287576b9fed5c6078", "filename": "gcc/c-opts.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1033,6 +1033,29 @@ c_common_post_options (const char **pfilename)\n   C_COMMON_OVERRIDE_OPTIONS;\n #endif\n \n+  if (flag_lto || flag_whopr)\n+    {\n+#ifdef ENABLE_LTO\n+      flag_generate_lto = 1;\n+\n+      /* When generating IL, do not operate in whole-program mode.\n+\t Otherwise, symbols will be privatized too early, causing link\n+\t errors later.  */\n+      flag_whole_program = 0;\n+\n+      /* FIXME lto.  Disable var-tracking until debug information\n+\t is properly handled in free_lang_data.  */\n+      flag_var_tracking = 0;\n+#else\n+      error (\"LTO support has not been enabled in this configuration\");\n+#endif\n+    }\n+\n+  /* Reconcile -flto and -fwhopr.  Set additional flags as appropriate and\n+     check option consistency.  */\n+  if (flag_lto && flag_whopr)\n+    error (\"-flto and -fwhopr are mutually exclusive\");\n+\n   /* Excess precision other than \"fast\" requires front-end\n      support.  */\n   if (c_dialect_cxx ())"}, {"sha": "006f9ae9c1b336cc795d3f6ae95b062c22b8de40", "filename": "gcc/c.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -113,11 +113,11 @@ C ObjC C++ ObjC++ Joined Separate\n -U<macro>\tUndefine <macro>\n \n Wabi\n-C ObjC C++ ObjC++ Var(warn_abi) Warning\n+C ObjC C++ ObjC++ LTO Var(warn_abi) Warning\n Warn about things that will change when compiling with an ABI-compliant compiler\n \n Wpsabi\n-C ObjC C++ ObjC++ Var(warn_psabi) Init(1) Undocumented\n+C ObjC C++ ObjC++ LTO Var(warn_psabi) Init(1) Undocumented\n \n Waddress\n C ObjC C++ ObjC++ Var(warn_address) Warning"}, {"sha": "8dcf4e43edb543af0b72e13f1d0b9befb82d0ae9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -802,7 +802,7 @@ initialize_inline_failed (struct cgraph_edge *e)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n   else if (!callee->local.inlinable)\n     e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n-  else if (gimple_call_cannot_inline_p (e->call_stmt))\n+  else if (e->call_stmt && gimple_call_cannot_inline_p (e->call_stmt))\n     e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n   else\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n@@ -816,13 +816,19 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n {\n   struct cgraph_edge *edge;\n \n+\n+  /* LTO does not actually have access to the call_stmt since these\n+     have not been loaded yet.  */\n+  if (call_stmt)\n+    {\n #ifdef ENABLE_CHECKING\n   /* This is rather pricely check possibly trigerring construction of call stmt\n      hashtable.  */\n   gcc_assert (!cgraph_edge (caller, call_stmt));\n #endif\n \n-  gcc_assert (is_gimple_call (call_stmt));\n+      gcc_assert (is_gimple_call (call_stmt));\n+    }\n \n   if (free_edges)\n     {\n@@ -860,7 +866,9 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   gcc_assert (freq <= CGRAPH_FREQ_MAX);\n   edge->loop_nest = nest;\n   edge->indirect_call = 0;\n-  if (caller->call_site_hash)\n+  edge->call_stmt_cannot_inline_p =\n+    (call_stmt ? gimple_call_cannot_inline_p (call_stmt) : false);\n+  if (call_stmt && caller->call_site_hash)\n     {\n       void **slot;\n       slot = htab_find_slot_with_hash (caller->call_site_hash,\n@@ -1624,8 +1632,8 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   gimple call_stmt, gcov_type count_scale, int freq_scale,\n-\t\t   int loop_nest, bool update_original)\n+\t\t   gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n+\t\t   int freq_scale, int loop_nest, bool update_original)\n {\n   struct cgraph_edge *new_edge;\n   gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n@@ -1638,6 +1646,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \n   new_edge->inline_failed = e->inline_failed;\n   new_edge->indirect_call = e->indirect_call;\n+  new_edge->lto_stmt_uid = stmt_uid;\n   if (update_original)\n     {\n       e->count -= new_edge->count;\n@@ -1702,8 +1711,8 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n \n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new_node, e->call_stmt, count_scale, freq, loop_nest,\n-\t\t       update_original);\n+    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n+\t\t       count_scale, freq, loop_nest, update_original);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)"}, {"sha": "845897b2841d46a46d4a136c2d1dc91892a8d32f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -46,6 +46,10 @@ enum availability\n   AVAIL_LOCAL\n };\n \n+/* This is the information that is put into the cgraph local structure\n+   to recover a function.  */\n+struct lto_file_decl_data;\n+\n extern const char * const cgraph_availability_names[];\n \n /* Function inlining information.  */\n@@ -69,6 +73,9 @@ struct GTY(()) inline_summary\n    Available after function is analyzed.  */\n \n struct GTY(()) cgraph_local_info {\n+  /* File stream where this node is being written to.  */\n+  struct lto_file_decl_data * GTY ((skip)) lto_file_data;\n+\n   struct inline_summary inline_summary;\n \n   /* Set when function function is visible in current compilation unit only\n@@ -277,6 +284,9 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   struct cgraph_edge *prev_callee;\n   struct cgraph_edge *next_callee;\n   gimple call_stmt;\n+  /* The stmt_uid of this call stmt.  This is used by LTO to recover\n+     the call_stmt when the function is serialized in.  */\n+  unsigned int lto_stmt_uid;\n   PTR GTY ((skip (\"\"))) aux;\n   /* When equal to CIF_OK, inline this call.  Otherwise, points to the\n      explanation why function was not inlined.  */\n@@ -291,6 +301,8 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   unsigned int loop_nest : 30;\n   /* Whether this edge describes a call that was originally indirect.  */\n   unsigned int indirect_call : 1;\n+  /* True if the corresponding CALL stmt cannot be inlined.  */\n+  unsigned int call_stmt_cannot_inline_p : 1;\n   /* Can this call throw externally?  */\n   unsigned int can_throw_external : 1;\n   /* Unique id of the edge.  */\n@@ -406,8 +418,8 @@ struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n-\t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\tgimple, gcov_type, int, int, bool);\n+\t\t\t\t\tstruct cgraph_node *, gimple,\n+\t\t\t\t\tunsigned, gcov_type, int, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n@@ -430,6 +442,7 @@ struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n void cgraph_finalize_function (tree, bool);\n void cgraph_mark_if_needed (tree);\n void cgraph_finalize_compilation_unit (void);\n+void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n void cgraph_mark_address_taken_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n@@ -449,6 +462,8 @@ struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree);\n bool cgraph_process_new_functions (void);\n \n+bool cgraph_decide_is_function_needed (struct cgraph_node *, tree);\n+\n typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);\n typedef void (*cgraph_node_hook)(struct cgraph_node *, void *);\n typedef void (*cgraph_2edge_hook)(struct cgraph_edge *, struct cgraph_edge *,\n@@ -476,6 +491,7 @@ void cgraph_materialize_all_clones (void);\n \n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n+void reset_inline_failed (struct cgraph_node *);\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n \n /* In ipa.c  */\n@@ -560,6 +576,22 @@ unsigned int compute_inline_parameters (struct cgraph_node *);\n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n \n+/* lto-cgraph.c */\n+\n+enum LTO_cgraph_tags\n+{\n+  /* Must leave 0 for the stopper.  */\n+  LTO_cgraph_avail_node = 1,\n+  LTO_cgraph_overwritable_node,\n+  LTO_cgraph_unavail_node,\n+  LTO_cgraph_edge,\n+  LTO_cgraph_last_tag\n+};\n+\n+extern const char * LTO_cgraph_tag_names[LTO_cgraph_last_tag];\n+\n+#define LCC_NOT_FOUND\t(-1)\n+\n \n /* Return true if iterator CSI points to nothing.  */\n static inline bool"}, {"sha": "d61def279ad44476ef37bec143c135055925bd08", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -78,6 +78,29 @@ record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n+/* Reset inlining information of all incoming call edges of NODE.  */\n+\n+void\n+reset_inline_failed (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      e->callee->global.inlined_to = NULL;\n+      if (!node->analyzed)\n+\te->inline_failed = CIF_BODY_NOT_AVAILABLE;\n+      else if (node->local.redefined_extern_inline)\n+\te->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n+      else if (!node->local.inlinable)\n+\te->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n+      else if (e->call_stmt_cannot_inline_p)\n+\te->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+      else\n+\te->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+    }\n+}\n+\n /* Computes the frequency of the call statement so that it can be stored in\n    cgraph_edge.  BB is the basic block of the call statement.  */\n int"}, {"sha": "9a4f63d3acac60215d0d51f6db00b5ffe4624602", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -140,7 +140,6 @@ static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static void cgraph_output_pending_asms (void);\n-static void cgraph_optimize (void);\n static void cgraph_analyze_function (struct cgraph_node *);\n \n static FILE *cgraph_dump_file;\n@@ -314,8 +313,8 @@ cgraph_build_cdtor_fns (void)\n    either outside this translation unit, something magic in the system\n    configury.  */\n \n-static bool\n-decide_is_function_needed (struct cgraph_node *node, tree decl)\n+bool\n+cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n   if (MAIN_NAME_P (DECL_NAME (decl))\n       && TREE_PUBLIC (decl))\n@@ -522,7 +521,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   node->finalized_by_frontend = true;\n   record_cdtor_fn (node->decl);\n \n-  if (decide_is_function_needed (node, decl))\n+  if (cgraph_decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n \n   /* Since we reclaim unreachable nodes at the end of every language\n@@ -551,7 +550,7 @@ void\n cgraph_mark_if_needed (tree decl)\n {\n   struct cgraph_node *node = cgraph_node (decl);\n-  if (node->local.finalized && decide_is_function_needed (node, decl))\n+  if (node->local.finalized && cgraph_decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n }\n \n@@ -692,7 +691,8 @@ verify_cgraph_node (struct cgraph_node *node)\n \n   if (node->analyzed && gimple_has_body_p (node->decl)\n       && !TREE_ASM_WRITTEN (node->decl)\n-      && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n+      && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n+      && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n \t{\n@@ -949,8 +949,8 @@ cgraph_analyze_functions (void)\n \t  continue;\n \t}\n \n-      gcc_assert (!node->analyzed && node->reachable);\n-      cgraph_analyze_function (node);\n+      if (!node->analyzed)\n+\tcgraph_analyze_function (node);\n \n       for (edge = node->callees; edge; edge = edge->next_callee)\n \tif (!edge->callee->reachable)\n@@ -1355,23 +1355,39 @@ ipa_passes (void)\n   current_function_decl = NULL;\n   gimple_register_cfg_hooks ();\n   bitmap_obstack_initialize (NULL);\n-  execute_ipa_pass_list (all_ipa_passes);\n+  execute_ipa_pass_list (all_small_ipa_passes);\n \n-  /* Generate coverage variables and constructors.  */\n-  coverage_finish ();\n+  /* If pass_all_early_optimizations was not scheduled, the state of\n+     the cgraph will not be properly updated.  Update it now.  */\n+  if (cgraph_state < CGRAPH_STATE_IPA_SSA)\n+    cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n-  /* Process new functions added.  */\n-  set_cfun (NULL);\n-  current_function_decl = NULL;\n-  cgraph_process_new_functions ();\n+  if (!in_lto_p)\n+    {\n+      /* Generate coverage variables and constructors.  */\n+      coverage_finish ();\n+\n+      /* Process new functions added.  */\n+      set_cfun (NULL);\n+      current_function_decl = NULL;\n+      cgraph_process_new_functions ();\n+    }\n+\n+  execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n+  execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_lto_gen_passes);\n+\n+  if (!in_lto_p)\n+    ipa_write_summaries ();\n+\n+  execute_ipa_pass_list (all_regular_ipa_passes);\n \n   bitmap_obstack_release (NULL);\n }\n \n \n /* Perform simple optimizations based on callgraph.  */\n \n-static void\n+void\n cgraph_optimize (void)\n {\n   if (errorcount || sorrycount)\n@@ -1598,7 +1614,8 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n       also cloned.  */\n    for (e = old_version->callees;e; e=e->next_callee)\n      {\n-       new_e = cgraph_clone_edge (e, new_version, e->call_stmt, 0, e->frequency,\n+       new_e = cgraph_clone_edge (e, new_version, e->call_stmt,\n+\t\t\t\t  e->lto_stmt_uid, 0, e->frequency,\n \t\t\t\t  e->loop_nest, true);\n        new_e->count = e->count;\n      }"}, {"sha": "20caa451f89ce8fc15f6b80c5f0ee6ca9446da9b", "filename": "gcc/collect2.c", "status": "modified", "additions": 390, "deletions": 11, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -184,6 +184,15 @@ static int aix64_flag;\t\t\t/* true if -b64 */\n static int aixrtl_flag;\t\t\t/* true if -brtl */\n #endif\n \n+enum lto_mode_d {\n+  LTO_MODE_NONE,\t\t\t/* Not doing LTO.  */\n+  LTO_MODE_LTO,\t\t\t\t/* Normal LTO.  */\n+  LTO_MODE_WHOPR\t\t\t/* WHOPR.  */\n+};\n+\n+/* Current LTO mode.  */\n+static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n+\n int debug;\t\t\t\t/* true if -debug */\n \n static int shared_obj;\t\t\t/* true if -shared */\n@@ -193,6 +202,7 @@ static const char *o_file;\t\t/* <xxx>.o for constructor/destructor list.  */\n #ifdef COLLECT_EXPORT_LIST\n static const char *export_file;\t\t/* <xxx>.x for AIX export list.  */\n #endif\n+static char **lto_o_files;\t\t/* Output files for LTO.  */\n const char *ldout;\t\t\t/* File for ld stdout.  */\n const char *lderrout;\t\t\t/* File for ld stderr.  */\n static const char *output_file;\t\t/* Output file for ld.  */\n@@ -250,6 +260,25 @@ static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n \t\t\t\t\t  &libpath_lib_dirs, NULL};\n #endif\n \n+/* List of names of object files containing LTO information.\n+   These are a subset of the object file names appearing on the\n+   command line, and must be identical, in the sense of pointer\n+   equality, with the names passed to maybe_run_lto_and_relink().  */\n+\n+struct lto_object\n+{\n+  const char *name;\t\t/* Name of object file.  */\n+  struct lto_object *next;\t/* Next in linked list.  */\n+};\n+\n+struct lto_object_list\n+{\n+  struct lto_object *first;\t/* First list element.  */\n+  struct lto_object *last;\t/* Last list element.  */\n+};\n+\n+static struct lto_object_list lto_objects;\n+\n /* Special kinds of symbols that a name may denote.  */\n \n typedef enum {\n@@ -272,6 +301,7 @@ static void prefix_from_string (const char *, struct path_prefix *);\n static void do_wait (const char *, struct pex_obj *);\n static void fork_execute (const char *, char **);\n static void maybe_unlink (const char *);\n+static void maybe_unlink_list (char **);\n static void add_to_list (struct head *, const char *);\n static int extract_init_priority (const char *);\n static void sort_ids (struct head *);\n@@ -310,7 +340,8 @@ typedef enum {\n   PASS_FIRST,\t\t\t\t/* without constructors */\n   PASS_OBJ,\t\t\t\t/* individual objects */\n   PASS_LIB,\t\t\t\t/* looking for shared libraries */\n-  PASS_SECOND\t\t\t\t/* with constructors linked in */\n+  PASS_SECOND,\t\t\t\t/* with constructors linked in */\n+  PASS_LTOINFO\t\t\t\t/* looking for objects with LTO info */\n } scanpass;\n \n /* ... and which kinds of symbols are to be considered.  */\n@@ -363,6 +394,9 @@ collect_exit (int status)\n     maybe_unlink (export_file);\n #endif\n \n+  if (lto_o_files)\n+    maybe_unlink_list (lto_o_files);\n+\n   if (ldout != 0 && ldout[0])\n     {\n       dump_file (ldout, stdout);\n@@ -472,6 +506,9 @@ handler (int signo)\n     maybe_unlink (export_file);\n #endif\n \n+  if (lto_o_files)\n+    maybe_unlink_list (lto_o_files);\n+\n   if (response_file)\n     maybe_unlink (response_file);\n \n@@ -815,6 +852,244 @@ prefix_from_string (const char *p, struct path_prefix *pprefix)\n     }\n   free (nstore);\n }\n+\n+/* Add an entry for the object file NAME to object file list LIST.\n+   New entries are added at the end of the list. The original pointer\n+   value of NAME is preserved, i.e., no string copy is performed.  */\n+\n+static void\n+add_lto_object (struct lto_object_list *list, const char *name)\n+{\n+  struct lto_object *n = XNEW (struct lto_object);\n+  n->name = name;\n+  n->next = NULL;\n+\n+  if (list->last)\n+    list->last->next = n;\n+  else\n+    list->first = n;\n+\n+  list->last = n;\n+}\n+\n+\n+/* Perform a link-time recompilation and relink if any of the object\n+   files contain LTO info.  The linker command line LTO_LD_ARGV\n+   represents the linker command that would produce a final executable\n+   without the use of LTO. OBJECT_LST is a vector of object file names\n+   appearing in LTO_LD_ARGV that are to be considerd for link-time\n+   recompilation, where OBJECT is a pointer to the last valid element.\n+   (This awkward convention avoids an impedance mismatch with the\n+   usage of similarly-named variables in main().)  The elements of\n+   OBJECT_LST must be identical, i.e., pointer equal, to the\n+   corresponding arguments in LTO_LD_ARGV.\n+\n+   Upon entry, at least one linker run has been performed without the\n+   use of any LTO info that might be present.  Any recompilations\n+   necessary for template instantiations have been performed, and\n+   initializer/finalizer tables have been created if needed and\n+   included in the linker command line LTO_LD_ARGV. If any of the\n+   object files contain LTO info, we run the LTO back end on all such\n+   files, and perform the final link with the LTO back end output\n+   substituted for the LTO-optimized files.  In some cases, a final\n+   link with all link-time generated code has already been performed,\n+   so there is no need to relink if no LTO info is found.  In other\n+   cases, our caller has not produced the final executable, and is\n+   relying on us to perform the required link whether LTO info is\n+   present or not.  In that case, the FORCE argument should be true.\n+   Note that the linker command line argument LTO_LD_ARGV passed into\n+   this function may be modified in place.  */\n+\n+static void\n+maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n+\t\t\t  const char **object, bool force)\n+{\n+  const char **object_file = CONST_CAST2 (const char **, char **, object_lst);\n+\n+  int num_lto_c_args = 1;    /* Allow space for the terminating NULL.  */\n+\n+  while (object_file < object)\n+  {\n+    /* If file contains LTO info, add it to the list of LTO objects.  */\n+    scan_prog_file (*object_file++, PASS_LTOINFO, SCAN_ALL);\n+\n+    /* Increment the argument count by the number of object file arguments\n+       we will add.  An upper bound suffices, so just count all of the\n+       object files regardless of whether they contain LTO info.  */\n+    num_lto_c_args++;\n+  }\n+\n+  if (lto_objects.first)\n+    {\n+      const char *opts;\n+      char **lto_c_argv;\n+      const char **lto_c_ptr;\n+      const char *cp;\n+      const char **p, **q, **r;\n+      const char **lto_o_ptr;\n+      struct lto_object *list;\n+      char *lto_wrapper = getenv (\"COLLECT_LTO_WRAPPER\");\n+      struct pex_obj *pex;\n+      const char *prog = \"lto-wrapper\";\n+\n+      if (!lto_wrapper)\n+\tfatal (\"COLLECT_LTO_WRAPPER must be set.\");\n+\n+      /* There is at least one object file containing LTO info,\n+         so we need to run the LTO back end and relink.  */\n+\n+      /* Get compiler options passed down from the parent `gcc' command.\n+         These must be passed to the LTO back end.  */\n+      opts = getenv (\"COLLECT_GCC_OPTIONS\");\n+\n+      /* Increment the argument count by the number of inherited options.\n+         Some arguments may be filtered out later.  Again, an upper bound\n+         suffices.  */\n+\n+      cp = opts;\n+\n+      while (cp && *cp)\n+        {\n+          extract_string (&cp);\n+          num_lto_c_args++;\n+        }\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+\n+      if (debug)\n+\tnum_lto_c_args++;\n+\n+      /* Increment the argument count by the number of initial\n+\t arguments added below.  */\n+      num_lto_c_args += 9;\n+\n+      lto_c_argv = (char **) xcalloc (sizeof (char *), num_lto_c_args);\n+      lto_c_ptr = CONST_CAST2 (const char **, char **, lto_c_argv);\n+\n+      *lto_c_ptr++ = lto_wrapper;\n+      *lto_c_ptr++ = c_file_name;\n+\n+      cp = opts;\n+\n+      while (cp && *cp)\n+        {\n+          const char *s = extract_string (&cp);\n+\n+\t  /* Pass the option or argument to the wrapper.  */\n+\t  *lto_c_ptr++ = xstrdup (s);\n+        }\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+\n+      if (debug)\n+\t*lto_c_ptr++ = xstrdup (\"-debug\");\n+\n+      /* Add LTO objects to the wrapper command line.  */\n+      for (list = lto_objects.first; list; list = list->next)\n+\t*lto_c_ptr++ = list->name;\n+\n+      *lto_c_ptr = NULL;\n+\n+      /* Save intermediate WPA files in lto1 if debug.  */\n+      if (debug)\n+\tputenv (xstrdup (\"WPA_SAVE_LTRANS=1\"));\n+\n+      /* Run the LTO back end.  */\n+      pex = collect_execute (prog, lto_c_argv, NULL, NULL, PEX_SEARCH);\n+      {\n+\tint c;\n+\tFILE *stream;\n+\tsize_t i, num_files;\n+\tchar *start, *end;\n+\n+\tstream = pex_read_output (pex, 0);\n+\tgcc_assert (stream);\n+\n+\tnum_files = 0;\n+\twhile ((c = getc (stream)) != EOF)\n+\t  {\n+\t    obstack_1grow (&temporary_obstack, c);\n+\t    if (c == '\\n')\n+\t      ++num_files;\n+\t  }\n+\n+\tlto_o_files = XNEWVEC (char *, num_files + 1);\n+\tlto_o_files[num_files] = NULL;\n+\tstart = XOBFINISH (&temporary_obstack, char *);\n+\tfor (i = 0; i < num_files; ++i)\n+\t  {\n+\t    end = start;\n+\t    while (*end != '\\n')\n+\t      ++end;\n+\t    *end = '\\0';\n+\n+\t    lto_o_files[i] = xstrdup (start);\n+\n+\t    start = end + 1;\n+\t  }\n+\n+\tobstack_free (&temporary_obstack, temporary_firstobj);\n+      }\n+      do_wait (prog, pex);\n+      pex = NULL;\n+\n+      /* After running the LTO back end, we will relink, substituting\n+\t the LTO output for the object files that we submitted to the\n+\t LTO. Here, we modify the linker command line for the relink.  */\n+      p = CONST_CAST2 (const char **, char **, lto_ld_argv);\n+      lto_o_ptr = CONST_CAST2 (const char **, char **, lto_o_files);\n+\n+      while (*p != NULL)\n+        {\n+          for (list = lto_objects.first; list; list = list->next)\n+            {\n+              if (*p == list->name) /* Note test for pointer equality!  */\n+                {\n+                  /* Excise argument from linker command line.  */\n+                  if (*lto_o_ptr)\n+                    {\n+                      /* Replace first argument with LTO output file.  */\n+                      *p++ = *lto_o_ptr++;\n+                    }\n+                  else\n+                    {\n+                      /* Move following arguments one position earlier,\n+                         overwriting the current argument.  */\n+                      q = p;\n+                      r = p + 1;\n+                      while (*r != NULL)\n+                        *q++ = *r++;\n+                      *q = NULL;\n+                    }\n+\n+                  /* No need to continue searching the LTO object list.  */\n+                  break;\n+                }\n+            }\n+\n+          /* If we didn't find a match, move on to the next argument.\n+             Otherwise, P has been set to the correct argument position\n+             at which to continue.  */\n+          if (!list) ++p;\n+        }\n+\n+      /* The code above assumes we will never have more lto output files than\n+\t input files.  Otherwise, we need to resize lto_ld_argv.  Check this\n+\t assumption.  */\n+      if (*lto_o_ptr)\n+\tfatal (\"too many lto output files\");\n+\n+      /* Run the linker again, this time replacing the object files\n+         optimized by the LTO with the temporary file generated by the LTO.  */\n+      fork_execute (\"ld\", lto_ld_argv);\n+\n+      maybe_unlink_list (lto_o_files);\n+    }\n+  else if (force)\n+    {\n+      /* Our caller is relying on us to do the link\n+         even though there is no LTO back end work to be done.  */\n+      fork_execute  (\"ld\", lto_ld_argv);\n+    }\n+}\n \f\n /* Main program.  */\n \n@@ -935,14 +1210,25 @@ main (int argc, char **argv)\n \n   /* Parse command line early for instances of -debug.  This allows\n      the debug flag to be set before functions like find_a_file()\n-     are called.  */\n+     are called.  We also look for the -flto or -fwhopr flag to know\n+     what LTO mode we are in.  */\n   {\n     int i;\n+    bool use_plugin = false;\n \n     for (i = 1; argv[i] != NULL; i ++)\n       {\n \tif (! strcmp (argv[i], \"-debug\"))\n \t  debug = 1;\n+        else if (! strcmp (argv[i], \"-flto\") && ! use_plugin)\n+          lto_mode = LTO_MODE_LTO;\n+        else if (! strcmp (argv[i], \"-fwhopr\") && ! use_plugin)\n+          lto_mode = LTO_MODE_WHOPR;\n+        else if (! strcmp (argv[i], \"-plugin\"))\n+\t  {\n+\t    use_plugin = true;\n+\t    lto_mode = LTO_MODE_NONE;\n+\t  }\n #ifdef COLLECT_EXPORT_LIST\n \t/* since -brtl, -bexport, -b64 are not position dependent\n \t   also check for them here */\n@@ -1194,6 +1480,20 @@ main (int argc, char **argv)\n \t\t}\n \t      break;\n \n+            case 'f':\n+\t      if (strcmp (arg, \"-flto\") == 0 || strcmp (arg, \"-fwhopr\") == 0)\n+\t\t{\n+#ifdef ENABLE_LTO\n+\t\t  /* Do not pass LTO flag to the linker. */\n+\t\t  ld1--;\n+\t\t  ld2--;\n+#else\n+\t\t  error (\"LTO support has not been enabled in this \"\n+\t\t\t \"configuration\");\n+#endif\n+\t\t}\n+              break;\n+\n \t    case 'l':\n \t      if (first_file)\n \t\t{\n@@ -1456,6 +1756,9 @@ main (int argc, char **argv)\n \tif (export_file != 0 && export_file[0])\n \t  maybe_unlink (export_file);\n #endif\n+\tif (lto_mode)\n+\t  maybe_run_lto_and_relink (ld1_argv, object_lst, object, false);\n+\n \tmaybe_unlink (c_file);\n \tmaybe_unlink (o_file);\n \treturn 0;\n@@ -1498,6 +1801,9 @@ main (int argc, char **argv)\n       if (ld1_filter == SCAN_NOTHING)\n \tdo_tlink (ld1_argv, object_lst);\n \n+      if (lto_mode)\n+        maybe_run_lto_and_relink (ld1_argv, object_lst, object, false);\n+\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n@@ -1591,9 +1897,15 @@ main (int argc, char **argv)\n #ifdef COLLECT_EXPORT_LIST\n   /* On AIX we must call tlink because of possible templates resolution.  */\n   do_tlink (ld2_argv, object_lst);\n+\n+  if (lto_mode)\n+    maybe_run_lto_and_relink (ld2_argv, object_lst, object, false);\n #else\n   /* Otherwise, simply call ld because tlink is already done.  */\n-  fork_execute (\"ld\", ld2_argv);\n+  if (lto_mode)\n+    maybe_run_lto_and_relink (ld2_argv, object_lst, object, true);\n+  else\n+    fork_execute (\"ld\", ld2_argv);\n \n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n      constructors/destructors in shared libraries.  */\n@@ -1661,7 +1973,7 @@ do_wait (const char *prog, struct pex_obj *pex)\n \n struct pex_obj *\n collect_execute (const char *prog, char **argv, const char *outname,\n-\t\t const char *errname)\n+\t\t const char *errname, int flags)\n {\n   struct pex_obj *pex;\n   const char *errmsg;\n@@ -1737,7 +2049,7 @@ collect_execute (const char *prog, char **argv, const char *outname,\n   if (pex == NULL)\n     fatal_perror (\"pex_init failed\");\n \n-  errmsg = pex_run (pex, PEX_LAST | PEX_SEARCH, argv[0], argv, outname,\n+  errmsg = pex_run (pex, flags, argv[0], argv, outname,\n \t\t    errname, &err);\n   if (errmsg != NULL)\n     {\n@@ -1761,7 +2073,7 @@ fork_execute (const char *prog, char **argv)\n {\n   struct pex_obj *pex;\n \n-  pex = collect_execute (prog, argv, NULL, NULL);\n+  pex = collect_execute (prog, argv, NULL, NULL, PEX_LAST | PEX_SEARCH);\n   do_wait (prog, pex);\n }\n \f\n@@ -1776,6 +2088,17 @@ maybe_unlink (const char *file)\n     notice (\"[Leaving %s]\\n\", file);\n }\n \n+/* Call maybe_unlink on the NULL-terminated list, FILE_LIST.  */\n+\n+static void\n+maybe_unlink_list (char **file_list)\n+{\n+  char **tmp = file_list;\n+\n+  while (*tmp)\n+    maybe_unlink (*(tmp++));\n+}\n+\n \f\n static long sequence_number = 0;\n \n@@ -2170,6 +2493,25 @@ write_aix_file (FILE *stream, struct id *list)\n \f\n #ifdef OBJECT_FORMAT_NONE\n \n+/* Check to make sure the file is an ELF file.  LTO objects must\n+   be in ELF format.  */\n+\n+static bool\n+is_elf (const char *prog_name)\n+{\n+  FILE *f;\n+  char buf[4];\n+  static char magic[4] = { 0x7f, 'E', 'L', 'F' };\n+\n+  f = fopen (prog_name, \"r\");\n+  if (f == NULL)\n+    return false;\n+  if (fread (buf, sizeof (buf), 1, f) != 1)\n+    buf[0] = 0;\n+  fclose (f);\n+  return memcmp (buf, magic, sizeof (magic)) == 0;\n+}\n+\n /* Generic version to scan the name list of the loaded program for\n    the symbols g++ uses for static constructors and destructors.  */\n \n@@ -2189,10 +2531,17 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   int err;\n   char *p, buf[1024];\n   FILE *inf;\n+  int found_lto = 0;\n \n   if (which_pass == PASS_SECOND)\n     return;\n \n+  /* LTO objects must be in ELF format.  This check prevents\n+     us from accepting an archive containing LTO objects, which\n+     gcc cannnot currently handle.  */\n+  if (which_pass == PASS_LTOINFO && !is_elf (prog_name))\n+    return;\n+\n   /* If we do not have an `nm', complain.  */\n   if (nm_file_name == 0)\n     fatal (\"cannot find 'nm'\");\n@@ -2223,7 +2572,8 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   if (pex == NULL)\n     fatal_perror (\"pex_init failed\");\n \n-  errmsg = pex_run (pex, 0, nm_file_name, real_nm_argv, NULL, NULL, &err);\n+  errmsg = pex_run (pex, 0, nm_file_name, real_nm_argv, NULL, HOST_BIT_BUCKET,\n+\t\t    &err);\n   if (errmsg != NULL)\n     {\n       if (err != 0)\n@@ -2245,14 +2595,46 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n     fatal_perror (\"can't open nm output\");\n \n   if (debug)\n-    fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n+    {\n+      if (which_pass == PASS_LTOINFO)\n+        fprintf (stderr, \"\\nnm output with LTO info marker symbol.\\n\");\n+      else\n+        fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n+    }\n \n   /* Read each line of nm output.  */\n   while (fgets (buf, sizeof buf, inf) != (char *) 0)\n     {\n       int ch, ch2;\n       char *name, *end;\n \n+      if (debug)\n+        fprintf (stderr, \"\\t%s\\n\", buf);\n+\n+      if (which_pass == PASS_LTOINFO)\n+        {\n+          if (found_lto)\n+            continue;\n+\n+          /* Look for the LTO info marker symbol, and add filename to\n+             the LTO objects list if found.  */\n+          for (p = buf; (ch = *p) != '\\0' && ch != '\\n'; p++)\n+            if (ch == ' '\n+\t\t&& (strncmp (p +1 , \"gnu_lto_v1\", 10) == 0)\n+\t\t&& ISSPACE( p[11]))\n+              {\n+                add_lto_object (&lto_objects, prog_name);\n+\n+                /* We need to read all the input, so we can't just\n+                   return here.  But we can avoid useless work.  */\n+                found_lto = 1;\n+\n+                break;\n+              }\n+\n+\t  continue;\n+        }\n+\n       /* If it contains a constructor or destructor name, add the name\n \t to the appropriate list unless this is a kind of symbol we're\n \t not supposed to even consider.  */\n@@ -2319,9 +2701,6 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \tdefault:\t\t/* not a constructor or destructor */\n \t  continue;\n \t}\n-\n-      if (debug)\n-\tfprintf (stderr, \"\\t%s\\n\", buf);\n     }\n \n   if (debug)"}, {"sha": "81113cfb68b9b047c8c3119388c957066598bb05", "filename": "gcc/collect2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n extern void do_tlink (char **, char **);\n \n extern struct pex_obj *collect_execute (const char *, char **, const char *,\n-\t\t\t\t\tconst char *);\n+\t\t\t\t\tconst char *, int flags);\n \n extern void collect_exit (int) ATTRIBUTE_NORETURN;\n "}, {"sha": "de43201a4b206a9cc2e1d5d46396df748f7066dd", "filename": "gcc/common.opt", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -749,6 +749,19 @@ floop-optimize\n Common\n Does nothing.  Preserved for backward compatibility.\n \n+flto\n+Common Var(flag_lto)\n+Enable link-time optimization.\n+\n+; The initial value of -1 comes from Z_DEFAULT_COMPRESSION in zlib.h.\n+flto-compression-level=\n+Common Joined UInteger Var(flag_lto_compression_level) Init(-1)\n+-flto-compression-level=<number> Use zlib compression level <number> for IL\n+\n+flto-report\n+Common Report Var(flag_lto_report) Init(0) Optimization\n+Report various link-time optimization statistics\n+\n fmath-errno\n Common Report Var(flag_errno_math) Init(1) Optimization\n Set errno after built-in math functions\n@@ -1432,6 +1445,10 @@ fweb\n Common Report Var(flag_web) Init(2) Optimization\n Construct webs and split unrelated uses of single variable\n \n+fwhopr\n+Common Var(flag_whopr)\n+Enable partitioned link-time optimization.\n+\n ftree-builtin-call-dce\n Common Report Var(flag_tree_builtin_call_dce) Init(0) Optimization\n Enable conditional dead code elimination for builtin calls"}, {"sha": "220ff9f2ae2fc01efefb207d3e177c189f68bbc6", "filename": "gcc/config.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -113,6 +113,12 @@\n #endif\n \n \n+/* Define to enable LTO support. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_LTO\n+#endif\n+\n+\n /* Define to 1 if translation of program messages to the user's native\n    language is requested. */\n #ifndef USED_FOR_TARGET\n@@ -1453,6 +1459,12 @@\n #endif\n \n \n+/* Define if libelf is in use. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_libelf\n+#endif\n+\n+\n /* Define if mpc is in use. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_mpc"}, {"sha": "f44bc992a481ce76b7e753dbe9ef0048f7c742ed", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -20052,8 +20052,10 @@ rs6000_output_function_epilogue (FILE *file,\n \t use language_string.\n \t C is 0.  Fortran is 1.  Pascal is 2.  Ada is 3.  C++ is 9.\n \t Java is 13.  Objective-C is 14.  Objective-C++ isn't assigned\n-\t a number, so for now use 9.  */\n-      if (! strcmp (language_string, \"GNU C\"))\n+\t a number, so for now use 9.  LTO isn't assigned a number either,\n+\t so for now use 0.  */\n+      if (! strcmp (language_string, \"GNU C\")\n+\t  || ! strcmp (language_string, \"GNU GIMPLE\"))\n \ti = 0;\n       else if (! strcmp (language_string, \"GNU F77\")\n \t       || ! strcmp (language_string, \"GNU Fortran\"))"}, {"sha": "e4f3c2e0acdf483217cf2e2f2ea6f1b433d7cf3c", "filename": "gcc/configure", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -741,6 +741,8 @@ ac_subst_vars='LTLIBOBJS\n LIBOBJS\n enable_plugin\n pluginlibs\n+LIBELFINC\n+LIBELFLIBS\n CLOOGINC\n CLOOGLIBS\n PPLINC\n@@ -808,6 +810,7 @@ subdirs\n slibdir\n dollar\n gcc_tooldir\n+enable_lto\n MAINT\n zlibinc\n zlibdir\n@@ -1061,7 +1064,9 @@ GMPINC\n PPLLIBS\n PPLINC\n CLOOGLIBS\n-CLOOGINC'\n+CLOOGINC\n+LIBELFLIBS\n+LIBELFINC'\n \n \n # Initialize some variables set by options.\n@@ -1799,6 +1804,8 @@ Some influential environment variables:\n   PPLINC      How to find PPL include files\n   CLOOGLIBS   How to link CLOOG\n   CLOOGINC    How to find CLOOG include files\n+  LIBELFLIBS  How to link libelf\n+  LIBELFINC   How to find libelf include files\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -11565,13 +11572,13 @@ if test \"${lt_cv_nm_interface+set}\" = set; then :\n else\n   lt_cv_nm_interface=\"BSD nm\"\n   echo \"int some_variable = 0;\" > conftest.$ac_ext\n-  (eval echo \"\\\"\\$as_me:11568: $ac_compile\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:11575: $ac_compile\\\"\" >&5)\n   (eval \"$ac_compile\" 2>conftest.err)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:11571: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:11578: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n   (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:11574: output\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:11581: output\\\"\" >&5)\n   cat conftest.out >&5\n   if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n     lt_cv_nm_interface=\"MS dumpbin\"\n@@ -12776,7 +12783,7 @@ ia64-*-hpux*)\n   ;;\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 12779 \"configure\"' > conftest.$ac_ext\n+  echo '#line 12786 \"configure\"' > conftest.$ac_ext\n   if { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_compile\\\"\"; } >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -14436,11 +14443,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:14439: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:14446: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:14443: \\$? = $ac_status\" >&5\n+   echo \"$as_me:14450: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -14775,11 +14782,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:14778: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:14785: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:14782: \\$? = $ac_status\" >&5\n+   echo \"$as_me:14789: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -14880,11 +14887,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:14883: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:14890: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:14887: \\$? = $ac_status\" >&5\n+   echo \"$as_me:14894: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -14935,11 +14942,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:14938: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:14945: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:14942: \\$? = $ac_status\" >&5\n+   echo \"$as_me:14949: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -17317,7 +17324,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17320 \"configure\"\n+#line 17327 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -17413,7 +17420,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17416 \"configure\"\n+#line 17423 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19369,11 +19376,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:19372: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:19379: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:19376: \\$? = $ac_status\" >&5\n+   echo \"$as_me:19383: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -19468,11 +19475,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:19471: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:19478: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:19475: \\$? = $ac_status\" >&5\n+   echo \"$as_me:19482: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -19520,11 +19527,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:19523: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:19530: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:19527: \\$? = $ac_status\" >&5\n+   echo \"$as_me:19534: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -24760,6 +24767,16 @@ do\n \tall_compilers=\"$all_compilers $compilers\"\n \tall_outputs=\"$all_outputs $outputs\"\n \tall_gtfiles=\"$all_gtfiles [$subdir] $gtfiles\"\n+        case \",$enable_languages,\" in\n+        \t*,lto,*)\n+\n+$as_echo \"#define ENABLE_LTO 1\" >>confdefs.h\n+\n+\t\t    enable_lto=yes\n+\n+\t\t    ;;\n+\t\t*) ;;\n+\tesac\n done\n \n # Pick up gtfiles for c\n@@ -24941,6 +24958,14 @@ $as_echo \"#define HAVE_cloog 1\" >>confdefs.h\n \n fi\n \n+\n+\n+if test \"x${LIBELFLIBS}\" != \"x\" ; then\n+\n+$as_echo \"#define HAVE_libelf 1\" >>confdefs.h\n+\n+fi\n+\n # Check for plugin support\n # Check whether --enable-plugin was given.\n if test \"${enable_plugin+set}\" = set; then :"}, {"sha": "79de6cd7964b7cd0277af606243ea8b693c3b03d", "filename": "gcc/configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -4041,6 +4041,14 @@ changequote([,])dnl\n \tall_compilers=\"$all_compilers $compilers\"\n \tall_outputs=\"$all_outputs $outputs\"\n \tall_gtfiles=\"$all_gtfiles [[$subdir]] $gtfiles\"\n+        case \",$enable_languages,\" in\n+        \t*,lto,*)\n+\t\t    AC_DEFINE(ENABLE_LTO, 1, [Define to enable LTO support.])\n+\t\t    enable_lto=yes\n+\t\t    AC_SUBST(enable_lto)\n+\t\t    ;;\n+\t\t*) ;;\n+\tesac\n done\n \n # Pick up gtfiles for c\n@@ -4213,6 +4221,12 @@ if test \"x${CLOOGLIBS}\" != \"x\" ; then\n    AC_DEFINE(HAVE_cloog, 1, [Define if cloog is in use.])\n fi\n \n+AC_ARG_VAR(LIBELFLIBS,[How to link libelf])\n+AC_ARG_VAR(LIBELFINC,[How to find libelf include files])\n+if test \"x${LIBELFLIBS}\" != \"x\" ; then \n+   AC_DEFINE(HAVE_libelf, 1, [Define if libelf is in use.])\n+fi\n+\n # Check for plugin support\n AC_ARG_ENABLE(plugin,\n [  --enable-plugin         enable plugin support],"}, {"sha": "6bf446b32fbe5e86dc0e834bfce001683d452080", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -356,6 +356,15 @@ Alternatively, if an MPC source distribution is found in a\n subdirectory of your GCC sources named @file{mpc}, it will be built\n together with GCC@.\n \n+@item libelf version 0.8.12 (or later)\n+\n+Necessary to build link-time optimization (LTO) support.  It can be\n+downloaded from @uref{http://www.mr511.de/software/libelf-0.8.12.tar.gz},\n+though it is commonly available in several systems.\n+\n+The @option{--with-libelf} configure option should be used if libelf is\n+not installed in your default library search patch.\n+\n @end table\n \n @heading Tools/packages necessary for modifying GCC\n@@ -1893,6 +1902,30 @@ Use the @code{WCHAR} and Win32 W functions natively.  Does @emph{not}\n add @code{-lunicows} to @file{libgcj.spec}.  The built executables will\n only run on Microsoft Windows NT and above.\n @end table\n+\n+@item --enable-lto\n+Enable support for link-time optimization (LTO).  This is enabled by\n+default if a working libelf implementation is found (see\n+@option{--with-libelf}).\n+\n+@item --with-libelf=@var{pathname}\n+@itemx --with-libelf-include=@var{pathname}\n+@itemx --with-libelf-lib=@var{pathname}\n+If you do not have libelf installed in a standard location and you\n+want to enable support for link-time optimization (LTO), you can\n+explicitly specify the directory where libelf is installed\n+(@samp{--with-libelf=@var{libelfinstalldir}}).  The\n+@option{--with-libelf=@var{libelfinstalldir}} option is shorthand for\n+@option{--with-libelf-include=@var{libelfinstalldir}/include}\n+@option{--with-libelf-lib=@var{libelfinstalldir}/lib}.\n+\n+@item --enable-gold\n+Enable support for using @command{gold} as the linker.  If gold support is\n+enabled together with @option{--enable-lto}, an additional directory\n+@file{lto-plugin} will be built.  The code in this directory is a\n+plugin for gold that allows the link-time optimizer to extract object\n+files with LTO information out of library archives.  See\n+@option{-flto} and @option{-fwhopr} for details.\n @end table\n \n @subsubheading AWT-Specific Options"}, {"sha": "9d39624ad9f80f5e128dc3b637ec347de34e8cda", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 220, "deletions": 3, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -349,8 +349,8 @@ Objective-C and Objective-C++ Dialects}.\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -floop-block -floop-interchange -floop-strip-mine -fgraphite-identity @gol\n--floop-parallelize-all @gol\n--fmerge-all-constants -fmerge-constants -fmodulo-sched @gol\n+-floop-parallelize-all -flto -flto-compression-level -flto-report -fltrans @gol\n+-fltrans-output-list -fmerge-all-constants -fmerge-constants -fmodulo-sched @gol\n -fmodulo-sched-allow-regmoves -fmove-loop-invariants -fmudflap @gol\n -fmudflapir -fmudflapth -fno-branch-count-reg -fno-default-inline @gol\n -fno-defer-pop -fno-function-cse -fno-guess-branch-probability @gol\n@@ -389,7 +389,7 @@ Objective-C and Objective-C++ Dialects}.\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n -fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol\n--fwhole-program @gol\n+-fwhole-program -fwhopr -fwpa -use-linker-plugin @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -7111,6 +7111,223 @@ compilation unit, not for the single source file itself.\n \n This option implies @option{-fwhole-file} for Fortran programs.\n \n+@item -flto\n+@opindex flto\n+This option runs the standard link-time optimizer.  When invoked\n+with source code, it generates GIMPLE (one of GCC's internal\n+representations) and writes it to special ELF sections in the object\n+file.  When the object files are linked together, all the function\n+bodies are read from these ELF sections and instantiated as if they\n+had been part of the same translation unit.\n+\n+To use the link-timer optimizer, @option{-flto} needs to be specified at\n+compile time and during the final link.  For example,\n+\n+@smallexample\n+gcc -c -O2 -flto foo.c\n+gcc -c -O2 -flto bar.c\n+gcc -o myprog -flto -O2 foo.o bar.o\n+@end smallexample\n+\n+The first two invocations to GCC will save a bytecode representation\n+of GIMPLE into special ELF sections inside @file{foo.o} and\n+@file{bar.o}.  The final invocation will read the GIMPLE bytecode from\n+@file{foo.o} and @file{bar.o}, merge the two files into a single\n+internal image, and compile the result as usual.  Since both\n+@file{foo.o} and @file{bar.o} are merged into a single image, this\n+causes all the inter-procedural analyses and optimizations in GCC to\n+work across the two files as if they were a single one.  This means,\n+for example, that the inliner will be able to inline functions in\n+@file{bar.o} into functions in @file{foo.o} and vice-versa.\n+\n+Another (simpler) way to enable link-time optimization is,\n+\n+@smallexample\n+gcc -o myprog -flto -O2 foo.c bar.c\n+@end smallexample\n+\n+The above will generate bytecode for @file{foo.c} and @file{bar.c},\n+merge them together into a single GIMPLE representation and optimize\n+them as usual to produce @file{myprog}.\n+\n+The only important thing to keep in mind is that to enable link-time\n+optimizations the @option{-flto} flag needs to be passed to both the\n+compile and the link commands.\n+\n+Note that when a file is compiled with @option{-flto}, the generated\n+object file will be larger than a regular object file because it will\n+contain GIMPLE bytecodes and the usual final code.  This means that\n+object files with LTO information can be linked as a normal object\n+file.  So, in the previous example, if the final link is done with\n+\n+@smallexample\n+gcc -o myprog foo.o bar.o\n+@end smallexample\n+\n+The only difference will be that no inter-procedural optimizations\n+will be applied to produce @file{myprog}.  The two object files\n+@file{foo.o} and @file{bar.o} will be simply sent to the regular\n+linker.\n+\n+Additionally, the optimization flags used to compile individual files\n+are not necessarily related to those used at link-time.  For instance,\n+\n+@smallexample\n+gcc -c -O0 -flto foo.c\n+gcc -c -O0 -flto bar.c\n+gcc -o myprog -flto -O3 foo.o bar.o\n+@end smallexample\n+\n+This will produce individual object files with unoptimized assembler\n+code, but the resulting binary @file{myprog} will be optimized at\n+@option{-O3}.  Now, if the final binary is generated without\n+@option{-flto}, then @file{myprog} will not be optimized.\n+\n+When producing the final binary with @option{-flto}, GCC will only\n+apply link-time optimizations to those files that contain bytecode.\n+Therefore, you can mix and match object files and libraries with\n+GIMPLE bytecodes and final object code.  GCC will automatically select\n+which files to optimize in LTO mode and which files to link without\n+further processing.\n+\n+There are some code generation flags that GCC will preserve when\n+generating bytecodes, as they need to be used during the final link\n+stage.  Currently, the following options are saved into the GIMPLE\n+bytecode files: @option{-fPIC}, @option{-fcommon} and all the\n+@option{-m} target flags.\n+\n+At link time, these options are read-in and reapplied.  Note that the\n+current implementation makes no attempt at recognizing conflicting\n+values for these options.  If two or more files have a conflicting\n+value (e.g., one file is compiled with @option{-fPIC} and another\n+isn't), the compiler will simply use the last value read from the\n+bytecode files.  It is recommended, then, that all the files\n+participating in the same link be compiled with the same options.\n+\n+Another feature of LTO is that it is possible to apply interprocedural\n+optimizations on files written in different languages.  This requires\n+some support in the language front end.  Currently, the C, C++ and\n+Fortran front ends are capable of emitting GIMPLE bytecodes, so\n+something like this should work\n+\n+@smallexample\n+gcc -c -flto foo.c\n+g++ -c -flto bar.cc\n+gfortran -c -flto baz.f90\n+g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran\n+@end smallexample\n+\n+Notice that the final link is done with @command{g++} to get the C++\n+runtime libraries and @option{-lgfortran} is added to get the Fortran\n+runtime libraries.  In general, when mixing languages in LTO mode, you\n+should use the same link command used when mixing languages in a\n+regular (non-LTO) compilation.  This means that if your build process\n+was mixing languages before, all you need to add is @option{-flto} to\n+all the compile and link commands.\n+\n+If object files containing GIMPLE bytecode are stored in a library\n+archive, say @file{libfoo.a}, it is possible to extract and use them\n+in an LTO link if you are using @command{gold} as the linker (which,\n+in turn requires GCC to be configured with @option{--enable-gold}).\n+To enable this feature, use the flag @option{-use-linker-plugin} at\n+link-time:\n+\n+@smallexample\n+gcc -o myprog -O2 -flto -use-linker-plugin a.o b.o -lfoo\n+@end smallexample\n+\n+With the linker plugin enabled, @command{gold} will extract the needed\n+GIMPLE files from @file{libfoo.a} and pass them on to the running GCC\n+to make them part of the aggregated GIMPLE image to be optimized.\n+\n+If you are not using @command{gold} and/or do not specify\n+@option{-use-linker-plugin} then the objects inside @file{libfoo.a}\n+will be extracted and linked as usual, but they will not participate\n+in the LTO optimization process.\n+\n+Regarding portability: the current implementation of LTO makes no\n+attempt at generating bytecode that can be ported between different\n+types of hosts.  The bytecode files are versioned and there is a\n+strict version check, so bytecode files generated in one version of\n+GCC will not work with an older/newer version of GCC.\n+\n+This option is disabled by default.\n+\n+@item -fwhopr\n+@opindex fwhopr\n+This option is identical in functionality to @option{-flto} but it\n+differs in how the final link stage is executed.  Instead of loading\n+all the function bodies in memory, the callgraph is analyzed and\n+optimization decisions are made (whole program analysis or WPA). Once\n+optimization decisions are made, the callgraph is partitioned and the\n+different sections are compiled separately (local transformations or\n+LTRANS)@.  This process allows optimizations on very large programs\n+that otherwise would not fit in memory.  This option enables\n+@option{-fwpa} and @option{-fltrans} automatically.\n+\n+Disabled by default.\n+\n+@item -fwpa\n+@opindex fwpa\n+This is an internal option used by GCC when compiling with\n+@option{-fwhopr}.  You should never need to use it.\n+\n+This option runs the link-time optimizer in the whole-program-analysis\n+(WPA) mode, which reads in summary information from all inputs and\n+performs a whole-program analysis based on summary information only.\n+It generates object files for subsequent runs of the link-time\n+optimizer where individual object files are optimized using both\n+summary information from the WPA mode and the actual function bodies.\n+It then drives the LTRANS phase.\n+\n+Disabled by default.\n+\n+@item -fltrans\n+@opindex fltrans\n+This is an internal option used by GCC when compiling with\n+@option{-fwhopr}.  You should never need to use it.\n+\n+This option runs the link-time optimizer in the local-transformation (LTRANS)\n+mode, which reads in output from a previous run of the LTO in WPA mode.\n+In the LTRANS mode, LTO optimizes an object and produces the final assembly.\n+\n+Disabled by default.\n+\n+@item -fltrans-output-list=@var{file}\n+@opindex fltrans-output-list\n+This is an internal option used by GCC when compiling with\n+@option{-fwhopr}.  You should never need to use it.\n+\n+This option specifies a file to which the names of LTRANS output files are\n+written.  This option is only meaningful in conjunction with @option{-fwpa}.\n+\n+Disabled by default.\n+\n+@item -flto-compression-level=@var{n}\n+This option specifies the level of compression used for intermediate\n+language written to LTO object files, and is only meaningful in\n+conjunction with LTO mode (@option{-fwhopr}, @option{-flto}).  Valid\n+values are 0 (no compression) to 9 (maximum compression).  Values\n+outside this range are clamped to either 0 or 9.  If the option is not\n+given, a default balanced compression setting is used.\n+\n+@item -flto-report\n+Prints a report with internal details on the workings of the link-time\n+optimizer.  The contents of this report vary from version to version,\n+it is meant to be useful to GCC developers when processing object\n+files in LTO mode (via @option{-fwhopr} or @option{-flto}).\n+\n+Disabled by default.\n+\n+@item -use-linker-plugin\n+Enables the extraction of objects with GIMPLE bytecode information\n+from library archives.  This option relies on features available only\n+in @command{gold}, so to use this you must configure GCC with\n+@option{--enable-gold}.  See @option{-flto} for a description on the\n+effect of this flag and how to use it.\n+\n+Disabled by default.\n+\n @item -fcprop-registers\n @opindex fcprop-registers\n After register allocation and post-register allocation instruction splitting,"}, {"sha": "4cbc36f14a36849fae1047a9cdeff3a96be4785c", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -93,12 +93,16 @@ The Objective-C and Objective-C++ runtime library.\n @item libstdc++-v3\n The C++ runtime library.\n \n+@item lto-plugin\n+Plugin used by @command{gold} if link-time optimizations are enabled.\n+\n @item maintainer-scripts\n Scripts used by the @code{gccadmin} account on @code{gcc.gnu.org}.\n \n @item zlib\n-The @code{zlib} compression library, used by the Java front end and as\n-part of the Java runtime library.\n+The @code{zlib} compression library, used by the Java front end, as\n+part of the Java runtime library, and for compressing and uncompressing\n+GCC's intermediate language in LTO object files.\n @end table\n \n The build system in the top level directory, including how recursion\n@@ -137,11 +141,12 @@ The @file{gcc} directory contains the following subdirectories:\n @item @var{language}\n Subdirectories for various languages.  Directories containing a file\n @file{config-lang.in} are language subdirectories.  The contents of\n-the subdirectories @file{cp} (for C++), @file{objc} (for Objective-C)\n-and @file{objcp} (for Objective-C++) are documented in this manual\n-(@pxref{Passes, , Passes and Files of the Compiler}); those for other\n-languages are not.  @xref{Front End, , Anatomy of a Language Front End},\n-for details of the files in these directories.\n+the subdirectories @file{cp} (for C++), @file{lto} (for LTO),\n+@file{objc} (for Objective-C) and @file{objcp} (for Objective-C++) are\n+documented in this manual (@pxref{Passes, , Passes and Files of the\n+Compiler}); those for other languages are not.  @xref{Front End, ,\n+Anatomy of a Language Front End}, for details of the files in these\n+directories.\n \n @item config\n Configuration files for supported architectures and operating\n@@ -821,6 +826,7 @@ here; FIXME: document the others.\n * Ada Tests::       The Ada language testsuites.\n * C Tests::         The C language testsuites.\n * libgcj Tests::    The Java library testsuites.\n+* LTO Testing::     Support for testing link-time optimizations.\n * gcov Testing::    Support for testing gcov.\n * profopt Testing:: Support for testing profile-directed optimizations.\n * compat Testing::  Support for testing binary compatibility.\n@@ -1347,6 +1353,42 @@ bugs in libgcj that had caused Mauve test failures.\n \n We encourage developers to contribute test cases to Mauve.\n \n+@node LTO Testing\n+@subsection Support for testing link-time optimizations\n+\n+Tests for link-time optimizations usually require multiple source files\n+that are compiled separately, perhaps with different sets of options.\n+There are several special-purpose test directives used for these tests.\n+\n+@table @code\n+@item @{ dg-lto-do @var{do-what-keyword} @}\n+@var{do-what-keyword} specifies how the test is compiled and whether\n+it is executed.  It is one of:\n+\n+@table @code\n+@item assemble\n+Compile with @option{-c} to produce a relocatable object file.\n+@item link\n+Compile, assemble, and link to produce an executable file.\n+@item run\n+Produce and run an executable file, which is expected to return\n+an exit code of 0.\n+@end table\n+\n+The default is @code{assemble}.  That can be overridden for a set of\n+tests by redefining @code{dg-do-what-default} within the @code{.exp}\n+file for those tests.\n+\n+Unlike @code{dg-do}, @code{dg-lto-do} does not support an optional\n+@samp{target} or @samp{xfail} list.  Use @code{dg-skip-if},\n+@code{dg-xfail-if}, or @code{dg-xfail-run-if}.\n+\n+@item @{ dg-lto-options @{ @{ @var{options} @} [@{ @var{options} @}] @} [@{ target @var{selector} @}]@}\n+This directive provides a list of one or more sets of compiler options\n+to override @var{LTO_OPTIONS}.  Each test will be compiled and run with\n+each of these sets of options.\n+@end table\n+\n @node gcov Testing\n @subsection Support for testing @command{gcov}\n "}, {"sha": "c00bcd397bd63b86cf58b4e3bc18863ba36179fe", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -2886,7 +2886,14 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     {\n       struct varpool_node *node;\n \n-      type = lookup_type_for_runtime (type);\n+      /* FIXME lto.  pass_ipa_free_lang_data changes all types to\n+\t runtime types so TYPE should already be a runtime type\n+\t reference.  When pass_ipa_free_lang data is made a default\n+\t pass, we can then remove the call to lookup_type_for_runtime\n+\t below.  */\n+      if (TYPE_P (type))\n+\ttype = lookup_type_for_runtime (type);\n+\n       value = expand_expr (type, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n \n       /* Let cgraph know that the rtti decl is used.  Not all of the"}, {"sha": "bd8b82d43726454c193bc868681bbd11db23e926", "filename": "gcc/flags.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -111,6 +111,17 @@ extern int optimize;\n \n extern int optimize_size;\n \n+/* True if this is the LTO front end (lto1).  This is used to disable\n+   gimple generation and lowering passes that are normally run on the\n+   output of a front end.  These passes must be bypassed for lto since\n+   they have already been done before the gimple was written.  */ \n+\n+extern bool in_lto_p;\n+\n+/* Nonzero if we should write GIMPLE bytecode for link-time optimization.  */\n+\n+extern int flag_generate_lto;\n+\n /* Used to set the level of -Wstrict-aliasing, when no level is specified.  \n    The external way to set the default level is to use\n    -Wstrict-aliasing=level.  "}, {"sha": "c3444d4883134610a5803c8ac4398073b3088b60", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1,3 +1,7 @@\n+2009-10-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* options.c (gfc_post_options): Handle -flto and -fwhopr.\n+\n 2009-10-02  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/41479"}, {"sha": "d2c6d9ba8495aadc14516ddc21e5f7810955c2b9", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -242,6 +242,28 @@ gfc_post_options (const char **pfilename)\n   if (flag_whole_program)\n     gfc_option.flag_whole_file = 1;\n \n+  if (flag_lto || flag_whopr)\n+    {\n+#ifdef ENABLE_LTO\n+      flag_generate_lto = 1;\n+\n+      /* When generating IL, do not operate in whole-program mode.\n+\t Otherwise, symbols will be privatized too early, causing link\n+\t errors later.  */\n+      flag_whole_program = 0;\n+\n+      /* But do enable whole-file mode.  */\n+      gfc_option.flag_whole_file = 1;\n+#else\n+      error (\"LTO support has not been enabled in this configuration\");\n+#endif\n+    }\n+\n+  /* Reconcile -flto and -fwhopr.  Set additional flags as appropriate and\n+     check option consistency.  */\n+  if (flag_lto && flag_whopr)\n+    error (\"-flto and -fwhopr are mutually exclusive\");\n+\n   /* -fbounds-check is equivalent to -fcheck=bounds */\n   if (flag_bounds_check)\n     gfc_option.rtcheck |= GFC_RTCHECK_BOUNDS;"}, {"sha": "9be56f2cd024a73470ed4d7495d2495e08c81771", "filename": "gcc/gcc.c", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -764,10 +764,23 @@ proper position among the other output files.  */\n /* We want %{T*} after %{L*} and %D so that it can be used to specify linker\n    scripts which exist in user specified directories, or in standard\n    directories.  */\n+/* We pass any -flto and -fwhopr flags on to the linker, which is expected\n+   to understand them.  In practice, this means it had better be collect2.  */\n #ifndef LINK_COMMAND_SPEC\n #define LINK_COMMAND_SPEC \"\\\n %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\\\n-    %(linker) %l \" LINK_PIE_SPEC \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\\n+    %(linker) \\\n+    %{use-linker-plugin: \\\n+    -plugin %(linker_plugin_file) \\\n+    -plugin-opt=%(lto_wrapper) \\\n+    -plugin-opt=%(lto_gcc) \\\n+    %{static|static-libgcc:-plugin-opt=-pass-through=%(lto_libgcc)}\t\\\n+    %{O*:-plugin-opt=-O%*} \\\n+    %{w:-plugin-opt=-w} \\\n+    %{f*:-plugin-opt=-f%*} \\\n+    } \\\n+    %{flto} %{fwhopr} %l \" LINK_PIE_SPEC \\\n+   \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\\\n     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)} %(mflib)\\\n@@ -815,6 +828,10 @@ static const char *endfile_spec = ENDFILE_SPEC;\n static const char *startfile_spec = STARTFILE_SPEC;\n static const char *switches_need_spaces = SWITCHES_NEED_SPACES;\n static const char *linker_name_spec = LINKER_NAME;\n+static const char *linker_plugin_file_spec = \"\";\n+static const char *lto_wrapper_spec = \"\";\n+static const char *lto_gcc_spec = \"\";\n+static const char *lto_libgcc_spec = \"\";\n static const char *link_command_spec = LINK_COMMAND_SPEC;\n static const char *link_libgcc_spec = LINK_LIBGCC_SPEC;\n static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;\n@@ -891,11 +908,15 @@ static const char *asm_options =\n \n static const char *invoke_as =\n #ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT\n-\"%{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n- %{!S:-o %|.s |\\n as %(asm_options) %|.s %A }\";\n+\"%{!fwpa:\\\n+   %{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n+   %{!S:-o %|.s |\\n as %(asm_options) %|.s %A }\\\n+  }\";\n #else\n-\"%{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n- %{!S:-o %|.s |\\n as %(asm_options) %m.s %A }\";\n+\"%{!fwpa:\\\n+   %{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n+   %{!S:-o %|.s |\\n as %(asm_options) %m.s %A }\\\n+  }\";\n #endif\n \n /* Some compilers have limits on line lengths, and the multilib_select\n@@ -1653,6 +1674,10 @@ static struct spec_list static_specs[] =\n   INIT_STATIC_SPEC (\"multilib_exclusions\",\t&multilib_exclusions),\n   INIT_STATIC_SPEC (\"multilib_options\",\t\t&multilib_options),\n   INIT_STATIC_SPEC (\"linker\",\t\t\t&linker_name_spec),\n+  INIT_STATIC_SPEC (\"linker_plugin_file\",\t&linker_plugin_file_spec),\n+  INIT_STATIC_SPEC (\"lto_wrapper\",\t\t&lto_wrapper_spec),\n+  INIT_STATIC_SPEC (\"lto_gcc\",\t\t\t&lto_gcc_spec),\n+  INIT_STATIC_SPEC (\"lto_libgcc\",\t\t&lto_libgcc_spec),\n   INIT_STATIC_SPEC (\"link_libgcc\",\t\t&link_libgcc_spec),\n   INIT_STATIC_SPEC (\"md_exec_prefix\",\t\t&md_exec_prefix),\n   INIT_STATIC_SPEC (\"md_startfile_prefix\",\t&md_startfile_prefix),\n@@ -6834,14 +6859,6 @@ main (int argc, char **argv)\n     multilib_defaults = XOBFINISH (&multilib_obstack, const char *);\n   }\n \n-  /* Set up to remember the pathname of gcc and any options\n-     needed for collect.  We use argv[0] instead of programname because\n-     we need the complete pathname.  */\n-  obstack_init (&collect_obstack);\n-  obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\") - 1);\n-  obstack_grow (&collect_obstack, argv[0], strlen (argv[0]) + 1);\n-  xputenv (XOBFINISH (&collect_obstack, char *));\n-\n #ifdef INIT_ENVIRONMENT\n   /* Set up any other necessary machine specific environment variables.  */\n   xputenv (INIT_ENVIRONMENT);\n@@ -7055,6 +7072,27 @@ main (int argc, char **argv)\n      the subdirectory based on the options.  */\n   set_multilib_dir ();\n \n+  /* Set up to remember the pathname of gcc and any options\n+     needed for collect.  We use argv[0] instead of programname because\n+     we need the complete pathname.  */\n+  obstack_init (&collect_obstack);\n+  obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\") - 1);\n+  obstack_grow (&collect_obstack, argv[0], strlen (argv[0]) + 1);\n+  xputenv (XOBFINISH (&collect_obstack, char *));\n+\n+  /* Set up to remember the pathname of the lto wrapper. */\n+\n+  lto_wrapper_spec = find_a_file (&exec_prefixes, \"lto-wrapper\", X_OK, false);\n+  if (lto_wrapper_spec)\n+    {\n+      obstack_init (&collect_obstack);\n+      obstack_grow (&collect_obstack, \"COLLECT_LTO_WRAPPER=\",\n+\t\t    sizeof (\"COLLECT_LTO_WRAPPER=\") - 1);\n+      obstack_grow (&collect_obstack, lto_wrapper_spec,\n+\t\t    strlen (lto_wrapper_spec) + 1);\n+      xputenv (XOBFINISH (&collect_obstack, char *));\n+    }\n+\n   /* Warn about any switches that no pass was interested in.  */\n \n   for (i = 0; (int) i < n_switches; i++)\n@@ -7475,6 +7513,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n   if (num_linker_inputs > 0 && error_count == 0 && print_subprocess_help < 2)\n     {\n       int tmp = execution_count;\n+      const char *use_linker_plugin = \"use-linker-plugin\";\n \n       /* We'll use ld if we can't find collect2.  */\n       if (! strcmp (linker_name_spec, \"collect2\"))\n@@ -7483,6 +7522,23 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t  if (s == NULL)\n \t    linker_name_spec = \"ld\";\n \t}\n+\n+      if (switch_matches (use_linker_plugin,\n+\t\t\t  use_linker_plugin + strlen (use_linker_plugin), 0))\n+\t{\n+\t  linker_plugin_file_spec = find_a_file (&exec_prefixes,\n+\t\t\t\t\t\t \"liblto_plugin.so\", X_OK,\n+\t\t\t\t\t\t false);\n+\t  if (!linker_plugin_file_spec)\n+\t    fatal (\"-use-linker-plugin, but liblto_plugin.so not found.\");\n+\n+\t  lto_libgcc_spec = find_a_file (&startfile_prefixes, \"libgcc.a\",\n+\t\t\t\t\t R_OK, true);\n+\t  if (!lto_libgcc_spec)\n+\t    fatal (\"could not find libgcc.a.\");\n+\t}\n+      lto_gcc_spec = argv[0];\n+\n       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n \t for collect.  */\n       putenv_from_prefixes (&exec_prefixes, \"COMPILER_PATH\", false);"}, {"sha": "af54306e54a09b4fe6a21a100c1813b3b9a0925f", "filename": "gcc/gimple.c", "status": "modified", "additions": 1169, "deletions": 4, "changes": 1173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"target.h\"\n #include \"tree.h\"\n #include \"ggc.h\"\n #include \"hard-reg-set.h\"\n@@ -33,8 +34,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"value-prof.h\"\n #include \"flags.h\"\n+#include \"alias.h\"\n #include \"demangle.h\"\n \n+/* Global type table.  FIXME lto, it should be possible to re-use some\n+   of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n+   etc), but those assume that types were built with the various\n+   build_*_type routines which is not the case with the streamer.  */\n+static htab_t gimple_types;\n+static struct pointer_map_t *type_hash_cache;\n+\n+/* Global type comparison cache.  */\n+static htab_t gtc_visited;\n \n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n@@ -115,8 +126,7 @@ gimple_size (enum gimple_code code)\n /* Allocate memory for a GIMPLE statement with code CODE and NUM_OPS\n    operands.  */\n \n-#define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n-static gimple\n+gimple\n gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n {\n   size_t size;\n@@ -613,7 +623,7 @@ gimple_build_eh_must_not_throw (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (flags_from_decl_or_type (decl) & ECF_NORETURN);\n-  p->gimple_eh_mnt.fndecl = decl;\n+  gimple_eh_must_not_throw_set_fndecl (p, decl);\n \n   return p;\n }\n@@ -3000,6 +3010,1162 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n }\n \n \n+static hashval_t gimple_type_hash (const void *);\n+\n+/* Structure used to maintain a cache of some type pairs compared by\n+   gimple_types_compatible_p when comparing aggregate types.  There are\n+   four possible values for SAME_P:\n+\n+   \t-2: The pair (T1, T2) has just been inserted in the table.\n+\t-1: The pair (T1, T2) is currently being compared.\n+\t 0: T1 and T2 are different types.\n+\t 1: T1 and T2 are the same type.\n+\n+   This table is only used when comparing aggregate types to avoid\n+   infinite recursion due to self-referential types.  */\n+struct type_pair_d\n+{\n+  tree t1;\n+  tree t2;\n+  int same_p;\n+};\n+typedef struct type_pair_d *type_pair_t;\n+\n+/* Return a hash value for the type pair pointed-to by P.  */\n+\n+static hashval_t\n+type_pair_hash (const void *p)\n+{\n+  const struct type_pair_d *pair = (const struct type_pair_d *) p;\n+  hashval_t val1 = iterative_hash_hashval_t (htab_hash_pointer (pair->t1), 0);\n+  hashval_t val2 = iterative_hash_hashval_t (htab_hash_pointer (pair->t2), 0);\n+  return (iterative_hash_hashval_t (val2, val1)\n+\t  ^ iterative_hash_hashval_t (val1, val2));\n+}\n+\n+/* Compare two type pairs pointed-to by P1 and P2.  */\n+\n+static int\n+type_pair_eq (const void *p1, const void *p2)\n+{\n+  const struct type_pair_d *pair1 = (const struct type_pair_d *) p1;\n+  const struct type_pair_d *pair2 = (const struct type_pair_d *) p2;\n+  return ((pair1->t1 == pair2->t1 && pair1->t2 == pair2->t2)\n+\t  || (pair1->t1 == pair2->t2 && pair1->t2 == pair2->t1));\n+}\n+\n+/* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n+   entry if none existed.  */\n+\n+static type_pair_t\n+lookup_type_pair (tree t1, tree t2, htab_t *visited_p)\n+{\n+  struct type_pair_d pair;\n+  type_pair_t p;\n+  void **slot;\n+\n+  if (*visited_p == NULL)\n+    *visited_p = htab_create (251, type_pair_hash, type_pair_eq, free);\n+\n+  pair.t1 = t1;\n+  pair.t2 = t2;\n+  slot = htab_find_slot (*visited_p, &pair, INSERT);\n+\n+  if (*slot)\n+    p = *((type_pair_t *) slot);\n+  else\n+    {\n+      p = XNEW (struct type_pair_d);\n+      p->t1 = t1;\n+      p->t2 = t2;\n+      p->same_p = -2;\n+      *slot = (void *) p;\n+    }\n+\n+  return p;\n+}\n+\n+\n+/* Force merging the type T2 into the type T1.  */\n+\n+void\n+gimple_force_type_merge (tree t1, tree t2)\n+{\n+  void **slot;\n+  type_pair_t p;\n+\n+  /* There's no other way than copying t2 to t1 in this case.\n+     Yuck.  We'll just call this \"completing\" t1.  */\n+  memcpy (t1, t2, tree_size (t1));\n+\n+  /* Adjust the hash value of T1 if it was computed already.  Otherwise\n+     we would be forced to not hash fields of structs to match the\n+     hash value of an incomplete struct.  */\n+  if (type_hash_cache\n+      && (slot = pointer_map_contains (type_hash_cache, t1)) != NULL)\n+    {\n+      gimple_type_hash (t2);\n+      *slot = *pointer_map_contains (type_hash_cache, t2);\n+    }\n+\n+  /* Adjust cached comparison results for T1 and T2 to make sure\n+     they now compare compatible.  */\n+  p = lookup_type_pair (t1, t2, &gtc_visited);\n+  p->same_p = 1;\n+}\n+\n+\n+/* Return true if both types have the same name.  */\n+\n+static bool\n+compare_type_names_p (tree t1, tree t2)\n+{\n+  tree name1 = TYPE_NAME (t1);\n+  tree name2 = TYPE_NAME (t2);\n+\n+  /* Consider anonymous types all unique.  */\n+  if (!name1 || !name2)\n+    return false;\n+\n+  if (TREE_CODE (name1) == TYPE_DECL)\n+    {\n+      name1 = DECL_NAME (name1);\n+      if (!name1)\n+\treturn false;\n+    }\n+  gcc_assert (TREE_CODE (name1) == IDENTIFIER_NODE);\n+\n+  if (TREE_CODE (name2) == TYPE_DECL)\n+    {\n+      name2 = DECL_NAME (name2);\n+      if (!name2)\n+\treturn false;\n+    }\n+  gcc_assert (TREE_CODE (name2) == IDENTIFIER_NODE);\n+\n+  /* Identifiers can be compared with pointer equality rather\n+     than a string comparison.  */\n+  if (name1 == name2)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the field decls F1 and F2 are at the same offset.  */\n+\n+static bool\n+compare_field_offset (tree f1, tree f2)\n+{\n+  if (DECL_OFFSET_ALIGN (f1) == DECL_OFFSET_ALIGN (f2))\n+    return (operand_equal_p (DECL_FIELD_OFFSET (f1),\n+\t\t\t     DECL_FIELD_OFFSET (f2), 0)\n+\t    && tree_int_cst_equal (DECL_FIELD_BIT_OFFSET (f1),\n+\t\t\t\t   DECL_FIELD_BIT_OFFSET (f2)));\n+\n+  /* Fortran and C do not always agree on what DECL_OFFSET_ALIGN\n+     should be, so handle differing ones specially by decomposing\n+     the offset into a byte and bit offset manually.  */\n+  if (host_integerp (DECL_FIELD_OFFSET (f1), 0)\n+      && host_integerp (DECL_FIELD_OFFSET (f2), 0))\n+    {\n+      unsigned HOST_WIDE_INT byte_offset1, byte_offset2;\n+      unsigned HOST_WIDE_INT bit_offset1, bit_offset2;\n+      bit_offset1 = TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (f1));\n+      byte_offset1 = (TREE_INT_CST_LOW (DECL_FIELD_OFFSET (f1))\n+\t\t      + bit_offset1 / BITS_PER_UNIT);\n+      bit_offset2 = TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (f2));\n+      byte_offset2 = (TREE_INT_CST_LOW (DECL_FIELD_OFFSET (f2))\n+\t\t      + bit_offset2 / BITS_PER_UNIT);\n+      if (byte_offset1 != byte_offset2)\n+\treturn false;\n+      return bit_offset1 % BITS_PER_UNIT == bit_offset2 % BITS_PER_UNIT;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return 1 iff T1 and T2 are structurally identical.\n+   Otherwise, return 0.  */\n+\n+int\n+gimple_types_compatible_p (tree t1, tree t2)\n+{\n+  type_pair_t p = NULL;\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    goto same_types;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    goto different_types;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    goto different_types;\n+\n+  /* Void types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE)\n+    goto same_types;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    goto different_types;\n+\n+  /* If the hash values of t1 and t2 are different the types can't\n+     possibly be the same.  This helps keeping the type-pair hashtable\n+     small, only tracking comparisons for hash collisions.  */\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n+    return 0;\n+\n+  /* If we've visited this type pair before (in the case of aggregates\n+     with self-referential types), and we made a decision, return it.  */\n+  p = lookup_type_pair (t1, t2, &gtc_visited);\n+  if (p->same_p == 0 || p->same_p == 1)\n+    {\n+      /* We have already decided whether T1 and T2 are the\n+\t same, return the cached result.  */\n+      return p->same_p == 1;\n+    }\n+  else if (p->same_p == -1)\n+    {\n+      /* We are currently comparing this pair of types, assume\n+\t that they are the same and let the caller decide.  */\n+      return 1;\n+    }\n+\n+  gcc_assert (p->same_p == -2);\n+\n+  /* Mark the (T1, T2) comparison in progress.  */\n+  p->same_p = -1;\n+\n+  /* If their attributes are not the same they can't be the same type.  */\n+  if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n+    goto different_types;\n+\n+  /* For numerical types, the bounds must coincide.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different size, alignment,\n+\t sign, precision or mode.  Note that from now on, comparisons\n+\t between *_CST nodes must be done using tree_int_cst_equal because\n+\t we cannot assume that constants from T1 and T2 will be shared\n+\t since T1 and T2 are distinct pointers.  */\n+      if (!tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n+\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2))\n+\t  || TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\tgoto different_types;\n+\n+      /* For non-enumeral types, check type bounds.  FIXME lto, we\n+\t cannot check bounds on enumeral types because different front\n+\t ends will produce different values.  In C, enumeral types are\n+\t integers, while in C++ each element will have its own\n+\t symbolic value.  We should decide how enums are to be\n+\t represented in GIMPLE and have each front end lower to that.  */\n+      if (TREE_CODE (t1) != ENUMERAL_TYPE)\n+\t{\n+\t  tree min1 = TYPE_MIN_VALUE (t1);\n+\t  tree max1 = TYPE_MAX_VALUE (t1);\n+\t  tree min2 = TYPE_MIN_VALUE (t2);\n+\t  tree max2 = TYPE_MAX_VALUE (t2);\n+\t  bool min_equal_p = false;\n+\t  bool max_equal_p = false;\n+\n+\t  /* If either type has a minimum value, the other type must\n+\t     have the same.  */\n+\t  if (min1 == NULL_TREE && min2 == NULL_TREE)\n+\t    min_equal_p = true;\n+\t  else if (min1 && min2 && operand_equal_p (min1, min2, 0))\n+\t    min_equal_p = true;\n+\n+\t  /* Likewise, if either type has a maximum value, the other\n+\t     type must have the same.  */\n+\t  if (max1 == NULL_TREE && max2 == NULL_TREE)\n+\t    max_equal_p = true;\n+\t  else if (max1 && max2 && operand_equal_p (max1, max2, 0))\n+\t    max_equal_p = true;\n+\n+\t  if (!min_equal_p || !max_equal_p)\n+\t    goto different_types;\n+\t}\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE)\n+\t{\n+\t  if (TYPE_IS_SIZETYPE (t1) == TYPE_IS_SIZETYPE (t2)\n+\t      && TYPE_STRING_FLAG (t1) == TYPE_STRING_FLAG (t2))\n+\t    goto same_types;\n+\t  else\n+\t    goto different_types;\n+\t}\n+      else if (TREE_CODE (t1) == BOOLEAN_TYPE)\n+\tgoto same_types;\n+      else if (TREE_CODE (t1) == REAL_TYPE)\n+\tgoto same_types;\n+    }\n+\n+  /* Do type-specific comparisons.  */\n+  switch (TREE_CODE (t1))\n+    {\n+    case ARRAY_TYPE:\n+      /* Array types are the same if the element types are the same and\n+\t the number of elements are the same.  */\n+      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\tgoto different_types;\n+      else\n+\t{\n+\t  tree i1 = TYPE_DOMAIN (t1);\n+\t  tree i2 = TYPE_DOMAIN (t2);\n+\n+\t  /* For an incomplete external array, the type domain can be\n+ \t     NULL_TREE.  Check this condition also.  */\n+\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n+\t    goto same_types;\n+\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n+\t    goto different_types;\n+\t  /* If for a complete array type the possibly gimplified sizes\n+\t     are different the types are different.  */\n+\t  else if (((TYPE_SIZE (i1) != NULL) ^ (TYPE_SIZE (i2) != NULL))\n+\t\t   || (TYPE_SIZE (i1)\n+\t\t       && TYPE_SIZE (i2)\n+\t\t       && !operand_equal_p (TYPE_SIZE (i1), TYPE_SIZE (i2), 0)))\n+\t    goto different_types;\n+\t  else\n+\t    {\n+\t      tree min1 = TYPE_MIN_VALUE (i1);\n+\t      tree min2 = TYPE_MIN_VALUE (i2);\n+\t      tree max1 = TYPE_MAX_VALUE (i1);\n+\t      tree max2 = TYPE_MAX_VALUE (i2);\n+\n+\t      /* The minimum/maximum values have to be the same.  */\n+\t      if ((min1 == min2\n+\t\t   || (min1 && min2 && operand_equal_p (min1, min2, 0)))\n+\t\t  && (max1 == max2\n+\t\t      || (max1 && max2 && operand_equal_p (max1, max2, 0))))\n+\t\tgoto same_types;\n+\t      else\n+\t\tgoto different_types;\n+\t    }\n+\t}\n+\n+    case METHOD_TYPE:\n+      /* Method types should belong to the same class.  */\n+      if (!gimple_types_compatible_p (TYPE_METHOD_BASETYPE (t1),\n+\t\t\t\t TYPE_METHOD_BASETYPE (t2)))\n+\tgoto different_types;\n+\n+      /* Fallthru  */\n+\n+    case FUNCTION_TYPE:\n+      /* Function types are the same if the return type and arguments types\n+\t are the same.  */\n+      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tgoto different_types;\n+      else\n+\t{\n+\t  if (!targetm.comp_type_attributes (t1, t2))\n+\t    goto different_types;\n+\n+\t  if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\t    goto same_types;\n+\t  else\n+\t    {\n+\t      tree parms1, parms2;\n+\n+\t      for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t\t   parms1 && parms2;\n+\t\t   parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n+\t\t{\n+\t\t  if (!gimple_types_compatible_p (TREE_VALUE (parms1),\n+\t\t\t\t\t     TREE_VALUE (parms2)))\n+\t\t    goto different_types;\n+\t\t}\n+\n+\t      if (parms1 || parms2)\n+\t\tgoto different_types;\n+\n+\t      goto same_types;\n+\t    }\n+\t}\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+\t{\n+\t  /* If the two pointers have different ref-all attributes,\n+\t     they can't be the same type.  */\n+\t  if (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t    goto different_types;\n+\n+\t  /* If one pointer points to an incomplete type variant of\n+\t     the other pointed-to type they are the same.  */\n+\t  if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n+\t      && (!COMPLETE_TYPE_P (TREE_TYPE (t1))\n+\t\t  || !COMPLETE_TYPE_P (TREE_TYPE (t2)))\n+\t      && compare_type_names_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t    {\n+\t      /* If t2 is complete we want to choose it instead of t1.  */\n+\t      if (COMPLETE_TYPE_P (TREE_TYPE (t2)))\n+\t\tgimple_force_type_merge (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t      goto same_types;\n+\t    }\n+\n+\t  /* Otherwise, pointer and reference types are the same if the\n+\t     pointed-to types are the same.  */\n+\t  if (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t    goto same_types;\n+\t  \n+\t  goto different_types;\n+\t}\n+\n+    case ENUMERAL_TYPE:\n+\t{\n+\t  /* For enumeral types, all the values must be the same.  */\n+\t  tree v1, v2;\n+\n+\t  if (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n+\t    goto same_types;\n+\n+\t  for (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n+\t       v1 && v2;\n+\t       v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n+\t    {\n+\t      tree c1 = TREE_VALUE (v1);\n+\t      tree c2 = TREE_VALUE (v2);\n+\n+\t      if (TREE_CODE (c1) == CONST_DECL)\n+\t\tc1 = DECL_INITIAL (c1);\n+\n+\t      if (TREE_CODE (c2) == CONST_DECL)\n+\t\tc2 = DECL_INITIAL (c2);\n+\n+\t      if (tree_int_cst_equal (c1, c2) != 1)\n+\t\tgoto different_types;\n+\t    }\n+\n+\t  /* If one enumeration has more values than the other, they\n+\t     are not the same.  */\n+\t  if (v1 || v2)\n+\t    goto different_types;\n+\n+\t  goto same_types;\n+\t}\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+\t{\n+\t  /* For aggregate types, all the fields must be the same.  */\n+\t  tree f1, f2;\n+\n+\t  /* Compare every field.  */\n+\t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t       f1 && f2;\n+\t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t    {\n+\t      /* The fields must have the same name, offset and type.  */\n+\t      if (DECL_NAME (f1) != DECL_NAME (f2)\n+\t\t  || !compare_field_offset (f1, f2)\n+\t\t  || !gimple_types_compatible_p (TREE_TYPE (f1),\n+\t\t\t\t\t    TREE_TYPE (f2)))\n+\t\tgoto different_types;\n+\t    }\n+\n+\t  /* If one aggregate has more fields than the other, they\n+\t     are not the same.  */\n+\t  if (f1 || f2)\n+\t    goto different_types;\n+\n+\t  goto same_types;\n+\t}\n+\n+    case VECTOR_TYPE:\n+      if (TYPE_VECTOR_SUBPARTS (t1) != TYPE_VECTOR_SUBPARTS (t2))\n+\tgoto different_types;\n+\n+      /* Fallthru  */\n+    case COMPLEX_TYPE:\n+      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tgoto different_types;\n+      goto same_types;\n+\n+    default:\n+      goto different_types;\n+    }\n+\n+  /* Common exit path for types that are not compatible.  */\n+different_types:\n+  if (p)\n+    p->same_p = 0;\n+  return 0;\n+\n+  /* Common exit path for types that are compatible.  */\n+same_types:\n+  if (p)\n+    p->same_p = 1;\n+  return 1;\n+}\n+\n+\n+\n+\n+/* Per pointer state for the SCC finding.  The on_sccstack flag\n+   is not strictly required, it is true when there is no hash value\n+   recorded for the type and false otherwise.  But querying that\n+   is slower.  */\n+\n+struct sccs\n+{\n+  unsigned int dfsnum;\n+  unsigned int low;\n+  bool on_sccstack;\n+  hashval_t hash;\n+};\n+\n+static unsigned int next_dfs_num;\n+\n+static hashval_t\n+iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n+\t\t\t    struct pointer_map_t *, struct obstack *);\n+\n+/* DFS visit the edge from the callers type with state *STATE to T.\n+   Update the callers type hash V with the hash for T if it is not part\n+   of the SCC containing the callers type and return it.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n+\n+static hashval_t\n+visit (tree t, struct sccs *state, hashval_t v,\n+       VEC (tree, heap) **sccstack,\n+       struct pointer_map_t *sccstate,\n+       struct obstack *sccstate_obstack)\n+{\n+  struct sccs *cstate = NULL;\n+  void **slot;\n+\n+  /* If there is a hash value recorded for this type then it can't\n+     possibly be part of our parent SCC.  Simply mix in its hash.  */\n+  if ((slot = pointer_map_contains (type_hash_cache, t)))\n+    return iterative_hash_hashval_t ((hashval_t) (size_t) *slot, v);\n+\n+  if ((slot = pointer_map_contains (sccstate, t)) != NULL)\n+    cstate = (struct sccs *)*slot;\n+  if (!cstate)\n+    {\n+      hashval_t tem;\n+      /* Not yet visited.  DFS recurse.  */\n+      tem = iterative_hash_gimple_type (t, v,\n+\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n+      if (!cstate)\n+\tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n+      state->low = MIN (state->low, cstate->low);\n+      /* If the type is no longer on the SCC stack and thus is not part\n+         of the parents SCC mix in its hash value.  Otherwise we will\n+\t ignore the type for hashing purposes and return the unaltered\n+\t hash value.  */\n+      if (!cstate->on_sccstack)\n+\treturn tem;\n+    }\n+  if (cstate->dfsnum < state->dfsnum\n+      && cstate->on_sccstack)\n+    state->low = MIN (cstate->dfsnum, state->low);\n+\n+  /* We are part of our parents SCC, skip this type during hashing\n+     and return the unaltered hash value.  */\n+  return v;\n+}\n+\n+/* Hash the name of TYPE with the previous hash value V and return it.  */\n+\n+static hashval_t\n+iterative_hash_type_name (tree type, hashval_t v)\n+{\n+  tree name = TYPE_NAME (TYPE_MAIN_VARIANT (type));\n+  if (!name)\n+    return v;\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  if (!name)\n+    return v;\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  /* Do not hash names of anonymous unions.  At least the C++ FE insists\n+     to have a non-NULL TYPE_NAME for them.  See cp/cp-tree.h for all\n+     the glory.  */\n+#ifndef NO_DOT_IN_LABEL\n+  if (IDENTIFIER_POINTER (name)[0] == '.')\n+    return v;\n+#else\n+#ifndef NO_DOLLAR_IN_LABEL\n+  if (IDENTIFIER_POINTER (name)[0] == '$')\n+    return v;\n+#else\n+  if (!strncmp (IDENTIFIER_POINTER (name), \"__anon_\", sizeof (\"__anon_\") - 1))\n+    return v;\n+#endif\n+#endif\n+  return iterative_hash_object (IDENTIFIER_HASH_VALUE (name), v);\n+}\n+\n+/* Returning a hash value for gimple type TYPE combined with VAL.\n+   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.\n+\n+   To hash a type we end up hashing in types that are reachable.\n+   Through pointers we can end up with cycles which messes up the\n+   required property that we need to compute the same hash value\n+   for structurally equivalent types.  To avoid this we have to\n+   hash all types in a cycle (the SCC) in a commutative way.  The\n+   easiest way is to not mix in the hashes of the SCC members at\n+   all.  To make this work we have to delay setting the hash\n+   values of the SCC until it is complete.  */\n+\n+static hashval_t\n+iterative_hash_gimple_type (tree type, hashval_t val,\n+\t\t\t    VEC(tree, heap) **sccstack,\n+\t\t\t    struct pointer_map_t *sccstate,\n+\t\t\t    struct obstack *sccstate_obstack)\n+{\n+  hashval_t v;\n+  void **slot;\n+  struct sccs *state;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Not visited during this DFS walk nor during previous walks.  */\n+  gcc_assert (!pointer_map_contains (type_hash_cache, type)\n+\t      && !pointer_map_contains (sccstate, type));\n+#endif\n+  state = XOBNEW (sccstate_obstack, struct sccs);\n+  *pointer_map_insert (sccstate, type) = state;\n+\n+  VEC_safe_push (tree, heap, *sccstack, type);\n+  state->dfsnum = next_dfs_num++;\n+  state->low = state->dfsnum;\n+  state->on_sccstack = true;\n+\n+  /* Combine a few common features of types so that types are grouped into\n+     smaller sets; when searching for existing matching types to merge,\n+     only existing types having the same features as the new type will be\n+     checked.  */\n+  v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n+  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n+  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n+\n+  /* Do not hash the types size as this will cause differences in\n+     hash values for the complete vs. the incomplete type variant.  */\n+\n+  /* Incorporate common features of numerical types.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || FIXED_POINT_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n+      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  /* For pointer and reference types, fold in information about the type\n+     pointed to but do not recurse into possibly incomplete types to\n+     avoid hash differences for complete vs. incomplete types.  */\n+  if (POINTER_TYPE_P (type))\n+    {\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+\t  v = iterative_hash_type_name (type, v);\n+\t}\n+      else\n+\tv = visit (TREE_TYPE (type), state, v,\n+\t\t   sccstack, sccstate, sccstate_obstack);\n+    }\n+\n+  /* Recurse for aggregates with a single element.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    v = visit (TREE_TYPE (type), state, v,\n+\t       sccstack, sccstate, sccstate_obstack);\n+\n+  /* Incorporate function return and argument types.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      unsigned na;\n+      tree p;\n+\n+      /* For method types also incorporate their parent class.  */\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+\tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n+\t\t   sccstack, sccstate, sccstate_obstack);\n+\n+      v = visit (TREE_TYPE (type), state, v,\n+\t\t sccstack, sccstate, sccstate_obstack);\n+\n+      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n+\t{\n+\t  v = visit (TREE_VALUE (p), state, v,\n+\t\t     sccstack, sccstate, sccstate_obstack);\n+\t  na++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (na, v);\n+    }\n+\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      || TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      unsigned nf;\n+      tree f;\n+\n+      v = iterative_hash_type_name (type, v);\n+\n+      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\t{\n+\t  v = visit (TREE_TYPE (f), state, v,\n+\t\t     sccstack, sccstate, sccstate_obstack);\n+\t  nf++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (nf, v);\n+    }\n+\n+  /* Record hash for us.  */\n+  state->hash = v;\n+\n+  /* See if we found an SCC.  */\n+  if (state->low == state->dfsnum)\n+    {\n+      tree x;\n+\n+      /* Pop off the SCC and set its hash values.  */\n+      do\n+\t{\n+\t  struct sccs *cstate;\n+\t  x = VEC_pop (tree, *sccstack);\n+\t  gcc_assert (!pointer_map_contains (type_hash_cache, x));\n+\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n+\t  cstate->on_sccstack = false;\n+\t  slot = pointer_map_insert (type_hash_cache, x);\n+\t  *slot = (void *) (size_t) cstate->hash;\n+\t}\n+      while (x != type);\n+    }\n+\n+  return iterative_hash_hashval_t (v, val);\n+}\n+\n+\n+/* Returns a hash value for P (assumed to be a type).  The hash value\n+   is computed using some distinguishing features of the type.  Note\n+   that we cannot use pointer hashing here as we may be dealing with\n+   two distinct instances of the same type.\n+\n+   This function should produce the same hash value for two compatible\n+   types according to gimple_types_compatible_p.  */\n+\n+static hashval_t\n+gimple_type_hash (const void *p)\n+{\n+  VEC(tree, heap) *sccstack = NULL;\n+  struct pointer_map_t *sccstate;\n+  struct obstack sccstate_obstack;\n+  hashval_t val;\n+  void **slot;\n+\n+  if (type_hash_cache == NULL)\n+    type_hash_cache = pointer_map_create ();\n+\n+  if ((slot = pointer_map_contains (type_hash_cache, p)) != NULL)\n+    return iterative_hash_hashval_t ((hashval_t) (size_t) *slot, 0);\n+\n+  /* Perform a DFS walk and pre-hash all reachable types.  */\n+  next_dfs_num = 1;\n+  sccstate = pointer_map_create ();\n+  gcc_obstack_init (&sccstate_obstack);\n+  val = iterative_hash_gimple_type (CONST_CAST2 (tree, const void *, p), 0,\n+\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n+  VEC_free (tree, heap, sccstack);\n+  pointer_map_destroy (sccstate);\n+  obstack_free (&sccstate_obstack, NULL);\n+\n+  return val;\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+gimple_type_eq (const void *p1, const void *p2)\n+{\n+  const_tree t1 = (const_tree) p1;\n+  const_tree t2 = (const_tree) p2;\n+  return gimple_types_compatible_p (CONST_CAST_TREE (t1), CONST_CAST_TREE (t2));\n+}\n+\n+\n+/* Register type T in the global type table gimple_types.\n+   If another type T', compatible with T, already existed in\n+   gimple_types then return T', otherwise return T.  This is used by\n+   LTO to merge identical types read from different TUs.  */\n+\n+tree\n+gimple_register_type (tree t)\n+{\n+  void **slot;\n+\n+  gcc_assert (TYPE_P (t));\n+\n+  if (gimple_types == NULL)\n+    gimple_types = htab_create (16381, gimple_type_hash, gimple_type_eq, 0);\n+\n+  slot = htab_find_slot (gimple_types, t, INSERT);\n+  if (*slot\n+      && *(tree *)slot != t)\n+    {\n+      tree new_type = (tree) *((tree *) slot);\n+\n+      /* Do not merge types with different addressability.  */\n+      gcc_assert (TREE_ADDRESSABLE (t) == TREE_ADDRESSABLE (new_type));\n+\n+      /* If t is not its main variant then make t unreachable from its\n+\t main variant list.  Otherwise we'd queue up a lot of duplicates\n+\t there.  */\n+      if (t != TYPE_MAIN_VARIANT (t))\n+\t{\n+\t  tree tem = TYPE_MAIN_VARIANT (t);\n+\t  while (tem && TYPE_NEXT_VARIANT (tem) != t)\n+\t    tem = TYPE_NEXT_VARIANT (tem);\n+\t  if (tem)\n+\t    TYPE_NEXT_VARIANT (tem) = TYPE_NEXT_VARIANT (t);\n+\t  TYPE_NEXT_VARIANT (t) = NULL_TREE;\n+\t}\n+\n+      /* If we are a pointer then remove us from the pointer-to or\n+\t reference-to chain.  Otherwise we'd queue up a lot of duplicates\n+\t there.  */\n+      if (TREE_CODE (t) == POINTER_TYPE)\n+\t{\n+\t  if (TYPE_POINTER_TO (TREE_TYPE (t)) == t)\n+\t    TYPE_POINTER_TO (TREE_TYPE (t)) = TYPE_NEXT_PTR_TO (t);\n+\t  else\n+\t    {\n+\t      tree tem = TYPE_POINTER_TO (TREE_TYPE (t));\n+\t      while (tem && TYPE_NEXT_PTR_TO (tem) != t)\n+\t\ttem = TYPE_NEXT_PTR_TO (tem);\n+\t      if (tem)\n+\t\tTYPE_NEXT_PTR_TO (tem) = TYPE_NEXT_PTR_TO (t);\n+\t    }\n+\t  TYPE_NEXT_PTR_TO (t) = NULL_TREE;\n+\t}\n+      else if (TREE_CODE (t) == REFERENCE_TYPE)\n+\t{\n+\t  if (TYPE_REFERENCE_TO (TREE_TYPE (t)) == t)\n+\t    TYPE_REFERENCE_TO (TREE_TYPE (t)) = TYPE_NEXT_REF_TO (t);\n+\t  else\n+\t    {\n+\t      tree tem = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+\t      while (tem && TYPE_NEXT_REF_TO (tem) != t)\n+\t\ttem = TYPE_NEXT_REF_TO (tem);\n+\t      if (tem)\n+\t\tTYPE_NEXT_REF_TO (tem) = TYPE_NEXT_REF_TO (t);\n+\t    }\n+\t  TYPE_NEXT_REF_TO (t) = NULL_TREE;\n+\t}\n+\n+      t = new_type;\n+    }\n+  else\n+    *slot = (void *) t;\n+\n+  return t;\n+}\n+\n+\n+/* Show statistics on references to the global type table gimple_types.  */\n+\n+void\n+print_gimple_types_stats (void)\n+{\n+  if (gimple_types)\n+    fprintf (stderr, \"GIMPLE type table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (gimple_types),\n+\t     (long) htab_elements (gimple_types),\n+\t     (long) gimple_types->searches,\n+\t     (long) gimple_types->collisions,\n+\t     htab_collisions (gimple_types));\n+  else\n+    fprintf (stderr, \"GIMPLE type table is empty\\n\");\n+  if (gtc_visited)\n+    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (gtc_visited),\n+\t     (long) htab_elements (gtc_visited),\n+\t     (long) gtc_visited->searches,\n+\t     (long) gtc_visited->collisions,\n+\t     htab_collisions (gtc_visited));\n+  else\n+    fprintf (stderr, \"GIMPLE type comparison table is empty\\n\");\n+}\n+\n+\n+/* Return a type the same as TYPE except unsigned or\n+   signed according to UNSIGNEDP.  */\n+\n+static tree\n+gimple_signed_or_unsigned_type (bool unsignedp, tree type)\n+{\n+  tree type1;\n+\n+  type1 = TYPE_MAIN_VARIANT (type);\n+  if (type1 == signed_char_type_node\n+      || type1 == char_type_node\n+      || type1 == unsigned_char_type_node)\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+  if (type1 == integer_type_node || type1 == unsigned_type_node)\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+  if (type1 == short_integer_type_node || type1 == short_unsigned_type_node)\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+  if (type1 == long_integer_type_node || type1 == long_unsigned_type_node)\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+  if (type1 == long_long_integer_type_node\n+      || type1 == long_long_unsigned_type_node)\n+    return unsignedp\n+           ? long_long_unsigned_type_node\n+\t   : long_long_integer_type_node;\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  if (type1 == intTI_type_node || type1 == unsigned_intTI_type_node)\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+#endif\n+  if (type1 == intDI_type_node || type1 == unsigned_intDI_type_node)\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+  if (type1 == intSI_type_node || type1 == unsigned_intSI_type_node)\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+  if (type1 == intHI_type_node || type1 == unsigned_intHI_type_node)\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+  if (type1 == intQI_type_node || type1 == unsigned_intQI_type_node)\n+    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+\n+#define GIMPLE_FIXED_TYPES(NAME)\t    \\\n+  if (type1 == short_ ## NAME ## _type_node \\\n+      || type1 == unsigned_short_ ## NAME ## _type_node) \\\n+    return unsignedp ? unsigned_short_ ## NAME ## _type_node \\\n+\t\t     : short_ ## NAME ## _type_node; \\\n+  if (type1 == NAME ## _type_node \\\n+      || type1 == unsigned_ ## NAME ## _type_node) \\\n+    return unsignedp ? unsigned_ ## NAME ## _type_node \\\n+\t\t     : NAME ## _type_node; \\\n+  if (type1 == long_ ## NAME ## _type_node \\\n+      || type1 == unsigned_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? unsigned_long_ ## NAME ## _type_node \\\n+\t\t     : long_ ## NAME ## _type_node; \\\n+  if (type1 == long_long_ ## NAME ## _type_node \\\n+      || type1 == unsigned_long_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? unsigned_long_long_ ## NAME ## _type_node \\\n+\t\t     : long_long_ ## NAME ## _type_node;\n+\n+#define GIMPLE_FIXED_MODE_TYPES(NAME) \\\n+  if (type1 == NAME ## _type_node \\\n+      || type1 == u ## NAME ## _type_node) \\\n+    return unsignedp ? u ## NAME ## _type_node \\\n+\t\t     : NAME ## _type_node;\n+\n+#define GIMPLE_FIXED_TYPES_SAT(NAME) \\\n+  if (type1 == sat_ ## short_ ## NAME ## _type_node \\\n+      || type1 == sat_ ## unsigned_short_ ## NAME ## _type_node) \\\n+    return unsignedp ? sat_ ## unsigned_short_ ## NAME ## _type_node \\\n+\t\t     : sat_ ## short_ ## NAME ## _type_node; \\\n+  if (type1 == sat_ ## NAME ## _type_node \\\n+      || type1 == sat_ ## unsigned_ ## NAME ## _type_node) \\\n+    return unsignedp ? sat_ ## unsigned_ ## NAME ## _type_node \\\n+\t\t     : sat_ ## NAME ## _type_node; \\\n+  if (type1 == sat_ ## long_ ## NAME ## _type_node \\\n+      || type1 == sat_ ## unsigned_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? sat_ ## unsigned_long_ ## NAME ## _type_node \\\n+\t\t     : sat_ ## long_ ## NAME ## _type_node; \\\n+  if (type1 == sat_ ## long_long_ ## NAME ## _type_node \\\n+      || type1 == sat_ ## unsigned_long_long_ ## NAME ## _type_node) \\\n+    return unsignedp ? sat_ ## unsigned_long_long_ ## NAME ## _type_node \\\n+\t\t     : sat_ ## long_long_ ## NAME ## _type_node;\n+\n+#define GIMPLE_FIXED_MODE_TYPES_SAT(NAME)\t\\\n+  if (type1 == sat_ ## NAME ## _type_node \\\n+      || type1 == sat_ ## u ## NAME ## _type_node) \\\n+    return unsignedp ? sat_ ## u ## NAME ## _type_node \\\n+\t\t     : sat_ ## NAME ## _type_node;\n+\n+  GIMPLE_FIXED_TYPES (fract);\n+  GIMPLE_FIXED_TYPES_SAT (fract);\n+  GIMPLE_FIXED_TYPES (accum);\n+  GIMPLE_FIXED_TYPES_SAT (accum);\n+\n+  GIMPLE_FIXED_MODE_TYPES (qq);\n+  GIMPLE_FIXED_MODE_TYPES (hq);\n+  GIMPLE_FIXED_MODE_TYPES (sq);\n+  GIMPLE_FIXED_MODE_TYPES (dq);\n+  GIMPLE_FIXED_MODE_TYPES (tq);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (qq);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (hq);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (sq);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (dq);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (tq);\n+  GIMPLE_FIXED_MODE_TYPES (ha);\n+  GIMPLE_FIXED_MODE_TYPES (sa);\n+  GIMPLE_FIXED_MODE_TYPES (da);\n+  GIMPLE_FIXED_MODE_TYPES (ta);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (ha);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (sa);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (da);\n+  GIMPLE_FIXED_MODE_TYPES_SAT (ta);\n+\n+  /* For ENUMERAL_TYPEs in C++, must check the mode of the types, not\n+     the precision; they have precision set to match their range, but\n+     may use a wider mode to match an ABI.  If we change modes, we may\n+     wind up with bad conversions.  For INTEGER_TYPEs in C, must check\n+     the precision as well, so as to yield correct results for\n+     bit-field types.  C++ does not have these separate bit-field\n+     types, and producing a signed or unsigned variant of an\n+     ENUMERAL_TYPE may cause other problems as well.  */\n+  if (!INTEGRAL_TYPE_P (type)\n+      || TYPE_UNSIGNED (type) == unsignedp)\n+    return type;\n+\n+#define TYPE_OK(node)\t\t\t\t\t\t\t    \\\n+  (TYPE_MODE (type) == TYPE_MODE (node)\t\t\t\t\t    \\\n+   && TYPE_PRECISION (type) == TYPE_PRECISION (node))\n+  if (TYPE_OK (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+  if (TYPE_OK (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+  if (TYPE_OK (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+  if (TYPE_OK (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+  if (TYPE_OK (long_long_integer_type_node))\n+    return (unsignedp\n+\t    ? long_long_unsigned_type_node\n+\t    : long_long_integer_type_node);\n+\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  if (TYPE_OK (intTI_type_node))\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+#endif\n+  if (TYPE_OK (intDI_type_node))\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+  if (TYPE_OK (intSI_type_node))\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+  if (TYPE_OK (intHI_type_node))\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+  if (TYPE_OK (intQI_type_node))\n+    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+\n+#undef GIMPLE_FIXED_TYPES\n+#undef GIMPLE_FIXED_MODE_TYPES\n+#undef GIMPLE_FIXED_TYPES_SAT\n+#undef GIMPLE_FIXED_MODE_TYPES_SAT\n+#undef TYPE_OK\n+\n+  return build_nonstandard_integer_type (TYPE_PRECISION (type), unsignedp);\n+}\n+\n+\n+/* Return an unsigned type the same as TYPE in other respects.  */\n+\n+tree\n+gimple_unsigned_type (tree type)\n+{\n+  return gimple_signed_or_unsigned_type (true, type);\n+}\n+\n+\n+/* Return a signed type the same as TYPE in other respects.  */\n+\n+tree\n+gimple_signed_type (tree type)\n+{\n+  return gimple_signed_or_unsigned_type (false, type);\n+}\n+\n+\n+/* Return the typed-based alias set for T, which may be an expression\n+   or a type.  Return -1 if we don't do anything special.  */\n+\n+alias_set_type\n+gimple_get_alias_set (tree t)\n+{\n+  tree u;\n+\n+  /* Permit type-punning when accessing a union, provided the access\n+     is directly through the union.  For example, this code does not\n+     permit taking the address of a union member and then storing\n+     through it.  Even the type-punning allowed here is a GCC\n+     extension, albeit a common and useful one; the C standard says\n+     that such accesses have implementation-defined behavior.  */\n+  for (u = t;\n+       TREE_CODE (u) == COMPONENT_REF || TREE_CODE (u) == ARRAY_REF;\n+       u = TREE_OPERAND (u, 0))\n+    if (TREE_CODE (u) == COMPONENT_REF\n+\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (u, 0))) == UNION_TYPE)\n+      return 0;\n+\n+  /* That's all the expressions we handle specially.  */\n+  if (!TYPE_P (t))\n+    return -1;\n+\n+  /* For convenience, follow the C standard when dealing with\n+     character types.  Any object may be accessed via an lvalue that\n+     has character type.  */\n+  if (t == char_type_node\n+      || t == signed_char_type_node\n+      || t == unsigned_char_type_node)\n+    return 0;\n+\n+  /* Allow aliasing between signed and unsigned variants of the same\n+     type.  We treat the signed variant as canonical.  */\n+  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_UNSIGNED (t))\n+    {\n+      tree t1 = gimple_signed_type (t);\n+\n+      /* t1 == t can happen for boolean nodes which are always unsigned.  */\n+      if (t1 != t)\n+\treturn get_alias_set (t1);\n+    }\n+  else if (POINTER_TYPE_P (t))\n+    {\n+      tree t1;\n+\n+      /* Unfortunately, there is no canonical form of a pointer type.\n+\t In particular, if we have `typedef int I', then `int *', and\n+\t `I *' are different types.  So, we have to pick a canonical\n+\t representative.  We do this below.\n+\n+\t Technically, this approach is actually more conservative that\n+\t it needs to be.  In particular, `const int *' and `int *'\n+\t should be in different alias sets, according to the C and C++\n+\t standard, since their types are not the same, and so,\n+\t technically, an `int **' and `const int **' cannot point at\n+\t the same thing.\n+\n+\t But, the standard is wrong.  In particular, this code is\n+\t legal C++:\n+\n+\t int *ip;\n+\t int **ipp = &ip;\n+\t const int* const* cipp = ipp;\n+\t And, it doesn't make sense for that to be legal unless you\n+\t can dereference IPP and CIPP.  So, we ignore cv-qualifiers on\n+\t the pointed-to types.  This issue has been reported to the\n+\t C++ committee.  */\n+      t1 = build_type_no_quals (t);\n+      if (t1 != t)\n+\treturn get_alias_set (t1);\n+    }\n+\n+  return -1;\n+}\n+\n+\n /* Data structure used to count the number of dereferences to PTR\n    inside an expression.  */\n struct count_ptr_d\n@@ -3344,7 +4510,6 @@ gimple_decl_printable_name (tree decl, int verbosity)\n       if (verbosity >= 2)\n \t{\n \t  dmgl_opts = DMGL_VERBOSE\n-\t\t      | DMGL_TYPES\n \t\t      | DMGL_ANSI\n \t\t      | DMGL_GNU_V3\n \t\t      | DMGL_RET_POSTFIX;"}, {"sha": "e21d53fcb3cab868f57952e394d444f34b39afd0", "filename": "gcc/gimple.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -855,6 +855,8 @@ bool gimple_assign_rhs_could_trap_p (gimple);\n void gimple_regimplify_operands (gimple, gimple_stmt_iterator *);\n bool empty_body_p (gimple_seq);\n unsigned get_gimple_rhs_num_ops (enum tree_code);\n+#define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n+gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n tree gimple_fold_obj_type_ref (tree, tree);\n \n@@ -913,6 +915,13 @@ extern bool is_gimple_call_addr (tree);\n extern tree get_call_expr_in (tree t);\n \n extern void recalculate_side_effects (tree);\n+extern void gimple_force_type_merge (tree, tree);\n+extern int gimple_types_compatible_p (tree, tree);\n+extern tree gimple_register_type (tree);\n+extern void print_gimple_types_stats (void);\n+extern tree gimple_unsigned_type (tree);\n+extern tree gimple_signed_type (tree);\n+extern alias_set_type gimple_get_alias_set (tree);\n extern void count_uses_and_derefs (tree, gimple, unsigned *, unsigned *,\n \t\t\t\t   unsigned *);\n extern bool walk_stmt_load_store_addr_ops (gimple, void *,\n@@ -2912,6 +2921,16 @@ gimple_eh_must_not_throw_fndecl (gimple gs)\n   return gs->gimple_eh_mnt.fndecl;\n }\n \n+/* Set the function decl to be called by GS to DECL.  */\n+\n+static inline void\n+gimple_eh_must_not_throw_set_fndecl (gimple gs, tree decl)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_MUST_NOT_THROW);\n+  gs->gimple_eh_mnt.fndecl = decl;\n+}\n+\n+\n /* GIMPLE_TRY accessors. */\n \n /* Return the kind of try block represented by GIMPLE_TRY GS.  This is"}, {"sha": "a974dd0aab3f9f237d91ac9dfed91e042b34a11f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1273,7 +1273,13 @@ ipcp_generate_summary (void)\n static bool\n cgraph_gate_cp (void)\n {\n-  return flag_ipa_cp;\n+  /* FIXME lto.  IPA-CP does not tolerate running when the inlining decisions\n+     have not been applied.  This happens when WPA modifies the callgraph.\n+     Since those decisions are not applied until after all the IPA passes\n+     have been run in LTRANS, this means that IPA passes may see partially\n+     modified callgraphs.  The solution to this is to apply WPA decisions\n+     early during LTRANS.  */\n+  return flag_ipa_cp && !flag_ltrans;\n }\n \n struct ipa_opt_pass_d pass_ipa_cp ="}, {"sha": "0a02ae1770a39d146717b4e2d929b1c685d931c0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -326,7 +326,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n   struct cgraph_node *what = edge->callee;\n   struct cgraph_edge *e, *next;\n \n-  gcc_assert (!gimple_call_cannot_inline_p (edge->call_stmt));\n+  gcc_assert (!edge->call_stmt_cannot_inline_p);\n   /* Look for all calls, mark them inline and clone recursively\n      all inlined functions.  */\n   for (e = what->callers; e; e = next)\n@@ -1031,7 +1031,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       else\n \t{\n \t  struct cgraph_node *callee;\n-\t  if (gimple_call_cannot_inline_p (edge->call_stmt)\n+\t  if (edge->call_stmt_cannot_inline_p\n \t      || !cgraph_check_inline_limits (edge->caller, edge->callee,\n \t\t\t\t\t      &edge->inline_failed, true))\n \t    {\n@@ -1111,7 +1111,13 @@ cgraph_decide_inlining (void)\n   bool redo_always_inline = true;\n   int initial_size = 0;\n \n-  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  /* FIXME lto.  We need to rethink how to coordinate different passes. */\n+  if (flag_ltrans)\n+    return 0;\n+\n+  /* FIXME lto.  We need to re-think about how the passes get invoked. */\n+  if (!flag_wpa)\n+    cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n \n   max_count = 0;\n   max_benefit = 0;\n@@ -1121,15 +1127,16 @@ cgraph_decide_inlining (void)\n \tstruct cgraph_edge *e;\n \n \tgcc_assert (inline_summary (node)->self_size == node->global.size);\n-\tgcc_assert (node->needed || node->reachable);\n \tinitial_size += node->global.size;\n \tfor (e = node->callees; e; e = e->next_callee)\n \t  if (max_count < e->count)\n \t    max_count = e->count;\n \tif (max_benefit < inline_summary (node)->time_inlining_benefit)\n \t  max_benefit = inline_summary (node)->time_inlining_benefit;\n       }\n-  gcc_assert (!max_count || (profile_info && flag_branch_probabilities));\n+  gcc_assert (in_lto_p\n+\t      || !max_count\n+\t      || (profile_info && flag_branch_probabilities));\n   overall_size = initial_size;\n \n   nnodes = cgraph_postorder (order);\n@@ -1177,8 +1184,7 @@ cgraph_decide_inlining (void)\n \t  for (e = node->callers; e; e = next)\n \t    {\n \t      next = e->next_caller;\n-\t      if (!e->inline_failed\n-\t\t  || gimple_call_cannot_inline_p (e->call_stmt))\n+\t      if (!e->inline_failed || e->call_stmt_cannot_inline_p)\n \t\tcontinue;\n \t      if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t\t       &e->inline_failed))\n@@ -1225,7 +1231,7 @@ cgraph_decide_inlining (void)\n \t      && node->callers->inline_failed\n \t      && node->callers->caller != node\n \t      && node->callers->caller->global.inlined_to != node\n-\t      && !gimple_call_cannot_inline_p (node->callers->call_stmt)\n+\t      && !node->callers->call_stmt_cannot_inline_p\n \t      && !DECL_EXTERNAL (node->decl)\n \t      && !DECL_COMDAT (node->decl))\n \t    {\n@@ -1411,7 +1417,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \tif (!e->callee->local.disregard_inline_limits\n \t    && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \t  continue;\n-\tif (gimple_call_cannot_inline_p (e->call_stmt))\n+\tif (e->call_stmt_cannot_inline_p)\n \t  continue;\n \t/* When the edge is already inlined, we just need to recurse into\n \t   it in order to fully flatten the leaves.  */\n@@ -1529,7 +1535,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t  }\n \tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n \t\t\t\t         false)\n-\t    || gimple_call_cannot_inline_p (e->call_stmt))\n+\t    || e->call_stmt_cannot_inline_p)\n \t  {\n \t    if (dump_file)\n \t      {\n@@ -1632,6 +1638,7 @@ static bool\n cgraph_gate_ipa_early_inlining (void)\n {\n   return (flag_early_inlining\n+\t  && !in_lto_p\n \t  && (flag_branch_probabilities || flag_test_coverage\n \t      || profile_arc_flag));\n }\n@@ -1919,6 +1926,10 @@ inline_generate_summary (void)\n {\n   struct cgraph_node *node;\n \n+  /* FIXME lto.  We should not run any IPA-summary pass in LTRANS mode.  */\n+  if (flag_ltrans)\n+    return;\n+\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n "}, {"sha": "7ffb676d914fcc38aaf3b1ee16ac05be1b37b64c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1150,6 +1150,10 @@ bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n {\n+  /* FIXME lto: We do not stream out indirect call information.  */\n+  if (flag_wpa)\n+    return false;\n+\n   /* Do nothing if the preparation phase has not been carried out yet\n      (i.e. during early inlining).  */\n   if (!ipa_node_params_vector)"}, {"sha": "ea1d81ea5e244aa585839cde6bef7702934a46a6", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 138, "deletions": 8, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"lto-streamer.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n \n@@ -648,20 +649,35 @@ remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n }\n \n \f\n-/* Analyze each function in the cgraph to see if it is locally PURE or\n-   CONST.  */\n-\n-static void \n-generate_summary (void)\n+static void\n+register_hooks (void)\n {\n-  struct cgraph_node *node;\n+  static bool init_p = false;\n+\n+  if (init_p)\n+    return;\n+\n+  init_p = true;\n \n   node_removal_hook_holder =\n       cgraph_add_node_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n       cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+}\n+\n+\n+/* Analyze each function in the cgraph to see if it is locally PURE or\n+   CONST.  */\n+\n+static void \n+generate_summary (void)\n+{\n+  struct cgraph_node *node;\n+\n+  register_hooks ();\n+\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n@@ -682,6 +698,120 @@ generate_summary (void)\n   visited_nodes = NULL;\n }\n \n+\n+/* Serialize the ipa info for lto.  */\n+\n+static void\n+pure_const_write_summary (cgraph_node_set set)\n+{\n+  struct cgraph_node *node;\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_ipa_pure_const);\n+  unsigned int count = 0;\n+  cgraph_node_set_iterator csi;\n+\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (node->analyzed && get_function_state (node) != NULL)\n+\tcount++;\n+    }\n+  \n+  lto_output_uleb128_stream (ob->main_stream, count);\n+  \n+  /* Process all of the functions.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (node->analyzed && get_function_state (node) != NULL)\n+\t{\n+\t  struct bitpack_d *bp;\n+\t  funct_state fs;\n+\t  int node_ref;\n+\t  lto_cgraph_encoder_t encoder;\n+\t  \n+\t  fs = get_function_state (node);\n+\n+\t  encoder = ob->decl_state->cgraph_node_encoder;\n+\t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n+\t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\t\n+\t  /* Note that flags will need to be read in the opposite\n+\t     order as we are pushing the bitflags into FLAGS.  */\n+\t  bp = bitpack_create ();\n+\t  bp_pack_value (bp, fs->pure_const_state, 2);\n+\t  bp_pack_value (bp, fs->state_previously_known, 2);\n+\t  bp_pack_value (bp, fs->looping_previously_known, 1);\n+\t  bp_pack_value (bp, fs->looping, 1);\n+\t  bp_pack_value (bp, fs->can_throw, 1);\n+\t  lto_output_bitpack (ob->main_stream, bp);\n+\t  bitpack_delete (bp);\n+\t}\n+    }\n+\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+\n+/* Deserialize the ipa info for lto.  */\n+\n+static void \n+pure_const_read_summary (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  register_hooks ();\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data, \n+\t\t\t\t\t LTO_section_ipa_pure_const, \n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{\n+\t  unsigned int i;\n+\t  unsigned int count = lto_input_uleb128 (ib);\n+\n+\t  for (i = 0; i < count; i++)\n+\t    {\n+\t      unsigned int index;\n+\t      struct cgraph_node *node;\n+\t      struct bitpack_d *bp;\n+\t      funct_state fs;\n+\t      lto_cgraph_encoder_t encoder;\n+\n+\t      fs = XCNEW (struct funct_state_d);\n+\t      index = lto_input_uleb128 (ib);\n+\t      encoder = file_data->cgraph_node_encoder;\n+\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      set_function_state (node, fs);\n+\n+\t      /* Note that the flags must be read in the opposite\n+\t\t order in which they were written (the bitflags were\n+\t\t pushed into FLAGS).  */\n+\t      bp = lto_input_bitpack (ib);\n+\t      fs->pure_const_state\n+\t\t\t= (enum pure_const_state_e) bp_unpack_value (bp, 2);\n+\t      fs->state_previously_known\n+\t\t\t= (enum pure_const_state_e) bp_unpack_value (bp, 2);\n+\t      fs->looping_previously_known = bp_unpack_value (bp, 1);\n+\t      fs->looping = bp_unpack_value (bp, 1);\n+\t      fs->can_throw = bp_unpack_value (bp, 1);\n+\t      bitpack_delete (bp);\n+\t    }\n+\n+\t  lto_destroy_simple_input_block (file_data, \n+\t\t\t\t\t  LTO_section_ipa_pure_const, \n+\t\t\t\t\t  ib, data, len);\n+\t}\n+    }\n+}\n+\n+\n static bool\n ignore_edge (struct cgraph_edge *e)\n {\n@@ -952,8 +1082,8 @@ struct ipa_opt_pass_d pass_ipa_pure_const =\n   0                                     /* todo_flags_finish */\n  },\n  generate_summary,\t\t        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n+ pure_const_write_summary,\t\t/* write_summary */\n+ pure_const_read_summary,\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t                /* function_transform */"}, {"sha": "795684692bf419a88979ca65893c00833d9ffc4b", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 163, "deletions": 9, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -68,6 +68,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n+#include \"lto-streamer.h\"\n+\n+static void add_new_function (struct cgraph_node *node,\n+\t\t\t      void *data ATTRIBUTE_UNUSED);\n+static void remove_node_data (struct cgraph_node *node,\n+\t\t\t      void *data ATTRIBUTE_UNUSED);\n+static void duplicate_node_data (struct cgraph_node *src,\n+\t\t\t\t struct cgraph_node *dst,\n+\t\t\t\t void *data ATTRIBUTE_UNUSED);\n \n /* The static variables defined within the compilation unit that are\n    loaded or stored directly by function that owns this structure.  */ \n@@ -578,6 +587,13 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n static void \n ipa_init (void) \n {\n+  static bool init_p = false;\n+\n+  if (init_p)\n+    return;\n+\n+  init_p = true;\n+\n   memory_identifier_string = build_string(7, \"memory\");\n \n   reference_vars_to_consider =\n@@ -594,6 +610,13 @@ ipa_init (void)\n      since all we would be interested in are the addressof\n      operations.  */\n   visited_nodes = pointer_set_create ();\n+\n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+  node_removal_hook_holder =\n+      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n+  node_duplication_hook_holder =\n+      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n }\n \n /* Check out the rhs of a static or global initialization VNODE to see\n@@ -614,6 +637,7 @@ analyze_variable (struct varpool_node *vnode)\n              &wi, wi.pset);\n }\n \n+\n /* Set up the persistent info for FN.  */\n \n static ipa_reference_local_vars_info_t\n@@ -634,9 +658,10 @@ init_function_info (struct cgraph_node *fn)\n   return l;\n }\n \n+\n /* This is the main routine for finding the reference patterns for\n    global variables within a function FN.  */\n-  \n+\n static void\n analyze_function (struct cgraph_node *fn)\n {\n@@ -845,12 +870,6 @@ generate_summary (void)\n   bitmap module_statics_readonly;\n   bitmap bm_temp;\n   \n-  function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n-  node_removal_hook_holder =\n-      cgraph_add_node_removal_hook (&remove_node_data, NULL);\n-  node_duplication_hook_holder =\n-      cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n   ipa_init ();\n   module_statics_readonly = BITMAP_ALLOC (&local_info_obstack);\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n@@ -986,6 +1005,141 @@ generate_summary (void)\n \t     fprintf (dump_file, \"\\n  calls read all: \");\n \t}\n }\n+\n+\n+/* Return true if we need to write summary of NODE. */\n+\n+static bool\n+write_node_summary_p (struct cgraph_node *node)\n+{\n+  return (node->analyzed \n+\t  && node->global.inlined_to == NULL\n+\t  && cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE\n+\t  && get_reference_vars_info (node) != NULL);\n+}\n+\n+/* Serialize the ipa info for lto.  */\n+\n+static void \n+ipa_reference_write_summary (cgraph_node_set set)\n+{\n+  struct cgraph_node *node;\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_ipa_reference);\n+  unsigned int count = 0;\n+  cgraph_node_set_iterator csi;\n+\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    if (write_node_summary_p (csi_node (csi)))\n+\tcount++;\n+  \n+  lto_output_uleb128_stream (ob->main_stream, count);\n+  \n+  /* Process all of the functions.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (write_node_summary_p (node))\n+\t{\n+\t  ipa_reference_local_vars_info_t l\n+\t    = get_reference_vars_info (node)->local;\n+\t  unsigned int index;\n+\t  bitmap_iterator bi;\n+\t  lto_cgraph_encoder_t encoder;\n+\t  int node_ref;\n+\n+\t  encoder = ob->decl_state->cgraph_node_encoder;\n+\t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n+\t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\n+\t  /* Stream out the statics read.  */\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     bitmap_count_bits (l->statics_read));\n+\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_read, 0, index, bi)\n+\t    lto_output_var_decl_index(ob->decl_state, ob->main_stream,\n+\t\t\t\t      get_static_decl (index));\n+\n+\t  /* Stream out the statics written.  */\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     bitmap_count_bits (l->statics_written));\n+\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_written, 0, index, bi)\n+\t    lto_output_var_decl_index(ob->decl_state, ob->main_stream,\n+\t\t\t\t      get_static_decl (index));\n+\t}\n+    }\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+\n+/* Deserialize the ipa info for lto.  */\n+\n+static void \n+ipa_reference_read_summary (void)\n+{\n+  struct lto_file_decl_data ** file_data_vec \n+    = lto_get_file_decl_data ();\n+  struct lto_file_decl_data * file_data;\n+  unsigned int j = 0;\n+\n+  ipa_init ();\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data, \n+\t\t\t\t\t LTO_section_ipa_reference, \n+\t\t\t\t\t &data, &len);\n+      if (ib)\n+\t{ \n+\t  unsigned int i;\n+\t  unsigned int f_count = lto_input_uleb128 (ib);\n+\n+\t  for (i = 0; i < f_count; i++)\n+\t    {\n+\t      unsigned int j, index;\n+\t      struct cgraph_node *node;\n+\t      ipa_reference_local_vars_info_t l;\n+\t      unsigned int v_count;\n+\t      lto_cgraph_encoder_t encoder;\n+\n+\t      index = lto_input_uleb128 (ib);\n+\t      encoder = file_data->cgraph_node_encoder;\n+\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      l = init_function_info (node);\n+\n+\t      /* Set the statics read.  */\n+\t      v_count = lto_input_uleb128 (ib);\n+\t      for (j = 0; j < v_count; j++)\n+\t\t{\n+\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t var_index);\n+\t\t  add_static_var (v_decl);\n+\t\t  bitmap_set_bit (l->statics_read, DECL_UID (v_decl));\n+\t\t} \n+\n+\t      /* Set the statics written.  */\n+\t      v_count = lto_input_uleb128 (ib);\n+\t      for (j = 0; j < v_count; j++)\n+\t\t{\n+\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t var_index);\n+\t\t  add_static_var (v_decl);\n+\t\t  bitmap_set_bit (l->statics_written, DECL_UID (v_decl));\n+\t\t} \n+\t    }\n+\n+\t  lto_destroy_simple_input_block (file_data, \n+\t\t\t\t\t  LTO_section_ipa_reference, \n+\t\t\t\t\t  ib, data, len);\n+\t}\n+    }\n+}\n+\n+\n \f\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by ipa_analyze_function\n@@ -1271,8 +1425,8 @@ struct ipa_opt_pass_d pass_ipa_reference =\n   0                                     /* todo_flags_finish */\n  },\n  generate_summary,\t\t        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n+ ipa_reference_write_summary,\t\t/* write_summary */\n+ ipa_reference_read_summary,\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t                /* function_transform */"}, {"sha": "6ce9d58b0e03fd649c49112dd73713f68d8c316a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -1,3 +1,7 @@\n+2009-10-03  Simon Baldwin  <simonb@google.com>\n+\n+\t* config-lang.in (lang_dirs): Remove zlib.\n+\n 2009-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (initialize_builtins): Update call to"}, {"sha": "29ee3fd8547a54d02e30b6571b04fe379df1e20e", "filename": "gcc/java/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -35,6 +35,6 @@ compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/jcf.h \\$(srcdir)/java/parse.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/resource.c\"\n \n target_libs=${libgcj_saved}\n-lang_dirs=\"zlib fastjar\"\n+lang_dirs=\"fastjar\"\n #build_by_default=no\n lang_requires=c++"}, {"sha": "4f01483846b87aa1020fd2748b3623c7b4af53b5", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -62,7 +62,7 @@ extern bool lhd_decl_ok_for_sibcall (const_tree);\n extern size_t lhd_tree_size (enum tree_code);\n extern HOST_WIDE_INT lhd_to_target_charset (HOST_WIDE_INT);\n extern tree lhd_expr_to_decl (tree, bool *, bool *);\n-extern tree lhd_builtin_function (tree decl);\n+extern tree lhd_builtin_function (tree);\n \n /* Declarations of default tree inlining hooks.  */\n extern void lhd_initialize_diagnostics (struct diagnostic_context *);\n@@ -236,6 +236,21 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_OMP_FINISH_CLAUSE \\\n }\n \n+/* LTO hooks.  */\n+extern void lhd_begin_section (const char *);\n+extern void lhd_append_data (const void *, size_t, void *);\n+extern void lhd_end_section (void);\n+\n+#define LANG_HOOKS_BEGIN_SECTION lhd_begin_section\n+#define LANG_HOOKS_APPEND_DATA lhd_append_data\n+#define LANG_HOOKS_END_SECTION lhd_end_section\n+\n+#define LANG_HOOKS_LTO { \\\n+  LANG_HOOKS_BEGIN_SECTION, \\\n+  LANG_HOOKS_APPEND_DATA, \\\n+  LANG_HOOKS_END_SECTION \\\n+}\n+\n /* The whole thing.  The structure is defined in langhooks.h.  */\n #define LANG_HOOKS_INITIALIZER { \\\n   LANG_HOOKS_NAME, \\\n@@ -273,6 +288,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n   LANG_HOOKS_DECLS, \\\n   LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n+  LANG_HOOKS_LTO, \\\n   LANG_HOOKS_GET_INNERMOST_GENERIC_PARMS, \\\n   LANG_HOOKS_GET_INNERMOST_GENERIC_ARGS, \\\n   LANG_HOOKS_FUNCTION_PARAMETER_PACK_P, \\"}, {"sha": "633caf58c538ad9fa882be8086fb8a784ba94d50", "filename": "gcc/langhooks.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"diagnostic.h\"\n #include \"cgraph.h\"\n+#include \"output.h\"\n \n /* Do nothing; in many cases the default hook.  */\n \n@@ -584,3 +585,54 @@ lhd_builtin_function (tree decl)\n   lang_hooks.decls.pushdecl (decl);\n   return decl;\n }\n+\n+/* LTO hooks.  */\n+\n+/* Used to save and restore any previously active section.  */\n+static section *saved_section;\n+\n+\n+/* Begin a new LTO output section named NAME.  This default implementation\n+   saves the old section and emits assembly code to switch to the new\n+   section.  */\n+\n+void\n+lhd_begin_section (const char *name)\n+{\n+  section *section;\n+\n+  /* Save the old section so we can restore it in lto_end_asm_section.  */\n+  gcc_assert (!saved_section);\n+  saved_section = in_section;\n+\n+  /* Create a new section and switch to it.  */\n+  section = get_section (name, SECTION_DEBUG, NULL);\n+  switch_to_section (section);\n+}\n+\n+\n+/* Write DATA of length LEN to the current LTO output section.  This default\n+   implementation just calls assemble_string and frees BLOCK.  */\n+\n+void\n+lhd_append_data (const void *data, size_t len, void *block)\n+{\n+  if (data)\n+    assemble_string ((const char *)data, len);\n+  free (block);\n+}\n+\n+\n+/* Finish the current LTO output section.  This default implementation emits\n+   assembly code to switch to any section previously saved by\n+   lhd_begin_section.  */\n+\n+void\n+lhd_end_section (void)\n+{\n+  if (saved_section)\n+    {\n+      switch_to_section (saved_section);\n+      saved_section = NULL;\n+    }\n+}"}, {"sha": "81f243662343f647cf5035cb1aae6cb67ef8cf64", "filename": "gcc/langhooks.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -231,6 +231,23 @@ struct lang_hooks_for_decls\n   void (*omp_finish_clause) (tree clause);\n };\n \n+/* Language hooks related to LTO serialization.  */\n+\n+struct lang_hooks_for_lto\n+{\n+  /* Begin a new LTO section named NAME.  */\n+  void (*begin_section) (const char *name);\n+\n+  /* Write DATA of length LEN to the currently open LTO section.  BLOCK is a\n+     pointer to the dynamically allocated memory containing DATA.  The\n+     append_data function is responsible for freeing it when it is no longer\n+     needed.  */\n+  void (*append_data) (const void *data, size_t len, void *block);\n+\n+  /* End the previously begun LTO section.  */\n+  void (*end_section) (void);\n+};\n+\n /* Language-specific hooks.  See langhooks-def.h for defaults.  */\n \n struct lang_hooks\n@@ -386,6 +403,8 @@ struct lang_hooks\n \n   struct lang_hooks_for_types types;\n \n+  struct lang_hooks_for_lto lto;\n+\n   /* Returns the generic parameters of an instantiation of\n      a generic type or decl, e.g. C++ template instantiation.  */\n   tree (*get_innermost_generic_parms) (const_tree);"}, {"sha": "b11483c9c8123858436c35616f2ad9d4d4b50742", "filename": "gcc/lto-cgraph.c", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,693 @@\n+/* Write and read the cgraph to the memory mapped representation of a\n+   .o file.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+#include \"input.h\"\n+#include \"varray.h\"\n+#include \"hashtab.h\"\n+#include \"langhooks.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"diagnostic.h\"\n+#include \"except.h\"\n+#include \"vec.h\"\n+#include \"timevar.h\"\n+#include \"output.h\"\n+#include \"pointer-set.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Create a new cgraph encoder.  */\n+\n+lto_cgraph_encoder_t\n+lto_cgraph_encoder_new (void)\n+{\n+  lto_cgraph_encoder_t encoder = XCNEW (struct lto_cgraph_encoder_d);\n+  encoder->map = pointer_map_create ();\n+  encoder->nodes = NULL;\n+  return encoder;\n+}\n+\n+\n+/* Delete ENCODER and its components.  */\n+\n+void\n+lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder)\n+{\n+   VEC_free (cgraph_node_ptr, heap, encoder->nodes);\n+   pointer_map_destroy (encoder->map);\n+   free (encoder);\n+}\n+\n+\n+/* Return the existing reference number of NODE in the cgraph encoder in\n+   output block OB.  Assign a new reference if this is the first time\n+   NODE is encoded.  */\n+\n+int\n+lto_cgraph_encoder_encode (lto_cgraph_encoder_t encoder,\n+\t\t\t   struct cgraph_node *node)\n+{\n+  int ref;\n+  void **slot;\n+  \n+  slot = pointer_map_contains (encoder->map, node);\n+  if (!slot)\n+    {\n+      ref = VEC_length (cgraph_node_ptr, encoder->nodes);\n+      slot = pointer_map_insert (encoder->map, node);\n+      *slot = (void *) (intptr_t) ref;\n+      VEC_safe_push (cgraph_node_ptr, heap, encoder->nodes, node);\n+    }\n+  else\n+    ref = (int) (intptr_t) *slot;\n+\n+  return ref;\n+}\n+\n+\n+/* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n+   or LCC_NOT_FOUND if it is not there.  */\n+\n+int\n+lto_cgraph_encoder_lookup (lto_cgraph_encoder_t encoder,\n+\t\t\t   struct cgraph_node *node)\n+{\n+  void **slot = pointer_map_contains (encoder->map, node);\n+  return (slot ? (int) (intptr_t) *slot : LCC_NOT_FOUND);\n+}\n+\n+\n+/* Return the cgraph node corresponding to REF using ENCODER.  */\n+\n+struct cgraph_node *\n+lto_cgraph_encoder_deref (lto_cgraph_encoder_t encoder, int ref)\n+{\n+  if (ref == LCC_NOT_FOUND)\n+    return NULL;\n+\n+  return VEC_index (cgraph_node_ptr, encoder->nodes, ref); \n+}\n+\n+\n+/* Return number of encoded nodes in ENCODER.  */\n+\n+static int\n+lto_cgraph_encoder_size (lto_cgraph_encoder_t encoder)\n+{\n+  return VEC_length (cgraph_node_ptr, encoder->nodes);\n+}\n+\n+\n+/* Output the cgraph EDGE to OB using ENCODER.  */\n+\n+static void\n+lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n+\t\t lto_cgraph_encoder_t encoder)\n+{\n+  unsigned int uid;\n+  intptr_t ref;\n+  struct bitpack_d *bp;\n+\n+  lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_edge);\n+\n+  ref = lto_cgraph_encoder_lookup (encoder, edge->caller);\n+  gcc_assert (ref != LCC_NOT_FOUND); \n+  lto_output_sleb128_stream (ob->main_stream, ref);\n+\n+  ref = lto_cgraph_encoder_lookup (encoder, edge->callee);\n+  gcc_assert (ref != LCC_NOT_FOUND); \n+  lto_output_sleb128_stream (ob->main_stream, ref);\n+\n+  lto_output_sleb128_stream (ob->main_stream, edge->count);\n+\n+  bp = bitpack_create ();\n+  uid = flag_wpa ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt);\n+  bp_pack_value (bp, uid, HOST_BITS_PER_INT);\n+  bp_pack_value (bp, edge->inline_failed, HOST_BITS_PER_INT);\n+  bp_pack_value (bp, edge->frequency, HOST_BITS_PER_INT);\n+  bp_pack_value (bp, edge->loop_nest, 30);\n+  bp_pack_value (bp, edge->indirect_call, 1);\n+  bp_pack_value (bp, edge->call_stmt_cannot_inline_p, 1);\n+  bp_pack_value (bp, edge->can_throw_external, 1);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+}\n+\n+\n+/* Output the cgraph NODE to OB.  ENCODER is used to find the\n+   reference number of NODE->inlined_to.  SET is the set of nodes we\n+   are writing to the current file.  If NODE is not in SET, then NODE\n+   is a boundary of a cgraph_node_set and we pretend NODE just has a\n+   decl and no callees.  WRITTEN_DECLS is the set of FUNCTION_DECLs\n+   that have had their callgraph node written so far.  This is used to\n+   determine if NODE is a clone of a previously written node.  */\n+\n+static void\n+lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n+\t\t lto_cgraph_encoder_t encoder, cgraph_node_set set,\n+\t\t bitmap written_decls)\n+{\n+  unsigned int tag;\n+  struct bitpack_d *bp;\n+  unsigned local, externally_visible, inlinable, analyzed;\n+  bool boundary_p, wrote_decl_p;\n+  intptr_t ref;\n+\n+  boundary_p = !cgraph_node_in_set_p (node, set);\n+  wrote_decl_p = bitmap_bit_p (written_decls, DECL_UID (node->decl));\n+\n+  switch (cgraph_function_body_availability (node))\n+    {\n+    case AVAIL_NOT_AVAILABLE:\n+      tag = LTO_cgraph_unavail_node;\n+      break;\n+\n+    case AVAIL_AVAILABLE:\n+    case AVAIL_LOCAL:\n+      tag = LTO_cgraph_avail_node;\n+      break;\n+    \n+    case AVAIL_OVERWRITABLE:\n+      tag = LTO_cgraph_overwritable_node;\n+      break;\n+      \n+    default:\n+      gcc_unreachable ();\n+    }\n+ \n+  if (boundary_p)\n+    tag = LTO_cgraph_unavail_node;\n+\n+  lto_output_uleb128_stream (ob->main_stream, tag);\n+\n+  local = node->local.local;\n+  externally_visible = node->local.externally_visible;\n+  inlinable = node->local.inlinable;\n+  analyzed = node->analyzed;\n+\n+  /* In WPA mode, we only output part of the call-graph.  Also, we\n+     fake cgraph node attributes.  There are two cases that we care.\n+\n+     Boundary nodes: There are nodes that are not part of SET but are\n+     called from within SET.  We artificially make them look like\n+     externally visible nodes with no function body. \n+\n+     Cherry-picked nodes:  These are nodes we pulled from other\n+     translation units into SET during IPA-inlining.  We make them as\n+     local static nodes to prevent clashes with other local statics.  */\n+  if (boundary_p)\n+    {\n+      local = 0;\n+      externally_visible = 1;\n+      inlinable = 0;\n+      analyzed = 0;\n+    }\n+  else if (lto_forced_extern_inline_p (node->decl))\n+    {\n+      local = 1;\n+      externally_visible = 0;\n+      inlinable = 1;\n+    }\n+\n+  lto_output_uleb128_stream (ob->main_stream, wrote_decl_p);\n+\n+  if (!wrote_decl_p)\n+    bitmap_set_bit (written_decls, DECL_UID (node->decl));\n+\n+  lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n+  lto_output_sleb128_stream (ob->main_stream, node->count);\n+\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, local, 1);\n+  bp_pack_value (bp, externally_visible, 1);\n+  bp_pack_value (bp, node->local.finalized, 1);\n+  bp_pack_value (bp, inlinable, 1);\n+  bp_pack_value (bp, node->local.disregard_inline_limits, 1);\n+  bp_pack_value (bp, node->local.redefined_extern_inline, 1);\n+  bp_pack_value (bp, node->local.for_functions_valid, 1);\n+  bp_pack_value (bp, node->local.vtable_method, 1);\n+  bp_pack_value (bp, node->needed, 1);\n+  bp_pack_value (bp, node->address_taken, 1);\n+  bp_pack_value (bp, node->abstract_and_needed, 1);\n+  bp_pack_value (bp, node->reachable, 1);\n+  bp_pack_value (bp, node->lowered, 1);\n+  bp_pack_value (bp, analyzed, 1);\n+  bp_pack_value (bp, node->process, 1);\n+  bp_pack_value (bp, node->alias, 1);\n+  bp_pack_value (bp, node->finalized_by_frontend, 1);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  if (tag != LTO_cgraph_unavail_node)\n+    {\n+      lto_output_sleb128_stream (ob->main_stream, \n+\t\t\t\t node->local.inline_summary.estimated_self_stack_size);\n+      lto_output_sleb128_stream (ob->main_stream, \n+\t\t\t\t node->local.inline_summary.self_size);\n+      lto_output_sleb128_stream (ob->main_stream, \n+\t\t\t\t node->local.inline_summary.size_inlining_benefit);\n+      lto_output_sleb128_stream (ob->main_stream, \n+\t\t\t\t node->local.inline_summary.self_time);\n+      lto_output_sleb128_stream (ob->main_stream, \n+\t\t\t\t node->local.inline_summary.time_inlining_benefit);\n+    }\n+\n+  /* FIXME lto: Outputting global info is not neccesary until after\n+     inliner was run.  Global structure holds results of propagation\n+     done by inliner.  */\n+  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t     node->global.estimated_stack_size);\n+  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t     node->global.stack_frame_offset);\n+  if (node->global.inlined_to && !boundary_p)\n+    {\n+      ref = lto_cgraph_encoder_lookup (encoder, node->global.inlined_to);\n+      gcc_assert (ref != LCC_NOT_FOUND);\n+    }\n+  else\n+    ref = LCC_NOT_FOUND;\n+  lto_output_sleb128_stream (ob->main_stream, ref);\n+\n+  lto_output_sleb128_stream (ob->main_stream, node->global.time);\n+  lto_output_sleb128_stream (ob->main_stream, node->global.size);\n+  lto_output_sleb128_stream (ob->main_stream,\n+\t\t\t     node->global.estimated_growth);\n+  lto_output_uleb128_stream (ob->main_stream, node->global.inlined);\n+}\n+\n+\n+/* Output the part of the cgraph in SET.  */\n+\n+void\n+output_cgraph (cgraph_node_set set)\n+{\n+  struct cgraph_node *node;\n+  struct lto_simple_output_block *ob;\n+  cgraph_node_set_iterator csi;\n+  struct cgraph_edge *edge;\n+  int i, n_nodes;\n+  bitmap written_decls;\n+  lto_cgraph_encoder_t encoder;\n+\n+  ob = lto_create_simple_output_block (LTO_section_cgraph);\n+\n+  /* An encoder for cgraph nodes should have been created by\n+     ipa_write_summaries_1.  */\n+  gcc_assert (ob->decl_state->cgraph_node_encoder);\n+  encoder = ob->decl_state->cgraph_node_encoder;\n+\n+  /* The FUNCTION_DECLs for which we have written a node.  The first\n+     node found is written as the \"original\" node, the remaining nodes\n+     are considered its clones.  */\n+  written_decls = lto_bitmap_alloc ();\n+\n+  /* Go over all the nodes in SET and assign references.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      lto_cgraph_encoder_encode (encoder, node);\n+    }\n+\n+  /* Go over all the nodes again to include callees that are not in\n+     SET.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t{\n+\t  struct cgraph_node *callee = edge->callee;\n+\t  if (!cgraph_node_in_set_p (callee, set))\n+\t    {\n+\t      /* We should have moved all the inlines.  */\n+\t      gcc_assert (!callee->global.inlined_to);\n+\t      lto_cgraph_encoder_encode (encoder, callee);\n+\t    }\n+\t}\n+    }\n+\n+  /* Write out the nodes.  */\n+  n_nodes = lto_cgraph_encoder_size (encoder);\n+  for (i = 0; i < n_nodes; i++)\n+    {\n+      node = lto_cgraph_encoder_deref (encoder, i);\n+      lto_output_node (ob, node, encoder, set, written_decls);\n+    }\n+\n+  lto_bitmap_free (written_decls);\n+\n+  /* Go over the nodes in SET again to write edges.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\tlto_output_edge (ob, edge, encoder);\n+    }\n+\n+  lto_output_uleb128_stream (ob->main_stream, 0);\n+\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+\n+/* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n+   STACK_SIZE, SELF_TIME and SELF_SIZE.  This is called either to initialize\n+   NODE or to replace the values in it, for instance because the first\n+   time we saw it, the function body was not available but now it\n+   is.  BP is a bitpack with all the bitflags for NODE read from the\n+   stream.  */\n+\n+static void\n+input_overwrite_node (struct lto_file_decl_data *file_data,\n+\t\t      struct cgraph_node *node,\n+\t\t      enum LTO_cgraph_tags tag,\n+\t\t      struct bitpack_d *bp,\n+\t\t      unsigned int stack_size,\n+\t\t      unsigned int self_time,\n+\t\t      unsigned int time_inlining_benefit,\n+\t\t      unsigned int self_size,\n+\t\t      unsigned int size_inlining_benefit)\n+{\n+  node->aux = (void *) tag;\n+  node->local.inline_summary.estimated_self_stack_size = stack_size;\n+  node->local.inline_summary.self_time = self_time;\n+  node->local.inline_summary.time_inlining_benefit = time_inlining_benefit;\n+  node->local.inline_summary.self_size = self_size;\n+  node->local.inline_summary.size_inlining_benefit = size_inlining_benefit;\n+  node->global.time = self_time;\n+  node->global.size = self_size;\n+  node->local.lto_file_data = file_data;\n+\n+  node->local.local = bp_unpack_value (bp, 1);\n+  node->local.externally_visible = bp_unpack_value (bp, 1);\n+  node->local.finalized = bp_unpack_value (bp, 1);\n+  node->local.inlinable = bp_unpack_value (bp, 1);\n+  node->local.disregard_inline_limits = bp_unpack_value (bp, 1);\n+  node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n+  node->local.for_functions_valid = bp_unpack_value (bp, 1);\n+  node->local.vtable_method = bp_unpack_value (bp, 1);\n+  node->needed = bp_unpack_value (bp, 1);\n+  node->address_taken = bp_unpack_value (bp, 1);\n+  node->abstract_and_needed = bp_unpack_value (bp, 1);\n+  node->reachable = bp_unpack_value (bp, 1);\n+  node->lowered = bp_unpack_value (bp, 1);\n+  node->analyzed = bp_unpack_value (bp, 1);\n+  node->process = bp_unpack_value (bp, 1);\n+  node->alias = bp_unpack_value (bp, 1);\n+  node->finalized_by_frontend = bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Read a node from input_block IB.  TAG is the node's tag just read. \n+   Return the node read or overwriten.  */\n+ \n+static struct cgraph_node *\n+input_node (struct lto_file_decl_data *file_data,\n+\t    struct lto_input_block *ib,\n+\t    enum LTO_cgraph_tags tag)\n+{\n+  tree fn_decl;\n+  struct cgraph_node *node;\n+  struct bitpack_d *bp;\n+  int stack_size = 0;\n+  unsigned decl_index;\n+  bool clone_p;\n+  int estimated_stack_size = 0;\n+  int stack_frame_offset = 0;\n+  int ref = LCC_NOT_FOUND;\n+  int estimated_growth = 0;\n+  int time = 0;\n+  int size = 0;\n+  int self_time = 0;\n+  int self_size = 0;\n+  int time_inlining_benefit = 0;\n+  int size_inlining_benefit = 0;\n+  bool inlined = false;\n+\n+  clone_p = (lto_input_uleb128 (ib) != 0);\n+\n+  decl_index = lto_input_uleb128 (ib);\n+  fn_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+\n+  if (clone_p)\n+    node = cgraph_clone_node (cgraph_node (fn_decl), 0,\n+\t\t\t      CGRAPH_FREQ_BASE, 0, false, NULL);\n+\n+  else\n+    node = cgraph_node (fn_decl);\n+\n+  node->count = lto_input_sleb128 (ib);\n+  bp = lto_input_bitpack (ib);\n+  \n+  if (tag != LTO_cgraph_unavail_node)\n+    {\n+      stack_size = lto_input_sleb128 (ib);\n+      self_size = lto_input_sleb128 (ib);\n+      size_inlining_benefit = lto_input_sleb128 (ib);\n+      self_time = lto_input_sleb128 (ib);\n+      time_inlining_benefit = lto_input_sleb128 (ib);\n+    }\n+\n+  estimated_stack_size = lto_input_sleb128 (ib);\n+  stack_frame_offset = lto_input_sleb128 (ib);\n+  ref = lto_input_sleb128 (ib);\n+  time = lto_input_sleb128 (ib);\n+  size = lto_input_sleb128 (ib);\n+  estimated_growth = lto_input_sleb128 (ib);\n+  inlined = lto_input_uleb128 (ib);\n+\n+  /* Make sure that we have not read this node before.  Nodes that\n+     have already been read will have their tag stored in the 'aux'\n+     field.  Since built-in functions can be referenced in multiple\n+     functions, they are expected to be read more than once.  */\n+  if (node->aux && !DECL_IS_BUILTIN (node->decl))\n+    internal_error (\"bytecode stream: found multiple instances of cgraph \"\n+\t\t    \"node %d\", node->uid);\n+\n+  input_overwrite_node (file_data, node, tag, bp, stack_size, self_time,\n+  \t\t\ttime_inlining_benefit, self_size,\n+\t\t\tsize_inlining_benefit);\n+  bitpack_delete (bp);\n+\n+  node->global.estimated_stack_size = estimated_stack_size;\n+  node->global.stack_frame_offset = stack_frame_offset;\n+  node->global.time = time;\n+  node->global.size = size;\n+\n+  /* Store a reference for now, and fix up later to be a pointer.  */\n+  node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n+\n+  node->global.estimated_growth = estimated_growth;\n+  node->global.inlined = inlined;\n+\n+  return node;\n+}\n+\n+\n+/* Read an edge from IB.  NODES points to a vector of previously read\n+   nodes for decoding caller and callee of the edge to be read.  */\n+\n+static void\n+input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n+{\n+  struct cgraph_node *caller, *callee;\n+  struct cgraph_edge *edge;\n+  unsigned int stmt_id;\n+  gcov_type count;\n+  int freq;\n+  unsigned int nest;\n+  cgraph_inline_failed_t inline_failed;\n+  struct bitpack_d *bp;\n+  tree prevailing_callee;\n+  tree prevailing_caller;\n+  enum ld_plugin_symbol_resolution caller_resolution;\n+\n+  caller = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+  if (caller == NULL || caller->decl == NULL_TREE)\n+    internal_error (\"bytecode stream: no caller found while reading edge\");\n+\n+  callee = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+  if (callee == NULL || callee->decl == NULL_TREE)\n+    internal_error (\"bytecode stream: no callee found while reading edge\");\n+\n+  caller_resolution = lto_symtab_get_resolution (caller->decl);\n+\n+  count = (gcov_type) lto_input_sleb128 (ib);\n+\n+  bp = lto_input_bitpack (ib);\n+  stmt_id = (unsigned int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n+  inline_failed = (cgraph_inline_failed_t) bp_unpack_value (bp,\n+\t\t\t\t\t\t\t    HOST_BITS_PER_INT);\n+  freq = (int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n+  nest = (unsigned) bp_unpack_value (bp, 30);\n+\n+  /* If the caller was preempted, don't create the edge.  */\n+  if (caller_resolution == LDPR_PREEMPTED_REG\n+      || caller_resolution == LDPR_PREEMPTED_IR)\n+    return;\n+\n+  prevailing_callee = lto_symtab_prevailing_decl (callee->decl);\n+\n+  /* Make sure the caller is the prevailing decl.  */\n+  prevailing_caller = lto_symtab_prevailing_decl (caller->decl);\n+\n+  if (prevailing_callee != callee->decl)\n+    {\n+      struct lto_file_decl_data *file_data;\n+\n+      /* We cannot replace a clone!  */\n+      gcc_assert (callee == cgraph_node (callee->decl));\n+\n+      callee = cgraph_node (prevailing_callee);\n+      gcc_assert (callee);\n+\n+      /* If LGEN (cc1 or cc1plus) had nothing to do with the node, it\n+\t might not have created it. In this case, we just created a\n+\t new node in the above call to cgraph_node. Mark the file it\n+\t came from. */\n+      file_data = lto_symtab_get_file_data (prevailing_callee);\n+      if (callee->local.lto_file_data)\n+\tgcc_assert (callee->local.lto_file_data == file_data);\n+      else\n+\tcallee->local.lto_file_data = file_data;\n+    }\n+\n+  edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n+  edge->lto_stmt_uid = stmt_id;\n+  edge->inline_failed = inline_failed;\n+  edge->indirect_call = bp_unpack_value (bp, 1);\n+  edge->call_stmt_cannot_inline_p = bp_unpack_value (bp, 1);\n+  edge->can_throw_external = bp_unpack_value (bp, 1);\n+  bitpack_delete (bp);\n+}\n+\n+\n+/* Read a cgraph from IB using the info in FILE_DATA.  */\n+\n+static void\n+input_cgraph_1 (struct lto_file_decl_data *file_data,\n+\t\tstruct lto_input_block *ib)\n+{\n+  enum LTO_cgraph_tags tag;\n+  VEC(cgraph_node_ptr, heap) *nodes = NULL;\n+  struct cgraph_node *node;\n+  unsigned i;\n+\n+  tag = (enum LTO_cgraph_tags) lto_input_uleb128 (ib);\n+  while (tag)\n+    {\n+      if (tag == LTO_cgraph_edge)\n+        input_edge (ib, nodes);\n+      else \n+\t{\n+\t  node = input_node (file_data, ib, tag);\n+\t  if (node == NULL || node->decl == NULL_TREE)\n+\t    internal_error (\"bytecode stream: found empty cgraph node\");\n+\t  VEC_safe_push (cgraph_node_ptr, heap, nodes, node);\n+\t  lto_cgraph_encoder_encode (file_data->cgraph_node_encoder, node);\n+\t}\n+\n+      tag = (enum LTO_cgraph_tags) lto_input_uleb128 (ib);\n+    }\n+\n+  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n+    {\n+      const int ref = (int) (intptr_t) node->global.inlined_to;\n+\n+      /* Fixup inlined_to from reference to pointer.  */\n+      if (ref != LCC_NOT_FOUND)\n+\tnode->global.inlined_to = VEC_index (cgraph_node_ptr, nodes, ref);\n+      else\n+\tnode->global.inlined_to = NULL;\n+    }\n+\n+  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n+    {\n+      tree prevailing = lto_symtab_prevailing_decl (node->decl);\n+\n+      if (prevailing != node->decl)\n+\t{\n+\t  cgraph_remove_node (node);\n+\t  VEC_replace (cgraph_node_ptr, nodes, i, NULL);\n+\t}\n+    }\n+\n+  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n+    if (node && cgraph_decide_is_function_needed (node, node->decl))\n+      cgraph_mark_needed_node (node);\n+\n+  VEC_free (cgraph_node_ptr, heap, nodes);\n+}\n+\n+\n+/* Input and merge the cgraph from each of the .o files passed to\n+   lto1.  */\n+\n+void\n+input_cgraph (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+  struct cgraph_node *node;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib;\n+\n+      ib = lto_create_simple_input_block (file_data, LTO_section_cgraph, \n+\t\t\t\t\t  &data, &len);\n+      file_data->cgraph_node_encoder = lto_cgraph_encoder_new ();\n+      input_cgraph_1 (file_data, ib);\n+      lto_destroy_simple_input_block (file_data, LTO_section_cgraph, \n+\t\t\t\t      ib, data, len);\n+      \n+      /* Assume that every file read needs to be processed by LTRANS.  */\n+      if (flag_wpa)\n+\tlto_mark_file_for_ltrans (file_data);\n+    } \n+\n+  /* Clear out the aux field that was used to store enough state to\n+     tell which nodes should be overwritten.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      /* Some nodes may have been created by cgraph_node.  This\n+\t happens when the callgraph contains nested functions.  If the\n+\t node for the parent function was never emitted to the gimple\n+\t file, cgraph_node will create a node for it when setting the\n+\t context of the nested function.  */\n+      if (node->local.lto_file_data)\n+\tnode->aux = NULL;\n+    }\n+}"}, {"sha": "8d745f6a0473f9ec823e8300d46f369271fc0709", "filename": "gcc/lto-compress.c", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-compress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-compress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-compress.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,314 @@\n+/* LTO IL compression streams.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Simon Baldwin <simonb@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+/* zlib.h includes other system headers.  Those headers may test feature\n+   test macros.  config.h may define feature test macros.  For this reason,\n+   zlib.h needs to be included after, rather than before, config.h and\n+   system.h.  */\n+#include <zlib.h>\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"errors.h\"\n+#include \"langhooks.h\"\n+#include \"lto-streamer.h\"\n+#include \"lto-compress.h\"\n+\n+/* Compression stream structure, holds the flush callback and opaque token,\n+   the buffered data, and a note of whether compressing or uncompressing.  */\n+\n+struct lto_compression_stream\n+{\n+  void (*callback) (const char *, unsigned, void *);\n+  void *opaque;\n+  char *buffer;\n+  size_t bytes;\n+  size_t allocation;\n+  bool is_compression;\n+};\n+\n+/* Overall compression constants for zlib.  */\n+\n+static const size_t Z_BUFFER_LENGTH = 4096;\n+static const size_t MIN_STREAM_ALLOCATION = 1024;\n+\n+/* For zlib, allocate SIZE count of ITEMS and return the address, OPAQUE\n+   is unused.  */\n+\n+static void *\n+lto_zalloc (void *opaque, unsigned items, unsigned size)\n+{\n+  gcc_assert (opaque == Z_NULL);\n+  return xmalloc (items * size);\n+}\n+\n+/* For zlib, free memory at ADDRESS, OPAQUE is unused.  */\n+\n+static void\n+lto_zfree (void *opaque, void *address)\n+{\n+  gcc_assert (opaque == Z_NULL);\n+  free (address);\n+}\n+\n+/* Return a zlib compression level that zlib will not reject.  Normalizes\n+   the compression level from the command line flag, clamping non-default\n+   values to the appropriate end of their valid range.  */\n+\n+static int\n+lto_normalized_zlib_level (void)\n+{\n+  int level = flag_lto_compression_level;\n+\n+  if (level != Z_DEFAULT_COMPRESSION)\n+    {\n+      if (level < Z_NO_COMPRESSION)\n+\tlevel = Z_NO_COMPRESSION;\n+      else if (level > Z_BEST_COMPRESSION)\n+\tlevel = Z_BEST_COMPRESSION;\n+    }\n+\n+  return level;\n+}\n+\n+/* Create a new compression stream, with CALLBACK flush function passed\n+   OPAQUE token, IS_COMPRESSION indicates if compressing or uncompressing.  */\n+\n+static struct lto_compression_stream *\n+lto_new_compression_stream (void (*callback) (const char *, unsigned, void *),\n+\t\t\t    void *opaque, bool is_compression)\n+{\n+  struct lto_compression_stream *stream\n+    = (struct lto_compression_stream *) xmalloc (sizeof (*stream));\n+\n+  memset (stream, 0, sizeof (*stream));\n+  stream->callback = callback;\n+  stream->opaque = opaque;\n+  stream->is_compression = is_compression;\n+\n+  return stream;\n+}\n+\n+/* Append NUM_CHARS from address BASE to STREAM.  */\n+\n+static void\n+lto_append_to_compression_stream (struct lto_compression_stream *stream,\n+\t\t\t\t  const char *base, size_t num_chars)\n+{\n+  size_t required = stream->bytes + num_chars;\n+\n+  if (stream->allocation < required)\n+    {\n+      if (stream->allocation == 0)\n+\tstream->allocation = MIN_STREAM_ALLOCATION;\n+      while (stream->allocation < required)\n+\tstream->allocation *= 2;\n+\n+      stream->buffer = (char *) xrealloc (stream->buffer, stream->allocation);\n+    }\n+\n+  memcpy (stream->buffer + stream->bytes, base, num_chars);\n+  stream->bytes += num_chars;\n+}\n+\n+/* Free the buffer and memory associated with STREAM.  */\n+\n+static void\n+lto_destroy_compression_stream (struct lto_compression_stream *stream)\n+{\n+  free (stream->buffer);\n+  free (stream);\n+}\n+\n+/* Return a new compression stream, with CALLBACK flush function passed\n+   OPAQUE token.  */\n+\n+struct lto_compression_stream *\n+lto_start_compression (void (*callback) (const char *, unsigned, void *),\n+\t\t       void *opaque)\n+{\n+  return lto_new_compression_stream (callback, opaque, true);\n+}\n+\n+/* Append NUM_CHARS from address BASE to STREAM.  */\n+\n+void\n+lto_compress_block (struct lto_compression_stream *stream,\n+\t\t    const char *base, size_t num_chars)\n+{\n+  gcc_assert (stream->is_compression);\n+\n+  lto_append_to_compression_stream (stream, base, num_chars);\n+  lto_stats.num_output_il_bytes += num_chars;\n+}\n+\n+/* Finalize STREAM compression, and free stream allocations.  */\n+\n+void\n+lto_end_compression (struct lto_compression_stream *stream)\n+{\n+  unsigned char *cursor = (unsigned char *) stream->buffer;\n+  size_t remaining = stream->bytes;\n+  const size_t outbuf_length = Z_BUFFER_LENGTH;\n+  unsigned char *outbuf = (unsigned char *) xmalloc (outbuf_length);\n+  z_stream out_stream;\n+  size_t compressed_bytes = 0;\n+  int status;\n+\n+  gcc_assert (stream->is_compression);\n+\n+  out_stream.next_out = outbuf;\n+  out_stream.avail_out = outbuf_length;\n+  out_stream.next_in = cursor;\n+  out_stream.avail_in = remaining;\n+  out_stream.zalloc = lto_zalloc;\n+  out_stream.zfree = lto_zfree;\n+  out_stream.opaque = Z_NULL;\n+\n+  status = deflateInit (&out_stream, lto_normalized_zlib_level ());\n+  if (status != Z_OK)\n+    internal_error (\"compressed stream: %s\", zError (status));\n+\n+  do\n+    {\n+      size_t in_bytes, out_bytes;\n+\n+      status = deflate (&out_stream, Z_FINISH);\n+      if (status != Z_OK && status != Z_STREAM_END)\n+\tinternal_error (\"compressed stream: %s\", zError (status));\n+\n+      in_bytes = remaining - out_stream.avail_in;\n+      out_bytes = outbuf_length - out_stream.avail_out;\n+\n+      stream->callback ((const char *) outbuf, out_bytes, stream->opaque);\n+      lto_stats.num_compressed_il_bytes += out_bytes;\n+      compressed_bytes += out_bytes;\n+\n+      cursor += in_bytes;\n+      remaining -= in_bytes;\n+\n+      out_stream.next_out = outbuf;\n+      out_stream.avail_out = outbuf_length;\n+      out_stream.next_in = cursor;\n+      out_stream.avail_in = remaining;\n+    }\n+  while (status != Z_STREAM_END);\n+\n+  status = deflateEnd (&out_stream);\n+  if (status != Z_OK)\n+    internal_error (\"compressed stream: %s\", zError (status));\n+\n+  lto_destroy_compression_stream (stream);\n+  free (outbuf);\n+}\n+\n+/* Return a new uncompression stream, with CALLBACK flush function passed\n+   OPAQUE token.  */\n+\n+struct lto_compression_stream *\n+lto_start_uncompression (void (*callback) (const char *, unsigned, void *),\n+\t\t\t void *opaque)\n+{\n+  return lto_new_compression_stream (callback, opaque, false);\n+}\n+\n+/* Append NUM_CHARS from address BASE to STREAM.  */\n+\n+void\n+lto_uncompress_block (struct lto_compression_stream *stream,\n+\t\t      const char *base, size_t num_chars)\n+{\n+  gcc_assert (!stream->is_compression);\n+\n+  lto_append_to_compression_stream (stream, base, num_chars);\n+  lto_stats.num_input_il_bytes += num_chars;\n+}\n+\n+/* Finalize STREAM uncompression, and free stream allocations.\n+  \n+   Because of the way LTO IL streams are compressed, there may be several\n+   concatenated compressed segments in the accumulated data, so for this\n+   function we iterate decompressions until no data remains.  */\n+\n+void\n+lto_end_uncompression (struct lto_compression_stream *stream)\n+{\n+  unsigned char *cursor = (unsigned char *) stream->buffer;\n+  size_t remaining = stream->bytes;\n+  const size_t outbuf_length = Z_BUFFER_LENGTH;\n+  unsigned char *outbuf = (unsigned char *) xmalloc (outbuf_length);\n+  size_t uncompressed_bytes = 0;\n+\n+  gcc_assert (!stream->is_compression);\n+\n+  while (remaining > 0)\n+    {\n+      z_stream in_stream;\n+      size_t out_bytes;\n+      int status;\n+\n+      in_stream.next_out = outbuf;\n+      in_stream.avail_out = outbuf_length;\n+      in_stream.next_in = cursor;\n+      in_stream.avail_in = remaining;\n+      in_stream.zalloc = lto_zalloc;\n+      in_stream.zfree = lto_zfree;\n+      in_stream.opaque = Z_NULL;\n+\n+      status = inflateInit (&in_stream);\n+      if (status != Z_OK)\n+\tinternal_error (\"compressed stream: %s\", zError (status));\n+\n+      do\n+\t{\n+\t  size_t in_bytes;\n+\n+\t  status = inflate (&in_stream, Z_SYNC_FLUSH);\n+\t  if (status != Z_OK && status != Z_STREAM_END)\n+\t    internal_error (\"compressed stream: %s\", zError (status));\n+\n+\t  in_bytes = remaining - in_stream.avail_in;\n+\t  out_bytes = outbuf_length - in_stream.avail_out;\n+\n+\t  stream->callback ((const char *) outbuf, out_bytes, stream->opaque);\n+\t  lto_stats.num_uncompressed_il_bytes += out_bytes;\n+\t  uncompressed_bytes += out_bytes;\n+\n+\t  cursor += in_bytes;\n+\t  remaining -= in_bytes;\n+\n+\t  in_stream.next_out = outbuf;\n+\t  in_stream.avail_out = outbuf_length;\n+\t  in_stream.next_in = cursor;\n+\t  in_stream.avail_in = remaining;\n+\t}\n+      while (!(status == Z_STREAM_END && out_bytes == 0));\n+\n+      status = inflateEnd (&in_stream);\n+      if (status != Z_OK)\n+\tinternal_error (\"compressed stream: %s\", zError (status));\n+    }\n+\n+  lto_destroy_compression_stream (stream);\n+  free (outbuf);\n+}"}, {"sha": "566a73498d2285b2c4464373472389414c5b0b9d", "filename": "gcc/lto-compress.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-compress.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-compress.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-compress.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,42 @@\n+/* LTO IL compression streams.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Simon Baldwin <simonb@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LTO_COMPRESS_H\n+#define GCC_LTO_COMPRESS_H\n+\n+struct lto_compression_stream;\n+\n+/* In lto-compress.c.  */\n+extern struct lto_compression_stream\n+  *lto_start_compression (void (*callback) (const char *, unsigned, void *),\n+\t\t\t  void *opaque);\n+extern void lto_compress_block (struct lto_compression_stream *stream,\n+\t\t\t\tconst char *base, size_t num_chars);\n+extern void lto_end_compression (struct lto_compression_stream *stream);\n+\n+extern struct lto_compression_stream\n+  *lto_start_uncompression (void (*callback) (const char *, unsigned, void *),\n+\t\t\t    void *opaque);\n+extern void lto_uncompress_block (struct lto_compression_stream *stream,\n+\t\t\t\t  const char *base, size_t num_chars);\n+extern void lto_end_uncompression (struct lto_compression_stream *stream);\n+\n+#endif /* GCC_LTO_COMPRESS_H  */"}, {"sha": "2a379f40fdcf793f061ddaabb1e9049d55aeb7de", "filename": "gcc/lto-opts.c", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,409 @@\n+/* LTO IL options.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Simon Baldwin <simonb@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"hashtab.h\"\n+#include \"ggc.h\"\n+#include \"vec.h\"\n+#include \"bitmap.h\"\n+#include \"flags.h\"\n+#include \"opts.h\"\n+#include \"options.h\"\n+#include \"target.h\"\n+#include \"toplev.h\"\n+#include \"lto-streamer.h\"\n+\n+/* When a file is initially compiled, the options used when generating\n+   the IL are not necessarily the same as those used when linking the\n+   objects into the final executable.  In general, most build systems\n+   will proceed with something along the lines of:\n+\n+   \t$ gcc <cc-flags> -flto -c f1.c -o f1.o\n+\t$ gcc <cc-flags> -flto -c f2.c -o f2.o\n+\t...\n+\t$ gcc <cc-flags> -flto -c fN.c -o fN.o\n+\n+   And the final link may or may not include the same <cc-flags> used\n+   to generate the initial object files:\n+\n+   \t$ gcc <ld-flags> -flto -o prog f1.o ... fN.o\n+\n+   Since we will be generating final code during the link step, some\n+   of the flags used during the compile step need to be re-applied\n+   during the link step.  For instance, flags in the -m family.\n+\n+   The idea is to save a selected set of <cc-flags> in a special\n+   section of the initial object files.  This section is then read\n+   during linking and the options re-applied.\n+\n+   FIXME lto.  Currently the scheme is limited in that only the\n+   options saved on the first object file (f1.o) are read back during\n+   the link step.  This means that the options used to compile f1.o\n+   will be applied to ALL the object files in the final link step.\n+   More work needs to be done to implement a merging and validation\n+   mechanism, as this will not be enough for all cases.  */\n+\n+/* Saved options hold the type of the option (currently CL_TARGET or\n+   CL_COMMON), and the code, argument, and value.  */\n+\n+typedef struct GTY(()) opt_d\n+{\n+  unsigned int type;\n+  size_t code;\n+  char *arg;\n+  int value;\n+} opt_t;\n+\n+DEF_VEC_O (opt_t);\n+DEF_VEC_ALLOC_O (opt_t, heap);\n+\n+\n+/* Options are held in two vectors, one for those registered by\n+   command line handling code, and the other for those read in from\n+   any LTO IL input.  */\n+static VEC(opt_t, heap) *user_options = NULL;\n+static VEC(opt_t, heap) *file_options = NULL;\n+\n+/* Iterate FROM in reverse, writing option codes not yet in CODES into *TO.\n+   Mark each new option code encountered in CODES.  */\n+\n+static void\n+reverse_iterate_options (VEC(opt_t, heap) *from, VEC(opt_t, heap) **to,\n+\t\t\t bitmap codes)\n+{\n+  int i;\n+\n+  for (i = VEC_length (opt_t, from); i > 0; i--)\n+    {\n+      const opt_t *const o = VEC_index (opt_t, from, i - 1);\n+\n+      if (bitmap_set_bit (codes, o->code))\n+\tVEC_safe_push (opt_t, heap, *to, o);\n+    }\n+}\n+\n+/* Concatenate options vectors FIRST and SECOND, rationalize so that only the\n+   final of any given option remains, and return the result.  */\n+\n+static VEC(opt_t, heap) *\n+concatenate_options (VEC(opt_t, heap) *first, VEC(opt_t, heap) *second)\n+{\n+  VEC(opt_t, heap) *results = NULL;\n+  bitmap codes = lto_bitmap_alloc ();\n+\n+  reverse_iterate_options (second, &results, codes);\n+  reverse_iterate_options (first, &results, codes);\n+\n+  lto_bitmap_free (codes);\n+  return results;\n+}\n+\n+/* Clear the options vector in *OPTS_P and set it to NULL.  */\n+\n+static void\n+clear_options (VEC(opt_t, heap) **opts_p)\n+{\n+  int i;\n+  opt_t *o;\n+\n+  for (i = 0; VEC_iterate (opt_t, *opts_p, i, o); i++)\n+    free (o->arg);\n+\n+  VEC_free (opt_t, heap, *opts_p);\n+}\n+\n+/* Write LENGTH bytes from ADDR to STREAM.  */\n+\n+static void\n+output_data_stream (struct lto_output_stream *stream,\n+                    const void *addr, size_t length)\n+{\n+  lto_output_data_stream (stream, addr, length);\n+}\n+\n+/* Write string STRING to STREAM.  */\n+\n+static void\n+output_string_stream (struct lto_output_stream *stream, const char *string)\n+{\n+  bool flag = false;\n+\n+  if (string != NULL)\n+    {\n+      const size_t length = strlen (string);\n+\n+      flag = true;\n+      output_data_stream (stream, &flag, sizeof (flag));\n+      output_data_stream (stream, &length, sizeof (length));\n+      output_data_stream (stream, string, length);\n+    }\n+  else\n+    output_data_stream (stream, &flag, sizeof (flag));\n+}\n+\n+/* Read LENGTH bytes from STREAM to ADDR.  */\n+\n+static void\n+input_data_block (struct lto_input_block *ib, void *addr, size_t length)\n+{\n+  size_t i;\n+  unsigned char *const buffer = (unsigned char *const) addr;\n+\n+  for (i = 0; i < length; i++)\n+    buffer[i] = lto_input_1_unsigned (ib);\n+}\n+\n+/* Return a string from IB.  The string is allocated, and the caller is\n+   responsible for freeing it.  */\n+\n+static char *\n+input_string_block (struct lto_input_block *ib)\n+{\n+  bool flag;\n+\n+  input_data_block (ib, &flag, sizeof (flag));\n+  if (flag)\n+    {\n+      size_t length;\n+      char *string;\n+\n+      input_data_block (ib, &length, sizeof (length));\n+      string = (char *) xcalloc (1, length + 1);\n+      input_data_block (ib, string, length);\n+\n+      return string;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+/* Return true if this option is one we need to save in LTO output files.\n+   At present, we pass along all target options, and common options that\n+   involve position independent code.\n+\n+   TODO This list of options requires expansion and rationalization.\n+   Among others, optimization options may well be appropriate here.  */\n+\n+static bool\n+register_user_option_p (size_t code, int type)\n+{\n+  return type == CL_TARGET\n+         || (type == CL_COMMON\n+\t     && (code == OPT_fPIC\n+\t\t || code == OPT_fcommon));\n+}\n+\n+/* Note command line option with the given TYPE and CODE, ARG, and VALUE.\n+   If relevant to LTO, save it in the user options vector.  */\n+\n+void\n+lto_register_user_option (size_t code, const char *arg, int value, int type)\n+{\n+  if (register_user_option_p (code, type))\n+    {\n+      opt_t o;\n+\n+      o.type = type;\n+      o.code = code;\n+      if (arg != NULL)\n+\t{\n+\t  o.arg = (char *) xmalloc (strlen (arg) + 1);\n+\t  strcpy (o.arg, arg);\n+\t}\n+      else\n+\to.arg = NULL;\n+      o.value = value;\n+      VEC_safe_push (opt_t, heap, user_options, &o);\n+    }\n+}\n+\n+/* Empty the saved user options vector.  */\n+\n+void\n+lto_clear_user_options (void)\n+{\n+  clear_options (&user_options);\n+}\n+\n+/* Empty the saved file options vector.  */\n+\n+void\n+lto_clear_file_options (void)\n+{\n+  clear_options (&file_options);\n+}\n+\n+/* Concatenate the user options and any file options read from an LTO IL\n+   file, and serialize them to STREAM.  File options precede user options\n+   so that the latter override the former when reissued.  */\n+\n+static void\n+output_options (struct lto_output_stream *stream)\n+{\n+  VEC(opt_t, heap) *opts = concatenate_options (file_options, user_options);\n+  const size_t length = VEC_length (opt_t, opts);\n+  int i;\n+  opt_t *o;\n+\n+  output_data_stream (stream, &length, sizeof (length));\n+\n+  for (i = 0; VEC_iterate (opt_t, opts, i, o); i++)\n+    {\n+      output_data_stream (stream, &o->type, sizeof (o->type));\n+      output_data_stream (stream, &o->code, sizeof (o->code));\n+      output_string_stream (stream, o->arg);\n+      output_data_stream (stream, &o->value, sizeof (o->value));\n+    }\n+\n+  VEC_free (opt_t, heap, opts);\n+}\n+\n+/* Write currently held options to an LTO IL section.  */\n+\n+void\n+lto_write_options (void)\n+{\n+  char *const section_name = lto_get_section_name (LTO_section_opts, NULL);\n+  struct lto_output_stream stream;\n+  struct lto_simple_header header;\n+  struct lto_output_stream *header_stream;\n+\n+  lto_begin_section (section_name, !flag_wpa);\n+  free (section_name);\n+\n+  memset (&stream, 0, sizeof (stream));\n+  output_options (&stream);\n+\n+  memset (&header, 0, sizeof (header));\n+  header.lto_header.major_version = LTO_major_version;\n+  header.lto_header.minor_version = LTO_minor_version;\n+  header.lto_header.section_type = LTO_section_opts;\n+  \n+  header.compressed_size = 0;\n+  header.main_size = stream.total_size;\n+\n+  header_stream = ((struct lto_output_stream *)\n+\t\t   xcalloc (1, sizeof (*header_stream)));\n+  lto_output_data_stream (header_stream, &header, sizeof (header));\n+  lto_write_stream (header_stream);\n+  free (header_stream);\n+\n+  lto_write_stream (&stream);\n+  lto_end_section ();\n+}\n+\n+/* Unserialize an options vector from IB, and append to file_options.  */\n+\n+static void\n+input_options (struct lto_input_block *ib)\n+{\n+  size_t length, i;\n+\n+  input_data_block (ib, &length, sizeof (length));\n+\n+  for (i = 0; i < length; i++)\n+    {\n+      opt_t o;\n+\n+      input_data_block (ib, &o.type, sizeof (o.type));\n+      input_data_block (ib, &o.code, sizeof (o.code));\n+      o.arg = input_string_block (ib);\n+      input_data_block (ib, &o.value, sizeof (o.value));\n+      VEC_safe_push (opt_t, heap, file_options, &o);\n+    }\n+}\n+\n+/* Read options from an LTO IL section.  */\n+\n+void\n+lto_read_file_options (struct lto_file_decl_data *file_data)\n+{\n+  size_t len;\n+  const char *data;\n+  const struct lto_simple_header *header;\n+  int32_t opts_offset;\n+  struct lto_input_block ib;\n+\n+  data = lto_get_section_data (file_data, LTO_section_opts, NULL, &len);\n+  header = (const struct lto_simple_header *) data;\n+  opts_offset = sizeof (*header);\n+\n+  lto_check_version (header->lto_header.major_version,\n+\t\t     header->lto_header.minor_version);\n+\n+  LTO_INIT_INPUT_BLOCK (ib, data + opts_offset, 0, header->main_size);\n+  input_options (&ib);\n+\n+  lto_free_section_data (file_data, LTO_section_opts, 0, data, len);\n+}\n+\n+/* Re-handle option with type TYPE and CODE, ARG, and VALUE.  Logic extracted\n+   from common_handle_option() in opts.c.\n+\n+   FIXME lto. This section is not complete.  If extended to handle\n+   optimization options, note that changing these after opts.c prescan may\n+   involve also adjusting other options that were defaulted from initial\n+   optimization option values.  */\n+\n+static void\n+handle_common_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n+{\n+  switch (code)\n+    {\n+    case OPT_fPIC:\n+      flag_pic = !!value;\n+      break;\n+\n+    case OPT_fcommon:\n+      flag_no_common = !value;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Concatenate the user options and any file options read from an LTO IL\n+   file, and reissue them as if all had just been read in from the command\n+   line.  As with serialization, file options precede user options.  */\n+\n+void\n+lto_reissue_options (void)\n+{\n+  VEC(opt_t, heap) *opts = concatenate_options (file_options, user_options);\n+  int i;\n+  opt_t *o;\n+\n+  for (i = 0; VEC_iterate (opt_t, opts, i, o); i++)\n+    {\n+      if (o->type == CL_TARGET)\n+\ttargetm.handle_option (o->code, o->arg, o->value);\n+      else if (o->type == CL_COMMON)\n+\thandle_common_option (o->code, o->arg, o->value);\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  VEC_free (opt_t, heap, opts);\n+}"}, {"sha": "da2384e083934885691ca123cf27acb71550d479", "filename": "gcc/lto-section-in.c", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,489 @@\n+/* Input functions for reading LTO sections.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+#include \"input.h\"\n+#include \"varray.h\"\n+#include \"hashtab.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"diagnostic.h\"\n+#include \"except.h\"\n+#include \"vec.h\"\n+#include \"timevar.h\"\n+#include \"output.h\"\n+#include \"lto-streamer.h\"\n+#include \"lto-compress.h\"\n+\n+/* Section names.  These must correspond to the values of\n+   enum lto_section_type.  */\n+const char *lto_section_name[LTO_N_SECTION_TYPES] =\n+{\n+  \"decls\",\n+  \"function_body\",\n+  \"static_initializer\",\n+  \"cgraph\",\n+  \"ipa_pure_const\",\n+  \"ipa_reference\",\n+  \"symtab\",\n+  \"wpa_fixup\",\n+  \"opts\"\n+};\n+\n+unsigned char \n+lto_input_1_unsigned (struct lto_input_block *ib)\n+{\n+  if (ib->p >= ib->len)\n+    internal_error (\"bytecode stream: trying to read %d bytes \"\n+\t\t    \"after the end of the input buffer\", ib->p - ib->len);\n+\n+  return (ib->data[ib->p++]);\n+}\n+\n+\n+/* Read an ULEB128 Number of IB.  */\n+\n+unsigned HOST_WIDE_INT \n+lto_input_uleb128 (struct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\treturn result;\n+    }\n+}\n+\n+/* HOST_WIDEST_INT version of lto_input_uleb128.  IB is as in\n+   lto_input_uleb128.  */\n+\n+unsigned HOST_WIDEST_INT \n+lto_input_widest_uint_uleb128 (struct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDEST_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDEST_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\treturn result;\n+    }\n+}\n+\n+/* Read an SLEB128 Number of IB.  */\n+\n+HOST_WIDE_INT \n+lto_input_sleb128 (struct lto_input_block *ib)\n+{\n+  HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\t{\n+\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (byte & 0x40))\n+\t    result |= - ((HOST_WIDE_INT)1 << shift);\n+\n+\t  return result;\n+\t}\n+    }\n+}\n+\n+\n+/* Hooks so that the ipa passes can call into the lto front end to get\n+   sections.  */\n+\n+static struct lto_file_decl_data ** file_decl_data; \n+static lto_get_section_data_f* get_section_f;\n+static lto_free_section_data_f* free_section_f;\n+\n+\n+/* This is called from the lto front end to set up the hooks that are\n+   used by the ipa passes to get the data that they will\n+   deserialize.  */\n+\n+void \n+lto_set_in_hooks (struct lto_file_decl_data ** data, \n+\t\t  lto_get_section_data_f* get_f,\n+\t\t  lto_free_section_data_f* free_f)\n+{\n+  file_decl_data = data;\n+  get_section_f = get_f;\n+  free_section_f = free_f;\n+}\n+\n+\n+/* Return an array of file decl datas for all of the files passed to\n+   this compilation.  */\n+\n+struct lto_file_decl_data **\n+lto_get_file_decl_data (void)\n+{\n+  gcc_assert (file_decl_data);\n+  return file_decl_data;\n+}\n+\n+/* Buffer structure for accumulating data from compression callbacks.  */\n+\n+struct lto_buffer\n+{\n+  char *data;\n+  size_t length;\n+};\n+\n+/* Compression callback, append LENGTH bytes from DATA to the buffer pointed\n+   to by OPAQUE.  */\n+\n+static void\n+lto_append_data (const char *data, unsigned length, void *opaque)\n+{\n+  struct lto_buffer *buffer = (struct lto_buffer *) opaque;\n+\n+  buffer->data = (char *) xrealloc (buffer->data, buffer->length + length);\n+  memcpy (buffer->data + buffer->length, data, length);\n+  buffer->length += length;\n+}\n+\n+/* Header placed in returned uncompressed data streams.  Allows the\n+   uncompressed allocated data to be mapped back to the underlying\n+   compressed data for use with free_section_f.  */\n+\n+struct lto_data_header\n+{\n+  const char *data;\n+  size_t len;\n+};\n+\n+/* Return a char pointer to the start of a data stream for an LTO pass\n+   or function.  FILE_DATA indicates where to obtain the data.\n+   SECTION_TYPE is the type of information to be obtained.  NAME is\n+   the name of the function and is only used when finding a function\n+   body; otherwise it is NULL.  LEN is the size of the data\n+   returned.  */\n+\n+const char *\n+lto_get_section_data (struct lto_file_decl_data *file_data, \n+\t\t      enum lto_section_type section_type,\n+\t\t      const char *name, \n+\t\t      size_t *len)\n+{\n+  const char *data = (get_section_f) (file_data, section_type, name, len);\n+  const size_t header_length = sizeof (struct lto_data_header);\n+  struct lto_data_header *header;\n+  struct lto_buffer buffer;\n+  struct lto_compression_stream *stream;\n+  lto_stats.section_size[section_type] += *len;\n+\n+  if (data == NULL)\n+    return NULL;\n+\n+  /* FIXME lto: WPA mode does not write compressed sections, so for now\n+     suppress uncompression if flag_ltrans.  */\n+  if (flag_ltrans)\n+    return data;\n+\n+  /* Create a mapping header containing the underlying data and length,\n+     and prepend this to the uncompression buffer.  The uncompressed data\n+     then follows, and a pointer to the start of the uncompressed data is\n+     returned.  */\n+  header = (struct lto_data_header *) xmalloc (header_length);\n+  header->data = data;\n+  header->len = *len;\n+  \n+  buffer.data = (char *) header;\n+  buffer.length = header_length; \n+\n+  stream = lto_start_uncompression (lto_append_data, &buffer);\n+  lto_uncompress_block (stream, data, *len);\n+  lto_end_uncompression (stream);\n+\n+  *len = buffer.length - header_length;\n+  return buffer.data + header_length;\n+}\n+\n+\n+/* Free the data found from the above call.  The first three\n+   parameters are the same as above.  DATA is the data to be freed and\n+   LEN is the length of that data.  */\n+\n+void \n+lto_free_section_data (struct lto_file_decl_data *file_data, \n+\t\t       enum lto_section_type section_type,\n+\t\t       const char *name,\n+\t\t       const char *data,\n+\t\t       size_t len)\n+{\n+  const size_t header_length = sizeof (struct lto_data_header);\n+  const char *real_data = data - header_length;\n+  const struct lto_data_header *header\n+    = (const struct lto_data_header *) real_data;\n+\n+  gcc_assert (free_section_f);\n+\n+  /* FIXME lto: WPA mode does not write compressed sections, so for now\n+     suppress uncompression mapping if flag_ltrans.  */\n+  if (flag_ltrans)\n+    {\n+      (free_section_f) (file_data, section_type, name, data, len);\n+      return;\n+    }\n+\n+  /* The underlying data address has been extracted from the mapping header.\n+     Free that, then free the allocated uncompression buffer.  */\n+  (free_section_f) (file_data, section_type, name, header->data, header->len);\n+  free (CONST_CAST (char *, real_data));\n+}\n+\n+\n+/* Load a section of type SECTION_TYPE from FILE_DATA, parse the\n+   header and then return an input block pointing to the section.  The\n+   raw pointer to the section is returned in DATAR and LEN.  These are\n+   used to free the section.  Return NULL if the section is not present.  */\n+\n+struct lto_input_block *\n+lto_create_simple_input_block (struct lto_file_decl_data *file_data, \n+\t\t\t       enum lto_section_type section_type,\n+\t\t\t       const char **datar, size_t *len)\n+{\n+  const char *data = lto_get_section_data (file_data, section_type, NULL, len);\n+  const struct lto_simple_header * header \n+    = (const struct lto_simple_header *) data;\n+\n+  struct lto_input_block* ib_main;\n+  int32_t main_offset = sizeof (struct lto_simple_header); \n+\n+  if (!data)\n+    return NULL;\n+\n+  ib_main = XNEW (struct lto_input_block);\n+\n+  *datar = data;\n+  LTO_INIT_INPUT_BLOCK_PTR (ib_main, data + main_offset,\n+\t\t\t    0, header->main_size);\n+\n+  return ib_main;\n+}\n+\n+\n+/* Close the section returned from a call to\n+   LTO_CREATE_SIMPLE_INPUT_BLOCK.  IB is the input block returned from\n+   that call.  The FILE_DATA and SECTION_TYPE are the same as what was\n+   passed to that call and the DATA and LEN are what was returned from\n+   that call.  */\n+\n+void\n+lto_destroy_simple_input_block (struct lto_file_decl_data *file_data, \n+\t\t\t\tenum lto_section_type section_type,\n+\t\t\t\tstruct lto_input_block *ib,\n+\t\t\t\tconst char *data, size_t len)\n+{\n+  free (ib);\n+  lto_free_section_data (file_data, section_type, NULL, data, len);\n+}\n+\n+/*****************************************************************************/\n+/* Record renamings of static declarations                                   */\n+/*****************************************************************************/\n+\n+struct lto_renaming_slot\n+{\n+  const char *old_name;\n+  const char *new_name;\n+};\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_name (const void *p)\n+{\n+  const struct lto_renaming_slot *ds = (const struct lto_renaming_slot *) p;\n+  return (hashval_t) htab_hash_string (ds->new_name);\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_name (const void *p1, const void *p2)\n+{\n+  const struct lto_renaming_slot *s1 =\n+    (const struct lto_renaming_slot *) p1;\n+  const struct lto_renaming_slot *s2 =\n+    (const struct lto_renaming_slot *) p2;\n+\n+  return strcmp (s1->new_name, s2->new_name) == 0;\n+}\n+\n+/* Free a renaming table entry.  */\n+\n+static void\n+renaming_slot_free (void *slot)\n+{\n+  struct lto_renaming_slot *s = (struct lto_renaming_slot *) slot;\n+\n+  free (CONST_CAST (void *, (const void *) s->old_name));\n+  free (CONST_CAST (void *, (const void *) s->new_name));\n+  free ((void *) s);\n+}\n+\n+/* Create an empty hash table for recording declaration renamings.  */\n+\n+htab_t\n+lto_create_renaming_table (void)\n+{\n+  return htab_create (37, hash_name, eq_name, renaming_slot_free);\n+}\n+\n+/* Record a declaration name mapping OLD_NAME -> NEW_NAME.  DECL_DATA\n+   holds the renaming hash table to use.  */\n+\n+void\n+lto_record_renamed_decl (struct lto_file_decl_data *decl_data,\n+\t\t\t const char *old_name, const char *new_name)\n+{\n+  void **slot;\n+  struct lto_renaming_slot r_slot;\n+\n+  r_slot.new_name = new_name;\n+  slot = htab_find_slot (decl_data->renaming_hash_table, &r_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct lto_renaming_slot *new_slot = XNEW (struct lto_renaming_slot);\n+      new_slot->old_name = xstrdup (old_name);\n+      new_slot->new_name = xstrdup (new_name);\n+      *slot = new_slot;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Given a string NAME, return the string that it has been mapped to\n+   by lto_record_renamed_decl.  If NAME was not renamed, it is\n+   returned unchanged.  DECL_DATA holds the renaming hash table to use.  */\n+\n+const char *\n+lto_get_decl_name_mapping (struct lto_file_decl_data *decl_data,\n+\t\t\t   const char *name)\n+{\n+  htab_t renaming_hash_table = decl_data->renaming_hash_table;\n+  struct lto_renaming_slot *slot;\n+  struct lto_renaming_slot r_slot;\n+\n+  r_slot.new_name = name;\n+  slot = (struct lto_renaming_slot *) htab_find (renaming_hash_table, &r_slot);\n+  if (slot)\n+    return slot->old_name;\n+  else\n+    return name;\n+}\n+\n+/*****************************************************************************/\n+/* Input decl state object.                                                  */\n+/*****************************************************************************/\n+\n+/* Return a newly created in-decl state object. */\n+\n+struct lto_in_decl_state *\n+lto_new_in_decl_state (void)\n+{\n+  struct lto_in_decl_state *state;\n+\n+  state = ((struct lto_in_decl_state *) xmalloc (sizeof (*state)));\n+  memset (state, 0, sizeof (*state));\n+  return state;\n+}\n+\n+/* Delete STATE and its components. */\n+\n+void\n+lto_delete_in_decl_state (struct lto_in_decl_state *state)\n+{\n+  int i;\n+\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    if (state->streams[i].trees)\n+      free (state->streams[i].trees);\n+  free (state);\n+}\n+\n+/* Hashtable helpers. lto_in_decl_states are hash by their function decls. */\n+\n+hashval_t\n+lto_hash_in_decl_state (const void *p)\n+{\n+  const struct lto_in_decl_state *state = (const struct lto_in_decl_state *) p;\n+  return htab_hash_pointer (state->fn_decl);\n+}\n+\n+/* Return true if the fn_decl field of the lto_in_decl_state pointed to by\n+   P1 equals to the function decl P2. */\n+\n+int\n+lto_eq_in_decl_state (const void *p1, const void *p2)\n+{\n+  const struct lto_in_decl_state *state1 =\n+   (const struct lto_in_decl_state *) p1;\n+  const struct lto_in_decl_state *state2 =\n+   (const struct lto_in_decl_state *) p2;\n+  return state1->fn_decl == state2->fn_decl;\n+}\n+\n+\n+/* Search the in-decl state of a function FUNC contained in the file\n+   associated with FILE_DATA.  Return NULL if not found.  */\n+\n+struct lto_in_decl_state*\n+lto_get_function_in_decl_state (struct lto_file_decl_data *file_data,\n+\t\t\t\ttree func)\n+{\n+  struct lto_in_decl_state temp;\n+  void **slot;\n+\n+  temp.fn_decl = func;\n+  slot = htab_find_slot (file_data->function_decl_states, &temp, NO_INSERT);\n+  return slot? ((struct lto_in_decl_state*) *slot) : NULL;\n+}"}, {"sha": "e347027c709271e388f5130bb285e80d65b00b5a", "filename": "gcc/lto-section-out.c", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,652 @@\n+/* Functions for writing LTO sections.\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"params.h\"\n+#include \"input.h\"\n+#include \"varray.h\"\n+#include \"hashtab.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"except.h\"\n+#include \"vec.h\"\n+#include \"pointer-set.h\"\n+#include \"bitmap.h\"\n+#include \"langhooks.h\"\n+#include \"lto-streamer.h\"\n+#include \"lto-compress.h\"\n+\n+static VEC(lto_out_decl_state_ptr, heap) *decl_state_stack;\n+\n+/* List of out decl states used by functions.  We use this to\n+   generate the decl directory later. */\n+\n+VEC(lto_out_decl_state_ptr, heap) *lto_function_decl_states;\n+\n+/* Bitmap indexed by DECL_UID to indicate if a function needs to be\n+   forced extern inline. */\n+static bitmap forced_extern_inline;\n+\n+/* Initialize states for determining which function decls to be ouput\n+   as extern inline, regardless of the decls' own attributes.  */\n+\n+void\n+lto_new_extern_inline_states (void)\n+{\n+  forced_extern_inline = lto_bitmap_alloc ();\n+}\n+\n+/* Releasing resources use for states to determine which function decls\n+   to be ouput as extern inline */\n+\n+void\n+lto_delete_extern_inline_states (void)\n+{\n+  lto_bitmap_free (forced_extern_inline);\n+  forced_extern_inline = NULL;\n+}\n+\n+/* Force all the functions in DECLS to be output as extern inline.\n+   DECLS is a bitmap indexed by DECL_UID. */\n+ \n+void\n+lto_force_functions_extern_inline (bitmap decls)\n+{\n+  bitmap_ior_into (forced_extern_inline, decls);\n+}\n+\n+/* Return true if FN_DECL is a function which should be emitted as\n+   extern inline.  */\n+\n+bool\n+lto_forced_extern_inline_p (tree fn_decl)\n+{\n+  return bitmap_bit_p (forced_extern_inline, DECL_UID (fn_decl));\n+}\n+\n+/* Returns a hash code for P.  */\n+\n+hashval_t\n+lto_hash_decl_slot_node (const void *p)\n+{\n+  const struct lto_decl_slot *ds = (const struct lto_decl_slot *) p;\n+\n+  /*\n+    return (hashval_t) DECL_UID (ds->t);\n+  */\n+  return (hashval_t) TREE_HASH (ds->t);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+int\n+lto_eq_decl_slot_node (const void *p1, const void *p2)\n+{\n+  const struct lto_decl_slot *ds1 =\n+    (const struct lto_decl_slot *) p1;\n+  const struct lto_decl_slot *ds2 =\n+    (const struct lto_decl_slot *) p2;\n+\n+  /*\n+  return DECL_UID (ds1->t) == DECL_UID (ds2->t);\n+  */\n+  return ds1->t == ds2->t;\n+}\n+\n+\n+/* Returns a hash code for P.  */\n+\n+hashval_t\n+lto_hash_type_slot_node (const void *p)\n+{\n+  const struct lto_decl_slot *ds = (const struct lto_decl_slot *) p;\n+  return (hashval_t) TYPE_UID (ds->t);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+int\n+lto_eq_type_slot_node (const void *p1, const void *p2)\n+{\n+  const struct lto_decl_slot *ds1 =\n+    (const struct lto_decl_slot *) p1;\n+  const struct lto_decl_slot *ds2 =\n+    (const struct lto_decl_slot *) p2;\n+\n+  return TYPE_UID (ds1->t) == TYPE_UID (ds2->t);\n+}\n+\n+/*****************************************************************************\n+   Output routines shared by all of the serialization passes.\n+*****************************************************************************/\n+\n+\n+/* Flush compressed stream data function, sends NUM_CHARS from CHARS\n+   to the append lang hook, OPAQUE is currently always NULL.  */\n+\n+static void\n+lto_append_data (const char *chars, unsigned int num_chars, void *opaque)\n+{\n+  gcc_assert (opaque == NULL);\n+  lang_hooks.lto.append_data (chars, num_chars, opaque);\n+}\n+\n+/* Pointer to the current compression stream.  */\n+\n+static struct lto_compression_stream *compression_stream = NULL;\n+\n+/* Begin a new output section named NAME. If COMPRESS is true, zlib compress\n+   the section. */\n+\n+void\n+lto_begin_section (const char *name, bool compress)\n+{\n+  lang_hooks.lto.begin_section (name);\n+\n+  /* FIXME lto: for now, suppress compression if the lang_hook that appends\n+     data is anything other than assembler output.  The effect here is that\n+     we get compression of IL only in non-ltrans object files.  */\n+  gcc_assert (compression_stream == NULL);\n+  if (compress)\n+    compression_stream = lto_start_compression (lto_append_data, NULL);\n+}\n+\n+\n+/* End the current output section.  */\n+\n+void\n+lto_end_section (void)\n+{\n+  if (compression_stream)\n+    {\n+      lto_end_compression (compression_stream);\n+      compression_stream = NULL;\n+    }\n+  lang_hooks.lto.end_section ();\n+}\n+\n+\n+/* Write all of the chars in OBS to the assembler.  Recycle the blocks\n+   in obs as this is being done.  */\n+\n+void\n+lto_write_stream (struct lto_output_stream *obs)\n+{\n+  unsigned int block_size = 1024;\n+  struct lto_char_ptr_base *block;\n+  struct lto_char_ptr_base *next_block;\n+  if (!obs->first_block)\n+    return;\n+\n+  for (block = obs->first_block; block; block = next_block)\n+    {\n+      const char *base = ((char *)block) + sizeof (struct lto_char_ptr_base);\n+      unsigned int num_chars = block_size - sizeof (struct lto_char_ptr_base);\n+\n+      /* If this is not the last block, it is full.  If it is the last\n+\t block, left_in_block indicates how many chars are unoccupied in\n+\t this block; subtract from num_chars to obtain occupancy.  */\n+      next_block = (struct lto_char_ptr_base *) block->ptr;\n+      if (!next_block)\n+\tnum_chars -= obs->left_in_block;\n+\n+      /* FIXME lto: WPA mode uses an ELF function as a lang_hook to append\n+         output data.  This hook is not happy with the way that compression\n+         blocks up output differently to the way it's blocked here.  So for\n+         now, we don't compress WPA output.  */\n+      if (compression_stream)\n+\t{\n+\t  lto_compress_block (compression_stream, base, num_chars);\n+\t  lang_hooks.lto.append_data (NULL, 0, block);\n+\t}\n+      else\n+\tlang_hooks.lto.append_data (base, num_chars, block);\n+      block_size *= 2;\n+    }\n+}\n+\n+\n+/* Adds a new block to output stream OBS.  */\n+\n+static void\n+append_block (struct lto_output_stream *obs)\n+{\n+  struct lto_char_ptr_base *new_block;\n+\n+  gcc_assert (obs->left_in_block == 0);\n+\n+  if (obs->first_block == NULL)\n+    {\n+      /* This is the first time the stream has been written\n+\t into.  */\n+      obs->block_size = 1024;\n+      new_block = (struct lto_char_ptr_base*) xmalloc (obs->block_size);\n+      obs->first_block = new_block;\n+    }\n+  else\n+    {\n+      struct lto_char_ptr_base *tptr;\n+      /* Get a new block that is twice as big as the last block\n+\t and link it into the list.  */\n+      obs->block_size *= 2;\n+      new_block = (struct lto_char_ptr_base*) xmalloc (obs->block_size);\n+      /* The first bytes of the block are reserved as a pointer to\n+\t the next block.  Set the chain of the full block to the\n+\t pointer to the new block.  */\n+      tptr = obs->current_block;\n+      tptr->ptr = (char *) new_block;\n+    }\n+\n+  /* Set the place for the next char at the first position after the\n+     chain to the next block.  */\n+  obs->current_pointer\n+    = ((char *) new_block) + sizeof (struct lto_char_ptr_base);\n+  obs->current_block = new_block;\n+  /* Null out the newly allocated block's pointer to the next block.  */\n+  new_block->ptr = NULL;\n+  obs->left_in_block = obs->block_size - sizeof (struct lto_char_ptr_base);\n+}\n+\n+\n+/* Write a character to the output block.  */\n+\n+void\n+lto_output_1_stream (struct lto_output_stream *obs, char c)\n+{\n+  /* No space left.  */\n+  if (obs->left_in_block == 0)\n+    append_block (obs);\n+\n+  /* Write the actual character.  */\n+  *obs->current_pointer = c;\n+  obs->current_pointer++;\n+  obs->total_size++;\n+  obs->left_in_block--;\n+}\n+\n+\n+/* Write raw DATA of length LEN to the output block OB.  */\n+\n+void\n+lto_output_data_stream (struct lto_output_stream *obs, const void *data,\n+\t\t\tsize_t len)\n+{\n+  while (len)\n+    {\n+      size_t copy;\n+\n+      /* No space left.  */\n+      if (obs->left_in_block == 0)\n+\tappend_block (obs);\n+\n+      /* Determine how many bytes to copy in this loop.  */\n+      if (len <= obs->left_in_block)\n+\tcopy = len;\n+      else\n+\tcopy = obs->left_in_block;\n+\n+      /* Copy the data and do bookkeeping.  */\n+      memcpy (obs->current_pointer, data, copy);\n+      obs->current_pointer += copy;\n+      obs->total_size += copy;\n+      obs->left_in_block -= copy;\n+      data = (const char *) data + copy;\n+      len -= copy;\n+    }\n+}\n+\n+\n+/* Output an unsigned LEB128 quantity to OBS.  */\n+\n+void\n+lto_output_uleb128_stream (struct lto_output_stream *obs,\n+\t\t\t   unsigned HOST_WIDE_INT work)\n+{\n+  do\n+    {\n+      unsigned int byte = (work & 0x7f);\n+      work >>= 7;\n+      if (work != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (work != 0);\n+}\n+\n+/* Identical to output_uleb128_stream above except using unsigned \n+   HOST_WIDEST_INT type.  For efficiency on host where unsigned HOST_WIDEST_INT\n+   is not native, we only use this if we know that HOST_WIDE_INT is not wide\n+   enough.  */\n+\n+void\n+lto_output_widest_uint_uleb128_stream (struct lto_output_stream *obs,\n+\t\t\t\t       unsigned HOST_WIDEST_INT work)\n+{\n+  do\n+    {\n+      unsigned int byte = (work & 0x7f);\n+      work >>= 7;\n+      if (work != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (work != 0);\n+}\n+\n+\n+/* Output a signed LEB128 quantity.  */\n+\n+void\n+lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n+{\n+  int more, byte;\n+\n+  do\n+    {\n+      byte = (work & 0x7f);\n+      /* arithmetic shift */\n+      work >>= 7;\n+      more = !((work == 0 && (byte & 0x40) == 0)\n+\t       || (work == -1 && (byte & 0x40) != 0));\n+      if (more)\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (more);\n+}\n+\n+\n+/* Lookup NAME in ENCODER.  If NAME is not found, create a new entry in\n+   ENCODER for NAME with the next available index of ENCODER,  then\n+   print the index to OBS.  True is returned if NAME was added to\n+   ENCODER.  The resulting index is stored in THIS_INDEX.\n+\n+   If OBS is NULL, the only action is to add NAME to the encoder. */\n+\n+bool\n+lto_output_decl_index (struct lto_output_stream *obs,\n+\t\t       struct lto_tree_ref_encoder *encoder,\n+\t\t       tree name, unsigned int *this_index)\n+{\n+  void **slot;\n+  struct lto_decl_slot d_slot;\n+  int index;\n+  bool new_entry_p = FALSE;\n+\n+  d_slot.t = name;\n+  slot = htab_find_slot (encoder->tree_hash_table, &d_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct lto_decl_slot *new_slot\n+\t= (struct lto_decl_slot *) xmalloc (sizeof (struct lto_decl_slot));\n+      index = encoder->next_index++;\n+\n+      new_slot->t = name;\n+      new_slot->slot_num = index;\n+      *slot = new_slot;\n+      VEC_safe_push (tree, heap, encoder->trees, name);\n+      new_entry_p = TRUE;\n+    }\n+  else\n+    {\n+      struct lto_decl_slot *old_slot = (struct lto_decl_slot *)*slot;\n+      index = old_slot->slot_num;\n+    }\n+\n+  if (obs)\n+    lto_output_uleb128_stream (obs, index);\n+  *this_index = index;\n+  return new_entry_p;\n+}\n+\n+/* Output a field DECL to OBS.  */\n+\n+void\n+lto_output_field_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t     struct lto_output_stream * obs, tree decl)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_FIELD_DECL],\n+\t\t\t decl, &index);\n+}\n+\n+/* Output a function DECL to OBS.  */\n+\n+void\n+lto_output_fn_decl_index (struct lto_out_decl_state *decl_state, \n+\t\t\t  struct lto_output_stream * obs, tree decl)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_FN_DECL],\n+\t\t\t decl, &index);\n+}\n+\n+/* Output a namespace DECL to OBS.  */\n+\n+void\n+lto_output_namespace_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t\t struct lto_output_stream * obs, tree decl)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs,\n+\t\t\t &decl_state->streams[LTO_DECL_STREAM_NAMESPACE_DECL],\n+\t\t\t decl, &index);\n+}\n+\n+/* Output a static or extern var DECL to OBS.  */\n+\n+void\n+lto_output_var_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t   struct lto_output_stream * obs, tree decl)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_VAR_DECL],\n+\t\t\t decl, &index);\n+}\n+\n+/* Output a type DECL to OBS.  */\n+\n+void\n+lto_output_type_decl_index (struct lto_out_decl_state *decl_state,\n+\t\t\t    struct lto_output_stream * obs, tree decl)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_TYPE_DECL],\n+\t\t\t decl, &index);\n+}\n+\n+/* Output a type REF to OBS.  */\n+\n+void\n+lto_output_type_ref_index (struct lto_out_decl_state *decl_state,\n+\t\t\t   struct lto_output_stream *obs, tree ref)\n+{\n+  unsigned int index;\n+  lto_output_decl_index (obs, &decl_state->streams[LTO_DECL_STREAM_TYPE],\n+\t\t\t ref, &index);\n+}\n+\n+\n+/* Create the output block and return it.  */\n+\n+struct lto_simple_output_block *\n+lto_create_simple_output_block (enum lto_section_type section_type)\n+{\n+  struct lto_simple_output_block *ob\n+    = ((struct lto_simple_output_block *)\n+       xcalloc (1, sizeof (struct lto_simple_output_block)));\n+\n+  ob->section_type = section_type;\n+  ob->decl_state = lto_get_out_decl_state ();\n+  ob->main_stream = ((struct lto_output_stream *)\n+\t\t     xcalloc (1, sizeof (struct lto_output_stream)));\n+\n+  return ob;\n+}\n+\n+\n+/* Produce a simple section for one of the ipa passes.  */\n+\n+void\n+lto_destroy_simple_output_block (struct lto_simple_output_block *ob)\n+{\n+  char *section_name;\n+  struct lto_simple_header header;\n+  struct lto_output_stream *header_stream;\n+\n+  section_name = lto_get_section_name (ob->section_type, NULL);\n+  lto_begin_section (section_name, !flag_wpa);\n+  free (section_name);\n+\n+  /* Write the header which says how to decode the pieces of the\n+     t.  */\n+  memset (&header, 0, sizeof (struct lto_simple_header));\n+  header.lto_header.major_version = LTO_major_version;\n+  header.lto_header.minor_version = LTO_minor_version;\n+  header.lto_header.section_type = LTO_section_cgraph;\n+  \n+  header.compressed_size = 0;\n+  \n+  header.main_size = ob->main_stream->total_size;\n+\n+  header_stream = XCNEW (struct lto_output_stream);\n+  lto_output_data_stream (header_stream, &header, sizeof header);\n+  lto_write_stream (header_stream);\n+  free (header_stream);\n+\n+  lto_write_stream (ob->main_stream);\n+\n+  /* Put back the assembly section that was there before we started\n+     writing lto info.  */\n+  lto_end_section ();\n+\n+  free (ob->main_stream);\n+  free (ob);\n+}\n+\n+\n+/* Return a new lto_out_decl_state. */\n+\n+struct lto_out_decl_state *\n+lto_new_out_decl_state (void)\n+{\n+  struct lto_out_decl_state *state = XCNEW (struct lto_out_decl_state);\n+  int i;\n+  htab_hash hash_fn;\n+  htab_eq eq_fn;\n+\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    {\n+      if (i == LTO_DECL_STREAM_TYPE)\n+\t{\n+\t  hash_fn = lto_hash_type_slot_node;\n+\t  eq_fn = lto_eq_type_slot_node;\n+\t}\n+      else\n+\t{\n+\t  hash_fn = lto_hash_decl_slot_node;\n+\t  eq_fn = lto_eq_decl_slot_node;\n+\t}\n+      lto_init_tree_ref_encoder (&state->streams[i], hash_fn, eq_fn);\n+    }\n+\n+  state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n+\n+  return state;\n+}\n+\n+\n+/* Delete STATE and components.  */\n+\n+void\n+lto_delete_out_decl_state (struct lto_out_decl_state *state)\n+{\n+  int i;\n+\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    lto_destroy_tree_ref_encoder (&state->streams[i]);\n+\n+  free (state);\n+}\n+\n+\n+/* Get the currently used lto_out_decl_state structure. */\n+\n+struct lto_out_decl_state *\n+lto_get_out_decl_state (void)\n+{\n+  return VEC_last (lto_out_decl_state_ptr, decl_state_stack);\n+}\n+\n+/* Push STATE to top of out decl stack. */\n+\n+void\n+lto_push_out_decl_state (struct lto_out_decl_state *state)\n+{\n+  VEC_safe_push (lto_out_decl_state_ptr, heap, decl_state_stack, state);\n+}\n+\n+/* Pop the currently used out-decl state from top of stack. */\n+\n+struct lto_out_decl_state *\n+lto_pop_out_decl_state (void)\n+{\n+  return VEC_pop (lto_out_decl_state_ptr, decl_state_stack);\n+}\n+\n+/* Record STATE after it has been used in serializing the body of\n+   FN_DECL.  STATE should no longer be used by the caller.  The ownership\n+   of it is taken over from this point.  */\n+\n+void\n+lto_record_function_out_decl_state (tree fn_decl,\n+\t\t\t\t    struct lto_out_decl_state *state)\n+{\n+  int i;\n+\n+  /* Strip all hash tables to save some memory. */\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    if (state->streams[i].tree_hash_table)\n+      {\n+\thtab_delete (state->streams[i].tree_hash_table);\n+\tstate->streams[i].tree_hash_table = NULL;\n+      }\n+  state->fn_decl = fn_decl;\n+  VEC_safe_push (lto_out_decl_state_ptr, heap, lto_function_decl_states,\n+\t\t state);\n+}"}, {"sha": "a8d237959c3ab3fc3c77778a1e10e0d60683c8c4", "filename": "gcc/lto-streamer-in.c", "status": "added", "additions": 2624, "deletions": 0, "changes": 2624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,2624 @@\n+/* Read the GIMPLE representation from a file stream.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+   Re-implemented by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+#include \"input.h\"\n+#include \"varray.h\"\n+#include \"hashtab.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"diagnostic.h\"\n+#include \"libfuncs.h\"\n+#include \"except.h\"\n+#include \"debug.h\"\n+#include \"vec.h\"\n+#include \"timevar.h\"\n+#include \"output.h\"\n+#include \"ipa-utils.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Data structure used to hash file names in the source_location field.  */\n+struct string_slot\n+{\n+  const char *s;\n+  unsigned int slot_num;\n+};\n+\n+/* The table to hold the file names.  */\n+static htab_t file_name_hash_table;\n+\n+\n+/* Check that tag ACTUAL has one of the given values.  NUM_TAGS is the\n+   number of valid tag values to check.  */\n+\n+static void\n+lto_tag_check_set (enum LTO_tags actual, int ntags, ...)\n+{\n+  va_list ap;\n+  int i;\n+\n+  va_start (ap, ntags);\n+  for (i = 0; i < ntags; i++)\n+    if ((unsigned) actual == va_arg (ap, unsigned))\n+      {\n+\tva_end (ap);\n+\treturn;\n+      }\n+\n+  va_end (ap);\n+  internal_error (\"bytecode stream: unexpected tag %s\", lto_tag_name (actual));\n+}\n+\n+\n+/* Check that tag ACTUAL is in the range [TAG1, TAG2].  */\n+\n+static void\n+lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n+\t\t     enum LTO_tags tag2)\n+{\n+  if (actual < tag1 || actual > tag2)\n+    internal_error (\"bytecode stream: tag %s is not in the expected range \"\n+\t\t    \"[%s, %s]\",\n+\t\t    lto_tag_name (actual),\n+\t\t    lto_tag_name (tag1),\n+\t\t    lto_tag_name (tag2));\n+}\n+\n+\n+/* Check that tag ACTUAL == EXPECTED.  */\n+\n+static void\n+lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n+{\n+  if (actual != expected)\n+    internal_error (\"bytecode stream: expected tag %s instead of %s\",\n+\t\t    lto_tag_name (expected), lto_tag_name (actual));\n+}\n+\n+\n+/* Return a hash code for P.  */\n+\n+static hashval_t\n+hash_string_slot_node (const void *p)\n+{\n+  const struct string_slot *ds = (const struct string_slot *) p;\n+  return (hashval_t) htab_hash_string (ds->s);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_string_slot_node (const void *p1, const void *p2)\n+{\n+  const struct string_slot *ds1 = (const struct string_slot *) p1;\n+  const struct string_slot *ds2 = (const struct string_slot *) p2;\n+  return strcmp (ds1->s, ds2->s) == 0;\n+}\n+\n+\n+/* Read a string from the string table in DATA_IN using input block\n+   IB.  Write the length to RLEN.  */\n+\n+static const char *\n+input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n+\t\t       unsigned int *rlen)\n+{\n+  struct lto_input_block str_tab;\n+  unsigned int len;\n+  unsigned int loc;\n+  const char *result;\n+  \n+  loc = lto_input_uleb128 (ib);\n+  LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc, data_in->strings_len);\n+  len = lto_input_uleb128 (&str_tab);\n+  *rlen = len;\n+\n+  if (str_tab.p + len > data_in->strings_len)\n+    internal_error (\"bytecode stream: string too long for the string table\");\n+  \n+  result = (const char *)(data_in->strings + str_tab.p);\n+\n+  return result;\n+}\n+\n+\n+/* Read a STRING_CST from the string table in DATA_IN using input\n+   block IB.  */\n+\n+static tree\n+input_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char * ptr;\n+  unsigned int is_null;\n+\n+  is_null = lto_input_uleb128 (ib);\n+  if (is_null)\n+    return NULL;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  return build_string (len, ptr);\n+}\n+\n+\n+/* Read an IDENTIFIER from the string table in DATA_IN using input\n+   block IB.  */\n+\n+static tree\n+input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char *ptr;\n+  unsigned int is_null;\n+\n+  is_null = lto_input_uleb128 (ib);\n+  if (is_null)\n+    return NULL;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  return get_identifier_with_length (ptr, len);\n+}\n+\n+/* Read a NULL terminated string from the string table in DATA_IN.  */\n+\n+static const char *\n+input_string (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char *ptr;\n+  unsigned int is_null;\n+\n+  is_null = lto_input_uleb128 (ib);\n+  if (is_null)\n+    return NULL;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  if (ptr[len - 1] != '\\0')\n+    internal_error (\"bytecode stream: found non-null terminated string\");\n+\n+  return ptr;\n+}\n+\n+\n+/* Return the next tag in the input block IB.  */\n+\n+static enum LTO_tags\n+input_record_start (struct lto_input_block *ib)\n+{\n+  enum LTO_tags tag = (enum LTO_tags) lto_input_uleb128 (ib);\n+  return tag;\n+} \n+\n+\n+/* Lookup STRING in file_name_hash_table.  If found, return the existing\n+   string, otherwise insert STRING as the canonical version.  */\n+\n+static const char *\n+canon_file_name (const char *string)\n+{\n+  void **slot;\n+  struct string_slot s_slot;\n+  s_slot.s = string;\n+\n+  slot = htab_find_slot (file_name_hash_table, &s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      size_t len;\n+      char *saved_string;\n+      struct string_slot *new_slot;\n+\n+      len = strlen (string);\n+      saved_string = (char *) xmalloc (len + 1);\n+      new_slot = XCNEW (struct string_slot);\n+      strcpy (saved_string, string);\n+      new_slot->s = saved_string;\n+      *slot = new_slot;\n+      return saved_string;\n+    }\n+  else\n+    {\n+      struct string_slot *old_slot = (struct string_slot *) *slot;\n+      return old_slot->s;\n+    }\n+}\n+\n+\n+/* Clear the line info stored in DATA_IN.  */\n+\n+static void\n+clear_line_info (struct data_in *data_in)\n+{\n+  if (data_in->current_file)\n+    linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+  data_in->current_file = NULL;\n+  data_in->current_line = 0;\n+  data_in->current_col = 0;\n+}\n+\n+\n+/* Read a location from input block IB.  */\n+\n+static location_t\n+lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  expanded_location xloc;\n+  location_t loc;\n+\n+  xloc.file = input_string (data_in, ib);\n+  if (xloc.file == NULL)\n+    return UNKNOWN_LOCATION;\n+\n+  xloc.line = lto_input_sleb128 (ib);\n+  xloc.column = lto_input_sleb128 (ib);\n+\n+  if (data_in->current_file)\n+    linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+\n+  data_in->current_file = canon_file_name (xloc.file);\n+  data_in->current_line = xloc.line;\n+  data_in->current_col = xloc.column;\n+\n+  linemap_add (line_table, LC_ENTER, false, data_in->current_file, xloc.line);\n+  LINEMAP_POSITION_FOR_COLUMN (loc, line_table, xloc.column);\n+\n+  return loc;\n+}\n+\n+\n+/* Read a reference to a tree node from DATA_IN using input block IB.\n+   TAG is the expected node that should be found in IB, if TAG belongs\n+   to one of the indexable trees, expect to read a reference index to\n+   be looked up in one of the symbol tables, otherwise read the pysical\n+   representation of the tree using lto_input_tree.  FN is the\n+   function scope for the read tree.  */\n+\n+static tree\n+lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in, \n+\t\t    struct function *fn, enum LTO_tags tag)\n+{\n+  unsigned HOST_WIDE_INT ix_u;\n+  tree result = NULL_TREE;\n+\n+  lto_tag_check_range (tag, LTO_field_decl_ref, LTO_global_decl_ref);\n+\n+  switch (tag)\n+    {\n+    case LTO_type_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_type (data_in->file_data, ix_u);\n+      break;\n+\n+    case LTO_ssa_name_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = VEC_index (tree, SSANAMES (fn), ix_u);\n+      break;\n+\n+    case LTO_field_decl_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_field_decl (data_in->file_data, ix_u);\n+      break;\n+\n+    case LTO_function_decl_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_fn_decl (data_in->file_data, ix_u);\n+      break;\n+\n+    case LTO_type_decl_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_type_decl (data_in->file_data, ix_u);\n+      break;\n+\n+    case LTO_namespace_decl_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_namespace_decl (data_in->file_data, ix_u);\n+      break;\n+\n+    case LTO_global_decl_ref:\n+    case LTO_result_decl_ref:\n+    case LTO_const_decl_ref:\n+    case LTO_imported_decl_ref:\n+    case LTO_label_decl_ref:\n+      ix_u = lto_input_uleb128 (ib);\n+      result = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n+      if (tag == LTO_global_decl_ref)\n+\tvarpool_mark_needed_node (varpool_node (result));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_assert (result);\n+\n+  return result;\n+}\n+\n+\n+/* Read and return a double-linked list of catch handlers from input\n+   block IB, using descriptors in DATA_IN.  */\n+\n+static struct eh_catch_d *\n+lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t\t eh_catch *last_p)\n+{\n+  eh_catch first;\n+  enum LTO_tags tag;\n+\n+  *last_p = first = NULL;\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      tree list;\n+      eh_catch n;\n+\n+      lto_tag_check_range (tag, LTO_eh_catch, LTO_eh_catch);\n+\n+      /* Read the catch node.  */\n+      n = GGC_CNEW (struct eh_catch_d);\n+      n->type_list = lto_input_tree (ib, data_in);\n+      n->filter_list = lto_input_tree (ib, data_in);\n+      n->label = lto_input_tree (ib, data_in);\n+\n+      /* Register all the types in N->FILTER_LIST.  */\n+      for (list = n->filter_list; list; list = TREE_CHAIN (list))\n+\tadd_type_for_runtime (TREE_VALUE (list));\n+\n+      /* Chain N to the end of the list.  */\n+      if (*last_p)\n+\t(*last_p)->next_catch = n;\n+      n->prev_catch = *last_p;\n+      *last_p = n;\n+\n+      /* Set the head of the list the first time through the loop.  */\n+      if (first == NULL)\n+\tfirst = n;\n+\n+      tag = input_record_start (ib);\n+    }\n+\n+  return first;\n+}\n+\n+\n+/* Read and return EH region IX from input block IB, using descriptors\n+   in DATA_IN.  */\n+\n+static eh_region\n+input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n+{\n+  enum LTO_tags tag;\n+  eh_region r;\n+\n+  /* Read the region header.  */\n+  tag = input_record_start (ib);\n+  if (tag == LTO_null)\n+    return NULL;\n+\n+  r = GGC_CNEW (struct eh_region_d);\n+  r->index = lto_input_sleb128 (ib);\n+\n+  gcc_assert (r->index == ix);\n+\n+  /* Read all the region pointers as region numbers.  We'll fix up\n+     the pointers once the whole array has been read.  */\n+  r->outer = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+  r->inner = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+  r->next_peer = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+\n+  switch (tag)\n+    {\n+      case LTO_ert_cleanup:\n+\tr->type = ERT_CLEANUP;\n+\tbreak;\n+\n+      case LTO_ert_try:\n+\t{\n+\t  struct eh_catch_d *last_catch;\n+\t  r->type = ERT_TRY;\n+\t  r->u.eh_try.first_catch = lto_input_eh_catch_list (ib, data_in,\n+\t\t\t\t\t\t\t     &last_catch);\n+\t  r->u.eh_try.last_catch = last_catch;\n+\t  break;\n+\t}\n+\n+      case LTO_ert_allowed_exceptions:\n+\t{\n+\t  tree l;\n+\n+\t  r->type = ERT_ALLOWED_EXCEPTIONS;\n+\t  r->u.allowed.type_list = lto_input_tree (ib, data_in);\n+\t  r->u.allowed.label = lto_input_tree (ib, data_in);\n+\t  r->u.allowed.filter = lto_input_uleb128 (ib);\n+\n+\t  for (l = r->u.allowed.type_list; l ; l = TREE_CHAIN (l))\n+\t    add_type_for_runtime (TREE_VALUE (l));\n+\t}\n+\tbreak;\n+\n+      case LTO_ert_must_not_throw:\n+\tr->type = ERT_MUST_NOT_THROW;\n+\tr->u.must_not_throw.failure_decl = lto_input_tree (ib, data_in);\n+\tr->u.must_not_throw.failure_loc = lto_input_location (ib, data_in);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  r->landing_pads = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n+\n+  return r;\n+}\n+\n+\n+/* Read and return EH landing pad IX from input block IB, using descriptors\n+   in DATA_IN.  */\n+\n+static eh_landing_pad\n+input_eh_lp (struct lto_input_block *ib, struct data_in *data_in, int ix)\n+{\n+  enum LTO_tags tag;\n+  eh_landing_pad lp;\n+\n+  /* Read the landing pad header.  */\n+  tag = input_record_start (ib);\n+  if (tag == LTO_null)\n+    return NULL;\n+\n+  lto_tag_check_range (tag, LTO_eh_landing_pad, LTO_eh_landing_pad);\n+\n+  lp = GGC_CNEW (struct eh_landing_pad_d);\n+  lp->index = lto_input_sleb128 (ib);\n+  gcc_assert (lp->index == ix);\n+  lp->next_lp = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n+  lp->region = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+  lp->post_landing_pad = lto_input_tree (ib, data_in);\n+\n+  return lp;\n+}\n+\n+\n+/* After reading the EH regions, pointers to peer and children regions\n+   are region numbers.  This converts all these region numbers into\n+   real pointers into the rematerialized regions for FN.  ROOT_REGION\n+   is the region number for the root EH region in FN.  */\n+\n+static void\n+fixup_eh_region_pointers (struct function *fn, HOST_WIDE_INT root_region)\n+{\n+  unsigned i;\n+  VEC(eh_region,gc) *eh_array = fn->eh->region_array;\n+  VEC(eh_landing_pad,gc) *lp_array = fn->eh->lp_array;\n+  eh_region r;\n+  eh_landing_pad lp;\n+\n+  gcc_assert (eh_array && lp_array);\n+\n+  gcc_assert (root_region >= 0);\n+  fn->eh->region_tree = VEC_index (eh_region, eh_array, root_region);\n+\n+#define FIXUP_EH_REGION(r) (r) = VEC_index (eh_region, eh_array, \\\n+\t\t\t\t\t    (HOST_WIDE_INT) (intptr_t) (r))\n+#define FIXUP_EH_LP(p) (p) = VEC_index (eh_landing_pad, lp_array, \\\n+\t\t\t\t\t(HOST_WIDE_INT) (intptr_t) (p))\n+\n+  /* Convert all the index numbers stored in pointer fields into\n+     pointers to the corresponding slots in the EH region array.  */\n+  for (i = 0; VEC_iterate (eh_region, eh_array, i, r); i++)\n+    {\n+      /* The array may contain NULL regions.  */\n+      if (r == NULL)\n+\tcontinue;\n+\n+      gcc_assert (i == (unsigned) r->index);\n+      FIXUP_EH_REGION (r->outer);\n+      FIXUP_EH_REGION (r->inner);\n+      FIXUP_EH_REGION (r->next_peer);\n+      FIXUP_EH_LP (r->landing_pads);\n+    }\n+\n+  /* Convert all the index numbers stored in pointer fields into\n+     pointers to the corresponding slots in the EH landing pad array.  */\n+  for (i = 0; VEC_iterate (eh_landing_pad, lp_array, i, lp); i++)\n+    {\n+      /* The array may contain NULL landing pads.  */\n+      if (lp == NULL)\n+\tcontinue;\n+\n+      gcc_assert (i == (unsigned) lp->index);\n+      FIXUP_EH_LP (lp->next_lp);\n+      FIXUP_EH_REGION (lp->region);\n+    }\n+\n+#undef FIXUP_EH_REGION\n+#undef FIXUP_EH_LP\n+}\n+\n+\n+/* Initialize EH support.  */\n+\n+static void\n+lto_init_eh (void)\n+{\n+  /* Contrary to most other FEs, we only initialize EH support when at\n+     least one of the files in the set contains exception regions in\n+     it.  Since this happens much later than the call to init_eh in\n+     lang_dependent_init, we have to set flag_exceptions and call\n+     init_eh again to initialize the EH tables.  */\n+  flag_exceptions = 1;\n+  init_eh ();\n+\n+  /* Initialize dwarf2 tables.  Since dwarf2out_do_frame() returns\n+     true only when exceptions are enabled, this initialization is\n+     never done during lang_dependent_init.  */\n+#if defined DWARF2_DEBUGGING_INFO || defined DWARF2_UNWIND_INFO\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_init ();\n+#endif\n+}\n+\n+\n+/* Read the exception table for FN from IB using the data descriptors\n+   in DATA_IN.  */\n+\n+static void\n+input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t  struct function *fn)\n+{\n+  HOST_WIDE_INT i, root_region, len;\n+  enum LTO_tags tag;\n+  static bool eh_initialized_p = false;\n+  \n+  tag = input_record_start (ib);\n+  if (tag == LTO_null)\n+    return;\n+\n+  lto_tag_check_range (tag, LTO_eh_table, LTO_eh_table);\n+\n+  /* If the file contains EH regions, then it was compiled with\n+     -fexceptions.  In that case, initialize the backend EH\n+     machinery.  */\n+  if (!eh_initialized_p)\n+    {\n+      lto_init_eh ();\n+      eh_initialized_p = true;\n+    }\n+\n+  gcc_assert (fn->eh);\n+\n+  root_region = lto_input_sleb128 (ib);\n+  gcc_assert (root_region == (int) root_region);\n+\n+  /* Read the EH region array.  */\n+  len = lto_input_sleb128 (ib);\n+  gcc_assert (len == (int) len);\n+  if (len > 0)\n+    {\n+      VEC_safe_grow (eh_region, gc, fn->eh->region_array, len);\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  eh_region r = input_eh_region (ib, data_in, i);\n+\t  VEC_replace (eh_region, fn->eh->region_array, i, r);\n+\t}\n+    }\n+\n+  /* Read the landing pads.  */\n+  len = lto_input_sleb128 (ib);\n+  gcc_assert (len == (int) len);\n+  if (len > 0)\n+    {\n+      VEC_safe_grow (eh_landing_pad, gc, fn->eh->lp_array, len);\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  eh_landing_pad lp = input_eh_lp (ib, data_in, i);\n+\t  VEC_replace (eh_landing_pad, fn->eh->lp_array, i, lp);\n+\t}\n+    }\n+\n+  /* Read the runtime type data.  */\n+  len = lto_input_sleb128 (ib);\n+  gcc_assert (len == (int) len);\n+  if (len > 0)\n+    {\n+      VEC_safe_grow (tree, gc, fn->eh->ttype_data, len);\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  tree ttype = lto_input_tree (ib, data_in);\n+\t  VEC_replace (tree, fn->eh->ttype_data, i, ttype);\n+\t}\n+    }\n+\n+  /* Read the table of action chains.  */\n+  len = lto_input_sleb128 (ib);\n+  gcc_assert (len == (int) len);\n+  if (len > 0)\n+    {\n+      if (targetm.arm_eabi_unwinder)\n+\t{\n+\t  VEC_safe_grow (tree, gc, fn->eh->ehspec_data.arm_eabi, len);\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      tree t = lto_input_tree (ib, data_in);\n+\t      VEC_replace (tree, fn->eh->ehspec_data.arm_eabi, i, t);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  VEC_safe_grow (uchar, gc, fn->eh->ehspec_data.other, len);\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      uchar c = lto_input_1_unsigned (ib);\n+\t      VEC_replace (uchar, fn->eh->ehspec_data.other, i, c);\n+\t    }\n+\t}\n+    }\n+\n+  /* Reconstruct the EH region tree by fixing up the peer/children\n+     pointers.  */\n+  fixup_eh_region_pointers (fn, root_region);\n+\n+  tag = input_record_start (ib);\n+  lto_tag_check_range (tag, LTO_null, LTO_null);\n+}\n+\n+\n+/* Make a new basic block with index INDEX in function FN.  */\n+\n+static basic_block\n+make_new_block (struct function *fn, unsigned int index)\n+{\n+  basic_block bb = alloc_block ();\n+  bb->index = index;\n+  SET_BASIC_BLOCK_FOR_FUNCTION (fn, index, bb);\n+  bb->il.gimple = GGC_CNEW (struct gimple_bb_info);\n+  n_basic_blocks_for_function (fn)++;\n+  bb->flags = 0;\n+  set_bb_seq (bb, gimple_seq_alloc ());\n+  return bb;\n+}\n+\n+\n+/* Read the CFG for function FN from input block IB.  */\n+\n+static void \n+input_cfg (struct lto_input_block *ib, struct function *fn)\n+{\n+  unsigned int bb_count;\n+  basic_block p_bb;\n+  unsigned int i;\n+  int index;\n+\n+  init_empty_tree_cfg_for_function (fn);\n+  init_ssa_operands ();\n+\n+  profile_status_for_function (fn) = \n+    (enum profile_status_d) lto_input_uleb128 (ib);\n+\n+  bb_count = lto_input_uleb128 (ib);\n+\n+  last_basic_block_for_function (fn) = bb_count;\n+  if (bb_count > VEC_length (basic_block, basic_block_info_for_function (fn)))\n+    VEC_safe_grow_cleared (basic_block, gc,\n+\t\t\t   basic_block_info_for_function (fn), bb_count);\n+\n+  if (bb_count > VEC_length (basic_block, label_to_block_map_for_function (fn)))\n+    VEC_safe_grow_cleared (basic_block, gc, \n+\t\t\t   label_to_block_map_for_function (fn), bb_count);\n+\n+  index = lto_input_sleb128 (ib);\n+  while (index != -1)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n+      unsigned int edge_count;\n+\n+      if (bb == NULL)\n+\tbb = make_new_block (fn, index);\n+\n+      edge_count = lto_input_uleb128 (ib);\n+\n+      /* Connect up the CFG.  */\n+      for (i = 0; i < edge_count; i++)\n+\t{\n+\t  unsigned int dest_index;\n+\t  unsigned int edge_flags;\n+\t  basic_block dest;\n+\t  int probability;\n+\t  gcov_type count;\n+\t  edge e;\n+\n+\t  dest_index = lto_input_uleb128 (ib);\n+\t  probability = (int) lto_input_sleb128 (ib);\n+\t  count = (gcov_type) lto_input_sleb128 (ib);\n+\t  edge_flags = lto_input_uleb128 (ib);\n+\n+\t  dest = BASIC_BLOCK_FOR_FUNCTION (fn, dest_index);\n+\n+\t  if (dest == NULL) \n+\t    dest = make_new_block (fn, dest_index);\n+\n+\t  e = make_edge (bb, dest, edge_flags);\n+\t  e->probability = probability;\n+\t  e->count = count;\n+\t}\n+\n+      index = lto_input_sleb128 (ib);\n+    }\n+\n+  p_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION(fn);\n+  index = lto_input_sleb128 (ib);\n+  while (index != -1)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n+      bb->prev_bb = p_bb;\n+      p_bb->next_bb = bb;\n+      p_bb = bb;\n+      index = lto_input_sleb128 (ib);\n+    }\n+}\n+\n+\n+/* Read a PHI function for basic block BB in function FN.  DATA_IN is\n+   the file being read.  IB is the input block to use for reading.  */\n+\n+static gimple\n+input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n+\t   struct function *fn)\n+{\n+  unsigned HOST_WIDE_INT ix;\n+  tree phi_result;\n+  int i, len;\n+  gimple result;\n+\n+  ix = lto_input_uleb128 (ib);\n+  phi_result = VEC_index (tree, SSANAMES (fn), ix);\n+  len = EDGE_COUNT (bb->preds);\n+  result = create_phi_node (phi_result, bb);\n+  SSA_NAME_DEF_STMT (phi_result) = result;\n+\n+  /* We have to go through a lookup process here because the preds in the\n+     reconstructed graph are generally in a different order than they\n+     were in the original program.  */\n+  for (i = 0; i < len; i++)\n+    {\n+      tree def = lto_input_tree (ib, data_in);\n+      int src_index = lto_input_uleb128 (ib);\n+      location_t arg_loc = lto_input_location (ib, data_in);\n+      basic_block sbb = BASIC_BLOCK_FOR_FUNCTION (fn, src_index);\n+      \n+      edge e = NULL;\n+      int j;\n+      \n+      for (j = 0; j < len; j++)\n+\tif (EDGE_PRED (bb, j)->src == sbb)\n+\t  {\n+\t    e = EDGE_PRED (bb, j);\n+\t    break;\n+\t  }\n+\n+      add_phi_arg (result, def, e, arg_loc); \n+    }\n+\n+  return result;\n+}\n+\n+\n+/* Read the SSA names array for function FN from DATA_IN using input\n+   block IB.  */\n+\n+static void\n+input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t struct function *fn)\n+{\n+  unsigned int i, size;\n+\n+  size = lto_input_uleb128 (ib);\n+  init_ssanames (fn, size);\n+\n+  i = lto_input_uleb128 (ib);\n+  while (i)\n+    {\n+      tree ssa_name, name;\n+      bool is_default_def;\n+\n+      /* Skip over the elements that had been freed.  */\n+      while (VEC_length (tree, SSANAMES (fn)) < i)\n+\tVEC_quick_push (tree, SSANAMES (fn), NULL_TREE);\n+\n+      is_default_def = (lto_input_1_unsigned (ib) != 0);\n+      name = lto_input_tree (ib, data_in);\n+      ssa_name = make_ssa_name_fn (fn, name, gimple_build_nop ());\n+\n+      if (is_default_def)\n+\tset_default_def (SSA_NAME_VAR (ssa_name), ssa_name);\n+\n+      i = lto_input_uleb128 (ib);\n+    } \n+}\n+\n+\n+/* Read a statement with tag TAG in function FN from block IB using\n+   descriptors in DATA_IN.  */\n+\n+static gimple\n+input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t   struct function *fn, enum LTO_tags tag)\n+{\n+  gimple stmt;\n+  enum gimple_code code;\n+  unsigned HOST_WIDE_INT num_ops;\n+  size_t i;\n+  struct bitpack_d *bp;\n+\n+  code = lto_tag_to_gimple_code (tag);\n+\n+  /* Read the tuple header.  */\n+  bp = lto_input_bitpack (ib);\n+  num_ops = bp_unpack_value (bp, sizeof (unsigned) * 8);\n+  stmt = gimple_alloc (code, num_ops);\n+  stmt->gsbase.no_warning = bp_unpack_value (bp, 1);\n+  if (is_gimple_assign (stmt))\n+    stmt->gsbase.nontemporal_move = bp_unpack_value (bp, 1);\n+  stmt->gsbase.has_volatile_ops = bp_unpack_value (bp, 1);\n+  stmt->gsbase.subcode = bp_unpack_value (bp, 16);\n+  bitpack_delete (bp);\n+\n+  /* Read location information.  */\n+  gimple_set_location (stmt, lto_input_location (ib, data_in));\n+\n+  /* Read lexical block reference.  */\n+  gimple_set_block (stmt, lto_input_tree (ib, data_in));\n+\n+  /* Read in all the operands.  */\n+  switch (code)\n+    {\n+    case GIMPLE_RESX:\n+      gimple_resx_set_region (stmt, lto_input_sleb128 (ib));\n+      break;\n+\n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      gimple_eh_must_not_throw_set_fndecl (stmt, lto_input_tree (ib, data_in));\n+      break;\n+\n+    case GIMPLE_EH_DISPATCH:\n+      gimple_eh_dispatch_set_region (stmt, lto_input_sleb128 (ib));\n+      break;\n+\n+    case GIMPLE_ASM:\n+      {\n+\t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n+\ttree str;\n+\tstmt->gimple_asm.ni = lto_input_uleb128 (ib);\n+\tstmt->gimple_asm.no = lto_input_uleb128 (ib);\n+\tstmt->gimple_asm.nc = lto_input_uleb128 (ib);\n+\tstr = input_string_cst (data_in, ib);\n+\tstmt->gimple_asm.string = TREE_STRING_POINTER (str);\n+      }\n+      /* Fallthru  */\n+\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_CALL:\n+    case GIMPLE_RETURN:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_LABEL:\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_DEBUG:\n+      for (i = 0; i < num_ops; i++)\n+\t{\n+\t  tree op = lto_input_tree (ib, data_in);\n+\t  gimple_set_op (stmt, i, op);\n+\t}\n+      break;\n+\n+    case GIMPLE_PREDICT:\n+      break;\n+\n+    default:\n+      internal_error (\"bytecode stream: unknown GIMPLE statement tag %s\",\n+\t\t      lto_tag_name (tag));\n+    }\n+\n+  /* Update the properties of symbols, SSA names and labels associated\n+     with STMT.  */\n+  if (code == GIMPLE_ASSIGN || code == GIMPLE_CALL)\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\tSSA_NAME_DEF_STMT (lhs) = stmt;\n+    }\n+  else if (code == GIMPLE_LABEL)\n+    gcc_assert (emit_label_in_global_context_p (gimple_label_label (stmt))\n+\t        || DECL_CONTEXT (gimple_label_label (stmt)) == fn->decl);\n+  else if (code == GIMPLE_ASM)\n+    {\n+      unsigned i;\n+\n+      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+\t{\n+\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t  if (TREE_CODE (op) == SSA_NAME)\n+\t    SSA_NAME_DEF_STMT (op) = stmt;\n+\t}\n+    }\n+\n+  /* Mark the statement modified so its operand vectors can be filled in.  */\n+  gimple_set_modified (stmt, true);\n+\n+  return stmt;\n+}\n+\n+ \n+/* Read a basic block with tag TAG from DATA_IN using input block IB.\n+   FN is the function being processed.  */\n+\n+static void\n+input_bb (struct lto_input_block *ib, enum LTO_tags tag, \n+\t  struct data_in *data_in, struct function *fn)\n+{\n+  unsigned int index;\n+  basic_block bb;\n+  gimple_stmt_iterator bsi;\n+\n+  /* This routine assumes that CFUN is set to FN, as it needs to call\n+     basic GIMPLE routines that use CFUN.  */\n+  gcc_assert (cfun == fn);\n+\n+  index = lto_input_uleb128 (ib);\n+  bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n+\n+  bb->count = lto_input_sleb128 (ib);\n+  bb->loop_depth = lto_input_sleb128 (ib);\n+  bb->frequency = lto_input_sleb128 (ib);\n+  bb->flags = lto_input_sleb128 (ib);\n+\n+  /* LTO_bb1 has statements.  LTO_bb0 does not.  */\n+  if (tag == LTO_bb0)\n+    return;\n+\n+  bsi = gsi_start_bb (bb);\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      gimple stmt = input_gimple_stmt (ib, data_in, fn, tag);\n+\n+      /* Drop debug stmts on-the-fly if we do not have VTA enabled.\n+\t This allows us to build for example static libs with debugging\n+\t enabled and do the final link without.  */\n+      if (MAY_HAVE_DEBUG_STMTS\n+\t  || !is_gimple_debug (stmt))\n+\t{\n+\t  find_referenced_vars_in (stmt);\n+\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t}\n+\n+      /* After the statement, expect a 0 delimiter or the EH region\n+\t that the previous statement belongs to.  */\n+      tag = input_record_start (ib);\n+      lto_tag_check_set (tag, 2, LTO_eh_region, LTO_null);\n+\n+      if (tag == LTO_eh_region)\n+\t{\n+\t  HOST_WIDE_INT region = lto_input_sleb128 (ib);\n+\t  gcc_assert (region == (int) region);\n+\t  if (MAY_HAVE_DEBUG_STMTS || !is_gimple_debug (stmt))\n+\t    add_stmt_to_eh_lp (stmt, region);\n+\t}\n+\n+      tag = input_record_start (ib);\n+    }\n+\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      gimple phi = input_phi (ib, bb, data_in, fn);\n+      find_referenced_vars_in (phi);\n+      tag = input_record_start (ib);\n+    }\n+}\n+\n+/* Go through all NODE edges and fixup call_stmt pointers\n+   so they point to STMTS.  */\n+\n+static void\n+fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts)\n+{\n+  struct cgraph_edge *cedge;\n+  for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n+    cedge->call_stmt = stmts[cedge->lto_stmt_uid];\n+}\n+\n+/* Fixup call_stmt pointers in NODE and all clones.  */\n+\n+static void\n+fixup_call_stmt_edges (struct cgraph_node *orig, gimple *stmts)\n+{\n+  struct cgraph_node *node;\n+\n+  while (orig->clone_of)\n+    orig = orig->clone_of;\n+\n+  fixup_call_stmt_edges_1 (orig, stmts);\n+  if (orig->clones)\n+    for (node = orig->clones; node != orig;)\n+      {\n+\tfixup_call_stmt_edges_1 (node, stmts);\n+\tif (node->clones)\n+\t  node = node->clones;\n+\telse if (node->next_sibling_clone)\n+\t  node = node->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (node != orig && !node->next_sibling_clone)\n+\t      node = node->clone_of;\n+\t    if (node != orig)\n+\t      node = node->next_sibling_clone;\n+\t  }\n+      }\n+}\n+\n+/* Read the body of function FN_DECL from DATA_IN using input block IB.  */\n+\n+static void\n+input_function (tree fn_decl, struct data_in *data_in, \n+\t\tstruct lto_input_block *ib)\n+{\n+  struct function *fn;\n+  enum LTO_tags tag;\n+  gimple *stmts;\n+  basic_block bb;\n+  struct bitpack_d *bp;\n+\n+  fn = DECL_STRUCT_FUNCTION (fn_decl);\n+  tag = input_record_start (ib);\n+  clear_line_info (data_in);\n+\n+  gimple_register_cfg_hooks ();\n+  lto_tag_check (tag, LTO_function);\n+\n+  /* Read all the attributes for FN.  */\n+  bp = lto_input_bitpack (ib);\n+  fn->is_thunk = bp_unpack_value (bp, 1);\n+  fn->has_local_explicit_reg_vars = bp_unpack_value (bp, 1);\n+  fn->after_tree_profile = bp_unpack_value (bp, 1);\n+  fn->returns_pcc_struct = bp_unpack_value (bp, 1);\n+  fn->returns_struct = bp_unpack_value (bp, 1);\n+  fn->always_inline_functions_inlined = bp_unpack_value (bp, 1);\n+  fn->after_inlining = bp_unpack_value (bp, 1);\n+  fn->dont_save_pending_sizes_p = bp_unpack_value (bp, 1);\n+  fn->stdarg = bp_unpack_value (bp, 1);\n+  fn->has_nonlocal_label = bp_unpack_value (bp, 1);\n+  fn->calls_alloca = bp_unpack_value (bp, 1);\n+  fn->calls_setjmp = bp_unpack_value (bp, 1);\n+  fn->function_frequency = (enum function_frequency) bp_unpack_value (bp, 2);\n+  fn->va_list_fpr_size = bp_unpack_value (bp, 8);\n+  fn->va_list_gpr_size = bp_unpack_value (bp, 8);\n+  bitpack_delete (bp);\n+\n+  /* Read the static chain and non-local goto save area.  */\n+  fn->static_chain_decl = lto_input_tree (ib, data_in);\n+  fn->nonlocal_goto_save_area = lto_input_tree (ib, data_in);\n+\n+  /* Read all the local symbols.  */\n+  fn->local_decls = lto_input_tree (ib, data_in);\n+\n+  /* Read all the SSA names.  */\n+  input_ssa_names (ib, data_in, fn);\n+\n+  /* Read the exception handling regions in the function.  */\n+  input_eh_regions (ib, data_in, fn);\n+\n+  /* Read the tree of lexical scopes for the function.  */\n+  DECL_INITIAL (fn_decl) = lto_input_tree (ib, data_in);\n+  gcc_assert (DECL_INITIAL (fn_decl));\n+  DECL_SAVED_TREE (fn_decl) = NULL_TREE;\n+\n+  /* Read all function arguments.  */\n+  DECL_ARGUMENTS (fn_decl) = lto_input_tree (ib, data_in); \n+\n+  /* Read all the basic blocks.  */\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      input_bb (ib, tag, data_in, fn);\n+      tag = input_record_start (ib);\n+    }\n+\n+  /* Fix up the call statements that are mentioned in the callgraph\n+     edges.  */\n+  renumber_gimple_stmt_uids ();\n+  stmts = (gimple *) xcalloc (gimple_stmt_max_uid (fn), sizeof (gimple));\n+  FOR_ALL_BB (bb)\n+    {\n+      gimple_stmt_iterator bsi;\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (bsi);\n+\t  stmts[gimple_uid (stmt)] = stmt;\n+\t}\n+    }\n+\n+  /* Set the gimple body to the statement sequence in the entry\n+     basic block.  FIXME lto, this is fairly hacky.  The existence\n+     of a gimple body is used by the cgraph routines, but we should\n+     really use the presence of the CFG.  */\n+  {\n+    edge_iterator ei = ei_start (ENTRY_BLOCK_PTR->succs);\n+    gimple_set_body (fn_decl, bb_seq (ei_edge (ei)->dest));\n+  }\n+\n+  fixup_call_stmt_edges (cgraph_node (fn_decl), stmts);\n+\n+  update_ssa (TODO_update_ssa_only_virtuals); \n+  free (stmts);\n+}\n+\n+\n+/* Read initializer expressions for public statics.  DATA_IN is the\n+   file being read.  IB is the input block used for reading.  */\n+\n+static void\n+input_alias_pairs (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  tree var;\n+\n+  clear_line_info (data_in);\n+\n+  /* Skip over all the unreferenced globals.  */\n+  do\n+    var = lto_input_tree (ib, data_in);\n+  while (var);\n+\n+  var = lto_input_tree (ib, data_in);\n+  while (var)\n+    {\n+      const char *orig_name, *new_name;\n+      alias_pair *p;\n+      \n+      p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n+      p->decl = var;\n+      p->target = lto_input_tree (ib, data_in);\n+\n+      /* If the target is a static object, we may have registered a\n+\t new name for it to avoid clashes between statics coming from\n+\t different files.  In that case, use the new name.  */\n+      orig_name = IDENTIFIER_POINTER (p->target);\n+      new_name = lto_get_decl_name_mapping (data_in->file_data, orig_name);\n+      if (strcmp (orig_name, new_name) != 0)\n+\tp->target = get_identifier (new_name);\n+\n+      var = lto_input_tree (ib, data_in);\n+    }\n+}\n+\n+\n+/* Read the body from DATA for function FN_DECL and fill it in.\n+   FILE_DATA are the global decls and types.  SECTION_TYPE is either\n+   LTO_section_function_body or LTO_section_static_initializer.  If\n+   section type is LTO_section_function_body, FN must be the decl for\n+   that function.  */\n+\n+static void \n+lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n+\t       const char *data, enum lto_section_type section_type)\n+{\n+  const struct lto_function_header *header;\n+  struct data_in *data_in;\n+  int32_t cfg_offset;\n+  int32_t main_offset;\n+  int32_t string_offset;\n+  struct lto_input_block ib_cfg;\n+  struct lto_input_block ib_main;\n+\n+  header = (const struct lto_function_header *) data;\n+  cfg_offset = sizeof (struct lto_function_header); \n+  main_offset = cfg_offset + header->cfg_size;\n+  string_offset = main_offset + header->main_size;\n+\n+  LTO_INIT_INPUT_BLOCK (ib_cfg,\n+\t\t        data + cfg_offset,\n+\t\t\t0,\n+\t\t\theader->cfg_size);\n+\n+  LTO_INIT_INPUT_BLOCK (ib_main,\n+\t\t\tdata + main_offset,\n+\t\t\t0,\n+\t\t\theader->main_size);\n+  \n+  data_in = lto_data_in_create (file_data, data + string_offset,\n+\t\t\t\theader->string_size, NULL);\n+\n+  /* Make sure the file was generated by the exact same compiler.  */\n+  lto_check_version (header->lto_header.major_version,\n+\t\t     header->lto_header.minor_version);\n+\n+  if (section_type == LTO_section_function_body)\n+    {\n+      struct function *fn = DECL_STRUCT_FUNCTION (fn_decl);\n+      struct lto_in_decl_state *decl_state;\n+\n+      push_cfun (fn);\n+      init_tree_ssa (fn);\n+\n+      /* Use the function's decl state. */\n+      decl_state = lto_get_function_in_decl_state (file_data, fn_decl);\n+      gcc_assert (decl_state);\n+      file_data->current_decl_state = decl_state;\n+\n+      input_cfg (&ib_cfg, fn);\n+\n+      /* Set up the struct function.  */\n+      input_function (fn_decl, data_in, &ib_main);\n+\n+      /* We should now be in SSA.  */\n+      cfun->gimple_df->in_ssa_p = true;\n+\n+      /* Fill in properties we know hold for the rebuilt CFG.  */\n+      cfun->curr_properties = PROP_ssa\n+\t\t\t      | PROP_cfg\n+\t\t\t      | PROP_gimple_any\n+\t\t\t      | PROP_gimple_lcf\n+\t\t\t      | PROP_gimple_leh\n+\t\t\t      | PROP_referenced_vars;\n+\n+      /* Restore decl state */\n+      file_data->current_decl_state = file_data->global_decl_state;\n+\n+      pop_cfun ();\n+    }\n+  else \n+    {\n+      input_alias_pairs (&ib_main, data_in);\n+    }\n+\n+  clear_line_info (data_in);\n+  lto_data_in_delete (data_in);\n+}\n+\n+\n+/* Read the body of FN_DECL using DATA.  FILE_DATA holds the global\n+   decls and types.  */\n+\n+void \n+lto_input_function_body (struct lto_file_decl_data *file_data,\n+\t\t\t tree fn_decl, const char *data)\n+{\n+  current_function_decl = fn_decl;\n+  lto_read_body (file_data, fn_decl, data, LTO_section_function_body);\n+}\n+\n+\n+/* Read in VAR_DECL using DATA.  FILE_DATA holds the global decls and\n+   types.  */\n+\n+void \n+lto_input_constructors_and_inits (struct lto_file_decl_data *file_data,\n+\t\t\t\t  const char *data)\n+{\n+  lto_read_body (file_data, NULL, data, LTO_section_static_initializer);\n+}\n+\n+\n+/* Return the resolution for the decl with index INDEX from DATA_IN. */\n+\n+static enum ld_plugin_symbol_resolution\n+get_resolution (struct data_in *data_in, unsigned index)\n+{\n+  if (data_in->globals_resolution)\n+    {\n+      ld_plugin_symbol_resolution_t ret;\n+      gcc_assert (index < VEC_length (ld_plugin_symbol_resolution_t,\n+\t\t\t\t      data_in->globals_resolution));\n+      ret = VEC_index (ld_plugin_symbol_resolution_t,\n+\t\t       data_in->globals_resolution,\n+\t\t       index);\n+      gcc_assert (ret != LDPR_UNKNOWN);\n+      return ret;\n+    }\n+  else\n+    {\n+      /* Fake symbol resolution if no resolution file was provided.  */\n+      tree t = lto_streamer_cache_get (data_in->reader_cache, index);\n+\n+      gcc_assert (TREE_PUBLIC (t));\n+\n+      /* There should be no DECL_ABSTRACT in the middle end.  */\n+      gcc_assert (!DECL_ABSTRACT (t));\n+\n+      /* If T is a weak definition, we select the first one we see to\n+\t be the prevailing definition.  */\n+      if (DECL_WEAK (t))\n+\t{\n+\t  tree prevailing_decl;\n+\t  if (DECL_EXTERNAL (t))\n+\t    return LDPR_RESOLVED_IR;\n+\n+\t  /* If this is the first time we see T, it won't have a\n+\t     prevailing definition yet.  */\n+\t  prevailing_decl = lto_symtab_prevailing_decl (t);\n+\t  if (prevailing_decl == t\n+\t      || prevailing_decl == NULL_TREE\n+\t      || DECL_EXTERNAL (prevailing_decl))\n+\t    return LDPR_PREVAILING_DEF;\n+\t  else\n+\t    return LDPR_PREEMPTED_IR;\n+\t}\n+      else\n+\t{\n+\t  /* For non-weak definitions, extern declarations are assumed\n+\t     to be resolved elsewhere (LDPR_RESOLVED_IR), otherwise T\n+\t     is a prevailing definition.  */\n+\t  if (DECL_EXTERNAL (t))\n+\t    return LDPR_RESOLVED_IR;\n+\t  else\n+\t    return LDPR_PREVAILING_DEF;\n+\t}\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_BASE structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  /* Note that the code for EXPR has already been unpacked to create EXPR in\n+     lto_materialize_tree.  */\n+  if (!TYPE_P (expr))\n+    {\n+      TREE_SIDE_EFFECTS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      TREE_CONSTANT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      TREE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n+\n+      /* TREE_PUBLIC is used on types to indicate that the type\n+\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n+\t so we skip it here.  */\n+      TREE_PUBLIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+    }\n+  TREE_ADDRESSABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_THIS_VOLATILE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (DECL_P (expr))\n+    DECL_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else if (TYPE_P (expr))\n+    TYPE_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_ASM_WRITTEN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_NO_WARNING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_USED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_NOTHROW (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_STATIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_PRIVATE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_PROTECTED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TYPE_P (expr))\n+    TYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    SSA_NAME_IS_DEFAULT_DEF (expr) = (unsigned) bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_REAL_CST structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  unsigned i;\n+  REAL_VALUE_TYPE r;\n+  REAL_VALUE_TYPE *rp;\n+  \n+  r.cl = (unsigned) bp_unpack_value (bp, 2);\n+  r.decimal = (unsigned) bp_unpack_value (bp, 1);\n+  r.sign = (unsigned) bp_unpack_value (bp, 1);\n+  r.signalling = (unsigned) bp_unpack_value (bp, 1);\n+  r.canonical = (unsigned) bp_unpack_value (bp, 1);\n+  r.uexp = (unsigned) bp_unpack_value (bp, EXP_BITS);\n+  for (i = 0; i < SIGSZ; i++)\n+    r.sig[i] = (unsigned long) bp_unpack_value (bp, HOST_BITS_PER_LONG);\n+\n+  rp = GGC_NEW (REAL_VALUE_TYPE);\n+  memcpy (rp, &r, sizeof (REAL_VALUE_TYPE));\n+  TREE_REAL_CST_PTR (expr) = rp;\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_FIXED_CST structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  struct fixed_value fv;\n+  \n+  fv.data.low = (HOST_WIDE_INT) bp_unpack_value (bp, HOST_BITS_PER_WIDE_INT);\n+  fv.data.high = (HOST_WIDE_INT) bp_unpack_value (bp, HOST_BITS_PER_WIDE_INT);\n+  TREE_FIXED_CST (expr) = fv;\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_COMMON structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_MODE (expr) = (enum machine_mode) bp_unpack_value (bp, 8);\n+  DECL_NONLOCAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_VIRTUAL_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IGNORED_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_PRESERVE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DEBUG_EXPR_IS_FROM (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_EXTERNAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_GIMPLE_REG_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ALIGN (expr) = (unsigned) bp_unpack_value (bp, HOST_BITS_PER_INT);\n+\n+  if (TREE_CODE (expr) == LABEL_DECL)\n+    {\n+      DECL_ERROR_ISSUED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      EH_LANDING_PAD_NR (expr) = (int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n+\n+      /* Always assume an initial value of -1 for LABEL_DECL_UID to\n+\t force gimple_set_bb to recreate label_to_block_map.  */\n+      LABEL_DECL_UID (expr) = -1;\n+    }\n+\n+  if (TREE_CODE (expr) == FIELD_DECL)\n+    {\n+      unsigned HOST_WIDE_INT off_align;\n+      DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      off_align = (unsigned HOST_WIDE_INT) bp_unpack_value (bp, 8);\n+      SET_DECL_OFFSET_ALIGN (expr, off_align);\n+    }\n+\n+  if (TREE_CODE (expr) == RESULT_DECL\n+      || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == VAR_DECL)\n+    {\n+      DECL_BY_REFERENCE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  || TREE_CODE (expr) == PARM_DECL)\n+\tDECL_HAS_VALUE_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_WRTL structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_DEFER_OUTPUT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_COMMON (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DLLIMPORT_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_WEAK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_SEEN_IN_BIND_EXPR_P (expr) = (unsigned) bp_unpack_value (bp,  1);\n+  DECL_COMDAT (expr) = (unsigned) bp_unpack_value (bp,  1);\n+  DECL_VISIBILITY (expr) = (enum symbol_visibility) bp_unpack_value (bp,  2);\n+  DECL_VISIBILITY_SPECIFIED (expr) = (unsigned) bp_unpack_value (bp,  1);\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    {\n+      DECL_HARD_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_IN_TEXT_SECTION (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_TLS_MODEL (expr) = (enum tls_model) bp_unpack_value (bp,  3);\n+    }\n+\n+  if (VAR_OR_FUNCTION_DECL_P (expr))\n+    {\n+      priority_type p;\n+      p = (priority_type) bp_unpack_value (bp, HOST_BITS_PER_SHORT);\n+      SET_DECL_INIT_PRIORITY (expr, p);\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_FUNCTION_DECL structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_FUNCTION_CODE (expr) = (enum built_in_function) bp_unpack_value (bp, 11);\n+  DECL_BUILT_IN_CLASS (expr) = (enum built_in_class) bp_unpack_value (bp, 2);\n+  DECL_STATIC_CONSTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_STATIC_DESTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_UNINLINABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_POSSIBLY_INLINED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_NOVOPS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_RETURNS_TWICE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_MALLOC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_OPERATOR_NEW (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DECLARED_INLINE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_STATIC_CHAIN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_INLINE_WARNING_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr)\n+    \t\t\t= (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_LIMIT_STACK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DISREGARD_INLINE_LIMITS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_LOOPING_CONST_OR_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_TYPE structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_type_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  enum machine_mode mode;\n+\n+  TYPE_PRECISION (expr) = (unsigned) bp_unpack_value (bp, 9);\n+  mode = (enum machine_mode) bp_unpack_value (bp, 7);\n+  SET_TYPE_MODE (expr, mode);\n+  TYPE_STRING_FLAG (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_NO_FORCE_BLK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_NEEDS_CONSTRUCTING(expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TREE_CODE (expr) == UNION_TYPE)\n+    TYPE_TRANSPARENT_UNION (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr)\n+    \t= (unsigned) bp_unpack_value (bp, 2);\n+  TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_ALIGN (expr) = (unsigned) bp_unpack_value (bp, HOST_BITS_PER_INT);\n+  TYPE_ALIAS_SET (expr) = bp_unpack_value (bp, HOST_BITS_PER_INT);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_BLOCK structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  BLOCK_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  BLOCK_NUMBER (expr) = (unsigned) bp_unpack_value (bp, 31);\n+}\n+\n+\n+/* Unpack all the non-pointer fields in EXPR into a bit pack.  */\n+\n+static void\n+unpack_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  /* Note that all these functions are highly sensitive to changes in\n+     the types and sizes of each of the fields being packed.  */\n+  unpack_ts_base_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    unpack_ts_real_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    unpack_ts_fixed_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    unpack_ts_decl_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    unpack_ts_decl_wrtl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    unpack_ts_decl_with_vis_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    unpack_ts_function_decl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n+    unpack_ts_type_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    unpack_ts_block_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_SSA_NAME))\n+    {\n+      /* We only stream the version number of SSA names.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STATEMENT_LIST))\n+    {\n+      /* This is only used by GENERIC.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OMP_CLAUSE))\n+    {\n+      /* This is only used by High GIMPLE.  */\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Read a bitpack from input block IB.  */\n+\n+struct bitpack_d *\n+lto_input_bitpack (struct lto_input_block *ib)\n+{\n+  unsigned i, num_words;\n+  struct bitpack_d *bp;\n+\n+  bp = bitpack_create ();\n+\n+  /* If we are about to read more than a handful of words, something\n+     is wrong.  This check is overly strict, but it acts as an early\n+     warning.  No streamed object has hundreds of bits in its fields.  */\n+  num_words = lto_input_uleb128 (ib);\n+  gcc_assert (num_words < 20);\n+\n+  for (i = 0; i < num_words; i++)\n+    {\n+      bitpack_word_t w = lto_input_uleb128 (ib);\n+      VEC_safe_push (bitpack_word_t, heap, bp->values, w);\n+    }\n+\n+  return bp;\n+}\n+\n+\n+/* Materialize a new tree from input block IB using descriptors in\n+   DATA_IN.  The code for the new tree should match TAG.  Store in\n+   *IX_P the index into the reader cache where the new tree is stored.  */\n+\n+static tree\n+lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t      enum LTO_tags tag, int *ix_p)\n+{\n+  struct bitpack_d *bp;\n+  enum tree_code code;\n+  tree result;\n+#ifdef LTO_STREAMER_DEBUG\n+  HOST_WIDEST_INT orig_address_in_writer;\n+#endif\n+  HOST_WIDE_INT ix;\n+\n+  result = NULL_TREE;\n+\n+  /* Read the header of the node we are about to create.  */\n+  ix = lto_input_sleb128 (ib);\n+  gcc_assert ((int) ix == ix);\n+  *ix_p = (int) ix;\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Read the word representing the memory address for the tree\n+     as it was written by the writer.  This is useful when\n+     debugging differences between the writer and reader.  */\n+  orig_address_in_writer = lto_input_sleb128 (ib);\n+  gcc_assert ((intptr_t) orig_address_in_writer == orig_address_in_writer);\n+#endif\n+\n+  code = lto_tag_to_tree_code (tag);\n+\n+  /* We should never see an SSA_NAME tree.  Only the version numbers of\n+     SSA names are ever written out.  See input_ssa_names.  */\n+  gcc_assert (code != SSA_NAME);\n+\n+  /* Instantiate a new tree using the header data.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    result = input_string_cst (data_in, ib);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    result = input_identifier (data_in, ib);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    {\n+      HOST_WIDE_INT len = lto_input_sleb128 (ib);\n+      result = make_tree_vec (len);\n+    }\n+  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned HOST_WIDE_INT len = lto_input_uleb128 (ib);\n+      result = make_tree_binfo (len);\n+    }\n+  else\n+    {\n+      /* All other nodes can be materialized with a raw make_node\n+\t call.  */\n+      result = make_node (code);\n+    }\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Store the original address of the tree as seen by the writer\n+     in RESULT's aux field.  This is useful when debugging streaming\n+     problems.  This way, a debugging session can be started on\n+     both writer and reader with a breakpoint using this address\n+     value in both.  */\n+  lto_orig_address_map (result, (intptr_t) orig_address_in_writer);\n+#endif\n+\n+  /* Read the bitpack of non-pointer values from IB.  */\n+  bp = lto_input_bitpack (ib);\n+\n+  /* The first word in BP contains the code of the tree that we\n+     are about to read.  */\n+  code = (enum tree_code) bp_unpack_value (bp, 16);\n+  lto_tag_check (lto_tree_code_to_tag (code), tag);\n+\n+  /* Unpack all the value fields from BP.  */\n+  unpack_value_fields (bp, result);\n+  bitpack_delete (bp);\n+\n+  /* Enter RESULT in the reader cache.  This will make RESULT\n+     available so that circular references in the rest of the tree\n+     structure can be resolved in subsequent calls to lto_input_tree.  */\n+  lto_streamer_cache_insert_at (data_in->reader_cache, result, ix);\n+\n+  return result;\n+}\n+\n+\n+/* Read a chain of tree nodes from input block IB. DATA_IN contains\n+   tables and descriptors for the file being read.  */\n+\n+static tree\n+lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  int i, count;\n+  tree first, prev, curr;\n+  \n+  first = prev = NULL_TREE;\n+  count = lto_input_sleb128 (ib);\n+  for (i = 0; i < count; i++)\n+    {\n+      curr = lto_input_tree (ib, data_in);\n+      if (prev)\n+\tTREE_CHAIN (prev) = curr;\n+      else\n+\tfirst = curr;\n+\n+      TREE_CHAIN (curr) = NULL_TREE;\n+      prev = curr;\n+    }\n+\n+  return first;\n+}\n+\n+  \n+/* Read all pointer fields in the TS_COMMON structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+\n+static void\n+lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t   struct data_in *data_in, tree expr)\n+{\n+  TREE_TYPE (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_VECTOR structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t   struct data_in *data_in, tree expr)\n+{\n+  TREE_VECTOR_CST_ELTS (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_COMPLEX structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t    struct data_in *data_in, tree expr)\n+{\n+  TREE_REALPART (expr) = lto_input_tree (ib, data_in);\n+  TREE_IMAGPART (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  DECL_NAME (expr) = lto_input_tree (ib, data_in);\n+  DECL_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  DECL_SOURCE_LOCATION (expr) = lto_input_location (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_COMMON structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  DECL_SIZE (expr) = lto_input_tree (ib, data_in);\n+  DECL_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n+\n+  if (TREE_CODE (expr) != FUNCTION_DECL)\n+    DECL_INITIAL (expr) = lto_input_tree (ib, data_in);\n+\n+  DECL_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+  DECL_ABSTRACT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n+\n+  if (TREE_CODE (expr) == PARM_DECL)\n+    TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_NON_COMMON structure of\n+   EXPR from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t    struct data_in *data_in, tree expr)\n+{\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    {\n+      DECL_ARGUMENTS (expr) = lto_input_tree (ib, data_in);\n+      DECL_RESULT (expr) = lto_input_tree (ib, data_in);\n+    }\n+  DECL_VINDEX (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t          struct data_in *data_in, tree expr)\n+{\n+  tree id;\n+  \n+  id = lto_input_tree (ib, data_in);\n+  if (id)\n+    {\n+      gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n+      SET_DECL_ASSEMBLER_NAME (expr, id);\n+    }\n+\n+  DECL_SECTION_NAME (expr) = lto_input_tree (ib, data_in);\n+  DECL_COMDAT_GROUP (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_FIELD_DECL structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t       struct data_in *data_in, tree expr)\n+{\n+  DECL_FIELD_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  DECL_BIT_FIELD_TYPE (expr) = lto_input_tree (ib, data_in);\n+  DECL_QUALIFIER (expr) = lto_input_tree (ib, data_in);\n+  DECL_FIELD_BIT_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  DECL_FCONTEXT (expr) = lto_input_tree (ib, data_in);\n+  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  /* DECL_STRUCT_FUNCTION is handled by lto_input_function.  FIXME lto,\n+     maybe it should be handled here?  */\n+  DECL_FUNCTION_PERSONALITY (expr) = lto_input_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_TARGET (expr) = lto_input_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_TYPE structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_type_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    TYPE_VALUES (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    TYPE_DOMAIN (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == RECORD_TYPE || TREE_CODE (expr) == UNION_TYPE)\n+    TYPE_FIELDS (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == FUNCTION_TYPE || TREE_CODE (expr) == METHOD_TYPE)\n+    TYPE_ARG_TYPES (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == VECTOR_TYPE)\n+    TYPE_DEBUG_REPRESENTATION_TYPE (expr) = lto_input_tree (ib, data_in);\n+\n+  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO nor\n+     TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO.  */\n+  if (!POINTER_TYPE_P (expr))\n+    TYPE_MINVAL (expr) = lto_input_tree (ib, data_in);\n+  TYPE_MAXVAL (expr) = lto_input_tree (ib, data_in);\n+  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_CANONICAL (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_LIST structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  TREE_PURPOSE (expr) = lto_input_tree (ib, data_in);\n+  TREE_VALUE (expr) = lto_input_tree (ib, data_in);\n+  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_VEC structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  int i;\n+\n+  /* Note that TREE_VEC_LENGTH was read by lto_materialize_tree to\n+     instantiate EXPR.  */\n+  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+    TREE_VEC_ELT (expr, i) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_EXP structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+\n+static void\n+lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n+\t\t\t        struct data_in *data_in, tree expr)\n+{\n+  int i, length;\n+  location_t loc;\n+\n+  length = lto_input_sleb128 (ib);\n+  gcc_assert (length == TREE_OPERAND_LENGTH (expr));\n+\n+  for (i = 0; i < length; i++)\n+    TREE_OPERAND (expr, i) = lto_input_tree (ib, data_in);\n+\n+  loc = lto_input_location (ib, data_in);\n+  SET_EXPR_LOCATION (expr, loc);\n+  TREE_BLOCK (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_BLOCK structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  unsigned i, len;\n+\n+  BLOCK_SOURCE_LOCATION (expr) = lto_input_location (ib, data_in);\n+  BLOCK_VARS (expr) = lto_input_chain (ib, data_in);\n+\n+  len = lto_input_uleb128 (ib);\n+  for (i = 0; i < len; i++)\n+    {\n+      tree t = lto_input_tree (ib, data_in);\n+      VEC_safe_push (tree, gc, BLOCK_NONLOCALIZED_VARS (expr), t);\n+    }\n+\n+  BLOCK_SUPERCONTEXT (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_ABSTRACT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_FRAGMENT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_FRAGMENT_CHAIN (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_SUBBLOCKS (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_BINFO structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  unsigned i, len;\n+  tree t;\n+\n+  /* Note that the number of slots in EXPR was read in\n+     lto_materialize_tree when instantiating EXPR.  However, the\n+     vector is empty so we cannot rely on VEC_length to know how many\n+     elements to read.  So, this list is emitted as a 0-terminated\n+     list on the writer side.  */\n+  do\n+    {\n+      t = lto_input_tree (ib, data_in);\n+      if (t)\n+\tVEC_quick_push (tree, BINFO_BASE_BINFOS (expr), t);\n+    }\n+  while (t);\n+\n+  BINFO_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VTABLE (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VIRTUALS (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VPTR_FIELD (expr) = lto_input_tree (ib, data_in);\n+\n+  len = lto_input_uleb128 (ib);\n+  for (i = 0; i < len; i++)\n+    {\n+      tree a = lto_input_tree (ib, data_in);\n+      VEC_safe_push (tree, gc, BINFO_BASE_ACCESSES (expr), a);\n+    }\n+\n+  BINFO_INHERITANCE_CHAIN (expr) = lto_input_tree (ib, data_in);\n+  BINFO_SUBVTT_INDEX (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VPTR_INDEX (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_CONSTRUCTOR structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t        struct data_in *data_in, tree expr)\n+{\n+  unsigned i, len;\n+\n+  len = lto_input_uleb128 (ib);\n+  for (i = 0; i < len; i++)\n+    {\n+      tree index, value;\n+\n+      index = lto_input_tree (ib, data_in);\n+      value = lto_input_tree (ib, data_in);\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (expr), index, value);\n+    }\n+}\n+\n+\n+/* Helper for lto_input_tree.  Read all pointer fields in EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t\t tree expr)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMMON))\n+    lto_input_ts_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    lto_input_ts_vector_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    lto_input_ts_complex_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    lto_input_ts_decl_minimal_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    lto_input_ts_decl_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    lto_input_ts_decl_non_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    lto_input_ts_decl_with_vis_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    lto_input_ts_field_decl_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    lto_input_ts_function_decl_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n+    lto_input_ts_type_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    lto_input_ts_list_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    lto_input_ts_vec_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    lto_input_ts_exp_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_SSA_NAME))\n+    {\n+      /* We only stream the version number of SSA names.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    lto_input_ts_block_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    lto_input_ts_binfo_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STATEMENT_LIST))\n+    {\n+      /* This should only appear in GENERIC.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    lto_input_ts_constructor_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OMP_CLAUSE))\n+    {\n+      /* This should only appear in High GIMPLE.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n+    {\n+      sorry (\"optimization options not supported yet\");\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    {\n+      sorry (\"target optimization options not supported yet\");\n+    }\n+}\n+\n+static VEC(tree, heap) *deferred_global_decls;\n+\n+/* Register the queued global decls with the symtab.  DATA_IN contains\n+   tables and descriptors for the file being read.*/\n+\n+void\n+lto_register_deferred_decls_in_symtab (struct data_in *data_in)\n+{\n+  unsigned i;\n+  tree decl;\n+\n+  for (i = 0; VEC_iterate (tree, deferred_global_decls, i, decl); ++i)\n+    {\n+      enum ld_plugin_symbol_resolution resolution;\n+      int ix;\n+\n+      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+\tgcc_unreachable ();\n+\n+      /* Register and adjust the decls type.  */\n+      TREE_TYPE (decl) = gimple_register_type (TREE_TYPE (decl));\n+\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\t{\n+\t  gcc_assert (TREE_PUBLIC (decl));\n+\t  resolution = get_resolution (data_in, ix);\n+\t  lto_symtab_merge_var (decl, resolution);\n+\t}\n+      else if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  gcc_assert (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl));\n+\t  resolution = get_resolution (data_in, ix);\n+\t  lto_symtab_merge_fn (decl, resolution, data_in->file_data);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  VEC_free (tree, heap, deferred_global_decls);\n+  deferred_global_decls = NULL;\n+}\n+\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  */\n+\n+static void\n+lto_register_var_decl_in_symtab (tree decl)\n+{\n+  /* Register symbols with file or global scope to mark what input\n+     file has their definition.  */\n+  if (decl_function_context (decl) == NULL_TREE)\n+    {\n+      /* Variable has file scope, not local. Need to ensure static variables\n+\t between different files don't clash unexpectedly.  */\n+      if (!TREE_PUBLIC (decl))\n+        {\n+\t  /* ??? We normally pre-mangle names before we serialize them\n+\t     out.  Here, in lto1, we do not know the language, and\n+\t     thus cannot do the mangling again. Instead, we just\n+\t     append a suffix to the mangled name.  The resulting name,\n+\t     however, is not a properly-formed mangled name, and will\n+\t     confuse any attempt to unmangle it.  */\n+\t  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\t  char *label;\n+      \n+\t  ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+\t  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n+          rest_of_decl_compilation (decl, 1, 0);\n+        }\n+    }\n+\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl))\n+    VEC_safe_push (tree, heap, deferred_global_decls, decl);\n+}\n+\n+\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  DATA_IN contains descriptors and tables for the\n+   file being read.  */\n+\n+static void\n+lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n+{\n+  /* Need to ensure static entities between different files\n+     don't clash unexpectedly.  */\n+  if (!TREE_PUBLIC (decl))\n+    {\n+      /* We must not use the DECL_ASSEMBLER_NAME macro here, as it\n+\t may set the assembler name where it was previously empty.  */\n+      tree old_assembler_name = decl->decl_with_vis.assembler_name;\n+\n+      /* FIXME lto: We normally pre-mangle names before we serialize\n+\t them out.  Here, in lto1, we do not know the language, and\n+\t thus cannot do the mangling again. Instead, we just append a\n+\t suffix to the mangled name.  The resulting name, however, is\n+\t not a properly-formed mangled name, and will confuse any\n+\t attempt to unmangle it.  */\n+      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      char *label;\n+      \n+      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n+\n+      /* We may arrive here with the old assembler name not set\n+\t if the function body is not needed, e.g., it has been\n+\t inlined away and does not appear in the cgraph.  */\n+      if (old_assembler_name)\n+\t{\n+\t  tree new_assembler_name = DECL_ASSEMBLER_NAME (decl);\n+\n+\t  /* Make the original assembler name available for later use.\n+\t     We may have used it to indicate the section within its\n+\t     object file where the function body may be found.\n+\t     FIXME lto: Find a better way to maintain the function decl\n+\t     to body section mapping so we don't need this hack.  */\n+\t  lto_record_renamed_decl (data_in->file_data,\n+\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name),\n+\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name));\n+\n+\t  /* Also register the reverse mapping so that we can find the\n+\t     new name given to an existing assembler name (used when\n+\t     restoring alias pairs in input_constructors_or_inits.  */ \n+\t  lto_record_renamed_decl (data_in->file_data,\n+\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name),\n+\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name));\n+\t}\t\t\t\t   \n+    }\n+\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n+    VEC_safe_push (tree, heap, deferred_global_decls, decl);\n+}\n+\n+\n+/* Read an index IX from input block IB and return the tree node at\n+   DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n+\n+static tree\n+lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  HOST_WIDE_INT ix;\n+  tree result;\n+  enum LTO_tags expected_tag;\n+  unsigned HOST_WIDE_INT orig_offset;\n+\n+  ix = lto_input_sleb128 (ib);\n+  expected_tag = (enum LTO_tags) lto_input_uleb128 (ib);\n+\n+  orig_offset = lto_input_uleb128 (ib);\n+  gcc_assert (orig_offset == (unsigned) orig_offset);\n+\n+  result = lto_streamer_cache_get (data_in->reader_cache, ix);\n+  if (result == NULL_TREE)\n+    {\n+      /* We have not yet read the cache slot IX.  Go to the offset\n+\t in the stream where the physical tree node is, and materialize\n+\t it from there.  */\n+      struct lto_input_block fwd_ib;\n+\n+      /* If we are trying to go back in the stream, something is wrong.\n+\t We should've read the node at the earlier position already.  */\n+      if (ib->p >= orig_offset)\n+\tinternal_error (\"bytecode stream: tried to jump backwards in the \"\n+\t\t        \"stream\");\n+\n+      LTO_INIT_INPUT_BLOCK (fwd_ib, ib->data, orig_offset, ib->len);\n+      result = lto_input_tree (&fwd_ib, data_in);\n+    }\n+\n+  gcc_assert (result\n+              && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n+\n+  return result;\n+}\n+\n+\n+/* Read a code and class from input block IB and return the\n+   corresponding builtin.  DATA_IN is as in lto_input_tree.  */\n+\n+static tree\n+lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  enum built_in_class fclass;\n+  enum built_in_function fcode;\n+  const char *asmname;\n+  tree result;\n+  int ix;\n+\n+  fclass = (enum built_in_class) lto_input_uleb128 (ib);\n+  gcc_assert (fclass == BUILT_IN_NORMAL || fclass == BUILT_IN_MD);\n+\n+  fcode = (enum built_in_function) lto_input_uleb128 (ib);\n+  gcc_assert (fcode < END_BUILTINS);\n+\n+  ix = lto_input_sleb128 (ib);\n+  gcc_assert (ix == (int) ix);\n+\n+  result = built_in_decls[fcode];\n+  gcc_assert (result);\n+\n+  asmname = input_string (data_in, ib);\n+  if (asmname)\n+    set_builtin_user_assembler_name (result, asmname);\n+\n+  lto_streamer_cache_insert_at (data_in->reader_cache, result, ix);\n+\n+  return result;\n+}\n+\n+\n+/* Read the physical representation of a tree node with tag TAG from\n+   input block IB using the per-file context in DATA_IN.  */\n+\n+static tree\n+lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t       enum LTO_tags tag)\n+{\n+  tree result;\n+  char end_marker;\n+  int ix;\n+\n+  result = lto_materialize_tree (ib, data_in, tag, &ix);\n+\n+  /* Read all the pointer fields in RESULT.  */\n+  lto_input_tree_pointers (ib, data_in, result);\n+\n+  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n+  if (TREE_CODE (result) == FUNCTION_DECL)\n+    gcc_assert (!lto_stream_as_builtin_p (result));\n+\n+  if (TREE_CODE (result) == VAR_DECL)\n+    lto_register_var_decl_in_symtab (result);\n+  else if (TREE_CODE (result) == FUNCTION_DECL && !DECL_BUILT_IN (result))\n+    lto_register_function_decl_in_symtab (data_in, result);\n+\n+  end_marker = lto_input_1_unsigned (ib);\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Remove the mapping to RESULT's original address set by\n+     lto_materialize_tree.  */\n+  lto_orig_address_remove (result);\n+#endif\n+\n+  return result;\n+}\n+\n+\n+/* Read and INTEGER_CST node from input block IB using the per-file\n+   context in DATA_IN.  */\n+\n+static tree\n+lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  tree result, type;\n+  HOST_WIDE_INT low, high;\n+  bool overflow_p;\n+\n+  type = lto_input_tree (ib, data_in);\n+  overflow_p = (lto_input_1_unsigned (ib) != 0);\n+  low = lto_input_uleb128 (ib);\n+  high = lto_input_uleb128 (ib);\n+  result = build_int_cst_wide (type, low, high);\n+\n+  /* If the original constant had overflown, build a replica of RESULT to\n+     avoid modifying the shared constant returned by build_int_cst_wide.  */\n+  if (overflow_p)\n+    {\n+      result = copy_node (result);\n+      TREE_OVERFLOW (result) = 1;\n+    }\n+\n+  return result;\n+}\n+\n+\n+/* Read a tree from input block IB using the per-file context in\n+   DATA_IN.  This context is used, for example, to resolve references\n+   to previously read nodes.  */\n+\n+tree\n+lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  enum LTO_tags tag;\n+  tree result;\n+  \n+  tag = input_record_start (ib);\n+  gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n+\n+  if (tag == LTO_null)\n+    result = NULL_TREE;\n+  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n+    {\n+      /* If TAG is a reference to an indexable tree, the next value\n+\t in IB is the index into the table where we expect to find\n+\t that tree.  */\n+      result = lto_input_tree_ref (ib, data_in, cfun, tag);\n+    }\n+  else if (tag == LTO_tree_pickle_reference)\n+    {\n+      /* If TAG is a reference to a previously read tree, look it up in\n+\t the reader cache.  */\n+      result = lto_get_pickled_tree (ib, data_in);\n+    }\n+  else if (tag == LTO_builtin_decl)\n+    {\n+      /* If we are going to read a built-in function, all we need is\n+\t the code and class.  */\n+      result = lto_get_builtin_tree (ib, data_in);\n+    }\n+  else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n+    {\n+      /* For integer constants we only need the type and its hi/low\n+\t words.  */\n+      result = lto_input_integer_cst (ib, data_in);\n+    }\n+  else\n+    {\n+      /* Otherwise, materialize a new node from IB.  */\n+      result = lto_read_tree (ib, data_in, tag);\n+    }\n+\n+  return result;\n+}\n+\n+\n+/* Initialization for the LTO reader.  */\n+\n+void\n+lto_init_reader (void)\n+{\n+  lto_streamer_init ();\n+\n+  memset (&lto_stats, 0, sizeof (lto_stats));\n+  bitmap_obstack_initialize (NULL);\n+\n+  file_name_hash_table = htab_create (37, hash_string_slot_node,\n+\t\t\t\t      eq_string_slot_node, free);\n+\n+  gimple_register_cfg_hooks ();\n+}\n+\n+\n+/* Create a new data_in object for FILE_DATA. STRINGS is the string\n+   table to use with LEN strings.  RESOLUTIONS is the vector of linker\n+   resolutions (NULL if not using a linker plugin).  */\n+\n+struct data_in *\n+lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n+\t\t    unsigned len,\n+\t\t    VEC(ld_plugin_symbol_resolution_t,heap) *resolutions)\n+{\n+  struct data_in *data_in = XCNEW (struct data_in);\n+  data_in->file_data = file_data;\n+  data_in->strings = strings;\n+  data_in->strings_len = len;\n+  data_in->globals_resolution = resolutions;\n+  data_in->reader_cache = lto_streamer_cache_create ();\n+\n+  return data_in;\n+}\n+\n+\n+/* Remove DATA_IN.  */\n+\n+void\n+lto_data_in_delete (struct data_in *data_in)\n+{\n+  VEC_free (ld_plugin_symbol_resolution_t, heap, data_in->globals_resolution);\n+  lto_streamer_cache_delete (data_in->reader_cache);\n+  free (data_in->labels);\n+  free (data_in);\n+}"}, {"sha": "616486762c485858951ddd109d4a486fa5c19125", "filename": "gcc/lto-streamer-out.c", "status": "added", "additions": 2548, "deletions": 0, "changes": 2548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,2548 @@\n+/* Write the GIMPLE representation to a file stream.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+   Re-implemented by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+#include \"input.h\"\n+#include \"varray.h\"\n+#include \"hashtab.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"diagnostic.h\"\n+#include \"except.h\"\n+#include \"vec.h\"\n+#include \"lto-symtab.h\"\n+#include \"lto-streamer.h\"\n+\n+\n+struct string_slot\n+{\n+  const char *s;\n+  int len;\n+  unsigned int slot_num;\n+};\n+\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_string_slot_node (const void *p)\n+{\n+  const struct string_slot *ds = (const struct string_slot *) p;\n+  return (hashval_t) htab_hash_string (ds->s);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_string_slot_node (const void *p1, const void *p2)\n+{\n+  const struct string_slot *ds1 = (const struct string_slot *) p1;\n+  const struct string_slot *ds2 = (const struct string_slot *) p2;\n+\n+  if (ds1->len == ds2->len)\n+    {\n+      int i;\n+      for (i = 0; i < ds1->len; i++)\n+\tif (ds1->s[i] != ds2->s[i])\n+\t  return 0;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Free the string slot pointed-to by P.  */\n+\n+static void \n+string_slot_free (void *p)\n+{\n+  struct string_slot *slot = (struct string_slot *) p;\n+  free (CONST_CAST (void *, (const void *) slot->s));\n+  free (slot);\n+}\n+\n+\n+/* Clear the line info stored in DATA_IN.  */\n+\n+static void\n+clear_line_info (struct output_block *ob)\n+{\n+  ob->current_file = NULL;\n+  ob->current_line = 0;\n+  ob->current_col = 0;\n+}\n+\n+\n+/* Create the output block and return it.  SECTION_TYPE is\n+   LTO_section_function_body or LTO_static_initializer.  */\n+\n+struct output_block *\n+create_output_block (enum lto_section_type section_type)\n+{\n+  struct output_block *ob = XCNEW (struct output_block);\n+\n+  ob->section_type = section_type;\n+  ob->decl_state = lto_get_out_decl_state ();\n+  ob->main_stream = XCNEW (struct lto_output_stream);\n+  ob->string_stream = XCNEW (struct lto_output_stream);\n+  ob->writer_cache = lto_streamer_cache_create ();\n+\n+  if (section_type == LTO_section_function_body)\n+    ob->cfg_stream = XCNEW (struct lto_output_stream);\n+\n+  clear_line_info (ob);\n+\n+  ob->string_hash_table = htab_create (37, hash_string_slot_node,\n+\t\t\t\t       eq_string_slot_node, string_slot_free);\n+\n+  return ob;\n+}\n+\n+\n+/* Destroy the output block OB.  */\n+\n+void\n+destroy_output_block (struct output_block *ob)\n+{\n+  enum lto_section_type section_type = ob->section_type;\n+\n+  htab_delete (ob->string_hash_table);\n+\n+  free (ob->main_stream);\n+  free (ob->string_stream);\n+  if (section_type == LTO_section_function_body)\n+    free (ob->cfg_stream);\n+\n+  lto_streamer_cache_delete (ob->writer_cache);\n+\n+  free (ob);\n+}\n+\n+\n+/* Output bitpack BP to output stream S.  */\n+\n+void\n+lto_output_bitpack (struct lto_output_stream *s, struct bitpack_d *bp)\n+{\n+  unsigned i;\n+  bitpack_word_t v;\n+\n+  lto_output_uleb128_stream (s, VEC_length (bitpack_word_t, bp->values));\n+  for (i = 0; VEC_iterate (bitpack_word_t, bp->values, i, v); i++)\n+    lto_output_uleb128_stream (s, v);\n+}\n+\n+\n+/* Output STRING of LEN characters to the string\n+   table in OB. The string might or might not include a trailing '\\0'.\n+   Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_string_with_length (struct output_block *ob,\n+\t\t\t   struct lto_output_stream *index_stream,\n+\t\t\t   const char *s,\n+\t\t\t   unsigned int len)\n+{\n+  struct string_slot **slot;\n+  struct string_slot s_slot;\n+  char *string = (char *) xmalloc (len + 1);\n+  memcpy (string, s, len);\n+  string[len] = '\\0';\n+\n+  s_slot.s = string;\n+  s_slot.len = len;\n+  s_slot.slot_num = 0;\n+\n+  slot = (struct string_slot **) htab_find_slot (ob->string_hash_table,\n+\t\t\t\t\t\t &s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct lto_output_stream *string_stream = ob->string_stream;\n+      unsigned int start = string_stream->total_size;\n+      struct string_slot *new_slot\n+\t= (struct string_slot *) xmalloc (sizeof (struct string_slot));\n+      unsigned int i;\n+\n+      new_slot->s = string;\n+      new_slot->len = len;\n+      new_slot->slot_num = start;\n+      *slot = new_slot;\n+      lto_output_uleb128_stream (index_stream, start);\n+      lto_output_uleb128_stream (string_stream, len);\n+      for (i = 0; i < len; i++)\n+\tlto_output_1_stream (string_stream, string[i]);\n+    }\n+  else\n+    {\n+      struct string_slot *old_slot = (struct string_slot *)*slot;\n+      lto_output_uleb128_stream (index_stream, old_slot->slot_num);\n+      free (string);\n+    }\n+}\n+\n+/* Output the '\\0' terminated STRING to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_string (struct output_block *ob,\n+\t       struct lto_output_stream *index_stream,\n+\t       const char *string)\n+{\n+  if (string)\n+    {\n+      lto_output_uleb128_stream (index_stream, 0);\n+      output_string_with_length (ob, index_stream, string, strlen (string) + 1);\n+    }\n+  else\n+    lto_output_uleb128_stream (index_stream, 1);\n+}\n+\n+\n+/* Output the STRING constant to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_string_cst (struct output_block *ob,\n+\t\t   struct lto_output_stream *index_stream,\n+\t\t   tree string)\n+{\n+  if (string)\n+    {\n+      lto_output_uleb128_stream (index_stream, 0);\n+      output_string_with_length (ob, index_stream,\n+\t\t\t\t TREE_STRING_POINTER (string),\n+\t\t\t\t TREE_STRING_LENGTH (string));\n+    }\n+  else\n+    lto_output_uleb128_stream (index_stream, 1);\n+}\n+\n+\n+/* Output the identifier ID to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_identifier (struct output_block *ob,\n+\t\t   struct lto_output_stream *index_stream,\n+\t\t   tree id)\n+{\n+  if (id)\n+    {\n+      lto_output_uleb128_stream (index_stream, 0);\n+      output_string_with_length (ob, index_stream,\n+\t\t\t\t IDENTIFIER_POINTER (id),\n+\t\t\t\t IDENTIFIER_LENGTH (id));\n+    }\n+  else\n+    lto_output_uleb128_stream (index_stream, 1);\n+}\n+\n+/* Write a zero to the output stream.  */\n+\n+static void\n+output_zero (struct output_block *ob)\n+{\n+  lto_output_1_stream (ob->main_stream, 0);\n+}\n+\n+\n+/* Output an unsigned LEB128 quantity to OB->main_stream.  */\n+\n+static void\n+output_uleb128 (struct output_block *ob, unsigned HOST_WIDE_INT work)\n+{\n+  lto_output_uleb128_stream (ob->main_stream, work);\n+}\n+\n+\n+/* Output a signed LEB128 quantity to OB->main_stream.  */\n+\n+static void\n+output_sleb128 (struct output_block *ob, HOST_WIDE_INT work)\n+{\n+  lto_output_sleb128_stream (ob->main_stream, work);\n+}\n+\n+\n+/* Output the start of a record with TAG to output block OB.  */\n+\n+static void\n+output_record_start (struct output_block *ob, enum LTO_tags tag)\n+{\n+  /* Make sure TAG fits inside an unsigned int.  */\n+  gcc_assert (tag == (enum LTO_tags) (unsigned) tag);\n+  output_uleb128 (ob, tag);\n+}\n+\n+\n+/* Look up NODE in the type table and write the index for it to OB.  */\n+\n+static void\n+output_type_ref (struct output_block *ob, tree node)\n+{\n+  output_record_start (ob, LTO_type_ref);\n+  lto_output_type_ref_index (ob->decl_state, ob->main_stream, node);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_BASE structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, TREE_CODE (expr), 16);\n+  if (!TYPE_P (expr))\n+    {\n+      bp_pack_value (bp, TREE_SIDE_EFFECTS (expr), 1);\n+      bp_pack_value (bp, TREE_CONSTANT (expr), 1);\n+      bp_pack_value (bp, TREE_READONLY (expr), 1);\n+\n+      /* TREE_PUBLIC is used on types to indicate that the type\n+\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n+\t so we skip it here.  */\n+      bp_pack_value (bp, TREE_PUBLIC (expr), 1);\n+    }\n+  bp_pack_value (bp, TREE_ADDRESSABLE (expr), 1);\n+  bp_pack_value (bp, TREE_THIS_VOLATILE (expr), 1);\n+  if (DECL_P (expr))\n+    bp_pack_value (bp, DECL_UNSIGNED (expr), 1);\n+  else if (TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_UNSIGNED (expr), 1);\n+  bp_pack_value (bp, TREE_ASM_WRITTEN (expr), 1);\n+  bp_pack_value (bp, TREE_NO_WARNING (expr), 1);\n+  bp_pack_value (bp, TREE_USED (expr), 1);\n+  bp_pack_value (bp, TREE_NOTHROW (expr), 1);\n+  bp_pack_value (bp, TREE_STATIC (expr), 1);\n+  bp_pack_value (bp, TREE_PRIVATE (expr), 1);\n+  bp_pack_value (bp, TREE_PROTECTED (expr), 1);\n+  bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n+  if (TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_SATURATING (expr), 1);\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    bp_pack_value (bp, SSA_NAME_IS_DEFAULT_DEF (expr), 1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_REAL_CST structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  unsigned i;\n+  REAL_VALUE_TYPE r;\n+  \n+  r = TREE_REAL_CST (expr);\n+  bp_pack_value (bp, r.cl, 2);\n+  bp_pack_value (bp, r.decimal, 1);\n+  bp_pack_value (bp, r.sign, 1);\n+  bp_pack_value (bp, r.signalling, 1);\n+  bp_pack_value (bp, r.canonical, 1);\n+  bp_pack_value (bp, r.uexp, EXP_BITS);\n+  for (i = 0; i < SIGSZ; i++)\n+    bp_pack_value (bp, r.sig[i], HOST_BITS_PER_LONG);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_FIXED_CST structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  struct fixed_value fv = TREE_FIXED_CST (expr);\n+  bp_pack_value (bp, fv.data.low, HOST_BITS_PER_WIDE_INT);\n+  bp_pack_value (bp, fv.data.high, HOST_BITS_PER_WIDE_INT);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_COMMON structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, DECL_MODE (expr), 8);\n+  bp_pack_value (bp, DECL_NONLOCAL (expr), 1);\n+  bp_pack_value (bp, DECL_VIRTUAL_P (expr), 1);\n+  bp_pack_value (bp, DECL_IGNORED_P (expr), 1);\n+  bp_pack_value (bp, DECL_ABSTRACT (expr), 1);\n+  bp_pack_value (bp, DECL_ARTIFICIAL (expr), 1);\n+  bp_pack_value (bp, DECL_USER_ALIGN (expr), 1);\n+  bp_pack_value (bp, DECL_PRESERVE_P (expr), 1);\n+  bp_pack_value (bp, DECL_DEBUG_EXPR_IS_FROM (expr), 1);\n+  bp_pack_value (bp, DECL_EXTERNAL (expr), 1);\n+  bp_pack_value (bp, DECL_GIMPLE_REG_P (expr), 1);\n+  bp_pack_value (bp, DECL_ALIGN (expr), HOST_BITS_PER_INT);\n+\n+  if (TREE_CODE (expr) == LABEL_DECL)\n+    {\n+      /* Note that we do not write LABEL_DECL_UID.  The reader will\n+\t always assume an initial value of -1 so that the\n+\t label_to_block_map is recreated by gimple_set_bb.  */\n+      bp_pack_value (bp, DECL_ERROR_ISSUED (expr), 1);\n+      bp_pack_value (bp, EH_LANDING_PAD_NR (expr), HOST_BITS_PER_INT);\n+    }\n+\n+  if (TREE_CODE (expr) == FIELD_DECL)\n+    {\n+      bp_pack_value (bp, DECL_PACKED (expr), 1);\n+      bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);\n+      bp_pack_value (bp, DECL_OFFSET_ALIGN (expr), 8);\n+    }\n+\n+  if (TREE_CODE (expr) == RESULT_DECL\n+      || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == VAR_DECL)\n+    {\n+      bp_pack_value (bp, DECL_BY_REFERENCE (expr), 1);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  || TREE_CODE (expr) == PARM_DECL)\n+\tbp_pack_value (bp, DECL_HAS_VALUE_EXPR_P (expr), 1);\n+    }\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_WRTL structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, DECL_REGISTER (expr), 1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, DECL_DEFER_OUTPUT (expr), 1);\n+  bp_pack_value (bp, DECL_COMMON (expr), 1);\n+  bp_pack_value (bp, DECL_DLLIMPORT_P (expr), 1);\n+  bp_pack_value (bp, DECL_WEAK (expr), 1);\n+  bp_pack_value (bp, DECL_SEEN_IN_BIND_EXPR_P (expr),  1);\n+  bp_pack_value (bp, DECL_COMDAT (expr),  1);\n+  bp_pack_value (bp, DECL_VISIBILITY (expr),  2);\n+  bp_pack_value (bp, DECL_VISIBILITY_SPECIFIED (expr),  1);\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    {\n+      bp_pack_value (bp, DECL_HARD_REGISTER (expr), 1);\n+      bp_pack_value (bp, DECL_IN_TEXT_SECTION (expr), 1);\n+      bp_pack_value (bp, DECL_TLS_MODEL (expr),  3);\n+    }\n+\n+  if (VAR_OR_FUNCTION_DECL_P (expr))\n+    bp_pack_value (bp, DECL_INIT_PRIORITY (expr), HOST_BITS_PER_SHORT);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_FUNCTION_DECL structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  /* For normal/md builtins we only write the class and code, so they\n+     should never be handled here.  */\n+  gcc_assert (!lto_stream_as_builtin_p (expr));\n+\n+  bp_pack_value (bp, DECL_FUNCTION_CODE (expr), 11);\n+  bp_pack_value (bp, DECL_BUILT_IN_CLASS (expr), 2);\n+  bp_pack_value (bp, DECL_STATIC_CONSTRUCTOR (expr), 1);\n+  bp_pack_value (bp, DECL_STATIC_DESTRUCTOR (expr), 1);\n+  bp_pack_value (bp, DECL_UNINLINABLE (expr), 1);\n+  bp_pack_value (bp, DECL_POSSIBLY_INLINED (expr), 1);\n+  bp_pack_value (bp, DECL_IS_NOVOPS (expr), 1);\n+  bp_pack_value (bp, DECL_IS_RETURNS_TWICE (expr), 1);\n+  bp_pack_value (bp, DECL_IS_MALLOC (expr), 1);\n+  bp_pack_value (bp, DECL_IS_OPERATOR_NEW (expr), 1);\n+  bp_pack_value (bp, DECL_DECLARED_INLINE_P (expr), 1);\n+  bp_pack_value (bp, DECL_STATIC_CHAIN (expr), 1);\n+  bp_pack_value (bp, DECL_NO_INLINE_WARNING_P (expr), 1);\n+  bp_pack_value (bp, DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr), 1);\n+  bp_pack_value (bp, DECL_NO_LIMIT_STACK (expr), 1);\n+  bp_pack_value (bp, DECL_DISREGARD_INLINE_LIMITS (expr), 1);\n+  bp_pack_value (bp, DECL_PURE_P (expr), 1);\n+  bp_pack_value (bp, DECL_LOOPING_CONST_OR_PURE_P (expr), 1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_TYPE structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_type_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, TYPE_PRECISION (expr), 9);\n+  bp_pack_value (bp, TYPE_MODE (expr), 7);\n+  bp_pack_value (bp, TYPE_STRING_FLAG (expr), 1);\n+  bp_pack_value (bp, TYPE_NO_FORCE_BLK (expr), 1);\n+  bp_pack_value (bp, TYPE_NEEDS_CONSTRUCTING(expr), 1);\n+  if (TREE_CODE (expr) == UNION_TYPE)\n+    bp_pack_value (bp, TYPE_TRANSPARENT_UNION (expr), 1);\n+  bp_pack_value (bp, TYPE_PACKED (expr), 1);\n+  bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n+  bp_pack_value (bp, TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr), 2);\n+  bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n+  bp_pack_value (bp, TYPE_READONLY (expr), 1);\n+  bp_pack_value (bp, TYPE_ALIGN (expr), HOST_BITS_PER_INT);\n+  bp_pack_value (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1, HOST_BITS_PER_INT);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_BLOCK structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, BLOCK_ABSTRACT (expr), 1);\n+  bp_pack_value (bp, BLOCK_NUMBER (expr), 31);\n+}\n+\n+\n+/* Pack all the non-pointer fields in EXPR into a bit pack.  */\n+\n+static struct bitpack_d *\n+pack_value_fields (tree expr)\n+{\n+  enum tree_code code;\n+  struct bitpack_d *bp;\n+\n+  code = TREE_CODE (expr);\n+  bp = bitpack_create ();\n+\n+  /* Note that all these functions are highly sensitive to changes in\n+     the types and sizes of each of the fields being packed.  */\n+  pack_ts_base_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    pack_ts_real_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    pack_ts_fixed_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    pack_ts_decl_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    pack_ts_decl_wrtl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    pack_ts_decl_with_vis_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    pack_ts_function_decl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n+    pack_ts_type_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    pack_ts_block_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_SSA_NAME))\n+    {\n+      /* We only stream the version number of SSA names.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STATEMENT_LIST))\n+    {\n+      /* This is only used by GENERIC.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OMP_CLAUSE))\n+    {\n+      /* This is only used by High GIMPLE.  */\n+      gcc_unreachable ();\n+    }\n+\n+  return bp;\n+}\n+\n+\n+/* Emit location LOC to output block OB.  */\n+\n+static void\n+lto_output_location (struct output_block *ob, location_t loc)\n+{\n+  expanded_location xloc;\n+\n+  if (loc == UNKNOWN_LOCATION)\n+    {\n+      output_string (ob, ob->main_stream, NULL);\n+      return;\n+    }\n+\n+  xloc = expand_location (loc);\n+\n+  output_string (ob, ob->main_stream, xloc.file);\n+  output_sleb128 (ob, xloc.line);\n+  output_sleb128 (ob, xloc.column);\n+\n+  ob->current_file = xloc.file;\n+  ob->current_line = xloc.line;\n+  ob->current_col = xloc.column;\n+}\n+\n+\n+/* Return true if tree node T is written to various tables.  For these\n+   nodes, we sometimes want to write their phyiscal representation\n+   (via lto_output_tree), and sometimes we need to emit an index\n+   reference into a table (via lto_output_tree_ref).  */\n+\n+static bool\n+tree_is_indexable (tree t)\n+{\n+  if (TREE_CODE (t) == PARM_DECL)\n+    return false;\n+  else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t))\n+    return false;\n+  else\n+    return (TYPE_P (t) || DECL_P (t) || TREE_CODE (t) == SSA_NAME);\n+}\n+\n+\n+/* If EXPR is an indexable tree node, output a reference to it to\n+   output block OB.  Otherwise, output the physical representation of\n+   EXPR to OB.  */\n+\n+static void\n+lto_output_tree_ref (struct output_block *ob, tree expr)\n+{\n+  enum tree_code code;\n+\n+  if (expr == NULL_TREE)\n+    {\n+      output_zero (ob);\n+      return;\n+    }\n+\n+  if (!tree_is_indexable (expr))\n+    {\n+      /* Even though we are emitting the physical representation of\n+\t EXPR, its leaves must be emitted as references.  */\n+      lto_output_tree (ob, expr, true);\n+      return;\n+    }\n+\n+  if (TYPE_P (expr))\n+    {\n+      output_type_ref (ob, expr);\n+      return;\n+    }\n+\n+  code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case SSA_NAME:\n+      output_record_start (ob, LTO_ssa_name_ref);\n+      output_uleb128 (ob, SSA_NAME_VERSION (expr));\n+      break;\n+\n+    case FIELD_DECL:\n+      output_record_start (ob, LTO_field_decl_ref);\n+      lto_output_field_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case FUNCTION_DECL:\n+      output_record_start (ob, LTO_function_decl_ref);\n+      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case VAR_DECL:\n+      gcc_assert (decl_function_context (expr) == NULL);\n+      output_record_start (ob, LTO_global_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case CONST_DECL:\n+      output_record_start (ob, LTO_const_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case IMPORTED_DECL:\n+      gcc_assert (decl_function_context (expr) == NULL);\n+      output_record_start (ob, LTO_imported_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case TYPE_DECL:\n+      output_record_start (ob, LTO_type_decl_ref);\n+      lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case NAMESPACE_DECL:\n+      output_record_start (ob, LTO_namespace_decl_ref);\n+      lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case LABEL_DECL:\n+      output_record_start (ob, LTO_label_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case RESULT_DECL:\n+      output_record_start (ob, LTO_result_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    default:\n+      /* No other node is indexable, so it should have been handled\n+\t by lto_output_tree.  */\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* If REF_P is true, emit a reference to EXPR in output block OB,\n+   otherwise emit the physical representation of EXPR in OB.  */\n+\n+static inline void\n+lto_output_tree_or_ref (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  if (ref_p)\n+    lto_output_tree_ref (ob, expr);\n+  else\n+    lto_output_tree (ob, expr, false);\n+}\n+\n+\n+/* Emit the chain of tree nodes starting at T.  OB is the output block\n+   to write to.  REF_P is true if chain elements should be emitted\n+   as references.  */\n+\n+static void\n+lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n+{\n+  int i, count;\n+  \n+  count = list_length (t);\n+  output_sleb128 (ob, count);\n+  for (i = 0; i < count; i++)\n+    {\n+      tree saved_chain;\n+\n+      /* Clear TREE_CHAIN to avoid blindly recursing into the rest\n+\t of the list.  */\n+      saved_chain = TREE_CHAIN (t);\n+      TREE_CHAIN (t) = NULL_TREE;\n+\n+      lto_output_tree_or_ref (ob, t, ref_p);\n+\n+      TREE_CHAIN (t) = saved_chain;\n+      t = TREE_CHAIN (t);\n+    }\n+}\n+\n+\n+/* Write all pointer fields in the TS_COMMON structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TREE_TYPE (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_VECTOR structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_vector_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n+{\n+  lto_output_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_COMPLEX structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t     bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TREE_REALPART (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TREE_IMAGPART (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t  bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_NAME (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_CONTEXT (expr), ref_p);\n+  lto_output_location (ob, DECL_SOURCE_LOCATION (expr));\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_COMMON structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_SIZE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n+\n+  if (TREE_CODE (expr) != FUNCTION_DECL)\n+    lto_output_tree_or_ref (ob, DECL_INITIAL (expr), ref_p);\n+\n+  lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_ABSTRACT_ORIGIN (expr), ref_p);\n+\n+  if (TREE_CODE (expr) == PARM_DECL)\n+    lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_NON_COMMON structure of\n+   EXPR to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t     tree expr, bool ref_p)\n+{\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    {\n+      /* DECL_SAVED_TREE holds the GENERIC representation for DECL.\n+\t At this point, it should not exist.  Either because it was\n+\t converted to gimple or because DECL didn't have a GENERIC\n+\t representation in this TU.  */\n+      gcc_assert (DECL_SAVED_TREE (expr) == NULL_TREE);\n+      lto_output_tree_or_ref (ob, DECL_ARGUMENTS (expr), ref_p);\n+      lto_output_tree_or_ref (ob, DECL_RESULT (expr), ref_p);\n+    }\n+  lto_output_tree_or_ref (ob, DECL_VINDEX (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t   bool ref_p)\n+{\n+  /* Make sure we don't inadvertently set the assembler name.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n+    lto_output_tree_or_ref (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n+  else\n+    output_zero (ob);\n+\n+  lto_output_tree_or_ref (ob, DECL_SECTION_NAME (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_COMDAT_GROUP (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_FIELD_DECL structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\tbool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_FIELD_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_QUALIFIER (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FCONTEXT (expr), ref_p);\n+  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t   bool ref_p)\n+{\n+  /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  FIXME lto,\n+     maybe it should be handled here?  */\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr),\n+\t\t\t  ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_TYPE structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_type_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t  bool ref_p)\n+{\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_VALUES (expr), ref_p);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_DOMAIN (expr), ref_p);\n+  else if (TREE_CODE (expr) == RECORD_TYPE || TREE_CODE (expr) == UNION_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_FIELDS (expr), ref_p);\n+  else if (TREE_CODE (expr) == FUNCTION_TYPE || TREE_CODE (expr) == METHOD_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_ARG_TYPES (expr), ref_p);\n+  else if (TREE_CODE (expr) == VECTOR_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_DEBUG_REPRESENTATION_TYPE (expr), ref_p);\n+\n+  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO nor\n+     TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO.  */\n+  if (!POINTER_TYPE_P (expr))\n+    lto_output_tree_or_ref (ob, TYPE_MINVAL (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_MAXVAL (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  if (TREE_CODE (expr) == RECORD_TYPE || TREE_CODE (expr) == UNION_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_CANONICAL (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_LIST structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t  bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TREE_PURPOSE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TREE_VALUE (expr), ref_p);\n+  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_VEC structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  int i;\n+\n+  /* Note that the number of slots for EXPR has already been emitted\n+     in EXPR's header (see lto_output_tree_header).  */\n+  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+    lto_output_tree_or_ref (ob, TREE_VEC_ELT (expr, i), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_EXP structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  int i;\n+\n+  output_sleb128 (ob, TREE_OPERAND_LENGTH (expr));\n+  for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n+    lto_output_tree_or_ref (ob, TREE_OPERAND (expr, i), ref_p);\n+  lto_output_location (ob, EXPR_LOCATION (expr));\n+  lto_output_tree_or_ref (ob, TREE_BLOCK (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_BLOCK structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t   bool ref_p)\n+{\n+  unsigned i;\n+  tree t;\n+\n+  lto_output_location (ob, BLOCK_SOURCE_LOCATION (expr));\n+  lto_output_chain (ob, BLOCK_VARS (expr), ref_p);\n+\n+  output_uleb128 (ob, VEC_length (tree, BLOCK_NONLOCALIZED_VARS (expr)));\n+  for (i = 0; VEC_iterate (tree, BLOCK_NONLOCALIZED_VARS (expr), i, t); i++)\n+    lto_output_tree_or_ref (ob, t, ref_p);\n+\n+  lto_output_tree_or_ref (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BLOCK_ABSTRACT_ORIGIN (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_ORIGIN (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_CHAIN (expr), ref_p);\n+  lto_output_chain (ob, BLOCK_SUBBLOCKS (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_BINFO structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t   bool ref_p)\n+{\n+  unsigned i;\n+  tree t;\n+\n+  /* Note that the number of BINFO slots has already been emitted in\n+     EXPR's header (see lto_output_tree_header) because this length\n+     is needed to build the empty BINFO node on the reader side.  */\n+  for (i = 0; VEC_iterate (tree, BINFO_BASE_BINFOS (expr), i, t); i++)\n+    lto_output_tree_or_ref (ob, t, ref_p);\n+  output_zero (ob);\n+\n+  lto_output_tree_or_ref (ob, BINFO_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VTABLE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VIRTUALS (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VPTR_FIELD (expr), ref_p);\n+\n+  output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n+  for (i = 0; VEC_iterate (tree, BINFO_BASE_ACCESSES (expr), i, t); i++)\n+    lto_output_tree_or_ref (ob, t, ref_p);\n+\n+  lto_output_tree_or_ref (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_SUBVTT_INDEX (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VPTR_INDEX (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_CONSTRUCTOR structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  unsigned i;\n+  tree index, value;\n+\n+  output_uleb128 (ob, CONSTRUCTOR_NELTS (expr));\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n+    {\n+      lto_output_tree_or_ref (ob, index, ref_p);\n+      lto_output_tree_or_ref (ob, value, ref_p);\n+    }\n+}\n+\n+\n+/* Helper for lto_output_tree.  Write all pointer fields in EXPR to output\n+   block OB.  If REF_P is true, the leaves of EXPR are emitted as\n+   references.  */\n+\n+static void\n+lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMMON))\n+    lto_output_ts_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    lto_output_ts_vector_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    lto_output_ts_complex_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    lto_output_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    lto_output_ts_decl_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    lto_output_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    lto_output_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    lto_output_ts_field_decl_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    lto_output_ts_function_decl_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE))\n+    lto_output_ts_type_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    lto_output_ts_list_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    lto_output_ts_vec_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    lto_output_ts_exp_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_SSA_NAME))\n+    {\n+      /* We only stream the version number of SSA names.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    lto_output_ts_block_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    lto_output_ts_binfo_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    lto_output_ts_constructor_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STATEMENT_LIST))\n+    {\n+      /* This should only appear in GENERIC.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OMP_CLAUSE))\n+    {\n+      /* This should only appear in High GIMPLE.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n+    {\n+      /* FIXME lto.  Not handled yet.  */\n+      gcc_unreachable ();\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    {\n+      /* FIXME lto.  Not handled yet.  */\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Emit header information for tree EXPR to output block OB.  The header\n+   contains everything needed to instantiate an empty skeleton for\n+   EXPR on the reading side.  IX is the index into the streamer cache\n+   where EXPR is stored.  REF_P is as in lto_output_tree.  */\n+\n+static void\n+lto_output_tree_header (struct output_block *ob, tree expr, int ix)\n+{\n+  enum LTO_tags tag;\n+  enum tree_code code;\n+\n+  /* We should not see any non-GIMPLE tree nodes here.  */\n+  code = TREE_CODE (expr);\n+  if (!lto_is_streamable (expr))\n+    internal_error (\"tree code %qs is not supported in gimple streams\",\n+\t\t    tree_code_name[code]);\n+\n+  /* The header of a tree node consists of its tag, the size of\n+     the node, and any other information needed to instantiate\n+     EXPR on the reading side (such as the number of slots in\n+     variable sized nodes).  */\n+  tag = lto_tree_code_to_tag (code);\n+  output_record_start (ob, tag);\n+  output_sleb128 (ob, ix);\n+\n+  /* The following will cause bootstrap miscomparisons.  Enable with care.  */\n+#ifdef LTO_STREAMER_DEBUG\n+  /* This is used mainly for debugging purposes.  When the reader\n+     and the writer do not agree on a streamed node, the pointer\n+     value for EXPR can be used to track down the differences in\n+     the debugger.  */\n+  gcc_assert ((HOST_WIDEST_INT) (intptr_t) expr == (intptr_t) expr);\n+  output_sleb128 (ob, (HOST_WIDEST_INT) (intptr_t) expr);\n+#endif\n+\n+  /* The text in strings and identifiers are completely emitted in\n+     the header.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    output_string_cst (ob, ob->main_stream, expr);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    output_identifier (ob, ob->main_stream, expr);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n+  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n+}\n+\n+\n+/* Write the code and class of builtin EXPR to output block OB.  IX is\n+   the index into the streamer cache where EXPR is stored.*/\n+\n+static void\n+lto_output_builtin_tree (struct output_block *ob, tree expr, int ix)\n+{\n+  gcc_assert (lto_stream_as_builtin_p (expr));\n+\n+  output_record_start (ob, LTO_builtin_decl);\n+  output_uleb128 (ob, DECL_BUILT_IN_CLASS (expr));\n+  output_uleb128 (ob, DECL_FUNCTION_CODE (expr));\n+  output_sleb128 (ob, ix);\n+\n+  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n+    {\n+      /* When the assembler name of a builtin gets a user name,\n+\t the new name is always prefixed with '*' by\n+\t set_builtin_user_assembler_name.  So, to prevent the\n+\t reader side from adding a second '*', we omit it here.  */\n+      const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (expr));\n+      if (strlen (str) > 1 && str[0] == '*')\n+\toutput_string (ob, ob->main_stream, &str[1]);\n+      else\n+\toutput_string (ob, ob->main_stream, NULL);\n+    }\n+  else\n+    output_string (ob, ob->main_stream, NULL);\n+}\n+\n+\n+/* Write a physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  IX is the index into the streamer cache\n+   where EXPR is stored.  */\n+\n+static void\n+lto_write_tree (struct output_block *ob, tree expr, bool ref_p, int ix)\n+{\n+  struct bitpack_d *bp;\n+\n+  /* Write the header, containing everything needed to materialize\n+     EXPR on the reading side.  */\n+  lto_output_tree_header (ob, expr, ix);\n+\n+  /* Pack all the non-pointer fields in EXPR into a bitpack and write\n+     the resulting bitpack.  */\n+  bp = pack_value_fields (expr);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  /* Write all the pointer fields in EXPR.  */\n+  lto_output_tree_pointers (ob, expr, ref_p);\n+\n+  /* Mark the end of EXPR.  */\n+  output_zero (ob);\n+}\n+\n+\n+/* Emit the integer constant CST to output block OB.  If REF_P is true,\n+   CST's type will be emitted as a reference.  */\n+\n+static void\n+lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n+{\n+  output_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n+  lto_output_tree_or_ref (ob, TREE_TYPE (cst), ref_p);\n+  lto_output_1_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n+  output_uleb128 (ob, TREE_INT_CST_LOW (cst));\n+  output_uleb128 (ob, TREE_INT_CST_HIGH (cst));\n+}\n+\n+\n+/* Emit the physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  */\n+\n+void\n+lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  int ix;\n+  bool existed_p;\n+  unsigned offset;\n+\n+  if (expr == NULL_TREE)\n+    {\n+      output_zero (ob);\n+      return;\n+    }\n+\n+  /* INTEGER_CST nodes are special because they need their original type\n+     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    {\n+      lto_output_integer_cst (ob, expr, ref_p);\n+      return;\n+    }\n+\n+  /* Determine the offset in the stream where EXPR will be written.\n+     This is used when emitting pickle references so the reader knows\n+     where to reconstruct the pickled object from.  This allows\n+     circular and forward references within the same stream.  */\n+  offset = ob->main_stream->total_size;\n+\n+  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix, &offset);\n+  if (existed_p)\n+    {\n+      /* If a node has already been streamed out, make sure that\n+\t we don't write it more than once.  Otherwise, the reader\n+\t will instantiate two different nodes for the same object.  */\n+      output_record_start (ob, LTO_tree_pickle_reference);\n+      output_sleb128 (ob, ix);\n+      output_uleb128 (ob, lto_tree_code_to_tag (TREE_CODE (expr)));\n+      output_uleb128 (ob, offset);\n+    }\n+  else if (lto_stream_as_builtin_p (expr))\n+    {\n+      /* MD and NORMAL builtins do not need to be written out\n+\t completely as they are always instantiated by the\n+\t compiler on startup.  The only builtins that need to\n+\t be written out are BUILT_IN_FRONTEND.  For all other\n+\t builtins, we simply write the class and code.  */\n+      lto_output_builtin_tree (ob, expr, ix);\n+    }\n+  else\n+    {\n+      /* This is the first time we see EXPR, write its fields\n+\t to OB.  */\n+      lto_write_tree (ob, expr, ref_p, ix);\n+    }\n+}\n+\n+\n+/* Output to OB a list of try/catch handlers starting with FIRST.  */\n+\n+static void\n+output_eh_try_list (struct output_block *ob, eh_catch first)\n+{\n+  eh_catch n;\n+\n+  for (n = first; n; n = n->next_catch)\n+    {\n+      output_record_start (ob, LTO_eh_catch);\n+      lto_output_tree_ref (ob, n->type_list);\n+      lto_output_tree_ref (ob, n->filter_list);\n+      lto_output_tree_ref (ob, n->label);\n+    }\n+\n+  output_zero (ob);\n+}\n+\n+\n+/* Output EH region R in function FN to OB.  CURR_RN is the slot index\n+   that is being emitted in FN->EH->REGION_ARRAY.  This is used to\n+   detect EH region sharing.  */\n+\n+static void\n+output_eh_region (struct output_block *ob, eh_region r)\n+{\n+  enum LTO_tags tag;\n+\n+  if (r == NULL)\n+    {\n+      output_zero (ob);\n+      return;\n+    }\n+\n+  if (r->type == ERT_CLEANUP)\n+    tag = LTO_ert_cleanup;\n+  else if (r->type == ERT_TRY)\n+    tag = LTO_ert_try;\n+  else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n+    tag = LTO_ert_allowed_exceptions;\n+  else if (r->type == ERT_MUST_NOT_THROW)\n+    tag = LTO_ert_must_not_throw;\n+  else\n+    gcc_unreachable ();\n+\n+  output_record_start (ob, tag);\n+  output_sleb128 (ob, r->index);\n+\n+  if (r->outer)\n+    output_sleb128 (ob, r->outer->index);\n+  else\n+    output_zero (ob);\n+\n+  if (r->inner)\n+    output_sleb128 (ob, r->inner->index);\n+  else\n+    output_zero (ob);\n+\n+  if (r->next_peer)\n+    output_sleb128 (ob, r->next_peer->index);\n+  else\n+    output_zero (ob);\n+\n+  if (r->type == ERT_TRY)\n+    {\n+      output_eh_try_list (ob, r->u.eh_try.first_catch);\n+    }\n+  else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n+    {\n+      lto_output_tree_ref (ob, r->u.allowed.type_list);\n+      lto_output_tree_ref (ob, r->u.allowed.label);\n+      output_uleb128 (ob, r->u.allowed.filter);\n+    }\n+  else if (r->type == ERT_MUST_NOT_THROW)\n+    {\n+      lto_output_tree_ref (ob, r->u.must_not_throw.failure_decl);\n+      lto_output_location (ob, r->u.must_not_throw.failure_loc);\n+    }\n+\n+  if (r->landing_pads)\n+    output_sleb128 (ob, r->landing_pads->index);\n+  else\n+    output_zero (ob);\n+}\n+\n+\n+/* Output landing pad LP to OB.  */\n+\n+static void\n+output_eh_lp (struct output_block *ob, eh_landing_pad lp)\n+{\n+  if (lp == NULL)\n+    {\n+      output_zero (ob);\n+      return;\n+    }\n+\n+  output_record_start (ob, LTO_eh_landing_pad);\n+  output_sleb128 (ob, lp->index);\n+  if (lp->next_lp)\n+    output_sleb128 (ob, lp->next_lp->index);\n+  else\n+    output_zero (ob);\n+\n+  if (lp->region)\n+    output_sleb128 (ob, lp->region->index);\n+  else\n+    output_zero (ob);\n+\n+  lto_output_tree_ref (ob, lp->post_landing_pad);\n+}\n+\n+\n+/* Output the existing eh_table to OB.  */\n+\n+static void\n+output_eh_regions (struct output_block *ob, struct function *fn)\n+{\n+  if (fn->eh && fn->eh->region_tree)\n+    {\n+      unsigned i;\n+      eh_region eh;\n+      eh_landing_pad lp;\n+      tree ttype;\n+\n+      output_record_start (ob, LTO_eh_table);\n+\n+      /* Emit the index of the root of the EH region tree.  */\n+      output_sleb128 (ob, fn->eh->region_tree->index);\n+\n+      /* Emit all the EH regions in the region array.  */\n+      output_sleb128 (ob, VEC_length (eh_region, fn->eh->region_array));\n+      for (i = 0; VEC_iterate (eh_region, fn->eh->region_array, i, eh); i++)\n+\toutput_eh_region (ob, eh);\n+\n+      /* Emit all landing pads.  */\n+      output_sleb128 (ob, VEC_length (eh_landing_pad, fn->eh->lp_array));\n+      for (i = 0; VEC_iterate (eh_landing_pad, fn->eh->lp_array, i, lp); i++)\n+\toutput_eh_lp (ob, lp);\n+\n+      /* Emit all the runtime type data.  */\n+      output_sleb128 (ob, VEC_length (tree, fn->eh->ttype_data));\n+      for (i = 0; VEC_iterate (tree, fn->eh->ttype_data, i, ttype); i++)\n+\tlto_output_tree_ref (ob, ttype);\n+\n+      /* Emit the table of action chains.  */\n+      if (targetm.arm_eabi_unwinder)\n+\t{\n+\t  tree t;\n+\t  output_sleb128 (ob, VEC_length (tree, fn->eh->ehspec_data.arm_eabi));\n+\t  for (i = 0;\n+\t       VEC_iterate (tree, fn->eh->ehspec_data.arm_eabi, i, t);\n+\t       i++)\n+\t    lto_output_tree_ref (ob, t);\n+\t}\n+      else\n+\t{\n+\t  uchar c;\n+\t  output_sleb128 (ob, VEC_length (uchar, fn->eh->ehspec_data.other));\n+\t  for (i = 0; VEC_iterate (uchar, fn->eh->ehspec_data.other, i, c); i++)\n+\t    lto_output_1_stream (ob->main_stream, c);\n+\t}\n+    }\n+\n+  /* The 0 either terminates the record or indicates that there are no\n+     eh_records at all.  */\n+  output_zero (ob);\n+}\n+\n+\n+/* Output all of the active ssa names to the ssa_names stream.  */\n+\n+static void\n+output_ssa_names (struct output_block *ob, struct function *fn)\n+{\n+  unsigned int i, len;\n+\n+  len = VEC_length (tree, SSANAMES (fn));\n+  output_uleb128 (ob, len);\n+\n+  for (i = 1; i < len; i++)\n+    {\n+      tree ptr = VEC_index (tree, SSANAMES (fn), i);\n+\n+      if (ptr == NULL_TREE\n+\t  || SSA_NAME_IN_FREE_LIST (ptr)\n+\t  || !is_gimple_reg (ptr))\n+\tcontinue;\n+\n+      output_uleb128 (ob, i);\n+      lto_output_1_stream (ob->main_stream, SSA_NAME_IS_DEFAULT_DEF (ptr));\n+      lto_output_tree_ref (ob, SSA_NAME_VAR (ptr));\n+    }\n+\n+  output_zero (ob);\n+}\n+\n+\n+/* Output the cfg.  */\n+\n+static void\n+output_cfg (struct output_block *ob, struct function *fn)\n+{\n+  struct lto_output_stream *tmp_stream = ob->main_stream;\n+  basic_block bb;\n+\n+  ob->main_stream = ob->cfg_stream;\n+\n+  output_uleb128 (ob, profile_status_for_function (fn));\n+\n+  /* Output the number of the highest basic block.  */\n+  output_uleb128 (ob, last_basic_block_for_function (fn));\n+\n+  FOR_ALL_BB_FN (bb, fn)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+\n+      output_sleb128 (ob, bb->index);\n+\n+      /* Output the successors and the edge flags.  */\n+      output_uleb128 (ob, EDGE_COUNT (bb->succs));\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  output_uleb128 (ob, e->dest->index);\n+\t  output_sleb128 (ob, e->probability);\n+\t  output_sleb128 (ob, e->count);\n+\t  output_uleb128 (ob, e->flags);\n+\t}\n+    }\n+\n+  output_sleb128 (ob, -1);\n+\n+  bb = ENTRY_BLOCK_PTR;\n+  while (bb->next_bb)\n+    {\n+      output_sleb128 (ob, bb->next_bb->index);\n+      bb = bb->next_bb;\n+    }\n+\n+  output_sleb128 (ob, -1);\n+\n+  ob->main_stream = tmp_stream;\n+}\n+\n+\n+/* Output PHI function PHI to the main stream in OB.  */\n+\n+static void\n+output_phi (struct output_block *ob, gimple phi)\n+{\n+  unsigned i, len = gimple_phi_num_args (phi);\n+  \n+  output_record_start (ob, lto_gimple_code_to_tag (GIMPLE_PHI));\n+  output_uleb128 (ob, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      lto_output_tree_ref (ob, gimple_phi_arg_def (phi, i));\n+      output_uleb128 (ob, gimple_phi_arg_edge (phi, i)->src->index);\n+      lto_output_location (ob, gimple_phi_arg_location (phi, i));\n+    }\n+}\n+\n+\n+/* Emit statement STMT on the main stream of output block OB.  */\n+\n+static void\n+output_gimple_stmt (struct output_block *ob, gimple stmt)\n+{\n+  unsigned i;\n+  enum gimple_code code;\n+  enum LTO_tags tag;\n+  struct bitpack_d *bp;\n+\n+  /* Emit identifying tag.  */\n+  code = gimple_code (stmt);\n+  tag = lto_gimple_code_to_tag (code);\n+  output_record_start (ob, tag);\n+\n+  /* Emit the tuple header.  */\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, gimple_num_ops (stmt), sizeof (unsigned) * 8);\n+  bp_pack_value (bp, gimple_no_warning_p (stmt), 1);\n+  if (is_gimple_assign (stmt))\n+    bp_pack_value (bp, gimple_assign_nontemporal_move_p (stmt), 1);\n+  bp_pack_value (bp, gimple_has_volatile_ops (stmt), 1);\n+  bp_pack_value (bp, stmt->gsbase.subcode, 16);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  /* Emit location information for the statement.  */\n+  lto_output_location (ob, gimple_location (stmt));\n+\n+  /* Emit the lexical block holding STMT.  */\n+  lto_output_tree (ob, gimple_block (stmt), true);\n+\n+  /* Emit the operands.  */\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_RESX:\n+      output_sleb128 (ob, gimple_resx_region (stmt));\n+      break;\n+\n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      lto_output_tree_ref (ob, gimple_eh_must_not_throw_fndecl (stmt));\n+      break;\n+\n+    case GIMPLE_EH_DISPATCH:\n+      output_sleb128 (ob, gimple_eh_dispatch_region (stmt));\n+      break;\n+\n+    case GIMPLE_ASM:\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_ninputs (stmt));\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_noutputs (stmt));\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nclobbers (stmt));\n+      output_string (ob, ob->main_stream, gimple_asm_string (stmt));\n+      /* Fallthru  */\n+\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_CALL:\n+    case GIMPLE_RETURN:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_LABEL:\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_DEBUG:\n+      for (i = 0; i < gimple_num_ops (stmt); i++)\n+\t{\n+\t  tree op = gimple_op (stmt, i);\n+\t  lto_output_tree_ref (ob, op);\n+\t}\n+      break;\n+\n+    case GIMPLE_PREDICT:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Output a basic block BB to the main stream in OB for this FN.  */\n+\n+static void\n+output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n+{\n+  gimple_stmt_iterator bsi = gsi_start_bb (bb);\n+\n+  output_record_start (ob,\n+\t\t       (!gsi_end_p (bsi)) || phi_nodes (bb)\n+\t\t        ? LTO_bb1\n+\t\t\t: LTO_bb0);\n+\n+  output_uleb128 (ob, bb->index);\n+  output_sleb128 (ob, bb->count);\n+  output_sleb128 (ob, bb->loop_depth);\n+  output_sleb128 (ob, bb->frequency);\n+  output_sleb128 (ob, bb->flags);\n+\n+  if (!gsi_end_p (bsi) || phi_nodes (bb))\n+    {\n+      /* Output the statements.  The list of statements is terminated\n+\t with a zero.  */\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  int region;\n+\t  gimple stmt = gsi_stmt (bsi);\n+\n+\t  output_gimple_stmt (ob, stmt);\n+\t\n+\t  /* Emit the EH region holding STMT.  */\n+\t  region = lookup_stmt_eh_lp_fn (fn, stmt);\n+\t  if (region != 0)\n+\t    {\n+\t      output_record_start (ob, LTO_eh_region);\n+\t      output_sleb128 (ob, region);\n+\t    }\n+\t  else\n+\t    output_zero (ob);\n+\t}\n+\n+      output_zero (ob);\n+\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple phi = gsi_stmt (bsi);\n+\n+\t  /* Only emit PHIs for gimple registers.  PHI nodes for .MEM\n+\t     will be filled in on reading when the SSA form is\n+\t     updated.  */\n+\t  if (is_gimple_reg (gimple_phi_result (phi)))\n+\t    output_phi (ob, phi);\n+\t}\n+\n+      output_zero (ob);\n+    }\n+}\n+\n+/* Create the header in the file using OB.  If the section type is for\n+   a function, set FN to the decl for that function.  */\n+\n+static void\n+produce_asm (struct output_block *ob, tree fn)\n+{\n+  enum lto_section_type section_type = ob->section_type;\n+  struct lto_function_header header;\n+  char *section_name;\n+  struct lto_output_stream *header_stream;\n+\n+  if (section_type == LTO_section_function_body)\n+    {\n+      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fn));\n+      section_name = lto_get_section_name (section_type, name);\n+    }\n+  else\n+    section_name = lto_get_section_name (section_type, NULL);\n+\n+  lto_begin_section (section_name, !flag_wpa);\n+  free (section_name);\n+\n+  /* The entire header is stream computed here.  */\n+  memset (&header, 0, sizeof (struct lto_function_header));\n+  \n+  /* Write the header.  */\n+  header.lto_header.major_version = LTO_major_version;\n+  header.lto_header.minor_version = LTO_minor_version;\n+  header.lto_header.section_type = section_type;\n+  \n+  header.compressed_size = 0;\n+  \n+  if (section_type == LTO_section_function_body)\n+    header.cfg_size = ob->cfg_stream->total_size;\n+  header.main_size = ob->main_stream->total_size;\n+  header.string_size = ob->string_stream->total_size;\n+\n+  header_stream = XCNEW (struct lto_output_stream);\n+  lto_output_data_stream (header_stream, &header, sizeof header);\n+  lto_write_stream (header_stream);\n+  free (header_stream);\n+\n+  /* Put all of the gimple and the string table out the asm file as a\n+     block of text.  */\n+  if (section_type == LTO_section_function_body)\n+    lto_write_stream (ob->cfg_stream);\n+  lto_write_stream (ob->main_stream);\n+  lto_write_stream (ob->string_stream);\n+\n+  lto_end_section ();\n+}\n+\n+\n+/* Output the body of function NODE->DECL.  */\n+\n+static void\n+output_function (struct cgraph_node *node)\n+{\n+  struct bitpack_d *bp;\n+  tree function;\n+  struct function *fn;\n+  basic_block bb;\n+  struct output_block *ob;\n+\n+  function = node->decl;\n+  fn = DECL_STRUCT_FUNCTION (function);\n+  ob = create_output_block (LTO_section_function_body);\n+\n+  clear_line_info (ob);\n+  ob->cgraph_node = node;\n+\n+  gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n+\n+  /* Set current_function_decl and cfun.  */\n+  current_function_decl = function;\n+  push_cfun (fn);\n+\n+  /* Make string 0 be a NULL string.  */\n+  lto_output_1_stream (ob->string_stream, 0);\n+\n+  output_record_start (ob, LTO_function);\n+\n+  /* Write all the attributes for FN.  */\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, fn->is_thunk, 1);\n+  bp_pack_value (bp, fn->has_local_explicit_reg_vars, 1);\n+  bp_pack_value (bp, fn->after_tree_profile, 1);\n+  bp_pack_value (bp, fn->returns_pcc_struct, 1);\n+  bp_pack_value (bp, fn->returns_struct, 1);\n+  bp_pack_value (bp, fn->always_inline_functions_inlined, 1);\n+  bp_pack_value (bp, fn->after_inlining, 1);\n+  bp_pack_value (bp, fn->dont_save_pending_sizes_p, 1);\n+  bp_pack_value (bp, fn->stdarg, 1);\n+  bp_pack_value (bp, fn->has_nonlocal_label, 1);\n+  bp_pack_value (bp, fn->calls_alloca, 1);\n+  bp_pack_value (bp, fn->calls_setjmp, 1);\n+  bp_pack_value (bp, fn->function_frequency, 2);\n+  bp_pack_value (bp, fn->va_list_fpr_size, 8);\n+  bp_pack_value (bp, fn->va_list_gpr_size, 8);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  /* Output the static chain and non-local goto save area.  */\n+  lto_output_tree_ref (ob, fn->static_chain_decl);\n+  lto_output_tree_ref (ob, fn->nonlocal_goto_save_area);\n+\n+  /* Output all the local variables in the function.  */\n+  lto_output_tree_ref (ob, fn->local_decls);\n+\n+  /* Output all the SSA names used in the function.  */\n+  output_ssa_names (ob, fn);\n+\n+  /* Output any exception handling regions.  */\n+  output_eh_regions (ob, fn);\n+\n+  /* Output DECL_INITIAL for the function, which contains the tree of\n+     lexical scopes.  */\n+  lto_output_tree (ob, DECL_INITIAL (function), true);\n+\n+  /* Output the head of the arguments list.  */\n+  lto_output_tree_ref (ob, DECL_ARGUMENTS (function));\n+\n+  /* We will renumber the statements.  The code that does this uses\n+     the same ordering that we use for serializing them so we can use\n+     the same code on the other end and not have to write out the\n+     statement numbers.  */\n+  renumber_gimple_stmt_uids ();\n+\n+  /* Output the code for the function.  */\n+  FOR_ALL_BB_FN (bb, fn)\n+    output_bb (ob, bb, fn);\n+\n+  /* The terminator for this function.  */\n+  output_zero (ob);\n+\n+  output_cfg (ob, fn);\n+\n+  /* Create a section to hold the pickled output of this function.   */\n+  produce_asm (ob, function);\n+\n+  destroy_output_block (ob);\n+\n+  current_function_decl = NULL;\n+  pop_cfun ();\n+}\n+\n+\n+/* Return true if alias pair P belongs to the set of cgraph nodes in\n+   SET.  If P is a an alias for a VAR_DECL, it can always be emitted.\n+   However, for FUNCTION_DECL aliases, we should only output the pair\n+   if it belongs to a function whose cgraph node is in SET.\n+   Otherwise, the LTRANS phase will get into trouble when finalizing\n+   aliases because the alias will refer to a function not defined in\n+   the file processed by LTRANS.  */\n+\n+static bool\n+output_alias_pair_p (alias_pair *p, cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator csi;\n+  struct cgraph_node *target_node;\n+\n+  /* Always emit VAR_DECLs.  FIXME lto, we should probably only emit\n+     those VAR_DECLs that are instantiated in this file partition, but\n+     we have no easy way of knowing this based on SET.  */\n+  if (TREE_CODE (p->decl) == VAR_DECL)\n+    return true;\n+\n+  /* Check if the assembler name for P->TARGET has its cgraph node in SET.  */\n+  gcc_assert (TREE_CODE (p->decl) == FUNCTION_DECL);\n+  target_node = cgraph_node_for_asm (p->target);\n+  csi = cgraph_node_set_find (set, target_node);\n+  return (!csi_end_p (csi));\n+}\n+\n+\n+/* Output any unreferenced global symbol defined in SET, alias pairs\n+   and labels.  */\n+\n+static void\n+output_unreferenced_globals (cgraph_node_set set)\n+{\n+  struct output_block *ob;\n+  alias_pair *p;\n+  unsigned i;\n+  struct varpool_node *vnode;\n+\n+  ob = create_output_block (LTO_section_static_initializer);\n+  ob->cgraph_node = NULL;\n+\n+  clear_line_info (ob);\n+\n+  /* Make string 0 be a NULL string.  */\n+  lto_output_1_stream (ob->string_stream, 0);\n+\n+  /* Emit references for all the global symbols.  If a global symbol\n+     was never referenced in any of the functions of this file, it\n+     would not be emitted otherwise.  This will result in unreferenced\n+     symbols at link time if a file defines a global symbol but\n+     never references it.  */\n+  FOR_EACH_STATIC_VARIABLE (vnode)\n+    {\n+      tree var = vnode->decl;\n+\n+      if (TREE_CODE (var) == VAR_DECL && TREE_PUBLIC (var))\n+\tlto_output_tree_ref (ob, var);\n+    }\n+\n+  output_zero (ob);\n+\n+  /* Emit the alias pairs for the nodes in SET.  */\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+    {\n+      if (output_alias_pair_p (p, set))\n+\t{\n+\t  lto_output_tree_ref (ob, p->decl);\n+\t  lto_output_tree_ref (ob, p->target);\n+\t}\n+    }\n+\n+  output_zero (ob);\n+\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+\n+/* Copy the function body of NODE without deserializing. */\n+\n+static void\n+copy_function (struct cgraph_node *node)\n+{\n+  tree function = node->decl;\n+  struct lto_file_decl_data *file_data = node->local.lto_file_data;\n+  struct lto_output_stream *output_stream = XCNEW (struct lto_output_stream);\n+  const char *data;\n+  size_t len;\n+  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function));\n+  char *section_name =\n+    lto_get_section_name (LTO_section_function_body, name);\n+  size_t i, j;\n+  struct lto_in_decl_state *in_state;\n+  struct lto_out_decl_state *out_state = lto_get_out_decl_state ();\n+\n+  lto_begin_section (section_name, !flag_wpa);\n+  free (section_name);\n+\n+  /* We may have renamed the declaration, e.g., a static function.  */\n+  name = lto_get_decl_name_mapping (file_data, name);\n+\n+  data = lto_get_section_data (file_data, LTO_section_function_body,\n+                               name, &len);\n+  gcc_assert (data);\n+\n+  /* Do a bit copy of the function body.  */\n+  lto_output_data_stream (output_stream, data, len);\n+  lto_write_stream (output_stream);\n+\n+  /* Copy decls. */\n+  in_state =\n+    lto_get_function_in_decl_state (node->local.lto_file_data, function);\n+  gcc_assert (in_state);\n+\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    {\n+      size_t n = in_state->streams[i].size;\n+      tree *trees = in_state->streams[i].trees;\n+      struct lto_tree_ref_encoder *encoder = &(out_state->streams[i]);\n+\n+      /* The out state must have the same indices and the in state.\n+\t So just copy the vector.  All the encoders in the in state\n+\t must be empty where we reach here. */\n+      gcc_assert (lto_tree_ref_encoder_size (encoder) == 0);\n+      for (j = 0; j < n; j++)\n+\tVEC_safe_push (tree, heap, encoder->trees, trees[j]);\n+      encoder->next_index = n;\n+    }\n+  \n+  lto_free_section_data (file_data, LTO_section_function_body, name,\n+\t\t\t data, len);\n+  free (output_stream);\n+  lto_end_section ();\n+}\n+\n+\n+/* Initialize the LTO writer.  */\n+\n+static void\n+lto_writer_init (void)\n+{\n+  lto_streamer_init ();\n+}\n+\n+\n+/* Main entry point from the pass manager.  */\n+\n+static void\n+lto_output (cgraph_node_set set)\n+{\n+  struct cgraph_node *node;\n+  struct lto_out_decl_state *decl_state;\n+  cgraph_node_set_iterator csi;\n+  bitmap output = lto_bitmap_alloc ();\n+\n+  lto_writer_init ();\n+\n+  /* Process only the functions with bodies.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (node->analyzed && !bitmap_bit_p (output, DECL_UID (node->decl)))\n+\t{\n+\t  bitmap_set_bit (output, DECL_UID (node->decl));\n+\t  decl_state = lto_new_out_decl_state ();\n+\t  lto_push_out_decl_state (decl_state);\n+\t  if (!flag_wpa)\n+\t    output_function (node);\n+\t  else\n+\t    copy_function (node);\n+\t  gcc_assert (lto_get_out_decl_state () == decl_state);\n+\t  lto_pop_out_decl_state ();\n+\t  lto_record_function_out_decl_state (node->decl, decl_state);\n+\t}\n+    }\n+\n+  /* Emit the callgraph after emitting function bodies.  This needs to\n+     be done now to make sure that all the statements in every function\n+     have been renumbered so that edges can be associated with call\n+     statements using the statement UIDs.  */\n+  output_cgraph (set);\n+\n+  lto_bitmap_free (output);\n+}\n+\n+struct ipa_opt_pass_d pass_ipa_lto_gimple_out =\n+{\n+ {\n+  IPA_PASS,\n+  \"lto_gimple_out\",\t                /* name */\n+  gate_lto_out,\t\t\t        /* gate */\n+  NULL,\t\t                \t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_LTO_GIMPLE_IO,\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,            \t\t\t/* todo_flags_start */\n+  TODO_dump_func                        /* todo_flags_finish */\n+ },\n+ NULL,\t\t                        /* generate_summary */\n+ lto_output,           \t\t\t/* write_summary */\n+ NULL,\t\t         \t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n+};\n+\n+\n+/* Write each node in encoded by ENCODER to OB, as well as those reachable \n+   from it and required for correct representation of its semantics.\n+   Each node in ENCODER must be a global declaration or a type.  A node\n+   is written only once, even if it appears multiple times in the\n+   vector.  Certain transitively-reachable nodes, such as those\n+   representing expressions, may be duplicated, but such nodes\n+   must not appear in ENCODER itself.  */\n+\n+static void\n+write_global_stream (struct output_block *ob,\n+\t\t     struct lto_tree_ref_encoder *encoder)\n+{\n+  tree t;\n+  size_t index;\n+  const size_t size = lto_tree_ref_encoder_size (encoder);\n+\n+  for (index = 0; index < size; index++)\n+    {\n+      t = lto_tree_ref_encoder_get_tree (encoder, index);\n+      if (!lto_streamer_cache_lookup (ob->writer_cache, t, NULL))\n+\t{\n+\t  if (flag_wpa)\n+\t    {\n+\t      /* In WPA we should not emit multiple definitions of the\n+\t\t same symbol to all the files in the link set.  If\n+\t\t T had already been emitted as the pervailing definition\n+\t\t in one file, emit it as an external reference in the\n+\t\t others.  */\n+\t      /* FIXME lto.  We should check if T belongs to the\n+\t\t file we are writing to.  */\n+\t      if (TREE_CODE (t) == VAR_DECL\n+\t\t  && TREE_PUBLIC (t)\n+\t\t  && !DECL_EXTERNAL (t))\n+\t\t{\n+\t\t  /* FIXME lto.  Make DECLS_ALREADY_EMITTED an argument\n+\t\t     to this function so it can be freed up afterwards.\n+\t\t     Alternately, assign global symbols to cgraph\n+\t\t     node sets.  */\n+\t\t  static struct pointer_set_t *decls_already_emitted = NULL;\n+\n+\t\t  if (decls_already_emitted == NULL)\n+\t\t    decls_already_emitted = pointer_set_create ();\n+\n+\t\t  if (pointer_set_insert (decls_already_emitted, t))\n+\t\t    make_decl_one_only (t, DECL_ASSEMBLER_NAME (t));\n+\t\t}\n+\t    }\n+\n+\t  lto_output_tree (ob, t, false);\n+\t}\n+    }\n+}\n+\n+\n+/* Write a sequence of indices into the globals vector corresponding\n+   to the trees in ENCODER.  These are used by the reader to map the\n+   indices used to refer to global entities within function bodies to\n+   their referents.  */\n+\n+static void\n+write_global_references (struct output_block *ob,\n+\t\t\t struct lto_output_stream *ref_stream,\n+ \t\t\t struct lto_tree_ref_encoder *encoder)\n+{\n+  tree t;\n+  int32_t index;\n+  const int32_t size = lto_tree_ref_encoder_size (encoder);\n+\n+  /* Write size as 32-bit unsigned. */\n+  lto_output_data_stream (ref_stream, &size, sizeof (int32_t));\n+\n+  for (index = 0; index < size; index++)\n+    {\n+      int32_t slot_num;\n+\n+      t = lto_tree_ref_encoder_get_tree (encoder, index);\n+      lto_streamer_cache_lookup (ob->writer_cache, t, &slot_num);\n+      gcc_assert (slot_num >= 0);\n+      lto_output_data_stream (ref_stream, &slot_num, sizeof slot_num);\n+    }\n+}\n+\n+\n+/* Write all the streams in an lto_out_decl_state STATE using\n+   output block OB and output stream OUT_STREAM.  */\n+\n+static void\n+lto_output_decl_state_streams (struct output_block *ob,\n+\t\t\t       struct lto_out_decl_state *state)\n+{\n+  int i;\n+\n+  for (i = 0;  i < LTO_N_DECL_STREAMS; i++)\n+    write_global_stream (ob, &state->streams[i]);\n+}\n+\n+\n+/* Write all the references in an lto_out_decl_state STATE using\n+   output block OB and output stream OUT_STREAM.  */\n+\n+static void\n+lto_output_decl_state_refs (struct output_block *ob,\n+\t\t\t    struct lto_output_stream *out_stream,\n+\t\t\t    struct lto_out_decl_state *state)\n+{\n+  unsigned i;\n+  int32_t ref;\n+  tree decl;\n+  \n+  /* Write reference to FUNCTION_DECL.  If there is not function,\n+     write reference to void_type_node. */\n+  decl = (state->fn_decl) ? state->fn_decl : void_type_node;\n+  lto_streamer_cache_lookup (ob->writer_cache, decl, &ref);\n+  gcc_assert (ref >= 0);\n+  lto_output_data_stream (out_stream, &ref, sizeof (int32_t));\n+\n+  for (i = 0;  i < LTO_N_DECL_STREAMS; i++)\n+    write_global_references (ob, out_stream, &state->streams[i]);\n+}\n+\n+\n+/* Return the written size of STATE. */\n+\n+static size_t\n+lto_out_decl_state_written_size (struct lto_out_decl_state *state)\n+{\n+  int i;\n+  size_t size;\n+\n+  size = sizeof (int32_t);\t/* fn_ref. */\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    {\n+      size += sizeof (int32_t); /* vector size. */\n+      size += (lto_tree_ref_encoder_size (&state->streams[i])\n+\t       * sizeof (int32_t));\n+    }\n+  return size;\n+}\n+\n+\n+/* Helper function of write_symbols_of_kind.  CACHE is the streamer\n+   cache with all the pickled nodes.  STREAM is the stream where to\n+   write the table.  V is a vector with the DECLs that should be on\n+   the table.  SEEN is a bitmap of symbols written so far.  */\n+\n+static void\n+write_symbol_vec (struct lto_streamer_cache_d *cache,\n+\t\t  struct lto_output_stream *stream,\n+\t\t  VEC(tree,heap) *v, bitmap seen)\n+{\n+  tree t;\n+  int index;\n+\n+  for (index = 0; VEC_iterate(tree, v, index, t); index++)\n+    {\n+      const char *name;\n+      enum gcc_plugin_symbol_kind kind;\n+      enum gcc_plugin_symbol_visibility visibility;\n+      int slot_num;\n+      uint64_t size;\n+      const char *comdat;\n+\n+      /* None of the following kinds of symbols are needed in the\n+\t symbol table.  */\n+      if (!TREE_PUBLIC (t)\n+\t  || is_builtin_fn (t)\n+\t  || DECL_ABSTRACT (t)\n+\t  || TREE_CODE (t) == RESULT_DECL)\n+\tcontinue;\n+\n+      gcc_assert (TREE_CODE (t) == VAR_DECL\n+\t\t  || TREE_CODE (t) == FUNCTION_DECL);\n+\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n+\n+      /* FIXME lto: this is from assemble_name_raw in varasm.c. For some\n+\t architectures we might have to do the same name manipulations that\n+\t ASM_OUTPUT_LABELREF does. */\n+      if (name[0] == '*')\n+\tname = &name[1];\n+\n+      lto_streamer_cache_lookup (cache, t, &slot_num);\n+      gcc_assert (slot_num >= 0);\n+\n+      /* Avoid duplicate symbols. */\n+      if (bitmap_bit_p (seen, slot_num))\n+\tcontinue;\n+      else\n+        bitmap_set_bit (seen, slot_num);\n+\n+      if (DECL_EXTERNAL (t))\n+\t{\n+\t  if (DECL_WEAK (t))\n+\t    kind = GCCPK_WEAKUNDEF;\n+\t  else\n+\t    kind = GCCPK_UNDEF;\n+\t}\n+      else\n+\t{\n+\t  if (DECL_WEAK (t))\n+\t    kind = GCCPK_WEAKDEF;\n+\t  else if (DECL_COMMON (t))\n+\t    kind = GCCPK_COMMON;\n+\t  else\n+\t    kind = GCCPK_DEF;\n+\t}\n+\n+      switch (DECL_VISIBILITY(t))\n+\t{\n+\tcase VISIBILITY_DEFAULT:\n+\t  visibility = GCCPV_DEFAULT;\n+\t  break;\n+\tcase VISIBILITY_PROTECTED:\n+\t  visibility = GCCPV_PROTECTED;\n+\t  break;\n+\tcase VISIBILITY_HIDDEN:\n+\t  visibility = GCCPV_HIDDEN;\n+\t  break;\n+\tcase VISIBILITY_INTERNAL:\n+\t  visibility = GCCPV_INTERNAL;\n+\t  break;\n+\t}\n+\n+      if (kind == GCCPK_COMMON && DECL_SIZE (t))\n+\tsize = (((uint64_t) TREE_INT_CST_HIGH (DECL_SIZE (t))) << 32)\n+\t  | TREE_INT_CST_LOW (DECL_SIZE (t));\n+      else\n+\tsize = 0;\n+\n+      if (DECL_ONE_ONLY (t))\n+\tcomdat = IDENTIFIER_POINTER (DECL_COMDAT_GROUP (t));\n+      else\n+\tcomdat = \"\";\n+\n+      lto_output_data_stream (stream, name, strlen (name) + 1);\n+      lto_output_data_stream (stream, comdat, strlen (comdat) + 1);\n+      lto_output_data_stream (stream, &kind, 1);\n+      lto_output_data_stream (stream, &visibility, 1);\n+      lto_output_data_stream (stream, &size, 8);\n+      lto_output_data_stream (stream, &slot_num, 4);\n+    }\n+}\n+\n+\n+/* Write IL symbols of KIND.  CACHE is the streamer cache with all the\n+   pickled nodes.  SEEN is a bitmap of symbols written so far.  */\n+\n+static void\n+write_symbols_of_kind (lto_decl_stream_e_t kind,\n+\t\t       struct lto_streamer_cache_d *cache, bitmap seen)\n+{\n+  struct lto_out_decl_state *out_state;\n+  struct lto_output_stream stream;\n+  unsigned num_fns =\n+    VEC_length (lto_out_decl_state_ptr, lto_function_decl_states);\n+  unsigned idx;\n+\n+  memset (&stream, 0, sizeof (stream));\n+  out_state = lto_get_out_decl_state ();\n+  write_symbol_vec (cache, &stream, out_state->streams[kind].trees, seen);\n+\n+  for (idx = 0; idx < num_fns; idx++)\n+    {\n+      out_state =\n+\tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n+      write_symbol_vec (cache, &stream, out_state->streams[kind].trees, seen);\n+    }\n+\n+  lto_write_stream (&stream);\n+}\n+\n+\n+/* Write an IL symbol table.  CACHE is the streamer cache with all the\n+   pickled nodes.  */\n+\n+static void\n+produce_symtab (struct lto_streamer_cache_d *cache)\n+{\n+  char *section_name = lto_get_section_name (LTO_section_symtab, NULL);\n+  bitmap seen;\n+\n+  lto_begin_section (section_name, false);\n+  free (section_name);\n+\n+  seen = lto_bitmap_alloc ();\n+  write_symbols_of_kind (LTO_DECL_STREAM_FN_DECL, cache, seen);\n+  write_symbols_of_kind (LTO_DECL_STREAM_VAR_DECL, cache, seen);\n+  lto_bitmap_free (seen);\n+\n+  lto_end_section ();\n+}\n+\n+\n+/* This pass is run after all of the functions are serialized and all\n+   of the IPA passes have written their serialized forms.  This pass\n+   causes the vector of all of the global decls and types used from\n+   this file to be written in to a section that can then be read in to\n+   recover these on other side.  */\n+\n+static void\n+produce_asm_for_decls (cgraph_node_set set)\n+{\n+  struct lto_out_decl_state *out_state;\n+  struct lto_out_decl_state *fn_out_state;\n+  struct lto_decl_header header;\n+  char *section_name;\n+  struct output_block *ob;\n+  struct lto_output_stream *header_stream, *decl_state_stream;\n+  unsigned idx, num_fns;\n+  size_t decl_state_size;\n+  int32_t num_decl_states;\n+\n+  ob = create_output_block (LTO_section_decls);\n+  ob->global = true;\n+\n+  /* Write out unreferenced globals, alias pairs and labels.  We defer\n+     doing this until now so that we can write out only what is\n+     needed.  */\n+  output_unreferenced_globals (set);\n+\n+  memset (&header, 0, sizeof (struct lto_decl_header)); \n+\n+  section_name = lto_get_section_name (LTO_section_decls, NULL);\n+  lto_begin_section (section_name, !flag_wpa);\n+  free (section_name);\n+\n+  /* Make string 0 be a NULL string.  */\n+  lto_output_1_stream (ob->string_stream, 0);\n+\n+  /* Write the global symbols.  */\n+  out_state = lto_get_out_decl_state ();\n+  num_fns = VEC_length (lto_out_decl_state_ptr, lto_function_decl_states);\n+  lto_output_decl_state_streams (ob, out_state);\n+  for (idx = 0; idx < num_fns; idx++)\n+    {\n+      fn_out_state =\n+\tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n+      lto_output_decl_state_streams (ob, fn_out_state);\n+    }\n+\n+  header.lto_header.major_version = LTO_major_version;\n+  header.lto_header.minor_version = LTO_minor_version;\n+  header.lto_header.section_type = LTO_section_decls;\n+\n+  /* Currently not used.  This field would allow us to preallocate\n+     the globals vector, so that it need not be resized as it is extended.  */\n+  header.num_nodes = -1;\n+\n+  /* Compute the total size of all decl out states. */\n+  decl_state_size = sizeof (int32_t);\n+  decl_state_size += lto_out_decl_state_written_size (out_state);\n+  for (idx = 0; idx < num_fns; idx++)\n+    {\n+      fn_out_state =\n+\tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n+      decl_state_size += lto_out_decl_state_written_size (fn_out_state);\n+    }\n+  header.decl_state_size = decl_state_size;\n+\n+  header.main_size = ob->main_stream->total_size;\n+  header.string_size = ob->string_stream->total_size;\n+\n+  header_stream = XCNEW (struct lto_output_stream);\n+  lto_output_data_stream (header_stream, &header, sizeof header);\n+  lto_write_stream (header_stream);\n+  free (header_stream);\n+ \n+  /* Write the main out-decl state, followed by out-decl states of\n+     functions. */\n+  decl_state_stream = ((struct lto_output_stream *)\n+\t\t       xcalloc (1, sizeof (struct lto_output_stream)));\n+  num_decl_states = num_fns + 1;\n+  lto_output_data_stream (decl_state_stream, &num_decl_states,\n+\t\t\t  sizeof (num_decl_states));\n+  lto_output_decl_state_refs (ob, decl_state_stream, out_state);\n+  for (idx = 0; idx < num_fns; idx++)\n+    {\n+      fn_out_state =\n+\tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n+      lto_output_decl_state_refs (ob, decl_state_stream, fn_out_state);\n+    }\n+  lto_write_stream (decl_state_stream);\n+  free(decl_state_stream); \n+\n+  lto_write_stream (ob->main_stream);\n+  lto_write_stream (ob->string_stream);\n+\n+  lto_end_section ();\n+\n+  /* Write the symbol table. */\n+  produce_symtab (ob->writer_cache);\n+\n+  /* Write command line opts.  */\n+  lto_write_options ();\n+\n+  /* Deallocate memory and clean up.  */\n+  lto_cgraph_encoder_delete (ob->decl_state->cgraph_node_encoder);\n+  VEC_free (lto_out_decl_state_ptr, heap, lto_function_decl_states);\n+  lto_function_decl_states = NULL;\n+  destroy_output_block (ob);\n+}\n+\n+\n+struct ipa_opt_pass_d pass_ipa_lto_finish_out =\n+{\n+ {\n+  IPA_PASS,\n+  \"lto_decls_out\",\t                /* name */\n+  gate_lto_out,\t\t\t        /* gate */\n+  NULL,        \t                        /* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_LTO_DECL_IO,\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,            \t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ },\n+ NULL,\t\t                        /* generate_summary */\n+ produce_asm_for_decls,\t\t\t/* write_summary */\n+ NULL,\t\t         \t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n+};"}, {"sha": "36172c03131f393c397dd3f86319f358745c01d4", "filename": "gcc/lto-streamer.c", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,860 @@\n+/* Miscellaneous utilities for GIMPLE streaming.  Things that are used\n+   in both input and output are here.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Doug Kwan <dougkwan@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-flow.h\"\n+#include \"diagnostic.h\"\n+#include \"bitmap.h\"\n+#include \"vec.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Statistics gathered during LTO, WPA and LTRANS.  */\n+struct lto_stats_d lto_stats;\n+\n+/* LTO uses bitmaps with different life-times.  So use a seperate\n+   obstack for all LTO bitmaps.  */\n+static bitmap_obstack lto_obstack;\n+static bool lto_obstack_initialized;\n+\n+\n+/* Return a string representing LTO tag TAG.  */\n+\n+const char *\n+lto_tag_name (enum LTO_tags tag)\n+{\n+  if (lto_tag_is_tree_code_p (tag))\n+    {\n+      /* For tags representing tree nodes, return the name of the\n+\t associated tree code.  */\n+      return tree_code_name[lto_tag_to_tree_code (tag)];\n+    }\n+\n+  if (lto_tag_is_gimple_code_p (tag))\n+    {\n+      /* For tags representing gimple statements, return the name of\n+\t the associated gimple code.  */\n+      return gimple_code_name[lto_tag_to_gimple_code (tag)];\n+    }\n+\n+  switch (tag)\n+    {\n+    case LTO_null:\n+      return \"LTO_null\";\n+    case LTO_bb0:\n+      return \"LTO_bb0\";\n+    case LTO_bb1:\n+      return \"LTO_bb1\";\n+    case LTO_eh_region:\n+      return \"LTO_eh_region\";\n+    case LTO_function:\n+      return \"LTO_function\";\n+    case LTO_eh_table:\n+      return \"LTO_eh_table\";\n+    case LTO_ert_cleanup:\n+      return \"LTO_ert_cleanup\";\n+    case LTO_ert_try:\n+      return \"LTO_ert_try\";\n+    case LTO_ert_allowed_exceptions:\n+      return \"LTO_ert_allowed_exceptions\";\n+    case LTO_ert_must_not_throw:\n+      return \"LTO_ert_must_not_throw\";\n+    case LTO_tree_pickle_reference:\n+      return \"LTO_tree_pickle_reference\";\n+    case LTO_field_decl_ref:\n+      return \"LTO_field_decl_ref\";\n+    case LTO_function_decl_ref:\n+      return \"LTO_function_decl_ref\";\n+    case LTO_label_decl_ref:\n+      return \"LTO_label_decl_ref\";\n+    case LTO_namespace_decl_ref:\n+      return \"LTO_namespace_decl_ref\";\n+    case LTO_result_decl_ref:\n+      return \"LTO_result_decl_ref\";\n+    case LTO_ssa_name_ref:\n+      return \"LTO_ssa_name_ref\";\n+    case LTO_type_decl_ref:\n+      return \"LTO_type_decl_ref\";\n+    case LTO_type_ref:\n+      return \"LTO_type_ref\";\n+    case LTO_global_decl_ref:\n+      return \"LTO_global_decl_ref\";\n+    default:\n+      return \"LTO_UNKNOWN\";\n+    }\n+}\n+\n+\n+/* Allocate a bitmap from heap.  Initializes the LTO obstack if necessary.  */\n+\n+bitmap\n+lto_bitmap_alloc (void)\n+{\n+  if (!lto_obstack_initialized)\n+    {\n+      bitmap_obstack_initialize (&lto_obstack);\n+      lto_obstack_initialized = true;\n+    }\n+  return BITMAP_ALLOC (&lto_obstack);\n+}\n+\n+/* Free bitmap B.  */\n+\n+void\n+lto_bitmap_free (bitmap b)\n+{\n+  BITMAP_FREE (b);\n+}\n+\n+\n+/* Get a section name for a particular type or name.  The NAME field\n+   is only used if SECTION_TYPE is LTO_section_function_body or\n+   LTO_static_initializer.  For all others it is ignored.  The callee\n+   of this function is responcible to free the returned name.  */\n+\n+char *\n+lto_get_section_name (int section_type, const char *name)\n+{\n+  switch (section_type)\n+    {\n+    case LTO_section_function_body:\n+      return concat (LTO_SECTION_NAME_PREFIX, name, NULL);\n+\n+    case LTO_section_static_initializer:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".statics\", NULL);\n+\n+    case LTO_section_symtab:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".symtab\", NULL);\n+\n+    case LTO_section_decls:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".decls\", NULL);\n+\n+    case LTO_section_cgraph:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".cgraph\", NULL);\n+\n+    case LTO_section_ipa_pure_const:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".pureconst\", NULL);\n+\n+    case LTO_section_ipa_reference:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".reference\", NULL);\n+\n+    case LTO_section_wpa_fixup:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".wpa_fixup\", NULL);\n+\n+    case LTO_section_opts:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".opts\", NULL);\n+\n+    default:\n+      internal_error (\"bytecode stream: unexpected LTO section %s\", name);\n+    }\n+}\n+\n+\n+/* Show various memory usage statistics related to LTO.  */\n+\n+void\n+print_lto_report (void)\n+{\n+  const char *s = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n+  unsigned i;\n+\n+  fprintf (stderr, \"%s statistics\\n\", s);\n+  fprintf (stderr, \"[%s] # of input files: \"\n+\t   HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s, lto_stats.num_input_files);\n+\n+  fprintf (stderr, \"[%s] # of input cgraph nodes: \" \n+\t   HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t   lto_stats.num_input_cgraph_nodes);\n+\n+  fprintf (stderr, \"[%s] # of function bodies: \"\n+\t   HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t   lto_stats.num_function_bodies);\n+\n+  fprintf (stderr, \"[%s] \", s);\n+  print_gimple_types_stats ();\n+\n+  for (i = 0; i < NUM_TREE_CODES; i++)\n+    if (lto_stats.num_trees[i])\n+      fprintf (stderr, \"[%s] # of '%s' objects read: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       tree_code_name[i], lto_stats.num_trees[i]);\n+\n+  if (flag_lto)\n+    {\n+      fprintf (stderr, \"[%s] Compression: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \" output bytes, \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \" compressed bytes\", s,\n+\t       lto_stats.num_output_il_bytes,\n+\t       lto_stats.num_compressed_il_bytes);\n+      if (lto_stats.num_output_il_bytes > 0)\n+\t{\n+\t  const float dividend = (float) lto_stats.num_compressed_il_bytes;\n+\t  const float divisor = (float) lto_stats.num_output_il_bytes;\n+\t  fprintf (stderr, \" (ratio: %f)\", dividend / divisor);\n+\t}\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  if (flag_wpa)\n+    {\n+      fprintf (stderr, \"[%s] # of output files: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       lto_stats.num_output_files);\n+\n+      fprintf (stderr, \"[%s] # of output cgraph nodes: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       lto_stats.num_output_cgraph_nodes);\n+\n+      fprintf (stderr, \"[%s] # callgraph partitions: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", s,\n+\t       lto_stats.num_cgraph_partitions);\n+\n+      fprintf (stderr, \"[%s] Compression: \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \" input bytes, \"\n+\t       HOST_WIDE_INT_PRINT_UNSIGNED \" uncompressed bytes\", s,\n+\t       lto_stats.num_input_il_bytes,\n+\t       lto_stats.num_uncompressed_il_bytes);\n+      if (lto_stats.num_input_il_bytes > 0)\n+\t{\n+\t  const float dividend = (float) lto_stats.num_uncompressed_il_bytes;\n+\t  const float divisor = (float) lto_stats.num_input_il_bytes;\n+\t  fprintf (stderr, \" (ratio: %f)\", dividend / divisor);\n+\t}\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  for (i = 0; i < LTO_N_SECTION_TYPES; i++)\n+    fprintf (stderr, \"[%s] Size of mmap'd section %s: \"\n+\t     HOST_WIDE_INT_PRINT_UNSIGNED \" bytes\\n\", s,\n+\t     lto_section_name[i], lto_stats.section_size[i]);\n+}\n+\n+\n+/* Create a new bitpack.  */\n+\n+struct bitpack_d *\n+bitpack_create (void)\n+{\n+  return XCNEW (struct bitpack_d);\n+}\n+\n+\n+/* Free the memory used by bitpack BP.  */\n+\n+void\n+bitpack_delete (struct bitpack_d *bp)\n+{\n+  VEC_free (bitpack_word_t, heap, bp->values);\n+  free (bp);\n+}\n+\n+\n+/* Return an index to the word in bitpack BP that contains the\n+   next NBITS.  */\n+\n+static inline unsigned\n+bp_get_next_word (struct bitpack_d *bp, unsigned nbits)\n+{\n+  unsigned last, ix;\n+\n+  /* In principle, the next word to use is determined by the\n+     number of bits already processed in BP.  */\n+  ix = bp->num_bits / BITS_PER_BITPACK_WORD;\n+\n+  /* All the encoded bit patterns in BP are contiguous, therefore if\n+     the next NBITS would straddle over two different words, move the\n+     index to the next word and update the number of encoded bits\n+     by adding up the hole of unused bits created by this move.  */\n+  bp->first_unused_bit %= BITS_PER_BITPACK_WORD;\n+  last = bp->first_unused_bit + nbits - 1;\n+  if (last >= BITS_PER_BITPACK_WORD)\n+    {\n+      ix++;\n+      bp->num_bits += (BITS_PER_BITPACK_WORD - bp->first_unused_bit);\n+      bp->first_unused_bit = 0;\n+    }\n+\n+  return ix;\n+}\n+\n+\n+/* Pack NBITS of value VAL into bitpack BP.  */\n+\n+void\n+bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n+{\n+  unsigned ix;\n+  bitpack_word_t word;\n+\n+  /* We cannot encode more bits than BITS_PER_BITPACK_WORD.  */\n+  gcc_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n+\n+  /* Compute which word will contain the next NBITS.  */\n+  ix = bp_get_next_word (bp, nbits);\n+  if (ix >= VEC_length (bitpack_word_t, bp->values))\n+    {\n+      /* If there is no room left in the last word of the values\n+\t array, add a new word.  Additionally, we should only\n+\t need to add a single word, since every pack operation cannot\n+\t use more bits than fit in a single word.  */\n+      gcc_assert (ix < VEC_length (bitpack_word_t, bp->values) + 1);\n+      VEC_safe_push (bitpack_word_t, heap, bp->values, 0);\n+    }\n+\n+  /* Grab the last word to pack VAL into.  */\n+  word = VEC_index (bitpack_word_t, bp->values, ix);\n+\n+  /* To fit VAL in WORD, we need to shift VAL to the left to\n+     skip the bottom BP->FIRST_UNUSED_BIT bits.  */\n+  gcc_assert (BITS_PER_BITPACK_WORD >= bp->first_unused_bit + nbits);\n+  val <<= bp->first_unused_bit;\n+\n+  /* Update WORD with VAL.  */\n+  word |= val;\n+\n+  /* Update BP.  */\n+  VEC_replace (bitpack_word_t, bp->values, ix, word);\n+  bp->num_bits += nbits;\n+  bp->first_unused_bit += nbits;\n+}\n+\n+\n+/* Unpack the next NBITS from bitpack BP.  */\n+\n+bitpack_word_t\n+bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n+{\n+  bitpack_word_t val, word, mask;\n+  unsigned ix;\n+\n+  /* We cannot decode more bits than BITS_PER_BITPACK_WORD.  */\n+  gcc_assert (nbits > 0 && nbits <= BITS_PER_BITPACK_WORD);\n+\n+  /* Compute which word contains the next NBITS.  */\n+  ix = bp_get_next_word (bp, nbits);\n+  word = VEC_index (bitpack_word_t, bp->values, ix);\n+\n+  /* Compute the mask to get NBITS from WORD.  */\n+  mask = (nbits == BITS_PER_BITPACK_WORD)\n+\t ? (bitpack_word_t) -1\n+\t : ((bitpack_word_t) 1 << nbits) - 1;\n+\n+  /* Shift WORD to the right to skip over the bits already decoded\n+     in word.  */\n+  word >>= bp->first_unused_bit;\n+\n+  /* Apply the mask to obtain the requested value.  */\n+  val = word & mask;\n+\n+  /* Update BP->NUM_BITS for the next unpack operation.  */\n+  bp->num_bits += nbits;\n+  bp->first_unused_bit += nbits;\n+\n+  return val;\n+}\n+\n+\n+/* Check that all the TS_* structures handled by the lto_output_* and\n+   lto_input_* routines are exactly ALL the structures defined in\n+   treestruct.def.  */\n+\n+static void\n+check_handled_ts_structures (void)\n+{\n+  bool handled_p[LAST_TS_ENUM];\n+  unsigned i;\n+\n+  memset (&handled_p, 0, sizeof (handled_p));\n+\n+  /* These are the TS_* structures that are either handled or\n+     explicitly ignored by the streamer routines.  */\n+  handled_p[TS_BASE] = true;\n+  handled_p[TS_COMMON] = true;\n+  handled_p[TS_INT_CST] = true;\n+  handled_p[TS_REAL_CST] = true;\n+  handled_p[TS_FIXED_CST] = true;\n+  handled_p[TS_VECTOR] = true;\n+  handled_p[TS_STRING] = true;\n+  handled_p[TS_COMPLEX] = true;\n+  handled_p[TS_IDENTIFIER] = true;\n+  handled_p[TS_DECL_MINIMAL] = true;\n+  handled_p[TS_DECL_COMMON] = true;\n+  handled_p[TS_DECL_WRTL] = true;\n+  handled_p[TS_DECL_NON_COMMON] = true;\n+  handled_p[TS_DECL_WITH_VIS] = true;\n+  handled_p[TS_FIELD_DECL] = true;\n+  handled_p[TS_VAR_DECL] = true;\n+  handled_p[TS_PARM_DECL] = true;\n+  handled_p[TS_LABEL_DECL] = true;\n+  handled_p[TS_RESULT_DECL] = true;\n+  handled_p[TS_CONST_DECL] = true;\n+  handled_p[TS_TYPE_DECL] = true;\n+  handled_p[TS_FUNCTION_DECL] = true;\n+  handled_p[TS_TYPE] = true;\n+  handled_p[TS_LIST] = true;\n+  handled_p[TS_VEC] = true;\n+  handled_p[TS_EXP] = true;\n+  handled_p[TS_SSA_NAME] = true;\n+  handled_p[TS_BLOCK] = true;\n+  handled_p[TS_BINFO] = true;\n+  handled_p[TS_STATEMENT_LIST] = true;\n+  handled_p[TS_CONSTRUCTOR] = true;\n+  handled_p[TS_OMP_CLAUSE] = true;\n+  handled_p[TS_OPTIMIZATION] = true;\n+  handled_p[TS_TARGET_OPTION] = true;\n+\n+  /* Anything not marked above will trigger the following assertion.\n+     If this assertion triggers, it means that there is a new TS_*\n+     structure that should be handled by the streamer.  */\n+  for (i = 0; i < LAST_TS_ENUM; i++)\n+    gcc_assert (handled_p[i]);\n+}\n+\n+\n+/* Helper for lto_streamer_cache_insert_1.  Add T to CACHE->NODES at\n+   slot IX.  Add OFFSET to CACHE->OFFSETS at slot IX.  */\n+\n+static void\n+lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n+\t\t\t\t      int ix, tree t, unsigned offset)\n+{\n+  gcc_assert (ix >= 0);\n+\n+  /* Grow the array of nodes and offsets to accomodate T at IX.  */\n+  if (ix >= (int) VEC_length (tree, cache->nodes))\n+    {\n+      size_t sz = ix + (20 + ix) / 4;\n+      VEC_safe_grow_cleared (tree, gc, cache->nodes, sz);\n+      VEC_safe_grow_cleared (unsigned, heap, cache->offsets, sz);\n+    }\n+\n+  VEC_replace (tree, cache->nodes, ix, t);\n+  VEC_replace (unsigned, cache->offsets, ix, offset);\n+}\n+\n+\n+/* Helper for lto_streamer_cache_insert and lto_streamer_cache_insert_at.\n+   CACHE, T, IX_P and OFFSET_P are as in lto_streamer_cache_insert.\n+\n+   If INSERT_AT_NEXT_SLOT_P is true, T is inserted at the next available\n+   slot in the cache.  Otherwise, T is inserted at the position indicated\n+   in *IX_P.\n+\n+   If T already existed in CACHE, return true.  Otherwise,\n+   return false.  */\n+\n+static bool\n+lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n+\t\t\t     tree t, int *ix_p, unsigned *offset_p,\n+\t\t\t     bool insert_at_next_slot_p)\n+{\n+  void **slot;\n+  struct tree_int_map d_entry, *entry;\n+  int ix;\n+  unsigned offset;\n+  bool existed_p;\n+\n+  gcc_assert (t);\n+\n+  d_entry.base.from = t;\n+  slot = htab_find_slot (cache->node_map, &d_entry, INSERT);\n+  if (*slot == NULL)\n+    {\n+      /* Determine the next slot to use in the cache.  */\n+      if (insert_at_next_slot_p)\n+\tix = cache->next_slot++;\n+      else\n+\tix = *ix_p;\n+\n+      entry = XCNEW (struct tree_int_map);\n+      entry->base.from = t;\n+      entry->to = (unsigned) ix;\n+      *slot = entry;\n+\n+      /* If no offset was given, store the invalid offset -1.  */\n+      offset = (offset_p) ? *offset_p : (unsigned) -1;\n+\n+      lto_streamer_cache_add_to_node_array (cache, ix, t, offset);\n+\n+      /* Indicate that the item was not present in the cache.  */\n+      existed_p = false;\n+    }\n+  else\n+    {\n+      entry = (struct tree_int_map *) *slot;\n+      ix = (int) entry->to;\n+      offset = VEC_index (unsigned, cache->offsets, ix);\n+\n+      if (!insert_at_next_slot_p && ix != *ix_p)\n+\t{\n+\t  /* If the caller wants to insert T at a specific slot\n+\t     location, and ENTRY->TO does not match *IX_P, add T to\n+\t     the requested location slot.  This situation arises when\n+\t     streaming builtin functions.\n+\n+\t     For instance, on the writer side we could have two\n+\t     FUNCTION_DECLS T1 and T2 that are represented by the same\n+\t     builtin function.  The reader will only instantiate the\n+\t     canonical builtin, but since T1 and T2 had been\n+\t     originally stored in different cache slots (S1 and S2),\n+\t     the reader must be able to find the canonical builtin\n+\t     function at slots S1 and S2.  */\n+\t  gcc_assert (lto_stream_as_builtin_p (t));\n+\t  ix = *ix_p;\n+\n+\t  /* Since we are storing a builtin, the offset into the\n+\t     stream is not necessary as we will not need to read\n+\t     forward in the stream.  */\n+\t  lto_streamer_cache_add_to_node_array (cache, ix, t, -1);\n+\t}\n+\n+      /* Indicate that T was already in the cache.  */\n+      existed_p = true;\n+    }\n+\n+  if (ix_p)\n+    *ix_p = ix;\n+\n+  if (offset_p)\n+    *offset_p = offset; \n+\n+  return existed_p;\n+}\n+\n+\n+/* Insert tree node T in CACHE.  If T already existed in the cache\n+   return true.  Otherwise, return false.\n+\n+   If IX_P is non-null, update it with the index into the cache where\n+   T has been stored.\n+\n+   *OFFSET_P represents the offset in the stream where T is physically\n+   written out.  The first time T is added to the cache, *OFFSET_P is\n+   recorded in the cache together with T.  But if T already existed\n+   in the cache, *OFFSET_P is updated with the value that was recorded\n+   the first time T was added to the cache.\n+\n+   If OFFSET_P is NULL, it is ignored.  */\n+\n+bool\n+lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n+\t\t\t   int *ix_p, unsigned *offset_p)\n+{\n+  return lto_streamer_cache_insert_1 (cache, t, ix_p, offset_p, true);\n+}\n+\n+\n+/* Insert tree node T in CACHE at slot IX.  If T already\n+   existed in the cache return true.  Otherwise, return false.  */\n+\n+bool\n+lto_streamer_cache_insert_at (struct lto_streamer_cache_d *cache,\n+\t\t\t      tree t, int ix)\n+{\n+  return lto_streamer_cache_insert_1 (cache, t, &ix, NULL, false);\n+}\n+\n+\n+/* Return true if tree node T exists in CACHE.  If IX_P is\n+   not NULL, write to *IX_P the index into the cache where T is stored\n+   (-1 if T is not found).  */\n+\n+bool\n+lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n+\t\t\t   int *ix_p)\n+{\n+  void **slot;\n+  struct tree_int_map d_slot;\n+  bool retval;\n+  int ix;\n+\n+  gcc_assert (t);\n+\n+  d_slot.base.from = t;\n+  slot = htab_find_slot (cache->node_map, &d_slot, NO_INSERT);\n+  if (slot == NULL)\n+    {\n+      retval = false;\n+      ix = -1;\n+    }\n+  else\n+    {\n+      retval = true;\n+      ix = (int) ((struct tree_int_map *) *slot)->to;\n+    }\n+\n+  if (ix_p)\n+    *ix_p = ix;\n+\n+  return retval;\n+}\n+\n+\n+/* Return the tree node at slot IX in CACHE.  */\n+\n+tree\n+lto_streamer_cache_get (struct lto_streamer_cache_d *cache, int ix)\n+{\n+  gcc_assert (cache);\n+\n+  /* If the reader is requesting an index beyond the length of the\n+     cache, it will need to read ahead.  Return NULL_TREE to indicate\n+     that.  */\n+  if ((unsigned) ix >= VEC_length (tree, cache->nodes))\n+    return NULL_TREE;\n+\n+  return VEC_index (tree, cache->nodes, (unsigned) ix);\n+}\n+\n+\n+/* Record NODE in COMMON_NODES if it is not NULL and is not already in\n+   SEEN_NODES.  */\n+\n+static void\n+lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n+\t\t\tstruct pointer_set_t *seen_nodes)\n+{\n+  tree node = *nodep;\n+\n+  if (node == NULL_TREE)\n+    return;\n+\n+  if (TYPE_P (node))\n+    *nodep = node = gimple_register_type (node);\n+\n+  /* Return if node is already seen.  */\n+  if (pointer_set_insert (seen_nodes, node))\n+    return;\n+\n+  VEC_safe_push (tree, heap, *common_nodes, node);\n+\n+  if (tree_node_can_be_shared (node))\n+    {\n+      if (POINTER_TYPE_P (node)\n+\t  || TREE_CODE (node) == COMPLEX_TYPE\n+\t  || TREE_CODE (node) == ARRAY_TYPE)\n+\tlto_record_common_node (&TREE_TYPE (node), common_nodes, seen_nodes);\n+    }\n+}\n+\n+\n+/* Generate a vector of common nodes and make sure they are merged\n+   properly according to the the gimple type table.  */\n+\n+static VEC(tree,heap) *\n+lto_get_common_nodes (void)\n+{\n+  unsigned i;\n+  VEC(tree,heap) *common_nodes = NULL;\n+  struct pointer_set_t *seen_nodes;\n+\n+  /* The MAIN_IDENTIFIER_NODE is normally set up by the front-end, but the\n+     LTO back-end must agree. Currently, the only languages that set this\n+     use the name \"main\".  */\n+  if (main_identifier_node)\n+    {\n+      const char *main_name = IDENTIFIER_POINTER (main_identifier_node);\n+      gcc_assert (strcmp (main_name, \"main\") == 0);\n+    }\n+  else\n+    main_identifier_node = get_identifier (\"main\");\n+\n+  gcc_assert (ptrdiff_type_node == integer_type_node);\n+\n+  /* FIXME lto.  In the C++ front-end, fileptr_type_node is defined as a\n+     variant copy of of ptr_type_node, rather than ptr_node itself.  The\n+     distinction should only be relevant to the front-end, so we always\n+     use the C definition here in lto1.\n+\n+     These should be assured in pass_ipa_free_lang_data.  */\n+  gcc_assert (fileptr_type_node == ptr_type_node);\n+  gcc_assert (TYPE_MAIN_VARIANT (fileptr_type_node) == ptr_type_node);\n+  \n+  seen_nodes = pointer_set_create ();\n+\n+  /* Skip itk_char.  char_type_node is shared with the appropriately\n+     signed variant.  */\n+  for (i = itk_signed_char; i < itk_none; i++)\n+    lto_record_common_node (&integer_types[i], &common_nodes, seen_nodes);\n+\n+  for (i = 0; i < TYPE_KIND_LAST; i++)\n+    lto_record_common_node (&sizetype_tab[i], &common_nodes, seen_nodes);\n+\n+  for (i = 0; i < TI_MAX; i++)\n+    lto_record_common_node (&global_trees[i], &common_nodes, seen_nodes);\n+\n+  pointer_set_destroy (seen_nodes);\n+\n+  return common_nodes;\n+}\n+\n+\n+/* Assign an index to tree node T and enter it in the streamer cache\n+   CACHE.  */\n+\n+static void\n+preload_common_node (struct lto_streamer_cache_d *cache, tree t)\n+{\n+  gcc_assert (t);\n+\n+  lto_streamer_cache_insert (cache, t, NULL, NULL);\n+\n+ /* The FIELD_DECLs of structures should be shared, so that every\n+    COMPONENT_REF uses the same tree node when referencing a field.\n+    Pointer equality between FIELD_DECLs is used by the alias\n+    machinery to compute overlapping memory references (See\n+    nonoverlapping_component_refs_p).  */\n+ if (TREE_CODE (t) == RECORD_TYPE)\n+   {\n+     tree f;\n+\n+     for (f = TYPE_FIELDS (t); f; f = TREE_CHAIN (f))\n+       preload_common_node (cache, f);\n+   }\n+}\n+\n+\n+/* Create a cache of pickled nodes.  */\n+\n+struct lto_streamer_cache_d *\n+lto_streamer_cache_create (void)\n+{\n+  struct lto_streamer_cache_d *cache;\n+  VEC(tree, heap) *common_nodes;\n+  unsigned i;\n+  tree node;\n+\n+  cache = XCNEW (struct lto_streamer_cache_d);\n+\n+  cache->node_map = htab_create (101, tree_int_map_hash, tree_int_map_eq, NULL);\n+\n+  /* Load all the well-known tree nodes that are always created by\n+     the compiler on startup.  This prevents writing them out\n+     unnecessarily.  */\n+  common_nodes = lto_get_common_nodes ();\n+\n+  for (i = 0; VEC_iterate (tree, common_nodes, i, node); i++)\n+    preload_common_node (cache, node);\n+\n+  VEC_free(tree, heap, common_nodes);\n+\n+  return cache;\n+}\n+\n+\n+/* Delete the streamer cache C.  */\n+\n+void\n+lto_streamer_cache_delete (struct lto_streamer_cache_d *c)\n+{\n+  if (c == NULL)\n+    return;\n+\n+  htab_delete (c->node_map);\n+  VEC_free (tree, gc, c->nodes);\n+  VEC_free (unsigned, heap, c->offsets);\n+  free (c);\n+}\n+\n+\n+/* Initialization common to the LTO reader and writer.  */\n+\n+void\n+lto_streamer_init (void)\n+{\n+  /* Check that all the TS_* handled by the reader and writer routines\n+     match exactly the structures defined in treestruct.def.  When a\n+     new TS_* astructure is added, the streamer should be updated to\n+     handle it.  */\n+  check_handled_ts_structures ();\n+}\n+\n+\n+/* Gate function for all LTO streaming passes.  */\n+\n+bool\n+gate_lto_out (void)\n+{\n+  return ((flag_generate_lto || in_lto_p)\n+\t  /* Don't bother doing anything if the program has errors.  */\n+\t  && !(errorcount || sorrycount));\n+}\n+\n+\n+#ifdef LTO_STREAMER_DEBUG\n+/* Add a mapping between T and ORIG_T, which is the numeric value of\n+   the original address of T as it was seen by the LTO writer.  This\n+   mapping is useful when debugging streaming problems.  A debugging\n+   session can be started on both reader and writer using ORIG_T\n+   as a breakpoint value in both sessions.\n+\n+   Note that this mapping is transient and only valid while T is \n+   being reconstructed.  Once T is fully built, the mapping is\n+   removed.  */\n+\n+void\n+lto_orig_address_map (tree t, intptr_t orig_t)\n+{\n+  /* FIXME lto.  Using the annotation field is quite hacky as it relies\n+     on the GC not running while T is being rematerialized.  It would\n+     be cleaner to use a hash table here.  */\n+  t->base.ann = (union tree_ann_d *) orig_t;\n+}\n+\n+\n+/* Get the original address of T as it was seen by the writer.  This\n+   is only valid while T is being reconstructed.  */\n+\n+intptr_t\n+lto_orig_address_get (tree t)\n+{\n+  return (intptr_t) t->base.ann;\n+}\n+\n+\n+/* Clear the mapping of T to its original address.  */\n+\n+void\n+lto_orig_address_remove (tree t)\n+{\n+  t->base.ann = NULL;\n+}\n+#endif\n+\n+\n+/* Check that the version MAJOR.MINOR is the correct version number.  */\n+\n+void\n+lto_check_version (int major, int minor)\n+{\n+  if (major != LTO_major_version || minor != LTO_minor_version)\n+    fatal_error (\"bytecode stream generated with LTO version %d.%d instead \"\n+\t         \"of the expected %d.%d\",\n+\t\t major, minor,\n+\t\t LTO_major_version, LTO_minor_version);\n+}"}, {"sha": "b156ff4245577068ce67b121cc5aaa171f700173", "filename": "gcc/lto-streamer.h", "status": "added", "additions": 1054, "deletions": 0, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,1054 @@\n+/* Data structures and declarations used for reading and writing\n+   GIMPLE to a file stream.\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Doug Kwan <dougkwan@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LTO_STREAMER_H\n+#define GCC_LTO_STREAMER_H\n+\n+#include \"plugin-api.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"vec.h\"\n+#include \"vecprim.h\"\n+\n+/* Define when debugging the LTO streamer.  This causes the writer\n+   to output the numeric value for the memory address of the tree node\n+   being emitted.  When debugging a problem in the reader, check the\n+   original address that the writer was emitting using lto_orig_address_get.\n+   With this value, set a breakpoint in the writer (e.g., lto_output_tree)\n+   to trace how the faulty node is being emitted.  */\n+/* #define LTO_STREAMER_DEBUG\t1  */\n+\n+/* The encoding for a function consists of the following sections:\n+\n+   1)    The header.\n+   2)    FIELD_DECLS.\n+   3)    FUNCTION_DECLS.\n+   4)    global VAR_DECLS.\n+   5)    type_decls\n+   6)    types.\n+   7)    Names for the labels that have names\n+   8)    The SSA names.\n+   9)    The control flow graph.\n+   10-11)Gimple for local decls.\n+   12)   Gimple for the function.\n+   13)   Strings.\n+\n+   1) THE HEADER.\n+   2-6) THE GLOBAL DECLS AND TYPES.\n+\n+      The global decls and types are encoded in the same way.  For each\n+      entry, there is word with the offset within the section to the\n+      entry.\n+\n+   7) THE LABEL NAMES.  \n+\n+      Since most labels do not have names, this section my be of zero\n+      length.  It consists of an array of string table references, one\n+      per label.  In the lto code, the labels are given either\n+      positive or negative indexes.  the positive ones have names and\n+      the negative ones do not.  The positive index can be used to\n+      find the name in this array.\n+\n+   9) THE CFG. \n+\n+   10) Index into the local decls.  Since local decls can have local\n+      decls inside them, they must be read in randomly in order to\n+      properly restore them.  \n+\n+   11-12) GIMPLE FOR THE LOCAL DECLS AND THE FUNCTION BODY.\n+\n+     The gimple consists of a set of records.\n+\n+     THE FUNCTION\n+\t\n+     At the top level of (8) is the function. It consists of five\n+     pieces:\n+\n+     LTO_function     - The tag.\n+     eh tree          - This is all of the exception handling regions\n+                        put out in a post order traversial of the\n+                        tree.  Siblings are output as lists terminated\n+\t\t\tby a 0.  The set of fields matches the fields\n+\t\t\tdefined in except.c.\n+\n+     last_basic_block - in uleb128 form.\n+\n+     basic blocks     - This is the set of basic blocks.\n+\n+     zero             - The termination of the basic blocks.\n+\n+     BASIC BLOCKS\n+\n+     There are two forms of basic blocks depending on if they are\n+     empty or not.\n+\n+     The basic block consists of:\n+\n+     LTO_bb1 or LTO_bb0 - The tag.\n+\n+     bb->index          - the index in uleb128 form.\n+\n+     #succs             - The number of successors un uleb128 form.\n+\n+     the successors     - For each edge, a pair.  The first of the\n+                          pair is the index of the successor in\n+                          uleb128 form and the second are the flags in\n+                          uleb128 form.\n+\n+     the statements     - A gimple tree, as described above.\n+                          These are only present for LTO_BB1.\n+                          Following each statement is an optional\n+                          exception handling record LTO_eh_region\n+\t\t\t  which contains the region number (for\n+\t\t\t  regions >= 0).\n+\n+     zero               - This is only present for LTO_BB1 and is used\n+\t\t\t  to terminate the statements and exception\n+\t\t\t  regions within this block.\n+\n+   12) STRINGS\n+\n+     String are represented in the table as pairs, a length in ULEB128\n+     form followed by the data for the string.  */\n+\n+/* The string that is the prefix on the section names we make for lto.\n+   For decls the DECL_ASSEMBLER_NAME is appended to make the section\n+   name for the functions and static_initializers.  For other types of\n+   sections a '.' and the section type are appended.  */\n+#define LTO_SECTION_NAME_PREFIX         \".gnu.lto_\"\n+\n+#define LTO_major_version 1\n+#define LTO_minor_version 0\n+\n+typedef unsigned char\tlto_decl_flags_t;\n+\n+\n+/* Data structures used to pack values and bitflags into a vector of\n+   words.  Used to stream values of a fixed number of bits in a space\n+   efficient way.  */\n+static unsigned const BITS_PER_BITPACK_WORD = HOST_BITS_PER_WIDE_INT;\n+\n+typedef unsigned HOST_WIDE_INT bitpack_word_t;\n+DEF_VEC_I(bitpack_word_t);\n+DEF_VEC_ALLOC_I(bitpack_word_t, heap);\n+\n+struct bitpack_d\n+{\n+  /* Total number of bits packed/unpacked so far.  */\n+  size_t num_bits;\n+\n+  /* Values are stored contiguously, so there may be internal\n+     fragmentation (words with unused bits).  Therefore, we need to\n+     keep track of the first available bit in the last word of the\n+     bitpack.  */\n+  size_t first_unused_bit;\n+\n+  /* Vector of words holding the packed values.  */\n+  VEC(bitpack_word_t, heap) *values;\n+};\n+\n+/* Tags representing the various IL objects written to the bytecode file\n+   (GIMPLE statements, basic blocks, EH regions, tree nodes, etc).\n+\n+   NOTE, when adding new LTO tags, also update lto_tag_name.  */\n+enum LTO_tags \n+{\n+  LTO_null = 0,\n+\n+  /* Reserve enough entries to fit all the tree and gimple codes handled\n+     by the streamer.  This guarantees that:\n+\n+     1- Given a tree code C:\n+     \t\tenum LTO_tags tag == C + 1\n+\n+     2- Given a gimple code C:\n+\t\tenum LTO_tags tag == C + NUM_TREE_CODES + 1\n+\n+     Conversely, to map between LTO tags and tree/gimple codes, the\n+     reverse operation must be applied.  */\n+  LTO_bb0 = 1 + NUM_TREE_CODES + LAST_AND_UNUSED_GIMPLE_CODE,\n+  LTO_bb1,\n+\n+  /* EH region holding the previous statement.  */\n+  LTO_eh_region,\n+\n+  /* An MD or NORMAL builtin.  Only the code and class are streamed out.  */\n+  LTO_builtin_decl,\n+\n+  /* Function body.  */\n+  LTO_function,\n+\n+  /* EH table.  */\n+  LTO_eh_table,\n+\n+  /* EH region types.  These mirror enum eh_region_type.  */\n+  LTO_ert_cleanup,\n+  LTO_ert_try,\n+  LTO_ert_allowed_exceptions,\n+  LTO_ert_must_not_throw,\n+\n+  /* EH landing pad.  */\n+  LTO_eh_landing_pad,\n+\n+  /* EH try/catch node.  */\n+  LTO_eh_catch,\n+\n+  /* Special for global streamer. Reference to previously-streamed node.  */\n+  LTO_tree_pickle_reference,\n+\n+  /* References to indexable tree nodes.  These objects are stored in\n+     tables that are written separately from the function bodies that\n+     reference them.  This way they can be instantiated even when the\n+     referencing functions aren't (e.g., during WPA) and it also allows\n+     functions to be copied from one file to another without having\n+     to unpickle the body first (the references are location\n+     independent).\n+\n+     NOTE, do not regroup these values as the grouping is exposed\n+     in the range checks done in lto_input_tree.  */\n+  LTO_field_decl_ref,\t\t\t/* Do not change.  */\n+  LTO_function_decl_ref,\n+  LTO_label_decl_ref,\n+  LTO_namespace_decl_ref,\n+  LTO_result_decl_ref,\n+  LTO_ssa_name_ref,\n+  LTO_type_decl_ref,\n+  LTO_type_ref,\n+  LTO_const_decl_ref,\n+  LTO_imported_decl_ref,\n+  LTO_global_decl_ref,\t\t\t/* Do not change.  */\n+\n+  /* This tag must always be last.  */\n+  LTO_NUM_TAGS\n+};\n+\n+\n+/* Set of section types that are in an LTO file.  This list will grow\n+   as the number of IPA passes grows since each IPA pass will need its\n+   own section type to store its summary information.\n+\n+   When adding a new section type, you must also extend the\n+   LTO_SECTION_NAME array in lto-section-in.c.  */\n+enum lto_section_type\n+{\n+  LTO_section_decls = 0,\n+  LTO_section_function_body,\n+  LTO_section_static_initializer,\n+  LTO_section_cgraph,\n+  LTO_section_ipa_pure_const,\n+  LTO_section_ipa_reference,\n+  LTO_section_symtab,\n+  LTO_section_wpa_fixup,\n+  LTO_section_opts,\n+  LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n+};\n+\n+/* Indices to the various function, type and symbol streams. */\n+typedef enum\n+{\n+  LTO_DECL_STREAM_TYPE = 0,\t\t/* Must be first. */\n+  LTO_DECL_STREAM_FIELD_DECL,\n+  LTO_DECL_STREAM_FN_DECL,\n+  LTO_DECL_STREAM_VAR_DECL,\n+  LTO_DECL_STREAM_TYPE_DECL,\n+  LTO_DECL_STREAM_NAMESPACE_DECL,\n+  LTO_DECL_STREAM_LABEL_DECL,\n+  LTO_N_DECL_STREAMS\n+} lto_decl_stream_e_t;\n+\n+typedef enum ld_plugin_symbol_resolution ld_plugin_symbol_resolution_t;\n+DEF_VEC_I(ld_plugin_symbol_resolution_t);\n+DEF_VEC_ALLOC_I(ld_plugin_symbol_resolution_t, heap);\n+\n+\n+/* Macro to define convenience functions for type and decl streams\n+   in lto_file_decl_data.  */ \n+#define DEFINE_DECL_STREAM_FUNCS(UPPER_NAME, name) \\\n+static inline tree \\\n+lto_file_decl_data_get_ ## name (struct lto_file_decl_data *data, \\\n+\t\t\t\t unsigned int idx) \\\n+{ \\\n+  struct lto_in_decl_state *state = data->current_decl_state; \\\n+  gcc_assert (idx < state->streams[LTO_DECL_STREAM_## UPPER_NAME].size); \\\n+  return state->streams[LTO_DECL_STREAM_## UPPER_NAME].trees[idx]; \\\n+} \\\n+\\\n+static inline unsigned int \\\n+lto_file_decl_data_num_ ## name ## s (struct lto_file_decl_data *data) \\\n+{ \\\n+  struct lto_in_decl_state *state = data->current_decl_state; \\\n+  return state->streams[LTO_DECL_STREAM_## UPPER_NAME].size; \\\n+}\n+\n+\n+/* Return a char pointer to the start of a data stream for an lto pass\n+   or function.  The first parameter is the file data that contains\n+   the information.  The second parameter is the type of information\n+   to be obtained.  The third parameter is the name of the function\n+   and is only used when finding a function body; otherwise it is \n+   NULL.  The fourth parameter is the length of the data returned.  */\n+typedef const char* (lto_get_section_data_f) (struct lto_file_decl_data *, \n+\t\t\t\t\t      enum lto_section_type,\n+\t\t\t\t\t      const char *, \n+\t\t\t\t\t      size_t *);\n+\n+/* Return the data found from the above call.  The first three\n+   parameters are the same as above.  The fourth parameter is the data\n+   itself and the fifth is the lenght of the data. */\n+typedef void (lto_free_section_data_f) (struct lto_file_decl_data *, \n+\t\t\t\t\tenum lto_section_type,\n+\t\t\t\t\tconst char *,\n+\t\t\t\t\tconst char *,\n+\t\t\t\t\tsize_t);\n+\n+/* Cache of pickled nodes.  Used to avoid writing the same node more\n+   than once.  The first time a tree node is streamed out, it is\n+   entered in this cache.  Subsequent references to the same node are\n+   resolved by looking it up in this cache.\n+\n+   This is used in two ways:\n+\n+   - On the writing side, the first time T is added to STREAMER_CACHE,\n+     a new reference index is created for T and T is emitted on the\n+     stream.  If T needs to be emitted again to the stream, instead of\n+     pickling it again, the reference index is emitted.\n+\n+   - On the reading side, the first time T is read from the stream, it\n+     is reconstructed in memory and a new reference index created for\n+     T.  The reconstructed T is inserted in some array so that when\n+     the reference index for T is found in the input stream, it can be\n+     used to look up into the array to get the reconstructed T.  */\n+struct lto_streamer_cache_d\n+{\n+  /* The mapping between tree nodes and slots into the nodes array.  */\n+  htab_t node_map;\n+\n+  /* Next available slot in the nodes and offsets arrays.  */\n+  unsigned next_slot;\n+\n+  /* The nodes pickled so far.  */\n+  VEC(tree,gc) *nodes;\n+\n+  /* Offset into the stream where the nodes have been written.  */\n+  VEC(unsigned,heap) *offsets;\n+};\n+\n+\n+/* Structure used as buffer for reading an LTO file.  */\n+struct lto_input_block \n+{\n+  const char *data;\n+  unsigned int p;\n+  unsigned int len;\n+};\n+\n+#define LTO_INIT_INPUT_BLOCK(BASE,D,P,L)   \\\n+  do {                                     \\\n+    BASE.data = D;                         \\\n+    BASE.p = P;                            \\\n+    BASE.len = L;                          \\\n+  } while (0)\n+\n+#define LTO_INIT_INPUT_BLOCK_PTR(BASE,D,P,L) \\\n+  do {                                       \\\n+    BASE->data = D;                          \\\n+    BASE->p = P;                             \\\n+    BASE->len = L;                           \\\n+  } while (0)\n+\n+\n+/* The is the first part of the record for a function or constructor\n+   in the .o file.  */\n+struct lto_header\n+{\n+  int16_t major_version;\n+  int16_t minor_version;\n+  enum lto_section_type section_type;\n+};\n+\n+/* The header for a function body.  */\n+struct lto_function_header\n+{\n+  /* The header for all types of sections. */\n+  struct lto_header lto_header;\n+\n+  /* Number of labels with names.  */\n+  int32_t num_named_labels;\n+\n+  /* Number of labels without names.  */\n+  int32_t num_unnamed_labels;\n+\n+  /* Size compressed or 0 if not compressed.  */\n+  int32_t compressed_size;\n+\n+  /* Size of names for named labels.  */\n+  int32_t named_label_size;\n+\n+  /* Size of the cfg.  */\n+  int32_t cfg_size;\n+\n+  /* Size of main gimple body of function.  */\n+  int32_t main_size;\n+\n+  /* Size of the string table.  */\n+  int32_t string_size;\n+};\n+\n+\n+/* Structure describing a symbol section.  */\n+struct lto_decl_header\n+{\n+  /* The header for all types of sections. */\n+  struct lto_header lto_header;\n+\n+  /* Size of region for decl state. */\n+  int32_t decl_state_size;\n+\n+  /* Number of nodes in globals stream.  */\n+  int32_t num_nodes;\n+\n+  /* Size of region for expressions, decls, types, etc. */\n+  int32_t main_size;\n+\n+  /* Size of the string table.  */\n+  int32_t string_size;\n+};\n+\n+\n+/* Statistics gathered during LTO, WPA and LTRANS.  */\n+struct lto_stats_d\n+{\n+  unsigned HOST_WIDE_INT num_input_cgraph_nodes;\n+  unsigned HOST_WIDE_INT num_output_cgraph_nodes;\n+  unsigned HOST_WIDE_INT num_input_files;\n+  unsigned HOST_WIDE_INT num_output_files;\n+  unsigned HOST_WIDE_INT num_cgraph_partitions;\n+  unsigned HOST_WIDE_INT section_size[LTO_N_SECTION_TYPES];\n+  unsigned HOST_WIDE_INT num_function_bodies;\n+  unsigned HOST_WIDE_INT num_trees[NUM_TREE_CODES];\n+  unsigned HOST_WIDE_INT num_output_il_bytes;\n+  unsigned HOST_WIDE_INT num_compressed_il_bytes;\n+  unsigned HOST_WIDE_INT num_input_il_bytes;\n+  unsigned HOST_WIDE_INT num_uncompressed_il_bytes;\n+};\n+\n+/* Encoder data structure used to stream callgraph nodes.  */\n+struct lto_cgraph_encoder_d\n+{\n+  /* Map nodes to reference number. */\n+  struct pointer_map_t *map;\n+\n+  /* Map reference number to node. */\n+  VEC(cgraph_node_ptr,heap) *nodes;\n+};\n+\n+typedef struct lto_cgraph_encoder_d *lto_cgraph_encoder_t;\n+\n+/* Mapping from indices to trees.  */\n+struct lto_tree_ref_table\n+{\n+  /* Array of referenced trees . */\n+  tree *trees;\n+\n+  /* Size of array. */\n+  unsigned int size;\n+};\n+\n+\n+/* Mapping between trees and slots in an array.  */\n+struct lto_decl_slot\n+{\n+  tree t;\n+  int slot_num;\n+};\n+\n+\n+/* The lto_tree_ref_encoder struct is used to encode trees into indices. */\n+\n+struct lto_tree_ref_encoder\n+{\n+  htab_t tree_hash_table;\t/* Maps pointers to indices. */\n+  unsigned int next_index;\t/* Next available index. */\n+  VEC(tree,heap) *trees;\t/* Maps indices to pointers. */\n+};\n+\n+\n+/* Structure to hold states of input scope.  */\n+struct lto_in_decl_state\n+{\n+  /* Array of lto_in_decl_buffers to store type and decls streams. */\n+  struct lto_tree_ref_table streams[LTO_N_DECL_STREAMS];\n+\n+  /* If this in-decl state is associated with a function. FN_DECL\n+     point to the FUNCTION_DECL. */\n+  tree fn_decl;\n+};\n+\n+typedef struct lto_in_decl_state *lto_in_decl_state_ptr;\n+\n+\n+/* The structure that holds all of the vectors of global types,\n+   decls and cgraph nodes used in the serialization of this file.  */\n+struct lto_out_decl_state\n+{\n+  /* The buffers contain the sets of decls of various kinds and types we have\n+     seen so far and the indexes assigned to them.  */\n+  struct lto_tree_ref_encoder streams[LTO_N_DECL_STREAMS];\n+\n+  /* Encoder for cgraph nodes.  */\n+  lto_cgraph_encoder_t cgraph_node_encoder;\n+\n+  /* If this out-decl state belongs to a function, fn_decl points to that\n+     function.  Otherwise, it is NULL. */\n+  tree fn_decl;\n+};\n+\n+typedef struct lto_out_decl_state *lto_out_decl_state_ptr;\n+\n+DEF_VEC_P(lto_out_decl_state_ptr);\n+DEF_VEC_ALLOC_P(lto_out_decl_state_ptr, heap);\n+\n+/* One of these is allocated for each object file that being compiled\n+   by lto.  This structure contains the tables that are needed by the\n+   serialized functions and ipa passes to connect themselves to the\n+   global types and decls as they are reconstituted.  */\n+struct lto_file_decl_data\n+{\n+  /* Decl state currently used. */\n+  struct lto_in_decl_state *current_decl_state;\n+\n+  /* Decl state corresponding to regions outside of any functions\n+     in the compilation unit. */\n+  struct lto_in_decl_state *global_decl_state;\n+\n+  /* Table of cgraph nodes present in this file.  */\n+  lto_cgraph_encoder_t cgraph_node_encoder;\n+\n+  /* Hash table maps lto-related section names to location in file.  */\n+  htab_t function_decl_states;\n+\n+  /* The .o file that these offsets relate to.  */\n+  const char *file_name;\n+\n+  /* Nonzero if this file should be recompiled with LTRANS.  */\n+  unsigned needs_ltrans_p : 1;\n+\n+  /* If the file is open, this is the fd of the mapped section.  This\n+     is -1 if the file has not yet been opened.  */\n+  int fd;\n+\n+  /* Hash table maps lto-related section names to location in file.  */\n+  htab_t section_hash_table;\n+\n+  /* Hash new name of renamed global declaration to its original name.  */\n+  htab_t renaming_hash_table;\n+};\n+\n+struct lto_char_ptr_base\n+{\n+  char *ptr;\n+};\n+\n+/* An incore byte stream to buffer the various parts of the function.\n+   The entire structure should be zeroed when created.  The record\n+   consists of a set of blocks.  The first sizeof (ptr) bytes are used\n+   as a chain, and the rest store the bytes to be written.  */\n+struct lto_output_stream\n+{\n+  /* The pointer to the first block in the stream.  */\n+  struct lto_char_ptr_base * first_block;\n+\n+  /* The pointer to the last and current block in the stream.  */\n+  struct lto_char_ptr_base * current_block;\n+\n+  /* The pointer to where the next char should be written.  */\n+  char * current_pointer;\n+\n+  /* The number of characters left in the current block.  */\n+  unsigned int left_in_block;\n+\n+  /* The block size of the last block allocated.  */\n+  unsigned int block_size;\n+\n+  /* The total number of characters written.  */\n+  unsigned int total_size;\n+};\n+\n+/* The is the first part of the record in an LTO file for many of the\n+   IPA passes.  */\n+struct lto_simple_header\n+{\n+  /* The header for all types of sections. */\n+  struct lto_header lto_header;\n+\n+  /* Size of main gimple body of function.  */\n+  int32_t main_size;\n+\n+  /* Size of main stream when compressed.  */\n+  int32_t compressed_size;\n+};\n+\n+/* A simple output block.  This can be used for simple IPA passes that\n+   do not need more than one stream.  */\n+struct lto_simple_output_block\n+{\n+  enum lto_section_type section_type;\n+  struct lto_out_decl_state *decl_state;\n+\n+  /* The stream that the main tree codes are written to.  */\n+  struct lto_output_stream *main_stream;\n+};\n+\n+/* Data structure holding all the data and descriptors used when writing\n+   an LTO file.  */\n+struct output_block\n+{\n+  enum lto_section_type section_type;\n+  struct lto_out_decl_state *decl_state;\n+\n+  /* The stream that the main tree codes are written to.  */\n+  struct lto_output_stream *main_stream;\n+\n+  /* The stream that contains the string table.  */\n+  struct lto_output_stream *string_stream;\n+\n+  /* The stream that contains the cfg.  */\n+  struct lto_output_stream *cfg_stream;\n+\n+  /* The hash table that contains the set of strings we have seen so\n+     far and the indexes assigned to them.  */\n+  htab_t string_hash_table;\n+\n+  /* The current cgraph_node that we are currently serializing.  Null\n+     if we are serializing something else.  */\n+  struct cgraph_node *cgraph_node;\n+\n+  /* These are the last file and line that were seen in the stream.\n+     If the current node differs from these, it needs to insert\n+     something into the stream and fix these up.  */\n+  const char *current_file;\n+  int current_line;\n+  int current_col;\n+\n+  /* True if writing globals and types.  */\n+  bool global;\n+\n+  /* Cache of nodes written in this section.  */\n+  struct lto_streamer_cache_d *writer_cache;\n+};\n+\n+\n+/* Data and descriptors used when reading from an LTO file.  */\n+struct data_in\n+{\n+  /* The global decls and types.  */\n+  struct lto_file_decl_data *file_data;\n+\n+  /* All of the labels.  */\n+  tree *labels;\n+\n+  /* The string table.  */\n+  const char *strings;\n+\n+  /* The length of the string table.  */\n+  unsigned int strings_len;\n+\n+  /* Number of named labels.  Used to find the index of unnamed labels\n+     since they share space with the named labels.  */\n+  unsigned int num_named_labels;  \n+\n+  /* Number of unnamed labels.  */\n+  unsigned int num_unnamed_labels;\n+\n+  const char *current_file;\n+  int current_line;\n+  int current_col;\n+\n+  /* Maps each reference number to the resolution done by the linker. */\n+  VEC(ld_plugin_symbol_resolution_t,heap) *globals_resolution;\n+\n+  /* Cache of pickled nodes.  */\n+  struct lto_streamer_cache_d *reader_cache;\n+};\n+\n+\n+/* In lto-section-in.c  */\n+extern struct lto_input_block * lto_create_simple_input_block (\n+\t\t\t       struct lto_file_decl_data *, \n+\t\t\t       enum lto_section_type, const char **, size_t *);\n+extern void\n+lto_destroy_simple_input_block (struct lto_file_decl_data *, \n+\t\t\t\tenum lto_section_type,\n+\t\t\t\tstruct lto_input_block *, const char *, size_t);\n+extern void lto_set_in_hooks (struct lto_file_decl_data **, \n+\t\t\t      lto_get_section_data_f *,\n+\t\t\t      lto_free_section_data_f *);\n+extern struct lto_file_decl_data **lto_get_file_decl_data (void);\n+extern const char *lto_get_section_data (struct lto_file_decl_data *,\n+\t\t\t\t\t enum lto_section_type,\n+\t\t\t\t\t const char *, size_t *);\n+extern void lto_free_section_data (struct lto_file_decl_data *,\n+\t\t\t\t   enum lto_section_type,\n+\t\t\t\t   const char *, const char *, size_t);\n+extern unsigned char lto_input_1_unsigned (struct lto_input_block *);\n+extern unsigned HOST_WIDE_INT lto_input_uleb128 (struct lto_input_block *);\n+extern unsigned HOST_WIDEST_INT lto_input_widest_uint_uleb128 (\n+\t\t\t\t\t\tstruct lto_input_block *);\n+extern HOST_WIDE_INT lto_input_sleb128 (struct lto_input_block *);\n+extern htab_t lto_create_renaming_table (void);\n+extern void lto_record_renamed_decl (struct lto_file_decl_data *,\n+\t\t\t\t     const char *, const char *);\n+extern const char *lto_get_decl_name_mapping (struct lto_file_decl_data *,\n+\t\t\t\t\t      const char *);\n+extern struct lto_in_decl_state *lto_new_in_decl_state (void);\n+extern void lto_delete_in_decl_state (struct lto_in_decl_state *);\n+extern hashval_t lto_hash_in_decl_state (const void *);\n+extern int lto_eq_in_decl_state (const void *, const void *);\n+extern struct lto_in_decl_state *lto_get_function_in_decl_state (\n+\t\t\t\t      struct lto_file_decl_data *, tree);\n+\n+/* In lto-section-out.c  */\n+extern hashval_t lto_hash_decl_slot_node (const void *);\n+extern int lto_eq_decl_slot_node (const void *, const void *);\n+extern hashval_t lto_hash_type_slot_node (const void *);\n+extern int lto_eq_type_slot_node (const void *, const void *);\n+extern void lto_begin_section (const char *, bool);\n+extern void lto_end_section (void);\n+extern void lto_write_stream (struct lto_output_stream *);\n+extern void lto_output_1_stream (struct lto_output_stream *, char);\n+extern void lto_output_data_stream (struct lto_output_stream *, const void *,\n+\t\t\t\t    size_t);\n+extern void lto_output_uleb128_stream (struct lto_output_stream *,\n+       \t\t\t\t       unsigned HOST_WIDE_INT);\n+extern void lto_output_widest_uint_uleb128_stream (struct lto_output_stream *,\n+       \t\t\t\t\t           unsigned HOST_WIDEST_INT);\n+extern void lto_output_sleb128_stream (struct lto_output_stream *,\n+\t\t\t\t       HOST_WIDE_INT);\n+extern bool lto_output_decl_index (struct lto_output_stream *,\n+\t\t\t    struct lto_tree_ref_encoder *,\n+\t\t\t    tree, unsigned int *);\n+extern void lto_output_field_decl_index (struct lto_out_decl_state *,\n+\t\t\t\t  struct lto_output_stream *, tree);\n+extern void lto_output_fn_decl_index (struct lto_out_decl_state *,\n+\t\t\t       struct lto_output_stream *, tree);\n+extern void lto_output_namespace_decl_index (struct lto_out_decl_state *,\n+\t\t\t\t      struct lto_output_stream *, tree);\n+extern void lto_output_var_decl_index (struct lto_out_decl_state *,\n+\t\t\t\tstruct lto_output_stream *, tree);\n+extern void lto_output_type_decl_index (struct lto_out_decl_state *,\n+\t\t\t\t struct lto_output_stream *, tree);\n+extern void lto_output_type_ref_index (struct lto_out_decl_state *,\n+\t\t\t\tstruct lto_output_stream *, tree);\n+extern struct lto_simple_output_block *lto_create_simple_output_block (\n+\t\t\t\tenum lto_section_type);\n+extern void lto_destroy_simple_output_block (struct lto_simple_output_block *);\n+extern struct lto_out_decl_state *lto_new_out_decl_state (void);\n+extern void lto_delete_out_decl_state (struct lto_out_decl_state *);\n+extern struct lto_out_decl_state *lto_get_out_decl_state (void);\n+extern void lto_push_out_decl_state (struct lto_out_decl_state *);\n+extern struct lto_out_decl_state *lto_pop_out_decl_state (void);\n+extern void lto_record_function_out_decl_state (tree,\n+\t\t\t\t\t\tstruct lto_out_decl_state *);\n+extern void lto_new_extern_inline_states (void);\n+extern void lto_delete_extern_inline_states (void);\n+extern void lto_force_functions_extern_inline (bitmap decls);\n+extern bool lto_forced_extern_inline_p (tree fn_decl);\n+\n+\n+/* In lto-streamer.c.  */\n+extern const char *lto_tag_name (enum LTO_tags);\n+extern bitmap lto_bitmap_alloc (void);\n+extern void lto_bitmap_free (bitmap);\n+extern char *lto_get_section_name (int, const char *);\n+extern void print_lto_report (void);\n+extern struct bitpack_d *bitpack_create (void);\n+extern void bitpack_delete (struct bitpack_d *);\n+extern void bp_pack_value (struct bitpack_d *, bitpack_word_t, unsigned);\n+extern bitpack_word_t bp_unpack_value (struct bitpack_d *, unsigned);\n+extern bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n+\t\t\t\t       int *, unsigned *);\n+extern bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n+\t\t\t\t\t  int);\n+extern bool lto_streamer_cache_lookup (struct lto_streamer_cache_d *, tree,\n+\t\t\t\t       int *);\n+extern tree lto_streamer_cache_get (struct lto_streamer_cache_d *, int);\n+extern struct lto_streamer_cache_d *lto_streamer_cache_create (void);\n+extern void lto_streamer_cache_delete (struct lto_streamer_cache_d *);\n+extern void lto_streamer_init (void);\n+extern bool gate_lto_out (void);\n+#ifdef LTO_STREAMER_DEBUG\n+extern void lto_orig_address_map (tree, intptr_t);\n+extern intptr_t lto_orig_address_get (tree);\n+extern void lto_orig_address_remove (tree);\n+#endif\n+extern void lto_check_version (int, int);\n+\n+\n+/* In lto-streamer-in.c */\n+extern void lto_input_function_body (struct lto_file_decl_data *, tree,\n+\t\t\t\t     const char *);\n+extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n+\t\t\t\t\t      const char *);\n+extern void lto_input_cgraph (struct lto_file_decl_data *, const char *);\n+extern void lto_init_reader (void);\n+extern tree lto_input_tree (struct lto_input_block *, struct data_in *);\n+extern void lto_input_function_body (struct lto_file_decl_data *, tree,\n+\t\t\t\t     const char *);\n+extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n+\t\t\t\t\t      const char *);\n+extern struct bitpack_d *lto_input_bitpack (struct lto_input_block *);\n+extern void lto_init_reader (void);\n+extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n+\t\t\t\t    const char *, unsigned,\n+\t\t\t\t    VEC(ld_plugin_symbol_resolution_t,heap) *);\n+extern void lto_data_in_delete (struct data_in *);\n+extern void lto_register_deferred_decls_in_symtab (struct data_in *);\n+\n+\n+/* In lto-streamer-out.c  */\n+extern void lto_register_decl_definition (tree, struct lto_file_decl_data *);\n+extern struct output_block *create_output_block (enum lto_section_type);\n+extern void destroy_output_block (struct output_block *);\n+extern void lto_output_tree (struct output_block *, tree, bool);\n+extern void lto_output_bitpack (struct lto_output_stream *, struct bitpack_d *);\n+\n+\n+/* In lto-cgraph.c  */\n+struct cgraph_node *lto_cgraph_encoder_deref (lto_cgraph_encoder_t, int);\n+int lto_cgraph_encoder_lookup (lto_cgraph_encoder_t, struct cgraph_node *);\n+lto_cgraph_encoder_t lto_cgraph_encoder_new (void);\n+int lto_cgraph_encoder_encode (lto_cgraph_encoder_t, struct cgraph_node *);\n+void lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder);\n+void output_cgraph (cgraph_node_set);\n+void input_cgraph (void);\n+\n+\n+/* In lto-symtab.c.  */\n+extern void lto_symtab_merge_var (tree, enum ld_plugin_symbol_resolution);\n+extern void lto_symtab_merge_fn (tree, enum ld_plugin_symbol_resolution,\n+                                 struct lto_file_decl_data *);\n+extern tree lto_symtab_prevailing_decl (tree decl);\n+extern enum ld_plugin_symbol_resolution lto_symtab_get_resolution (tree decl);\n+struct lto_file_decl_data *lto_symtab_get_file_data (tree decl);\n+extern void lto_symtab_clear_resolution (tree decl);\n+\n+\n+/* In lto-opts.c.  */\n+extern void lto_register_user_option (size_t, const char *, int, int);\n+extern void lto_read_file_options (struct lto_file_decl_data *);\n+extern void lto_write_options (void);\n+extern void lto_reissue_options (void);\n+void lto_clear_user_options (void);\n+void lto_clear_file_options (void);\n+\n+\n+/* In lto-wpa-fixup.c  */\n+void lto_mark_nothrow_fndecl (tree);\n+void lto_fixup_nothrow_decls (void);\n+\n+\n+/* Statistics gathered during LTO, WPA and LTRANS.  */\n+extern struct lto_stats_d lto_stats;\n+\n+/* Section names corresponding to the values of enum lto_section_type.  */\n+extern const char *lto_section_name[];\n+\n+/* Holds all the out decl states of functions output so far in the\n+   current output file.  */\n+extern VEC(lto_out_decl_state_ptr, heap) *lto_function_decl_states;\n+\n+/* Return true if LTO tag TAG corresponds to a tree code.  */\n+static inline bool\n+lto_tag_is_tree_code_p (enum LTO_tags tag)\n+{\n+  return tag > LTO_null && (unsigned) tag <= NUM_TREE_CODES;\n+}\n+\n+\n+/* Return true if LTO tag TAG corresponds to a gimple code.  */\n+static inline bool\n+lto_tag_is_gimple_code_p (enum LTO_tags tag)\n+{\n+  return (unsigned) tag >= NUM_TREE_CODES + 1\n+\t && (unsigned) tag < 1 + NUM_TREE_CODES + LAST_AND_UNUSED_GIMPLE_CODE;\n+}\n+\n+\n+/* Return the LTO tag corresponding to gimple code CODE.  See enum\n+   LTO_tags for details on the conversion.  */\n+static inline enum LTO_tags\n+lto_gimple_code_to_tag (enum gimple_code code)\n+{\n+  return (enum LTO_tags) ((unsigned) code + NUM_TREE_CODES + 1);\n+}\n+\n+\n+/* Return the GIMPLE code corresponding to TAG.  See enum LTO_tags for\n+   details on the conversion.  */\n+static inline enum gimple_code\n+lto_tag_to_gimple_code (enum LTO_tags tag)\n+{\n+  gcc_assert (lto_tag_is_gimple_code_p (tag));\n+  return (enum gimple_code) ((unsigned) tag - NUM_TREE_CODES - 1);\n+}\n+\n+\n+/* Return the LTO tag corresponding to tree code CODE.  See enum\n+   LTO_tags for details on the conversion.  */\n+static inline enum LTO_tags\n+lto_tree_code_to_tag (enum tree_code code)\n+{\n+  return (enum LTO_tags) ((unsigned) code + 1);\n+}\n+\n+\n+/* Return the tree code corresponding to TAG.  See enum LTO_tags for\n+   details on the conversion.  */\n+static inline enum tree_code\n+lto_tag_to_tree_code (enum LTO_tags tag)\n+{\n+  gcc_assert (lto_tag_is_tree_code_p (tag));\n+  return (enum tree_code) ((unsigned) tag - 1);\n+}\n+\n+\n+/* Return true if FILE needs to be compiled with LTRANS.  */\n+static inline bool\n+lto_file_needs_ltrans_p (struct lto_file_decl_data *file)\n+{\n+  return file->needs_ltrans_p != 0;\n+}\n+\n+\n+/* Mark FILE to be compiled with LTRANS.  */\n+static inline void\n+lto_mark_file_for_ltrans (struct lto_file_decl_data *file)\n+{\n+  file->needs_ltrans_p = 1;\n+}\n+\n+\n+/* Return true if any files in node set SET need to be compiled\n+   with LTRANS.  */\n+static inline bool\n+cgraph_node_set_needs_ltrans_p (cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator csi;\n+\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    if (lto_file_needs_ltrans_p (csi_node (csi)->local.lto_file_data))\n+      return true;\n+\n+  return false;\n+}\n+\n+\n+/* Initialize an lto_out_decl_buffer ENCODER.  */\n+static inline void\n+lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder,\n+\t\t\t   htab_hash hash_fn, htab_eq eq_fn)\n+{\n+  encoder->tree_hash_table = htab_create (37, hash_fn, eq_fn, free);\n+  encoder->next_index = 0;\n+  encoder->trees = NULL;\n+}\n+\n+\n+/* Destory an lto_tree_ref_encoder ENCODER by freeing its contents.  The\n+   memory used by ENCODER is not freed by this function.  */\n+static inline void\n+lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n+{\n+  /* Hash table may be delete already.  */\n+  if (encoder->tree_hash_table)\n+    htab_delete (encoder->tree_hash_table);\n+  VEC_free (tree, heap, encoder->trees);\n+}\n+\n+/* Return the number of trees encoded in ENCODER. */\n+static inline unsigned int\n+lto_tree_ref_encoder_size (struct lto_tree_ref_encoder *encoder)\n+{\n+  return VEC_length (tree, encoder->trees);\n+}\n+\n+/* Return the IDX-th tree in ENCODER. */\n+static inline tree\n+lto_tree_ref_encoder_get_tree (struct lto_tree_ref_encoder *encoder,\n+\t\t\t       unsigned int idx)\n+{\n+  return VEC_index (tree, encoder->trees, idx);\n+}\n+\n+\n+/* Return true if LABEL should be emitted in the global context.  */\n+static inline bool\n+emit_label_in_global_context_p (tree label)\n+{\n+  return DECL_NONLOCAL (label) || FORCED_LABEL (label);\n+}\n+\n+/* Return true if tree node EXPR should be streamed as a builtin.  For\n+   these nodes, we just emit the class and function code.  */\n+static inline bool\n+lto_stream_as_builtin_p (tree expr)\n+{\n+  return (TREE_CODE (expr) == FUNCTION_DECL\n+\t  && DECL_IS_BUILTIN (expr)\n+\t  && (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n+\t      || DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD));\n+}\n+\n+/* Return true if EXPR is a tree node that can be written to disk.  */\n+static inline bool\n+lto_is_streamable (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  /* Notice that we reject SSA_NAMEs as well.  We only emit the SSA\n+     name version in lto_output_tree_ref (see output_ssa_names).  */\n+  return !is_lang_specific (expr)\n+\t && code != SSA_NAME\n+\t && code != CALL_EXPR\n+\t && code != LANG_TYPE\n+\t && code != MODIFY_EXPR\n+\t && code != INIT_EXPR\n+\t && code != TARGET_EXPR\n+\t && code != BIND_EXPR\n+\t && code != WITH_CLEANUP_EXPR\n+\t && code != STATEMENT_LIST\n+\t && (code == CASE_LABEL_EXPR\n+\t     || code == DECL_EXPR\n+\t     || TREE_CODE_CLASS (code) != tcc_statement);\n+}\n+\n+DEFINE_DECL_STREAM_FUNCS (TYPE, type)\n+DEFINE_DECL_STREAM_FUNCS (FIELD_DECL, field_decl)\n+DEFINE_DECL_STREAM_FUNCS (FN_DECL, fn_decl)\n+DEFINE_DECL_STREAM_FUNCS (VAR_DECL, var_decl)\n+DEFINE_DECL_STREAM_FUNCS (TYPE_DECL, type_decl)\n+DEFINE_DECL_STREAM_FUNCS (NAMESPACE_DECL, namespace_decl)\n+DEFINE_DECL_STREAM_FUNCS (LABEL_DECL, label_decl)\n+\n+#endif /* GCC_LTO_STREAMER_H  */"}, {"sha": "90a200fc7357ce5e9c36a0334e57ff386d0c942a", "filename": "gcc/lto-symtab.c", "status": "added", "additions": 793, "deletions": 0, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,793 @@\n+/* LTO symbol table.\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ggc.h\"\t/* lambda.h needs this */\n+#include \"lambda.h\"\t/* gcd */\n+#include \"hashtab.h\"\n+#include \"plugin-api.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Vector to keep track of external variables we've seen so far.  */\n+VEC(tree,gc) *lto_global_var_decls;\n+\n+/* Base type for resolution map. It maps NODE to resolution.  */\n+\n+struct GTY(()) lto_symtab_base_def\n+{\n+  /* Key is either an IDENTIFIER or a DECL.  */\n+  tree node;\n+};\n+typedef struct lto_symtab_base_def *lto_symtab_base_t;\n+\n+struct GTY(()) lto_symtab_identifier_def\n+{\n+  struct lto_symtab_base_def base;\n+  tree decl;\n+};\n+typedef struct lto_symtab_identifier_def *lto_symtab_identifier_t;\n+\n+struct GTY(()) lto_symtab_decl_def\n+{\n+  struct lto_symtab_base_def base;\n+  enum ld_plugin_symbol_resolution resolution;\n+  struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n+};\n+typedef struct lto_symtab_decl_def *lto_symtab_decl_t;\n+\n+/* A poor man's symbol table. This hashes identifier to prevailing DECL\n+   if there is one. */\n+\n+static GTY ((if_marked (\"lto_symtab_identifier_marked_p\"),\n+\t     param_is (struct lto_symtab_identifier_def)))\n+  htab_t lto_symtab_identifiers;\n+\n+static GTY ((if_marked (\"lto_symtab_decl_marked_p\"),\n+\t     param_is (struct lto_symtab_decl_def)))\n+  htab_t lto_symtab_decls;\n+\n+/* Return the hash value of an lto_symtab_base_t object pointed to by P.  */\n+\n+static hashval_t\n+lto_symtab_base_hash (const void *p)\n+{\n+  const struct lto_symtab_base_def *base =\n+    (const struct lto_symtab_base_def*) p;\n+  return htab_hash_pointer (base->node);\n+}\n+\n+/* Return non-zero if P1 and P2 points to lto_symtab_base_def structs\n+   corresponding to the same tree node.  */\n+\n+static int\n+lto_symtab_base_eq (const void *p1, const void *p2)\n+{\n+  const struct lto_symtab_base_def *base1 =\n+     (const struct lto_symtab_base_def *) p1;\n+  const struct lto_symtab_base_def *base2 =\n+     (const struct lto_symtab_base_def *) p2;\n+  return (base1->node == base2->node);\n+}\n+\n+/* Returns non-zero if P points to an lto_symtab_base_def struct that needs\n+   to be marked for GC.  */ \n+\n+static int\n+lto_symtab_base_marked_p (const void *p)\n+{\n+  const struct lto_symtab_base_def *base =\n+     (const struct lto_symtab_base_def *) p;\n+\n+  /* Keep this only if the key node is marked.  */\n+  return ggc_marked_p (base->node);\n+}\n+\n+/* Returns non-zero if P points to an lto_symtab_identifier_def struct that\n+   needs to be marked for GC.  */ \n+\n+static int\n+lto_symtab_identifier_marked_p (const void *p)\n+{\n+  return lto_symtab_base_marked_p (p);\n+}\n+\n+/* Returns non-zero if P points to an lto_symtab_decl_def struct that needs\n+   to be marked for GC.  */ \n+\n+static int\n+lto_symtab_decl_marked_p (const void *p)\n+{\n+  return lto_symtab_base_marked_p (p);\n+}\n+\n+#define lto_symtab_identifier_eq\tlto_symtab_base_eq\n+#define lto_symtab_identifier_hash\tlto_symtab_base_hash\n+#define lto_symtab_decl_eq\t\tlto_symtab_base_eq\n+#define lto_symtab_decl_hash\t\tlto_symtab_base_hash\n+\n+/* Lazily initialize resolution hash tables.  */\n+\n+static void\n+lto_symtab_maybe_init_hash_tables (void)\n+{\n+  if (!lto_symtab_identifiers)\n+    {\n+      lto_symtab_identifiers =\n+\thtab_create_ggc (1021, lto_symtab_identifier_hash,\n+\t\t\t lto_symtab_identifier_eq, NULL);\n+      lto_symtab_decls =\n+\thtab_create_ggc (1021, lto_symtab_decl_hash,\n+\t\t\t lto_symtab_decl_eq, NULL);\n+    }\n+}\n+\n+/* Returns true iff the union of ATTRIBUTES_1 and ATTRIBUTES_2 can be\n+   applied to DECL.  */\n+static bool\n+lto_compatible_attributes_p (tree decl ATTRIBUTE_UNUSED, \n+\t\t\t     tree attributes_1, \n+\t\t\t     tree attributes_2)\n+{\n+#if 0\n+  /* ??? For now, assume two attribute sets are compatible only if they\n+     are both empty.  */\n+  return !attributes_1 && !attributes_2;\n+#else\n+  /* FIXME.  For the moment, live dangerously, and assume the user knows\n+     what he's doing. I don't think the linker would distinguish these cases.  */\n+  return true || (!attributes_1 && !attributes_2);\n+#endif\n+}\n+\n+/* Helper for lto_symtab_compatible. Return TRUE if DECL is an external\n+   variable declaration of an aggregate type. */\n+\n+static bool\n+external_aggregate_decl_p (tree decl)\n+{\n+  return (TREE_CODE (decl) == VAR_DECL\n+\t  && DECL_EXTERNAL (decl)\n+\t  && AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n+}\n+\n+static bool maybe_merge_incomplete_and_complete_type (tree, tree);\n+\n+/* Try to merge an incomplete type INCOMPLETE with a complete type\n+   COMPLETE of same kinds.\n+   Return true if they were merged, false otherwise.  */\n+\n+static bool\n+merge_incomplete_and_complete_type (tree incomplete, tree complete)\n+{\n+  /* For merging array types do some extra sanity checking.  */\n+  if (TREE_CODE (incomplete) == ARRAY_TYPE\n+      && !maybe_merge_incomplete_and_complete_type (TREE_TYPE (incomplete),\n+\t\t\t\t\t\t    TREE_TYPE (complete))\n+      && !gimple_types_compatible_p (TREE_TYPE (incomplete),\n+\t\t\t\t     TREE_TYPE (complete)))\n+    return false;\n+\n+  /* ??? Ideally we would do this by means of a common canonical type, but\n+     that's difficult as we do not have links from the canonical type\n+     back to all its children.  */\n+  gimple_force_type_merge (incomplete, complete);\n+\n+  return true;\n+}\n+\n+/* Try to merge a maybe complete / incomplete type pair TYPE1 and TYPE2.\n+   Return true if they were merged, false otherwise.  */\n+\n+static bool\n+maybe_merge_incomplete_and_complete_type (tree type1, tree type2)\n+{\n+  bool res = false;\n+\n+  if (TREE_CODE (type1) != TREE_CODE (type2))\n+    return false;\n+\n+  if (!COMPLETE_TYPE_P (type1) && COMPLETE_TYPE_P (type2))\n+    res = merge_incomplete_and_complete_type (type1, type2);\n+  else if (COMPLETE_TYPE_P (type1) && !COMPLETE_TYPE_P (type2))\n+    res = merge_incomplete_and_complete_type (type2, type1);\n+\n+  /* Recurse on pointer targets.  */\n+  if (!res\n+      && POINTER_TYPE_P (type1)\n+      && POINTER_TYPE_P (type2))\n+    res = maybe_merge_incomplete_and_complete_type (TREE_TYPE (type1),\n+\t\t\t\t\t\t    TREE_TYPE (type2));\n+\n+  return res;\n+}\n+\n+/* Check if OLD_DECL and NEW_DECL are compatible. */\n+\n+static bool\n+lto_symtab_compatible (tree old_decl, tree new_decl)\n+{\n+  tree merged_type = NULL_TREE;\n+\n+  if (TREE_CODE (old_decl) != TREE_CODE (new_decl))\n+    {\n+      switch (TREE_CODE (new_decl))\n+\t{\n+\tcase VAR_DECL:\n+\t  gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t    \"function %qD redeclared as variable\", new_decl);\n+\t  inform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t  \"previously declared here\");\n+\t  return false;\n+\n+\tcase FUNCTION_DECL:\n+\t  gcc_assert (TREE_CODE (old_decl) == VAR_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t    \"variable %qD redeclared as function\", new_decl);\n+\t  inform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t  \"previously declared here\");\n+\t  return false;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* Handle external declarations with incomplete type or pointed-to\n+     incomplete types by forcefully merging the types.\n+     ???  In principle all types involved in the two decls should\n+     be merged forcefully, for example without considering type or\n+     field names.  */\n+  if (TREE_CODE (old_decl) == VAR_DECL)\n+    {\n+      tree old_type = TREE_TYPE (old_decl);\n+      tree new_type = TREE_TYPE (new_decl);\n+\n+      if (DECL_EXTERNAL (old_decl) || DECL_EXTERNAL (new_decl))\n+\tmaybe_merge_incomplete_and_complete_type (old_type, new_type);\n+      else if (POINTER_TYPE_P (old_type)\n+\t       && POINTER_TYPE_P (new_type))\n+\tmaybe_merge_incomplete_and_complete_type (TREE_TYPE (old_type),\n+\t\t\t\t\t\t  TREE_TYPE (new_type));\n+\n+      /* For array types we have to accept external declarations with\n+\t different sizes than the actual definition (164.gzip).\n+\t ???  We could emit a warning here.  */\n+      if (TREE_CODE (old_type) == TREE_CODE (new_type)\n+\t  && TREE_CODE (old_type) == ARRAY_TYPE\n+\t  && COMPLETE_TYPE_P (old_type)\n+\t  && COMPLETE_TYPE_P (new_type)\n+\t  && tree_int_cst_compare (TYPE_SIZE (old_type),\n+\t\t\t\t   TYPE_SIZE (new_type)) != 0\n+\t  && gimple_types_compatible_p (TREE_TYPE (old_type),\n+\t\t\t\t\tTREE_TYPE (new_type)))\n+\t{\n+\t  /* If only one is external use the type of the non-external decl.\n+\t     Else use the larger one and also adjust the decl size.\n+\t     ???  Directional merging would allow us to simply pick the\n+\t     larger one instead of rewriting it.  */\n+\t  if (DECL_EXTERNAL (old_decl) ^ DECL_EXTERNAL (new_decl))\n+\t    {\n+\t      if (DECL_EXTERNAL (old_decl))\n+\t\tTREE_TYPE (old_decl) = new_type;\n+\t      else if (DECL_EXTERNAL (new_decl))\n+\t\tTREE_TYPE (new_decl) = old_type;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (tree_int_cst_compare (TYPE_SIZE (old_type),\n+\t\t\t\t\tTYPE_SIZE (new_type)) < 0)\n+\t\t{\n+\t\t  TREE_TYPE (old_decl) = new_type;\n+\t\t  DECL_SIZE (old_decl) = DECL_SIZE (new_decl);\n+\t\t  DECL_SIZE_UNIT (old_decl) = DECL_SIZE_UNIT (new_decl);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  TREE_TYPE (new_decl) = old_type;\n+\t\t  DECL_SIZE (new_decl) = DECL_SIZE (old_decl);\n+\t\t  DECL_SIZE_UNIT (new_decl) = DECL_SIZE_UNIT (old_decl);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (!gimple_types_compatible_p (TREE_TYPE (old_decl), TREE_TYPE (new_decl)))\n+    {\n+      if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+\t{\n+\t  if (!merged_type\n+\t      /* We want either of the types to have argument types,\n+\t\t but not both.  */\n+\t      && ((TYPE_ARG_TYPES (TREE_TYPE (old_decl)) != NULL)\n+\t\t  ^ (TYPE_ARG_TYPES (TREE_TYPE (new_decl)) != NULL)))\n+\t    {\n+\t      /* The situation here is that (in C) somebody was smart\n+\t\t enough to use proper declarations in a header file, but\n+\t\t the actual definition of the function uses\n+\t\t non-ANSI-style argument lists.  Or we have a situation\n+\t\t where declarations weren't used anywhere and we're\n+\t\t merging the actual definition with a use.  One of the\n+\t\t decls will then have a complete function type, whereas\n+\t\t the other will only have a result type.  Assume that\n+\t\t the more complete type is the right one and don't\n+\t\t complain.  */\n+\t      if (TYPE_ARG_TYPES (TREE_TYPE (old_decl)))\n+\t\t{\n+\t\t  merged_type = TREE_TYPE (old_decl);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  merged_type = TREE_TYPE (new_decl);\n+\t\t}\n+\t    }\n+\n+\t  /* If we don't have a merged type yet...sigh.  The linker\n+\t     wouldn't complain if the types were mismatched, so we\n+\t     probably shouldn't either.  Just use the type from\n+\t     whichever decl appears to be associated with the\n+\t     definition.  If for some odd reason neither decl is, the\n+\t     older one wins.  */\n+\t  if (!merged_type)\n+\t    {\n+\t      if (!DECL_EXTERNAL (new_decl))\n+\t\t{\n+\t\t  merged_type = TREE_TYPE (new_decl);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  merged_type = TREE_TYPE (old_decl);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (!merged_type)\n+\t{\n+\t  if (warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n+\t\t\t  \"type of %qD does not match original declaration\",\n+\t\t\t  new_decl))\n+\t    inform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t    \"previously declared here\");\n+\t  return false;\n+\t}\n+    }\n+\n+  if (DECL_UNSIGNED (old_decl) != DECL_UNSIGNED (new_decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t\"signedness of %qD does not match original declaration\",\n+\t\tnew_decl);\n+      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n+      return false;\n+    }\n+\n+  if (!tree_int_cst_equal (DECL_SIZE (old_decl),\n+\t\t\t   DECL_SIZE (new_decl))\n+      || !tree_int_cst_equal (DECL_SIZE_UNIT (old_decl),\n+\t\t\t      DECL_SIZE_UNIT (new_decl)))\n+    {\n+      /* Permit cases where we are declaring aggregates and at least one\n+\t of the decls is external and one of the decls has a size whereas\n+\t the other one does not.  This is perfectly legal in C:\n+\n+         struct s;\n+\t extern struct s x;\n+\n+\t void*\n+\t f (void)\n+\t {\n+\t   return &x;\n+\t }\n+\n+\t There is no way a compiler can tell the size of x.  So we cannot\n+\t assume that external aggreates have complete types.  */\n+\n+      if (!((TREE_CODE (TREE_TYPE (old_decl))\n+\t     == TREE_CODE (TREE_TYPE (new_decl)))\n+\t    && ((external_aggregate_decl_p (old_decl)\n+\t\t && DECL_SIZE (old_decl) == NULL_TREE)\n+\t\t|| (external_aggregate_decl_p (new_decl)\n+\t\t    && DECL_SIZE (new_decl) == NULL_TREE))))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t    \"size of %qD does not match original declaration\",\n+\t\t    new_decl);\n+\t  inform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t  \"previously declared here\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Report an error if user-specified alignments do not match.  */\n+  if ((DECL_USER_ALIGN (old_decl) && DECL_USER_ALIGN (new_decl))\n+      && DECL_ALIGN (old_decl) != DECL_ALIGN (new_decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t\"alignment of %qD does not match original declaration\",\n+\t\tnew_decl);\n+      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n+      return false;\n+    }\n+\n+  /* Do not compare the modes of the decls.  The type compatibility\n+     checks or the completing of types has properly dealt with all issues.  */\n+\n+  if (!lto_compatible_attributes_p (old_decl,\n+\t\t\t\t    DECL_ATTRIBUTES (old_decl),\n+\t\t\t\t    DECL_ATTRIBUTES (new_decl)))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t\"attributes applied to %qD are incompatible with original \"\n+\t\t\"declaration\", new_decl);\n+      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n+      return false;\n+    }\n+\n+  /* We do not require matches for:\n+\n+     - DECL_NAME\n+\n+       Only the name used in object files matters.\n+\n+     - DECL_CONTEXT  \n+\n+       An entity might be declared in a C++ namespace in one file and\n+       with a C identifier in another file.  \n+\n+     - TREE_PRIVATE, TREE_PROTECTED\n+\n+       Access control is the problem of the front end that created the\n+       object file.  \n+       \n+     Therefore, at this point we have decided to merge the declarations.  */\n+  return true;\n+}\n+\n+\n+/* Marks decl DECL as having resolution RESOLUTION. */\n+\n+static void\n+lto_symtab_set_resolution_and_file_data (tree decl,\n+\t\t\t\t\t ld_plugin_symbol_resolution_t\n+\t\t\t\t\t resolution,\n+\t\t\t\t\t struct lto_file_decl_data *file_data)\n+{\n+  lto_symtab_decl_t new_entry;\n+  void **slot;\n+\n+  gcc_assert (decl);\n+\n+  gcc_assert (TREE_PUBLIC (decl));\n+  gcc_assert (TREE_CODE (decl) != FUNCTION_DECL || !DECL_ABSTRACT (decl));\n+\n+  new_entry = GGC_CNEW (struct lto_symtab_decl_def);\n+  new_entry->base.node = decl;\n+  new_entry->resolution = resolution;\n+  new_entry->file_data = file_data;\n+  \n+  lto_symtab_maybe_init_hash_tables ();\n+  slot = htab_find_slot (lto_symtab_decls, new_entry, INSERT);\n+  gcc_assert (!*slot);\n+  *slot = new_entry;\n+}\n+\n+/* Get the lto_symtab_identifier_def struct associated with ID\n+   if there is one.  If there is none and INSERT_P is true, create\n+   a new one.  */\n+\n+static lto_symtab_identifier_t\n+lto_symtab_get_identifier (tree id, bool insert_p)\n+{\n+  struct lto_symtab_identifier_def temp;\n+  lto_symtab_identifier_t symtab_id;\n+  void **slot;\n+\n+  lto_symtab_maybe_init_hash_tables ();\n+  temp.base.node = id;\n+  slot = htab_find_slot (lto_symtab_identifiers, &temp,\n+\t\t\t insert_p ? INSERT : NO_INSERT);\n+  if (insert_p)\n+    {\n+      if (*slot)\n+\treturn (lto_symtab_identifier_t) *slot;\n+      else\n+\t{\n+\t  symtab_id = GGC_CNEW (struct lto_symtab_identifier_def);\n+\t  symtab_id->base.node = id;\n+\t  *slot = symtab_id;\n+\t  return symtab_id;\n+\t}\n+    }\n+  else\n+    return slot ? (lto_symtab_identifier_t) *slot : NULL;\n+}\n+\n+/* Return the DECL associated with an IDENTIFIER ID or return NULL_TREE\n+   if there is none.  */\n+\n+static tree\n+lto_symtab_get_identifier_decl (tree id)\n+{\n+  lto_symtab_identifier_t symtab_id = lto_symtab_get_identifier (id, false);\n+  return symtab_id ? symtab_id->decl : NULL_TREE;\n+}\n+\n+/* SET the associated DECL of an IDENTIFIER ID to be DECL.  */\n+\n+static void\n+lto_symtab_set_identifier_decl (tree id, tree decl)\n+{\n+  lto_symtab_identifier_t symtab_id = lto_symtab_get_identifier (id, true);\n+  symtab_id->decl = decl;\n+}\n+\n+/* Common helper function for merging variable and function declarations.\n+   NEW_DECL is the newly found decl. RESOLUTION is the decl's resolution\n+   provided by the linker. */\n+\n+static void\n+lto_symtab_merge_decl (tree new_decl,\n+\t\t       enum ld_plugin_symbol_resolution resolution,\n+\t\t       struct lto_file_decl_data *file_data)\n+{\n+  tree old_decl;\n+  tree name;\n+  ld_plugin_symbol_resolution_t old_resolution;\n+\n+  gcc_assert (TREE_CODE (new_decl) == VAR_DECL\n+\t      || TREE_CODE (new_decl) == FUNCTION_DECL);\n+\n+  gcc_assert (TREE_PUBLIC (new_decl));\n+\n+  gcc_assert (DECL_LANG_SPECIFIC (new_decl) == NULL);\n+\n+  /* Check that declarations reaching this function do not have\n+     properties inconsistent with having external linkage.  If any of\n+     these asertions fail, then the object file reader has failed to\n+     detect these cases and issue appropriate error messages.  */\n+  if (TREE_CODE (new_decl) == VAR_DECL)\n+    gcc_assert (!(DECL_EXTERNAL (new_decl) && DECL_INITIAL (new_decl)));\n+\n+  /* Remember the resolution of this symbol. */\n+  lto_symtab_set_resolution_and_file_data (new_decl, resolution, file_data);\n+\n+  /* Ensure DECL_ASSEMBLER_NAME will not set assembler name.  */\n+  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (new_decl));\n+\n+  /* Retrieve the previous declaration.  */\n+  name = DECL_ASSEMBLER_NAME (new_decl);\n+  old_decl = lto_symtab_get_identifier_decl (name);\n+\n+  /* If there was no previous declaration, then there is nothing to\n+     merge.  */\n+  if (!old_decl)\n+    {\n+      lto_symtab_set_identifier_decl (name, new_decl);\n+      VEC_safe_push (tree, gc, lto_global_var_decls, new_decl);\n+      return;\n+    }\n+\n+  /* Give ODR violation errors.  */\n+  old_resolution = lto_symtab_get_resolution (old_decl);\n+  if (resolution == LDPR_PREVAILING_DEF\n+      || resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    {\n+      if ((old_resolution == LDPR_PREVAILING_DEF\n+\t   || old_resolution == LDPR_PREVAILING_DEF_IRONLY)\n+\t  && (old_resolution != resolution || flag_no_common))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n+\t\t    \"%qD has already been defined\", new_decl);\n+\t  inform (DECL_SOURCE_LOCATION (old_decl),\n+\t\t  \"previously defined here\");\n+\t  return;\n+\t}\n+    }\n+\n+  /* The linker may ask us to combine two incompatible symbols.\n+     Find a decl we can merge with or chain it in the list of decls\n+     for that symbol.  */\n+  while (old_decl\n+\t && !lto_symtab_compatible (old_decl, new_decl))\n+    old_decl = (tree) DECL_LANG_SPECIFIC (old_decl);\n+  if (!old_decl)\n+    {\n+      old_decl = lto_symtab_get_identifier_decl (name);\n+      while (DECL_LANG_SPECIFIC (old_decl) != NULL)\n+\told_decl = (tree) DECL_LANG_SPECIFIC (old_decl);\n+      DECL_LANG_SPECIFIC (old_decl) = (struct lang_decl *) new_decl;\n+      return;\n+    }\n+\n+  /* Merge decl state in both directions, we may still end up using\n+     the new decl.  */\n+  TREE_ADDRESSABLE (old_decl) |= TREE_ADDRESSABLE (new_decl);\n+  TREE_ADDRESSABLE (new_decl) |= TREE_ADDRESSABLE (old_decl);\n+\n+  gcc_assert (resolution != LDPR_UNKNOWN\n+\t      && resolution != LDPR_UNDEF\n+\t      && old_resolution != LDPR_UNKNOWN\n+\t      && old_resolution != LDPR_UNDEF);\n+\n+  if (resolution == LDPR_PREVAILING_DEF\n+      || resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    {\n+      tree decl;\n+      gcc_assert (old_resolution == LDPR_PREEMPTED_IR\n+\t\t  || old_resolution ==  LDPR_RESOLVED_IR\n+\t\t  || (old_resolution == resolution && !flag_no_common));\n+      DECL_LANG_SPECIFIC (new_decl) = DECL_LANG_SPECIFIC (old_decl);\n+      DECL_LANG_SPECIFIC (old_decl) = NULL;\n+      decl = lto_symtab_get_identifier_decl (name);\n+      if (decl == old_decl)\n+\t{\n+\t  lto_symtab_set_identifier_decl (name, new_decl);\n+\t  return;\n+\t}\n+      while ((tree) DECL_LANG_SPECIFIC (decl) != old_decl)\n+\tdecl = (tree) DECL_LANG_SPECIFIC (decl);\n+      DECL_LANG_SPECIFIC (decl) = (struct lang_decl *) new_decl;\n+      return;\n+    }\n+\n+  if (resolution == LDPR_PREEMPTED_REG\n+      || resolution == LDPR_RESOLVED_EXEC\n+      || resolution == LDPR_RESOLVED_DYN)\n+    gcc_assert (old_resolution == LDPR_PREEMPTED_REG\n+\t\t|| old_resolution == LDPR_RESOLVED_EXEC\n+\t\t|| old_resolution == LDPR_RESOLVED_DYN);\n+\n+  if (resolution == LDPR_PREEMPTED_IR\n+      || resolution == LDPR_RESOLVED_IR)\n+    gcc_assert (old_resolution == LDPR_PREVAILING_DEF\n+\t\t|| old_resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t|| old_resolution == LDPR_PREEMPTED_IR\n+\t\t|| old_resolution == LDPR_RESOLVED_IR);\n+\n+  return;\n+}\n+\n+\n+/* Merge the VAR_DECL NEW_VAR with resolution RESOLUTION with any previous\n+   declaration with the same name. */\n+\n+void\n+lto_symtab_merge_var (tree new_var, enum ld_plugin_symbol_resolution resolution)\n+{\n+  lto_symtab_merge_decl (new_var, resolution, NULL);\n+}\n+\n+/* Merge the FUNCTION_DECL NEW_FN with resolution RESOLUTION with any previous\n+   declaration with the same name. */\n+\n+void\n+lto_symtab_merge_fn (tree new_fn, enum ld_plugin_symbol_resolution resolution,\n+\t\t     struct lto_file_decl_data *file_data)\n+{\n+  lto_symtab_merge_decl (new_fn, resolution, file_data);\n+}\n+\n+/* Given the decl DECL, return the prevailing decl with the same name. */\n+\n+tree\n+lto_symtab_prevailing_decl (tree decl)\n+{\n+  tree ret;\n+  gcc_assert (decl);\n+\n+  /* Builtins and local symbols are their own prevailing decl.  */\n+  if (!TREE_PUBLIC (decl) || is_builtin_fn (decl))\n+    return decl;\n+\n+  /* DECL_ABSTRACTs are their own prevailng decl.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT (decl))\n+    return decl;\n+\n+  /* Ensure DECL_ASSEMBLER_NAME will not set assembler name.  */\n+  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n+\n+  /* Walk through the list of candidates and return the one we merged to.  */\n+  ret = lto_symtab_get_identifier_decl (DECL_ASSEMBLER_NAME (decl));\n+  if (!ret\n+      || DECL_LANG_SPECIFIC (ret) == NULL)\n+    return ret;\n+\n+  /* If there are multiple decls to choose from find the one we merged\n+     with and return that.  */\n+  while (ret)\n+    {\n+      if (gimple_types_compatible_p (TREE_TYPE (decl), TREE_TYPE (ret)))\n+\treturn ret;\n+\n+      ret = (tree) DECL_LANG_SPECIFIC (ret);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the hash table entry of DECL. */\n+\n+static struct lto_symtab_decl_def *\n+lto_symtab_get_symtab_def (tree decl)\n+{\n+  struct lto_symtab_decl_def temp, *symtab_decl;\n+  void **slot;\n+\n+  gcc_assert (decl);\n+\n+  lto_symtab_maybe_init_hash_tables ();\n+  temp.base.node = decl;\n+  slot = htab_find_slot (lto_symtab_decls, &temp, NO_INSERT);\n+  gcc_assert (slot && *slot);\n+  symtab_decl = (struct lto_symtab_decl_def*) *slot;\n+  return symtab_decl;\n+}\n+\n+/* Return the resolution of DECL. */\n+\n+enum ld_plugin_symbol_resolution\n+lto_symtab_get_resolution (tree decl)\n+{\n+  gcc_assert (decl);\n+\n+  if (!TREE_PUBLIC (decl) || is_builtin_fn (decl))\n+    return LDPR_PREVAILING_DEF_IRONLY;\n+\n+  /* FIXME lto: There should be no DECL_ABSTRACT in the middle end. */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT (decl))\n+    return LDPR_PREVAILING_DEF_IRONLY;\n+\n+  return lto_symtab_get_symtab_def (decl)->resolution;\n+}\n+\n+/* Return the file of DECL. */\n+\n+struct lto_file_decl_data *\n+lto_symtab_get_file_data (tree decl)\n+{\n+  return lto_symtab_get_symtab_def (decl)->file_data;\n+}\n+\n+/* Remove any storage used to store resolution of DECL.  */\n+\n+void\n+lto_symtab_clear_resolution (tree decl)\n+{\n+  struct lto_symtab_decl_def temp;\n+  gcc_assert (decl);\n+\n+  if (!TREE_PUBLIC (decl))\n+    return;\n+\n+  /* LTO FIXME: There should be no DECL_ABSTRACT in the middle end. */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT (decl))\n+    return;\n+\n+  lto_symtab_maybe_init_hash_tables ();\n+  temp.base.node = decl;\n+  htab_remove_elt (lto_symtab_decls, &temp);\n+}\n+\n+#include \"gt-lto-symtab.h\""}, {"sha": "4411588f2f382ad430acba18ce71aa220c7fcf94", "filename": "gcc/lto-wpa-fixup.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-wpa-fixup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-wpa-fixup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wpa-fixup.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,281 @@\n+/* Write and read any fix-up information generated by the WPA mode.\n+\n+   Copyright 2009 Free Software Foundation, Inc.\n+   Contributed by Doug Kwan <dougkwan@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"vec.h\"\n+#include \"bitmap.h\"\n+#include \"timevar.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"lto-streamer.h\"\n+\n+/* LTO fix-up.\n+\n+   In WPA mode, LTO cannot access function bodies.  Some modifications in\n+   IR require additional updates in function bodies,  which are not possible\n+   in WPA mode.  So we write out information about these modifications for\n+   LTRANS to fix up the function bodies accordingly.  */\n+\n+/* The vectors records function DECLs having multiple copies with different\n+   exception throwing attributes.  We do not mark a DECL if all copies of it\n+   have the same exception throwing attribute. */\n+static bitmap lto_nothrow_fndecls;\n+\n+/* We need to fix up GIMPLE bodies due to changes in exception setting.\n+   Consider this example:\n+\n+   a.h:\n+   class a {\n+   public:\n+     a();\n+     ~a();\n+   };\n+\n+   main.cc:\n+   #include \"a.h\"\n+\n+   int\n+   main (int argc, char **argv)\n+   {\n+     a x;\n+     return 0;\n+   }\n+\n+   a.cc:\n+   #include \"a.h\"\n+   a::a() {}\n+   a::~a() {}\n+   \n+   When main.cc is compiled, gcc only sees the constructor declaration, so\n+   the constructor and hence the call to it are marked as exception throwing.\n+   When a.cc is compiled, the body of the constructor is available and is\n+   obviously not exception throwing. Thus DECL of a::a in a.o has the NOTHROW\n+   attribute.  When LTO runs, two DECLs of a::a with different exception\n+   attributes are merged.  We want the merged DECL to be not exception\n+   throwing for better generated code.  To do that, we need to fix up any\n+   function calls that have been marked as exception throwing.  */\n+\n+/* Fix up all the call statements whose target fndecls might have changed\n+   to NOTHROW.   Note that this problem is not WPA specific.  We can also\n+   run into this problem in normal LTO with multiple input files.  */\n+\n+void\n+lto_fixup_nothrow_decls (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+  struct function *caller_function;\n+  gimple call_stmt;\n+\n+  /* Quit if we are in WPA mode or have not marked any DECLs.  */\n+  if (flag_wpa || !lto_nothrow_fndecls)\n+    return;\n+\n+  /* For each node that has been marked, go over all call edges to it.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (node->decl)))\n+      {\n+\tgcc_assert (TREE_NOTHROW (node->decl));\n+\tfor (edge = node->callers; edge; edge = edge->next_caller)\n+\t  {\n+\t    caller_function = DECL_STRUCT_FUNCTION (edge->caller->decl);\n+\t    call_stmt = edge->call_stmt;\n+\t    gcc_assert (call_stmt);\n+\t    if (lookup_stmt_eh_lp_fn (caller_function, call_stmt) != 0)\n+\t      remove_stmt_from_eh_lp_fn (caller_function, call_stmt);\n+\t  } \n+      }\n+}\n+\n+/* Mark FNDECL as becoming not exception throwing.  */\n+\n+void\n+lto_mark_nothrow_fndecl (tree fndecl)\n+{\n+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+  if (!lto_nothrow_fndecls)\n+    lto_nothrow_fndecls = lto_bitmap_alloc ();\n+    \n+  bitmap_set_bit (lto_nothrow_fndecls, DECL_UID (fndecl));\n+}\n+\n+/* Write out fix-up information.  Currently the only WPA fix-up\n+   information is the list of DECLs marked as not exception throwing. SET\n+   is a cgraph node set whose fix-up information is to be written.  */\n+\n+static void\n+lto_output_wpa_fixup (cgraph_node_set set)\n+{\n+  struct lto_simple_output_block *ob;\n+  cgraph_node_set_iterator csi;\n+  tree fndecl;\n+  bitmap seen_decls;\n+  VEC(tree, heap) *decls = NULL;\n+  unsigned HOST_WIDE_INT i, count;\n+\n+  ob = lto_create_simple_output_block (LTO_section_wpa_fixup);\n+\n+  /* Accumulate the DECLs to be written out.  Since we do not want\n+     duplicates, we need to use a bitmap and a vector to save the\n+     DECLs we want.  Note that we need to check if lto_nothrow_fndecls\n+     is NULL.  This happens when no DECL has been marked.  */\n+  seen_decls = lto_bitmap_alloc ();\n+  if (lto_nothrow_fndecls)\n+    for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+      {\n+\tstruct cgraph_edge *e;\n+\tstruct cgraph_node *n;\n+\t\n+\tn = csi_node (csi);\n+\tfndecl = n->decl;\n+\n+\t/* Check if the N's function is in the set of nothrow functions.  */\n+\tif (!bitmap_bit_p (seen_decls, DECL_UID (fndecl)))\n+\t  {\n+\t    bitmap_set_bit (seen_decls, (DECL_UID (fndecl)));\n+\t    if (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (fndecl)))\n+\t      VEC_safe_push (tree, heap, decls, fndecl);\n+\t  }\n+\n+\t/* Now check the callees and also add them if they are nothrow.  This\n+\t   is needed because node N may end up in a different partition than\n+\t   its callees.  In which case, when the file holding N is compiled,\n+\t   the calls it makes to nothrow functions will not be fixed up,\n+\t   causing verification issues.  */\n+\tfor (e = n->callees; e; e = e->next_callee)\n+\t  {\n+\t    fndecl = e->callee->decl;\n+\t    if (!bitmap_bit_p (seen_decls, DECL_UID (fndecl)))\n+\t      {\n+\t\tbitmap_set_bit (seen_decls, (DECL_UID (fndecl)));\n+\t\tif (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (fndecl)))\n+\t\t  VEC_safe_push (tree, heap, decls, fndecl);\n+\t      }\n+\t  }\n+      }\n+\n+  /* Write out number of DECLs, followed by the DECLs.  */\n+  count = VEC_length (tree, decls); \n+  lto_output_uleb128_stream (ob->main_stream, count);\n+  for (i = 0; i < count; i++)\n+    {\n+      fndecl = VEC_index (tree, decls, i);\n+      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, fndecl);\n+    }\n+\n+  /* Release resources.  */\n+  lto_destroy_simple_output_block (ob);\n+  VEC_free(tree, heap, decls);\n+  lto_bitmap_free (seen_decls);\n+}\n+\n+/* Read in WPA fix-up information from one file. FILE_DATA points to\n+   DECL information of the file where as IB is the input block for the\n+   WPA fix-up section.  */\n+\n+static void\n+lto_input_wpa_fixup_1 (struct lto_file_decl_data *file_data,\n+\t\t   struct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDE_INT i, count, decl_index;\n+  tree fndecl;\n+\n+  count = lto_input_uleb128 (ib);\n+  for (i = 0; i < count; i++)\n+    {\n+      decl_index = lto_input_uleb128 (ib);\n+      fndecl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+      lto_mark_nothrow_fndecl (fndecl);\n+    }\n+}\n+\n+/* Read in WPA fix-up information. */\n+\n+static void\n+lto_input_wpa_fixup (void)\n+{\n+  struct lto_file_decl_data ** file_data_vec\n+    = lto_get_file_decl_data ();\n+  struct lto_file_decl_data * file_data;\n+  int i = 0;\n+\n+  /* Fix up information is only used in LTRANS mode.  */\n+  if (!flag_ltrans)\n+    return;\n+\n+  while ((file_data = file_data_vec[i++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data, LTO_section_wpa_fixup,\n+\t\t\t\t\t &data, &len);\n+\n+      lto_input_wpa_fixup_1 (file_data, ib);\n+      lto_destroy_simple_input_block (file_data, LTO_section_wpa_fixup, ib,\n+\t\t\t\t      data, len);\n+    }\n+}\n+\n+/* Gate function for all lto streaming passes.  */\n+\n+static bool\n+gate_wpa_fixup (void)\n+{\n+  return (flag_wpa || flag_ltrans) && gate_lto_out ();\n+}\n+\n+struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup =\n+{\n+ {\n+  IPA_PASS,\n+  \"lto_wpa_fixup\",\t\t\t/* name */\n+  gate_wpa_fixup,\t\t        /* gate */\n+  NULL,\t\t                        /* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_WHOPR_WPA_FIXUP,\t\t        /* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,            \t\t\t/* todo_flags_start */\n+  TODO_dump_func                        /* todo_flags_finish */\n+ },\n+ NULL,\t\t                        /* generate_summary */\n+ lto_output_wpa_fixup,\t\t\t/* write_summary */\n+ lto_input_wpa_fixup,\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n+};\n+"}, {"sha": "228a0a4bb10af09b570761a28ed3d715a37df511", "filename": "gcc/lto-wrapper.c", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792", "patch": "@@ -0,0 +1,378 @@\n+/* Wrapper to call lto.  Used by collect2 and the linker plugin.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   Factored out of collect2 by Rafael Espindola <espindola@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This program is passed a gcc, a list of gcc arguments and a list of\n+   object files containing IL. It scans the argument list to check if\n+   we are in whopr mode or not modifies the arguments and needed and\n+   prints a list of output files on stdout.\n+\n+   Example:\n+\n+   $ lto-wrapper gcc/xgcc -B gcc a.o b.o -o test -flto\n+\n+   The above will print something like\n+   /tmp/ccwbQ8B2.lto.o\n+\n+   If -fwhopr is used instead, more than one file might be produced\n+   ./ccXj2DTk.lto.ltrans.o\n+   ./ccCJuXGv.lto.ltrans.o\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"intl.h\"\n+#include \"libiberty.h\"\n+\n+int debug;\t\t\t\t/* true if -debug */\n+\n+enum lto_mode_d {\n+  LTO_MODE_NONE,\t\t\t/* Not doing LTO. */\n+  LTO_MODE_LTO,\t\t\t\t/* Normal LTO. */\n+  LTO_MODE_WHOPR\t\t\t/* WHOPR. */\n+};\n+\n+/* Current LTO mode.  */\n+static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n+\n+/* Just die. CMSGID is the error message. */\n+\n+static void __attribute__ ((format (printf, 1, 2)))\n+fatal (const char * cmsgid, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, cmsgid);\n+  fprintf (stderr, \"lto-wrapper: \");\n+  vfprintf (stderr, _(cmsgid), ap);\n+  fprintf (stderr, \"\\n\");\n+  va_end (ap);\n+\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+\n+/* Die when sys call fails. CMSGID is the error message.  */\n+\n+static void __attribute__ ((format (printf, 1, 2)))\n+fatal_perror (const char *cmsgid, ...)\n+{\n+  int e = errno;\n+  va_list ap;\n+\n+  va_start (ap, cmsgid);\n+  fprintf (stderr, \"lto-wrapper: \");\n+  vfprintf (stderr, _(cmsgid), ap);\n+  fprintf (stderr, \": %s\\n\", xstrerror (e));\n+  va_end (ap);\n+\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+\n+/* Execute a program, and wait for the reply. ARGV are the arguments. The\n+   last one must be NULL. */\n+\n+static struct pex_obj *\n+collect_execute (char **argv)\n+{\n+  struct pex_obj *pex;\n+  const char *errmsg;\n+  int err;\n+\n+  if (debug)\n+    {\n+      char **p_argv;\n+      const char *str;\n+\n+      for (p_argv = argv; (str = *p_argv) != (char *) 0; p_argv++)\n+\tfprintf (stderr, \" %s\", str);\n+\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  fflush (stdout);\n+  fflush (stderr);\n+\n+  pex = pex_init (0, \"lto-wrapper\", NULL);\n+  if (pex == NULL)\n+    fatal_perror (\"pex_init failed\");\n+\n+  errmsg = pex_run (pex, PEX_LAST | PEX_SEARCH, argv[0], argv, NULL,\n+\t\t    NULL, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err != 0)\n+\t{\n+\t  errno = err;\n+\t  fatal_perror (errmsg);\n+\t}\n+      else\n+\tfatal (errmsg);\n+    }\n+\n+  return pex;\n+}\n+\n+\n+/* Wait for a process to finish, and exit if a nonzero status is found.\n+   PROG is the program name. PEX is the process we should wait for. */\n+\n+static int\n+collect_wait (const char *prog, struct pex_obj *pex)\n+{\n+  int status;\n+\n+  if (!pex_get_status (pex, 1, &status))\n+    fatal_perror (\"can't get program status\");\n+  pex_free (pex);\n+\n+  if (status)\n+    {\n+      if (WIFSIGNALED (status))\n+\t{\n+\t  int sig = WTERMSIG (status);\n+\t  if (WCOREDUMP (status))\n+\t    fatal (\"%s terminated with signal %d [%s], core dumped\",\n+\t\t   prog, sig, strsignal (sig));\n+\t  else\n+\t    fatal (\"%s terminated with signal %d [%s]\",\n+\t\t   prog, sig, strsignal (sig));\n+\t}\n+\n+      if (WIFEXITED (status))\n+\tfatal (\"%s returned %d exit status\", prog, WEXITSTATUS (status));\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Unlink a temporary LTRANS file unless requested otherwise.  */\n+\n+static void\n+maybe_unlink_file (const char *file)\n+{\n+  if (! debug)\n+    {\n+      if (unlink_if_ordinary (file))\n+\tfatal_perror (\"deleting LTRANS file %s\", file);\n+    }\n+  else\n+    fprintf (stderr, \"[Leaving LTRANS %s]\\n\", file);\n+}\n+\n+\n+/* Execute program ARGV[0] with arguments ARGV. Wait for it to finish.  */\n+\n+static void\n+fork_execute (char **argv)\n+{\n+  struct pex_obj *pex;\n+  char *new_argv[3];\n+  char *args_name = make_temp_file (\".args\");\n+  char *at_args = concat (\"@\", args_name, NULL);\n+  FILE *args = fopen (args_name, \"w\");\n+  int status;\n+\n+  if (args == NULL)\n+    fatal (\"failed to open %s\", args_name);\n+\n+  status = writeargv (&argv[1], args);\n+\n+  if (status)\n+    fatal (\"could not write to temporary file %s\",  args_name);\n+\n+  fclose (args);\n+\n+  new_argv[0] = argv[0];\n+  new_argv[1] = at_args;\n+  new_argv[2] = NULL;\n+\n+  pex = collect_execute (new_argv);\n+  collect_wait (new_argv[0], pex);\n+\n+  maybe_unlink_file (args_name);\n+  free (args_name);\n+  free (at_args);\n+}\n+\n+\n+/* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n+\n+static void\n+run_gcc (unsigned argc, char *argv[])\n+{\n+  unsigned i;\n+  unsigned new_argc = argc;\n+  const char **new_argv;\n+  const char **argv_ptr;\n+  char *ltrans_output_file = NULL;\n+  char *flto_out = NULL;\n+  char *list_option_full = NULL;\n+\n+  new_argc += 8;\n+  new_argv = (const char **) xcalloc (sizeof (char *), new_argc);\n+\n+  argv_ptr = new_argv;\n+\n+  *argv_ptr++ = argv[0];\n+  *argv_ptr++ = \"-combine\";\n+  *argv_ptr++ = \"-x\";\n+  *argv_ptr++ = \"lto\";\n+  *argv_ptr++ = \"-c\";\n+  if (lto_mode == LTO_MODE_LTO)\n+    {\n+      flto_out = make_temp_file (\".lto.o\");\n+      *argv_ptr++ = \"-o\";\n+      *argv_ptr++ = flto_out;\n+    }\n+  else if (lto_mode == LTO_MODE_WHOPR)\n+    {\n+      const char *list_option = \"-fltrans-output-list=\";\n+      size_t list_option_len = strlen (list_option);\n+      char *tmp;\n+\n+      ltrans_output_file = make_temp_file (\".ltrans.out\");\n+      list_option_full = (char *) xmalloc (sizeof (char) *\n+\t\t         (strlen (ltrans_output_file) + list_option_len + 1));\n+      tmp = list_option_full;\n+\n+      *argv_ptr++ = tmp;\n+      strcpy (tmp, list_option);\n+      tmp += list_option_len;\n+      strcpy (tmp, ltrans_output_file);\n+\n+      *argv_ptr++ = \"-fwpa\";\n+    }\n+  else\n+    fatal (\"invalid LTO mode\");\n+\n+  /* Add inherited GCC options to the LTO back end command line.\n+     Filter out some obviously inappropriate options that will\n+     conflict with  the options that we force above.  We pass\n+     all of the remaining options on to LTO, and let it complain\n+     about any it doesn't like. Note that we invoke LTO via the\n+     `gcc' driver, so the usual option processing takes place.\n+     Except for `-flto' and `-fwhopr', we should only filter options that\n+     are meaningful to `ld', lest an option go silently unclaimed.  */\n+  for (i = 1; i < argc; i++)\n+    {\n+      const char *s = argv[i];\n+\n+      if (strcmp (s, \"-flto\") == 0 || strcmp (s, \"-fwhopr\") == 0)\n+\t/* We've handled this LTO option, don't pass it on.  */\n+\t;\n+      else if (*s == '-' && s[1] == 'o')\n+\t{\n+\t  /* Drop `-o' and its filename argument.  We will use a\n+\t     temporary file for the LTO output.  The `-o' option\n+\t     will be interpreted by the linker.  */\n+\t  if (s[2] == '\\0')\n+\t    i++;\n+\t}\n+      else\n+\t/* Pass the option or argument to LTO.  */\n+\t*argv_ptr++ = s;\n+    }\n+\n+  *argv_ptr = NULL;\n+\n+  fork_execute (CONST_CAST (char **, new_argv));\n+  free (new_argv);\n+  new_argv = NULL;\n+\n+  if (lto_mode == LTO_MODE_LTO)\n+    {\n+      printf(\"%s\\n\", flto_out);\n+      free (flto_out);\n+      flto_out = NULL;\n+    }\n+  else if (lto_mode == LTO_MODE_WHOPR)\n+    {\n+      FILE *stream = fopen (ltrans_output_file, \"r\");\n+      int c;\n+\n+      if (!stream)\n+\tfatal_perror (\"fopen: %s\", ltrans_output_file);\n+\n+      while ((c = getc (stream)) != EOF)\n+\tputc (c, stdout);\n+      fclose (stream);\n+      maybe_unlink_file (ltrans_output_file);\n+      free (ltrans_output_file);\n+      free (list_option_full);\n+    }\n+  else\n+    fatal (\"invalid LTO mode\");\n+}\n+\n+\n+/* Parse the command line. Copy any unused argument to GCC_ARGV. ARGC is the\n+   number of arguments. ARGV contains the arguments. */\n+\n+static int\n+process_args (int argc, char *argv[], char *gcc_argv[])\n+{\n+  int i;\n+  int j = 0;\n+\n+  for (i = 1; i < argc; i ++)\n+    {\n+      if (! strcmp (argv[i], \"-debug\"))\n+\tdebug = 1;\n+      else if (! strcmp (argv[i], \"-flto\"))\n+\tlto_mode = LTO_MODE_LTO;\n+      else if (! strcmp (argv[i], \"-fwhopr\"))\n+\tlto_mode = LTO_MODE_WHOPR;\n+      else\n+\t{\n+\t  gcc_argv[j] = argv[i];\n+\t  j++;\n+\t}\n+    }\n+\n+  return j;\n+}\n+\n+\n+/* Entry point.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  char **gcc_argv;\n+  int gcc_argc;\n+\n+  gcc_init_libintl ();\n+\n+  /* We may be called with all the arguments stored in some file and\n+     passed with @file.  Expand them into argv before processing.  */\n+  expandargv (&argc, &argv);\n+  gcc_argv = (char **) xcalloc (sizeof (char *), argc);\n+  gcc_argc = process_args (argc, argv, gcc_argv);\n+  run_gcc (gcc_argc, gcc_argv);\n+  free (gcc_argv);\n+\n+  return 0;\n+}"}, {"sha": "3ccce8fb5cf939dbb3d48659b340f87933c299bc", "filename": "gcc/lto/ChangeLog", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1dcaace1adee986fc1704ab380ca800d49eb019b", "filename": "gcc/lto/Make-lang.in", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b54ec491e1215924bbdd8ac81bc84678e6141e7a", "filename": "gcc/lto/common.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fcommon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fcommon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Fcommon.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e82184795ba75efb29357b300c32f7bce3b098a0", "filename": "gcc/lto/common.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Fcommon.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "aa84db1e79f3ff607562dc59f4741d01bf74c9b4", "filename": "gcc/lto/config-lang.in", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Fconfig-lang.in?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "cbcb19b797cf3d862435466e0d11bf2118117224", "filename": "gcc/lto/lang-specs.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flang-specs.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f383d7ce18a630404411ca833ec3e82666e7dc0a", "filename": "gcc/lto/lang.opt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flang.opt?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f678348a86ff4d43e6253a706bb1f564d5c486e3", "filename": "gcc/lto/lto-elf.c", "status": "added", "additions": 674, "deletions": 0, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-elf.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f5e83de75f5679b6d29a286dcb5dac60675a8558", "filename": "gcc/lto/lto-lang.c", "status": "added", "additions": 1188, "deletions": 0, "changes": 1188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "671fa4ade26d8d54ca8ccb770d6d4143f1ac4c57", "filename": "gcc/lto/lto-tree.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-tree.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "056d249a161c76f2f4e8a1786cd8101a554ae25b", "filename": "gcc/lto/lto.c", "status": "added", "additions": 2067, "deletions": 0, "changes": 2067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "cdd1e06de931c2f86d811e81852ffe40934f7682", "filename": "gcc/lto/lto.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Flto%2Flto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "fee1c6b3065c8b9073bb54fad98d82213bc6cb8e", "filename": "gcc/opts.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e3fd7a8454d1074b32a23e48d9b716d45e3178a8", "filename": "gcc/passes.c", "status": "modified", "additions": 249, "deletions": 37, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "699be089ef0a600addf073cab630aa0552a63bc4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7c50675dbe0d76da40f193b9490b8103491be64f", "filename": "gcc/testsuite/g++.dg/20090107-1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9dff0f87af38fbccb3f0c5a49d12cba986759526", "filename": "gcc/testsuite/g++.dg/20090121-1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "fe308a542107904f74d99f0f4671caa033dd95c7", "filename": "gcc/testsuite/g++.dg/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2642da12301e191790bf75873249cad538303da1", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3f371257e577f3e6de4a3919c3a1717d104436dd", "filename": "gcc/testsuite/g++.dg/ipa/20090113-1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2F20090113-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2F20090113-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2F20090113-1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "55ae8c9ec2c10c30413c703eeb8db1efb1b57206", "filename": "gcc/testsuite/g++.dg/lto/20080709_0.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080709_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080709_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080709_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0890cf66d3bec5be9e176c94fb7126015459bdee", "filename": "gcc/testsuite/g++.dg/lto/20080829_0.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080829_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080829_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080829_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0161a00be7f11903aa43f91faaa7d9b4422f2301", "filename": "gcc/testsuite/g++.dg/lto/20080904_0.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080904_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080904_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080904_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9a4552310d936547330cdb89137c3afe86595996", "filename": "gcc/testsuite/g++.dg/lto/20080907_0.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080907_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080907_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080907_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8b761c0844caa4dd301ef4b148643069a536e087", "filename": "gcc/testsuite/g++.dg/lto/20080908-1_0.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7042b3d08d63df61b19af24225f0a4ef98a2885a", "filename": "gcc/testsuite/g++.dg/lto/20080908-2_0.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b7e0e1b0271671e93b779b331e4aa1bba9421284", "filename": "gcc/testsuite/g++.dg/lto/20080908-3_0.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-3_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-3_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080908-3_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "245ca58f3084164c84d3e074800cd1959e363ea8", "filename": "gcc/testsuite/g++.dg/lto/20080909-1_0.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080909-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080909-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080909-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "48e9e5d15cbc815a83b8a3d75e4a9cdc59d2e64e", "filename": "gcc/testsuite/g++.dg/lto/20080910-1_0.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080910-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080910-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080910-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ebead90e03a9385e797c44400d7134896c7fb722", "filename": "gcc/testsuite/g++.dg/lto/20080912-1_0.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7b3039fbf8de460d92fc3494b48f113337787f7a", "filename": "gcc/testsuite/g++.dg/lto/20080912_0.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080912_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3789765a9641034da36ab140692d726182a35e95", "filename": "gcc/testsuite/g++.dg/lto/20080915_0.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080915_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080915_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080915_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3c900cd43b544d9a236e0b172d4b0bebcd05fc7b", "filename": "gcc/testsuite/g++.dg/lto/20080916_0.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080916_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080916_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080916_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2f4f33bd0e9ac7c6c402b4035dc826bc0c269bb0", "filename": "gcc/testsuite/g++.dg/lto/20080917_0.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080917_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080917_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080917_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b1e381351bb4ee230c5b04c0e0f31a1ca274284a", "filename": "gcc/testsuite/g++.dg/lto/20080924_0.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080924_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080924_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080924_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d6a7bbffc701735faacbd14f5cef1614f9d0ebe7", "filename": "gcc/testsuite/g++.dg/lto/20080926_0.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080926_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080926_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20080926_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "258265a4fe13769177ee0270980668a557d241cc", "filename": "gcc/testsuite/g++.dg/lto/20081008_0.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081008_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081008_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081008_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bccd2ad7b6897acf887b3529e1ed157e62b48ba8", "filename": "gcc/testsuite/g++.dg/lto/20081022.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "219f92d6a9607f8794e560132a1a5ab940cccc4f", "filename": "gcc/testsuite/g++.dg/lto/20081022_0.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "94c5aecfd6b6bc6fd4321eeb31877ba41ea64f43", "filename": "gcc/testsuite/g++.dg/lto/20081022_1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081022_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ab3fc36f386c1edf853923034edf83e4634f54a6", "filename": "gcc/testsuite/g++.dg/lto/20081023_0.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081023_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081023_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081023_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "243f0ed72465bf30c915dcd9b7b03bc126c2d486", "filename": "gcc/testsuite/g++.dg/lto/20081109-1_0.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "dc43286bf3626a57287ff365521f270f1c24e085", "filename": "gcc/testsuite/g++.dg/lto/20081109-2_0.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "93cfc67fff2555962a1b1d48d56da5f2093f002a", "filename": "gcc/testsuite/g++.dg/lto/20081109_0.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3395e13550173aab2e89f1b97235602ec35971ea", "filename": "gcc/testsuite/g++.dg/lto/20081109_1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081109_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "99e024f9e516d1e1b1b635cc23297410087bf310", "filename": "gcc/testsuite/g++.dg/lto/20081118-1_0.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "fc654fe9199e0a5067be0e537559ab08a06c9927", "filename": "gcc/testsuite/g++.dg/lto/20081118-1_1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "cbac06a474707999607eed2df39ecf8fde6e6f4d", "filename": "gcc/testsuite/g++.dg/lto/20081118_0.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b9e56a48b9be82a896e17e7b66902123f960a620", "filename": "gcc/testsuite/g++.dg/lto/20081118_1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081118_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "be193581dcd6ce132b6a5547ca020d1519cb6f58", "filename": "gcc/testsuite/g++.dg/lto/20081119-1.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d38fca3d44dcc954d3754112fe8aad9751151218", "filename": "gcc/testsuite/g++.dg/lto/20081119-1_0.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c2ba78d6ed7b823deb1c3c520e37eb059248e64c", "filename": "gcc/testsuite/g++.dg/lto/20081119-1_1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c77a4309811c12562ab44aa14aa491865206c893", "filename": "gcc/testsuite/g++.dg/lto/20081119_0.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "71a2a5c02428e3127cedebfb11363064de61a5fb", "filename": "gcc/testsuite/g++.dg/lto/20081119_1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081119_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3cb97538945f84003110640319096f3afced0e03", "filename": "gcc/testsuite/g++.dg/lto/20081120-1_0.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e7e24a58b760802d01ac87fd8baccf3d72a2dc55", "filename": "gcc/testsuite/g++.dg/lto/20081120-1_1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d4e4cd43cc58abab4d41d0d84f56622b9fce9590", "filename": "gcc/testsuite/g++.dg/lto/20081120-2_0.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "242d50a41ce6da79e643502abf66bded3a949372", "filename": "gcc/testsuite/g++.dg/lto/20081120-2_1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081120-2_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2b182a95e42de8696c8c6249f6d66c6227e0a420", "filename": "gcc/testsuite/g++.dg/lto/20081123_0.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "aef512e8e4d3c45e8349ea61bdc77ae3e935a966", "filename": "gcc/testsuite/g++.dg/lto/20081123_1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081123_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bc470040a67299eddce85675f372fd637f57e7f4", "filename": "gcc/testsuite/g++.dg/lto/20081125.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ade9744946d1ce8c4637e7f4563cac08c47ac89c", "filename": "gcc/testsuite/g++.dg/lto/20081125_0.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d52b9edcada15eda797f6691fa9ea0b13fc75459", "filename": "gcc/testsuite/g++.dg/lto/20081125_1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081125_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a5200ff4beac91eee440a2ab5cca512ffe7aa943", "filename": "gcc/testsuite/g++.dg/lto/20081127_0.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "6488ac8d797d644f83a2b91902b96a00752abb94", "filename": "gcc/testsuite/g++.dg/lto/20081127_1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081127_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e92d89a4c3bdaa1422fe8bbbacaa5c856db656a5", "filename": "gcc/testsuite/g++.dg/lto/20081203_0.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "83de109eaa9187c2310d16326b28761fe2873339", "filename": "gcc/testsuite/g++.dg/lto/20081203_1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081203_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8c625f51e474c0debb7e23a0ced2be2b46f3549b", "filename": "gcc/testsuite/g++.dg/lto/20081204-1_0.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "20627b5c54d1c2906d6087059bc36cbc1871b531", "filename": "gcc/testsuite/g++.dg/lto/20081204-1_1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "dfae081bfa16e545b52b316ea4376bd6838f9dc3", "filename": "gcc/testsuite/g++.dg/lto/20081204-2_0.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "676b9b27d63cecdaa62dd3546a22af86bab3144b", "filename": "gcc/testsuite/g++.dg/lto/20081204-2_1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081204-2_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3744a9ac42a1ddf78d033a350ce002d0a537b04f", "filename": "gcc/testsuite/g++.dg/lto/20081209_0.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "83eee3e46e8d81436cd0f59954baeddd5d3ae9fe", "filename": "gcc/testsuite/g++.dg/lto/20081209_1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081209_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f9a8ca7550d76985a2c34957ed4604049de9cbba", "filename": "gcc/testsuite/g++.dg/lto/20081211-1.h", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "89c06acf53a2d2bdc1eba5ae0e002f55bf2aa97a", "filename": "gcc/testsuite/g++.dg/lto/20081211-1_0.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "124d69a7cce5f9fa0155f12472706427d19a638b", "filename": "gcc/testsuite/g++.dg/lto/20081211-1_1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081211-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c91872bd2db3ac0007890f4af0b3cbeeeb40b57c", "filename": "gcc/testsuite/g++.dg/lto/20081217-1_0.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a47b0b5781b4fb2b5675bf4c3ad9e4aced02ae3c", "filename": "gcc/testsuite/g++.dg/lto/20081217-2_0.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081217-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "29ad575d0a760adaa488ae84393c73ed307a88ec", "filename": "gcc/testsuite/g++.dg/lto/20081219_0.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1bb96ef37ded81e9ef72c51d74d17d18289cc51b", "filename": "gcc/testsuite/g++.dg/lto/20081219_1.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20081219_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8c4d3952ef2a3caa084687c5c5a6ddab11c066c4", "filename": "gcc/testsuite/g++.dg/lto/20090106_0.C", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090106_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090106_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090106_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b9dc24bc1bc4cec8cdeb40d74f41b944efa769ee", "filename": "gcc/testsuite/g++.dg/lto/20090112_0.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090112_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090112_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090112_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "24ff5970c1207c5d9f9ee26ce24d7dd42602ec4c", "filename": "gcc/testsuite/g++.dg/lto/20090128_0.C", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090128_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090128_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090128_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "5bf031906c7e1c221c244611905d10188a7d0646", "filename": "gcc/testsuite/g++.dg/lto/20090221_0.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090221_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090221_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090221_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c71e062f31949e1c6fdca43b6a961dd7ac9bd075", "filename": "gcc/testsuite/g++.dg/lto/20090302_0.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0ccaf3c82054cf298f51bd96f777ab51a0ba0618", "filename": "gcc/testsuite/g++.dg/lto/20090302_1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090302_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f6d5512e12397569e4a57d870901f8d084f2fd87", "filename": "gcc/testsuite/g++.dg/lto/20090303_0.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090303_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090303_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090303_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "389d94f0054a234be820026a4eb621b891806f19", "filename": "gcc/testsuite/g++.dg/lto/20090311-1.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "6d403272428afec7078a805b6d38fb3f7c81ce21", "filename": "gcc/testsuite/g++.dg/lto/20090311-1_0.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "520aa957a98ef8dfc865d64ab11e9d42e09bf07d", "filename": "gcc/testsuite/g++.dg/lto/20090311-1_1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311-1_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "cc54bbfdc9606f62f66fb446b94b2bd6bd3f2a3f", "filename": "gcc/testsuite/g++.dg/lto/20090311_0.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e78da7223dd8905bf2a73278fad17e3cf4c26597", "filename": "gcc/testsuite/g++.dg/lto/20090311_1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090311_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c902e93c78dd09b532f38f27147242656e48899a", "filename": "gcc/testsuite/g++.dg/lto/20090312.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b2222c2aa20c0e193c0abb1645d4572115752456", "filename": "gcc/testsuite/g++.dg/lto/20090312_0.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a0f9085f5286e43e9bafb3de95b1a9f678c04ae8", "filename": "gcc/testsuite/g++.dg/lto/20090312_1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090312_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "df1a94287b25e182214f8aad28bc2cf9f3c1441b", "filename": "gcc/testsuite/g++.dg/lto/20090313_0.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "088792b2dd323f0dc327e9da25da55dadc50f182", "filename": "gcc/testsuite/g++.dg/lto/20090313_1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090313_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "930fb16e5cfcc77102e4279ae3fc565b648f9e90", "filename": "gcc/testsuite/g++.dg/lto/20090315_0.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0a2fba552a611ebbaa9a6b6c35159bec1aece531", "filename": "gcc/testsuite/g++.dg/lto/20090315_1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20090315_1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d348e9c1a7d10121fd3042f612312a433ac9a2f2", "filename": "gcc/testsuite/g++.dg/lto/20091002-1_0.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "5b000fa580ce5ac9759085825664949ab0c4da44", "filename": "gcc/testsuite/g++.dg/lto/20091002-2_0.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-2_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7ed81559dd30952b46eef87e8ae8e1a66ae3cb00", "filename": "gcc/testsuite/g++.dg/lto/20091002-3_0.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-3_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-3_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-3_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "5fa3123b42d04d22d1c87c12aeaab68e8092d399", "filename": "gcc/testsuite/g++.dg/lto/README", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2FREADME?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d19bad889274d43af3268e2bab37719c119fc473", "filename": "gcc/testsuite/g++.dg/lto/lto.exp", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Flto.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8430f9cd015aabb5dad508bcb728db14c5616a39", "filename": "gcc/testsuite/g++.dg/lto/pr40818_0.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr40818_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr40818_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr40818_0.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c540b0fa2b4f0052e410a286b30f925634b40c68", "filename": "gcc/testsuite/g++.dg/opt/thunk3-1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk3-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk3-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk3-1.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7dd5ea4338bd7572df44cbc3eabe5a25f7d055dd", "filename": "gcc/testsuite/g++.dg/opt/thunk4.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fthunk4.C?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a54f3c1b53ef0fbf1f03bbd55a2611001b9260eb", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1e0857f734dc2580844d6b1dfbca4e9d5b155b55", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/abs.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fabs.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "deb6cf5228e3f1889300fb4d4dc0f4906e09df7b", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/bfill.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbfill.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbfill.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbfill.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a02b5358b37ce0cd3a1fe611d14cfcc5026595ed", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/bzero.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbzero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbzero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fbzero.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "853a705e86dba542c9c052acb976ec3b34fb7d52", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/fprintf.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Ffprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Ffprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Ffprintf.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2f15c57a7701139713c9f43112e958c7315e0f08", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/memchr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemchr.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "fd6556d227b4d7f621bdaa1a21838eb5174d3a21", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/memcmp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemcmp.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "08fcd08014893178eae70c73086a145b40a3953f", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/memmove.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemmove.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bc16da536fff60e3c12869389a326a33dd58baf5", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/mempcpy.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmempcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmempcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmempcpy.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "90545abbf24eda4f750d50a8e2b55a66b8afd03d", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/memset.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmemset.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4be7578d124763af0cb5a96324c9c29a7195c9d4", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/printf.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fprintf.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3ac447b117f81f0f9905ce49bc03243ecb87c995", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/sprintf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fsprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fsprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fsprintf.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2c7c8178bab86a1c052af59c36bc0a9dca55a7ce", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/stpcpy.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstpcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstpcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstpcpy.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d592087a933f6b74d0e6c81bd1c3a98173553034", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strcat.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcat.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bee3d3203ebeaaee9828c941e2a451d3170fb347", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strchr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrchr.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "82284546f653551d8ae00c1e33111d5c82b8175d", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strcmp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcmp.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "916446623f9960ef6bf52e01a7e2064e5cf6dabe", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strcpy.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcpy.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8270996374af67e0b9b5f6ece3e0ffc828536a65", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strcspn.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcspn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcspn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrcspn.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7f81c115b8176a43068df4ed8f1a47ec65bc584d", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strlen.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrlen.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7fd334cb4d8e2150811b6cf4dc033707e2f0bbd3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strncat.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7a8eb6fd27eb1044e11273d6b2deb16469b8254c", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strncmp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncmp.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a6ec98b054a2fe1128300c2de393001436c366c5", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strncpy.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncpy.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0c049272cca37a64eecb371de161b7f9a68cbba2", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strpbrk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrpbrk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrpbrk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrpbrk.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9a45af3c8e57816735a62fb0044d6940dbbf1dd3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strrchr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrrchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrrchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrrchr.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "622aac6ab38890bcab0384a2896850d767cc885f", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strspn.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrspn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrspn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrspn.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7d35445063e44d8efbc8d4c59753dbedebf2c756", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strstr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrstr.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a26e5907639d7f57d894d0ca2b7b693b155ca4e7", "filename": "gcc/testsuite/gcc.c-torture/execute/execute.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fexecute.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fexecute.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fexecute.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c23f32e85abe7d5b31b635f706ba9227d2a7c916", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fieee.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fieee.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fieee.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "def4bc5afb60e86fafcf49e1866f6d597a52ea72", "filename": "gcc/testsuite/gcc.c-torture/unsorted/unsorted.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Funsorted%2Funsorted.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.c-torture%2Funsorted%2Funsorted.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Funsorted%2Funsorted.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3c36955c9e3650f5238ef44c1bb5556cdb9e8b4f", "filename": "gcc/testsuite/gcc.dg/20081223-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2F20081223-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2F20081223-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20081223-1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3bc1c3a725c53081f8f80e784e5eec3e91337ead", "filename": "gcc/testsuite/gcc.dg/lto/20080908_0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080908_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080908_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080908_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ac0891081fed90c3a47e8c52ab6289976b94f77d", "filename": "gcc/testsuite/gcc.dg/lto/20080917_0.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080917_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080917_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080917_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "db7745077e26395fcd8032a717e42eaede1c88b1", "filename": "gcc/testsuite/gcc.dg/lto/20080924_0.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080924_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080924_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20080924_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9fa297abc0e5e15e5be780e5e0de5a200afb8438", "filename": "gcc/testsuite/gcc.dg/lto/20081024_0.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081024_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081024_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081024_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "eaa25f673d382b8bcda1cf0212b496909cb56480", "filename": "gcc/testsuite/gcc.dg/lto/20081109_0.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081109_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081109_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081109_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "899689c1bc4078432f037aaaa27443efcbb30d64", "filename": "gcc/testsuite/gcc.dg/lto/20081111_0.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2b7fee58690a0f1e8f12dbb0dd938585e1d46e66", "filename": "gcc/testsuite/gcc.dg/lto/20081111_1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081111_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a90aa70b3ab28f936b7ec662927a29de969233cf", "filename": "gcc/testsuite/gcc.dg/lto/20081112_0.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2ba1cb9405c27e909f72a104dd30458ff87fd15e", "filename": "gcc/testsuite/gcc.dg/lto/20081112_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081112_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f24a92deda401635b2c26a26a4dcc6bc20da0778", "filename": "gcc/testsuite/gcc.dg/lto/20081115_0.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "62ffa5200000c9dbad8ec68403eb1170db8cb98e", "filename": "gcc/testsuite/gcc.dg/lto/20081115_1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0ccecd7363de184787602f0658d04fcb39bf42f1", "filename": "gcc/testsuite/gcc.dg/lto/20081115_2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081115_2.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0640428be6d7ff3f6cfcc293e8d7590c2b92517f", "filename": "gcc/testsuite/gcc.dg/lto/20081118_0.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f0a8c3c876b9012093c680550a10bf6fdaac8651", "filename": "gcc/testsuite/gcc.dg/lto/20081118_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "32ce432a128e6440d52d7e8916439d61e1a01572", "filename": "gcc/testsuite/gcc.dg/lto/20081118_2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081118_2.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c35119605d66912e7c0e95186b81c26a596e8e48", "filename": "gcc/testsuite/gcc.dg/lto/20081120-1_0.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "73d25000c915c3cbf757d8ed0c73c83ffc0193fc", "filename": "gcc/testsuite/gcc.dg/lto/20081120-1_1.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-1_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ff8a9a435f209de71943911200b5cc87d2d30b2c", "filename": "gcc/testsuite/gcc.dg/lto/20081120-2_0.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c81f8c7fd071125ce52a4ca4a469c703df24ee82", "filename": "gcc/testsuite/gcc.dg/lto/20081120-2_1.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081120-2_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4b2e7191fed8ec7c26e9a6f53ff8edb8b9677ce0", "filename": "gcc/testsuite/gcc.dg/lto/20081125_0.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1fcf4e7d3917cb5e6291161f2f7bde153892a88d", "filename": "gcc/testsuite/gcc.dg/lto/20081125_1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081125_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9d0bb14c4cba12bad4ff69702fff893f32fa1b4a", "filename": "gcc/testsuite/gcc.dg/lto/20081126_0.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081126_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081126_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081126_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "05cbb82fdd12b101c0d8a65ab405f9050e4d9a0f", "filename": "gcc/testsuite/gcc.dg/lto/20081201-1_0.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f0a8c3c876b9012093c680550a10bf6fdaac8651", "filename": "gcc/testsuite/gcc.dg/lto/20081201-1_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bcf87a749b55be5e8147fdcc0b98e8c2abc6dc3c", "filename": "gcc/testsuite/gcc.dg/lto/20081201-1_2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-1_2.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4c1510d1cec2529dde95d5833c63d84007331c08", "filename": "gcc/testsuite/gcc.dg/lto/20081201-2_0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f93e1fd025f8ca5012e38504bb824b3df68c9b25", "filename": "gcc/testsuite/gcc.dg/lto/20081201-2_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081201-2_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "933610a894bc537e2e8d106441734facbd096713", "filename": "gcc/testsuite/gcc.dg/lto/20081202-1_0.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2f6777864a02c6cc42cba47a26e8fc0cabc356d2", "filename": "gcc/testsuite/gcc.dg/lto/20081202-1_1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-1_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "09f417698ca6d1181315b7446bcd4af74093a513", "filename": "gcc/testsuite/gcc.dg/lto/20081202-2_0.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "adb150245027ab5efa31d7e206ce8f0d2f3aef75", "filename": "gcc/testsuite/gcc.dg/lto/20081202-2_1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081202-2_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "92598085c9abb60c2ddd5a8a22af6f901cd4eb45", "filename": "gcc/testsuite/gcc.dg/lto/20081204-1_0.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "95761ea156b3f1b08b1b7003aece5c202eb1be62", "filename": "gcc/testsuite/gcc.dg/lto/20081204-1_1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-1_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "241ac5d607adba862aae93495de819dcebff149f", "filename": "gcc/testsuite/gcc.dg/lto/20081204-2_0.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081204-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "5cf020ec227411d138123cad7a8d8d6d37f077b1", "filename": "gcc/testsuite/gcc.dg/lto/20081210-1_0.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081210-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081210-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081210-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a19bff1bac5ce79fe84b88c95b2c81f528416260", "filename": "gcc/testsuite/gcc.dg/lto/20081212-1_0.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081212-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081212-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081212-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e44766613bd38cbb9928e9bf0965873488add391", "filename": "gcc/testsuite/gcc.dg/lto/20081222_0.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4c26f461651aee6eda57903e43c5e1fb0fde782a", "filename": "gcc/testsuite/gcc.dg/lto/20081222_0.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_0.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e8f9254421be0c948932a2b4ae5866f66a78b3ce", "filename": "gcc/testsuite/gcc.dg/lto/20081222_1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081222_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c146115b086f02fd0979b2ceec8a7f0561596c65", "filename": "gcc/testsuite/gcc.dg/lto/20081224_0.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7b62a07966770094a0b87530ce8cbadd5932d9cd", "filename": "gcc/testsuite/gcc.dg/lto/20081224_0.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_0.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3e1ff341088168752ca015672e27b619b4333d71", "filename": "gcc/testsuite/gcc.dg/lto/20081224_1.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20081224_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4b88e4ab3b14351b94951d788467fc1cdff9c4b8", "filename": "gcc/testsuite/gcc.dg/lto/20090116_0.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090116_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090116_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090116_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "6c69a9918b2dd3742822eeae80fbc05f7959d103", "filename": "gcc/testsuite/gcc.dg/lto/20090120_0.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090120_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090120_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090120_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0ed8ea324019ca7f4d34192758780f8475ffda5a", "filename": "gcc/testsuite/gcc.dg/lto/20090126-1_0.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "64e6385325057703d0de024543d8af9f6436b8ec", "filename": "gcc/testsuite/gcc.dg/lto/20090126-2_0.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090126-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "42eaca9d5e28ee6a2f201197ee4ebe630c320ea1", "filename": "gcc/testsuite/gcc.dg/lto/20090206-1_0.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "3e85c5d227c66663b951f299179b45d413232bff", "filename": "gcc/testsuite/gcc.dg/lto/20090206-2_0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090206-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c588e8a27789e2cfb112c2864236d49365aee8f8", "filename": "gcc/testsuite/gcc.dg/lto/20090210_0.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bf12aa6c08b7b6e3ac6677f5146fb05dd789db63", "filename": "gcc/testsuite/gcc.dg/lto/20090210_1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090210_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "6387a0e4716dd1732698a1c1b4d5a0cc408d8f03", "filename": "gcc/testsuite/gcc.dg/lto/20090213_0.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4a852efd1936c4cdd55bde9d9e69d73687a70899", "filename": "gcc/testsuite/gcc.dg/lto/20090213_1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090213_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1dc9ee0854071162d26bddfbb2e764abebf3a24c", "filename": "gcc/testsuite/gcc.dg/lto/20090218-1_0.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "33d4fb000f31683372fbf1db4dc2ad21ce691237", "filename": "gcc/testsuite/gcc.dg/lto/20090218-1_1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-1_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8857e7a6d214cf5104fd2b3b9d99811b9d8b4611", "filename": "gcc/testsuite/gcc.dg/lto/20090218-2_0.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "119fbe4a16bcb790322d6d6f4e86a414be0ec6a1", "filename": "gcc/testsuite/gcc.dg/lto/20090218-2_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218-2_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c4390fa1f104a7d2bc357a9f66b1e439f91f8617", "filename": "gcc/testsuite/gcc.dg/lto/20090218_0.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "c28b84ada6ee6c41a6f6342f585b35adf64c9f70", "filename": "gcc/testsuite/gcc.dg/lto/20090218_1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e9f835f362766947428d9d7758955fbdfc6d6a59", "filename": "gcc/testsuite/gcc.dg/lto/20090218_2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_2.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e1f4df61479a5f3436fb8a56a0df8f1265ee76ff", "filename": "gcc/testsuite/gcc.dg/lto/20090218_3.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090218_3.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "6229de7aef1a42349c15072f21c171ee33730a3d", "filename": "gcc/testsuite/gcc.dg/lto/20090219_0.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090219_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090219_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090219_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8aaad754cc3512191091d4e136285889971c6e1c", "filename": "gcc/testsuite/gcc.dg/lto/20090312_0.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "882fb0f41573e20879a72894f1e4618ac0e24ad2", "filename": "gcc/testsuite/gcc.dg/lto/20090312_1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090312_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "120ba3c50e004258e2c32916cb7647bbab75e6aa", "filename": "gcc/testsuite/gcc.dg/lto/20090313_0.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090313_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090313_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090313_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7877fd350d7da3a222e4406a7de9a82970af0409", "filename": "gcc/testsuite/gcc.dg/lto/20090706-1_0.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "69da98b5cca8805c4654b711eddf8547ee4bd124", "filename": "gcc/testsuite/gcc.dg/lto/20090706-2_0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090706-2_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "fe13bdf78d4510136bd56923741548faf2501e90", "filename": "gcc/testsuite/gcc.dg/lto/20090717_0.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bda8138214baaa47012bd16a443109b0e9db8dda", "filename": "gcc/testsuite/gcc.dg/lto/20090717_1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090717_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "05ae74f872e28c417a8032688b3c75cd38eb6f6f", "filename": "gcc/testsuite/gcc.dg/lto/20090729_0.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0a5091ac29e152e0199f38743b1ee7250fb3f2f2", "filename": "gcc/testsuite/gcc.dg/lto/20090729_1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090729_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "baf20f520a26a109014c4c10be1841f0ccc1de04", "filename": "gcc/testsuite/gcc.dg/lto/20090812_0.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e91424492a086f5cd48faf8d2b2320c2c4e6eab6", "filename": "gcc/testsuite/gcc.dg/lto/20090812_1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090812_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ef9f7b35182bcc81a919d4c1dfdf1d2e3351f324", "filename": "gcc/testsuite/gcc.dg/lto/20090914-1_0.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090914-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090914-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20090914-1_0.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "1a13dd92c622fbbdfff870ffab20e330f981ee5b", "filename": "gcc/testsuite/gcc.dg/lto/README", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2FREADME?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0e343c19b77b72b9ec460c569ac318aae40cfeff", "filename": "gcc/testsuite/gcc.dg/lto/lto.exp", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Flto.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9b97ccb1b38431ca3361c2492c468b4d64452a5f", "filename": "gcc/testsuite/gcc.target/i386/math-torture/math-torture.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmath-torture%2Fmath-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmath-torture%2Fmath-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmath-torture%2Fmath-torture.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "a3707ddbd6b57afbe45d51b0299351680f9e740a", "filename": "gcc/testsuite/gfortran.dg/lto/lto.exp", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Flto.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2d7a9864e40aba84f258795a8b2180bcd5b6169d", "filename": "gcc/testsuite/gfortran.dg/lto/pr40724_0.f", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_0.f?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ed8f31020dd03a885373d5a06e6dab8b073dccb2", "filename": "gcc/testsuite/gfortran.dg/lto/pr40724_1.f", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40724_1.f?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "2f33a0f5bf49fd62b0804bfa0da6a883ec0be763", "filename": "gcc/testsuite/gfortran.dg/lto/pr40725_0.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_0.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_0.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_0.f03?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7de46b8a988afaea01b92b93b1f3fccdf633909b", "filename": "gcc/testsuite/gfortran.dg/lto/pr40725_1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr40725_1.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4e7d65939c805d1e69d10fae23cbc8dcb6895a63", "filename": "gcc/testsuite/gfortran.dg/lto/pr41069_0.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_0.f90?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "0c4e05d66d314da0488b3089c28066b00238651b", "filename": "gcc/testsuite/gfortran.dg/lto/pr41069_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_1.f90?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "121603eaa60efc395a3e03486e1aa08776bdd3f8", "filename": "gcc/testsuite/gfortran.dg/lto/pr41069_2.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41069_2.f90?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8b15b577005bd501757b60719ac1ad86dadb64cd", "filename": "gcc/testsuite/lib/c-torture.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Fc-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Fc-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fc-torture.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "4acfdfec8ff7adb02c6271275e3b828edf81d6f7", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "7f2d7ecec83b4d6b4723f305cef16fd3cd0941e5", "filename": "gcc/testsuite/lib/lto.exp", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Flto.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Flto.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Flto.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "26ef7b7038e4f0bd2a4979d9feaaeec2a1a60daa", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "f3b3e22948b2afb6ef325ebead1e2f890244db53", "filename": "gcc/testsuite/lib/torture-options.exp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Ftorture-options.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftestsuite%2Flib%2Ftorture-options.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftorture-options.exp?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "d885e50dd3076ebf9c8de48a49627724a9477c75", "filename": "gcc/timevar.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "969c75d0aa68b675d0b940bbc436eab0326ed49e", "filename": "gcc/tlink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8686e4dd94725d9828ffa23277fe67f9fa06cc7b", "filename": "gcc/toplev.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e392f48af3e0cfeeef7e1c820c22012e55698405", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "8e790aec7847e57c1ccda8e67bf1988aea5b2e3a", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "e38da6d5bde75b34cfc9dd7ea35375c97f38d2c2", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "abd56fcc484c85406100fffc848c0c6af19ba584", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "ae510494c86af7a7d2633429934b144817b734a0", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "77ba3f8498c85428e7598308ad387ab8540df0c1", "filename": "gcc/tree.c", "status": "modified", "additions": 135, "deletions": 89, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "20463b4a18b572c5b99e418d4a7e473e25849f03", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "63cebabfad503cd9002f9c6482e7d92d58d8019f", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "9312c5d9d33aece6818797bcece4b46c53cffcef", "filename": "include/lto-symtab.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2Flto-symtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2Flto-symtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flto-symtab.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "bb038ad249eaa91b90910ae941a053308a95bbd0", "filename": "include/plugin-api.h", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2Fplugin-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/include%2Fplugin-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fplugin-api.h?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "49f2efb40c5a1aca614bd68cabe9771ce3fb0912", "filename": "lto-plugin/ChangeLog", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}, {"sha": "b5dd5fc47164a5092b680ea891cabcab90624577", "filename": "lto-plugin/Makefile.am", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f09764d7bc66b9997c811c22e11efc87b44792/lto-plugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f09764d7bc66b9997c811c22e11efc87b44792/lto-plugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FMakefile.am?ref=d7f09764d7bc66b9997c811c22e11efc87b44792"}]}