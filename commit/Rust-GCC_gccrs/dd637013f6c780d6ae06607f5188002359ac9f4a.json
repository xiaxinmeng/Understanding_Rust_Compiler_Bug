{"sha": "dd637013f6c780d6ae06607f5188002359ac9f4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ2MzcwMTNmNmM3ODBkNmFlMDY2MDdmNTE4ODAwMjM1OWFjOWY0YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2014-10-21T15:17:12Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2014-10-21T15:17:12Z"}, "message": "cfg.h: New.\n\n2014-10-21  Andrew MacLeod  <amacleod@redhat.com>\n\n\n\t* cfg.h: New.  Header file for cfg.c.\n\t* cfganal.h: New.  Header file for cfganal.c.\n\t* lcm.h: New.  Header file for lcm.c.\n\t* loop-unroll.h: New.  Header file for loop-unroll.h.\n\t* cfgloop.h: (unroll_loops): Remove prototype.\n\t* basic-block.h: Move prototypes and structs to new header files.\n\tInclude cfg.h, cfganal.h, and lcm.h.\n\t* loop-init.c: Include loop-unroll.h.\n\t* loop-unroll.c: (referenced_in_one_insn_in_loop_p): Make static.\n\t* modulo-sched.c: Include loop-unroll.h.\n\nFrom-SVN: r216518", "tree": {"sha": "d97aa618a7b800cfd54f614af5d144b8805bd39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d97aa618a7b800cfd54f614af5d144b8805bd39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd637013f6c780d6ae06607f5188002359ac9f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd637013f6c780d6ae06607f5188002359ac9f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd637013f6c780d6ae06607f5188002359ac9f4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd637013f6c780d6ae06607f5188002359ac9f4a/comments", "author": null, "committer": null, "parents": [{"sha": "eb8a3cca947b3912ca890a25753e6b1aebba6089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8a3cca947b3912ca890a25753e6b1aebba6089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8a3cca947b3912ca890a25753e6b1aebba6089"}], "stats": {"total": 344, "additions": 225, "deletions": 119}, "files": [{"sha": "2c6a8199ae0c219135ff954d96ca618c83dd9e6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -1,3 +1,16 @@\n+2014-10-21  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* cfg.h: New.  Header file for cfg.c.\n+\t* cfganal.h: New.  Header file for cfganal.c.\n+\t* lcm.h: New.  Header file for lcm.c.\n+\t* loop-unroll.h: New.  Header file for loop-unroll.h.\n+\t* cfgloop.h: (unroll_loops): Remove prototype.\n+\t* basic-block.h: Move prototypes and structs to new header files.\n+\tInclude cfg.h, cfganal.h, and lcm.h.\n+\t* loop-init.c: Include loop-unroll.h.\n+\t* loop-unroll.c: (referenced_in_one_insn_in_loop_p): Make static.\n+\t* modulo-sched.c: Include loop-unroll.h.\n+\n 2014-10-21  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* tree-ssa-math-opts.c (find_bswap_or_nop_1): Fix creation of"}, {"sha": "b1055c00fa3f1f0c86f32fee1cf3ad7250ac235d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 117, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -30,6 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"input.h\"\n #include \"function.h\"\n #include \"cfgrtl.h\"\n+#include \"cfg.h\"\n+#include \"cfganal.h\"\n+#include \"lcm.h\"\n \n /* Use gcov_type to hold basic block counters.  Should be at least\n    64bit.  Although a counter cannot be negative, we use a signed\n@@ -381,26 +384,7 @@ struct GTY(()) control_flow_graph {\n #define NUM_FIXED_BLOCKS (2)\n \n \n-basic_block split_edge_and_insert (edge, rtx_insn *);\n-\n-extern edge unchecked_make_edge (basic_block, basic_block, int);\n-extern edge cached_make_edge (sbitmap, basic_block, basic_block, int);\n-extern edge make_edge (basic_block, basic_block, int);\n-extern edge make_single_succ_edge (basic_block, basic_block, int);\n-extern void remove_edge_raw (edge);\n-extern void redirect_edge_succ (edge, basic_block);\n extern edge redirect_edge_succ_nodup (edge, basic_block);\n-extern void redirect_edge_pred (edge, basic_block);\n-extern void clear_bb_flags (void);\n-extern void dump_bb_info (FILE *, basic_block, int, int, bool, bool);\n-extern void dump_edge_info (FILE *, edge, int, int);\n-extern void debug (edge_def &ref);\n-extern void debug (edge_def *ptr);\n-extern void brief_dump_cfg (FILE *, int);\n-extern void clear_edges (void);\n-extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n-extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n-\t\t\t\t\t     gcov_type);\n \n /* Structure to group all of the information to process IF-THEN and\n    IF-THEN-ELSE blocks for the conditional execution support.  This\n@@ -424,31 +408,6 @@ struct ce_if_block\n   int pass;\t\t\t\t/* Pass number.  */\n };\n \n-/* This structure maintains an edge list vector.  */\n-/* FIXME: Make this a vec<edge>.  */\n-struct edge_list\n-{\n-  int num_edges;\n-  edge *index_to_edge;\n-};\n-\n-/* Class to compute and manage control dependences on an edge-list.  */\n-class control_dependences\n-{\n-public:\n-  control_dependences (edge_list *);\n-  ~control_dependences ();\n-  bitmap get_edges_dependent_on (int);\n-  edge get_edge (int);\n-\n-private:\n-  void set_control_dependence_map_bit (basic_block, int);\n-  void clear_control_dependence_bitmap (basic_block);\n-  void find_control_dependence (int);\n-  vec<bitmap> control_dependence_map;\n-  edge_list *m_el;\n-};\n-\n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -690,24 +649,7 @@ ei_cond (edge_iterator ei, edge *p)\n #define CLEANUP_CFGLAYOUT\t32\t/* Do cleanup in cfglayout mode.  */\n #define CLEANUP_CFG_CHANGED\t64      /* The caller changed the CFG.  */\n \n-/* In cfganal.c */\n-extern void bitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n-extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n-extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n-extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n-\n-/* In lcm.c */\n-extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n-\t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n-\t\t\t\t       sbitmap **);\n-extern struct edge_list *pre_edge_lcm_avs (int, sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap **, sbitmap **);\n-extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap **,\n-\t\t\t\t\t   sbitmap **);\n-extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n+extern void dump_flow_info (FILE *, int);\n \n /* In predict.c */\n extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n@@ -733,50 +675,6 @@ extern bool edge_probability_reliable_p (const_edge);\n extern bool br_prob_note_reliable_p (const_rtx);\n extern bool predictable_edge_p (edge);\n \n-/* In cfg.c  */\n-extern void init_flow (struct function *);\n-extern void debug_bb (basic_block);\n-extern basic_block debug_bb_n (int);\n-extern void dump_flow_info (FILE *, int);\n-extern void expunge_block (basic_block);\n-extern void link_block (basic_block, basic_block);\n-extern void unlink_block (basic_block);\n-extern void compact_blocks (void);\n-extern basic_block alloc_block (void);\n-extern void alloc_aux_for_blocks (int);\n-extern void clear_aux_for_blocks (void);\n-extern void free_aux_for_blocks (void);\n-extern void alloc_aux_for_edge (edge, int);\n-extern void alloc_aux_for_edges (int);\n-extern void clear_aux_for_edges (void);\n-extern void free_aux_for_edges (void);\n-\n-/* In cfganal.c  */\n-extern void find_unreachable_blocks (void);\n-extern bool mark_dfs_back_edges (void);\n-struct edge_list * create_edge_list (void);\n-void free_edge_list (struct edge_list *);\n-void print_edge_list (FILE *, struct edge_list *);\n-void verify_edge_list (FILE *, struct edge_list *);\n-int find_edge_index (struct edge_list *, basic_block, basic_block);\n-edge find_edge (basic_block, basic_block);\n-extern void remove_fake_edges (void);\n-extern void remove_fake_exit_edges (void);\n-extern void add_noreturn_fake_exit_edges (void);\n-extern void connect_infinite_loops_to_exit (void);\n-extern int post_order_compute (int *, bool, bool);\n-extern basic_block dfs_find_deadend (basic_block);\n-extern int inverted_post_order_compute (int *);\n-extern int pre_and_rev_post_order_compute_fn (struct function *,\n-\t\t\t\t\t      int *, int *, bool);\n-extern int pre_and_rev_post_order_compute (int *, int *, bool);\n-extern int dfs_enumerate_from (basic_block, int,\n-\t\t\t       bool (*)(const_basic_block, const void *),\n-\t\t\t       basic_block *, int, const void *);\n-extern void compute_dominance_frontiers (struct bitmap_head *);\n-extern bitmap compute_idf (bitmap, struct bitmap_head *);\n-extern basic_block * single_pred_before_succ_order (void);\n-\n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);\n extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n@@ -841,17 +739,6 @@ extern basic_block next_dom_son (enum cdi_direction, basic_block);\n unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);\n unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n \n-extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n-\n-extern void initialize_original_copy_tables (void);\n-extern void free_original_copy_tables (void);\n-extern void set_bb_original (basic_block, basic_block);\n-extern basic_block get_bb_original (basic_block);\n-extern void set_bb_copy (basic_block, basic_block);\n-extern basic_block get_bb_copy (basic_block);\n-void set_loop_copy (struct loop *, struct loop *);\n-struct loop *get_loop_copy (struct loop *);\n-\n #include \"cfghooks.h\"\n \n /* Return true if BB is in a transaction.  */"}, {"sha": "11935d10b8400d05a80d516fbbd39fc2ef0f9cbf", "filename": "gcc/cfg.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -0,0 +1,65 @@\n+/* Control flow graph manipulation code header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CFG_H\n+#define GCC_CFG_H\n+\n+extern void init_flow (struct function *);\n+extern void clear_edges (void);\n+extern basic_block alloc_block (void);\n+extern void link_block (basic_block, basic_block);\n+extern void unlink_block (basic_block);\n+extern void compact_blocks (void);\n+extern void expunge_block (basic_block);\n+extern edge unchecked_make_edge (basic_block, basic_block, int);\n+extern edge cached_make_edge (sbitmap, basic_block, basic_block, int);\n+extern edge make_edge (basic_block, basic_block, int);\n+extern edge make_single_succ_edge (basic_block, basic_block, int);\n+extern void remove_edge_raw (edge);\n+extern void redirect_edge_succ (edge, basic_block);\n+extern void redirect_edge_pred (edge, basic_block);\n+extern void clear_bb_flags (void);\n+extern void dump_edge_info (FILE *, edge, int, int);\n+extern void debug (edge_def &ref);\n+extern void debug (edge_def *ptr);\n+extern void alloc_aux_for_blocks (int);\n+extern void clear_aux_for_blocks (void);\n+extern void free_aux_for_blocks (void);\n+extern void alloc_aux_for_edge (edge, int);\n+extern void alloc_aux_for_edges (int);\n+extern void clear_aux_for_edges (void);\n+extern void free_aux_for_edges (void);\n+extern void debug_bb (basic_block);\n+extern basic_block debug_bb_n (int);\n+extern void dump_bb_info (FILE *, basic_block, int, int, bool, bool);\n+extern void brief_dump_cfg (FILE *, int);\n+extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n+extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n+extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n+\t\t\t\t\t     gcov_type);\n+extern void initialize_original_copy_tables (void);\n+extern void free_original_copy_tables (void);\n+extern void set_bb_original (basic_block, basic_block);\n+extern basic_block get_bb_original (basic_block);\n+extern void set_bb_copy (basic_block, basic_block);\n+extern basic_block get_bb_copy (basic_block);\n+void set_loop_copy (struct loop *, struct loop *);\n+struct loop *get_loop_copy (struct loop *);\n+\n+#endif /* GCC_CFG_H */"}, {"sha": "5c60f53983cede45ee715009c6af59452f122565", "filename": "gcc/cfganal.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -0,0 +1,79 @@\n+/* Control flow graph analysis header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef GCC_CFGANAL_H\n+#define GCC_CFGANAL_H\n+\n+/* This structure maintains an edge list vector.  */\n+/* FIXME: Make this a vec<edge>.  */\n+struct edge_list\n+{\n+  int num_edges;\n+  edge *index_to_edge;\n+};\n+\n+\n+/* Class to compute and manage control dependences on an edge-list.  */\n+class control_dependences\n+{\n+public:\n+  control_dependences (edge_list *);\n+  ~control_dependences ();\n+  bitmap get_edges_dependent_on (int);\n+  edge get_edge (int);\n+\n+private:\n+  void set_control_dependence_map_bit (basic_block, int);\n+  void clear_control_dependence_bitmap (basic_block);\n+  void find_control_dependence (int);\n+  vec<bitmap> control_dependence_map;\n+  edge_list *m_el;\n+};\n+\n+extern bool mark_dfs_back_edges (void);\n+extern void find_unreachable_blocks (void);\n+struct edge_list * create_edge_list (void);\n+void free_edge_list (struct edge_list *);\n+void print_edge_list (FILE *, struct edge_list *);\n+void verify_edge_list (FILE *, struct edge_list *);\n+edge find_edge (basic_block, basic_block);\n+int find_edge_index (struct edge_list *, basic_block, basic_block);\n+extern void remove_fake_edges (void);\n+extern void remove_fake_exit_edges (void);\n+extern void add_noreturn_fake_exit_edges (void);\n+extern void connect_infinite_loops_to_exit (void);\n+extern int post_order_compute (int *, bool, bool);\n+extern basic_block dfs_find_deadend (basic_block);\n+extern int inverted_post_order_compute (int *);\n+extern int pre_and_rev_post_order_compute_fn (struct function *,\n+\t\t\t\t\t      int *, int *, bool);\n+extern int pre_and_rev_post_order_compute (int *, int *, bool);\n+extern int dfs_enumerate_from (basic_block, int,\n+\t\t\t       bool (*)(const_basic_block, const void *),\n+\t\t\t       basic_block *, int, const void *);\n+extern void compute_dominance_frontiers (struct bitmap_head *);\n+extern bitmap compute_idf (bitmap, struct bitmap_head *);\n+extern void bitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n+extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n+extern basic_block * single_pred_before_succ_order (void);\n+\n+#endif /* GCC_CFGANAL_H */"}, {"sha": "f54ac1dcbd922287f4940006e45f9a4e29accd00", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -740,7 +740,6 @@ enum\n   UAP_UNROLL_ALL = 2\t/* Enables unrolling of all loops.  */\n };\n \n-extern void unroll_loops (int);\n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n extern void scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound);"}, {"sha": "bb11e4f77f45ae2737d81afba6aa8f6547fcb43a", "filename": "gcc/lcm.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Flcm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Flcm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -0,0 +1,34 @@\n+/* Generic partial redundancy elimination with lazy code motion header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LCM_H\n+#define GCC_LCM_H\n+\n+extern struct edge_list *pre_edge_lcm_avs (int, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap **, sbitmap **);\n+extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n+\t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n+\t\t\t\t       sbitmap **);\n+extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n+extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap **,\n+\t\t\t\t\t   sbitmap **);\n+#endif /* GCC_LCM_H */"}, {"sha": "767b8ac58d60b478c2424d5f39db4a84a59f7e66", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"ggc.h\"\n #include \"tree-ssa-loop-niter.h\"\n+#include \"loop-unroll.h\"\n \n \f\n /* Apply FLAGS to the loop state.  */"}, {"sha": "d68b8467b3df68a1ecf1ee35272db68f29802682", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -1236,7 +1236,7 @@ unroll_loop_stupid (struct loop *loop)\n    Set *DEBUG_USES to the number of debug insns that reference the\n    variable.  */\n \n-bool\n+static bool\n referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg,\n \t\t\t\t  int *debug_uses)\n {"}, {"sha": "a14be10d524fe776e0000cd2854c76761593512c", "filename": "gcc/loop-unroll.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-unroll.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Floop-unroll.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.h?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -0,0 +1,27 @@\n+/* Loop unrolling header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LOOP_UNROLL_H\n+#define GCC_LOOP_UNROLL_H\n+\n+extern void unroll_loops (int);\n+extern basic_block split_edge_and_insert (edge, rtx_insn *);\n+\n+\n+#endif /* GCC_LOOP_UNROLL_H */"}, {"sha": "4a745fddbe5269e4d8bf834bc7992da5cee1b7ec", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd637013f6c780d6ae06607f5188002359ac9f4a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=dd637013f6c780d6ae06607f5188002359ac9f4a", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"df.h\"\n+#include \"loop-unroll.h\"\n \n #ifdef INSN_SCHEDULING\n "}]}