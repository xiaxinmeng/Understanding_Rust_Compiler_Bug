{"sha": "359255a957150238a4517312232c6bd491b9c4a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU5MjU1YTk1NzE1MDIzOGE0NTE3MzEyMjMyYzZiZDQ5MWI5YzRhMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-08T06:37:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-08T06:37:08Z"}, "message": "pa.md (alternate dbra pattern): Remove incorrect pattern.\n\n        * pa.md (alternate dbra pattern): Remove incorrect pattern.\n\n        * pa.c (struct defer_plab): Renamed to struct deferred_plabel.\n        Remove \"symbol\" field and replace with \"name\" field.\n        (output_function_epilogue): Don't output deferred plabels here.\n        (output_deferred_labels): New function.  Output them here instead.\n        (output_call): Rewrite long call support.\n        * pa.h (ASM_FILE_END): Define.\n        (LEGITIMATE_CONSTANT_P): Never accept a function_label_operand.\n        * pa.md (HIGH and LO_SUM of function address): Remove patterns.\n\nFrom-SVN: r14171", "tree": {"sha": "62b04ea8ac51caea1107a82da41cab9470cbec71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62b04ea8ac51caea1107a82da41cab9470cbec71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/359255a957150238a4517312232c6bd491b9c4a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359255a957150238a4517312232c6bd491b9c4a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/359255a957150238a4517312232c6bd491b9c4a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359255a957150238a4517312232c6bd491b9c4a1/comments", "author": null, "committer": null, "parents": [{"sha": "6c48ca54b3b855407dcf1962b64cbb1baf019e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c48ca54b3b855407dcf1962b64cbb1baf019e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c48ca54b3b855407dcf1962b64cbb1baf019e6e"}], "stats": {"total": 292, "additions": 120, "deletions": 172}, "files": [{"sha": "0eae0b1c1b666e50c5fae02598706343ca392800", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 117, "deletions": 70, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=359255a957150238a4517312232c6bd491b9c4a1", "patch": "@@ -70,10 +70,10 @@ unsigned int total_code_bytes;\n /* Variables to handle plabels that we discover are necessary at assembly\n    output time.  They are output after the current function.  */\n \n-struct defer_plab\n+struct deferred_plabel\n {\n   rtx internal_label;\n-  rtx symbol;\n+  char *name;\n } *deferred_plabels = 0;\n int n_deferred_plabels = 0;\n \n@@ -2898,23 +2898,6 @@ output_function_epilogue (file, size)\n     fputs (\"\\tnop\\n\", file);\n \n   fputs (\"\\t.EXIT\\n\\t.PROCEND\\n\", file);\n-\n-  /* If we have deferred plabels, then we need to switch into the data\n-     section and align it to a 4 byte boundary before we output the\n-     deferred plabels.  */\n-  if (n_deferred_plabels)\n-    {\n-      data_section ();\n-      ASM_OUTPUT_ALIGN (file, 2);\n-    }\n-\n-  /* Now output the deferred plabels.  */\n-  for (i = 0; i < n_deferred_plabels; i++)\n-    {\n-      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n-      assemble_integer (deferred_plabels[i].symbol, 4, 1);\n-    }\n-  n_deferred_plabels = 0;\n }\n \n void\n@@ -3900,6 +3883,29 @@ output_global_address (file, x, round_constant)\n     output_addr_const (file, x);\n }\n \n+void\n+output_deferred_plabels (file)\n+     FILE *file;\n+{\n+  int i;\n+  /* If we have deferred plabels, then we need to switch into the data\n+     section and align it to a 4 byte boundary before we output the\n+     deferred plabels.  */\n+  if (n_deferred_plabels)\n+    {\n+      data_section ();\n+      ASM_OUTPUT_ALIGN (file, 2);\n+    }\n+\n+  /* Now output the deferred plabels.  */\n+  for (i = 0; i < n_deferred_plabels; i++)\n+    {\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (deferred_plabels[i].internal_label));\n+      assemble_integer (gen_rtx (SYMBOL_REF, VOIDmode,\n+\t\t\t\t deferred_plabels[i].name), 4, 1);\n+    }\n+}\n+\n /* HP's millicode routines mean something special to the assembler.\n    Keep track of which ones we have used.  */\n \n@@ -5039,6 +5045,11 @@ output_millicode_call (insn, call_dest)\n   return \"\";\n }\n \n+extern struct obstack permanent_obstack;\n+extern struct obstack *saveable_obstack;\n+extern struct obstack *rtl_obstack;\n+extern struct obstack *current_obstack;\n+\n /* INSN is either a function call.  It may have an unconditional jump\n    in its delay slot.\n \n@@ -5128,70 +5139,109 @@ output_call (insn, call_dest)\n \t\t  output_asm_insn (\"ldw -12(%%sr0,%%r30),%R1\", xoperands);\n \t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n \t\t}\n-\t\t\n \t    }\n \t}\n \n       /* Don't have to worry about TARGET_PORTABLE_RUNTIME here since\n \t we don't have any direct calls in that case.  */\n-      if (flag_pic)\n \t{\n-\t  /* We have to load the address of the function using a procedure\n-\t     label (plabel).  The LP and RP relocs don't work reliably for PIC,\n-\t     so we make a plain 32 bit plabel in the data segment instead.  We\n-\t     have to defer outputting it of course...  Not pretty.  */\n+\t  int i;\n+\t  char *name = XSTR (call_dest, 0);\n+\n+\t  /* See if we have already put this function on the list\n+\t     of deferred plabels.  This list is generally small,\n+\t     so a liner search is not too ugly.  If it proves too\n+\t     slow replace it with something faster.  */\n+\t  for (i = 0; i < n_deferred_plabels; i++)\n+\t    if (strcmp (name, deferred_plabels[i].name) == 0)\n+\t      break;\n+\n+\t  /* If the deferred plabel list is empty, or this entry was\n+\t     not found on the list, create a new entry on the list.  */\n+\t  if (deferred_plabels == NULL || i == n_deferred_plabels)\n+\t    {\n+\t      struct obstack *ambient_obstack = current_obstack;\n+\t      struct obstack *ambient_rtl_obstack = rtl_obstack;\n+\t      char *real_name;\n+\n+\t      /* Any RTL we create here needs to live until the end of\n+\t\t the compilation unit and therefore must live on the\n+\t\t permanent obstack.  */\n+\t      current_obstack = &permanent_obstack;\n+\t      rtl_obstack = &permanent_obstack;\n+\n+\t      if (deferred_plabels == 0)\n+\t\tdeferred_plabels = (struct deferred_plabel *)\n+\t\t  xmalloc (1 * sizeof (struct deferred_plabel));\n+\t      else\n+\t\tdeferred_plabels = (struct deferred_plabel *)\n+\t\t  xrealloc (deferred_plabels,\n+\t\t\t    ((n_deferred_plabels + 1)\n+\t\t\t     * sizeof (struct deferred_plabel)));\n+\n+\t      i = n_deferred_plabels++;\n+\t      deferred_plabels[i].internal_label = gen_label_rtx ();\n+\t      deferred_plabels[i].name = obstack_alloc (&permanent_obstack,\n+\t\t\t\t\t\t\tstrlen (name) + 1);\n+\t      strcpy (deferred_plabels[i].name, name);\n+\n+\t      /* Switch back to normal obstack allocation.  */\n+\t      current_obstack = ambient_obstack;\n+\t      rtl_obstack = ambient_rtl_obstack;\n+\n+\t      /* Gross.  We have just implicitly taken the address of this\n+\t\t function, mark it as such.  */\n+\t      STRIP_NAME_ENCODING (real_name, name);\n+\t      TREE_SYMBOL_REFERENCED (get_identifier (real_name)) = 1;\n+\t    }\n \n-\t  xoperands[0] = gen_label_rtx ();\n-\t  xoperands[1] = gen_label_rtx ();\n-\t  output_asm_insn (\"addil LT%%%0,%%r19\", xoperands);\n-\t  output_asm_insn (\"ldw RT%%%0(%%r1),%%r22\", xoperands);\n-\t  output_asm_insn (\"ldw 0(0,%%r22),%%r22\", xoperands);\n+\t  /* We have to load the address of the function using a procedure\n+\t     label (plabel).  Inline plabels can lose for PIC and other\n+\t     cases, so avoid them by creating a 32bit plabel in the data\n+\t     segment.  */\n+\t  if (flag_pic)\n+\t    {\n+\t      xoperands[0] = deferred_plabels[i].internal_label;\n+\t      xoperands[1] = gen_label_rtx ();\n \n-\t  if (deferred_plabels == 0)\n-\t    deferred_plabels = (struct defer_plab *)\n-\t      xmalloc (1 * sizeof (struct defer_plab));\n-\t  else\n-\t    deferred_plabels = (struct defer_plab *)\n-\t      xrealloc (deferred_plabels,\n-\t\t\t(n_deferred_plabels + 1) * sizeof (struct defer_plab));\n-\t  deferred_plabels[n_deferred_plabels].internal_label = xoperands[0];\n-\t  deferred_plabels[n_deferred_plabels].symbol = call_dest;\n-\t  n_deferred_plabels++;\n+\t      output_asm_insn (\"addil LT%%%0,%%r19\", xoperands);\n+\t      output_asm_insn (\"ldw RT%%%0(%%r1),%%r22\", xoperands);\n+\t      output_asm_insn (\"ldw 0(0,%%r22),%%r22\", xoperands);\n \n-\t  /* Get our address + 8 into %r1.  */\n-\t  output_asm_insn (\"bl .+8,%%r1\", xoperands);\n+\t      /* Get our address + 8 into %r1.  */\n+\t      output_asm_insn (\"bl .+8,%%r1\", xoperands);\n \n-\t  /* Add %r1 to the offset of dyncall from the next insn.  */\n-\t  output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t  output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n+\t      /* Add %r1 to the offset of dyncall from the next insn.  */\n+\t      output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+\t      output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n \n-\t  /* Get the return address into %r31.  */\n-\t  output_asm_insn (\"blr 0,%%r31\", xoperands);\n+\t      /* Get the return address into %r31.  */\n+\t      output_asm_insn (\"blr 0,%%r31\", xoperands);\n \n-\t  /* Branch to our target which is in %r1.  */\n-\t  output_asm_insn (\"bv 0(%%r1)\", xoperands);\n+\t      /* Branch to our target which is in %r1.  */\n+\t      output_asm_insn (\"bv 0(%%r1)\", xoperands);\n \n-\t  /* Copy the return address into %r2 also.  */\n-\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  /* No PIC stuff to worry about.  We can use ldil;ble.  */\n-\t  xoperands[0] = call_dest;\n+\t      /* Copy the return address into %r2 also.  */\n+\t      output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      xoperands[0] = deferred_plabels[i].internal_label;\n \n-\t  /*  Get the address of our target into %r22.  */\n-\t  output_asm_insn (\"ldil LP%%%0,%%r22\", xoperands);\n-\t  output_asm_insn (\"ldo RP%%%0(%%r22),%%r22\", xoperands);\n+\t      /* Get the address of our target into %r22.  */\n+\t      output_asm_insn (\"addil LR%%%0-$global$,%%r27\", xoperands);\n+\t      output_asm_insn (\"ldw RR%%%0-$global$(%%r1),%%r22\", xoperands);\n \n-\t  /* Get the high part of the  address of $dyncall into %r2, then\n-\t     add in the low part in the branch instruction.  */\n-\t  output_asm_insn (\"ldil L%%$$dyncall,%%r2\", xoperands);\n-\t  output_asm_insn (\"ble  R%%$$dyncall(%%sr4,%%r2)\", xoperands);\n+\t      /* Get the high part of the  address of $dyncall into %r2, then\n+\t\t add in the low part in the branch instruction.  */\n+\t      output_asm_insn (\"ldil L%%$$dyncall,%%r2\", xoperands);\n+\t      output_asm_insn (\"ble  R%%$$dyncall(%%sr4,%%r2)\", xoperands);\n \n-\t  /* Copy the return pointer into both %r31 and %r2.  */\n-\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t      /* Copy the return pointer into both %r31 and %r2.  */\n+\t      output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t    }\n \t}\n \n       /* If we had a jump in the call's delay slot, output it now.  */\n@@ -5244,9 +5294,6 @@ output_call (insn, call_dest)\n   return \"\";\n }\n \n-extern struct obstack permanent_obstack;\n-extern struct obstack *saveable_obstack;\n-\n /* In HPUX 8.0's shared library scheme, special relocations are needed\n    for function labels if they might be passed to a function\n    in a shared library (because shared libraries don't live in code"}, {"sha": "25e8d547a051c0ab2c6d14afb7c203855adae97b", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=359255a957150238a4517312232c6bd491b9c4a1", "patch": "@@ -1376,7 +1376,7 @@ extern struct rtx_def *hppa_builtin_saveregs ();\n #define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n   ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n     || (X) == CONST0_RTX (GET_MODE (X)))\t\\\n-   && !(flag_pic && function_label_operand (X, VOIDmode)))\n+   && !function_label_operand (X, VOIDmode))\n \n /* Subroutine for EXTRA_CONSTRAINT.\n \n@@ -1931,6 +1931,8 @@ do { fputs (\"\\t.SPACE $PRIVATE$\\n\\\n        output_file_directive ((FILE), main_input_filename); \\\n    } while (0)\n \n+#define ASM_FILE_END(FILE) output_deferred_plabels (FILE)\n+\n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n "}, {"sha": "9a4165c6fff758ca5fb567f33acc0188f6af5bcc", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359255a957150238a4517312232c6bd491b9c4a1/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=359255a957150238a4517312232c6bd491b9c4a1", "patch": "@@ -1585,25 +1585,6 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"4,8\")])\n \n-;; For function addresses.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(high:SI (match_operand:SI 1 \"function_label_operand\" \"\")))]\n-  \"!TARGET_PORTABLE_RUNTIME\"\n-  \"ldil LP'%G1,%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This version is used only for the portable runtime conventions model\n-;; (it does not use/support plabels)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(high:SI (match_operand:SI 1 \"function_label_operand\" \"\")))]\n-  \"TARGET_PORTABLE_RUNTIME\"\n-  \"ldil L'%G1,%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -1619,32 +1600,6 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"4\")])\n \n-;; lo_sum of a function address.\n-;;\n-;; Note since we are not supporting MPE style external calls we can\n-;; use the short ldil;ldo sequence.  If one wanted to support\n-;; MPE external calls you would want to generate something like\n-;; ldil;ldo;extru;ldw;add.  See the HP compiler's output for details.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n-  \"!TARGET_PORTABLE_RUNTIME\"\n-  \"ldo RP'%G2(%1),%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This version is used only for the portable runtime conventions model\n-;; (it does not use/support plabels)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n-  \"TARGET_PORTABLE_RUNTIME\"\n-  \"ldo R'%G2(%1),%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -4578,62 +4533,6 @@\n \t    (const_int 12)\n \t    (const_int 16))))))])\n \n-;; Simply another variant of the dbra pattern.  More restrictive\n-;; in testing the comparison operator as it must worry about overflow\n-;; problems.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t  (match_operator 2 \"eq_neq_comparison_operator\"\n-\t   [(match_operand:SI 0 \"register_operand\" \"+!r,!*f,!*m\")\n-\t    (match_operand:SI 5 \"const_int_operand\" \"\")])\n-\t  (label_ref (match_operand 3 \"\" \"\"))\n-\t  (pc)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0) (match_operand:SI 1 \"int5_operand\" \"L,L,L\")))\n-   (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n-  \"INTVAL (operands[5]) == - INTVAL (operands[1])\"\n-\"* return output_dbra (operands, insn, which_alternative);\"\n-;; Do not expect to understand this the first time through.\n-[(set_attr \"type\" \"cbranch,multi,multi\")\n- (set (attr \"length\")\n-      (if_then_else (eq_attr \"alternative\" \"0\")\n-;; Loop counter in register case\n-;; Short branch has length of 4\n-;; Long branch has length of 8\n-\t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8184))\n-           (const_int 4)\n-\t   (const_int 8))\n-\n-;; Loop counter in FP reg case.\n-;; Extra goo to deal with additional reload insns.\n-\t(if_then_else (eq_attr \"alternative\" \"1\")\n-\t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n-\t\t  (const_int 8184))\n-\t      (const_int 24)\n-\t      (const_int 28))\n-\t    (if_then_else\n-\t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8184))\n-\t      (const_int 24)\n-\t      (const_int 28)))\n-;; Loop counter in memory case.\n-;; Extra goo to deal with additional reload insns.\n-\t(if_then_else (lt (match_dup 3) (pc))\n-\t  (if_then_else\n-\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t(const_int 8184))\n-\t    (const_int 12)\n-\t    (const_int 16))\n-\t  (if_then_else\n-\t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t(const_int 8184))\n-\t    (const_int 12)\n-\t    (const_int 16))))))])\n-\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else"}]}