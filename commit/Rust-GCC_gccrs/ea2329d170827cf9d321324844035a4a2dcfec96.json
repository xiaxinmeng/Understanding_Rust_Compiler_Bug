{"sha": "ea2329d170827cf9d321324844035a4a2dcfec96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEyMzI5ZDE3MDgyN2NmOWQzMjEzMjQ4NDQwMzVhNGEyZGNmZWM5Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-08-07T11:31:16Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-07T11:31:16Z"}, "message": "Define monotonic_buffer_resource members out-of-line\n\nMove the allocation logic into libstdc++.so so that it can be changed\nwithout worrying about inlined code in existing binaries.\n\nLeave do_allocate inline so that calls to it can be devirtualized, and\nonly the slow path needs to call into the library.\n\n\t* config/abi/pre/gnu.ver: Export monotonic_buffer_resource members.\n\t* include/std/memory_resource (monotonic_buffer_resource::release):\n\tCall _M_release_buffers to free buffers.\n\t(monotonic_buffer_resource::do_allocate): Call _M_new_buffer to\n\tallocate a new buffer from upstream.\n\t(monotonic_buffer_resource::_M_new_buffer): Declare.\n\t(monotonic_buffer_resource::_M_release_buffers): Declare.\n\t(monotonic_buffer_resource::_Chunk): Replace definition with\n\tdeclaration as opaque type.\n\t* src/c++17/memory_resource.cc (monotonic_buffer_resource::_Chunk):\n\tDefine.\n\t(monotonic_buffer_resource::_M_new_buffer): Define.\n\t(monotonic_buffer_resource::_M_release_buffers): Define.\n\nFrom-SVN: r263354", "tree": {"sha": "62957004c39724b8ca85a29f12c56aa450b58fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62957004c39724b8ca85a29f12c56aa450b58fae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea2329d170827cf9d321324844035a4a2dcfec96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2329d170827cf9d321324844035a4a2dcfec96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea2329d170827cf9d321324844035a4a2dcfec96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2329d170827cf9d321324844035a4a2dcfec96/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c9291262affd31e66dec1c8af607e07a8ce2904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9291262affd31e66dec1c8af607e07a8ce2904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9291262affd31e66dec1c8af607e07a8ce2904"}], "stats": {"total": 193, "additions": 119, "deletions": 74}, "files": [{"sha": "5f098c87e4051f5b1a136426683c84b007ce6898", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ea2329d170827cf9d321324844035a4a2dcfec96", "patch": "@@ -1,3 +1,19 @@\n+2018-08-07  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* config/abi/pre/gnu.ver: Export monotonic_buffer_resource members.\n+\t* include/std/memory_resource (monotonic_buffer_resource::release):\n+\tCall _M_release_buffers to free buffers.\n+\t(monotonic_buffer_resource::do_allocate): Call _M_new_buffer to\n+\tallocate a new buffer from upstream.\n+\t(monotonic_buffer_resource::_M_new_buffer): Declare.\n+\t(monotonic_buffer_resource::_M_release_buffers): Declare.\n+\t(monotonic_buffer_resource::_Chunk): Replace definition with\n+\tdeclaration as opaque type.\n+\t* src/c++17/memory_resource.cc (monotonic_buffer_resource::_Chunk):\n+\tDefine.\n+\t(monotonic_buffer_resource::_M_new_buffer): Define.\n+\t(monotonic_buffer_resource::_M_release_buffers): Define.\n+\n 2018-08-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/bits/stl_iterator.h: Fix comment."}, {"sha": "593783da1aae11d1f9bda2f96892e317873f7bca", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=ea2329d170827cf9d321324844035a4a2dcfec96", "patch": "@@ -2043,6 +2043,8 @@ GLIBCXX_3.4.26 {\n     _ZNSt3pmr20null_memory_resourceEv;\n     _ZNSt3pmr20get_default_resourceEv;\n     _ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE;\n+    _ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferE[jmy][jmy];\n+    _ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv;\n \n } GLIBCXX_3.4.25;\n "}, {"sha": "bb4e31551e6810c03b4dbe3523665f5039b4c02d", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 18, "deletions": 74, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=ea2329d170827cf9d321324844035a4a2dcfec96", "patch": "@@ -365,7 +365,8 @@ namespace pmr\n     void\n     release() noexcept\n     {\n-      _Chunk::release(_M_head, _M_upstream);\n+      if (_M_head)\n+\t_M_release_buffers();\n \n       // reset to initial state at contruction:\n       if ((_M_current_buf = _M_orig_buf))\n@@ -392,19 +393,14 @@ namespace pmr\n       if (__bytes == 0)\n \t__bytes = 1; // Ensures we don't return the same pointer twice.\n \n-      if (auto __p = std::align(__alignment, __bytes, _M_current_buf, _M_avail))\n+      void* __p = std::align(__alignment, __bytes, _M_current_buf, _M_avail);\n+      if (!__p)\n \t{\n-\t  _M_current_buf = (char*)_M_current_buf + __bytes;\n-\t  _M_avail -= __bytes;\n-\t  return __p;\n+\t  _M_new_buffer(__bytes, __alignment);\n+\t  __p = _M_current_buf;\n \t}\n-\n-      const size_t __n = std::max(__bytes, _M_next_bufsiz);\n-      const size_t __m = std::max(__alignment, alignof(std::max_align_t));\n-      auto [__p, __size] = _Chunk::allocate(_M_upstream, __n, __m, _M_head);\n-      _M_current_buf = (char*)__p + __bytes;\n-      _M_avail = __size - __bytes;\n-      _M_next_bufsiz *= _S_growth_factor;\n+      _M_current_buf = (char*)_M_current_buf + __bytes;\n+      _M_avail -= __bytes;\n       return __p;\n     }\n \n@@ -417,6 +413,15 @@ namespace pmr\n     { return this == &__other; }\n \n   private:\n+    // Update _M_current_buf and _M_avail to refer to a new buffer with\n+    // at least the specified size and alignment, allocated from upstream.\n+    void\n+    _M_new_buffer(size_t __bytes, size_t __alignment);\n+\n+    // Deallocate all buffers obtained from upstream.\n+    void\n+    _M_release_buffers() noexcept;\n+\n     static size_t\n     _S_next_bufsize(size_t __buffer_size) noexcept\n     {\n@@ -437,68 +442,7 @@ namespace pmr\n     void* const\t\t\t_M_orig_buf = nullptr;\n     size_t const\t\t_M_orig_size = _M_next_bufsiz;\n \n-    // Memory allocated by the upstream resource is managed in a linked list\n-    // of _Chunk objects. A _Chunk object recording the size and alignment of\n-    // the allocated block and a pointer to the previous chunk is placed\n-    // at end of the block.\n-    class _Chunk\n-    {\n-    public:\n-      // Return the address and size of a block of memory allocated from __r,\n-      // of at least __size bytes and aligned to __align.\n-      // Add a new _Chunk to the front of the linked list at __head.\n-      static pair<void*, size_t>\n-      allocate(memory_resource* __r, size_t __size, size_t __align,\n-\t       _Chunk*& __head)\n-      {\n-\t__size = std::__ceil2(__size + sizeof(_Chunk));\n-\tvoid* __p = __r->allocate(__size, __align);\n-\t// Add a chunk defined by (__p, __size, __align) to linked list __head.\n-\tvoid* const __back = (char*)__p + __size - sizeof(_Chunk);\n-\t__head = ::new(__back) _Chunk(__size, __align, __head);\n-\treturn { __p, __size - sizeof(_Chunk) };\n-      }\n-\n-      // Return every chunk in linked list __head to resource __r.\n-      static void\n-      release(_Chunk*& __head, memory_resource* __r) noexcept\n-      {\n-\t_Chunk* __next = __head;\n-\t__head = nullptr;\n-\twhile (__next)\n-\t  {\n-\t    _Chunk* __ch = __next;\n-\t    __builtin_memcpy(&__next, __ch->_M_next, sizeof(_Chunk*));\n-\n-\t    __glibcxx_assert(__ch->_M_canary != 0);\n-\t    __glibcxx_assert(__ch->_M_canary == (__ch->_M_size|__ch->_M_align));\n-\n-\t    if (__ch->_M_canary != (__ch->_M_size | __ch->_M_align))\n-\t      return; // buffer overflow detected!\n-\n-\t    size_t __size = (1u << __ch->_M_size);\n-\t    size_t __align = (1u << __ch->_M_align);\n-\t    void* __start = (char*)(__ch + 1) - __size;\n-\t    __r->deallocate(__start, __size, __align);\n-\t  }\n-      }\n-\n-    private:\n-      _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept\n-      : _M_size(std::__log2p1(__size) - 1),\n-\t_M_align(std::__log2p1(__align) - 1)\n-      {\n-\t__builtin_memcpy(_M_next, &__next, sizeof(__next));\n-\t_M_canary = _M_size | _M_align;\n-      }\n-\n-      unsigned char _M_canary;\n-      unsigned char _M_size;\n-      unsigned char _M_align;\n-      unsigned char _M_next[sizeof(_Chunk*)];\n-    };\n-    static_assert(alignof(_Chunk) == 1);\n-\n+    class _Chunk;\n     _Chunk* _M_head = nullptr;\n   };\n "}, {"sha": "c3ae2b69f716bb547e5155b4bd9c9780d23ece13", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2329d170827cf9d321324844035a4a2dcfec96/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=ea2329d170827cf9d321324844035a4a2dcfec96", "patch": "@@ -104,6 +104,89 @@ namespace pmr\n   get_default_resource() noexcept\n   { return default_res.obj.load(); }\n \n+  // Member functions for std::pmr::monotonic_buffer_resource\n+\n+  // Memory allocated by the upstream resource is managed in a linked list\n+  // of _Chunk objects. A _Chunk object recording the size and alignment of\n+  // the allocated block and a pointer to the previous chunk is placed\n+  // at end of the block.\n+  class monotonic_buffer_resource::_Chunk\n+  {\n+  public:\n+    // Return the address and size of a block of memory allocated from __r,\n+    // of at least __size bytes and aligned to __align.\n+    // Add a new _Chunk to the front of the linked list at __head.\n+    static pair<void*, size_t>\n+    allocate(memory_resource* __r, size_t __size, size_t __align,\n+\t     _Chunk*& __head)\n+    {\n+      __size = std::__ceil2(__size + sizeof(_Chunk));\n+      void* __p = __r->allocate(__size, __align);\n+      // Add a chunk defined by (__p, __size, __align) to linked list __head.\n+      void* const __back = (char*)__p + __size - sizeof(_Chunk);\n+      __head = ::new(__back) _Chunk(__size, __align, __head);\n+      return { __p, __size - sizeof(_Chunk) };\n+    }\n+\n+    // Return every chunk in linked list __head to resource __r.\n+    static void\n+    release(_Chunk*& __head, memory_resource* __r) noexcept\n+    {\n+      _Chunk* __next = __head;\n+      __head = nullptr;\n+      while (__next)\n+\t{\n+\t  _Chunk* __ch = __next;\n+\t  __builtin_memcpy(&__next, __ch->_M_next, sizeof(_Chunk*));\n+\n+\t  __glibcxx_assert(__ch->_M_canary != 0);\n+\t  __glibcxx_assert(__ch->_M_canary == (__ch->_M_size|__ch->_M_align));\n+\n+\t  if (__ch->_M_canary != (__ch->_M_size | __ch->_M_align))\n+\t    return; // buffer overflow detected!\n+\n+\t  size_t __size = (1u << __ch->_M_size);\n+\t  size_t __align = (1u << __ch->_M_align);\n+\t  void* __start = (char*)(__ch + 1) - __size;\n+\t  __r->deallocate(__start, __size, __align);\n+\t}\n+    }\n+\n+  private:\n+    _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept\n+    : _M_size(std::__log2p1(__size) - 1),\n+      _M_align(std::__log2p1(__align) - 1)\n+    {\n+      __builtin_memcpy(_M_next, &__next, sizeof(__next));\n+      _M_canary = _M_size | _M_align;\n+    }\n+\n+    unsigned char _M_canary;\n+    unsigned char _M_size;\n+    unsigned char _M_align;\n+    unsigned char _M_next[sizeof(_Chunk*)];\n+  };\n+\n+  void\n+  monotonic_buffer_resource::_M_new_buffer(size_t bytes, size_t alignment)\n+  {\n+    // Need to check this somewhere, so put it here:\n+    static_assert(alignof(monotonic_buffer_resource::_Chunk) == 1);\n+\n+    const size_t n = std::max(bytes, _M_next_bufsiz);\n+    const size_t m = std::max(alignment, alignof(std::max_align_t));\n+    auto [p, size] = _Chunk::allocate(_M_upstream, n, m, _M_head);\n+    _M_current_buf = p;\n+    _M_avail = size;\n+    _M_next_bufsiz *= _S_growth_factor;\n+  }\n+\n+  void\n+  monotonic_buffer_resource::_M_release_buffers() noexcept\n+  {\n+    _Chunk::release(_M_head, _M_upstream);\n+  }\n+\n } // namespace pmr\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}]}