{"sha": "a70cb11b6cf6b16ef6b20328027a11ccb516c286", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcwY2IxMWI2Y2Y2YjE2ZWY2YjIwMzI4MDI3YTExY2NiNTE2YzI4Ng==", "commit": {"author": {"name": "Adam Megacz", "email": "megacz@gcc.gnu.org", "date": "2002-02-02T04:31:34Z"}, "committer": {"name": "Adam Megacz", "email": "megacz@gcc.gnu.org", "date": "2002-02-02T04:31:34Z"}, "message": "2002-02-01  Adam Megacz\n\n        * win32-threads.cc:\n        (_Jv_CondWait, _Jv_CondNotify, _Jv_CondNotifyAll): Corrected\n        wait() algorithm to make it safe.\n        (ensure_condvar_initialized, _Jv_CondInit, _Jv_CondDestroy):\n        Added lazy creation of Win32 Events for better performance\n        (really_start): This now uses GC_CreateThread so boehm-gc\n        knows about new threads even when statically linked.\n\nFrom-SVN: r49428", "tree": {"sha": "6ba9a208fa9b54c8678094c32ab543d83da922c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ba9a208fa9b54c8678094c32ab543d83da922c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a70cb11b6cf6b16ef6b20328027a11ccb516c286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70cb11b6cf6b16ef6b20328027a11ccb516c286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70cb11b6cf6b16ef6b20328027a11ccb516c286", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70cb11b6cf6b16ef6b20328027a11ccb516c286/comments", "author": null, "committer": null, "parents": [{"sha": "8627cc158dc97db6469d7ca0099da712c1a37189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8627cc158dc97db6469d7ca0099da712c1a37189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8627cc158dc97db6469d7ca0099da712c1a37189"}], "stats": {"total": 118, "additions": 87, "deletions": 31}, "files": [{"sha": "d26c014f86b6de98c0c64ba9f23b943e7e60b82c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70cb11b6cf6b16ef6b20328027a11ccb516c286/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70cb11b6cf6b16ef6b20328027a11ccb516c286/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a70cb11b6cf6b16ef6b20328027a11ccb516c286", "patch": "@@ -1,3 +1,13 @@\n+2002-02-01  Adam Megacz\n+\n+        * win32-threads.cc:\n+        (_Jv_CondWait, _Jv_CondNotify, _Jv_CondNotifyAll): Corrected\n+        wait() algorithm to make it safe.\n+        (ensure_condvar_initialized, _Jv_CondInit, _Jv_CondDestroy):\n+        Added lazy creation of Win32 Events for better performance\n+        (really_start): This now uses GC_CreateThread so boehm-gc\n+        knows about new threads even when statically linked.\n+\n 2002-02-01  Adam Megacz <adam@xwt.org>\n \n         * include/win32-threads.h (_Jv_ConditionVariable_t): Now a struct, to"}, {"sha": "57223305649cb07251ccdfa829226e891521c98c", "filename": "libjava/win32-threads.cc", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70cb11b6cf6b16ef6b20328027a11ccb516c286/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70cb11b6cf6b16ef6b20328027a11ccb516c286/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=a70cb11b6cf6b16ef6b20328027a11ccb516c286", "patch": "@@ -15,7 +15,6 @@ details.  */\n #ifdef HAVE_BOEHM_GC\n extern \"C\"\n {\n-#include <boehm-config.h>\n #include <gc.h>\n };\n #endif /* HAVE_BOEHM_GC */\n@@ -62,50 +61,97 @@ DWORD _Jv_ThreadDataKey;\n // Condition variables.\n //\n \n+// we do lazy creation of Events since CreateEvent() is insanely\n+// expensive, and because the rest of libgcj will call _Jv_CondInit\n+// when only a mutex is needed.\n+\n+inline void\n+ensure_condvar_initialized(_Jv_ConditionVariable_t *cv)\n+{\n+  if (cv->ev[0] == 0) {\n+    cv->ev[0] = CreateEvent (NULL, 0, 0, NULL);\n+    if (cv->ev[0] == 0) JvFail(\"CreateEvent() failed\");\n+    cv->ev[1] = CreateEvent (NULL, 1, 0, NULL);\n+    if (cv->ev[1] == 0) JvFail(\"CreateEvent() failed\");\n+  }\n+}\n+\n+// Reimplementation of the general algorithm described at\n+// http://www.cs.wustl.edu/~schmidt/win32-cv-1.html (isomorphic to\n+// 3.2, not a cut-and-paste).\n+\n int\n-_Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint nanos)\n+_Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint nanos)\n {\n-  DWORD time;\n-  DWORD rval;\n \n-  // FIXME: check for mutex ownership?\n+  EnterCriticalSection(&cv->count_mutex);\n+  ensure_condvar_initialized(cv);\n+  cv->blocked_count++;\n+  LeaveCriticalSection(&cv->count_mutex);\n+\n+  DWORD time;\n+  if ((millis == 0) && (nanos > 0)) time = 1;\n+  else if (millis == 0) time = INFINITE;\n+  else time = millis;\n \n   _Jv_MutexUnlock (mu);\n \n-  if((millis == 0) && (nanos > 0))\n-    time = 1;\n-  else if(millis == 0)\n-    time = INFINITE;\n-  else\n-    time = millis;\n+  DWORD rval = WaitForMultipleObjects (2, &(cv->ev[0]), 0, time);\n+\n+  EnterCriticalSection(&cv->count_mutex);\n+  cv->blocked_count--;\n+  // If we were unblocked by the second event (the broadcast one) and nobody is\n+  // left, then reset the signal.\n+  int last_waiter = rval == WAIT_OBJECT_0 + 1 && cv->blocked_count == 0;\n+  LeaveCriticalSection(&cv->count_mutex);\n+\n+  if (last_waiter) ResetEvent(&cv->ev[1]);\n \n-  rval = WaitForSingleObject (*cv, time);\n   _Jv_MutexLock (mu);\n \n-  if (rval == WAIT_FAILED)\n-    return _JV_NOT_OWNER;       // FIXME?\n-  else\n-    return 0;\n+  if (rval == WAIT_FAILED) return GetLastError();\n+  else if (rval == WAIT_TIMEOUT) return ETIMEDOUT;\n+  else return 0;\n }\n \n-//\n-// Mutexes.\n-//\n+void\n+_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n+{\n+  // we do lazy creation of Events since CreateEvent() is insanely expensive\n+  cv->ev[0] = 0;\n+  InitializeCriticalSection(&cv->count_mutex);\n+  cv->blocked_count = 0;\n+}\n+\n+void\n+_Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n+{\n+  if (cv->ev[0] != 0) CloseHandle(cv->ev[0]);\n+  cv = NULL;\n+}\n \n int\n-_Jv_MutexLock (_Jv_Mutex_t *mu)\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n {\n-  DWORD rval;\n+  EnterCriticalSection(&cv->count_mutex);\n+  ensure_condvar_initialized(cv);\n+  int somebody_is_blocked = cv->blocked_count > 0;\n+  LeaveCriticalSection(&cv->count_mutex);\n \n-  // FIXME: Are Win32 mutexs recursive? Should we use critical section objects\n-  rval = WaitForSingleObject (*mu, INFINITE);\n+  if (somebody_is_blocked) return SetEvent (cv->ev[0]) ? 0 : GetLastError();\n+  else return 0;\n+}\n \n-  if (rval == WAIT_FAILED)\n-    return GetLastError ();       // FIXME: Map to errno?\n-  else if (rval == WAIT_TIMEOUT)\n-    return ETIMEDOUT;\n-  else\n-    return 0;\n+int\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+{\n+  EnterCriticalSection(&cv->count_mutex);\n+  ensure_condvar_initialized(cv);\n+  int somebody_is_blocked = cv->blocked_count > 0;\n+  LeaveCriticalSection(&cv->count_mutex);\n+\n+  if (somebody_is_blocked) return SetEvent (cv->ev[1]) ? 0 : GetLastError();\n+  else return 0;\n }\n \n //\n@@ -193,7 +239,7 @@ _Jv_ThreadUnRegister ()\n // This function is called when a thread is started.  We don't arrange\n // to call the `run' method directly, because this function must\n // return a value.\n-static DWORD __stdcall\n+static DWORD WINAPI\n really_start (void* x)\n {\n   struct starter *info = (struct starter *) x;\n@@ -239,7 +285,7 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data, _Jv_ThreadStart\n   else\n     data->flags |= FLAG_DAEMON;\n \n-  HANDLE h = CreateThread(NULL, 0, really_start, info, 0, &id);\n+  HANDLE h = GC_CreateThread(NULL, 0, really_start, info, 0, &id);\n   _Jv_ThreadSetPriority(data, thread->getPriority());\n \n   //if (!h)"}]}