{"sha": "6dc8c4656444153c9e2f98d382de39728a849672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjOGM0NjU2NDQ0MTUzYzllMmY5OGQzODJkZTM5NzI4YTg0OTY3Mg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2021-08-04T16:40:10Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2021-08-04T16:40:10Z"}, "message": "IBM Z: Implement TARGET_VECTORIZE_VEC_PERM_CONST for vector merge\n\nThis patch implements the TARGET_VECTORIZE_VEC_PERM_CONST in the IBM Z\nbackend. The initial implementation only exploits the vector merge\ninstruction but there is more to come.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.c (MAX_VECT_LEN): Define macro.\n\t(struct expand_vec_perm_d): Define struct.\n\t(expand_perm_with_merge): New function.\n\t(vectorize_vec_perm_const_1): New function.\n\t(s390_vectorize_vec_perm_const): New function.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST): Define target macro.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/vector/perm-merge.c: New test.\n\t* gcc.target/s390/vector/vec-types.h: New test.", "tree": {"sha": "6bef915786fd85474decd0f2e301e52d3e00d727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bef915786fd85474decd0f2e301e52d3e00d727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc8c4656444153c9e2f98d382de39728a849672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc8c4656444153c9e2f98d382de39728a849672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc8c4656444153c9e2f98d382de39728a849672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc8c4656444153c9e2f98d382de39728a849672/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e34925ef1aeab73e022d80149be8cec92c48667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e34925ef1aeab73e022d80149be8cec92c48667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e34925ef1aeab73e022d80149be8cec92c48667"}], "stats": {"total": 244, "additions": 244, "deletions": 0}, "files": [{"sha": "8dc805f67403798eb69b95c4428f03cdbddbd2d9", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6dc8c4656444153c9e2f98d382de39728a849672", "patch": "@@ -16926,6 +16926,107 @@ s390_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &inputs,\n   return after_md_seq;\n }\n \n+#define MAX_VECT_LEN\t16\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  machine_mode vmode;\n+  unsigned char nelt;\n+  bool testing_p;\n+};\n+\n+/* Try to expand the vector permute operation described by D using the\n+   vector merge instructions vml and vmh.  Return true if vector merge\n+   could be used.  */\n+static bool\n+expand_perm_with_merge (const struct expand_vec_perm_d &d)\n+{\n+  bool merge_lo_p = true;\n+  bool merge_hi_p = true;\n+\n+  if (d.nelt % 2)\n+    return false;\n+\n+  // For V4SI this checks for: { 0, 4, 1, 5 }\n+  for (int telt = 0; telt < d.nelt; telt++)\n+    if (d.perm[telt] != telt / 2 + (telt % 2) * d.nelt)\n+      {\n+\tmerge_hi_p = false;\n+\tbreak;\n+      }\n+\n+  if (!merge_hi_p)\n+    {\n+      // For V4SI this checks for: { 2, 6, 3, 7 }\n+      for (int telt = 0; telt < d.nelt; telt++)\n+\tif (d.perm[telt] != (telt + d.nelt) / 2 + (telt % 2) * d.nelt)\n+\t  {\n+\t    merge_lo_p = false;\n+\t    break;\n+\t  }\n+    }\n+  else\n+    merge_lo_p = false;\n+\n+  if (d.testing_p)\n+    return merge_lo_p || merge_hi_p;\n+\n+  if (merge_lo_p || merge_hi_p)\n+    s390_expand_merge (d.target, d.op0, d.op1, merge_hi_p);\n+\n+  return merge_lo_p || merge_hi_p;\n+}\n+\n+/* Try to find the best sequence for the vector permute operation\n+   described by D.  Return true if the operation could be\n+   expanded.  */\n+static bool\n+vectorize_vec_perm_const_1 (const struct expand_vec_perm_d &d)\n+{\n+  if (expand_perm_with_merge (d))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if we can emit instructions for the constant\n+   permutation vector in SEL.  If OUTPUT, IN0, IN1 are non-null the\n+   hook is supposed to emit the required INSNs.  */\n+\n+bool\n+s390_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt;\n+\n+  if (!s390_vector_mode_supported_p (vmode) || GET_MODE_SIZE (vmode) != 16)\n+    return false;\n+\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+\n+  d.vmode = vmode;\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = target == NULL_RTX;\n+\n+  gcc_assert (target == NULL_RTX || REG_P (target));\n+  gcc_assert (sel.length () == nelt);\n+\n+  for (i = 0; i < nelt; i++)\n+    {\n+      unsigned char e = sel[i];\n+      gcc_assert (e < 2 * nelt);\n+      d.perm[i] = e;\n+    }\n+\n+  return vectorize_vec_perm_const_1 (d);\n+}\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -17236,6 +17337,10 @@ s390_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &inputs,\n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST s390_md_asm_adjust\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST\n+#define TARGET_VECTORIZE_VEC_PERM_CONST s390_vectorize_vec_perm_const\n+\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "51b23ddd88619e15a9ce96d79881dc76402dee71", "filename": "gcc/testsuite/gcc.target/s390/vector/perm-merge.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fperm-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fperm-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fperm-merge.c?ref=6dc8c4656444153c9e2f98d382de39728a849672", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mzarch -march=z14 -mzvector --save-temps\" } */\n+/* { dg-do run { target { s390_z14_hw } } } */\n+\n+/* { dg-final { scan-assembler-times \"\\tvmrhb\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrlb\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrhh\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrlh\\t\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrhf\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrlf\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrhg\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tvmrlg\\t\" 3 } } */\n+\n+#include \"vec-types.h\"\n+\n+#define GEN_MERGE_2(VEC_TYPE, HILO, A)\t\t\t\\\n+  VEC_TYPE __attribute__((noinline))\t\t\t\\\n+  merge_##HILO##_##VEC_TYPE(VEC_TYPE a, VEC_TYPE b) {\t\\\n+    return (VEC_TYPE){ a[0+A], b[0+A] }; }\n+\n+#define GEN_MERGE_4(VEC_TYPE, HILO, A)\t\t\t\t\\\n+  VEC_TYPE __attribute__((noinline))\t\t\t\t\\\n+  merge_##HILO##_##VEC_TYPE(VEC_TYPE a, VEC_TYPE b) {\t\t\\\n+    return (VEC_TYPE){ a[0+A], b[0+A], a[1+A], b[1+A] }; }\n+\n+#define GEN_MERGE_8(VEC_TYPE, HILO, A)\t\t\t\t\t\\\n+  VEC_TYPE __attribute__((noinline))\t\t\t\t\t\\\n+  merge_##HILO##_##VEC_TYPE(VEC_TYPE a, VEC_TYPE b) {\t\t\t\\\n+    return (VEC_TYPE){ a[0+A], b[0+A], a[1+A], b[1+A], a[2+A], b[2+A], a[3+A], b[3+A] }; }\n+\n+#define GEN_MERGE_16(VEC_TYPE, HILO, A)\t\t\t\t\t\\\n+  VEC_TYPE __attribute__((noinline))\t\t\t\t\t\\\n+  merge_##HILO##_##VEC_TYPE(VEC_TYPE a, VEC_TYPE b) {\t\t\t\\\n+    return (VEC_TYPE){ a[0+A], b[0+A], a[1+A], b[1+A], a[2+A], b[2+A], a[3+A], b[3+A], \\\n+      a[4+A], b[4+A], a[5+A], b[5+A], a[6+A], b[6+A], a[7+A], b[7+A]}; }\n+\n+\n+GEN_MERGE_16(v16qi, l, 8)\n+GEN_MERGE_16(v16qi, h, 0)\n+GEN_MERGE_16(uv16qi, l, 8)\n+GEN_MERGE_16(uv16qi, h, 0)\n+\n+GEN_MERGE_8(v8hi, l, 4)\n+GEN_MERGE_8(v8hi, h, 0)\n+GEN_MERGE_8(uv8hi, l, 4)\n+GEN_MERGE_8(uv8hi, h, 0)\n+\n+GEN_MERGE_4(v4si, l, 2)\n+GEN_MERGE_4(v4si, h, 0)\n+GEN_MERGE_4(uv4si, l, 2)\n+GEN_MERGE_4(uv4si, h, 0)\n+\n+GEN_MERGE_4(v4sf, l, 2)\n+GEN_MERGE_4(v4sf, h, 0)\n+\n+GEN_MERGE_2(v2di, l, 1)\n+GEN_MERGE_2(v2di, h, 0)\n+GEN_MERGE_2(uv2di, l, 1)\n+GEN_MERGE_2(uv2di, h, 0)\n+\n+GEN_MERGE_2(v2df, l, 1)\n+GEN_MERGE_2(v2df, h, 0)\n+\n+\n+#define CHECK_MERGE_LO(VEC_TYPE, SRC1, SRC2)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    VEC_TYPE v = merge_l_##VEC_TYPE ((SRC1), (SRC2));\t\\\n+    int elts = sizeof(v) / sizeof(v[0]);\t\t\\\n+    for (int i = 0; i < elts; i++)\t\t\t\\\n+      if (v[i] != (i + elts) / 2 + (i % 2) * elts)\t\\\n+\t__builtin_abort();\t\t\t\t\\\n+  }\n+\n+#define CHECK_MERGE_HI(VEC_TYPE, SRC1, SRC2)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    VEC_TYPE v = merge_h_##VEC_TYPE ((SRC1), (SRC2));\t\\\n+    int elts = sizeof(v) / sizeof(v[0]);\t\t\\\n+    for (int i = 0; i < elts; i++)\t\t\t\\\n+      if (v[i] != i / 2 + (i % 2) * elts)\t\t\\\n+\t__builtin_abort();\t\t\t\t\\\n+  }\n+\n+#define CHECK_MERGE(VEC_TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    VEC_TYPE a = GEN_SEQ_VEC (VEC_TYPE, 0);\t\t\t\t\\\n+    VEC_TYPE b = GEN_SEQ_VEC (VEC_TYPE, sizeof(VEC_TYPE) / sizeof(a[0])); \\\n+    CHECK_MERGE_LO (VEC_TYPE, a, b);\t\t\t\t\t\\\n+    CHECK_MERGE_HI (VEC_TYPE, a, b);\t\t\t\t\t\\\n+  }\n+\n+int\n+main ()\n+{\n+  CHECK_MERGE(v16qi);\n+  CHECK_MERGE(uv16qi);\n+  CHECK_MERGE(v8hi);\n+  CHECK_MERGE(uv8hi);\n+  CHECK_MERGE(v4si);\n+  CHECK_MERGE(uv4si);\n+  CHECK_MERGE(v4sf);\n+  CHECK_MERGE(v2di);\n+  CHECK_MERGE(uv2di);\n+  CHECK_MERGE(v2df);\n+}"}, {"sha": "b7ffbe73321b538a711b147fe72fd24c9aec655f", "filename": "gcc/testsuite/gcc.target/s390/vector/vec-types.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc8c4656444153c9e2f98d382de39728a849672/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-types.h?ref=6dc8c4656444153c9e2f98d382de39728a849672", "patch": "@@ -0,0 +1,35 @@\n+#ifndef VEC_TYPES_H\n+#define VEC_TYPES_H 1\n+\n+typedef __attribute__((vector_size(16))) signed char v16qi;\n+typedef __attribute__((vector_size(16))) unsigned char uv16qi;\n+\n+typedef __attribute__((vector_size(16))) signed short v8hi;\n+typedef __attribute__((vector_size(16))) unsigned short uv8hi;\n+\n+typedef __attribute__((vector_size(16))) signed int v4si;\n+typedef __attribute__((vector_size(16))) unsigned int uv4si;\n+\n+typedef __attribute__((vector_size(16))) signed long long v2di;\n+typedef __attribute__((vector_size(16))) unsigned long long uv2di;\n+\n+#if __SIZEOF_INT128__ == 16\n+typedef __attribute__((vector_size(16))) __int128_t v1ti;\n+#endif\n+\n+typedef __attribute__((vector_size(16))) double v2df;\n+typedef __attribute__((vector_size(16))) long double v1tf;\n+\n+#if __ARCH__ >= 12\n+typedef __attribute__((vector_size(16))) float v4sf;\n+#endif\n+\n+#define GEN_SEQ_VEC(VEC_TYPE, ADDEND)\t\t\t\t\t\\\n+  ({ VEC_TYPE dummy;\t\t\t\t\t\t\t\\\n+    const int elts = sizeof(VEC_TYPE) / sizeof(dummy[0]);\t\t\\\n+    typeof(dummy[0]) __attribute__((aligned(8))) ar[elts];\t\t\\\n+    for (int i = 0; i < elts; i++)\t\t\t\t\t\\\n+      ar[i] = (typeof(dummy[0]))(i + (ADDEND));\t\t\t\t\\\n+    *(VEC_TYPE*)ar;})\n+\n+#endif"}]}