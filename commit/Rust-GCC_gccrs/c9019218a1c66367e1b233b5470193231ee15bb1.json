{"sha": "c9019218a1c66367e1b233b5470193231ee15bb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkwMTkyMThhMWM2NjM2N2UxYjIzM2I1NDcwMTkzMjMxZWUxNWJiMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-11-26T09:35:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-11-26T09:35:35Z"}, "message": "re PR bootstrap/45700 (--enable-checking=fold bootstrap failures)\n\n\tPR bootstrap/45700\n\t* tree.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n\tbuild4_stat_loc, build5_stat_loc, build6_stat_loc): New inlines.\n\t(build1_loc, build2_loc, build3_loc, build4_loc, build5_loc,\n\tbuild6_loc): Define.\n\t* fold-const.c (protected_set_expr_location_unshare): New inline.\n\t(fold_convert_loc, pedantic_non_lvalue_loc): Use it.\n\t(negate_expr, associate_trees, non_lvalue_loc, omit_one_operand_loc,\n\tpedantic_omit_one_operand_loc, omit_two_operands_loc,\n\tfold_truth_not_expr, invert_truthvalue_loc, make_bit_field_ref,\n\toptimize_bit_field_compare, make_range, fold_range_test, fold_truthop,\n\tbuild_fold_addr_expr_with_type_loc, fold_unary_loc, fold_binary_loc,\n\tfold_indirect_ref_1, build_fold_indirect_ref_loc): Use builN_loc\n\tinstead of buildN followed by SET_EXPR_LOCATION or\n\tprotected_set_expr_location.\n\t(fold_build1_stat_loc, fold_build2_stat_loc, fold_build3_stat_loc):\n\tUse buildN_stat_loc instead of buildN_stat followed by\n\tSET_EXPR_LOCATION.\n\n\t* trans.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n\tbuild4_stat_loc): Removed.\n\t(build1_loc, build2_loc, build3_loc, build4_loc): Removed.\n\nFrom-SVN: r167168", "tree": {"sha": "4d93db2e07d692eed7e53bd5b4e69709df724266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d93db2e07d692eed7e53bd5b4e69709df724266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9019218a1c66367e1b233b5470193231ee15bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9019218a1c66367e1b233b5470193231ee15bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9019218a1c66367e1b233b5470193231ee15bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9019218a1c66367e1b233b5470193231ee15bb1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93b39277c527e4ebab79cb5c024908a1b25b7c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b39277c527e4ebab79cb5c024908a1b25b7c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b39277c527e4ebab79cb5c024908a1b25b7c07"}], "stats": {"total": 535, "additions": 243, "deletions": 292}, "files": [{"sha": "c20209ee5cb250d5f2153caf49b8d1bbea195612", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9019218a1c66367e1b233b5470193231ee15bb1", "patch": "@@ -1,3 +1,24 @@\n+2010-11-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/45700\n+\t* tree.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n+\tbuild4_stat_loc, build5_stat_loc, build6_stat_loc): New inlines.\n+\t(build1_loc, build2_loc, build3_loc, build4_loc, build5_loc,\n+\tbuild6_loc): Define.\n+\t* fold-const.c (protected_set_expr_location_unshare): New inline.\n+\t(fold_convert_loc, pedantic_non_lvalue_loc): Use it.\n+\t(negate_expr, associate_trees, non_lvalue_loc, omit_one_operand_loc,\n+\tpedantic_omit_one_operand_loc, omit_two_operands_loc,\n+\tfold_truth_not_expr, invert_truthvalue_loc, make_bit_field_ref,\n+\toptimize_bit_field_compare, make_range, fold_range_test, fold_truthop,\n+\tbuild_fold_addr_expr_with_type_loc, fold_unary_loc, fold_binary_loc,\n+\tfold_indirect_ref_1, build_fold_indirect_ref_loc): Use builN_loc\n+\tinstead of buildN followed by SET_EXPR_LOCATION or\n+\tprotected_set_expr_location.\n+\t(fold_build1_stat_loc, fold_build2_stat_loc, fold_build3_stat_loc):\n+\tUse buildN_stat_loc instead of buildN_stat followed by\n+\tSET_EXPR_LOCATION.\n+\n 2010-11-26  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* Makefile.in (s-tm-texi): Remove spurous tab."}, {"sha": "c1950733b55a6ec6f40ee772d00ece491c0ed1af", "filename": "gcc/fold-const.c", "status": "modified", "additions": 140, "deletions": 247, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c9019218a1c66367e1b233b5470193231ee15bb1", "patch": "@@ -143,6 +143,25 @@ static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_convert_const (enum tree_code, tree, tree);\n \n \n+/* Similar to protected_set_expr_location, but never modify x in place,\n+   if location can and needs to be set, unshare it.  */\n+\n+static inline tree\n+protected_set_expr_location_unshare (tree x, location_t loc)\n+{\n+  if (CAN_HAVE_LOCATION_P (x)\n+      && EXPR_LOCATION (x) != loc\n+      && !(TREE_CODE (x) == SAVE_EXPR\n+\t   || TREE_CODE (x) == TARGET_EXPR\n+\t   || TREE_CODE (x) == BIND_EXPR))\n+    {\n+      x = copy_node (x);\n+      SET_EXPR_LOCATION (x, loc);\n+    }\n+  return x;\n+}\n+\n+\n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n    and SUM1.  Then this yields nonzero if overflow occurred during the\n@@ -727,10 +746,7 @@ negate_expr (tree t)\n \n   tem = fold_negate_expr (loc, t);\n   if (!tem)\n-    {\n-      tem = build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n-      SET_EXPR_LOCATION (tem, loc);\n-    }\n+    tem = build1_loc (loc, NEGATE_EXPR, TREE_TYPE (t), t);\n   return fold_convert_loc (loc, type, tem);\n }\n \f\n@@ -841,8 +857,6 @@ split_tree (tree in, enum tree_code code, tree *conp, tree *litp,\n static tree\n associate_trees (location_t loc, tree t1, tree t2, enum tree_code code, tree type)\n {\n-  tree tem;\n-\n   if (t1 == 0)\n     return t2;\n   else if (t2 == 0)\n@@ -857,11 +871,15 @@ associate_trees (location_t loc, tree t1, tree t2, enum tree_code code, tree typ\n       if (code == PLUS_EXPR)\n \t{\n \t  if (TREE_CODE (t1) == NEGATE_EXPR)\n-\t    tem = build2 (MINUS_EXPR, type, fold_convert_loc (loc, type, t2),\n-\t\t\t  fold_convert_loc (loc, type, TREE_OPERAND (t1, 0)));\n+\t    return build2_loc (loc, MINUS_EXPR, type,\n+\t\t\t       fold_convert_loc (loc, type, t2),\n+\t\t\t       fold_convert_loc (loc, type,\n+\t\t\t\t\t\t TREE_OPERAND (t1, 0)));\n \t  else if (TREE_CODE (t2) == NEGATE_EXPR)\n-\t    tem = build2 (MINUS_EXPR, type, fold_convert_loc (loc, type, t1),\n-\t\t\t  fold_convert_loc (loc, type, TREE_OPERAND (t2, 0)));\n+\t    return build2_loc (loc, MINUS_EXPR, type,\n+\t\t\t       fold_convert_loc (loc, type, t1),\n+\t\t\t       fold_convert_loc (loc, type,\n+\t\t\t\t\t\t TREE_OPERAND (t2, 0)));\n \t  else if (integer_zerop (t2))\n \t    return fold_convert_loc (loc, type, t1);\n \t}\n@@ -871,16 +889,12 @@ associate_trees (location_t loc, tree t1, tree t2, enum tree_code code, tree typ\n \t    return fold_convert_loc (loc, type, t1);\n \t}\n \n-      tem = build2 (code, type, fold_convert_loc (loc, type, t1),\n-\t\t    fold_convert_loc (loc, type, t2));\n-      goto associate_trees_exit;\n+      return build2_loc (loc, code, type, fold_convert_loc (loc, type, t1),\n+\t\t\t fold_convert_loc (loc, type, t2));\n     }\n \n   return fold_build2_loc (loc, code, type, fold_convert_loc (loc, type, t1),\n-\t\t      fold_convert_loc (loc, type, t2));\n- associate_trees_exit:\n-  protected_set_expr_location (tem, loc);\n-  return tem;\n+\t\t\t  fold_convert_loc (loc, type, t2));\n }\n \f\n /* Check whether TYPE1 and TYPE2 are equivalent integer types, suitable\n@@ -2015,7 +2029,7 @@ fold_convert_loc (location_t loc, tree type, tree arg)\n       gcc_unreachable ();\n     }\n  fold_convert_exit:\n-  protected_set_expr_location (tem, loc);\n+  protected_set_expr_location_unshare (tem, loc);\n   return tem;\n }\n \f\n@@ -2079,9 +2093,7 @@ non_lvalue_loc (location_t loc, tree x)\n \n   if (! maybe_lvalue_p (x))\n     return x;\n-  x = build1 (NON_LVALUE_EXPR, TREE_TYPE (x), x);\n-  SET_EXPR_LOCATION (x, loc);\n-  return x;\n+  return build1_loc (loc, NON_LVALUE_EXPR, TREE_TYPE (x), x);\n }\n \n /* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n@@ -2098,16 +2110,7 @@ pedantic_non_lvalue_loc (location_t loc, tree x)\n   if (pedantic_lvalues)\n     return non_lvalue_loc (loc, x);\n \n-  if (CAN_HAVE_LOCATION_P (x)\n-      && EXPR_LOCATION (x) != loc\n-      && !(TREE_CODE (x) == SAVE_EXPR\n-\t   || TREE_CODE (x) == TARGET_EXPR\n-\t   || TREE_CODE (x) == BIND_EXPR))\n-    {\n-      x = copy_node (x);\n-      SET_EXPR_LOCATION (x, loc);\n-    }\n-  return x;\n+  return protected_set_expr_location_unshare (x, loc);\n }\n \f\n /* Given a tree comparison code, return the code that is the logical inverse\n@@ -2981,22 +2984,14 @@ omit_one_operand_loc (location_t loc, tree type, tree result, tree omitted)\n   /* If the resulting operand is an empty statement, just return the omitted\n      statement casted to void. */\n   if (IS_EMPTY_STMT (t) && TREE_SIDE_EFFECTS (omitted))\n-    {\n-      t = build1 (NOP_EXPR, void_type_node, fold_ignored_result (omitted));\n-      goto omit_one_operand_exit;\n-    }\n+    return build1_loc (loc, NOP_EXPR, void_type_node,\n+\t\t       fold_ignored_result (omitted));\n \n   if (TREE_SIDE_EFFECTS (omitted))\n-    {\n-      t = build2 (COMPOUND_EXPR, type, fold_ignored_result (omitted), t);\n-      goto omit_one_operand_exit;\n-    }\n+    return build2_loc (loc, COMPOUND_EXPR, type,\n+\t\t       fold_ignored_result (omitted), t);\n \n   return non_lvalue_loc (loc, t);\n-\n- omit_one_operand_exit:\n-  protected_set_expr_location (t, loc);\n-  return t;\n }\n \n /* Similar, but call pedantic_non_lvalue instead of non_lvalue.  */\n@@ -3010,22 +3005,14 @@ pedantic_omit_one_operand_loc (location_t loc, tree type, tree result,\n   /* If the resulting operand is an empty statement, just return the omitted\n      statement casted to void. */\n   if (IS_EMPTY_STMT (t) && TREE_SIDE_EFFECTS (omitted))\n-    {\n-      t = build1 (NOP_EXPR, void_type_node, fold_ignored_result (omitted));\n-      goto pedantic_omit_one_operand_exit;\n-    }\n+    return build1_loc (loc, NOP_EXPR, void_type_node,\n+\t\t       fold_ignored_result (omitted));\n \n   if (TREE_SIDE_EFFECTS (omitted))\n-    {\n-      t = build2 (COMPOUND_EXPR, type, fold_ignored_result (omitted), t);\n-      goto pedantic_omit_one_operand_exit;\n-    }\n+    return build2_loc (loc, COMPOUND_EXPR, type,\n+\t\t       fold_ignored_result (omitted), t);\n \n   return pedantic_non_lvalue_loc (loc, t);\n-\n- pedantic_omit_one_operand_exit:\n-  protected_set_expr_location (t, loc);\n-  return t;\n }\n \n /* Return a tree for the case when the result of an expression is RESULT\n@@ -3039,20 +3026,14 @@ pedantic_omit_one_operand_loc (location_t loc, tree type, tree result,\n \n tree\n omit_two_operands_loc (location_t loc, tree type, tree result,\n-\t\t   tree omitted1, tree omitted2)\n+\t\t       tree omitted1, tree omitted2)\n {\n   tree t = fold_convert_loc (loc, type, result);\n \n   if (TREE_SIDE_EFFECTS (omitted2))\n-    {\n-      t = build2 (COMPOUND_EXPR, type, omitted2, t);\n-      SET_EXPR_LOCATION (t, loc);\n-    }\n+    t = build2_loc (loc, COMPOUND_EXPR, type, omitted2, t);\n   if (TREE_SIDE_EFFECTS (omitted1))\n-    {\n-      t = build2 (COMPOUND_EXPR, type, omitted1, t);\n-      SET_EXPR_LOCATION (t, loc);\n-    }\n+    t = build2_loc (loc, COMPOUND_EXPR, type, omitted1, t);\n \n   return TREE_CODE (t) != COMPOUND_EXPR ? non_lvalue_loc (loc, t) : t;\n }\n@@ -3068,7 +3049,7 @@ omit_two_operands_loc (location_t loc, tree type, tree result,\n tree\n fold_truth_not_expr (location_t loc, tree arg)\n {\n-  tree t, type = TREE_TYPE (arg);\n+  tree type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n   location_t loc1, loc2;\n \n@@ -3089,9 +3070,8 @@ fold_truth_not_expr (location_t loc, tree arg)\n       if (code == ERROR_MARK)\n \treturn NULL_TREE;\n \n-      t = build2 (code, type, TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n-      SET_EXPR_LOCATION (t, loc);\n-      return t;\n+      return build2_loc (loc, code, type, TREE_OPERAND (arg, 0),\n+\t\t\t TREE_OPERAND (arg, 1));\n     }\n \n   switch (code)\n@@ -3106,10 +3086,9 @@ fold_truth_not_expr (location_t loc, tree arg)\n \tloc1 = loc;\n       if (loc2 == UNKNOWN_LOCATION)\n \tloc2 = loc;\n-      t = build2 (TRUTH_OR_EXPR, type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n-\t\t  invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n-      break;\n+      return build2_loc (loc, TRUTH_OR_EXPR, type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n+\t\t\t invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n \n     case TRUTH_OR_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n@@ -3118,10 +3097,9 @@ fold_truth_not_expr (location_t loc, tree arg)\n \tloc1 = loc;\n       if (loc2 == UNKNOWN_LOCATION)\n \tloc2 = loc;\n-      t = build2 (TRUTH_AND_EXPR, type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n-\t\t  invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n-      break;\n+      return build2_loc (loc, TRUTH_AND_EXPR, type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n+\t\t\t invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n \n     case TRUTH_XOR_EXPR:\n       /* Here we can invert either operand.  We invert the first operand\n@@ -3130,13 +3108,12 @@ fold_truth_not_expr (location_t loc, tree arg)\n \t negation of the second operand.  */\n \n       if (TREE_CODE (TREE_OPERAND (arg, 1)) == TRUTH_NOT_EXPR)\n-\tt = build2 (TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t    TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n+\treturn build2_loc (loc, TRUTH_XOR_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t\t   TREE_OPERAND (TREE_OPERAND (arg, 1), 0));\n       else\n-\tt = build2 (TRUTH_XOR_EXPR, type,\n-\t\t    invert_truthvalue_loc (loc, TREE_OPERAND (arg, 0)),\n-\t\t    TREE_OPERAND (arg, 1));\n-      break;\n+\treturn build2_loc (loc, TRUTH_XOR_EXPR, type,\n+\t\t\t   invert_truthvalue_loc (loc, TREE_OPERAND (arg, 0)),\n+\t\t\t   TREE_OPERAND (arg, 1));\n \n     case TRUTH_ANDIF_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n@@ -3145,10 +3122,9 @@ fold_truth_not_expr (location_t loc, tree arg)\n \tloc1 = loc;\n       if (loc2 == UNKNOWN_LOCATION)\n \tloc2 = loc;\n-      t = build2 (TRUTH_ORIF_EXPR, type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n-\t\t  invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n-      break;\n+      return build2_loc (loc, TRUTH_ORIF_EXPR, type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n+\t\t\t invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n \n     case TRUTH_ORIF_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n@@ -3157,10 +3133,9 @@ fold_truth_not_expr (location_t loc, tree arg)\n \tloc1 = loc;\n       if (loc2 == UNKNOWN_LOCATION)\n \tloc2 = loc;\n-      t = build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n-\t\t  invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n-      break;\n+      return build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)),\n+\t\t\t invert_truthvalue_loc (loc2, TREE_OPERAND (arg, 1)));\n \n     case TRUTH_NOT_EXPR:\n       return TREE_OPERAND (arg, 0);\n@@ -3180,22 +3155,20 @@ fold_truth_not_expr (location_t loc, tree arg)\n \t/* A COND_EXPR may have a throw as one operand, which\n \t   then has void type.  Just leave void operands\n \t   as they are.  */\n-\tt = build3 (COND_EXPR, type, TREE_OPERAND (arg, 0),\n-\t\t    VOID_TYPE_P (TREE_TYPE (arg1))\n-\t\t    ? arg1 : invert_truthvalue_loc (loc1, arg1),\n-\t\t    VOID_TYPE_P (TREE_TYPE (arg2))\n-\t\t    ? arg2 : invert_truthvalue_loc (loc2, arg2));\n-\tbreak;\n+\treturn build3_loc (loc, COND_EXPR, type, TREE_OPERAND (arg, 0),\n+\t\t\t   VOID_TYPE_P (TREE_TYPE (arg1))\n+\t\t\t   ? arg1 : invert_truthvalue_loc (loc1, arg1),\n+\t\t\t   VOID_TYPE_P (TREE_TYPE (arg2))\n+\t\t\t   ? arg2 : invert_truthvalue_loc (loc2, arg2));\n       }\n \n     case COMPOUND_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 1));\n       if (loc1 == UNKNOWN_LOCATION)\n \tloc1 = loc;\n-      t = build2 (COMPOUND_EXPR, type,\n-\t\t  TREE_OPERAND (arg, 0),\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 1)));\n-      break;\n+      return build2_loc (loc, COMPOUND_EXPR, type,\n+\t\t\t TREE_OPERAND (arg, 0),\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 1)));\n \n     case NON_LVALUE_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n@@ -3205,48 +3178,35 @@ fold_truth_not_expr (location_t loc, tree arg)\n \n     CASE_CONVERT:\n       if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n-\t{\n-\t  t = build1 (TRUTH_NOT_EXPR, type, arg);\n-\t  break;\n-\t}\n+\treturn build1_loc (loc, TRUTH_NOT_EXPR, type, arg);\n \n       /* ... fall through ...  */\n \n     case FLOAT_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n       if (loc1 == UNKNOWN_LOCATION)\n \tloc1 = loc;\n-      t = build1 (TREE_CODE (arg), type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)));\n-      break;\n+      return build1_loc (loc, TREE_CODE (arg), type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)));\n \n     case BIT_AND_EXPR:\n       if (!integer_onep (TREE_OPERAND (arg, 1)))\n \treturn NULL_TREE;\n-      t = build2 (EQ_EXPR, type, arg, build_int_cst (type, 0));\n-      break;\n+      return build2_loc (loc, EQ_EXPR, type, arg, build_int_cst (type, 0));\n \n     case SAVE_EXPR:\n-      t = build1 (TRUTH_NOT_EXPR, type, arg);\n-      break;\n+      return build1_loc (loc, TRUTH_NOT_EXPR, type, arg);\n \n     case CLEANUP_POINT_EXPR:\n       loc1 = EXPR_LOCATION (TREE_OPERAND (arg, 0));\n       if (loc1 == UNKNOWN_LOCATION)\n \tloc1 = loc;\n-      t = build1 (CLEANUP_POINT_EXPR, type,\n-\t\t  invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)));\n-      break;\n+      return build1_loc (loc, CLEANUP_POINT_EXPR, type,\n+\t\t\t invert_truthvalue_loc (loc1, TREE_OPERAND (arg, 0)));\n \n     default:\n-      t = NULL_TREE;\n-      break;\n+      return NULL_TREE;\n     }\n-\n-  if (t)\n-    SET_EXPR_LOCATION (t, loc);\n-\n-  return t;\n }\n \n /* Return a simplified tree node for the truth-negation of ARG.  This\n@@ -3266,10 +3226,7 @@ invert_truthvalue_loc (location_t loc, tree arg)\n \n   tem = fold_truth_not_expr (loc, arg);\n   if (!tem)\n-    {\n-      tem = build1 (TRUTH_NOT_EXPR, TREE_TYPE (arg), arg);\n-      SET_EXPR_LOCATION (tem, loc);\n-    }\n+    tem = build1_loc (loc, TRUTH_NOT_EXPR, TREE_TYPE (arg), arg);\n \n   return tem;\n }\n@@ -3395,9 +3352,8 @@ make_bit_field_ref (location_t loc, tree inner, tree type,\n       || TYPE_UNSIGNED (bftype) == !unsignedp)\n     bftype = build_nonstandard_integer_type (bitsize, 0);\n \n-  result = build3 (BIT_FIELD_REF, bftype, inner,\n-\t\t   size_int (bitsize), bitsize_int (bitpos));\n-  SET_EXPR_LOCATION (result, loc);\n+  result = build3_loc (loc, BIT_FIELD_REF, bftype, inner,\n+\t\t       size_int (bitsize), bitsize_int (bitpos));\n \n   if (bftype != type)\n     result = fold_convert_loc (loc, type, result);\n@@ -3576,10 +3532,8 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n \t\t\t\t  size_int (lbitpos)),\n \t\t     mask);\n \n-  lhs = build2 (code, compare_type,\n-\t\tbuild2 (BIT_AND_EXPR, unsigned_type, lhs, mask),\n-\t\trhs);\n-  SET_EXPR_LOCATION (lhs, loc);\n+  lhs = build2_loc (loc, code, compare_type,\n+\t\t    build2 (BIT_AND_EXPR, unsigned_type, lhs, mask), rhs);\n   return lhs;\n }\n \f\n@@ -4005,9 +3959,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n \n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n-\t  exp = build2 (MINUS_EXPR, exp_type, negate_expr (arg0),\n-\t\t\tbuild_int_cst (exp_type, 1));\n-\t  SET_EXPR_LOCATION (exp, loc);\n+\t  exp = build2_loc (loc, MINUS_EXPR, exp_type, negate_expr (arg0),\n+\t\t\t    build_int_cst (exp_type, 1));\n \t  continue;\n \n \tcase PLUS_EXPR:  case MINUS_EXPR:\n@@ -4925,13 +4878,9 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n \t unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in\n \t which cases we can't do this.  */\n       if (simple_operand_p (lhs))\n-\t{\n-\t  tem = build2 (code == TRUTH_ANDIF_EXPR\n-\t\t\t? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t\ttype, op0, op1);\n-\t  SET_EXPR_LOCATION (tem, loc);\n-\t  return tem;\n-\t}\n+\treturn build2_loc (loc, code == TRUTH_ANDIF_EXPR\n+\t\t\t   ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\t   type, op0, op1);\n \n       else if (lang_hooks.decls.global_bindings_p () == 0\n \t       && ! CONTAINS_PLACEHOLDER_P (lhs))\n@@ -4948,11 +4897,9 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n \t      if (strict_overflow_p)\n \t\tfold_overflow_warning (warnmsg,\n \t\t\t\t       WARN_STRICT_OVERFLOW_COMPARISON);\n-\t      tem = build2 (code == TRUTH_ANDIF_EXPR\n-\t\t\t    ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t\t    type, lhs, rhs);\n-\t      SET_EXPR_LOCATION (tem, loc);\n-\t      return tem;\n+\t      return build2_loc (loc, code == TRUTH_ANDIF_EXPR\n+\t\t\t\t ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\t\t type, lhs, rhs);\n \t    }\n \t}\n     }\n@@ -5166,7 +5113,6 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n   if (simple_operand_p (ll_arg)\n       && simple_operand_p (lr_arg))\n     {\n-      tree result;\n       if (operand_equal_p (ll_arg, rl_arg, 0)\n           && operand_equal_p (lr_arg, rr_arg, 0))\n \t{\n@@ -5207,35 +5153,26 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \t  && rcode == NE_EXPR && integer_zerop (rr_arg)\n \t  && TREE_TYPE (ll_arg) == TREE_TYPE (rl_arg)\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (ll_arg)))\n-\t{\n-\t  result = build2 (NE_EXPR, truth_type,\n+\treturn build2_loc (loc, NE_EXPR, truth_type,\n \t\t\t   build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t\t   ll_arg, rl_arg),\n \t\t\t   build_int_cst (TREE_TYPE (ll_arg), 0));\n-\t  goto fold_truthop_exit;\n-\t}\n \n       /* Convert (a == 0) && (b == 0) into (a | b) == 0.  */\n       if (code == TRUTH_AND_EXPR\n \t  && lcode == EQ_EXPR && integer_zerop (lr_arg)\n \t  && rcode == EQ_EXPR && integer_zerop (rr_arg)\n \t  && TREE_TYPE (ll_arg) == TREE_TYPE (rl_arg)\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (ll_arg)))\n-\t{\n-\t  result = build2 (EQ_EXPR, truth_type,\n+\treturn build2_loc (loc, EQ_EXPR, truth_type,\n \t\t\t   build2 (BIT_IOR_EXPR, TREE_TYPE (ll_arg),\n \t\t\t\t   ll_arg, rl_arg),\n \t\t\t   build_int_cst (TREE_TYPE (ll_arg), 0));\n-\t  goto fold_truthop_exit;\n-\t}\n \n       if (LOGICAL_OP_NON_SHORT_CIRCUIT)\n \t{\n \t  if (code != orig_code || lhs != orig_lhs || rhs != orig_rhs)\n-\t    {\n-\t      result = build2 (code, truth_type, lhs, rhs);\n-\t      goto fold_truthop_exit;\n-\t    }\n+\t    return build2_loc (loc, code, truth_type, lhs, rhs);\n \t  return NULL_TREE;\n \t}\n     }\n@@ -5426,8 +5363,7 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \t  if (! all_ones_mask_p (lr_mask, rnbitsize))\n \t    rhs = build2 (BIT_AND_EXPR, rntype, rhs, lr_mask);\n \n-\t  result = build2 (wanted_code, truth_type, lhs, rhs);\n-\t  goto fold_truthop_exit;\n+\t  return build2_loc (loc, wanted_code, truth_type, lhs, rhs);\n \t}\n \n       /* There is still another way we can do something:  If both pairs of\n@@ -5480,8 +5416,7 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \t  if (! all_ones_mask_p (lr_mask, lr_bitsize + rr_bitsize))\n \t    rhs = build2 (BIT_AND_EXPR, type, rhs, lr_mask);\n \n-\t  result = build2 (wanted_code, truth_type, lhs, rhs);\n-\t  goto fold_truthop_exit;\n+\t  return build2_loc (loc, wanted_code, truth_type, lhs, rhs);\n \t}\n \n       return 0;\n@@ -5517,17 +5452,10 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \n   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);\n   if (! all_ones_mask_p (ll_mask, lnbitsize))\n-    {\n-      result = build2 (BIT_AND_EXPR, lntype, result, ll_mask);\n-      SET_EXPR_LOCATION (result, loc);\n-    }\n+    result = build2_loc (loc, BIT_AND_EXPR, lntype, result, ll_mask);\n \n-  result = build2 (wanted_code, truth_type, result,\n-\t\t   const_binop (BIT_IOR_EXPR, l_const, r_const));\n-\n- fold_truthop_exit:\n-  SET_EXPR_LOCATION (result, loc);\n-  return result;\n+  return build2_loc (loc, wanted_code, truth_type, result,\n+\t\t     const_binop (BIT_IOR_EXPR, l_const, r_const));\n }\n \f\n /* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a\n@@ -7616,10 +7544,7 @@ build_fold_addr_expr_with_type_loc (location_t loc, tree t, tree ptrtype)\n       t = TREE_OPERAND (t, 0);\n \n       if (TREE_TYPE (t) != ptrtype)\n-\t{\n-\t  t = build1 (NOP_EXPR, ptrtype, t);\n-\t  SET_EXPR_LOCATION (t, loc);\n-\t}\n+\tt = build1_loc (loc, NOP_EXPR, ptrtype, t);\n     }\n   else if (TREE_CODE (t) == MEM_REF\n       && integer_zerop (TREE_OPERAND (t, 1)))\n@@ -7632,10 +7557,7 @@ build_fold_addr_expr_with_type_loc (location_t loc, tree t, tree ptrtype)\n \tt = fold_convert_loc (loc, ptrtype, t);\n     }\n   else\n-    {\n-      t = build1 (ADDR_EXPR, ptrtype, t);\n-      SET_EXPR_LOCATION (t, loc);\n-    }\n+    t = build1_loc (loc, ADDR_EXPR, ptrtype, t);\n \n   return t;\n }\n@@ -7736,16 +7658,14 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t\t\t (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))))\n \t\t     && TYPE_PRECISION (TREE_TYPE (tem)) <= BITS_PER_WORD)\n \t\t  || flag_syntax_only))\n-\t    {\n-\t      tem = build1 (code, type,\n-\t\t\t    build3 (COND_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t       (TREE_OPERAND (tem, 1), 0)),\n-\t\t\t\t    TREE_OPERAND (tem, 0),\n-\t\t\t\t    TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n-\t\t\t\t    TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n-\t      SET_EXPR_LOCATION (tem, loc);\n-\t    }\n+\t    tem = build1_loc (loc, code, type,\n+\t\t\t      build3 (COND_EXPR,\n+\t\t\t\t      TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t\t (TREE_OPERAND (tem, 1), 0)),\n+\t\t\t\t      TREE_OPERAND (tem, 0),\n+\t\t\t\t      TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n+\t\t\t\t      TREE_OPERAND (TREE_OPERAND (tem, 2),\n+\t\t\t\t\t\t    0)));\n \t  return tem;\n \t}\n       else if (COMPARISON_CLASS_P (arg0))\n@@ -7908,10 +7828,9 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t     unless assigning a bitfield.  */\n \t  tem = fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 1));\n \t  /* First do the assignment, then return converted constant.  */\n-\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), op0, tem);\n+\t  tem = build2_loc (loc, COMPOUND_EXPR, TREE_TYPE (tem), op0, tem);\n \t  TREE_NO_WARNING (tem) = 1;\n \t  TREE_USED (tem) = 1;\n-\t  SET_EXPR_LOCATION (tem, loc);\n \t  return tem;\n \t}\n \n@@ -9533,17 +9452,17 @@ fold_binary_loc (location_t loc,\n \t  tem = fold_build2_loc (loc, code, type,\n \t\t\t     fold_convert_loc (loc, TREE_TYPE (op0),\n \t\t\t\t\t       TREE_OPERAND (arg0, 1)), op1);\n-\t  tem = build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0), tem);\n-\t  goto fold_binary_exit;\n+\t  return build2_loc (loc, COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     tem);\n \t}\n       if (TREE_CODE (arg1) == COMPOUND_EXPR\n \t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n \t{\n \t  tem = fold_build2_loc (loc, code, type, op0,\n \t\t\t     fold_convert_loc (loc, TREE_TYPE (op1),\n \t\t\t\t\t       TREE_OPERAND (arg1, 1)));\n-\t  tem = build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0), tem);\n-\t  goto fold_binary_exit;\n+\t  return build2_loc (loc, COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n+\t\t\t     tem);\n \t}\n \n       if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n@@ -9942,12 +9861,10 @@ fold_binary_loc (location_t loc,\n \t\t&& ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n \t\t    == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n \t      {\n-\t\ttem = build2 (LROTATE_EXPR,\n-\t\t\t      TREE_TYPE (TREE_OPERAND (arg0, 0)),\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      code0 == LSHIFT_EXPR\n-\t\t\t      ? tree01 : tree11);\n-\t\tSET_EXPR_LOCATION (tem, loc);\n+\t\ttem = build2_loc (loc, LROTATE_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_OPERAND (arg0, 0)),\n+\t\t\t\t  TREE_OPERAND (arg0, 0),\n+\t\t\t\t  code0 == LSHIFT_EXPR ? tree01 : tree11);\n \t\treturn fold_convert_loc (loc, type, tem);\n \t      }\n \t    else if (code11 == MINUS_EXPR)\n@@ -13142,28 +13059,22 @@ fold_binary_loc (location_t loc,\n \t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && TREE_CODE (arg1) == LSHIFT_EXPR\n \t  && integer_onep (TREE_OPERAND (arg1, 0)))\n-\t{\n-\t  tem = build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\tTREE_OPERAND (arg1, 1)),\n-\t\t\tbuild_int_cst (TREE_TYPE (arg0), 0));\n-\t  goto fold_binary_exit;\n-\t}\n+\treturn build2_loc (loc, code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n+\t\t\t   build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t\t   TREE_OPERAND (arg1, 1)),\n+\t\t\t   build_int_cst (TREE_TYPE (arg0), 0));\n \n       if ((code == LT_EXPR || code == GE_EXPR)\n \t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t  && CONVERT_EXPR_P (arg1)\n \t  && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n \t  && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n \t{\n-\t  tem = build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t\tfold_convert_loc (loc, TREE_TYPE (arg0),\n-\t\t\t\t\t  build2 (RSHIFT_EXPR,\n-\t\t\t\t\t\t  TREE_TYPE (arg0), arg0,\n-\t\t\t\t\t\t  TREE_OPERAND (TREE_OPERAND (arg1, 0),\n-\t\t\t\t\t\t\t\t1))),\n-\t\t\tbuild_int_cst (TREE_TYPE (arg0), 0));\n-\t  goto fold_binary_exit;\n+\t  tem = build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\tTREE_OPERAND (TREE_OPERAND (arg1, 0), 1));\n+\t  return build2_loc (loc, code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n+\t\t\t     fold_convert_loc (loc, TREE_TYPE (arg0), tem),\n+\t\t\t     build_int_cst (TREE_TYPE (arg0), 0));\n \t}\n \n       return NULL_TREE;\n@@ -13257,9 +13168,6 @@ fold_binary_loc (location_t loc,\n     default:\n       return NULL_TREE;\n     } /* switch (code) */\n- fold_binary_exit:\n-  protected_set_expr_location (tem, loc);\n-  return tem;\n }\n \n /* Callback for walk_tree, looking for LABEL_EXPR.  Return *TP if it is\n@@ -14026,10 +13934,7 @@ fold_build1_stat_loc (location_t loc,\n \n   tem = fold_unary_loc (loc, code, type, op0);\n   if (!tem)\n-    {\n-      tem = build1_stat (code, type, op0 PASS_MEM_STAT);\n-      SET_EXPR_LOCATION (tem, loc);\n-    }\n+    tem = build1_stat_loc (loc, code, type, op0 PASS_MEM_STAT);\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n@@ -14077,10 +13982,7 @@ fold_build2_stat_loc (location_t loc,\n \n   tem = fold_binary_loc (loc, code, type, op0, op1);\n   if (!tem)\n-    {\n-      tem = build2_stat (code, type, op0, op1 PASS_MEM_STAT);\n-      SET_EXPR_LOCATION (tem, loc);\n-    }\n+    tem = build2_stat_loc (loc, code, type, op0, op1 PASS_MEM_STAT);\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n@@ -14142,10 +14044,7 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n   gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n   tem = fold_ternary_loc (loc, code, type, op0, op1, op2);\n   if (!tem)\n-    {\n-      tem =  build3_stat (code, type, op0, op1, op2 PASS_MEM_STAT);\n-      SET_EXPR_LOCATION (tem, loc);\n-    }\n+    tem = build3_stat_loc (loc, code, type, op0, op1, op2 PASS_MEM_STAT);\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n@@ -15661,9 +15560,8 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t  tree min_val = size_zero_node;\n \t  if (type_domain && TYPE_MIN_VALUE (type_domain))\n \t    min_val = TYPE_MIN_VALUE (type_domain);\n-\t  op0 = build4 (ARRAY_REF, type, op, min_val, NULL_TREE, NULL_TREE);\n-\t  SET_EXPR_LOCATION (op0, loc);\n-\t  return op0;\n+\t  return build4_loc (loc, ARRAY_REF, type, op, min_val,\n+\t\t\t     NULL_TREE, NULL_TREE);\n \t}\n       /* *(foo *)&complexfoo => __real__ complexfoo */\n       else if (TREE_CODE (optype) == COMPLEX_TYPE\n@@ -15727,10 +15625,8 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t      op01 = size_binop_loc (loc, EXACT_DIV_EXPR, op01,\n \t\t\t\t     TYPE_SIZE_UNIT (type));\n \t      op01 = size_binop_loc (loc, PLUS_EXPR, op01, min_val);\n-\t      op0 = build4 (ARRAY_REF, type, op00, op01,\n-\t\t\t    NULL_TREE, NULL_TREE);\n-\t      SET_EXPR_LOCATION (op0, loc);\n-\t      return op0;\n+\t      return build4_loc (loc, ARRAY_REF, type, op00, op01,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n \t    }\n \t}\n     }\n@@ -15745,9 +15641,8 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n       type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n       if (type_domain && TYPE_MIN_VALUE (type_domain))\n \tmin_val = TYPE_MIN_VALUE (type_domain);\n-      op0 = build4 (ARRAY_REF, type, sub, min_val, NULL_TREE, NULL_TREE);\n-      SET_EXPR_LOCATION (op0, loc);\n-      return op0;\n+      return build4_loc (loc, ARRAY_REF, type, sub, min_val, NULL_TREE,\n+\t\t\t NULL_TREE);\n     }\n \n   return NULL_TREE;\n@@ -15765,9 +15660,7 @@ build_fold_indirect_ref_loc (location_t loc, tree t)\n   if (sub)\n     return sub;\n \n-  t = build1 (INDIRECT_REF, type, t);\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n+  return build1_loc (loc, INDIRECT_REF, type, t);\n }\n \n /* Given an INDIRECT_REF T, return either T or a simplified version.  */"}, {"sha": "51ca33f57c5bf7fc75e8264ce2746292403d901f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c9019218a1c66367e1b233b5470193231ee15bb1", "patch": "@@ -756,51 +756,6 @@ struct GTY((variable_size)) lang_decl {\n   (TYPE_LANG_SPECIFIC(node)->base_decl[(internal)])\n \n \n-/* Create _loc version of build[0-9].  */\n-\n-static inline tree\n-build1_stat_loc (location_t loc, enum tree_code code, tree type,\n-\t\t tree op MEM_STAT_DECL)\n-{\n-  tree t = build1_stat (code, type, op PASS_MEM_STAT);\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n-}\n-#define build1_loc(l,c,t1,t2) build1_stat_loc (l,c,t1,t2 MEM_STAT_INFO)\n-\n-static inline tree\n-build2_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n-\t\t tree op MEM_STAT_DECL)\n-{\n-  tree t = build2_stat (code, type, arg0, op PASS_MEM_STAT);\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n-}\n-#define build2_loc(l,c,t1,t2,t3) build2_stat_loc (l,c,t1,t2,t3 MEM_STAT_INFO)\n-\n-static inline tree\n-build3_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n-\t\t tree arg1, tree op MEM_STAT_DECL)\n-{\n-  tree t = build3_stat (code, type, arg0, arg1, op PASS_MEM_STAT);\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n-}\n-#define build3_loc(l,c,t1,t2,t3,t4) \\\n-  build3_stat_loc (l,c,t1,t2,t3,t4 MEM_STAT_INFO)\n-\n-static inline tree\n-build4_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n-\t\t tree arg1, tree arg2, tree op MEM_STAT_DECL)\n-{\n-  tree t = build4_stat (code, type, arg0, arg1, arg2, op PASS_MEM_STAT);\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n-}\n-#define build4_loc(l,c,t1,t2,t3,t4,t5) \\\n-  build4_stat_loc (l,c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n-\n-\n /* Build an expression with void type.  */\n #define build1_v(code, arg) \\\n \tfold_build1_loc (input_location, code, void_type_node, arg)"}, {"sha": "2f4df678dcf5051b8d22b4e4f32b62109446b79a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9019218a1c66367e1b233b5470193231ee15bb1", "patch": "@@ -1,3 +1,10 @@\n+2010-11-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/45700\n+\t* trans.h (build1_stat_loc, build2_stat_loc, build3_stat_loc,\n+\tbuild4_stat_loc): Removed.\n+\t(build1_loc, build2_loc, build3_loc, build4_loc): Removed.\n+\n 2010-11-25  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/46581"}, {"sha": "14fe7aa679932c24fae9c6d47a7bb650fff5c7cf", "filename": "gcc/tree.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9019218a1c66367e1b233b5470193231ee15bb1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c9019218a1c66367e1b233b5470193231ee15bb1", "patch": "@@ -4034,6 +4034,81 @@ extern tree build6_stat (enum tree_code, tree, tree, tree, tree, tree,\n #define build6(c,t1,t2,t3,t4,t5,t6,t7) \\\n   build6_stat (c,t1,t2,t3,t4,t5,t6,t7 MEM_STAT_INFO)\n \n+/* _loc versions of build[1-6].  */\n+\n+static inline tree\n+build1_stat_loc (location_t loc, enum tree_code code, tree type,\n+\t\t tree arg1 MEM_STAT_DECL)\n+{\n+  tree t = build1_stat (code, type, arg1 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build1_loc(l,c,t1,t2) build1_stat_loc (l,c,t1,t2 MEM_STAT_INFO)\n+\n+static inline tree\n+build2_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1 MEM_STAT_DECL)\n+{\n+  tree t = build2_stat (code, type, arg0, arg1 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build2_loc(l,c,t1,t2,t3) build2_stat_loc (l,c,t1,t2,t3 MEM_STAT_INFO)\n+\n+static inline tree\n+build3_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree arg2 MEM_STAT_DECL)\n+{\n+  tree t = build3_stat (code, type, arg0, arg1, arg2 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build3_loc(l,c,t1,t2,t3,t4) \\\n+  build3_stat_loc (l,c,t1,t2,t3,t4 MEM_STAT_INFO)\n+\n+static inline tree\n+build4_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree arg2, tree arg3 MEM_STAT_DECL)\n+{\n+  tree t = build4_stat (code, type, arg0, arg1, arg2, arg3 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build4_loc(l,c,t1,t2,t3,t4,t5) \\\n+  build4_stat_loc (l,c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n+\n+static inline tree\n+build5_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree arg2, tree arg3, tree arg4 MEM_STAT_DECL)\n+{\n+  tree t = build5_stat (code, type, arg0, arg1, arg2, arg3,\n+\t\t\targ4 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build5_loc(l,c,t1,t2,t3,t4,t5,t6) \\\n+  build5_stat_loc (l,c,t1,t2,t3,t4,t5,t6 MEM_STAT_INFO)\n+\n+static inline tree\n+build6_stat_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n+\t\t tree arg1, tree arg2, tree arg3, tree arg4,\n+\t\t tree arg5 MEM_STAT_DECL)\n+{\n+  tree t = build6_stat (code, type, arg0, arg1, arg2, arg3, arg4,\n+\t\t\targ5 PASS_MEM_STAT);\n+  if (CAN_HAVE_LOCATION_P (t))\n+    SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+#define build6_loc(l,c,t1,t2,t3,t4,t5,t6,t7) \\\n+  build6_stat_loc (l,c,t1,t2,t3,t4,t5,t6,t7 MEM_STAT_INFO)\n+\n extern tree build_var_debug_value_stat (tree, tree MEM_STAT_DECL);\n #define build_var_debug_value(t1,t2) \\\n   build_var_debug_value_stat (t1,t2 MEM_STAT_INFO)"}]}