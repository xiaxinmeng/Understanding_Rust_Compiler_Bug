{"sha": "0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "node_id": "C_kwDOANBUbNoAKDAxMjJmYWFlMzBmZTFhZDFkZmE4YzY5ZjNkM2YwNDI4Yjk5NmI2MDA", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-10-31T10:11:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-11-01T10:04:48Z"}, "message": "c++: Reorganize per-scope lambda discriminators\n\nWe currently use a per-extra-scope counter to discriminate multiple\nlambdas in a particular such scope.  This is not ABI compliant.  This\npatch merely refactors the existing code to make it easier to drop in\na conformant mangling -- there's no functional change here.  I rename\nthe LAMBDA_EXPR_DISCIMINATOR to LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR,\nforeshadowing that there'll be a new discriminator.  To provide ABI\nwarnings we'll need to calculate both, and that requires some\nrepacking of the lambda_expr's fields.  Finally, although we end up\ncalling the discriminator setter and the scope recorder (nearly)\nalways consecutively, it's clearer to handle it as two separate\noperations.  That also allows us to remove the instantiation\nspecial-case for a null extra-scope.\n\n\tgcc/cp/\n\t* cp-tree.h (LAMBDA_EXPR_DISCRIMINATOR): Rename to ...\n\t(LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR): ... here.\n\t(struct tree_lambda_expr): Make default_capture_mode &\n\tdiscriminator_scope bitfields.\n\t(record_null_lambda_scope) Delete.\n\t(record_lambda_scope_discriminator): Declare.\n\t* lambda.cc (struct lambda_discriminator): New struct.\n\t(lambda_scope, lambda_scope_stack): Adjust types.\n\t(lambda_count): Delete.\n\t(struct tree_int): Delete.\n\t(start_lambda_scope, finish_lambda_scope): Adjust.\n\t(record_lambda_scope): Only record the scope.\n\t(record_lambda_scope_discriminator): New.\n\t* mangle.cc (write_closure_type_name): Adjust.\n\t* module.cc (trees_out::core_vals): Likewise,\n\t(trees_in::core_vals): Likewise.\n\t* parser.cc (cp_parser_lambda_expression): Call\n\trecord_lambda_scope_discriminator.\n\t* pt.cc (tsubst_lambda_expr): Adjust record_lambda_scope caling.  Call\n\trecord_lambda_scope_discriminator. Commonize control flow on tsubsting\n\tthe operator function.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_start_closure): Adjust.\n\tgcc/testsuite/\n\t* g++.dg/abi/lambda-sig1-17.C: New.\n\t* g++.dg/abi/lambda-sig1.h: New.\n\t* g++.dg/cpp1y/lambda-mangle-1.C: Extracted to ...\n\t* g++.dg/cpp1y/lambda-mangle-1.h: ... here.\n\t* g++.dg/cpp1y/lambda-mangle-1-11.C: New\n\t* g++.dg/cpp1y/lambda-mangle-1-17.C", "tree": {"sha": "b22a5db786c232d8636ce81e8898afc4a66c7340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22a5db786c232d8636ce81e8898afc4a66c7340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4acc4c2be84d66075d60736623c3a7134d129eaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4acc4c2be84d66075d60736623c3a7134d129eaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4acc4c2be84d66075d60736623c3a7134d129eaa"}], "stats": {"total": 297, "additions": 199, "deletions": 98}, "files": [{"sha": "4c0bacb91da1f3ca1dc7bb9fe09449a5be5a82d5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -1500,9 +1500,10 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_EXTRA_SCOPE(NODE) \\\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->extra_scope)\n \n-/* If EXTRA_SCOPE, this is the number of the lambda within that scope.  */\n-#define LAMBDA_EXPR_DISCRIMINATOR(NODE) \\\n-  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator)\n+/* Lambdas in the same extra scope might need a discriminating count.\n+   This is a single per-scope count.  */\n+#define LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator_scope)\n \n /* During parsing of the lambda, a vector of capture proxies which need\n    to be pushed once we're done processing a nested lambda.  */\n@@ -1530,8 +1531,8 @@ struct GTY (()) tree_lambda_expr\n   tree regen_info;\n   vec<tree, va_gc> *pending_proxies;\n   location_t locus;\n-  enum cp_lambda_default_capture_mode_type default_capture_mode : 8;\n-  short int discriminator;\n+  enum cp_lambda_default_capture_mode_type default_capture_mode : 2;\n+  unsigned discriminator_scope : 15; // Per-scope discriminator\n };\n \n /* Non-zero if this template specialization has access violations that\n@@ -7778,10 +7779,10 @@ extern tree cp_build_vec_convert\t\t(tree, location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_build_bit_cast\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern void start_lambda_scope\t\t\t(tree);\n-extern void record_lambda_scope\t\t\t(tree);\n-extern void record_null_lambda_scope\t\t(tree);\n+extern void start_lambda_scope\t\t\t(tree decl);\n extern void finish_lambda_scope\t\t\t(void);\n+extern void record_lambda_scope\t\t\t(tree lambda);\n+extern void record_lambda_scope_discriminator\t(tree lambda);\n extern tree start_lambda_function\t\t(tree fn, tree lambda_expr);\n extern void finish_lambda_function\t\t(tree body);\n extern bool regenerated_lambda_fn_p\t\t(tree);"}, {"sha": "d2673e2ceebadaa4dadb3e374b0cccf69ed34892", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -1444,79 +1444,77 @@ is_lambda_ignored_entity (tree val)\n   return false;\n }\n \n-/* Lambdas that appear in variable initializer or default argument scope\n-   get that in their mangling, so we need to record it.  We might as well\n-   use the count for function and namespace scopes as well.  */\n-static GTY(()) tree lambda_scope;\n-static GTY(()) int lambda_count;\n-struct GTY(()) tree_int\n+/* Lambdas that appear in variable initializer or default argument\n+   scope get that in their mangling, so we need to record it.  Also,\n+   multiple lambdas in the same scope may need a mangling\n+   discriminator.  Record in the same data structure.  */\n+struct GTY(()) lambda_discriminator\n {\n-  tree t;\n-  int i;\n+  tree scope;\n+  unsigned nesting; // Inside a function, VAR_DECLs get the function\n+  \t\t    // as scope. This counts that nesting.\n+  unsigned count;   // The per-scope counter.\n };\n-static GTY(()) vec<tree_int, va_gc> *lambda_scope_stack;\n+// The current scope.\n+static GTY(()) lambda_discriminator lambda_scope;\n+// Stack of previous scopes.\n+static GTY(()) vec<lambda_discriminator, va_gc> *lambda_scope_stack;\n+\n+// Push DECL as lambda extra scope, also new discriminator counters.\n \n void\n start_lambda_scope (tree decl)\n {\n-  tree_int ti;\n-  gcc_assert (decl);\n-  /* Once we're inside a function, we ignore variable scope and just push\n-     the function again so that popping works properly.  */\n+  gcc_checking_assert (decl);\n   if (current_function_decl && TREE_CODE (decl) == VAR_DECL)\n-    decl = current_function_decl;\n-  ti.t = lambda_scope;\n-  ti.i = lambda_count;\n-  vec_safe_push (lambda_scope_stack, ti);\n-  if (lambda_scope != decl)\n+    // If we're inside a function, we ignore variable scope.  Don't push.\n+    lambda_scope.nesting++;\n+  else\n     {\n-      /* Don't reset the count if we're still in the same function.  */\n-      lambda_scope = decl;\n-      lambda_count = 0;\n+      vec_safe_push (lambda_scope_stack, lambda_scope);\n+      lambda_scope.scope = decl;\n+      lambda_scope.nesting = 0;\n+      lambda_scope.count = 0;\n     }\n }\n \n+// Pop from the current lambda extra scope.\n+\n void\n-record_lambda_scope (tree lambda)\n+finish_lambda_scope (void)\n {\n-  LAMBDA_EXPR_EXTRA_SCOPE (lambda) = lambda_scope;\n-  LAMBDA_EXPR_DISCRIMINATOR (lambda) = lambda_count++;\n-  if (lambda_scope)\n+  if (!lambda_scope.nesting--)\n     {\n-      tree closure = LAMBDA_EXPR_CLOSURE (lambda);\n-      gcc_checking_assert (closure);\n-      maybe_key_decl (lambda_scope, TYPE_NAME (closure));\n+      lambda_scope = lambda_scope_stack->last ();\n+      lambda_scope_stack->pop ();\n     }\n }\n \n-/* This lambda is an instantiation of a lambda in a template default argument\n-   that got no LAMBDA_EXPR_EXTRA_SCOPE, so this shouldn't either.  But we do\n-   need to use and increment the global count to avoid collisions.  */\n+// Record the current lambda scope into LAMBDA\n \n void\n-record_null_lambda_scope (tree lambda)\n+record_lambda_scope (tree lambda)\n {\n-  if (vec_safe_is_empty (lambda_scope_stack))\n-    record_lambda_scope (lambda);\n-  else\n+  LAMBDA_EXPR_EXTRA_SCOPE (lambda) = lambda_scope.scope;\n+  if (lambda_scope.scope)\n     {\n-      tree_int *p = lambda_scope_stack->begin();\n-      LAMBDA_EXPR_EXTRA_SCOPE (lambda) = p->t;\n-      LAMBDA_EXPR_DISCRIMINATOR (lambda) = p->i++;\n+      tree closure = LAMBDA_EXPR_CLOSURE (lambda);\n+      gcc_checking_assert (closure);\n+      maybe_key_decl (lambda_scope.scope, TYPE_NAME (closure));\n     }\n-  gcc_assert (LAMBDA_EXPR_EXTRA_SCOPE (lambda) == NULL_TREE);\n }\n \n+// Record the per-scope discriminator of LAMBDA.  If the extra scope\n+// is empty, we must use the empty scope counter, which might not be\n+// the live one.\n+\n void\n-finish_lambda_scope (void)\n+record_lambda_scope_discriminator (tree lambda)\n {\n-  tree_int *p = &lambda_scope_stack->last ();\n-  if (lambda_scope != p->t)\n-    {\n-      lambda_scope = p->t;\n-      lambda_count = p->i;\n-    }\n-  lambda_scope_stack->pop ();\n+  auto *slot = (vec_safe_is_empty (lambda_scope_stack)\n+\t\t|| LAMBDA_EXPR_EXTRA_SCOPE (lambda)\n+\t\t? &lambda_scope : lambda_scope_stack->begin ());\n+  LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda) = slot->count++;\n }\n \n tree\n@@ -1648,6 +1646,10 @@ prune_lambda_captures (tree body)\n     }\n }\n \n+// Record the per-scope per-signature discriminator of LAMBDA.  If the\n+// extra scope is empty, we must use the empty scope counter, which\n+// might not be the live one.\n+\n void\n finish_lambda_function (tree body)\n {"}, {"sha": "a62c9756c9161622830b8c2dcf45d958f09c3779", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -1810,7 +1810,7 @@ write_closure_type_name (const tree type)\n \n   write_method_parms (parms, /*method_p=*/1, fn);\n   write_char ('E');\n-  write_compact_number (LAMBDA_EXPR_DISCRIMINATOR (lambda));\n+  write_compact_number (LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda));\n }\n \n /* Convert NUMBER to ascii using base BASE and generating at least"}, {"sha": "df05b524136fbe5571c1585e99d6ded82bf33aea", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -6327,7 +6327,7 @@ trees_out::core_vals (tree t)\n       if (streaming_p ())\n \t{\n \t  WU (((lang_tree_node *)t)->lambda_expression.default_capture_mode);\n-\t  WU (((lang_tree_node *)t)->lambda_expression.discriminator);\n+\t  WU (((lang_tree_node *)t)->lambda_expression.discriminator_scope);\n \t}\n       break;\n \n@@ -6819,7 +6819,7 @@ trees_in::core_vals (tree t)\n \t= state->read_location (*this);\n       RUC (cp_lambda_default_capture_mode_type,\n \t   ((lang_tree_node *)t)->lambda_expression.default_capture_mode);\n-      RU (((lang_tree_node *)t)->lambda_expression.discriminator);\n+      RU (((lang_tree_node *)t)->lambda_expression.discriminator_scope);\n       break;\n \n     case OVERLOAD:"}, {"sha": "e0e3cf3eaf6c128055b1ff091f00083855510358", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -11035,6 +11035,7 @@ cp_parser_lambda_expression (cp_parser* parser)\n     return error_mark_node;\n \n   record_lambda_scope (lambda_expr);\n+  record_lambda_scope_discriminator (lambda_expr);\n \n   /* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n   determine_visibility (TYPE_NAME (type));\n@@ -11085,9 +11086,7 @@ cp_parser_lambda_expression (cp_parser* parser)\n       ok = false;\n \n     if (ok)\n-      {\n-\tcp_parser_lambda_body (parser, lambda_expr);\n-      }\n+      cp_parser_lambda_body (parser, lambda_expr);\n     else if (cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n       {\n \tif (cp_parser_skip_to_closing_brace (parser))"}, {"sha": "fc6279c00a3e6c6592a2831d90641be7c5e708c1", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -19866,21 +19866,13 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (LAMBDA_EXPR_EXTRA_SCOPE (t) == NULL_TREE)\n-    {\n-      /* A lambda in a default argument outside a class gets no\n-\t LAMBDA_EXPR_EXTRA_SCOPE, as specified by the ABI.  But\n-\t tsubst_default_argument calls start_lambda_scope, so we need to\n-\t specifically ignore it here, and use the global scope.  */\n-      record_null_lambda_scope (r);\n-\n-      /* If we're pushed into another scope (PR105652), fix it.  */\n-      if (TYPE_NAMESPACE_SCOPE_P (TREE_TYPE (t)))\n-\tTYPE_CONTEXT (type) = DECL_CONTEXT (TYPE_NAME (type))\n-\t  = TYPE_CONTEXT (TREE_TYPE (t));\n-    }\n-  else\n+  if (LAMBDA_EXPR_EXTRA_SCOPE (t))\n     record_lambda_scope (r);\n+  else if (TYPE_NAMESPACE_SCOPE_P (TREE_TYPE (t)))\n+    /* If we're pushed into another scope (PR105652), fix it.  */\n+    TYPE_CONTEXT (type) = DECL_CONTEXT (TYPE_NAME (type))\n+      = TYPE_CONTEXT (TREE_TYPE (t));\n+  record_lambda_scope_discriminator (r);\n \n   /* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n   determine_visibility (TYPE_NAME (type));\n@@ -19911,29 +19903,17 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       fntype = build_memfn_type (fntype, type,\n \t\t\t\t type_memfn_quals (fntype),\n \t\t\t\t type_memfn_rqual (fntype));\n-      tree fn, tmpl;\n-      if (oldtmpl)\n+      tree inst = (oldtmpl\n+\t\t   ? tsubst_template_decl (oldtmpl, args, complain, fntype)\n+\t\t   : tsubst_function_decl (oldfn, args, complain, fntype));\n+      if (inst == error_mark_node)\n \t{\n-\t  tmpl = tsubst_template_decl (oldtmpl, args, complain, fntype);\n-\t  if (tmpl == error_mark_node)\n-\t    {\n-\t      r = error_mark_node;\n-\t      goto out;\n-\t    }\n-\t  fn = DECL_TEMPLATE_RESULT (tmpl);\n-\t  finish_member_declaration (tmpl);\n-\t}\n-      else\n-\t{\n-\t  tmpl = NULL_TREE;\n-\t  fn = tsubst_function_decl (oldfn, args, complain, fntype);\n-\t  if (fn == error_mark_node)\n-\t    {\n-\t      r = error_mark_node;\n-\t      goto out;\n-\t    }\n-\t  finish_member_declaration (fn);\n+\t  r = error_mark_node;\n+\t  goto out;\n \t}\n+      finish_member_declaration (inst);\n+\n+      tree fn = oldtmpl ? DECL_TEMPLATE_RESULT (inst) : inst;\n \n       /* Let finish_function set this.  */\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;"}, {"sha": "cb71209f9575012f78f9273cf2aaf076f4103af8", "filename": "gcc/testsuite/g++.dg/abi/lambda-sig1-17.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-17.C?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-options -fabi-version=17 }\n+\n+#include \"lambda-sig1.h\"\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfE0_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfE3_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfT_E1_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfT_E4_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlT_E2_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlT_E_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE0_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE3_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE6_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfT_E1_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfT_E4_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfT_E7_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlT_E2_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlT_E5_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlT_E_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliE0_clEi:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliE3_clEi:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliT_E1_clIiEEDaiS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliT_E4_clIiEEDaiS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlT_E2_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlT_E_clIiEEDaS1_:} } }"}, {"sha": "a8b77ae0ebf771acff0682d7dfad5421b457ccf2", "filename": "gcc/testsuite/g++.dg/abi/lambda-sig1.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1.h?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -0,0 +1,42 @@\n+template<typename T, unsigned I> struct X \n+{\n+  void Fn () \n+  {\n+    {\n+      auto v1 = []<typename U> (U) {};\n+      auto v2 = [] (T) {};\n+      auto v3 = []<typename U> (T, U) {};\n+\n+      v1 (1);\n+      v2 (1);\n+      v3 (1, 2);\n+    }\n+    if constexpr (I) \n+      {\n+\tauto v1 = []<typename U> (U) {};\n+\tauto v2 = [] (T) {};\n+\tauto v3 = []<typename U> (T, U) {};\n+\n+\tv1 (1);\n+\tv2 (1);\n+\tv3 (1, 2);\n+      }\n+    {\n+      auto v1 = []<typename U> (U) {};\n+      auto v2 = [] (T) {};\n+      auto v3 = []<typename U> (T, U) {};\n+\n+      v1 (1);\n+      v2 (1);\n+      v3 (1, 2);\n+    }\n+    \n+  };\n+};\n+\n+void f (X<int, 0> &x, X<float, 0> &y, X<float, 1> &z)\n+{\n+  x.Fn ();\n+  y.Fn ();\n+  z.Fn ();\n+}"}, {"sha": "9847587950c87c3fc821cf2b3f6ed00d56e2bdf4", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1-11.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-11.C?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options -fabi-version=11 }\n+\n+// PRs 78621\n+\n+#include \"lambda-mangle-1.h\"\n+\n+// We erroneously mangled lambda auto parms as-if template parameters (T<n>_),\n+// rather than auto (Da). Fixed in abi version 11\n+\n+\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_E_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRiRT_E0_EOS1_S2_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_R1XIiEE1_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlPA5_T_E2_EOS0_RS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_E_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRiRT_E0_EvS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_R1XIiEE1_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPA5_T_E2_EvRS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPfS1_E3_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPT_PT0_E4_EvRS1_RS3_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E1_EvRT_RT0_:\" } }"}, {"sha": "31af5b89bfd624d31d76548822b60d92f282079a", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1-17.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-17.C?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options -fabi-version=17 }\n+\n+// PRs 78621\n+\n+#include \"lambda-mangle-1.h\"\n+\n+// We erroneously mangled lambda auto parms as-if template parameters (T<n>_),\n+// rather than auto (Da). Fixed in abi version 11\n+// Up to abi version 17 we had a single per-scope discriminator\n+\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_E_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRiRT_E0_EOS1_S2_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_R1XIiEE1_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlPA5_T_E2_EOS0_RS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_E_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRiRT_E0_EvS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_R1XIiEE1_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPA5_T_E2_EvRS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPfS1_E3_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPT_PT0_E4_EvRS1_RS3_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E1_EvRT_RT0_:\" } }"}, {"sha": "c91ce0186d832e4983f07f27ad4b645e5a5ed7bb", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.h", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1.h?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -23,7 +23,7 @@ template<typename S, typename T>\n {\n }\n \n-void Foo ()\n+inline void Foo ()\n {\n   auto lam = [](auto &) { };\n   auto lam_1 = [](int &, auto &) { };\n@@ -70,6 +70,7 @@ template<typename X> void Bar ()\n void Baz ()\n {\n   Bar<short> ();\n+  Foo ();\n }\n \n // { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_E_EOS0_S1_:\" } }", "previous_filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C"}, {"sha": "b0f0cb96626750a2f80b4c62ff4d022279c46e97", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0122faae30fe1ad1dfa8c69f3d3f0428b996b600/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=0122faae30fe1ad1dfa8c69f3d3f0428b996b600", "patch": "@@ -1655,7 +1655,7 @@ plugin_start_closure_class_type (cc1_plugin::connection *self,\n \n   /* Instead of calling record_lambda_scope, do this:  */\n   LAMBDA_EXPR_EXTRA_SCOPE (lambda_expr) = extra_scope;\n-  LAMBDA_EXPR_DISCRIMINATOR (lambda_expr) = discriminator;\n+  LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda_expr) = discriminator;\n \n   tree decl = TYPE_NAME (type);\n   determine_visibility (decl);"}]}