{"sha": "75defde9fb56157d5f0279720d48866925b71b19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkZWZkZTlmYjU2MTU3ZDVmMDI3OTcyMGQ0ODg2NjkyNWI3MWIxOQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-03-28T12:43:20Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-03-28T12:43:20Z"}, "message": "c++: Replay errors during diagnosis of constraint satisfaction failures\n\nThis patch adds a new flag -fconcepts-diagnostics-depth to the C++ frontend\nwhich controls how deeply we replay errors when diagnosing a constraint\nsatisfaction failure.  The default is -fconcepts-diagnostics-depth=1 which\ndiagnoses only the topmost constraint satisfaction failure and is consistent\nwith our behavior before this patch.  By increasing this flag's value, the user\ncan control how deeply they want the compiler to explain a constraint\nsatisfaction error.\n\nFor example, if the unsatisfied constraint is a disjunction, then the default\nbehavior is to just say \"no branch in the disjunction is satisfied\", but with\n-fconcepts-diagnostics-depth=2 we will additionally replay and diagnose the\nerror in each branch of the disjunction.  And if the unsatisfied constraint is a\nrequires expression, then we will replay the error in the requires expression,\netc.  This proceeds recursively until there is nothing more to replay or we\nexceeded the maximum depth specified by the flag.\n\nImplementation wise, this patch essentially just uncomments the existing\ncommented-out code that performs the error-replaying, and along the way adds\nlogic to keep track of and limit the current replay depth.  Besides that, there\nis a new routine collect_operands_of_disjunction which flattens a disjunction\nand collects all of its operands into a vector.\n\nThe extra diagnostics enabled by this flag are at times longer than they need to\nbe (e.g.  \"the operand is_array_v<...> is unsatisfied because \\n the expression\nis_array_v<...> [with ...] evaluated to false\") and not immediately easy to\nfollow (especially when there are nested disjunctions), but the transparency\nprovided by these optional diagnostics seems to be pretty helpful in practice.\n\ngcc/c-family/ChangeLog:\n\n\t* c.opt: Add -fconcepts-diagnostics-depth.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (finish_constraint_binary_op): Set the location of EXPR\n\tas well as its range, because build_x_binary_op doesn't always do so.\n\t(current_constraint_diagnosis_depth): New.\n\t(concepts_diagnostics_max_depth_exceeded_p): New.\n\t(collect_operands_of_disjunction): New.\n\t(satisfy_disjunction): When diagnosing a satisfaction failure, maybe\n\treplay each branch of the disjunction, subject to the current diagnosis\n\tdepth.\n\t(diagnose_valid_expression): When diagnosing a satisfaction failure,\n\tmaybe replay the substitution error, subject to the current diagnosis\n\trecursion.\n\t(diagnose_valid_type): Likewise.\n\t(diagnose_nested_requiremnet): Likewise.\n\t(diagnosing_failed_constraint::diagnosing_failed_constraint): Increment\n\tcurrent_constraint_diagnosis_depth when diagnosing.\n\t(diagnosing_failed_constraint::~diagnosing_failed_constraint): Decrement\n\tcurrent_constraint_diagnosis_depth when diagnosing.\n\t(diagnosing_failed_constraint::replay_errors_p): New static member\n\tfunction.\n\t(diagnose_constraints): Don't diagnose if concepts_diagnostics_max_depth\n\tis 0.  Emit a one-off note to increase -fconcepts-diagnostics-depth if\n\tthe limit was exceeded.\n\t* cp-tree.h (diagnosing_failed_constraint::replay_errors_p): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/concepts/diagnostic2.C: Expect \"no operand\" instead of\n\t\"neither operand\".\n\t* g++.dg/concepts/diagnostic5.C: New test.", "tree": {"sha": "9aacf4a114baa2bc27601c688bd699e3d5ffd9b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aacf4a114baa2bc27601c688bd699e3d5ffd9b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75defde9fb56157d5f0279720d48866925b71b19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75defde9fb56157d5f0279720d48866925b71b19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75defde9fb56157d5f0279720d48866925b71b19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75defde9fb56157d5f0279720d48866925b71b19/comments", "author": null, "committer": null, "parents": [{"sha": "c6a562de88c44a555e1688c212869b20b02151bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a562de88c44a555e1688c212869b20b02151bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a562de88c44a555e1688c212869b20b02151bc"}], "stats": {"total": 239, "additions": 218, "deletions": 21}, "files": [{"sha": "38406a8c551a8372f7e5236a69aaff46dea25c0b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -1,3 +1,7 @@\n+2020-03-28  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* c.opt: Add -fconcepts-diagnostics-depth.\n+\n 2020-03-27  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/94346"}, {"sha": "c49da99d3957b7447f78c5d460c8427653887b80", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -1453,6 +1453,10 @@ fconcepts-ts\n C++ ObjC++ Var(flag_concepts_ts) Init(0)\n Enable certain features present in the Concepts TS.\n \n+fconcepts-diagnostics-depth=\n+C++ ObjC++ Joined RejectNegative UInteger Var(concepts_diagnostics_max_depth) Init(1)\n+Specify maximum error replay depth during recursive diagnosis of a constraint satisfaction failure.\n+\n fcond-mismatch\n C ObjC C++ ObjC++\n Allow the arguments of the '?' operator to have different types."}, {"sha": "a65ed1414787b86c311d6da188dc92a5b0da9c38", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -1,3 +1,29 @@\n+2020-03-28  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* constraint.cc (finish_constraint_binary_op): Set the location of EXPR\n+\tas well as its range, because build_x_binary_op doesn't always do so.\n+\t(current_constraint_diagnosis_depth): New.\n+\t(concepts_diagnostics_max_depth_exceeded_p): New.\n+\t(collect_operands_of_disjunction): New.\n+\t(satisfy_disjunction): When diagnosing a satisfaction failure, maybe\n+\treplay each branch of the disjunction, subject to the current diagnosis\n+\tdepth.\n+\t(diagnose_valid_expression): When diagnosing a satisfaction failure,\n+\tmaybe replay the substitution error, subject to the current diagnosis\n+\trecursion.\n+\t(diagnose_valid_type): Likewise.\n+\t(diagnose_nested_requiremnet): Likewise.\n+\t(diagnosing_failed_constraint::diagnosing_failed_constraint): Increment\n+\tcurrent_constraint_diagnosis_depth when diagnosing.\n+\t(diagnosing_failed_constraint::~diagnosing_failed_constraint): Decrement\n+\tcurrent_constraint_diagnosis_depth when diagnosing.\n+\t(diagnosing_failed_constraint::replay_errors_p): New static member\n+\tfunction.\n+\t(diagnose_constraints): Don't diagnose if concepts_diagnostics_max_depth\n+\tis 0.  Emit a one-off note to increase -fconcepts-diagnostics-depth if\n+\tthe limit was exceeded.\n+\t* cp-tree.h (diagnosing_failed_constraint::replay_errors_p): Declare.\n+\n 2020-03-27  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/84733"}, {"sha": "76c520318c347ccd68a2d93a232314f64a61c5af", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -162,6 +162,7 @@ finish_constraint_binary_op (location_t loc,\n   /* When either operand is dependent, the overload set may be non-empty.  */\n   if (expr == error_mark_node)\n     return error_mark_node;\n+  expr.set_location (loc);\n   expr.set_range (lhs.get_start (), rhs.get_finish ());\n   return expr;\n }\n@@ -2395,6 +2396,49 @@ satisfy_conjunction (tree t, tree args, subst_info info)\n   return satisfy_constraint_r (TREE_OPERAND (t, 1), args, info);\n }\n \n+/* The current depth at which we're replaying an error during recursive\n+   diagnosis of a constraint satisfaction failure.  */\n+\n+static int current_constraint_diagnosis_depth;\n+\n+/* Whether CURRENT_CONSTRAINT_DIAGNOSIS_DEPTH has ever exceeded\n+   CONCEPTS_DIAGNOSTICS_MAX_DEPTH during recursive diagnosis of a constraint\n+   satisfaction error.  */\n+\n+static bool concepts_diagnostics_max_depth_exceeded_p;\n+\n+/* Recursive subroutine of collect_operands_of_disjunction.  T is a normalized\n+   subexpression of a constraint (composed of CONJ_CONSTRs and DISJ_CONSTRs)\n+   and E is the corresponding unnormalized subexpression (composed of\n+   TRUTH_ANDIF_EXPRs and TRUTH_ORIF_EXPRs).  */\n+\n+static void\n+collect_operands_of_disjunction_r (tree t, tree e,\n+\t\t\t\t   auto_vec<tree_pair> *operands)\n+{\n+  if (TREE_CODE (e) == TRUTH_ORIF_EXPR)\n+    {\n+      collect_operands_of_disjunction_r (TREE_OPERAND (t, 0),\n+\t\t\t\t\t TREE_OPERAND (e, 0), operands);\n+      collect_operands_of_disjunction_r (TREE_OPERAND (t, 1),\n+\t\t\t\t\t TREE_OPERAND (e, 1), operands);\n+    }\n+  else\n+    {\n+      tree_pair p = std::make_pair (t, e);\n+      operands->safe_push (p);\n+    }\n+}\n+\n+/* Recursively collect the normalized and unnormalized operands of the\n+   disjunction T and append them to OPERANDS in order.  */\n+\n+static void\n+collect_operands_of_disjunction (tree t, auto_vec<tree_pair> *operands)\n+{\n+  collect_operands_of_disjunction_r (t, CONSTR_EXPR (t), operands);\n+}\n+\n /* Compute the satisfaction of a disjunction.  */\n \n static tree\n@@ -2412,11 +2456,25 @@ satisfy_disjunction (tree t, tree args, subst_info info)\n   tree rhs = satisfy_constraint_r (TREE_OPERAND (t, 1), args, quiet);\n   if (rhs != boolean_true_node && info.noisy ())\n     {\n-      location_t loc = cp_expr_location (CONSTR_EXPR (t));\n-      inform (loc, \"neither operand of the disjunction is satisfied\");\n-      /* TODO: Replay the LHS and RHS to find failures in both branches.  */\n-      // satisfy_constraint_r (TREE_OPERAND (t, 0), args, info);\n-      // satisfy_constraint_r (TREE_OPERAND (t, 1), args, info);\n+      cp_expr disj_expr = CONSTR_EXPR (t);\n+      inform (disj_expr.get_location (),\n+\t      \"no operand of the disjunction is satisfied\");\n+      if (diagnosing_failed_constraint::replay_errors_p ())\n+\t{\n+\t  /* Replay the error in each branch of the disjunction.  */\n+\t  auto_vec<tree_pair> operands;\n+\t  collect_operands_of_disjunction (t, &operands);\n+\t  for (unsigned i = 0; i < operands.length (); i++)\n+\t    {\n+\t      tree norm_op = operands[i].first;\n+\t      tree op = operands[i].second;\n+\t      location_t loc = make_location (cp_expr_location (op),\n+\t\t\t\t\t      disj_expr.get_start (),\n+\t\t\t\t\t      disj_expr.get_finish ());\n+\t      inform (loc, \"the operand %qE is unsatisfied because\", op);\n+\t      satisfy_constraint_r (norm_op, args, info);\n+\t    }\n+\t}\n     }\n   return rhs;\n }\n@@ -3182,10 +3240,14 @@ diagnose_valid_expression (tree expr, tree args, tree in_decl)\n     return result;\n \n   location_t loc = cp_expr_loc_or_input_loc (expr);\n-  inform (loc, \"the required expression %qE is invalid\", expr);\n-\n-  /* TODO: Replay the substitution to diagnose the error?  */\n-  // tsubst_expr (expr, args, tf_error, in_decl, false);\n+  if (diagnosing_failed_constraint::replay_errors_p ())\n+    {\n+      /* Replay the substitution error.  */\n+      inform (loc, \"the required expression %qE is invalid, because\", expr);\n+      tsubst_expr (expr, args, tf_error, in_decl, false);\n+    }\n+  else\n+    inform (loc, \"the required expression %qE is invalid\", expr);\n \n   return error_mark_node;\n }\n@@ -3198,10 +3260,14 @@ diagnose_valid_type (tree type, tree args, tree in_decl)\n     return result;\n \n   location_t loc = cp_expr_loc_or_input_loc (type);\n-  inform (loc, \"the required type %qT is invalid\", type);\n-\n-  /* TODO: Replay the substitution to diagnose the error?  */\n-  // tsubst (type, args, tf_error, in_decl);\n+  if (diagnosing_failed_constraint::replay_errors_p ())\n+    {\n+      /* Replay the substitution error.  */\n+      inform (loc, \"the required type %qT is invalid, because\", type);\n+      tsubst (type, args, tf_error, in_decl);\n+    }\n+  else\n+    inform (loc, \"the required type %qT is invalid\", type);\n \n   return error_mark_node;\n }\n@@ -3280,11 +3346,16 @@ diagnose_nested_requirement (tree req, tree args)\n \n   tree expr = TREE_OPERAND (req, 0);\n   location_t loc = cp_expr_location (expr);\n-  inform (loc, \"nested requirement %qE is not satisfied\", expr);\n+  if (diagnosing_failed_constraint::replay_errors_p ())\n+    {\n+      /* Replay the substitution error.  */\n+      inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n+      subst_info noisy (tf_warning_or_error, NULL_TREE);\n+      satisfy_constraint_expression (expr, args, noisy);\n+    }\n+  else\n+    inform (loc, \"nested requirement %qE is not satisfied\", expr);\n \n-  /* TODO: Replay the substitution to diagnose the error?  */\n-  // subst_info noisy (tf_warning_or_error, NULL_TREE);\n-  // satisfy_constraint (norm, args, info);\n }\n \n static void\n@@ -3385,14 +3456,38 @@ diagnosing_failed_constraint (tree t, tree args, bool diag)\n   : diagnosing_error (diag)\n {\n   if (diagnosing_error)\n-    current_failed_constraint = tree_cons (args, t, current_failed_constraint);\n+    {\n+      current_failed_constraint\n+\t= tree_cons (args, t, current_failed_constraint);\n+      ++current_constraint_diagnosis_depth;\n+    }\n }\n \n diagnosing_failed_constraint::\n ~diagnosing_failed_constraint ()\n {\n-  if (diagnosing_error && current_failed_constraint)\n-    current_failed_constraint = TREE_CHAIN (current_failed_constraint);\n+  if (diagnosing_error)\n+    {\n+      --current_constraint_diagnosis_depth;\n+      if (current_failed_constraint)\n+\tcurrent_failed_constraint = TREE_CHAIN (current_failed_constraint);\n+    }\n+\n+}\n+\n+/* Whether we are allowed to replay an error that underlies a constraint failure\n+   at the current diagnosis depth.  */\n+\n+bool\n+diagnosing_failed_constraint::replay_errors_p ()\n+{\n+  if (current_constraint_diagnosis_depth >= concepts_diagnostics_max_depth)\n+    {\n+      concepts_diagnostics_max_depth_exceeded_p = true;\n+      return false;\n+    }\n+  else\n+    return true;\n }\n \n /* Emit diagnostics detailing the failure ARGS to satisfy the constraints\n@@ -3403,11 +3498,26 @@ diagnose_constraints (location_t loc, tree t, tree args)\n {\n   inform (loc, \"constraints not satisfied\");\n \n+  if (concepts_diagnostics_max_depth == 0)\n+    return;\n+\n   /* Replay satisfaction, but diagnose errors.  */\n   if (!args)\n     constraint_satisfaction_value (t, tf_warning_or_error);\n   else\n     constraint_satisfaction_value (t, args, tf_warning_or_error);\n+\n+  static bool suggested_p;\n+  if (concepts_diagnostics_max_depth_exceeded_p\n+      && current_constraint_diagnosis_depth == 0\n+      && !suggested_p)\n+    {\n+      inform (UNKNOWN_LOCATION,\n+\t      \"set %qs to at least %d for more detail\",\n+\t      \"-fconcepts-diagnostics-depth=\",\n+\t      concepts_diagnostics_max_depth + 1);\n+      suggested_p = true;\n+    }\n }\n \n #include \"gt-cp-constraint.h\""}, {"sha": "63aaf615926799a956d1be3d62b39f80209381cf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -7834,6 +7834,7 @@ struct diagnosing_failed_constraint\n {\n   diagnosing_failed_constraint (tree, tree, bool);\n   ~diagnosing_failed_constraint ();\n+  static bool replay_errors_p ();\n \n   bool diagnosing_error;\n };"}, {"sha": "f60813f1d26c294404939a6e4152ba83f3eb6a3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -1,3 +1,9 @@\n+2020-03-28  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* g++.dg/concepts/diagnostic2.C: Expect \"no operand\" instead of\n+\t\"neither operand\".\n+\t* g++.dg/concepts/diagnostic5.C: New test.\n+\n 2020-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/93573"}, {"sha": "47accb8366eca1538e500d1fe7bc54ed5474046e", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic2.C?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -5,7 +5,7 @@ template<typename T>\n   inline constexpr bool foo_v = false;\n \n template<typename T>\n-  concept foo = foo_v<T> || foo_v<T&>; // { dg-message \"neither operand\" }\n+  concept foo = foo_v<T> || foo_v<T&>; // { dg-message \"no operand\" }\n /* { dg-begin-multiline-output \"\" }\n    concept foo = foo_v<T> || foo_v<T&>;\n                  ~~~~~~~~~^~~~~~~~~~~~"}, {"sha": "2641dc1842397c4afff6fee0f5df215ef7f8f310", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic5.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75defde9fb56157d5f0279720d48866925b71b19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic5.C?ref=75defde9fb56157d5f0279720d48866925b71b19", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options \"-fconcepts-diagnostics-depth=2\" }\n+\n+template<typename T>\n+  concept c1 = requires { typename T::blah; };\n+// { dg-message \"satisfaction of .c1<T>. .with T = char.\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"satisfaction of .c1<char\\\\*>.\" \"\" { target *-*-* } .-2 }\n+// { dg-message \".typename T::blah. is invalid\" \"\" { target *-*-* } .-3 }\n+\n+template<typename T>\n+  concept c2 = requires (T x) { *x; };\n+// { dg-message \"satisfaction of .c2<T>. .with T = char.\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"in requirements with .char x.\" \"\" { target *-*-* } .-2 }\n+// { dg-message \"required expression .* is invalid\" \"\" { target *-*-* } .-3 }\n+\n+template<typename T>\n+  concept c3 = __is_same(T, const T) || __is_same(T, int);\n+// { dg-message \"satisfaction of .c3<T>. .with T = char.\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"no operand of the disjunction is satisfied\" \"\" { target *-*-* } .-2 }\n+\n+template<typename T>\n+  concept c4 = requires (T x) { requires c2<const T> || c2<volatile T>; };\n+// { dg-message \"satisfaction of .c4<T>. .with T = char.\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"nested requirement\" \"\" { target *-*-* } .-2 }\n+\n+template<typename T>\n+  concept c5 = requires (T x) { { &x } -> c1; };\n+// { dg-message \"satisfaction of .c5<T>. .with T = char.\" \"\" { target *-*-* } .-1 }\n+// { dg-message \"in requirements with .char x.\" \"\" { target *-*-* } .-2 }\n+// { dg-message \"does not satisfy return-type-requirement\" \"\" { target *-*-* } .-3 }\n+// { dg-error \"deduced expression type does not satisfy\" \"\" { target *-*-* } .-4 }\n+\n+template<typename T>\n+  requires (c1<T> || c2<T>) || (c3<T> || c4<T>) || c5<T> // { dg-message \"49: no operand\" }\n+  // { dg-message \".c1<T>. is unsatisfied because\" \"\" { target *-*-* } .-1 }\n+  // { dg-message \".c2<T>. is unsatisfied because\" \"\" { target *-*-* } .-2 }\n+  // { dg-message \".c3<T>. is unsatisfied because\" \"\" { target *-*-* } .-3 }\n+  // { dg-message \".c4<T>. is unsatisfied because\" \"\" { target *-*-* } .-4 }\n+  // { dg-message \".c5<T>. is unsatisfied because\" \"\" { target *-*-* } .-5 }\n+  void foo() { }\n+\n+void\n+bar()\n+{\n+  foo<char>(); // { dg-error \"use of\" }\n+}"}]}