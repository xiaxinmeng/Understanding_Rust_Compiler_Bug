{"sha": "cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RjMTg0MTc0Y2U1NmRmMWZjYWYyMzU1ZDVlY2RiNDcyNDRjMmRlOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-04-30T15:21:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-04-30T15:21:01Z"}, "message": "PR c++/61982 - dead stores to destroyed objects.\n\ngcc/cp/\n\t* call.c (build_trivial_dtor_call): New, assigns a clobber.\n\t(build_over_call, build_special_member_call): Use it.\n\t* cp-tree.h: Declare it.\n\t* init.c (build_delete): Remove trivial path.\ngcc/\n\t* gimplify.c (gimplify_modify_expr): Simplify complex lvalue on LHS\n\tof clobber.\n\nFrom-SVN: r259772", "tree": {"sha": "9654bf8df2ca4818d260cdca690325cbc05f7405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9654bf8df2ca4818d260cdca690325cbc05f7405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d20f49036b7a669518aab3ba4cbb062287957da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d20f49036b7a669518aab3ba4cbb062287957da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d20f49036b7a669518aab3ba4cbb062287957da"}], "stats": {"total": 291, "additions": 175, "deletions": 116}, "files": [{"sha": "0a776ae76344bf111a3451248ab276bbfe9d2020", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -1,3 +1,9 @@\n+2018-04-30  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/61982 - dead stores to destroyed objects.\n+\t* gimplify.c (gimplify_modify_expr): Simplify complex lvalue on LHS\n+\tof clobber.\n+\n 2018-04-30  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (build_clobber): New."}, {"sha": "1ab91588e6cad7bcbf02738652cdd1d750ac25e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -1,5 +1,11 @@\n 2018-04-30  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/61982 - dead stores to destroyed objects.\n+\t* call.c (build_trivial_dtor_call): New, assigns a clobber.\n+\t(build_over_call, build_special_member_call): Use it.\n+\t* cp-tree.h: Declare it.\n+\t* init.c (build_delete): Remove trivial path.\n+\n \t* init.c (build_dtor_call): Use build_special_member_call.\n \t(build_delete): Remove redundant uses of save_addr.\n "}, {"sha": "d3ee152808ac9d3a5aafb2bb5331cca96fb18109", "filename": "gcc/cp/call.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -7629,6 +7629,33 @@ conv_binds_ref_to_prvalue (conversion *c)\n   return false;\n }\n \n+/* Call the trivial destructor for INSTANCE, which can be either an lvalue of\n+   class type or a pointer to class type.  */\n+\n+tree\n+build_trivial_dtor_call (tree instance)\n+{\n+  gcc_assert (!is_dummy_object (instance));\n+\n+  if (!flag_lifetime_dse)\n+    {\n+    no_clobber:\n+      return fold_convert (void_type_node, instance);\n+    }\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (instance)))\n+    {\n+      if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (instance))))\n+\tgoto no_clobber;\n+      instance = cp_build_fold_indirect_ref (instance);\n+    }\n+\n+  /* A trivial destructor should still clobber the object.  */\n+  tree clobber = build_clobber (TREE_TYPE (instance));\n+  return build2 (MODIFY_EXPR, void_type_node,\n+\t\t instance, clobber);\n+}\n+\n /* Subroutine of the various build_*_call functions.  Overload resolution\n    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.\n    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a\n@@ -8240,7 +8267,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   else if (trivial_fn_p (fn))\n     {\n       if (DECL_DESTRUCTOR_P (fn))\n-\treturn fold_convert (void_type_node, argarray[0]);\n+\treturn build_trivial_dtor_call (argarray[0]);\n       else if (default_ctor_p (fn))\n \t{\n \t  if (is_dummy_object (argarray[0]))\n@@ -8863,6 +8890,18 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n   tree ret;\n \n   gcc_assert (IDENTIFIER_CDTOR_P (name) || name == assign_op_identifier);\n+\n+  if (error_operand_p (instance))\n+    return error_mark_node;\n+\n+  if (IDENTIFIER_DTOR_P (name))\n+    {\n+      gcc_assert (args == NULL || vec_safe_is_empty (*args));\n+      if (!type_build_dtor_call (TREE_TYPE (instance)))\n+\t/* Shortcut to avoid lazy destructor declaration.  */\n+\treturn build_trivial_dtor_call (instance);\n+    }\n+\n   if (TYPE_P (binfo))\n     {\n       /* Resolve the name.  */\n@@ -8881,9 +8920,6 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n     instance = build_dummy_object (class_type);\n   else\n     {\n-      if (IDENTIFIER_DTOR_P (name))\n-\tgcc_assert (args == NULL || vec_safe_is_empty (*args));\n-\n       /* Convert to the base class, if necessary.  */\n       if (!same_type_ignoring_top_level_qualifiers_p\n \t  (TREE_TYPE (instance), BINFO_TYPE (binfo)))"}, {"sha": "3cd7421ba9231870440a637fa1b99e6ad96b6564", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -6037,6 +6037,7 @@ extern bool null_member_pointer_value_p\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree extract_call_expr\t\t\t(tree);\n+extern tree build_trivial_dtor_call\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **,"}, {"sha": "221a831b7b8198f9e3bdf16548e65e747eca4b16", "filename": "gcc/cp/init.c", "status": "modified", "additions": 97, "deletions": 110, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -4664,126 +4664,113 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n       addr = convert_force (build_pointer_type (type), addr, 0, complain);\n     }\n \n-  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n-    {\n-      /* Make sure the destructor is callable.  */\n-      if (type_build_dtor_call (type))\n-\t{\n-\t  expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n-\t\t\t\t  sfk_complete_destructor, flags, complain);\n-\t  if (expr == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+  tree head = NULL_TREE;\n+  tree do_delete = NULL_TREE;\n+  tree ifexp;\n \n-      if (auto_delete != sfk_deleting_destructor)\n-\treturn void_node;\n+  bool virtual_p = false;\n+  if (type_build_dtor_call (type))\n+    {\n+      if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n+\tlazily_declare_fn (sfk_destructor, type);\n+      virtual_p = DECL_VIRTUAL_P (CLASSTYPE_DESTRUCTOR (type));\n+    }\n \n-      return build_op_delete_call (DELETE_EXPR, addr,\n-\t\t\t\t   cxx_sizeof_nowarn (type),\n-\t\t\t\t   use_global_delete,\n-\t\t\t\t   /*placement=*/NULL_TREE,\n-\t\t\t\t   /*alloc_fn=*/NULL_TREE,\n-\t\t\t\t   complain);\n+  /* For `::delete x', we must not use the deleting destructor\n+     since then we would not be sure to get the global `operator\n+     delete'.  */\n+  if (use_global_delete && auto_delete == sfk_deleting_destructor)\n+    {\n+      /* We will use ADDR multiple times so we must save it.  */\n+      addr = save_expr (addr);\n+      head = get_target_expr (build_headof (addr));\n+      /* Delete the object.  */\n+      do_delete = build_op_delete_call (DELETE_EXPR,\n+\t\t\t\t\thead,\n+\t\t\t\t\tcxx_sizeof_nowarn (type),\n+\t\t\t\t\t/*global_p=*/true,\n+\t\t\t\t\t/*placement=*/NULL_TREE,\n+\t\t\t\t\t/*alloc_fn=*/NULL_TREE,\n+\t\t\t\t\tcomplain);\n+      /* Otherwise, treat this like a complete object destructor\n+\t call.  */\n+      auto_delete = sfk_complete_destructor;\n     }\n-  else\n+  /* If the destructor is non-virtual, there is no deleting\n+     variant.  Instead, we must explicitly call the appropriate\n+     `operator delete' here.  */\n+  else if (!virtual_p\n+\t   && auto_delete == sfk_deleting_destructor)\n     {\n-      tree head = NULL_TREE;\n-      tree do_delete = NULL_TREE;\n-      tree ifexp;\n+      /* We will use ADDR multiple times so we must save it.  */\n+      addr = save_expr (addr);\n+      /* Build the call.  */\n+      do_delete = build_op_delete_call (DELETE_EXPR,\n+\t\t\t\t\taddr,\n+\t\t\t\t\tcxx_sizeof_nowarn (type),\n+\t\t\t\t\t/*global_p=*/false,\n+\t\t\t\t\t/*placement=*/NULL_TREE,\n+\t\t\t\t\t/*alloc_fn=*/NULL_TREE,\n+\t\t\t\t\tcomplain);\n+      /* Call the complete object destructor.  */\n+      auto_delete = sfk_complete_destructor;\n+    }\n+  else if (auto_delete == sfk_deleting_destructor\n+\t   && TYPE_GETS_REG_DELETE (type))\n+    {\n+      /* Make sure we have access to the member op delete, even though\n+\t we'll actually be calling it from the destructor.  */\n+      build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n+\t\t\t    /*global_p=*/false,\n+\t\t\t    /*placement=*/NULL_TREE,\n+\t\t\t    /*alloc_fn=*/NULL_TREE,\n+\t\t\t    complain);\n+    }\n \n-      if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n-\tlazily_declare_fn (sfk_destructor, type);\n+  if (type_build_dtor_call (type))\n+    expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n+\t\t\t    auto_delete, flags, complain);\n+  else\n+    expr = build_trivial_dtor_call (addr);\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n \n-      /* For `::delete x', we must not use the deleting destructor\n-\t since then we would not be sure to get the global `operator\n-\t delete'.  */\n-      if (use_global_delete && auto_delete == sfk_deleting_destructor)\n-\t{\n-\t  /* We will use ADDR multiple times so we must save it.  */\n-\t  addr = save_expr (addr);\n-\t  head = get_target_expr (build_headof (addr));\n-\t  /* Delete the object.  */\n-\t  do_delete = build_op_delete_call (DELETE_EXPR,\n-\t\t\t\t\t    head,\n-\t\t\t\t\t    cxx_sizeof_nowarn (type),\n-\t\t\t\t\t    /*global_p=*/true,\n-\t\t\t\t\t    /*placement=*/NULL_TREE,\n-\t\t\t\t\t    /*alloc_fn=*/NULL_TREE,\n-\t\t\t\t\t    complain);\n-\t  /* Otherwise, treat this like a complete object destructor\n-\t     call.  */\n-\t  auto_delete = sfk_complete_destructor;\n-\t}\n-      /* If the destructor is non-virtual, there is no deleting\n-\t variant.  Instead, we must explicitly call the appropriate\n-\t `operator delete' here.  */\n-      else if (!DECL_VIRTUAL_P (CLASSTYPE_DESTRUCTOR (type))\n-\t       && auto_delete == sfk_deleting_destructor)\n-\t{\n-\t  /* We will use ADDR multiple times so we must save it.  */\n-\t  addr = save_expr (addr);\n-\t  /* Build the call.  */\n-\t  do_delete = build_op_delete_call (DELETE_EXPR,\n-\t\t\t\t\t    addr,\n-\t\t\t\t\t    cxx_sizeof_nowarn (type),\n-\t\t\t\t\t    /*global_p=*/false,\n-\t\t\t\t\t    /*placement=*/NULL_TREE,\n-\t\t\t\t\t    /*alloc_fn=*/NULL_TREE,\n-\t\t\t\t\t    complain);\n-\t  /* Call the complete object destructor.  */\n-\t  auto_delete = sfk_complete_destructor;\n-\t}\n-      else if (auto_delete == sfk_deleting_destructor\n-\t       && TYPE_GETS_REG_DELETE (type))\n-\t{\n-\t  /* Make sure we have access to the member op delete, even though\n-\t     we'll actually be calling it from the destructor.  */\n-\t  build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n-\t\t\t\t/*global_p=*/false,\n-\t\t\t\t/*placement=*/NULL_TREE,\n-\t\t\t\t/*alloc_fn=*/NULL_TREE,\n-\t\t\t\tcomplain);\n-\t}\n+  if (do_delete && !TREE_SIDE_EFFECTS (expr))\n+    expr = do_delete;\n+  else if (do_delete)\n+    /* The delete operator must be called, regardless of whether\n+       the destructor throws.\n \n-      expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n-\t\t\t      auto_delete, flags, complain);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n-      if (do_delete)\n-\t/* The delete operator must be called, regardless of whether\n-\t   the destructor throws.\n-\n-\t   [expr.delete]/7 The deallocation function is called\n-\t   regardless of whether the destructor for the object or some\n-\t   element of the array throws an exception.  */\n-\texpr = build2 (TRY_FINALLY_EXPR, void_type_node, expr, do_delete);\n-\n-      /* We need to calculate this before the dtor changes the vptr.  */\n-      if (head)\n-\texpr = build2 (COMPOUND_EXPR, void_type_node, head, expr);\n-\n-      if (flags & LOOKUP_DESTRUCTOR)\n-\t/* Explicit destructor call; don't check for null pointer.  */\n-\tifexp = integer_one_node;\n-      else\n-\t{\n-\t  /* Handle deleting a null pointer.  */\n-\t  warning_sentinel s (warn_address);\n-\t  ifexp = cp_build_binary_op (input_location, NE_EXPR, addr,\n-\t\t\t\t      nullptr_node, complain);\n-\t  if (ifexp == error_mark_node)\n-\t    return error_mark_node;\n-\t  /* This is a compiler generated comparison, don't emit\n-\t     e.g. -Wnonnull-compare warning for it.  */\n-\t  else if (TREE_CODE (ifexp) == NE_EXPR)\n-\t    TREE_NO_WARNING (ifexp) = 1;\n-\t}\n+       [expr.delete]/7 The deallocation function is called\n+       regardless of whether the destructor for the object or some\n+       element of the array throws an exception.  */\n+    expr = build2 (TRY_FINALLY_EXPR, void_type_node, expr, do_delete);\n \n-      if (ifexp != integer_one_node)\n-\texpr = build3 (COND_EXPR, void_type_node, ifexp, expr, void_node);\n+  /* We need to calculate this before the dtor changes the vptr.  */\n+  if (head)\n+    expr = build2 (COMPOUND_EXPR, void_type_node, head, expr);\n \n-      return expr;\n+  if (flags & LOOKUP_DESTRUCTOR)\n+    /* Explicit destructor call; don't check for null pointer.  */\n+    ifexp = integer_one_node;\n+  else\n+    {\n+      /* Handle deleting a null pointer.  */\n+      warning_sentinel s (warn_address);\n+      ifexp = cp_build_binary_op (input_location, NE_EXPR, addr,\n+\t\t\t\t  nullptr_node, complain);\n+      if (ifexp == error_mark_node)\n+\treturn error_mark_node;\n+      /* This is a compiler generated comparison, don't emit\n+\t e.g. -Wnonnull-compare warning for it.  */\n+      else if (TREE_CODE (ifexp) == NE_EXPR)\n+\tTREE_NO_WARNING (ifexp) = 1;\n     }\n+\n+  if (ifexp != integer_one_node)\n+    expr = build3 (COND_EXPR, void_type_node, ifexp, expr, void_node);\n+\n+  return expr;\n }\n \n /* At the beginning of a destructor, push cleanups that will call the"}, {"sha": "d27aae2eea8c6f70e33b8cf26c03af7a6788219b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -5558,8 +5558,13 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n       if (ret == GS_ERROR)\n \treturn ret;\n-      gcc_assert (!want_value\n-\t\t  && (VAR_P (*to_p) || TREE_CODE (*to_p) == MEM_REF));\n+      gcc_assert (!want_value);\n+      if (!VAR_P (*to_p) && TREE_CODE (*to_p) != MEM_REF)\n+\t{\n+\t  tree addr = get_initialized_tmp_var (build_fold_addr_expr (*to_p),\n+\t\t\t\t\t       pre_p, post_p);\n+\t  *to_p = build_simple_mem_ref_loc (EXPR_LOCATION (*to_p), addr);\n+\t}\n       gimplify_seq_add_stmt (pre_p, gimple_build_assign (*to_p, *from_p));\n       *expr_p = NULL;\n       return GS_ALL_DONE;"}, {"sha": "90c90f2650c9e2197dfdc6e52cb68e8fbaeb8ce9", "filename": "gcc/testsuite/g++.dg/tree-ssa/lifetime-dse1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Flifetime-dse1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc184174ce56df1fcaf2355d5ecdb47244c2de8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Flifetime-dse1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Flifetime-dse1.C?ref=cdc184174ce56df1fcaf2355d5ecdb47244c2de8", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/61982\n+// { dg-additional-options \"-O2 -fdump-tree-optimized\" }\n+// { dg-final { scan-tree-dump-not \"= 0\" \"optimized\" } }\n+\n+struct X { \n+  int i; \n+  void clear() { i = 0; }\n+}; \n+\n+void f(X* x) { \n+  x->clear(); \n+  x->~X(); \n+} \n+\n+void g(X* x) {\n+  x->clear();\n+  delete x;\n+}"}]}