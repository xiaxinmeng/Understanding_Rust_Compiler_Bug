{"sha": "56a0044b23379c1b4129f7d97d4abb444f3df175", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZhMDA0NGIyMzM3OWMxYjQxMjlmN2Q5N2Q0YWJiNDQ0ZjNkZjE3NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-22T19:36:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-22T19:36:33Z"}, "message": "Another bunch of patches from Craig.  See ChangeLogs for details.\n\nFrom-SVN: r18188", "tree": {"sha": "896df8a7767510a09f2791565643d25b1dc6ef2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/896df8a7767510a09f2791565643d25b1dc6ef2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56a0044b23379c1b4129f7d97d4abb444f3df175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56a0044b23379c1b4129f7d97d4abb444f3df175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56a0044b23379c1b4129f7d97d4abb444f3df175", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56a0044b23379c1b4129f7d97d4abb444f3df175/comments", "author": null, "committer": null, "parents": [{"sha": "86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1"}], "stats": {"total": 652, "additions": 458, "deletions": 194}, "files": [{"sha": "509061ef0c17c439490f5f060fd2feaef47deb39", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -8,6 +8,15 @@ Fri Feb 20 10:11:20 1998  Craig Burley  <burley@gnu.org>\n \n Sun Jan 11 02:14:47 1998  Craig Burley  <burley@gnu.org>\n \n+\tFix 970626-2.f by not doing most back-end processing\n+\twhen current_function_decl is an ERROR_MARK, and by\n+\tmaking that the case when its type would be an ERROR_MARK:\n+\t* com.c (ffecom_start_progunit_, finish_function,\n+\tlang_printable_name, start_function,\n+\tffecom_finish_symbol_transform_): Test for ERROR_MARK.\n+\t* std.c (ffestd_stmt_pass_): Don't do any downstream\n+\tprocessing if ERROR_MARK.\n+\n \tSupport FORMAT(I<1+2>) (constant variable-FORMAT\n \texpressions):\n \t* bad.def (FFEBAD_FORMAT_VARIABLE): New diagnostic.\n@@ -106,6 +115,22 @@ Sun Nov 30 22:22:22 1997  Craig Burley  <burley@gnu.org>\n \t* com.c (ffecom_arglist_expr_): Pass null pointers for optional\n \targs which aren't supplied.\n \n+Sun Oct 26 02:36:21 1997  Craig Burley  <burley@gnu.ai.mit.edu>\n+\n+\t* com.c (lang_print_error_function): Fix to more\n+\treliably notice when the diagnosed region changes.\n+\n+Sat Oct 25 23:43:36 1997  Craig Burley  <burley@gnu.ai.mit.edu>\n+\n+\tFix 950327-0.f:\n+\t* sta.c, sta.h (ffesta_outpooldisp): New function.\n+\t* std.c (ffestd_stmt_pass_): Don't kill NULL pool.\n+\t(ffestd_R842): If pool already preserved, save NULL\n+\tfor pool, because it should be killed only once.\n+\n+\t* malloc.c [MALLOC_DEBUG]: Put initializer for `name'\n+\tcomponent in braces, to avoid compiler warning.\n+\n Fri Oct 10 13:00:48 1997  Craig Burley  <burley@gnu.ai.mit.edu>\n \n \t* ste.c (ffeste_begin_iterdo_): Fix loop setup so iteration"}, {"sha": "acaadb9a490ff99f1653a59b3e35093b9327d653", "filename": "gcc/f/com.c", "status": "modified", "additions": 90, "deletions": 62, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -6659,7 +6659,7 @@ ffecom_finish_global_ (ffeglobal global)\n static ffesymbol\n ffecom_finish_symbol_transform_ (ffesymbol s)\n {\n-  if (s == NULL)\n+  if ((s == NULL) || (TREE_CODE (current_function_decl) == ERROR_MARK))\n     return s;\n \n   /* It's easy to know to transform an untransformed symbol, to make sure\n@@ -7948,7 +7948,8 @@ ffecom_start_progunit_ ()\n \n   resume_momentary (yes);\n \n-  store_parm_decls (main_program ? 1 : 0);\n+  if (TREE_CODE (current_function_decl) != ERROR_MARK)\n+    store_parm_decls (main_program ? 1 : 0);\n \n   ffecom_start_compstmt_ ();\n \n@@ -14206,39 +14207,46 @@ finish_function (int nested)\n   register tree fndecl = current_function_decl;\n \n   assert (fndecl != NULL_TREE);\n-  if (nested)\n-    assert (DECL_CONTEXT (fndecl) != NULL_TREE);\n-  else\n-    assert (DECL_CONTEXT (fndecl) == NULL_TREE);\n+  if (TREE_CODE (fndecl) != ERROR_MARK)\n+    {\n+      if (nested)\n+\tassert (DECL_CONTEXT (fndecl) != NULL_TREE);\n+      else\n+\tassert (DECL_CONTEXT (fndecl) == NULL_TREE);\n+    }\n \n /*  TREE_READONLY (fndecl) = 1;\n     This caused &foo to be of type ptr-to-const-function\n     which then got a warning when stored in a ptr-to-function variable.  */\n \n   poplevel (1, 0, 1);\n-  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n-  /* Must mark the RESULT_DECL as being in this function.  */\n+  if (TREE_CODE (fndecl) != ERROR_MARK)\n+    {\n+      BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n+\n+      /* Must mark the RESULT_DECL as being in this function.  */\n \n-  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n+      DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n-  /* Obey `register' declarations if `setjmp' is called in this fn.  */\n-  /* Generate rtl for function exit.  */\n-  expand_function_end (input_filename, lineno, 0);\n+      /* Obey `register' declarations if `setjmp' is called in this fn.  */\n+      /* Generate rtl for function exit.  */\n+      expand_function_end (input_filename, lineno, 0);\n \n-  /* So we can tell if jump_optimize sets it to 1.  */\n-  can_reach_end = 0;\n+      /* So we can tell if jump_optimize sets it to 1.  */\n+      can_reach_end = 0;\n \n-  /* Run the optimizers and output the assembler code for this function.  */\n-  rest_of_compilation (fndecl);\n+      /* Run the optimizers and output the assembler code for this function.  */\n+      rest_of_compilation (fndecl);\n+    }\n \n   /* Free all the tree nodes making up this function.  */\n   /* Switch back to allocating nodes permanently until we start another\n      function.  */\n   if (!nested)\n     permanent_allocation (1);\n \n-  if (DECL_SAVED_INSNS (fndecl) == 0 && !nested)\n+  if (DECL_SAVED_INSNS (fndecl) == 0 && !nested && (TREE_CODE (fndecl) != ERROR_MARK))\n     {\n       /* Stop pointing to the local nodes about to be freed.  */\n       /* But DECL_INITIAL must remain nonzero so we know this was an actual\n@@ -14276,6 +14284,8 @@ lang_printable_name (tree decl, int v)\n   switch (v)\n     {\n     default:\n+      if (TREE_CODE (decl) == ERROR_MARK)\n+\treturn \"erroneous code\";\n       return IDENTIFIER_POINTER (DECL_NAME (decl));\n     }\n }\n@@ -14288,48 +14298,56 @@ void\n lang_print_error_function (file)\n      char *file;\n {\n+  static ffeglobal last_g = NULL;\n   static ffesymbol last_s = NULL;\n+  ffeglobal g;\n   ffesymbol s;\n   char *kind;\n \n-  if (ffecom_primary_entry_ == NULL)\n+  if ((ffecom_primary_entry_ == NULL)\n+      || (ffesymbol_global (ffecom_primary_entry_) == NULL))\n     {\n+      g = NULL;\n       s = NULL;\n       kind = NULL;\n     }\n-  else if (ffecom_nested_entry_ == NULL)\n+  else\n     {\n-      s = ffecom_primary_entry_;\n-      switch (ffesymbol_kind (s))\n+      g = ffesymbol_global (ffecom_primary_entry_);\n+      if (ffecom_nested_entry_ == NULL)\n \t{\n-\tcase FFEINFO_kindFUNCTION:\n-\t  kind = \"function\";\n-\t  break;\n+\t  s = ffecom_primary_entry_;\n+\t  switch (ffesymbol_kind (s))\n+\t    {\n+\t    case FFEINFO_kindFUNCTION:\n+\t      kind = \"function\";\n+\t      break;\n \n-\tcase FFEINFO_kindSUBROUTINE:\n-\t  kind = \"subroutine\";\n-\t  break;\n+\t    case FFEINFO_kindSUBROUTINE:\n+\t      kind = \"subroutine\";\n+\t      break;\n \n-\tcase FFEINFO_kindPROGRAM:\n-\t  kind = \"program\";\n-\t  break;\n+\t    case FFEINFO_kindPROGRAM:\n+\t      kind = \"program\";\n+\t      break;\n \n-\tcase FFEINFO_kindBLOCKDATA:\n-\t  kind = \"block-data\";\n-\t  break;\n+\t    case FFEINFO_kindBLOCKDATA:\n+\t      kind = \"block-data\";\n+\t      break;\n \n-\tdefault:\n-\t  kind = ffeinfo_kind_message (ffesymbol_kind (s));\n-\t  break;\n+\t    default:\n+\t      kind = ffeinfo_kind_message (ffesymbol_kind (s));\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  s = ffecom_nested_entry_;\n+\t  kind = \"statement function\";\n \t}\n-    }\n-  else\n-    {\n-      s = ffecom_nested_entry_;\n-      kind = \"statement function\";\n     }\n \n-  if (last_s != s)\n+  if ((last_g != g) || (last_s != s))\n     {\n       if (file)\n \tfprintf (stderr, \"%s: \", file);\n@@ -14343,6 +14361,7 @@ lang_print_error_function (file)\n \t  fprintf (stderr, \"In %s `%s':\\n\", kind, name);\n \t}\n \n+      last_g = g;\n       last_s = s;\n     }\n }\n@@ -14615,42 +14634,51 @@ start_function (tree name, tree type, int nested, int public)\n       assert (current_function_decl == NULL_TREE);\n     }\n \n-  decl1 = build_decl (FUNCTION_DECL,\n-\t\t      name,\n-\t\t      type);\n-  TREE_PUBLIC (decl1) = public ? 1 : 0;\n-  if (nested)\n-    DECL_INLINE (decl1) = 1;\n-  TREE_STATIC (decl1) = 1;\n-  DECL_EXTERNAL (decl1) = 0;\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    decl1 = current_function_decl = error_mark_node;\n+  else\n+    {\n+      decl1 = build_decl (FUNCTION_DECL,\n+\t\t\t  name,\n+\t\t\t  type);\n+      TREE_PUBLIC (decl1) = public ? 1 : 0;\n+      if (nested)\n+\tDECL_INLINE (decl1) = 1;\n+      TREE_STATIC (decl1) = 1;\n+      DECL_EXTERNAL (decl1) = 0;\n \n-  announce_function (decl1);\n+      announce_function (decl1);\n \n-  /* Make the init_value nonzero so pushdecl knows this is not tentative.\n-     error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n-  DECL_INITIAL (decl1) = error_mark_node;\n+      /* Make the init_value nonzero so pushdecl knows this is not tentative.\n+\t error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n+      DECL_INITIAL (decl1) = error_mark_node;\n \n-  /* Record the decl so that the function name is defined. If we already have\n-     a decl for this name, and it is a FUNCTION_DECL, use the old decl.  */\n+      /* Record the decl so that the function name is defined. If we already have\n+\t a decl for this name, and it is a FUNCTION_DECL, use the old decl.  */\n+\n+      current_function_decl = pushdecl (decl1);\n+    }\n \n-  current_function_decl = pushdecl (decl1);\n   if (!nested)\n     ffecom_outer_function_decl_ = current_function_decl;\n \n   pushlevel (0);\n \n-  make_function_rtl (current_function_decl);\n+  if (TREE_CODE (current_function_decl) != ERROR_MARK)\n+    {\n+      make_function_rtl (current_function_decl);\n \n-  restype = TREE_TYPE (TREE_TYPE (current_function_decl));\n-  DECL_RESULT (current_function_decl)\n-    = build_decl (RESULT_DECL, NULL_TREE, restype);\n+      restype = TREE_TYPE (TREE_TYPE (current_function_decl));\n+      DECL_RESULT (current_function_decl)\n+\t= build_decl (RESULT_DECL, NULL_TREE, restype);\n+    }\n \n   if (!nested)\n     /* Allocate further tree nodes temporarily during compilation of this\n        function only.  */\n     temporary_allocation ();\n \n-  if (!nested)\n+  if (!nested && (TREE_CODE (current_function_decl) != ERROR_MARK))\n     TREE_ADDRESSABLE (current_function_decl) = 1;\n \n   immediate_size_expand = old_immediate_size_expand;"}, {"sha": "6033fb42ea7e5d970b1bc30662a3455619c5f60a", "filename": "gcc/f/g77.texi", "status": "modified", "additions": 121, "deletions": 26, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -1345,6 +1345,8 @@ by type.  Explanations are in the following sections.\n -fcase-initcap  -fcase-upper  -fcase-lower  -fcase-preserve\n -ff2c-intrinsics-delete  -ff2c-intrinsics-hide\n -ff2c-intrinsics-disable  -ff2c-intrinsics-enable\n+-fbadu77-intrinsics-delete  -fbadu77-intrinsics-hide\n+-fbadu77-intrinsics-disable  -fbadu77-intrinsics-enable\n -ff90-intrinsics-delete  -ff90-intrinsics-hide\n -ff90-intrinsics-disable  -ff90-intrinsics-enable\n -fgnu-intrinsics-delete  -fgnu-intrinsics-hide\n@@ -1827,9 +1829,11 @@ had read @samp{DIMENSION X(*)}.\n @cindex -fugly-comma option\n @cindex options, -fugly-comma\n @item -fugly-comma\n-Treat a trailing comma in an argument list as specification\n-of a trailing null argument, and treat an empty argument\n-list as specification of a single null argument.\n+In an external-procedure invocation,\n+treat a trailing comma in the argument list\n+as specification of a trailing null argument,\n+and treat an empty argument list\n+as specification of a single null argument.\n \n For example, @samp{CALL FOO(,)} is treated as\n @samp{CALL FOO(%VAL(0), %VAL(0))}.\n@@ -1839,6 +1843,8 @@ And @samp{F = FUNC()} is treated as @samp{F = FUNC(%VAL(0))}.\n \n The default behavior, @samp{-fno-ugly-comma}, is to ignore\n a single trailing comma in an argument list.\n+So, by default, @samp{CALL FOO(X,)} is treated\n+exactly the same as @samp{CALL FOO(X)}.\n \n @xref{Ugly Null Arguments}, for more information.\n \n@@ -2046,6 +2052,24 @@ while allowing any-case matching of intrinsics and keywords.\n For example, @samp{call Foo(i,I)} would pass two @emph{different}\n variables named @samp{i} and @samp{I} to a procedure named @samp{Foo}.)\n \n+@cindex -fbadu77-intrinsics-delete option\n+@cindex options, -fbadu77-intrinsics-delete\n+@item -fbadu77-intrinsics-delete\n+@cindex -fbadu77-intrinsics-hide option\n+@cindex options, -fbadu77-intrinsics-hide\n+@item -fbadu77-intrinsics-hide\n+@cindex -fbadu77-intrinsics-disable option\n+@cindex options, -fbadu77-intrinsics-disable\n+@item -fbadu77-intrinsics-disable\n+@cindex -fbadu77-intrinsics-enable option\n+@cindex options, -fbadu77-intrinsics-enable\n+@item -fbadu77-intrinsics-enable\n+@cindex badu77 intrinsics\n+@cindex intrinsics, badu77\n+Specify status of UNIX intrinsics having inappropriate forms.\n+@samp{-fbadu77-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n+\n @cindex -ff2c-intrinsics-delete option\n @cindex options, -ff2c-intrinsics-delete\n @item -ff2c-intrinsics-delete\n@@ -2062,6 +2086,7 @@ variables named @samp{i} and @samp{I} to a procedure named @samp{Foo}.)\n @cindex intrinsics, f2c\n Specify status of f2c-specific intrinsics.\n @samp{-ff2c-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -ff90-intrinsics-delete option\n @cindex options, -ff90-intrinsics-delete\n@@ -2079,6 +2104,7 @@ Specify status of f2c-specific intrinsics.\n @cindex intrinsics, Fortran 90\n Specify status of F90-specific intrinsics.\n @samp{-ff90-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -fgnu-intrinsics-delete option\n @cindex options, -fgnu-intrinsics-delete\n@@ -2097,6 +2123,7 @@ Specify status of F90-specific intrinsics.\n @cindex intrinsics, COMPLEX\n Specify status of Digital's COMPLEX-related intrinsics.\n @samp{-fgnu-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -fmil-intrinsics-delete option\n @cindex options, -fmil-intrinsics-delete\n@@ -2114,6 +2141,7 @@ Specify status of Digital's COMPLEX-related intrinsics.\n @cindex intrinsics, MIL-STD 1753\n Specify status of MIL-STD-1753-specific intrinsics.\n @samp{-fmil-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -funix-intrinsics-delete option\n @cindex options, -funix-intrinsics-delete\n@@ -2131,6 +2159,7 @@ Specify status of MIL-STD-1753-specific intrinsics.\n @cindex intrinsics, UNIX\n Specify status of UNIX intrinsics.\n @samp{-funix-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -fvxt-intrinsics-delete option\n @cindex options, -fvxt-intrinsics-delete\n@@ -2148,6 +2177,7 @@ Specify status of UNIX intrinsics.\n @cindex intrinsics, VXT\n Specify status of VXT intrinsics.\n @samp{-fvxt-intrinsics-enable} is the default.\n+@xref{Intrinsic Groups}.\n \n @cindex -ffixed-line-length-@var{n} option\n @cindex options, -ffixed-line-length-@var{n}\n@@ -3251,7 +3281,7 @@ users use @code{g77}.\n such changes to @code{g77}.\n \n To find out about existing bugs and ongoing plans for GNU\n-Fortran, retrieve @code{ftp://alpha.gnu.org/g77.plan}\n+Fortran, retrieve @uref{ftp://alpha.gnu.org/g77.plan}\n or, if you cannot do that, email\n @email{fortran@@gnu.org} asking for a recent copy of the\n GNU Fortran @file{.plan} file.\n@@ -3699,8 +3729,8 @@ way through the compilation process instead of being lost.\n GNU Fortran supports a variety of extensions to, and dialects\n of, the Fortran language.\n Its primary base is the ANSI FORTRAN 77 standard, currently available on\n-the network at @code{http://kumo.swcp.com/fortran/F77_std/f77_std.html}\n-or in @code{ftp://ftp.ast.cam.ac.uk/pub/michael/}.\n+the network at @uref{http://kumo.swcp.com/fortran/F77_std/f77_std.html}\n+or in @uref{ftp://ftp.ast.cam.ac.uk/pub/michael/}.\n It offers some extensions that are popular among users\n of UNIX @code{f77} and @code{f2c} compilers, some that\n are popular among users of other compilers (such as Digital\n@@ -5726,7 +5756,7 @@ C INT(I1-I2) as INT(I1)-INT(I2) given INTEGER*2 I1,I2.\n C\n C Version 0:\n C Written by James Craig Burley 1997-02-20.\n-C Contact via Internet email: burley@@gnu.ai.mit.edu\n+C Contact via Internet email: burley@@gnu.org\n C\n C Purpose:\n C Determine how compilers handle non-standard IDIM\n@@ -7060,11 +7090,11 @@ without conversion.\n @cindex null arguments\n @cindex arguments, null\n \n-The @samp{-fugly-comma} option enables\n-use of a single trailing comma to mean ``pass an extra trailing null\n-argument'' in a list of actual arguments to a procedure other than a\n-statement function, and use of an empty list of arguments to\n-mean ``pass a single null argument''.\n+The @samp{-fugly-comma} option enables use of a single trailing comma\n+to mean ``pass an extra trailing null argument''\n+in a list of actual arguments to an external procedure,\n+and use of an empty list of arguments to such a procedure\n+to mean ``pass a single null argument''.\n \n @cindex omitting arguments\n @cindex arguments, omitting\n@@ -7598,26 +7628,33 @@ The groups are:\n @cindex intrinsics, groups of\n @cindex groups of intrinsics\n @table @code\n+@cindex @code{badu77} intrinsics group\n @item badu77\n UNIX intrinsics having inappropriate forms (usually functions that\n have intended side effects).\n \n+@cindex @code{gnu} intrinsics group\n @item gnu\n Intrinsics the GNU Fortran language supports that are extensions to\n the Fortran standards (77 and 90).\n \n+@cindex @code{f2c} intrinsics group\n @item f2c\n Intrinsics supported by AT&T's @code{f2c} converter and/or @code{libf2c}.\n \n+@cindex @code{f90} intrinsics group\n @item f90\n Fortran 90 intrinsics.\n \n+@cindex @code{mil} intrinsics group\n @item mil\n MIL-STD 1753 intrinsics (@code{MVBITS}, @code{IAND}, @code{BTEST}, and so on).\n \n+@cindex @code{mil} intrinsics group\n @item unix\n UNIX intrinsics (@code{IARGC}, @code{EXIT}, @code{ERF}, and so on).\n \n+@cindex @code{mil} intrinsics group\n @item vxt\n VAX/VMS FORTRAN (current as of v4) intrinsics.\n @end table\n@@ -7867,7 +7904,7 @@ options @code{g77} passes by running @samp{g77 -v}.\n @cindex cfortran.h\n @cindex Netlib\n Even if you don't actually use it as a compiler, @samp{f2c} from\n-@code{ftp://ftp.netlib.org/f2c/src}, can be a useful tool when you're\n+@uref{ftp://ftp.netlib.org/f2c/src}, can be a useful tool when you're\n interfacing (linking) Fortran and C@.\n @xref{f2c Skeletons and Prototypes,,Generating Skeletons and Prototypes with @code{f2c}}.\n \n@@ -7877,7 +7914,7 @@ build the @file{src} directory from the distribution, consult the\n @code{f2c} program on your path.\n \n Something else that might be useful is @samp{cfortran.h} from\n-@code{ftp://zebra/desy.de/cfortran}.\n+@uref{ftp://zebra/desy.de/cfortran}.\n This is a fairly general tool which\n can be used to generate interfaces for calling in both directions\n between Fortran and C@.\n@@ -7921,8 +7958,8 @@ the return type of a @code{REAL} @code{FUNCTION}.)\n @samp{-P} option to generate C prototypes appropriate for calling the\n Fortran.@footnote{The files generated like this can also be used for\n inter-unit consistency checking of dummy and actual arguments, although\n-the @samp{ftnchek} tool from @code{ftp://ftp.netlib.org/fortran}\n-or @code{ftp://ftp.dsm.fordham.edu} is\n+the @samp{ftnchek} tool from @uref{ftp://ftp.netlib.org/fortran}\n+or @uref{ftp://ftp.dsm.fordham.edu} is\n probably better for this purpose.}\n If the Fortran code containing any\n routines to be called from C is in file @file{joe.f}, use the command\n@@ -10164,7 +10201,7 @@ or installing @code{g77} is not provided here.\n \n To find out about major bugs discovered in the current release and\n possible workarounds for them, retrieve\n-@code{ftp://alpha.gnu.org/g77.plan}.\n+@uref{ftp://alpha.gnu.org/g77.plan}.\n \n (Note that some of this portion of the manual is lifted\n directly from the @code{gcc} manual, with minor modifications\n@@ -10541,7 +10578,7 @@ In the meantime, finding and fixing the programming\n bugs that lead to these behaviors is, ultimately, the user's\n responsibility, as difficult as that task can sometimes be.\n \n-@cindex `infinite spaces' printed\n+@cindex ``infinite spaces'' printed\n @cindex spaces, endless printing of\n @cindex libc, non-ANSI or non-default\n @cindex C library\n@@ -11029,16 +11066,17 @@ specifiers.\n Supporting this requires a significant redesign or replacement\n of @code{libf2c}.\n \n-However, a future version of @code{g77} might support\n-this construct when the expression is constant.  For\n-example:\n+However, @code{g77} does support\n+this construct when the expression is constant\n+(as of version 0.5.22).\n+For example:\n \n @smallexample\n       PARAMETER (IWIDTH = 12)\n 10    FORMAT (I<IWIDTH>)\n @end smallexample\n \n-In the meantime, at least for output (@code{PRINT} and\n+Otherwise, at least for output (@code{PRINT} and\n @code{WRITE}), Fortran code making use of this feature can\n be rewritten to avoid it by constructing the @code{FORMAT}\n string in a @code{CHARACTER} variable or array, then\n@@ -12272,8 +12310,65 @@ their use into selective changes in your own code.\n @pindex ftncheck\n Validate your code with @code{ftnchek} or a similar code-checking\n tool.\n-@code{ftncheck} can be found at @code{ftp://ftp.netlib.org/fortran}\n-or @code{ftp://ftp.dsm.fordham.edu}.\n+@code{ftncheck} can be found at @uref{ftp://ftp.netlib.org/fortran}\n+or @uref{ftp://ftp.dsm.fordham.edu}.\n+\n+@pindex make\n+@cindex Makefile example\n+Here are some sample @file{Makefile} rules using @code{ftnchek}\n+``project'' files to do cross-file checking and @code{sfmakedepend}\n+(from @uref{ftp://ahab.rutgers.edu/pub/perl/sfmakedepend})\n+to maintain dependencies automatically.\n+These assume the use of GNU @code{make}.\n+\n+@smallexample\n+# Dummy suffix for ftnchek targets:\n+.SUFFIXES: .chek\n+.PHONY: chekall\n+\n+# How to compile .f files (for implicit rule):\n+FC = g77\n+# Assume `include' directory:\n+FFLAGS = -Iinclude -g -O -Wall\n+\n+# Flags for ftnchek:\n+CHEK1 = -array=0 -include=includes -noarray\n+CHEK2 = -nonovice -usage=1 -notruncation\n+CHEKFLAGS = $(CHEK1) $(CHEK2)\n+\n+# Run ftnchek with all the .prj files except the one corresponding\n+# to the target's root:\n+%.chek : %.f ; \\\n+  ftnchek $(filter-out $*.prj,$(PRJS)) $(CHEKFLAGS) \\\n+    -noextern -library $<\n+\n+# Derive a project file from a source file:\n+%.prj : %.f ; \\\n+  ftnchek $(CHEKFLAGS) -noextern -project -library $<\n+\n+# The list of objects is assumed to be in variable OBJS.\n+# Sources corresponding to the objects:\n+SRCS = $(OBJS:%.o=%.f)\n+# ftnchek project files:\n+PRJS = $(OBJS:%.o=%.prj)\n+\n+# Build the program\n+prog: $(OBJS) ; \\\n+  $(FC) -o $@ $(OBJS)\n+\n+chekall: $(PRJS) ; \\\n+  ftnchek $(CHEKFLAGS) $(PRJS)\n+\n+prjs: $(PRJS)\n+\n+# For Emacs M-x find-tag:\n+TAGS: $(SRCS) ; \\\n+  etags $(SRCS)\n+\n+# Rebuild dependencies:\n+depend: ; \\\n+  sfmakedepend -I $(PLTLIBDIR) -I includes -a prj $(SRCS1)\n+@end smallexample\n \n @item\n Try your code out using other Fortran compilers, such as @code{f2c}.\n@@ -13352,7 +13447,7 @@ that the explanations are given below, and the diagnostics themselves\n identify the appropriate explanation.\n \n Identification uses the GNU Info format---specifically, the @code{info}\n-command that displays the explanation is given in within square\n+command that displays the explanation is given within square\n brackets in the diagnostic.\n For example:\n \n@@ -13556,7 +13651,7 @@ The following sample program might help:\n       PROGRAM JCB003\n C\n C Written by James Craig Burley 1997-02-23.\n-C Contact via Internet email: burley@@gnu.ai.mit.edu\n+C Contact via Internet email: burley@@gnu.org\n C\n C Determine how compilers handle non-standard REAL\n C and AIMAG on DOUBLE COMPLEX operands."}, {"sha": "33223fc552f430d52b99c8e4542c259af606adcb", "filename": "gcc/f/g77install.texi", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fg77install.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fg77install.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77install.texi?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -5,7 +5,7 @@\n @c The text of this file appears in the file INSTALL\n @c in the G77 distribution, as well as in the G77 manual.\n \n-@c 1997-09-09\n+@c 1997-12-23\n \n Note most of this information is out of date and superceded by the EGCS\n install procedures.  It is provided for historical reference only.\n@@ -66,9 +66,9 @@ most systems, if desired.\n \n =======\n The version of GNU @code{gzip} used to package this release\n-is 1.24.\n+is 1.2.4.\n (The version of GNU @code{tar} used to package this release\n-is 1.11.2.)\n+is 1.12.)\n \n @item @file{gcc-2.7.2.3.tar.gz}\n You need to have this, or some other applicable, version\n@@ -202,15 +202,15 @@ In any case, you can apply patches by hand---patch files\n are designed for humans to read them.\n \n The version of GNU @code{patch} used to develop this release\n-is 2.4.\n+is 2.5.\n \n @item @code{make}\n Your system must have @code{make}, and you will probably save\n yourself a lot of trouble if it is GNU @code{make} (sometimes\n referred to as @code{gmake}).\n \n The version of GNU @code{make} used to develop this release\n-is 3.73.\n+is 3.76.1.\n \n @item @code{cc}\n Your system must have a working C compiler.\n@@ -300,10 +300,10 @@ either @code{gcc} or @code{g77}.\n These problems can occur on most or all systems.\n \n @menu\n-* GNU C Required::\t       Why even ANSI C is not enough.\n+* GNU C Required::             Why even ANSI C is not enough.\n * Patching GNU CC Necessary::  Why @code{gcc} must be patched first.\n * Building GNU CC Necessary::  Why you can't build @emph{just} Fortran.\n-* Missing strtoul::\t       If linking @code{f771} fails due to an\n+* Missing strtoul::            If linking @code{f771} fails due to an\n                                 unresolved reference to @code{strtoul}.\n * Cleanup Kills Stage Directories::  A minor nit for @code{g77} developers.\n * Missing gperf?::             When building requires @code{gperf}."}, {"sha": "4a553e920843b78d2fd3c272ccdb707e97c6c78b", "filename": "gcc/f/malloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fmalloc.c?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -51,7 +51,7 @@ struct _malloc_root_ malloc_root_\n     (mallocArea_) &malloc_root_.malloc_pool_image_.first,\n     0,\n #if MALLOC_DEBUG\n-    0, 0, 0, 0, 0, 0, 0, '/'\n+    0, 0, 0, 0, 0, 0, 0, { '/' }\n #endif\n   },\n };"}, {"sha": "281ca9361333b1067b0e60005139733a894821dd", "filename": "gcc/f/sta.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fsta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fsta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsta.c?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -1792,9 +1792,11 @@ ffesta_ffebad_2t (ffebad errnum, ffelexToken t1, ffelexToken t2)\n     }\n }\n \n-/* ffesta_set_outpooldisp -- Set disposition of statement output pool\n-\n-   ffesta_set_outpooldisp(FFESTA_pooldispPRESERVE);  */\n+ffestaPooldisp\n+ffesta_outpooldisp ()\n+{\n+  return ffesta_outpooldisp_;\n+}\n \n void\n ffesta_set_outpooldisp (ffestaPooldisp d)"}, {"sha": "26e78c412ce2fe17950a884191573e595e08715d", "filename": "gcc/f/sta.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fsta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fsta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsta.h?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -98,6 +98,7 @@ void ffesta_ffebad_2st (ffebad msg, char *s, ffelexToken t1, ffelexToken t2);\n void ffesta_ffebad_2t (ffebad msg, ffelexToken t1, ffelexToken t2);\n ffelexHandler ffesta_zero (ffelexToken t);\n ffelexHandler ffesta_two (ffelexToken first, ffelexToken second);\n+ffestaPooldisp ffesta_outpooldisp (void);\n void ffesta_set_outpooldisp (ffestaPooldisp d);\n \n /* Define macros. */"}, {"sha": "dac22817dabb0330e18fc781d0f215e80b5b3873", "filename": "gcc/f/std.c", "status": "modified", "additions": 189, "deletions": 88, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fstd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/gcc%2Ff%2Fstd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.c?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -662,9 +662,10 @@ ffestd_stmt_pass_ ()\n {\n   ffestdStmt_ stmt;\n   ffestdExprItem_ expr;\t\t/* For traversing lists. */\n+  bool okay = (TREE_CODE (current_function_decl) != ERROR_MARK);\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n-  if (ffestd_2pass_entrypoints_ != 0)\n+  if ((ffestd_2pass_entrypoints_ != 0) && okay)\n     {\n       tree which = ffecom_which_entrypoint_decl ();\n       tree value;\n@@ -718,83 +719,97 @@ ffestd_stmt_pass_ ()\n \t{\n \tcase FFESTD_stmtidENDDOLOOP_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_do (stmt->u.enddoloop.block);\n+\t  if (okay)\n+\t    ffeste_do (stmt->u.enddoloop.block);\n \t  ffestw_kill (stmt->u.enddoloop.block);\n \t  break;\n \n \tcase FFESTD_stmtidENDLOGIF_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_end_R807 ();\n+\t  if (okay)\n+\t    ffeste_end_R807 ();\n \t  break;\n \n \tcase FFESTD_stmtidEXECLABEL_:\n-\t  ffeste_labeldef_branch (stmt->u.execlabel.label);\n+\t  if (okay)\n+\t    ffeste_labeldef_branch (stmt->u.execlabel.label);\n \t  break;\n \n \tcase FFESTD_stmtidFORMATLABEL_:\n-\t  ffeste_labeldef_format (stmt->u.formatlabel.label);\n+\t  if (okay)\n+\t    ffeste_labeldef_format (stmt->u.formatlabel.label);\n \t  break;\n \n \tcase FFESTD_stmtidR737A_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R737A (stmt->u.R737A.dest, stmt->u.R737A.source);\n+\t  if (okay)\n+\t    ffeste_R737A (stmt->u.R737A.dest, stmt->u.R737A.source);\n \t  malloc_pool_kill (stmt->u.R737A.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR803_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R803 (stmt->u.R803.expr);\n+\t  if (okay)\n+\t    ffeste_R803 (stmt->u.R803.expr);\n \t  malloc_pool_kill (stmt->u.R803.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR804_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R804 (stmt->u.R804.expr);\n+\t  if (okay)\n+\t    ffeste_R804 (stmt->u.R804.expr);\n \t  malloc_pool_kill (stmt->u.R804.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR805_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R805 ();\n+\t  if (okay)\n+\t    ffeste_R805 ();\n \t  break;\n \n \tcase FFESTD_stmtidR806_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R806 ();\n+\t  if (okay)\n+\t    ffeste_R806 ();\n \t  break;\n \n \tcase FFESTD_stmtidR807_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R807 (stmt->u.R807.expr);\n+\t  if (okay)\n+\t    ffeste_R807 (stmt->u.R807.expr);\n \t  malloc_pool_kill (stmt->u.R807.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR809_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R809 (stmt->u.R809.block, stmt->u.R809.expr);\n+\t  if (okay)\n+\t    ffeste_R809 (stmt->u.R809.block, stmt->u.R809.expr);\n \t  malloc_pool_kill (stmt->u.R809.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR810_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R810 (stmt->u.R810.block, stmt->u.R810.casenum);\n+\t  if (okay)\n+\t    ffeste_R810 (stmt->u.R810.block, stmt->u.R810.casenum);\n \t  malloc_pool_kill (stmt->u.R810.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR811_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R811 (stmt->u.R811.block);\n+\t  if (okay)\n+\t    ffeste_R811 (stmt->u.R811.block);\n \t  malloc_pool_kill (ffestw_select (stmt->u.R811.block)->pool);\n \t  ffestw_kill (stmt->u.R811.block);\n \t  break;\n \n \tcase FFESTD_stmtidR819A_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R819A (stmt->u.R819A.block, stmt->u.R819A.label,\n-\t\t\tstmt->u.R819A.var,\n-\t\t\tstmt->u.R819A.start, stmt->u.R819A.start_token,\n-\t\t\tstmt->u.R819A.end, stmt->u.R819A.end_token,\n-\t\t\tstmt->u.R819A.incr, stmt->u.R819A.incr_token);\n+\t  if (okay)\n+\t    ffeste_R819A (stmt->u.R819A.block, stmt->u.R819A.label,\n+\t\t\t  stmt->u.R819A.var,\n+\t\t\t  stmt->u.R819A.start, stmt->u.R819A.start_token,\n+\t\t\t  stmt->u.R819A.end, stmt->u.R819A.end_token,\n+\t\t\t  stmt->u.R819A.incr, stmt->u.R819A.incr_token);\n \t  ffelex_token_kill (stmt->u.R819A.start_token);\n \t  ffelex_token_kill (stmt->u.R819A.end_token);\n \t  if (stmt->u.R819A.incr_token != NULL)\n@@ -804,269 +819,342 @@ ffestd_stmt_pass_ ()\n \n \tcase FFESTD_stmtidR819B_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R819B (stmt->u.R819B.block, stmt->u.R819B.label,\n-\t\t\tstmt->u.R819B.expr);\n+\t  if (okay)\n+\t    ffeste_R819B (stmt->u.R819B.block, stmt->u.R819B.label,\n+\t\t\t  stmt->u.R819B.expr);\n \t  malloc_pool_kill (stmt->u.R819B.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR825_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R825 ();\n+\t  if (okay)\n+\t    ffeste_R825 ();\n \t  break;\n \n \tcase FFESTD_stmtidR834_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R834 (stmt->u.R834.block);\n+\t  if (okay)\n+\t    ffeste_R834 (stmt->u.R834.block);\n \t  break;\n \n \tcase FFESTD_stmtidR835_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R835 (stmt->u.R835.block);\n+\t  if (okay)\n+\t    ffeste_R835 (stmt->u.R835.block);\n \t  break;\n \n \tcase FFESTD_stmtidR836_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R836 (stmt->u.R836.label);\n+\t  if (okay)\n+\t    ffeste_R836 (stmt->u.R836.label);\n \t  break;\n \n \tcase FFESTD_stmtidR837_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R837 (stmt->u.R837.labels, stmt->u.R837.count,\n-\t\t       stmt->u.R837.expr);\n+\t  if (okay)\n+\t    ffeste_R837 (stmt->u.R837.labels, stmt->u.R837.count,\n+\t\t\t stmt->u.R837.expr);\n \t  malloc_pool_kill (stmt->u.R837.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR838_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R838 (stmt->u.R838.label, stmt->u.R838.target);\n+\t  if (okay)\n+\t    ffeste_R838 (stmt->u.R838.label, stmt->u.R838.target);\n \t  malloc_pool_kill (stmt->u.R838.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR839_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R839 (stmt->u.R839.target);\n+\t  if (okay)\n+\t    ffeste_R839 (stmt->u.R839.target);\n \t  malloc_pool_kill (stmt->u.R839.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR840_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R840 (stmt->u.R840.expr, stmt->u.R840.neg, stmt->u.R840.zero,\n-\t\t       stmt->u.R840.pos);\n+\t  if (okay)\n+\t    ffeste_R840 (stmt->u.R840.expr, stmt->u.R840.neg, stmt->u.R840.zero,\n+\t\t\t stmt->u.R840.pos);\n \t  malloc_pool_kill (stmt->u.R840.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR841_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R841 ();\n+\t  if (okay)\n+\t    ffeste_R841 ();\n \t  break;\n \n \tcase FFESTD_stmtidR842_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R842 (stmt->u.R842.expr);\n-\t  malloc_pool_kill (stmt->u.R842.pool);\n+\t  if (okay)\n+\t    ffeste_R842 (stmt->u.R842.expr);\n+\t  if (stmt->u.R842.pool != NULL)\n+\t    malloc_pool_kill (stmt->u.R842.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR843_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R843 (stmt->u.R843.expr);\n+\t  if (okay)\n+\t    ffeste_R843 (stmt->u.R843.expr);\n \t  malloc_pool_kill (stmt->u.R843.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR904_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R904 (stmt->u.R904.params);\n+\t  if (okay)\n+\t    ffeste_R904 (stmt->u.R904.params);\n \t  malloc_pool_kill (stmt->u.R904.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR907_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R907 (stmt->u.R907.params);\n+\t  if (okay)\n+\t    ffeste_R907 (stmt->u.R907.params);\n \t  malloc_pool_kill (stmt->u.R907.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR909_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R909_start (stmt->u.R909.params, stmt->u.R909.only_format,\n-\t\t\t     stmt->u.R909.unit, stmt->u.R909.format,\n-\t\t\t     stmt->u.R909.rec, stmt->u.R909.key);\n+\t  if (okay)\n+\t    ffeste_R909_start (stmt->u.R909.params, stmt->u.R909.only_format,\n+\t\t\t       stmt->u.R909.unit, stmt->u.R909.format,\n+\t\t\t       stmt->u.R909.rec, stmt->u.R909.key);\n \t  for (expr = stmt->u.R909.list; expr != NULL; expr = expr->next)\n \t    {\n-\t      ffeste_R909_item (expr->expr, expr->token);\n+\t      if (okay)\n+\t\tffeste_R909_item (expr->expr, expr->token);\n \t      ffelex_token_kill (expr->token);\n \t    }\n-\t  ffeste_R909_finish ();\n+\t  if (okay)\n+\t    ffeste_R909_finish ();\n \t  malloc_pool_kill (stmt->u.R909.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR910_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R910_start (stmt->u.R910.params, stmt->u.R910.unit,\n-\t\t\t     stmt->u.R910.format, stmt->u.R910.rec);\n+\t  if (okay)\n+\t    ffeste_R910_start (stmt->u.R910.params, stmt->u.R910.unit,\n+\t\t\t       stmt->u.R910.format, stmt->u.R910.rec);\n \t  for (expr = stmt->u.R910.list; expr != NULL; expr = expr->next)\n \t    {\n-\t      ffeste_R910_item (expr->expr, expr->token);\n+\t      if (okay)\n+\t\tffeste_R910_item (expr->expr, expr->token);\n \t      ffelex_token_kill (expr->token);\n \t    }\n-\t  ffeste_R910_finish ();\n+\t  if (okay)\n+\t    ffeste_R910_finish ();\n \t  malloc_pool_kill (stmt->u.R910.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR911_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R911_start (stmt->u.R911.params, stmt->u.R911.format);\n+\t  if (okay)\n+\t    ffeste_R911_start (stmt->u.R911.params, stmt->u.R911.format);\n \t  for (expr = stmt->u.R911.list; expr != NULL; expr = expr->next)\n \t    {\n-\t      ffeste_R911_item (expr->expr, expr->token);\n+\t      if (okay)\n+\t\tffeste_R911_item (expr->expr, expr->token);\n \t      ffelex_token_kill (expr->token);\n \t    }\n-\t  ffeste_R911_finish ();\n+\t  if (okay)\n+\t    ffeste_R911_finish ();\n \t  malloc_pool_kill (stmt->u.R911.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR919_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R919 (stmt->u.R919.params);\n+\t  if (okay)\n+\t    ffeste_R919 (stmt->u.R919.params);\n \t  malloc_pool_kill (stmt->u.R919.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR920_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R920 (stmt->u.R920.params);\n+\t  if (okay)\n+\t    ffeste_R920 (stmt->u.R920.params);\n \t  malloc_pool_kill (stmt->u.R920.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR921_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R921 (stmt->u.R921.params);\n+\t  if (okay)\n+\t    ffeste_R921 (stmt->u.R921.params);\n \t  malloc_pool_kill (stmt->u.R921.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR923A_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R923A (stmt->u.R923A.params, stmt->u.R923A.by_file);\n+\t  if (okay)\n+\t    ffeste_R923A (stmt->u.R923A.params, stmt->u.R923A.by_file);\n \t  malloc_pool_kill (stmt->u.R923A.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR923B_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R923B_start (stmt->u.R923B.params);\n+\t  if (okay)\n+\t    ffeste_R923B_start (stmt->u.R923B.params);\n \t  for (expr = stmt->u.R923B.list; expr != NULL; expr = expr->next)\n-\t    ffeste_R923B_item (expr->expr);\n-\t  ffeste_R923B_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_R923B_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_R923B_finish ();\n \t  malloc_pool_kill (stmt->u.R923B.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR1001_:\n-\t  ffeste_R1001 (&stmt->u.R1001.str);\n+\t  if (okay)\n+\t    ffeste_R1001 (&stmt->u.R1001.str);\n \t  ffests_kill (&stmt->u.R1001.str);\n \t  break;\n \n \tcase FFESTD_stmtidR1103_:\n-\t  ffeste_R1103 ();\n+\t  if (okay)\n+\t    ffeste_R1103 ();\n \t  break;\n \n \tcase FFESTD_stmtidR1112_:\n-\t  ffeste_R1112 ();\n+\t  if (okay)\n+\t    ffeste_R1112 ();\n \t  break;\n \n \tcase FFESTD_stmtidR1212_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R1212 (stmt->u.R1212.expr);\n+\t  if (okay)\n+\t    ffeste_R1212 (stmt->u.R1212.expr);\n \t  malloc_pool_kill (stmt->u.R1212.pool);\n \t  break;\n \n \tcase FFESTD_stmtidR1221_:\n-\t  ffeste_R1221 ();\n+\t  if (okay)\n+\t    ffeste_R1221 ();\n \t  break;\n \n \tcase FFESTD_stmtidR1225_:\n-\t  ffeste_R1225 ();\n+\t  if (okay)\n+\t    ffeste_R1225 ();\n \t  break;\n \n \tcase FFESTD_stmtidR1226_:\n \t  ffestd_subr_line_restore_ (stmt);\n \t  if (stmt->u.R1226.entry != NULL)\n-\t    ffeste_R1226 (stmt->u.R1226.entry);\n+\t    {\n+\t      if (okay)\n+\t\tffeste_R1226 (stmt->u.R1226.entry);\n+\t    }\n \t  break;\n \n \tcase FFESTD_stmtidR1227_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_R1227 (stmt->u.R1227.block, stmt->u.R1227.expr);\n+\t  if (okay)\n+\t    ffeste_R1227 (stmt->u.R1227.block, stmt->u.R1227.expr);\n \t  malloc_pool_kill (stmt->u.R1227.pool);\n \t  break;\n \n #if FFESTR_VXT\n \tcase FFESTD_stmtidV018_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V018_start (stmt->u.V018.params, stmt->u.V018.format);\n+\t  if (okay)\n+\t    ffeste_V018_start (stmt->u.V018.params, stmt->u.V018.format);\n \t  for (expr = stmt->u.V018.list; expr != NULL; expr = expr->next)\n-\t    ffeste_V018_item (expr->expr);\n-\t  ffeste_V018_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_V018_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_V018_finish ();\n \t  malloc_pool_kill (stmt->u.V018.pool);\n \t  break;\n \n \tcase FFESTD_stmtidV019_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V019_start (stmt->u.V019.params, stmt->u.V019.format);\n+\t  if (okay)\n+\t    ffeste_V019_start (stmt->u.V019.params, stmt->u.V019.format);\n \t  for (expr = stmt->u.V019.list; expr != NULL; expr = expr->next)\n-\t    ffeste_V019_item (expr->expr);\n-\t  ffeste_V019_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_V019_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_V019_finish ();\n \t  malloc_pool_kill (stmt->u.V019.pool);\n \t  break;\n #endif\n \n \tcase FFESTD_stmtidV020_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V020_start (stmt->u.V020.params, stmt->u.V020.format);\n+\t  if (okay)\n+\t    ffeste_V020_start (stmt->u.V020.params, stmt->u.V020.format);\n \t  for (expr = stmt->u.V020.list; expr != NULL; expr = expr->next)\n-\t    ffeste_V020_item (expr->expr);\n-\t  ffeste_V020_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_V020_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_V020_finish ();\n \t  malloc_pool_kill (stmt->u.V020.pool);\n \t  break;\n \n #if FFESTR_VXT\n \tcase FFESTD_stmtidV021_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V021 (stmt->u.V021.params);\n+\t  if (okay)\n+\t    ffeste_V021 (stmt->u.V021.params);\n \t  malloc_pool_kill (stmt->u.V021.pool);\n \t  break;\n \n \tcase FFESTD_stmtidV023_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V023_start (stmt->u.V023.params);\n+\t  if (okay)\n+\t    ffeste_V023_start (stmt->u.V023.params);\n \t  for (expr = stmt->u.V023.list; expr != NULL; expr = expr->next)\n-\t    ffeste_V023_item (expr->expr);\n-\t  ffeste_V023_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_V023_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_V023_finish ();\n \t  malloc_pool_kill (stmt->u.V023.pool);\n \t  break;\n \n \tcase FFESTD_stmtidV024_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V024_start (stmt->u.V024.params);\n+\t  if (okay)\n+\t    ffeste_V024_start (stmt->u.V024.params);\n \t  for (expr = stmt->u.V024.list; expr != NULL; expr = expr->next)\n-\t    ffeste_V024_item (expr->expr);\n-\t  ffeste_V024_finish ();\n+\t    {\n+\t      if (okay)\n+\t\tffeste_V024_item (expr->expr);\n+\t    }\n+\t  if (okay)\n+\t    ffeste_V024_finish ();\n \t  malloc_pool_kill (stmt->u.V024.pool);\n \t  break;\n \n \tcase FFESTD_stmtidV025start_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V025_start ();\n+\t  if (okay)\n+\t    ffeste_V025_start ();\n \t  break;\n \n \tcase FFESTD_stmtidV025item_:\n-\t  ffeste_V025_item (stmt->u.V025item.u, stmt->u.V025item.m,\n-\t\t\t    stmt->u.V025item.n, stmt->u.V025item.asv);\n+\t  if (okay)\n+\t    ffeste_V025_item (stmt->u.V025item.u, stmt->u.V025item.m,\n+\t\t\t      stmt->u.V025item.n, stmt->u.V025item.asv);\n \t  break;\n \n \tcase FFESTD_stmtidV025finish_:\n-\t  ffeste_V025_finish ();\n+\t  if (okay)\n+\t    ffeste_V025_finish ();\n \t  malloc_pool_kill (stmt->u.V025finish.pool);\n \t  break;\n \n \tcase FFESTD_stmtidV026_:\n \t  ffestd_subr_line_restore_ (stmt);\n-\t  ffeste_V026 (stmt->u.V026.params);\n+\t  if (okay)\n+\t    ffeste_V026 (stmt->u.V026.params);\n \t  malloc_pool_kill (stmt->u.V026.pool);\n \t  break;\n #endif\n@@ -3516,9 +3604,22 @@ ffestd_R842 (ffebld expr)\n     stmt = ffestd_stmt_new_ (FFESTD_stmtidR842_);\n     ffestd_stmt_append_ (stmt);\n     ffestd_subr_line_save_ (stmt);\n-    stmt->u.R842.pool = ffesta_output_pool;\n-    stmt->u.R842.expr = expr;\n-    ffesta_set_outpooldisp (FFESTA_pooldispPRESERVE);\n+    if (ffesta_outpooldisp () == FFESTA_pooldispPRESERVE)\n+      {\n+\t/* This is a \"spurious\" (automatically-generated) STOP\n+\t   that follows a previous STOP or other statement.\n+\t   Make sure we don't have an expression in the pool,\n+\t   and then mark that the pool has already been killed.  */\n+\tassert (expr == NULL);\n+\tstmt->u.R842.pool = NULL;\n+\tstmt->u.R842.expr = NULL;\n+      }\n+    else\n+      {\n+\tstmt->u.R842.pool = ffesta_output_pool;\n+\tstmt->u.R842.expr = expr;\n+\tffesta_set_outpooldisp (FFESTA_pooldispPRESERVE);\n+      }\n   }\n #endif\n "}, {"sha": "c66c0aaeed396c58bf9813c107573e4b3f45cb38", "filename": "libf2c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FChangeLog?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -5,6 +5,10 @@ Tue Dec 23 22:56:01 1997  Craig Burley  <burley@gnu.org>\n \thandler on 64-bit systems like Alphas.\n \t* f2cext.c (signal_): Changed accordingly.\n \n+Wed Oct 29 01:01:04 1997  Mumit Khan  <khan@brahma.xraylith.wisc.edu>\n+\n+\t* configure.in: Set CC to CC_FOR_TARGET when cross-compiling.\n+\n Tue Sep 30 00:41:39 1997  Craig Burley  <burley@gnu.ai.mit.edu>\n \n \tDo a better job of printing the offending FORMAT string"}, {"sha": "f5b127ec2b31b1806dc2afd52f2e1203467c5c99", "filename": "libf2c/configure.in", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2Fconfigure.in?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -23,15 +23,20 @@ AC_INIT(libF77/Version.c)\n \n AC_REVISION(1.10)\n \n-dnl Checks for programs.\n-# For g77 we'll set CC to point at the built gcc, but this will get it into\n-# the makefiles\n-AC_PROG_CC\n dnl AC_C_CROSS\n dnl Gives misleading `(cached)' message from the check.\n if test \"$CROSS\";then\n+  if test \"$CC_FOR_TARGET\"; then\n+    CC=\"$CC_FOR_TARGET\"\n+  else\n+    CC=\"../../xgcc -B../../xgcc/\"\n+  fi\n   ac_cv_c_cross=yes\n else\n+  dnl Checks for programs.\n+  # For g77 we'll set CC to point at the built gcc, but this will get it into\n+  # the makefiles\n+  AC_PROG_CC\n   ac_cv_c_cross=no\n fi\n "}, {"sha": "5c3af4c085409e7d87ba84f9906f6714419a3b7e", "filename": "libf2c/libI77/close.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2FlibI77%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56a0044b23379c1b4129f7d97d4abb444f3df175/libf2c%2FlibI77%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibI77%2Fclose.c?ref=56a0044b23379c1b4129f7d97d4abb444f3df175", "patch": "@@ -75,9 +75,12 @@ f_exit(void)\n \tstatic cllist xx;\n \tif (! (f__init & 1))\n \t\treturn;\t\t/* Not initialized, so no open units. */\n-\t/* no more I/O to be done. If this is not done, then if the\n-\t   program is interrupted during I/O, f_clos thinks, incorrectly,\n-\t   that there is an I/O recursion. */\n+\t/* I/O no longer in progress.  If, during an I/O operation (such\n+\t   as waiting for the user to enter a line), there is an\n+\t   interrupt (such as ^C to stop the program on a UNIX system),\n+\t   f_exit() is called, but there is no longer any I/O in\n+\t   progress.  Without turning off this flag, f_clos() would\n+\t   think that there is an I/O recursion in this circumstance. */\n \tf__init &= ~2;\n \tif (!xx.cerr) {\n \t\txx.cerr=1;"}]}