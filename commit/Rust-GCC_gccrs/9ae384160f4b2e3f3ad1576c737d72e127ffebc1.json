{"sha": "9ae384160f4b2e3f3ad1576c737d72e127ffebc1", "node_id": "C_kwDOANBUbNoAKDlhZTM4NDE2MGY0YjJlM2YzYWQxNTc2YzczN2Q3MmUxMjdmZmViYzE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-03-23T13:35:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:33Z"}, "message": "[Ada] Small housekeeping work in gnat_gimplify_expr\n\nThis alphabetizes the large switch statement, removes a useless nested\nswitch statement, an artificial fall through and adds a default return.\n\nNo functional changes.\n\ngcc/ada/\n\n\t* gcc-interface/trans.cc (gnat_gimplify_expr): Tidy up.", "tree": {"sha": "5bf888d2bd782ed67ac55fcaaeaeed7869c24f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bf888d2bd782ed67ac55fcaaeaeed7869c24f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ae384160f4b2e3f3ad1576c737d72e127ffebc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae384160f4b2e3f3ad1576c737d72e127ffebc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae384160f4b2e3f3ad1576c737d72e127ffebc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae384160f4b2e3f3ad1576c737d72e127ffebc1/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfc07102ef2ff3675cb193e4f0e61c9d2d5b368e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc07102ef2ff3675cb193e4f0e61c9d2d5b368e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc07102ef2ff3675cb193e4f0e61c9d2d5b368e"}], "stats": {"total": 131, "additions": 60, "deletions": 71}, "files": [{"sha": "3e8842f4a92ba331bb887389b3b8e74e9b8524ed", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 60, "deletions": 71, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae384160f4b2e3f3ad1576c737d72e127ffebc1/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae384160f4b2e3f3ad1576c737d72e127ffebc1/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=9ae384160f4b2e3f3ad1576c737d72e127ffebc1", "patch": "@@ -8638,30 +8638,6 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \n   switch (TREE_CODE (expr))\n     {\n-    case NULL_EXPR:\n-      /* If this is an aggregate type, build a null pointer of the appropriate\n-\t type and dereference it.  */\n-      if (AGGREGATE_TYPE_P (type)\n-\t  || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n-\t*expr_p = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t  convert (build_pointer_type (type),\n-\t\t\t\t\t   integer_zero_node));\n-      /* Otherwise, just make a VAR_DECL.  */\n-      else\n-\t{\n-\t  *expr_p = create_tmp_var (type, NULL);\n-\t  suppress_warning (*expr_p);\n-\t}\n-\n-      gimplify_and_add (TREE_OPERAND (expr, 0), pre_p);\n-      return GS_OK;\n-\n-    case UNCONSTRAINED_ARRAY_REF:\n-      /* We should only do this if we are just elaborating for side-effects,\n-\t but we can't know that yet.  */\n-      *expr_p = TREE_OPERAND (*expr_p, 0);\n-      return GS_OK;\n-\n     case ADDR_EXPR:\n       op = TREE_OPERAND (expr, 0);\n \n@@ -8695,8 +8671,7 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t    else\n \t      op = inner;\n \t  }\n-\n-      return GS_UNHANDLED;\n+      break;\n \n     case CALL_EXPR:\n       /* If we are passing a constant fat pointer CONSTRUCTOR, make sure it is\n@@ -8720,8 +8695,62 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t\t*(CALL_EXPR_ARGP (expr) + i) = tree_output_constant_def (arg);\n \t    }\n \t}\n+      break;\n+\n+    case DECL_EXPR:\n+      op = DECL_EXPR_DECL (expr);\n+\n+      /* The expressions for the RM bounds must be gimplified to ensure that\n+\t they are properly elaborated.  See gimplify_decl_expr.  */\n+      if ((TREE_CODE (op) == TYPE_DECL || TREE_CODE (op) == VAR_DECL)\n+\t  && !TYPE_SIZES_GIMPLIFIED (TREE_TYPE (op))\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (op))\n+\t      || SCALAR_FLOAT_TYPE_P (TREE_TYPE (op))))\n+\t{\n+\t  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (op)), t, val;\n+\n+\t  val = TYPE_RM_MIN_VALUE (type);\n+\t  if (val)\n+\t    {\n+\t      gimplify_one_sizepos (&val, pre_p);\n+\t      for (t = type; t; t = TYPE_NEXT_VARIANT (t))\n+\t\tSET_TYPE_RM_MIN_VALUE (t, val);\n+\t    }\n+\n+\t  val = TYPE_RM_MAX_VALUE (type);\n+\t  if (val)\n+\t    {\n+\t      gimplify_one_sizepos (&val, pre_p);\n+\t      for (t = type; t; t = TYPE_NEXT_VARIANT (t))\n+\t\tSET_TYPE_RM_MAX_VALUE (t, val);\n+\t    }\n+\t}\n+      break;\n+\n+    case NULL_EXPR:\n+      /* If this is an aggregate type, build a null pointer of the appropriate\n+\t type and dereference it.  */\n+      if (AGGREGATE_TYPE_P (type)\n+\t  || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t*expr_p = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t  convert (build_pointer_type (type),\n+\t\t\t\t\t   integer_zero_node));\n+\n+      /* Otherwise, just make a VAR_DECL.  */\n+      else\n+\t{\n+\t  *expr_p = create_tmp_var (type, NULL);\n+\t   suppress_warning (*expr_p);\n+\t}\n \n-      return GS_UNHANDLED;\n+      gimplify_and_add (TREE_OPERAND (expr, 0), pre_p);\n+      return GS_OK;\n+\n+    case UNCONSTRAINED_ARRAY_REF:\n+      /* We should only do this if we are just elaborating for side effects,\n+\t but we can't know that yet.  */\n+      *expr_p = TREE_OPERAND (*expr_p, 0);\n+      return GS_OK;\n \n     case VIEW_CONVERT_EXPR:\n       op = TREE_OPERAND (expr, 0);\n@@ -8742,53 +8771,13 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  return GS_OK;\n \t}\n-\n-      return GS_UNHANDLED;\n-\n-    case DECL_EXPR:\n-      op = DECL_EXPR_DECL (expr);\n-\n-      /* The expressions for the RM bounds must be gimplified to ensure that\n-\t they are properly elaborated.  See gimplify_decl_expr.  */\n-      if ((TREE_CODE (op) == TYPE_DECL || TREE_CODE (op) == VAR_DECL)\n-\t  && !TYPE_SIZES_GIMPLIFIED (TREE_TYPE (op)))\n-\tswitch (TREE_CODE (TREE_TYPE (op)))\n-\t  {\n-\t  case INTEGER_TYPE:\n-\t  case ENUMERAL_TYPE:\n-\t  case BOOLEAN_TYPE:\n-\t  case REAL_TYPE:\n-\t    {\n-\t      tree type = TYPE_MAIN_VARIANT (TREE_TYPE (op)), t, val;\n-\n-\t      val = TYPE_RM_MIN_VALUE (type);\n-\t      if (val)\n-\t\t{\n-\t\t  gimplify_one_sizepos (&val, pre_p);\n-\t\t  for (t = type; t; t = TYPE_NEXT_VARIANT (t))\n-\t\t    SET_TYPE_RM_MIN_VALUE (t, val);\n-\t\t}\n-\n-\t      val = TYPE_RM_MAX_VALUE (type);\n-\t      if (val)\n-\t\t{\n-\t\t  gimplify_one_sizepos (&val, pre_p);\n-\t\t  for (t = type; t; t = TYPE_NEXT_VARIANT (t))\n-\t\t    SET_TYPE_RM_MAX_VALUE (t, val);\n-\t\t}\n-\n-\t    }\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      /* ... fall through ... */\n+      break;\n \n     default:\n-      return GS_UNHANDLED;\n+      break;\n     }\n+\n+  return GS_UNHANDLED;\n }\n \n /* Generate GIMPLE in place for the statement at *STMT_P.  */"}]}