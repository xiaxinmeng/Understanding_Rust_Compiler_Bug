{"sha": "b7fe373bfb4dbbde0178914b2218862f7677b69d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmZTM3M2JmYjRkYmJkZTAxNzg5MTRiMjIxODg2MmY3Njc3YjY5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-29T18:46:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-29T18:46:38Z"}, "message": "loop.c (prescan_loop): Set has_multiple_exit_targets for exception edges.\n\n        * loop.c (prescan_loop): Set has_multiple_exit_targets for exception\n        edges.  Rearrange jump interpretation code to use pc_set.\n        (check_dbra_loop): Examine has_multiple_exit_targets not exit_count.\n\n        * sched-deps.c (sched_analyze_insn): Set scheduling barrier for\n        all insns that can throw, not just if flag_non_call_exceptions.\n\nFrom-SVN: r48377", "tree": {"sha": "35b7bc875a47a23ed39a2fd5552bbadc94584ca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b7bc875a47a23ed39a2fd5552bbadc94584ca1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7fe373bfb4dbbde0178914b2218862f7677b69d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fe373bfb4dbbde0178914b2218862f7677b69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7fe373bfb4dbbde0178914b2218862f7677b69d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fe373bfb4dbbde0178914b2218862f7677b69d/comments", "author": null, "committer": null, "parents": [{"sha": "4e5ea414df790f3de4acff45cd2fc8be4d5e3fff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e5ea414df790f3de4acff45cd2fc8be4d5e3fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e5ea414df790f3de4acff45cd2fc8be4d5e3fff"}], "stats": {"total": 138, "additions": 82, "deletions": 56}, "files": [{"sha": "07a78e47ec255726114e7ee09254454508eef51d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7fe373bfb4dbbde0178914b2218862f7677b69d", "patch": "@@ -1,3 +1,12 @@\n+2001-12-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* loop.c (prescan_loop): Set has_multiple_exit_targets for exception\n+\tedges.  Rearrange jump interpretation code to use pc_set.\n+\t(check_dbra_loop): Examine has_multiple_exit_targets not exit_count.\n+\n+\t* sched-deps.c (sched_analyze_insn): Set scheduling barrier for\n+\tall insns that can throw, not just if flag_non_call_exceptions.\n+\n 2001-12-29  Stan Shebs  <shebs@apple.com>\n \n \t* objc/objc-act.c (STRING_OBJECT_CLASS_NAME): Remove."}, {"sha": "2069588aed604098e2803abde68cf9d306de3dfe", "filename": "gcc/loop.c", "status": "modified", "additions": 72, "deletions": 55, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b7fe373bfb4dbbde0178914b2218862f7677b69d", "patch": "@@ -2450,33 +2450,83 @@ prescan_loop (loop)\n   for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n+      switch (GET_CODE (insn))\n \t{\n+\tcase NOTE:\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t    {\n \t      ++level;\n \t      /* Count number of loops contained in this one.  */\n \t      loop->level++;\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    {\n-\t      --level;\n-\t    }\n-\t}\n-      else if (GET_CODE (insn) == CALL_INSN)\n-\t{\n+\t    --level;\n+\t  break;\n+\n+\tcase CALL_INSN:\n \t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    {\n \t      loop_info->unknown_address_altered = 1;\n \t      loop_info->has_nonconst_call = 1;\n \t    }\n \t  loop_info->has_call = 1;\n-\t}\n-      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  rtx label1 = NULL_RTX;\n-\t  rtx label2 = NULL_RTX;\n+\t  if (can_throw_internal (insn))\n+\t    loop_info->has_multiple_exit_targets = 1;\n+\t  break;\n+\n+\tcase JUMP_INSN:\n+\t  if (! loop_info->has_multiple_exit_targets)\n+\t    {\n+\t      rtx set = pc_set (insn);\n+\n+\t      if (set)\n+\t\t{\n+\t\t  rtx label1, label2;\n+\n+\t\t  if (GET_CODE (SET_SRC (set)) == IF_THEN_ELSE)\n+\t\t    {\n+\t\t      label1 = XEXP (SET_SRC (set), 1);\n+\t\t      label2 = XEXP (SET_SRC (set), 2);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      label1 = SET_SRC (PATTERN (insn));\n+\t\t      label2 = NULL_RTX;\n+\t\t    }\n+\n+\t\t  do\n+\t\t    {\n+\t\t      if (label1 && label1 != pc_rtx)\n+\t\t\t{\n+\t\t\t  if (GET_CODE (label1) != LABEL_REF)\n+\t\t\t    {\n+\t\t\t      /* Something tricky.  */\n+\t\t\t      loop_info->has_multiple_exit_targets = 1;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t  else if (XEXP (label1, 0) != exit_target\n+\t\t\t\t   && LABEL_OUTSIDE_LOOP_P (label1))\n+\t\t\t    {\n+\t\t\t      /* A jump outside the current loop.  */\n+\t\t\t      loop_info->has_multiple_exit_targets = 1;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      label1 = label2;\n+\t\t      label2 = NULL_RTX;\n+\t\t    }\n+\t\t  while (label1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* A return, or something tricky.  */\n+\t\t  loop_info->has_multiple_exit_targets = 1;\n+\t\t}\n+\t    }\n+\t  /* FALLTHRU */\n \n+\tcase INSN:\n \t  if (volatile_refs_p (PATTERN (insn)))\n \t    loop_info->has_volatile = 1;\n \n@@ -2489,48 +2539,13 @@ prescan_loop (loop)\n \t  if (! loop_info->first_loop_store_insn && loop_info->store_mems)\n \t    loop_info->first_loop_store_insn = insn;\n \n-\t  if (! loop_info->has_multiple_exit_targets\n-\t      && GET_CODE (insn) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n-\t    {\n-\t      if (GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-\t\t{\n-\t\t  label1 = XEXP (SET_SRC (PATTERN (insn)), 1);\n-\t\t  label2 = XEXP (SET_SRC (PATTERN (insn)), 2);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  label1 = SET_SRC (PATTERN (insn));\n-\t\t}\n-\n-\t      do\n-\t\t{\n-\t\t  if (label1 && label1 != pc_rtx)\n-\t\t    {\n-\t\t      if (GET_CODE (label1) != LABEL_REF)\n-\t\t\t{\n-\t\t\t  /* Something tricky.  */\n-\t\t\t  loop_info->has_multiple_exit_targets = 1;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else if (XEXP (label1, 0) != exit_target\n-\t\t\t       && LABEL_OUTSIDE_LOOP_P (label1))\n-\t\t\t{\n-\t\t\t  /* A jump outside the current loop.  */\n-\t\t\t  loop_info->has_multiple_exit_targets = 1;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n+\t  if (flag_non_call_exceptions && can_throw_internal (insn))\n+\t    loop_info->has_multiple_exit_targets = 1;\n+\t  break;\n \n-\t\t  label1 = label2;\n-\t\t  label2 = NULL_RTX;\n-\t\t}\n-\t      while (label1);\n-\t    }\n+\tdefault:\n+\t  break;\n \t}\n-      else if (GET_CODE (insn) == RETURN)\n-\tloop_info->has_multiple_exit_targets = 1;\n     }\n \n   /* Now, rescan the loop, setting up the LOOP_MEMS array.  */\n@@ -7962,7 +7977,7 @@ check_dbra_loop (loop, insn_count)\n \t which is reversible.  */\n       int reversible_mem_store = 1;\n \n-      if (bl->giv_count == 0 && ! loop->exit_count)\n+      if (bl->giv_count == 0 && ! loop_info->has_multiple_exit_targets)\n \t{\n \t  rtx bivreg = regno_reg_rtx[bl->regno];\n \t  struct iv_class *blt;\n@@ -8003,9 +8018,11 @@ check_dbra_loop (loop, insn_count)\n \t\t  }\n \t      }\n \n-\t  /* A biv has uses besides counting if it is used to set another biv.  */\n+\t  /* A biv has uses besides counting if it is used to set\n+\t     another biv.  */\n \t  for (blt = ivs->list; blt; blt = blt->next)\n-\t    if (blt->init_set && reg_mentioned_p (bivreg, SET_SRC (blt->init_set)))\n+\t    if (blt->init_set\n+\t\t&& reg_mentioned_p (bivreg, SET_SRC (blt->init_set)))\n \t      {\n \t\tno_use_except_counting = 0;\n \t\tbreak;"}, {"sha": "e315a4c22472001554cb85879b8894c446ad0521", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fe373bfb4dbbde0178914b2218862f7677b69d/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b7fe373bfb4dbbde0178914b2218862f7677b69d", "patch": "@@ -1141,7 +1141,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n   /* If this instruction can throw an exception, then moving it changes\n      where block boundaries fall.  This is mighty confusing elsewhere. \n      Therefore, prevent such an instruction from being moved.  */\n-  if (flag_non_call_exceptions && can_throw_internal (insn))\n+  if (can_throw_internal (insn))\n     schedule_barrier_found = 1;\n \n   /* Add dependencies if a scheduling barrier was found.  */"}]}