{"sha": "3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IwZGRhZGY3NGVjOWM3YWE0MDQ3NjVlYzUwYmI1NWQyNTVkYmVjNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-22T14:44:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-22T14:44:30Z"}, "message": "runtime: change some stack fields to uintptr\n    \n    Because of how gccgo implements cgo calls, the code in dropm may not\n    have any write barriers.  As a step toward implementing that, change\n    the gcstack, gcnextsegment, and gcnextsp fields of the g struct to\n    uintptr, so that assignments to them do not require write barriers.\n    The gcinitialsp field remains unsafe.Pointer, as on 32-bit systems\n    that do not support split stack it points to a heap allocated space\n    used for the goroutine stack.\n    \n    The test for this is runtime tests like TestCgoCallbackGC, which are\n    not run today but will be run with a future gotools patch.\n    \n    Reviewed-on: https://go-review.googlesource.com/46396\n\nFrom-SVN: r249561", "tree": {"sha": "0c76bd6000837d9b83d3a57a300d41d87eaf3fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c76bd6000837d9b83d3a57a300d41d87eaf3fb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/comments", "author": null, "committer": null, "parents": [{"sha": "a055692a25c10bcd8fd90825cc39709f455335b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a055692a25c10bcd8fd90825cc39709f455335b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a055692a25c10bcd8fd90825cc39709f455335b2"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "942752b10205c50d28bc72b0a9b681b6182e640b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "patch": "@@ -1,4 +1,4 @@\n-73b14da15ec731837ce2a45db658142bfbf5fe22\n+b5c9fe259ec43f8079581c3bea0f1d12d85213a7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "066d0e52de6ee411e58eb61b44fc32352546f713", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "patch": "@@ -1460,8 +1460,8 @@ func dropm() {\n \t// gccgo sets the stack to Gdead here, because the splitstack\n \t// context is not initialized.\n \tatomic.Store(&mp.curg.atomicstatus, _Gdead)\n-\tmp.curg.gcstack = nil\n-\tmp.curg.gcnextsp = nil\n+\tmp.curg.gcstack = 0\n+\tmp.curg.gcnextsp = 0\n \n \tmnext := lockextra(true)\n \tmp.schedlink.set(mnext)\n@@ -2591,8 +2591,8 @@ func exitsyscallclear(gp *g) {\n \t// clear syscallsp.\n \tgp.syscallsp = 0\n \n-\tgp.gcstack = nil\n-\tgp.gcnextsp = nil\n+\tgp.gcstack = 0\n+\tgp.gcnextsp = 0\n \tmemclrNoHeapPointers(unsafe.Pointer(&gp.gcregs), unsafe.Sizeof(gp.gcregs))\n }\n "}, {"sha": "96a4edb83d4445b57ebd2ffdd045d03009ed50fd", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "patch": "@@ -402,10 +402,10 @@ type g struct {\n \tisforeign bool           // whether current exception is not from Go\n \n \t// Fields that hold stack and context information if status is Gsyscall\n-\tgcstack       unsafe.Pointer\n+\tgcstack       uintptr\n \tgcstacksize   uintptr\n-\tgcnextsegment unsafe.Pointer\n-\tgcnextsp      unsafe.Pointer\n+\tgcnextsegment uintptr\n+\tgcnextsp      uintptr\n \tgcinitialsp   unsafe.Pointer\n \tgcregs        g_ucontext_t\n "}, {"sha": "303a1b580b354069e0e5c38ff1917984f183afbe", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "patch": "@@ -316,7 +316,7 @@ runtime_mcall(FuncVal *fv)\n #else\n \t\t// We have to point to an address on the stack that is\n \t\t// below the saved registers.\n-\t\tgp->gcnextsp = &afterregs;\n+\t\tgp->gcnextsp = (uintptr)(&afterregs);\n #endif\n \t\tgp->fromgogo = false;\n \t\tgetcontext(ucontext_arg(&gp->context[0]));\n@@ -489,7 +489,7 @@ runtime_mstart(void *arg)\n \t// Setting gcstacksize to 0 is a marker meaning that gcinitialsp\n \t// is the top of the stack, not the bottom.\n \tgp->gcstacksize = 0;\n-\tgp->gcnextsp = &arg;\n+\tgp->gcnextsp = (uintptr)(&arg);\n #endif\n \n \t// Save the currently active context.  This will return\n@@ -558,9 +558,9 @@ setGContext()\n \t__splitstack_block_signals(&val, nil);\n #else\n \tgp->gcinitialsp = &val;\n-\tgp->gcstack = nil;\n+\tgp->gcstack = 0;\n \tgp->gcstacksize = 0;\n-\tgp->gcnextsp = &val;\n+\tgp->gcnextsp = (uintptr)(&val);\n #endif\n \tgetcontext(ucontext_arg(&gp->context[0]));\n \n@@ -628,16 +628,17 @@ doentersyscall(uintptr pc, uintptr sp)\n #ifdef USING_SPLIT_STACK\n \t{\n \t  size_t gcstacksize;\n-\t  g->gcstack = __splitstack_find(nil, nil, &gcstacksize,\n-\t\t\t\t\t &g->gcnextsegment, &g->gcnextsp,\n-\t\t\t\t\t &g->gcinitialsp);\n+\t  g->gcstack = (uintptr)(__splitstack_find(nil, nil, &gcstacksize,\n+\t\t\t\t\t\t   (void**)(&g->gcnextsegment),\n+\t\t\t\t\t\t   (void**)(&g->gcnextsp),\n+\t\t\t\t\t\t   &g->gcinitialsp));\n \t  g->gcstacksize = (uintptr)gcstacksize;\n \t}\n #else\n \t{\n \t\tvoid *v;\n \n-\t\tg->gcnextsp = (byte *) &v;\n+\t\tg->gcnextsp = (uintptr)(&v);\n \t}\n #endif\n \n@@ -667,9 +668,10 @@ doentersyscallblock(uintptr pc, uintptr sp)\n #ifdef USING_SPLIT_STACK\n \t{\n \t  size_t gcstacksize;\n-\t  g->gcstack = __splitstack_find(nil, nil, &gcstacksize,\n-\t\t\t\t\t &g->gcnextsegment, &g->gcnextsp,\n-\t\t\t\t\t &g->gcinitialsp);\n+\t  g->gcstack = (uintptr)(__splitstack_find(nil, nil, &gcstacksize,\n+\t\t\t\t\t\t   (void**)(&g->gcnextsegment),\n+\t\t\t\t\t\t   (void**)(&g->gcnextsp),\n+\t\t\t\t\t\t   &g->gcinitialsp));\n \t  g->gcstacksize = (uintptr)gcstacksize;\n \t}\n #else\n@@ -765,7 +767,7 @@ resetNewG(G *newg, void **sp, uintptr *spsize)\n   *spsize = newg->gcstacksize;\n   if(*spsize == 0)\n     runtime_throw(\"bad spsize in resetNewG\");\n-  newg->gcnextsp = *sp;\n+  newg->gcnextsp = (uintptr)(*sp);\n #endif\n }\n "}, {"sha": "900ca64b7f7d3f8b99faea92b3446c79b56ae2fc", "filename": "libgo/runtime/stack.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fruntime%2Fstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b0ddadf74ec9c7aa404765ec50bb55d255dbec7/libgo%2Fruntime%2Fstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstack.c?ref=3b0ddadf74ec9c7aa404765ec50bb55d255dbec7", "patch": "@@ -60,12 +60,12 @@ static void doscanstack1(G *gp, void *gcw) {\n \t\t// as schedlock and may have needed to start a new stack segment.\n \t\t// Use the stack segment and stack pointer at the time of\n \t\t// the system call instead, since that won't change underfoot.\n-\t\tif(gp->gcstack != nil) {\n-\t\t\tsp = gp->gcstack;\n+\t\tif(gp->gcstack != 0) {\n+\t\t\tsp = (void*)(gp->gcstack);\n \t\t\tspsize = gp->gcstacksize;\n-\t\t\tnext_segment = gp->gcnextsegment;\n-\t\t\tnext_sp = gp->gcnextsp;\n-\t\t\tinitial_sp = gp->gcinitialsp;\n+\t\t\tnext_segment = (void*)(gp->gcnextsegment);\n+\t\t\tnext_sp = (void*)(gp->gcnextsp);\n+\t\t\tinitial_sp = (void*)(gp->gcinitialsp);\n \t\t} else {\n \t\t\tsp = __splitstack_find_context((void**)(&gp->stackcontext[0]),\n \t\t\t\t\t\t       &spsize, &next_segment,\n@@ -89,11 +89,11 @@ static void doscanstack1(G *gp, void *gcw) {\n \t} else {\n \t\t// Scanning another goroutine's stack.\n \t\t// The goroutine is usually asleep (the world is stopped).\n-\t\tbottom = (byte*)gp->gcnextsp;\n+\t\tbottom = (void*)gp->gcnextsp;\n \t\tif(bottom == nil)\n \t\t\treturn;\n \t}\n-\ttop = (byte*)gp->gcinitialsp + gp->gcstacksize;\n+\ttop = (byte*)(void*)(gp->gcinitialsp) + gp->gcstacksize;\n \tif(top > bottom)\n \t\tscanstackblock(bottom, (uintptr)(top - bottom), gcw);\n \telse"}]}