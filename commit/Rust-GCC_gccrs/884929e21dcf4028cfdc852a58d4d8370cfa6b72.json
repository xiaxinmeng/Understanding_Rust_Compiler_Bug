{"sha": "884929e21dcf4028cfdc852a58d4d8370cfa6b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg0OTI5ZTIxZGNmNDAyOGNmZGM4NTJhNThkNGQ4MzcwY2ZhNmI3Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-08-01T20:20:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-08-01T20:20:12Z"}, "message": "mangle.c (get_abi_tags): New.\n\n\t* mangle.c (get_abi_tags): New.\n\n\t(find_substitution, write_unqualified_name, write_abi_tags)\n\t(maybe_check_abi_tags): Use it.\n\nFrom-SVN: r238965", "tree": {"sha": "fd150ea54854f5f1f2f65351f5cd5804174ac6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd150ea54854f5f1f2f65351f5cd5804174ac6a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/884929e21dcf4028cfdc852a58d4d8370cfa6b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884929e21dcf4028cfdc852a58d4d8370cfa6b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884929e21dcf4028cfdc852a58d4d8370cfa6b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884929e21dcf4028cfdc852a58d4d8370cfa6b72/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "352b8babea0ef7d9995f1cb54a482cedca08987f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/352b8babea0ef7d9995f1cb54a482cedca08987f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/352b8babea0ef7d9995f1cb54a482cedca08987f"}], "stats": {"total": 51, "additions": 34, "deletions": 17}, "files": [{"sha": "9d46aaaa5de430d6ca3cf33c1e6219e13b6ced56", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884929e21dcf4028cfdc852a58d4d8370cfa6b72/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884929e21dcf4028cfdc852a58d4d8370cfa6b72/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=884929e21dcf4028cfdc852a58d4d8370cfa6b72", "patch": "@@ -1,5 +1,9 @@\n 2016-08-01  Jason Merrill  <jason@redhat.com>\n \n+\t* mangle.c (get_abi_tags): New.\n+\t(find_substitution, write_unqualified_name, write_abi_tags)\n+\t(maybe_check_abi_tags): Use it.\n+\n \t* mangle.c (mangle_decl): Fix mangled name change warning.\n \n \tPR c++/72766"}, {"sha": "29be7fde4982fa9f13b3e0e5d1ec327161a74f13", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884929e21dcf4028cfdc852a58d4d8370cfa6b72/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884929e21dcf4028cfdc852a58d4d8370cfa6b72/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=884929e21dcf4028cfdc852a58d4d8370cfa6b72", "patch": "@@ -447,6 +447,30 @@ is_std_substitution (const tree node,\n \t      == subst_identifiers[index]));\n }\n \n+/* Return the ABI tags (the TREE_VALUE of the \"abi_tag\" attribute entry) for T,\n+   which can be a decl or type.  */\n+\n+static tree\n+get_abi_tags (tree t)\n+{\n+  if (!t || TREE_CODE (t) == NAMESPACE_DECL)\n+    return NULL_TREE;\n+\n+  if (DECL_P (t) && DECL_DECLARES_TYPE_P (t))\n+    t = TREE_TYPE (t);\n+\n+  tree attrs;\n+  if (TYPE_P (t))\n+    attrs = TYPE_ATTRIBUTES (t);\n+  else\n+    attrs = DECL_ATTRIBUTES (t);\n+\n+  tree tags = lookup_attribute (\"abi_tag\", attrs);\n+  if (tags)\n+    tags = TREE_VALUE (tags);\n+  return tags;\n+}\n+\n /* Helper function for find_substitution.  Returns nonzero if NODE,\n    which may be a decl or a CLASS_TYPE, is the template-id\n    ::std::identifier<char>, where identifier is\n@@ -601,7 +625,7 @@ find_substitution (tree node)\n \n   tree tags = NULL_TREE;\n   if (OVERLOAD_TYPE_P (node) || DECL_CLASS_TEMPLATE_P (node))\n-    tags = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (type));\n+    tags = get_abi_tags (type);\n   /* Now check the list of available substitutions for this mangling\n      operation.  */\n   if (!abbr || tags) for (i = 0; i < size; ++i)\n@@ -667,7 +691,7 @@ unmangled_name_p (const tree decl)\n \treturn false;\n \n       /* Declarations with ABI tags are mangled.  */\n-      if (lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (decl)))\n+      if (get_abi_tags (decl))\n \treturn false;\n \n       /* The names of non-static global variables aren't mangled.  */\n@@ -1314,12 +1338,7 @@ write_unqualified_name (tree decl)\n     decl = DECL_TEMPLATE_RESULT (tmpl);\n   /* Don't crash on an unbound class template.  */\n   if (decl && TREE_CODE (decl) != NAMESPACE_DECL)\n-    {\n-      tree attrs = (TREE_CODE (decl) == TYPE_DECL\n-\t\t    ? TYPE_ATTRIBUTES (TREE_TYPE (decl))\n-\t\t    : DECL_ATTRIBUTES (decl));\n-      write_abi_tags (lookup_attribute (\"abi_tag\", attrs));\n-    }\n+    write_abi_tags (get_abi_tags (decl));\n }\n \n /* Write the unqualified-name for a conversion operator to TYPE.  */\n@@ -1371,8 +1390,6 @@ write_abi_tags (tree tags)\n   if (tags == NULL_TREE)\n     return;\n \n-  tags = TREE_VALUE (tags);\n-\n   vec<tree, va_gc> * vec = make_tree_vector();\n \n   for (tree t = tags; t; t = TREE_CHAIN (t))\n@@ -4027,16 +4044,12 @@ maybe_check_abi_tags (tree t, tree for_decl)\n   if (DECL_ASSEMBLER_NAME_SET_P (t))\n     return;\n \n-  tree attr = lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (t));\n-  tree oldtags = NULL_TREE;\n-  if (attr)\n-    oldtags = TREE_VALUE (attr);\n+  tree oldtags = get_abi_tags (t);\n \n   mangle_decl (t);\n \n-  if (!attr)\n-    attr = lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (t));\n-  if (attr && TREE_VALUE (attr) != oldtags\n+  tree newtags = get_abi_tags (t);\n+  if (newtags && newtags != oldtags\n       && abi_version_crosses (10))\n     {\n       if (for_decl)"}]}