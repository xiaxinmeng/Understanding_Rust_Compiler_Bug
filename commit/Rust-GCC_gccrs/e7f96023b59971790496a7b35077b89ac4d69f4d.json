{"sha": "e7f96023b59971790496a7b35077b89ac4d69f4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmOTYwMjNiNTk5NzE3OTA0OTZhN2IzNTA3N2I4OWFjNGQ2OWY0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-07T16:17:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-07T16:17:55Z"}, "message": "df-problems.c (df_lr_problem_data): Add lr_bitmaps.\n\n\n\t* df-problems.c (df_lr_problem_data): Add lr_bitmaps.\n\t(df_lr_alloc): Initialize problem data; move bitmaps to\n\tlr_bitmaps obstack.\n\t(df_lr_finalize): Free problem data; do not bother to free bitmaps.\n\t(df_lr_verify_solution_start): Do not initialize problem data;\n\tallocate bitmaps in lr_bitmaps.\n\t(df_lr_verify_solution_end): Do not free problem data.\n\nFrom-SVN: r160382", "tree": {"sha": "f6d06e89b9855d2b736bed2e4aee5025c8eb7fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d06e89b9855d2b736bed2e4aee5025c8eb7fb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f96023b59971790496a7b35077b89ac4d69f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f96023b59971790496a7b35077b89ac4d69f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f96023b59971790496a7b35077b89ac4d69f4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f96023b59971790496a7b35077b89ac4d69f4d/comments", "author": null, "committer": null, "parents": [{"sha": "4c2332c73b55fed5ab89b80ca314fb410be01c3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2332c73b55fed5ab89b80ca314fb410be01c3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2332c73b55fed5ab89b80ca314fb410be01c3f"}], "stats": {"total": 79, "additions": 46, "deletions": 33}, "files": [{"sha": "3c9819e79bae769dfb9b65759c7201b49d7bb85f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f96023b59971790496a7b35077b89ac4d69f4d", "patch": "@@ -1,3 +1,13 @@\n+2010-06-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-problems.c (df_lr_problem_data): Add lr_bitmaps.\n+\t(df_lr_alloc): Initialize problem data; move bitmaps to\n+\tlr_bitmaps obstack.\n+\t(df_lr_finalize): Free problem data; do not bother to free bitmaps.\n+\t(df_lr_verify_solution_start): Do not initialize problem data;\n+\tallocate bitmaps in lr_bitmaps.\n+\t(df_lr_verify_solution_end): Do not free problem data.\n+\n 2010-06-07  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_edge_cannot_lead_to_return): Also check"}, {"sha": "6c9f5c927e950d44166be07dbbd08ae431d9aac9", "filename": "gcc/df-core.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=e7f96023b59971790496a7b35077b89ac4d69f4d", "patch": "@@ -1084,15 +1084,15 @@ df_analyze_problem (struct dataflow *dflow,\n {\n   timevar_push (dflow->problem->tv_id);\n \n+  /* (Re)Allocate the datastructures necessary to solve the problem.  */\n+  if (dflow->problem->alloc_fun)\n+    dflow->problem->alloc_fun (blocks_to_consider);\n+\n #ifdef ENABLE_DF_CHECKING\n   if (dflow->problem->verify_start_fun)\n     dflow->problem->verify_start_fun ();\n #endif\n \n-  /* (Re)Allocate the datastructures necessary to solve the problem.  */\n-  if (dflow->problem->alloc_fun)\n-    dflow->problem->alloc_fun (blocks_to_consider);\n-\n   /* Set up the problem and compute the local information.  */\n   if (dflow->problem->local_compute_fun)\n     dflow->problem->local_compute_fun (blocks_to_consider);"}, {"sha": "f11b2518079a3047463d5029e07e7064d283828e", "filename": "gcc/df-problems.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f96023b59971790496a7b35077b89ac4d69f4d/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=e7f96023b59971790496a7b35077b89ac4d69f4d", "patch": "@@ -734,6 +734,8 @@ struct df_lr_problem_data\n {\n   bitmap_head *in;\n   bitmap_head *out;\n+  /* An obstack for the bitmaps we need for this problem.  */\n+  bitmap_obstack lr_bitmaps;\n };\n \n \n@@ -775,12 +777,24 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n+  struct df_lr_problem_data *problem_data;\n \n   if (!df_lr->block_pool)\n     df_lr->block_pool = create_alloc_pool (\"df_lr_block pool\",\n \t\t\t\t\t   sizeof (struct df_lr_bb_info), 50);\n \n   df_grow_bb_info (df_lr);\n+  if (df_lr->problem_data)\n+    problem_data = (struct df_lr_problem_data *) df_lr->problem_data;\n+  else\n+    {\n+      problem_data = XNEW (struct df_lr_problem_data);\n+      df_lr->problem_data = problem_data;\n+\n+      problem_data->out = NULL;\n+      problem_data->in = NULL;\n+      bitmap_obstack_initialize (&problem_data->lr_bitmaps);\n+    }\n \n   EXECUTE_IF_SET_IN_BITMAP (df_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n@@ -794,10 +808,10 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t{\n \t  bb_info = (struct df_lr_bb_info *) pool_alloc (df_lr->block_pool);\n \t  df_lr_set_bb_info (bb_index, bb_info);\n-\t  bitmap_initialize (&bb_info->use, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->def, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->in, &bitmap_default_obstack);\n-\t  bitmap_initialize (&bb_info->out, &bitmap_default_obstack);\n+\t  bitmap_initialize (&bb_info->use, &problem_data->lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->def, &problem_data->lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->lr_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->lr_bitmaps);\n \t}\n     }\n \n@@ -1073,24 +1087,17 @@ df_lr_finalize (bitmap all_blocks)\n static void\n df_lr_free (void)\n {\n+  struct df_lr_problem_data *problem_data\n+    = (struct df_lr_problem_data *) df_lr->problem_data;\n   if (df_lr->block_info)\n     {\n-      unsigned int i;\n-      for (i = 0; i < df_lr->block_info_size; i++)\n-\t{\n-\t  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (i);\n-\t  if (bb_info)\n-\t    {\n-\t      bitmap_clear (&bb_info->use);\n-\t      bitmap_clear (&bb_info->def);\n-\t      bitmap_clear (&bb_info->in);\n-\t      bitmap_clear (&bb_info->out);\n-\t    }\n-\t}\n       free_alloc_pool (df_lr->block_pool);\n \n       df_lr->block_info_size = 0;\n       free (df_lr->block_info);\n+      bitmap_obstack_release (&problem_data->lr_bitmaps);\n+      free (df_lr->problem_data);\n+      df_lr->problem_data = NULL;\n     }\n \n   BITMAP_FREE (df_lr->out_of_date_transfer_functions);\n@@ -1153,23 +1160,19 @@ df_lr_verify_solution_start (void)\n   basic_block bb;\n   struct df_lr_problem_data *problem_data;\n   if (df_lr->solutions_dirty)\n-    {\n-      df_lr->problem_data = NULL;\n-      return;\n-    }\n+    return;\n \n   /* Set it true so that the solution is recomputed.  */\n   df_lr->solutions_dirty = true;\n \n-  problem_data = XNEW (struct df_lr_problem_data);\n-  df_lr->problem_data = problem_data;\n+  problem_data = (struct df_lr_problem_data *)df_lr->problem_data;\n   problem_data->in = XNEWVEC (bitmap_head, last_basic_block);\n   problem_data->out = XNEWVEC (bitmap_head, last_basic_block);\n \n   FOR_ALL_BB (bb)\n     {\n-      bitmap_initialize (&problem_data->in[bb->index], &bitmap_default_obstack);\n-      bitmap_initialize (&problem_data->out[bb->index], &bitmap_default_obstack);\n+      bitmap_initialize (&problem_data->in[bb->index], &problem_data->lr_bitmaps);\n+      bitmap_initialize (&problem_data->out[bb->index], &problem_data->lr_bitmaps);\n       bitmap_copy (&problem_data->in[bb->index], DF_LR_IN (bb));\n       bitmap_copy (&problem_data->out[bb->index], DF_LR_OUT (bb));\n     }\n@@ -1185,11 +1188,11 @@ df_lr_verify_solution_end (void)\n   struct df_lr_problem_data *problem_data;\n   basic_block bb;\n \n-  if (df_lr->problem_data == NULL)\n-    return;\n-\n   problem_data = (struct df_lr_problem_data *)df_lr->problem_data;\n \n+  if (!problem_data->out)\n+    return;\n+\n   if (df_lr->solutions_dirty)\n     /* Do not check if the solution is still dirty.  See the comment\n        in df_lr_finalize for details.  */\n@@ -1215,8 +1218,8 @@ df_lr_verify_solution_end (void)\n \n   free (problem_data->in);\n   free (problem_data->out);\n-  free (problem_data);\n-  df_lr->problem_data = NULL;\n+  problem_data->in = NULL;\n+  problem_data->out = NULL;\n }\n \n "}]}