{"sha": "df3781485406ededf60d901bbcbbcbeeaf0529b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYzNzgxNDg1NDA2ZWRlZGY2MGQ5MDFiYmNiYmNiZWVhZjA1MjliOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-14T10:56:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-14T10:56:22Z"}, "message": "[multiple changes]\n\n2012-06-14  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Expand_Put_Call_With_Dimension_Symbol\n\tcall replaced by Expand_Put_Call_With_Symbol call.\n\t* sem_dim.adb: New fields Unit_Names, Unit_Symbols\n\tand Dim_Symbols for record type System_Type.\n\t(From_Dimension_To_String_Of_Symbols): Removed.\n\t(From_Dim_To_Str_Of_Dim_Symbols): Renames previous\n\troutine From_Dimension_To_String_Of_Symbols.\n\t(From_Dim_To_Str_Of_Unit_Symbols): New routine.\n\t(Analyze_Aspect_Dimension): argument Symbol in aspect\n\tDimension aggregate is optional. Named association implemented.\n\t(Has_Compile_Time_Known_Expressions): Removed.\n\t(Analyze_Aspect_Dimension_System): New\n\tcomponent Dim_Symbol in each Dimension aggregate in\n\taspect Dimension_System. Named associations implemented.\n\t(Add_Dimension_Vector_To_Buffer): Removed.\n\t(Add_Whole_To_Buffer): Removed.\n\t(Expand_Put_Call_With_Dimension_Symbol.): Removed.\n\t(Expand_Put_Call_With_Symbol): Renames previous routine\n\tExpand_Put_Call_With_Dimension_Symbol.\n\t(Has_Dimension_Symbols): Removed.\n\t(Has_Symbols): Renames previous routine\n\tHas_Dimension_Symbols.\t(Store_String_Oexpon): New routine.\n\t* sem_dim.ads (Expand_Put_Call_With_Dimension_Symbol.): Removed.\n\t(Expand_Put_Call_With_Symbol): Renames previous routine\n\tExpand_Put_Call_With_Dimension_Symbol.\n\t* s-diflio.adb, s-diinio.adb (Put): Symbol renames Symbols.\n\t(Put_Dim_Of): New routines.\n\t* s-diflio.ads, s-diinio.ads: documentation updated.\n\t(Put): Symbol renames Symbols.\n\t(Put_Dim_Of): New routines.\n\t* s-dim.ads: documentation updated.\n\t* s-dimmks.ads: dimensioned type and subtypes updated.\n\t* snames.ads-tmpl: Name_Dim_Symbol, Name_Put_Dim_Of, Name_Symbol,\n\tand Name_Unit_Symbol added. Name_Symbols removed.\n\n2012-06-14  Vincent Pucci  <pucci@adacore.com>\n\n\t* freeze.adb (In_Exp_Body): Expression function case added.\n\t(Freeze_Expression): Insert the Freeze_Nodes\n\tlist before the correct current scope in case of a quantified\n\texpression.\n\n2012-06-14  Pascal Obry  <obry@adacore.com>\n\n\t* projects.texi: Document the Install package for gprinstall.\n2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elim.adb (Check_For_Eliminated_Subprogram): Do not check within\n\ta default expression.\n\t* sem_res.adb (Resolve_Call): simplify code.\n\n2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_case.adb (Check, Issue_Msg): within an instance, non-other\n\tvalues in a variant part or a case expression do not have to\n\tbelong to the actual subtype.\n\n2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Validate_Derived_Type_Instance): If parent is\n\tan interface type, check whether it is itself a previous formal\n\talready instantiated in the current list of actuals.\n\n2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): The\n\texpression for a stream attribute is a name that may be overloaded\n\twith other declarations. To determine whether it matches the\n\taspect at the freeze point, it is necessary to verify that one\n\tof its interpretations matches.\n\nFrom-SVN: r188610", "tree": {"sha": "4fcf9aeac898e8c5349c2120203d8e8760d546a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fcf9aeac898e8c5349c2120203d8e8760d546a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df3781485406ededf60d901bbcbbcbeeaf0529b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3781485406ededf60d901bbcbbcbeeaf0529b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3781485406ededf60d901bbcbbcbeeaf0529b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3781485406ededf60d901bbcbbcbeeaf0529b9/comments", "author": null, "committer": null, "parents": [{"sha": "2a290fec3d61859b69f865d1769f4e11ac1c3dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a290fec3d61859b69f865d1769f4e11ac1c3dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a290fec3d61859b69f865d1769f4e11ac1c3dc8"}], "stats": {"total": 1641, "additions": 1115, "deletions": 526}, "files": [{"sha": "0654b273bd59e62a078c7b183fd3d05eed06ca39", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -1,3 +1,76 @@\n+2012-06-14  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Expand_Put_Call_With_Dimension_Symbol\n+\tcall replaced by Expand_Put_Call_With_Symbol call.\n+\t* sem_dim.adb: New fields Unit_Names, Unit_Symbols\n+\tand Dim_Symbols for record type System_Type.\n+\t(From_Dimension_To_String_Of_Symbols): Removed.\n+\t(From_Dim_To_Str_Of_Dim_Symbols): Renames previous\n+\troutine From_Dimension_To_String_Of_Symbols.\n+\t(From_Dim_To_Str_Of_Unit_Symbols): New routine.\n+\t(Analyze_Aspect_Dimension): argument Symbol in aspect\n+\tDimension aggregate is optional. Named association implemented.\n+\t(Has_Compile_Time_Known_Expressions): Removed.\n+\t(Analyze_Aspect_Dimension_System): New\n+\tcomponent Dim_Symbol in each Dimension aggregate in\n+\taspect Dimension_System. Named associations implemented.\n+\t(Add_Dimension_Vector_To_Buffer): Removed.\n+\t(Add_Whole_To_Buffer): Removed.\n+\t(Expand_Put_Call_With_Dimension_Symbol.): Removed.\n+\t(Expand_Put_Call_With_Symbol): Renames previous routine\n+\tExpand_Put_Call_With_Dimension_Symbol.\n+\t(Has_Dimension_Symbols): Removed.\n+\t(Has_Symbols): Renames previous routine\n+\tHas_Dimension_Symbols.\t(Store_String_Oexpon): New routine.\n+\t* sem_dim.ads (Expand_Put_Call_With_Dimension_Symbol.): Removed.\n+\t(Expand_Put_Call_With_Symbol): Renames previous routine\n+\tExpand_Put_Call_With_Dimension_Symbol.\n+\t* s-diflio.adb, s-diinio.adb (Put): Symbol renames Symbols.\n+\t(Put_Dim_Of): New routines.\n+\t* s-diflio.ads, s-diinio.ads: documentation updated.\n+\t(Put): Symbol renames Symbols.\n+\t(Put_Dim_Of): New routines.\n+\t* s-dim.ads: documentation updated.\n+\t* s-dimmks.ads: dimensioned type and subtypes updated.\n+\t* snames.ads-tmpl: Name_Dim_Symbol, Name_Put_Dim_Of, Name_Symbol,\n+\tand Name_Unit_Symbol added. Name_Symbols removed.\n+\n+2012-06-14  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* freeze.adb (In_Exp_Body): Expression function case added.\n+\t(Freeze_Expression): Insert the Freeze_Nodes\n+\tlist before the correct current scope in case of a quantified\n+\texpression.\n+\n+2012-06-14  Pascal Obry  <obry@adacore.com>\n+\n+\t* projects.texi: Document the Install package for gprinstall.\n+2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_elim.adb (Check_For_Eliminated_Subprogram): Do not check within\n+\ta default expression.\n+\t* sem_res.adb (Resolve_Call): simplify code.\n+\n+2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_case.adb (Check, Issue_Msg): within an instance, non-other\n+\tvalues in a variant part or a case expression do not have to\n+\tbelong to the actual subtype.\n+\n+2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Validate_Derived_Type_Instance): If parent is\n+\tan interface type, check whether it is itself a previous formal\n+\talready instantiated in the current list of actuals.\n+\n+2012-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): The\n+\texpression for a stream attribute is a name that may be overloaded\n+\twith other declarations. To determine whether it matches the\n+\taspect at the freeze point, it is necessary to verify that one\n+\tof its interpretations matches.\n+\n 2012-06-14  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch7.adb, exp_util.adb, sem_aux.ads, exp_ch9.adb,"}, {"sha": "eb37fa3c2fac7ffc50a56b23e859ae446087ca09", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -2389,7 +2389,7 @@ package body Exp_Ch6 is\n         and then Nkind (Call_Node) = N_Procedure_Call_Statement\n         and then Present (Parameter_Associations (Call_Node))\n       then\n-         Expand_Put_Call_With_Dimension_Symbol (Call_Node);\n+         Expand_Put_Call_With_Symbol (Call_Node);\n       end if;\n \n       --  Remove the dimensions of every parameters in call"}, {"sha": "ca8c336c383c8804ea9bd6d3ca30a952cfcc38bf", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -4698,13 +4698,15 @@ package body Freeze is\n             Id := Defining_Unit_Name (Specification (P));\n \n             if Nkind (Id) = N_Defining_Identifier\n-              and then (Is_Init_Proc (Id)              or else\n-                        Is_TSS (Id, TSS_Stream_Input)  or else\n-                        Is_TSS (Id, TSS_Stream_Output) or else\n-                        Is_TSS (Id, TSS_Stream_Read)   or else\n-                        Is_TSS (Id, TSS_Stream_Write)  or else\n+              and then (Is_Init_Proc (Id)                    or else\n+                        Is_TSS (Id, TSS_Stream_Input)        or else\n+                        Is_TSS (Id, TSS_Stream_Output)       or else\n+                        Is_TSS (Id, TSS_Stream_Read)         or else\n+                        Is_TSS (Id, TSS_Stream_Write)        or else\n                         Nkind (Original_Node (P)) =\n-                          N_Subprogram_Renaming_Declaration)\n+                          N_Subprogram_Renaming_Declaration  or else\n+                        Nkind (Original_Node (P)) =\n+                          N_Expression_Function)\n             then\n                return True;\n             else\n@@ -5091,9 +5093,9 @@ package body Freeze is\n         or else Ekind (Current_Scope) = E_Void\n       then\n          declare\n-            N            : constant Node_Id    := Current_Scope;\n-            Freeze_Nodes : List_Id             := No_List;\n-            Pos          : Int                 := Scope_Stack.Last;\n+            N            : constant Node_Id := Current_Scope;\n+            Freeze_Nodes : List_Id          := No_List;\n+            Pos          : Int              := Scope_Stack.Last;\n \n          begin\n             if Present (Desig_Typ) then\n@@ -5109,13 +5111,18 @@ package body Freeze is\n             end if;\n \n             --  The current scope may be that of a constrained component of\n-            --  an enclosing record declaration, which is above the current\n-            --  scope in the scope stack.\n+            --  an enclosing record declaration, or of a loop of an enclosing\n+            --  quantified expression, which is above the current scope in the\n+            --  scope stack. Indeed in the context of a quantified expression,\n+            --  a scope is created and pushed above the current scope in order\n+            --  to emulate the loop-like behavior of the quantified expression.\n             --  If the expression is within a top-level pragma, as for a pre-\n             --  condition on a library-level subprogram, nothing to do.\n \n             if not Is_Compilation_Unit (Current_Scope)\n-              and then Is_Record_Type (Scope (Current_Scope))\n+              and then (Is_Record_Type (Scope (Current_Scope))\n+                         or else Nkind (Parent (Current_Scope)) =\n+                                   N_Quantified_Expression)\n             then\n                Pos := Pos - 1;\n             end if;"}, {"sha": "1c0c593ac1510ad9b09b05bd62f52ba3592dd5b5", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -226,6 +226,7 @@ should contain the following code:\n * Executable File Names::\n * Avoid Duplication With Variables::\n * Naming Schemes::\n+* Installation::\n @end menu\n \n @c ---------------------------------------------\n@@ -1023,6 +1024,54 @@ For example, the following package models the DEC Ada file naming rules:\n names in lower case)\n @end ifset\n \n+@c ---------------------------------------------\n+@node Installation\n+@subsection Installation\n+@c ---------------------------------------------\n+\n+@noindent\n+After building an application or a library it is often required to\n+install it into the development environment. This installation is\n+required if the library is to be used by another application for\n+example. The @code{gprinstall} tool provide an easy way to install\n+libraries, executable or object code generated durting the build. The\n+@b{Install} package can be used to change the default locations.\n+\n+The following attributes can be defined in package @code{Install}:\n+\n+@table @asis\n+\n+@item @b{Active}\n+\n+Whether the project is to be installed, values are @code{true}\n+(default) or @code{false}.\n+\n+@item @b{Prefix}:\n+@cindex @code{Prefix}\n+\n+Root directory for the installation.\n+\n+@item @b{Exec_Subdir}\n+\n+Subdirectory of @b{Prefix} where executables are to be\n+installed. Default is @b{bin}.\n+\n+@item @b{Lib_Subdir}\n+\n+Subdirectory of @b{Prefix} where directory with the library or object\n+files is to be installed. Default is @b{lib}.\n+\n+@item @b{Sources_Subdir}\n+\n+Subdirectory of @b{Prefix} where directory with sources is to be\n+installed. Default is @b{include}.\n+\n+@item @b{Project_Subdir}\n+\n+Subdirectory of @b{Prefix} where the installed project is to be\n+installed. Default is @b{share/gpr}.\n+@end table\n+\n @c ---------------------------------------------\n @node Organizing Projects into Subsystems\n @section Organizing Projects into Subsystems\n@@ -3039,6 +3088,9 @@ The following packages are currently supported in project files\n   This package specifies the options used when starting an integrated\n   development environment, for instance @command{GPS} or @command{Gnatbench}.\n   @xref{The Development Environments}.\n+@item Install\n+  This package specifies the options used when installing a project\n+  with @command{gprinstall}. @xref{Installation}.\n @item Linker\n   This package specifies the options used by the linker.\n   @xref{Main Subprograms}."}, {"sha": "527d7bbbaf8b39f26296fb68d405f2b0aaac56a8", "filename": "gcc/ada/s-diflio.adb", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diflio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diflio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diflio.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -38,40 +38,72 @@ package body System.Dim.Float_IO is\n    ---------\n \n    procedure Put\n-     (File    : File_Type;\n-      Item    : Num_Dim_Float;\n-      Fore    : Field  := Default_Fore;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\")\n+     (File   : File_Type;\n+      Item   : Num_Dim_Float;\n+      Fore   : Field  := Default_Fore;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\")\n    is\n    begin\n       Num_Dim_Float_IO.Put (File, Item, Fore, Aft, Exp);\n-      Ada.Text_IO.Put (File, Symbols);\n+      Ada.Text_IO.Put (File, Symbol);\n    end Put;\n \n    procedure Put\n-     (Item    : Num_Dim_Float;\n-      Fore    : Field  := Default_Fore;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\")\n+     (Item   : Num_Dim_Float;\n+      Fore   : Field  := Default_Fore;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\")\n    is\n    begin\n       Num_Dim_Float_IO.Put (Item, Fore, Aft, Exp);\n-      Ada.Text_IO.Put (Symbols);\n+      Ada.Text_IO.Put (Symbol);\n    end Put;\n \n    procedure Put\n-     (To      : out String;\n-      Item    : Num_Dim_Float;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\")\n+     (To     : out String;\n+      Item   : Num_Dim_Float;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\")\n    is\n    begin\n       Num_Dim_Float_IO.Put (To, Item, Aft, Exp);\n-      To := To & Symbols;\n+      To := To & Symbol;\n    end Put;\n \n+   ----------------\n+   -- Put_Dim_Of --\n+   ----------------\n+\n+   pragma Warnings (Off);\n+   --  kill warnings on unreferenced formals\n+\n+   procedure Put_Dim_Of\n+     (File   : File_Type;\n+      Item   : Num_Dim_Float;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      Ada.Text_IO.Put (File, Symbol);\n+   end Put_Dim_Of;\n+\n+   procedure Put_Dim_Of\n+     (Item   : Num_Dim_Float;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      Ada.Text_IO.Put (Symbol);\n+   end Put_Dim_Of;\n+\n+   procedure Put_Dim_Of\n+     (To     : out String;\n+      Item   : Num_Dim_Float;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      To := Symbol;\n+   end Put_Dim_Of;\n end System.Dim.Float_IO;"}, {"sha": "f866f4aad84d3bd8203d73ac382f1c8cb842a560", "filename": "gcc/ada/s-diflio.ads", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diflio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diflio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diflio.ads?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -31,33 +31,63 @@\n \n --  This package provides output routines for float dimensioned types. All Put\n --  routines are modelled after those in package Ada.Text_IO.Float_IO with the\n---  addition of an extra default parameter.\n+--  addition of an extra default parameter. All Put_Dim_Of routines\n+--  output the dimension of Item in a symbolic manner.\n \n --  Parameter Symbol may be used in the following manner (all the examples are\n---  based on the MKS system of units as defined in package System.Dim.Mks):\n+--  based on the MKS system of units defined in package System.Dim.Mks):\n+\n+--    type Mks_Type is new Long_Long_Float\n+--      with\n+--       Dimension_System => (\n+--        (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),\n+--        (Unit_Name => Kilogram, Unit_Symbol => \"kg\",  Dim_Symbol => 'M'),\n+--        (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),\n+--        (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),\n+--        (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => \"\u0398\"),\n+--        (Unit_Name => Mole,     Unit_Symbol => \"mol\", Dim_Symbol => 'N'),\n+--        (Unit_Name => Candela,  Unit_Symbol => \"cd\",  Dim_Symbol => 'J'));\n \n --  Case 1. A value is supplied for Symbol\n \n---    The string appears as a suffix of Item\n+--   * Put        : The string appears as a suffix of Item\n+\n+--   * Put_Dim_Of : The string appears alone\n \n --      Obj : Mks_Type := 2.6;\n --      Put (Obj, 1, 1, 0, \" dimensionless\");\n+--      Put_Dim_Of (Obj, \"dimensionless\");\n \n---      The corresponding output is: 2.6 dimensionless\n+--      The corresponding outputs are:\n+--      $2.6 dimensionless\n+--      $dimensionless\n \n --  Case 2. No value is supplied for Symbol and Item is dimensionless\n \n---    Item appears without a suffix\n+--   * Put        : Item appears without a suffix\n+\n+--   * Put_Dim_Of : the output is []\n \n --      Obj : Mks_Type := 2.6;\n --      Put (Obj, 1, 1, 0);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 2.6\n+--      The corresponding outputs are:\n+--      $2.6\n+--      $[]\n \n --  Case 3. No value is supplied for Symbol and Item has a dimension\n \n---    If the type of Item is a dimensioned subtype whose symbolic name is not\n---    empty, then the symbolic name appears as a suffix.\n+--   * Put        : If the type of Item is a dimensioned subtype whose\n+--                  symbol is not empty, then the symbol appears as a suffix.\n+--                  Otherwise, a new string is created and appears as a\n+--                  suffix of Item. This string results in the successive\n+--                  concatenations between each unit symbol raised by its\n+--                  corresponding dimension power from the dimensions of Item.\n+\n+--   * Put_Dim_Of : The output is a new string resulting in the successive\n+--                  concatenations between each dimension symbol raised by its\n+--                  corresponding dimension power from the dimensions of Item.\n \n --      subtype Length is Mks_Type\n --        with\n@@ -67,29 +97,33 @@\n \n --      Obj : Length := 2.3 * dm;\n --      Put (Obj, 1, 2, 0);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 0.23 m\n-\n---    Otherwise, a new string is created and appears as a suffix of Item.\n---    This string results in the successive concatanations between each\n---    dimension symbolic name raised by its corresponding dimension power from\n---    the dimensions of Item.\n+--      The corresponding outputs are:\n+--      $0.23 m\n+--      $[L]\n \n --      subtype Random is Mks_Type\n --        with\n---         Dimension => (\"\",\n---         Meter =>   3,\n---         Candela => -1,\n---         others =>  0);\n+--         Dimension => (\n+--           Meter =>   3,\n+--           Candela => -1,\n+--           others =>  0);\n \n --      Obj : Random := 5.0;\n --      Put (Obj);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 5.0 m**3.cd**(-1)\n+--      The corresponding outputs are:\n+--      $5.0 m**3.cd**(-1)\n+--      $[l**3.J**(-1)]\n \n --      Put (3.3 * km * dm * min, 5, 1, 0);\n+--      Put_Dim_Of (3.3 * km * dm * min);\n \n---      The corresponding output is: 19800.0 m**2.s\n+--      The corresponding outputs are:\n+--      $19800.0 m**2.s\n+--      $[L**2.T]\n \n with Ada.Text_IO; use Ada.Text_IO;\n \n@@ -103,27 +137,42 @@ package System.Dim.Float_IO is\n    Default_Exp  : Field := 3;\n \n    procedure Put\n-     (File    : File_Type;\n-      Item    : Num_Dim_Float;\n-      Fore    : Field  := Default_Fore;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\");\n+     (File   : File_Type;\n+      Item   : Num_Dim_Float;\n+      Fore   : Field  := Default_Fore;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\");\n \n    procedure Put\n-     (Item    : Num_Dim_Float;\n-      Fore    : Field  := Default_Fore;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\");\n+     (Item   : Num_Dim_Float;\n+      Fore   : Field  := Default_Fore;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\");\n \n    procedure Put\n-     (To      : out String;\n-      Item    : Num_Dim_Float;\n-      Aft     : Field  := Default_Aft;\n-      Exp     : Field  := Default_Exp;\n-      Symbols : String := \"\");\n+     (To     : out String;\n+      Item   : Num_Dim_Float;\n+      Aft    : Field  := Default_Aft;\n+      Exp    : Field  := Default_Exp;\n+      Symbol : String := \"\");\n+\n+   procedure Put_Dim_Of\n+     (File   : File_Type;\n+      Item   : Num_Dim_Float;\n+      Symbol : String := \"\");\n+\n+   procedure Put_Dim_Of\n+     (Item   : Num_Dim_Float;\n+      Symbol : String := \"\");\n+\n+   procedure Put_Dim_Of\n+     (To     : out String;\n+      Item   : Num_Dim_Float;\n+      Symbol : String := \"\");\n \n    pragma Inline (Put);\n+   pragma Inline (Put_Dim_Of);\n \n end System.Dim.Float_IO;"}, {"sha": "d8f4fcc50f5d1c30003cf5e8f85f15ecb855129a", "filename": "gcc/ada/s-diinio.adb", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diinio.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -38,40 +38,72 @@ package body System.Dim.Integer_IO is\n    ---------\n \n    procedure Put\n-     (File    : File_Type;\n-      Item    : Num_Dim_Integer;\n-      Width   : Field       := Default_Width;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\")\n+     (File   : File_Type;\n+      Item   : Num_Dim_Integer;\n+      Width  : Field       := Default_Width;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\")\n \n    is\n    begin\n       Num_Dim_Integer_IO.Put (File, Item, Width, Base);\n-      Ada.Text_IO.Put (File, Symbols);\n+      Ada.Text_IO.Put (File, Symbol);\n    end Put;\n \n    procedure Put\n-     (Item    : Num_Dim_Integer;\n-      Width   : Field       := Default_Width;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\")\n+     (Item   : Num_Dim_Integer;\n+      Width  : Field       := Default_Width;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\")\n \n    is\n    begin\n       Num_Dim_Integer_IO.Put (Item, Width, Base);\n-      Ada.Text_IO.Put (Symbols);\n+      Ada.Text_IO.Put (Symbol);\n    end Put;\n \n    procedure Put\n-     (To      : out String;\n-      Item    : Num_Dim_Integer;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\")\n+     (To     : out String;\n+      Item   : Num_Dim_Integer;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\")\n \n    is\n    begin\n       Num_Dim_Integer_IO.Put (To, Item, Base);\n-      To := To & Symbols;\n+      To := To & Symbol;\n    end Put;\n \n+   ----------------\n+   -- Put_Dim_Of --\n+   ----------------\n+\n+   pragma Warnings (Off);\n+   --  kill warnings on unreferenced formals\n+\n+   procedure Put_Dim_Of\n+     (File   : File_Type;\n+      Item   : Num_Dim_Integer;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      Ada.Text_IO.Put (File, Symbol);\n+   end Put_Dim_Of;\n+\n+   procedure Put_Dim_Of\n+     (Item   : Num_Dim_Integer;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      Ada.Text_IO.Put (Symbol);\n+   end Put_Dim_Of;\n+\n+   procedure Put_Dim_Of\n+     (To     : out String;\n+      Item   : Num_Dim_Integer;\n+      Symbol : String := \"\")\n+   is\n+   begin\n+      To := Symbol;\n+   end Put_Dim_Of;\n end System.Dim.Integer_IO;"}, {"sha": "e5e8c444caddcb8de2576fb998db044c5fe8e918", "filename": "gcc/ada/s-diinio.ads", "status": "modified", "additions": 76, "deletions": 41, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diinio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-diinio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-diinio.ads?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -31,44 +31,63 @@\n \n --  This package provides output routines for integer dimensioned types. All\n --  Put routines are modelled after those in package Ada.Text_IO.Integer_IO\n---  with the addition of an extra default parameter.\n+--  with the addition of an extra default parameter. All Put_Dim_Of routines\n+--  output the dimension of Item in a symbolic manner.\n \n---  All the examples in this package are based on the MKS system of units:\n+--  Parameter Symbol may be used in the following manner (all the examples are\n+--  based on the MKS system of units as defined in package System.Dim.Mks):\n \n --    type Mks_Type is new Integer\n --      with\n---       Dimension_System => ((Meter, 'm'),\n---         (Kilogram, \"kg\"),\n---         (Second,   's'),\n---         (Ampere,   'A'),\n---         (Kelvin,   'K'),\n---         (Mole,     \"mol\"),\n---         (Candela,  \"cd\"));\n-\n---  Parameter Symbol may be used in the following manner:\n+--       Dimension_System => (\n+--        (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),\n+--        (Unit_Name => Kilogram, Unit_Symbol => \"kg\",  Dim_Symbol => 'M'),\n+--        (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),\n+--        (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),\n+--        (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => \"\u0398\"),\n+--        (Unit_Name => Mole,     Unit_Symbol => \"mol\", Dim_Symbol => 'N'),\n+--        (Unit_Name => Candela,  Unit_Symbol => \"cd\",  Dim_Symbol => 'J'));\n \n --  Case 1. A value is supplied for Symbol\n \n---    The string appears as a suffix of Item\n+--   * Put        : The string appears as a suffix of Item\n+\n+--   * Put_Dim_Of : The string appears alone\n \n --      Obj : Mks_Type := 2;\n---      Put (Obj, Symbols => \" dimensionless\");\n+--      Put (Obj, Symbols => \"dimensionless\");\n+--      Put_Dim_Of (Obj, Symbols => \"dimensionless\");\n \n---      The corresponding output is: 2 dimensionless\n+--      The corresponding outputs are:\n+--      $2 dimensionless\n+--      $dimensionless\n \n --  Case 2. No value is supplied for Symbol and Item is dimensionless\n \n---    Item appears without a suffix\n+--   * Put        : Item appears without a suffix\n+\n+--   * Put_Dim_Of : the output is []\n \n --      Obj : Mks_Type := 2;\n --      Put (Obj);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 2\n+--      The corresponding outputs are:\n+--      $2\n+--      $[]\n \n --  Case 3. No value is supplied for Symbol and Item has a dimension\n \n---    If the type of Item is a dimensioned subtype whose symbolic name is not\n---    empty, then the symbolic name appears as a suffix.\n+--   * Put        : If the type of Item is a dimensioned subtype whose\n+--                  symbol is not empty, then the symbol appears as a suffix.\n+--                  Otherwise, a new string is created and appears as a\n+--                  suffix of Item. This string results in the successive\n+--                  concatenations between each unit symbol raised by its\n+--                  corresponding dimension power from the dimensions of Item.\n+\n+--   * Put_Dim_Of : The output is a new string resulting in the successive\n+--                  concatenations between each dimension symbol raised by its\n+--                  corresponding dimension power from the dimensions of Item.\n \n --      subtype Length is Mks_Type\n --        with\n@@ -78,25 +97,26 @@\n \n --      Obj : Length := 2;\n --      Put (Obj);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 2 m\n-\n---    Otherwise, a new string is created and appears as a suffix of Item.\n---    This string results in the successive concatanations between each\n---    dimension symbolic name raised by its corresponding dimension power from\n---    the dimensions of Item.\n+--      The corresponding outputs are:\n+--      $2 m\n+--      $[L]\n \n --      subtype Random is Mks_Type\n --        with\n --         Dimension => (\"\",\n---         Meter =>   3,\n---         Candela => 2,\n---         others =>  0);\n+--           Meter =>   3,\n+--           Candela => 2,\n+--           others =>  0);\n \n --      Obj : Random := 5;\n --      Put (Obj);\n+--      Put_Dim_Of (Obj);\n \n---      The corresponding output is: 5 m**3.cd**2\n+--      The corresponding outputs are:\n+--      $5 m**3.cd**2\n+--      $[L**3.J**2]\n \n with Ada.Text_IO; use Ada.Text_IO;\n \n@@ -109,24 +129,39 @@ package System.Dim.Integer_IO is\n    Default_Base  : Number_Base := 10;\n \n    procedure Put\n-     (File    : File_Type;\n-      Item    : Num_Dim_Integer;\n-      Width   : Field       := Default_Width;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\");\n+     (File   : File_Type;\n+      Item   : Num_Dim_Integer;\n+      Width  : Field       := Default_Width;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\");\n \n    procedure Put\n-     (Item    : Num_Dim_Integer;\n-      Width   : Field       := Default_Width;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\");\n+     (Item   : Num_Dim_Integer;\n+      Width  : Field       := Default_Width;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\");\n \n    procedure Put\n-     (To      : out String;\n-      Item    : Num_Dim_Integer;\n-      Base    : Number_Base := Default_Base;\n-      Symbols : String      := \"\");\n+     (To     : out String;\n+      Item   : Num_Dim_Integer;\n+      Base   : Number_Base := Default_Base;\n+      Symbol : String      := \"\");\n+\n+   procedure Put_Dim_Of\n+     (File   : File_Type;\n+      Item   : Num_Dim_Integer;\n+      Symbol : String := \"\");\n+\n+   procedure Put_Dim_Of\n+     (Item   : Num_Dim_Integer;\n+      Symbol : String := \"\");\n+\n+   procedure Put_Dim_Of\n+     (To     : out String;\n+      Item   : Num_Dim_Integer;\n+      Symbol : String := \"\");\n \n    pragma Inline (Put);\n+   pragma Inline (Put_Dim_Of);\n \n end System.Dim.Integer_IO;"}, {"sha": "9896de8dd79abb165b512939f3f600f4a6e18be8", "filename": "gcc/ada/s-dim.ads", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dim.ads?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -42,15 +42,14 @@\n \n --      type Mks_Type is new Long_Long_Float\n --        with\n---         Dimension_System => ((Meter, 'm'),\n---           (Kilogram, \"kg\"),\n---           (Second,   's'),\n---           (Ampere,   'A'),\n---           (Kelvin,   'K'),\n---           (Mole,     \"mol\"),\n---           (Candela,  \"cd\"));\n-\n---      'm' is the symbolic name of dimension Meter\n+--         Dimension_System => (\n+--          (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),\n+--          (Unit_Name => Kilogram, Unit_Symbol => \"kg\",  Dim_Symbol => 'M'),\n+--          (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),\n+--          (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),\n+--          (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => \"\u0398\"),\n+--          (Unit_Name => Mole,     Unit_Symbol => \"mol\", Dim_Symbol => 'N'),\n+--          (Unit_Name => Candela,  Unit_Symbol => \"cd\",  Dim_Symbol => 'J'));\n \n --  * Dimensioned subtype\n \n@@ -59,12 +58,10 @@\n \n --      subtype Length is Mks_Type\n --        with\n---         Dimension => ('m',\n+--         Dimension => (Symbol => 'm',\n --           Meter =>  1,\n --           others => 0);\n \n---      'm' is the symbolic name of dimensioned subtype Length\n-\n package System.Dim is\n    pragma Pure;\n "}, {"sha": "50553d1d195679a7235031882c92242d07adf1cd", "filename": "gcc/ada/s-dimmks.ads", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-dimmks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fs-dimmks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dimmks.ads?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -48,49 +48,50 @@ package System.Dim.Mks is\n \n    type Mks_Type is new Long_Long_Float\n      with\n-      Dimension_System => ((Meter, 'm'),\n-        (Kilogram, \"kg\"),\n-        (Second,   's'),\n-        (Ampere,   'A'),\n-        (Kelvin,   'K'),\n-        (Mole,     \"mol\"),\n-        (Candela,  \"cd\"));\n+      Dimension_System => (\n+        (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),\n+        (Unit_Name => Kilogram, Unit_Symbol => \"kg\",  Dim_Symbol => 'M'),\n+        (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),\n+        (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),\n+        (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => \"\u0398\"),\n+        (Unit_Name => Mole,     Unit_Symbol => \"mol\", Dim_Symbol => 'N'),\n+        (Unit_Name => Candela,  Unit_Symbol => \"cd\",  Dim_Symbol => 'J'));\n \n    --  SI Base dimensioned subtype\n \n    subtype Length is Mks_Type\n      with\n-      Dimension => ('m',\n-        Meter =>  1,\n+      Dimension => (Symbol => 'm',\n+        Meter  => 1,\n         others => 0);\n    subtype Mass is Mks_Type\n      with\n-      Dimension => (\"kg\",\n+      Dimension => (Symbol => \"kg\",\n         Kilogram => 1,\n         others =>   0);\n    subtype Time is Mks_Type\n      with\n-      Dimension => ('s',\n+      Dimension => (Symbol => 's',\n         Second => 1,\n         others => 0);\n    subtype Electric_Current is Mks_Type\n      with\n-      Dimension => ('A',\n+      Dimension => (Symbol => 'A',\n         Ampere => 1,\n         others => 0);\n    subtype Thermodynamic_Temperature is Mks_Type\n      with\n-      Dimension => ('K',\n+      Dimension => (Symbol => 'K',\n         Kelvin => 1,\n         others => 0);\n    subtype Amount_Of_Substance is Mks_Type\n      with\n-      Dimension => (\"mol\",\n+      Dimension => (Symbol => \"mol\",\n         Mole =>   1,\n         others => 0);\n    subtype Luminous_Intensity is Mks_Type\n      with\n-      Dimension => (\"cd\",\n+      Dimension => (Symbol => \"cd\",\n         Candela => 1,\n         others =>  0);\n \n@@ -108,144 +109,144 @@ package System.Dim.Mks is\n \n    subtype Angle is Mks_Type\n      with\n-      Dimension => (\"rad\",\n+      Dimension => (Symbol => \"rad\",\n         others => 0);\n \n    subtype Solid_Angle is Mks_Type\n      with\n-      Dimension => (\"sr\",\n+      Dimension => (Symbol => \"sr\",\n         others => 0);\n \n    subtype Frequency is Mks_Type\n      with\n-      Dimension => (\"Hz\",\n+      Dimension => (Symbol => \"Hz\",\n         Second => -1,\n         others => 0);\n    subtype Force is Mks_Type\n      with\n-      Dimension => ('N',\n+      Dimension => (Symbol => 'N',\n         Meter =>    1,\n         Kilogram => 1,\n         Second =>  -2,\n         others =>   0);\n    subtype Pressure is Mks_Type\n      with\n-      Dimension => (\"Pa\",\n+      Dimension => (Symbol => \"Pa\",\n         Meter =>    -1,\n         Kilogram => 1,\n         Second =>   -2,\n         others =>   0);\n    subtype Energy is Mks_Type\n      with\n-      Dimension => ('J',\n+      Dimension => (Symbol => 'J',\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -2,\n         others =>   0);\n    subtype Power is Mks_Type\n      with\n-      Dimension => ('W',\n+      Dimension => (Symbol => 'W',\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -3,\n         others =>   0);\n    subtype Electric_Charge is Mks_Type\n      with\n-      Dimension => ('C',\n+      Dimension => (Symbol => 'C',\n         Second => 1,\n         Ampere => 1,\n         others => 0);\n    subtype Electric_Potential_Difference is Mks_Type\n      with\n-      Dimension => ('V',\n+      Dimension => (Symbol => 'V',\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -3,\n         Ampere =>   -1,\n         others =>   0);\n    subtype Electric_Capacitance is Mks_Type\n      with\n-      Dimension => ('F',\n+      Dimension => (Symbol => 'F',\n         Meter =>    -2,\n         Kilogram => -1,\n         Second =>   4,\n         Ampere =>   2,\n         others =>   0);\n    subtype Electric_Resistance is Mks_Type\n      with\n-      Dimension => (\"\u03a9\",\n+      Dimension => (Symbol => \"\u03a9\",\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -3,\n         Ampere =>   -2,\n         others =>   0);\n    subtype Electric_Conductance is Mks_Type\n      with\n-      Dimension => ('S',\n+      Dimension => (Symbol => 'S',\n         Meter =>    -2,\n         Kilogram => -1,\n         Second =>   3,\n         Ampere =>   2,\n         others =>   0);\n    subtype Magnetic_Flux is Mks_Type\n      with\n-      Dimension => (\"Wb\",\n+      Dimension => (Symbol => \"Wb\",\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -2,\n         Ampere =>   -1,\n         others =>   0);\n    subtype Magnetic_Flux_Density is Mks_Type\n      with\n-      Dimension => ('T',\n+      Dimension => (Symbol => 'T',\n         Kilogram => 1,\n         Second =>   -2,\n         Ampere =>   -1,\n         others =>   0);\n    subtype Inductance is Mks_Type\n      with\n-      Dimension => ('H',\n+      Dimension => (Symbol => 'H',\n         Meter =>    2,\n         Kilogram => 1,\n         Second =>   -2,\n         Ampere =>   -2,\n         others =>   0);\n    subtype Celsius_Temperature is Mks_Type\n      with\n-      Dimension => (\"\u00b0C\",\n+      Dimension => (Symbol => \"\u00b0C\",\n         Kelvin => 1,\n         others => 0);\n    subtype Luminous_Flux is Mks_Type\n      with\n-      Dimension => (\"lm\",\n+      Dimension => (Symbol => \"lm\",\n         Candela => 1,\n         others =>  0);\n    subtype Illuminance is Mks_Type\n      with\n-      Dimension => (\"lx\",\n+      Dimension => (Symbol => \"lx\",\n         Meter =>   -2,\n         Candela => 1,\n         others =>  0);\n    subtype Radioactivity is Mks_Type\n      with\n-      Dimension => (\"Bq\",\n+      Dimension => (Symbol => \"Bq\",\n         Second => -1,\n         others => 0);\n    subtype Absorbed_Dose is Mks_Type\n      with\n-      Dimension => (\"Gy\",\n+      Dimension => (Symbol => \"Gy\",\n         Meter =>  2,\n         Second => -2,\n         others => 0);\n    subtype Equivalent_Dose is Mks_Type\n      with\n-      Dimension => (\"Sv\",\n+      Dimension => (Symbol => \"Sv\",\n         Meter =>  2,\n         Second => -2,\n         others => 0);\n    subtype Catalytic_Activity is Mks_Type\n      with\n-      Dimension => (\"kat\",\n+      Dimension => (Symbol => \"kat\",\n         Second => -1,\n         Mole =>   1,\n         others => 0);"}, {"sha": "8fa307442a64057852f251608a49ebfd0d105a88", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -159,6 +159,15 @@ package body Sem_Case is\n          Msg_Sloc : constant Source_Ptr := Sloc (Case_Node);\n \n       begin\n+         --  AI05-0188 : within an instance the non-others choices do not\n+         --  have to belong to the actual subtype.\n+\n+         if Ada_Version >= Ada_2012\n+           and then In_Instance\n+         then\n+            return;\n+         end if;\n+\n          --  In some situations, we call this with a null range, and\n          --  obviously we don't want to complain in this case!\n \n@@ -718,6 +727,14 @@ package body Sem_Case is\n                Raises_CE := True;\n                return;\n \n+            --  AI05-0188 : within an instance the non-others choices do not\n+            --  have to belong to the actual subtype.\n+\n+            elsif Ada_Version >= Ada_2012\n+              and then In_Instance\n+            then\n+               return;\n+\n             --  Otherwise we have an OK static choice\n \n             else"}, {"sha": "c4351fce11acae998019c48dd62fdd2daed9192c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -10811,6 +10811,11 @@ package body Sem_Ch12 is\n \n                pragma Assert (Present (Ancestor));\n \n+               --  the ancestor itself may be a previous formal that\n+               --  has been instantiated.\n+\n+               Ancestor := Get_Instance_Of (Ancestor);\n+\n             else\n                Ancestor :=\n                  Get_Instance_Of (Base_Type (Get_Instance_Of (A_Gen_T)));"}, {"sha": "bca378254f4f800622e561d8ac5d8cb4146e9b36", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -6136,15 +6136,41 @@ package body Sem_Ch13 is\n       if A_Id = Aspect_Synchronization then\n          return;\n \n-      --  Case of stream attributes, just have to compare entities\n+      --  Case of stream attributes, just have to compare entities. However,\n+      --  the expression is just a name (possibly overloaded), and there may\n+      --  be stream operations declared for unrelated types, so we just need\n+      --  to verify that one of these interpretations is the one available at\n+      --  at the freeze point.\n \n       elsif A_Id = Aspect_Input  or else\n          A_Id = Aspect_Output    or else\n          A_Id = Aspect_Read      or else\n          A_Id = Aspect_Write\n       then\n          Analyze (End_Decl_Expr);\n-         Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n+\n+         if not Is_Overloaded (End_Decl_Expr) then\n+            Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n+\n+         else\n+            Err := True;\n+\n+            declare\n+               Index : Interp_Index;\n+               It    : Interp;\n+\n+            begin\n+               Get_First_Interp (End_Decl_Expr, Index, It);\n+               while Present (It.Typ) loop\n+                  if It.Nam = Entity (Freeze_Expr) then\n+                     Err := False;\n+                     exit;\n+                  end if;\n+\n+                  Get_Next_Interp (Index, It);\n+               end loop;\n+            end;\n+         end if;\n \n       elsif A_Id = Aspect_Variable_Indexing or else\n             A_Id = Aspect_Constant_Indexing or else"}, {"sha": "49f29a3423b129b2f0be0f9b9d8d602b30b5c931", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 589, "deletions": 334, "changes": 923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -117,14 +117,15 @@ package body Sem_Dim is\n    No_Symbols : constant Symbol_Array := (others => No_String);\n \n    type System_Type is record\n-      Type_Decl : Node_Id;\n-      Names     : Name_Array;\n-      Symbols   : Symbol_Array;\n-      Count     : Dimension_Position;\n+      Type_Decl    : Node_Id;\n+      Unit_Names   : Name_Array;\n+      Unit_Symbols : Symbol_Array;\n+      Dim_Symbols  : Symbol_Array;\n+      Count        : Dimension_Position;\n    end record;\n \n    Null_System : constant System_Type :=\n-                   (Empty, No_Names, No_Symbols, Invalid_Position);\n+                   (Empty, No_Names, No_Symbols, No_Symbols, Invalid_Position);\n \n    subtype System_Id is Nat;\n \n@@ -290,8 +291,8 @@ package body Sem_Dim is\n    --  Return the dimension vector of node N\n \n    function Dimensions_Msg_Of (N : Node_Id) return String;\n-   --  Given a node, return \"has dimension\" followed by the dimension vector of\n-   --  N or \"is dimensionless\" if N is dimensionless.\n+   --  Given a node, return \"has dimension\" followed by the dimension symbols\n+   --  of N or \"is dimensionless\" if N is dimensionless.\n \n    procedure Eval_Op_Expon_With_Rational_Exponent\n      (N              : Node_Id;\n@@ -304,11 +305,21 @@ package body Sem_Dim is\n    function Exists (Sys : System_Type) return Boolean;\n    --  Returns True iff Sys does not denote the null system\n \n-   function From_Dimension_To_String_Of_Symbols\n+   function From_Dim_To_Str_Of_Dim_Symbols\n+     (Dims         : Dimension_Type;\n+      System       : System_Type;\n+      In_Error_Msg : Boolean := False) return String_Id;\n+   --  Given a dimension vector and a dimension system, return the proper\n+   --  string of dimension symbols. If In_Error_Msg is True (i.e. the String_Id\n+   --  will be used to issue an error message) then this routine has a special\n+   --  handling for the insertion character asterisk * which must be precede by\n+   --  a quote ' to to be placed literally into the message.\n+\n+   function From_Dim_To_Str_Of_Unit_Symbols\n      (Dims   : Dimension_Type;\n       System : System_Type) return String_Id;\n    --  Given a dimension vector and a dimension system, return the proper\n-   --  string of symbols.\n+   --  string of unit symbols.\n \n    function Is_Dim_IO_Package_Entity (E : Entity_Id) return Boolean;\n    --  Return True if E is the package entity of System.Dim.Float_IO or\n@@ -403,6 +414,7 @@ package body Sem_Dim is\n       return Reduce (Rational'(Numerator =>   L.Numerator * R.Denominator,\n                                Denominator => L.Denominator * R.Numerator));\n    end \"/\";\n+\n    -----------\n    -- \"abs\" --\n    -----------\n@@ -417,15 +429,27 @@ package body Sem_Dim is\n    -- Analyze_Aspect_Dimension --\n    ------------------------------\n \n-   --  with Dimension => DIMENSION_FOR_SUBTYPE\n-   --  DIMENSION_FOR_SUBTYPE ::= (DIMENSION_STRING, DIMENSION_RATIONALS)\n-   --  DIMENSION_RATIONALS ::=\n-   --    RATIONAL,  {, RATIONAL}\n-   --  | RATIONAL {, RATIONAL}, others => RATIONAL\n+   --  with Dimension => (\n+   --       [Symbol =>] SYMBOL,\n+   --                   DIMENSION_VALUE\n+   --    [,             DIMENSION_VALUE]\n+   --    [,             DIMENSION_VALUE]\n+   --    [,             DIMENSION_VALUE]\n+   --    [,             DIMENSION_VALUE]\n+   --    [,             DIMENSION_VALUE]\n+   --    [,             DIMENSION_VALUE]);\n+   --\n+   --  SYMBOL ::= STRING_LITERAL | CHARACTER_LITERAL\n+\n+   --  DIMENSION_VALUE ::=\n+   --    RATIONAL\n+   --  | others => RATIONAL\n    --  | DISCRETE_CHOICE_LIST => RATIONAL\n+\n    --  RATIONAL ::= [-] NUMERAL [/ NUMERAL]\n \n-   --  (see Analyze_Aspect_Dimension_System for DIMENSION_STRING grammar)\n+   --  Note that when the dimensioned type is an integer type, then any\n+   --  dimension value must be an integer literal.\n \n    procedure Analyze_Aspect_Dimension\n      (N    : Node_Id;\n@@ -446,11 +470,6 @@ package body Sem_Dim is\n       --  Given an expression with denotes a rational number, read the number\n       --  and associate it with Position in Dimensions.\n \n-      function Has_Compile_Time_Known_Expressions\n-        (Aggr : Node_Id) return Boolean;\n-      --  Determine whether aggregate Aggr contains only expressions that are\n-      --  known at compile time.\n-\n       function Position_In_System\n         (Id     : Node_Id;\n          System : System_Type) return Dimension_Position;\n@@ -466,60 +485,26 @@ package body Sem_Dim is\n          Position : Dimension_Position)\n       is\n       begin\n+         --  Integer case\n+\n          if Is_Integer_Type (Def_Id) then\n-            Dimensions (Position) := +Whole (UI_To_Int (Expr_Value (Expr)));\n+            --  Dimension value must be an integer literal\n+\n+            if Nkind (Expr) = N_Integer_Literal then\n+               Dimensions (Position) := +Whole (UI_To_Int (Intval (Expr)));\n+            else\n+               Error_Msg_N (\"integer literal expected\", Expr);\n+            end if;\n+\n+         --  Float case\n+\n          else\n             Dimensions (Position) := Create_Rational_From (Expr, True);\n          end if;\n \n          Processed (Position) := True;\n       end Extract_Power;\n \n-      ----------------------------------------\n-      -- Has_Compile_Time_Known_Expressions --\n-      ----------------------------------------\n-\n-      function Has_Compile_Time_Known_Expressions\n-        (Aggr : Node_Id) return Boolean\n-      is\n-         Comp : Node_Id;\n-         Expr : Node_Id;\n-\n-      begin\n-         Expr := First (Expressions (Aggr));\n-         if Present (Expr) then\n-\n-            --  The first expression within the aggregate describes the\n-            --  symbolic name of a dimension, skip it.\n-\n-            Next (Expr);\n-            while Present (Expr) loop\n-               Analyze_And_Resolve (Expr);\n-\n-               if not Compile_Time_Known_Value (Expr) then\n-                  return False;\n-               end if;\n-\n-               Next (Expr);\n-            end loop;\n-         end if;\n-\n-         Comp := First (Component_Associations (Aggr));\n-         while Present (Comp) loop\n-            Expr := Expression (Comp);\n-\n-            Analyze_And_Resolve (Expr);\n-\n-            if not Compile_Time_Known_Value (Expr) then\n-               return False;\n-            end if;\n-\n-            Next (Comp);\n-         end loop;\n-\n-         return True;\n-      end Has_Compile_Time_Known_Expressions;\n-\n       ------------------------\n       -- Position_In_System --\n       ------------------------\n@@ -531,8 +516,8 @@ package body Sem_Dim is\n          Dimension_Name : constant Name_Id := Chars (Id);\n \n       begin\n-         for Position in System.Names'Range loop\n-            if Dimension_Name = System.Names (Position) then\n+         for Position in System.Unit_Names'Range loop\n+            if Dimension_Name = System.Unit_Names (Position) then\n                return Position;\n             end if;\n          end loop;\n@@ -550,15 +535,16 @@ package body Sem_Dim is\n       Others_Seen    : Boolean := False;\n       Position       : Nat := 0;\n       Sub_Ind        : Node_Id;\n-      Symbol         : String_Id;\n-      Symbol_Decl    : Node_Id;\n+      Symbol         : String_Id := No_String;\n+      Symbol_Expr    : Node_Id;\n       System         : System_Type;\n       Typ            : Entity_Id;\n \n       Errors_Count : Nat;\n       --  Errors_Count is a count of errors detected by the compiler so far\n-      --  just before the extraction of names and values in the aggregate\n-      --  (Step 3).\n+      --  just before the extraction of symbol, names and values in the\n+      --  aggregate\n+      --  (Step 2).\n       --\n       --  At the end of the analysis, there is a check to verify that this\n       --  count equals to Serious_Errors_Detected i.e. no erros have been\n@@ -585,18 +571,6 @@ package body Sem_Dim is\n          return;\n       end if;\n \n-      if Nkind (Aggr) /= N_Aggregate then\n-         Error_Msg_N (\"aggregate expected\", Aggr);\n-         return;\n-      end if;\n-\n-      --  Each expression in dimension aggregate must be known at compile time\n-\n-      if not Has_Compile_Time_Known_Expressions (Aggr) then\n-         Error_Msg_N (\"values of aggregate must be static\", Aggr);\n-         return;\n-      end if;\n-\n       --  The dimension declarations are useless if the parent type does not\n       --  declare a valid system.\n \n@@ -606,30 +580,88 @@ package body Sem_Dim is\n          return;\n       end if;\n \n-      --  STEP 2: Structural verification of the dimension aggregate\n+      if Nkind (Aggr) /= N_Aggregate then\n+         Error_Msg_N (\"aggregate expected\", Aggr);\n+         return;\n+      end if;\n+\n+      --  STEP 2: Symbol, Names and values extraction\n+\n+      --  Get the number of errors detected by the compiler so far\n+\n+      Errors_Count := Serious_Errors_Detected;\n+\n+      --  STEP 2a: Symbol extraction\n+\n+      --  The first entry in the aggregate may be the symbolic representation\n+      --  of the quantity.\n \n-      --  The first entry in the aggregate is the symbolic representation of\n-      --  the dimension.\n+      --  Positional symbol argument\n \n-      Symbol_Decl := First (Expressions (Aggr));\n+      Symbol_Expr := First (Expressions (Aggr));\n \n-      if No (Symbol_Decl)\n-        or else not Nkind_In (Symbol_Decl, N_Character_Literal,\n+      --  Named symbol argument\n+\n+      if No (Symbol_Expr)\n+        or else not Nkind_In (Symbol_Expr, N_Character_Literal,\n                                            N_String_Literal)\n       then\n-         Error_Msg_N (\"first argument must be character or string\", Aggr);\n-         return;\n-      end if;\n+         Symbol_Expr := Empty;\n \n-      --  STEP 3: Name and value extraction\n+         --  Component associations present\n \n-      --  Get the number of errors detected by the compiler so far\n+         if Present (Component_Associations (Aggr)) then\n+            Assoc  := First (Component_Associations (Aggr));\n+            Choice := First (Choices (Assoc));\n \n-      Errors_Count := Serious_Errors_Detected;\n+            if No (Next (Choice))\n+              and then Nkind (Choice) = N_Identifier\n+            then\n+               --  Symbol component association is present\n+\n+               if Chars (Choice) = Name_Symbol then\n+                  Num_Choices := Num_Choices + 1;\n+                  Symbol_Expr := Expression (Assoc);\n+\n+                  --  Verify symbol expression is a string or a character\n+\n+                  if not Nkind_In (Symbol_Expr, N_Character_Literal,\n+                                                N_String_Literal)\n+                  then\n+                     Symbol_Expr := Empty;\n+                     Error_Msg_N (\"symbol expression must be character or \" &\n+                                  \"string\",\n+                                  Symbol_Expr);\n+                  end if;\n+\n+               --  Special error if no Symbol choice but expression is string\n+               --  or character.\n+\n+               elsif Nkind_In (Expression (Assoc), N_Character_Literal,\n+                                                   N_String_Literal)\n+               then\n+                  Num_Choices := Num_Choices + 1;\n+                  Error_Msg_N (\"optional component Symbol expected, found&\",\n+                               Choice);\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  STEP 2b: Names and values extraction\n \n       --  Positional elements\n \n-      Expr := Next (Symbol_Decl);\n+      Expr := First (Expressions (Aggr));\n+\n+      --  Skip the symbol expression when present\n+\n+      if Present (Symbol_Expr)\n+        and then Num_Choices = 0\n+      then\n+         Expr := Next (Expr);\n+      end if;\n+\n       Position := Low_Position_Bound;\n       while Present (Expr) loop\n          if Position > High_Position_Bound then\n@@ -649,9 +681,17 @@ package body Sem_Dim is\n       --  Named elements\n \n       Assoc := First (Component_Associations (Aggr));\n+\n+      --  Skip the symbol association when present\n+\n+      if Num_Choices = 1 then\n+         Next (Assoc);\n+      end if;\n+\n       while Present (Assoc) loop\n          Expr   := Expression (Assoc);\n          Choice := First (Choices (Assoc));\n+\n          while Present (Choice) loop\n \n             --  Identifier case: NAME => EXPRESSION\n@@ -747,43 +787,56 @@ package body Sem_Dim is\n          Next (Assoc);\n       end loop;\n \n-      --  STEP 4: Consistency of system and dimensions\n+      --  STEP 3: Consistency of system and dimensions\n \n-      if Present (Next (Symbol_Decl))\n+      if Present (First (Expressions (Aggr)))\n+        and then (First (Expressions (Aggr)) /= Symbol_Expr\n+                    or else Present (Next (Symbol_Expr)))\n         and then (Num_Choices > 1\n                    or else (Num_Choices = 1 and then not Others_Seen))\n       then\n          Error_Msg_N\n            (\"named associations cannot follow positional associations\", Aggr);\n+      end if;\n \n-      elsif Num_Dimensions > System.Count then\n+      if Num_Dimensions > System.Count then\n          Error_Msg_N (\"type& has more dimensions than system allows\", Def_Id);\n \n       elsif Num_Dimensions < System.Count and then not Others_Seen then\n          Error_Msg_N (\"type& has less dimensions than system allows\", Def_Id);\n       end if;\n \n-      --  STEP 5: Dimension symbol extraction\n+      --  STEP 4: Dimension symbol extraction\n \n-      if Nkind (Symbol_Decl) = N_Character_Literal then\n-         Start_String;\n-         Store_String_Char (UI_To_CC (Char_Literal_Value (Symbol_Decl)));\n-         Symbol := End_String;\n+      if Present (Symbol_Expr) then\n+         if Nkind (Symbol_Expr) = N_Character_Literal then\n+            Start_String;\n+            Store_String_Char (UI_To_CC (Char_Literal_Value (Symbol_Expr)));\n+            Symbol := End_String;\n \n-      else\n-         Symbol := Strval (Symbol_Decl);\n-      end if;\n+         else\n+            Symbol := Strval (Symbol_Expr);\n+         end if;\n \n-      if String_Length (Symbol) = 0 and then not Exists (Dimensions) then\n-         Error_Msg_N (\"useless dimension declaration\", Aggr);\n+         if String_Length (Symbol) = 0 then\n+            Error_Msg_N (\"empty string not allowed here\", Symbol_Expr);\n+         end if;\n       end if;\n \n-      --  STEP 6: Storage of extracted values\n+      --  STEP 5: Storage of extracted values\n \n       --  Check that no errors have been detected during the analysis\n \n       if Errors_Count = Serious_Errors_Detected then\n-         if String_Length (Symbol) /= 0 then\n+         --  useless declaration\n+\n+         if Symbol = No_String\n+           and then not Exists (Dimensions)\n+         then\n+            Error_Msg_N (\"useless dimension declaration\", Aggr);\n+         end if;\n+\n+         if Symbol /= No_String then\n             Set_Symbol (Def_Id, Symbol);\n          end if;\n \n@@ -797,19 +850,19 @@ package body Sem_Dim is\n    -- Analyze_Aspect_Dimension_System --\n    -------------------------------------\n \n-   --  with Dimension_System => DIMENSION_PAIRS\n+   --  with Dimension_System => (\n+   --        DIMENSION\n+   --     [, DIMENSION]\n+   --     [, DIMENSION]\n+   --     [, DIMENSION]\n+   --     [, DIMENSION]\n+   --     [, DIMENSION]\n+   --     [, DIMENSION]);\n \n-   --  DIMENSION_PAIRS ::=\n-   --    (DIMENSION_PAIR\n-   --      [, DIMENSION_PAIR]\n-   --      [, DIMENSION_PAIR]\n-   --      [, DIMENSION_PAIR]\n-   --      [, DIMENSION_PAIR]\n-   --      [, DIMENSION_PAIR]\n-   --      [, DIMENSION_PAIR])\n-   --  DIMENSION_PAIR ::= (DIMENSION_IDENTIFIER, DIMENSION_STRING)\n-   --  DIMENSION_IDENTIFIER ::= IDENTIFIER\n-   --  DIMENSION_STRING ::= STRING_LITERAL | CHARACTER_LITERAL\n+   --  DIMENSION ::= (\n+   --    [Unit_Name   =>] IDENTIFIER,\n+   --    [Unit_Symbol =>] SYMBOL,\n+   --    [Dim_Symbol  =>] SYMBOL)\n \n    procedure Analyze_Aspect_Dimension_System\n      (N    : Node_Id;\n@@ -834,13 +887,17 @@ package body Sem_Dim is\n \n       --  Local variables\n \n-      Dim_Name     : Node_Id;\n-      Dim_Pair     : Node_Id;\n+      Assoc        : Node_Id;\n+      Choice       : Node_Id;\n+      Dim_Aggr     : Node_Id;\n       Dim_Symbol   : Node_Id;\n+      Dim_Symbols  : Symbol_Array := No_Symbols;\n       Dim_System   : System_Type  := Null_System;\n-      Names        : Name_Array   := No_Names;\n       Position     : Nat := 0;\n-      Symbols      : Symbol_Array := No_Symbols;\n+      Unit_Name    : Node_Id;\n+      Unit_Names   : Name_Array   := No_Names;\n+      Unit_Symbol  : Node_Id;\n+      Unit_Symbols : Symbol_Array := No_Symbols;\n \n       Errors_Count : Nat;\n       --  Errors_Count is a count of errors detected by the compiler so far\n@@ -877,9 +934,9 @@ package body Sem_Dim is\n \n       --  STEP 3: Name and Symbol extraction\n \n-      Dim_Pair     := First (Expressions (Aggr));\n+      Dim_Aggr     := First (Expressions (Aggr));\n       Errors_Count := Serious_Errors_Detected;\n-      while Present (Dim_Pair) loop\n+      while Present (Dim_Aggr) loop\n          Position := Position + 1;\n \n          if Position > High_Position_Bound then\n@@ -888,79 +945,175 @@ package body Sem_Dim is\n             exit;\n          end if;\n \n-         if Nkind (Dim_Pair) /= N_Aggregate then\n-            Error_Msg_N (\"aggregate expected\", Dim_Pair);\n+         if Nkind (Dim_Aggr) /= N_Aggregate then\n+            Error_Msg_N (\"aggregate expected\", Dim_Aggr);\n \n          else\n-            if Present (Component_Associations (Dim_Pair)) then\n-               Error_Msg_N (\"expected positional aggregate\", Dim_Pair);\n+            if Present (Component_Associations (Dim_Aggr))\n+              and then Present (Expressions (Dim_Aggr))\n+            then\n+               Error_Msg_N (\"mixed positional/named aggregate not allowed \" &\n+                            \"here\",\n+                            Dim_Aggr);\n+\n+            --  Verify each dimension aggregate has three arguments\n+\n+            elsif List_Length (Component_Associations (Dim_Aggr)) /= 3\n+              and then List_Length (Expressions (Dim_Aggr)) /= 3\n+            then\n+               Error_Msg_N\n+                  (\"three components expected in aggregate\", Dim_Aggr);\n \n             else\n-               if List_Length (Expressions (Dim_Pair)) = 2 then\n-                  Dim_Name := First (Expressions (Dim_Pair));\n-                  Dim_Symbol := Next (Dim_Name);\n+               --  Named dimension aggregate\n \n-                  --  Check the first argument for each pair is a name\n+               if Present (Component_Associations (Dim_Aggr)) then\n+                  --  Check first argument denotes the unit name\n \n-                  if Nkind (Dim_Name) = N_Identifier then\n-                     Names (Position) := Chars (Dim_Name);\n-                  else\n-                     Error_Msg_N (\"expected dimension name\", Dim_Name);\n+                  Assoc     := First (Component_Associations (Dim_Aggr));\n+                  Choice    := First (Choices (Assoc));\n+                  Unit_Name := Expression (Assoc);\n+\n+                  if Present (Next (Choice))\n+                    or else Nkind (Choice) /= N_Identifier\n+                  then\n+                     Error_Msg_NE (\"wrong syntax for aspect&\", Choice, Id);\n+\n+                  elsif Chars (Choice) /= Name_Unit_Name then\n+                     Error_Msg_N (\"expected Unit_Name, found&\", Choice);\n                   end if;\n \n-                  --  Check the second argument for each pair is a string or a\n-                  --  character.\n+                  --  Check the second argument denotes the unit symbol\n+\n+                  Next (Assoc);\n+                  Choice      := First (Choices (Assoc));\n+                  Unit_Symbol := Expression (Assoc);\n \n-                  if not Nkind_In\n-                           (Dim_Symbol,\n-                              N_String_Literal,\n-                              N_Character_Literal)\n+                  if Present (Next (Choice))\n+                    or else Nkind (Choice) /= N_Identifier\n                   then\n-                     Error_Msg_N (\"expected dimension string or character\",\n-                                  Dim_Symbol);\n+                     Error_Msg_NE (\"wrong syntax for aspect&\", Choice, Id);\n \n-                  else\n-                     --  String case\n+                  elsif Chars (Choice) /= Name_Unit_Symbol then\n+                     Error_Msg_N (\"expected Unit_Symbol, found&\", Choice);\n+                  end if;\n \n-                     if Nkind (Dim_Symbol) = N_String_Literal then\n-                        Symbols (Position) := Strval (Dim_Symbol);\n+                  --  Check the third argument denotes the dimension symbol\n \n-                     --  Character case\n+                  Next (Assoc);\n+                  Choice     := First (Choices (Assoc));\n+                  Dim_Symbol := Expression (Assoc);\n \n-                     else\n-                        Start_String;\n-                        Store_String_Char\n-                          (UI_To_CC (Char_Literal_Value (Dim_Symbol)));\n-                        Symbols (Position) := End_String;\n-                     end if;\n+                  if Present (Next (Choice))\n+                    or else Nkind (Choice) /= N_Identifier\n+                  then\n+                     Error_Msg_NE (\"wrong syntax for aspect&\", Choice, Id);\n \n-                     --  Verify that the string is not empty\n+                  elsif Chars (Choice) /= Name_Dim_Symbol then\n+                     Error_Msg_N (\"expected Dim_Symbol, found&\", Choice);\n+                  end if;\n \n-                     if String_Length (Symbols (Position)) = 0 then\n-                        Error_Msg_N\n-                          (\"empty string not allowed here\", Dim_Symbol);\n-                     end if;\n+               --  Positional dimension aggregate\n+\n+               else\n+                  Unit_Name   := First (Expressions (Dim_Aggr));\n+                  Unit_Symbol := Next (Unit_Name);\n+                  Dim_Symbol  := Next (Unit_Symbol);\n+               end if;\n+\n+               --  Check the first argument for each dimension aggregate is\n+               --  a name.\n+\n+               if Nkind (Unit_Name) = N_Identifier then\n+                  Unit_Names (Position) := Chars (Unit_Name);\n+               else\n+                  Error_Msg_N (\"expected unit name\", Unit_Name);\n+               end if;\n+\n+               --  Check the second argument for each dimension aggregate is\n+               --  a string or a character.\n+\n+               if not Nkind_In\n+                        (Unit_Symbol,\n+                           N_String_Literal,\n+                           N_Character_Literal)\n+               then\n+                  Error_Msg_N (\"expected unit symbol (string or character)\",\n+                               Unit_Symbol);\n+\n+               else\n+                  --  String case\n+\n+                  if Nkind (Unit_Symbol) = N_String_Literal then\n+                     Unit_Symbols (Position) := Strval (Unit_Symbol);\n+\n+                  --  Character case\n+\n+                  else\n+                     Start_String;\n+                     Store_String_Char\n+                       (UI_To_CC (Char_Literal_Value (Unit_Symbol)));\n+                     Unit_Symbols (Position) := End_String;\n                   end if;\n \n+                  --  Verify that the string is not empty\n+\n+                  if String_Length (Unit_Symbols (Position)) = 0 then\n+                     Error_Msg_N\n+                       (\"empty string not allowed here\", Unit_Symbol);\n+                  end if;\n+               end if;\n+\n+               --  Check the third argument for each dimension aggregate is\n+               --  a string or a character.\n+\n+               if not Nkind_In\n+                        (Dim_Symbol,\n+                           N_String_Literal,\n+                           N_Character_Literal)\n+               then\n+                  Error_Msg_N (\"expected dimension symbol (string or \" &\n+                               \"character)\",\n+                               Dim_Symbol);\n+\n                else\n-                  Error_Msg_N\n-                    (\"two expressions expected in aggregate\", Dim_Pair);\n+                  --  String case\n+\n+                  if Nkind (Dim_Symbol) = N_String_Literal then\n+                     Dim_Symbols (Position) := Strval (Dim_Symbol);\n+\n+                  --  Character case\n+\n+                  else\n+                     Start_String;\n+                     Store_String_Char\n+                       (UI_To_CC (Char_Literal_Value (Dim_Symbol)));\n+                     Dim_Symbols (Position) := End_String;\n+                  end if;\n+\n+                  --  Verify that the string is not empty\n+\n+                  if String_Length (Dim_Symbols (Position)) = 0 then\n+                     Error_Msg_N\n+                       (\"empty string not allowed here\", Dim_Symbol);\n+                  end if;\n                end if;\n             end if;\n          end if;\n \n-         Next (Dim_Pair);\n+         Next (Dim_Aggr);\n       end loop;\n \n       --  STEP 4: Storage of extracted values\n \n       --  Check that no errors have been detected during the analysis\n \n       if Errors_Count = Serious_Errors_Detected then\n-         Dim_System.Type_Decl := N;\n-         Dim_System.Names := Names;\n-         Dim_System.Count := Position;\n-         Dim_System.Symbols := Symbols;\n+         Dim_System.Type_Decl    := N;\n+         Dim_System.Unit_Names   := Unit_Names;\n+         Dim_System.Unit_Symbols := Unit_Symbols;\n+         Dim_System.Dim_Symbols  := Dim_Symbols;\n+         Dim_System.Count        := Position;\n          System_Table.Append (Dim_System);\n       end if;\n    end Analyze_Aspect_Dimension_System;\n@@ -1822,7 +1975,7 @@ package body Sem_Dim is\n       --  generate an error message.\n \n       if Complain and then Result = No_Rational then\n-         Error_Msg_N (\"must be a rational\", Expr);\n+         Error_Msg_N (\"rational expected\", Expr);\n       end if;\n \n       return Result;\n@@ -1846,70 +1999,16 @@ package body Sem_Dim is\n       Dimensions_Msg : Name_Id;\n       System         : System_Type;\n \n-      procedure Add_Dimension_Vector_To_Buffer\n-        (Dims   : Dimension_Type;\n-         System : System_Type);\n-      --  Given a Dims and System, add to Name_Buffer the string representation\n-      --  of a dimension vector.\n-\n-      procedure Add_Whole_To_Buffer (W : Whole);\n-      --  Add image of Whole to Name_Buffer\n-\n-      ------------------------------------\n-      -- Add_Dimension_Vector_To_Buffer --\n-      ------------------------------------\n-\n-      procedure Add_Dimension_Vector_To_Buffer\n-        (Dims   : Dimension_Type;\n-         System : System_Type)\n-      is\n-         Dim_Power : Rational;\n-         First_Dim : Boolean := True;\n-\n-      begin\n-         Add_Char_To_Name_Buffer ('(');\n-\n-         for Position in Dims_Of_N'First ..  System.Count loop\n-            Dim_Power := Dims (Position);\n-\n-            if First_Dim then\n-               First_Dim := False;\n-            else\n-               Add_Str_To_Name_Buffer (\", \");\n-            end if;\n-\n-            Add_Whole_To_Buffer (Dim_Power.Numerator);\n-\n-            if Dim_Power.Denominator /= 1 then\n-               Add_Char_To_Name_Buffer ('/');\n-               Add_Whole_To_Buffer (Dim_Power.Denominator);\n-            end if;\n-         end loop;\n-\n-         Add_Char_To_Name_Buffer (')');\n-      end Add_Dimension_Vector_To_Buffer;\n-\n-      -------------------------\n-      -- Add_Whole_To_Buffer --\n-      -------------------------\n-\n-      procedure Add_Whole_To_Buffer (W : Whole) is\n-      begin\n-         UI_Image (UI_From_Int (Int (W)));\n-         Add_Str_To_Name_Buffer (UI_Image_Buffer (1 .. UI_Image_Length));\n-      end Add_Whole_To_Buffer;\n-\n-   --  Start of processing for Dimensions_Msg_Of\n-\n    begin\n       --  Initialization of Name_Buffer\n \n       Name_Len := 0;\n \n       if Exists (Dims_Of_N) then\n          System := System_Of (Base_Type (Etype (N)));\n-         Add_Str_To_Name_Buffer (\"has dimensions \");\n-         Add_Dimension_Vector_To_Buffer (Dims_Of_N, System);\n+         Add_Str_To_Name_Buffer (\"has dimension \");\n+         Add_String_To_Name_Buffer\n+           (From_Dim_To_Str_Of_Dim_Symbols (Dims_Of_N, System, True));\n       else\n          Add_Str_To_Name_Buffer (\"is dimensionless\");\n       end if;\n@@ -2014,7 +2113,7 @@ package body Sem_Dim is\n \n          --  subtype T is Btyp_Of_L\n          --    with\n-         --      Dimension => (\"\",\n+         --      Dimension => (\n          --        Dims_Of_N (1).Numerator / Dims_Of_N (1).Denominator,\n          --        Dims_Of_N (2).Numerator / Dims_Of_N (2).Denominator,\n          --        ...\n@@ -2025,7 +2124,6 @@ package body Sem_Dim is\n \n          New_Aspects  := Empty_List;\n          List_Of_Dims := New_List;\n-         Append (Make_String_Literal (Loc, \"\"), List_Of_Dims);\n \n          for Position in Dims_Of_N'First ..  System.Count loop\n             Dim_Power := Dims_Of_N (Position);\n@@ -2133,41 +2231,61 @@ package body Sem_Dim is\n       return Sys /= Null_System;\n    end Exists;\n \n-   -------------------------------------------\n-   -- Expand_Put_Call_With_Dimension_Symbol --\n-   -------------------------------------------\n+   ---------------------------------\n+   -- Expand_Put_Call_With_Symbol --\n+   ---------------------------------\n+\n+   --  For procedure Put (resp. Put_Dim_Of) defined in\n+   --  System.Dim.Float_IO/System.Dim.Integer_IO, the default string parameter\n+   --  must be rewritten to include the unit symbols (resp. dimension symbols)\n+   --  in the output of a dimensioned object. Note that if a value is already\n+   --  supplied for parameter Symbol, this routine doesn't do anything.\n+\n+   --  Case 1. Item is dimensionless\n+\n+   --   * Put        : Item appears without a suffix\n \n-   --  For procedure Put defined in System.Dim.Float_IO/System.Dim.Integer_IO,\n-   --  the default string parameter must be rewritten to include the dimension\n-   --  symbols in the output of a dimensioned object.\n+   --   * Put_Dim_Of : the output is []\n \n-   --  Case 1: the parameter is a variable\n+   --      Obj : Mks_Type := 2.6;\n+   --      Put (Obj, 1, 1, 0);\n+   --      Put_Dim_Of (Obj);\n \n-   --  The default string parameter is replaced by the symbol defined in the\n-   --  aspect Dimension of the subtype. For instance to output a speed:\n+   --      The corresponding outputs are:\n+   --      $2.6\n+   --      $[]\n \n-   --  subtype Force is Mks_Type\n-   --    with\n-   --      Dimension => (\"N\",\n-   --        Meter =>    1,\n-   --        Kilogram => 1,\n-   --        Second =>   -2,\n-   --        others =>   0);\n-   --  F : Force := 2.1 * m * kg * s**(-2);\n-   --  Put (F);\n-   --  > 2.1 N\n+   --  Case 2. Item has a dimension\n \n-   --  Case 2: the parameter is an expression\n+   --   * Put        : If the type of Item is a dimensioned subtype whose\n+   --                  symbol is not empty, then the symbol appears as a\n+   --                  suffix. Otherwise, a new string is created and appears\n+   --                  as a suffix of Item. This string results in the\n+   --                  successive concatanations between each unit symbol\n+   --                  raised by its corresponding dimension power from the\n+   --                  dimensions of Item.\n \n-   --  In this case we call the procedure Expand_Put_Call_With_Dimension_Symbol\n-   --  that creates the string of symbols (for instance \"m.s**(-1)\") and\n-   --  rewrites the default string parameter of Put with the corresponding\n-   --  the String_Id. For instance:\n+   --   * Put_Dim_Of : The output is a new string resulting in the successive\n+   --                  concatanations between each dimension symbol raised by\n+   --                  its corresponding dimension power from the dimensions of\n+   --                  Item.\n \n-   --  Put (2.1 * m * kg * s**(-2));\n-   --  > 2.1 m.kg.s**(-2)\n+   --      subtype Random is Mks_Type\n+   --        with\n+   --         Dimension => (\n+   --           Meter =>   3,\n+   --           Candela => -1,\n+   --           others =>  0);\n \n-   procedure Expand_Put_Call_With_Dimension_Symbol (N : Node_Id) is\n+   --      Obj : Random := 5.0;\n+   --      Put (Obj);\n+   --      Put_Dim_Of (Obj);\n+\n+   --      The corresponding outputs are:\n+   --      $5.0 m**3.cd**(-1)\n+   --      $[l**3.J**(-1)]\n+\n+   procedure Expand_Put_Call_With_Symbol (N : Node_Id) is\n       Actuals        : constant List_Id := Parameter_Associations (N);\n       Loc            : constant Source_Ptr := Sloc (N);\n       Name_Call      : constant Node_Id := Name (N);\n@@ -2178,7 +2296,12 @@ package body Sem_Dim is\n       New_Str_Lit    : Node_Id := Empty;\n       System         : System_Type;\n \n-      function Has_Dimension_Symbols return Boolean;\n+      Is_Put_Dim_Of : Boolean := False;\n+      --  This flag is used in order to differentiate routines Put and\n+      --  Put_Dim_Of. Set to True if the procedure is one of the Put_Dim_Of\n+      --  defined in System.Dim.Float_IO or System.Dim.Integer_IO.\n+\n+      function Has_Symbols return Boolean;\n       --  Return True if the current Put call already has a parameter\n       --  association for parameter \"Symbols\" with the correct string of\n       --  symbols.\n@@ -2189,13 +2312,13 @@ package body Sem_Dim is\n       --  System.Dim.Integer_IO.\n \n       function Item_Actual return Node_Id;\n-      --  Return the item actual parameter node in the put call\n+      --  Return the item actual parameter node in the output call\n \n-      ---------------------------\n-      -- Has_Dimension_Symbols --\n-      ---------------------------\n+      -----------------\n+      -- Has_Symbols --\n+      -----------------\n \n-      function Has_Dimension_Symbols return Boolean is\n+      function Has_Symbols return Boolean is\n          Actual : Node_Id;\n \n       begin\n@@ -2205,7 +2328,7 @@ package body Sem_Dim is\n \n          while Present (Actual) loop\n             if Nkind (Actual) = N_Parameter_Association\n-              and then Chars (Selector_Name (Actual)) = Name_Symbols\n+              and then Chars (Selector_Name (Actual)) = Name_Symbol\n             then\n \n                --  return True if the actual comes from source or if the string\n@@ -2225,7 +2348,7 @@ package body Sem_Dim is\n          --  one.\n \n          return Nkind (Last (Actuals)) = N_String_Literal;\n-      end Has_Dimension_Symbols;\n+      end Has_Symbols;\n \n       ---------------------------\n       -- Is_Procedure_Put_Call --\n@@ -2236,8 +2359,9 @@ package body Sem_Dim is\n          Loc : Source_Ptr;\n \n       begin\n-         --  There are three different Put routines in each generic dim IO\n-         --  package. Verify the current procedure call is one of them.\n+         --  There are three different Put (resp. Put_Dim_Of) routines in each\n+         --  generic dim IO package. Verify the current procedure call is one\n+         --  of them.\n \n          if Is_Entity_Name (Name_Call) then\n             Ent := Entity (Name_Call);\n@@ -2250,14 +2374,22 @@ package body Sem_Dim is\n \n             Loc := Sloc (Ent);\n \n-            --  Check the name of the entity subprogram is Put and verify this\n-            --  entity is located in either System.Dim.Float_IO or\n-            --  System.Dim.Integer_IO.\n+            --  Check the name of the entity subprogram is Put (resp.\n+            --  Put_Dim_Of) and verify this entity is located in either\n+            --  System.Dim.Float_IO or System.Dim.Integer_IO.\n \n-            return Chars (Ent) = Name_Put\n-              and then Loc > No_Location\n+            if Loc > No_Location\n               and then Is_Dim_IO_Package_Entity\n-                         (Cunit_Entity (Get_Source_Unit (Loc)));\n+                         (Cunit_Entity (Get_Source_Unit (Loc)))\n+            then\n+               if Chars (Ent) = Name_Put_Dim_Of then\n+                  Is_Put_Dim_Of := True;\n+                  return True;\n+\n+               elsif Chars (Ent) = Name_Put then\n+                  return True;\n+               end if;\n+            end if;\n          end if;\n \n          return False;\n@@ -2298,36 +2430,61 @@ package body Sem_Dim is\n          end if;\n       end Item_Actual;\n \n-   --  Start of processing for Expand_Put_Call_With_Dimension_Symbol\n+   --  Start of processing for Expand_Put_Call_With_Symbol\n \n    begin\n-      if Is_Procedure_Put_Call and then not Has_Dimension_Symbols then\n+      if Is_Procedure_Put_Call and then not Has_Symbols then\n          Actual := Item_Actual;\n          Dims_Of_Actual := Dimensions_Of (Actual);\n          Etyp := Etype (Actual);\n \n-         --  Add the symbol as a suffix of the value if the subtype has a\n-         --  dimension symbol or if the parameter is not dimensionless.\n+         --  Put_Dim_Of case\n \n-         if Symbol_Of (Etyp) /= No_String then\n-            Start_String;\n+         if Is_Put_Dim_Of then\n+            --  Check that the item is not dimensionless\n+\n+            --  Create the new String_Literal with the new String_Id generated\n+            --  by the routine From_Dim_To_Str_Of_Dim_Symbols.\n+\n+            if Exists (Dims_Of_Actual) then\n+               System := System_Of (Base_Type (Etyp));\n+               New_Str_Lit :=\n+                 Make_String_Literal (Loc,\n+                   From_Dim_To_Str_Of_Dim_Symbols (Dims_Of_Actual, System));\n+\n+            --  If dimensionless, the output is []\n+\n+            else\n+               New_Str_Lit :=\n+                 Make_String_Literal (Loc, \"[]\");\n+            end if;\n+\n+         --  Put case\n+\n+         else\n+            --  Add the symbol as a suffix of the value if the subtype has a\n+            --  unit symbol or if the parameter is not dimensionless.\n+\n+            if Symbol_Of (Etyp) /= No_String then\n+               Start_String;\n \n-            --  Put a space between the value and the dimension\n+               --  Put a space between the value and the dimension\n \n-            Store_String_Char (' ');\n-            Store_String_Chars (Symbol_Of (Etyp));\n-            New_Str_Lit := Make_String_Literal (Loc, End_String);\n+               Store_String_Char (' ');\n+               Store_String_Chars (Symbol_Of (Etyp));\n+               New_Str_Lit := Make_String_Literal (Loc, End_String);\n \n-         --  Check that the item is not dimensionless\n+            --  Check that the item is not dimensionless\n \n-         --  Create the new String_Literal with the new String_Id generated by\n-         --  the routine From_Dimension_To_String.\n+            --  Create the new String_Literal with the new String_Id generated\n+            --  by the routine From_Dim_To_Str_Of_Unit_Symbols.\n \n-         elsif Exists (Dims_Of_Actual) then\n-            System := System_Of (Base_Type (Etyp));\n-            New_Str_Lit :=\n-              Make_String_Literal (Loc,\n-                From_Dimension_To_String_Of_Symbols (Dims_Of_Actual, System));\n+            elsif Exists (Dims_Of_Actual) then\n+               System := System_Of (Base_Type (Etyp));\n+               New_Str_Lit :=\n+                 Make_String_Literal (Loc,\n+                   From_Dim_To_Str_Of_Unit_Symbols (Dims_Of_Actual, System));\n+            end if;\n          end if;\n \n          if Present (New_Str_Lit) then\n@@ -2341,7 +2498,7 @@ package body Sem_Dim is\n                --  parameter association.\n \n                if Nkind (Actual) = N_Parameter_Association\n-                 and then Chars (Selector_Name (Actual)) /= Name_Symbols\n+                 and then Chars (Selector_Name (Actual)) /= Name_Symbol\n                then\n                   Append_To (New_Actuals,\n                      Make_Parameter_Association (Loc,\n@@ -2360,7 +2517,7 @@ package body Sem_Dim is\n \n             Append_To (New_Actuals,\n               Make_Parameter_Association (Loc,\n-                Selector_Name => Make_Identifier (Loc, Name_Symbols),\n+                Selector_Name => Make_Identifier (Loc, Name_Symbol),\n                 Explicit_Actual_Parameter => New_Str_Lit));\n \n             --  Rewrite and analyze the procedure call\n@@ -2373,22 +2530,133 @@ package body Sem_Dim is\n             Analyze (N);\n          end if;\n       end if;\n-   end Expand_Put_Call_With_Dimension_Symbol;\n+   end Expand_Put_Call_With_Symbol;\n \n-   -----------------------------------------\n-   -- From_Dimension_To_String_Of_Symbols --\n-   -----------------------------------------\n+   ------------------------------------\n+   -- From_Dim_To_Str_Of_Dim_Symbols --\n+   ------------------------------------\n \n    --  Given a dimension vector and the corresponding dimension system,\n-   --  create a String_Id to output the dimension symbols corresponding to\n-   --  the dimensions Dims.\n+   --  create a String_Id to output the dimension symbols corresponding to the\n+   --  dimensions Dims. If In_Error_Msg is True, there is a special handling\n+   --  for character asterisk * which is an insertion character in error\n+   --  messages.\n+\n+   function From_Dim_To_Str_Of_Dim_Symbols\n+     (Dims         : Dimension_Type;\n+      System       : System_Type;\n+      In_Error_Msg : Boolean := False) return String_Id\n+   is\n+      Dim_Power : Rational;\n+      First_Dim : Boolean := True;\n+\n+      procedure Store_String_Oexpon;\n+      --  Store the expon operator symbol \"**\" to the string. In error\n+      --  messages, asterisk * is a special character and must be precede by a\n+      --  quote ' to be placed literally into the message.\n+\n+      -------------------------\n+      -- Store_String_Oexpon --\n+      -------------------------\n+\n+      procedure Store_String_Oexpon is\n+      begin\n+         if In_Error_Msg then\n+            Store_String_Chars (\"'*'*\");\n+\n+         else\n+            Store_String_Chars (\"**\");\n+         end if;\n+      end Store_String_Oexpon;\n+\n+   --  Start of processing for From_Dim_To_Str_Of_Dim_Symbols\n \n-   function From_Dimension_To_String_Of_Symbols\n+   begin\n+      --  Initialization of the new String_Id\n+\n+      Start_String;\n+\n+      --  Store the dimension symbols inside boxes\n+\n+      Store_String_Char ('[');\n+\n+      for Position in Dimension_Type'Range loop\n+         Dim_Power := Dims (Position);\n+         if Dim_Power /= Zero then\n+\n+            if First_Dim then\n+               First_Dim := False;\n+            else\n+               Store_String_Char ('.');\n+            end if;\n+\n+            Store_String_Chars (System.Dim_Symbols (Position));\n+\n+            --  Positive dimension case\n+\n+            if Dim_Power.Numerator > 0 then\n+               --  Integer case\n+\n+               if Dim_Power.Denominator = 1 then\n+                  if Dim_Power.Numerator /= 1 then\n+                     Store_String_Oexpon;\n+                     Store_String_Int (Int (Dim_Power.Numerator));\n+                  end if;\n+\n+               --  Rational case when denominator /= 1\n+\n+               else\n+                  Store_String_Oexpon;\n+                  Store_String_Char ('(');\n+                  Store_String_Int (Int (Dim_Power.Numerator));\n+                  Store_String_Char ('/');\n+                  Store_String_Int (Int (Dim_Power.Denominator));\n+                  Store_String_Char (')');\n+               end if;\n+\n+            --  Negative dimension case\n+\n+            else\n+               Store_String_Oexpon;\n+               Store_String_Char ('(');\n+               Store_String_Char ('-');\n+               Store_String_Int (Int (-Dim_Power.Numerator));\n+\n+               --  Integer case\n+\n+               if Dim_Power.Denominator = 1 then\n+                  Store_String_Char (')');\n+\n+               --  Rational case when denominator /= 1\n+\n+               else\n+                  Store_String_Char ('/');\n+                  Store_String_Int (Int (Dim_Power.Denominator));\n+                  Store_String_Char (')');\n+               end if;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      Store_String_Char (']');\n+\n+      return End_String;\n+   end From_Dim_To_Str_Of_Dim_Symbols;\n+\n+   -------------------------------------\n+   -- From_Dim_To_Str_Of_Unit_Symbols --\n+   -------------------------------------\n+\n+   --  Given a dimension vector and the corresponding dimension system,\n+   --  create a String_Id to output the unit symbols corresponding to the\n+   --  dimensions Dims.\n+\n+   function From_Dim_To_Str_Of_Unit_Symbols\n      (Dims   : Dimension_Type;\n       System : System_Type) return String_Id\n    is\n-      Dimension_Power     : Rational;\n-      First_Symbol_In_Str : Boolean := True;\n+      Dim_Power : Rational;\n+      First_Dim : Boolean := True;\n \n    begin\n       --  Initialization of the new String_Id\n@@ -2400,77 +2668,65 @@ package body Sem_Dim is\n       Store_String_Char (' ');\n \n       for Position in Dimension_Type'Range loop\n-         Dimension_Power := Dims (Position);\n-         if Dimension_Power /= Zero then\n+         Dim_Power := Dims (Position);\n+         if Dim_Power /= Zero then\n \n-            if First_Symbol_In_Str then\n-               First_Symbol_In_Str := False;\n+            if First_Dim then\n+               First_Dim := False;\n             else\n                Store_String_Char ('.');\n             end if;\n \n-            --  Positive dimension case\n+            Store_String_Chars (System.Unit_Symbols (Position));\n \n-            if Dimension_Power.Numerator > 0 then\n-               if System.Symbols (Position) = No_String then\n-                  Store_String_Chars\n-                    (Get_Name_String (System.Names (Position)));\n-               else\n-                  Store_String_Chars (System.Symbols (Position));\n-               end if;\n+            --  Positive dimension case\n \n+            if Dim_Power.Numerator > 0 then\n                --  Integer case\n \n-               if Dimension_Power.Denominator = 1 then\n-                  if Dimension_Power.Numerator /= 1 then\n+               if Dim_Power.Denominator = 1 then\n+                  if Dim_Power.Numerator /= 1 then\n                      Store_String_Chars (\"**\");\n-                     Store_String_Int (Int (Dimension_Power.Numerator));\n+                     Store_String_Int (Int (Dim_Power.Numerator));\n                   end if;\n \n                --  Rational case when denominator /= 1\n \n                else\n                   Store_String_Chars (\"**\");\n                   Store_String_Char ('(');\n-                  Store_String_Int (Int (Dimension_Power.Numerator));\n+                  Store_String_Int (Int (Dim_Power.Numerator));\n                   Store_String_Char ('/');\n-                  Store_String_Int (Int (Dimension_Power.Denominator));\n+                  Store_String_Int (Int (Dim_Power.Denominator));\n                   Store_String_Char (')');\n                end if;\n \n             --  Negative dimension case\n \n             else\n-               if System.Symbols (Position) = No_String then\n-                  Store_String_Chars\n-                    (Get_Name_String (System.Names (Position)));\n-               else\n-                  Store_String_Chars (System.Symbols (Position));\n-               end if;\n-\n                Store_String_Chars (\"**\");\n                Store_String_Char ('(');\n                Store_String_Char ('-');\n-               Store_String_Int (Int (-Dimension_Power.Numerator));\n+               Store_String_Int (Int (-Dim_Power.Numerator));\n \n                --  Integer case\n \n-               if Dimension_Power.Denominator = 1 then\n+               if Dim_Power.Denominator = 1 then\n                   Store_String_Char (')');\n \n                --  Rational case when denominator /= 1\n \n                else\n                   Store_String_Char ('/');\n-                  Store_String_Int (Int (Dimension_Power.Denominator));\n+                  Store_String_Int (Int (Dim_Power.Denominator));\n                   Store_String_Char (')');\n                end if;\n             end if;\n          end if;\n       end loop;\n \n       return End_String;\n-   end From_Dimension_To_String_Of_Symbols;\n+   end From_Dim_To_Str_Of_Unit_Symbols;\n \n    ---------\n    -- GCD --\n@@ -2700,5 +2956,4 @@ package body Sem_Dim is\n \n       return Null_System;\n    end System_Of;\n-\n end Sem_Dim;"}, {"sha": "3799651a0722fb38a6da1371d1503ff082518179", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -137,7 +137,7 @@ package Sem_Dim is\n    --  restricted to Integer exponent. This routine deals only with rational\n    --  exponent which is not an integer if Btyp is a dimensioned type.\n \n-   procedure Expand_Put_Call_With_Dimension_Symbol (N : Node_Id);\n+   procedure Expand_Put_Call_With_Symbol (N : Node_Id);\n    --  Determine whether N denotes a subprogram call to one of the routines\n    --  defined in System.Dim.Float_IO or System.Dim.Integer_IO and add an\n    --  extra actual to the call to represent the symbolic representation of"}, {"sha": "3d1bd14eb7c13974b0ba083de60704980448af42", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -724,6 +724,14 @@ package body Sem_Elim is\n       Enclosing_Subp : Entity_Id;\n \n    begin\n+      --  No check needed within a default expression for a formal, since this\n+      --  is not really a use, and the expression (a call or attribute) may\n+      --  never be used if the enclosing subprogram is itself eliminated.\n+\n+      if In_Spec_Expression then\n+         return;\n+      end if;\n+\n       if Is_Eliminated (Ultimate_Subp)\n         and then not Inside_A_Generic\n         and then not Is_Generic_Unit (Cunit_Entity (Current_Sem_Unit))\n@@ -823,10 +831,10 @@ package body Sem_Elim is\n       Arg_Uname : Node_Id;\n \n       function OK_Selected_Component (N : Node_Id) return Boolean;\n-      --  Test if N is a selected component with all identifiers, or a\n-      --  selected component whose selector is an operator symbol. As a\n-      --  side effect if result is True, sets Num_Names to the number\n-      --  of names present (identifiers and operator if any).\n+      --  Test if N is a selected component with all identifiers, or a selected\n+      --  component whose selector is an operator symbol. As a side effect if\n+      --  result is True, sets Num_Names to the number of names present\n+      --  (identifiers, and operator if any).\n \n       ---------------------------\n       -- OK_Selected_Component --"}, {"sha": "28832237997a80b766a7d8c94c3331208136c479", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -5839,14 +5839,11 @@ package body Sem_Res is\n          Check_Restriction (No_Relative_Delay, N);\n       end if;\n \n-      --  Issue an error for a call to an eliminated subprogram. We skip this\n-      --  in a spec expression, e.g. a call in a default parameter value, since\n-      --  we are not really doing a call at this time. That's important because\n-      --  the spec expression may itself belong to an eliminated subprogram.\n+      --  Issue an error for a call to an eliminated subprogram.\n+      --  The routine will not perform the check if the call appears within\n+      --  a default expression.\n \n-      if not In_Spec_Expression then\n-         Check_For_Eliminated_Subprogram (Subp, Nam);\n-      end if;\n+      Check_For_Eliminated_Subprogram (Subp, Nam);\n \n       --  In formal mode, the primitive operations of a tagged type or type\n       --  extension do not include functions that return the tagged type."}, {"sha": "bffc4207619498026b98e27e53e1ce6aaf3a9549", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df3781485406ededf60d901bbcbbcbeeaf0529b9/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=df3781485406ededf60d901bbcbbcbeeaf0529b9", "patch": "@@ -225,9 +225,12 @@ package Snames is\n    --  Names used by the analyzer and expander for aspect Dimension and\n    --  Dimension_System to deal with Sqrt and IO routines.\n \n-   Name_Item                         : constant Name_Id := N + $; -- Ada 12\n-   Name_Sqrt                         : constant Name_Id := N + $; -- Ada 12\n-   Name_Symbols                      : constant Name_Id := N + $; -- Ada 12\n+   Name_Dim_Symbol                     : constant Name_Id := N + $; -- Ada 12\n+   Name_Item                           : constant Name_Id := N + $; -- Ada 12\n+   Name_Put_Dim_Of                     : constant Name_Id := N + $; -- Ada 12\n+   Name_Sqrt                           : constant Name_Id := N + $; -- Ada 12\n+   Name_Symbol                         : constant Name_Id := N + $; -- Ada 12\n+   Name_Unit_Symbol                    : constant Name_Id := N + $; -- Ada 12\n \n    --  Some miscellaneous names used for error detection/recovery\n "}]}