{"sha": "dbb5c281c6d3f675b4df1be7398c54167097c86e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiNWMyODFjNmQzZjY3NWI0ZGYxYmU3Mzk4YzU0MTY3MDk3Yzg2ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-05-02T22:54:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-05-02T22:54:03Z"}, "message": "Revert my previous store_constructor* change\n\nFrom-SVN: r81417", "tree": {"sha": "ab13fabb458448d0d784610ad533cae3643601b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab13fabb458448d0d784610ad533cae3643601b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbb5c281c6d3f675b4df1be7398c54167097c86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb5c281c6d3f675b4df1be7398c54167097c86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb5c281c6d3f675b4df1be7398c54167097c86e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb5c281c6d3f675b4df1be7398c54167097c86e/comments", "author": null, "committer": null, "parents": [{"sha": "02c672d58bc5de8dd7b10401ab37eebadf2cfbf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c672d58bc5de8dd7b10401ab37eebadf2cfbf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02c672d58bc5de8dd7b10401ab37eebadf2cfbf6"}], "stats": {"total": 67, "additions": 25, "deletions": 42}, "files": [{"sha": "3d7dd82f4ddc5094f885c35da7b56dca5e684967", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb5c281c6d3f675b4df1be7398c54167097c86e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb5c281c6d3f675b4df1be7398c54167097c86e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbb5c281c6d3f675b4df1be7398c54167097c86e", "patch": "@@ -194,12 +194,6 @@\n \t(EXTRA_SPECS): Don't use CPP_*ARCH*_SPEC.\n \t(FPUTYPE_DEFAULT): Don't define here.\n \n-2004-04-30  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\n-\t* expr.c (store_constructor): SIZE operand is now in bits; CLEARED\n-\tless than zero now means emitted CLOBBER already.\n-\t(store_constructor_field, expand_expr_real): Reflect above changes.\n-\n 2004-04-30  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* flow.c (propagate_one_insn): Call mark_set_regs for stack pointer"}, {"sha": "e8c3ab53c81e437aa6ec1622ccca511990d05398", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb5c281c6d3f675b4df1be7398c54167097c86e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb5c281c6d3f675b4df1be7398c54167097c86e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dbb5c281c6d3f675b4df1be7398c54167097c86e", "patch": "@@ -4515,7 +4515,7 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \t  set_mem_alias_set (target, alias_set);\n \t}\n \n-      store_constructor (exp, target, cleared, bitsize);\n+      store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n     store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n@@ -4525,10 +4525,8 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM; we know it cannot conflict, since\n    safe_from_p has been called.\n-   CLEARED is positive if TARGET is known to have been zeroed, zero if\n-   this is the top level of calls to store_constructor, and negative\n-   if this is a recursive call but no clearing has been done.\n-   SIZE is the number of bits of TARGET we are allowed to modify: this\n+   CLEARED is true if TARGET is known to have been zero'd.\n+   SIZE is the number of bytes of TARGET we are allowed to modify: this\n    may not be the same as the size of EXP if we are assigning to a field\n    which has been packed to exclude padding bits.  */\n \n@@ -4545,19 +4543,16 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n     {\n       tree elt;\n \n-      /* If this is not the top level, we don't do any initialization.  */\n-      if (cleared)\n-\t;\n-      /* If the size is zero, pretend we've cleared it.  */\n-      else if (size == 0)\n+      /* If size is zero or the target is already cleared, do nothing.  */\n+      if (size == 0 || cleared)\n \tcleared = 1;\n       /* We either clear the aggregate or indicate the value is dead.  */\n       else if ((TREE_CODE (type) == UNION_TYPE\n \t\t|| TREE_CODE (type) == QUAL_UNION_TYPE)\n \t       && ! CONSTRUCTOR_ELTS (exp))\n \t/* If the constructor is empty, clear the union.  */\n \t{\n-\t  clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n+\t  clear_storage (target, expr_size (exp));\n \t  cleared = 1;\n \t}\n \n@@ -4580,7 +4575,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       else if (((list_length (CONSTRUCTOR_ELTS (exp)) != fields_length (type))\n \t\t|| mostly_zeros_p (exp))\n \t       && (GET_CODE (target) != REG\n-\t\t   || ((HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target))\n+\t\t   || ((HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target))\n \t\t       == size)))\n \t{\n \t  rtx xtarget = target;\n@@ -4591,14 +4586,12 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      RTX_UNCHANGING_P (xtarget) = 1;\n \t    }\n \n-\t  clear_storage (xtarget, GEN_INT (size / BITS_PER_UNIT));\n+\t  clear_storage (xtarget, GEN_INT (size));\n \t  cleared = 1;\n \t}\n-      else\n-\t{\n-\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n-\t  cleared = -1;\n-\t}\n+\n+      if (! cleared)\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* Store each element of the constructor into\n \t the corresponding field of TARGET.  */\n@@ -4619,7 +4612,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  if (field == 0)\n \t    continue;\n \n-\t  if (cleared > 0 && is_zeros_p (value))\n+\t  if (cleared && is_zeros_p (value))\n \t    continue;\n \n \t  if (host_integerp (DECL_SIZE (field), 1))\n@@ -4830,17 +4823,13 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      if (REG_P (target))\n \t\temit_move_insn (target,  CONST0_RTX (GET_MODE (target)));\n \t      else\n-\t\tclear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n-\n-\t      cleared = 1;\n+\t\tclear_storage (target, GEN_INT (size));\n \t    }\n+\t  cleared = 1;\n \t}\n       else if (REG_P (target))\n-\t{\n-\t  /* Inform later passes that the old value is dead.  */\n-\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n-\t  cleared = -1;\n-\t}\n+\t/* Inform later passes that the old value is dead.  */\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* Store each element of the constructor into\n \t the corresponding element of TARGET, determined\n@@ -4857,7 +4846,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n-\t  if (cleared > 0 && is_zeros_p (value))\n+\t  if (cleared && is_zeros_p (value))\n \t    continue;\n \n \t  unsignedp = TYPE_UNSIGNED (elttype);\n@@ -4951,7 +4940,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t    highest_pow2_factor (position));\n \t\t  xtarget = adjust_address (xtarget, mode, 0);\n \t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n-\t\t    store_constructor (value, xtarget, cleared, bitsize);\n+\t\t    store_constructor (value, xtarget, cleared,\n+\t\t\t\t       bitsize / BITS_PER_UNIT);\n \t\t  else\n \t\t    store_expr (value, xtarget, 0);\n \n@@ -5049,8 +5039,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       /* Check for all zeros.  */\n       if (elt == NULL_TREE && size > 0)\n \t{\n-\t  if (cleared <= 0)\n-\t    clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n+\t  if (!cleared)\n+\t    clear_storage (target, GEN_INT (size));\n \t  return;\n \t}\n \n@@ -5090,7 +5080,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      bit_pos++;  ibit++;\n \t      if (bit_pos >= set_word_size || ibit == nbits)\n \t\t{\n-\t\t  if (word != 0 || cleared <= 0)\n+\t\t  if (word != 0 || ! cleared)\n \t\t    {\n \t\t      rtx datum = gen_int_mode (word, mode);\n \t\t      rtx to_rtx;\n@@ -5115,7 +5105,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t}\n \t    }\n \t}\n-      else if (cleared <= 0)\n+      else if (!cleared)\n \t/* Don't bother clearing storage if the set is all ones.  */\n \tif (TREE_CHAIN (elt) != NULL_TREE\n \t    || (TREE_PURPOSE (elt) == NULL_TREE\n@@ -5125,7 +5115,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t   || (tree_low_cst (TREE_VALUE (elt), 0)\n \t\t       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1\n \t\t       != (HOST_WIDE_INT) nbits))))\n-\t  clear_storage (target, GEN_INT (size / BITS_PER_UNIT));\n+\t  clear_storage (target, expr_size (exp));\n \n       for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n \t{\n@@ -6753,8 +6743,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n \t\t\t     0, TREE_ADDRESSABLE (exp), 1);\n \n-\t  store_constructor (exp, target, 0,\n-\t\t\t     int_expr_size (exp) * BITS_PER_UNIT);\n+\t  store_constructor (exp, target, 0, int_expr_size (exp));\n \t  return target;\n \t}\n "}]}