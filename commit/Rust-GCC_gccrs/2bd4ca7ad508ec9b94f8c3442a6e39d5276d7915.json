{"sha": "2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJkNGNhN2FkNTA4ZWM5Yjk0ZjhjMzQ0MmE2ZTM5ZDUyNzZkNzkxNQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2018-09-28T10:54:34Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2018-09-28T10:54:34Z"}, "message": "Simplify vec_merge according to the mask.\n\nThis patch was part of the original patch we acquired from Honza and Martin.\n\nIt simplifies nested vec_merge operations using the same mask.\n\nSelf-tests are included.\n\n2018-09-28  Andrew Stubbs  <ams@codesourcery.com>\n\t    Jan Hubicka  <jh@suse.cz>\n\t    Martin Jambor  <mjambor@suse.cz>\n\n\t* simplify-rtx.c (simplify_merge_mask): New function.\n\t(simplify_ternary_operation): Use it, also see if VEC_MERGEs with the\n\tsame masks are used in op1 or op2.\n\t(test_vec_merge): New function.\n\t(test_vector_ops): Call test_vec_merge.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r264688", "tree": {"sha": "781b4e29be46dc92429d9d9fc342d8f4e12d388f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/781b4e29be46dc92429d9d9fc342d8f4e12d388f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "227efe870043c9e8b4c58a702e90698b2970ff75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227efe870043c9e8b4c58a702e90698b2970ff75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227efe870043c9e8b4c58a702e90698b2970ff75"}], "stats": {"total": 146, "additions": 146, "deletions": 0}, "files": [{"sha": "5b685e4243322452b20eb0ab7d57f1d66e51ea01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "patch": "@@ -1,3 +1,13 @@\n+2018-09-28  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* simplify-rtx.c (simplify_merge_mask): New function.\n+\t(simplify_ternary_operation): Use it, also see if VEC_MERGEs with the\n+\tsame masks are used in op1 or op2.\n+\t(test_vec_merge): New function.\n+\t(test_vector_ops): Call test_vec_merge.\n+\n 2018-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc-protos.h (sparc_branch_cost): Declare."}, {"sha": "9bc53866b9f12e33ee49d5570073646637b11b46", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=2bd4ca7ad508ec9b94f8c3442a6e39d5276d7915", "patch": "@@ -5578,6 +5578,68 @@ simplify_cond_clz_ctz (rtx x, rtx_code cmp_code, rtx true_val, rtx false_val)\n   return NULL_RTX;\n }\n \n+/* Try to simplify X given that it appears within operand OP of a\n+   VEC_MERGE operation whose mask is MASK.  X need not use the same\n+   vector mode as the VEC_MERGE, but it must have the same number of\n+   elements.\n+\n+   Return the simplified X on success, otherwise return NULL_RTX.  */\n+\n+rtx\n+simplify_merge_mask (rtx x, rtx mask, int op)\n+{\n+  gcc_assert (VECTOR_MODE_P (GET_MODE (x)));\n+  poly_uint64 nunits = GET_MODE_NUNITS (GET_MODE (x));\n+  if (GET_CODE (x) == VEC_MERGE && rtx_equal_p (XEXP (x, 2), mask))\n+    {\n+      if (side_effects_p (XEXP (x, 1 - op)))\n+\treturn NULL_RTX;\n+\n+      return XEXP (x, op);\n+    }\n+  if (UNARY_P (x)\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 0)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 0))), nunits))\n+    {\n+      rtx top0 = simplify_merge_mask (XEXP (x, 0), mask, op);\n+      if (top0)\n+\treturn simplify_gen_unary (GET_CODE (x), GET_MODE (x), top0,\n+\t\t\t\t   GET_MODE (XEXP (x, 0)));\n+    }\n+  if (BINARY_P (x)\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 0)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 0))), nunits)\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 1)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 1))), nunits))\n+    {\n+      rtx top0 = simplify_merge_mask (XEXP (x, 0), mask, op);\n+      rtx top1 = simplify_merge_mask (XEXP (x, 1), mask, op);\n+      if (top0 || top1)\n+\treturn simplify_gen_binary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t    top0 ? top0 : XEXP (x, 0),\n+\t\t\t\t    top1 ? top1 : XEXP (x, 1));\n+    }\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 0)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 0))), nunits)\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 1)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 1))), nunits)\n+      && VECTOR_MODE_P (GET_MODE (XEXP (x, 2)))\n+      && known_eq (GET_MODE_NUNITS (GET_MODE (XEXP (x, 2))), nunits))\n+    {\n+      rtx top0 = simplify_merge_mask (XEXP (x, 0), mask, op);\n+      rtx top1 = simplify_merge_mask (XEXP (x, 1), mask, op);\n+      rtx top2 = simplify_merge_mask (XEXP (x, 2), mask, op);\n+      if (top0 || top1 || top2)\n+\treturn simplify_gen_ternary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t     GET_MODE (XEXP (x, 0)),\n+\t\t\t\t     top0 ? top0 : XEXP (x, 0),\n+\t\t\t\t     top1 ? top1 : XEXP (x, 1),\n+\t\t\t\t     top2 ? top2 : XEXP (x, 2));\n+    }\n+  return NULL_RTX;\n+}\n+\n \f\n /* Simplify CODE, an operation with result mode MODE and three operands,\n    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became\n@@ -5967,6 +6029,16 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  && !side_effects_p (op2) && !side_effects_p (op1))\n \treturn op0;\n \n+      if (!side_effects_p (op2))\n+\t{\n+\t  rtx top0 = simplify_merge_mask (op0, op2, 0);\n+\t  rtx top1 = simplify_merge_mask (op1, op2, 1);\n+\t  if (top0 || top1)\n+\t    return simplify_gen_ternary (code, mode, mode,\n+\t\t\t\t\t top0 ? top0 : op0,\n+\t\t\t\t\t top1 ? top1 : op1, op2);\n+\t}\n+\n       break;\n \n     default:\n@@ -6856,6 +6928,69 @@ test_vector_ops_series (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t    constm1_rtx));\n }\n \n+/* Verify simplify_merge_mask works correctly.  */\n+\n+static void\n+test_vec_merge (machine_mode mode)\n+{\n+  rtx op0 = make_test_reg (mode);\n+  rtx op1 = make_test_reg (mode);\n+  rtx op2 = make_test_reg (mode);\n+  rtx op3 = make_test_reg (mode);\n+  rtx op4 = make_test_reg (mode);\n+  rtx op5 = make_test_reg (mode);\n+  rtx mask1 = make_test_reg (SImode);\n+  rtx mask2 = make_test_reg (SImode);\n+  rtx vm1 = gen_rtx_VEC_MERGE (mode, op0, op1, mask1);\n+  rtx vm2 = gen_rtx_VEC_MERGE (mode, op2, op3, mask1);\n+  rtx vm3 = gen_rtx_VEC_MERGE (mode, op4, op5, mask1);\n+\n+  /* Simple vec_merge.  */\n+  ASSERT_EQ (op0, simplify_merge_mask (vm1, mask1, 0));\n+  ASSERT_EQ (op1, simplify_merge_mask (vm1, mask1, 1));\n+  ASSERT_EQ (NULL_RTX, simplify_merge_mask (vm1, mask2, 0));\n+  ASSERT_EQ (NULL_RTX, simplify_merge_mask (vm1, mask2, 1));\n+\n+  /* Nested vec_merge.\n+     It's tempting to make this simplify right down to opN, but we don't\n+     because all the simplify_* functions assume that the operands have\n+     already been simplified.  */\n+  rtx nvm = gen_rtx_VEC_MERGE (mode, vm1, vm2, mask1);\n+  ASSERT_EQ (vm1, simplify_merge_mask (nvm, mask1, 0));\n+  ASSERT_EQ (vm2, simplify_merge_mask (nvm, mask1, 1));\n+\n+  /* Intermediate unary op. */\n+  rtx unop = gen_rtx_NOT (mode, vm1);\n+  ASSERT_RTX_EQ (gen_rtx_NOT (mode, op0),\n+\t\t simplify_merge_mask (unop, mask1, 0));\n+  ASSERT_RTX_EQ (gen_rtx_NOT (mode, op1),\n+\t\t simplify_merge_mask (unop, mask1, 1));\n+\n+  /* Intermediate binary op. */\n+  rtx binop = gen_rtx_PLUS (mode, vm1, vm2);\n+  ASSERT_RTX_EQ (gen_rtx_PLUS (mode, op0, op2), \n+\t\t simplify_merge_mask (binop, mask1, 0));\n+  ASSERT_RTX_EQ (gen_rtx_PLUS (mode, op1, op3),\n+\t\t simplify_merge_mask (binop, mask1, 1));\n+\n+  /* Intermediate ternary op. */\n+  rtx tenop = gen_rtx_FMA (mode, vm1, vm2, vm3);\n+  ASSERT_RTX_EQ (gen_rtx_FMA (mode, op0, op2, op4),\n+\t\t simplify_merge_mask (tenop, mask1, 0));\n+  ASSERT_RTX_EQ (gen_rtx_FMA (mode, op1, op3, op5),\n+\t\t simplify_merge_mask (tenop, mask1, 1));\n+\n+  /* Side effects.  */\n+  rtx badop0 = gen_rtx_PRE_INC (mode, op0);\n+  rtx badvm = gen_rtx_VEC_MERGE (mode, badop0, op1, mask1);\n+  ASSERT_EQ (badop0, simplify_merge_mask (badvm, mask1, 0));\n+  ASSERT_EQ (NULL_RTX, simplify_merge_mask (badvm, mask1, 1));\n+\n+  /* Called indirectly.  */\n+  ASSERT_RTX_EQ (gen_rtx_VEC_MERGE (mode, op0, op3, mask1),\n+\t\t simplify_rtx (nvm));\n+}\n+\n /* Verify some simplifications involving vectors.  */\n \n static void\n@@ -6871,6 +7006,7 @@ test_vector_ops ()\n \t  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n \t      && maybe_gt (GET_MODE_NUNITS (mode), 2))\n \t    test_vector_ops_series (mode, scalar_reg);\n+\t  test_vec_merge (mode);\n \t}\n     }\n }"}]}