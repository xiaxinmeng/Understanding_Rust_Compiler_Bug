{"sha": "29a7d776ea22f0c3120f6ed2866af6649778c16a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhN2Q3NzZlYTIyZjBjMzEyMGY2ZWQyODY2YWY2NjQ5Nzc4YzE2YQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-12-03T08:54:18Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-12-03T08:54:18Z"}, "message": "re PR fortran/37336 ([F03] Finish derived-type finalization)\n\n2012-11-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/37336\n        * class.c (finalizer_insert_packed_call): New static function.\n        (finalize_component, generate_finalization_wrapper):\n        Fix coarray handling and packing.\n\nFrom-SVN: r194075", "tree": {"sha": "99502cdd2cf81c8eeb8dcb817c4004ee700ecdaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99502cdd2cf81c8eeb8dcb817c4004ee700ecdaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a7d776ea22f0c3120f6ed2866af6649778c16a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a7d776ea22f0c3120f6ed2866af6649778c16a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a7d776ea22f0c3120f6ed2866af6649778c16a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a7d776ea22f0c3120f6ed2866af6649778c16a/comments", "author": null, "committer": null, "parents": [{"sha": "9cc263b8526c272221d81af96869b6f7c7f28072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc263b8526c272221d81af96869b6f7c7f28072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc263b8526c272221d81af96869b6f7c7f28072"}], "stats": {"total": 555, "additions": 450, "deletions": 105}, "files": [{"sha": "84b085a4d7ed7b790d33bc0680ff5fe450f0df6d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a7d776ea22f0c3120f6ed2866af6649778c16a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a7d776ea22f0c3120f6ed2866af6649778c16a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=29a7d776ea22f0c3120f6ed2866af6649778c16a", "patch": "@@ -1,11 +1,18 @@\n+2012-11-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/37336\n+\t* class.c (finalizer_insert_packed_call): New static function.\n+\t(finalize_component, generate_finalization_wrapper):\n+\tFix coarray handling and packing.\n+\n 2012-12-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \t* resolve.c (resolve_allocate_deallocate,\n \tresolve_typebound_intrinsic_op): Recover revisions 193568 and\n \t193778, which were accidentally reverted by the previous patch.\n \n 2012-12-01   Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n-             Paul Thomas  <pault@gcc.gnu.org>\n+\t     Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/46897\n \t* gfortran.h : Add bit field 'defined_assign_comp' to"}, {"sha": "1271300900b9d2c4ed00fc350b1e773978fea219", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 442, "deletions": 104, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a7d776ea22f0c3120f6ed2866af6649778c16a/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a7d776ea22f0c3120f6ed2866af6649778c16a/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=29a7d776ea22f0c3120f6ed2866af6649778c16a", "patch": "@@ -731,7 +731,7 @@ has_finalizer_component (gfc_symbol *derived)\n \n static void\n finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n-\t\t    gfc_expr *stat, gfc_code **code)\n+\t\t    gfc_symbol *stat, gfc_symbol *fini_coarray, gfc_code **code)\n {\n   gfc_expr *e;\n   gfc_ref *ref;\n@@ -779,22 +779,48 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n       e->rank = ref->next->u.ar.as->rank;\n     }\n \n+  /* Call DEALLOCATE (comp, stat=ignore).  */\n   if (comp->attr.allocatable\n       || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n \t  && CLASS_DATA (comp)->attr.allocatable))\n     {\n-      /* Call DEALLOCATE (comp, stat=ignore).  */\n-      gfc_code *dealloc;\n+      gfc_code *dealloc, *block = NULL;\n+\n+      /* Add IF (fini_coarray).  */\n+      if (comp->attr.codimension\n+\t  || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t      && CLASS_DATA (comp)->attr.allocatable))\n+\t{\n+\t  block = XCNEW (gfc_code);\n+\t  if (*code)\n+\t    {\n+\t      (*code)->next = block;\n+\t      (*code) = (*code)->next;\n+\t    }\n+\t  else\n+\t      (*code) = block;\n+\n+\t  block->loc = gfc_current_locus;\n+\t  block->op = EXEC_IF;\n+\n+\t  block->block = XCNEW (gfc_code);\n+\t  block = block->block;\n+\t  block->loc = gfc_current_locus;\n+\t  block->op = EXEC_IF;\n+\t  block->expr1 = gfc_lval_expr_from_sym (fini_coarray);\n+\t}\n \n       dealloc = XCNEW (gfc_code);\n       dealloc->op = EXEC_DEALLOCATE;\n       dealloc->loc = gfc_current_locus;\n \n       dealloc->ext.alloc.list = gfc_get_alloc ();\n       dealloc->ext.alloc.list->expr = e;\n+      dealloc->expr1 = gfc_lval_expr_from_sym (stat);\n \n-      dealloc->expr1 = stat;\n-      if (*code)\n+      if (block)\n+\tblock->next = dealloc;\n+      else if (*code)\n \t{\n \t  (*code)->next = dealloc;\n \t  (*code) = (*code)->next;\n@@ -839,20 +865,19 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n       gfc_component *c;\n \n       for (c = comp->ts.u.derived->components; c; c = c->next)\n-\tfinalize_component (e, c->ts.u.derived, c, stat, code);\n+\tfinalize_component (e, comp->ts.u.derived, c, stat, fini_coarray, code);\n       gfc_free_expr (e);\n     }\n }\n \n \n /* Generate code equivalent to\n    CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t     + idx * STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE., c_ptr),\n-\t\t     ptr).  */\n+\t\t     + idx * stride, c_ptr), ptr).  */\n \n static gfc_code *\n finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n-\t\t\t gfc_namespace *sub_ns)\n+\t\t\t gfc_expr *stride, gfc_namespace *sub_ns)\n {\n   gfc_code *block;\n   gfc_expr *expr, *expr2, *expr3;\n@@ -919,40 +944,13 @@ finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n   expr->ts.kind = gfc_index_integer_kind;\n   expr2->value.function.actual->expr = expr;\n \n-  /* STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE.  */\n-  block->ext.actual->expr = gfc_get_expr ();\n-  expr = block->ext.actual->expr;\n-  expr->expr_type = EXPR_OP;\n-  expr->value.op.op = INTRINSIC_DIVIDE;\n-\n-  /* STORAGE_SIZE (array,kind=c_intptr_t).  */\n-  expr->value.op.op1 = gfc_get_expr ();\n-  expr->value.op.op1->expr_type = EXPR_FUNCTION;\n-  expr->value.op.op1->value.function.isym\n-\t\t= gfc_intrinsic_function_by_id (GFC_ISYM_STORAGE_SIZE);\n-  gfc_get_sym_tree (\"storage_size\", sub_ns, &expr->value.op.op1->symtree,\n-\t\t    false);\n-  expr->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n-  expr->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n-  gfc_commit_symbol (expr->value.op.op1->symtree->n.sym);\n-  expr->value.op.op1->value.function.actual = gfc_get_actual_arglist ();\n-  expr->value.op.op1->value.function.actual->expr\n-\t\t= gfc_lval_expr_from_sym (array);\n-  expr->value.op.op1->value.function.actual->next = gfc_get_actual_arglist ();\n-  expr->value.op.op1->value.function.actual->next->expr\n-\t\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n-  expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n-\t\t\t\t\t gfc_character_storage_size);\n-  expr->value.op.op1->ts = expr->value.op.op2->ts;\n-  expr->ts = expr->value.op.op1->ts;\n-\n-  /* Offset calculation: idx * (STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE).  */\n+  /* Offset calculation: idx * stride (in bytes).  */\n   block->ext.actual->expr = gfc_get_expr ();\n   expr3 = block->ext.actual->expr;\n   expr3->expr_type = EXPR_OP;\n   expr3->value.op.op = INTRINSIC_TIMES;\n   expr3->value.op.op1 = gfc_lval_expr_from_sym (idx);\n-  expr3->value.op.op2 = expr;\n+  expr3->value.op.op2 = stride;\n   expr3->ts = expr->ts;\n \n   /* <array addr> + <offset>.  */\n@@ -972,26 +970,294 @@ finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n }\n \n \n+/* Insert code of the following form:\n+\n+   if (stride == STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n+       || 0 == STORAGE_SIZE (array)) then\n+     call final_rank3 (array)\n+   else\n+     block\n+       type(t) :: tmp(shape (array))\n+\n+       do i = 0, size (array)-1\n+\t addr = transfer (c_loc (array), addr) + i * stride\n+\t call c_f_pointer (transfer (addr, cptr), ptr)\n+\n+\t addr = transfer (c_loc (tmp), addr)\n+\t\t\t  + i * STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n+\t call c_f_pointer (transfer (addr, cptr), ptr2)\n+\t ptr2 = ptr\n+       end do\n+       call final_rank3 (tmp)\n+     end block\n+   end if  */\n+\n+static void\n+finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n+\t\t\t      gfc_symbol *array, gfc_symbol *stride,\n+\t\t\t      gfc_symbol *idx, gfc_symbol *ptr,\n+\t\t\t      gfc_symbol *nelem, gfc_symtree *size_intr,\n+\t\t\t      gfc_namespace *sub_ns)\n+{\n+  gfc_symbol *tmp_array, *ptr2;\n+  gfc_expr *size_expr;\n+  gfc_namespace *ns;\n+  gfc_iterator *iter;\n+  int i;\n+\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->loc = gfc_current_locus;\n+  block->op = EXEC_IF;\n+\n+  block->block = XCNEW (gfc_code);\n+  block = block->block;\n+  block->loc = gfc_current_locus;\n+  block->op = EXEC_IF;\n+\n+  /* size_expr = STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE.  */\n+  size_expr = gfc_get_expr ();\n+  size_expr->where = gfc_current_locus;\n+  size_expr->expr_type = EXPR_OP;\n+  size_expr->value.op.op = INTRINSIC_DIVIDE;\n+\n+  /* STORAGE_SIZE (array,kind=c_intptr_t).  */\n+  size_expr->value.op.op1 = gfc_get_expr ();\n+  size_expr->value.op.op1->where = gfc_current_locus;\n+  size_expr->value.op.op1->expr_type = EXPR_FUNCTION;\n+  size_expr->value.op.op1->value.function.isym\n+               = gfc_intrinsic_function_by_id (GFC_ISYM_STORAGE_SIZE);\n+  gfc_get_sym_tree (\"storage_size\", sub_ns, &size_expr->value.op.op1->symtree,\n+\t\t    false);\n+  size_expr->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  size_expr->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (size_expr->value.op.op1->symtree->n.sym);\n+  size_expr->value.op.op1->value.function.actual = gfc_get_actual_arglist ();\n+  size_expr->value.op.op1->value.function.actual->expr\n+               = gfc_lval_expr_from_sym (array);\n+  size_expr->value.op.op1->value.function.actual->next = gfc_get_actual_arglist ();\n+  size_expr->value.op.op1->value.function.actual->next->expr\n+               = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+\n+  /* NUMERIC_STORAGE_SIZE.  */\n+  size_expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n+\t\t\t\t\t      gfc_character_storage_size);\n+  size_expr->value.op.op1->ts = size_expr->value.op.op2->ts;\n+  size_expr->ts = size_expr->value.op.op1->ts;\n+\n+  /* IF condition: stride == size_expr || 0 == size_expr.  */\n+  block->expr1 = gfc_get_expr ();\n+  block->expr1->expr_type = EXPR_FUNCTION;\n+  block->expr1->ts.type = BT_LOGICAL;\n+  block->expr1->ts.kind = 4;\n+  block->expr1->expr_type = EXPR_OP;\n+  block->expr1->where = gfc_current_locus;\n+\n+  block->expr1->value.op.op = INTRINSIC_OR;\n+\n+  /* stride == size_expr */\n+  block->expr1->value.op.op1 = gfc_get_expr ();\n+  block->expr1->value.op.op1->expr_type = EXPR_FUNCTION;\n+  block->expr1->value.op.op1->ts.type = BT_LOGICAL;\n+  block->expr1->value.op.op1->ts.kind = 4;\n+  block->expr1->value.op.op1->expr_type = EXPR_OP;\n+  block->expr1->value.op.op1->where = gfc_current_locus;\n+  block->expr1->value.op.op1->value.op.op = INTRINSIC_EQ;\n+  block->expr1->value.op.op1->value.op.op1 = gfc_lval_expr_from_sym (stride);\n+  block->expr1->value.op.op1->value.op.op2 = size_expr;\n+\n+  /* 0 == size_expr */\n+  block->expr1->value.op.op2 = gfc_get_expr ();\n+  block->expr1->value.op.op2->expr_type = EXPR_FUNCTION;\n+  block->expr1->value.op.op2->ts.type = BT_LOGICAL;\n+  block->expr1->value.op.op2->ts.kind = 4;\n+  block->expr1->value.op.op2->expr_type = EXPR_OP;\n+  block->expr1->value.op.op2->where = gfc_current_locus;\n+  block->expr1->value.op.op2->value.op.op = INTRINSIC_EQ;\n+  block->expr1->value.op.op2->value.op.op1 =\n+\t\t\tgfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  block->expr1->value.op.op2->value.op.op2 = gfc_copy_expr (size_expr);\n+\n+  /* IF body: call final subroutine.  */\n+  block->next = XCNEW (gfc_code);\n+  block->next->op = EXEC_CALL;\n+  block->next->loc = gfc_current_locus;\n+  block->next->symtree = fini->proc_tree;\n+  block->next->resolved_sym = fini->proc_tree->n.sym;\n+  block->next->ext.actual = gfc_get_actual_arglist ();\n+  block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+\n+  /* ELSE.  */\n+\n+  block->block = XCNEW (gfc_code);\n+  block = block->block;\n+  block->loc = gfc_current_locus;\n+  block->op = EXEC_IF;\n+\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+\n+  /* BLOCK ... END BLOCK.  */\n+  block->op = EXEC_BLOCK;\n+  block->loc = gfc_current_locus;\n+  ns = gfc_build_block_ns (sub_ns);\n+  block->ext.block.ns = ns;\n+  block->ext.block.assoc = NULL;\n+\n+  gfc_get_symbol (\"ptr2\", ns, &ptr2);\n+  ptr2->ts.type = BT_DERIVED;\n+  ptr2->ts.u.derived = array->ts.u.derived;\n+  ptr2->attr.flavor = FL_VARIABLE;\n+  ptr2->attr.pointer = 1;\n+  ptr2->attr.artificial = 1;\n+  gfc_set_sym_referenced (ptr2);\n+  gfc_commit_symbol (ptr2);\n+\n+  gfc_get_symbol (\"tmp_array\", ns, &tmp_array);\n+  tmp_array->ts.type = BT_DERIVED;\n+  tmp_array->ts.u.derived = array->ts.u.derived;\n+  tmp_array->attr.flavor = FL_VARIABLE;\n+  tmp_array->attr.contiguous = 1;\n+  tmp_array->attr.dimension = 1;\n+  tmp_array->attr.artificial = 1;\n+  tmp_array->as = gfc_get_array_spec();\n+  tmp_array->attr.intent = INTENT_INOUT;\n+  tmp_array->as->type = AS_EXPLICIT;\n+  tmp_array->as->rank = fini->proc_tree->n.sym->formal->sym->as->rank;\n+\n+  for (i = 0; i < tmp_array->as->rank; i++)\n+    {\n+      gfc_expr *shape_expr;\n+      tmp_array->as->lower[i] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t  NULL, 1);\n+      /* SIZE (array, dim=i+1, kind=default_kind).  */\n+      shape_expr = gfc_get_expr ();\n+      shape_expr->expr_type = EXPR_FUNCTION;\n+      shape_expr->value.function.isym\n+\t\t\t\t= gfc_intrinsic_function_by_id (GFC_ISYM_SIZE);\n+      shape_expr->symtree = size_intr;\n+      shape_expr->value.function.actual = gfc_get_actual_arglist ();\n+      shape_expr->value.function.actual->expr = gfc_lval_expr_from_sym (array);\n+      shape_expr->value.function.actual->next = gfc_get_actual_arglist ();\n+      shape_expr->value.function.actual->next->expr\n+\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL, i+1);\n+      shape_expr->value.function.actual->next->next = gfc_get_actual_arglist ();\n+      shape_expr->value.function.actual->next->next->expr\n+\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+      shape_expr->ts = shape_expr->value.function.isym->ts;\n+\n+      tmp_array->as->upper[i] = shape_expr;\n+    }\n+  gfc_set_sym_referenced (tmp_array);\n+  gfc_commit_symbol (tmp_array);\n+\n+  /* Create loop.  */\n+  iter = gfc_get_iterator ();\n+  iter->var = gfc_lval_expr_from_sym (idx);\n+  iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  iter->end = gfc_lval_expr_from_sym (nelem);\n+  iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+\n+  block = XCNEW (gfc_code);\n+  ns->code = block;\n+  block->op = EXEC_DO;\n+  block->loc = gfc_current_locus;\n+  block->ext.iterator = iter;\n+  block->block = gfc_get_code ();\n+  block->block->op = EXEC_DO;\n+\n+  /* Create code for\n+     CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n+\t\t       + idx * stride, c_ptr), ptr).  */\n+  block->block->next = finalization_scalarizer (idx, array, ptr,\n+\t\t\t\t\t\tgfc_lval_expr_from_sym (stride),\n+\t\t\t\t\t\tsub_ns);\n+  block->block->next->next = finalization_scalarizer (idx, tmp_array, ptr2,\n+\t\t\t\t\t\t      gfc_copy_expr (size_expr),\n+\t\t\t\t\t\t      sub_ns);\n+  /* ptr2 = ptr.  */\n+  block->block->next->next->next = XCNEW (gfc_code);\n+  block->block->next->next->next->op = EXEC_ASSIGN;\n+  block->block->next->next->next->loc = gfc_current_locus;\n+  block->block->next->next->next->expr1 = gfc_lval_expr_from_sym (ptr2);\n+  block->block->next->next->next->expr2 = gfc_lval_expr_from_sym (ptr);\n+\n+  block->next  = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_CALL;\n+  block->loc = gfc_current_locus;\n+  block->symtree = fini->proc_tree;\n+  block->resolved_sym = fini->proc_tree->n.sym;\n+  block->ext.actual = gfc_get_actual_arglist ();\n+  block->ext.actual->expr = gfc_lval_expr_from_sym (tmp_array);\n+\n+  if (fini->proc_tree->n.sym->formal->sym->attr.intent == INTENT_IN)\n+    return;\n+\n+  /* Copy back.  */\n+\n+  /* Loop.  */\n+  iter = gfc_get_iterator ();\n+  iter->var = gfc_lval_expr_from_sym (idx);\n+  iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  iter->end = gfc_lval_expr_from_sym (nelem);\n+  iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_DO;\n+  block->loc = gfc_current_locus;\n+  block->ext.iterator = iter;\n+  block->block = gfc_get_code ();\n+  block->block->op = EXEC_DO;\n+\n+  /* Create code for\n+     CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n+\t\t       + idx * stride, c_ptr), ptr).  */\n+  block->block->next = finalization_scalarizer (idx, array, ptr,\n+\t\t\t\t\t\tgfc_lval_expr_from_sym (stride),\n+\t\t\t\t\t\tsub_ns);\n+  block->block->next->next = finalization_scalarizer (idx, tmp_array, ptr2,\n+\t\t\t\t\t\t      gfc_copy_expr (size_expr),\n+\t\t\t\t\t\t      sub_ns);\n+  /* ptr = ptr2.  */\n+  block->block->next->next->next = XCNEW (gfc_code);\n+  block->block->next->next->next->op = EXEC_ASSIGN;\n+  block->block->next->next->next->loc = gfc_current_locus;\n+  block->block->next->next->next->expr1 = gfc_lval_expr_from_sym (ptr);\n+  block->block->next->next->next->expr2 = gfc_lval_expr_from_sym (ptr2);\n+}\n+\n+\n /* Generate the finalization/polymorphic freeing wrapper subroutine for the\n    derived type \"derived\". The function first calls the approriate FINAL\n    subroutine, then it DEALLOCATEs (finalizes/frees) the allocatable\n    components (but not the inherited ones). Last, it calls the wrapper\n    subroutine of the parent. The generated wrapper procedure takes as argument\n    an assumed-rank array.\n    If neither allocatable components nor FINAL subroutines exists, the vtab\n-   will contain a NULL pointer.  */\n+   will contain a NULL pointer.\n+   The generated function has the form\n+     _final(assumed-rank array, stride, skip_corarray)\n+   where the array has to be contiguous (except of the lowest dimension). The\n+   stride (in bytes) is used to allow different sizes for ancestor types by\n+   skipping over the additionally added components in the scalarizer. If\n+   \"fini_coarray\" is false, coarray components are not finalized to allow for\n+   the correct semantic with intrinsic assignment.  */\n \n static void\n generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t\t\t       const char *tname, gfc_component *vtab_final)\n {\n-  gfc_symbol *final, *array, *nelem;\n+  gfc_symbol *final, *array, *nelem, *fini_coarray, *stride;\n   gfc_symbol *ptr = NULL, *idx = NULL;\n+  gfc_symtree *size_intr;\n   gfc_component *comp;\n   gfc_namespace *sub_ns;\n   gfc_code *last_code;\n   char name[GFC_MAX_SYMBOL_LEN+1];\n   bool finalizable_comp = false;\n+  bool expr_null_wrapper = false;\n   gfc_expr *ancestor_wrapper = NULL;\n \n   /* Search for the ancestor's finalizers. */\n@@ -1011,40 +1277,44 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t  }\n     }\n \n-  /* No wrapper of the ancestor and no own FINAL subroutines and\n-     allocatable components: Return a NULL() expression.  */\n+  /* No wrapper of the ancestor and no own FINAL subroutines and allocatable\n+     components: Return a NULL() expression; we defer this a bit to have have\n+     an interface declaration.  */\n   if ((!ancestor_wrapper || ancestor_wrapper->expr_type == EXPR_NULL)\n       && !derived->attr.alloc_comp\n       && (!derived->f2k_derived || !derived->f2k_derived->finalizers)\n       && !has_finalizer_component (derived))\n-    {\n-      vtab_final->initializer = gfc_get_null_expr (NULL);\n-      return;\n-    }\n-\n-  /* Check whether there are new allocatable components.  */\n-  for (comp = derived->components; comp; comp = comp->next)\n-    {\n-      if (comp == derived->components && derived->attr.extension\n-\t  && ancestor_wrapper && ancestor_wrapper->expr_type != EXPR_NULL)\n+    expr_null_wrapper = true;\n+  else\n+    /* Check whether there are new allocatable components.  */\n+    for (comp = derived->components; comp; comp = comp->next)\n+      {\n+\tif (comp == derived->components && derived->attr.extension\n+\t    && ancestor_wrapper && ancestor_wrapper->expr_type != EXPR_NULL)\n \tcontinue;\n \n-      if (comp->ts.type != BT_CLASS && !comp->attr.pointer\n-\t  && (comp->attr.alloc_comp || comp->attr.allocatable\n-\t      || (comp->ts.type == BT_DERIVED\n-\t\t  && has_finalizer_component (comp->ts.u.derived))))\n-\tfinalizable_comp = true;\n-      else if (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n-\t       && CLASS_DATA (comp)->attr.allocatable)\n-\tfinalizable_comp = true;\n-    }\n+\tif (comp->ts.type != BT_CLASS && !comp->attr.pointer\n+\t    && (comp->attr.allocatable\n+\t\t|| (comp->ts.type == BT_DERIVED\n+\t\t    && (comp->ts.u.derived->attr.alloc_comp\n+\t\t\t|| has_finalizer_component (comp->ts.u.derived)\n+\t\t\t|| (comp->ts.u.derived->f2k_derived\n+\t\t\t    && comp->ts.u.derived->f2k_derived->finalizers)))))\n+\t  finalizable_comp = true;\n+\telse if (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t\t && CLASS_DATA (comp)->attr.allocatable)\n+\t  finalizable_comp = true;\n+      }\n \n   /* If there is no new finalizer and no new allocatable, return with\n      an expr to the ancestor's one.  */\n-  if ((!derived->f2k_derived || !derived->f2k_derived->finalizers)\n-      && !finalizable_comp)\n+  if (!expr_null_wrapper && !finalizable_comp\n+      && (!derived->f2k_derived || !derived->f2k_derived->finalizers))\n     {\n+      gcc_assert (ancestor_wrapper && ancestor_wrapper->ref == NULL\n+\t          && ancestor_wrapper->expr_type == EXPR_VARIABLE);\n       vtab_final->initializer = gfc_copy_expr (ancestor_wrapper);\n+      vtab_final->ts.interface = vtab_final->initializer->symtree->n.sym;\n       return;\n     }\n \n@@ -1057,26 +1327,31 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n      3. Call the ancestor's finalizer.  */\n \n   /* Declare the wrapper function; it takes an assumed-rank array\n-     as argument. */\n+     and a VALUE logical as arguments. */\n \n   /* Set up the namespace.  */\n   sub_ns = gfc_get_namespace (ns, 0);\n   sub_ns->sibling = ns->contained;\n-  ns->contained = sub_ns;\n+  if (!expr_null_wrapper)\n+    ns->contained = sub_ns;\n   sub_ns->resolved = 1;\n \n   /* Set up the procedure symbol.  */\n   sprintf (name, \"__final_%s\", tname);\n   gfc_get_symbol (name, sub_ns, &final);\n   sub_ns->proc_name = final;\n   final->attr.flavor = FL_PROCEDURE;\n-  final->attr.subroutine = 1;\n-  final->attr.pure = 1;\n+  final->attr.function = 1;\n+  final->attr.pure = 0;\n+  final->result = final;\n+  final->ts.type = BT_INTEGER;\n+  final->ts.kind = 4;\n   final->attr.artificial = 1;\n-  final->attr.if_source = IFSRC_DECL;\n+  final->attr.if_source = expr_null_wrapper ? IFSRC_IFBODY : IFSRC_DECL;\n   if (ns->proc_name->attr.flavor == FL_MODULE)\n     final->module = ns->proc_name->name;\n   gfc_set_sym_referenced (final);\n+  gfc_commit_symbol (final);\n \n   /* Set up formal argument.  */\n   gfc_get_symbol (\"array\", sub_ns, &array);\n@@ -1096,6 +1371,50 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   final->formal->sym = array;\n   gfc_commit_symbol (array);\n \n+  /* Set up formal argument.  */\n+  gfc_get_symbol (\"stride\", sub_ns, &stride);\n+  stride->ts.type = BT_INTEGER;\n+  stride->ts.kind = gfc_index_integer_kind;\n+  stride->attr.flavor = FL_VARIABLE;\n+  stride->attr.dummy = 1;\n+  stride->attr.value = 1;\n+  stride->attr.artificial = 1;\n+  gfc_set_sym_referenced (stride);\n+  final->formal->next = gfc_get_formal_arglist ();\n+  final->formal->next->sym = stride;\n+  gfc_commit_symbol (stride);\n+\n+  /* Set up formal argument.  */\n+  gfc_get_symbol (\"fini_coarray\", sub_ns, &fini_coarray);\n+  fini_coarray->ts.type = BT_LOGICAL;\n+  fini_coarray->ts.kind = 4;\n+  fini_coarray->attr.flavor = FL_VARIABLE;\n+  fini_coarray->attr.dummy = 1;\n+  fini_coarray->attr.value = 1;\n+  fini_coarray->attr.artificial = 1;\n+  gfc_set_sym_referenced (fini_coarray);\n+  final->formal->next->next = gfc_get_formal_arglist ();\n+  final->formal->next->next->sym = fini_coarray;\n+  gfc_commit_symbol (fini_coarray);\n+\n+  /* Return with a NULL() expression but with an interface which has\n+     the formal arguments.  */\n+  if (expr_null_wrapper)\n+    {\n+      vtab_final->initializer = gfc_get_null_expr (NULL);\n+      vtab_final->ts.interface = final;\n+      return;\n+    }\n+\n+\n+  /* Set return value to 0.  */\n+  last_code = XCNEW (gfc_code);\n+  last_code->op = EXEC_ASSIGN;\n+  last_code->loc = gfc_current_locus;\n+  last_code->expr1 = gfc_lval_expr_from_sym (final);\n+  last_code->expr2 = gfc_get_int_expr (4, NULL, 0);\n+  sub_ns->code = last_code;\n+\n   /* Obtain the size (number of elements) of \"array\" MINUS ONE,\n      which is used in the scalarization.  */\n   gfc_get_symbol (\"nelem\", sub_ns, &nelem);\n@@ -1107,7 +1426,8 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   gfc_commit_symbol (nelem);\n \n   /* Generate: nelem = SIZE (array) - 1.  */\n-  last_code = XCNEW (gfc_code);\n+  last_code->next = XCNEW (gfc_code);\n+  last_code = last_code->next;\n   last_code->op = EXEC_ASSIGN;\n   last_code->loc = gfc_current_locus;\n \n@@ -1126,6 +1446,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t= gfc_intrinsic_function_by_id (GFC_ISYM_SIZE);\n   gfc_get_sym_tree (\"size\", sub_ns, &last_code->expr2->value.op.op1->symtree,\n \t\t    false);\n+  size_intr = last_code->expr2->value.op.op1->symtree;\n   last_code->expr2->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n   last_code->expr2->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n   gfc_commit_symbol (last_code->expr2->value.op.op1->symtree->n.sym);\n@@ -1154,10 +1475,11 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \n      select case (rank (array))\n        case (3)\n+         ! If needed, the array is packed\n \t call final_rank3 (array)\n        case default:\n \t do i = 0, size (array)-1\n-\t   addr = transfer (c_loc (array), addr) + i * STORAGE_SIZE (array)\n+\t   addr = transfer (c_loc (array), addr) + i * stride\n \t   call c_f_pointer (transfer (addr, cptr), ptr)\n \t   call elemental_final (ptr)\n \t end do\n@@ -1168,6 +1490,23 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       gfc_finalizer *fini, *fini_elem = NULL;\n       gfc_code *block = NULL;\n \n+      gfc_get_symbol (\"idx\", sub_ns, &idx);\n+      idx->ts.type = BT_INTEGER;\n+      idx->ts.kind = gfc_index_integer_kind;\n+      idx->attr.flavor = FL_VARIABLE;\n+      idx->attr.artificial = 1;\n+      gfc_set_sym_referenced (idx);\n+      gfc_commit_symbol (idx);\n+\n+      gfc_get_symbol (\"ptr\", sub_ns, &ptr);\n+      ptr->ts.type = BT_DERIVED;\n+      ptr->ts.u.derived = derived;\n+      ptr->attr.flavor = FL_VARIABLE;\n+      ptr->attr.pointer = 1;\n+      ptr->attr.artificial = 1;\n+      gfc_set_sym_referenced (ptr);\n+      gfc_commit_symbol (ptr);\n+\n       /* SELECT CASE (RANK (array)).  */\n       last_code->next = XCNEW (gfc_code);\n       last_code = last_code->next;\n@@ -1221,14 +1560,20 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t  block->ext.block.case_list->high\n \t\t= block->ext.block.case_list->low;\n \n-\t  /* CALL fini_rank (array).  */\n-\t  block->next = XCNEW (gfc_code);\n-\t  block->next->op = EXEC_CALL;\n-\t  block->next->loc = gfc_current_locus;\n-\t  block->next->symtree = fini->proc_tree;\n-\t  block->next->resolved_sym = fini->proc_tree->n.sym;\n-\t  block->next->ext.actual = gfc_get_actual_arglist ();\n-\t  block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+\t  /* CALL fini_rank (array) - possibly with packing.  */\n+          if (fini->proc_tree->n.sym->formal->sym->attr.dimension)\n+\t    finalizer_insert_packed_call (block, fini, array, stride, idx, ptr,\n+\t\t\t\t\t  nelem, size_intr, sub_ns);\n+\t  else\n+\t    {\n+\t      block->next = XCNEW (gfc_code);\n+\t      block->next->op = EXEC_CALL;\n+\t      block->next->loc = gfc_current_locus;\n+\t      block->next->symtree = fini->proc_tree;\n+\t      block->next->resolved_sym = fini->proc_tree->n.sym;\n+\t      block->next->ext.actual = gfc_get_actual_arglist ();\n+\t      block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+\t    }\n \t}\n \n       /* Elemental call - scalarized.  */\n@@ -1251,23 +1596,6 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t  block->op = EXEC_SELECT;\n \t  block->ext.block.case_list = gfc_get_case ();\n \n-\t  gfc_get_symbol (\"idx\", sub_ns, &idx);\n-\t  idx->ts.type = BT_INTEGER;\n-\t  idx->ts.kind = gfc_index_integer_kind;\n-\t  idx->attr.flavor = FL_VARIABLE;\n-\t  idx->attr.artificial = 1;\n-\t  gfc_set_sym_referenced (idx);\n-\t  gfc_commit_symbol (idx);\n-\n-\t  gfc_get_symbol (\"ptr\", sub_ns, &ptr);\n-\t  ptr->ts.type = BT_DERIVED;\n-\t  ptr->ts.u.derived = derived;\n-\t  ptr->attr.flavor = FL_VARIABLE;\n-\t  ptr->attr.pointer = 1;\n-\t  ptr->attr.artificial = 1;\n-\t  gfc_set_sym_referenced (ptr);\n-\t  gfc_commit_symbol (ptr);\n-\n \t  /* Create loop.  */\n \t  iter = gfc_get_iterator ();\n \t  iter->var = gfc_lval_expr_from_sym (idx);\n@@ -1284,8 +1612,11 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \n \t  /* Create code for\n \t     CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t\t       + idx * STORAGE_SIZE (array), c_ptr), ptr).  */\n-\t  block->block->next = finalization_scalarizer (idx, array, ptr, sub_ns);\n+\t\t\t       + idx * stride, c_ptr), ptr).  */\n+\t  block->block->next\n+\t\t\t= finalization_scalarizer (idx, array, ptr,\n+\t\t\t\t\t\t   gfc_lval_expr_from_sym (stride),\n+\t\t\t\t\t\t   sub_ns);\n \t  block = block->block->next;\n \n \t  /* CALL final_elemental (array).  */\n@@ -1356,8 +1687,11 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \n       /* Create code for\n \t CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t\t   + idx * STORAGE_SIZE (array), c_ptr), ptr).  */\n-      last_code->block->next = finalization_scalarizer (idx, array, ptr, sub_ns);\n+\t\t\t   + idx * stride, c_ptr), ptr).  */\n+      last_code->block->next\n+\t\t= finalization_scalarizer (idx, array, ptr,\n+\t\t\t\t\t   gfc_lval_expr_from_sym (stride),\n+\t\t\t\t\t   sub_ns);\n       block = last_code->block->next;\n \n       for (comp = derived->components; comp; comp = comp->next)\n@@ -1367,7 +1701,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t    continue;\n \n \t  finalize_component (gfc_lval_expr_from_sym (ptr), derived, comp,\n-\t\t\t      gfc_lval_expr_from_sym (stat), &block);\n+\t\t\t      stat, fini_coarray, &block);\n \t  if (!last_code->block->next)\n \t    last_code->block->next = block;\n \t}\n@@ -1386,9 +1720,13 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \n       last_code->ext.actual = gfc_get_actual_arglist ();\n       last_code->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+      last_code->ext.actual->next = gfc_get_actual_arglist ();\n+      last_code->ext.actual->next->expr = gfc_lval_expr_from_sym (stride);\n+      last_code->ext.actual->next->next = gfc_get_actual_arglist ();\n+      last_code->ext.actual->next->next->expr\n+\t\t\t= gfc_lval_expr_from_sym (fini_coarray);\n     }\n \n-  gfc_commit_symbol (final);\n   vtab_final->initializer = gfc_lval_expr_from_sym (final);\n   vtab_final->ts.interface = final;\n }\n@@ -1419,7 +1757,7 @@ add_procs_to_declared_vtab (gfc_symbol *derived, gfc_symbol *vtype)\n }\n \n \n-/* Find (or generate) the symbol for a derived type's vtab.  */\n+/* Find or generate the symbol for a derived type's vtab.  */\n \n gfc_symbol *\n gfc_find_derived_vtab (gfc_symbol *derived)\n@@ -1440,7 +1778,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   if (ns)\n     {\n       char name[GFC_MAX_SYMBOL_LEN+1], tname[GFC_MAX_SYMBOL_LEN+1];\n-      \n+\n       get_unique_hashed_string (tname, derived);\n       sprintf (name, \"__vtab_%s\", tname);\n \n@@ -1464,7 +1802,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t  vtab->attr.access = ACCESS_PUBLIC;\n \t  gfc_set_sym_referenced (vtab);\n \t  sprintf (name, \"__vtype_%s\", tname);\n-\t  \n+\n \t  gfc_find_symbol (name, ns, 0, &vtype);\n \t  if (vtype == NULL)\n \t    {"}]}