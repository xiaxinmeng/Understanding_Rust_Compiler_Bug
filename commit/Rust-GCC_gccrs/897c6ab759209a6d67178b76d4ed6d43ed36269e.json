{"sha": "897c6ab759209a6d67178b76d4ed6d43ed36269e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk3YzZhYjc1OTIwOWE2ZDY3MTc4Yjc2ZDRlZDZkNDNlZDM2MjY5ZQ==", "commit": {"author": {"name": "David Billinghurst", "email": "David.Billinghurst@riotinto.com", "date": "2001-07-24T13:32:53Z"}, "committer": {"name": "Toon Moene", "email": "toon@gcc.gnu.org", "date": "2001-07-24T13:32:53Z"}, "message": "intrinsic-unix-bessel.f: New test\n\n2001-07-24  David Billinghurst <David.Billinghurst@riotinto.com>\n\n\t* g77.f-torture/execute/intrinsic-unix-bessel.f: New test\n\t* g77.f-torture/execute/intrinsic-unix-erf.f: New test\n\t* g77.f-torture/execute/intrinsic-vax-cd.f: New test\n\t* g77.f-torture/execute/intrinsic-f2c-z.f: New test\n\nFrom-SVN: r44295", "tree": {"sha": "103cd7a6e2767b548b20646ee190640fd58e4ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/103cd7a6e2767b548b20646ee190640fd58e4ad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/897c6ab759209a6d67178b76d4ed6d43ed36269e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897c6ab759209a6d67178b76d4ed6d43ed36269e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/897c6ab759209a6d67178b76d4ed6d43ed36269e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897c6ab759209a6d67178b76d4ed6d43ed36269e/comments", "author": null, "committer": null, "parents": [{"sha": "46d2e8d7780c9caf47f292eeae73ac1843c8fe2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46d2e8d7780c9caf47f292eeae73ac1843c8fe2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46d2e8d7780c9caf47f292eeae73ac1843c8fe2c"}], "stats": {"total": 369, "additions": 369, "deletions": 0}, "files": [{"sha": "995daaef83250be07128002d0310f98635134927", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=897c6ab759209a6d67178b76d4ed6d43ed36269e", "patch": "@@ -1,3 +1,10 @@\n+2001-07-24  David Billinghurst <David.Billinghurst@riotinto.com>\n+\n+\t* g77.f-torture/execute/intrinsic-unix-bessel.f: New test\n+\t* g77.f-torture/execute/intrinsic-unix-erf.f: New test\n+\t* g77.f-torture/execute/intrinsic-vax-cd.f: New test\n+\t* g77.f-torture/execute/intrinsic-f2c-z.f: New test\n+\n Mon Jul 23 10:14:17 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcc.c-torture/execute/20010723-1.c: New test."}, {"sha": "ec7b3324379063ef63ad26c34644d636619e6912", "filename": "gcc/testsuite/g77.f-torture/execute/intrinsic-f2c-z.f", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-f2c-z.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-f2c-z.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-f2c-z.f?ref=897c6ab759209a6d67178b76d4ed6d43ed36269e", "patch": "@@ -0,0 +1,94 @@\n+c  intrinsic-f2c-z.f\n+c\n+c Test double complex intrinsics Z*.  \n+c These functions are f2c extensions\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      double complex z, a\n+      double precision x\n+      logical fail\n+      intrinsic zabs, zcos, zexp, zlog, zsin, zsqrt\n+      common /flags/ fail\n+      fail = .false.\n+\n+c     ZABS - Absolute value\n+      z = (3.0d0,-4.0d0)\n+      x = 5.0d0\n+      call c_d(ZABS(z),x,'ZABS(double complex)')\n+      call p_d_z(ZABS,z,x,'ZABS')\n+\n+c     ZCOS - Cosine\n+      z = (3.0d0,1.0d0)\n+      a = (-1.52763825012d0,-0.165844401919)\n+      call c_z(ZCOS(z),a,'ZCOS(double complex)')\n+      call p_z_z(ZCOS,z,a,'ZCOS')\n+\n+c     ZEXP - Exponential\n+      z = (3.0d0,1.0d0)\n+      a = (10.8522619142d0,16.9013965352)\n+      call c_z(ZEXP(z),a,'ZEXP(double complex)')\n+      call p_z_z(ZEXP,z,a,'ZEXP')\n+\n+c     ZLOG - Natural logarithm\n+      call c_z(ZLOG(a),z,'ZLOG(double complex)')\n+      call p_z_z(ZLOG,a,z,'ZLOG')\n+\n+c     ZSIN - Sine\n+      z = (3.0d0,1.0d0)\n+      a = (0.217759551622d0,-1.1634403637d0)\n+      call c_z(ZSIN(z),a,'ZSIN(double complex)')\n+      call p_z_z(ZSIN,z,a,'ZSIN')\n+\n+c     ZSQRT - Square root\n+      z = (0.0d0,-4.0d0)\n+      a = sqrt(2.0d0)*(1.0d0,-1.0d0)\n+      call c_z(ZSQRT(z),a,'ZSQRT(double complex)')\n+      call p_z_z(ZSQRT,z,a,'ZSQRT')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_z(a,b,label)\n+c     Check if DOUBLE COMPLEX a equals b, and fail otherwise\n+      double complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine p_z_z(f,x,a,label)\n+c     Check if DOUBLE COMPLEX f(x) equals a for DOUBLE COMPLEX x\n+      double complex f,x,a\n+      character*(*) label\n+      call c_z(f(x),a,label)\n+      end\n+\n+      subroutine p_d_z(f,x,a,label)\n+c     Check if DOUBLE PRECISION f(x) equals a for DOUBLE COMPLEX x\n+      double precision f,x\n+      double complex a\n+      character*(*) label\n+      call c_d(f(x),a,label)\n+      end"}, {"sha": "8ff841866b8315c884437b43c6f65d7674877a38", "filename": "gcc/testsuite/g77.f-torture/execute/intrinsic-unix-bessel.f", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-bessel.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-bessel.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-bessel.f?ref=897c6ab759209a6d67178b76d4ed6d43ed36269e", "patch": "@@ -0,0 +1,114 @@\n+c  intrinsic-unix-bessel.f\n+c\n+c Test Bessel function intrinsics.  \n+c These functions are only available if provided by system\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      real x, a\n+      double precision dx, da\n+      integer i\n+      integer*2 j\n+      integer*1 k\n+      integer*8 m\n+      logical fail\n+      common /flags/ fail\n+      fail = .false.\n+\n+      x = 2.0\n+      dx = x \n+      i = 2\n+      j = i\n+      k = i\n+      m = i\n+c     BESJ0  - Bessel function of first kind of order zero\n+      a = 0.22389077\n+      da = a\n+      call c_r(BESJ0(x),a,'BESJ0(real)')\n+      call c_d(BESJ0(dx),da,'BESJ0(double)')\n+      call c_d(DBESJ0(dx),da,'DBESJ0(double)')\n+\n+c     BESJ1  - Bessel function of first kind of order one\n+      a = 0.57672480\n+      da = a\n+      call c_r(BESJ1(x),a,'BESJ1(real)')\n+      call c_d(BESJ1(dx),da,'BESJ1(double)')\n+      call c_d(DBESJ1(dx),da,'DBESJ1(double)')\n+\n+c     BESJN  - Bessel function of first kind of order N\n+      a = 0.3528340\n+      da = a\n+      call c_r(BESJN(i,x),a,'BESJN(integer,real)')\n+c      call c_r(BESJN(j,x),a,'BESJN(integer*2,real)')\n+c      call c_r(BESJN(k,x),a,'BESJN(integer*1,real)')\n+c      call c_r(BESJN(m,x),a,'BESJN(integer*8,real)')\n+c      call c_d(BESJN(i,dx),da,'BESJN(integer,double)')\n+c      call c_d(BESJN(j,dx),da,'BESJN(integer*2,double)')\n+      call c_d(BESJN(k,dx),da,'BESJN(integer*1,double)')\n+c      call c_d(BESJN(m,dx),da,'BESJN(integer*8,double)')\n+      call c_d(DBESJN(i,dx),da,'DBESJN(integer,double)')\n+      call c_d(DBESJN(j,dx),da,'DBESJN(integer*2,double)')\n+      call c_d(DBESJN(k,dx),da,'DBESJN(integer*1,double)')\n+c      call c_d(DBESJN(m,dx),da,'DBESJN(integer*8,double)')\n+\n+c     BESY0  - Bessel function of second kind of order zero\n+      a = 0.51037567\n+      da = a\n+      call c_r(BESY0(x),a,'BESY0(real)')\n+      call c_d(BESY0(dx),da,'BESY0(double)')\n+      call c_d(DBESY0(dx),da,'DBESY0(double)')\n+\n+c     BESY1  - Bessel function of second kind of order one\n+      a = 0.-0.1070324\n+      da = a\n+      call c_r(BESY1(x),a,'BESY1(real)')\n+      call c_d(BESY1(dx),da,'BESY1(double)')\n+      call c_d(DBESY1(dx),da,'DBESY1(double)')\n+\n+c     BESYN  - Bessel function of second kind of order N\n+      a = -0.6174081\n+      da = a\n+      call c_r(BESYN(i,x),a,'BESYN(integer,real)')\n+c      call c_r(BESYN(j,x),a,'BESYN(integer*2,real)')\n+c      call c_r(BESYN(k,x),a,'BESYN(integer*1,real)')\n+c      call c_r(BESYN(m,x),a,'BESYN(integer*8,real)')\n+c      call c_d(BESYN(i,dx),da,'BESYN(integer,double)')\n+c      call c_d(BESYN(j,dx),da,'BESYN(integer*2,double)')\n+      call c_d(BESYN(k,dx),da,'BESYN(integer*1,double)')\n+c      call c_d(BESYN(m,dx),da,'BESYN(integer*8,double)')\n+      call c_d(DBESYN(i,dx),da,'DBESYN(integer,double)')\n+      call c_d(DBESYN(j,dx),da,'DBESYN(integer*2,double)')\n+      call c_d(DBESYN(k,dx),da,'DBESYN(integer*1,double)')\n+c      call c_d(DBESYN(m,dx),da,'DBESYN(integer*8,double)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}, {"sha": "5ab48d65036799e59e285036bfc0550bf026b090", "filename": "gcc/testsuite/g77.f-torture/execute/intrinsic-unix-erf.f", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-erf.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-erf.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-unix-erf.f?ref=897c6ab759209a6d67178b76d4ed6d43ed36269e", "patch": "@@ -0,0 +1,60 @@\n+c  intrinsic-unix-erf.f\n+c\n+c Test Bessel function intrinsics.  \n+c These functions are only available if provided by system\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      real x, a\n+      double precision dx, da\n+      logical fail\n+      common /flags/ fail\n+      fail = .false.\n+\n+      x = 0.6\n+      dx = x \n+c     ERF  - error function\n+      a = 0.6038561\n+      da = a\n+      call c_r(ERF(x),a,'ERF(real)')\n+      call c_d(ERF(dx),da,'ERF(double)')\n+      call c_d(DERF(dx),da,'DERF(double)')\n+\n+c     ERFC  - complementary error function\n+      a = 1.0 - a\n+      da = a\n+      call c_r(ERFC(x),a,'ERFC(real)')\n+      call c_d(ERFC(dx),da,'ERFC(double)')\n+      call c_d(DERFC(dx),da,'DERFC(double)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}, {"sha": "93f1c43b0f5dc75d50b97314d92da814804abfee", "filename": "gcc/testsuite/g77.f-torture/execute/intrinsic-vax-cd.f", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-vax-cd.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897c6ab759209a6d67178b76d4ed6d43ed36269e/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-vax-cd.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2Fintrinsic-vax-cd.f?ref=897c6ab759209a6d67178b76d4ed6d43ed36269e", "patch": "@@ -0,0 +1,94 @@\n+c  intrinsic-vax-cd.f\n+c\n+c Test double complex intrinsics CD*.  \n+c These functions are VAX extensions\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      double complex z, a\n+      double precision x\n+      logical fail\n+      intrinsic cdabs, cdcos, cdexp, cdlog, cdsin, cdsqrt\n+      common /flags/ fail\n+      fail = .false.\n+\n+c     CDABS - Absolute value\n+      z = (3.0d0,-4.0d0)\n+      x = 5.0d0\n+      call c_d(CDABS(z),x,'CDABS(double complex)')\n+      call p_d_z(CDABS,z,x,'CDABS')\n+\n+c     CDCOS - Cosine\n+      z = (3.0d0,1.0d0)\n+      a = (-1.52763825012d0,-0.165844401919)\n+      call c_z(CDCOS(z),a,'CDCOS(double complex)')\n+      call p_z_z(CDCOS,z,a,'CDCOS')\n+\n+c     CDEXP - Exponential\n+      z = (3.0d0,1.0d0)\n+      a = (10.8522619142d0,16.9013965352)\n+      call c_z(CDEXP(z),a,'CDEXP(double complex)')\n+      call p_z_z(CDEXP,z,a,'CDEXP')\n+\n+c     CDLOG - Natural logarithm\n+      call c_z(CDLOG(a),z,'CDLOG(double complex)')\n+      call p_z_z(CDLOG,a,z,'CDLOG')\n+\n+c     CDSIN - Sine\n+      z = (3.0d0,1.0d0)\n+      a = (0.217759551622d0,-1.1634403637d0)\n+      call c_z(CDSIN(z),a,'CDSIN(double complex)')\n+      call p_z_z(CDSIN,z,a,'CDSIN')\n+\n+c     CDSQRT - Square root\n+      z = (0.0d0,-4.0d0)\n+      a = sqrt(2.0d0)*(1.0d0,-1.0d0)\n+      call c_z(CDSQRT(z),a,'CDSQRT(double complex)')\n+      call p_z_z(CDSQRT,z,a,'CDSQRT')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_z(a,b,label)\n+c     Check if DOUBLE COMPLEX a equals b, and fail otherwise\n+      double complex a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine p_z_z(f,x,a,label)\n+c     Check if DOUBLE COMPLEX f(x) equals a for DOUBLE COMPLEX x\n+      double complex f,x,a\n+      character*(*) label\n+      call c_z(f(x),a,label)\n+      end\n+\n+      subroutine p_d_z(f,x,a,label)\n+c     Check if DOUBLE PRECISION f(x) equals a for DOUBLE COMPLEX x\n+      double precision f,x\n+      double complex a\n+      character*(*) label\n+      call c_d(f(x),a,label)\n+      end"}]}