{"sha": "4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQxYTkxYzJiZjRlODFiNGMyNjBhMDcyYzQxMWQzYmZjNWNhNmRkOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-13T12:08:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-13T12:08:59Z"}, "message": "mn10300.h (REG_CLASS_FROM_LETTER): Map 'y' to SP_REGS.\n\n        * mn10300.h (REG_CLASS_FROM_LETTER): Map 'y' to SP_REGS.\n        Handle 'x' as NO_REGS for this cpu.\n        (REGNO_OK_FOR_BIT_BASE_P): Define.\n        (REG_OK_FOR_BIT_BASE_P): Define.\n        (GO_IF_LEGITIMATE_ADDRESS): Use them.\n        (REG_OK_FOR_INDEX_P): Tweak.\n        * mn13000.c (REG_SAVE_BYTES): Define.\n        (expand_epilogue, initial_offset): Use it.\n        (secondary_reload_class): Slightly reformat.\n        (output_tst): Tweak comments.\n        * mn10300.md: Change 'x' to 'y' for SP_REGS.  Then add 'x' to many\n        patterns.\n        (addsi3): Turn into a define_expand/define_insn pair.  Rework code for\n        three operand addition case to be more efficient.\n        (subsi3): Turn into a define_expand/define_insn pair.\n\nFrom-SVN: r21104", "tree": {"sha": "e8f087aef94231eca8a8367138b5f491b07c24e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8f087aef94231eca8a8367138b5f491b07c24e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/comments", "author": null, "committer": null, "parents": [{"sha": "518b6ce38a5a1ec4ec2e3935a6b24a0cad1ca9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518b6ce38a5a1ec4ec2e3935a6b24a0cad1ca9dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518b6ce38a5a1ec4ec2e3935a6b24a0cad1ca9dd"}], "stats": {"total": 233, "additions": 146, "deletions": 87}, "files": [{"sha": "7456c32febed4f1dd9497d3d88dac6d3c987d018", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "patch": "@@ -36,6 +36,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"obstack.h\"\n \n+/* The size of the callee register save area.  Right now we save everything\n+   on entry since it costs us nothing in code size.  It does cost us from a\n+   speed standpoint, so we want to optimize this sooner or later.  */\n+#define REG_SAVE_BYTES (16)\n+\n /* Global registers known to hold the value zero.\n \n    Normally we'd depend on CSE and combine to put zero into a\n@@ -439,8 +444,8 @@ expand_prologue ()\n   /* Determine if it is profitable to put the value zero into a register\n      for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n   if (regs_ever_live[2] || regs_ever_live[3]\n-       || regs_ever_live[6] || regs_ever_live[7]\n-       || frame_pointer_needed)\n+      || regs_ever_live[6] || regs_ever_live[7]\n+      || frame_pointer_needed)\n     {\n       int dreg_count, areg_count;\n \n@@ -569,7 +574,7 @@ expand_epilogue ()\n     }\n   else if ((regs_ever_live[2] || regs_ever_live[3]\n \t    || regs_ever_live[6] || regs_ever_live[7])\n-\t   && size + 16 > 255)\n+\t   && size + REG_SAVE_BYTES > 255)\n     {\n       emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t     stack_pointer_rtx,\n@@ -585,7 +590,7 @@ expand_epilogue ()\n   if (regs_ever_live[2] || regs_ever_live[3]\n       || regs_ever_live[6] || regs_ever_live[7]\n       || frame_pointer_needed)\n-    emit_jump_insn (gen_return_internal_regs (GEN_INT (size + 16)));\n+    emit_jump_insn (gen_return_internal_regs (GEN_INT (size + REG_SAVE_BYTES)));\n   else\n     {\n       if (size)\n@@ -689,7 +694,9 @@ secondary_reload_class (class, mode, in)\n   if (GET_CODE (in) == MEM\n       && (mode == QImode || mode == HImode)\n       && (class == ADDRESS_REGS || class == SP_REGS))\n-    return DATA_REGS;\n+    {\n+      return DATA_REGS;\n+    }\n \n   /* We can't directly load sp + const_int into a data register;\n      we must use an address register as an intermediate.  */\n@@ -705,9 +712,10 @@ secondary_reload_class (class, mode, in)\n   if (GET_CODE (in) == PLUS\n       && (XEXP (in, 0) == stack_pointer_rtx\n \t  || XEXP (in, 1) == stack_pointer_rtx))\n-    return DATA_REGS;\n+    {\n+      return DATA_REGS;\n+    }\n  \n-\n   /* Otherwise assume no secondary reloads are needed.  */\n   return NO_REGS;\n }\n@@ -723,7 +731,7 @@ initial_offset (from, to)\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || frame_pointer_needed)\n-\treturn 16;\n+\treturn REG_SAVE_BYTES;\n       else\n \treturn 0;\n     }\n@@ -736,7 +744,7 @@ initial_offset (from, to)\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || frame_pointer_needed)\n-\treturn (get_frame_size () + 16 \n+\treturn (get_frame_size () + REG_SAVE_BYTES\n \t\t+ (current_function_outgoing_args_size\n \t\t   ? current_function_outgoing_args_size + 4 : 0)); \n       else\n@@ -950,7 +958,10 @@ output_tst (operand, insn)\n \t If it's a call clobbered register, have we past a call?\n \n \t Make sure the register we find isn't the same as ourself;\n-\t the mn10300 can't encode that.  */\n+\t the mn10300 can't encode that.\n+\n+\t ??? reg_set_between_p return nonzero anytime we pass a CALL_INSN\n+\t so the code to detect calls here isn't doing anything useful.  */\n       if (REG_P (SET_DEST (set))\n \t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n \t  && !reg_set_between_p (SET_DEST (set), temp, insn)"}, {"sha": "eea94a2d24442a93b4de3d66e52a003555a188ac", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler. Matsushita MN10300 series\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GNU CC.\n@@ -209,7 +209,9 @@ extern struct rtx_def *zero_areg;\n    class that represents their union.  */\n    \n enum reg_class {\n-  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS, DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS,\n+  DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, \n+  GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n@@ -244,10 +246,9 @@ enum reg_class {\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) < 4 ? DATA_REGS : \\\n    (REGNO) < 9 ? ADDRESS_REGS : \\\n-    (REGNO) == 9 ? SP_REGS: 0)\n+    (REGNO) == 9 ? SP_REGS : 0)\n \n /* The class value for index registers, and the one for base regs.  */\n-\n #define INDEX_REG_CLASS DATA_REGS\n #define BASE_REG_CLASS  SP_OR_ADDRESS_REGS\n \n@@ -256,7 +257,7 @@ enum reg_class {\n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'd' ? DATA_REGS : \\\n    (C) == 'a' ? ADDRESS_REGS : \\\n-   (C) == 'x' ? SP_REGS : NO_REGS)\n+   (C) == 'y' ? SP_REGS : NO_REGS)\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -270,6 +271,10 @@ enum reg_class {\n   (((regno) > 3 && regno < FIRST_PSEUDO_REGISTER)\t\\\n    || (reg_renumber[regno] > 3 && reg_renumber[regno] < FIRST_PSEUDO_REGISTER))\n \n+#define REGNO_OK_FOR_BIT_BASE_P(regno) \\\n+  (((regno) > 3 && regno < 10)\t\\\n+   || (reg_renumber[regno] > 3 && reg_renumber[regno] < 10))\n+\n #define REGNO_OK_FOR_INDEX_P(regno) \\\n   (((regno) >= 0 && regno < 4)\t\\\n    || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n@@ -585,11 +590,11 @@ extern struct rtx_def *mn10300_builtin_saveregs ();\n     && GET_MODE (OP) == QImode\t\t\t\t\t\\\n     && (CONSTANT_ADDRESS_P (XEXP (OP, 0))\t\t\t\\\n \t|| (GET_CODE (XEXP (OP, 0)) == REG\t\t\t\\\n-\t    && REG_OK_FOR_BASE_P (XEXP (OP, 0))\t\t\t\\\n+\t    && REG_OK_FOR_BIT_BASE_P (XEXP (OP, 0))\t\t\\\n \t    && XEXP (OP, 0) != stack_pointer_rtx)\t\t\\\n \t|| (GET_CODE (XEXP (OP, 0)) == PLUS\t\t\t\\\n \t    && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\t\\\n-\t    && REG_OK_FOR_BASE_P (XEXP (XEXP (OP, 0), 0))\t\\\n+\t    && REG_OK_FOR_BIT_BASE_P (XEXP (XEXP (OP, 0), 0))\t\\\n \t    && XEXP (XEXP (OP, 0), 0) != stack_pointer_rtx\t\\\n \t    && GET_CODE (XEXP (XEXP (OP, 0), 1)) == CONST_INT\t\\\n \t    && INT_8_BITS (INTVAL (XEXP (XEXP (OP, 0), 1))))))\n@@ -618,16 +623,20 @@ extern struct rtx_def *mn10300_builtin_saveregs ();\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X)  \\\n-  ((REGNO (X) >= 0 && REGNO(X) <= 3) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  ((REGNO (X) >= 0 && REGNO(X) <= 3) || REGNO (X) >= 10)\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  ((REGNO (X) >= 4 && REGNO(X) <= 9) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  ((REGNO (X) >= 4 && REGNO(X) <= 9) || REGNO (X) >= 10)\n+#define REG_OK_FOR_BIT_BASE_P(X) \\\n+  ((REGNO (X) >= 4 && REGNO(X) <= 9))\n #else\n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BIT_BASE_P(X) REGNO_OK_FOR_BIT_BASE_P (REGNO (X))\n #endif\n \n \f"}, {"sha": "d8f506a36a54887b3bb19a2c01972df68c289a7f", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 107, "deletions": 68, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=4d1a91c2bf4e81b4c260a072c411d3bfc5ca6dd8", "patch": "@@ -57,8 +57,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,d,*a,d,*a,d,*a,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,0,I,I,a,d,di,ia,m,d\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dx,*a,dx,*a,dx,*a,dx,*a,dx,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dx\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n   \"*\n@@ -112,8 +112,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,*a,d,*a,d,*a,d,*a,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,0,I,I,a,d,di,ia,m,d\"))]\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dx,*a,dx,*a,dx,*a,dx,*a,dx,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dx\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\"\n   \"*\n@@ -206,9 +206,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\"\n-\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a,aR,x\")\n+\t\t\t\t\"=dx,ax,dx,ax,dxm,dxm,axm,axm,dx,dx,ax,ax,axR,y\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,d,a,d,a,dim,aim,dim,aim,x,aR\"))]\n+\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dixm,aixm,dixm,aixm,xy,axR\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"*\n@@ -263,8 +263,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=d,a,d,a,dam,da\")\n-\t(match_operand:SF 1 \"general_operand\" \"0,0,G,G,da,daim\"))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=dx,ax,dx,ax,daxm,dax\")\n+\t(match_operand:SF 1 \"general_operand\" \"0,0,G,G,dax,daxim\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"*\n@@ -312,9 +312,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"general_operand\"\n-\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a\")\n+\t\t\t\t\"=dx,ax,dx,ax,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t\t\"0,0,I,I,d,a,d,a,dim,aim,dim,aim\"))]\n+\t\t\t\t\"0,0,I,I,dx,ax,dx,ax,dxim,axim,dxim,axim\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n   \"*\n@@ -473,9 +473,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"general_operand\"\n-\t\t\t\t\"=d,a,d,a,dm,dm,am,am,d,d,a,a\")\n+\t\t\t\t\"=dx,ax,dx,ax,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\t\"0,0,G,G,d,a,d,a,dim,aim,dim,aim\"))]\n+\t\t\t\t\"0,0,G,G,dx,ax,dx,ax,dxim,axim,dxim,axim\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n@@ -629,28 +629,28 @@\n ;; Go ahead and define tstsi so we can eliminate redundant tst insns\n ;; when we start trying to optimize this port.\n (define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"da\"))]\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dax\"))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n+  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx\")))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"d\")))]\n+  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx\")))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a,da\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"!*0,dai\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"!*0,daxi\")))]\n   \"\"\n   \"@\n   add 0,%0\n@@ -682,27 +682,60 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,da,x,&!da\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,da\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,dai,i,da\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,ax,ax,dax,xy,!dax\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,dax\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,daxi,i,dax\")))]\n   \"\"\n-  \"@\n-  inc %0\n-  inc %0\n-  inc4 %0\n-  add %2,%0\n-  add %2,%0\n-  mov %2,%0\\;add %1,%0\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"inc %0\\\";\n+    case 2:\n+      return \\\"inc4 %0\\\";\n+    case 3:\n+    case 4:\n+      return \\\"add %2,%0\\\";\n+    case 5:\n+      /* I'm not sure if this can happen or not.  Might as well be prepared\n+\t and generate the best possible code if it does happen.  */\n+      if (true_regnum (operands[0]) == true_regnum (operands[1]))\n+\treturn \\\"add %2,%0\\\";\n+      if (true_regnum (operands[0]) == true_regnum (operands[2]))\n+\treturn \\\"add %1,%0\\\";\n+\n+      /* We have to copy one of the sources into the destination, then add\n+\t the other source to the destination.\n+\n+\t Carefully select which source to copy to the destination; a naive\n+\t implementation will waste a byte when the source classes are different\n+\t and the destination is an address register.  Selecting the lowest\n+\t cost register copy will optimize this sequence.  */\n+      if (REGNO_REG_CLASS (true_regnum (operands[1]))\n+\t  == REGNO_REG_CLASS (true_regnum (operands[0])))\n+\treturn \\\"mov %1,%0\\;add %2,%0\\\";\n+      return \\\"mov %2,%0\\;add %1,%0\\\";\n+    }\n+}\"\n   [(set_attr \"cc\" \"set_zn,none_0hit,none_0hit,set_zn,none_0hit,set_zn\")])\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=da\")\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dax\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"dai\")))]\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi\")))]\n   \"\"\n   \"sub %2,%0\"\n   [(set_attr \"cc\" \"set_zn\")])\n@@ -726,9 +759,9 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))]\n   \"\"\n   \"*\n {\n@@ -740,9 +773,9 @@\n   [(set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"d\")))\n+\t\t (match_operand:SI 2 \"general_operand\" \"dx\")))\n    (set (match_operand:SI 3 \"general_operand\" \"=&d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n@@ -761,9 +794,9 @@\n   [(set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"d\")))\n+\t\t (match_operand:SI 2 \"general_operand\" \"dx\")))\n    (set (match_operand:SI 3 \"general_operand\" \"=d\")\n \t(mod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n@@ -782,9 +815,9 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,di\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi\")))]\n   \"\"\n   \"*\n {\n@@ -817,9 +850,9 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))]\n   \"\"\n   \"or %2,%0\"\n   [(set_attr \"cc\" \"set_znv\")])\n@@ -829,9 +862,9 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))]\n   \"\"\n   \"xor %2,%0\"\n   [(set_attr \"cc\" \"set_znv\")])\n@@ -841,7 +874,7 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"\"\n   \"not %0\"\n@@ -897,7 +930,7 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-     (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+     (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n \t\t      (match_operand 1 \"const_int_operand\" \"\")\n \t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n   \"\"\n@@ -924,7 +957,7 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-     (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,d\")\n+     (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,dx\")\n \t\t      (match_operand 1 \"const_int_operand\" \"\")\n \t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n   \"mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n@@ -968,7 +1001,7 @@\n   [(set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"\"\n-  [(set (cc0) (and:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+  [(set (cc0) (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n \t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))]\n   \"\"\n   \"btst %1,%0\"\n@@ -977,7 +1010,7 @@\n (define_insn \"\"\n   [(set (cc0)\n      (and:SI\n-       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,d\") 0)\n+       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,dx\") 0)\n        (match_operand:SI 1 \"const_8bit_operand\" \"\")))]\n   \"\"\n   \"@\n@@ -1188,7 +1221,7 @@\n }\")\n \n (define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"\" \"=da\")\n+  [(set (match_operand 0 \"\" \"=dax\")\n \t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"aS\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n@@ -1232,7 +1265,7 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n \t (match_operand:QI 1 \"general_operand\" \"0,d,m\")))]\n   \"\"\n@@ -1243,9 +1276,9 @@\n   [(set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,d,m\")))]\n+\t (match_operand:HI 1 \"general_operand\" \"0,dx,m\")))]\n   \"\"\n   \"@\n   exthu %0\n@@ -1256,19 +1289,19 @@\n ;;- sign extension instructions\n \n (define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,d\")))]\n+\t (match_operand:QI 1 \"general_operand\" \"0,dx\")))]\n   \"\"\n   \"@\n   extb %0\n   mov %1,%0\\;extb %0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,d\")))]\n+\t (match_operand:HI 1 \"general_operand\" \"0,dx\")))]\n   \"\"\n   \"@\n   exth %0\n@@ -1280,10 +1313,10 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=da,d,d,d,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,dx,dx,dx\")\n \t(ashift:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,M,L,di\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,M,L,dxi\")))]\n   \"\"\n   \"@\n   add %0,%0\n@@ -1294,19 +1327,19 @@\n   [(set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(lshiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"di\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))]\n   \"\"\n   \"lsr %S2,%0\"\n   [(set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ashiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"di\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))]\n   \"\"\n   \"asr %S2,%0\"\n   [(set_attr \"cc\" \"set_zn\")])\n@@ -1341,13 +1374,19 @@\n    (match_operand:SI 0  \"const_int_operand\" \"i\")\n    (return)]\n   \"\"\n-  \"ret [d2,d3,a2,a3],%0\"\n+  \"*\n+{\n+  return \\\"ret [d2,d3,a2,a3],%0\\\";\n+}\"\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"store_movm\"\n   [(const_int 1)]\n   \"\"\n-  \"movm [d2,d3,a2,a3],(sp)\"\n+  \"*\n+{\n+  return \\\"movm [d2,d3,a2,a3],(sp)\\\";\n+}\"\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"return\"\n@@ -1369,7 +1408,7 @@\n ;; Try to combine consecutive updates of the stack pointer (or any\n ;; other register for that matter).\n (define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dax\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dxay\")\n \t(plus:SI (match_dup 0)\n \t\t (match_operand 1 \"const_int_operand\" \"\")))\n    (set (match_dup 0)\n@@ -1393,7 +1432,7 @@\n ;; This will work on the mn10200 because we can check the ZX flag\n ;; if the comparison is in HImode.\n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (match_operand 1 \"\" \"\")\n \t\t\t   (pc)))]\n@@ -1402,7 +1441,7 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (match_operand 1 \"\" \"\")\n \t\t\t   (pc)))]\n@@ -1411,7 +1450,7 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n    (set (pc) (if_then_else (ge (cc0) (const_int 0))\n \t\t\t   (pc)\n \t\t\t   (match_operand 1 \"\" \"\")))]\n@@ -1420,7 +1459,7 @@\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_peephole\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"dx\"))\n    (set (pc) (if_then_else (lt (cc0) (const_int 0))\n \t\t\t   (pc)\n \t\t\t   (match_operand 1 \"\" \"\")))]"}]}