{"sha": "a6de01a6ddfb5bab044091548df0f868bc208646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkZTAxYTZkZGZiNWJhYjA0NDA5MTU0OGRmMGY4NjhiYzIwODY0Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-15T20:53:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-15T20:53:04Z"}, "message": "Use backend interface for send statement.\n\nFrom-SVN: r172519", "tree": {"sha": "c64b3959198eb9ac5c369a8db6148883a97d1500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c64b3959198eb9ac5c369a8db6148883a97d1500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6de01a6ddfb5bab044091548df0f868bc208646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6de01a6ddfb5bab044091548df0f868bc208646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6de01a6ddfb5bab044091548df0f868bc208646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6de01a6ddfb5bab044091548df0f868bc208646/comments", "author": null, "committer": null, "parents": [{"sha": "2ba172e0dfb01abd3e6f41c41cee82c1c2c07a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba172e0dfb01abd3e6f41c41cee82c1c2c07a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba172e0dfb01abd3e6f41c41cee82c1c2c07a52"}], "stats": {"total": 266, "additions": 112, "deletions": 154}, "files": [{"sha": "5b72c6a0661ff4549c84a961acf8ab76a8623dcf", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=a6de01a6ddfb5bab044091548df0f868bc208646", "patch": "@@ -3622,6 +3622,16 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n \t\t && et->interface_type()->is_empty());\n       use_view_convert = true;\n     }\n+  else if (t->integer_type() != NULL)\n+    {\n+      gcc_assert(et->is_boolean_type()\n+\t\t || et->integer_type() != NULL\n+\t\t || et->function_type() != NULL\n+\t\t || et->points_to() != NULL\n+\t\t || et->map_type() != NULL\n+\t\t || et->channel_type() != NULL);\n+      return convert_to_integer(type_tree, expr_tree);\n+    }\n   else\n     gcc_unreachable();\n "}, {"sha": "ea4663953d8cd85fd6a409e232e8aea2257e2f57", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=a6de01a6ddfb5bab044091548df0f868bc208646", "patch": "@@ -2764,144 +2764,6 @@ Gogo::runtime_error(int code, source_location location)\n   return ret;\n }\n \n-// Send VAL on CHANNEL.  If BLOCKING is true, the resulting tree has a\n-// void type.  If BLOCKING is false, the resulting tree has a boolean\n-// type, and it will evaluate as true if the value was sent.  If\n-// FOR_SELECT is true, this is being done because it was chosen in a\n-// select statement.\n-\n-tree\n-Gogo::send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n-\t\t      source_location location)\n-{\n-  if (channel == error_mark_node || val == error_mark_node)\n-    return error_mark_node;\n-\n-  if (int_size_in_bytes(TREE_TYPE(val)) <= 8\n-      && !AGGREGATE_TYPE_P(TREE_TYPE(val))\n-      && !FLOAT_TYPE_P(TREE_TYPE(val)))\n-    {\n-      val = convert_to_integer(uint64_type_node, val);\n-      if (blocking)\n-\t{\n-\t  static tree send_small_fndecl;\n-\t  tree ret = Gogo::call_builtin(&send_small_fndecl,\n-\t\t\t\t\tlocation,\n-\t\t\t\t\t\"__go_send_small\",\n-\t\t\t\t\t3,\n-\t\t\t\t\tvoid_type_node,\n-\t\t\t\t\tptr_type_node,\n-\t\t\t\t\tchannel,\n-\t\t\t\t\tuint64_type_node,\n-\t\t\t\t\tval,\n-\t\t\t\t\tboolean_type_node,\n-\t\t\t\t\t(for_select\n-\t\t\t\t\t ? boolean_true_node\n-\t\t\t\t\t : boolean_false_node));\n-\t  if (ret == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if there are too many operations on a\n-\t  // closed channel.\n-\t  TREE_NOTHROW(send_small_fndecl) = 0;\n-\t  return ret;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert(!for_select);\n-\t  static tree send_nonblocking_small_fndecl;\n-\t  tree ret = Gogo::call_builtin(&send_nonblocking_small_fndecl,\n-\t\t\t\t\tlocation,\n-\t\t\t\t\t\"__go_send_nonblocking_small\",\n-\t\t\t\t\t2,\n-\t\t\t\t\tboolean_type_node,\n-\t\t\t\t\tptr_type_node,\n-\t\t\t\t\tchannel,\n-\t\t\t\t\tuint64_type_node,\n-\t\t\t\t\tval);\n-\t  if (ret == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if there are too many operations on a\n-\t  // closed channel.\n-\t  TREE_NOTHROW(send_nonblocking_small_fndecl) = 0;\n-\t  return ret;\n-\t}\n-    }\n-  else\n-    {\n-      tree make_tmp;\n-      if (TREE_ADDRESSABLE(TREE_TYPE(val)) || TREE_CODE(val) == VAR_DECL)\n-\t{\n-\t  make_tmp = NULL_TREE;\n-\t  val = build_fold_addr_expr(val);\n-\t  if (DECL_P(val))\n-\t    TREE_ADDRESSABLE(val) = 1;\n-\t}\n-      else\n-\t{\n-\t  tree tmp = create_tmp_var(TREE_TYPE(val), get_name(val));\n-\t  DECL_IGNORED_P(tmp) = 0;\n-\t  DECL_INITIAL(tmp) = val;\n-\t  TREE_ADDRESSABLE(tmp) = 1;\n-\t  make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n-\t  SET_EXPR_LOCATION(make_tmp, location);\n-\t  val = build_fold_addr_expr(tmp);\n-\t}\n-      val = fold_convert(ptr_type_node, val);\n-\n-      tree call;\n-      if (blocking)\n-\t{\n-\t  static tree send_big_fndecl;\n-\t  call = Gogo::call_builtin(&send_big_fndecl,\n-\t\t\t\t    location,\n-\t\t\t\t    \"__go_send_big\",\n-\t\t\t\t    3,\n-\t\t\t\t    void_type_node,\n-\t\t\t\t    ptr_type_node,\n-\t\t\t\t    channel,\n-\t\t\t\t    ptr_type_node,\n-\t\t\t\t    val,\n-\t\t\t\t    boolean_type_node,\n-\t\t\t\t    (for_select\n-\t\t\t\t     ? boolean_true_node\n-\t\t\t\t     : boolean_false_node));\n-\t  if (call == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if there are too many operations on a\n-\t  // closed channel.\n-\t  TREE_NOTHROW(send_big_fndecl) = 0;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert(!for_select);\n-\t  static tree send_nonblocking_big_fndecl;\n-\t  call = Gogo::call_builtin(&send_nonblocking_big_fndecl,\n-\t\t\t\t    location,\n-\t\t\t\t    \"__go_send_nonblocking_big\",\n-\t\t\t\t    2,\n-\t\t\t\t    boolean_type_node,\n-\t\t\t\t    ptr_type_node,\n-\t\t\t\t    channel,\n-\t\t\t\t    ptr_type_node,\n-\t\t\t\t    val);\n-\t  if (call == error_mark_node)\n-\t    return error_mark_node;\n-\t  // This can panic if there are too many operations on a\n-\t  // closed channel.\n-\t  TREE_NOTHROW(send_nonblocking_big_fndecl) = 0;\n-\t}\n-\n-      if (make_tmp == NULL_TREE)\n-\treturn call;\n-      else\n-\t{\n-\t  tree ret = build2(COMPOUND_EXPR, TREE_TYPE(call), make_tmp, call);\n-\t  SET_EXPR_LOCATION(ret, location);\n-\t  return ret;\n-\t}\n-    }\n-}\n-\n // Return a tree for receiving a value of type TYPE_TREE on CHANNEL.\n // This does a blocking receive and returns the value read from the\n // channel.  If FOR_SELECT is true, this is being done because it was"}, {"sha": "b622d049e0569a879876b8789321d2d5df7ab06f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=a6de01a6ddfb5bab044091548df0f868bc208646", "patch": "@@ -526,11 +526,6 @@ class Gogo\n   tree\n   go_string_constant_tree(const std::string&);\n \n-  // Send a value on a channel.\n-  static tree\n-  send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n-\t\t  source_location);\n-\n   // Receive a value from a channel.\n   static tree\n   receive_from_channel(tree type_tree, tree channel, bool for_select,"}, {"sha": "4875ed71f6979dc1c96ff08041b5c1af1ba8ca08", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 102, "deletions": 11, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de01a6ddfb5bab044091548df0f868bc208646/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=a6de01a6ddfb5bab044091548df0f868bc208646", "patch": "@@ -3779,18 +3779,109 @@ Send_statement::do_check_types(Gogo*)\n tree\n Send_statement::do_get_tree(Translate_context* context)\n {\n-  tree channel = this->channel_->get_tree(context);\n-  tree val = this->val_->get_tree(context);\n-  if (channel == error_mark_node || val == error_mark_node)\n-    return error_mark_node;\n+  source_location loc = this->location();\n+\n   Channel_type* channel_type = this->channel_->type()->channel_type();\n-  val = Expression::convert_for_assignment(context,\n-\t\t\t\t\t   channel_type->element_type(),\n-\t\t\t\t\t   this->val_->type(),\n-\t\t\t\t\t   val,\n-\t\t\t\t\t   this->location());\n-  return Gogo::send_on_channel(channel, val, true, this->for_select_,\n-\t\t\t       this->location());\n+  Type* element_type = channel_type->element_type();\n+  Expression* val = Expression::make_cast(element_type, this->val_, loc);\n+\n+  bool is_small;\n+  bool can_take_address;\n+  switch (element_type->base()->classification())\n+    {\n+    case Type::TYPE_BOOLEAN:\n+    case Type::TYPE_INTEGER:\n+    case Type::TYPE_FUNCTION:\n+    case Type::TYPE_POINTER:\n+    case Type::TYPE_MAP:\n+    case Type::TYPE_CHANNEL:\n+      is_small = true;\n+      can_take_address = false;\n+      break;\n+\n+    case Type::TYPE_FLOAT:\n+    case Type::TYPE_COMPLEX:\n+    case Type::TYPE_STRING:\n+    case Type::TYPE_INTERFACE:\n+      is_small = false;\n+      can_take_address = false;\n+      break;\n+\n+    case Type::TYPE_STRUCT:\n+      is_small = false;\n+      can_take_address = true;\n+      break;\n+\n+    case Type::TYPE_ARRAY:\n+      is_small = false;\n+      can_take_address = !element_type->is_open_array_type();\n+      break;\n+\n+    default:\n+    case Type::TYPE_ERROR:\n+    case Type::TYPE_VOID:\n+    case Type::TYPE_SINK:\n+    case Type::TYPE_NIL:\n+    case Type::TYPE_NAMED:\n+    case Type::TYPE_FORWARD:\n+      gcc_assert(saw_errors());\n+      return error_mark_node;\n+    }\n+\n+  // Only try to take the address of a variable.  We have already\n+  // moved variables to the heap, so this should not cause that to\n+  // happen unnecessarily.\n+  if (can_take_address\n+      && val->var_expression() == NULL\n+      && val->temporary_reference_expression() == NULL)\n+    can_take_address = false;\n+\n+  Runtime::Function code;\n+  Bstatement* btemp = NULL;\n+  Expression* call;\n+  if (is_small)\n+      {\n+\t// Type is small enough to handle as uint64.\n+\tcode = Runtime::SEND_SMALL;\n+\tval = Expression::make_unsafe_cast(Type::lookup_integer_type(\"uint64\"),\n+\t\t\t\t\t   val, loc);\n+      }\n+  else if (can_take_address)\n+    {\n+      // Must pass address of value.  The function doesn't change the\n+      // value, so just take its address directly.\n+      code = Runtime::SEND_BIG;\n+      val = Expression::make_unary(OPERATOR_AND, val, loc);\n+    }\n+  else\n+    {\n+      // Must pass address of value, but the value is small enough\n+      // that it might be in registers.  Copy value into temporary\n+      // variable to take address.\n+      code = Runtime::SEND_BIG;\n+      Temporary_statement* temp = Statement::make_temporary(element_type,\n+\t\t\t\t\t\t\t    val, loc);\n+      Expression* ref = Expression::make_temporary_reference(temp, loc);\n+      val = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      btemp = tree_to_stat(temp->get_tree(context));\n+    }\n+\n+  call = Runtime::make_call(code, loc, 3, this->channel_, val,\n+\t\t\t    Expression::make_boolean(this->for_select_, loc));\n+\n+  context->gogo()->lower_expression(context->function(), &call);\n+  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n+  Bstatement* s = context->backend()->expression_statement(bcall);\n+\n+  if (btemp == NULL)\n+    return stat_to_tree(s);\n+  else\n+    {\n+      std::vector<Bstatement*> stats(2);\n+      stats[0] = btemp;\n+      stats[1] = s;\n+      return stat_to_tree(context->backend()->statement_list(stats));\n+    }\n }\n \n // Make a send statement."}]}