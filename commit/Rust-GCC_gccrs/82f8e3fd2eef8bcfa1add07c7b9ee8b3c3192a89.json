{"sha": "82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJmOGUzZmQyZWVmOGJjZmExYWRkMDdjN2I5ZWU4YjNjMzE5MmE4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:22:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:22:21Z"}, "message": "read-rtl.c (md_name): New structure.\n\ngcc/\n\t* read-rtl.c (md_name): New structure.\n\t(read_name): Take an md_name instead of a buffer pointer.\n\tUse the \"string\" field instead of strcpy when expanding constants.\n\t(read_constants): Remove the tmp_char argument.  Update the calls\n\tto read_name, using two local name buffers instead of the tmp_char\n\targument.  Merge the constant-creation code.\n\t(read_conditions): Remove the tmp_char argument.  Update the calls\n\tto read_name, using a local name buffer instead of the tmp_char\n\targument.\n\t(read_mapping): Replace tmp_char variable with a local name buffer.\n\tUpdate the calls to read_name.\n\t(read_rtx_1): Likewise.  Update the calls to read_constants and\n\tread_conditions.\n\nFrom-SVN: r160574", "tree": {"sha": "d81c5651475024cbb881c2a40b61508ea4e36d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d81c5651475024cbb881c2a40b61508ea4e36d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb933490c3e9c3347c1566662688c6cafa6768e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb933490c3e9c3347c1566662688c6cafa6768e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb933490c3e9c3347c1566662688c6cafa6768e5"}], "stats": {"total": 189, "additions": 111, "deletions": 78}, "files": [{"sha": "7d62dc4387aaeb92b9b4b66523390702d13d8776", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "patch": "@@ -1,3 +1,19 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* read-rtl.c (md_name): New structure.\n+\t(read_name): Take an md_name instead of a buffer pointer.\n+\tUse the \"string\" field instead of strcpy when expanding constants.\n+\t(read_constants): Remove the tmp_char argument.  Update the calls\n+\tto read_name, using two local name buffers instead of the tmp_char\n+\targument.  Merge the constant-creation code.\n+\t(read_conditions): Remove the tmp_char argument.  Update the calls\n+\tto read_name, using a local name buffer instead of the tmp_char\n+\targument.\n+\t(read_mapping): Replace tmp_char variable with a local name buffer.\n+\tUpdate the calls to read_name.\n+\t(read_rtx_1): Likewise.  Update the calls to read_constants and\n+\tread_conditions.\n+\n 2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (build/read-md.o): Depend on errors.h."}, {"sha": "1b7d77d09c5324d204d9a7ffb71d5681035ae7ee", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 95, "deletions": 78, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=82f8e3fd2eef8bcfa1add07c7b9ee8b3c3192a89", "patch": "@@ -35,6 +35,17 @@ along with GCC; see the file COPYING3.  If not see\n \n static htab_t md_constants;\n \n+/* Holds one symbol or number in the .md file.  */\n+struct md_name {\n+  /* The name as it appeared in the .md file.  Names are syntactically\n+     limited to the length of this buffer.  */\n+  char buffer[256];\n+\n+  /* The name that should actually be used by the generator programs.\n+     This is an expansion of NAME, after things like constant substitution.  */\n+  char *string;\n+};\n+\n /* One element in a singly-linked list of (integer, string) pairs.  */\n struct map_value {\n   struct map_value *next;\n@@ -114,11 +125,11 @@ static struct mapping *add_mapping (struct iterator_group *, htab_t t,\n static struct map_value **add_map_value (struct map_value **,\n \t\t\t\t\t int, const char *);\n static void initialize_iterators (void);\n-static void read_name (char *);\n+static void read_name (struct md_name *);\n static hashval_t def_hash (const void *);\n static int def_name_eq_p (const void *, const void *);\n-static void read_constants (char *tmp_char);\n-static void read_conditions (char *tmp_char);\n+static void read_constants (void);\n+static void read_conditions (void);\n static void validate_const_int (const char *);\n static int find_iterator (struct iterator_group *, const char *);\n static struct mapping *read_mapping (struct iterator_group *, htab_t);\n@@ -611,55 +622,60 @@ initialize_iterators (void)\n     }\n }\n \n-/* Read an rtx code name into the buffer STR[].\n-   It is terminated by any of the punctuation chars of rtx printed syntax.  */\n+/* Read an rtx code name into NAME.  It is terminated by any of the\n+   punctuation chars of rtx printed syntax.  */\n \n static void\n-read_name (char *str)\n+read_name (struct md_name *name)\n {\n-  char *p;\n   int c;\n+  size_t i;\n \n   c = read_skip_spaces ();\n \n-  p = str;\n+  i = 0;\n   while (1)\n     {\n-      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f' || c == '\\r' || c == EOF)\n+      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f' || c == '\\r'\n+\t  || c == EOF)\n \tbreak;\n       if (c == ':' || c == ')' || c == ']' || c == '\"' || c == '/'\n \t  || c == '(' || c == '[')\n \t{\n \t  unread_char (c);\n \t  break;\n \t}\n-      *p++ = c;\n+\n+      if (i == sizeof (name->buffer) - 1)\n+\tfatal_with_file_and_line (\"name too long\");\n+      name->buffer[i++] = c;\n+\n       c = read_char ();\n     }\n-  if (p == str)\n+\n+  if (i == 0)\n     fatal_with_file_and_line (\"missing name or number\");\n   if (c == '\\n')\n     read_md_lineno++;\n \n-  *p = 0;\n+  name->buffer[i] = 0;\n+  name->string = name->buffer;\n \n   if (md_constants)\n     {\n       /* Do constant expansion.  */\n       struct md_constant *def;\n \n-      p = str;\n       do\n \t{\n \t  struct md_constant tmp_def;\n \n-\t  tmp_def.name = p;\n+\t  tmp_def.name = name->string;\n \t  def = (struct md_constant *) htab_find (md_constants, &tmp_def);\n \t  if (def)\n-\t    p = def->value;\n-\t} while (def);\n-      if (p != str)\n-\tstrcpy (str, p);\n+\t    name->string = def->value;\n+\t}\n+      while (def);\n     }\n }\n \f\n@@ -723,49 +739,53 @@ def_name_eq_p (const void *def1, const void *def2)\n \t\t   *(const char *const *) def2);\n }\n \n-/* TMP_CHAR is a buffer suitable to read a name or number into.  Process\n-   a define_constants directive, starting with the optional space after\n-   the \"define_constants\".  */\n+/* Process a define_constants directive, starting with the optional space\n+   after the \"define_constants\".  */\n static void\n-read_constants (char *tmp_char)\n+read_constants (void)\n {\n   int c;\n   htab_t defs;\n \n   c = read_skip_spaces ();\n   if (c != '[')\n     fatal_expected_char ('[', c);\n+\n   defs = md_constants;\n   if (! defs)\n     defs = htab_create (32, def_hash, def_name_eq_p, (htab_del) 0);\n+\n   /* Disable constant expansion during definition processing.  */\n   md_constants = 0;\n   while ( (c = read_skip_spaces ()) != ']')\n     {\n-      struct md_constant *def;\n+      struct md_name name, value;\n+      struct md_constant *def, tmp_def;\n       void **entry_ptr;\n \n       if (c != '(')\n \tfatal_expected_char ('(', c);\n-      def = XNEW (struct md_constant);\n-      def->name = tmp_char;\n-      read_name (tmp_char);\n-      entry_ptr = htab_find_slot (defs, def, INSERT);\n-      if (! *entry_ptr)\n-\tdef->name = xstrdup (tmp_char);\n-      read_name (tmp_char);\n-      if (! *entry_ptr)\n+\n+      read_name (&name);\n+      read_name (&value);\n+\n+      tmp_def.name = name.string;\n+      entry_ptr = htab_find_slot (defs, &tmp_def, INSERT);\n+      if (*entry_ptr)\n \t{\n-\t  def->value = xstrdup (tmp_char);\n-\t  *entry_ptr = def;\n+\t  def = (struct md_constant *) *entry_ptr;\n+\t  if (strcmp (def->value, value.string) != 0)\n+\t    fatal_with_file_and_line (\"redefinition of %s, was %s, now %s\",\n+\t\t\t\t      def->name, def->value, value.string);\n \t}\n       else\n \t{\n-\t  def = (struct md_constant *) *entry_ptr;\n-\t  if (strcmp (def->value, tmp_char))\n-\t    fatal_with_file_and_line (\"redefinition of %s, was %s, now %s\",\n-\t\t\t\t      def->name, def->value, tmp_char);\n+\t  def = XNEW (struct md_constant);\n+\t  def->name = xstrdup (name.string);\n+\t  def->value = xstrdup (value.string);\n+\t  *entry_ptr = def;\n \t}\n+\n       c = read_skip_spaces ();\n       if (c != ')')\n \tfatal_expected_char (')', c);\n@@ -786,9 +806,8 @@ traverse_md_constants (htab_trav callback, void *info)\n     htab_traverse (md_constants, callback, info);\n }\n \f\n-/* TMP_CHAR is a buffer suitable to read a name or number into.  Process\n-   a define_conditions directive, starting with the optional space after\n-   the \"define_conditions\".  The directive looks like this:\n+/* Process a define_conditions directive, starting with the optional\n+   space after the \"define_conditions\".  The directive looks like this:\n \n      (define_conditions [\n         (number \"string\")\n@@ -801,7 +820,7 @@ traverse_md_constants (htab_trav callback, void *info)\n    slipped in at the beginning of the sequence of MD files read by\n    most of the other generators.  */\n static void\n-read_conditions (char *tmp_char)\n+read_conditions (void)\n {\n   int c;\n \n@@ -811,15 +830,16 @@ read_conditions (char *tmp_char)\n \n   while ( (c = read_skip_spaces ()) != ']')\n     {\n+      struct md_name name;\n       char *expr;\n       int value;\n \n       if (c != '(')\n \tfatal_expected_char ('(', c);\n \n-      read_name (tmp_char);\n-      validate_const_int (tmp_char);\n-      value = atoi (tmp_char);\n+      read_name (&name);\n+      validate_const_int (name.string);\n+      value = atoi (name.string);\n \n       c = read_skip_spaces ();\n       if (c != '\"')\n@@ -884,15 +904,15 @@ find_iterator (struct iterator_group *group, const char *name)\n static struct mapping *\n read_mapping (struct iterator_group *group, htab_t table)\n {\n-  char tmp_char[256];\n+  struct md_name name;\n   struct mapping *m;\n   struct map_value **end_ptr;\n   const char *string;\n   int number, c;\n \n   /* Read the mapping name and create a structure for it.  */\n-  read_name (tmp_char);\n-  m = add_mapping (group, table, tmp_char);\n+  read_name (&name);\n+  m = add_mapping (group, table, name.string);\n \n   c = read_skip_spaces ();\n   if (c != '[')\n@@ -908,19 +928,19 @@ read_mapping (struct iterator_group *group, htab_t table)\n \t  /* A bare symbol name that is implicitly paired to an\n \t     empty string.  */\n \t  unread_char (c);\n-\t  read_name (tmp_char);\n+\t  read_name (&name);\n \t  string = \"\";\n \t}\n       else\n \t{\n \t  /* A \"(name string)\" pair.  */\n-\t  read_name (tmp_char);\n+\t  read_name (&name);\n \t  string = read_string (false);\n \t  c = read_skip_spaces ();\n \t  if (c != ')')\n \t    fatal_expected_char (')', c);\n \t}\n-      number = group->find_builtin (tmp_char);\n+      number = group->find_builtin (name.string);\n       end_ptr = add_map_value (end_ptr, number, string);\n       c = read_skip_spaces ();\n     }\n@@ -1025,10 +1045,7 @@ read_rtx_1 (struct map_value **mode_maps)\n   int i;\n   RTX_CODE real_code, bellwether_code;\n   const char *format_ptr;\n-  /* tmp_char is a buffer used for reading decimal integers\n-     and names of rtx types and machine modes.\n-     Therefore, 256 must be enough.  */\n-  char tmp_char[256];\n+  struct md_name name;\n   rtx return_rtx;\n   int c;\n   int tmp_int;\n@@ -1050,46 +1067,46 @@ read_rtx_1 (struct map_value **mode_maps)\n   if (c != '(')\n     fatal_expected_char ('(', c);\n \n-  read_name (tmp_char);\n-  if (strcmp (tmp_char, \"nil\") == 0)\n+  read_name (&name);\n+  if (strcmp (name.string, \"nil\") == 0)\n     {\n       /* (nil) stands for an expression that isn't there.  */\n       c = read_skip_spaces ();\n       if (c != ')')\n \tfatal_expected_char (')', c);\n       return 0;\n     }\n-  if (strcmp (tmp_char, \"define_constants\") == 0)\n+  if (strcmp (name.string, \"define_constants\") == 0)\n     {\n-      read_constants (tmp_char);\n+      read_constants ();\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_conditions\") == 0)\n+  if (strcmp (name.string, \"define_conditions\") == 0)\n     {\n-      read_conditions (tmp_char);\n+      read_conditions ();\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_mode_attr\") == 0)\n+  if (strcmp (name.string, \"define_mode_attr\") == 0)\n     {\n       read_mapping (&modes, modes.attrs);\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_mode_iterator\") == 0)\n+  if (strcmp (name.string, \"define_mode_iterator\") == 0)\n     {\n       read_mapping (&modes, modes.iterators);\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_code_attr\") == 0)\n+  if (strcmp (name.string, \"define_code_attr\") == 0)\n     {\n       read_mapping (&codes, codes.attrs);\n       goto again;\n     }\n-  if (strcmp (tmp_char, \"define_code_iterator\") == 0)\n+  if (strcmp (name.string, \"define_code_iterator\") == 0)\n     {\n       check_code_iterator (read_mapping (&codes, codes.iterators));\n       goto again;\n     }\n-  real_code = (enum rtx_code) find_iterator (&codes, tmp_char);\n+  real_code = (enum rtx_code) find_iterator (&codes, name.string);\n   bellwether_code = BELLWETHER_CODE (real_code);\n \n   /* If we end up with an insn expression then we free this space below.  */\n@@ -1105,11 +1122,11 @@ read_rtx_1 (struct map_value **mode_maps)\n     {\n       unsigned int mode;\n \n-      read_name (tmp_char);\n-      if (tmp_char[0] != '<' || tmp_char[strlen (tmp_char) - 1] != '>')\n-\tmode = find_iterator (&modes, tmp_char);\n+      read_name (&name);\n+      if (name.string[0] != '<' || name.string[strlen (name.string) - 1] != '>')\n+\tmode = find_iterator (&modes, name.string);\n       else\n-\tmode = mode_attr_index (mode_maps, tmp_char);\n+\tmode = mode_attr_index (mode_maps, name.string);\n       PUT_MODE (return_rtx, (enum machine_mode) mode);\n       if (GET_MODE (return_rtx) != mode)\n \tfatal_with_file_and_line (\"mode too large\");\n@@ -1233,20 +1250,20 @@ read_rtx_1 (struct map_value **mode_maps)\n \tbreak;\n \n       case 'w':\n-\tread_name (tmp_char);\n-\tvalidate_const_int (tmp_char);\n+\tread_name (&name);\n+\tvalidate_const_int (name.string);\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\ttmp_wide = atoi (tmp_char);\n+\ttmp_wide = atoi (name.string);\n #else\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n-\ttmp_wide = atol (tmp_char);\n+\ttmp_wide = atol (name.string);\n #else\n \t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n \t   But prefer not to use our hand-rolled function above either.  */\n #if defined(HAVE_ATOLL) || !defined(HAVE_ATOQ)\n-\ttmp_wide = atoll (tmp_char);\n+\ttmp_wide = atoll (name.string);\n #else\n-\ttmp_wide = atoq (tmp_char);\n+\ttmp_wide = atoq (name.string);\n #endif\n #endif\n #endif\n@@ -1255,9 +1272,9 @@ read_rtx_1 (struct map_value **mode_maps)\n \n       case 'i':\n       case 'n':\n-\tread_name (tmp_char);\n-\tvalidate_const_int (tmp_char);\n-\ttmp_int = atoi (tmp_char);\n+\tread_name (&name);\n+\tvalidate_const_int (name.string);\n+\ttmp_int = atoi (name.string);\n \tXINT (return_rtx, i) = tmp_int;\n \tbreak;\n "}]}