{"sha": "b5407ad1efa9c19efa34d187ad9ee60f248ede60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0MDdhZDFlZmE5YzE5ZWZhMzRkMTg3YWQ5ZWU2MGYyNDhlZGU2MA==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-01-17T04:35:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-17T04:35:40Z"}, "message": "compiler: Use backend interface for binary expressions.\n\n\t* go-gcc.cc (Gcc_backend::conditional_expression): Add btype\n\tparameter.\n\t(operator_to_tree_code): New static function.\n\t(Gcc_backend::binary_expression): New function.\n\nFrom-SVN: r206696", "tree": {"sha": "e2af79a4381d2e47953832502a194400882303e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2af79a4381d2e47953832502a194400882303e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5407ad1efa9c19efa34d187ad9ee60f248ede60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5407ad1efa9c19efa34d187ad9ee60f248ede60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5407ad1efa9c19efa34d187ad9ee60f248ede60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5407ad1efa9c19efa34d187ad9ee60f248ede60/comments", "author": null, "committer": null, "parents": [{"sha": "f910753dbe1faad4ec8295f621c5177214fe8232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f910753dbe1faad4ec8295f621c5177214fe8232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f910753dbe1faad4ec8295f621c5177214fe8232"}], "stats": {"total": 597, "additions": 347, "deletions": 250}, "files": [{"sha": "68784052b053ec0f3b11d6e4452bad282c54d963", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=b5407ad1efa9c19efa34d187ad9ee60f248ede60", "patch": "@@ -1,3 +1,10 @@\n+2014-01-16  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::conditional_expression): Add btype\n+\tparameter.\n+\t(operator_to_tree_code): New static function.\n+\t(Gcc_backend::binary_expression): New function.\n+\n 2014-01-14  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Gcc_backend::compound_expression): New function."}, {"sha": "6a0d1e7a001a8e3a564383afa85ccbabe9a5b898", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 128, "deletions": 4, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=b5407ad1efa9c19efa34d187ad9ee60f248ede60", "patch": "@@ -250,7 +250,11 @@ class Gcc_backend : public Backend\n   compound_expression(Bstatement*, Bexpression*, Location);\n \n   Bexpression*\n-  conditional_expression(Bexpression*, Bexpression*, Bexpression*, Location);\n+  conditional_expression(Btype*, Bexpression*, Bexpression*, Bexpression*,\n+                         Location);\n+\n+  Bexpression*\n+  binary_expression(Operator, Bexpression*, Bexpression*, Location);\n \n   // Statements.\n \n@@ -1059,22 +1063,142 @@ Gcc_backend::compound_expression(Bstatement* bstat, Bexpression* bexpr,\n // ELSE_EXPR otherwise.\n \n Bexpression*\n-Gcc_backend::conditional_expression(Bexpression* condition,\n+Gcc_backend::conditional_expression(Btype* btype, Bexpression* condition,\n                                     Bexpression* then_expr,\n                                     Bexpression* else_expr, Location location)\n {\n+  tree type_tree = btype == NULL ? void_type_node : btype->get_tree();\n   tree cond_tree = condition->get_tree();\n   tree then_tree = then_expr->get_tree();\n   tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree();\n-  if (cond_tree == error_mark_node\n+  if (type_tree == error_mark_node\n+      || cond_tree == error_mark_node\n       || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n     return this->error_expression();\n-  tree ret = build3_loc(location.gcc_location(), COND_EXPR, void_type_node,\n+  tree ret = build3_loc(location.gcc_location(), COND_EXPR, type_tree,\n                         cond_tree, then_tree, else_tree);\n   return this->make_expression(ret);\n }\n \n+// Convert a gofrontend operator to an equivalent tree_code.\n+\n+static enum tree_code\n+operator_to_tree_code(Operator op, tree type)\n+{\n+  enum tree_code code;\n+  switch (op)\n+    {\n+    case OPERATOR_EQEQ:\n+      code = EQ_EXPR;\n+      break;\n+    case OPERATOR_NOTEQ:\n+      code = NE_EXPR;\n+      break;\n+    case OPERATOR_LT:\n+      code = LT_EXPR;\n+      break;\n+    case OPERATOR_LE:\n+      code = LE_EXPR;\n+      break;\n+    case OPERATOR_GT:\n+      code = GT_EXPR;\n+      break;\n+    case OPERATOR_GE:\n+      code = GE_EXPR;\n+      break;\n+    case OPERATOR_OROR:\n+      code = TRUTH_ORIF_EXPR;\n+      break;\n+    case OPERATOR_ANDAND:\n+      code = TRUTH_ANDIF_EXPR;\n+      break;\n+    case OPERATOR_PLUS:\n+      code = PLUS_EXPR;\n+      break;\n+    case OPERATOR_MINUS:\n+      code = MINUS_EXPR;\n+      break;\n+    case OPERATOR_OR:\n+      code = BIT_IOR_EXPR;\n+      break;\n+    case OPERATOR_XOR:\n+      code = BIT_XOR_EXPR;\n+      break;\n+    case OPERATOR_MULT:\n+      code = MULT_EXPR;\n+      break;\n+    case OPERATOR_DIV:\n+      if (TREE_CODE(type) == REAL_TYPE || TREE_CODE(type) == COMPLEX_TYPE)\n+\tcode = RDIV_EXPR;\n+      else\n+\tcode = TRUNC_DIV_EXPR;\n+      break;\n+    case OPERATOR_MOD:\n+      code = TRUNC_MOD_EXPR;\n+      break;\n+    case OPERATOR_LSHIFT:\n+      code = LSHIFT_EXPR;\n+      break;\n+    case OPERATOR_RSHIFT:\n+      code = RSHIFT_EXPR;\n+      break;\n+    case OPERATOR_AND:\n+      code = BIT_AND_EXPR;\n+      break;\n+    case OPERATOR_BITCLEAR:\n+      code = BIT_AND_EXPR;\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+\n+  return code;\n+}\n+\n+// Return an expression for the binary operation LEFT OP RIGHT.\n+\n+Bexpression*\n+Gcc_backend::binary_expression(Operator op, Bexpression* left,\n+                               Bexpression* right, Location location)\n+{\n+  tree left_tree = left->get_tree();\n+  tree right_tree = right->get_tree();\n+  if (left_tree == error_mark_node\n+      || right_tree == error_mark_node)\n+    return this->error_expression();\n+  enum tree_code code = operator_to_tree_code(op, TREE_TYPE(left_tree));\n+\n+  bool use_left_type = op != OPERATOR_OROR && op != OPERATOR_ANDAND;\n+  tree type_tree = use_left_type ? TREE_TYPE(left_tree) : TREE_TYPE(right_tree);\n+  tree computed_type = excess_precision_type(type_tree);\n+  if (computed_type != NULL_TREE)\n+    {\n+      left_tree = convert(computed_type, left_tree);\n+      right_tree = convert(computed_type, right_tree);\n+      type_tree = computed_type;\n+    }\n+\n+  // For comparison operators, the resulting type should be boolean.\n+  switch (op)\n+    {\n+    case OPERATOR_EQEQ:\n+    case OPERATOR_NOTEQ:\n+    case OPERATOR_LT:\n+    case OPERATOR_LE:\n+    case OPERATOR_GT:\n+    case OPERATOR_GE:\n+      type_tree = boolean_type_node;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  tree ret = fold_build2_loc(location.gcc_location(), code, type_tree,\n+                             left_tree, right_tree);\n+  return this->make_expression(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "e3025167fd449d6f19ce1ac19a4287f5ea71e95d", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=b5407ad1efa9c19efa34d187ad9ee60f248ede60", "patch": "@@ -10,6 +10,8 @@\n #include <gmp.h>\n #include <mpfr.h>\n \n+#include \"operator.h\"\n+\n // Pointers to these types are created by the backend, passed to the\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n@@ -289,10 +291,20 @@ class Backend\n   compound_expression(Bstatement* bstat, Bexpression* bexpr, Location) = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n-  // ELSE_EXPR otherwise.  ELSE_EXPR may be NULL.\n+  // ELSE_EXPR otherwise and returns the result as type BTYPE.  ELSE_EXPR\n+  // may be NULL.  BTYPE may be NULL.\n+  virtual Bexpression*\n+  conditional_expression(Btype* btype, Bexpression* condition,\n+                         Bexpression* then_expr, Bexpression* else_expr,\n+                         Location) = 0;\n+\n+  // Return an expression for the binary operation LEFT OP RIGHT.\n+  // Supported values of OP are (from operators.h):\n+  //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,\n+  //    LSHIFT, RSHIFT, AND, NOT.\n   virtual Bexpression*\n-  conditional_expression(Bexpression* condition, Bexpression* then_expr,\n-                         Bexpression* else_expr, Location) = 0;\n+  binary_expression(Operator op, Bexpression* left, Bexpression* right,\n+                    Location) = 0;\n \n   // Statements.\n "}, {"sha": "544996ea6cbdc0a4c0a26029a5497c519ea50e61", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 190, "deletions": 239, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b5407ad1efa9c19efa34d187ad9ee60f248ede60", "patch": "@@ -5536,6 +5536,61 @@ Binary_expression::lower_compare_to_memcmp(Gogo*, Statement_inserter* inserter)\n   return Expression::make_binary(this->op_, call, zero, loc);\n }\n \n+Expression*\n+Binary_expression::do_flatten(Gogo*, Named_object*,\n+                              Statement_inserter* inserter)\n+{\n+  Location loc = this->location();\n+  Temporary_statement* temp;\n+  if (this->left_->type()->is_string_type()\n+      && this->op_ == OPERATOR_PLUS)\n+    {\n+      if (!this->left_->is_variable())\n+        {\n+          temp = Statement::make_temporary(NULL, this->left_, loc);\n+          inserter->insert(temp);\n+          this->left_ = Expression::make_temporary_reference(temp, loc);\n+        }\n+      if (!this->right_->is_variable())\n+        {\n+          temp =\n+              Statement::make_temporary(this->left_->type(), this->right_, loc);\n+          this->right_ = Expression::make_temporary_reference(temp, loc);\n+          inserter->insert(temp);\n+        }\n+    }\n+\n+  Type* left_type = this->left_->type();\n+  bool is_shift_op = (this->op_ == OPERATOR_LSHIFT\n+                      || this->op_ == OPERATOR_RSHIFT);\n+  bool is_idiv_op = ((this->op_ == OPERATOR_DIV &&\n+                      left_type->integer_type() != NULL)\n+                     || this->op_ == OPERATOR_MOD);\n+\n+  // FIXME: go_check_divide_zero and go_check_divide_overflow are globals\n+  // defined in gcc/go/lang.opt.  These should be defined in go_create_gogo\n+  // and accessed from the Gogo* passed to do_flatten.\n+  if (is_shift_op\n+      || (is_idiv_op && (go_check_divide_zero || go_check_divide_overflow)))\n+    {\n+      if (!this->left_->is_variable())\n+        {\n+          temp = Statement::make_temporary(NULL, this->left_, loc);\n+          inserter->insert(temp);\n+          this->left_ = Expression::make_temporary_reference(temp, loc);\n+        }\n+      if (!this->right_->is_variable())\n+        {\n+          temp =\n+              Statement::make_temporary(NULL, this->right_, loc);\n+          this->right_ = Expression::make_temporary_reference(temp, loc);\n+          inserter->insert(temp);\n+        }\n+    }\n+  return this;\n+}\n+\n+\n // Return the address of EXPR, cast to unsafe.Pointer.\n \n Expression*\n@@ -5956,14 +6011,10 @@ tree\n Binary_expression::do_get_tree(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n+  Location loc = this->location();\n+  Type* left_type = this->left_->type();\n+  Type* right_type = this->right_->type();\n \n-  tree left = this->left_->get_tree(context);\n-  tree right = this->right_->get_tree(context);\n-\n-  if (left == error_mark_node || right == error_mark_node)\n-    return error_mark_node;\n-\n-  enum tree_code code;\n   bool use_left_type = true;\n   bool is_shift_op = false;\n   bool is_idiv_op = false;\n@@ -5975,198 +6026,126 @@ Binary_expression::do_get_tree(Translate_context* context)\n     case OPERATOR_LE:\n     case OPERATOR_GT:\n     case OPERATOR_GE:\n-      return Expression::comparison_tree(context, this->type_, this->op_,\n-\t\t\t\t\t this->left_, this->right_,\n-\t\t\t\t\t this->location());\n+      {\n+        Bexpression* ret =\n+            Expression::comparison(context, this->type_, this->op_,\n+                                   this->left_, this->right_, loc);\n+        return expr_to_tree(ret);\n+      }\n \n     case OPERATOR_OROR:\n-      code = TRUTH_ORIF_EXPR;\n-      use_left_type = false;\n-      break;\n     case OPERATOR_ANDAND:\n-      code = TRUTH_ANDIF_EXPR;\n       use_left_type = false;\n       break;\n     case OPERATOR_PLUS:\n-      code = PLUS_EXPR;\n-      break;\n     case OPERATOR_MINUS:\n-      code = MINUS_EXPR;\n-      break;\n     case OPERATOR_OR:\n-      code = BIT_IOR_EXPR;\n-      break;\n     case OPERATOR_XOR:\n-      code = BIT_XOR_EXPR;\n-      break;\n     case OPERATOR_MULT:\n-      code = MULT_EXPR;\n       break;\n     case OPERATOR_DIV:\n-      {\n-\tType *t = this->left_->type();\n-\tif (t->float_type() != NULL || t->complex_type() != NULL)\n-\t  code = RDIV_EXPR;\n-\telse\n-\t  {\n-\t    code = TRUNC_DIV_EXPR;\n-\t    is_idiv_op = true;\n-\t  }\n-      }\n-      break;\n+      if (left_type->float_type() != NULL || left_type->complex_type() != NULL)\n+        break;\n     case OPERATOR_MOD:\n-      code = TRUNC_MOD_EXPR;\n       is_idiv_op = true;\n       break;\n     case OPERATOR_LSHIFT:\n-      code = LSHIFT_EXPR;\n-      is_shift_op = true;\n-      break;\n     case OPERATOR_RSHIFT:\n-      code = RSHIFT_EXPR;\n       is_shift_op = true;\n       break;\n-    case OPERATOR_AND:\n-      code = BIT_AND_EXPR;\n-      break;\n     case OPERATOR_BITCLEAR:\n-      right = fold_build1(BIT_NOT_EXPR, TREE_TYPE(right), right);\n-      code = BIT_AND_EXPR;\n+      this->right_ = Expression::make_unary(OPERATOR_XOR, this->right_, loc);\n+    case OPERATOR_AND:\n       break;\n     default:\n       go_unreachable();\n     }\n \n-  location_t gccloc = this->location().gcc_location();\n-  tree type = use_left_type ? TREE_TYPE(left) : TREE_TYPE(right);\n-\n-  if (this->left_->type()->is_string_type())\n+  if (left_type->is_string_type())\n     {\n       go_assert(this->op_ == OPERATOR_PLUS);\n-      Type* st = Type::make_string_type();\n-      tree string_type = type_to_tree(st->get_backend(gogo));\n-      static tree string_plus_decl;\n-      return Gogo::call_builtin(&string_plus_decl,\n-\t\t\t\tthis->location(),\n-\t\t\t\t\"__go_string_plus\",\n-\t\t\t\t2,\n-\t\t\t\tstring_type,\n-\t\t\t\tstring_type,\n-\t\t\t\tleft,\n-\t\t\t\tstring_type,\n-\t\t\t\tright);\n-    }\n-\n-  // For complex division Go wants slightly different results than the\n-  // GCC library provides, so we have our own runtime routine.\n+      Expression* string_plus =\n+          Runtime::make_call(Runtime::STRING_PLUS, loc, 2,\n+                             this->left_, this->right_);\n+      return string_plus->get_tree(context);\n+    }\n+\n+  // For complex division Go might want slightly different results than the\n+  // backend implementation provides, so we have our own runtime routine.\n   if (this->op_ == OPERATOR_DIV && this->left_->type()->complex_type() != NULL)\n     {\n-      const char *name;\n-      tree *pdecl;\n-      Type* ctype;\n-      static tree complex64_div_decl;\n-      static tree complex128_div_decl;\n+      Runtime::Function complex_code;\n       switch (this->left_->type()->complex_type()->bits())\n \t{\n \tcase 64:\n-\t  name = \"__go_complex64_div\";\n-\t  pdecl = &complex64_div_decl;\n-\t  ctype = Type::lookup_complex_type(\"complex64\");\n+          complex_code = Runtime::COMPLEX64_DIV;\n \t  break;\n \tcase 128:\n-\t  name = \"__go_complex128_div\";\n-\t  pdecl = &complex128_div_decl;\n-\t  ctype = Type::lookup_complex_type(\"complex128\");\n+          complex_code = Runtime::COMPLEX128_DIV;\n \t  break;\n \tdefault:\n \t  go_unreachable();\n \t}\n-      Btype* cbtype = ctype->get_backend(gogo);\n-      tree ctype_tree = type_to_tree(cbtype);\n-      return Gogo::call_builtin(pdecl,\n-\t\t\t\tthis->location(),\n-\t\t\t\tname,\n-\t\t\t\t2,\n-\t\t\t\tctype_tree,\n-\t\t\t\tctype_tree,\n-\t\t\t\tfold_convert_loc(gccloc, ctype_tree, left),\n-\t\t\t\ttype,\n-\t\t\t\tfold_convert_loc(gccloc, ctype_tree, right));\n+      Expression* complex_div =\n+          Runtime::make_call(complex_code, loc, 2, this->left_, this->right_);\n+      return complex_div->get_tree(context);\n     }\n \n-  tree compute_type = excess_precision_type(type);\n-  if (compute_type != NULL_TREE)\n-    {\n-      left = ::convert(compute_type, left);\n-      right = ::convert(compute_type, right);\n-    }\n+  Bexpression* left = tree_to_expr(this->left_->get_tree(context));\n+  Bexpression* right = tree_to_expr(this->right_->get_tree(context));\n \n-  tree eval_saved = NULL_TREE;\n-  if (is_shift_op\n-      || (is_idiv_op && (go_check_divide_zero || go_check_divide_overflow)))\n-    {\n-      // Make sure the values are evaluated.\n-      if (!DECL_P(left))\n-\t{\n-\t  left = save_expr(left);\n-\t  eval_saved = left;\n-\t}\n-      if (!DECL_P(right))\n-\t{\n-\t  right = save_expr(right);\n-\t  if (eval_saved == NULL_TREE)\n-\t    eval_saved = right;\n-\t  else\n-\t    eval_saved = fold_build2_loc(gccloc, COMPOUND_EXPR,\n-\t\t\t\t\t void_type_node, eval_saved, right);\n-\t}\n-    }\n+  Type* type = use_left_type ? left_type : right_type;\n+  Btype* btype = type->get_backend(gogo);\n+\n+  Bexpression* ret =\n+      gogo->backend()->binary_expression(this->op_, left, right, loc);\n+  ret = gogo->backend()->convert_expression(btype, ret, loc);\n \n-  tree ret = fold_build2_loc(gccloc, code,\n-\t\t\t     compute_type != NULL_TREE ? compute_type : type,\n-\t\t\t     left, right);\n+  // Initialize overflow constants.\n+  Bexpression* overflow;\n+  mpz_t zero;\n+  mpz_init_set_ui(zero, 0UL);\n+  mpz_t one;\n+  mpz_init_set_ui(one, 1UL);\n+  mpz_t neg_one;\n+  mpz_init_set_si(neg_one, -1);\n \n-  if (compute_type != NULL_TREE)\n-    ret = ::convert(type, ret);\n+  Btype* left_btype = left_type->get_backend(gogo);\n+  Btype* right_btype = right_type->get_backend(gogo);\n \n   // In Go, a shift larger than the size of the type is well-defined.\n-  // This is not true in GENERIC, so we need to insert a conditional.\n+  // This is not true in C, so we need to insert a conditional.\n   if (is_shift_op)\n     {\n-      go_assert(INTEGRAL_TYPE_P(TREE_TYPE(left)));\n-      go_assert(this->left_->type()->integer_type() != NULL);\n-      int bits = TYPE_PRECISION(TREE_TYPE(left));\n+      go_assert(left_type->integer_type() != NULL);\n \n-      tree compare = fold_build2(LT_EXPR, boolean_type_node, right,\n-\t\t\t\t build_int_cst_type(TREE_TYPE(right), bits));\n+      mpz_t bitsval;\n+      int bits = left_type->integer_type()->bits();\n+      mpz_init_set_ui(bitsval, bits);\n+      Bexpression* bits_expr =\n+          gogo->backend()->integer_constant_expression(right_btype, bitsval);\n+      Bexpression* compare =\n+          gogo->backend()->binary_expression(OPERATOR_LT,\n+                                             right, bits_expr, loc);\n \n-      tree overflow_result = fold_convert_loc(gccloc, TREE_TYPE(left),\n-\t\t\t\t\t      integer_zero_node);\n+      Bexpression* zero_expr =\n+          gogo->backend()->integer_constant_expression(left_btype, zero);\n+      overflow = zero_expr;\n       if (this->op_ == OPERATOR_RSHIFT\n-\t  && !this->left_->type()->integer_type()->is_unsigned())\n+\t  && !left_type->integer_type()->is_unsigned())\n \t{\n-\t  tree neg =\n-            fold_build2_loc(gccloc, LT_EXPR, boolean_type_node,\n-\t\t\t    left,\n-                            fold_convert_loc(gccloc, TREE_TYPE(left),\n-                                             integer_zero_node));\n-\t  tree neg_one =\n-            fold_build2_loc(gccloc, MINUS_EXPR, TREE_TYPE(left),\n-                            fold_convert_loc(gccloc, TREE_TYPE(left),\n-                                             integer_zero_node),\n-                            fold_convert_loc(gccloc, TREE_TYPE(left),\n-                                             integer_one_node));\n-\t  overflow_result =\n-            fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(left),\n-\t\t\t    neg, neg_one, overflow_result);\n+          Bexpression* neg_expr =\n+              gogo->backend()->binary_expression(OPERATOR_LT, left,\n+                                                 zero_expr, loc);\n+          Bexpression* neg_one_expr =\n+              gogo->backend()->integer_constant_expression(left_btype, neg_one);\n+          overflow = gogo->backend()->conditional_expression(btype, neg_expr,\n+                                                             neg_one_expr,\n+                                                             zero_expr, loc);\n \t}\n-\n-      ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(left),\n-\t\t\t    compare, ret, overflow_result);\n-\n-      if (eval_saved != NULL_TREE)\n-\tret = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n-\t\t\t      eval_saved, ret);\n+      ret = gogo->backend()->conditional_expression(btype, compare, ret,\n+                                                    overflow, loc);\n+      mpz_clear(bitsval);\n     }\n \n   // Add checks for division by zero and division overflow as needed.\n@@ -6175,84 +6154,83 @@ Binary_expression::do_get_tree(Translate_context* context)\n       if (go_check_divide_zero)\n \t{\n \t  // right == 0\n-\t  tree check = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n-\t\t\t\t       right,\n-\t\t\t\t       fold_convert_loc(gccloc,\n-\t\t\t\t\t\t\tTREE_TYPE(right),\n-\t\t\t\t\t\t\tinteger_zero_node));\n+          Bexpression* zero_expr =\n+              gogo->backend()->integer_constant_expression(right_btype, zero);\n+          Bexpression* check =\n+              gogo->backend()->binary_expression(OPERATOR_EQEQ,\n+                                                 right, zero_expr, loc);\n \n-\t  // __go_runtime_error(RUNTIME_ERROR_DIVISION_BY_ZERO), 0\n+\t  // __go_runtime_error(RUNTIME_ERROR_DIVISION_BY_ZERO)\n \t  int errcode = RUNTIME_ERROR_DIVISION_BY_ZERO;\n-\t  Expression* crash = gogo->runtime_error(errcode, this->location());\n-\t  tree panic = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n-\t\t\t\t       crash->get_tree(context),\n-\t\t\t\t       fold_convert_loc(gccloc, TREE_TYPE(ret),\n-\t\t\t\t\t\t\tinteger_zero_node));\n+\t  Expression* crash = gogo->runtime_error(errcode, loc);\n+          Bexpression* crash_expr = tree_to_expr(crash->get_tree(context));\n \n \t  // right == 0 ? (__go_runtime_error(...), 0) : ret\n-\t  ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n-\t\t\t\tcheck, panic, ret);\n+          ret = gogo->backend()->conditional_expression(btype, check,\n+                                                        crash_expr, ret, loc);\n \t}\n \n       if (go_check_divide_overflow)\n \t{\n \t  // right == -1\n \t  // FIXME: It would be nice to say that this test is expected\n \t  // to return false.\n-\t  tree m1 = integer_minus_one_node;\n-\t  tree check = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n-\t\t\t\t       right,\n-\t\t\t\t       fold_convert_loc(gccloc,\n-\t\t\t\t\t\t\tTREE_TYPE(right),\n-\t\t\t\t\t\t\tm1));\n-\n-\t  tree overflow;\n-\t  if (TYPE_UNSIGNED(TREE_TYPE(ret)))\n+\n+          Bexpression* neg_one_expr =\n+              gogo->backend()->integer_constant_expression(right_btype, neg_one);\n+          Bexpression* check =\n+              gogo->backend()->binary_expression(OPERATOR_EQEQ,\n+                                                 right, neg_one_expr, loc);\n+\n+          Bexpression* zero_expr =\n+              gogo->backend()->integer_constant_expression(btype, zero);\n+          Bexpression* one_expr =\n+              gogo->backend()->integer_constant_expression(btype, one);\n+\n+\t  if (type->integer_type()->is_unsigned())\n \t    {\n \t      // An unsigned -1 is the largest possible number, so\n \t      // dividing is always 1 or 0.\n-\t      tree cmp = fold_build2_loc(gccloc, EQ_EXPR, boolean_type_node,\n-\t\t\t\t\t left, right);\n+\n+              Bexpression* cmp =\n+                  gogo->backend()->binary_expression(OPERATOR_EQEQ,\n+                                                     left, right, loc);\n \t      if (this->op_ == OPERATOR_DIV)\n-\t\toverflow = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n-\t\t\t\t\t   cmp,\n-\t\t\t\t\t   fold_convert_loc(gccloc,\n-\t\t\t\t\t\t\t    TREE_TYPE(ret),\n-\t\t\t\t\t\t\t    integer_one_node),\n-\t\t\t\t\t   fold_convert_loc(gccloc,\n-\t\t\t\t\t\t\t    TREE_TYPE(ret),\n-\t\t\t\t\t\t\t    integer_zero_node));\n+                overflow =\n+                    gogo->backend()->conditional_expression(btype, cmp,\n+                                                            one_expr, zero_expr,\n+                                                            loc);\n \t      else\n-\t\toverflow = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n-\t\t\t\t\t   cmp,\n-\t\t\t\t\t   fold_convert_loc(gccloc,\n-\t\t\t\t\t\t\t    TREE_TYPE(ret),\n-\t\t\t\t\t\t\t    integer_zero_node),\n-\t\t\t\t\t   left);\n+                overflow =\n+                    gogo->backend()->conditional_expression(btype, cmp,\n+                                                            zero_expr, left,\n+                                                            loc);\n \t    }\n \t  else\n \t    {\n \t      // Computing left / -1 is the same as computing - left,\n \t      // which does not overflow since Go sets -fwrapv.\n \t      if (this->op_ == OPERATOR_DIV)\n-\t\toverflow = fold_build1_loc(gccloc, NEGATE_EXPR, TREE_TYPE(left),\n-\t\t\t\t\t   left);\n+                {\n+                  Expression* negate_expr =\n+                      Expression::make_unary(OPERATOR_MINUS, this->left_, loc);\n+                  overflow = tree_to_expr(negate_expr->get_tree(context));\n+                }\n \t      else\n-\t\toverflow = integer_zero_node;\n+                overflow = zero_expr;\n \t    }\n-\t  overflow = fold_convert_loc(gccloc, TREE_TYPE(ret), overflow);\n+          overflow = gogo->backend()->convert_expression(btype, overflow, loc);\n \n \t  // right == -1 ? - left : ret\n-\t  ret = fold_build3_loc(gccloc, COND_EXPR, TREE_TYPE(ret),\n-\t\t\t\tcheck, overflow, ret);\n+          ret = gogo->backend()->conditional_expression(btype, check, overflow,\n+                                                        ret, loc);\n \t}\n-\n-      if (eval_saved != NULL_TREE)\n-\tret = fold_build2_loc(gccloc, COMPOUND_EXPR, TREE_TYPE(ret),\n-\t\t\t      eval_saved, ret);\n     }\n \n-  return ret;\n+  mpz_clear(zero);\n+  mpz_clear(one);\n+  mpz_clear(neg_one);\n+  return expr_to_tree(ret);\n }\n \n // Export a binary expression.\n@@ -6471,10 +6449,10 @@ Expression::make_binary(Operator op, Expression* left, Expression* right,\n \n // Implement a comparison.\n \n-tree\n-Expression::comparison_tree(Translate_context* context, Type* result_type,\n-\t\t\t    Operator op, Expression* left, Expression* right,\n-\t\t\t    Location location)\n+Bexpression*\n+Expression::comparison(Translate_context* context, Type* result_type,\n+\t\t       Operator op, Expression* left, Expression* right,\n+\t\t       Location location)\n {\n   Type* left_type = left->type();\n   Type* right_type = right->type();\n@@ -6484,31 +6462,6 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n   Expression* zexpr = Expression::make_integer(&zval, NULL, location);\n   mpz_clear(zval);\n \n-  enum tree_code code;\n-  switch (op)\n-    {\n-    case OPERATOR_EQEQ:\n-      code = EQ_EXPR;\n-      break;\n-    case OPERATOR_NOTEQ:\n-      code = NE_EXPR;\n-      break;\n-    case OPERATOR_LT:\n-      code = LT_EXPR;\n-      break;\n-    case OPERATOR_LE:\n-      code = LE_EXPR;\n-      break;\n-    case OPERATOR_GT:\n-      code = GT_EXPR;\n-      break;\n-    case OPERATOR_GE:\n-      code = GE_EXPR;\n-      break;\n-    default:\n-      go_unreachable();\n-    }\n-\n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n       left = Runtime::make_call(Runtime::STRCMP, location, 2,\n@@ -6601,20 +6554,15 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n \t}\n     }\n \n-  tree left_tree = left->get_tree(context);\n-  tree right_tree = right->get_tree(context);\n-  if (left_tree == error_mark_node || right_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  tree result_type_tree;\n-  if (result_type == NULL)\n-    result_type_tree = boolean_type_node;\n-  else\n-    result_type_tree = type_to_tree(result_type->get_backend(context->gogo()));\n+  Bexpression* left_bexpr = tree_to_expr(left->get_tree(context));\n+  Bexpression* right_bexpr = tree_to_expr(right->get_tree(context));\n \n-  tree ret = fold_build2(code, result_type_tree, left_tree, right_tree);\n-  if (CAN_HAVE_LOCATION_P(ret))\n-    SET_EXPR_LOCATION(ret, location.gcc_location());\n+  Gogo* gogo = context->gogo();\n+  Bexpression* ret = gogo->backend()->binary_expression(op, left_bexpr,\n+                                                        right_bexpr, location);\n+  if (result_type != NULL)\n+    ret = gogo->backend()->convert_expression(result_type->get_backend(gogo),\n+                                              ret, location);\n   return ret;\n }\n \n@@ -6830,6 +6778,7 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n   Block* b = gogo->finish_block(loc);\n   gogo->add_block(b, loc);\n   gogo->lower_block(new_no, b);\n+  gogo->flatten_block(new_no, b);\n   gogo->finish_function(loc);\n \n   ins.first->second = new_no;\n@@ -11827,6 +11776,7 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n   Block* b = gogo->finish_block(loc);\n   gogo->add_block(b, loc);\n   gogo->lower_block(new_no, b);\n+  gogo->flatten_block(new_no, b);\n   gogo->finish_function(loc);\n \n   ins.first->second->push_back(std::make_pair(name, new_no));\n@@ -11888,7 +11838,7 @@ Interface_field_reference_expression::do_get_tree(Translate_context* context)\n   Bexpression* bcrash = tree_to_expr(crash->get_tree(context));\n \n   Bexpression* bcond =\n-      gogo->backend()->conditional_expression(bnil_check, bcrash, NULL, loc);\n+      gogo->backend()->conditional_expression(NULL, bnil_check, bcrash, NULL, loc);\n   Bstatement* cond_statement = gogo->backend()->expression_statement(bcond);\n   Bexpression* ret =\n       gogo->backend()->compound_expression(cond_statement, bclosure, loc);\n@@ -12157,6 +12107,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \n   // Lower the call in case there are multiple results.\n   gogo->lower_block(no, b);\n+  gogo->flatten_block(no, b);\n \n   gogo->finish_function(location);\n "}, {"sha": "9ddd17122f2578bf085aa42580018879f8c7458a", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5407ad1efa9c19efa34d187ad9ee60f248ede60/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b5407ad1efa9c19efa34d187ad9ee60f248ede60", "patch": "@@ -704,11 +704,11 @@ class Expression\n \t\t\t\t Type* rhs_type, tree rhs_tree,\n \t\t\t\t bool for_type_guard, Location);\n \n-  // Return a tree implementing the comparison LHS_EXPR OP RHS_EXPR.\n+  // Return a backend expression implementing the comparison LEFT OP RIGHT.\n   // TYPE is the type of both sides.\n-  static tree\n-  comparison_tree(Translate_context*, Type* result_type, Operator op,\n-\t\t  Expression* left_expr, Expression* right_expr, Location);\n+  static Bexpression*\n+  comparison(Translate_context*, Type* result_type, Operator op,\n+\t     Expression* left, Expression* right, Location);\n \n   // Return the backend expression for the numeric constant VAL.\n   static Bexpression*\n@@ -1289,6 +1289,9 @@ class Binary_expression : public Expression\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   bool\n   do_is_constant() const\n   { return this->left_->is_constant() && this->right_->is_constant(); }"}]}