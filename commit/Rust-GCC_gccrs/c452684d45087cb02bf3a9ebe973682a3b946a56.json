{"sha": "c452684d45087cb02bf3a9ebe973682a3b946a56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1MjY4NGQ0NTA4N2NiMDJiZjNhOWViZTk3MzY4MmEzYjk0NmE1Ng==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2010-10-04T14:59:30Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2010-10-04T14:59:30Z"}, "message": "expr.c (expand_assignment): Add assertion to prevent emitting null rtx for movmisalign pattern.\n\n\tgcc/\n\t* expr.c (expand_assignment): Add assertion to prevent emitting\n\tnull rtx for movmisalign pattern.\n\t(expand_expr_real_1): Likewise.\n\t* config/arm/arm.c (arm_builtin_support_vector_misalignment): New.\n\t(TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT): New. Use above.\n\t(arm_vector_alignment_reachable): New.\n\t(TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE): New. Use above.\n\t(neon_vector_mem_operand): Disallow PRE_DEC for misaligned loads.\n\t(arm_print_operand): Include alignment qualifier in %A.\n\t* config/arm/neon.md (UNSPEC_MISALIGNED_ACCESS): New constant.\n\t(movmisalign<mode>): New expander.\n\t(movmisalign<mode>_neon_store, movmisalign<mode>_neon_load): New\n\tinsn patterns.\n\n\tgcc/testsuite/\n\t* gcc.dg/vect/vect-42.c: Use vect_element_align instead of\n\tvect_hw_misalign.\n\t* gcc.dg/vect/vect-60.c: Likewise.\n\t* gcc.dg/vect/vect-56.c: Likewise.\n\t* gcc.dg/vect/vect-93.c: Likewise.\n\t* gcc.dg/vect/no-scevccp-outer-8.c: Likewise.\n\t* gcc.dg/vect/vect-95.c: Likewise.\n\t* gcc.dg/vect/vect-96.c: Likewise.\n\t* gcc.dg/vect/vect-outer-5.c: Use quad-word vectors when available.\n\t* gcc.dg/vect/slp-25.c: Likewise.\n\t* gcc.dg/vect/slp-3.c: Likewise.\n\t* gcc.dg/vect/vect-multitypes-1.c: Likewise.\n\t* gcc.dg/vect/no-vfa-pr29145.c: Likewise.\n\t* gcc.dg/vect/vect-multitypes-4.c: Likewise. Use vect_element_align.\n\t* gcc.dg/vect/vect-109.c: Likewise.\n\t* gcc.dg/vect/vect-peel-1.c: Likewise.\n\t* gcc.dg/vect/vect-peel-2.c: Likewise.\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_vect_no_misalign): New.\n\t(check_effective_target_vect_no_align): Use above.\n\t(check_effective_target_vect_element_align): New.\n\t(add_options_for_quad_vectors): New.\n\nFrom-SVN: r164941", "tree": {"sha": "b1fa492abbca688528392350fda6e82bd301c1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1fa492abbca688528392350fda6e82bd301c1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c452684d45087cb02bf3a9ebe973682a3b946a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c452684d45087cb02bf3a9ebe973682a3b946a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c452684d45087cb02bf3a9ebe973682a3b946a56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c452684d45087cb02bf3a9ebe973682a3b946a56/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3f2babd42c1b52ec313dec8af4eaa0386182d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f2babd42c1b52ec313dec8af4eaa0386182d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f2babd42c1b52ec313dec8af4eaa0386182d64"}], "stats": {"total": 287, "additions": 253, "deletions": 34}, "files": [{"sha": "2915c281a169374d57ba3f5d79c7d1d8192c27db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,3 +1,19 @@\n+2010-10-04  Julian Brown  <julian@codesourcery.com>\n+\n+\t* expr.c (expand_assignment): Add assertion to prevent emitting\n+\tnull rtx for movmisalign pattern.\n+\t(expand_expr_real_1): Likewise.\n+\t* config/arm/arm.c (arm_builtin_support_vector_misalignment): New.\n+\t(TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT): New. Use above.\n+\t(arm_vector_alignment_reachable): New.\n+\t(TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE): New. Use above.\n+\t(neon_vector_mem_operand): Disallow PRE_DEC for misaligned loads.\n+\t(arm_print_operand): Include alignment qualifier in %A.\n+\t* config/arm/neon.md (UNSPEC_MISALIGNED_ACCESS): New constant.\n+\t(movmisalign<mode>): New expander.\n+\t(movmisalign<mode>_neon_store, movmisalign<mode>_neon_load): New\n+\tinsn patterns.\n+\n 2010-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* optc-gen.awk: Define global_options_set.  Don't define"}, {"sha": "7a8155d2fbc895095bd523223ee04b9f210a810a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -242,6 +242,11 @@ static bool cortex_a9_sched_adjust_cost (rtx, rtx, rtx, int *);\n static bool xscale_sched_adjust_cost (rtx, rtx, rtx, int *);\n static unsigned int arm_units_per_simd_word (enum machine_mode);\n static bool arm_class_likely_spilled_p (reg_class_t);\n+static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);\n+static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,\n+\t\t\t\t\t\t     const_tree type,\n+\t\t\t\t\t\t     int misalignment,\n+\t\t\t\t\t\t     bool is_packed);\n \n \f\n /* Table of machine attributes.  */\n@@ -557,6 +562,14 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_CLASS_LIKELY_SPILLED_P\n #define TARGET_CLASS_LIKELY_SPILLED_P arm_class_likely_spilled_p\n \n+#undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \\\n+  arm_vector_alignment_reachable\n+\n+#undef TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n+#define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT \\\n+  arm_builtin_support_vector_misalignment\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -8834,7 +8847,8 @@ neon_vector_mem_operand (rtx op, int type)\n     return arm_address_register_rtx_p (ind, 0);\n \n   /* Allow post-increment with Neon registers.  */\n-  if (type != 1 && (GET_CODE (ind) == POST_INC || GET_CODE (ind) == PRE_DEC))\n+  if ((type != 1 && GET_CODE (ind) == POST_INC)\n+      || (type == 0 && GET_CODE (ind) == PRE_DEC))\n     return arm_address_register_rtx_p (XEXP (ind, 0), 0);\n \n   /* FIXME: vld1 allows register post-modify.  */\n@@ -16317,14 +16331,38 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       {\n \trtx addr;\n \tbool postinc = FALSE;\n+\tunsigned align, modesize, align_bits;\n+\n \tgcc_assert (GET_CODE (x) == MEM);\n \taddr = XEXP (x, 0);\n \tif (GET_CODE (addr) == POST_INC)\n \t  {\n \t    postinc = 1;\n \t    addr = XEXP (addr, 0);\n \t  }\n-\tasm_fprintf (stream, \"[%r]\", REGNO (addr));\n+\tasm_fprintf (stream, \"[%r\", REGNO (addr));\n+\n+\t/* We know the alignment of this access, so we can emit a hint in the\n+\t   instruction (for some alignments) as an aid to the memory subsystem\n+\t   of the target.  */\n+\talign = MEM_ALIGN (x) >> 3;\n+\tmodesize = GET_MODE_SIZE (GET_MODE (x));\n+\t\n+\t/* Only certain alignment specifiers are supported by the hardware.  */\n+\tif (modesize == 16 && (align % 32) == 0)\n+\t  align_bits = 256;\n+\telse if ((modesize == 8 || modesize == 16) && (align % 16) == 0)\n+\t  align_bits = 128;\n+\telse if ((align % 8) == 0)\n+\t  align_bits = 64;\n+\telse\n+\t  align_bits = 0;\n+\t\n+\tif (align_bits != 0)\n+\t  asm_fprintf (stream, \":%d\", align_bits);\n+\n+\tasm_fprintf (stream, \"]\");\n+\n \tif (postinc)\n \t  fputs(\"!\", stream);\n       }\n@@ -23145,4 +23183,43 @@ arm_expand_sync (enum machine_mode mode,\n     }\n }\n \n+static bool\n+arm_vector_alignment_reachable (const_tree type, bool is_packed)\n+{\n+  /* Vectors which aren't in packed structures will not be less aligned than\n+     the natural alignment of their element type, so this is safe.  */\n+  if (TARGET_NEON && !BYTES_BIG_ENDIAN)\n+    return !is_packed;\n+\n+  return default_builtin_vector_alignment_reachable (type, is_packed);\n+}\n+\n+static bool\n+arm_builtin_support_vector_misalignment (enum machine_mode mode,\n+\t\t\t\t\t const_tree type, int misalignment,\n+\t\t\t\t\t bool is_packed)\n+{\n+  if (TARGET_NEON && !BYTES_BIG_ENDIAN)\n+    {\n+      HOST_WIDE_INT align = TYPE_ALIGN_UNIT (type);\n+\n+      if (is_packed)\n+        return align == 1;\n+\n+      /* If the misalignment is unknown, we should be able to handle the access\n+\t so long as it is not to a member of a packed data structure.  */\n+      if (misalignment == -1)\n+        return true;\n+\n+      /* Return true if the misalignment is a multiple of the natural alignment\n+         of the vector's element type.  This is probably always going to be\n+\t true in practice, since we've already established that this isn't a\n+\t packed access.  */\n+      return ((misalignment % align) == 0);\n+    }\n+  \n+  return default_builtin_support_vector_misalignment (mode, type, misalignment,\n+\t\t\t\t\t\t      is_packed);\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "cd91573be107f60d1076e9cf140e9001a5195177", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -141,6 +141,7 @@\n    (UNSPEC_VUZP2\t\t202)\n    (UNSPEC_VZIP1\t\t203)\n    (UNSPEC_VZIP2\t\t204)\n+   (UNSPEC_MISALIGNED_ACCESS\t205)\n    (UNSPEC_VCLE\t\t\t206)\n    (UNSPEC_VCLT\t\t\t207)])\n \n@@ -369,6 +370,52 @@\n   neon_disambiguate_copy (operands, dest, src, 4);\n })\n \n+(define_expand \"movmisalign<mode>\"\n+  [(set (match_operand:VDQX 0 \"nonimmediate_operand\"\t      \"\")\n+\t(unspec:VDQX [(match_operand:VDQX 1 \"general_operand\" \"\")]\n+\t\t     UNSPEC_MISALIGNED_ACCESS))]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+{\n+  /* This pattern is not permitted to fail during expansion: if both arguments\n+     are non-registers (e.g. memory := constant, which can be created by the\n+     auto-vectorizer), force operand 1 into a register.  */\n+  if (!s_register_operand (operands[0], <MODE>mode)\n+      && !s_register_operand (operands[1], <MODE>mode))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"*movmisalign<mode>_neon_store\"\n+  [(set (match_operand:VDX 0 \"memory_operand\"\t\t       \"=Um\")\n+\t(unspec:VDX [(match_operand:VDX 1 \"s_register_operand\" \" w\")]\n+\t\t    UNSPEC_MISALIGNED_ACCESS))]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+  \"vst1.<V_sz_elem>\\t{%P1}, %A0\"\n+  [(set_attr \"neon_type\" \"neon_vst1_1_2_regs_vst2_2_regs\")])\n+\n+(define_insn \"*movmisalign<mode>_neon_load\"\n+  [(set (match_operand:VDX 0 \"s_register_operand\"\t   \"=w\")\n+\t(unspec:VDX [(match_operand:VDX 1 \"memory_operand\" \" Um\")]\n+\t\t    UNSPEC_MISALIGNED_ACCESS))]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+  \"vld1.<V_sz_elem>\\t{%P0}, %A1\"\n+  [(set_attr \"neon_type\" \"neon_vld1_1_2_regs\")])\n+\n+(define_insn \"*movmisalign<mode>_neon_store\"\n+  [(set (match_operand:VQX 0 \"memory_operand\"\t\t       \"=Um\")\n+\t(unspec:VQX [(match_operand:VQX 1 \"s_register_operand\" \" w\")]\n+\t\t    UNSPEC_MISALIGNED_ACCESS))]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+  \"vst1.<V_sz_elem>\\t{%q1}, %A0\"\n+  [(set_attr \"neon_type\" \"neon_vst1_1_2_regs_vst2_2_regs\")])\n+\n+(define_insn \"*movmisalign<mode>_neon_load\"\n+  [(set (match_operand:VQX 0 \"s_register_operand\"\t   \"=w\")\n+\t(unspec:VQX [(match_operand:VQX 1 \"memory_operand\" \" Um\")]\n+\t\t    UNSPEC_MISALIGNED_ACCESS))]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+  \"vld1.<V_sz_elem>\\t{%q0}, %A1\"\n+  [(set_attr \"neon_type\" \"neon_vld1_1_2_regs\")])\n+\n (define_insn \"vec_set<mode>_internal\"\n   [(set (match_operand:VD 0 \"s_register_operand\" \"=w\")\n         (vec_merge:VD"}, {"sha": "51483f9006014d145db80d5a45fe44716e68681f", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -4223,6 +4223,9 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \treg = copy_to_mode_reg (op_mode1, reg);\n \n       insn = GEN_FCN (icode) (mem, reg);\n+      /* The movmisalign<mode> pattern cannot fail, else the assignment would\n+         silently be omitted.  */\n+      gcc_assert (insn != NULL_RTX);\n       emit_insn (insn);\n       return;\n     }\n@@ -8674,6 +8677,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t    /* Nor can the insn generator.  */\n \t    insn = GEN_FCN (icode) (reg, temp);\n+\t    gcc_assert (insn != NULL_RTX);\n \t    emit_insn (insn);\n \n \t    return reg;"}, {"sha": "3f8172633296e3364fbd17d9d7068dde0aa8a407", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,3 +1,28 @@\n+2010-10-04  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gcc.dg/vect/vect-42.c: Use vect_element_align instead of\n+\tvect_hw_misalign.\n+\t* gcc.dg/vect/vect-60.c: Likewise.\n+\t* gcc.dg/vect/vect-56.c: Likewise.\n+\t* gcc.dg/vect/vect-93.c: Likewise.\n+\t* gcc.dg/vect/no-scevccp-outer-8.c: Likewise.\n+\t* gcc.dg/vect/vect-95.c: Likewise.\n+\t* gcc.dg/vect/vect-96.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-5.c: Use quad-word vectors when available.\n+\t* gcc.dg/vect/slp-25.c: Likewise.\n+\t* gcc.dg/vect/slp-3.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-1.c: Likewise.\n+\t* gcc.dg/vect/no-vfa-pr29145.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-4.c: Likewise. Use vect_element_align.\n+\t* gcc.dg/vect/vect-109.c: Likewise.\n+\t* gcc.dg/vect/vect-peel-1.c: Likewise.\n+\t* gcc.dg/vect/vect-peel-2.c: Likewise.\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_vect_no_misalign): New.\n+\t(check_effective_target_vect_no_align): Use above.\n+\t(check_effective_target_vect_element_align): New.\n+\t(add_options_for_quad_vectors): New.\n+\n 2010-10-04  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/45572"}, {"sha": "afa5b3d241e9ad19fb2abe171d4a1c2ad172cb0d", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -46,5 +46,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail { ! { vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail { ! { vect_element_align } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "954474eb9256ca58a32b5f85773e8314b1ad75b4", "filename": "gcc/testsuite/gcc.dg/vect/no-vfa-pr29145.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-vfa-pr29145.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "45176398834649d0d0c1d083c64c0b0f3c14d38f", "filename": "gcc/testsuite/gcc.dg/vect/slp-25.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "18614cdfb2eee9128918dad214c2d0e043931091", "filename": "gcc/testsuite/gcc.dg/vect/slp-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include <stdio.h>"}, {"sha": "1f2f53ed9ebac042a019ae33e9cdbde3f1d5a02e", "filename": "gcc/testsuite/gcc.dg/vect/vect-109.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -72,8 +73,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_hw_misalign } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_element_align } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" { xfail vect_element_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_element_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "b9faea491d9a52ad5ce57cda9800d002c9906e63", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -64,8 +64,8 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { { ! vector_alignment_reachable } && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { { !  vector_alignment_reachable } || vect_hw_misalign  } } } } }  */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || { { ! vector_alignment_reachable } || vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { { ! vector_alignment_reachable } && { ! vect_element_align } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { { !  vector_alignment_reachable } || vect_element_align  } } } } }  */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_element_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || { { ! vector_alignment_reachable } || vect_element_align } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5a8130b11e24129ebe1a368fc94b3fb9518aacf9", "filename": "gcc/testsuite/gcc.dg/vect/vect-56.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -68,8 +68,8 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_element_align } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "838a9bca417aebf6f2a8d055a25f85c4bcb2e63b", "filename": "gcc/testsuite/gcc.dg/vect/vect-60.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -69,8 +69,8 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_element_align } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "65403eb72fcc0b3366a1f1fd1fcccf80978c4067", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -72,7 +72,7 @@ int main (void)\n /* main && main1 together: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_element_align } } } } } */\n \n /* in main1: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */"}, {"sha": "c03d1965df1233932c8db307549f62b994baefb1", "filename": "gcc/testsuite/gcc.dg/vect/vect-95.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -56,14 +56,14 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail {vect_hw_misalign} } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail {vect_element_align} } } } */\n \n /* For targets that support unaligned loads we version for the two unaligned \n    stores and generate misaligned accesses for the loads. For targets that \n    don't support unaligned loads we version for all four accesses.  */\n \n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign} } } }  */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_element_align} } } }  */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n /*  { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { target vect_no_align } } } */\n /*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 4 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "049ac2434032d9217e8dd779f8f01915d9fa9b06", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -44,6 +44,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { {! vect_no_align} && vector_alignment_reachable } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_element_align } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || { {! vector_alignment_reachable} && {! vect_element_align} } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5e2b41a82f6ba56dc395d2cba636c189cb85c678", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "9cb6817cec13e4ca0f298f04ae0c60a8eedb2984", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -92,9 +93,9 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail { vect_no_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { target { vect_hw_misalign}  } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { target { vect_hw_misalign  } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { target { vect_element_align}  } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { target { vect_element_align  } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "01094d343e8cd7fa4ec29bf5ff1c3cc93a5b0f08", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-5.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_float } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdio.h>\n #include <stdarg.h>"}, {"sha": "6af81a6f99311dec79944eb83e6fb6e3a5cb584c", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -45,7 +46,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail  vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign  } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_element_align  } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail  vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f518690b3d193379210e67bbe5f0916a81fffdca", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n+/* { dg-add-options quad_vectors } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -46,7 +47,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail  vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign  } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_element_align  } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_element_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vect_element_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "fe87ec939e91cd291f906b6218e738e8137a57fe", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c452684d45087cb02bf3a9ebe973682a3b946a56/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c452684d45087cb02bf3a9ebe973682a3b946a56", "patch": "@@ -1813,6 +1813,18 @@ proc check_effective_target_arm32 { } {\n     }]\n }\n \n+# Return 1 if this is an ARM target that only supports aligned vector accesses\n+proc check_effective_target_arm_vect_no_misalign { } {\n+    return [check_no_compiler_messages arm_vect_no_misalign assembly {\n+\t#if !defined(__arm__) \\\n+\t    || (defined(__ARMEL__) \\\n+\t        && (!defined(__thumb__) || defined(__thumb2__)))\n+\t#error FOO\n+\t#endif\n+    }]\n+}\n+\n+\n # Return 1 if this is an ARM target supporting -mfpu=vfp\n # -mfloat-abi=softfp.  Some multilibs may be incompatible with these\n # options.\n@@ -2776,7 +2788,7 @@ proc check_effective_target_vect_no_align { } {\n \tif { [istarget mipsisa64*-*-*]\n \t     || [istarget sparc*-*-*]\n \t     || [istarget ia64-*-*]\n-\t     || [check_effective_target_arm32]\n+\t     || [check_effective_target_arm_vect_no_misalign]\n \t     || ([istarget mips*-*-*]\n \t\t && [check_effective_target_mips_loongson]) } {\n \t    set et_vect_no_align_saved 1\n@@ -2913,6 +2925,25 @@ proc check_effective_target_vector_alignment_reachable_for_64bit { } {\n     return $et_vector_alignment_reachable_for_64bit_saved\n }\n \n+# Return 1 if the target only requires element alignment for vector accesses\n+\n+proc check_effective_target_vect_element_align { } {\n+    global et_vect_element_align\n+\n+    if [info exists et_vect_element_align] {\n+\tverbose \"check_effective_target_vect_element_align: using cached result\" 2\n+    } else {\n+\tset et_vect_element_align 0\n+\tif { [istarget arm*-*-*]\n+\t     || [check_effective_target_vect_hw_misalign] } {\n+\t   set et_vect_element_align 1\n+\t}\n+    }\n+\n+    verbose \"check_effective_target_vect_element_align: returning $et_vect_element_align\" 2\n+    return $et_vect_element_align\n+}\n+\n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n \n proc check_effective_target_vect_condition { } {\n@@ -3480,6 +3511,16 @@ proc add_options_for_bind_pic_locally { flags } {\n     return $flags\n }\n \n+# Add to FLAGS the flags needed to enable 128-bit vectors.\n+\n+proc add_options_for_quad_vectors { flags } {\n+    if [is-effective-target arm_neon_ok] {\n+\treturn \"$flags -mvectorize-with-neon-quad\"\n+    }\n+\n+    return $flags\n+}\n+\n # Return 1 if the target provides a full C99 runtime.\n \n proc check_effective_target_c99_runtime { } {"}]}