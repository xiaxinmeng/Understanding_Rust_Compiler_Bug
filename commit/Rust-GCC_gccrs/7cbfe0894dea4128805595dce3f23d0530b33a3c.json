{"sha": "7cbfe0894dea4128805595dce3f23d0530b33a3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NiZmUwODk0ZGVhNDEyODgwNTU5NWRjZTNmMjNkMDUzMGIzM2EzYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T19:03:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T19:13:08Z"}, "message": "c++: Hiddenness is a property of the symbol table\n\nThis patch moves the handling of decl-hiddenness entirely into the\nname lookup machinery, where it belongs.  We need a few new flags,\nbecause pressing the existing OVL_HIDDEN_P into play for non-function\ndecls doesn't work well.  For a local binding we only need one marker,\nas there cannot be both a hidden implicit typedef and a hidden\nfunction.  That's not true for namespace-scope, where they could both\nbe hidden.\n\nThe name-lookup machinery maintains the existing decl_hidden and co\nflags, and asserts have been sprinkled around to make sure they are\nconsistent.  The next series of patches will remove those old markers.\n(we'll need to keep one, as there are some special restrictions on\nredeclaring friend functions with in-class definitions or default args.)\n\n\tgcc/cp/\n\t* cp-tree.h (ovl_insert): Change final parm to hidden-or-using\n\tindicator.\n\t* name-lookup.h (HIDDEN_TYPE_BINDING_P): New.\n\t(struct cxx_binding): Add type_is_hidden flag.\n\t* tree.c (ovl_insert): Change using_p parm to using_or_hidden,\n\tadjust.\n\t(ovl_skip_hidden): Assert we never see a naked hidden decl.\n\t* decl.c (xref_tag_1): Delete unhiding friend from here (moved to\n\tlookup_elaborated_type_1).\n\t* name-lookup.c (STAT_TYPE_HIDDEN_P, STAT_DECL_HIDDEN_P): New.\n\t(name_lookup::search_namespace_only): Check new hidden markers.\n\t(cxx_binding_make): Clear HIDDEN_TYPE_BINDING_P.\n\t(update_binding): Update new hidden markers.\n\t(lookup_name_1): Check HIDDEN_TYPE_BINDING_P and simplify friend\n\tignoring.\n\t(lookup_elaborated_type_1): Use new hidden markers.  Reveal the\n\tdecl here.", "tree": {"sha": "8294bd15317839b583367f9b1f2cc367da535ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8294bd15317839b583367f9b1f2cc367da535ed4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cbfe0894dea4128805595dce3f23d0530b33a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbfe0894dea4128805595dce3f23d0530b33a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbfe0894dea4128805595dce3f23d0530b33a3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbfe0894dea4128805595dce3f23d0530b33a3c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec881f85abbddc6e37630b6e61ce621cea6acd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec881f85abbddc6e37630b6e61ce621cea6acd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec881f85abbddc6e37630b6e61ce621cea6acd7"}], "stats": {"total": 349, "additions": 213, "deletions": 136}, "files": [{"sha": "a25934e3263934cb670b757e025f8e6f8a93170d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7cbfe0894dea4128805595dce3f23d0530b33a3c", "patch": "@@ -7371,7 +7371,7 @@ inline tree ovl_first\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree ovl_make\t\t\t\t(tree fn,\n \t\t\t\t\t\t tree next = NULL_TREE);\n extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n-\t\t\t\t\t\t bool using_p = false);\n+\t\t\t\t\t\t int using_or_hidden = 0);\n extern tree ovl_skip_hidden\t\t\t(tree) ATTRIBUTE_PURE;\n extern void lookup_mark\t\t\t\t(tree lookup, bool val);\n extern tree lookup_add\t\t\t\t(tree fns, tree lookup);"}, {"sha": "617b96e02e4d99beaaaf1e295205cae38c141dbd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7cbfe0894dea4128805595dce3f23d0530b33a3c", "patch": "@@ -15089,22 +15089,9 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \t  return error_mark_node;\n \t}\n \n-      if (how != TAG_how::HIDDEN_FRIEND && TYPE_HIDDEN_P (t))\n-\t{\n-\t  /* This is no longer an invisible friend.  Make it\n-\t     visible.  */\n-\t  tree decl = TYPE_NAME (t);\n-\n-\t  DECL_ANTICIPATED (decl) = false;\n-\t  DECL_FRIEND_P (decl) = false;\n-\n-\t  if (TYPE_TEMPLATE_INFO (t))\n-\t    {\n-\t      tree tmpl = TYPE_TI_TEMPLATE (t);\n-\t      DECL_ANTICIPATED (tmpl) = false;\n-\t      DECL_FRIEND_P (tmpl) = false;\n-\t    }\n-\t}\n+      gcc_checking_assert (how == TAG_how::HIDDEN_FRIEND\n+\t\t\t   || !(DECL_LANG_SPECIFIC (TYPE_NAME (t))\n+\t\t\t\t&& DECL_ANTICIPATED (TYPE_NAME (t))));\n     }\n \n   return t;"}, {"sha": "bc60d343f7e45aa467d2d3d90a49bb856478c76f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 188, "deletions": 103, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7cbfe0894dea4128805595dce3f23d0530b33a3c", "patch": "@@ -55,6 +55,15 @@ static name_hint suggest_alternatives_for_1 (location_t location, tree name,\n #define MAYBE_STAT_DECL(N) (STAT_HACK_P (N) ? STAT_DECL (N) : N)\n #define MAYBE_STAT_TYPE(N) (STAT_HACK_P (N) ? STAT_TYPE (N) : NULL_TREE)\n \n+/* For regular (maybe) overloaded functions, we have OVL_HIDDEN_P.\n+   But we also need to indicate hiddenness on implicit type decls\n+   (injected friend classes), and (coming soon) decls injected from\n+   block-scope externs.  It is too awkward to press the existing\n+   overload marking for that.  If we have a hidden non-function, we\n+   always create a STAT_HACK, and use these two markers as needed.  */\n+#define STAT_TYPE_HIDDEN_P(N) OVL_HIDDEN_P (N)\n+#define STAT_DECL_HIDDEN_P(N) OVL_DEDUP_P (N)\n+\n /* Create a STAT_HACK node with DECL as the value binding and TYPE as\n    the type binding.  */\n \n@@ -545,14 +554,18 @@ name_lookup::search_namespace_only (tree scope)\n \t{\n \t  type = STAT_TYPE (value);\n \t  value = STAT_DECL (value);\n-      \n-\t  if (!bool (want & LOOK_want::HIDDEN_FRIEND)\n-\t      && DECL_LANG_SPECIFIC (type)\n-\t      && DECL_ANTICIPATED (type))\n-\t    type = NULL_TREE;\n+\t  \n+\t  if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\t    {\n+\t      if (STAT_TYPE_HIDDEN_P (*binding))\n+\t\ttype = NULL_TREE;\n+\t      if (STAT_DECL_HIDDEN_P (*binding))\n+\t\tvalue = NULL_TREE;\n+\t      else\n+\t\tvalue = ovl_skip_hidden (value);\n+\t    }\n \t}\n-\n-      if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+      else if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n \tvalue = ovl_skip_hidden (value);\n \n       found |= process_binding (value, type);\n@@ -1975,6 +1988,7 @@ cxx_binding_make (tree value, tree type)\n   /* Clear flags by default.  */\n   LOCAL_BINDING_P (binding) = false;\n   INHERITED_VALUE_BINDING_P (binding) = false;\n+  HIDDEN_TYPE_BINDING_P (binding) = false;\n \n   cxx_binding_init (binding, value, type);\n \n@@ -2046,13 +2060,15 @@ pop_local_binding (tree id, tree decl)\n   /* The name should be bound.  */\n   gcc_assert (binding != NULL);\n \n-  /* The DECL will be either the ordinary binding or the type\n-     binding for this identifier.  Remove that binding.  */\n+  /* The DECL will be either the ordinary binding or the type binding\n+     for this identifier.  Remove that binding.  We don't have to\n+     clear HIDDEN_TYPE_BINDING_P, as the whole binding will be going\n+     away.  */\n   if (binding->value == decl)\n     binding->value = NULL_TREE;\n   else\n     {\n-      gcc_assert (binding->type == decl);\n+      gcc_checking_assert (binding->type == decl);\n       binding->type = NULL_TREE;\n     }\n \n@@ -2367,11 +2383,22 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t\ttree old, tree decl, bool hiding = false)\n {\n   tree old_type = NULL_TREE;\n+  bool hide_type = false;\n+  bool hide_value = false;\n \n   if (!slot)\n-    old_type = binding->type;\n+    {\n+      old_type = binding->type;\n+      hide_type = HIDDEN_TYPE_BINDING_P (binding);\n+      if (!old_type)\n+\thide_value = hide_type, hide_type = false;\n+    }\n   else if (STAT_HACK_P (*slot))\n+    {\n       old_type = STAT_TYPE (*slot);\n+      hide_type = STAT_TYPE_HIDDEN_P (*slot);\n+      hide_value = STAT_DECL_HIDDEN_P (*slot);\n+    }\n \n   tree to_val = decl;\n   tree to_type = old_type;\n@@ -2394,9 +2421,12 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t{\n \t  /* Put DECL into the type slot.  */\n \t  gcc_checking_assert (!to_type);\n+\t  hide_type = hiding;\n \t  to_type = decl;\n \t  to_val = old;\n \t}\n+      else\n+\thide_value = hiding;\n \n       goto done;\n     }\n@@ -2407,7 +2437,9 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n       gcc_checking_assert (!to_type);\n \n       to_type = old;\n+      hide_type = hide_value;\n       old = NULL_TREE;\n+      hide_value = false;\n     }\n \n   if (DECL_DECLARES_FUNCTION_P (decl))\n@@ -2450,7 +2482,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t\t decl, to_type);\n \n       local_overload = old && level->kind != sk_namespace;\n-      to_val = ovl_insert (decl, old);\n+      to_val = ovl_insert (decl, old, -int (hiding));\n     }\n   else if (old)\n     {\n@@ -2483,11 +2515,13 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t{\n \t  /* There can be two block-scope declarations of the same\n \t     variable, so long as they are `extern' declarations.  */\n-\t  // FIXME: This is DECL_LOCAL_DECL_P type stuff.\n \t  if (!DECL_EXTERNAL (old) || !DECL_EXTERNAL (decl))\n \t    goto conflict;\n \t  else if (tree match = duplicate_decls (decl, old))\n-\t    return match;\n+\t    {\n+\t      gcc_checking_assert (!hide_value && !hiding);\n+\t      return match;\n+\t    }\n \t  else\n \t    goto conflict;\n \t}\n@@ -2498,6 +2532,8 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t  to_val = NULL_TREE;\n \t}\n     }\n+  else if (hiding)\n+    hide_value = true;\n \n  done:\n   if (to_val)\n@@ -2516,16 +2552,26 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t    {\n \t      STAT_TYPE (*slot) = to_type;\n \t      STAT_DECL (*slot) = to_val;\n+\t      STAT_TYPE_HIDDEN_P (*slot) = hide_type;\n+\t      STAT_DECL_HIDDEN_P (*slot) = hide_value;\n+\t    }\n+\t  else if (to_type || hide_value)\n+\t    {\n+\t      *slot = stat_hack (to_val, to_type);\n+\t      STAT_TYPE_HIDDEN_P (*slot) = hide_type;\n+\t      STAT_DECL_HIDDEN_P (*slot) = hide_value;\n \t    }\n-\t  else if (to_type)\n-\t    *slot = stat_hack (to_val, to_type);\n \t  else\n-\t    *slot = to_val;\n+\t    {\n+\t      gcc_checking_assert (!hide_type);\n+\t      *slot = to_val;\n+\t    }\n \t}\n       else\n \t{\n \t  binding->type = to_type;\n \t  binding->value = to_val;\n+\t  HIDDEN_TYPE_BINDING_P (binding) = hide_type || hide_value;\n \t}\n     }\n \n@@ -6489,86 +6535,37 @@ lookup_name_1 (tree name, LOOK_where where, LOOK_want want)\n     for (cxx_binding *iter = nullptr;\n \t (iter = outer_binding (name, iter, bool (where & LOOK_where::CLASS)));)\n       {\n-\ttree binding;\n-\n \t/* Skip entities we don't want.  */\n \tif (!bool (where & (LOCAL_BINDING_P (iter)\n \t\t\t    ? LOOK_where::BLOCK : LOOK_where::CLASS)))\n \t  continue;\n \n \t/* If this is the kind of thing we're looking for, we're done.  */\n-\tif (iter->value\n-\t    && (bool (want & LOOK_want::HIDDEN_LAMBDA)\n-\t\t|| !is_lambda_ignored_entity (iter->value))\n-\t    && qualify_lookup (iter->value, want))\n-\t  binding = iter->value;\n-\telse if (bool (want & LOOK_want::TYPE)\n-\t\t && qualify_lookup (iter->type, want))\n-\t  binding = iter->type;\n-\telse\n-\t  binding = NULL_TREE;\n-\n-\tif (binding)\n+\tif (iter->value)\n \t  {\n-\t    if (TREE_CODE (binding) == TYPE_DECL && DECL_HIDDEN_P (binding))\n+\t    tree binding = NULL_TREE;\n+\n+\t    if (!(!iter->type && HIDDEN_TYPE_BINDING_P (iter))\n+\t\t&& (bool (want & LOOK_want::HIDDEN_LAMBDA)\n+\t\t    || !is_lambda_ignored_entity (iter->value))\n+\t\t&& qualify_lookup (iter->value, want))\n+\t      binding = iter->value;\n+\t    else if (bool (want & LOOK_want::TYPE)\n+\t\t     && !HIDDEN_TYPE_BINDING_P (iter)\n+\t\t     && iter->type)\n+\t      binding = iter->type;\n+\n+\t    if (binding)\n \t      {\n-\t\t/* A non namespace-scope binding can only be hidden in the\n-\t\t   presence of a local class, due to friend declarations.\n-\n-\t\t   In particular, consider:\n-\n-\t\t   struct C;\n-\t\t   void f() {\n-\t\t     struct A {\n-\t\t       friend struct B;\n-\t\t       friend struct C;\n-\t\t       void g() {\n-\t\t         B* b; // error: B is hidden\n-\t\t\t C* c; // OK, finds ::C\n-\t\t       } \n-\t\t     };\n-\t\t     B *b;  // error: B is hidden\n-\t\t     C *c;  // OK, finds ::C\n-\t\t     struct B {};\n-\t\t     B *bb; // OK\n-\t\t   }\n-\n-\t\t   The standard says that \"B\" is a local class in \"f\"\n-\t\t   (but not nested within \"A\") -- but that name lookup\n-\t\t   for \"B\" does not find this declaration until it is\n-\t\t   declared directly with \"f\".\n-\n-\t\t   In particular:\n-\n-\t\t   [class.friend]\n-\n-\t\t   If a friend declaration appears in a local class and\n-\t\t   the name specified is an unqualified name, a prior\n-\t\t   declaration is looked up without considering scopes\n-\t\t   that are outside the innermost enclosing non-class\n-\t\t   scope. For a friend function declaration, if there is\n-\t\t   no prior declaration, the program is ill-formed. For a\n-\t\t   friend class declaration, if there is no prior\n-\t\t   declaration, the class that is specified belongs to the\n-\t\t   innermost enclosing non-class scope, but if it is\n-\t\t   subsequently referenced, its name is not found by name\n-\t\t   lookup until a matching declaration is provided in the\n-\t\t   innermost enclosing nonclass scope.\n-\n-\t\t   So just keep looking for a non-hidden binding.\n-\t\t*/\n-\t\tgcc_assert (TREE_CODE (binding) == TYPE_DECL);\n-\t\tcontinue;\n+\t\t/* The saved lookups for an operator record 'nothing\n+\t\t   found' as error_mark_node.  We need to stop the search\n+\t\t   here, but not return the error mark node.  */\n+\t\tif (binding == error_mark_node)\n+\t\t  binding = NULL_TREE;\n+\n+\t\tval = binding;\n+\t\tgoto found;\n \t      }\n-\n-\t    /* The saved lookups for an operator record 'nothing\n-\t       found' as error_mark_node.  We need to stop the search\n-\t       here, but not return the error mark node.  */\n-\t    if (binding == error_mark_node)\n-\t      binding = NULL_TREE;\n-\n-\t    val = binding;\n-\t    goto found;\n \t  }\n       }\n \n@@ -6649,17 +6646,55 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n \t     typedef struct C {} C;\n \t   correctly.  */\n \n+\ttree found = NULL_TREE;\n+\tbool reveal = false;\n \tif (tree type = iter->type)\n-\t  if (qualify_lookup (type, LOOK_want::TYPE)\n-\t      && (how != TAG_how::CURRENT_ONLY\n-\t\t  || LOCAL_BINDING_P (iter)\n-\t\t  || DECL_CONTEXT (type) == iter->scope->this_entity))\n-\t    return type;\n-\n-\tif (qualify_lookup (iter->value, LOOK_want::TYPE)\n-\t    && (how != TAG_how::CURRENT_ONLY\n-\t\t|| !INHERITED_VALUE_BINDING_P (iter)))\n-\t  return iter->value;\n+\t  {\n+\t    if (qualify_lookup (type, LOOK_want::TYPE)\n+\t\t&& (how != TAG_how::CURRENT_ONLY\n+\t\t    || LOCAL_BINDING_P (iter)\n+\t\t    || DECL_CONTEXT (type) == iter->scope->this_entity))\n+\t      {\n+\t\tfound = type;\n+\t\tif (how != TAG_how::HIDDEN_FRIEND)\n+\t\t  reveal = HIDDEN_TYPE_BINDING_P (iter);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (qualify_lookup (iter->value, LOOK_want::TYPE)\n+\t\t&& (how != TAG_how::CURRENT_ONLY\n+\t\t    || !INHERITED_VALUE_BINDING_P (iter)))\n+\t      {\n+\t\tfound = iter->value;\n+\t\tif (how != TAG_how::HIDDEN_FRIEND)\n+\t\t  reveal = !iter->type && HIDDEN_TYPE_BINDING_P (iter);\n+\t      }\n+\t  }\n+\n+\tif (found)\n+\t  {\n+\t    if (reveal)\n+\t      {\n+\t\t/* It is no longer a hidden binding.  */\n+\t\tHIDDEN_TYPE_BINDING_P (iter) = false;\n+\n+\t\t/* Unanticipate the decl itself.  */\n+\t\tDECL_ANTICIPATED (found) = false;\n+\t\tDECL_FRIEND_P (found) = false;\n+\n+\t\tgcc_checking_assert (TREE_CODE (found) != TEMPLATE_DECL);\n+\n+\t\tif (tree ti = TYPE_TEMPLATE_INFO (TREE_TYPE (found)))\n+\t\t  {\n+\t\t    tree tmpl = TI_TEMPLATE (ti);\n+\t\t    DECL_ANTICIPATED (tmpl) = false;\n+\t\t    DECL_FRIEND_P (tmpl) = false;\n+\t\t  }\n+\t      }\n+\n+\t    return found;\n+\t  }\n       }\n \n   /* Now check if we can look in namespace scope.  */\n@@ -6675,13 +6710,63 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n   if (tree *slot = find_namespace_slot (ns, name))\n     {\n       /* If this is the kind of thing we're looking for, we're done.  */\n+      tree found = NULL_TREE;\n+      bool reveal = false;\n+\n       if (tree type = MAYBE_STAT_TYPE (*slot))\n-\tif (qualify_lookup (type, LOOK_want::TYPE))\n-\t  return type;\n+\t{\n+\t  found = type;\n+\t  if (how != TAG_how::HIDDEN_FRIEND)\n+\t    {\n+\t      reveal = STAT_TYPE_HIDDEN_P (*slot);\n+\t      STAT_TYPE_HIDDEN_P (*slot) = false;\n+\t    }\n+\t}\n+      else if (tree decl = MAYBE_STAT_DECL (*slot))\n+\t{\n+\t  if (qualify_lookup (decl, LOOK_want::TYPE))\n+\t    {\n+\t      found = decl;\n+\n+\t      if (how != TAG_how::HIDDEN_FRIEND  && STAT_HACK_P (*slot))\n+\t\t{\n+\t\t  reveal = STAT_DECL_HIDDEN_P (*slot);\n+\t\t  if (reveal)\n+\t\t    {\n+\t\t      if (STAT_TYPE (*slot))\n+\t\t\tSTAT_DECL_HIDDEN_P (*slot) = false;\n+\t\t      else\n+\t\t\t/* There is no type, just remove the stat\n+\t\t\t   hack.  */\n+\t\t\t*slot = decl;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (found)\n+\t{\n+\t  if (reveal)\n+\t    {\n+\t      /* Reveal the previously hidden thing.  */\n+\t      DECL_ANTICIPATED (found) = false;\n+\t      DECL_FRIEND_P (found) = false;\n+\n+\t      if (TREE_CODE (found) == TEMPLATE_DECL)\n+\t\t{\n+\t\t  DECL_ANTICIPATED (DECL_TEMPLATE_RESULT (found)) = false;\n+\t\t  DECL_FRIEND_P (DECL_TEMPLATE_RESULT (found)) = false;\n+\t\t}\n+\t      else if (tree ti = TYPE_TEMPLATE_INFO (TREE_TYPE (found)))\n+\t\t{\n+\t\t  tree tmpl = TI_TEMPLATE (ti);\n+\t\t  DECL_ANTICIPATED (tmpl) = false;\n+\t\t  DECL_FRIEND_P (tmpl) = false;\n+\t\t}\n+\t    }\n \n-      if (tree decl = MAYBE_STAT_DECL (*slot))\n-\tif (qualify_lookup (decl, LOOK_want::TYPE))\n-\t  return decl;\n+\t  return found;\n+\t}\n     }\n \n   return NULL_TREE;"}, {"sha": "01643fb9b340eace7b8e7835ac45918d08dd0a81", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=7cbfe0894dea4128805595dce3f23d0530b33a3c", "patch": "@@ -58,6 +58,12 @@ struct cp_binding_level;\n    currently being defined.  */\n #define INHERITED_VALUE_BINDING_P(NODE) ((NODE)->value_is_inherited)\n \n+/* The IMPLICIT_TYPEDEF is hidden from ordinary name lookup (it was\n+   injected via a local class's friend decl). The typdef may be in the\n+   VALUE or the TYPE slot.  We do not get the situation where the\n+   value and type slots are both filled and both hidden.  */\n+#define HIDDEN_TYPE_BINDING_P(NODE) ((NODE)->type_is_hidden)\n+\n /* Datatype that represents binding established by a declaration between\n    a name and a C++ entity.  */\n struct GTY(()) cxx_binding {\n@@ -72,6 +78,7 @@ struct GTY(()) cxx_binding {\n \n   bool value_is_inherited : 1;\n   bool is_local : 1;\n+  bool type_is_hidden : 1;\n };\n \n /* Datatype used to temporarily save C++ bindings (for implicit"}, {"sha": "0b80d8ed40861b99030b2ea45f45b44f4e5b93d4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbfe0894dea4128805595dce3f23d0530b33a3c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7cbfe0894dea4128805595dce3f23d0530b33a3c", "patch": "@@ -2237,13 +2237,13 @@ ovl_make (tree fn, tree next)\n   return result;\n }\n \n-/* Add FN to the (potentially NULL) overload set OVL.  USING_P is\n-   true, if FN is via a using declaration.  We also pay attention to\n-   DECL_HIDDEN.  We keep the hidden decls first, but remaining ones\n-   are unordered.  */\n+/* Add FN to the (potentially NULL) overload set OVL.  USING_OR_HIDDEN\n+   is > 0, if FN is via a using declaration.  USING_OR_HIDDEN is < 0,\n+   if FN is hidden.  (A decl cannot be both using and hidden.)  We\n+   keep the hidden decls first, but remaining ones are unordered.  */\n \n tree\n-ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n+ovl_insert (tree fn, tree maybe_ovl, int using_or_hidden)\n {\n   tree result = maybe_ovl;\n   tree insert_after = NULL_TREE;\n@@ -2257,13 +2257,15 @@ ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n       insert_after = maybe_ovl;\n     }\n \n-  bool hidden_p = DECL_HIDDEN_P (fn);\n-  if (maybe_ovl || using_p || hidden_p || TREE_CODE (fn) == TEMPLATE_DECL)\n+  if (maybe_ovl || using_or_hidden || TREE_CODE (fn) == TEMPLATE_DECL)\n     {\n       maybe_ovl = ovl_make (fn, maybe_ovl);\n-      if (hidden_p)\n+\n+      gcc_checking_assert ((using_or_hidden < 0) == DECL_HIDDEN_P (fn));\n+\n+      if (using_or_hidden < 0)\n \tOVL_HIDDEN_P (maybe_ovl) = true;\n-      if (using_p)\n+      if (using_or_hidden > 0)\n \tOVL_DEDUP_P (maybe_ovl) = OVL_USING_P (maybe_ovl) = true;\n     }\n   else\n@@ -2290,13 +2292,9 @@ ovl_skip_hidden (tree ovl)\n        ovl = OVL_CHAIN (ovl))\n     gcc_checking_assert (DECL_HIDDEN_P (OVL_FUNCTION (ovl)));\n \n-  if (ovl && TREE_CODE (ovl) != OVERLOAD && DECL_HIDDEN_P (ovl))\n-    {\n-      /* Any hidden functions should have been wrapped in an\n-\t overload, but injected friend classes will not.  */\n-      gcc_checking_assert (!DECL_DECLARES_FUNCTION_P (ovl));\n-      ovl = NULL_TREE;\n-    }\n+  /* We should not see a naked hidden decl.  */\n+  gcc_checking_assert (!(ovl && TREE_CODE (ovl) != OVERLOAD\n+\t\t\t && DECL_HIDDEN_P (ovl)));\n \n   return ovl;\n }"}]}