{"sha": "61a7f947cc063f92ccdaa6319f1f3894bcc8557e", "node_id": "C_kwDOANBUbNoAKDYxYTdmOTQ3Y2MwNjNmOTJjY2RhYTYzMTlmMWYzODk0YmNjODU1N2U", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2021-11-08T09:35:45Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2021-11-08T09:35:45Z"}, "message": "[vect] Consider outside costs earlier for epilogue loops\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop.c (vect_better_loop_vinfo_p): Change how epilogue loop\n\tcosts are compared.", "tree": {"sha": "2e7131b27e644d24487c1ef1641980a70e3a66bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e7131b27e644d24487c1ef1641980a70e3a66bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a7f947cc063f92ccdaa6319f1f3894bcc8557e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a7f947cc063f92ccdaa6319f1f3894bcc8557e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a7f947cc063f92ccdaa6319f1f3894bcc8557e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a7f947cc063f92ccdaa6319f1f3894bcc8557e/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51152076338bc60b8bda8f061be2db97ea5b78de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51152076338bc60b8bda8f061be2db97ea5b78de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51152076338bc60b8bda8f061be2db97ea5b78de"}], "stats": {"total": 76, "additions": 67, "deletions": 9}, "files": [{"sha": "a28bb6321d76b8222bc8cfdade151ca9b4dca406", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a7f947cc063f92ccdaa6319f1f3894bcc8557e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a7f947cc063f92ccdaa6319f1f3894bcc8557e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=61a7f947cc063f92ccdaa6319f1f3894bcc8557e", "patch": "@@ -2784,17 +2784,75 @@ vect_better_loop_vinfo_p (loop_vec_info new_loop_vinfo,\n \treturn new_simdlen_p;\n     }\n \n+  loop_vec_info main_loop = LOOP_VINFO_ORIG_LOOP_INFO (old_loop_vinfo);\n+  if (main_loop)\n+    {\n+      poly_uint64 main_poly_vf = LOOP_VINFO_VECT_FACTOR (main_loop);\n+      unsigned HOST_WIDE_INT main_vf;\n+      unsigned HOST_WIDE_INT old_factor, new_factor, old_cost, new_cost;\n+      /* If we can determine how many iterations are left for the epilogue\n+\t loop, that is if both the main loop's vectorization factor and number\n+\t of iterations are constant, then we use them to calculate the cost of\n+\t the epilogue loop together with a 'likely value' for the epilogues\n+\t vectorization factor.  Otherwise we use the main loop's vectorization\n+\t factor and the maximum poly value for the epilogue's.  If the target\n+\t has not provided with a sensible upper bound poly vectorization\n+\t factors are likely to be favored over constant ones.  */\n+      if (main_poly_vf.is_constant (&main_vf)\n+\t  && LOOP_VINFO_NITERS_KNOWN_P (main_loop))\n+\t{\n+\t  unsigned HOST_WIDE_INT niters\n+\t    = LOOP_VINFO_INT_NITERS (main_loop) % main_vf;\n+\t  HOST_WIDE_INT old_likely_vf\n+\t    = estimated_poly_value (old_vf, POLY_VALUE_LIKELY);\n+\t  HOST_WIDE_INT new_likely_vf\n+\t    = estimated_poly_value (new_vf, POLY_VALUE_LIKELY);\n+\n+\t  /* If the epilogue is using partial vectors we account for the\n+\t     partial iteration here too.  */\n+\t  old_factor = niters / old_likely_vf;\n+\t  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (old_loop_vinfo)\n+\t      && niters % old_likely_vf != 0)\n+\t    old_factor++;\n+\n+\t  new_factor = niters / new_likely_vf;\n+\t  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (new_loop_vinfo)\n+\t      && niters % new_likely_vf != 0)\n+\t    new_factor++;\n+\t}\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT main_vf_max\n+\t    = estimated_poly_value (main_poly_vf, POLY_VALUE_MAX);\n+\n+\t  old_factor = main_vf_max / estimated_poly_value (old_vf,\n+\t\t\t\t\t\t\t   POLY_VALUE_MAX);\n+\t  new_factor = main_vf_max / estimated_poly_value (new_vf,\n+\t\t\t\t\t\t\t   POLY_VALUE_MAX);\n+\n+\t  /* If the loop is not using partial vectors then it will iterate one\n+\t     time less than one that does.  It is safe to subtract one here,\n+\t     because the main loop's vf is always at least 2x bigger than that\n+\t     of an epilogue.  */\n+\t  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (old_loop_vinfo))\n+\t    old_factor -= 1;\n+\t  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (new_loop_vinfo))\n+\t    new_factor -= 1;\n+\t}\n+\n+      /* Compute the costs by multiplying the inside costs with the factor and\n+\t add the outside costs for a more complete picture.  The factor is the\n+\t amount of times we are expecting to iterate this epilogue.  */\n+      old_cost = old_loop_vinfo->vec_inside_cost * old_factor;\n+      new_cost = new_loop_vinfo->vec_inside_cost * new_factor;\n+      old_cost += old_loop_vinfo->vec_outside_cost;\n+      new_cost += new_loop_vinfo->vec_outside_cost;\n+      return new_cost < old_cost;\n+    }\n+\n   /* Limit the VFs to what is likely to be the maximum number of iterations,\n      to handle cases in which at least one loop_vinfo is fully-masked.  */\n-  HOST_WIDE_INT estimated_max_niter;\n-  loop_vec_info main_loop = LOOP_VINFO_ORIG_LOOP_INFO (old_loop_vinfo);\n-  unsigned HOST_WIDE_INT main_vf;\n-  if (main_loop\n-      && LOOP_VINFO_NITERS_KNOWN_P (main_loop)\n-      && LOOP_VINFO_VECT_FACTOR (main_loop).is_constant (&main_vf))\n-    estimated_max_niter = LOOP_VINFO_INT_NITERS (main_loop) % main_vf;\n-  else\n-    estimated_max_niter = likely_max_stmt_executions_int (loop);\n+  HOST_WIDE_INT estimated_max_niter = likely_max_stmt_executions_int (loop);\n   if (estimated_max_niter != -1)\n     {\n       if (known_le (estimated_max_niter, new_vf))"}]}