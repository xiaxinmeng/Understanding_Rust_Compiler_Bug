{"sha": "76a1719f0ff8e802cd3124ec102da174e5c67f15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhMTcxOWYwZmY4ZTgwMmNkMzEyNGVjMTAyZGExNzRlNWM2N2YxNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-08T13:03:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-08T13:07:30Z"}, "message": "c++: module directive FSM\n\nAs mentioned in the preprocessor patches, there's a new kind of\npreprocessor directive for modules, and it interacts with the\ncompiler-proper, as that has to stream in header-unit macro\ninformation (when the directive is an import that names a\nheader-unit).  This is that machinery.  It's an FSM that inspects the\ntoken stream and does the minimal parsing to detect such imports.\nThis ends up being called from the C++ parser's tokenizer and from the\n-E tokenizer (via a lang hook).  The actual module streaming is a stub\nhere.\n\n\tgcc/cp/\n\t* cp-tree.h (module_token_pre, module_token_cdtor)\n\t(module_token_lang): Declare.\n\t* lex.c: Include langhooks.\n\t(struct module_token_filter): New.\n\t* cp-tree.h (module_token_pre, module_token_cdtor)\n\t(module_token_lang): Define.\n\t* module.cc (get_module, preprocess_module, preprocessed_module):\n\tNop stubs.", "tree": {"sha": "a7a2eca344276782c976eb09fd650032baeb117b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7a2eca344276782c976eb09fd650032baeb117b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76a1719f0ff8e802cd3124ec102da174e5c67f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a1719f0ff8e802cd3124ec102da174e5c67f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a1719f0ff8e802cd3124ec102da174e5c67f15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a1719f0ff8e802cd3124ec102da174e5c67f15/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f2da02b2373078e96bb44fe83f5b7fd303414a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2da02b2373078e96bb44fe83f5b7fd303414a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2da02b2373078e96bb44fe83f5b7fd303414a6"}], "stats": {"total": 223, "additions": 222, "deletions": 1}, "files": [{"sha": "aa2b0f782fa3b4c825c330a55561bacb8ede2817", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=76a1719f0ff8e802cd3124ec102da174e5c67f15", "patch": "@@ -6849,6 +6849,10 @@ extern void set_identifier_kind\t\t\t(tree, cp_identifier_kind);\n extern bool cxx_init\t\t\t\t(void);\n extern void cxx_finish\t\t\t\t(void);\n extern bool in_main_input_context\t\t(void);\n+extern uintptr_t module_token_pre (cpp_reader *, const cpp_token *, uintptr_t);\n+extern uintptr_t module_token_cdtor (cpp_reader *, uintptr_t);\n+extern uintptr_t module_token_lang (int type, int keyword, tree value,\n+\t\t\t\t    location_t, uintptr_t);\n \n /* in method.c */\n extern void init_method\t\t\t\t(void);"}, {"sha": "6053848535e7a97d2511e17412a6b0b9562eaf8c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 201, "deletions": 1, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=76a1719f0ff8e802cd3124ec102da174e5c67f15", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-objc.h\"\n #include \"gcc-rich-location.h\"\n #include \"cp-name-hint.h\"\n+#include \"langhooks.h\"\n \n static int interface_strcmp (const char *);\n static void init_cp_pragma (void);\n@@ -380,7 +381,206 @@ interface_strcmp (const char* s)\n   return 1;\n }\n \n-\f\n+/* We've just read a cpp-token, figure out our next state.  Hey, this\n+   is a hand-coded co-routine!  */\n+\n+struct module_token_filter\n+{\n+  enum state\n+  {\n+   idle,\n+   module_first,\n+   module_cont,\n+   module_end,\n+  };\n+\n+  enum state state : 8;\n+  bool is_import : 1;\n+  bool got_export : 1;\n+  bool got_colon : 1;\n+  bool want_dot : 1;\n+\n+  location_t token_loc;\n+  cpp_reader *reader;\n+  module_state *module;\n+  module_state *import;\n+\n+  module_token_filter (cpp_reader *reader)\n+    : state (idle), is_import (false),\n+    got_export (false), got_colon (false), want_dot (false),\n+    token_loc (UNKNOWN_LOCATION),\n+    reader (reader), module (NULL), import (NULL)\n+  {\n+  };\n+\n+  /* Process the next token.  Note we cannot see CPP_EOF inside a\n+     pragma -- a CPP_PRAGMA_EOL always happens.  */\n+  uintptr_t resume (int type, int keyword, tree value, location_t loc)\n+  {\n+    unsigned res = 0;\n+\n+    switch (state)\n+      {\n+      case idle:\n+\tif (type == CPP_KEYWORD)\n+\t  switch (keyword)\n+\t    {\n+\t    default:\n+\t      break;\n+\n+\t    case RID__EXPORT:\n+\t      got_export = true;\n+\t      res = lang_hooks::PT_begin_pragma;\n+\t      break;\n+\n+\t    case RID__IMPORT:\n+\t      is_import = true;\n+\t      /* FALLTHRU */\n+\t    case RID__MODULE:\n+\t      state = module_first;\n+\t      want_dot = false;\n+\t      got_colon = false;\n+\t      token_loc = loc;\n+\t      import = NULL;\n+\t      if (!got_export)\n+\t\tres = lang_hooks::PT_begin_pragma;\n+\t      break;\n+\t    }\n+\tbreak;\n+\n+      case module_first:\n+\tif (is_import && type == CPP_HEADER_NAME)\n+\t  {\n+\t    /* A header name.  The preprocessor will have already\n+\t       done include searching and canonicalization.  */\n+\t    state = module_end;\n+\t    goto header_unit;\n+\t  }\n+\t\n+\tif (type == CPP_PADDING || type == CPP_COMMENT)\n+\t  break;\n+\n+\tstate = module_cont;\n+\tif (type == CPP_COLON && module)\n+\t  {\n+\t    got_colon = true;\n+\t    import = module;\n+\t    break;\n+\t  }\n+\t/* FALLTHROUGH  */\n+\n+      case module_cont:\n+\tswitch (type)\n+\t  {\n+\t  case CPP_PADDING:\n+\t  case CPP_COMMENT:\n+\t    break;\n+\n+\t  default:\n+\t    /* If we ever need to pay attention to attributes for\n+\t       header modules, more logic will be needed.  */\n+\t    state = module_end;\n+\t    break;\n+\n+\t  case CPP_COLON:\n+\t    if (got_colon)\n+\t      state = module_end;\n+\t    got_colon = true;\n+\t    /* FALLTHROUGH  */\n+\t  case CPP_DOT:\n+\t    if (!want_dot)\n+\t      state = module_end;\n+\t    want_dot = false;\n+\t    break;\n+\n+\t  case CPP_PRAGMA_EOL:\n+\t    goto module_end;\n+\n+\t  case CPP_NAME:\n+\t    if (want_dot)\n+\t      {\n+\t\t/* Got name instead of [.:].  */\n+\t\tstate = module_end;\n+\t\tbreak;\n+\t      }\n+\t  header_unit:\n+\t    import = get_module (value, import, got_colon);\n+\t    want_dot = true;\n+\t    break;\n+\t  }\n+\tbreak;\n+\n+      case module_end:\n+\tif (type == CPP_PRAGMA_EOL)\n+\t  {\n+\t  module_end:;\n+\t    /* End of the directive, handle the name.  */\n+\t    if (import)\n+\t      if (module_state *m\n+\t\t  = preprocess_module (import, token_loc, module != NULL,\n+\t\t\t\t       is_import, got_export, reader))\n+\t\tif (!module)\n+\t\t  module = m;\n+\n+\t    is_import = got_export = false;\n+\t    state = idle;\n+\t  }\n+\tbreak;\n+      }\n+\n+    return res;\n+  }\n+};\n+\n+/* Initialize or teardown.  */\n+\n+uintptr_t\n+module_token_cdtor (cpp_reader *pfile, uintptr_t data_)\n+{\n+  if (module_token_filter *filter = reinterpret_cast<module_token_filter *> (data_))\n+    {\n+      preprocessed_module (pfile);\n+      delete filter;\n+      data_ = 0;\n+    }\n+  else if (modules_p ())\n+    data_ = reinterpret_cast<uintptr_t > (new module_token_filter (pfile));\n+\n+  return data_;\n+}\n+\n+uintptr_t\n+module_token_lang (int type, int keyword, tree value, location_t loc,\n+\t\t   uintptr_t data_)\n+{\n+  module_token_filter *filter = reinterpret_cast<module_token_filter *> (data_);\n+  return filter->resume (type, keyword, value, loc);\n+}\n+\n+uintptr_t\n+module_token_pre (cpp_reader *pfile, const cpp_token *tok, uintptr_t data_)\n+{\n+  if (!tok)\n+    return module_token_cdtor (pfile, data_);\n+\n+  int type = tok->type;\n+  int keyword = RID_MAX;\n+  tree value = NULL_TREE;\n+\n+  if (tok->type == CPP_NAME)\n+    {\n+      value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node.node));\n+      if (IDENTIFIER_KEYWORD_P (value))\n+\t{\n+\t  keyword = C_RID_CODE (value);\n+\t  type = CPP_KEYWORD;\n+\t}\n+    }\n+  else if (tok->type == CPP_HEADER_NAME)\n+    value = build_string (tok->val.str.len, (const char *)tok->val.str.text);\n+\n+  return module_token_lang (type, keyword, value, tok->src_loc, data_);\n+}\n \n /* Parse a #pragma whose sole argument is a string constant.\n    If OPT is true, the argument is optional.  */"}, {"sha": "91a1681581103d5ad7b13bf421af15c1f95c7b7b", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a1719f0ff8e802cd3124ec102da174e5c67f15/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=76a1719f0ff8e802cd3124ec102da174e5c67f15", "patch": "@@ -64,3 +64,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"langhooks.h\"\n \n+module_state *\n+get_module (tree, module_state *, bool)\n+{\n+  return nullptr;\n+}\n+\n+module_state *\n+preprocess_module (module_state *, unsigned, bool, bool, bool, cpp_reader *)\n+{\n+  return nullptr;\n+}\n+\n+void\n+preprocessed_module (cpp_reader *)\n+{\n+}\n+"}]}