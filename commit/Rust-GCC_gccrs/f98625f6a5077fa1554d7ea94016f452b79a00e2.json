{"sha": "f98625f6a5077fa1554d7ea94016f452b79a00e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4NjI1ZjZhNTA3N2ZhMTU1NGQ3ZWE5NDAxNmY0NTJiNzlhMDBlMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-12-23T08:14:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-12-23T08:14:33Z"}, "message": "re PR c++/16405 (Temporary aggregate copy not elided)\n\n\tPR c++/16405\n\t* gimplify.c (gimplify_modify_expr_rhs): Handle\n\tINDIRECT_REF/ADDR_EXPR combinations.\n\n\tPR c++/16405\n\t* g++.dg/opt/temp1.C: New test.\n\nFrom-SVN: r92539", "tree": {"sha": "53f2733f9b2d5981233b4f403e52b59105601acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f2733f9b2d5981233b4f403e52b59105601acd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f98625f6a5077fa1554d7ea94016f452b79a00e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98625f6a5077fa1554d7ea94016f452b79a00e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98625f6a5077fa1554d7ea94016f452b79a00e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98625f6a5077fa1554d7ea94016f452b79a00e2/comments", "author": null, "committer": null, "parents": [{"sha": "ad78a663e81b3d549a7e407d10e5755afc50d7c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad78a663e81b3d549a7e407d10e5755afc50d7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad78a663e81b3d549a7e407d10e5755afc50d7c5"}], "stats": {"total": 77, "additions": 77, "deletions": 0}, "files": [{"sha": "4f8f3a61f016cf06d6fbf7d11325d81ea3ac9923", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f98625f6a5077fa1554d7ea94016f452b79a00e2", "patch": "@@ -1,3 +1,9 @@\n+2004-12-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16405\n+\t* gimplify.c (gimplify_modify_expr_rhs): Handle\n+\tINDIRECT_REF/ADDR_EXPR combinations.\n+\n 2004-12-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (alpha_expand_mov): Split out ..."}, {"sha": "0f610e4d24242542f575533737a3ff66084665dc", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f98625f6a5077fa1554d7ea94016f452b79a00e2", "patch": "@@ -2801,6 +2801,33 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n   while (ret != GS_UNHANDLED)\n     switch (TREE_CODE (*from_p))\n       {\n+      case INDIRECT_REF:\n+\t{\n+\t  /* If we have code like \n+\n+\t        *(const A*)(A*)&x\n+\n+\t     where the type of \"x\" is a (possibly cv-qualified variant\n+\t     of \"A\"), treat the entire expression as identical to \"x\".\n+\t     This kind of code arises in C++ when an object is bound\n+\t     to a const reference, and if \"x\" is a TARGET_EXPR we want\n+\t     to take advantage of the optimization below.  */\n+\t  tree pointer;\n+\n+\t  pointer = TREE_OPERAND (*from_p, 0);\n+\t  STRIP_NOPS (pointer);\n+\t  if (TREE_CODE (pointer) == ADDR_EXPR\n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (pointer, 0)))\n+\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (*from_p))))\n+\t    {\n+\t      *from_p = TREE_OPERAND (pointer, 0); \n+\t      ret = GS_OK;\n+\t    }\n+\t  else\n+\t    ret = GS_UNHANDLED;\n+\t  break;\n+\t}\n+\n       case TARGET_EXPR:\n \t{\n \t  /* If we are initializing something from a TARGET_EXPR, strip the"}, {"sha": "61347db2c40cd07173b3a0d7e5e695b1a47e5e01", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f98625f6a5077fa1554d7ea94016f452b79a00e2", "patch": "@@ -1,3 +1,8 @@\n+2004-12-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16405\n+\t* g++.dg/opt/temp1.C: New test.\n+\n 2004-12-23  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/18733"}, {"sha": "f34bb8fff582acaa147bf2926f0065f948684b0b", "filename": "gcc/testsuite/g++.dg/opt/temp1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98625f6a5077fa1554d7ea94016f452b79a00e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C?ref=f98625f6a5077fa1554d7ea94016f452b79a00e2", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/16405\n+// { dg-options \"-O2\" } \n+\n+// There should be exactly one temporary generated for the code in \"f\"\n+// below when optimizing -- for the result of \"b + c\".  We have no\n+// easy way of checking that directly, so we count the number of calls\n+// to \"memcpy\", which is used on (some?) targets to copy temporaries.\n+// If there is more than two calls (one for coping \"*this\" to \"t\", and\n+// one for copying the temporary to \"a\"), then there are too many\n+// temporaries. \n+\n+int i;\n+\n+extern \"C\"\n+void *memcpy (void *dest, const void *src, __SIZE_TYPE__ n)\n+{\n+  ++i;\n+}\n+ \n+struct T {\n+  int a[128];\n+  T &operator+=(T const &v) __attribute__((noinline));\n+  T operator+(T const &v) const { T t = *this; t += v; return t; }\n+};\n+\n+T &T::operator+=(T const &v) {\n+  return *this;\n+}\n+\n+T a, b, c;\n+\n+void f() { a = b + c; }\n+\n+int main () {\n+  i = 0;\n+  f();\n+  if (i > 2)\n+    return 1;\n+}"}]}