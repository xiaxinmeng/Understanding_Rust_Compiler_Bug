{"sha": "0435312e3890ead4503ac3d1c83afc556b39dc39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQzNTMxMmUzODkwZWFkNDUwM2FjM2QxYzgzYWZjNTU2YjM5ZGMzOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-08T19:35:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-08T19:35:54Z"}, "message": "cfglayout.c (insn_scope): New static function\n\n\n\t* cfglayout.c (insn_scope): New static function\n\t(block_locators_*, line_locators*, file_locators*): New static varrays.\n\t(scope_to_insns_initialize): Use them.\n\t(insn_line, insn_file): New functions.\n\t(scope_to_insns_finalize): Use insn_scope.\n\t(prologue_locator, epilogue_locator): New global variables.\n\t* emit-rt.c (try_split, make_insn_raw, make_jump_insn_raw,\n\tmake_call_insn_raw, emit_copy_of_insn_after): Use locators.\n\t(emit_insn_after_scope, emit_insn_before_scope\n\temit_jump_insn_after_scope, emit_jump_insn_before_scope\n\temit_call_insn_after_scope, emit_call_insn_before_scope): Rename to...\n\t(emit_insn_after_setloc, emit_insn_before_setloc\n\temit_jump_insn_after_setloc, emit_jump_insn_before_setloc\n\temit_call_insn_after_setloc, emit_call_insn_before_setloc): ... these;\n\tuse locators.\n\t* final.c (notice_source_line): Use locators.\n\t(final_start_function): Set initial source file and line.\n\t(final_scan_insn): Use locators.\n\t* ifcvt.c (noce_try_store_flag, noce_try_store_flag_constants,\n\tnoce_try_addcc, noce_try_store_flag_mask, noce_try_cmove,\n\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n\tnoce_process_if_block, find_cond_trap): Likewise.\n\t* integrate.c (copy_insn_list): Likewise.\n\t* jump.c (duplicate_loop_exit_test): LIkewise.\n\t* print-rtl.c (print_rtx): Print locators.\n\t* recog.c (peephole2_optimize): Likewise.\n\t* rtl.h (INSN_SCOPE): Remove.\n\t(emit_insn_after_scope, emit_insn_before_scope\n\temit_jump_insn_after_scope, emit_jump_insn_before_scope\n\temit_call_insn_after_scope, emit_call_insn_before_scope): Rename to...\n\t(emit_insn_after_setloc, emit_insn_before_setloc\n\temit_jump_insn_after_setloc, emit_jump_insn_before_setloc\n\temit_call_insn_after_setloc, emit_call_insn_before_setloc): ... these;\n\t(insn_file, insn_line, prologue_locator, epilogue_locator): Declare.\n\t* unroll.c (copy_loop_body): Use locators.\n\t* function.c (set_insn_locators): New function.\n\t(thread_prologue_and_epilogue_insns): Set the locators accordingly.\n\nFrom-SVN: r67637", "tree": {"sha": "852a6d09fbb544c05a647e6acf28fdbf9741a19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/852a6d09fbb544c05a647e6acf28fdbf9741a19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0435312e3890ead4503ac3d1c83afc556b39dc39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435312e3890ead4503ac3d1c83afc556b39dc39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0435312e3890ead4503ac3d1c83afc556b39dc39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435312e3890ead4503ac3d1c83afc556b39dc39/comments", "author": null, "committer": null, "parents": [{"sha": "5d39821d113805e918072e3bb6c91a28a6f66188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d39821d113805e918072e3bb6c91a28a6f66188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d39821d113805e918072e3bb6c91a28a6f66188"}], "stats": {"total": 453, "additions": 324, "deletions": 129}, "files": [{"sha": "ccf8cccf6cd4046ad6048a158657cd0ae5f7a20c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -1,3 +1,43 @@\n+Sun Jun  8 21:27:41 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfglayout.c (insn_scope): New static function\n+\t(block_locators_*, line_locators*, file_locators*): New static varrays.\n+\t(scope_to_insns_initialize): Use them.\n+\t(insn_line, insn_file): New functions.\n+\t(scope_to_insns_finalize): Use insn_scope.\n+\t(prologue_locator, epilogue_locator): New global variables.\n+\t* emit-rt.c (try_split, make_insn_raw, make_jump_insn_raw,\n+\tmake_call_insn_raw, emit_copy_of_insn_after): Use locators.\n+\t(emit_insn_after_scope, emit_insn_before_scope\n+\temit_jump_insn_after_scope, emit_jump_insn_before_scope\n+\temit_call_insn_after_scope, emit_call_insn_before_scope): Rename to...\n+\t(emit_insn_after_setloc, emit_insn_before_setloc\n+\temit_jump_insn_after_setloc, emit_jump_insn_before_setloc\n+\temit_call_insn_after_setloc, emit_call_insn_before_setloc): ... these;\n+\tuse locators.\n+\t* final.c (notice_source_line): Use locators.\n+\t(final_start_function): Set initial source file and line.\n+\t(final_scan_insn): Use locators.\n+\t* ifcvt.c (noce_try_store_flag, noce_try_store_flag_constants,\n+\tnoce_try_addcc, noce_try_store_flag_mask, noce_try_cmove,\n+\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n+\tnoce_process_if_block, find_cond_trap): Likewise.\n+\t* integrate.c (copy_insn_list): Likewise.\n+\t* jump.c (duplicate_loop_exit_test): LIkewise.\n+\t* print-rtl.c (print_rtx): Print locators.\n+\t* recog.c (peephole2_optimize): Likewise.\n+\t* rtl.h (INSN_SCOPE): Remove.\n+\t(emit_insn_after_scope, emit_insn_before_scope\n+\temit_jump_insn_after_scope, emit_jump_insn_before_scope\n+\temit_call_insn_after_scope, emit_call_insn_before_scope): Rename to...\n+\t(emit_insn_after_setloc, emit_insn_before_setloc\n+\temit_jump_insn_after_setloc, emit_jump_insn_before_setloc\n+\temit_call_insn_after_setloc, emit_call_insn_before_setloc): ... these;\n+\t(insn_file, insn_line, prologue_locator, epilogue_locator): Declare.\n+\t* unroll.c (copy_loop_body): Use locators.\n+\t* function.c (set_insn_locators): New function.\n+\t(thread_prologue_and_epilogue_insns): Set the locators accordingly.\n+\n 2003-06-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.h (LONG_LONG_TYPE_SIZE): Set to 64."}, {"sha": "535e50f04a2185d25254685c323de2e39c7f8225", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -1775,7 +1775,7 @@ tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    $(PARAMS_H) $(COVERAGE_H)\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \\\n-   function.h cfglayout.h cfgloop.h $(TARGET_H)\n+   function.h cfglayout.h cfgloop.h $(TARGET_H) gt-cfglayout.h $(GGC_H)\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TIMEVAR_H) flags.h \\\n    intl.h toplev.h\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n@@ -1995,7 +1995,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(srcdir)/fold-const.c $(srcdir)/function.c \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/ra-build.c $(srcdir)/regclass.c \\\n-  $(srcdir)/reg-stack.c \\\n+  $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(out_file) \\\n@@ -2013,7 +2013,7 @@ gt-lists.h gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h \\\n gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h \\\n gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n-gt-c-pragma.h gt-c-objc-common.h gtype-c.h gt-input.h \\\n+gt-c-pragma.h gt-c-objc-common.h gtype-c.h gt-input.h gt-cfglayout.h \\\n gt-stringpool.h : s-gtype ; @true\n \n gtyp-gen.h: Makefile"}, {"sha": "5bd3ca056559c9acf2e51ffe9f3c6ea7027f15ee", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 166, "deletions": 9, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -33,6 +33,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"cfgloop.h\"\n #include \"target.h\"\n+#include \"ggc.h\"\n \n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.  */\n@@ -54,6 +55,7 @@ static void cleanup_unconditional_jumps\tPARAMS ((struct loops *));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n static void break_superblocks PARAMS ((void));\n+static tree insn_scope PARAMS ((rtx));\n \f\n rtx\n unlink_insn_chain (first, last)\n@@ -212,22 +214,83 @@ record_effective_endpoints ()\n     cfg_layout_function_footer = unlink_insn_chain (cfg_layout_function_footer, get_last_insn ());\n }\n \f\n-/* Build a varray mapping INSN_UID to lexical block.  Return it.  */\n+/* Data structures representing mapping of INSN_LOCATOR into scope blocks, line\n+   numbers and files.  In order to be GGC friendly we need to use separate\n+   varrays.  This also slightly improve the memory locality in binary search.\n+   The _locs array contains locators where the given property change.  The\n+   block_locators_blocks contains the scope block that is used for all insn\n+   locator greater than corresponding block_locators_locs value and smaller\n+   than the following one.  Similarly for the other properties.  */\n+static GTY(()) varray_type block_locators_locs;\n+static GTY(()) varray_type block_locators_blocks;\n+static GTY(()) varray_type line_locators_locs;\n+static GTY(()) varray_type line_locators_lines;\n+static GTY(()) varray_type file_locators_locs;\n+static GTY(()) varray_type file_locators_files;\n+int prologue_locator;\n+int epilogue_locator;\n+\n+/* During the RTL expansion the lexical blocks and line numbers are\n+   represented via INSN_NOTEs.  Replace them by representation using\n+   INSN_LOCATORs.  */\n \n void\n-scope_to_insns_initialize ()\n+insn_locators_initialize ()\n {\n   tree block = NULL;\n+  tree last_block = NULL;\n   rtx insn, next;\n+  int loc = 0;\n+  int line_number = 0, last_line_number = 0;\n+  char *file_name = NULL, *last_file_name = NULL;\n+\n+  prologue_locator = epilogue_locator = 0;\n+\n+  VARRAY_INT_INIT (block_locators_locs, 32, \"block_locators_locs\");\n+  VARRAY_TREE_INIT (block_locators_blocks, 32, \"block_locators_blocks\");\n+  VARRAY_INT_INIT (line_locators_locs, 32, \"line_locators_locs\");\n+  VARRAY_INT_INIT (line_locators_lines, 32, \"line_locators_lines\");\n+  VARRAY_INT_INIT (file_locators_locs, 32, \"file_locators_locs\");\n+  VARRAY_CHAR_PTR_INIT (file_locators_files, 32, \"file_locators_files\");\n \n   for (insn = get_insns (); insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n \n-      if (active_insn_p (insn)\n-\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n-        INSN_SCOPE (insn) = block;\n+      if ((active_insn_p (insn)\n+\t   && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\t  || !NEXT_INSN (insn)\n+\t  || (!prologue_locator && file_name))\n+\t{\n+\t  if (last_block != block)\n+\t    {\n+\t      loc++;\n+\t      VARRAY_PUSH_INT (block_locators_locs, loc);\n+\t      VARRAY_PUSH_TREE (block_locators_blocks, block);\n+\t      last_block = block;\n+\t    }\n+\t  if (last_line_number != line_number)\n+\t    {\n+\t      loc++;\n+\t      VARRAY_PUSH_INT (line_locators_locs, loc);\n+\t      VARRAY_PUSH_INT (line_locators_lines, line_number);\n+\t      last_line_number = line_number;\n+\t    }\n+\t  if (last_file_name != file_name)\n+\t    {\n+\t      loc++;\n+\t      VARRAY_PUSH_INT (file_locators_locs, loc);\n+\t      VARRAY_PUSH_CHAR_PTR (file_locators_files, file_name);\n+\t      last_file_name = file_name;\n+\t    }\n+\t}\n+      if (!prologue_locator && file_name)\n+\tprologue_locator = loc;\n+      if (!NEXT_INSN (insn))\n+\tepilogue_locator = loc;\n+      if (active_insn_p (insn))\n+        INSN_LOCATOR (insn) = loc;\n       else if (GET_CODE (insn) == NOTE)\n \t{\n \t  switch (NOTE_LINE_NUMBER (insn))\n@@ -243,6 +306,11 @@ scope_to_insns_initialize ()\n \t      delete_insn (insn);\n \t      break;\n \t    default:\n+\t      if (NOTE_LINE_NUMBER (insn) > 0)\n+\t\t{\n+\t\t  line_number = NOTE_LINE_NUMBER (insn);\n+\t\t  file_name = (char *)NOTE_SOURCE_FILE (insn);\n+\t\t}\n \t      break;\n \t    }\n \t}\n@@ -330,11 +398,98 @@ change_scope (orig_insn, s1, s2)\n     }\n }\n \n+/* Return lexical scope block insn belong to.  */\n+static tree\n+insn_scope (insn)\n+   rtx insn;\n+{\n+  int max = VARRAY_ACTIVE_SIZE (block_locators_locs);\n+  int min = 0;\n+  int loc = INSN_LOCATOR (insn);\n+\n+  if (!max || !loc)\n+    return NULL;\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VARRAY_INT (block_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+   return VARRAY_TREE (block_locators_blocks, min);\n+}\n+\n+/* Return line number of the statement that produced this insn.  */\n+int\n+insn_line (insn)\n+   rtx insn;\n+{\n+  int max = VARRAY_ACTIVE_SIZE (line_locators_locs);\n+  int min = 0;\n+  int loc = INSN_LOCATOR (insn);\n+\n+  if (!max || !loc)\n+    return 0;\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VARRAY_INT (line_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+   return VARRAY_INT (line_locators_lines, min);\n+}\n+\n+/* Return source file of the statement that produced this insn.  */\n+const char *\n+insn_file (insn)\n+   rtx insn;\n+{\n+  int max = VARRAY_ACTIVE_SIZE (file_locators_locs);\n+  int min = 0;\n+  int loc = INSN_LOCATOR (insn);\n+\n+  if (!max || !loc)\n+    return NULL;\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VARRAY_INT (file_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+   return VARRAY_CHAR_PTR (file_locators_files, min);\n+}\n+\n /* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n    on the scope tree and the newly reordered instructions.  */\n \n void\n-scope_to_insns_finalize ()\n+reemit_insn_block_notes ()\n {\n   tree cur_block = DECL_INITIAL (cfun->decl);\n   rtx insn, note;\n@@ -346,7 +501,7 @@ scope_to_insns_finalize ()\n     {\n       tree this_block;\n \n-      this_block = INSN_SCOPE (insn);\n+      this_block = insn_scope (insn);\n       /* For sequences compute scope resulting from merging all scopes\n          of instructions nested inside.  */\n       if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n@@ -357,7 +512,7 @@ scope_to_insns_finalize ()\n \t  this_block = NULL;\n \t  for (i = 0; i < XVECLEN (body, 0); i++)\n \t    this_block = choose_inner_scope (this_block,\n-\t\t\t    \t\t INSN_SCOPE (XVECEXP (body, 0, i)));\n+\t\t\t    \t\t insn_scope (XVECEXP (body, 0, i)));\n \t}\n       if (! this_block)\n \tcontinue;\n@@ -1051,3 +1206,5 @@ cfg_layout_finalize ()\n   verify_flow_info ();\n #endif\n }\n+\n+#include \"gt-cfglayout.h\""}, {"sha": "4ae8b6677c9955366fa2658acfa17eeaf995382c", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -41,5 +41,5 @@ extern void cfg_layout_initialize\tPARAMS ((struct loops *));\n extern void cfg_layout_finalize\t\tPARAMS ((void));\n extern bool cfg_layout_can_duplicate_bb_p PARAMS ((basic_block));\n extern basic_block cfg_layout_duplicate_bb PARAMS ((basic_block, edge));\n-extern void scope_to_insns_initialize\tPARAMS ((void));\n-extern void scope_to_insns_finalize\tPARAMS ((void));\n+extern void insn_locators_initialize\tPARAMS ((void));\n+extern void reemit_insn_block_notes\tPARAMS ((void));"}, {"sha": "3e2f089bed978f1f77427b8968d9b1f3b621832d", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -1702,7 +1702,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t     as I2 will not cause a problem.  */\n \n \t  i1 = gen_rtx_INSN (VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n-\t\t\t     BLOCK_FOR_INSN (i2), INSN_SCOPE (i2),\n+\t\t\t     BLOCK_FOR_INSN (i2), INSN_LOCATOR (i2),\n \t\t\t     XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX,\n \t\t\t     NULL_RTX);\n "}, {"sha": "208af572c6dd642091191faf050819394691c9e3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -3586,7 +3586,7 @@ try_split (pat, trial, last)\n \t}\n     }\n \n-  tem = emit_insn_after_scope (seq, trial, INSN_SCOPE (trial));\n+  tem = emit_insn_after_setloc (seq, trial, INSN_LOCATOR (trial));\n \n   delete_insn (trial);\n   if (has_barrier)\n@@ -3624,7 +3624,7 @@ make_insn_raw (pattern)\n   INSN_CODE (insn) = -1;\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n-  INSN_SCOPE (insn) = NULL;\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n #ifdef ENABLE_RTL_CHECKING\n@@ -3658,7 +3658,7 @@ make_jump_insn_raw (pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   JUMP_LABEL (insn) = NULL;\n-  INSN_SCOPE (insn) = NULL;\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -3680,7 +3680,7 @@ make_call_insn_raw (pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   CALL_INSN_FUNCTION_USAGE (insn) = NULL;\n-  INSN_SCOPE (insn) = NULL;\n+  INSN_LOCATOR (insn) = 0;\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -4653,71 +4653,71 @@ emit_line_note_after (file, line, after)\n   return note;\n }\n \f\n-/* Like emit_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+/* Like emit_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_insn_after_scope (pattern, after, scope)\n+emit_insn_after_setloc (pattern, after, loc)\n      rtx pattern, after;\n-     tree scope;\n+     int loc;\n {\n   rtx last = emit_insn_after (pattern, after);\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n       if (active_insn_p (after))\n-\tINSN_SCOPE (after) = scope;\n+\tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n       after = NEXT_INSN (after);\n     }\n   return last;\n }\n \n-/* Like emit_jump_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+/* Like emit_jump_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_jump_insn_after_scope (pattern, after, scope)\n+emit_jump_insn_after_setloc (pattern, after, loc)\n      rtx pattern, after;\n-     tree scope;\n+     int loc;\n {\n   rtx last = emit_jump_insn_after (pattern, after);\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n       if (active_insn_p (after))\n-\tINSN_SCOPE (after) = scope;\n+\tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n       after = NEXT_INSN (after);\n     }\n   return last;\n }\n \n-/* Like emit_call_insn_after, but set INSN_SCOPE according to SCOPE.  */\n+/* Like emit_call_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_call_insn_after_scope (pattern, after, scope)\n+emit_call_insn_after_setloc (pattern, after, loc)\n      rtx pattern, after;\n-     tree scope;\n+     int loc;\n {\n   rtx last = emit_call_insn_after (pattern, after);\n \n   after = NEXT_INSN (after);\n   while (1)\n     {\n       if (active_insn_p (after))\n-\tINSN_SCOPE (after) = scope;\n+\tINSN_LOCATOR (after) = loc;\n       if (after == last)\n \tbreak;\n       after = NEXT_INSN (after);\n     }\n   return last;\n }\n \n-/* Like emit_insn_before, but set INSN_SCOPE according to SCOPE.  */\n+/* Like emit_insn_before, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_insn_before_scope (pattern, before, scope)\n+emit_insn_before_setloc (pattern, before, loc)\n      rtx pattern, before;\n-     tree scope;\n+     int loc;\n {\n   rtx first = PREV_INSN (before);\n   rtx last = emit_insn_before (pattern, before);\n@@ -4726,7 +4726,7 @@ emit_insn_before_scope (pattern, before, scope)\n   while (1)\n     {\n       if (active_insn_p (first))\n-\tINSN_SCOPE (first) = scope;\n+\tINSN_LOCATOR (first) = loc;\n       if (first == last)\n \tbreak;\n       first = NEXT_INSN (first);\n@@ -5798,7 +5798,7 @@ emit_copy_of_insn_after (insn, after)\n   /* Update LABEL_NUSES.  */\n   mark_jump_label (PATTERN (new), new, 0);\n \n-  INSN_SCOPE (new) = INSN_SCOPE (insn);\n+  INSN_LOCATOR (new) = INSN_LOCATOR (insn);\n \n   /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n      make them.  */"}, {"sha": "dae455d2990b8c8c4b8228ae4db1b2bf94f82d4a", "filename": "gcc/final.c", "status": "modified", "additions": 23, "deletions": 56, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -205,7 +205,7 @@ static int asm_insn_count\tPARAMS ((rtx));\n #endif\n static void profile_function\tPARAMS ((FILE *));\n static void profile_after_prologue PARAMS ((FILE *));\n-static void notice_source_line\tPARAMS ((rtx));\n+static bool notice_source_line\tPARAMS ((rtx));\n static rtx walk_alter_subreg\tPARAMS ((rtx *));\n static void output_asm_name\tPARAMS ((void));\n static void output_alternate_entry_point PARAMS ((FILE *, rtx));\n@@ -1338,7 +1338,7 @@ asm_insn_count (body)\n \n void\n final_start_function (first, file, optimize)\n-     rtx first;\n+     rtx first ATTRIBUTE_UNUSED;\n      FILE *file;\n      int optimize ATTRIBUTE_UNUSED;\n {\n@@ -1359,8 +1359,8 @@ final_start_function (first, file, optimize)\n     }\n #endif\n \n-  if (NOTE_LINE_NUMBER (first) != NOTE_INSN_DELETED)\n-    notice_source_line (first);\n+  last_linenum = 0;\n+  last_filename = 0;\n   high_block_linenum = high_function_linenum = last_linenum;\n \n   (*debug_hooks->begin_prologue) (last_linenum, last_filename);\n@@ -1392,7 +1392,7 @@ final_start_function (first, file, optimize)\n   if (write_symbols)\n     {\n       remove_unnecessary_notes ();\n-      scope_to_insns_finalize ();\n+      reemit_insn_block_notes ();\n       number_blocks (current_function_decl);\n       /* We never actually put out begin/end notes for the top-level\n \t block in the function.  But, conceptually, that block is\n@@ -1821,51 +1821,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tdefault:\n \t  if (NOTE_LINE_NUMBER (insn) <= 0)\n \t    abort ();\n-\n-\t  /* This note is a line-number.  */\n-\t  {\n-\t    rtx note;\n-\t    int note_after = 0;\n-\n-\t    /* If there is anything real after this note, output it.\n-\t       If another line note follows, omit this one.  */\n-\t    for (note = NEXT_INSN (insn); note; note = NEXT_INSN (note))\n-\t      {\n-\t\tif (GET_CODE (note) != NOTE && GET_CODE (note) != CODE_LABEL)\n-\t\t  break;\n-\n-\t\t/* These types of notes can be significant\n-\t\t   so make sure the preceding line number stays.  */\n-\t\telse if (GET_CODE (note) == NOTE\n-\t\t\t && (NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_BEG\n-\t\t\t     || NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_END\n-\t\t\t     || NOTE_LINE_NUMBER (note) == NOTE_INSN_FUNCTION_BEG))\n-\t\t  break;\n-\t\telse if (GET_CODE (note) == NOTE && NOTE_LINE_NUMBER (note) > 0)\n-\t\t  {\n-\t\t    /* Another line note follows; we can delete this note\n-\t\t       if no intervening line numbers have notes elsewhere.  */\n-\t\t    int num;\n-\t\t    for (num = NOTE_LINE_NUMBER (insn) + 1;\n-\t\t         num < NOTE_LINE_NUMBER (note);\n-\t\t         num++)\n-\t\t      if (line_note_exists[num])\n-\t\t\tbreak;\n-\n-\t\t    if (num >= NOTE_LINE_NUMBER (note))\n-\t\t      note_after = 1;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\n-\t    /* Output this line note if it is the first or the last line\n-\t       note in a row.  */\n-\t    if (!note_after)\n-\t      {\n-\t\tnotice_source_line (insn);\n-\t\t(*debug_hooks->source_line) (last_linenum, last_filename);\n-\t      }\n-\t  }\n \t  break;\n \t}\n       break;\n@@ -2091,6 +2046,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \t    break;\n \t  }\n+\t/* Output this line note if it is the first or the last line\n+\t   note in a row.  */\n+\tif (notice_source_line (insn))\n+\t  {\n+\t    (*debug_hooks->source_line) (last_linenum, last_filename);\n+\t  }\n \n \tif (GET_CODE (body) == ASM_INPUT)\n \t  {\n@@ -2561,16 +2522,22 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n /* Output debugging info to the assembler file FILE\n    based on the NOTE-insn INSN, assumed to be a line number.  */\n \n-static void\n+static bool\n notice_source_line (insn)\n      rtx insn;\n {\n-  const char *filename = NOTE_SOURCE_FILE (insn);\n+  const char *filename = insn_file (insn);\n+  int linenum = insn_line (insn);\n \n-  last_filename = filename;\n-  last_linenum = NOTE_LINE_NUMBER (insn);\n-  high_block_linenum = MAX (last_linenum, high_block_linenum);\n-  high_function_linenum = MAX (last_linenum, high_function_linenum);\n+  if (filename && (filename != last_filename || last_linenum != linenum))\n+    {\n+      last_filename = filename;\n+      last_linenum = linenum;\n+      high_block_linenum = MAX (last_linenum, high_block_linenum);\n+      high_function_linenum = MAX (last_linenum, high_function_linenum);\n+      return true;\n+    }\n+  return false;\n }\n \f\n /* For each operand in INSN, simplify (subreg (reg)) so that it refers"}, {"sha": "e59bf6a954c59f8b9ab4c357e116873837c5042b", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -300,6 +300,7 @@ static void do_clobber_return_reg PARAMS ((rtx, void *));\n static void do_use_return_reg PARAMS ((rtx, void *));\n static void instantiate_virtual_regs_lossage PARAMS ((rtx));\n static tree split_complex_args (tree);\n+static void set_insn_locators (rtx, int);\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n static GTY(()) struct function *outer_function_chain;\n@@ -7348,6 +7349,20 @@ record_insns (insns, vecp)\n     }\n }\n \n+/* Set the specified locator to the insn chain.  */\n+static void\n+set_insn_locators (insn, loc)\n+  rtx insn;\n+  int loc;\n+{\n+  while (insn != NULL_RTX)\n+    {\n+      if (INSN_P (insn))\n+\tINSN_LOCATOR (insn) = loc;\n+      insn = NEXT_INSN (insn);\n+    }\n+}\n+\n /* Determine how many INSN_UIDs in VEC are part of INSN.  Because we can\n    be running after reorg, SEQUENCE rtl is possible.  */\n \n@@ -7754,6 +7769,7 @@ thread_prologue_and_epilogue_insns (f)\n \n       seq = get_insns ();\n       end_sequence ();\n+      set_insn_locators (seq, prologue_locator);\n \n       /* Can't deal with multiple successors of the entry block\n          at the moment.  Function should always have at least one\n@@ -7901,6 +7917,7 @@ thread_prologue_and_epilogue_insns (f)\n \n       /* Retain a map of the epilogue insns.  */\n       record_insns (seq, &epilogue);\n+      set_insn_locators (seq, epilogue_locator);\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -7936,6 +7953,7 @@ thread_prologue_and_epilogue_insns (f)\n \t avoid getting rid of sibcall epilogue insns.  Do this before we\n \t actually emit the sequence.  */\n       record_insns (seq, &sibcall_epilogue);\n+      set_insn_locators (seq, epilogue_locator);\n \n       i = PREV_INSN (insn);\n       newinsn = emit_insn_before (seq, insn);"}, {"sha": "84788f0bd3a8e7141ea459dea6a1ccd077e3c492", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -718,7 +718,7 @@ noce_try_store_flag (if_info)\n \n       seq = get_insns ();\n       end_sequence ();\n-      emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+      emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -853,7 +853,7 @@ noce_try_store_flag_constants (if_info)\n       if (seq_contains_jump (seq))\n \treturn FALSE;\n \n-      emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+      emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n \n       return TRUE;\n     }\n@@ -901,8 +901,8 @@ noce_try_addcc (if_info)\n \n \t      seq = get_insns ();\n \t      end_sequence ();\n-\t      emit_insn_before_scope (seq, if_info->jump,\n-\t\t\t\t      INSN_SCOPE (if_info->insn_a));\n+\t      emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t      INSN_LOCATOR (if_info->insn_a));\n \t      return TRUE;\n \t    }\n \t  end_sequence ();\n@@ -943,8 +943,8 @@ noce_try_addcc (if_info)\n \t      if (seq_contains_jump (seq))\n \t\treturn FALSE;\n \n-\t      emit_insn_before_scope (seq, if_info->jump,\n-\t\t\t\t      INSN_SCOPE (if_info->insn_a));\n+\t      emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t      INSN_LOCATOR (if_info->insn_a));\n \n \t      return TRUE;\n \t    }\n@@ -996,8 +996,8 @@ noce_try_store_flag_mask (if_info)\n \t  if (seq_contains_jump (seq))\n \t    return FALSE;\n \n-\t  emit_insn_before_scope (seq, if_info->jump,\n-\t\t\t\t  INSN_SCOPE (if_info->insn_a));\n+\t  emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t  INSN_LOCATOR (if_info->insn_a));\n \n \t  return TRUE;\n \t}\n@@ -1092,8 +1092,8 @@ noce_try_cmove (if_info)\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n-\t  emit_insn_before_scope (seq, if_info->jump,\n-\t\t\t\t  INSN_SCOPE (if_info->insn_a));\n+\t  emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t  INSN_LOCATOR (if_info->insn_a));\n \t  return TRUE;\n \t}\n       else\n@@ -1255,7 +1255,7 @@ noce_try_cmove_arith (if_info)\n \n   tmp = get_insns ();\n   end_sequence ();\n-  emit_insn_before_scope (tmp, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_setloc (tmp, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n   return TRUE;\n \n  end_seq_and_fail:\n@@ -1507,7 +1507,7 @@ noce_try_minmax (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1625,7 +1625,7 @@ noce_try_abs (if_info)\n   if (seq_contains_jump (seq))\n     return FALSE;\n \n-  emit_insn_before_scope (seq, if_info->jump, INSN_SCOPE (if_info->insn_a));\n+  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -1945,7 +1945,7 @@ noce_process_if_block (ce_info)\n       insn_b = get_insns ();\n       end_sequence ();\n \n-      emit_insn_after_scope (insn_b, test_bb->end, INSN_SCOPE (insn_a));\n+      emit_insn_after_setloc (insn_b, test_bb->end, INSN_LOCATOR (insn_a));\n     }\n \n   /* Merge the blocks!  */\n@@ -2548,7 +2548,7 @@ find_cond_trap (test_bb, then_edge, else_edge)\n     return FALSE;\n \n   /* Emit the new insns before cond_earliest.  */\n-  emit_insn_before_scope (seq, cond_earliest, INSN_SCOPE (trap));\n+  emit_insn_before_setloc (seq, cond_earliest, INSN_LOCATOR (trap));\n \n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);"}, {"sha": "4152fb27fa4f37734051f747db50156267aed407", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -1546,7 +1546,7 @@ copy_insn_list (insns, map, static_chain_value)\n #else\n \t  try_constants (copy, map);\n #endif\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \t  break;\n \n \tcase JUMP_INSN:\n@@ -1567,7 +1567,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t  cc0_insn = 0;\n #endif\n \t  try_constants (copy, map);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \n \t  /* If this used to be a conditional jump insn but whose branch\n \t     direction is now know, we must do something special.  */\n@@ -1635,7 +1635,7 @@ copy_insn_list (insns, map, static_chain_value)\n \n \t  SIBLING_CALL_P (copy) = SIBLING_CALL_P (insn);\n \t  CONST_OR_PURE_CALL_P (copy) = CONST_OR_PURE_CALL_P (insn);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \n \t  /* Because the USAGE information potentially contains objects other\n \t     than hard registers, we need to copy it.  */"}, {"sha": "40166b40e31169a6f04403d42cd3fe52209b96cb", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -429,7 +429,7 @@ duplicate_loop_exit_test (loop_start)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \n \t  mark_jump_label (PATTERN (copy), copy, 0);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \n \t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n \t     make them.  */\n@@ -455,7 +455,7 @@ duplicate_loop_exit_test (loop_start)\n \tcase JUMP_INSN:\n \t  copy = emit_jump_insn_before (copy_insn (PATTERN (insn)),\n \t\t\t\t\tloop_start);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \t  mark_jump_label (PATTERN (copy), copy, 0);"}, {"sha": "165db771e35df4aee7d33d07c5c96b2bf1d9f5d8", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -379,7 +379,17 @@ print_rtx (in_rtx)\n \tbreak;\n \n       case 'i':\n-\tif (i == 6 && GET_CODE (in_rtx) == NOTE)\n+\tif (i == 4 && GET_RTX_CLASS (GET_CODE (in_rtx)) == 'i')\n+\t  {\n+#ifndef GENERATOR_FILE\n+\t    /*  Pretty-print insn locators.  Ignore scoping as it is mostly\n+\t\tredundant with line number information and do not print anything\n+\t\twhen there is no location information available.  */\n+\t    if (INSN_LOCATOR (in_rtx) && insn_file (in_rtx))\n+\t      fprintf(outfile, \" %s:%i\", insn_file (in_rtx), insn_line (in_rtx));\n+#endif\n+\t  }\n+\telse if (i == 6 && GET_CODE (in_rtx) == NOTE)\n \t  {\n \t    /* This field is only used for NOTE_INSN_DELETED_LABEL, and\n \t       other times often contains garbage from INSN->NOTE death.  */"}, {"sha": "8ea1e8d58dc7453572104d0c8bbf10111a3e7fe4", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -3249,8 +3249,8 @@ peephole2_optimize (dump_file)\n \t\t\t\t\tREG_EH_REGION, NULL_RTX);\n \n \t\t  /* Replace the old sequence with the new.  */\n-\t\t  try = emit_insn_after_scope (try, peep2_insn_data[i].insn,\n-\t\t\t\t\t       INSN_SCOPE (peep2_insn_data[i].insn));\n+\t\t  try = emit_insn_after_setloc (try, peep2_insn_data[i].insn,\n+\t\t\t\t\t        INSN_LOCATOR (peep2_insn_data[i].insn));\n \t\t  before_try = PREV_INSN (insn);\n \t\t  delete_insn_chain (insn, peep2_insn_data[i].insn);\n "}, {"sha": "1388b6ffd5584678a6e836b36d4861d965468701", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -603,18 +603,18 @@ DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n    ---------------------------------------------------------------------- */\n \n /* An instruction that cannot jump.  */\n-DEF_RTL_EXPR(INSN, \"insn\", \"iuuBteiee\", 'i')\n+DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", 'i')\n \n /* An instruction that can possibly jump.\n    Fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBteiee0\", 'i')\n+DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", 'i')\n \n /* An instruction that can possibly call a subroutine\n    but which will not change which instruction comes next\n    in the current function.\n    Field ( rtx->fld[9] ) is CALL_INSN_FUNCTION_USAGE.\n    All other fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBteieee\", 'i')\n+DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", 'i')\n \n /* A marker that indicates that control will not flow through.  */\n DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", 'x')"}, {"sha": "8b2ae092ebbedaa98267369e8401be079bb273cd", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -538,7 +538,7 @@ do {\t\t\t\t\\\n #define NEXT_INSN(INSN)\tXEXP (INSN, 2)\n \n #define BLOCK_FOR_INSN(INSN) XBBDEF (INSN, 3)\n-#define INSN_SCOPE(INSN) XTREE (INSN, 4)\n+#define INSN_LOCATOR(INSN) XINT (INSN, 4)\n /* The body of an insn.  */\n #define PATTERN(INSN)\tXEXP (INSN, 5)\n \n@@ -1513,20 +1513,20 @@ extern rtx assign_stack_temp_for_type\tPARAMS ((enum machine_mode,\n extern rtx assign_temp\t\t\tPARAMS ((tree, int, int, int));\n /* In emit-rtl.c */\n extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\n-extern rtx emit_jump_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_jump_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\n-extern rtx emit_call_insn_before_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_call_insn_before_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_barrier_before\t\tPARAMS ((rtx));\n extern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_before\t\tPARAMS ((int, rtx));\n extern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_jump_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_jump_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_call_insn_after\t\tPARAMS ((rtx, rtx));\n-extern rtx emit_call_insn_after_scope\tPARAMS ((rtx, rtx, tree));\n+extern rtx emit_call_insn_after_setloc\tPARAMS ((rtx, rtx, int));\n extern rtx emit_barrier_after\t\tPARAMS ((rtx));\n extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_after\t\tPARAMS ((int, rtx));\n@@ -1558,6 +1558,9 @@ extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n \n /* In cfglayout.c  */\n extern tree choose_inner_scope\t\tPARAMS ((tree, tree));\n+extern int insn_line \t\t\tPARAMS ((rtx));\n+extern const char * insn_file \t\tPARAMS ((rtx));\n+extern int prologue_locator, epilogue_locator;\n \n /* In jump.c */\n extern rtx next_nondeleted_insn\t\tPARAMS ((rtx));"}, {"sha": "85157e7bb0ddfae08ff587c423b004e240f6f9e0", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -3570,7 +3570,7 @@ rest_of_compilation (tree decl)\n \n   timevar_pop (TV_JUMP);\n \n-  scope_to_insns_initialize ();\n+  insn_locators_initialize ();\n   /* Complete generation of exception handling code.  */\n   if (doing_eh (0))\n     {"}, {"sha": "43539c34eaf49aa932376d8e5802ead2ebc2d345", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435312e3890ead4503ac3d1c83afc556b39dc39/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0435312e3890ead4503ac3d1c83afc556b39dc39", "patch": "@@ -2040,7 +2040,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t      copy = emit_insn (pattern);\n \t    }\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \n \t  /* If there is a REG_EQUAL note present whose value\n \t     is not loop invariant, then delete it, since it\n@@ -2094,7 +2094,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_jump_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \n \t  if (JUMP_LABEL (insn))\n \t    {\n@@ -2218,7 +2218,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map, 0);\n \t  copy = emit_call_insn (pattern);\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n-\t  INSN_SCOPE (copy) = INSN_SCOPE (insn);\n+\t  INSN_LOCATOR (copy) = INSN_LOCATOR (insn);\n \t  SIBLING_CALL_P (copy) = SIBLING_CALL_P (insn);\n \t  CONST_OR_PURE_CALL_P (copy) = CONST_OR_PURE_CALL_P (insn);\n "}]}