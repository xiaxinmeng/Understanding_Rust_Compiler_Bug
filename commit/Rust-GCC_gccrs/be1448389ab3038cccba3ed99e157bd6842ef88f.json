{"sha": "be1448389ab3038cccba3ed99e157bd6842ef88f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxNDQ4Mzg5YWIzMDM4Y2NjYmEzZWQ5OWUxNTdiZDY4NDJlZjg4Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-02-13T20:17:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-02-13T20:17:55Z"}, "message": "re PR rtl-optimization/47477 (Sub-optimal mov at end of method)\n\n\tPR rtl-optimization/47477\n\t* match.pd (convert (plus/minus (convert @0) (convert @1): New\n\tsimplifier to narrow arithmetic.\n\n\tPR rtl-optimization/47477\n\t* gcc.dg/tree-ssa/pr47477.c: New test.\n\nFrom-SVN: r220695", "tree": {"sha": "79bec4c1dc64b01a597c72371d5e618363458405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79bec4c1dc64b01a597c72371d5e618363458405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1448389ab3038cccba3ed99e157bd6842ef88f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1448389ab3038cccba3ed99e157bd6842ef88f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1448389ab3038cccba3ed99e157bd6842ef88f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1448389ab3038cccba3ed99e157bd6842ef88f/comments", "author": null, "committer": null, "parents": [{"sha": "d05022766b7e692567e24198d44b91253c4a2625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05022766b7e692567e24198d44b91253c4a2625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05022766b7e692567e24198d44b91253c4a2625"}], "stats": {"total": 74, "additions": 74, "deletions": 0}, "files": [{"sha": "f36e16c1514ae4a0b562c7a4480ad8576a62433c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1448389ab3038cccba3ed99e157bd6842ef88f", "patch": "@@ -1,3 +1,9 @@\n+2015-02-13  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/47477\n+\t* match.pd (convert (plus/minus (convert @0) (convert @1): New\n+\tsimplifier to narrow arithmetic.\n+\n 2015-02-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65028"}, {"sha": "d438179be4f5cf3dc5f155f9234562022fa90365", "filename": "gcc/match.pd", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=be1448389ab3038cccba3ed99e157bd6842ef88f", "patch": "@@ -1018,3 +1018,44 @@ along with GCC; see the file COPYING3.  If not see\n    (logs (pows @0 @1))\n    (mult @1 (logs @0)))))\n \n+/* Narrowing of arithmetic and logical operations. \n+\n+   These are conceptually similar to the transformations performed for\n+   the C/C++ front-ends by shorten_binary_op and shorten_compare.  Long\n+   term we want to move all that code out of the front-ends into here.  */\n+\n+/* If we have a narrowing conversion of an arithmetic operation where\n+   both operands are widening conversions from the same type as the outer\n+   narrowing conversion.  Then convert the innermost operands to a suitable\n+   unsigned type (to avoid introducing undefined behaviour), perform the\n+   operation and convert the result to the desired type.  */\n+(for op (plus minus)\n+  (simplify\n+    (convert (op (convert@2 @0) (convert@3 @1)))\n+    (if (INTEGRAL_TYPE_P (type)\n+\t /* We check for type compatibility between @0 and @1 below,\n+\t    so there's no need to check that @1/@3 are integral types.  */\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n+\t /* The precision of the type of each operand must match the\n+\t    precision of the mode of each operand, similarly for the\n+\t    result.  */\n+\t && (TYPE_PRECISION (TREE_TYPE (@0))\n+\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n+\t && (TYPE_PRECISION (TREE_TYPE (@1))\n+\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n+\t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n+\t /* The inner conversion must be a widening conversion.  */\n+\t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n+\t && ((GENERIC \n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n+\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (@1)))\n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (@0))\n+\t\t  == TYPE_MAIN_VARIANT (type)))\n+\t     || (GIMPLE\n+\t\t && types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1))\n+\t\t && types_compatible_p (TREE_TYPE (@0), type))))\n+      (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n+\t(convert (op @0 @1)))\n+      (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n+\t(convert (op (convert:utype @0) (convert:utype @1)))))))"}, {"sha": "2fe9698f34c51156a2c4021460ff476d30ab488e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be1448389ab3038cccba3ed99e157bd6842ef88f", "patch": "@@ -1,3 +1,8 @@\n+2015-02-13  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/47477\n+\t* gcc.dg/tree-ssa/pr47477.c: New test.\n+\n 2015-02-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/60211"}, {"sha": "104cb6f595cad1cc247f3da5aa0895fe66e64c1a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr47477.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47477.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1448389ab3038cccba3ed99e157bd6842ef88f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47477.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47477.c?ref=be1448389ab3038cccba3ed99e157bd6842ef88f", "patch": "@@ -0,0 +1,22 @@\n+/* PR tree-optimization/47477 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -w\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+typedef int int64_t __attribute__ ((__mode__ (__DI__)));\n+typedef int * intptr_t;\n+\n+typedef struct toto_s *toto_t;\n+toto_t add (toto_t a, toto_t b) {\n+  int64_t tmp = (int64_t)(intptr_t)a + ((int64_t)(intptr_t)b&~1L);\n+  return (toto_t)(intptr_t) tmp;\n+}\n+\n+/* For an ILP32 target there'll be 6 casts when we start, but just 4\n+   if the match.pd pattern is successfully matched.  */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(int\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(unsigned int\\\\)\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\(struct toto_s \\\\*\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+\n+"}]}