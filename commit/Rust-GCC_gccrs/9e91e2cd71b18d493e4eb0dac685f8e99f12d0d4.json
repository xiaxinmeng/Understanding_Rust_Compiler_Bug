{"sha": "9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5MWUyY2Q3MWIxOGQ0OTNlNGViMGRhYzY4NWY4ZTk5ZjEyZDBkNA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-03-31T17:06:37Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-03-31T17:06:37Z"}, "message": "re PR target/58945 (Improve atomic_compare_and_swap*_doubleword pattern)\n\n\tPR target/58945\n\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n\tDo not split operands 0 and operands 2 to halfmode.\n\t(atomic_compare_and_swap<mode>): Update for\n\tatomic_compare_and_swap<dwi>_doubleword changes.\n\nFrom-SVN: r221798", "tree": {"sha": "547fde4efa085d8d61632b6b1a155a479de573d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/547fde4efa085d8d61632b6b1a155a479de573d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4/comments", "author": null, "committer": null, "parents": [{"sha": "36ceb0e3ccbac8324601234546210239d334bb0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ceb0e3ccbac8324601234546210239d334bb0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ceb0e3ccbac8324601234546210239d334bb0a"}], "stats": {"total": 77, "additions": 35, "deletions": 42}, "files": [{"sha": "f70709675754a172fee101e6d5b8a9f92067b942", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "patch": "@@ -1,7 +1,14 @@\n-2015-03-27  Jan Hubicka  <hubicka@ucw.cz>\n+2015-03-31  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/58945\n+\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n+\tDo not split operands 0 and operands 2 to halfmode.\n+\t(atomic_compare_and_swap<mode>): Update for\n+\tatomic_compare_and_swap<dwi>_doubleword changes.\n+\n+2015-03-31  Jan Hubicka  <hubicka@ucw.cz>\n \n-\t* tree.c (need_assembler_name_p): Artificial types have no ODR\n-\tnames.\n+\t* tree.c (need_assembler_name_p): Artificial types have no ODR names.\n \t* ipa-devirt.c (warn_odr): Do not try to apply ODR cache when\n \tno caching is done.\n "}, {"sha": "28b8122e1efdfdb965503780be8244317641284a", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=9e91e2cd71b18d493e4eb0dac685f8e99f12d0d4", "patch": "@@ -351,28 +351,41 @@\n   else\n     {\n       machine_mode hmode = <CASHMODE>mode;\n-      rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n;\n-\n-      lo_o = operands[1];\n-      lo_e = operands[3];\n-      lo_n = operands[4];\n-      hi_o = gen_highpart (hmode, lo_o);\n-      hi_e = gen_highpart (hmode, lo_e);\n-      hi_n = gen_highpart (hmode, lo_n);\n-      lo_o = gen_lowpart (hmode, lo_o);\n-      lo_e = gen_lowpart (hmode, lo_e);\n-      lo_n = gen_lowpart (hmode, lo_n);\n \n       emit_insn\n        (gen_atomic_compare_and_swap<mode>_doubleword\n-        (lo_o, hi_o, operands[2], lo_e, hi_e, lo_n, hi_n, operands[6]));\n+        (operands[1], operands[2], operands[3],\n+\t gen_lowpart (hmode, operands[4]), gen_highpart (hmode, operands[4]),\n+\t operands[6]));\n     }\n \n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n \t\t     const0_rtx);\n   DONE;\n })\n \n+;; For double-word compare and swap, we are obliged to play tricks with\n+;; the input newval (op3:op4) because the Intel register numbering does\n+;; not match the gcc register numbering, so the pair must be CX:BX.\n+\n+(define_mode_attr doublemodesuffix [(SI \"8\") (DI \"16\")])\n+\n+(define_insn \"atomic_compare_and_swap<dwi>_doubleword\"\n+  [(set (match_operand:<DWI> 0 \"register_operand\" \"=A\")\n+\t(unspec_volatile:<DWI>\n+\t  [(match_operand:<DWI> 1 \"memory_operand\" \"+m\")\n+\t   (match_operand:<DWI> 2 \"register_operand\" \"0\")\n+\t   (match_operand:DWIH 3 \"register_operand\" \"b\")\n+\t   (match_operand:DWIH 4 \"register_operand\" \"c\")\n+\t   (match_operand:SI 5 \"const_int_operand\")]\n+\t  UNSPECV_CMPXCHG))\n+   (set (match_dup 1)\n+\t(unspec_volatile:<DWI> [(const_int 0)] UNSPECV_CMPXCHG))\n+   (set (reg:CCZ FLAGS_REG)\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))]\n+  \"TARGET_CMPXCHG<doublemodesuffix>B\"\n+  \"lock{%;} %K5cmpxchg<doublemodesuffix>b\\t%1\")\n+\n (define_insn \"atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:SWI 0 \"register_operand\" \"=a\")\n \t(unspec_volatile:SWI\n@@ -388,33 +401,6 @@\n   \"TARGET_CMPXCHG\"\n   \"lock{%;} %K4cmpxchg{<imodesuffix>}\\t{%3, %1|%1, %3}\")\n \n-;; For double-word compare and swap, we are obliged to play tricks with\n-;; the input newval (op5:op6) because the Intel register numbering does\n-;; not match the gcc register numbering, so the pair must be CX:BX.\n-;; That said, in order to take advantage of possible lower-subreg opts,\n-;; treat all of the integral operands in the same way.\n-\n-(define_mode_attr doublemodesuffix [(SI \"8\") (DI \"16\")])\n-\n-(define_insn \"atomic_compare_and_swap<dwi>_doubleword\"\n-  [(set (match_operand:DWIH 0 \"register_operand\" \"=a\")\n-\t(unspec_volatile:DWIH\n-\t  [(match_operand:<DWI> 2 \"memory_operand\" \"+m\")\n-\t   (match_operand:DWIH 3 \"register_operand\" \"0\")\n-\t   (match_operand:DWIH 4 \"register_operand\" \"1\")\n-\t   (match_operand:DWIH 5 \"register_operand\" \"b\")\n-\t   (match_operand:DWIH 6 \"register_operand\" \"c\")\n-\t   (match_operand:SI 7 \"const_int_operand\")]\n-\t  UNSPECV_CMPXCHG))\n-   (set (match_operand:DWIH 1 \"register_operand\" \"=d\")\n-\t(unspec_volatile:DWIH [(const_int 0)] UNSPECV_CMPXCHG))\n-   (set (match_dup 2)\n-\t(unspec_volatile:<DWI> [(const_int 0)] UNSPECV_CMPXCHG))\n-   (set (reg:CCZ FLAGS_REG)\n-        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))]\n-  \"TARGET_CMPXCHG<doublemodesuffix>B\"\n-  \"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\")\n-\n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic\n ;; additions of constants."}]}