{"sha": "358a95e46245bbdbaefe19369b8d95496cf3eb5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU4YTk1ZTQ2MjQ1YmJkYmFlZmUxOTM2OWI4ZDk1NDk2Y2YzZWI1YQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2016-11-20T18:34:06Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2016-11-20T18:34:06Z"}, "message": "re PR middle-end/61409 (-Wmaybe-uninitialized false-positive with -O2)\n\n\tPR middle-end/61409\n\t* tree-ssa-uninit.c: Define new global max_phi_args.\n\t(compute_uninit_opnds_pos): Use max_phi_args.\n\t(prune_uninit_phi_opnds): Same.\n\t(use_pred_not_overlap_with_undef_path_pred): Remove reference to\n\tmissing NUM_PREDS in function comment.\n\t(can_one_predicate_be_invalidated_p): New.\n\t(can_chain_union_be_invalidated_p): New.\n\t(flatten_out_predicate_chains): New.\n\t(uninit_ops_invalidate_phi_use): New.\n\t(is_use_properly_guarded): Call uninit_ops_invalidate_phi_use.\n\nFrom-SVN: r242639", "tree": {"sha": "81b063e9484a3b0f61f3ef95753338d2515ab4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b063e9484a3b0f61f3ef95753338d2515ab4d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/358a95e46245bbdbaefe19369b8d95496cf3eb5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358a95e46245bbdbaefe19369b8d95496cf3eb5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358a95e46245bbdbaefe19369b8d95496cf3eb5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358a95e46245bbdbaefe19369b8d95496cf3eb5a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40fd269ab128d1f5fa7688d7d5e7298744c08cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fd269ab128d1f5fa7688d7d5e7298744c08cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fd269ab128d1f5fa7688d7d5e7298744c08cdd"}], "stats": {"total": 214, "additions": 207, "deletions": 7}, "files": [{"sha": "0f3d3187ffd57b8ec36fc1700a5a1f8e558e3c9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=358a95e46245bbdbaefe19369b8d95496cf3eb5a", "patch": "@@ -1,3 +1,17 @@\n+2016-08-25  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR middle-end/61409\n+\t* tree-ssa-uninit.c: Define new global max_phi_args.\n+\t(compute_uninit_opnds_pos): Use max_phi_args.\n+\t(prune_uninit_phi_opnds): Same.\n+\t(use_pred_not_overlap_with_undef_path_pred): Remove reference to\n+\tmissing NUM_PREDS in function comment.\n+\t(can_one_predicate_be_invalidated_p): New.\n+\t(can_chain_union_be_invalidated_p): New.\n+\t(flatten_out_predicate_chains): New.\n+\t(uninit_ops_invalidate_phi_use): New.\n+\t(is_use_properly_guarded): Call uninit_ops_invalidate_phi_use.\n+\n 2016-11-20  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* fold-const.c (fold_comparison): Ignore EXACT_DIV_EXPR."}, {"sha": "c27a67bd07ff146d2369beedfde5e86ba8490d62", "filename": "gcc/testsuite/gcc.dg/uninit-pr61409.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr61409.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr61409.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr61409.c?ref=358a95e46245bbdbaefe19369b8d95496cf3eb5a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wuninitialized\" } */\n+\n+int *rw;\n+int line_height;\n+int pixel_width;\n+int text_cols;\n+int width1, width2, width3;\n+\n+void *pointer;\n+\n+void f (int i, int j)\n+{\n+  void *ptr;\n+  if (i)\n+    {\n+      if (j)\n+\treturn;\n+      ptr = pointer;\n+    }\n+  pixel_width = 1234 + width1 + 2 * width2 + 2 * width3;\n+  *rw = text_cols + line_height;\n+  if (i)\n+    rw=ptr; /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+}"}, {"sha": "68dcf156da2082446495743e7ef40996d8a9c4ee", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 168, "deletions": 7, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/358a95e46245bbdbaefe19369b8d95496cf3eb5a/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=358a95e46245bbdbaefe19369b8d95496cf3eb5a", "patch": "@@ -44,6 +44,9 @@ along with GCC; see the file COPYING3.  If not see\n    default definitions or by checking if the predicate set that guards the\n    defining paths is a superset of the use predicate.  */\n \n+/* Max PHI args we can handle in pass.  */\n+const unsigned max_phi_args = 32;\n+\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n@@ -314,7 +317,7 @@ compute_uninit_opnds_pos (gphi *phi)\n \n   n = gimple_phi_num_args (phi);\n   /* Bail out for phi with too many args.  */\n-  if (n > 32)\n+  if (n > max_phi_args)\n     return 0;\n \n   for (i = 0; i < n; ++i)\n@@ -1031,7 +1034,7 @@ prune_uninit_phi_opnds (gphi *phi, unsigned uninit_opnds, gphi *flag_def,\n {\n   unsigned i;\n \n-  for (i = 0; i < MIN (32, gimple_phi_num_args (flag_def)); i++)\n+  for (i = 0; i < MIN (max_phi_args, gimple_phi_num_args (flag_def)); i++)\n     {\n       tree flag_arg;\n \n@@ -1192,11 +1195,10 @@ prune_uninit_phi_opnds (gphi *phi, unsigned uninit_opnds, gphi *flag_def,\n      transformation which eliminates the merge point thus makes\n      path sensitive analysis unnecessary.)\n \n-     NUM_PREDS is the number is the number predicate chains, PREDS is\n-     the array of chains, PHI is the phi node whose incoming (undefined)\n-     paths need to be pruned, and UNINIT_OPNDS is the bitmap holding\n-     uninit operand positions.  VISITED_PHIS is the pointer set of phi\n-     stmts being checked.  */\n+     PHI is the phi node whose incoming (undefined) paths need to be\n+     pruned, and UNINIT_OPNDS is the bitmap holding uninit operand\n+     positions.  VISITED_PHIS is the pointer set of phi stmts being\n+     checked.  */\n \n static bool\n use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n@@ -2148,6 +2150,158 @@ normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n   return norm_preds;\n }\n \n+/* Return TRUE if PREDICATE can be invalidated by any individual\n+   predicate in WORKLIST.  */\n+\n+static bool\n+can_one_predicate_be_invalidated_p (pred_info predicate,\n+\t\t\t\t    vec<pred_info *> worklist)\n+{\n+  for (size_t i = 0; i < worklist.length (); ++i)\n+    {\n+      pred_info *p = worklist[i];\n+\n+      /* NOTE: This is a very simple check, and only understands an\n+\t exact opposite.  So, [i == 0] is currently only invalidated\n+\t by [.NOT. i == 0] or [i != 0].  Ideally we should also\n+\t invalidate with say [i > 5] or [i == 8].  There is certainly\n+\t room for improvement here.  */\n+      if (pred_neg_p (predicate, *p))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE if all USE_PREDS can be invalidated by some predicate\n+   in WORKLIST.  */\n+\n+static bool\n+can_chain_union_be_invalidated_p (pred_chain_union use_preds,\n+\t\t\t\t  vec<pred_info *> worklist)\n+{\n+  /* Remember:\n+       PRED_CHAIN_UNION = PRED_CHAIN1 || PRED_CHAIN2 || PRED_CHAIN3\n+       PRED_CHAIN = PRED_INFO1 && PRED_INFO2 && PRED_INFO3, etc.\n+\n+       We need to invalidate the entire PRED_CHAIN_UNION, which means,\n+       invalidating every PRED_CHAIN in this union.  But to invalidate\n+       an individual PRED_CHAIN, all we need to invalidate is _any_ one\n+       PRED_INFO, by boolean algebra !PRED_INFO1 || !PRED_INFO2...  */\n+  for (size_t i = 0; i < use_preds.length (); ++i)\n+    {\n+      pred_chain c = use_preds[i];\n+      bool entire_pred_chain_invalidated = false;\n+      for (size_t j = 0; j < c.length (); ++j)\n+\tif (can_one_predicate_be_invalidated_p (c[i], worklist))\n+\t  {\n+\t    entire_pred_chain_invalidated = true;\n+\t    break;\n+\t  }\n+      if (!entire_pred_chain_invalidated)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Flatten out all the factors in all the pred_chain_union's in PREDS\n+   into a WORKLIST of individual PRED_INFO's.\n+\n+   N is the number of pred_chain_union's in PREDS.\n+\n+   Since we are interested in the inverse of the PRED_CHAIN's, by\n+   boolean algebra, an inverse turns those PRED_CHAINS into unions,\n+   which means we can flatten all the factors out for easy access.  */\n+\n+static void\n+flatten_out_predicate_chains (pred_chain_union preds[], size_t n,\n+\t\t\t      vec<pred_info *> *worklist)\n+{\n+  for (size_t i = 0; i < n; ++i)\n+    {\n+      pred_chain_union u = preds[i];\n+      for (size_t j = 0; j < u.length (); ++j)\n+\t{\n+\t  pred_chain c = u[j];\n+\t  for (size_t k = 0; k < c.length (); ++k)\n+\t    worklist->safe_push (&c[k]);\n+\t}\n+    }\n+}\n+\n+/* Return TRUE if executing the path to some uninitialized operands in\n+   a PHI will invalidate the use of the PHI result later on.\n+\n+   UNINIT_OPNDS is a bit vector specifying which PHI arguments have\n+   arguments which are considered uninitialized.\n+\n+   USE_PREDS is the pred_chain_union specifying the guard conditions\n+   for the use of the PHI result.\n+\n+   What we want to do is disprove each of the guards in the factors of\n+   the USE_PREDS.  So if we have:\n+\n+   # USE_PREDS guards of:\n+   #\t1. i > 5 && i < 100\n+   #\t2. j > 10 && j < 88\n+\n+   Then proving that the control dependenies for the UNINIT_OPNDS are:\n+\n+   #      [i <= 5]\n+   # .OR. [i >= 100]\n+   #\n+\n+   ...we can prove that the 1st guard above in USE_PREDS is invalid.\n+   Similarly for the 2nd guard.  We return TRUE if we can disprove\n+   both of the guards in USE_PREDS above.  */\n+\n+static bool\n+uninit_ops_invalidate_phi_use (gphi *phi, unsigned uninit_opnds,\n+\t\t\t       pred_chain_union use_preds)\n+{\n+  /* Look for the control dependencies of all the uninitialized\n+     operands and build predicates describing them.  */\n+  unsigned i;\n+  pred_chain_union uninit_preds[max_phi_args];\n+  memset (uninit_preds, 0, sizeof (pred_chain_union) * max_phi_args);\n+  for (i = 0; i < MIN (max_phi_args, gimple_phi_num_args (phi)); i++)\n+    {\n+      if (!MASK_TEST_BIT (uninit_opnds, i))\n+\tcontinue;\n+\n+      edge e = gimple_phi_arg_edge (phi, i);\n+      vec<edge> dep_chains[MAX_NUM_CHAINS];\n+      auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+      size_t num_chains = 0;\n+      int num_calls = 0;\n+\n+      /* Build the control dependency chain for `i'...  */\n+      if (compute_control_dep_chain (find_dom (e->src),\n+\t\t\t\t     e->src,\n+\t\t\t\t     dep_chains,\n+\t\t\t\t     &num_chains,\n+\t\t\t\t     &cur_chain,\n+\t\t\t\t     &num_calls))\n+\t{\n+\t  /* ...and convert it into a set of predicates.  */\n+\t  convert_control_dep_chain_into_preds (dep_chains, num_chains,\n+\t\t\t\t\t\t&uninit_preds[i]);\n+\t  for (size_t j = 0; j < num_chains; ++j)\n+\t    dep_chains[j].release ();\n+\t  simplify_preds (&uninit_preds[i], NULL, false);\n+\t  uninit_preds[i]\n+\t    = normalize_preds (uninit_preds[i], NULL, false);\n+\t}\n+    }\n+\n+  /* Munge all the predicates into one worklist, and see if we can\n+     invalidate all the chains in USE_PREDs with the predicates in\n+     WORKLIST.  */\n+  auto_vec<pred_info *> worklist;\n+  flatten_out_predicate_chains (uninit_preds, i, &worklist);\n+  bool ret = can_chain_union_be_invalidated_p (use_preds, worklist);\n+  return ret;\n+}\n+\n /* Computes the predicates that guard the use and checks\n    if the incoming paths that have empty (or possibly\n    empty) definition can be pruned/filtered.  The function returns\n@@ -2203,6 +2357,13 @@ is_use_properly_guarded (gimple *use_stmt,\n     = use_pred_not_overlap_with_undef_path_pred (preds, phi, uninit_opnds,\n \t\t\t\t\t\t visited_phis);\n \n+  /* We might be able to prove that if the control dependencies\n+     for UNINIT_OPNDS are true, that the control dependencies for\n+     USE_STMT can never be true.  */\n+  if (!is_properly_guarded)\n+    is_properly_guarded |= uninit_ops_invalidate_phi_use (phi, uninit_opnds,\n+\t\t\t\t\t\t\t  preds);\n+\n   if (is_properly_guarded)\n     {\n       destroy_predicate_vecs (&preds);"}]}