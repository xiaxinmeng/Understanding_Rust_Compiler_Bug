{"sha": "082284da9d8069290a749218b6aebecab0da2868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyMjg0ZGE5ZDgwNjkyOTBhNzQ5MjE4YjZhZWJlY2FiMGRhMjg2OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-03-14T13:58:13Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-03-14T13:58:13Z"}, "message": "Fix ICE for missing header fix-it hints with overlarge #line directives (PR c/84852)\n\nPR c/84852 reports an ICE inside diagnostic_show_locus when printing\na diagnostic for a source file with a #line >= 2^31:\n\n  #line 7777777777\n  int foo (void) { return strlen(\"\"); }\n\nwhere we're attempting to print a fix-it hint at the top of the file\nand underline the \"strlen\" (two \"line spans\").\n\nThe\n  #line 7777777777\nwon't fix within the 32-bit linenum_type, and is truncated from\n  0x1cf977871\nto\n   0xcf977871\ni.e. 3482810481 in decimal.\n\nSuch a #line is reported by -pedantic and -pedantic-errors, but we\nshouldn't ICE.\n\nThe ICE is an assertion failure within layout::calculate_line_spans,\nwhere the line spans have not been properly sorted.\n\nThe layout_ranges are stored as int, rather than linenum_type,\ngiving line -812156815 for the error, and line 1 for the fix-it hint.\n\nHowever, line_span uses linenum_type rather than int.\n\nline_span::comparator compares these values as int, and hence\ndecides that (linenum_type)3482810481 aka (int)-812156815 is less\nthan line 1.\n\nThis leads to this assertion failing in layout::calculate_line_spans:\n\n1105\t      gcc_assert (next->m_first_line >= current->m_first_line);\n\nsince it isn't the case that 1 >= 3482810481.\n\nThe underlying problem is the mix of types for storing line numbers:\nin parts of libcpp and diagnostic-show-locus.c we use linenum_type;\nin other places (including libcpp's expanded_location) we use int.\n\nI looked at using linenum_type throughout, but doing so turned into\na large patch, so this patch fixes the ICE in a less invasive way\nby merely using linenum_type more consistently just within\ndiagnostic-show-locus.c, and fixing line_span::comparator to properly\nhandle line numbers (and line number differences) >= 2^31, by using\na new helper function for linenum_type differences, computing the\ndifference using long long, and using the sign of the difference\n(as the difference might not fit in the \"int\" return type imposed\nby qsort).\n\ngcc/ChangeLog:\n\tPR c/84852\n\t* diagnostic-show-locus.c (class layout_point): Convert m_line\n\tfrom int to linenum_type.\n\t(line_span::comparator): Use linenum \"compare\" function when\n\tcomparing line numbers.\n\t(test_line_span): New function.\n\t(layout_range::contains_point): Convert param \"row\" from int to\n\tlinenum_type.\n\t(layout_range::intersects_line_p): Likewise.\n\t(layout::will_show_line_p): Likewise.\n\t(layout::print_source_line): Likewise.\n\t(layout::should_print_annotation_line_p): Likewise.\n\t(layout::print_annotation_line): Likewise.\n\t(layout::print_leading_fixits): Likewise.\n\t(layout::annotation_line_showed_range_p): Likewise.\n\t(struct line_corrections): Likewise for field m_row.\n\t(line_corrections::line_corrections): Likewise for param \"row\".\n\t(layout::print_trailing_fixits): Likewise.\n\t(layout::get_state_at_point): Likewise.\n\t(layout::get_x_bound_for_row): Likewise.\n\t(layout::print_line): Likewise.\n\t(diagnostic_show_locus): Likewise for locals \"last_line\" and\n\t\"row\".\n\t(selftest::diagnostic_show_locus_c_tests): Call test_line_span.\n\t* input.c (selftest::test_linenum_comparisons): New function.\n\t(selftest::input_c_tests): Call it.\n\t* selftest.c (selftest::test_assertions): Test ASSERT_GT,\n\tASSERT_GT_AT, ASSERT_LT, and ASSERT_LT_AT.\n\t* selftest.h (ASSERT_GT): New macro.\n\t(ASSERT_GT_AT): New macro.\n\t(ASSERT_LT): New macro.\n\t(ASSERT_LT_AT): New macro.\n\ngcc/testsuite/ChangeLog:\n\tPR c/84852\n\t* gcc.dg/fixits-pr84852-1.c: New test.\n\t* gcc.dg/fixits-pr84852-2.c: New test.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (compare): New function on linenum_type.\n\nFrom-SVN: r258526", "tree": {"sha": "aba9b3b0569617b94157dbe4f5adea052917d7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba9b3b0569617b94157dbe4f5adea052917d7e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/082284da9d8069290a749218b6aebecab0da2868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082284da9d8069290a749218b6aebecab0da2868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/082284da9d8069290a749218b6aebecab0da2868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082284da9d8069290a749218b6aebecab0da2868/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1422855a403391ab2896f774871c5f3748f415dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1422855a403391ab2896f774871c5f3748f415dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1422855a403391ab2896f774871c5f3748f415dc"}], "stats": {"total": 270, "additions": 237, "deletions": 33}, "files": [{"sha": "8f81cc392aa101f824a69d9b8bc9a9bd4ce27df3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -1,3 +1,38 @@\n+2018-03-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/84852\n+\t* diagnostic-show-locus.c (class layout_point): Convert m_line\n+\tfrom int to linenum_type.\n+\t(line_span::comparator): Use linenum \"compare\" function when\n+\tcomparing line numbers.\n+\t(test_line_span): New function.\n+\t(layout_range::contains_point): Convert param \"row\" from int to\n+\tlinenum_type.\n+\t(layout_range::intersects_line_p): Likewise.\n+\t(layout::will_show_line_p): Likewise.\n+\t(layout::print_source_line): Likewise.\n+\t(layout::should_print_annotation_line_p): Likewise.\n+\t(layout::print_annotation_line): Likewise.\n+\t(layout::print_leading_fixits): Likewise.\n+\t(layout::annotation_line_showed_range_p): Likewise.\n+\t(struct line_corrections): Likewise for field m_row.\n+\t(line_corrections::line_corrections): Likewise for param \"row\".\n+\t(layout::print_trailing_fixits): Likewise.\n+\t(layout::get_state_at_point): Likewise.\n+\t(layout::get_x_bound_for_row): Likewise.\n+\t(layout::print_line): Likewise.\n+\t(diagnostic_show_locus): Likewise for locals \"last_line\" and\n+\t\"row\".\n+\t(selftest::diagnostic_show_locus_c_tests): Call test_line_span.\n+\t* input.c (selftest::test_linenum_comparisons): New function.\n+\t(selftest::input_c_tests): Call it.\n+\t* selftest.c (selftest::test_assertions): Test ASSERT_GT,\n+\tASSERT_GT_AT, ASSERT_LT, and ASSERT_LT_AT.\n+\t* selftest.h (ASSERT_GT): New macro.\n+\t(ASSERT_GT_AT): New macro.\n+\t(ASSERT_LT): New macro.\n+\t(ASSERT_LT_AT): New macro.\n+\n 2018-03-14  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/84780"}, {"sha": "bdf608a08bcad6e308549dea23dabdc46a467ef0", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 72, "deletions": 33, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -115,7 +115,7 @@ class layout_point\n   : m_line (exploc.line),\n     m_column (exploc.column) {}\n \n-  int m_line;\n+  linenum_type m_line;\n   int m_column;\n };\n \n@@ -129,8 +129,8 @@ class layout_range\n \t\tbool show_caret_p,\n \t\tconst expanded_location *caret_exploc);\n \n-  bool contains_point (int row, int column) const;\n-  bool intersects_line_p (int row) const;\n+  bool contains_point (linenum_type row, int column) const;\n+  bool intersects_line_p (linenum_type row) const;\n \n   layout_point m_start;\n   layout_point m_finish;\n@@ -172,16 +172,52 @@ struct line_span\n   {\n     const line_span *ls1 = (const line_span *)p1;\n     const line_span *ls2 = (const line_span *)p2;\n-    int first_line_diff = (int)ls1->m_first_line - (int)ls2->m_first_line;\n-    if (first_line_diff)\n-      return first_line_diff;\n-    return (int)ls1->m_last_line - (int)ls2->m_last_line;\n+    int first_line_cmp = compare (ls1->m_first_line, ls2->m_first_line);\n+    if (first_line_cmp)\n+      return first_line_cmp;\n+    return compare (ls1->m_last_line, ls2->m_last_line);\n   }\n \n   linenum_type m_first_line;\n   linenum_type m_last_line;\n };\n \n+#if CHECKING_P\n+\n+/* Selftests for line_span.  */\n+\n+static void\n+test_line_span ()\n+{\n+  line_span line_one (1, 1);\n+  ASSERT_EQ (1, line_one.get_first_line ());\n+  ASSERT_EQ (1, line_one.get_last_line ());\n+  ASSERT_FALSE (line_one.contains_line_p (0));\n+  ASSERT_TRUE (line_one.contains_line_p (1));\n+  ASSERT_FALSE (line_one.contains_line_p (2));\n+\n+  line_span lines_1_to_3 (1, 3);\n+  ASSERT_EQ (1, lines_1_to_3.get_first_line ());\n+  ASSERT_EQ (3, lines_1_to_3.get_last_line ());\n+  ASSERT_TRUE (lines_1_to_3.contains_line_p (1));\n+  ASSERT_TRUE (lines_1_to_3.contains_line_p (3));\n+\n+  ASSERT_EQ (0, line_span::comparator (&line_one, &line_one));\n+  ASSERT_GT (line_span::comparator (&lines_1_to_3, &line_one), 0);\n+  ASSERT_LT (line_span::comparator (&line_one, &lines_1_to_3), 0);\n+\n+  /* A linenum > 2^31.  */\n+  const linenum_type LARGEST_LINE = 0xffffffff;\n+  line_span largest_line (LARGEST_LINE, LARGEST_LINE);\n+  ASSERT_EQ (LARGEST_LINE, largest_line.get_first_line ());\n+  ASSERT_EQ (LARGEST_LINE, largest_line.get_last_line ());\n+\n+  ASSERT_GT (line_span::comparator (&largest_line, &line_one), 0);\n+  ASSERT_LT (line_span::comparator (&line_one, &largest_line), 0);\n+}\n+\n+#endif /* #if CHECKING_P */\n+\n /* A class to control the overall layout when printing a diagnostic.\n \n    The layout is determined within the constructor.\n@@ -207,18 +243,18 @@ class layout\n \n   expanded_location get_expanded_location (const line_span *) const;\n \n-  void print_line (int row);\n+  void print_line (linenum_type row);\n \n  private:\n-  bool will_show_line_p (int row) const;\n-  void print_leading_fixits (int row);\n-  void print_source_line (int row, const char *line, int line_width,\n+  bool will_show_line_p (linenum_type row) const;\n+  void print_leading_fixits (linenum_type row);\n+  void print_source_line (linenum_type row, const char *line, int line_width,\n \t\t\t  line_bounds *lbounds_out);\n-  bool should_print_annotation_line_p (int row) const;\n-  void print_annotation_line (int row, const line_bounds lbounds);\n-  void print_trailing_fixits (int row);\n+  bool should_print_annotation_line_p (linenum_type row) const;\n+  void print_annotation_line (linenum_type row, const line_bounds lbounds);\n+  void print_trailing_fixits (linenum_type row);\n \n-  bool annotation_line_showed_range_p (int line, int start_column,\n+  bool annotation_line_showed_range_p (linenum_type line, int start_column,\n \t\t\t\t       int finish_column) const;\n   void show_ruler (int max_column) const;\n \n@@ -230,13 +266,13 @@ class layout\n \n   bool\n   get_state_at_point (/* Inputs.  */\n-\t\t      int row, int column,\n+\t\t      linenum_type row, int column,\n \t\t      int first_non_ws, int last_non_ws,\n \t\t      /* Outputs.  */\n \t\t      point_state *out_state);\n \n   int\n-  get_x_bound_for_row (int row, int caret_column,\n+  get_x_bound_for_row (linenum_type row, int caret_column,\n \t\t       int last_non_ws);\n \n   void\n@@ -417,7 +453,7 @@ layout_range::layout_range (const expanded_location *start_exploc,\n    - 'a' indicates a subsequent point *after* the range.  */\n \n bool\n-layout_range::contains_point (int row, int column) const\n+layout_range::contains_point (linenum_type row, int column) const\n {\n   gcc_assert (m_start.m_line <= m_finish.m_line);\n   /* ...but the equivalent isn't true for the columns;\n@@ -478,7 +514,7 @@ layout_range::contains_point (int row, int column) const\n /* Does this layout_range contain any part of line ROW?  */\n \n bool\n-layout_range::intersects_line_p (int row) const\n+layout_range::intersects_line_p (linenum_type row) const\n {\n   gcc_assert (m_start.m_line <= m_finish.m_line);\n   if (row < m_start.m_line)\n@@ -940,7 +976,7 @@ layout::maybe_add_location_range (const location_range *loc_range,\n /* Return true iff ROW is within one of the line spans for this layout.  */\n \n bool\n-layout::will_show_line_p (int row) const\n+layout::will_show_line_p (linenum_type row) const\n {\n   for (int line_span_idx = 0; line_span_idx < get_num_line_spans ();\n        line_span_idx++)\n@@ -1138,7 +1174,7 @@ layout::calculate_line_spans ()\n    is its width.  */\n \n void\n-layout::print_source_line (int row, const char *line, int line_width,\n+layout::print_source_line (linenum_type row, const char *line, int line_width,\n \t\t\t   line_bounds *lbounds_out)\n {\n   m_colorizer.set_normal_text ();\n@@ -1201,7 +1237,7 @@ layout::print_source_line (int row, const char *line, int line_width,\n    i.e. if any of m_layout_ranges contains ROW.  */\n \n bool\n-layout::should_print_annotation_line_p (int row) const\n+layout::should_print_annotation_line_p (linenum_type row) const\n {\n   layout_range *range;\n   int i;\n@@ -1215,7 +1251,7 @@ layout::should_print_annotation_line_p (int row) const\n    source line.  */\n \n void\n-layout::print_annotation_line (int row, const line_bounds lbounds)\n+layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n {\n   int x_bound = get_x_bound_for_row (row, m_exploc.column,\n \t\t\t\t     lbounds.m_last_non_ws);\n@@ -1263,7 +1299,7 @@ layout::print_annotation_line (int row, const line_bounds lbounds)\n    itself, with a leading '+'.  */\n \n void\n-layout::print_leading_fixits (int row)\n+layout::print_leading_fixits (linenum_type row)\n {\n   for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n     {\n@@ -1301,7 +1337,7 @@ layout::print_leading_fixits (int row)\n    the exact range from START_COLUMN to FINISH_COLUMN.  */\n \n bool\n-layout::annotation_line_showed_range_p (int line, int start_column,\n+layout::annotation_line_showed_range_p (linenum_type line, int start_column,\n \t\t\t\t\tint finish_column) const\n {\n   layout_range *range;\n@@ -1552,15 +1588,15 @@ correction::ensure_terminated ()\n \n struct line_corrections\n {\n-  line_corrections (const char *filename, int row)\n+  line_corrections (const char *filename, linenum_type row)\n   : m_filename (filename), m_row (row)\n   {}\n   ~line_corrections ();\n \n   void add_hint (const fixit_hint *hint);\n \n   const char *m_filename;\n-  int m_row;\n+  linenum_type m_row;\n   auto_vec <correction *> m_corrections;\n };\n \n@@ -1674,7 +1710,7 @@ line_corrections::add_hint (const fixit_hint *hint)\n    in layout::print_leading_fixits.  */\n \n void\n-layout::print_trailing_fixits (int row)\n+layout::print_trailing_fixits (linenum_type row)\n {\n   /* Build a list of correction instances for the line,\n      potentially consolidating hints (for the sake of readability).  */\n@@ -1761,7 +1797,7 @@ layout::print_newline ()\n \n bool\n layout::get_state_at_point (/* Inputs.  */\n-\t\t\t    int row, int column,\n+\t\t\t    linenum_type row, int column,\n \t\t\t    int first_non_ws, int last_non_ws,\n \t\t\t    /* Outputs.  */\n \t\t\t    point_state *out_state)\n@@ -1806,7 +1842,7 @@ layout::get_state_at_point (/* Inputs.  */\n    character of source (as determined when printing the source line).  */\n \n int\n-layout::get_x_bound_for_row (int row, int caret_column,\n+layout::get_x_bound_for_row (linenum_type row, int caret_column,\n \t\t\t     int last_non_ws_column)\n {\n   int result = caret_column + 1;\n@@ -1897,7 +1933,7 @@ layout::show_ruler (int max_column) const\n    consisting of any caret/underlines, then any fixits.\n    If the source line can't be read, print nothing.  */\n void\n-layout::print_line (int row)\n+layout::print_line (linenum_type row)\n {\n   int line_width;\n   const char *line = location_get_source_line (m_exploc.file, row,\n@@ -1977,8 +2013,9 @@ diagnostic_show_locus (diagnostic_context * context,\n \t  expanded_location exploc = layout.get_expanded_location (line_span);\n \t  context->start_span (context, exploc);\n \t}\n-      int last_line = line_span->get_last_line ();\n-      for (int row = line_span->get_first_line (); row <= last_line; row++)\n+      linenum_type last_line = line_span->get_last_line ();\n+      for (linenum_type row = line_span->get_first_line ();\n+\t   row <= last_line; row++)\n \tlayout.print_line (row);\n     }\n \n@@ -3129,6 +3166,8 @@ test_fixit_deletion_affecting_newline (const line_table_case &case_)\n void\n diagnostic_show_locus_c_tests ()\n {\n+  test_line_span ();\n+\n   test_layout_range_for_single_point ();\n   test_layout_range_for_single_line ();\n   test_layout_range_for_multiple_lines ();"}, {"sha": "b6675768722f606320faffea3c5f3eed34bfaa2b", "filename": "gcc/input.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -1595,6 +1595,21 @@ get_num_source_ranges_for_substring (cpp_reader *pfile,\n \n /* Selftests of location handling.  */\n \n+/* Verify that compare() on linenum_type handles comparisons over the full\n+   range of the type.  */\n+\n+static void\n+test_linenum_comparisons ()\n+{\n+  linenum_type min_line (0);\n+  linenum_type max_line (0xffffffff);\n+  ASSERT_EQ (0, compare (min_line, min_line));\n+  ASSERT_EQ (0, compare (max_line, max_line));\n+\n+  ASSERT_GT (compare (max_line, min_line), 0);\n+  ASSERT_LT (compare (min_line, max_line), 0);\n+}\n+\n /* Helper function for verifying location data: when location_t\n    values are > LINE_MAP_MAX_LOCATION_WITH_COLS, they are treated\n    as having column 0.  */\n@@ -3528,6 +3543,7 @@ for_each_line_table_case (void (*testcase) (const line_table_case &))\n void\n input_c_tests ()\n {\n+  test_linenum_comparisons ();\n   test_should_have_column_data_p ();\n   test_unknown_location ();\n   test_builtins ();"}, {"sha": "5709110c291d04e618f74fa18015cddbdf7729e4", "filename": "gcc/selftest.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -288,6 +288,10 @@ test_assertions ()\n   ASSERT_EQ (1, 1);\n   ASSERT_EQ_AT (SELFTEST_LOCATION, 1, 1);\n   ASSERT_NE (1, 2);\n+  ASSERT_GT (2, 1);\n+  ASSERT_GT_AT (SELFTEST_LOCATION, 2, 1);\n+  ASSERT_LT (1, 2);\n+  ASSERT_LT_AT (SELFTEST_LOCATION, 1, 2);\n   ASSERT_STREQ (\"test\", \"test\");\n   ASSERT_STREQ_AT (SELFTEST_LOCATION, \"test\", \"test\");\n   ASSERT_STR_CONTAINS (\"foo bar baz\", \"bar\");"}, {"sha": "e3117c6bfc425c124b26bdd9f2b92b7db246952b", "filename": "gcc/selftest.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -333,6 +333,44 @@ extern int num_passes;\n     ::selftest::fail ((LOC), desc);\t\t\t\t\t\\\n   SELFTEST_END_STMT\n \n+/* Evaluate LHS and RHS and compare them with >, calling\n+   ::selftest::pass if LHS > RHS,\n+   ::selftest::fail otherwise.  */\n+\n+#define ASSERT_GT(LHS, RHS)\t\t\t\t\\\n+  ASSERT_GT_AT ((SELFTEST_LOCATION), (LHS), (RHS))\n+\n+/* Like ASSERT_GT, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_GT_AT(LOC, LHS, RHS)\t\t       \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n+  const char *desc_ = \"ASSERT_GT (\" #LHS \", \" #RHS \")\";\t       \\\n+  if ((LHS) > (RHS))\t\t\t\t\t       \\\n+    ::selftest::pass ((LOC), desc_);\t\t\t       \\\n+  else\t\t\t\t\t\t\t       \\\n+    ::selftest::fail ((LOC), desc_);\t\t\t       \\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate LHS and RHS and compare them with <, calling\n+   ::selftest::pass if LHS < RHS,\n+   ::selftest::fail otherwise.  */\n+\n+#define ASSERT_LT(LHS, RHS)\t\t\t\t\\\n+  ASSERT_LT_AT ((SELFTEST_LOCATION), (LHS), (RHS))\n+\n+/* Like ASSERT_LT, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_LT_AT(LOC, LHS, RHS)\t\t       \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n+  const char *desc_ = \"ASSERT_LT (\" #LHS \", \" #RHS \")\";\t       \\\n+  if ((LHS) < (RHS))\t\t\t\t\t       \\\n+    ::selftest::pass ((LOC), desc_);\t\t\t       \\\n+  else\t\t\t\t\t\t\t       \\\n+    ::selftest::fail ((LOC), desc_);\t\t\t       \\\n+  SELFTEST_END_STMT\n+\n /* Evaluate EXPECTED and ACTUAL and compare them with strcmp, calling\n    ::selftest::pass if they are equal,\n    ::selftest::fail if they are non-equal.  */"}, {"sha": "14b8e99a04f5cfaaf897a247a3ee3a6639d02637", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -1,3 +1,9 @@\n+2018-03-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/84852\n+\t* gcc.dg/fixits-pr84852-1.c: New test.\n+\t* gcc.dg/fixits-pr84852-2.c: New test.\n+\n 2018-03-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* lib/scanasm.exp (scan-assembler-times): Move FAIL debug info into a"}, {"sha": "ed88434f67243841e52589e1f7f154d04cfbceca", "filename": "gcc/testsuite/gcc.dg/fixits-pr84852-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-1.c?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -0,0 +1,25 @@\n+/* This is padding (to avoid the output containing DejaGnu directives).  */\n+\n+/* We need -fdiagnostics-show-caret to trigger the ICE.  */\n+\n+/* { dg-options \"-fdiagnostics-show-caret -pedantic-errors -Wno-implicit-function-declaration\" } */\n+\n+#line 3482810481 /* { dg-error \"line number out of range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ #line 3482810481\n+       ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+int foo (void) { return strlen(\"\"); }\n+\n+/* { dg-warning \"incompatible implicit declaration of built-in function 'strlen'\" \"\" { target *-*-* } -812156810 } */\n+/* { dg-message \"include '<string.h>' or provide a declaration of 'strlen'\" \"\" { target *-*-* } -812156810 } */\n+#if 0\n+{ dg-begin-multiline-output \"\" }\n++#include <string.h>\n+ /* This is padding (to avoid the output containing DejaGnu directives).  */\n+{ dg-end-multiline-output \"\" }\n+#endif\n+\n+/* We need this, to consume a stray line marker for the bogus line.  */\n+/* { dg-regexp \".*fixits-pr84852.c:-812156810:25:\" } */"}, {"sha": "0674ef546891f2f02f66c239fedd9abb49c3554e", "filename": "gcc/testsuite/gcc.dg/fixits-pr84852-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffixits-pr84852-2.c?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -0,0 +1,25 @@\n+/* This is padding (to avoid the output containing DejaGnu directives).  */\n+\n+/* We need -fdiagnostics-show-caret to trigger the ICE.  */\n+\n+/* { dg-options \"-fdiagnostics-show-caret -pedantic-errors -Wno-implicit-function-declaration\" } */\n+\n+#line 7777777777 /* { dg-error \"line number out of range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ #line 7777777777\n+       ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+int foo (void) { return strlen(\"\"); }\n+\n+/* { dg-warning \"incompatible implicit declaration of built-in function 'strlen'\" \"\" { target *-*-* } -812156810 } */\n+/* { dg-message \"include '<string.h>' or provide a declaration of 'strlen'\" \"\" { target *-*-* } -812156810 } */\n+#if 0\n+{ dg-begin-multiline-output \"\" }\n++#include <string.h>\n+ /* This is padding (to avoid the output containing DejaGnu directives).  */\n+{ dg-end-multiline-output \"\" }\n+#endif\n+\n+/* We need this, to consume a stray line marker for the bogus line.  */\n+/* { dg-regexp \".*fixits-pr84852-2.c:-812156810:25:\" } */"}, {"sha": "a66948ff1ace0388f8c0afb018446301a792c5ce", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -1,3 +1,7 @@\n+2018-03-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (compare): New function on linenum_type.\n+\n 2018-02-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR preprocessor/84517"}, {"sha": "d6cf81627cc21cbcbd4f1105a4398cd3847a0ae0", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082284da9d8069290a749218b6aebecab0da2868/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082284da9d8069290a749218b6aebecab0da2868/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=082284da9d8069290a749218b6aebecab0da2868", "patch": "@@ -49,6 +49,18 @@ along with this program; see the file COPYING3.  If not see\n /* The type of line numbers.  */\n typedef unsigned int linenum_type;\n \n+/* A function for for use by qsort for comparing line numbers.  */\n+\n+inline int compare (linenum_type lhs, linenum_type rhs)\n+{\n+  /* Avoid truncation issues by using long long for the comparison,\n+     and only consider the sign of the result.  */\n+  long long diff = (long long)lhs - (long long)rhs;\n+  if (diff)\n+    return diff > 0 ? 1 : -1;\n+  return 0;\n+}\n+\n /* Reason for creating a new line map with linemap_add.  LC_ENTER is\n    when including a new file, e.g. a #include directive in C.\n    LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file"}]}