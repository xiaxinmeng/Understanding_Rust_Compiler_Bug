{"sha": "5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkNjM0NWU5MmUyZTZmMTkxYjk0M2NmN2NiYTQ5YmI1ZDkwZWMyNw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2008-01-13T21:35:33Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-01-13T21:35:33Z"}, "message": "re PR fortran/34665 (Cannot pass scalar to array argument 'a')\n\n2008-01-13  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34665\n        * resolve.c (resolve_actual_arglist): For expressions,\n        also check for assume-sized arrays.\n        * interface.c (compare_parameter): Move F2003 character checks\n        here, print error messages here, reject elements of\n        assumed-shape array as argument to dummy arrays.\n        (compare_actual_formal): Update for the changes above.\n\n2008-01-13  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34665\n        * gfortran.dg/argument_checking_11.f90: New.\n        * gfortran.dg/argument_checking_12.f90: New.\n        * gfortran.dg/used_dummy_types_4.f90: Update dg-error.\n        * gfortran.dg/c_assoc_2.f03: Update dg-error.\n        * gfortran.dg/argument_checking_3.f90: Ditto.\n        * gfortran.dg/pointer_intent_2.f90: Ditto.\n        * gfortran.dg/import2.f90: Ditto.\n        * gfortran.dg/assumed_shape_ranks_1.f90: Ditto.\n        * gfortran.dg/implicit_actual.f90: Ditto.\n        * gfortran.dg/used_dummy_types_3.f90: Ditto.\n        * gfortran.dg/derived_comp_array_ref_6.f90: Ditto.\n\nFrom-SVN: r131513", "tree": {"sha": "99e3aac4649951ef115b9fe3fb115ab5d90a0f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99e3aac4649951ef115b9fe3fb115ab5d90a0f83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "083de129c8dd26ae3dcd5f24c77a3f424763e69f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083de129c8dd26ae3dcd5f24c77a3f424763e69f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083de129c8dd26ae3dcd5f24c77a3f424763e69f"}], "stats": {"total": 550, "additions": 486, "deletions": 64}, "files": [{"sha": "9c2cc465e7fd78143fc09d2777d777dda685280c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -1,3 +1,13 @@\n+2008-01-13  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34665\n+\t* resolve.c (resolve_actual_arglist): For expressions,\n+\talso check for assume-sized arrays.\n+\t* interface.c (compare_parameter): Move F2003 character checks\n+\there, print error messages here, reject elements of\n+\tassumed-shape array as argument to dummy arrays.\n+\t(compare_actual_formal): Update for the changes above.\n+\n 2008-01-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34763"}, {"sha": "9057ef932855b828d1d86ef4539d045a0bca4fdf", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 95, "deletions": 51, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -1420,9 +1420,10 @@ compare_pointer (gfc_symbol *formal, gfc_expr *actual)\n \n static int\n compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n-\t\t   int ranks_must_agree, int is_elemental)\n+\t\t   int ranks_must_agree, int is_elemental, locus *where)\n {\n   gfc_ref *ref;\n+  bool rank_check;\n \n   /* If the formal arg has type BT_VOID, it's to one of the iso_c_binding\n      procs c_f_pointer or c_f_procpointer, and we need to accept most\n@@ -1439,51 +1440,119 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (actual->ts.type == BT_PROCEDURE)\n     {\n       if (formal->attr.flavor != FL_PROCEDURE)\n-\treturn 0;\n+\tgoto proc_fail;\n \n       if (formal->attr.function\n \t  && !compare_type_rank (formal, actual->symtree->n.sym))\n-\treturn 0;\n+\tgoto proc_fail;\n \n       if (formal->attr.if_source == IFSRC_UNKNOWN\n \t  || actual->symtree->n.sym->attr.external)\n \treturn 1;\t\t/* Assume match.  */\n \n       if (actual->symtree->n.sym->attr.intrinsic)\n-\treturn compare_intr_interfaces (formal, actual->symtree->n.sym);\n-      else\n-\treturn compare_interfaces (formal, actual->symtree->n.sym, 0);\n+\t{\n+\t if (!compare_intr_interfaces (formal, actual->symtree->n.sym))\n+\t   goto proc_fail;\n+\t}\n+      else if (!compare_interfaces (formal, actual->symtree->n.sym, 0))\n+\tgoto proc_fail;\n+\n+      return 1;\n+\n+      proc_fail:\n+\tif (where)\n+\t  gfc_error (\"Type/rank mismatch in argument '%s' at %L\",\n+\t\t     formal->name, &actual->where);\n+      return 0;\n     }\n \n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && !gfc_compare_types (&formal->ts, &actual->ts))\n-    return 0;\n+    {\n+      if (where && actual->ts.type == BT_DERIVED\n+\t  && formal->ts.type == BT_DERIVED)\n+\tgfc_error (\"Type mismatch in argument '%s' at %L; passed type(%s) to \"\n+\t\t   \"type(%s)\", formal->name, &actual->where,\n+\t\t   actual->ts.derived->name, formal->ts.derived->name);\n+      else if (where)\n+\tgfc_error (\"Type mismatch in argument '%s' at %L; passed %s to %s\",\n+\t\t   formal->name, &actual->where,\n+\t\t   actual->ts.type == BT_DERIVED ? \"derived type\"\n+\t\t\t\t     : gfc_basic_typename (actual->ts.type),\n+\t\t   formal->ts.type == BT_DERIVED ? \"derived type\"\n+\t\t\t\t     : gfc_basic_typename (formal->ts.type));\n+      return 0;\n+    }\n \n   if (symbol_rank (formal) == actual->rank)\n     return 1;\n \n-  /* At this point the ranks didn't agree.  */\n-  if (ranks_must_agree || formal->attr.pointer)\n-    return 0;\n-\n-  if (actual->rank != 0)\n-    return is_elemental || formal->attr.dimension;\n-\n-  /* At this point, we are considering a scalar passed to an array.\n-     This is legal if the scalar is an array element of the right sort.  */\n-  if (formal->as->type == AS_ASSUMED_SHAPE)\n-    return 0;\n+  rank_check = where != NULL && !is_elemental && formal->as\n+\t       && (formal->as->type == AS_ASSUMED_SHAPE\n+\t\t   || formal->as->type == AS_DEFERRED);\n \n-  for (ref = actual->ref; ref; ref = ref->next)\n-    if (ref->type == REF_SUBSTRING)\n+  if (rank_check || ranks_must_agree || formal->attr.pointer\n+      || (actual->rank != 0 && !(is_elemental || formal->attr.dimension))\n+      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE))\n+    {\n+      if (where)\n+\tgfc_error (\"Rank mismatch in argument '%s' at %L (%d and %d)\",\n+\t\t   formal->name, &actual->where, symbol_rank (formal),\n+\t\t   actual->rank);\n       return 0;\n+    }\n+  else if (actual->rank != 0 && (is_elemental || formal->attr.dimension))\n+    return 1;\n+\n+  /* At this point, we are considering a scalar passed to an array.   This\n+     is valid (cf. F95 12.4.1.1; F2003 12.4.1.2),\n+     - if the actual argument is (a substring of) an element of a\n+       non-assumed-shape/non-pointer array;\n+     - (F2003) if the actual argument is of type character.  */\n \n   for (ref = actual->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)\n       break;\n \n-  if (ref == NULL)\n-    return 0;\t\t\t/* Not an array element.  */\n+  /* Not an array element.  */\n+  if (formal->ts.type == BT_CHARACTER\n+      && (ref == NULL\n+          || (actual->expr_type == EXPR_VARIABLE\n+\t      && (actual->symtree->n.sym->as->type == AS_ASSUMED_SHAPE\n+\t\t  || actual->symtree->n.sym->as->type == AS_DEFERRED))))\n+    {\n+      if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)\n+\t{\n+\t  gfc_error (\"Fortran 2003: Scalar CHARACTER actual argument with \"\n+\t\t     \"array dummy argument '%s' at %L\",\n+\t\t     formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+      else if ((gfc_option.allow_std & GFC_STD_F2003) == 0)\n+\treturn 0;\n+      else\n+\treturn 1;\n+    }\n+  else if (ref == NULL)\n+    {\n+      if (where)\n+\tgfc_error (\"Rank mismatch in argument '%s' at %L (%d and %d)\",\n+\t\t   formal->name, &actual->where, symbol_rank (formal),\n+\t\t   actual->rank);\n+      return 0;\n+    }\n+\n+  if (actual->expr_type == EXPR_VARIABLE\n+      && actual->symtree->n.sym->as\n+      && (actual->symtree->n.sym->as->type == AS_ASSUMED_SHAPE\n+\t  || actual->symtree->n.sym->as->type == AS_DEFERRED))\n+    {\n+      if (where)\n+\tgfc_error (\"Element of assumed-shaped array passed to dummy \"\n+\t\t   \"argument '%s' at %L\", formal->name, &actual->where);\n+      return 0;\n+    }\n \n   return 1;\n }\n@@ -1708,7 +1777,6 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n   gfc_actual_arglist **new, *a, *actual, temp;\n   gfc_formal_arglist *f;\n   int i, n, na;\n-  bool rank_check;\n   unsigned long actual_size, formal_size;\n \n   actual = *ap;\n@@ -1788,34 +1856,10 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"call at %L\", where);\n \t  return 0;\n \t}\n-\n-      rank_check = where != NULL && !is_elemental && f->sym->as\n-\t\t   && (f->sym->as->type == AS_ASSUMED_SHAPE\n-\t\t       || f->sym->as->type == AS_DEFERRED);\n-\n-      if (f->sym->ts.type == BT_CHARACTER && a->expr->ts.type == BT_CHARACTER\n-\t  && a->expr->rank == 0 && !ranks_must_agree\n-\t  && f->sym->as && f->sym->as->type != AS_ASSUMED_SHAPE)\n-\t{\n-\t  if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)\n-\t    {\n-\t      gfc_error (\"Fortran 2003: Scalar CHARACTER actual argument \"\n-\t\t\t \"with array dummy argument '%s' at %L\",\n-\t\t\t f->sym->name, &a->expr->where);\n-\t      return 0;\n-\t    }\n-\t  else if ((gfc_option.allow_std & GFC_STD_F2003) == 0)\n-\t    return 0;\n-\n-\t}\n-      else if (!compare_parameter (f->sym, a->expr,\n-\t\t\t\t   ranks_must_agree || rank_check, is_elemental))\n-\t{\n-\t  if (where)\n-\t    gfc_error (\"Type/rank mismatch in argument '%s' at %L\",\n-\t\t       f->sym->name, &a->expr->where);\n-\t  return 0;\n-\t}\n+      \n+      if (!compare_parameter (f->sym, a->expr, ranks_must_agree,\n+\t\t\t      is_elemental, where))\n+\treturn 0;\n \n       if (a->expr->ts.type == BT_CHARACTER\n \t   && a->expr->ts.cl && a->expr->ts.cl->length"}, {"sha": "0c4946e67bd5bbf470ec65cb4b9ed71f4a6acb43", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -1013,6 +1013,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n   gfc_symbol *sym;\n   gfc_symtree *parent_st;\n   gfc_expr *e;\n+  int save_need_full_assumed_size;\n \n   for (; arg; arg = arg->next)\n     {\n@@ -1041,8 +1042,12 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \n       if (e->ts.type != BT_PROCEDURE)\n \t{\n+\t  save_need_full_assumed_size = need_full_assumed_size;\n+\t  if (e->expr_type != FL_VARIABLE)\n+\t    need_full_assumed_size = 0;\n \t  if (gfc_resolve_expr (e) != SUCCESS)\n \t    return FAILURE;\n+\t  need_full_assumed_size = save_need_full_assumed_size;\n \t  goto argument_list;\n \t}\n \n@@ -1181,8 +1186,12 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t primary.c (match_actual_arg). If above code determines that it\n \t is a  variable instead, it needs to be resolved as it was not\n \t done at the beginning of this function.  */\n+      save_need_full_assumed_size = need_full_assumed_size;\n+      if (e->expr_type != FL_VARIABLE)\n+\tneed_full_assumed_size = 0;\n       if (gfc_resolve_expr (e) != SUCCESS)\n \treturn FAILURE;\n+      need_full_assumed_size = save_need_full_assumed_size;\n \n     argument_list:\n       /* Check argument list functions %VAL, %LOC and %REF.  There is"}, {"sha": "180d9559063c3046132aa67fd815d0b230ee91e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -1,3 +1,18 @@\n+2008-01-13  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34665\n+\t* gfortran.dg/argument_checking_11.f90: New.\n+\t* gfortran.dg/argument_checking_12.f90: New.\n+\t* gfortran.dg/used_dummy_types_4.f90: Update dg-error.\n+\t* gfortran.dg/c_assoc_2.f03: Update dg-error.\n+\t* gfortran.dg/argument_checking_3.f90: Ditto.\n+\t* gfortran.dg/pointer_intent_2.f90: Ditto.\n+\t* gfortran.dg/import2.f90: Ditto.\n+\t* gfortran.dg/assumed_shape_ranks_1.f90: Ditto.\n+\t* gfortran.dg/implicit_actual.f90: Ditto.\n+\t* gfortran.dg/used_dummy_types_3.f90: Ditto.\n+\t* gfortran.dg/derived_comp_array_ref_6.f90: Ditto.\n+\n 2008-01-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34763"}, {"sha": "7c70c37ee47b0de1de2205ee8c51c8664f155cb7", "filename": "gcc/testsuite/gfortran.dg/argument_checking_11.f90", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_11.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -0,0 +1,285 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95 -fmax-errors=100\" }\n+!\n+! PR fortran/34665\n+!\n+! Test argument checking\n+!\n+! TODO: Check also expressions, e.g. \"(a(1))\" instead of \"a(1)\n+! for strings; check also \"string\" and [ \"string\" ]\n+!\n+implicit none\n+CONTAINS\n+SUBROUTINE test1(a,b,c,d,e)\n+ integer, dimension(:) :: a\n+ integer, pointer, dimension(:) :: b\n+ integer, dimension(*) :: c\n+ integer, dimension(5) :: d\n+ integer               :: e\n+\n+ call as_size(a)\n+ call as_size(b)\n+ call as_size(c)\n+ call as_size(d)\n+ call as_size(e) ! { dg-error \"Rank mismatch\" }\n+ call as_size(1) ! { dg-error \"Rank mismatch\" }\n+ call as_size( (/ 1 /) )\n+ call as_size( (a) )\n+ call as_size( (b) )\n+ call as_size( (c) ) ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call as_size( (d) )\n+ call as_size( (e) ) ! { dg-error \"Rank mismatch\" }\n+ call as_size(a(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_size(b(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_size(c(1))\n+ call as_size(d(1))\n+ call as_size( (a(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_size( (b(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_size( (c(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_size( (d(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_size(a(1:2))\n+ call as_size(b(1:2))\n+ call as_size(c(1:2))\n+ call as_size(d(1:2))\n+ call as_size( (a(1:2)) )\n+ call as_size( (b(1:2)) )\n+ call as_size( (c(1:2)) )\n+ call as_size( (d(1:2)) )\n+\n+ call as_shape(a)\n+ call as_shape(b)\n+ call as_shape(c) ! { dg-error \"cannot be an assumed-size array\" }\n+ call as_shape(d)\n+ call as_shape(e) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( 1 ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (/ 1 /) )\n+ call as_shape( (a) )\n+ call as_shape( (b) )\n+ call as_shape( (c) ) ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call as_shape( (d) )\n+ call as_shape( (e) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (1) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( ((/ 1 /)) )\n+ call as_shape(a(1)) ! { dg-error \"Rank mismatch\" }\n+ call as_shape(b(1)) ! { dg-error \"Rank mismatch\" }\n+ call as_shape(c(1)) ! { dg-error \"Rank mismatch\" }\n+ call as_shape(d(1)) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (a(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (b(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (c(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape( (d(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_shape(a(1:2))\n+ call as_shape(b(1:2))\n+ call as_shape(c(1:2))\n+ call as_shape(d(1:2))\n+ call as_shape( (a(1:2)) )\n+ call as_shape( (b(1:2)) )\n+ call as_shape( (c(1:2)) )\n+ call as_shape( (d(1:2)) )\n+\n+ call as_expl(a)\n+ call as_expl(b)\n+ call as_expl(c)\n+ call as_expl(d)\n+ call as_expl(e) ! { dg-error \"Rank mismatch\" }\n+ call as_expl( 1 ) ! { dg-error \"Rank mismatch\" }\n+ call as_expl( (/ 1, 2, 3 /) )\n+ call as_expl( (a) )\n+ call as_expl( (b) )\n+ call as_expl( (c) ) ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call as_expl( (d) )\n+ call as_expl( (e) ) ! { dg-error \"Rank mismatch\" }\n+ call as_expl(a(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_expl(b(1)) ! { dg-error \"Element of assumed-shaped\" }\n+ call as_expl(c(1))\n+ call as_expl(d(1))\n+ call as_expl( (a(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_expl( (b(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_expl( (c(1)) ) ! { dg-error \"Rank mismatch\" }\n+ call as_expl( (d(1)) )  ! { dg-error \"Rank mismatch\" }\n+ call as_expl(a(1:3))\n+ call as_expl(b(1:3))\n+ call as_expl(c(1:3))\n+ call as_expl(d(1:3))\n+ call as_expl( (a(1:3)) )\n+ call as_expl( (b(1:3)) )\n+ call as_expl( (c(1:3)) )\n+ call as_expl( (d(1:3)) )\n+END SUBROUTINE test1\n+\n+SUBROUTINE as_size(a)\n+ integer, dimension(*) :: a\n+END SUBROUTINE as_size\n+\n+SUBROUTINE as_shape(a)\n+ integer, dimension(:) :: a\n+END SUBROUTINE as_shape\n+\n+SUBROUTINE as_expl(a)\n+ integer, dimension(3) :: a\n+END SUBROUTINE as_expl\n+\n+\n+SUBROUTINE test2(a,b,c,d,e)\n+ character(len=*), dimension(:) :: a\n+ character(len=*), pointer, dimension(:) :: b\n+ character(len=*), dimension(*) :: c\n+ character(len=*), dimension(5) :: d\n+ character(len=*)               :: e\n+\n+ call cas_size(a)\n+ call cas_size(b)\n+ call cas_size(c)\n+ call cas_size(d)\n+ call cas_size(e) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size(\"abc\") ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size( (/\"abc\"/) )\n+ call cas_size(a//\"a\")\n+ call cas_size(b//\"a\")\n+ call cas_size(c//\"a\")  ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call cas_size(d//\"a\")\n+ call cas_size(e//\"a\") ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size((\"abc\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size( ((/\"abc\"/)) )\n+ call cas_size(a(1)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size(b(1)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size(c(1)) ! OK in F95\n+ call cas_size(d(1)) ! OK in F95\n+ call cas_size((a(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+ call cas_size((b(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size((c(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+ call cas_size((d(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size(a(1:2))\n+ call cas_size(b(1:2))\n+ call cas_size(c(1:2))\n+ call cas_size(d(1:2))\n+ call cas_size((a(1:2)//\"a\"))\n+ call cas_size((b(1:2)//\"a\"))\n+ call cas_size((c(1:2)//\"a\"))\n+ call cas_size((d(1:2)//\"a\"))\n+ call cas_size(a(:)(1:3))\n+ call cas_size(b(:)(1:3))\n+ call cas_size(d(:)(1:3))\n+ call cas_size((a(:)(1:3)//\"a\"))\n+ call cas_size((b(:)(1:3)//\"a\"))\n+ call cas_size((d(:)(1:3)//\"a\"))\n+ call cas_size(a(1:2)(1:3))\n+ call cas_size(b(1:2)(1:3))\n+ call cas_size(c(1:2)(1:3))\n+ call cas_size(d(1:2)(1:3))\n+ call cas_size((a(1:2)(1:3)//\"a\"))\n+ call cas_size((b(1:2)(1:3)//\"a\"))\n+ call cas_size((c(1:2)(1:3)//\"a\"))\n+ call cas_size((d(1:2)(1:3)//\"a\"))\n+ call cas_size(e(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+ call cas_size(\"abcd\"(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+ call cas_size((e(1:3))) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+ call cas_size((\"abcd\"(1:3)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" } \n+\n+ call cas_shape(a)\n+ call cas_shape(b)\n+ call cas_shape(c) ! { dg-error \"cannot be an assumed-size array\" }\n+ call cas_shape(d)\n+ call cas_shape(e) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape(\"abc\") ! { dg-error \"Rank mismatch\" }\n+ call cas_shape( (/\"abc\"/) )\n+ call cas_shape(a//\"c\")\n+ call cas_shape(b//\"c\")\n+ call cas_shape(c//\"c\") ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call cas_shape(d//\"c\")\n+ call cas_shape(e//\"c\") ! { dg-error \"Rank mismatch\" }\n+ call cas_shape((\"abc\")) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape( ((/\"abc\"/)) )\n+ call cas_shape(a(1)) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape(b(1)) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape(c(1)) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape(d(1)) ! { dg-error \"Rank mismatch\" }\n+ call cas_shape(a(1:2))\n+ call cas_shape(b(1:2))\n+ call cas_shape(c(1:2))\n+ call cas_shape(d(1:2))\n+ call cas_shape((a(1:2)//\"a\"))\n+ call cas_shape((b(1:2)//\"a\"))\n+ call cas_shape((c(1:2)//\"a\"))\n+ call cas_shape((d(1:2)//\"a\"))\n+ call cas_shape(a(:)(1:3))\n+ call cas_shape(b(:)(1:3))\n+ call cas_shape(d(:)(1:3))\n+ call cas_shape((a(:)(1:3)//\"a\"))\n+ call cas_shape((b(:)(1:3)//\"a\"))\n+ call cas_shape((d(:)(1:3)//\"a\"))\n+ call cas_shape(a(1:2)(1:3))\n+ call cas_shape(b(1:2)(1:3))\n+ call cas_shape(c(1:2)(1:3))\n+ call cas_shape(d(1:2)(1:3))\n+ call cas_shape((a(1:2)(1:3)//\"a\"))\n+ call cas_shape((b(1:2)(1:3)//\"a\"))\n+ call cas_shape((c(1:2)(1:3)//\"a\"))\n+ call cas_shape((d(1:2)(1:3)//\"a\"))\n+ call cas_size(e(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size(\"abcd\"(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size((e(1:3))) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_size((\"abcd\"(1:3)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+\n+ call cas_expl(a)\n+ call cas_expl(b)\n+ call cas_expl(c)\n+ call cas_expl(d)\n+ call cas_expl(e) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(\"abc\") ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((/\"a\",\"b\",\"c\"/))\n+ call cas_expl(a//\"a\")\n+ call cas_expl(b//\"a\")\n+ call cas_expl(c//\"a\")  ! { dg-error \"The upper bound in the last dimension must appear in the reference to the assumed size array\" }\n+ call cas_expl(d//\"a\")\n+ call cas_expl(e//\"a\") ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((\"abc\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(((/\"a\",\"b\",\"c\"/)))\n+ call cas_expl(a(1)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(b(1)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(c(1)) ! OK in F95\n+ call cas_expl(d(1)) ! OK in F95\n+ call cas_expl((a(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((b(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((c(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((d(1)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(a(1:3))\n+ call cas_expl(b(1:3))\n+ call cas_expl(c(1:3))\n+ call cas_expl(d(1:3))\n+ call cas_expl((a(1:3)//\"a\"))\n+ call cas_expl((b(1:3)//\"a\"))\n+ call cas_expl((c(1:3)//\"a\"))\n+ call cas_expl((d(1:3)//\"a\"))\n+ call cas_expl(a(:)(1:3))\n+ call cas_expl(b(:)(1:3))\n+ call cas_expl(d(:)(1:3))\n+ call cas_expl((a(:)(1:3)))\n+ call cas_expl((b(:)(1:3)))\n+ call cas_expl((d(:)(1:3)))\n+ call cas_expl(a(1:2)(1:3))\n+ call cas_expl(b(1:2)(1:3))\n+ call cas_expl(c(1:2)(1:3))\n+ call cas_expl(d(1:2)(1:3))\n+ call cas_expl((a(1:2)(1:3)//\"a\"))\n+ call cas_expl((b(1:2)(1:3)//\"a\"))\n+ call cas_expl((c(1:2)(1:3)//\"a\"))\n+ call cas_expl((d(1:2)(1:3)//\"a\"))\n+ call cas_expl(e(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl(\"abcd\"(1:3)) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((e(1:3))) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+ call cas_expl((\"abcd\"(1:3)//\"a\")) ! { dg-error \"Fortran 2003: Scalar CHARACTER\" }\n+END SUBROUTINE test2\n+\n+SUBROUTINE cas_size(a)\n+ character(len=*), dimension(*) :: a\n+END SUBROUTINE cas_size\n+\n+SUBROUTINE cas_shape(a)\n+ character(len=*), dimension(:) :: a\n+END SUBROUTINE cas_shape\n+\n+SUBROUTINE cas_expl(a)\n+ character(len=*), dimension(3) :: a\n+END SUBROUTINE cas_expl\n+END"}, {"sha": "dc5b5268ad600e9a46b758e293be5c60872cc8cc", "filename": "gcc/testsuite/gfortran.dg/argument_checking_12.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_12.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR fortran/34665\n+!\n+! Test argument checking\n+!\n+implicit none\n+CONTAINS\n+SUBROUTINE test2(a,b,c,d,e)\n+ character(len=*), dimension(:) :: a\n+ character(len=*), pointer, dimension(:) :: b\n+ character(len=*), dimension(*) :: c\n+ character(len=*), dimension(5) :: d\n+ character(len=*)               :: e\n+\n+ call cas_size(e) \n+ call cas_size(\"abc\") \n+ call cas_size(e//\"a\") \n+ call cas_size((\"abc\")) \n+ call cas_size(a(1)) \n+ call cas_size(b(1)) \n+ call cas_size((a(1)//\"a\")) \n+ call cas_size((b(1)//\"a\")) \n+ call cas_size((c(1)//\"a\")) \n+ call cas_size((d(1)//\"a\")) \n+ call cas_size(e(1:3)) \n+ call cas_size(\"abcd\"(1:3)) \n+ call cas_size((e(1:3))) \n+ call cas_size((\"abcd\"(1:3)//\"a\")) \n+ call cas_size(e(1:3)) \n+ call cas_size(\"abcd\"(1:3)) \n+ call cas_size((e(1:3))) \n+ call cas_size((\"abcd\"(1:3)//\"a\")) \n+ call cas_expl(e) \n+ call cas_expl(\"abc\") \n+ call cas_expl(e//\"a\") \n+ call cas_expl((\"abc\")) \n+ call cas_expl(a(1)) \n+ call cas_expl(b(1)) \n+ call cas_expl((a(1)//\"a\")) \n+ call cas_expl((b(1)//\"a\")) \n+ call cas_expl((c(1)//\"a\")) \n+ call cas_expl((d(1)//\"a\")) \n+ call cas_expl(e(1:3)) \n+ call cas_expl(\"abcd\"(1:3)) \n+ call cas_expl((e(1:3))) \n+ call cas_expl((\"abcd\"(1:3)//\"a\")) \n+END SUBROUTINE test2\n+\n+SUBROUTINE cas_size(a)\n+ character(len=*), dimension(*) :: a\n+END SUBROUTINE cas_size\n+\n+SUBROUTINE cas_expl(a)\n+ character(len=*), dimension(5) :: a\n+END SUBROUTINE cas_expl\n+END\n+"}, {"sha": "1e01c1f3326b3c08942938bd79d3a16d9ced548a", "filename": "gcc/testsuite/gfortran.dg/argument_checking_3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_3.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -22,9 +22,9 @@ end subroutine arr\n   len2 = '12'\n   len4 = '1234'\n \n-  call foo(len2) ! { dg-warning \"Type/rank mismatch in argument\" }\n-  call foo(\"ca\") ! { dg-warning \"Type/rank mismatch in argument\" }\n-  call bar(\"ca\") ! { dg-warning \"Type/rank mismatch in argument\" }\n+  call foo(len2) ! { dg-warning \"Rank mismatch in argument\" }\n+  call foo(\"ca\") ! { dg-warning \"Rank mismatch in argument\" }\n+  call bar(\"ca\") ! { dg-warning \"Rank mismatch in argument\" }\n   call foobar(len2) ! { dg-warning \"contains too few elements\" }\n   call foobar(len4)\n   call foobar(\"bar\") ! { dg-warning \"contains too few elements\" }"}, {"sha": "e24414ad355a4cf920a0cc82964a7e11a219b968", "filename": "gcc/testsuite/gfortran.dg/assumed_shape_ranks_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_ranks_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_ranks_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_ranks_1.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -14,8 +14,8 @@ end module addon\n   use addon\n   INTEGER :: I(2,2)\n   I=RESHAPE((/1,2,3,4/),(/2,2/))\n-  CALL TST(I)   ! { dg-error \"Type/rank mismatch in argument\" }\n-  i = foo (i)   ! { dg-error \"Type/rank mismatch|Incompatible ranks\" }\n+  CALL TST(I)   ! { dg-error \"Rank mismatch in argument\" }\n+  i = foo (i)   ! { dg-error \"Rank mismatch|Incompatible ranks\" }\n CONTAINS\n   SUBROUTINE TST(I)\n     INTEGER :: I(:)"}, {"sha": "4b3b7963af9aab03523d30d769799cf19a181aa5", "filename": "gcc/testsuite/gfortran.dg/c_assoc_2.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -28,7 +28,7 @@ subroutine sub0(my_c_ptr) bind(c)\n        call abort()\n     end if\n \n-    if(.not. c_associated(my_integer)) then ! { dg-error \"Type/rank mismatch\" }\n+    if(.not. c_associated(my_integer)) then ! { dg-error \"Type mismatch\" }\n        call abort()\n     end if\n   end subroutine sub0"}, {"sha": "36a30672e32278ffa1e4cb0de6d2d56671d8cf3e", "filename": "gcc/testsuite/gfortran.dg/derived_comp_array_ref_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_comp_array_ref_6.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -20,7 +20,7 @@ SUBROUTINE cdf_beta()\n         USE cdf_aux_mod\n         INTEGER :: which\n           which = 1\n-          CALL set_bound(the_beta%parameters(1:which)) ! { dg-error \"Type/rank mismatch\" }\n+          CALL set_bound(the_beta%parameters(1:which)) ! { dg-error \"Rank mismatch\" }\n       END SUBROUTINE cdf_beta\n     END MODULE cdf_beta_mod\n "}, {"sha": "750d3f3850198f18e3289ee09fe0c0e4a645a762", "filename": "gcc/testsuite/gfortran.dg/implicit_actual.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_actual.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -16,7 +16,7 @@ program snafu\n !  use global\n   implicit type (t3) (z)\n \n-  call foo (zin) ! { dg-error \"defined|Type/rank\" }\n+  call foo (zin) ! { dg-error \"defined|Type mismatch\" }\n \n contains\n "}, {"sha": "4a0128a0bf15968fb8c19028581280ca54b63534", "filename": "gcc/testsuite/gfortran.dg/import2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport2.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -71,10 +71,10 @@ end subroutine test\n   integer(dp) :: i8\n   y%i = 2\n   i8 = 8\n-  call bar(y,i8) ! { dg-error \"Type/rank mismatch in argument\" }\n+  call bar(y,i8) ! { dg-error \"Type mismatch in argument\" }\n   if(y%i /= 5 .or. i8/= 42) call abort()\n   z%i = 7\n-  call test(z) ! { dg-error \"Type/rank mismatch in argument\" }\n+  call test(z) ! { dg-error \"Type mismatch in argument\" }\n   if(z%i /= 1) call abort()\n end program foo\n ! { dg-final { cleanup-modules \"testmod\" } }"}, {"sha": "692570339a36cac20e292bf799ad4a6d0b25aa2e", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_2.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -11,7 +11,7 @@ program test\n  integer, pointer :: p\n  allocate(p)\n  p = 33\n- call a(p) ! { dg-error \"Type/rank mismatch in argument\" }\n+ call a(p) ! { dg-error \"Type mismatch in argument\" }\n contains\n   subroutine a(p)! { dg-error \"has no IMPLICIT type\" }\n     integer, pointer,intent(in) :: p ! { dg-error \"POINTER attribute with INTENT attribute\" }"}, {"sha": "a308c0e374a5773a98e6313267926f1274fb75d8", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -31,7 +31,7 @@ END SUBROUTINE TEST\n     USE T1\n     USE T2 , ONLY : TEST\n     TYPE(data_type) :: x\n-    CALL TEST(x)         ! { dg-error \"Type/rank mismatch in argument\" }\n+    CALL TEST(x)         ! { dg-error \"Type mismatch in argument\" }\n   END\n \n ! { dg-final { cleanup-modules \"T1 T2\" } }"}, {"sha": "fb36fa7bfbd657c80b3813ff9fc37df4ae9d11f3", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6345e92e2e6f191b943cf7cba49bb5d90ec27/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90?ref=5ad6345e92e2e6f191b943cf7cba49bb5d90ec27", "patch": "@@ -47,7 +47,7 @@ end module global\n ! These are different.\n   st1 = dt                ! { dg-error \"convert REAL\" }\n \n-  call foo (st1)          ! { dg-error \"Type/rank mismatch in argument\" }\n+  call foo (st1)          ! { dg-error \"Type mismatch in argument\" }\n \n contains\n "}]}