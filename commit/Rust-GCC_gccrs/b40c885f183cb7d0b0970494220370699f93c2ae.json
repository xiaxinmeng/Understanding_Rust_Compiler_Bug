{"sha": "b40c885f183cb7d0b0970494220370699f93c2ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwYzg4NWYxODNjYjdkMGIwOTcwNDk0MjIwMzcwNjk5ZjkzYzJhZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-11-30T04:02:53Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-11-30T04:02:53Z"}, "message": "ordered.c (gomp_ordered_sync): Add MEMMODEL_ACQ_REL fence.\n\n\t* ordered.c (gomp_ordered_sync): Add MEMMODEL_ACQ_REL fence.\n\t* critical.c (GOMP_critical_start): Add MEMMODEL_RELEASE fence.\n\t* config/linux/mutex.h: Use atomic rather than sync builtins.\n\t* config/linux/mutex.c: Likewise.  Comment.  Use -1 for waiting state.\n\t* config/linux/omp-lock.h: Comment fix.\n\t* config/linux/arm/mutex.h: Delete.\n\t* config/linux/powerpc/mutex.h: Delete.\n\t* config/linux/ia64/mutex.h: Delete.\n\t* config/linux/mips/mutex.h: Delete.\n\nFrom-SVN: r181832", "tree": {"sha": "f2b455abcdef142ecdfee68c7c0c647af19edcdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b455abcdef142ecdfee68c7c0c647af19edcdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40c885f183cb7d0b0970494220370699f93c2ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c885f183cb7d0b0970494220370699f93c2ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40c885f183cb7d0b0970494220370699f93c2ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c885f183cb7d0b0970494220370699f93c2ae/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e348fccfa971cf81fe9fcf3489bf011979957e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e348fccfa971cf81fe9fcf3489bf011979957e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e348fccfa971cf81fe9fcf3489bf011979957e3"}], "stats": {"total": 210, "additions": 54, "deletions": 156}, "files": [{"sha": "faa6749d8248d3306fd8551a110a322d3c0fe90b", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -1,3 +1,15 @@\n+2011-11-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* ordered.c (gomp_ordered_sync): Add MEMMODEL_ACQ_REL fence.\n+\t* critical.c (GOMP_critical_start): Add MEMMODEL_RELEASE fence.\n+\t* config/linux/mutex.h: Use atomic rather than sync builtins.\n+\t* config/linux/mutex.c: Likewise.  Comment.  Use -1 for waiting state.\n+\t* config/linux/omp-lock.h: Comment fix.\n+\t* config/linux/arm/mutex.h: Delete.\n+\t* config/linux/powerpc/mutex.h: Delete.\n+\t* config/linux/ia64/mutex.h: Delete.\n+\t* config/linux/mips/mutex.h: Delete.\n+\n 2011-11-30  Alan Modra  <amodra@gmail.com>\n \n \tPR libgomp/51249"}, {"sha": "30021d54746d12d71f3875e7e7b215d54a31ba0a", "filename": "libgomp/config/linux/arm/mutex.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Farm%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Farm%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Farm%2Fmutex.h?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,28 +0,0 @@\n-/* Copyright (C) 2010 Free Software Foundation, Inc.\n-   Contributed by ARM Ltd.\n-\n-   This file is part of the GNU OpenMP Library (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* ARM needs the same correct usage of __sync_synchronize and\n-   __sync_lock_test_and_set as ia64.  So we just use its mutex.h.  */\n-\n-#include \"config/linux/ia64/mutex.h\""}, {"sha": "8a67673df40238dac0df8b13caa8d29a1845238b", "filename": "libgomp/config/linux/ia64/mutex.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fia64%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fia64%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fia64%2Fmutex.h?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,66 +0,0 @@\n-/* Copyright (C) 2005, 2008, 2009, 2011 Free Software Foundation, Inc.\n-   Contributed by Richard Henderson <rth@redhat.com>.\n-\n-   This file is part of the GNU OpenMP Library (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This is a Linux specific implementation of a mutex synchronization\n-   mechanism for libgomp.  This type is private to the library.  This\n-   implementation uses atomic instructions and the futex syscall.  */\n-\n-#ifndef GOMP_MUTEX_H\n-#define GOMP_MUTEX_H 1\n-\n-typedef int gomp_mutex_t;\n-\n-#define GOMP_MUTEX_INIT_0 1\n-\n-static inline void gomp_mutex_init (gomp_mutex_t *mutex)\n-{\n-  *mutex = 0;\n-}\n-\n-extern void gomp_mutex_lock_slow (gomp_mutex_t *mutex, int);\n-static inline void gomp_mutex_lock (gomp_mutex_t *mutex)\n-{\n-  int oldval = __sync_val_compare_and_swap (mutex, 0, 1);\n-  if (__builtin_expect (oldval, 0))\n-    gomp_mutex_lock_slow (mutex, oldval);\n-}\n-\n-extern void gomp_mutex_unlock_slow (gomp_mutex_t *mutex);\n-\n-/* IA64 needs a __sync_synchronize call before __sync_lock_test_and_set\n-   because __sync_lock_test_and_set is not a full memory fence.  */\n-static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)\n-{\n-  int val;\n-  __sync_synchronize ();\n-  val = __sync_lock_test_and_set (mutex, 0);\n-  if (__builtin_expect (val > 1, 0))\n-    gomp_mutex_unlock_slow (mutex);\n-}\n-\n-static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)\n-{\n-}\n-\n-#endif /* GOMP_MUTEX_H */"}, {"sha": "668cc11b29a95a876e0220ac251193120e4b30c4", "filename": "libgomp/config/linux/mips/mutex.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fmips%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fmips%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmips%2Fmutex.h?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,27 +0,0 @@\n-/* Copyright (C) 2009 Free Software Foundation, Inc.\n-\n-   This file is part of the GNU OpenMP Library (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* MIPS needs the same correct usage of __sync_synchronize and\n-   __sync_lock_test_and_set as ia64.  So we just use its mutex.h.  */\n-\n-#include \"config/linux/ia64/mutex.h\""}, {"sha": "1b84ffb0990fdc149c79d185d78052977ff4f105", "filename": "libgomp/config/linux/mutex.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fmutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fmutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmutex.c?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -34,25 +34,32 @@ long int gomp_futex_wait = FUTEX_WAIT | FUTEX_PRIVATE_FLAG;\n void\n gomp_mutex_lock_slow (gomp_mutex_t *mutex, int oldval)\n {\n+  /* First loop spins a while.  */\n   while (oldval == 1)\n     {\n       if (do_spin (mutex, 1))\n \t{\n-\t  oldval = __sync_lock_test_and_set (mutex, 2);\n+\t  /* Spin timeout, nothing changed.  Set waiting flag.  */\n+\t  oldval = __atomic_exchange_n (mutex, -1, MEMMODEL_ACQUIRE);\n \t  if (oldval == 0)\n \t    return;\n-\t  futex_wait (mutex, 2);\n+\t  futex_wait (mutex, -1);\n \t  break;\n \t}\n       else\n \t{\n-\t  oldval = __sync_val_compare_and_swap (mutex, 0, 1);\n-\t  if (oldval == 0)\n+\t  /* Something changed.  If now unlocked, we're good to go.  */\n+\t  oldval = 0;\n+\t  if (__atomic_compare_exchange_n (mutex, &oldval, 1, false,\n+\t\t\t\t\t   MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n \t    return;\n \t}\n     }\n-  while ((oldval = __sync_lock_test_and_set (mutex, 2)))\n-    do_wait (mutex, 2);\n+\n+  /* Second loop waits until mutex is unlocked.  We always exit this\n+     loop with wait flag set, so next unlock will awaken a thread.  */\n+  while ((oldval = __atomic_exchange_n (mutex, -1, MEMMODEL_ACQUIRE)))\n+    do_wait (mutex, -1);\n }\n \n void"}, {"sha": "912152ec3a1a75d25f6302c905acda61db651fac", "filename": "libgomp/config/linux/mutex.h", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmutex.h?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -33,39 +33,34 @@ typedef int gomp_mutex_t;\n \n #define GOMP_MUTEX_INIT_0 1\n \n-static inline void gomp_mutex_init (gomp_mutex_t *mutex)\n+extern void gomp_mutex_lock_slow (gomp_mutex_t *mutex, int);\n+extern void gomp_mutex_unlock_slow (gomp_mutex_t *mutex);\n+\n+static inline void\n+gomp_mutex_init (gomp_mutex_t *mutex)\n {\n   *mutex = 0;\n }\n \n-extern void gomp_mutex_lock_slow (gomp_mutex_t *mutex, int);\n-static inline void gomp_mutex_lock (gomp_mutex_t *mutex)\n+static inline void\n+gomp_mutex_destroy (gomp_mutex_t *mutex)\n {\n-  int oldval = __sync_val_compare_and_swap (mutex, 0, 1);\n-  if (__builtin_expect (oldval, 0))\n-    gomp_mutex_lock_slow (mutex, oldval);\n }\n \n-extern void gomp_mutex_unlock_slow (gomp_mutex_t *mutex);\n-static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)\n+static inline void\n+gomp_mutex_lock (gomp_mutex_t *mutex)\n {\n-  /* Warning: By definition __sync_lock_test_and_set() does not have\n-     proper memory barrier semantics for a mutex unlock operation.\n-     However, this default implementation is written assuming that it\n-     does, which is true for some targets.\n-\n-     Targets that require additional memory barriers before\n-     __sync_lock_test_and_set to achieve the release semantics of\n-     mutex unlock, are encouraged to include\n-     \"config/linux/ia64/mutex.h\" in a target specific mutex.h instead\n-     of using this file.  */\n-  int val = __sync_lock_test_and_set (mutex, 0);\n-  if (__builtin_expect (val > 1, 0))\n-    gomp_mutex_unlock_slow (mutex);\n+  int oldval = 0;\n+  if (!__atomic_compare_exchange_n (mutex, &oldval, 1, false,\n+\t\t\t\t    MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+    gomp_mutex_lock_slow (mutex, oldval);\n }\n \n-static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)\n+static inline void\n+gomp_mutex_unlock (gomp_mutex_t *mutex)\n {\n+  int wait = __atomic_exchange_n (mutex, 0, MEMMODEL_RELEASE);\n+  if (__builtin_expect (wait < 0, 0))\n+    gomp_mutex_unlock_slow (mutex);\n }\n-\n #endif /* GOMP_MUTEX_H */"}, {"sha": "2ca7c5e1d60fe13875ce767fd03f85cb3bf9a128", "filename": "libgomp/config/linux/omp-lock.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fomp-lock.h?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -3,8 +3,8 @@\n    structures without polluting the namespace.\n \n    When using the Linux futex primitive, non-recursive locks require\n-   only one int.  Recursive locks require we identify the owning task\n-   and so require one int and a pointer.  */\n+   one int.  Recursive locks require we identify the owning task\n+   and so require in addition one int and a pointer.  */\n \n typedef int omp_lock_t;\n typedef struct { int lock, count; void *owner; } omp_nest_lock_t;"}, {"sha": "e64ff077c836bbe83295ffb08f90c530ddcb8791", "filename": "libgomp/config/linux/powerpc/mutex.h", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Fmutex.h?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,2 +0,0 @@\n-/* On PowerPC __sync_lock_test_and_set isn't a full barrier.  */\n-#include \"config/linux/ia64/mutex.h\""}, {"sha": "414c42216265c43553b8ca63ef0efe16625dc94b", "filename": "libgomp/critical.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fcritical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fcritical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fcritical.c?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -33,6 +33,8 @@ static gomp_mutex_t default_lock;\n void\n GOMP_critical_start (void)\n {\n+  /* There is an implicit flush on entry to a critical region. */\n+  __atomic_thread_fence (MEMMODEL_RELEASE);\n   gomp_mutex_lock (&default_lock);\n }\n "}, {"sha": "f84d52eb9ff10bc034676452fbeef5af9caf4ccc", "filename": "libgomp/ordered.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c885f183cb7d0b0970494220370699f93c2ae/libgomp%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fordered.c?ref=b40c885f183cb7d0b0970494220370699f93c2ae", "patch": "@@ -207,8 +207,13 @@ gomp_ordered_sync (void)\n      post to our release semaphore.  So the two cases are that we will\n      either win the race an momentarily block on the semaphore, or lose\n      the race and find the semaphore already unlocked and so not block.\n-     Either way we get correct results.  */\n+     Either way we get correct results.\n+     However, there is an implicit flush on entry to an ordered region,\n+     so we do need to have a barrier here.  If we were taking a lock\n+     this could be MEMMODEL_RELEASE since the acquire would be coverd\n+     by the lock.  */\n \n+  __atomic_thread_fence (MEMMODEL_ACQ_REL);\n   if (ws->ordered_owner != thr->ts.team_id)\n     {\n       gomp_sem_wait (team->ordered_release[thr->ts.team_id]);"}]}