{"sha": "bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlNThlMzIwOGE0Mjk3YjVlOTA5OGNkNjlhNWNiYzFjYmIzZWZiYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-30T11:50:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-30T11:50:12Z"}, "message": "3vtrasym.adb: Demangle Ada symbols returned by TBK$SYMBOLIZE.\n\n\t* 3vtrasym.adb:\n\tDemangle Ada symbols returned by TBK$SYMBOLIZE. Correctly align line\n\tnumbers when symbol name is too long.\n\n\t* g-signal.ads, g-signal.adb: New files\n\n\t* impunit.adb: (Non_Imp_File_Names): Added \"g-signal\"\n\n\t* Makefile.rtl: Introduce GNAT.Signals\n\n\t* freeze.adb: Minor reformatting\n\n\t* lib-writ.adb (Write_ALI): Never write ali file if -gnats is specified\n\n\t* par.adb, par-ch12.adb, par-ch13.adb, par-ch2.adb, par-ch3.adb,\n\tpar-ch5.adb, par-ch6.adb, par-ch9.adb, par-util.adb:\n\tNew handling of Id_Check parameter to improve recognition of keywords\n\tused as identifiers.\n\tUpdate copyright notice to include 2003\n\nFrom-SVN: r73083", "tree": {"sha": "c4a85e3c12ef94392561f5d5ce3fd9901be49440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4a85e3c12ef94392561f5d5ce3fd9901be49440"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/comments", "author": null, "committer": null, "parents": [{"sha": "577d63287ad4a7508ba68432202580bfceeb531d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577d63287ad4a7508ba68432202580bfceeb531d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/577d63287ad4a7508ba68432202580bfceeb531d"}], "stats": {"total": 525, "additions": 459, "deletions": 66}, "files": [{"sha": "159c03fe2793bb0c7c2820cb45ebcb9010d5b5fa", "filename": "gcc/ada/3vtrasym.adb", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2F3vtrasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2F3vtrasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F3vtrasym.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1999-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2003 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,8 @@\n -- however invalidate  any other reasons why  the executable file  might be --\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n--- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -96,12 +97,83 @@ package body GNAT.Traceback.Symbolic is\n        Value, Value),\n        User_Act_Proc);\n \n+   function Demangle_Ada (Mangled : String) return String;\n+   --  Demangles an Ada symbol. Removes leading \"_ada_\" and trailing\n+   --  __{DIGIT}+ or ${DIGIT}+, converts other \"__\" to '.'\n+\n+\n+   ------------------\n+   -- Demangle_Ada --\n+   ------------------\n+\n+   function Demangle_Ada (Mangled : String) return String is\n+      Demangled : String (1 .. Mangled'Length);\n+      Pos  : Integer := Mangled'First;\n+      Last : Integer := Mangled'Last;\n+      DPos : Integer := 1;\n+   begin\n+\n+      if Pos > Last then\n+         return \"\";\n+      end if;\n+\n+      --  Skip leading _ada_\n+\n+      if Mangled'Length > 4 and then Mangled (Pos .. Pos + 4) = \"_ada_\" then\n+         Pos := Pos + 5;\n+      end if;\n+\n+      --  Skip trailing __{DIGIT}+ or ${DIGIT}+\n+\n+      if Mangled (Last) in '0' .. '9' then\n+\n+         for J in reverse Pos + 2 .. Last - 1 loop\n+\n+            case Mangled (J) is\n+               when '0' .. '9' =>\n+                  null;\n+               when '$' =>\n+                  Last := J - 1;\n+                  exit;\n+               when '_' =>\n+                  if Mangled (J - 1) = '_' then\n+                     Last := J - 2;\n+                  end if;\n+                  exit;\n+               when others =>\n+                  exit;\n+            end case;\n+\n+         end loop;\n+\n+      end if;\n+\n+      --  Now just copy Mangled to Demangled, converting \"__\" to '.' on the fly\n+\n+      while Pos <= Last loop\n+\n+         if Mangled (Pos) = '_' and then Mangled (Pos + 1) = '_'\n+           and then Pos /= Mangled'First then\n+            Demangled (DPos) := '.';\n+            Pos := Pos + 2;\n+         else\n+            Demangled (DPos) := Mangled (Pos);\n+            Pos := Pos + 1;\n+         end if;\n+\n+         DPos := DPos + 1;\n+\n+      end loop;\n+\n+      return Demangled (1 .. DPos - 1);\n+   end Demangle_Ada;\n+\n    ------------------------\n    -- Symbolic_Traceback --\n    ------------------------\n \n    function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-      Status       : Cond_Value_Type;\n+      Status            : Cond_Value_Type;\n       Image_Name        : ASCIC;\n       Image_Name_Addr   : Address;\n       Module_Name       : ASCIC;\n@@ -152,6 +224,11 @@ package body GNAT.Traceback.Symbolic is\n             declare\n                First : Integer := Len + 1;\n                Last  : Integer := First + 80 - 1;\n+               Pos   : Integer;\n+               Routine_Name_D : String := Demangle_Ada\n+                 (To_Ada\n+                    (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n+                     False));\n \n             begin\n                Res (First .. Last) := (others => ' ');\n@@ -168,13 +245,23 @@ package body GNAT.Traceback.Symbolic is\n                    False);\n \n                Res (First + 30 ..\n-                    First + 30 + Integer (Routine_Name.Count) - 1) :=\n-                 To_Ada\n-                  (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n-                   False);\n+                    First + 30 + Routine_Name_D'Length - 1) :=\n+                 Routine_Name_D;\n+\n+               --  If routine name doesn't fit 20 characters, output\n+               --  the line number on next line at 50th position\n+\n+               if Routine_Name_D'Length > 20 then\n+                  Pos := First + 30 + Routine_Name_D'Length;\n+                  Res (Pos) := ASCII.LF;\n+                  Last := Pos + 80;\n+                  Res (Pos + 1 .. Last) := (others => ' ');\n+                  Pos := Pos + 51;\n+               else\n+                  Pos := First + 50;\n+               end if;\n \n-               Res (First + 50 ..\n-                    First + 50 + Integer'Image (Line_Number)'Length - 1) :=\n+               Res (Pos .. Pos + Integer'Image (Line_Number)'Length - 1) :=\n                  Integer'Image (Line_Number);\n \n                Res (Last) := ASCII.LF;"}, {"sha": "d34a2a45de379c8bd229a776253cfa07ec88f31e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -1,3 +1,29 @@\n+2003-10-30  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* 3vtrasym.adb: \n+\tDemangle Ada symbols returned by TBK$SYMBOLIZE. Correctly align line\n+\tnumbers when symbol name is too long.\n+\n+2003-10-30  Ed Falis  <falis@gnat.com>\n+\n+\t* g-signal.ads, g-signal.adb: New files\n+\n+\t* impunit.adb: (Non_Imp_File_Names): Added \"g-signal\"\n+\n+\t* Makefile.rtl: Introduce GNAT.Signals\n+\n+2003-10-30  Robert Dewar  <dewar@gnat.com>\n+\n+\t* freeze.adb: Minor reformatting\n+\n+\t* lib-writ.adb (Write_ALI): Never write ali file if -gnats is specified\n+\n+\t* par.adb, par-ch12.adb, par-ch13.adb, par-ch2.adb, par-ch3.adb, \n+\tpar-ch5.adb, par-ch6.adb, par-ch9.adb, par-util.adb: \n+\tNew handling of Id_Check parameter to improve recognition of keywords\n+\tused as identifiers.\n+\tUpdate copyright notice to include 2003\n+\n 2003-10-29  Robert Dewar  <dewar@gnat.com>\n \n \t* 3vtrasym.adb, 5vtraent.ads, sprint.adb,\n@@ -8,10 +34,7 @@\n \n 2003-10-29  Vasiliy Fofanov  <fofanov@act-europe.fr>\n \n-\t* 3vtrasym.adb: \n-\t* 5vtraent.adb: \n-\t* 5vtraent.ads: \n-\t* tb-alvms.c: \n+\t* 3vtrasym.adb, 5vtraent.adb, 5vtraent.ads, tb-alvms.c: \n \tSupport for TBK$SYMBOLIZE-based symbolic traceback.\n \n 2003-10-29  Jose Ruiz  <ruiz@act-europe.fr>"}, {"sha": "62da39743f9364242f3cb3df26e5f9044049d9e9", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -38,6 +38,7 @@ GNATRTL_TASKING_OBJS= \\\n   g-boubuf$(objext) \\\n   g-boumai$(objext) \\\n   g-semaph$(objext) \\\n+  g-signal$(objext) \\\n   g-thread$(objext) \\\n   s-asthan$(objext) \\\n   s-inmaop$(objext) \\"}, {"sha": "68dc1776e02a5ad2c4e3d531051ead786661e944", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -124,7 +124,7 @@ package body Freeze is\n    --  a subprogram type (i.e. an access to a subprogram).\n \n    function Is_Fully_Defined (T : Entity_Id) return Boolean;\n-   --  true if T is not private and has no private components, or has a full\n+   --  True if T is not private and has no private components, or has a full\n    --  view. Used to determine whether the designated type of an access type\n    --  should be frozen when the access type is frozen. This is done when an\n    --  allocator is frozen, or an expression that may involve attributes of\n@@ -4262,12 +4262,12 @@ package body Freeze is\n       elsif Is_Record_Type (T)\n         and not Is_Private_Type (T)\n       then\n-\n          --  Verify that the record type has no components with\n          --  private types without completion.\n \n          declare\n             Comp : Entity_Id;\n+\n          begin\n             Comp := First_Component (T);\n "}, {"sha": "605b3e72f916d4f031f2abd2117969db367ca690", "filename": "gcc/ada/g-signal.adb", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fg-signal.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fg-signal.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-signal.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -0,0 +1,71 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                         G N A T . S I G N A L S                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2003 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Interrupts;\n+\n+package body GNAT.Signals is\n+\n+   package SI renames System.Interrupts;\n+\n+   ------------------\n+   -- Block_Signal --\n+   ------------------\n+\n+   procedure Block_Signal (Signal : Ada.Interrupts.Interrupt_ID) is\n+   begin\n+      SI.Block_Interrupt (SI.Interrupt_ID (Signal));\n+   end Block_Signal;\n+\n+   ----------------\n+   -- Is_Blocked --\n+   ----------------\n+\n+   function Is_Blocked\n+     (Signal : Ada.Interrupts.Interrupt_ID)\n+      return Boolean\n+   is\n+   begin\n+      return SI.Is_Blocked (SI.Interrupt_ID (Signal));\n+   end Is_Blocked;\n+\n+   --------------------\n+   -- Unblock_Signal --\n+   --------------------\n+\n+   procedure Unblock_Signal (Signal : Ada.Interrupts.Interrupt_ID) is\n+   begin\n+      SI.Unblock_Interrupt (SI.Interrupt_ID (Signal));\n+   end Unblock_Signal;\n+\n+end GNAT.Signals;\n+"}, {"sha": "6939fe27386743a9cb7c3dd35970d4f106c273e3", "filename": "gcc/ada/g-signal.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fg-signal.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fg-signal.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-signal.ads?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                         G N A T . S I G N A L S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2003 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Interrupts;\n+\n+--  This package provides operations for querying and setting the blocked\n+--  status of signals.\n+\n+--  This package is supported only on targets where Ada.Interrupts.Interrupt_ID\n+--  corresponds to software signals on the target, and where System.Interrupts\n+--  provides the ability to block and unblock signals.\n+\n+package GNAT.Signals is\n+\n+   procedure Block_Signal (Signal : Ada.Interrupts.Interrupt_ID);\n+   --  Block \"Signal\" at the process level\n+\n+   procedure Unblock_Signal (Signal : Ada.Interrupts.Interrupt_ID);\n+   --  Unblock \"Signal\" at the process level\n+\n+   function Is_Blocked (Signal : Ada.Interrupts.Interrupt_ID)\n+                       return Boolean;\n+   --  \"Signal\" blocked at the process level?\n+\n+end GNAT.Signals;"}, {"sha": "d2a8645fc1900f27a82d357dca36050d657da793", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -229,6 +229,7 @@ package body Impunit is\n      \"g-regist\",    -- GNAT.Registry\n      \"g-regpat\",    -- GNAT.Regpat\n      \"g-semaph\",    -- GNAT.Semaphores\n+     \"g-signal\",    -- GNAT.Signals\n      \"g-socket\",    -- GNAT.Sockets\n      \"g-souinf\",    -- GNAT.Source_Info\n      \"g-speche\",    -- GNAT.Spell_Checker"}, {"sha": "c359011f677eed831fd5931b19f84d1128562be4", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -680,6 +680,13 @@ package body Lib.Writ is\n    --  Start of processing for Writ_ALI\n \n    begin\n+      --  We never write an ALI file if the original operating mode was\n+      --  syntax-only (-gnats switch used in compiler invocation line)\n+\n+      if Original_Operating_Mode = Check_Syntax then\n+         return;\n+      end if;\n+\n       --  Build sorted source dependency table. We do this right away,\n       --  because it is referenced by Up_To_Date_ALI_File_Exists.\n "}, {"sha": "2880fe43678846b0da260db6e79598d6a12a9327", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -367,12 +367,12 @@ package body Ch12 is\n       --  bother to check for it being exceeded.\n \n    begin\n-      Idents (1) := P_Defining_Identifier;\n+      Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n       Num_Idents := 1;\n \n       while Comma_Present loop\n          Num_Idents := Num_Idents + 1;\n-         Idents (Num_Idents) := P_Defining_Identifier;\n+         Idents (Num_Idents) := P_Defining_Identifier (C_Comma_Colon);\n       end loop;\n \n       T_Colon;\n@@ -873,7 +873,7 @@ package body Ch12 is\n    begin\n       Def_Node := New_Node (N_Formal_Package_Declaration, Prev_Token_Ptr);\n       Scan; -- past PACKAGE\n-      Set_Defining_Identifier (Def_Node, P_Defining_Identifier);\n+      Set_Defining_Identifier (Def_Node, P_Defining_Identifier (C_Is));\n       T_Is;\n       T_New;\n       Set_Name (Def_Node, P_Qualified_Simple_Name);"}, {"sha": "7a7e4798a85df2612bf42fa27ea08810dd1e53aa", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -92,7 +92,7 @@ package body Ch13 is\n       --  Note that the name in a representation clause is always a simple\n       --  name, even in the attribute case, see AI-300 which made this so!\n \n-      Identifier_Node := P_Identifier;\n+      Identifier_Node := P_Identifier (C_Use);\n \n       --  Check case of qualified name to give good error message\n "}, {"sha": "dd58e1f9cdca816a556b334833258952a08bb2dd", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -47,7 +47,7 @@ package body Ch2 is\n \n    --  Error recovery: can raise Error_Resync (cannot return Error)\n \n-   function P_Identifier return Node_Id is\n+   function P_Identifier (C : Id_Check := None) return Node_Id is\n       Ident_Node : Node_Id;\n \n    begin\n@@ -61,7 +61,7 @@ package body Ch2 is\n       --  If we have a reserved identifier, manufacture an identifier with\n       --  a corresponding name after posting an appropriate error message\n \n-      elsif Is_Reserved_Identifier then\n+      elsif Is_Reserved_Identifier (C) then\n          Scan_Reserved_Identifier (Force_Msg => False);\n          Ident_Node := Token_Node;\n          Scan; -- past the node"}, {"sha": "8236c5897d7b15a0081bc7cc574f01300ce299a4", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -164,7 +164,7 @@ package body Ch3 is\n \n    --  Error recovery: can raise Error_Resync\n \n-   function P_Defining_Identifier return Node_Id is\n+   function P_Defining_Identifier (C : Id_Check := None) return Node_Id is\n       Ident_Node : Node_Id;\n \n    begin\n@@ -179,7 +179,7 @@ package body Ch3 is\n       --  If we have a reserved identifier, manufacture an identifier with\n       --  a corresponding name after posting an appropriate error message\n \n-      elsif Is_Reserved_Identifier then\n+      elsif Is_Reserved_Identifier (C) then\n          Scan_Reserved_Identifier (Force_Msg => True);\n \n       --  Otherwise we have junk that cannot be interpreted as an identifier\n@@ -262,7 +262,7 @@ package body Ch3 is\n       Type_Loc := Token_Ptr;\n       Type_Start_Col := Start_Column;\n       T_Type;\n-      Ident_Node := P_Defining_Identifier;\n+      Ident_Node := P_Defining_Identifier (C_Is);\n       Discr_Sloc := Token_Ptr;\n \n       if P_Unknown_Discriminant_Part_Opt then\n@@ -732,7 +732,7 @@ package body Ch3 is\n    begin\n       Decl_Node := New_Node (N_Subtype_Declaration, Token_Ptr);\n       Scan; -- past SUBTYPE\n-      Set_Defining_Identifier (Decl_Node, P_Defining_Identifier);\n+      Set_Defining_Identifier (Decl_Node, P_Defining_Identifier (C_Is));\n       TF_Is;\n \n       if Token = Tok_New then\n@@ -1090,7 +1090,7 @@ package body Ch3 is\n    begin\n       Ident_Sloc := Token_Ptr;\n       Save_Scan_State (Scan_State); -- at first identifier\n-      Idents (1) := P_Defining_Identifier;\n+      Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n \n       --  If we have a colon after the identifier, then we can assume that\n       --  this is in fact a valid identifier declaration and can steam ahead.\n@@ -1104,7 +1104,7 @@ package body Ch3 is\n \n          while Comma_Present loop\n             Num_Idents := Num_Idents + 1;\n-            Idents (Num_Idents) := P_Defining_Identifier;\n+            Idents (Num_Idents) := P_Defining_Identifier (C_Comma_Colon);\n          end loop;\n \n          Save_Scan_State (Scan_State); -- at colon\n@@ -1685,7 +1685,7 @@ package body Ch3 is\n       if Token = Tok_Char_Literal then\n          return P_Defining_Character_Literal;\n       else\n-         return P_Defining_Identifier;\n+         return P_Defining_Identifier (C_Comma_Right_Paren);\n       end if;\n    end P_Enumeration_Literal_Specification;\n \n@@ -2278,12 +2278,12 @@ package body Ch3 is\n          Specification_Loop : loop\n \n             Ident_Sloc := Token_Ptr;\n-            Idents (1) := P_Defining_Identifier;\n+            Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n             Num_Idents := 1;\n \n             while Comma_Present loop\n                Num_Idents := Num_Idents + 1;\n-               Idents (Num_Idents) := P_Defining_Identifier;\n+               Idents (Num_Idents) := P_Defining_Identifier (C_Comma_Colon);\n             end loop;\n \n             T_Colon;\n@@ -2518,7 +2518,7 @@ package body Ch3 is\n       Names_List := New_List;\n \n       loop\n-         Append (P_Identifier, Names_List);\n+         Append (P_Identifier (C_Vertical_Bar_Arrow), Names_List);\n          exit when Token /= Tok_Vertical_Bar;\n          Scan; -- past |\n       end loop;\n@@ -2747,12 +2747,12 @@ package body Ch3 is\n       end if;\n \n       Ident_Sloc := Token_Ptr;\n-      Idents (1) := P_Defining_Identifier;\n+      Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n       Num_Idents := 1;\n \n       while Comma_Present loop\n          Num_Idents := Num_Idents + 1;\n-         Idents (Num_Idents) := P_Defining_Identifier;\n+         Idents (Num_Idents) := P_Defining_Identifier (C_Comma_Colon);\n       end loop;\n \n       T_Colon;"}, {"sha": "e45b0fafb5949f391ae9973d7368b2b4b0e6a34e", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -1004,7 +1004,7 @@ package body Ch5 is\n    begin\n       Label_Node := New_Node (N_Label, Token_Ptr);\n       Scan; -- past <<\n-      Set_Identifier (Label_Node, P_Identifier);\n+      Set_Identifier (Label_Node, P_Identifier (C_Greater_Greater));\n       T_Greater_Greater;\n       Append_Elmt (Label_Node, Label_List);\n       return Label_Node;\n@@ -1621,7 +1621,7 @@ package body Ch5 is\n         New_Node (N_Loop_Parameter_Specification, Token_Ptr);\n \n       Save_Scan_State (Scan_State);\n-      ID_Node := P_Defining_Identifier;\n+      ID_Node := P_Defining_Identifier (C_In);\n       Set_Defining_Identifier (Loop_Param_Specification_Node, ID_Node);\n \n       if Token = Tok_Left_Paren then"}, {"sha": "cc0e89817401f53d17f258544a87fc77d4d47834", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -593,6 +593,10 @@ package body Ch6 is\n       --  True, a real dot has been scanned and we are positioned past it,\n       --  if the result is False, the scan position is unchanged.\n \n+      --------------\n+      -- Real_Dot --\n+      --------------\n+\n       function Real_Dot return Boolean is\n          Scan_State  : Saved_Scan_State;\n \n@@ -715,7 +719,7 @@ package body Ch6 is\n          Set_Identifier_Casing (Current_Source_File, Determine_Token_Casing);\n       end if;\n \n-      Ident_Node := P_Identifier;\n+      Ident_Node := P_Identifier (C_Dot);\n       Merge_Identifier (Ident_Node, Tok_Return);\n \n       --  Normal case (not child library unit name)\n@@ -746,7 +750,7 @@ package body Ch6 is\n             Name_Node := New_Node (N_Selected_Component, Token_Ptr);\n             Scan; -- past period\n             Set_Prefix (Name_Node, Prefix_Node);\n-            Ident_Node := P_Identifier;\n+            Ident_Node := P_Identifier (C_Dot);\n             Set_Selector_Name (Name_Node, Ident_Node);\n             Prefix_Node := Name_Node;\n          end loop;\n@@ -870,7 +874,7 @@ package body Ch6 is\n \n             Ignore (Tok_Left_Paren);\n             Ident_Sloc := Token_Ptr;\n-            Idents (1) := P_Defining_Identifier;\n+            Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n             Num_Idents := 1;\n \n             Ident_Loop : loop\n@@ -924,7 +928,7 @@ package body Ch6 is\n \n                T_Comma;\n                Num_Idents := Num_Idents + 1;\n-               Idents (Num_Idents) := P_Defining_Identifier;\n+               Idents (Num_Idents) := P_Defining_Identifier (C_Comma_Colon);\n             end loop Ident_Loop;\n \n             --  Fall through the loop on encountering a colon, or deciding"}, {"sha": "6bfc409acceed0fde0bccd901a7676f965e91f14", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -90,7 +90,7 @@ package body Ch9 is\n \n       if Token = Tok_Body then\n          Scan; -- past BODY\n-         Name_Node := P_Defining_Identifier;\n+         Name_Node := P_Defining_Identifier (C_Is);\n          Scope.Table (Scope.Last).Labl := Name_Node;\n \n          if Token = Tok_Left_Paren then\n@@ -133,15 +133,14 @@ package body Ch9 is\n \n          else\n             Task_Node := New_Node (N_Single_Task_Declaration, Task_Sloc);\n-            Name_Node := P_Defining_Identifier;\n+            Name_Node := P_Defining_Identifier (C_Is);\n             Set_Defining_Identifier (Task_Node, Name_Node);\n             Scope.Table (Scope.Last).Labl := Name_Node;\n \n             if Token = Tok_Left_Paren then\n                Error_Msg_SC (\"discriminant part not allowed for single task\");\n                Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n             end if;\n-\n          end if;\n \n          --  Parse optional task definition. Note that P_Task_Definition scans\n@@ -344,7 +343,7 @@ package body Ch9 is\n \n       if Token = Tok_Body then\n          Scan; -- past BODY\n-         Name_Node := P_Defining_Identifier;\n+         Name_Node := P_Defining_Identifier (C_Is);\n          Scope.Table (Scope.Last).Labl := Name_Node;\n \n          if Token = Tok_Left_Paren then\n@@ -381,7 +380,7 @@ package body Ch9 is\n             Scan; -- past TYPE\n             Protected_Node :=\n               New_Node (N_Protected_Type_Declaration, Protected_Sloc);\n-            Name_Node := P_Defining_Identifier;\n+            Name_Node := P_Defining_Identifier (C_Is);\n             Set_Defining_Identifier (Protected_Node, Name_Node);\n             Scope.Table (Scope.Last).Labl := Name_Node;\n             Set_Discriminant_Specifications\n@@ -390,7 +389,7 @@ package body Ch9 is\n          else\n             Protected_Node :=\n               New_Node (N_Single_Protected_Declaration, Protected_Sloc);\n-            Name_Node := P_Defining_Identifier;\n+            Name_Node := P_Defining_Identifier (C_Is);\n             Set_Defining_Identifier (Protected_Node, Name_Node);\n \n             if Token = Tok_Left_Paren then\n@@ -631,7 +630,8 @@ package body Ch9 is\n       Decl_Node := New_Node (N_Entry_Declaration, Token_Ptr);\n       Scan; -- past ENTRY\n \n-      Set_Defining_Identifier (Decl_Node, P_Defining_Identifier);\n+      Set_Defining_Identifier\n+        (Decl_Node, P_Defining_Identifier (C_Left_Paren_Semicolon));\n \n       --  If left paren, could be (Discrete_Subtype_Definition) or Formal_Part\n \n@@ -719,7 +719,7 @@ package body Ch9 is\n       Scan; -- past ACCEPT\n       Scope.Table (Scope.Last).Labl := Token_Node;\n \n-      Set_Entry_Direct_Name (Accept_Node, P_Identifier);\n+      Set_Entry_Direct_Name (Accept_Node, P_Identifier (C_Do));\n \n       --  Left paren could be (Entry_Index) or Formal_Part, determine which\n \n@@ -932,7 +932,7 @@ package body Ch9 is\n    begin\n       Iterator_Node := New_Node (N_Entry_Index_Specification, Token_Ptr);\n       T_For; -- past FOR\n-      Set_Defining_Identifier (Iterator_Node, P_Defining_Identifier);\n+      Set_Defining_Identifier (Iterator_Node, P_Defining_Identifier (C_In));\n       T_In;\n       Set_Discrete_Subtype_Definition\n         (Iterator_Node, P_Discrete_Subtype_Definition);"}, {"sha": "d23269ea88da12600b658ea2a6f373082c43f4b7", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -24,6 +24,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Csets; use Csets;\n with Uintp; use Uintp;\n \n with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n@@ -419,7 +420,7 @@ package body Util is\n    -- Is_Reserved_Identifier --\n    ----------------------------\n \n-   function Is_Reserved_Identifier return Boolean is\n+   function Is_Reserved_Identifier (C : Id_Check := None) return Boolean is\n    begin\n       if not Is_Reserved_Keyword (Token) then\n          return False;\n@@ -438,20 +439,88 @@ package body Util is\n             --  keyword casing, then we return False, since it is pretty\n             --  clearly intended to be a keyword.\n \n-            if Ident_Casing /= Unknown\n-              and then Key_Casing /= Unknown\n-              and then Ident_Casing /= Key_Casing\n-              and then Determine_Token_Casing = Key_Casing\n+            if Ident_Casing = Unknown\n+              or else Key_Casing = Unknown\n+              or else Ident_Casing = Key_Casing\n+              or else Determine_Token_Casing /= Key_Casing\n             then\n-               return False;\n+               return True;\n \n-            --  Otherwise assume that an identifier was intended\n+            --  Here we have a keyword written clearly with keyword casing.\n+            --  In default mode, we would not be willing to consider this as\n+            --  a reserved identifier, but if C is set, we may still accept it\n \n-            else\n-               return True;\n+            elsif C /= None then\n+               declare\n+                  Scan_State  : Saved_Scan_State;\n+                  OK_Next_Tok : Boolean;\n+\n+               begin\n+                  Save_Scan_State (Scan_State);\n+                  Scan;\n+\n+                  if Token_Is_At_Start_Of_Line then\n+                     return False;\n+                  end if;\n+\n+                  case C is\n+                     when None =>\n+                        raise Program_Error;\n+\n+                     when C_Comma_Right_Paren =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Comma or else Token = Tok_Right_Paren;\n+\n+                     when C_Comma_Colon =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Comma or else Token = Tok_Colon;\n+\n+                     when C_Do =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Do;\n+\n+                     when C_Dot =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Dot;\n+\n+                     when C_Greater_Greater =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Greater_Greater;\n+\n+                     when C_In =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_In;\n+\n+                     when C_Is =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Is;\n+\n+                     when C_Left_Paren_Semicolon =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Left_Paren or else Token = Tok_Semicolon;\n+\n+                     when C_Use =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Use;\n+\n+                     when C_Vertical_Bar_Arrow =>\n+                        OK_Next_Tok :=\n+                          Token = Tok_Vertical_Bar or else Token = Tok_Arrow;\n+                  end case;\n+\n+                  Restore_Scan_State (Scan_State);\n+\n+                  if OK_Next_Tok then\n+                     return True;\n+                  end if;\n+               end;\n             end if;\n          end;\n       end if;\n+\n+      --  If we fall through it is not a reserved identifier\n+\n+      return False;\n    end Is_Reserved_Identifier;\n \n    ----------------------"}, {"sha": "56629ef436ff91bd856ee3e2ff7c14e4fd90c46a", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "patch": "@@ -26,7 +26,6 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n-with Csets;    use Csets;\n with Debug;    use Debug;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -189,6 +188,73 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --   that there is a missing body, but it seems more reasonable to let the\n    --   later semantic checking discover this.\n \n+   ----------------------------------------------------\n+   -- Handling of Reserved Words Used as Identifiers --\n+   ----------------------------------------------------\n+\n+   --  Note: throughout the parser, the terms reserved word and keyword\n+   --  are used interchangably to refer to the same set of reserved\n+   --  keywords (including until, protected, etc).\n+\n+   --  If a reserved word is used in place of an identifier, the parser\n+   --  where possible tries to recover gracefully. In particular, if the\n+   --  keyword is clearly spelled using identifier casing, e.g. Until in\n+   --  a source program using mixed case identifiers and lower case keywords,\n+   --  then the keyword is treated as an identifier if it appears in a place\n+   --  where an identifier is required.\n+\n+   --  The situation is more complex if the keyword is spelled with normal\n+   --  keyword casing. In this case, the parser is more reluctant to\n+   --  consider it to be intended as an identifier, unless it has some\n+   --  further confirmation.\n+\n+   --  In the case of an identifier appearing in the identifier list of a\n+   --  declaration, the appearence of a comma or colon right after the\n+   --  keyword on the same line is taken as confirmation. For an enumeration\n+   --  literal, a comma or right paren right after the identifier is also\n+   --  treated as adequate confirmation.\n+\n+   --  The following type is used in calls to Is_Reserved_Identifier and\n+   --  also to P_Defining_Identifier and P_Identifier. The default for all\n+   --  these functins is that reserved words in reserved word case are not\n+   --  considered to be reserved identifiers. The Id_Check value indicates\n+   --  tokens, which if they appear immediately after the identifier, are\n+   --  taken as confirming that the use of an identifier was expected\n+\n+   type Id_Check is\n+     (None,\n+      --  Default, no special token test\n+\n+      C_Comma_Right_Paren,\n+      --  Consider as identifier if followed by comma or right paren\n+\n+      C_Comma_Colon,\n+      --  Consider as identifier if followed by comma or colon\n+\n+      C_Do,\n+      --  Consider as identifier if followed by DO\n+\n+      C_Dot,\n+      --  Consider as identifier if followed by period\n+\n+      C_Greater_Greater,\n+      --  Consider as identifier if followed by >>\n+\n+      C_In,\n+      --  Consider as identifier if followed by IN\n+\n+      C_Is,\n+      --  Consider as identifier if followed by IS\n+\n+      C_Left_Paren_Semicolon,\n+      --  Consider as identifier if followed by left paren or semicolon\n+\n+      C_Use,\n+      --  Consider as identifier if followed by USE\n+\n+      C_Vertical_Bar_Arrow);\n+      --  Consider as identifier if followed by | or =>\n+\n    --------------------------------------------\n    -- Handling IS Used in Place of Semicolon --\n    --------------------------------------------\n@@ -450,9 +516,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  List that is created.\n \n    package Ch2 is\n-      function P_Identifier                           return Node_Id;\n       function P_Pragma                               return Node_Id;\n \n+      function P_Identifier (C : Id_Check := None) return Node_Id;\n+      --  Scans out an identifier. The parameter C determines the treatment\n+      --  of reserved identifiers. See declaration of Id_Check for details.\n+\n       function P_Pragmas_Opt return List_Id;\n       --  This function scans for a sequence of pragmas in other than a\n       --  declaration sequence or statement sequence context. All pragmas\n@@ -482,7 +551,6 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Basic_Declarative_Items              return List_Id;\n       function P_Constraint_Opt                       return Node_Id;\n       function P_Declarative_Part                     return List_Id;\n-      function P_Defining_Identifier                  return Node_Id;\n       function P_Discrete_Choice_List                 return List_Id;\n       function P_Discrete_Range                       return Node_Id;\n       function P_Discrete_Subtype_Definition          return Node_Id;\n@@ -503,6 +571,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  case where the source has a single declaration with multiple\n       --  defining identifiers.\n \n+      function P_Defining_Identifier (C : Id_Check := None) return Node_Id;\n+      --  Scan out a defining identifier. The parameter C controls the\n+      --  treatment of errors in case a reserved word is scanned. See the\n+      --  declaration of this type for details.\n+\n       function Init_Expr_Opt (P : Boolean := False) return Node_Id;\n       --  If an initialization expression is present (:= expression), then\n       --  it is scanned out and returned, otherwise Empty is returned if no\n@@ -908,10 +981,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  past it, otherwise the call has no effect at all. T may be any\n       --  reserved word token, or comma, left or right paren, or semicolon.\n \n-      function Is_Reserved_Identifier return Boolean;\n+      function Is_Reserved_Identifier (C : Id_Check := None) return Boolean;\n       --  Test if current token is a reserved identifier. This test is based\n       --  on the token being a keyword and being spelled in typical identifier\n-      --  style (i.e. starting with an upper case letter).\n+      --  style (i.e. starting with an upper case letter). The parameter C\n+      --  determines the special treatment if a reserved word is encountered\n+      --  that has the normal casing of a reserved word.\n \n       procedure Merge_Identifier (Prev : Node_Id; Nxt : Token_Type);\n       --  Called when the previous token is an identifier (whose Token_Node"}]}