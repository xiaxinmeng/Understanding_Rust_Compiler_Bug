{"sha": "7b86458e38ee3c88ca4e222c85ef6fa883267315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I4NjQ1OGUzOGVlM2M4OGNhNGUyMjJjODVlZjZmYTg4MzI2NzMxNQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-09-14T14:23:44Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-09-14T14:23:44Z"}, "message": "regex.h (regex_match<>, [...]): Change regex_executor caller.\n\n2013-09-14  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h (regex_match<>, regex_search<>):\n\tChange regex_executor caller. Now use their return value instead\n\tof checking __m[0].matched to find out if it's successful.\n\t(regex_search<>): Move the search logic to regex_executor.\n\t* include/bits/regex_automaton.h: Add some new _Opcode. Refactor\n\t_NFA::_M_insert_*.\n\t* include/bits/regex_automaton.tcc: Add DEBUG dump for new\n\t_Opcode. Refactor _NFA::_M_insert_*.\n\t* include/bits/regex_compiler.h (_Compiler<>::_M_get_nfa):\n\tUse make_shared instead of construct by hand.\n\t* include/bits/regex_compiler.tcc: Implement _Compiler<>::_M_assertion.\n\t* include/bits/regex_constants.h: Fix indentation and line breaking.\n\t* include/bits/regex_executor.h: Add _ResultsEntry to support\n\tgreedy/ungreedy mode. Move regex_search logic here.\n\t* include/bits/regex_executor.tcc: Implement assertions and\n\tgreedy/ungreedy matching.\n\t* include/bits/regex_scanner.h: Add a new token _S_token_ungreedy.\n\t* include/bits/regex_scanner.tcc: Parse a new token _S_token_ungreedy.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc: New.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc: New.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc:\n\tFix comment.\n\nFrom-SVN: r202591", "tree": {"sha": "e9e7682ad565de0099407469cf75a3455639b6f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e7682ad565de0099407469cf75a3455639b6f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b86458e38ee3c88ca4e222c85ef6fa883267315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b86458e38ee3c88ca4e222c85ef6fa883267315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b86458e38ee3c88ca4e222c85ef6fa883267315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b86458e38ee3c88ca4e222c85ef6fa883267315/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "492d1e0ac5c5bae22a29c0e436b50603052f2c29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/492d1e0ac5c5bae22a29c0e436b50603052f2c29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/492d1e0ac5c5bae22a29c0e436b50603052f2c29"}], "stats": {"total": 1076, "additions": 769, "deletions": 307}, "files": [{"sha": "96891056ac7e397400cb8efaf5f52a8b4741abaf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -1,3 +1,28 @@\n+2013-09-14  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h (regex_match<>, regex_search<>):\n+\tChange regex_executor caller. Now use their return value instead\n+\tof checking __m[0].matched to find out if it's successful.\n+\t(regex_search<>): Move the search logic to regex_executor.\n+\t* include/bits/regex_automaton.h: Add some new _Opcode. Refactor\n+\t_NFA::_M_insert_*.\n+\t* include/bits/regex_automaton.tcc: Add DEBUG dump for new\n+\t_Opcode. Refactor _NFA::_M_insert_*.\n+\t* include/bits/regex_compiler.h (_Compiler<>::_M_get_nfa):\n+\tUse make_shared instead of construct by hand.\n+\t* include/bits/regex_compiler.tcc: Implement _Compiler<>::_M_assertion.\n+\t* include/bits/regex_constants.h: Fix indentation and line breaking.\n+\t* include/bits/regex_executor.h: Add _ResultsEntry to support\n+\tgreedy/ungreedy mode. Move regex_search logic here.\n+\t* include/bits/regex_executor.tcc: Implement assertions and\n+\tgreedy/ungreedy matching.\n+\t* include/bits/regex_scanner.h: Add a new token _S_token_ungreedy.\n+\t* include/bits/regex_scanner.tcc: Parse a new token _S_token_ungreedy.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc:\n+\tFix comment.\n+\n 2013-09-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/58415"}, {"sha": "659bee13120819e28ffc0142347149eb592baa7b", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -2106,14 +2106,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename, typename, typename, typename>\n \tfriend class __detail::_BFSExecutor;\n \n-      template<typename _Bp, typename _Ap, typename _Ch_type, typename _Rx_traits>\n+      template<typename _Bp, typename _Ap,\n+\ttypename _Ch_type, typename _Rx_traits>\n \tfriend bool\n \tregex_match(_Bp, _Bp, match_results<_Bp, _Ap>&,\n \t\t    const basic_regex<_Ch_type,\n \t\t    _Rx_traits>&,\n \t\t    regex_constants::match_flag_type);\n \n-      template<typename _Bp, typename _Ap, typename _Ch_type, typename _Rx_traits>\n+      template<typename _Bp, typename _Ap,\n+\ttypename _Ch_type, typename _Rx_traits>\n \tfriend bool\n \tregex_search(_Bp, _Bp, match_results<_Bp, _Ap>&,\n \t\t     const basic_regex<_Ch_type,\n@@ -2213,8 +2215,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n \treturn false;\n-      __detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match();\n-      if (__m.size() > 0 && __m[0].matched)\n+      if (__detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match())\n \t{\n \t  for (auto __it : __m)\n \t    if (!__it.matched)\n@@ -2373,29 +2374,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__re._M_automaton == nullptr)\n \treturn false;\n-      auto __cur = __first;\n-      // Continue when __cur == __last\n-      do\n+      if (__detail::__get_executor(__first, __last, __m, __re, __flags)\n+\t  ->_M_search())\n \t{\n-\t  __detail::__get_executor(__cur, __last, __m, __re, __flags)\n-\t    ->_M_search_from_first();\n-\t  if (__m.size() > 0 && __m[0].matched)\n-\t    {\n-\t      for (auto __it : __m)\n-\t\tif (!__it.matched)\n-\t\t  __it.first = __it.second = __last;\n-\t      __m.at(__m.size()).first = __first;\n-\t      __m.at(__m.size()).second = __m[0].first;\n-\t      __m.at(__m.size()+1).first = __m[0].second;\n-\t      __m.at(__m.size()+1).second = __last;\n-\t      __m.at(__m.size()).matched =\n-\t\t(__m.prefix().first != __m.prefix().second);\n-\t      __m.at(__m.size()+1).matched =\n-\t\t(__m.suffix().first != __m.suffix().second);\n-\t      return true;\n-\t    }\n+\t  for (auto __it : __m)\n+\t    if (!__it.matched)\n+\t      __it.first = __it.second = __last;\n+\t  __m.at(__m.size()).first = __first;\n+\t  __m.at(__m.size()).second = __m[0].first;\n+\t  __m.at(__m.size()+1).first = __m[0].second;\n+\t  __m.at(__m.size()+1).second = __last;\n+\t  __m.at(__m.size()).matched =\n+\t    (__m.prefix().first != __m.prefix().second);\n+\t  __m.at(__m.size()+1).matched =\n+\t    (__m.suffix().first != __m.suffix().second);\n+\t  return true;\n \t}\n-      while (__cur++ != __last);\n       return false;\n     }\n "}, {"sha": "94a14ce96aa0b16a0b12cf58bc5e3dcbb44f3d1d", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 71, "deletions": 45, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -51,14 +51,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// that represents the regular expression.\n   enum _Opcode\n   {\n-      _S_opcode_unknown       =   0,\n-      _S_opcode_alternative   =   1,\n-      _S_opcode_backref       =   2,\n-      _S_opcode_subexpr_begin =   4,\n-      _S_opcode_subexpr_end   =   5,\n-      _S_opcode_dummy         =   6,\n-      _S_opcode_match         = 100,\n-      _S_opcode_accept        = 255\n+      _S_opcode_unknown,\n+      _S_opcode_alternative,\n+      _S_opcode_backref,\n+      _S_opcode_line_begin_assertion,\n+      _S_opcode_line_end_assertion,\n+      _S_opcode_word_boundry,\n+      _S_opcode_subexpr_lookahead,\n+      _S_opcode_subexpr_begin,\n+      _S_opcode_subexpr_end,\n+      _S_opcode_dummy,\n+      _S_opcode_match,\n+      _S_opcode_accept,\n   };\n \n   template<typename _CharT, typename _TraitsT>\n@@ -72,35 +76,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT    _M_next;             // outgoing transition\n       union // Since they are mutually exclusive.\n       {\n-\t_StateIdT    _M_alt;            // for _S_opcode_alternative\n \tunsigned int _M_subexpr;        // for _S_opcode_subexpr_*\n \tunsigned int _M_backref_index;  // for _S_opcode_backref\n+\tstruct\n+\t{\n+\t  // for _S_opcode_alternative.\n+\t  _StateIdT  _M_quant_index;\n+\t  // for _S_opcode_alternative or _S_opcode_subexpr_lookahead\n+\t  _StateIdT  _M_alt;\n+\t  // for _S_opcode_word_boundry or _S_opcode_subexpr_lookahead or\n+\t  // quantifiers(ungreedy if set true)\n+\t  bool       _M_neg;\n+\t};\n       };\n-      _MatcherT    _M_matches;          // for _S_opcode_match\n+      _MatcherT      _M_matches;        // for _S_opcode_match\n \n       explicit _State(_OpcodeT __opcode)\n       : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n       { }\n \n-      _State(const _MatcherT& __m)\n-      : _M_opcode(_S_opcode_match), _M_next(_S_invalid_state_id),\n-\t_M_matches(__m)\n-      { }\n-\n-      _State(_OpcodeT __opcode, unsigned __index)\n-      : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n-      {\n-\tif (__opcode == _S_opcode_subexpr_begin\n-\t    || __opcode == _S_opcode_subexpr_end)\n-\t  _M_subexpr = __index;\n-\telse if (__opcode == _S_opcode_backref)\n-\t  _M_backref_index = __index;\n-      }\n-\n-      _State(_StateIdT __next, _StateIdT __alt)\n-      : _M_opcode(_S_opcode_alternative), _M_next(__next), _M_alt(__alt)\n-      { }\n-\n #ifdef _GLIBCXX_DEBUG\n       std::ostream&\n       _M_print(std::ostream& ostr) const;\n@@ -141,7 +135,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _NFA(_FlagT __f)\n       : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n-      _M_has_backref(false)\n+      _M_has_backref(false), _M_quant_count(0)\n       { }\n \n       _FlagT\n@@ -163,52 +157,83 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT\n       _M_insert_accept()\n       {\n-\tthis->push_back(_StateT(_S_opcode_accept));\n-\t_M_accepting_states.insert(this->size()-1);\n-\treturn this->size()-1;\n+\tauto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n+\t_M_accepting_states.insert(__ret);\n+\treturn __ret;\n       }\n \n       _StateIdT\n-      _M_insert_alt(_StateIdT __next, _StateIdT __alt)\n+      _M_insert_alt(_StateIdT __next, _StateIdT __alt, bool __neg)\n       {\n-\tthis->push_back(_StateT(__next, __alt));\n-\treturn this->size()-1;\n+\t_StateT __tmp(_S_opcode_alternative);\n+\t// It labels every quantifier to make greedy comparison easier in BFS\n+\t// approach.\n+\t__tmp._M_quant_index = _M_quant_count++;\n+\t__tmp._M_next = __next;\n+\t__tmp._M_alt = __alt;\n+\t__tmp._M_neg = __neg;\n+\treturn _M_insert_state(__tmp);\n       }\n \n       _StateIdT\n       _M_insert_matcher(_MatcherT __m)\n       {\n-\tthis->push_back(_StateT(__m));\n-\treturn this->size()-1;\n+\t_StateT __tmp(_S_opcode_match);\n+\t__tmp._M_matches = __m;\n+\treturn _M_insert_state(__tmp);\n       }\n \n       _StateIdT\n       _M_insert_subexpr_begin()\n       {\n \tauto __id = _M_subexpr_count++;\n \t_M_paren_stack.push_back(__id);\n-\tthis->push_back(_StateT(_S_opcode_subexpr_begin, __id));\n-\treturn this->size()-1;\n+\t_StateT __tmp(_S_opcode_subexpr_begin);\n+\t__tmp._M_subexpr = __id;\n+\treturn _M_insert_state(__tmp);\n       }\n \n       _StateIdT\n       _M_insert_subexpr_end()\n       {\n-\tthis->push_back(_StateT(_S_opcode_subexpr_end, _M_paren_stack.back()));\n+\t_StateT __tmp(_S_opcode_subexpr_end);\n+\t__tmp._M_subexpr = _M_paren_stack.back();\n \t_M_paren_stack.pop_back();\n-\treturn this->size()-1;\n+\treturn _M_insert_state(__tmp);\n       }\n \n       _StateIdT\n       _M_insert_backref(unsigned int __index);\n \n       _StateIdT\n-      _M_insert_dummy()\n+      _M_insert_line_begin()\n+      { return _M_insert_state(_StateT(_S_opcode_line_begin_assertion)); }\n+\n+      _StateIdT\n+      _M_insert_line_end()\n+      { return _M_insert_state(_StateT(_S_opcode_line_end_assertion)); }\n+\n+      _StateIdT\n+      _M_insert_word_bound(bool __neg)\n       {\n-\tthis->push_back(_StateT(_S_opcode_dummy));\n-\treturn this->size()-1;\n+\t_StateT __tmp(_S_opcode_word_boundry);\n+\t__tmp._M_neg = __neg;\n+\treturn _M_insert_state(__tmp);\n       }\n \n+      _StateIdT\n+      _M_insert_lookahead(_StateIdT __alt, bool __neg)\n+      {\n+\t_StateT __tmp(_S_opcode_subexpr_lookahead);\n+\t__tmp._M_alt = __alt;\n+\t__tmp._M_neg = __neg;\n+\treturn _M_insert_state(__tmp);\n+      }\n+\n+      _StateIdT\n+      _M_insert_dummy()\n+      { return _M_insert_state(_StateT(_S_opcode_dummy)); }\n+\n       _StateIdT\n       _M_insert_state(_StateT __s)\n       {\n@@ -230,6 +255,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _FlagT                    _M_flags;\n       _StateIdT                 _M_start_state;\n       _SizeT                    _M_subexpr_count;\n+      _SizeT                    _M_quant_count;\n       bool                      _M_has_backref;\n     };\n "}, {"sha": "13af984c273e910b81112b9ba99c71e3202b077d", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -80,6 +80,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t << __id << \" -> \" << _M_alt\n \t\t << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n \t  break;\n+\tcase _S_opcode_backref:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n+\t\t << _M_subexpr << \"\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_line_begin_assertion:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_BEGIN \\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_line_end_assertion:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_END \\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_word_boundry:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nWORD_BOUNDRY \"\n+\t\t << _M_neg << \"\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\t  break;\n+\tcase _S_opcode_subexpr_lookahead:\n+\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLOOK_AHEAD\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_next\n+\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+\t\t << __id << \" -> \" << _M_alt\n+\t\t << \" [label=\\\"<assert>\\\", tailport=\\\"n\\\"];\\n\";\n+\t  break;\n \tcase _S_opcode_subexpr_begin:\n \t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n \t\t << _M_subexpr << \"\\\"];\\n\"\n@@ -90,10 +115,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t << _M_subexpr << \"\\\"];\\n\"\n \t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n \t  break;\n-\tcase _S_opcode_backref:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n-\t\t << _M_subexpr << \"\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\tcase _S_opcode_dummy:\n \t  break;\n \tcase _S_opcode_match:\n \t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n@@ -102,8 +124,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_opcode_accept:\n \t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n \t  break;\n-\tcase _S_opcode_dummy:\n-\t  break;\n \tdefault:\n \t  _GLIBCXX_DEBUG_ASSERT(false);\n \t  break;\n@@ -141,8 +161,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (__index == __it)\n \t  __throw_regex_error(regex_constants::error_backref);\n       _M_has_backref = true;\n-      this->push_back(_StateT(_S_opcode_backref, __index));\n-      return this->size()-1;\n+      _StateT __tmp(_S_opcode_backref);\n+      __tmp._M_backref_index = __index;\n+      return _M_insert_state(__tmp);\n     }\n \n   template<typename _CharT, typename _TraitsT>\n@@ -152,7 +173,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       for (auto& __it : *this)\n \t{\n \t  while (__it._M_next >= 0 && (*this)[__it._M_next]._M_opcode\n-\t         == _S_opcode_dummy)\n+\t\t == _S_opcode_dummy)\n \t    __it._M_next = (*this)[__it._M_next]._M_next;\n \t  if (__it._M_opcode == _S_opcode_alternative)\n \t    while (__it._M_alt >= 0 && (*this)[__it._M_alt]._M_opcode"}, {"sha": "3b85d3a46c3b4e00986513d81427da452b348b99", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -56,7 +56,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::shared_ptr<_RegexT>\n       _M_get_nfa() const\n-      { return std::shared_ptr<_RegexT>(new _RegexT(_M_nfa)); }\n+      { return make_shared<_RegexT>(_M_nfa); }\n \n     private:\n       typedef _Scanner<_FwdIter>                              _ScannerT;"}, {"sha": "8dc779b68e176b51912b8ea89248412ba52c7e35", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -96,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __alt2._M_append(__end);\n \t  _M_stack.push(_StateSeqT(_M_nfa,\n \t\t\t\t   _M_nfa._M_insert_alt(__alt1._M_start,\n-\t\t\t\t\t\t        __alt2._M_start),\n+\t\t\t\t\t\t\t__alt2._M_start, false),\n \t\t\t\t   __end));\n \t}\n     }\n@@ -132,25 +132,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  // TODO Implement it.\n   template<typename _FwdIter, typename _CharT, typename _TraitsT>\n     bool\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_assertion()\n     {\n-      // temporary place holders.\n       if (_M_match_token(_ScannerT::_S_token_line_begin))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n+\t      _M_insert_line_begin()));\n       else if (_M_match_token(_ScannerT::_S_token_line_end))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n+\t      _M_insert_line_end()));\n       else if (_M_match_token(_ScannerT::_S_token_word_bound))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n-      else if (_M_match_token(_ScannerT::_S_token_neg_word_bound))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+\t// _M_value[0] == 'n' means it's negtive, say \"not word boundary\".\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n+\t      _M_insert_word_bound(_M_value[0] == 'n')));\n       else if (_M_match_token(_ScannerT::_S_token_subexpr_lookahead_begin))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n-      else if (_M_match_token(_ScannerT::_S_token_subexpr_neg_lookahead_begin))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_dummy()));\n+\t{\n+\t  auto __neg = _M_value[0] == 'n';\n+\t  this->_M_disjunction();\n+\t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n+\t    __throw_regex_error(regex_constants::error_paren);\n+\t  auto __tmp = _M_pop();\n+\t  __tmp._M_append(_M_nfa._M_insert_accept());\n+\t  _M_stack.push(\n+\t      _StateSeqT(\n+\t\t_M_nfa,\n+\t\t_M_nfa._M_insert_lookahead(__tmp._M_start, __neg)));\n+\t}\n       else\n \treturn false;\n       return true;\n@@ -161,40 +170,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_quantifier()\n     {\n-      if (_M_match_token(_ScannerT::_S_token_closure0))\n+      bool __neg = regex_constants::ECMAScript;\n+      auto __init = [this, &__neg]()\n \t{\n \t  if (_M_stack.empty())\n \t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  __neg = __neg && _M_match_token(_ScannerT::_S_token_opt);\n+\t};\n+      if (_M_match_token(_ScannerT::_S_token_closure0))\n+\t{\n+\t  __init();\n \t  auto __e = _M_pop();\n \t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t      __e._M_start));\n+\t\t\t\t\t\t      __e._M_start, __neg));\n \t  __e._M_append(__r);\n \t  _M_stack.push(__r);\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_closure1))\n \t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  __init();\n \t  auto __e = _M_pop();\n-\t  __e._M_append(_M_nfa._M_insert_alt(_S_invalid_state_id, __e._M_start));\n+\t  __e._M_append(_M_nfa._M_insert_alt(_S_invalid_state_id, __e._M_start,\n+\t\t\t\t\t     __neg));\n \t  _M_stack.push(__e);\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_opt))\n \t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  __init();\n \t  auto __e = _M_pop();\n \t  auto __end = _M_nfa._M_insert_dummy();\n \t  _StateSeqT __r(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t      __e._M_start));\n+\t\t\t\t\t\t      __e._M_start, __neg));\n \t  __e._M_append(__end);\n \t  __r._M_append(__end);\n \t  _M_stack.push(__r);\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_interval_begin))\n \t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  __init();\n \t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n \t    __throw_regex_error(regex_constants::error_badbrace);\n \t  _StateSeqT __r(_M_pop());\n@@ -206,23 +219,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (_M_match_token(_ScannerT::_S_token_comma))\n \t    if (_M_match_token(_ScannerT::_S_token_dup_count)) // {3,7}\n \t      {\n-\t        int __n = _M_cur_int_value(10) - __min_rep;\n-\t        if (__n < 0)\n-\t          __throw_regex_error(regex_constants::error_badbrace);\n-\t        auto __end = _M_nfa._M_insert_dummy();\n-\t        for (int __i = 0; __i < __n; ++__i)\n-\t          {\n+\t\tint __n = _M_cur_int_value(10) - __min_rep;\n+\t\tif (__n < 0)\n+\t\t  __throw_regex_error(regex_constants::error_badbrace);\n+\t\tauto __end = _M_nfa._M_insert_dummy();\n+\t\tfor (int __i = 0; __i < __n; ++__i)\n+\t\t  {\n \t\t    auto __tmp = __r._M_clone();\n-\t\t    __e._M_append(_StateSeqT(_M_nfa, _M_nfa.\n-\t\t\t_M_insert_alt(__tmp._M_start, __end), __tmp._M_end));\n-\t          }\n+\t\t    __e._M_append\n+\t\t      (_StateSeqT(_M_nfa,\n+\t\t\t\t  _M_nfa._M_insert_alt(__tmp._M_start,\n+\t\t\t\t\t\t       __end, __neg),\n+\t\t\t\t  __tmp._M_end));\n+\t\t  }\n \t\t__e._M_append(__end);\n \t      }\n \t    else // {3,}\n \t      {\n \t\tauto __tmp = __r._M_clone();\n-\t\t_StateSeqT __s(_M_nfa, _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t\t    __tmp._M_start));\n+\t\t_StateSeqT __s(_M_nfa,\n+\t\t\t       _M_nfa._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t    __tmp._M_start, __neg));\n \t\t__tmp._M_append(__s);\n \t\t__e._M_append(__s);\n \t      }"}, {"sha": "10b962ad21a2f655817236b42752b4a2e25765c5", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -78,87 +78,87 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * %set.\n    */\n   enum syntax_option_type : unsigned int\n-    {\n-      /**\n-       * Specifies that the matching of regular expressions against a character\n-       * sequence shall be performed without regard to case.\n-       */\n-      icase      = 1 << _S_icase,\n-\n-      /**\n-       * Specifies that when a regular expression is matched against a character\n-       * container sequence, no sub-expression matches are to be stored in the\n-       * supplied match_results structure.\n-       */\n-      nosubs     = 1 << _S_nosubs,\n-\n-      /**\n-       * Specifies that the regular expression engine should pay more attention to\n-       * the speed with which regular expressions are matched, and less to the\n-       * speed with which regular expression objects are constructed. Otherwise\n-       * it has no detectable effect on the program output.\n-       */\n-      optimize   = 1 << _S_optimize,\n-\n-      /**\n-       * Specifies that character ranges of the form [a-b] should be locale\n-       * sensitive.\n-       */\n-      collate    = 1 << _S_collate,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n-       * Language Specification, Standard Ecma-262, third edition, 1999], as\n-       * modified in section [28.13].  This grammar is similar to that defined\n-       * in the PERL scripting language but extended with elements found in the\n-       * POSIX regular expression grammar.\n-       */\n-      ECMAScript = 1 << _S_ECMAScript,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n-       * Portable Operating System Interface (POSIX), Base Definitions and\n-       * Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n-       * Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n-       */\n-      basic      = 1 << _S_basic,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n-       * Portable Operating System Interface (POSIX), Base Definitions and Headers,\n-       * Section 9, Regular Expressions.\n-       */\n-      extended   = 1 << _S_extended,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n-       * identical to syntax_option_type extended, except that C-style escape\n-       * sequences are supported.  These sequences are:\n-       * \\\\\\\\, \\\\a, \\\\b, \\\\f, \\\\n, \\\\r, \\\\t , \\\\v, \\\\&apos,, &apos,,\n-       * and \\\\ddd (where ddd is one, two, or three octal digits).\n-       */\n-      awk        = 1 << _S_awk,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n-       * identical to syntax_option_type basic, except that newlines are treated\n-       * as whitespace.\n-       */\n-      grep       = 1 << _S_grep,\n-\n-      /**\n-       * Specifies that the grammar recognized by the regular expression engine is\n-       * that used by POSIX utility grep when given the -E option in\n-       * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type\n-       * extended, except that newlines are treated as whitespace.\n-       */\n-      egrep      = 1 << _S_egrep,\n-    };\n+  {\n+    /**\n+     * Specifies that the matching of regular expressions against a character\n+     * sequence shall be performed without regard to case.\n+     */\n+    icase      = 1 << _S_icase,\n+\n+    /**\n+     * Specifies that when a regular expression is matched against a character\n+     * container sequence, no sub-expression matches are to be stored in the\n+     * supplied match_results structure.\n+     */\n+    nosubs     = 1 << _S_nosubs,\n+\n+    /**\n+     * Specifies that the regular expression engine should pay more attention to\n+     * the speed with which regular expressions are matched, and less to the\n+     * speed with which regular expression objects are constructed. Otherwise\n+     * it has no detectable effect on the program output.\n+     */\n+    optimize   = 1 << _S_optimize,\n+\n+    /**\n+     * Specifies that character ranges of the form [a-b] should be locale\n+     * sensitive.\n+     */\n+    collate    = 1 << _S_collate,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n+     * Language Specification, Standard Ecma-262, third edition, 1999], as\n+     * modified in section [28.13].  This grammar is similar to that defined\n+     * in the PERL scripting language but extended with elements found in the\n+     * POSIX regular expression grammar.\n+     */\n+    ECMAScript = 1 << _S_ECMAScript,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n+     * Portable Operating System Interface (POSIX), Base Definitions and\n+     * Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n+     * Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+     */\n+    basic      = 1 << _S_basic,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n+     * Portable Operating System Interface (POSIX), Base Definitions and\n+     * Headers, Section 9, Regular Expressions.\n+     */\n+    extended   = 1 << _S_extended,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n+     * identical to syntax_option_type extended, except that C-style escape\n+     * sequences are supported.  These sequences are:\n+     * \\\\\\\\, \\\\a, \\\\b, \\\\f, \\\\n, \\\\r, \\\\t , \\\\v, \\\\&apos,, &apos,,\n+     * and \\\\ddd (where ddd is one, two, or three octal digits).\n+     */\n+    awk        = 1 << _S_awk,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n+     * identical to syntax_option_type basic, except that newlines are treated\n+     * as whitespace.\n+     */\n+    grep       = 1 << _S_grep,\n+\n+    /**\n+     * Specifies that the grammar recognized by the regular expression engine is\n+     * that used by POSIX utility grep when given the -E option in\n+     * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type\n+     * extended, except that newlines are treated as whitespace.\n+     */\n+    egrep      = 1 << _S_egrep,\n+  };\n \n   constexpr inline syntax_option_type\n   operator&(syntax_option_type __a, syntax_option_type __b)"}, {"sha": "3df33e030245ef33e2daf022d724937bea19b2d3", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 180, "deletions": 48, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -66,33 +66,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       // Set matched when string exactly match the pattern.\n-      virtual void\n+      virtual bool\n       _M_match() = 0;\n \n       // Set matched when some prefix of the string matches the pattern.\n-      virtual void\n-      _M_search_from_first() = 0;\n+      virtual bool\n+      _M_search() = 0;\n \n     protected:\n       typedef typename _NFA<_CharT, _TraitsT>::_SizeT _SizeT;\n-      _Executor(_BiIter    __begin,\n-\t\t_BiIter    __end,\n-\t\t_ResultsT& __results,\n-\t\t_FlagT     __flags,\n-\t\t_SizeT     __size)\n-      : _M_current(__begin), _M_end(__end), _M_results(__results),\n-\t_M_flags(__flags)\n+      typedef typename _TraitsT::char_class_type      _ClassT;\n+\n+      _Executor(_BiIter         __begin,\n+\t\t_BiIter         __end,\n+\t\t_ResultsT&      __results,\n+\t\t_FlagT          __flags,\n+\t\t_SizeT          __size,\n+\t\tconst _TraitsT& __traits)\n+      : _M_current(__begin), _M_begin(__begin), _M_end(__end),\n+      _M_results(__results), _M_flags(__flags), _M_traits(__traits)\n       {\n \t__size += 2;\n \t_M_results.resize(__size);\n-\tfor (auto __i = 0; __i < __size; __i++)\n+\tfor (_SizeT __i = 0; __i < __size; ++__i)\n \t  _M_results[__i].matched = false;\n       }\n \n-      _BiIter       _M_current;\n-      _BiIter       _M_end;\n-      _ResultsVec&  _M_results;\n-      _FlagT        _M_flags;\n+      bool\n+      _M_is_word(_CharT __ch)\n+      {\n+\tstatic const _CharT __s = 'w';\n+\treturn _M_traits.isctype(__ch,\n+\t\t\t\t _M_traits.lookup_classname(&__s, &__s+1));\n+      }\n+\n+      _BiIter         _M_current;\n+      const _BiIter   _M_begin;\n+      const _BiIter   _M_end;\n+      _ResultsVec&    _M_results;\n+      const _TraitsT& _M_traits;\n+      _FlagT          _M_flags;\n     };\n \n   // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n@@ -126,26 +139,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t   const _RegexT&  __nfa,\n \t\t   const _TraitsT& __traits,\n \t\t   _FlagT          __flags)\n-      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n-\t_M_traits(__traits), _M_nfa(__nfa), _M_results_ret(this->_M_results)\n+      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count(),\n+\t       __traits),\n+\t_M_traits(__traits), _M_nfa(__nfa), _M_cur_results(this->_M_results),\n+\t_M_start_state(__nfa._M_start())\n       { }\n \n-      void\n+      bool\n       _M_match()\n-      { _M_dfs<true>(_M_nfa._M_start()); }\n+      {\n+\tthis->_M_current = this->_M_begin;\n+\treturn _M_dfs<true>(_M_start_state);\n+      }\n \n-      void\n+      bool\n       _M_search_from_first()\n-      { _M_dfs<false>(_M_nfa._M_start()); }\n+      {\n+\tthis->_M_current = this->_M_begin;\n+\treturn _M_dfs<false>(_M_start_state);\n+      }\n+\n+      bool\n+      _M_search()\n+      {\n+\tauto __cur = this->_M_begin;\n+\tdo\n+\t  {\n+\t    this->_M_current = __cur;\n+\t    if (_M_dfs<false>(_M_start_state))\n+\t      return true;\n+\t  }\n+\t// Continue when __cur == _M_end\n+\twhile (__cur++ != this->_M_end);\n+\treturn false;\n+      }\n \n     private:\n       template<bool __match_mode>\n \tbool\n \t_M_dfs(_StateIdT __i);\n \n-      _ResultsVec     _M_results_ret;\n+      // To record current solution.\n+      _ResultsVec     _M_cur_results;\n       const _TraitsT& _M_traits;\n       const _RegexT&  _M_nfa;\n+      _StateIdT       _M_start_state;\n     };\n \n   // Like the DFS approach, it try every possible state transition; Unlike DFS,\n@@ -170,35 +208,129 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n       typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n       typedef typename _BaseT::_ResultsT                   _ResultsT;\n-      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n-      typedef std::unique_ptr<_ResultsVec>                 _ResultsPtr;\n+      // Here's a solution for greedy/ungreedy mode in BFS approach. We need to\n+      // carefully work out how to compare to conflict matching states.\n+      //\n+      // A matching state is a pair(where, when); `where` is a NFA node; `when`\n+      // is a _BiIter, indicating which char is the next to be mathed one.  Two\n+      // matching states conflict means that they have equivalent `where` and\n+      // `when`.\n+      //\n+      // Now since we need to drop one and keep another, because at most one of\n+      // them could be the final optimal solution. This behavior is affected by\n+      // greedy policy.\n+      //\n+      // The definition of `greedy`:\n+      // For the sequence of quantifiers in NFA sorted by there start position,\n+      // now maintain a vector in a matching state, with equal length to\n+      // quantifier seq, recording repeating times of every quantifier. Now to\n+      // compare two matching states, we just lexically compare these two\n+      // vectors. To win the compare(to survive), one matching state needs to\n+      // make its greedy quantifier count larger, and ungreedy quantifiers\n+      // count smaller.\n+      //\n+      // In the implementation, we recorded negtive numbers for greedy\n+      // quantifiers and positive numbers of ungreedy ones. Now a simple\n+      // operator<() for lexicographical_compare will emit the answer.\n+      //\n+      // When two vectors equal, it means the `where`, `when` and quantifier\n+      // counts are identical, it indicates the same answer, so just return\n+      // false.\n+      struct _ResultsEntry\n+      : private _BaseT::_ResultsVec\n+      {\n+      public:\n+\t_ResultsEntry(unsigned int __res_sz, unsigned int __sz)\n+\t: _BaseT::_ResultsVec(__res_sz), _M_quant_keys(__sz)\n+\t{ }\n+\n+\tsub_match<_BiIter>&\n+\toperator[](unsigned int __idx)\n+\t{ return this->_BaseT::_ResultsVec::operator[](__idx); }\n+\n+\tbool\n+\toperator<(const _ResultsEntry& __rhs) const\n+\t{\n+\t  _GLIBCXX_DEBUG_ASSERT(_M_quant_keys.size()\n+\t\t\t\t== __rhs._M_quant_keys.size());\n+\t  return lexicographical_compare(_M_quant_keys.begin(),\n+\t\t\t\t\t _M_quant_keys.end(),\n+\t\t\t\t\t __rhs._M_quant_keys.begin(),\n+\t\t\t\t\t __rhs._M_quant_keys.end());\n+\t}\n+\n+\tvoid\n+\t_M_inc(unsigned int __idx, bool __neg)\n+\t{ _M_quant_keys[__idx] += __neg ? 1 : -1; }\n+\n+\ttypename _BaseT::_ResultsVec\n+\t_M_get()\n+\t{ return *this; }\n+\n+      public:\n+\tstd::vector<int> _M_quant_keys;\n+      };\n+\n+      typedef std::unique_ptr<_ResultsEntry>               _ResultsPtr;\n       typedef regex_constants::match_flag_type             _FlagT;\n \n-      _BFSExecutor(_BiIter        __begin,\n-\t\t   _BiIter        __end,\n-\t\t   _ResultsT&     __results,\n-\t\t   const _RegexT& __nfa,\n-\t\t   _FlagT         __flags)\n-      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n-\t_M_nfa(__nfa)\n-      {\n-\tif (_M_nfa._M_start() != _S_invalid_state_id)\n-\t  _M_covered[_M_nfa._M_start()] =\n-\t    _ResultsPtr(new _ResultsVec(this->_M_results));\n-\t_M_e_closure();\n-      }\n+      _BFSExecutor(_BiIter         __begin,\n+\t\t   _BiIter         __end,\n+\t\t   _ResultsT&      __results,\n+\t\t   const _RegexT&  __nfa,\n+\t\t   const _TraitsT& __traits,\n+\t\t   _FlagT          __flags)\n+      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count(),\n+\t       __traits),\n+\t_M_nfa(__nfa),\n+\t_M_cur_results(nullptr),\n+\t_M_start_state(__nfa._M_start())\n+      { }\n \n-      void\n+      bool\n       _M_match()\n-      { _M_main_loop<true>(); }\n+      {\n+\t_M_init(this->_M_begin);\n+\treturn _M_main_loop<true>();\n+      }\n \n-      void\n+      bool\n       _M_search_from_first()\n-      { _M_main_loop<false>(); }\n+      {\n+\t_M_init(this->_M_begin);\n+\treturn _M_main_loop<false>();\n+      }\n+\n+      bool\n+      _M_search()\n+      {\n+\tauto __cur = this->_M_begin;\n+\tdo\n+\t  {\n+\t    _M_init(__cur);\n+\t    if (_M_main_loop<false>())\n+\t      return true;\n+\t  }\n+\t// Continue when __cur == _M_end\n+\twhile (__cur++ != this->_M_end);\n+\treturn false;\n+      }\n \n     private:\n+      void\n+      _M_init(_BiIter __cur)\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_start_state != _S_invalid_state_id);\n+\tthis->_M_current = __cur;\n+\t_M_covered.clear();\n+\t_M_covered[_M_start_state] =\n+\t  _ResultsPtr(new _ResultsEntry(this->_M_results.size(),\n+\t\t\t\t\t_M_nfa._M_quant_count));\n+\t_M_e_closure();\n+      }\n+\n       template<bool __match_mode>\n-\tvoid\n+\tbool\n \t_M_main_loop();\n \n       void\n@@ -208,13 +340,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_move();\n \n       bool\n-      _M_match_less_than(const _ResultsVec& __u, const _ResultsVec& __v) const;\n-\n-      bool\n-      _M_includes_some() const;\n+      _M_includes_some();\n \n-      std::map<_StateIdT, _ResultsPtr>     _M_covered;\n-      const _RegexT&                       _M_nfa;\n+      std::map<_StateIdT, _ResultsPtr> _M_covered;\n+      // To record global optimal solution.\n+      _ResultsPtr                      _M_cur_results;\n+      const _RegexT&                   _M_nfa;\n+      _StateIdT                        _M_start_state;\n     };\n \n  //@} regex-detail"}, {"sha": "b110c5dc2f0ae5d35d1ada6c66e1a486cb7f1434", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 149, "deletions": 57, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -44,18 +44,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// This is not that certain. Need deeper investigate.\n \treturn false;\n       auto& __current = this->_M_current;\n+      auto& __begin = this->_M_begin;\n       auto& __end = this->_M_end;\n-      auto& __results = _M_results_ret;\n+      auto& __results = _M_cur_results;\n       const auto& __state = _M_nfa[__i];\n       bool __ret = false;\n       switch (__state._M_opcode)\n \t{\n \tcase _S_opcode_alternative:\n-\t  // Greedy mode by default. For non-greedy mode,\n-\t  // swap _M_alt and _M_next.\n-\t  // TODO: Add greedy mode option.\n-\t  __ret = _M_dfs<__match_mode>(__state._M_alt)\n-\t    || _M_dfs<__match_mode>(__state._M_next);\n+\t  // Greedy or not, this is a question ;)\n+\t  if (!__state._M_neg)\n+\t    __ret = _M_dfs<__match_mode>(__state._M_alt)\n+\t      || _M_dfs<__match_mode>(__state._M_next);\n+\t  else\n+\t    __ret = _M_dfs<__match_mode>(__state._M_next)\n+\t      || _M_dfs<__match_mode>(__state._M_alt);\n \t  break;\n \tcase _S_opcode_subexpr_begin:\n \t  // Here's the critical part: if there's nothing changed since last\n@@ -86,6 +89,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  else\n \t    __ret = _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n+\tcase _S_opcode_line_begin_assertion:\n+\t  if (__current == __begin)\n+\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  break;\n+\tcase _S_opcode_line_end_assertion:\n+\t  if (__current == __end)\n+\t    __ret = _M_dfs<__match_mode>(__state._M_next);\n+\t  break;\n+\t  // By definition.\n+\tcase _S_opcode_word_boundry:\n+\t    {\n+\t      bool __ans = false;\n+\t      if (__current == __begin && this->_M_is_word(*__current))\n+\t\t__ans = true;\n+\t      else if (__current == __end && this->_M_is_word(*__current))\n+\t\t__ans = true;\n+\t      else\n+\t\t{\n+\t\t  auto __pre = __current;\n+\t\t  --__pre;\n+\t\t  if (this->_M_is_word(*__current)\n+\t\t      != this->_M_is_word(*__pre))\n+\t\t    __ans = true;\n+\t\t}\n+\t      if (__ans == !__state._M_neg)\n+\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n+\t    }\n+\t  break;\n+\t  // Here __state._M_alt offers a single start node for a sub-NFA.\n+\t  // We recursivly invoke our algorithm to match the sub-NFA.\n+\tcase _S_opcode_subexpr_lookahead:\n+\t    {\n+\t      _ResultsT __m;\n+\t      // FIXME Here's not necessarily a DFSExecutor. But we need to\n+\t      // refactor the whole NFA to a recursive tree structure first.\n+\t      _DFSExecutor __sub(this->_M_current,\n+\t\t\t\t this->_M_end,\n+\t\t\t\t __m,\n+\t\t\t\t this->_M_nfa,\n+\t\t\t\t this->_M_traits,\n+\t\t\t\t this->_M_flags);\n+\t      __sub._M_start_state = __state._M_alt;\n+\t      if (__sub._M_search_from_first() == !__state._M_neg)\n+\t\t__ret = _M_dfs<__match_mode>(__state._M_next);\n+\t    }\n+\t  break;\n \tcase _S_opcode_match:\n \t  if (__current != __end && __state._M_matches(*__current))\n \t    {\n@@ -138,19 +187,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n   template<bool __match_mode>\n-    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n     _M_main_loop()\n     {\n+      bool __ret = false;\n       while (this->_M_current != this->_M_end)\n \t{\n \t  if (!__match_mode)\n-\t    if (_M_includes_some())\n-\t      return;\n+\t    // To keep regex_search greedy, no \"return true\" here.\n+\t    __ret = _M_includes_some() || __ret;\n \t  _M_move();\n \t  ++this->_M_current;\n \t  _M_e_closure();\n \t}\n-      _M_includes_some();\n+      __ret = _M_includes_some() || __ret;\n+      if (__ret)\n+\tthis->_M_results = _M_cur_results->_M_get();\n+      return __ret;\n     }\n \n   template<typename _BiIter, typename _Alloc,\n@@ -161,6 +214,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto& __current = this->_M_current;\n       std::queue<_StateIdT> __q;\n       std::vector<bool> __in_q(_M_nfa.size(), false);\n+      auto& __begin = this->_M_begin;\n+      auto& __end = this->_M_end;\n+\n       for (auto& __it : _M_covered)\n \t{\n \t  __in_q[__it.first] = true;\n@@ -173,18 +229,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __in_q[__u] = false;\n \t  const auto& __state = _M_nfa[__u];\n \n-\t  // Can be implemented using method, but there're too much arguments.\n-\t  // I would use macro function before C++11, but lambda is a better\n-\t  // choice, since hopefully compiler can inline it.\n+\t  // Can be implemented using method, but there will be too many\n+\t  // arguments. I would use macro function before C++11, but lambda is\n+\t  // a better choice, since hopefully compiler can inline it.\n \t  auto __add_visited_state = [&](_StateIdT __v)\n \t  {\n \t    if (__v == _S_invalid_state_id)\n \t      return;\n \t    if (_M_covered.count(__u) != 0\n \t\t&& (_M_covered.count(__v) == 0\n-\t\t    || _M_match_less_than(*_M_covered[__u], *_M_covered[__v])))\n+\t\t    || *_M_covered[__u] < *_M_covered[__v]))\n \t      {\n-\t\t_M_covered[__v] = _ResultsPtr(new _ResultsVec(*_M_covered[__u]));\n+\t\t_M_covered[__v] =\n+\t\t  _ResultsPtr(new _ResultsEntry(*_M_covered[__u]));\n \t\t// if a state is updated, it's outgoing neighbors should be\n \t\t// reconsidered too. Push them to the queue.\n \t\tif (!__in_q[__v])\n@@ -195,19 +252,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      }\n \t  };\n \n+\t  // Identical to DFS's switch part.\n \t  switch (__state._M_opcode)\n \t    {\n+\t      // Needs to maintain quantifier count vector here. A quantifier\n+\t      // must be concerned with a alt node.\n \t      case _S_opcode_alternative:\n-\t\t__add_visited_state(__state._M_next);\n-\t\t__add_visited_state(__state._M_alt);\n+\t\t{\n+\t\t  __add_visited_state(__state._M_next);\n+\t\t  auto __back =\n+\t\t    _M_covered[__u]->_M_quant_keys[__state._M_quant_index];\n+\t\t  _M_covered[__u]->_M_inc(__state._M_quant_index,\n+\t\t\t\t\t  __state._M_neg);\n+\t\t  __add_visited_state(__state._M_alt);\n+\t\t  _M_covered[__u]->_M_quant_keys[__state._M_quant_index]\n+\t\t    = __back;\n+\t\t}\n \t\tbreak;\n \t      case _S_opcode_subexpr_begin:\n \t\t{\n-\t\t  auto& __cu = *_M_covered[__u];\n-\t\t  auto __back = __cu[__state._M_subexpr].first;\n-\t\t  __cu[__state._M_subexpr].first = __current;\n-\t\t  __add_visited_state(__state._M_next);\n-\t\t  __cu[__state._M_subexpr].first = __back;\n+\t\t  auto& __sub = (*_M_covered[__u])[__state._M_subexpr];\n+\t\t  if (!__sub.matched || __sub.first != __current)\n+\t\t    {\n+\t\t      auto __back = __sub.first;\n+\t\t      __sub.first = __current;\n+\t\t      __add_visited_state(__state._M_next);\n+\t\t      __sub.first = __back;\n+\t\t    }\n \t\t}\n \t\tbreak;\n \t      case _S_opcode_subexpr_end:\n@@ -220,10 +291,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  __cu[__state._M_subexpr] = __back;\n \t\t}\n \t\tbreak;\n+\t      case _S_opcode_line_begin_assertion:\n+\t\tif (__current == __begin)\n+\t\t  __add_visited_state(__state._M_next);\n+\t\tbreak;\n+\t      case _S_opcode_line_end_assertion:\n+\t\tif (__current == __end)\n+\t\t  __add_visited_state(__state._M_next);\n+\t\tbreak;\n+\t      case _S_opcode_word_boundry:\n+\t\t  {\n+\t\t    bool __ans = false;\n+\t\t    if (__current == __begin && this->_M_is_word(*__current))\n+\t\t      __ans = true;\n+\t\t    else if (__current == __end && this->_M_is_word(*__current))\n+\t\t      __ans = true;\n+\t\t    else\n+\t\t      {\n+\t\t\tauto __pre = __current;\n+\t\t\t--__pre;\n+\t\t\tif (this->_M_is_word(*__current)\n+\t\t\t    != this->_M_is_word(*__pre))\n+\t\t\t  __ans = true;\n+\t\t      }\n+\t\t    if (__ans == !__state._M_neg)\n+\t\t      __add_visited_state(__state._M_next);\n+\t\t  }\n+\t\tbreak;\n+\t      case _S_opcode_subexpr_lookahead:\n+\t\t  {\n+\t\t    _ResultsT __m;\n+\t\t    // Same comment as in DFS.\n+\t\t    _BFSExecutor __sub(this->_M_current,\n+\t\t\t\t       this->_M_end,\n+\t\t\t\t       __m,\n+\t\t\t\t       this->_M_nfa,\n+\t\t\t\t       this->_M_traits,\n+\t\t\t\t       this->_M_flags);\n+\t\t    __sub._M_start_state = __state._M_alt;\n+\t\t    if (__sub._M_search_from_first() == !__state._M_neg)\n+\t\t      __add_visited_state(__state._M_next);\n+\t\t  }\n+\t\tbreak;\n \t      case _S_opcode_match:\n \t\tbreak;\n \t      case _S_opcode_accept:\n-\t\t__add_visited_state(__state._M_next);\n \t\tbreak;\n \t      default:\n \t\t_GLIBCXX_DEBUG_ASSERT(false);\n@@ -244,7 +356,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      && __state._M_matches(*this->_M_current))\n \t    if (__state._M_next != _S_invalid_state_id)\n \t      if (__next.count(__state._M_next) == 0\n-\t\t  || _M_match_less_than(*__it.second, *__next[__state._M_next]))\n+\t\t  || *__it.second < *__next[__state._M_next])\n \t\t__next[__state._M_next] = move(__it.second);\n \t}\n       _M_covered = move(__next);\n@@ -253,37 +365,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_match_less_than(const _ResultsVec& __u, const _ResultsVec& __v) const\n-    {\n-      // TODO: Greedy and Non-greedy support\n-      _GLIBCXX_DEBUG_ASSERT(__u.size() == __v.size());\n-      auto __size = __u.size();\n-      for (auto __i = 0; __i < __size; __i++)\n-\t{\n-\t  auto __uit = __u[__i], __vit = __v[__i];\n-\t  if (__uit.matched && !__vit.matched)\n-\t    return true;\n-\t  if (!__uit.matched && __vit.matched)\n-\t    return false;\n-\t  if (__uit.matched && __vit.matched)\n-\t    {\n-\t      // GREEDY\n-\t      if (__uit.first != __vit.first)\n-\t\treturn __uit.first < __vit.first;\n-\t      if (__uit.second != __vit.second)\n-\t\treturn __uit.second > __vit.second;\n-\t    }\n-\t}\n-      return false;\n-    }\n-\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_includes_some() const\n+    _M_includes_some()\n     {\n       auto& __s = _M_nfa._M_final_states();\n       auto& __t = _M_covered;\n+      bool __succ = false;\n       if (__s.size() > 0 && __t.size() > 0)\n \t{\n \t  auto __first = __s.begin();\n@@ -292,16 +378,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    {\n \t      if (*__first < __second->first)\n \t\t++__first;\n-\t      else if (__second->first < *__first)\n+\t      else if (*__first > __second->first)\n \t\t++__second;\n \t      else\n \t\t{\n-\t\t  this->_M_results = *__second->second;\n-\t\t  return true;\n+\t\t  if (_M_cur_results == nullptr\n+\t\t      || *__second->second < *_M_cur_results)\n+\t\t    _M_cur_results =\n+\t\t      _ResultsPtr(new _ResultsEntry(*__second->second));\n+\t\t  __succ = true;\n+\t\t  ++__first;\n+\t\t  ++__second;\n \t\t}\n \t    }\n \t}\n-      return false;\n+      return __succ;\n     }\n \n   template<typename _BiIter, typename _Alloc,\n@@ -322,7 +413,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__p->_M_has_backref)\n \treturn _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p,\n \t\t\t\t\t      __re._M_traits, __flags));\n-      return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, *__p, __flags));\n+      return _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, *__p,\n+\t\t\t\t\t    __re._M_traits, __flags));\n     }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "824d6ce1081513387cb8135985065a6d9ddac249", "filename": "libstdc++-v3/include/bits/regex_scanner.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.h?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -69,7 +69,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_subexpr_begin,\n \t_S_token_subexpr_no_group_begin,\n \t_S_token_subexpr_lookahead_begin,\n-\t_S_token_subexpr_neg_lookahead_begin,\n \t_S_token_subexpr_end,\n \t_S_token_bracket_begin,\n \t_S_token_bracket_neg_begin,\n@@ -84,10 +83,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_or,\n \t_S_token_closure0,\n \t_S_token_closure1,\n+\t_S_token_ungreedy,\n \t_S_token_line_begin,\n \t_S_token_line_end,\n \t_S_token_word_bound,\n-\t_S_token_neg_word_bound,\n \t_S_token_comma,\n \t_S_token_dup_count,\n \t_S_token_eof,"}, {"sha": "4b66157278b1691f4027838c056aa870580ed0cb", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -210,11 +210,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t{\n \t\t  ++_M_current;\n \t\t  _M_token = _S_token_subexpr_lookahead_begin;\n+\t\t  _M_value.assign(1, 'p');\n \t\t}\n \t      else if (*_M_current == '!')\n \t\t{\n \t\t  ++_M_current;\n-\t\t  _M_token = _S_token_subexpr_neg_lookahead_begin;\n+\t\t  _M_token = _S_token_subexpr_lookahead_begin;\n+\t\t  _M_value.assign(1, 'n');\n \t\t}\n \t      else\n \t\t__throw_regex_error(regex_constants::error_paren);\n@@ -371,9 +373,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_value.assign(1, _M_escape_map.at(__c));\n \t}\n       else if (__c == 'b')\n-\t_M_token = _S_token_word_bound;\n+\t{\n+\t  _M_token = _S_token_word_bound;\n+\t  _M_value.assign(1, 'p');\n+\t}\n       else if (__c == 'B')\n-\t_M_token = _S_token_neg_word_bound;\n+\t{\n+\t  _M_token = _S_token_word_bound;\n+\t  _M_value.assign(1, 'n');\n+\t}\n       // N3376 28.13\n       else if (__c == 'd'\n \t       || __c == 'D'\n@@ -581,9 +589,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       case _S_token_subexpr_lookahead_begin:\n \tostr << \"lookahead subexpr begin\\n\";\n \tbreak;\n-      case _S_token_subexpr_neg_lookahead_begin:\n-\tostr << \"neg lookahead subexpr begin\\n\";\n-\tbreak;\n       case _S_token_subexpr_end:\n \tostr << \"subexpr end\\n\";\n \tbreak;"}, {"sha": "82e99058743cd2aee8ebbd62a8a438448ff4a9d5", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/assertion.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fassertion.cc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2013-09-14  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.3 regex_search\n+// Tests ECMAScript assertion.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(!regex_search(\"2123456\", regex(\"^1234\")));\n+  VERIFY(regex_search(\"123456\", regex(\"^1234\")));\n+  VERIFY(regex_search(\"123456\", regex(\"(5|^)1234\")));\n+  VERIFY(regex_search(\"5123456\", regex(\"(5|^)1234\")));\n+  VERIFY(!regex_search(\"1234562\", regex(\"3456$\")));\n+  VERIFY(regex_search(\"123456\", regex(\"3456$\")));\n+  VERIFY(!regex_search(\"123456\", regex(\"(?=1234)56\")));\n+  VERIFY(regex_search(\"123456\", regex(\"(?=1234)123456\")));\n+  VERIFY(regex_search(\"123456\", regex(\"(?!1234)56\")));\n+  VERIFY(!regex_search(\"123456\", regex(\"(?!1234)123456\")));\n+\n+  VERIFY(regex_search(\"a-\", regex(\"a\\\\b-\")));\n+  VERIFY(!regex_search(\"ab\", regex(\"a\\\\bb\")));\n+  VERIFY(!regex_search(\"a-\", regex(\"a\\\\B-\")));\n+  VERIFY(regex_search(\"ab\", regex(\"a\\\\Bb\")));\n+\n+  string s(\"This is a regular expression\");\n+  string sol[] =\n+    {\n+      \"This\",\n+      \"is\",\n+      \"a\",\n+      \"regular\",\n+      \"expression\",\n+    };\n+\n+  regex re(\"\\\\b\\\\w*\\\\b\");\n+  int i = 0;\n+  for (auto it = sregex_iterator(s.begin(), s.end(), re);\n+       it != sregex_iterator() && i < 5;\n+       ++it)\n+    {\n+      string s((*it)[0].first, (*it)[0].second);\n+      VERIFY(s == sol[i++]);\n+    }\n+  VERIFY(i == 5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ad37ec8649a80959bc03f05b16030857b434681b", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -0,0 +1,71 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-14  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.3 regex_search\n+// Tests ECMAScript greedy and ungreedy quantifiers.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  cmatch m;\n+#define TEST(i, s) VERIFY(m[i].matched && string(m[i].first, m[i].second) == s)\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"a*\")));\n+  TEST(0, \"aaaa\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"a*?\")));\n+  TEST(0, \"\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"a+\")));\n+  TEST(0, \"aaaa\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"a+?\")));\n+  TEST(0, \"a\");\n+  VERIFY(regex_search(\"a\", m, regex(\"a?\")));\n+  TEST(0, \"a\");\n+  VERIFY(regex_search(\"a\", m, regex(\"a??\")));\n+  TEST(0, \"\");\n+  VERIFY(regex_search(\"\", m, regex(\"a??\")));\n+  TEST(0, \"\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"(a+)(a+)\")));\n+  TEST(1, \"aaa\");\n+  TEST(2, \"a\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"(a+?)(a+)\")));\n+  TEST(1, \"a\");\n+  TEST(2, \"aaa\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"(a+?)(a+)\")));\n+  TEST(1, \"a\");\n+  TEST(2, \"aaa\");\n+  VERIFY(regex_search(\"aaaa\", m, regex(\"(a+?)(a+?)\")));\n+  TEST(1, \"a\");\n+  TEST(2, \"a\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ec25875fdee07d712f511bec7278e150f6311795", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/string_01.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b86458e38ee3c88ca4e222c85ef6fa883267315/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fstring_01.cc?ref=7b86458e38ee3c88ca4e222c85ef6fa883267315", "patch": "@@ -21,7 +21,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // 28.11.3 regex_search\n-// Tests BRE against a std::string target.\n+// Tests ECMAScript against a std::string target.\n \n #include <regex>\n #include <testsuite_hooks.h>"}]}