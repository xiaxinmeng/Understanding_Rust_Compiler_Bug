{"sha": "6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQwOThjNTcyYWVmODcwZjZhMDY4ZDdlNjY5N2ZkZTVhNGVkMmNjYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-22T10:44:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-22T10:44:02Z"}, "message": "tree-vectorizer.h (_loop_vec_info): Add scalar_cost_vec and single_scalar_iteration_cost members.\n\n2015-06-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_loop_vec_info): Add scalar_cost_vec\n\tand single_scalar_iteration_cost members.\n\t(LOOP_VINFO_SCALAR_ITERATION_COST): New.\n\t(LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST): Likewise.\n\t(vect_get_single_scalar_iteration_cost): Remove.\n\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost):\n\tUse LOOP_VINFO_SCALAR_ITERATION_COST.\n\t* tree-vect-loop.c (destroy_loop_vec_info): Free\n\tscalar_cost_vec.\n\t(vect_get_single_scalar_iteration_cost): Compute result into\n\tLOOP_VINFO_SINGLE_SCALAR_ITERATION_COST and\n\tLOOP_VINFO_SCALAR_ITERATION_COST.  Make static.\n\t(vect_analyze_loop_2): Call vect_get_single_scalar_iteration_cost.\n\t(vect_estimate_min_profitable_iters): Use them.\n\nFrom-SVN: r224723", "tree": {"sha": "0e00bc071e7f538a73a3b51455376d755bd38499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e00bc071e7f538a73a3b51455376d755bd38499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "606e3099e8fb81ab22e046421a6fe5a7338b2cd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606e3099e8fb81ab22e046421a6fe5a7338b2cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606e3099e8fb81ab22e046421a6fe5a7338b2cd7"}], "stats": {"total": 181, "additions": 104, "deletions": 77}, "files": [{"sha": "9dc3b9159e405cfc68de15e59abaed8a360ec9b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "patch": "@@ -1,3 +1,20 @@\n+2015-06-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_loop_vec_info): Add scalar_cost_vec\n+\tand single_scalar_iteration_cost members.\n+\t(LOOP_VINFO_SCALAR_ITERATION_COST): New.\n+\t(LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST): Likewise.\n+\t(vect_get_single_scalar_iteration_cost): Remove.\n+\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost):\n+\tUse LOOP_VINFO_SCALAR_ITERATION_COST.\n+\t* tree-vect-loop.c (destroy_loop_vec_info): Free\n+\tscalar_cost_vec.\n+\t(vect_get_single_scalar_iteration_cost): Compute result into\n+\tLOOP_VINFO_SINGLE_SCALAR_ITERATION_COST and\n+\tLOOP_VINFO_SCALAR_ITERATION_COST.  Make static.\n+\t(vect_analyze_loop_2): Call vect_get_single_scalar_iteration_cost.\n+\t(vect_estimate_min_profitable_iters): Use them.\n+\n 2015-06-22  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/52144"}, {"sha": "ae474566992bd4fdf2201fa0a08f531e24897474", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "patch": "@@ -1165,11 +1165,10 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n       SET_DR_MISALIGNMENT (dr, save_misalignment);\n     }\n \n-  auto_vec<stmt_info_for_cost> scalar_cost_vec;\n-  vect_get_single_scalar_iteration_cost (loop_vinfo, &scalar_cost_vec);\n   outside_cost += vect_get_known_peeling_cost\n     (loop_vinfo, elem->npeel, &dummy,\n-     &scalar_cost_vec, &prologue_cost_vec, &epilogue_cost_vec);\n+     &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+     &prologue_cost_vec, &epilogue_cost_vec);\n \n   /* Prologue and epilogue costs are added to the target model later.\n      These costs depend only on the scalar iteration cost, the"}, {"sha": "1256fe2acf3f5e2d41e33870e0adf24876b17faa", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 77, "deletions": 72, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "patch": "@@ -1095,12 +1095,82 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   LOOP_VINFO_PEELING_HTAB (loop_vinfo) = NULL;\n \n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+  loop_vinfo->scalar_cost_vec.release ();\n \n   free (loop_vinfo);\n   loop->aux = NULL;\n }\n \n \n+/* Calculate the cost of one scalar iteration of the loop.  */\n+static void\n+vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes, factor, scalar_single_iter_cost = 0;\n+  int innerloop_iters, i;\n+\n+  /* Count statements in scalar loop.  Using this as scalar cost for a single\n+     iteration for now.\n+\n+     TODO: Add outer loop support.\n+\n+     TODO: Consider assigning different costs to different scalar\n+     statements.  */\n+\n+  /* FORNOW.  */\n+  innerloop_iters = 1;\n+  if (loop->inner)\n+    innerloop_iters = 50; /* FIXME */\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      gimple_stmt_iterator si;\n+      basic_block bb = bbs[i];\n+\n+      if (bb->loop_father == loop->inner)\n+        factor = innerloop_iters;\n+      else\n+        factor = 1;\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+        {\n+          gimple stmt = gsi_stmt (si);\n+          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+          if (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n+            continue;\n+\n+          /* Skip stmts that are not vectorized inside the loop.  */\n+          if (stmt_info\n+              && !STMT_VINFO_RELEVANT_P (stmt_info)\n+              && (!STMT_VINFO_LIVE_P (stmt_info)\n+                  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n+\t      && !STMT_VINFO_IN_PATTERN_P (stmt_info))\n+            continue;\n+\n+\t  vect_cost_for_stmt kind;\n+          if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n+            {\n+              if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n+               kind = scalar_load;\n+             else\n+               kind = scalar_store;\n+            }\n+          else\n+            kind = scalar_stmt;\n+\n+\t  scalar_single_iter_cost\n+\t    += record_stmt_cost (&LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+\t\t\t\t factor, kind, NULL, 0, vect_prologue);\n+        }\n+    }\n+  LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo)\n+    = scalar_single_iter_cost;\n+}\n+\n+\n /* Function vect_analyze_loop_1.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n@@ -1834,6 +1904,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* Compute the scalar iteration cost.  */\n+  vect_get_single_scalar_iteration_cost (loop_vinfo);\n+\n   /* This pass will decide on using loop versioning and/or loop peeling in\n      order to enhance the alignment of data references in the loop.  */\n \n@@ -2706,74 +2779,6 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple phi,\n \t\t\t\t     double_reduc, true);\n }\n \n-/* Calculate the cost of one scalar iteration of the loop.  */\n-int\n-vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo,\n-\t\t\t\t       stmt_vector_for_cost *scalar_cost_vec)\n-{\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  int nbbs = loop->num_nodes, factor, scalar_single_iter_cost = 0;\n-  int innerloop_iters, i;\n-\n-  /* Count statements in scalar loop.  Using this as scalar cost for a single\n-     iteration for now.\n-\n-     TODO: Add outer loop support.\n-\n-     TODO: Consider assigning different costs to different scalar\n-     statements.  */\n-\n-  /* FORNOW.  */\n-  innerloop_iters = 1;\n-  if (loop->inner)\n-    innerloop_iters = 50; /* FIXME */\n-\n-  for (i = 0; i < nbbs; i++)\n-    {\n-      gimple_stmt_iterator si;\n-      basic_block bb = bbs[i];\n-\n-      if (bb->loop_father == loop->inner)\n-        factor = innerloop_iters;\n-      else\n-        factor = 1;\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-        {\n-          gimple stmt = gsi_stmt (si);\n-          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n-          if (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n-            continue;\n-\n-          /* Skip stmts that are not vectorized inside the loop.  */\n-          if (stmt_info\n-              && !STMT_VINFO_RELEVANT_P (stmt_info)\n-              && (!STMT_VINFO_LIVE_P (stmt_info)\n-                  || !VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n-\t      && !STMT_VINFO_IN_PATTERN_P (stmt_info))\n-            continue;\n-\n-\t  vect_cost_for_stmt kind;\n-          if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n-            {\n-              if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n-               kind = scalar_load;\n-             else\n-               kind = scalar_store;\n-            }\n-          else\n-            kind = scalar_stmt;\n-\n-\t  scalar_single_iter_cost\n-\t    += record_stmt_cost (scalar_cost_vec, factor, kind,\n-\t\t\t\t NULL, 0, vect_prologue);\n-        }\n-    }\n-  return scalar_single_iter_cost;\n-}\n-\n /* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n int\n vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n@@ -2901,9 +2906,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      TODO: Consider assigning different costs to different scalar\n      statements.  */\n \n-  auto_vec<stmt_info_for_cost> scalar_cost_vec;\n   scalar_single_iter_cost\n-     = vect_get_single_scalar_iteration_cost (loop_vinfo, &scalar_cost_vec);\n+    = LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo);\n \n   /* Add additional cost for the peeled instructions in prologue and epilogue\n      loop.\n@@ -2941,7 +2945,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t    NULL, 0, vect_epilogue);\n       stmt_info_for_cost *si;\n       int j;\n-      FOR_EACH_VEC_ELT (scalar_cost_vec, j, si)\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n \t{\n \t  struct _stmt_vec_info *stmt_info\n \t    = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n@@ -2968,7 +2972,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n       (void) vect_get_known_peeling_cost (loop_vinfo, peel_iters_prologue,\n \t\t\t\t\t  &peel_iters_epilogue,\n-\t\t\t\t\t  &scalar_cost_vec,\n+\t\t\t\t\t  &LOOP_VINFO_SCALAR_ITERATION_COST\n+\t\t\t\t\t    (loop_vinfo),\n \t\t\t\t\t  &prologue_cost_vec,\n \t\t\t\t\t  &epilogue_cost_vec);\n "}, {"sha": "d3e788b878536c4156f841dec2156c1ff7792f63", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d098c572aef870f6a068d7e6697fde5a4ed2ccc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6d098c572aef870f6a068d7e6697fde5a4ed2ccc", "patch": "@@ -328,6 +328,12 @@ typedef struct _loop_vec_info {\n   /* Hash table used to choose the best peeling option.  */\n   hash_table<peel_info_hasher> *peeling_htab;\n \n+  /* Cost vector for a single scalar iteration.  */\n+  vec<stmt_info_for_cost> scalar_cost_vec;\n+\n+  /* Cost of a single scalar iteration.  */\n+  int single_scalar_iteration_cost;\n+\n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;\n \n@@ -406,6 +412,8 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_PEELING_FOR_NITER(L)    (L)->peeling_for_niter\n #define LOOP_VINFO_NO_DATA_DEPENDENCIES(L) (L)->no_data_dependencies\n #define LOOP_VINFO_SCALAR_LOOP(L)\t   (L)->scalar_loop\n+#define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n+#define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n   ((L)->may_misalign_stmts.length () > 0)\n@@ -1101,8 +1109,6 @@ extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *);\n-extern int vect_get_single_scalar_iteration_cost (loop_vec_info,\n-\t\t\t\t\t\t  stmt_vector_for_cost *);\n \n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);"}]}