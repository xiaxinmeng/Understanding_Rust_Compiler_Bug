{"sha": "f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA3NWJkOTUwYzVhZDNlMmJhZWIzZDhmODJmZTk2MmVmYzhlNGY3YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T06:58:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T06:58:16Z"}, "message": "poly_int: frame allocations\n\nThis patch converts the frame allocation code (mostly in function.c)\nto use poly_int64 rather than HOST_WIDE_INT for frame offsets and\nsizes.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* function.h (frame_space): Change start and length from HOST_WIDE_INT\n\tto poly_int64.\n\t(get_frame_size): Return the size as a poly_int64 rather than a\n\tHOST_WIDE_INT.\n\t(frame_offset_overflow): Take the offset as a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(assign_stack_local_1, assign_stack_local, assign_stack_temp_for_type)\n\t(assign_stack_temp): Likewise for the size.\n\t* function.c (get_frame_size): Return a poly_int64 rather than\n\ta HOST_WIDE_INT.\n\t(frame_offset_overflow): Take the offset as a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(try_fit_stack_local): Take the start, length and size as poly_int64s\n\trather than HOST_WIDE_INTs.  Return the offset as a poly_int64_pod\n\trather than a HOST_WIDE_INT.\n\t(add_frame_space): Take the start and end as poly_int64s rather than\n\tHOST_WIDE_INTs.\n\t(assign_stack_local_1, assign_stack_local, assign_stack_temp_for_type)\n\t(assign_stack_temp): Likewise for the size.\n\t(temp_slot): Change size, base_offset and full_size from HOST_WIDE_INT\n\tto poly_int64.\n\t(find_temp_slot_from_address): Handle polynomial offsets.\n\t(combine_temp_slots): Likewise.\n\t* emit-rtl.h (rtl_data::x_frame_offset): Change from HOST_WIDE_INT\n\tto poly_int64.\n\t* cfgexpand.c (alloc_stack_frame_space): Return the offset as a\n\tpoly_int64 rather than a HOST_WIDE_INT.\n\t(expand_one_stack_var_at): Take the offset as a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(expand_stack_vars, expand_one_stack_var_1, expand_used_vars): Handle\n\tpolynomial frame offsets.\n\t* config/m32r/m32r-protos.h (m32r_compute_frame_size): Take the size\n\tas a poly_int64 rather than an int.\n\t* config/m32r/m32r.c (m32r_compute_frame_size): Likewise.\n\t* config/v850/v850-protos.h (compute_frame_size): Likewise.\n\t* config/v850/v850.c (compute_frame_size): Likewise.\n\t* config/xtensa/xtensa-protos.h (compute_frame_size): Likewise.\n\t* config/xtensa/xtensa.c (compute_frame_size): Likewise.\n\t* config/pa/pa-protos.h (pa_compute_frame_size): Likewise.\n\t* config/pa/pa.c (pa_compute_frame_size): Likewise.\n\t* explow.h (get_dynamic_stack_base): Take the offset as a poly_int64\n\trather than a HOST_WIDE_INT.\n\t* explow.c (get_dynamic_stack_base): Likewise.\n\t* final.c (final_start_function): Use the constant lower bound\n\tof the frame size for -Wframe-larger-than.\n\t* ira.c (do_reload): Adjust for new get_frame_size return type.\n\t* lra.c (lra): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* config/avr/avr.c (avr_asm_function_end_prologue): Likewise.\n\t* config/pa/pa.h (EXIT_IGNORE_STACK): Likewise.\n\t* rtlanal.c (get_initial_register_offset): Return the offset as\n\ta poly_int64 rather than a HOST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255917", "tree": {"sha": "8b895dc76d9b5a9544b28dcb10c3ac925ccea4dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b895dc76d9b5a9544b28dcb10c3ac925ccea4dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/comments", "author": null, "committer": null, "parents": [{"sha": "7ee216163faf80d2a55f1c08abb971b7da34a793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee216163faf80d2a55f1c08abb971b7da34a793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee216163faf80d2a55f1c08abb971b7da34a793"}], "stats": {"total": 354, "additions": 216, "deletions": 138}, "files": [{"sha": "7039a3de99d63d1b168c3f75c5a05a72c50fd90a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -1,3 +1,60 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* function.h (frame_space): Change start and length from HOST_WIDE_INT\n+\tto poly_int64.\n+\t(get_frame_size): Return the size as a poly_int64 rather than a\n+\tHOST_WIDE_INT.\n+\t(frame_offset_overflow): Take the offset as a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(assign_stack_local_1, assign_stack_local, assign_stack_temp_for_type)\n+\t(assign_stack_temp): Likewise for the size.\n+\t* function.c (get_frame_size): Return a poly_int64 rather than\n+\ta HOST_WIDE_INT.\n+\t(frame_offset_overflow): Take the offset as a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(try_fit_stack_local): Take the start, length and size as poly_int64s\n+\trather than HOST_WIDE_INTs.  Return the offset as a poly_int64_pod\n+\trather than a HOST_WIDE_INT.\n+\t(add_frame_space): Take the start and end as poly_int64s rather than\n+\tHOST_WIDE_INTs.\n+\t(assign_stack_local_1, assign_stack_local, assign_stack_temp_for_type)\n+\t(assign_stack_temp): Likewise for the size.\n+\t(temp_slot): Change size, base_offset and full_size from HOST_WIDE_INT\n+\tto poly_int64.\n+\t(find_temp_slot_from_address): Handle polynomial offsets.\n+\t(combine_temp_slots): Likewise.\n+\t* emit-rtl.h (rtl_data::x_frame_offset): Change from HOST_WIDE_INT\n+\tto poly_int64.\n+\t* cfgexpand.c (alloc_stack_frame_space): Return the offset as a\n+\tpoly_int64 rather than a HOST_WIDE_INT.\n+\t(expand_one_stack_var_at): Take the offset as a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(expand_stack_vars, expand_one_stack_var_1, expand_used_vars): Handle\n+\tpolynomial frame offsets.\n+\t* config/m32r/m32r-protos.h (m32r_compute_frame_size): Take the size\n+\tas a poly_int64 rather than an int.\n+\t* config/m32r/m32r.c (m32r_compute_frame_size): Likewise.\n+\t* config/v850/v850-protos.h (compute_frame_size): Likewise.\n+\t* config/v850/v850.c (compute_frame_size): Likewise.\n+\t* config/xtensa/xtensa-protos.h (compute_frame_size): Likewise.\n+\t* config/xtensa/xtensa.c (compute_frame_size): Likewise.\n+\t* config/pa/pa-protos.h (pa_compute_frame_size): Likewise.\n+\t* config/pa/pa.c (pa_compute_frame_size): Likewise.\n+\t* explow.h (get_dynamic_stack_base): Take the offset as a poly_int64\n+\trather than a HOST_WIDE_INT.\n+\t* explow.c (get_dynamic_stack_base): Likewise.\n+\t* final.c (final_start_function): Use the constant lower bound\n+\tof the frame size for -Wframe-larger-than.\n+\t* ira.c (do_reload): Adjust for new get_frame_size return type.\n+\t* lra.c (lra): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* config/avr/avr.c (avr_asm_function_end_prologue): Likewise.\n+\t* config/pa/pa.h (EXIT_IGNORE_STACK): Likewise.\n+\t* rtlanal.c (get_initial_register_offset): Return the offset as\n+\ta poly_int64 rather than a HOST_WIDE_INT.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "32c48ac6a3b3f147e1e2321179deb707109a988d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -389,22 +389,23 @@ align_base (HOST_WIDE_INT base, unsigned HOST_WIDE_INT align, bool align_up)\n /* Allocate SIZE bytes at byte alignment ALIGN from the stack frame.\n    Return the frame offset.  */\n \n-static HOST_WIDE_INT\n+static poly_int64\n alloc_stack_frame_space (HOST_WIDE_INT size, unsigned HOST_WIDE_INT align)\n {\n-  HOST_WIDE_INT offset, new_frame_offset;\n+  poly_int64 offset, new_frame_offset;\n \n   if (FRAME_GROWS_DOWNWARD)\n     {\n       new_frame_offset\n-\t= align_base (frame_offset - frame_phase - size,\n-\t\t      align, false) + frame_phase;\n+\t= aligned_lower_bound (frame_offset - frame_phase - size,\n+\t\t\t       align) + frame_phase;\n       offset = new_frame_offset;\n     }\n   else\n     {\n       new_frame_offset\n-\t= align_base (frame_offset - frame_phase, align, true) + frame_phase;\n+\t= aligned_upper_bound (frame_offset - frame_phase,\n+\t\t\t       align) + frame_phase;\n       offset = new_frame_offset;\n       new_frame_offset += size;\n     }\n@@ -980,13 +981,13 @@ dump_stack_var_partition (void)\n \n static void\n expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n-\t\t\t HOST_WIDE_INT offset)\n+\t\t\t poly_int64 offset)\n {\n   unsigned align;\n   rtx x;\n \n   /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n-  gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n+  gcc_assert (known_eq (offset, trunc_int_for_mode (offset, Pmode)));\n \n   x = plus_constant (Pmode, base, offset);\n   x = gen_rtx_MEM (TREE_CODE (decl) == SSA_NAME\n@@ -1000,7 +1001,7 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n \t important, we'll simply use the alignment that is already set.  */\n       if (base == virtual_stack_vars_rtx)\n \toffset -= frame_phase;\n-      align = least_bit_hwi (offset);\n+      align = known_alignment (offset);\n       align *= BITS_PER_UNIT;\n       if (align == 0 || align > base_align)\n \talign = base_align;\n@@ -1094,7 +1095,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n     {\n       rtx base;\n       unsigned base_align, alignb;\n-      HOST_WIDE_INT offset;\n+      poly_int64 offset;\n \n       i = stack_vars_sorted[si];\n \n@@ -1119,21 +1120,27 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n \t  base = virtual_stack_vars_rtx;\n-\t  if ((asan_sanitize_stack_p ())\n-\t      && pred)\n+\t  /* ASAN description strings don't yet have a syntax for expressing\n+\t     polynomial offsets.  */\n+\t  HOST_WIDE_INT prev_offset;\n+\t  if (asan_sanitize_stack_p ()\n+\t      && pred\n+\t      && frame_offset.is_constant (&prev_offset))\n \t    {\n-\t      HOST_WIDE_INT prev_offset\n-\t\t= align_base (frame_offset,\n-\t\t\t      MAX (alignb, ASAN_RED_ZONE_SIZE),\n-\t\t\t      !FRAME_GROWS_DOWNWARD);\n+\t      prev_offset = align_base (prev_offset,\n+\t\t\t\t\tMAX (alignb, ASAN_RED_ZONE_SIZE),\n+\t\t\t\t\t!FRAME_GROWS_DOWNWARD);\n \t      tree repr_decl = NULL_TREE;\n \t      offset\n \t\t= alloc_stack_frame_space (stack_vars[i].size\n \t\t\t\t\t   + ASAN_RED_ZONE_SIZE,\n \t\t\t\t\t   MAX (alignb, ASAN_RED_ZONE_SIZE));\n \n \t      data->asan_vec.safe_push (prev_offset);\n-\t      data->asan_vec.safe_push (offset + stack_vars[i].size);\n+\t      /* Allocating a constant amount of space from a constant\n+\t\t starting offset must give a constant result.  */\n+\t      data->asan_vec.safe_push ((offset + stack_vars[i].size)\n+\t\t\t\t\t.to_constant ());\n \t      /* Find best representative of the partition.\n \t\t Prefer those with DECL_NAME, even better\n \t\t satisfying asan_protect_stack_decl predicate.  */\n@@ -1179,7 +1186,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t     space.  */\n \t  if (large_size > 0 && ! large_allocation_done)\n \t    {\n-\t      HOST_WIDE_INT loffset;\n+\t      poly_int64 loffset;\n \t      rtx large_allocsize;\n \n \t      large_allocsize = GEN_INT (large_size);\n@@ -1282,7 +1289,8 @@ set_parm_rtl (tree parm, rtx x)\n static void\n expand_one_stack_var_1 (tree var)\n {\n-  HOST_WIDE_INT size, offset;\n+  HOST_WIDE_INT size;\n+  poly_int64 offset;\n   unsigned byte_align;\n \n   if (TREE_CODE (var) == SSA_NAME)\n@@ -2218,9 +2226,12 @@ expand_used_vars (void)\n \t   in addition to phase 1 and 2.  */\n \texpand_stack_vars (asan_decl_phase_3, &data);\n \n-      if (!data.asan_vec.is_empty ())\n+      /* ASAN description strings don't yet have a syntax for expressing\n+\t polynomial offsets.  */\n+      HOST_WIDE_INT prev_offset;\n+      if (!data.asan_vec.is_empty ()\n+\t  && frame_offset.is_constant (&prev_offset))\n \t{\n-\t  HOST_WIDE_INT prev_offset = frame_offset;\n \t  HOST_WIDE_INT offset, sz, redzonesz;\n \t  redzonesz = ASAN_RED_ZONE_SIZE;\n \t  sz = data.asan_vec[0] - prev_offset;\n@@ -2229,8 +2240,10 @@ expand_used_vars (void)\n \t      && sz + ASAN_RED_ZONE_SIZE >= (int) data.asan_alignb)\n \t    redzonesz = ((sz + ASAN_RED_ZONE_SIZE + data.asan_alignb - 1)\n \t\t\t & ~(data.asan_alignb - HOST_WIDE_INT_1)) - sz;\n-\t  offset\n-\t    = alloc_stack_frame_space (redzonesz, ASAN_RED_ZONE_SIZE);\n+\t  /* Allocating a constant amount of space from a constant\n+\t     starting offset must give a constant result.  */\n+\t  offset = (alloc_stack_frame_space (redzonesz, ASAN_RED_ZONE_SIZE)\n+\t\t    .to_constant ());\n \t  data.asan_vec.safe_push (prev_offset);\n \t  data.asan_vec.safe_push (offset);\n \t  /* Leave space for alignment if STRICT_ALIGNMENT.  */\n@@ -2275,9 +2288,10 @@ expand_used_vars (void)\n   if (STACK_ALIGNMENT_NEEDED)\n     {\n       HOST_WIDE_INT align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-      if (!FRAME_GROWS_DOWNWARD)\n-\tframe_offset += align - 1;\n-      frame_offset &= -align;\n+      if (FRAME_GROWS_DOWNWARD)\n+\tframe_offset = aligned_lower_bound (frame_offset, align);\n+      else\n+\tframe_offset = aligned_upper_bound (frame_offset, align);\n     }\n \n   return var_end_seq;"}, {"sha": "e2db38d45decf4985e247ccdd573c76825fb7c03", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -2044,7 +2044,7 @@ avr_asm_function_end_prologue (FILE *file)\n              avr_outgoing_args_size());\n \n   fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n-           get_frame_size());\n+           (HOST_WIDE_INT) get_frame_size());\n \n   if (!cfun->machine->gasisr.yes)\n     {"}, {"sha": "83192daea5c7119d4d5ab38756765595539f426c", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -22,7 +22,7 @@\n \n extern void   m32r_init (void);\n extern void   m32r_init_expanders (void);\n-extern unsigned m32r_compute_frame_size (int);\n+extern unsigned m32r_compute_frame_size (poly_int64);\n extern void   m32r_expand_prologue (void);\n extern void   m32r_expand_epilogue (void);\n extern int    direct_return (void);"}, {"sha": "7f98dd57550611aa1fbe98778311bc1ed0b804da", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -1555,7 +1555,7 @@ static struct m32r_frame_info zero_frame_info;\n    SIZE is the size needed for local variables.  */\n \n unsigned int\n-m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n+m32r_compute_frame_size (poly_int64 size)   /* # of var. bytes allocated.  */\n {\n   unsigned int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;"}, {"sha": "7c38c60664cde18e15b461e33bd26351aa13f996", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -85,7 +85,7 @@ extern int pa_shadd_constant_p (int);\n extern int pa_zdepi_cint_p (unsigned HOST_WIDE_INT);\n \n extern void pa_output_ascii (FILE *, const char *, int);\n-extern HOST_WIDE_INT pa_compute_frame_size (HOST_WIDE_INT, int *);\n+extern HOST_WIDE_INT pa_compute_frame_size (poly_int64, int *);\n extern void pa_expand_prologue (void);\n extern void pa_expand_epilogue (void);\n extern bool pa_can_use_return_insn (void);"}, {"sha": "15f22fc1c64d2f561d8fcddd8941f3144c9753c4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -3771,7 +3771,7 @@ set_reg_plus_d (int reg, int base, HOST_WIDE_INT disp, int note)\n }\n \n HOST_WIDE_INT\n-pa_compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n+pa_compute_frame_size (poly_int64 size, int *fregs_live)\n {\n   int freg_saved = 0;\n   int i, j;"}, {"sha": "044f65ea16827a2b04ed2e561a33d21260964d15", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -691,7 +691,7 @@ void hppa_profile_hook (int label_no);\n extern int may_call_alloca;\n \n #define EXIT_IGNORE_STACK\t\\\n- (get_frame_size () != 0\t\\\n+ (maybe_ne (get_frame_size (), 0)\t\\\n   || cfun->calls_alloca || crtl->outgoing_args_size)\n \n /* Length in units of the trampoline for entering a nested function.  */"}, {"sha": "b59ca774fca43849d0362fbd13a1da4b1caaf5c2", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -26,7 +26,7 @@ extern void   expand_prologue               (void);\n extern void   expand_epilogue               (void);\n extern int    v850_handle_pragma            (int (*)(void), void (*)(int), char *);\n extern int    compute_register_save_size    (long *);\n-extern int    compute_frame_size            (int, long *);\n+extern int    compute_frame_size            (poly_int64, long *);\n extern void   v850_init_expanders           (void);\n \n #ifdef RTX_CODE"}, {"sha": "4f602f4bd50e476624c34b669d8c2932406c86d0", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -1574,7 +1574,7 @@ compute_register_save_size (long * p_reg_saved)\n   -------------------------- ---- ------------------   V */\n \n int\n-compute_frame_size (int size, long * p_reg_saved)\n+compute_frame_size (poly_int64 size, long * p_reg_saved)\n {\n   return (size\n \t  + compute_register_save_size (p_reg_saved)"}, {"sha": "3764340f2c21a5379effec6633d7e6a20789b477", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -67,7 +67,7 @@ extern rtx xtensa_return_addr (int, rtx);\n \n extern void xtensa_setup_frame_addresses (void);\n extern int xtensa_dbx_register_number (int);\n-extern long compute_frame_size (int);\n+extern long compute_frame_size (poly_int64);\n extern bool xtensa_use_return_instruction_p (void);\n extern void xtensa_expand_prologue (void);\n extern void xtensa_expand_epilogue (void);"}, {"sha": "18b349c0bc4953bd43d465e85ba5d91f73b9c06c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -2698,7 +2698,7 @@ xtensa_call_save_reg(int regno)\n #define XTENSA_STACK_ALIGN(LOC) (((LOC) + STACK_BYTES-1) & ~(STACK_BYTES-1))\n \n long\n-compute_frame_size (int size)\n+compute_frame_size (poly_int64 size)\n {\n   int regno;\n "}, {"sha": "c46ebb458f7b6a6837f1e3f58d182b002201ba0b", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -126,7 +126,7 @@ struct GTY(()) rtl_data {\n   /* Offset to end of allocated area of stack frame.\n      If stack grows down, this is the address of the last stack slot allocated.\n      If stack grows up, this is the address for the next slot.  */\n-  HOST_WIDE_INT x_frame_offset;\n+  poly_int64_pod x_frame_offset;\n \n   /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n   rtx_insn *x_parm_birth_insn;"}, {"sha": "4f3e0d41d1b379b1061014fdb19665ecbfe8c8dc", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -1587,7 +1587,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n    of memory.  */\n \n rtx\n-get_dynamic_stack_base (HOST_WIDE_INT offset, unsigned required_align)\n+get_dynamic_stack_base (poly_int64 offset, unsigned required_align)\n {\n   rtx target;\n "}, {"sha": "e981a6562542248cae31fa169ba2e2e474b3fc43", "filename": "gcc/explow.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -102,8 +102,7 @@ extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned,\n extern void get_dynamic_stack_size (rtx *, unsigned, unsigned, HOST_WIDE_INT *);\n \n /* Returns the address of the dynamic stack space without allocating it.  */\n-extern rtx get_dynamic_stack_base (HOST_WIDE_INT offset,\n-\t\t\t\t   unsigned required_align);\n+extern rtx get_dynamic_stack_base (poly_int64, unsigned);\n \n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n extern void emit_stack_probe (rtx);"}, {"sha": "1969ccbed0057fdc1149677ab33d4b51e9a63e74", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -1846,14 +1846,15 @@ final_start_function (rtx_insn *first, FILE *file,\n       TREE_ASM_WRITTEN (DECL_INITIAL (current_function_decl)) = 1;\n     }\n \n+  HOST_WIDE_INT min_frame_size = constant_lower_bound (get_frame_size ());\n   if (warn_frame_larger_than\n-    && get_frame_size () > frame_larger_than_size)\n-  {\n+      && min_frame_size > frame_larger_than_size)\n+    {\n       /* Issue a warning */\n       warning (OPT_Wframe_larger_than_,\n-               \"the frame size of %wd bytes is larger than %wd bytes\",\n-               get_frame_size (), frame_larger_than_size);\n-  }\n+\t       \"the frame size of %wd bytes is larger than %wd bytes\",\n+\t       min_frame_size, frame_larger_than_size);\n+    }\n \n   /* First output the function prologue: code to set up the stack frame.  */\n   targetm.asm_out.function_prologue (file);"}, {"sha": "743d4211b3c21518605f1d04c7f5df84e4fb1517", "filename": "gcc/function.c", "status": "modified", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -218,7 +218,7 @@ free_after_compilation (struct function *f)\n    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n \n-HOST_WIDE_INT\n+poly_int64\n get_frame_size (void)\n {\n   if (FRAME_GROWS_DOWNWARD)\n@@ -232,20 +232,22 @@ get_frame_size (void)\n    return FALSE.  */\n \n bool\n-frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n+frame_offset_overflow (poly_int64 offset, tree func)\n {\n-  unsigned HOST_WIDE_INT size = FRAME_GROWS_DOWNWARD ? -offset : offset;\n+  poly_uint64 size = FRAME_GROWS_DOWNWARD ? -offset : offset;\n+  unsigned HOST_WIDE_INT limit\n+    = ((HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (Pmode) - 1))\n+       /* Leave room for the fixed part of the frame.  */\n+       - 64 * UNITS_PER_WORD);\n \n-  if (size > (HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (Pmode) - 1))\n-\t       /* Leave room for the fixed part of the frame.  */\n-\t       - 64 * UNITS_PER_WORD)\n+  if (!coeffs_in_range_p (size, 0U, limit))\n     {\n       error_at (DECL_SOURCE_LOCATION (func),\n \t\t\"total size of local objects too large\");\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return the minimum spill slot alignment for a register of mode MODE.  */\n@@ -284,11 +286,11 @@ get_stack_local_alignment (tree type, machine_mode mode)\n    given a start/length pair that lies at the end of the frame.  */\n \n static bool\n-try_fit_stack_local (HOST_WIDE_INT start, HOST_WIDE_INT length,\n-\t\t     HOST_WIDE_INT size, unsigned int alignment,\n-\t\t     HOST_WIDE_INT *poffset)\n+try_fit_stack_local (poly_int64 start, poly_int64 length,\n+\t\t     poly_int64 size, unsigned int alignment,\n+\t\t     poly_int64_pod *poffset)\n {\n-  HOST_WIDE_INT this_frame_offset;\n+  poly_int64 this_frame_offset;\n   int frame_off, frame_alignment, frame_phase;\n \n   /* Calculate how many bytes the start of local variables is off from\n@@ -299,33 +301,31 @@ try_fit_stack_local (HOST_WIDE_INT start, HOST_WIDE_INT length,\n \n   /* Round the frame offset to the specified alignment.  */\n \n-  /*  We must be careful here, since FRAME_OFFSET might be negative and\n-      division with a negative dividend isn't as well defined as we might\n-      like.  So we instead assume that ALIGNMENT is a power of two and\n-      use logical operations which are unambiguous.  */\n   if (FRAME_GROWS_DOWNWARD)\n     this_frame_offset\n-      = (FLOOR_ROUND (start + length - size - frame_phase,\n-\t\t      (unsigned HOST_WIDE_INT) alignment)\n+      = (aligned_lower_bound (start + length - size - frame_phase, alignment)\n \t + frame_phase);\n   else\n     this_frame_offset\n-      = (CEIL_ROUND (start - frame_phase,\n-\t\t     (unsigned HOST_WIDE_INT) alignment)\n-\t + frame_phase);\n+      = aligned_upper_bound (start - frame_phase, alignment) + frame_phase;\n \n   /* See if it fits.  If this space is at the edge of the frame,\n      consider extending the frame to make it fit.  Our caller relies on\n      this when allocating a new slot.  */\n-  if (frame_offset == start && this_frame_offset < frame_offset)\n-    frame_offset = this_frame_offset;\n-  else if (this_frame_offset < start)\n-    return false;\n-  else if (start + length == frame_offset\n-\t   && this_frame_offset + size > start + length)\n-    frame_offset = this_frame_offset + size;\n-  else if (this_frame_offset + size > start + length)\n-    return false;\n+  if (maybe_lt (this_frame_offset, start))\n+    {\n+      if (known_eq (frame_offset, start))\n+\tframe_offset = this_frame_offset;\n+      else\n+\treturn false;\n+    }\n+  else if (maybe_gt (this_frame_offset + size, start + length))\n+    {\n+      if (known_eq (frame_offset, start + length))\n+\tframe_offset = this_frame_offset + size;\n+      else\n+\treturn false;\n+    }\n \n   *poffset = this_frame_offset;\n   return true;\n@@ -336,7 +336,7 @@ try_fit_stack_local (HOST_WIDE_INT start, HOST_WIDE_INT length,\n    function's frame_space_list.  */\n \n static void\n-add_frame_space (HOST_WIDE_INT start, HOST_WIDE_INT end)\n+add_frame_space (poly_int64 start, poly_int64 end)\n {\n   struct frame_space *space = ggc_alloc<frame_space> ();\n   space->next = crtl->frame_space_list;\n@@ -363,12 +363,12 @@ add_frame_space (HOST_WIDE_INT start, HOST_WIDE_INT end)\n    We do not round to stack_boundary here.  */\n \n rtx\n-assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n+assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \t\t      int align, int kind)\n {\n   rtx x, addr;\n-  int bigend_correction = 0;\n-  HOST_WIDE_INT slot_offset = 0, old_frame_offset;\n+  poly_int64 bigend_correction = 0;\n+  poly_int64 slot_offset = 0, old_frame_offset;\n   unsigned int alignment, alignment_in_bits;\n \n   if (align == 0)\n@@ -379,7 +379,7 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n   else if (align == -1)\n     {\n       alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n-      size = CEIL_ROUND (size, alignment);\n+      size = aligned_upper_bound (size, alignment);\n     }\n   else if (align == -2)\n     alignment = 1; /* BITS_PER_UNIT / BITS_PER_UNIT */\n@@ -415,7 +415,7 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n \t\t     requested size is 0 or the estimated stack\n \t\t     alignment >= mode alignment.  */\n \t\t  gcc_assert ((kind & ASLK_REDUCE_ALIGN)\n-\t\t              || size == 0\n+\t\t\t      || known_eq (size, 0)\n \t\t\t      || (crtl->stack_alignment_estimated\n \t\t\t\t  >= GET_MODE_ALIGNMENT (mode)));\n \t\t  alignment_in_bits = crtl->stack_alignment_estimated;\n@@ -430,7 +430,7 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n   if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n     crtl->max_used_stack_slot_alignment = alignment_in_bits;\n \n-  if (mode != BLKmode || size != 0)\n+  if (mode != BLKmode || maybe_ne (size, 0))\n     {\n       if (kind & ASLK_RECORD_PAD)\n \t{\n@@ -443,9 +443,9 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n \t\t\t\t\talignment, &slot_offset))\n \t\tcontinue;\n \t      *psp = space->next;\n-\t      if (slot_offset > space->start)\n+\t      if (known_gt (slot_offset, space->start))\n \t\tadd_frame_space (space->start, slot_offset);\n-\t      if (slot_offset + size < space->start + space->length)\n+\t      if (known_lt (slot_offset + size, space->start + space->length))\n \t\tadd_frame_space (slot_offset + size,\n \t\t\t\t space->start + space->length);\n \t      goto found_space;\n@@ -467,9 +467,9 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n \n       if (kind & ASLK_RECORD_PAD)\n \t{\n-\t  if (slot_offset > frame_offset)\n+\t  if (known_gt (slot_offset, frame_offset))\n \t    add_frame_space (frame_offset, slot_offset);\n-\t  if (slot_offset + size < old_frame_offset)\n+\t  if (known_lt (slot_offset + size, old_frame_offset))\n \t    add_frame_space (slot_offset + size, old_frame_offset);\n \t}\n     }\n@@ -480,18 +480,27 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n \n       if (kind & ASLK_RECORD_PAD)\n \t{\n-\t  if (slot_offset > old_frame_offset)\n+\t  if (known_gt (slot_offset, old_frame_offset))\n \t    add_frame_space (old_frame_offset, slot_offset);\n-\t  if (slot_offset + size < frame_offset)\n+\t  if (known_lt (slot_offset + size, frame_offset))\n \t    add_frame_space (slot_offset + size, frame_offset);\n \t}\n     }\n \n  found_space:\n   /* On a big-endian machine, if we are allocating more space than we will use,\n      use the least significant bytes of those that are allocated.  */\n-  if (BYTES_BIG_ENDIAN && mode != BLKmode && GET_MODE_SIZE (mode) < size)\n-    bigend_correction = size - GET_MODE_SIZE (mode);\n+  if (mode != BLKmode)\n+    {\n+      /* The slot size can sometimes be smaller than the mode size;\n+\t e.g. the rs6000 port allocates slots with a vector mode\n+\t that have the size of only one element.  However, the slot\n+\t size must always be ordered wrt to the mode size, in the\n+\t same way as for a subreg.  */\n+      gcc_checking_assert (ordered_p (GET_MODE_SIZE (mode), size));\n+      if (BYTES_BIG_ENDIAN && maybe_lt (GET_MODE_SIZE (mode), size))\n+\tbigend_correction = size - GET_MODE_SIZE (mode);\n+    }\n \n   /* If we have already instantiated virtual registers, return the actual\n      address relative to the frame pointer.  */\n@@ -521,7 +530,7 @@ assign_stack_local_1 (machine_mode mode, HOST_WIDE_INT size,\n /* Wrap up assign_stack_local_1 with last parameter as false.  */\n \n rtx\n-assign_stack_local (machine_mode mode, HOST_WIDE_INT size, int align)\n+assign_stack_local (machine_mode mode, poly_int64 size, int align)\n {\n   return assign_stack_local_1 (mode, size, align, ASLK_RECORD_PAD);\n }\n@@ -548,7 +557,7 @@ struct GTY(()) temp_slot {\n   /* The rtx to used to reference the slot.  */\n   rtx slot;\n   /* The size, in units, of the slot.  */\n-  HOST_WIDE_INT size;\n+  poly_int64 size;\n   /* The type of the object in the slot, or zero if it doesn't correspond\n      to a type.  We use this to determine whether a slot can be reused.\n      It can be reused if objects of the type of the new slot will always\n@@ -562,10 +571,10 @@ struct GTY(()) temp_slot {\n   int level;\n   /* The offset of the slot from the frame_pointer, including extra space\n      for alignment.  This info is for combine_temp_slots.  */\n-  HOST_WIDE_INT base_offset;\n+  poly_int64 base_offset;\n   /* The size of the slot, including extra space for alignment.  This\n      info is for combine_temp_slots.  */\n-  HOST_WIDE_INT full_size;\n+  poly_int64 full_size;\n };\n \n /* Entry for the below hash table.  */\n@@ -743,18 +752,14 @@ find_temp_slot_from_address (rtx x)\n     return p;\n \n   /* Last resort: Address is a virtual stack var address.  */\n-  if (GET_CODE (x) == PLUS\n-      && XEXP (x, 0) == virtual_stack_vars_rtx\n-      && CONST_INT_P (XEXP (x, 1)))\n+  poly_int64 offset;\n+  if (strip_offset (x, &offset) == virtual_stack_vars_rtx)\n     {\n       int i;\n       for (i = max_slot_level (); i >= 0; i--)\n \tfor (p = *temp_slots_at_level (i); p; p = p->next)\n-\t  {\n-\t    if (INTVAL (XEXP (x, 1)) >= p->base_offset\n-\t\t&& INTVAL (XEXP (x, 1)) < p->base_offset + p->full_size)\n-\t      return p;\n-\t  }\n+\t  if (known_in_range_p (offset, p->base_offset, p->full_size))\n+\t    return p;\n     }\n \n   return NULL;\n@@ -771,16 +776,13 @@ find_temp_slot_from_address (rtx x)\n    TYPE is the type that will be used for the stack slot.  */\n \n rtx\n-assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n-\t\t\t    tree type)\n+assign_stack_temp_for_type (machine_mode mode, poly_int64 size, tree type)\n {\n   unsigned int align;\n   struct temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n   rtx slot;\n \n-  /* If SIZE is -1 it means that somebody tried to allocate a temporary\n-     of a variable size.  */\n-  gcc_assert (size != -1);\n+  gcc_assert (known_size_p (size));\n \n   align = get_stack_local_alignment (type, mode);\n \n@@ -795,13 +797,16 @@ assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n     {\n       for (p = avail_temp_slots; p; p = p->next)\n \t{\n-\t  if (p->align >= align && p->size >= size\n+\t  if (p->align >= align\n+\t      && known_ge (p->size, size)\n \t      && GET_MODE (p->slot) == mode\n \t      && objects_must_conflict_p (p->type, type)\n-\t      && (best_p == 0 || best_p->size > p->size\n-\t\t  || (best_p->size == p->size && best_p->align > p->align)))\n+\t      && (best_p == 0\n+\t\t  || (known_eq (best_p->size, p->size)\n+\t\t      ? best_p->align > p->align\n+\t\t      : known_ge (best_p->size, p->size))))\n \t    {\n-\t      if (p->align == align && p->size == size)\n+\t      if (p->align == align && known_eq (p->size, size))\n \t\t{\n \t\t  selected = p;\n \t\t  cut_slot_from_list (selected, &avail_temp_slots);\n@@ -825,9 +830,9 @@ assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n       if (GET_MODE (best_p->slot) == BLKmode)\n \t{\n \t  int alignment = best_p->align / BITS_PER_UNIT;\n-\t  HOST_WIDE_INT rounded_size = CEIL_ROUND (size, alignment);\n+\t  poly_int64 rounded_size = aligned_upper_bound (size, alignment);\n \n-\t  if (best_p->size - rounded_size >= alignment)\n+\t  if (known_ge (best_p->size - rounded_size, alignment))\n \t    {\n \t      p = ggc_alloc<temp_slot> ();\n \t      p->in_use = 0;\n@@ -850,7 +855,7 @@ assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n   /* If we still didn't find one, make a new temporary.  */\n   if (selected == 0)\n     {\n-      HOST_WIDE_INT frame_offset_old = frame_offset;\n+      poly_int64 frame_offset_old = frame_offset;\n \n       p = ggc_alloc<temp_slot> ();\n \n@@ -864,9 +869,9 @@ assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n       gcc_assert (mode != BLKmode || align == BIGGEST_ALIGNMENT);\n       p->slot = assign_stack_local_1 (mode,\n \t\t\t\t      (mode == BLKmode\n-\t\t\t\t       ? CEIL_ROUND (size,\n-\t\t\t\t\t\t     (int) align\n-\t\t\t\t\t\t     / BITS_PER_UNIT)\n+\t\t\t\t       ? aligned_upper_bound (size,\n+\t\t\t\t\t\t\t      (int) align\n+\t\t\t\t\t\t\t      / BITS_PER_UNIT)\n \t\t\t\t       : size),\n \t\t\t\t      align, 0);\n \n@@ -931,7 +936,7 @@ assign_stack_temp_for_type (machine_mode mode, HOST_WIDE_INT size,\n    reuse.  First two arguments are same as in preceding function.  */\n \n rtx\n-assign_stack_temp (machine_mode mode, HOST_WIDE_INT size)\n+assign_stack_temp (machine_mode mode, poly_int64 size)\n {\n   return assign_stack_temp_for_type (mode, size, NULL_TREE);\n }\n@@ -1050,14 +1055,14 @@ combine_temp_slots (void)\n \t  if (GET_MODE (q->slot) != BLKmode)\n \t    continue;\n \n-\t  if (p->base_offset + p->full_size == q->base_offset)\n+\t  if (known_eq (p->base_offset + p->full_size, q->base_offset))\n \t    {\n \t      /* Q comes after P; combine Q into P.  */\n \t      p->size += q->size;\n \t      p->full_size += q->full_size;\n \t      delete_q = 1;\n \t    }\n-\t  else if (q->base_offset + q->full_size == p->base_offset)\n+\t  else if (known_eq (q->base_offset + q->full_size, p->base_offset))\n \t    {\n \t      /* P comes after Q; combine P into Q.  */\n \t      q->size += p->size;"}, {"sha": "95cb2bdc43a2de861779f70ab3301de994bb6213", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -187,8 +187,8 @@ struct GTY(()) frame_space\n {\n   struct frame_space *next;\n \n-  HOST_WIDE_INT start;\n-  HOST_WIDE_INT length;\n+  poly_int64 start;\n+  poly_int64 length;\n };\n \n struct GTY(()) stack_usage\n@@ -575,19 +575,19 @@ extern void free_after_compilation (struct function *);\n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n    the caller may have to do that.  */\n-extern HOST_WIDE_INT get_frame_size (void);\n+extern poly_int64 get_frame_size (void);\n \n /* Issue an error message and return TRUE if frame OFFSET overflows in\n    the signed target pointer arithmetics for function FUNC.  Otherwise\n    return FALSE.  */\n-extern bool frame_offset_overflow (HOST_WIDE_INT, tree);\n+extern bool frame_offset_overflow (poly_int64, tree);\n \n extern unsigned int spill_slot_alignment (machine_mode);\n \n-extern rtx assign_stack_local_1 (machine_mode, HOST_WIDE_INT, int, int);\n-extern rtx assign_stack_local (machine_mode, HOST_WIDE_INT, int);\n-extern rtx assign_stack_temp_for_type (machine_mode, HOST_WIDE_INT, tree);\n-extern rtx assign_stack_temp (machine_mode, HOST_WIDE_INT);\n+extern rtx assign_stack_local_1 (machine_mode, poly_int64, int, int);\n+extern rtx assign_stack_local (machine_mode, poly_int64, int);\n+extern rtx assign_stack_temp_for_type (machine_mode, poly_int64, tree);\n+extern rtx assign_stack_temp (machine_mode, poly_int64);\n extern rtx assign_temp (tree, int, int);\n extern void update_temp_slot_address (rtx, rtx);\n extern void preserve_temp_slots (rtx);"}, {"sha": "b3905b6742340afe0da2a6a15ffecdb80ac078a6", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -5553,13 +5553,13 @@ do_reload (void)\n      function's frame size is larger than we expect.  */\n   if (flag_stack_check == GENERIC_STACK_CHECK)\n     {\n-      HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;\n+      poly_int64 size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;\n \n       for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (df_regs_ever_live_p (i) && !fixed_regs[i] && call_used_regs[i])\n \t  size += UNITS_PER_WORD;\n \n-      if (size > STACK_CHECK_MAX_FRAME_SIZE)\n+      if (constant_lower_bound (size) > STACK_CHECK_MAX_FRAME_SIZE)\n \twarning (0, \"frame size too large for reliable stack checking\");\n     }\n "}, {"sha": "fec9886969a76d1fbaa7acc4eb61d067156c2021", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -2397,7 +2397,7 @@ lra (FILE *f)\n   bitmap_initialize (&lra_optional_reload_pseudos, &reg_obstack);\n   bitmap_initialize (&lra_subreg_reload_pseudos, &reg_obstack);\n   live_p = false;\n-  if (get_frame_size () != 0 && crtl->stack_alignment_needed)\n+  if (maybe_ne (get_frame_size (), 0) && crtl->stack_alignment_needed)\n     /* If we have a stack frame, we must align it now.  The stack size\n        may be a part of the offset computation for register\n        elimination.  */"}, {"sha": "7cf64124bfad08c449819b0cb9dcbde97ac64e94", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -887,7 +887,7 @@ reload (rtx_insn *first, int global)\n   for (;;)\n     {\n       int something_changed;\n-      HOST_WIDE_INT starting_frame_size;\n+      poly_int64 starting_frame_size;\n \n       starting_frame_size = get_frame_size ();\n       something_was_spilled = false;\n@@ -955,7 +955,7 @@ reload (rtx_insn *first, int global)\n       if (caller_save_needed)\n \tsetup_save_areas ();\n \n-      if (starting_frame_size && crtl->stack_alignment_needed)\n+      if (maybe_ne (starting_frame_size, 0) && crtl->stack_alignment_needed)\n \t{\n \t  /* If we have a stack frame, we must align it now.  The\n \t     stack size may be a part of the offset computation for\n@@ -968,7 +968,8 @@ reload (rtx_insn *first, int global)\n \t  assign_stack_local (BLKmode, 0, crtl->stack_alignment_needed);\n \t}\n       /* If we allocated another stack slot, redo elimination bookkeeping.  */\n-      if (something_was_spilled || starting_frame_size != get_frame_size ())\n+      if (something_was_spilled\n+\t  || maybe_ne (starting_frame_size, get_frame_size ()))\n \t{\n \t  if (update_eliminables_and_spill ())\n \t    finish_spills (0);\n@@ -994,7 +995,8 @@ reload (rtx_insn *first, int global)\n \n       /* If we allocated any new memory locations, make another pass\n \t since it might have changed elimination offsets.  */\n-      if (something_was_spilled || starting_frame_size != get_frame_size ())\n+      if (something_was_spilled\n+\t  || maybe_ne (starting_frame_size, get_frame_size ()))\n \tsomething_changed = 1;\n \n       /* Even if the frame size remained the same, we might still have\n@@ -1043,11 +1045,11 @@ reload (rtx_insn *first, int global)\n   if (insns_need_reload != 0 || something_needs_elimination\n       || something_needs_operands_changed)\n     {\n-      HOST_WIDE_INT old_frame_size = get_frame_size ();\n+      poly_int64 old_frame_size = get_frame_size ();\n \n       reload_as_needed (global);\n \n-      gcc_assert (old_frame_size == get_frame_size ());\n+      gcc_assert (known_eq (old_frame_size, get_frame_size ()));\n \n       gcc_assert (verify_initial_elim_offsets ());\n     }"}, {"sha": "859754df72454695a6654394ca70ee72034266b8", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f075bd950c5ad3e2baeb3d8f82fe962efc8e4f7a", "patch": "@@ -344,15 +344,15 @@ rtx_varies_p (const_rtx x, bool for_alias)\n    FROM and TO for the current function, as it was at the start\n    of the routine.  */\n \n-static HOST_WIDE_INT\n+static poly_int64\n get_initial_register_offset (int from, int to)\n {\n   static const struct elim_table_t\n   {\n     const int from;\n     const int to;\n   } table[] = ELIMINABLE_REGS;\n-  HOST_WIDE_INT offset1, offset2;\n+  poly_int64 offset1, offset2;\n   unsigned int i, j;\n \n   if (to == from)"}]}