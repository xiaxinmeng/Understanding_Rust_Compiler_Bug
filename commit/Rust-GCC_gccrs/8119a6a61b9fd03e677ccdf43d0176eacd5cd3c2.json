{"sha": "8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExOWE2YTYxYjlmZDAzZTY3N2NjZGY0M2QwMTc2ZWFjZDVjZDNjMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-07-28T19:58:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-07-28T19:58:38Z"}, "message": "Add power6 copysign/parity support\n\nFrom-SVN: r162656", "tree": {"sha": "f20e85f45b3293dc8a8643993ad10e771bc57f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f20e85f45b3293dc8a8643993ad10e771bc57f52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/comments", "author": null, "committer": null, "parents": [{"sha": "18081149255f8a116512c3e28bf3469ed66d496e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18081149255f8a116512c3e28bf3469ed66d496e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18081149255f8a116512c3e28bf3469ed66d496e"}], "stats": {"total": 200, "additions": 115, "deletions": 85}, "files": [{"sha": "25487588fed7160e6a66527b2dfc82d52bbca45a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "patch": "@@ -1,3 +1,36 @@\n+2010-07-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Update costs for\n+\tpopcount on power7 and parity on power6 systems.\n+\t(rs6000_emit_popcount): Rename gen_popcntwsi2 to gen_popcntddi2.\n+\t(rs6000_emit_parity): Add support for power6 prtyd/prtyw\n+\tinstructions.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_COPYSIGN): New unspec.\n+\t(UNSPEC_PARITY): Ditto.\n+\t(SFDF): New iterator for SF/DF.\n+\t(rreg2): New mode attribute for floating register constraint.\n+\t(TARGET_FLOAT): New mode attribute for whether single/double float\n+\tis supported.\n+\t(popcntd<mode>2): Combine popcntwsi2 and popcntddi2 into one\n+\tpattern.\n+\t(parity<mode>2_cmpb): New insn for parity on power6 and newer\n+\tmachines.\n+\t(copysign<mode>3): Combine copysignsf3, copysigndf3 into one\n+\tpattern.  Add support for fcpsgn instruction added in power6.\n+\t(copysignsf3): Delete.\n+\t(copysigndf3): Delete.\n+\t(copysign<mode>3_fcpsgn): New insn to generate fcpsgn.  Use UNSPEC\n+\tinstead of if_then_else in RTL to avoid problems with -0.\n+\n+\t* config/rs6000/vsx.md (vsx_copysign<mode>3): Use UNSPEC instead\n+\tof if_then_else to mirror scalar code.\n+\t(vsx_copysignsf3): Delete, use copysign<mode>3_fcpsgn in\n+\trs6000.md.\n+\n+\t* config/rs6000/vector.md (vector_copysign<mode>3): Use UNSPEC\n+\tinstead of if_then_else.\n+\n 2010-07-28  Xinliang David Li  <davidxl@google.com>\n \n \t* tree-ssa-loop-ivopts.c (avg_loop_niter): New function."}, {"sha": "92da9f049044f820be30c161738d903df31e69cf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "patch": "@@ -25485,7 +25485,11 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total,\n       return false;\n \n     case POPCOUNT:\n-      *total = COSTS_N_INSNS (6);\n+      *total = COSTS_N_INSNS (TARGET_POPCNTD ? 1 : 6);\n+      return false;\n+\n+    case PARITY:\n+      *total = COSTS_N_INSNS (TARGET_CMPB ? 2 : 6);\n       return false;\n \n     case NOT:\n@@ -26121,7 +26125,7 @@ rs6000_emit_popcount (rtx dst, rtx src)\n   if (TARGET_POPCNTD)\n     {\n       if (mode == SImode)\n-\temit_insn (gen_popcntwsi2 (dst, src));\n+\temit_insn (gen_popcntdsi2 (dst, src));\n       else\n \temit_insn (gen_popcntddi2 (dst, src));\n       return;\n@@ -26160,6 +26164,23 @@ rs6000_emit_parity (rtx dst, rtx src)\n   rtx tmp;\n \n   tmp = gen_reg_rtx (mode);\n+\n+  /* Use the PPC ISA 2.05 prtyw/prtyd instruction if we can.  */\n+  if (TARGET_CMPB)\n+    {\n+      if (mode == SImode)\n+\t{\n+\t  emit_insn (gen_popcntbsi2 (tmp, src));\n+\t  emit_insn (gen_paritysi2_cmpb (dst, tmp));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_popcntbdi2 (tmp, src));\n+\t  emit_insn (gen_paritydi2_cmpb (dst, tmp));\n+\t}\n+      return;\n+    }\n+\n   if (mode == SImode)\n     {\n       /* Is mult+shift >= shift+xor+shift+xor?  */"}, {"sha": "0ef7e98d9e5325c73a305b50d9c4746e078d57ba", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "patch": "@@ -103,6 +103,8 @@\n    (UNSPEC_TOCREL\t\t49)\n    (UNSPEC_MACHOPIC_OFFSET\t50)\n    (UNSPEC_BPERM\t\t51)\n+   (UNSPEC_COPYSIGN\t\t52)\n+   (UNSPEC_PARITY\t\t53)\n   ])\n \n ;;\n@@ -222,9 +224,12 @@\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n \n-;; Iterator for reciprocal estimate instructions\n+; Iterator for reciprocal estimate instructions\n (define_mode_iterator RECIPF [SF DF V4SF V2DF])\n \n+; Iterator for just SF/DF\n+(define_mode_iterator SFDF [SF DF])\n+\n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n (define_mode_attr wd [(QI \"b\") (HI \"h\") (SI \"w\") (DI \"d\")])\n@@ -250,6 +255,11 @@\n \t\t\t(V4SF \"Wf\")\n \t\t\t(V2DF \"Wd\")])\n \n+(define_mode_attr rreg2 [(SF   \"f\")\n+\t\t\t (DF   \"d\")])\n+\n+(define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n+\t\t\t\t(DF \"TARGET_DOUBLE_FLOAT\")])\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -2272,17 +2282,11 @@\n   \"TARGET_POPCNTB\"\n   \"popcntb %0,%1\")\n \n-(define_insn \"popcntwsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(popcount:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n+(define_insn \"popcntd<mode>2\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(popcount:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POPCNTD\"\n-  \"popcntw %0,%1\")\n-\n-(define_insn \"popcntddi2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(popcount:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_POPCNTD && TARGET_POWERPC64\"\n-  \"popcntd %0,%1\")\n+  \"popcnt<wd> %0,%1\")\n \n (define_expand \"popcount<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n@@ -2293,6 +2297,12 @@\n     DONE;\n   })\n \n+(define_insn \"parity<mode>2_cmpb\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:GPR [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")] UNSPEC_PARITY))]\n+  \"TARGET_CMPB && TARGET_POPCNTB\"\n+  \"prty<wd> %0,%1\")\n+\n (define_expand \"parity<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n \t(parity:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")))]\n@@ -5976,60 +5986,46 @@\n   \"frsqrtes %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"copysignsf3\"\n+(define_expand \"copysign<mode>3\"\n   [(set (match_dup 3)\n-        (abs:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))\n+        (abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))\n    (set (match_dup 4)\n-\t(neg:SF (abs:SF (match_dup 1))))\n-   (set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-        (if_then_else:SF (ge (match_operand:SF 2 \"gpc_reg_operand\" \"\")\n-\t                     (match_dup 5))\n+\t(neg:SFDF (abs:SFDF (match_dup 1))))\n+   (set (match_operand:SFDF 0 \"gpc_reg_operand\" \"\")\n+        (if_then_else:SFDF (ge (match_operand:SFDF 2 \"gpc_reg_operand\" \"\")\n+\t\t\t       (match_dup 5))\n \t\t\t (match_dup 3)\n \t\t\t (match_dup 4)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT>\n    && ((TARGET_PPC_GFXOPT\n-        && !HONOR_NANS (SFmode)\n-        && !HONOR_SIGNED_ZEROS (SFmode))\n-       || VECTOR_UNIT_VSX_P (DFmode))\"\n-  {\n-     if (VECTOR_UNIT_VSX_P (DFmode))\n-       {\n-\t emit_insn (gen_vsx_copysignsf3 (operands[0], operands[1], operands[2],\n-\t\t\t\t\t CONST0_RTX (SFmode)));\n-\t DONE;\n-       }\n-     operands[3] = gen_reg_rtx (SFmode);\n-     operands[4] = gen_reg_rtx (SFmode);\n-     operands[5] = CONST0_RTX (SFmode);\n-  })\n+        && !HONOR_NANS (<MODE>mode)\n+        && !HONOR_SIGNED_ZEROS (<MODE>mode))\n+       || TARGET_CMPB\n+       || VECTOR_UNIT_VSX_P (<MODE>mode))\"\n+{\n+  if (TARGET_CMPB || VECTOR_UNIT_VSX_P (<MODE>mode))\n+    {\n+      emit_insn (gen_copysign<mode>3_fcpsgn (operands[0], operands[1],\n+\t\t\t\t\t     operands[2]));\n+      DONE;\n+    }\n \n-(define_expand \"copysigndf3\"\n-  [(set (match_dup 3)\n-        (abs:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")))\n-   (set (match_dup 4)\n-\t(neg:DF (abs:DF (match_dup 1))))\n-   (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-        (if_then_else:DF (ge (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n-\t                     (match_dup 5))\n-\t\t\t (match_dup 3)\n-\t\t\t (match_dup 4)))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && ((TARGET_PPC_GFXOPT\n-        && !HONOR_NANS (DFmode)\n-        && !HONOR_SIGNED_ZEROS (DFmode))\n-       || VECTOR_UNIT_VSX_P (DFmode))\"\n-  {\n-     if (VECTOR_UNIT_VSX_P (DFmode))\n-       {\n-\t emit_insn (gen_vsx_copysigndf3 (operands[0], operands[1],\n-\t\t\t\t\t operands[2], CONST0_RTX (DFmode)));\n-\t DONE;\n-       }\n-     operands[3] = gen_reg_rtx (DFmode);\n-     operands[4] = gen_reg_rtx (DFmode);\n-     operands[5] = CONST0_RTX (DFmode);\n+   operands[3] = gen_reg_rtx (<MODE>mode);\n+   operands[4] = gen_reg_rtx (<MODE>mode);\n+   operands[5] = CONST0_RTX (<MODE>mode);\n   })\n \n+;; Use an unspec rather providing an if-then-else in RTL, to prevent the\n+;; compiler from optimizing -0.0\n+(define_insn \"copysign<mode>3_fcpsgn\"\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n+\t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")\n+\t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<rreg2>\")]\n+\t\t     UNSPEC_COPYSIGN))]\n+  \"TARGET_CMPB && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n+  \"fcpsgn %0,%2,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n ;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n ;; fsel instruction and some auxiliary computations.  Then we just have a\n ;; single DEFINE_INSN for fsel and the define_splits to make them if made by"}, {"sha": "05a498f1a1b0b55ed746c67c73f1ce3e22486f8f", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "patch": "@@ -309,11 +309,8 @@\n \n (define_expand \"vector_copysign<mode>3\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")\n-\t(if_then_else:VEC_F\n-\t (ge:VEC_F (match_operand:VEC_F 2 \"vfloat_operand\" \"\")\n-\t\t   (match_dup 3))\n-\t (abs:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\" \"\"))\n-\t (neg:VEC_F (abs:VEC_F (match_dup 1)))))]\n+\t(unspec:VEC_F [(match_operand:VEC_F 1 \"vfloat_operand\" \"\")\n+\t\t       (match_operand:VEC_F 2 \"vfloat_operand\" \"\")] UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\n {\n@@ -323,8 +320,6 @@\n \t\t\t\t\t     operands[2]));\n       DONE;\n     }\n-\n-  operands[3] = CONST0_RTX (<MODE>mode);\n }\")\n \n \f"}, {"sha": "add969c4c1c202e8b1d924ea8a0a776bd3a18222", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=8119a6a61b9fd03e677ccdf43d0176eacd5cd3c2", "patch": "@@ -852,30 +852,15 @@\n ;; Copy sign\n (define_insn \"vsx_copysign<mode>3\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(if_then_else:VSX_B\n-\t (ge:VSX_B (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t   (match_operand:VSX_B 3 \"zero_constant\" \"j,j\"))\n-\t (abs:VSX_B (match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\"))\n-\t (neg:VSX_B (abs:VSX_B (match_dup 1)))))]\n+\t(unspec:VSX_B\n+\t [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t  (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")]\n+\t UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cpsgn<VSs> %x0,%x2,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n-;; Special version of copysign for single precision that knows internally\n-;; scalar single values are kept as double\n-(define_insn \"vsx_copysignsf3\"\n-  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n-\t(if_then_else:SF\n-\t (ge:SF (match_operand:SF 2 \"vsx_register_operand\" \"f\")\n-\t\t(match_operand:SF 3 \"zero_constant\" \"j\"))\n-\t (abs:SF (match_operand:SF 1 \"vsx_register_operand\" \"f\"))\n-\t (neg:SF (abs:SF (match_dup 1)))))]\n-  \"VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"xscpsgndp %x0,%x2,%x1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n-\n ;; For the conversions, limit the register class for the integer value to be\n ;; the fprs because we don't want to add the altivec registers to movdi/movsi.\n ;; For the unsigned tests, there isn't a generic double -> unsigned conversion"}]}