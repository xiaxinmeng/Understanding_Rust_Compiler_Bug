{"sha": "909f21b39e4d27523d76258a039fd79911f11494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA5ZjIxYjM5ZTRkMjc1MjNkNzYyNThhMDM5ZmQ3OTkxMWYxMTQ5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-28T21:37:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-28T21:37:16Z"}, "message": "decl.c: Remove calls to add_decl_expr...\n\n\t* decl.c: Remove calls to add_decl_expr, pushdecl, rest_of_compilation,\n\tand rest_of_type_compilation; add arg to create_*_decl.\n \t(annotate_decl_with_node): Deleted.\n\t(gnat_to_gnu_entity, case E_Array_Type): Set location of fields.\n\t* gigi.h (get_decls, block_has_vars, pushdecl): Deleted.\n\t(get_current_block_context, gnat_pushdecl): New declarations.\n\t(gnat_init_stmt_group): Likewise.\n\t(create_var_decl, create_type_decl, create_subprog_decl): Add new arg.\n\t* misc.c (LANG_HOOKS_CLEAR_BINDING_STACK): Deleted.\n\t(LANG_HOOKS_GETDECLS, LANG_HOOKS_PUSHDECL): Deleted.\n\t(gnat_init): Call gnat_init_stmt_group.\n\t* trans.c (global_stmt_group, gnu_elab_proc_decl): New variables.\n\t(gnu_pending_elaboration_list): Deleted.\n\t(mark_visited, mark_unvisited, gnat_init_stmt_group): New functions.\n\t(gigi): Rearrange initialization calls and move some to last above.\n\t(gnat_to_gnu): If statement and not in procedure, go into elab proc.\n\tDelete calls to add_decl_expr; add arg to create_*_decl.\n\t(gnat_to_gnu, case N_Loop): Recalculate side effects on COND_EXPR.\n\t(gnat_to_gnu, case N_Subprogram_Body): Move some code to\n\tbegin_subprog_body and call it.\n\tDon't push and pop ggc context.\n\t(gnat_to_gnu, case N_Compilation_Unit): Rework to support elab proc.\n\t(add_stmt): Remove handling of DECL_EXPR from here.\n\tIf not in function, mark visited.\n\t(add_decl_expr): Put global at top level.\n\tCheck for cases of DECL_INITIAL we have to handle here.\n\t(process_type): Add extra arg to create_type_decl.\n\t(build_unit_elab): Rework to just gimplify.\n\t* utils.c (pending_elaborations, elist_stack, getdecls): Deleted.\n\t(block_has_vars, mark_visited, add_pending_elaborations): Likewise.\n\t(get_pending_elaborations, pending_elaborations_p): Likewise.\n\t(push_pending_elaborations, pop_pending_elaborations): Likewise.\n\t(get_elaboration_location, insert_elaboration_list): Likewise.\n\t(gnat_binding_level): Renamed from ada_binding_level.\n\t(init_gnat_to_gnu): Don't clear pending_elaborations.\n\t(global_bindings_p): Treat as global if no current_binding_level.\n\t(set_current_block_context): New function.\n\t(gnat_pushdecl): Renamed from pushdecl; major rework.\n\tAll callers changed.\n\t(create_type_decl, create_var_decl, create_subprog_decl): Add new arg.\n\t(finish_record_type): Call call pushdecl for stub decl.\n\t(function_nesting_depth): Deleted.\n\t(begin_subprog_body): Delete obsolete code.\n\t* utils2.c (build_call_alloc_dealloc): Add new arg to create_var_decl.\n\nFrom-SVN: r83816", "tree": {"sha": "a44463195d1b28c4051fddd70db0dd209f3a0fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a44463195d1b28c4051fddd70db0dd209f3a0fe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/909f21b39e4d27523d76258a039fd79911f11494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909f21b39e4d27523d76258a039fd79911f11494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909f21b39e4d27523d76258a039fd79911f11494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909f21b39e4d27523d76258a039fd79911f11494/comments", "author": null, "committer": null, "parents": [{"sha": "0b55e9321430150f742bc7be3f7da16b1a3872d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b55e9321430150f742bc7be3f7da16b1a3872d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b55e9321430150f742bc7be3f7da16b1a3872d5"}], "stats": {"total": 1137, "additions": 511, "deletions": 626}, "files": [{"sha": "22d06441bca3fae5612d8cd1fd521b94ce0d5a60", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -1,3 +1,50 @@\n+2004-06-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c: Remove calls to add_decl_expr, pushdecl, rest_of_compilation,\n+\tand rest_of_type_compilation; add arg to create_*_decl.\n+ \t(annotate_decl_with_node): Deleted.\n+\t(gnat_to_gnu_entity, case E_Array_Type): Set location of fields.\n+\t* gigi.h (get_decls, block_has_vars, pushdecl): Deleted.\n+\t(get_current_block_context, gnat_pushdecl): New declarations.\n+\t(gnat_init_stmt_group): Likewise.\n+\t(create_var_decl, create_type_decl, create_subprog_decl): Add new arg.\n+\t* misc.c (LANG_HOOKS_CLEAR_BINDING_STACK): Deleted.\n+\t(LANG_HOOKS_GETDECLS, LANG_HOOKS_PUSHDECL): Deleted.\n+\t(gnat_init): Call gnat_init_stmt_group.\n+\t* trans.c (global_stmt_group, gnu_elab_proc_decl): New variables.\n+\t(gnu_pending_elaboration_list): Deleted.\n+\t(mark_visited, mark_unvisited, gnat_init_stmt_group): New functions.\n+\t(gigi): Rearrange initialization calls and move some to last above.\n+\t(gnat_to_gnu): If statement and not in procedure, go into elab proc.\n+\tDelete calls to add_decl_expr; add arg to create_*_decl.\n+\t(gnat_to_gnu, case N_Loop): Recalculate side effects on COND_EXPR.\n+\t(gnat_to_gnu, case N_Subprogram_Body): Move some code to \n+\tbegin_subprog_body and call it.\n+\tDon't push and pop ggc context.\n+\t(gnat_to_gnu, case N_Compilation_Unit): Rework to support elab proc.\n+\t(add_stmt): Remove handling of DECL_EXPR from here.\n+\tIf not in function, mark visited.\n+\t(add_decl_expr): Put global at top level.\n+\tCheck for cases of DECL_INITIAL we have to handle here.\n+\t(process_type): Add extra arg to create_type_decl.\n+\t(build_unit_elab): Rework to just gimplify.\n+\t* utils.c (pending_elaborations, elist_stack, getdecls): Deleted.\n+\t(block_has_vars, mark_visited, add_pending_elaborations): Likewise.\n+\t(get_pending_elaborations, pending_elaborations_p): Likewise.\n+\t(push_pending_elaborations, pop_pending_elaborations): Likewise.\n+\t(get_elaboration_location, insert_elaboration_list): Likewise.\n+\t(gnat_binding_level): Renamed from ada_binding_level.\n+\t(init_gnat_to_gnu): Don't clear pending_elaborations.\n+\t(global_bindings_p): Treat as global if no current_binding_level.\n+\t(set_current_block_context): New function.\n+\t(gnat_pushdecl): Renamed from pushdecl; major rework.\n+\tAll callers changed.\n+\t(create_type_decl, create_var_decl, create_subprog_decl): Add new arg.\n+\t(finish_record_type): Call call pushdecl for stub decl.\n+\t(function_nesting_depth): Deleted.\n+\t(begin_subprog_body): Delete obsolete code.\n+\t* utils2.c (build_call_alloc_dealloc): Add new arg to create_var_decl.\n+\t\n 2004-06-28  Robert Dewar  <dewar@gnat.com>\n \n \t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb,"}, {"sha": "5ef6ef5db9f57655b7b4859ec090ef2e2b016c35", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 60, "deletions": 95, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -103,7 +103,6 @@ static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, int);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static void check_ok_for_atomic (tree, Entity_Id, int);\n-static void annotate_decl_with_node (tree, Node_Id);\n \f\n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n@@ -957,9 +956,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_new_var\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n \t\t\t\t NULL_TREE, gnu_new_type, gnu_expr,\n-\t\t\t\t 0, 0, 0, 0, 0);\n-\t    annotate_decl_with_node (gnu_new_var, gnat_entity);\n-\t    add_decl_expr (gnu_new_var, gnat_entity);\n+\t\t\t\t 0, 0, 0, 0, 0, gnat_entity);\n \n \t    if (gnu_expr != 0)\n \t      add_stmt_with_node\n@@ -1028,8 +1025,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    gnu_expr, const_flag,\n \t\t\t\t    Is_Public (gnat_entity),\n \t\t\t\t    imported_p || !definition,\n-\t\t\t\t    static_p, attr_list);\n-\tannotate_decl_with_node (gnu_decl, gnat_entity);\n+\t\t\t\t    static_p, attr_list, gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \n@@ -1041,8 +1037,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Present (Address_Clause (gnat_entity)) && used_by_ref)\n \t  DECL_POINTER_ALIAS_SET (gnu_decl) = 0;\n \n-\tadd_decl_expr (gnu_decl, gnat_entity);\n-\n \tif (definition && DECL_SIZE (gnu_decl) != 0\n \t    && get_block_jmpbuf_decl ()\n \t    && (TREE_CODE (DECL_SIZE (gnu_decl)) != INTEGER_CST\n@@ -1069,9 +1063,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tree gnu_corr_var\n \t      = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_expr, 0, Is_Public (gnat_entity), 0,\n-\t\t\t\t static_p, 0);\n+\t\t\t\t static_p, 0, gnat_entity);\n \n-\t    add_decl_expr (gnu_corr_var, gnat_entity);\n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }\n \n@@ -1152,9 +1145,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\tgnu_type);\n \t    tree gnu_literal\n \t      = create_var_decl (get_entity_name (gnat_literal),\n-\t\t\t\t 0, gnu_type, gnu_value, 1, 0, 0, 0, 0);\n+\t\t\t\t 0, gnu_type, gnu_value, 1, 0, 0, 0, 0,\n+\t\t\t\t gnat_literal);\n \n-\t    add_decl_expr (gnu_literal, gnat_literal);\n \t    save_gnu_tree (gnat_literal, gnu_literal, 0);\n \t    gnu_literal_list = tree_cons (DECL_NAME (gnu_literal),\n \t\t\t\t\t  gnu_value, gnu_literal_list);\n@@ -1463,7 +1456,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    this_deferred = this_made_decl = 1;\n \t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t\t ! Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p);\n+\t\t\t\t\t debug_info_p, gnat_entity);\n \t    save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t    saved = 1;\n \t  }\n@@ -1526,8 +1519,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t       gnu_ind_subtype,\n \t\t\t\t\t       gnu_template_type, 0, 0, 0, 0);\n \n-\t    annotate_decl_with_node (gnu_min_field, gnat_entity);\n-\t    annotate_decl_with_node (gnu_max_field, gnat_entity);\n+\t    Sloc_to_locus (Sloc (gnat_entity),\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_min_field));\n+\t    Sloc_to_locus (Sloc (gnat_entity),\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_max_field));\n \t    gnu_temp_fields[index] = chainon (gnu_min_field, gnu_max_field);\n \n \t    /* We can't use build_component_ref here since the template\n@@ -1669,8 +1664,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"),\n \t\t\t  tem, 0, ! Comes_From_Source (gnat_entity),\n-\t\t\t  debug_info_p);\n-\trest_of_type_compilation (gnu_fat_type, global_bindings_p ());\n+\t\t\t  debug_info_p, gnat_entity);\n \n \t/* Create a record type for the object and its template and\n \t   set the template at a negative offset.  */\n@@ -1688,7 +1682,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Give the thin pointer type a name.  */\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUX\"),\n \t\t\t  build_pointer_type (tem), 0,\n-\t\t\t  ! Comes_From_Source (gnat_entity), debug_info_p);\n+\t\t\t  ! Comes_From_Source (gnat_entity), debug_info_p,\n+\t\t\t  gnat_entity);\n       }\n       break;\n \n@@ -2060,8 +2055,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t* Treat_As_Volatile (gnat_entity))));\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       ! Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p);\n-\t  annotate_decl_with_node (gnu_decl, gnat_entity);\n+\t\t\t\t       debug_info_p, gnat_entity);\n \t  if (! Comes_From_Source (gnat_entity))\n \t    DECL_ARTIFICIAL (gnu_decl) = 1;\n \n@@ -2291,8 +2285,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    this_deferred = 1;\n \t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t\t ! Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p);\n-\t    annotate_decl_with_node (gnu_decl, gnat_entity);\n+\t\t\t\t\t debug_info_p, gnat_entity);\n \t    save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t    this_made_decl = saved = 1;\n \t  }\n@@ -2571,7 +2564,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_id;\n \t      TYPE_STUB_DECL (gnu_type)\n-\t\t= pushdecl (build_decl (TYPE_DECL, NULL_TREE, gnu_type));\n+\t\t= create_type_decl (NULL_TREE, gnu_type, NULL, 0, 0,\n+\t\t\t\t    gnat_entity);\n \t      TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_base_type);\n \n \t      for (gnat_field = First_Entity (gnat_entity);\n@@ -2736,11 +2730,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \t      TYPE_NAME (gnu_type) = gnu_entity_id;\n \t      TYPE_STUB_DECL (gnu_type)\n-\t\t= pushdecl (build_decl (TYPE_DECL, TYPE_NAME (gnu_type),\n-\t\t\t\t      gnu_type));\n-\t      DECL_ARTIFICIAL (TYPE_STUB_DECL (gnu_type)) = 1;\n-\t      DECL_IGNORED_P (TYPE_STUB_DECL (gnu_type)) = ! debug_info_p;\n-\t      rest_of_type_compilation (gnu_type, global_bindings_p ());\n+\t\t= create_type_decl (TYPE_NAME (gnu_type), gnu_type,\n+\t\t\t\t    NULL, 1, debug_info_p, gnat_entity);\n \t    }\n \n \t  /* Otherwise, go down all the components in the new type and\n@@ -2772,7 +2763,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       ! Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p);\n+\t\t\t\t       debug_info_p, gnat_entity);\n \t  save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t  this_made_decl = saved = 1;\n \n@@ -3039,7 +3030,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t\t ! Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p);\n+\t\t\t\t\t debug_info_p, gnat_entity);\n \t    save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t    this_made_decl = saved = 1;\n \n@@ -3500,7 +3491,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tDECL_POINTS_TO_READONLY_P (gnu_param)\n \t\t  = (Ekind (gnat_param) == E_In_Parameter\n \t\t     && (by_ref_p || by_component_ptr_p));\n-\t\tannotate_decl_with_node (gnu_param, gnat_param);\n+\t\tSloc_to_locus (Sloc (gnat_param),\n+\t\t\t       &DECL_SOURCE_LOCATION (gnu_param));\n \t\tsave_gnu_tree (gnat_param, gnu_param, 0);\n \t\tgnu_param_list = chainon (gnu_param, gnu_param_list);\n \n@@ -3528,7 +3520,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\tgnu_field = create_field_decl (gnu_param_name, gnu_param_type,\n \t\t\t\t\t       gnu_return_type, 0, 0, 0, 0);\n-\t\tannotate_decl_with_node (gnu_field, gnat_param);\n+\t\tSloc_to_locus (Sloc (gnat_param),\n+\t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n \t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n \t\tgnu_field_list = gnu_field;\n \t\tgnu_return_list = tree_cons (gnu_field, gnu_param,\n@@ -3625,21 +3618,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_decl\n \t      = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_address, 0, Is_Public (gnat_entity),\n-\t\t\t\t extern_flag, 0, 0);\n+\t\t\t\t extern_flag, 0, 0, gnat_entity);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n-\t    add_decl_expr (gnu_decl, gnat_entity);\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       ! Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p);\n+\t\t\t\t       debug_info_p, gnat_entity);\n \telse\n \t  {\n \t    gnu_decl = create_subprog_decl (gnu_entity_id, gnu_ext_name,\n \t\t\t\t\t    gnu_type, gnu_param_list,\n \t\t\t\t\t    inline_flag, public_flag,\n-\t\t\t\t\t    extern_flag, attr_list);\n+\t\t\t\t\t    extern_flag, attr_list,\n+\t\t\t\t\t    gnat_entity);\n \t    DECL_STUBBED_P (gnu_decl)\n \t      = Convention (gnat_entity) == Convention_Stubbed;\n \t  }\n@@ -3700,8 +3693,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t updates when we see it.  */\n       gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t   ! Comes_From_Source (gnat_entity),\n-\t\t\t\t   debug_info_p);\n-      annotate_decl_with_node (gnu_decl, gnat_entity);\n+\t\t\t\t   debug_info_p, gnat_entity);\n       save_gnu_tree (Full_View (gnat_entity), gnu_decl, 0);\n       break;\n \n@@ -3916,16 +3908,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_USER_ALIGN (gnu_type) = 1;\n \n       if (gnu_decl == 0)\n-\t{\n-\t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t       ! Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p);\n-\t  annotate_decl_with_node (gnu_decl, gnat_entity);\n-\t}\n+\tgnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t\t\t\t     ! Comes_From_Source (gnat_entity),\n+\t\t\t\t     debug_info_p, gnat_entity);\n       else\n \tTREE_TYPE (gnu_decl) = gnu_type;\n-\n-      add_decl_expr (gnu_decl, gnat_entity);\n     }\n \n   if (IN (kind, Type_Kind) && ! TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n@@ -4018,7 +4005,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_MAX_VALUE (gnu_scalar_type)\n \t= gnat_to_gnu (Type_High_Bound (gnat_entity));\n \n-      if (kind == E_Enumeration_Type)\n+      if (TREE_CODE (gnu_scalar_type) == ENUMERAL_TYPE)\n \t{\n \t  TYPE_STUB_DECL (gnu_scalar_type) = gnu_decl;\n \n@@ -4301,11 +4288,10 @@ make_dummy_type (Entity_Id gnat_type)\n     gnu_type = make_node (ENUMERAL_TYPE);\n \n   TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n+  TYPE_DUMMY_P (gnu_type) = 1;\n   if (AGGREGATE_TYPE_P (gnu_type))\n-    TYPE_STUB_DECL (gnu_type)\n-      = pushdecl (build_decl (TYPE_DECL, NULL_TREE, gnu_type));\n+    TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n \n-  TYPE_DUMMY_P (gnu_type) = 1;\n   dummy_node_table[gnat_underlying] = gnu_type;\n \n   return gnu_type;\n@@ -4538,15 +4524,12 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n \n   /* Now create the variable if we need it.  */\n   if (need_debug || (expr_variable && expr_global))\n-    {\n-      gnu_decl\n-\t= create_var_decl (create_concat_name (gnat_entity,\n-\t\t\t\t\t       IDENTIFIER_POINTER (gnu_name)),\n-\t\t\t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, 1,\n-\t\t\t   Is_Public (gnat_entity), ! definition, 0, 0);\n-      annotate_decl_with_node (gnu_decl, gnat_entity);\n-      add_decl_expr (gnu_decl, gnat_entity);\n-    }\n+    gnu_decl\n+      = create_var_decl (create_concat_name (gnat_entity,\n+\t\t\t\t\t     IDENTIFIER_POINTER (gnu_name)),\n+\t\t\t NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, 1,\n+\t\t\t Is_Public (gnat_entity), ! definition, 0, 0,\n+\t\t\t gnat_entity);\n \n   /* We only need to use this variable if we are in global context since GCC\n      can do the right thing in the local case.  */\n@@ -4757,7 +4740,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t      0, ! Comes_From_Source (gnat_entity),\n \t\t      ! (TYPE_NAME (type) != 0\n \t\t\t && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t\t\t && DECL_IGNORED_P (TYPE_NAME (type))));\n+\t\t\t && DECL_IGNORED_P (TYPE_NAME (type))),\n+\t\t      gnat_entity);\n \n   /* If we are changing the alignment and the input type is a record with\n      BLKmode and a small constant size, try to make a form that has an\n@@ -4805,7 +4789,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t  || ! DECL_IGNORED_P (TYPE_NAME (type))))\n     {\n       tree marker = make_node (RECORD_TYPE);\n-      tree name = DECL_NAME (TYPE_NAME (record));\n+      tree name = (TREE_CODE (TYPE_NAME (record)) == TYPE_DECL\n+\t\t   ? DECL_NAME (TYPE_NAME (record))\n+\t\t   : TYPE_NAME (record));\n       tree orig_name = TYPE_NAME (type);\n \n       if (TREE_CODE (orig_name) == TYPE_DECL)\n@@ -4819,13 +4805,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t  0, 0);\n \n       if (size != 0 && TREE_CODE (size) != INTEGER_CST && definition)\n-\t{\n-\t  tree gnu_xvz\n-\t    = create_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n-\t\t\t       sizetype, TYPE_SIZE (record), 0, 0, 0, 0, 0);\n-\n-\t  add_decl_expr (gnu_xvz, gnat_entity);\n-\t}\n+\tcreate_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n+\t\t\t sizetype, TYPE_SIZE (record), 0, 0, 0, 0, 0,\n+\t\t\t gnat_entity);\n     }\n \n   type = record;\n@@ -4965,9 +4947,7 @@ choices_to_gnu (tree operand, Node_Id choices)\n    DEFINITION is nonzero if this field is for a record being defined.  */\n \n static tree\n-gnat_to_gnu_field (Entity_Id gnat_field,\n-                   tree gnu_record_type,\n-                   int packed,\n+gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n                    int definition)\n {\n   tree gnu_field_id = get_entity_name (gnat_field);\n@@ -5181,7 +5161,7 @@ gnat_to_gnu_field (Entity_Id gnat_field,\n   gnu_field = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n \t\t\t\t packed, gnu_size, gnu_pos,\n \t\t\t\t Is_Aliased (gnat_field));\n-  annotate_decl_with_node (gnu_field, gnat_field);\n+  Sloc_to_locus (Sloc (gnat_field), &DECL_SOURCE_LOCATION (gnu_field));\n   TREE_THIS_VOLATILE (gnu_field) = Treat_As_Volatile (gnat_field);\n \n   if (Ekind (gnat_field) == E_Discriminant)\n@@ -5250,14 +5230,9 @@ is_variable_size (tree type)\n    fields of the record and then the record type is finished.  */\n \n static void\n-components_to_record (tree gnu_record_type,\n-                      Node_Id component_list,\n-                      tree gnu_field_list,\n-                      int packed,\n-                      int definition,\n-                      tree *p_gnu_rep_list,\n-                      int cancel_alignment,\n-                      int all_rep)\n+components_to_record (tree gnu_record_type, Node_Id component_list,\n+                      tree gnu_field_list, int packed, int definition,\n+                      tree *p_gnu_rep_list, int cancel_alignment, int all_rep)\n {\n   Node_Id component_decl;\n   Entity_Id gnat_field;\n@@ -6185,21 +6160,11 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, int comp_p)\n \t\t   gnat_error_point, gnat_entity);\n }\n \f\n-/* Set the DECL_SOURCE_LOCATION of GNU_DECL to the location of\n-   GNAT_NODE.  */\n-\n-static void\n-annotate_decl_with_node (tree gnu_decl, Node_Id gnat_node)\n-{\n-  Sloc_to_locus (Sloc (gnat_node), &DECL_SOURCE_LOCATION (gnu_decl));\n-}\n-\f\n-/* Given a type T, a FIELD_DECL F, and a replacement value R,\n-   return a new type with all size expressions that contain F\n-   updated by replacing F with R.  This is identical to GCC's\n-   substitute_in_type except that it knows about TYPE_INDEX_TYPE.\n-   If F is NULL_TREE, always make a new RECORD_TYPE, even if nothing has\n-   changed.  */\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new type\n+   with all size expressions that contain F updated by replacing F with R.\n+   This is identical to GCC's substitute_in_type except that it knows about\n+   TYPE_INDEX_TYPE.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n+   nothing has changed.  */\n \n tree\n gnat_substitute_in_type (tree t, tree f, tree r)"}, {"sha": "e63334189ad265ea16c1a23fec938ea12f36e065", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -110,8 +110,6 @@ extern tree get_unpadded_type (Entity_Id);\n /* Called when we need to protect a variable object using a save_expr.  */\n extern tree maybe_variable (tree);\n \n-/* Create a record type that contains a field of TYPE with a starting bit\n-   position so that it is aligned to ALIGN bits.  */\n /* Create a record type that contains a field of TYPE with a starting bit\n    position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n extern tree make_aligning_type (tree, int, tree);\n@@ -367,14 +365,14 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n /* Returns non-zero if we are currently in the global binding level       */\n extern int global_bindings_p (void);\n \n-/* Returns the list of declarations in the current level. Note that this list\n-   is in reverse order (it has to be so for back-end compatibility).  */\n-extern tree getdecls (void);\n-\n /* Enter and exit a new binding level. */\n extern void gnat_pushlevel (void);\n extern void gnat_poplevel (void);\n \n+/* Set SUPERCONTEXT of the BLOCK for the current binding level to FNDECL\n+   and point FNDECL to this BLOCK.  */\n+extern void set_current_block_context (tree);\n+\n /* Set the jmpbuf_decl for the current binding level to DECL.  */\n extern void set_block_jmpbuf_decl (tree);\n \n@@ -386,15 +384,11 @@ extern tree get_block_jmpbuf_decl (void);\n    to handle the BLOCK node inside the BIND_EXPR.  */\n extern void insert_block (tree);\n \n-/* Return nonzero if the are any variables in the current block.  */\n-extern int block_has_vars (void);\n+/* Records a ..._DECL node DECL as belonging to the current lexical scope\n+   and uses GNAT_ENTITY for location information.  */\n+extern void gnat_pushdecl (tree, Entity_Id);\n \n-/* Records a ..._DECL node DECL as belonging to the current lexical scope.\n-   Returns the ..._DECL node. */\n-extern tree pushdecl (tree);\n-\n-/* Create the predefined scalar types such as `integer_type_node' needed\n-   in the gcc back-end and initialize the global binding level.  */\n+extern void gnat_init_stmt_group (void);\n extern void gnat_init_decl_processing (void);\n extern void init_gigi_decls (tree, tree);\n extern void gnat_init_gcc_eh (void);\n@@ -476,8 +470,9 @@ extern tree create_index_type (tree, tree, tree);\n    string) and TYPE is a ..._TYPE node giving its data type.\n    ARTIFICIAL_P is nonzero if this is a declaration that was generated\n    by the compiler.  DEBUG_INFO_P is nonzero if we need to write debugging\n-   information about this type.  */\n-extern tree create_type_decl (tree, tree, struct attrib *, int, int);\n+   information about this type.  GNAT_NODE is used for the position of\n+   the decl.  */\n+extern tree create_type_decl (tree, tree, struct attrib *, int, int, Node_Id);\n \n /* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n    ASM_NAME is its assembler name (if provided).  TYPE is\n@@ -492,9 +487,11 @@ extern tree create_type_decl (tree, tree, struct attrib *, int, int);\n    when processing an external variable declaration (as opposed to a\n    definition: no storage is to be allocated for the variable here).\n    STATIC_FLAG is only relevant when not at top level.  In that case\n-   it indicates whether to always allocate storage to the variable.  */\n+   it indicates whether to always allocate storage to the variable.\n+\n+   GNAT_NODE is used for the position of the decl.  */\n extern tree create_var_decl (tree, tree, tree, tree, int, int, int, int,\n-\t\t\t     struct attrib *);\n+\t\t\t     struct attrib *, Node_Id);\n \n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n extern void process_attributes (tree, struct attrib *);\n@@ -542,10 +539,10 @@ extern tree create_param_decl (tree, tree, int);\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the TREE_CHAIN field).\n \n-   INLINE_FLAG, PUBLIC_FLAG, and EXTERN_FLAG are used to set the appropriate\n-   fields in the FUNCTION_DECL.  */\n+   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n+   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */ \n extern tree create_subprog_decl (tree, tree, tree, tree, int, int, int,\n-\t\t\t\t struct attrib *);\n+\t\t\t\t struct attrib *, Node_Id);\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n extern tree create_label_decl (tree);"}, {"sha": "5f2200ba71de0ae2555fb4f7d260f4f6336fc23f", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -123,12 +123,18 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #define LANG_HOOKS_HONOR_READONLY\ttrue\n #undef LANG_HOOKS_HASH_TYPES\n #define LANG_HOOKS_HASH_TYPES\t\tfalse\n+#undef LANG_HOOKS_CLEAR_BINDING_STACK\n+#define LANG_HOOKS_CLEAR_BINDING_STACK\tlhd_do_nothing\n #undef LANG_HOOKS_PUSHLEVEL\n #define LANG_HOOKS_PUSHLEVEL\t\tlhd_do_nothing_i\n #undef LANG_HOOKS_POPLEVEL\n #define LANG_HOOKS_POPLEVEL\t\tlhd_do_nothing_iii_return_null_tree\n #undef LANG_HOOKS_SET_BLOCK\n #define LANG_HOOKS_SET_BLOCK\t\tlhd_do_nothing_t\n+#undef LANG_HOOKS_GETDECLS\n+#define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n+#undef LANG_HOOKS_PUSHDECL\n+#define LANG_HOOKS_PUSHDECL\t\tlhd_return_tree\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n #undef LANG_HOOKS_GET_ALIAS_SET\n@@ -392,6 +398,9 @@ internal_error_function (const char *msgid, va_list *ap)\n static bool\n gnat_init (void)\n {\n+  /* Initialize translations and the outer statement group.  */\n+  gnat_init_stmt_group ();\n+\n   /* Performs whatever initialization steps needed by the language-dependent\n      lexical analyzer.  */\n   gnat_init_decl_processing ();"}, {"sha": "5992ce70095f7d0c29c2b715be85ccdcd23f0f70", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 231, "deletions": 202, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -88,6 +88,7 @@ struct stmt_group GTY((chain_next (\"%h.previous\"))) {\n };\n \n static GTY(()) struct stmt_group *current_stmt_group;\n+static struct stmt_group *global_stmt_group;\n \n /* List of unused struct stmt_group nodes.  */\n static GTY((deletable)) struct stmt_group *stmt_group_free_list;\n@@ -113,9 +114,8 @@ static GTY(()) tree gnu_loop_label_stack;\n    TREE_VALUE of each entry is the label at the end of the switch.  */\n static GTY(()) tree gnu_switch_label_stack;\n \n-/* List of TREE_LIST nodes containing pending elaborations lists.\n-   used to prevent the elaborations being reclaimed by GC.  */\n-static GTY(()) tree gnu_pending_elaboration_lists;\n+/* The FUNCTION_DECL for the elaboration procedure for the main unit.  */\n+static GTY(()) tree gnu_elab_proc_decl;\n \n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n@@ -127,6 +127,8 @@ static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n static void start_stmt_group (void);\n static void add_cleanup (tree);\n+static tree mark_visited (tree *, int *, void *);\n+static tree mark_unvisited (tree *, int *, void *);\n static tree end_stmt_group (void);\n static void add_stmt_list (List_Id);\n static tree build_stmt_group (List_Id, bool);\n@@ -148,7 +150,7 @@ static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference_1 (tree, int);\n-static int build_unit_elab (Entity_Id, int, tree);\n+static bool build_unit_elab (void);\n static void annotate_with_node (tree, Node_Id);\n \n /* Constants for +0.5 and -0.5 for float-to-integer rounding.  */\n@@ -159,22 +161,13 @@ static REAL_VALUE_TYPE dconstmp5;\n    structures and then generates code.  */\n \n void\n-gigi (Node_Id gnat_root,\n-      int max_gnat_node,\n-      int number_name,\n-      struct Node *nodes_ptr,\n-      Node_Id *next_node_ptr,\n-      Node_Id *prev_node_ptr,\n-      struct Elist_Header *elists_ptr,\n-      struct Elmt_Item *elmts_ptr,\n-      struct String_Entry *strings_ptr,\n-      Char_Code *string_chars_ptr,\n-      struct List_Header *list_headers_ptr,\n-      Int number_units ATTRIBUTE_UNUSED,\n-      char *file_info_ptr ATTRIBUTE_UNUSED,\n-      Entity_Id standard_integer,\n-      Entity_Id standard_long_long_float,\n-      Entity_Id standard_exception_type,\n+gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n+      struct Node *nodes_ptr, Node_Id *next_node_ptr, Node_Id *prev_node_ptr,\n+      struct Elist_Header *elists_ptr, struct Elmt_Item *elmts_ptr,\n+      struct String_Entry *strings_ptr, Char_Code *string_chars_ptr,\n+      struct List_Header *list_headers_ptr, Int number_units ATTRIBUTE_UNUSED,\n+      char *file_info_ptr ATTRIBUTE_UNUSED, Entity_Id standard_integer,\n+      Entity_Id standard_long_long_float, Entity_Id standard_exception_type,\n       Int gigi_operating_mode)\n {\n   tree gnu_standard_long_long_float;\n@@ -193,6 +186,10 @@ gigi (Node_Id gnat_root,\n \n   type_annotate_only = (gigi_operating_mode == 1);\n \n+  init_gnat_to_gnu ();\n+  gnat_compute_largest_alignment ();\n+  init_dummy_type ();\n+\n   /* If we are just annotating types, give VOID_TYPE zero sizes to avoid\n      errors.  */\n   if (type_annotate_only)\n@@ -204,20 +201,6 @@ gigi (Node_Id gnat_root,\n   if (Nkind (gnat_root) != N_Compilation_Unit)\n     gigi_abort (301);\n \n-  /* Initialize ourselves.  */\n-  init_gnat_to_gnu ();\n-  init_dummy_type ();\n-  init_code_table ();\n-  gnat_compute_largest_alignment ();\n-  start_stmt_group ();\n-\n-  /* Enable GNAT stack checking method if needed */\n-  if (!Stack_Check_Probes_On_Target)\n-    set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n-\n-  if (Exception_Mechanism == Front_End_ZCX)\n-    abort ();\n-\n   /* Save the type we made for integer as the type for Standard.Integer.\n      Then make the rest of the standard types.  Note that some of these\n      may be subtypes.  */\n@@ -226,9 +209,6 @@ gigi (Node_Id gnat_root,\n \n   gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n \n-  REAL_ARITHMETIC (dconstp5, RDIV_EXPR, dconst1, dconst2);\n-  REAL_ARITHMETIC (dconstmp5, RDIV_EXPR, dconstm1, dconst2);\n-\n   gnu_standard_long_long_float\n     = gnat_to_gnu_entity (Base_Type (standard_long_long_float), NULL_TREE, 0);\n   gnu_standard_exception_type\n@@ -251,6 +231,28 @@ gigi (Node_Id gnat_root,\n   gnat_to_gnu (gnat_root);\n }\n \f\n+/* Perform initializations for this module.  */\n+\n+void\n+gnat_init_stmt_group ()\n+{\n+  /* Initialize ourselves.  */\n+  init_code_table ();\n+  start_stmt_group ();\n+\n+  global_stmt_group = current_stmt_group;\n+\n+  /* Enable GNAT stack checking method if needed */\n+  if (!Stack_Check_Probes_On_Target)\n+    set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n+\n+  if (Exception_Mechanism == Front_End_ZCX)\n+    abort ();\n+\n+  REAL_ARITHMETIC (dconstp5, RDIV_EXPR, dconst1, dconst2);\n+  REAL_ARITHMETIC (dconstmp5, RDIV_EXPR, dconstm1, dconst2);\n+}\n+\f\n /* This function is the driver of the GNAT to GCC tree transformation\n    process.  It is the entry point of the tree transformer.  GNAT_NODE is the\n    root of some GNAT tree.  Return the root of the corresponding GCC tree.\n@@ -263,6 +265,7 @@ gigi (Node_Id gnat_root,\n tree\n gnat_to_gnu (Node_Id gnat_node)\n {\n+  bool went_into_elab_proc = false;\n   tree gnu_result = error_mark_node; /* Default to no value. */\n   tree gnu_result_type = void_type_node;\n   tree gnu_expr;\n@@ -287,6 +290,27 @@ gnat_to_gnu (Node_Id gnat_node)\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n \t\t   build_call_raise (CE_Range_Check_Failed));\n \n+  /* If this is a Statement and we are at top level, it must be part of\n+     the elaboration procedure, so mark us as being in that procedure\n+     and push our context.  */\n+  if (!current_function_decl\n+      && ((IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n+\t   && Nkind (gnat_node) != N_Null_Statement)\n+\t  || Nkind (gnat_node) == N_Procedure_Call_Statement\n+\t  || Nkind (gnat_node) == N_Label\n+\t  || Nkind (gnat_node) == N_Handled_Sequence_Of_Statements\n+\t  || ((Nkind (gnat_node) == N_Raise_Constraint_Error\n+\t       || Nkind (gnat_node) == N_Raise_Storage_Error\n+\t       || Nkind (gnat_node) == N_Raise_Program_Error)\n+\t      && (Ekind (Etype (gnat_node)) == E_Void))))\n+    {\n+      current_function_decl = gnu_elab_proc_decl;\n+      start_stmt_group ();\n+      gnat_pushlevel ();\n+      went_into_elab_proc = true;\n+    }\n+\n+\n   switch (Nkind (gnat_node))\n     {\n       /********************************/\n@@ -721,14 +745,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    {\n \t      if ((Is_Public (gnat_temp) || global_bindings_p ())\n \t\t  && ! TREE_CONSTANT (gnu_expr))\n-\t\t{\n-\t\t  gnu_expr\n-\t\t    = create_var_decl (create_concat_name (gnat_temp, \"init\"),\n-\t\t\t\t       NULL_TREE, TREE_TYPE (gnu_expr),\n-\t\t\t\t       gnu_expr, 0, Is_Public (gnat_temp), 0,\n-\t\t\t\t       0, 0);\n-\t\t  add_decl_expr (gnu_expr, gnat_temp);\n-\t\t}\n+\t\tgnu_expr\n+\t\t  = create_var_decl (create_concat_name (gnat_temp, \"init\"),\n+\t\t\t\t     NULL_TREE, TREE_TYPE (gnu_expr),\n+\t\t\t\t     gnu_expr, 0, Is_Public (gnat_temp), 0,\n+\t\t\t\t     0, 0, gnat_temp);\n \t      else\n \t\tgnu_expr = maybe_variable (gnu_expr);\n \n@@ -995,15 +1016,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   Prefix is a unit, not an object with a GCC equivalent.  Similarly\n \t   for Elaborated, since that variable isn't otherwise known.  */\n \tif (attribute == Attr_Elab_Body || attribute == Attr_Elab_Spec)\n-\t  {\n-\t    gnu_prefix\n-\t      = create_subprog_decl\n-\t\t(create_concat_name (Entity (Prefix (gnat_node)),\n-\t\t\t\t     attribute == Attr_Elab_Body\n-\t\t\t\t     ? \"elabb\" : \"elabs\"),\n-\t\t NULL_TREE, void_ftype, NULL_TREE, 0, 1, 1, 0);\n-\t    return gnu_prefix;\n-\t  }\n+\t  return (create_subprog_decl\n+\t\t  (create_concat_name (Entity (Prefix (gnat_node)),\n+\t\t\t\t       attribute == Attr_Elab_Body\n+\t\t\t\t       ? \"elabb\" : \"elabs\"),\n+\t\t   NULL_TREE, void_ftype, NULL_TREE, 0, 1, 1, 0, gnat_node));\n \n \tgnu_prefix = gnat_to_gnu (Prefix (gnat_node));\n \tgnu_type = TREE_TYPE (gnu_prefix);\n@@ -2272,6 +2289,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  {\n \t    COND_EXPR_THEN (gnu_cond_expr) = gnu_loop_stmt;\n \t    gnu_result = gnu_cond_expr;\n+\t    recalculate_side_effects (gnu_cond_expr);\n \t  }\n \telse\n \t  gnu_result = gnu_loop_stmt;\n@@ -2489,31 +2507,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n \n-\t/* We handle pending sizes via the elaboration of types, so we don't\n-\t   need to save them.  This causes them to be marked as part of the\n-\t   outer function and then discarded.  */\n-\tget_pending_sizes ();\n-\n-\t/* ??? Temporarily do this to avoid GC throwing away outer stuff.  */\n-\tggc_push_context ();\n-\n \t/* Set the line number in the decl to correspond to that of\n \t   the body so that the line number notes are written\n \t   correctly.  */\n \tSloc_to_locus (Sloc (gnat_node),\n \t\t       &DECL_SOURCE_LOCATION (gnu_subprog_decl));\n \n-\tcurrent_function_decl = gnu_subprog_decl;\n-\tannounce_function (gnu_subprog_decl);\n+\tbegin_subprog_body (gnu_subprog_decl);\n \n-\t/* Enter a new binding level and show that all the parameters belong to\n-\t   this function.  */\n-\tgnat_pushlevel ();\n-\tfor (gnu_expr = DECL_ARGUMENTS (gnu_subprog_decl); gnu_expr;\n-\t     gnu_expr = TREE_CHAIN (gnu_expr))\n-\t  DECL_CONTEXT (gnu_expr) = gnu_subprog_decl;\n-\t\n-\tmake_decl_rtl (gnu_subprog_decl, NULL);\n \tgnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n \n \t/* If there are OUT parameters, we need to ensure that the return\n@@ -2595,8 +2596,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  }\n \n \tpop_stack (&gnu_return_label_stack);\n-\tif (!type_annotate_only)\n-\t  add_decl_expr (current_function_decl, gnat_node);\n \n \t/* Initialize the information node for the function and set the\n \t   end location.  */\n@@ -2621,7 +2620,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \tmark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n \twrite_symbols = save_write_symbols;\n \tdebug_hooks = save_debug_hooks;\n-\tggc_pop_context ();\n \tgnu_result = alloc_stmt_list ();\n       }\n       break;\n@@ -3151,7 +3149,29 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Compilation_Unit:\n \n-      start_stmt_group ();\n+      /* If this is the main unit, make the decl for the elaboration\n+\t procedure.  Otherwise, push a statement group for this nested\n+\t compilation unit.  */\n+      if (gnat_node == Cunit (Main_Unit))\n+\t{\n+\t  bool body_p = (Defining_Entity (Unit (gnat_node)),\n+\t\t\t Nkind (Unit (gnat_node)) == N_Package_Body\n+\t\t\t || Nkind (Unit (gnat_node)) == N_Subprogram_Body);\n+\t  Entity_Id gnat_unit_entity = Defining_Entity (Unit (gnat_node));\n+\n+\t  gnu_elab_proc_decl\n+\t    = create_subprog_decl\n+\t      (create_concat_name (gnat_unit_entity,\n+\t\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n+\t       NULL_TREE, void_ftype, NULL_TREE, 0, 1, 0, 0, gnat_unit_entity);\n+\n+\t  DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n+\t  allocate_struct_function (gnu_elab_proc_decl);\n+\t  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n+\t  cfun = 0;\n+\t}\n+      else\n+\tstart_stmt_group ();\n \n       /* For a body, first process the spec if there is one. */\n       if (Nkind (Unit (gnat_node)) == N_Package_Body\n@@ -3169,7 +3189,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      || Nkind (Unit (gnat_node)) == N_Generic_Package_Declaration\n \t      || Nkind (Unit (gnat_node)) == N_Generic_Subprogram_Declaration)\n \t    {\n-\t      gnu_result = end_stmt_group ();\n+\t      gnu_result = alloc_stmt_list ();\n \t      break;\n \t    }\n \t}\n@@ -3182,17 +3202,19 @@ gnat_to_gnu (Node_Id gnat_node)\n       add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n       add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n       \n-      /* Generate elaboration code for this unit, if necessary, and\n-\t say whether we did or not.  */\n-      Set_Has_No_Elaboration_Code\n-\t(gnat_node,\n-\t build_unit_elab\n-\t (Defining_Entity (Unit (gnat_node)),\n-\t  Nkind (Unit (gnat_node)) == N_Package_Body\n-\t  || Nkind (Unit (gnat_node)) == N_Subprogram_Body,\n-\t  get_pending_elaborations ()));\n-\n-      gnu_result = end_stmt_group ();\n+      /* If this is the main unit, generate elaboration code for this\n+\t unit, if necessary, and say whether we did or not.  Otherwise,\n+\t there is no elaboration code and we end our statement group. */\n+      if (gnat_node == Cunit (Main_Unit))\n+\t{\n+\t  Set_Has_No_Elaboration_Code (gnat_node, build_unit_elab ());\n+\t  gnu_result = alloc_stmt_list ();\n+\t}\n+      else\n+\t{\n+\t  Set_Has_No_Elaboration_Code (gnat_node, 1);\n+\t  gnu_result = end_stmt_group ();\n+\t}\n       break;\n \n     case N_Subprogram_Body_Stub:\n@@ -3258,8 +3280,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t     && Exception_Mechanism == Setjmp_Longjmp);\n \tbool at_end = !type_annotate_only && Present (At_End_Proc (gnat_node));\n \tbool binding_for_block = (at_end || gcc_zcx || setjmp_longjmp);\n-\t/* The statement(s) for the block itself.  */\n-\ttree gnu_inner_block;\n+\ttree gnu_inner_block; /* The statement(s) for the block itself.  */\n \n \t/* If there are any exceptions or cleanup processing involved, we need\n \t   an outer statement group (for Setjmp_Longjmp) and binding level.  */\n@@ -3285,14 +3306,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      = create_var_decl (get_identifier (\"JMPBUF_SAVE\"), NULL_TREE,\n \t\t\t\t jmpbuf_ptr_type,\n \t\t\t\t build_call_0_expr (get_jmpbuf_decl),\n-\t\t\t\t 0, 0, 0, 0, 0);\n+\t\t\t\t 0, 0, 0, 0, 0, gnat_node);\n \t    gnu_jmpbuf_decl\n \t      = create_var_decl (get_identifier (\"JMP_BUF\"),\n \t\t\t\t NULL_TREE, jmpbuf_type,\n-\t\t\t\t NULL_TREE, 0, 0, 0, 0, 0);\n+\t\t\t\t NULL_TREE, 0, 0, 0, 0, 0, gnat_node);\n \n-\t    add_decl_expr (gnu_jmpsave_decl, gnat_node);\n-\t    add_decl_expr (gnu_jmpbuf_decl, gnat_node);\n \t    set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n \n \t    /* When we exit this block, restore the saved value.  */\n@@ -3340,8 +3359,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t NULL_TREE,\n \t\t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t\t build_call_0_expr (get_excptr_decl),\n-\t\t\t\t\t 0, 0, 0, 0, 0));\n-\t    add_decl_expr (TREE_VALUE (gnu_except_ptr_stack), gnat_node);\n+\t\t\t\t\t 0, 0, 0, 0, 0, gnat_node));\n \n \t    /* Generate code for each handler. The N_Exception_Handler case\n \t       below does the real work and returns a COND_EXPR for each\n@@ -3602,9 +3620,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_incoming_exc_ptr\n \t    = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t\t       ptr_type_node, gnu_current_exc_ptr,\n-\t\t\t       0, 0, 0, 0, 0);\n+\t\t\t       0, 0, 0, 0, 0, gnat_node);\n \n-\t  add_decl_expr (gnu_incoming_exc_ptr, gnat_node);\n \t  add_stmt_with_node (build_call_1_expr (begin_handler_decl,\n \t\t\t\t\t\t gnu_incoming_exc_ptr),\n \t\t\t      gnat_node);\n@@ -3863,6 +3880,16 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = alloc_stmt_list ();\n     }\n \n+  /* If we pushed our level as part of processing the elaboration routine,\n+     pop it back now.  */\n+  if (went_into_elab_proc)\n+    {\n+      add_stmt (gnu_result);\n+      gnat_poplevel ();\n+      gnu_result = end_stmt_group ();\n+      current_function_decl = NULL_TREE;\n+    }\n+\n   /* Set the location information into the result.  If we're supposed to\n      return something of void_type, it means we have something we're\n      elaborating for effect, so just return.  */\n@@ -4030,28 +4057,10 @@ add_stmt (tree gnu_stmt)\n {\n   append_to_statement_list (gnu_stmt, &current_stmt_group->stmt_list);\n \n-  /* If this is a DECL_EXPR for a variable with DECL_INITIAL set\n-     and decl has a padded type, convert it to the unpadded type so the\n-     assignment is done properly.  In other case, the gimplification\n-     of the DECL_EXPR will deal with DECL_INITIAL.  */\n-  if (TREE_CODE (gnu_stmt) == DECL_EXPR\n-      && TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == VAR_DECL\n-      && DECL_INITIAL (DECL_EXPR_DECL (gnu_stmt))\n-      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (gnu_stmt))) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (TREE_TYPE (DECL_EXPR_DECL (gnu_stmt))))\n-    {\n-      tree gnu_decl = DECL_EXPR_DECL (gnu_stmt);\n-      tree gnu_lhs\n-\t= convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_decl))), gnu_decl);\n-      tree gnu_assign_stmt\n-\t= build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t   gnu_lhs, DECL_INITIAL (gnu_decl));\n-\n-      DECL_INITIAL (gnu_decl) = 0;\n-\n-      annotate_with_locus (gnu_assign_stmt, DECL_SOURCE_LOCATION (gnu_decl));\n-      add_stmt (gnu_assign_stmt);\n-    }\n+  /* If we're at top level, show everything in here is in use in case\n+     any of it is shared by a subprogram.  */\n+  if (!current_function_decl)\n+    walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n }\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n@@ -4070,6 +4079,8 @@ add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n void\n add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n {\n+  struct stmt_group *save_stmt_group = current_stmt_group;\n+\n   /* If this is a variable that Gigi is to ignore, we may have been given\n      an ERROR_MARK.  So test for it.  We also might have been given a\n      reference for a renaming.  So only do something for a decl.  Also\n@@ -4079,8 +4090,76 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n+  if (global_bindings_p ())\n+    current_stmt_group = global_stmt_group;\n+\n   add_stmt_with_node (build (DECL_EXPR, void_type_node, gnu_decl),\n \t\t      gnat_entity);\n+\n+  if (global_bindings_p ())\n+    current_stmt_group = save_stmt_group;\n+\n+  /* If this is a DECL_EXPR for a variable with DECL_INITIAl set,\n+     there are two cases we need to handle here.  */\n+  if (TREE_CODE (gnu_decl) == VAR_DECL && DECL_INITIAL (gnu_decl))\n+    {\n+      tree gnu_init = DECL_INITIAL (gnu_decl);\n+      tree gnu_lhs = NULL_TREE;\n+\n+      /* If this is a DECL_EXPR for a variable with DECL_INITIAL set\n+\t and decl has a padded type, convert it to the unpadded type so the\n+\t assignment is done properly.  */\n+      if (TREE_CODE (TREE_TYPE (gnu_decl)) == RECORD_TYPE\n+\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_decl)))\n+\tgnu_lhs\n+\t  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_decl))), gnu_decl);\n+\n+      /* Otherwise, if this is going into memory and the initializer isn't\n+\t valid for the assembler and loader.  Gimplification could do this,\n+\t but would be run too late if -fno-unit-at-a-time.  */\n+      else if (TREE_STATIC (gnu_decl)\n+\t       && !initializer_constant_valid_p (gnu_init,\n+\t\t\t\t\t\t TREE_TYPE (gnu_decl)))\n+\tgnu_lhs = gnu_decl;\n+\n+      if (gnu_lhs)\n+\t{\n+\t  tree gnu_assign_stmt\n+\t    = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t       gnu_lhs, DECL_INITIAL (gnu_decl));\n+\t  \n+\t  DECL_INITIAL (gnu_decl) = 0;\n+\t  annotate_with_locus (gnu_assign_stmt,\n+\t\t\t       DECL_SOURCE_LOCATION (gnu_decl));\n+\t  add_stmt (gnu_assign_stmt);\n+\t}\n+    }\n+}\n+\n+/* Utility function to mark nodes with TREE_VISITED.  Called from walk_tree.\n+   We use this to indicate all variable sizes and positions in global types\n+   may not be shared by any subprogram.  */\n+\n+static tree\n+mark_visited (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_VISITED (*tp))\n+    *walk_subtrees = 0;\n+  else\n+    TREE_VISITED (*tp) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Likewise, but to mark as unvisited.  */\n+\n+static tree\n+mark_unvisited (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  TREE_VISITED (*tp) = 0;\n+\n+  return NULL_TREE;\n }\n \n /* Add GNU_CLEANUP, a cleanup action, to the current code group.  */\n@@ -5083,7 +5162,7 @@ process_type (Entity_Id gnat_entity)\n         {\n \t  tree gnu_decl = create_type_decl (get_entity_name (gnat_entity),\n \t\t\t\t\t    make_dummy_type (gnat_entity),\n-\t\t\t\t\t    0, 0, 0);\n+\t\t\t\t\t    0, 0, 0, gnat_entity);\n \n \t  save_gnu_tree (gnat_entity, gnu_decl, 0);\n \t  if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n@@ -5510,93 +5589,43 @@ gnat_stabilize_reference_1 (tree e, int force)\n   return result;\n }\n \f\n-/* GNAT_UNIT is the Defining_Identifier for some package or subprogram,\n-   either a spec or a body, BODY_P says which.  If needed, make a function\n-   to be the elaboration routine for that object and perform the elaborations\n-   in GNU_ELAB_LIST.\n+/* Take care of building the elaboration procedure for the main unit.\n \n-   Return 1 if we didn't need an elaboration function, zero otherwise.  */\n+   Return true if we didn't need an elaboration function, false otherwise.  */\n \n-static int\n-build_unit_elab (Entity_Id gnat_unit, int body_p, tree gnu_elab_list)\n+static bool\n+build_unit_elab ()\n {\n-  tree gnu_decl;\n-  rtx insn;\n-  int result = 1;\n-\n-  /* ??? For now, force nothing to do.  */\n-  gnu_elab_list = 0;\n-\n-  /* If we have nothing to do, return.  */\n-  if (gnu_elab_list == 0)\n-    return 1;\n-\n-  /* Prevent the elaboration list from being reclaimed by the GC.  */\n-  gnu_pending_elaboration_lists = chainon (gnu_pending_elaboration_lists,\n-\t\t\t\t\t   gnu_elab_list);\n-\n-  /* Set our file and line number to that of the object and set up the\n-     elaboration routine.  */\n-  gnu_decl = create_subprog_decl (create_concat_name (gnat_unit,\n-\t\t\t\t\t\t      body_p ?\n-\t\t\t\t\t\t      \"elabb\" : \"elabs\"),\n-\t\t\t\t  NULL_TREE, void_ftype, NULL_TREE, 0, 1, 0,\n-\t\t\t\t  0);\n-  DECL_ELABORATION_PROC_P (gnu_decl) = 1;\n-\n-  begin_subprog_body (gnu_decl);\n-  gnat_pushlevel ();\n-  expand_start_bindings (0);\n-\n-  /* Emit the assignments for the elaborations we have to do.  If there\n-     is no destination, this is just a call to execute some statement\n-     that was placed within the declarative region.   But first save a\n-     pointer so we can see if any insns were generated.  */\n-\n-  insn = get_last_insn ();\n-\n-  for (; gnu_elab_list; gnu_elab_list = TREE_CHAIN (gnu_elab_list))\n-    if (TREE_PURPOSE (gnu_elab_list) == NULL_TREE)\n-      {\n-\tif (TREE_VALUE (gnu_elab_list) != 0)\n-\t  expand_expr_stmt (TREE_VALUE (gnu_elab_list));\n-      }\n-    else\n-      {\n-\ttree lhs = TREE_PURPOSE (gnu_elab_list);\n-\n-\tinput_location = DECL_SOURCE_LOCATION (lhs);\n-\n-\t/* If LHS has a padded type, convert it to the unpadded type\n-\t   so the assignment is done properly.  */\n-\tif (TREE_CODE (TREE_TYPE (lhs)) == RECORD_TYPE\n-\t    && TYPE_IS_PADDING_P (TREE_TYPE (lhs)))\n-\t  lhs = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (lhs))), lhs);\n-\n-\temit_line_note (input_location);\n-\texpand_expr_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t   TREE_PURPOSE (gnu_elab_list),\n-\t\t\t\t\t   TREE_VALUE (gnu_elab_list)));\n-      }\n+  tree body, stmts;\n \n-  /* See if any non-NOTE insns were generated.  */\n-  for (insn = NEXT_INSN (insn); insn; insn = NEXT_INSN (insn))\n-    if (GET_RTX_CLASS (GET_CODE (insn)) == RTX_INSN)\n-      {\n-\tresult = 0;\n-\tbreak;\n-      }\n+  /* Mark everything we have as not visited.  */\n+  walk_tree_without_duplicates (&current_stmt_group->stmt_list,\n+\t\t\t\tmark_unvisited, NULL);\n \n-  expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+  /* Set the current function to be the elaboration procedure, pop our\n+     binding level, end our statement group, and gimplify what we have.  */\n+  set_current_block_context (gnu_elab_proc_decl);\n   gnat_poplevel ();\n-  end_subprog_body (alloc_stmt_list ());\n-\n-  /* We are finished with the elaboration list it can now be discarded.  */\n-  gnu_pending_elaboration_lists = TREE_CHAIN (gnu_pending_elaboration_lists);\n-\n-  /* If there were no insns, we don't need an elab routine.  It would\n-     be nice to not output this one, but there's no good way to do that.  */\n-  return result;\n+  body = end_stmt_group ();\n+  current_function_decl = gnu_elab_proc_decl;\n+  gimplify_body (&body, gnu_elab_proc_decl);\n+\n+  /* We should have a BIND_EXPR, but it may or may not have any statements\n+     in it.  If it doesn't have any, we have nothing to do.  */\n+  stmts = body;\n+  if (TREE_CODE (stmts) == BIND_EXPR)\n+    stmts = BIND_EXPR_BODY (stmts);\n+\n+  /* If there are no statements, we have nothing to do.  */\n+  if (!stmts || !STATEMENT_LIST_HEAD (stmts))\n+    return true;\n+\n+  /* Otherwise, compile the function.  Note that we'll be gimplifying\n+     it twice, but that's fine for the nodes we use.  */\n+  begin_subprog_body (gnu_elab_proc_decl);\n+  end_subprog_body (body);\n+\n+  return false;\n }\n \f\n extern char *__gnat_to_canonical_file_spec (char *);"}, {"sha": "5a0d5584b3da538a52522d5c571e560bfc7b8a6e", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 140, "deletions": 299, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -79,21 +79,6 @@ tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n    of `save_gnu_tree' for more info.  */\n static GTY((length (\"max_gnat_nodes\"))) tree *associate_gnat_to_gnu;\n \n-/* This listhead is used to record any global objects that need elaboration.\n-   TREE_PURPOSE is the variable to be elaborated and TREE_VALUE is the\n-   initial value to assign.  */\n-\n-static GTY(()) tree pending_elaborations;\n-\n-/* This stack allows us to momentarily switch to generating elaboration\n-   lists for an inner context.  */\n-\n-struct e_stack GTY((chain_next (\"%h.next\"))) {\n-  struct e_stack *next;\n-  tree elab_list;\n-};\n-static GTY(()) struct e_stack *elist_stack;\n-\n /* This variable keeps a table for types for each precision so that we only\n    allocate each of them once. Signed and unsigned types are kept separate.\n \n@@ -108,10 +93,10 @@ static GTY(()) tree float_types[NUM_MACHINE_MODES];\n /* For each binding contour we allocate a binding_level structure to indicate\n    the binding depth.  */\n \n-struct ada_binding_level GTY((chain_next (\"%h.chain\")))\n+struct gnat_binding_level GTY((chain_next (\"%h.chain\")))\n {\n   /* The binding level containing this one (the enclosing binding level). */\n-  struct ada_binding_level *chain;\n+  struct gnat_binding_level *chain;\n   /* The BLOCK node for this level.  */\n   tree block;\n   /* If nonzero, the setjmp buffer that needs to be updated for any\n@@ -120,10 +105,10 @@ struct ada_binding_level GTY((chain_next (\"%h.chain\")))\n };\n \n /* The binding level currently in effect.  */\n-static GTY(()) struct ada_binding_level *current_binding_level;\n+static GTY(()) struct gnat_binding_level *current_binding_level;\n \n-/* A chain of ada_binding_level structures awaiting reuse.  */\n-static GTY((deletable)) struct ada_binding_level *free_binding_level;\n+/* A chain of gnat_binding_level structures awaiting reuse.  */\n+static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n \n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n@@ -133,21 +118,20 @@ struct language_function GTY(())\n   int unused;\n };\n \n-static tree mark_visited (tree *, int *, void *);\n static void gnat_define_builtin (const char *, tree, int, const char *, bool);\n static void gnat_install_builtins (void);\n-static tree merge_sizes (tree, tree, tree, int, int);\n+static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n-static int value_zerop (tree);\n+static bool value_zerop (tree);\n static void gnat_gimplify_function (tree);\n static void gnat_finalize (tree);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static tree convert_to_thin_pointer (tree, tree);\n static tree make_descriptor_field (const char *,tree, tree, tree);\n-static int value_factor_p (tree, int);\n-static int potential_alignment_gap (tree, tree, tree);\n+static bool value_factor_p (tree, HOST_WIDE_INT);\n+static bool potential_alignment_gap (tree, tree, tree);\n \f\n /* Initialize the association of GNAT nodes to GCC trees.  */\n \n@@ -156,8 +140,6 @@ init_gnat_to_gnu (void)\n {\n   associate_gnat_to_gnu\n     = (tree *) ggc_alloc_cleared (max_gnat_nodes * sizeof (tree));\n-\n-  pending_elaborations = build_tree_list (NULL_TREE, NULL_TREE);\n }\n \n /* GNAT_ENTITY is a GNAT tree node for an entity.   GNU_DECL is the GCC tree\n@@ -211,24 +193,16 @@ present_gnu_tree (Entity_Id gnat_entity)\n int\n global_bindings_p (void)\n {\n-  return (force_global != 0 || current_binding_level->chain == 0 ? -1 : 0);\n-}\n-\n-/* Return the list of declarations in the current level. Note that this list\n-   is in reverse order (it has to be so for back-end compatibility).  */\n-\n-tree\n-getdecls (void)\n-{\n-  return BLOCK_VARS (current_binding_level->block);\n+  return (force_global != 0 || current_binding_level == 0\n+\t  || current_binding_level->chain == 0 ? -1 : 0);\n }\n \n /* Enter a new binding level. */\n \n void\n gnat_pushlevel ()\n {\n-  struct ada_binding_level *newlevel = NULL;\n+  struct gnat_binding_level *newlevel = NULL;\n \n   /* Reuse a struct for this binding level, if there is one.  */\n   if (free_binding_level)\n@@ -238,8 +212,8 @@ gnat_pushlevel ()\n     }\n   else\n     newlevel\n-      = (struct ada_binding_level *)\n-\tggc_alloc (sizeof (struct ada_binding_level));\n+      = (struct gnat_binding_level *)\n+\tggc_alloc (sizeof (struct gnat_binding_level));\n \n   /* Use a free BLOCK, if any; otherwise, allocate one.  */\n   if (free_block_chain)\n@@ -264,6 +238,16 @@ gnat_pushlevel ()\n   current_binding_level = newlevel;\n }\n \n+/* Set SUPERCONTEXT of the BLOCK for the current binding level to FNDECL\n+   and point FNDECL to this BLOCK.  */\n+\n+void\n+set_current_block_context (tree fndecl)\n+{\n+  BLOCK_SUPERCONTEXT (current_binding_level->block) = fndecl;\n+  DECL_INITIAL (fndecl) = current_binding_level->block;\n+}\n+\n /* Set the jmpbuf_decl for the current binding level to DECL.  */\n \n void\n@@ -285,7 +269,7 @@ get_block_jmpbuf_decl ()\n void\n gnat_poplevel ()\n {\n-  struct ada_binding_level *level = current_binding_level;\n+  struct gnat_binding_level *level = current_binding_level;\n   tree block = level->block;\n \n   BLOCK_VARS (block) = nreverse (BLOCK_VARS (block));\n@@ -329,59 +313,33 @@ insert_block (tree block)\n   TREE_CHAIN (block) = BLOCK_SUBBLOCKS (current_binding_level->block);\n   BLOCK_SUBBLOCKS (current_binding_level->block) = block;\n }\n-\n-/* Return nonzero if the current binding has any variables.  This means\n-   it will have a BLOCK node.  */\n-\n-int\n-block_has_vars ()\n-{\n-  return BLOCK_VARS (current_binding_level->block) != 0;\n-}\n-\f\n-/* Utility function to mark nodes with TREE_VISITED.  Called from walk_tree.\n-   We use this to indicate all variable sizes and positions in global types\n-   may not be shared by any subprogram.  */\n-\n-static tree\n-mark_visited (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n-{\n-  if (TREE_VISITED (*tp))\n-    *walk_subtrees = 0;\n-  else\n-    TREE_VISITED (*tp) = 1;\n-\n-  return NULL_TREE;\n-}\n \f\n-/* Records a ..._DECL node DECL as belonging to the current lexical scope.\n-   Returns the ..._DECL node. */\n+/* Records a ..._DECL node DECL as belonging to the current lexical scope\n+   and uses GNAT_NODE for location information.  */\n \n-tree\n-pushdecl (tree decl)\n+void\n+gnat_pushdecl (tree decl, Node_Id gnat_node)\n {\n   /* If at top level, there is no context. But PARM_DECLs always go in the\n-     level of its function.  Also, at toplevel we must protect all trees\n-     that are part of sizes and positions.  */\n+     level of its function.  */\n   if (global_bindings_p () && TREE_CODE (decl) != PARM_DECL)\n-    {\n-      /* Make a DECL_EXPR so we'll walk into the appropriate fields of\n-\t the type or decl.  */\n-      tree decl_expr = build1 (DECL_EXPR, void_type_node, decl);\n-\n-      DECL_CONTEXT (decl) = 0;\n-      walk_tree (&decl_expr, mark_visited, NULL, NULL);\n-    }\n+    DECL_CONTEXT (decl) = 0;\n   else\n     DECL_CONTEXT (decl) = current_function_decl;\n \n-  /* Put the declaration on the list.  The list of declarations is in reverse\n-     order. The list will be reversed later.\n+  /* Set the location of DECL and emit a declaration for it.  */\n+  if (Present (gnat_node))\n+    Sloc_to_locus (Sloc (gnat_node), &DECL_SOURCE_LOCATION (decl));\n+  add_decl_expr (decl, gnat_node);\n \n-     Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into the list.  They\n-     will cause trouble with the debugger and aren't needed anyway.  */\n-  if (TREE_CODE (decl) != TYPE_DECL\n-      || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE)\n+  /* Put the declaration on the list.  The list of declarations is in reverse\n+     order. The list will be reversed later.  We don't do this for global\n+     variables.  Also, don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into\n+     the list.  They will cause trouble with the debugger and aren't needed\n+     anyway.  */\n+  if (!global_bindings_p ()\n+      && (TREE_CODE (decl) != TYPE_DECL\n+\t  || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE))\n     {\n       TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n       BLOCK_VARS (current_binding_level->block) = decl;\n@@ -404,8 +362,9 @@ pushdecl (tree decl)\n \t      && DECL_ARTIFICIAL (TYPE_NAME (TREE_TYPE (decl)))\n \t      && ! DECL_ARTIFICIAL (decl))))\n     TYPE_NAME (TREE_TYPE (decl)) = decl;\n-\n-  return decl;\n+  \n+  if (TREE_CODE (decl) != CONST_DECL)\n+    rest_of_decl_compilation (decl, NULL, global_bindings_p (), 0);\n }\n \f\n /* Do little here.  Set up the standard declarations later after the\n@@ -433,14 +392,21 @@ gnat_init_decl_processing (void)\n   set_sizetype (size_type_node);\n   build_common_tree_nodes_2 (0);\n \n-  pushdecl (build_decl (TYPE_DECL, get_identifier (SIZE_TYPE), sizetype));\n-\n-  /* We need to make the integer type before doing anything else.\n-     We stitch this in to the appropriate GNAT type later.  */\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"integer\"),\n-\t\t\tinteger_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n-\t\t\tchar_type_node));\n+  /* Give names and make TYPE_DECLs for common types.  */\n+  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (SIZE_TYPE), sizetype),\n+\t\t Empty);\n+  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"integer\"),\n+\t\t\t     integer_type_node),\n+\t\t Empty);\n+  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n+\t\t\t     char_type_node),\n+\t\t Empty);\n+  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"long integer\"),\n+\t\t\t     long_integer_type_node),\n+\t\t Empty);\n+  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"),\n+\t\t\t     void_type_node),\n+\t\t Empty);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n \n@@ -462,7 +428,7 @@ gnat_define_builtin (const char *name, tree type,\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n   make_decl_rtl (decl, NULL);\n-  pushdecl (decl);\n+  gnat_pushdecl (decl, Empty);\n   DECL_BUILT_IN_CLASS (decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (decl) = function_code;\n   TREE_READONLY (decl) = const_p;\n@@ -540,7 +506,6 @@ gnat_install_builtins ()\n \t\t       BUILT_IN_STACK_RESTORE, \"stack_restore\", false);\n }\n \n-\n /* Create the predefined scalar types such as `integer_type_node' needed\n    in the gcc back-end and initialize the global binding level.  */\n \n@@ -560,21 +525,20 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       longest_float_type_node = make_node (REAL_TYPE);\n       TYPE_PRECISION (longest_float_type_node) = LONG_DOUBLE_TYPE_SIZE;\n       layout_type (longest_float_type_node);\n-      pushdecl (build_decl (TYPE_DECL, get_identifier (\"longest float type\"),\n-\t\t\t    longest_float_type_node));\n+      create_type_decl (get_identifier (\"longest float type\"),\n+\t\t\tlongest_float_type_node, NULL, 0, 1, Empty);\n     }\n   else\n     longest_float_type_node = TREE_TYPE (long_long_float_type);\n \n   except_type_node = TREE_TYPE (exception_type);\n \n   unsigned_type_node = gnat_type_for_size (INT_TYPE_SIZE, 1);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n-\t\t\tunsigned_type_node));\n+  create_type_decl (get_identifier (\"unsigned int\"), unsigned_type_node,\n+\t\t    NULL, 0, 1, Empty);\n \n-  void_type_decl_node\n-    = pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"),\n-\t\t\t    void_type_node));\n+  void_type_decl_node = create_type_decl (get_identifier (\"void\"),\n+\t\t\t\t\t  void_type_node, NULL, 0, 1, Empty);\n \n   void_ftype = build_function_type (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n@@ -590,7 +554,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\t\t  tree_cons (NULL_TREE,\n \t\t\t\t\t\t\t\t     sizetype,\n \t\t\t\t\t\t\t\t     endlink)),\n-\t\t\t\t     NULL_TREE, 0, 1, 1, 0);\n+\t\t\t\t     NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* free is a function declaration tree for a function to free memory.  */\n   free_decl\n@@ -599,37 +563,38 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0);\n+\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* Make the types and functions used for exception processing.    */\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),\n \t\t\tbuild_index_type (build_int_2 (5, 0)));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"JMPBUF_T\"), jmpbuf_type));\n+  create_type_decl (get_identifier (\"JMPBUF_T\"), jmpbuf_type, NULL,\n+\t\t    0, 1, Empty);\n   jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);\n \n   /* Functions to get and set the jumpbuf pointer for the current thread.  */\n   get_jmpbuf_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n      NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n-     NULL_TREE, 0, 1, 1, 0);\n+     NULL_TREE, 0, 1, 1, 0, Empty);\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n      NULL_TREE,\n      build_function_type (void_type_node,\n \t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, endlink)),\n-     NULL_TREE, 0, 1, 1, 0);\n+     NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* Function to get the current exception.  */\n   get_excptr_decl\n     = create_subprog_decl\n     (get_identifier (\"system__soft_links__get_gnat_exception\"),\n      NULL_TREE,\n      build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n-     NULL_TREE, 0, 1, 1, 0);\n+     NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* Functions that raise exceptions. */\n   raise_nodefer_decl\n@@ -639,7 +604,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t    tree_cons (NULL_TREE,\n \t\t\t\t       build_pointer_type (except_type_node),\n \t\t\t\t       endlink)),\n-       NULL_TREE, 0, 1, 1, 0);\n+       NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* Hooks to call when entering/leaving an exception handler.  */\n   begin_handler_decl\n@@ -648,15 +613,15 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0);\n+\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n \t\t\t   build_function_type (void_type_node,\n \t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_void_type_node,\n \t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, 0, 1, 1, 0);\n+\t\t\t   NULL_TREE, 0, 1, 1, 0, Empty);\n \n   /* If in no exception handlers mode, all raise statements are redirected to\n      __gnat_last_chance_handler. No need to redefine raise_nodefer_decl, since\n@@ -672,7 +637,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t   tree_cons (NULL_TREE,\n \t\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t\t      endlink))),\n-\t   NULL_TREE, 0, 1, 1, 0);\n+\t   NULL_TREE, 0, 1, 1, 0, Empty);\n \n       for (i = 0; i < ARRAY_SIZE (gnat_raise_decls); i++)\n \tgnat_raise_decls[i] = decl;\n@@ -694,7 +659,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\t\t\tinteger_type_node,\n \t\t\t\t\t\t\tendlink))),\n-\t     NULL_TREE, 0, 1, 1, 0);\n+\t     NULL_TREE, 0, 1, 1, 0, Empty);\n       }\n \n   /* Indicate that these never return.  */\n@@ -720,7 +685,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type (integer_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, 0, 1, 1, 0);\n+       NULL_TREE, 0, 1, 1, 0, Empty);\n \n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n@@ -732,25 +697,22 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type (void_type_node,\n \t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, 0, 1, 1, 0);\n+       NULL_TREE, 0, 1, 1, 0, Empty);\n \n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n   main_identifier_node = get_identifier (\"main\");\n }\n \f\n-/* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL\n-   nodes (FIELDLIST), finish constructing the record or union type.\n-   If HAS_REP is nonzero, this record has a rep clause; don't call\n-   layout_type but merely set the size and alignment ourselves.\n-   If DEFER_DEBUG is nonzero, do not call the debugging routines\n-   on this type; it will be done later. */\n+/* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL nodes\n+   (FIELDLIST), finish constructing the record or union type.  If HAS_REP is\n+   nonzero, this record has a rep clause; don't call layout_type but merely set\n+   the size and alignment ourselves.  If DEFER_DEBUG is nonzero, do not call\n+   the debugging routines on this type; it will be done later. */\n \n void\n-finish_record_type (tree record_type,\n-                    tree fieldlist,\n-                    int has_rep,\n+finish_record_type (tree record_type, tree fieldlist, int has_rep,\n                     int defer_debug)\n {\n   enum tree_code code = TREE_CODE (record_type);\n@@ -761,14 +723,8 @@ finish_record_type (tree record_type,\n   tree field;\n \n   TYPE_FIELDS (record_type) = fieldlist;\n-\n-  if (TYPE_NAME (record_type) != 0\n-      && TREE_CODE (TYPE_NAME (record_type)) == TYPE_DECL)\n-    TYPE_STUB_DECL (record_type) = TYPE_NAME (record_type);\n-  else\n-    TYPE_STUB_DECL (record_type)\n-      = pushdecl (build_decl (TYPE_DECL, TYPE_NAME (record_type),\n-\t\t\t      record_type));\n+  TYPE_STUB_DECL (record_type)\n+    = build_decl (TYPE_DECL, NULL_TREE, record_type);\n \n   /* We don't need both the typedef name and the record name output in\n      the debugging information, since they are the same.  */\n@@ -942,7 +898,10 @@ finish_record_type (tree record_type,\n \t  tree new_record_type\n \t    = make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n \t\t\t ? UNION_TYPE : TREE_CODE (record_type));\n-\t  tree orig_id = DECL_NAME (TYPE_STUB_DECL (record_type));\n+\t  tree orig_name = TYPE_NAME (record_type);\n+\t  tree orig_id\n+\t    = (TREE_CODE (orig_name) == TYPE_DECL ? DECL_NAME (orig_name)\n+\t       : orig_name);\n \t  tree new_id\n \t    = concat_id_with_name (orig_id,\n \t\t\t\t   TREE_CODE (record_type) == QUAL_UNION_TYPE\n@@ -954,7 +913,7 @@ finish_record_type (tree record_type,\n \t  TYPE_NAME (new_record_type) = new_id;\n \t  TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n \t  TYPE_STUB_DECL (new_record_type)\n-\t    = pushdecl (build_decl (TYPE_DECL, new_id, new_record_type));\n+\t    = build_decl (TYPE_DECL, NULL_TREE, new_record_type);\n \t  DECL_ARTIFICIAL (TYPE_STUB_DECL (new_record_type)) = 1;\n \t  DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n \t    = DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n@@ -1086,11 +1045,8 @@ finish_record_type (tree record_type,\n    We return an expression for the size.  */\n \n static tree\n-merge_sizes (tree last_size,\n-             tree first_bit,\n-             tree size,\n-             int special,\n-             int has_rep)\n+merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n+\t     bool has_rep)\n {\n   tree type = TREE_TYPE (last_size);\n   tree new;\n@@ -1188,13 +1144,9 @@ split_plus (tree in, tree *pvar)\n    object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n    RETURNS_WITH_DSP is nonzero if the function is to return with a\n    depressed stack pointer.  */\n-\n tree\n-create_subprog_type (tree return_type,\n-                     tree param_decl_list,\n-                     tree cico_list,\n-                     int returns_unconstrained,\n-                     int returns_by_ref,\n+create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n+                     int returns_unconstrained, int returns_by_ref,\n                      int returns_with_dsp)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n@@ -1275,25 +1227,26 @@ create_index_type (tree min, tree max, tree index)\n     type = copy_type (type);\n \n   SET_TYPE_INDEX_TYPE (type, index);\n-  add_decl_expr (create_type_decl (NULL_TREE, type, NULL, 1, 0), Empty);\n+  create_type_decl (NULL_TREE, type, NULL, 1, 0, Empty);\n   return type;\n }\n \f\n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n    ARTIFICIAL_P is nonzero if this is a declaration that was generated\n    by the compiler.  DEBUG_INFO_P is nonzero if we need to write debugging\n-   information about this type.  */\n+   information about this type.  GNAT_NODE is used for the position of\n+   the decl.  */\n \n tree\n create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n-\t\t  int artificial_p, int debug_info_p)\n+\t\t  int artificial_p, int debug_info_p, Node_Id gnat_node)\n {\n   tree type_decl = build_decl (TYPE_DECL, type_name, type);\n   enum tree_code code = TREE_CODE (type);\n \n   DECL_ARTIFICIAL (type_decl) = artificial_p;\n-  pushdecl (type_decl);\n+\n   process_attributes (type_decl, attr_list);\n \n   /* Pass type declaration information to the debugger unless this is an\n@@ -1309,6 +1262,9 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \t    && TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n     rest_of_decl_compilation (type_decl, NULL, global_bindings_p (), 0);\n \n+  if (!TYPE_IS_DUMMY_P (type))\n+    gnat_pushdecl (type_decl, gnat_node);\n+\n   return type_decl;\n }\n \n@@ -1326,12 +1282,14 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n    definition: no storage is to be allocated for the variable here).\n \n    STATIC_FLAG is only relevant when not at top level.  In that case\n-   it indicates whether to always allocate storage to the variable.   */\n+   it indicates whether to always allocate storage to the variable.\n+\n+   GNAT_NODE is used for the position of the decl.  */\n \n tree\n create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n                  int const_flag, int public_flag, int extern_flag,\n-                 int static_flag, struct attrib *attr_list)\n+                 int static_flag, struct attrib *attr_list, Node_Id gnat_node)\n {\n   int init_const\n     = (var_init == 0\n@@ -1357,17 +1315,10 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n      save any variable elaborations for the elaboration routine.  If we are\n      just annotating types, throw away the initialization if it isn't a\n      constant.  */\n-\n   if ((extern_flag && TREE_CODE (var_decl) != CONST_DECL)\n       || (type_annotate_only && var_init != 0 && ! TREE_CONSTANT (var_init)))\n     var_init = 0;\n \n-  if (global_bindings_p () && var_init != 0 && ! init_const)\n-    {\n-      add_pending_elaborations (var_decl, var_init);\n-      var_init = 0;\n-    }\n-\n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n@@ -1386,9 +1337,8 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \n   process_attributes (var_decl, attr_list);\n \n-  /* Add this decl to the current binding level and generate any\n-     needed code and RTL. */\n-  var_decl = pushdecl (var_decl);\n+  /* Add this decl to the current binding level.  */\n+  gnat_pushdecl (var_decl, gnat_node);\n \n   if (TREE_SIDE_EFFECTS (var_decl))\n     TREE_ADDRESSABLE (var_decl) = 1;\n@@ -1407,13 +1357,8 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n    the address of this field for aliasing purposes.  */\n \n tree\n-create_field_decl (tree field_name,\n-                   tree field_type,\n-                   tree record_type,\n-                   int packed,\n-                   tree size,\n-                   tree pos,\n-                   int addressable)\n+create_field_decl (tree field_name, tree field_type, tree record_type,\n+                   int packed, tree size, tree pos, int addressable)\n {\n   tree field_decl = build_decl (FIELD_DECL, field_name, field_type);\n \n@@ -1540,7 +1485,7 @@ create_field_decl (tree field_name,\n /* Subroutine of previous function: return nonzero if EXP, ignoring any side\n    effects, has the value of zero.  */\n \n-static int\n+static bool\n value_zerop (tree exp)\n {\n   if (TREE_CODE (exp) == COMPOUND_EXPR)\n@@ -1629,36 +1574,11 @@ process_attributes (tree decl, struct attrib *attr_list)\n       }\n }\n \f\n-/* Add some pending elaborations on the list.  */\n+/* Return true if VALUE is a known to be a multiple of FACTOR, which must be\n+   a power of 2. */\n \n-void\n-add_pending_elaborations (tree var_decl, tree var_init)\n-{\n-  if (var_init != 0)\n-    Check_Elaboration_Code_Allowed (error_gnat_node);\n-\n-  pending_elaborations\n-    = chainon (pending_elaborations, build_tree_list (var_decl, var_init));\n-}\n-\n-/* Obtain any pending elaborations and clear the old list.  */\n-\n-tree\n-get_pending_elaborations (void)\n-{\n-  /* Each thing added to the list went on the end; we want it on the\n-     beginning.  */\n-  tree result = TREE_CHAIN (pending_elaborations);\n-\n-  TREE_CHAIN (pending_elaborations) = 0;\n-  return result;\n-}\n-\n-/* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n-   of 2. */\n-\n-static int\n-value_factor_p (tree value, int factor)\n+static bool\n+value_factor_p (tree value, HOST_WIDE_INT factor)\n {\n   if (host_integerp (value, 1))\n     return tree_low_cst (value, 1) % factor == 0;\n@@ -1676,7 +1596,7 @@ value_factor_p (tree value, int factor)\n    is the distance in bits between the end of PREV_FIELD and the starting\n    position of CURR_FIELD. It is ignored if null. */\n \n-static int\n+static bool\n potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n {\n   /* If this is the first field of the record, there cannot be any gap */\n@@ -1716,64 +1636,6 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n   return 1;\n }\n \n-/* Return nonzero if there are pending elaborations.  */\n-\n-int\n-pending_elaborations_p (void)\n-{\n-  return TREE_CHAIN (pending_elaborations) != 0;\n-}\n-\n-/* Save a copy of the current pending elaboration list and make a new\n-   one.  */\n-\n-void\n-push_pending_elaborations (void)\n-{\n-  struct e_stack *p = (struct e_stack *) ggc_alloc (sizeof (struct e_stack));\n-\n-  p->next = elist_stack;\n-  p->elab_list = pending_elaborations;\n-  elist_stack = p;\n-  pending_elaborations = build_tree_list (NULL_TREE, NULL_TREE);\n-}\n-\n-/* Pop the stack of pending elaborations.  */\n-\n-void\n-pop_pending_elaborations (void)\n-{\n-  struct e_stack *p = elist_stack;\n-\n-  pending_elaborations = p->elab_list;\n-  elist_stack = p->next;\n-}\n-\n-/* Return the current position in pending_elaborations so we can insert\n-   elaborations after that point.  */\n-\n-tree\n-get_elaboration_location (void)\n-{\n-  return tree_last (pending_elaborations);\n-}\n-\n-/* Insert the current elaborations after ELAB, which is in some elaboration\n-   list.  */\n-\n-void\n-insert_elaboration_list (tree elab)\n-{\n-  tree next = TREE_CHAIN (elab);\n-\n-  if (TREE_CHAIN (pending_elaborations))\n-    {\n-      TREE_CHAIN (elab) = TREE_CHAIN (pending_elaborations);\n-      TREE_CHAIN (tree_last (pending_elaborations)) = next;\n-      TREE_CHAIN (pending_elaborations) = 0;\n-    }\n-}\n-\n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n \n tree\n@@ -1794,17 +1656,13 @@ create_label_decl (tree label_name)\n    PARM_DECL nodes chained through the TREE_CHAIN field).\n \n    INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n-   appropriate fields in the FUNCTION_DECL.  */\n+   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */\n \n tree\n-create_subprog_decl (tree subprog_name,\n-                     tree asm_name,\n-                     tree subprog_type,\n-                     tree param_decl_list,\n-                     int inline_flag,\n-                     int public_flag,\n-                     int extern_flag,\n-                     struct attrib *attr_list)\n+create_subprog_decl (tree subprog_name, tree asm_name,\n+                     tree subprog_type, tree param_decl_list, int inline_flag,\n+                     int public_flag, int extern_flag,\n+                     struct attrib *attr_list, Node_Id gnat_node)\n {\n   tree return_type  = TREE_TYPE (subprog_type);\n   tree subprog_decl = build_decl (FUNCTION_DECL, subprog_name, subprog_type);\n@@ -1834,20 +1692,14 @@ create_subprog_decl (tree subprog_name,\n   process_attributes (subprog_decl, attr_list);\n \n   /* Add this decl to the current binding level.  */\n-  subprog_decl = pushdecl (subprog_decl);\n+  gnat_pushdecl (subprog_decl, gnat_node);\n \n   /* Output the assembler code and/or RTL for the declaration.  */\n   rest_of_decl_compilation (subprog_decl, 0, global_bindings_p (), 0);\n \n   return subprog_decl;\n }\n \f\n-/* Count how deep we are into nested functions.  This is because\n-   we shouldn't call the backend function context routines unless we\n-   are in a nested function.  */\n-\n-static int function_nesting_depth;\n-\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body. This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */\n@@ -1857,30 +1709,22 @@ begin_subprog_body (tree subprog_decl)\n {\n   tree param_decl;\n \n-  if (function_nesting_depth++ != 0)\n-    push_function_context ();\n-\n+  current_function_decl = subprog_decl;\n   announce_function (subprog_decl);\n \n-  /* Make this field nonzero so further routines know that this is not\n-     tentative. error_mark_node is replaced below with the adequate BLOCK.  */\n-  DECL_INITIAL (subprog_decl)  = error_mark_node;\n-\n-  /* This function exists in static storage. This does not mean `static' in\n-     the C sense!  */\n-  TREE_STATIC (subprog_decl)   = 1;\n-\n   /* Enter a new binding level and show that all the parameters belong to\n      this function.  */\n-  current_function_decl = subprog_decl;\n   gnat_pushlevel ();\n-\n   for (param_decl = DECL_ARGUMENTS (subprog_decl); param_decl;\n        param_decl = TREE_CHAIN (param_decl))\n     DECL_CONTEXT (param_decl) = subprog_decl;\n \n-  init_function_start (subprog_decl);\n-  expand_function_start (subprog_decl, 0);\n+  make_decl_rtl (subprog_decl, NULL);\n+\n+  /* We handle pending sizes via the elaboration of types, so we don't need to\n+     save them.  This causes them to be marked as part of the outer function\n+     and then discarded.  */\n+  get_pending_sizes ();\n }\n \n /* Finish the definition of the current subprogram and compile it all the way\n@@ -1978,11 +1822,8 @@ gnat_finalize (tree fndecl)\n    ATTRS is nonzero, use that for the function attribute list.  */\n \n tree\n-builtin_function (const char *name,\n-                  tree type,\n-                  int function_code,\n-                  enum built_in_class class,\n-                  const char *library_name,\n+builtin_function (const char *name, tree type, int function_code,\n+                  enum built_in_class class, const char *library_name,\n                   tree attrs)\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n@@ -1992,7 +1833,7 @@ builtin_function (const char *name,\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n \n-  pushdecl (decl);\n+  gnat_pushdecl (decl, Empty);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;\n   if (attrs)\n@@ -2295,7 +2136,7 @@ build_template (tree template_type, tree array_type, tree expr)\n /* Build a VMS descriptor from a Mechanism_Type, which must specify\n    a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n    in the type contains in its DECL_INITIAL the expression to use when\n-   a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n+   a constructor is made for the type.  GNAT_ENTITY is an entity used\n    to print out an error message if the mechanism cannot be applied to\n    an object of that type and also for the name.  */\n \n@@ -2581,8 +2422,8 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     }\n \n   finish_record_type (record_type, field_list, 0, 1);\n-  pushdecl (build_decl (TYPE_DECL, create_concat_name (gnat_entity, \"DESC\"),\n-\t\t\trecord_type));\n+  create_type_decl (create_concat_name (gnat_entity, \"DESC\"), record_type,\n+\t\t    NULL, 1, 0, gnat_entity);\n \n   return record_type;\n }"}, {"sha": "0a563a55d686c5ec1c7a73edd94af002878824be", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909f21b39e4d27523d76258a039fd79911f11494/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=909f21b39e4d27523d76258a039fd79911f11494", "patch": "@@ -1751,9 +1751,10 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t  tree gnu_range\n \t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n \t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n-\t  tree gnu_decl =\n-\t    create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n-\t\t\t     gnu_array_type, NULL_TREE, 0, 0, 0, 0, 0);\n+\t  tree gnu_decl\n+\t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n+\t\t\t       gnu_array_type, NULL_TREE, 0, 0, 0, 0, 0,\n+\t\t\t       gnat_node);\n \n \t  return convert (ptr_void_type_node,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n@@ -1779,12 +1780,8 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n    the storage pool to use.  */\n \n tree\n-build_allocator (tree type,\n-                 tree init,\n-                 tree result_type,\n-                 Entity_Id gnat_proc,\n-                 Entity_Id gnat_pool,\n-                 Node_Id gnat_node)\n+build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n+                 Entity_Id gnat_pool, Node_Id gnat_node)\n {\n   tree size = TYPE_SIZE_UNIT (type);\n   tree result;"}]}