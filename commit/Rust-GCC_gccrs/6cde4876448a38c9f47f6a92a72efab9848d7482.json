{"sha": "6cde4876448a38c9f47f6a92a72efab9848d7482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkZTQ4NzY0NDhhMzhjOWY0N2Y2YTkyYTcyZWZhYjk4NDhkNzQ4Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-06-13T16:14:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-06-13T16:14:55Z"}, "message": "emit-rtl.c (static_regno_reg_rtx): Define.\n\n        * emit-rtl.c (static_regno_reg_rtx): Define.\n        (init_emit_once): Initialize static_regno_reg_rtx.\n        (init_emit): Copy static_regno_reg_rtx into regno_reg_rtx instead\n        of building new hard reg objects once per function.\n        (gen_rtx_REG): Try to share hard regs.\n\t* regclass.c (init_fake_stack_mems): New function broken out from\n\tinit_regs.\n\t* rtl.h (init_fake_stack_mems): Declare.\n\t* toplev.c (lang_independent_init): Call init_regs before\n\tinit_emit_once.  Call init_fake_stack_mems after init_emit_once.\n\nFrom-SVN: r54588", "tree": {"sha": "1e31a85b6ad526e69fcd507891472e959a6541de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e31a85b6ad526e69fcd507891472e959a6541de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cde4876448a38c9f47f6a92a72efab9848d7482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cde4876448a38c9f47f6a92a72efab9848d7482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cde4876448a38c9f47f6a92a72efab9848d7482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cde4876448a38c9f47f6a92a72efab9848d7482/comments", "author": null, "committer": null, "parents": [{"sha": "dd3fbd933dabd20c31e293b0e0cd0714fc9a56ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3fbd933dabd20c31e293b0e0cd0714fc9a56ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3fbd933dabd20c31e293b0e0cd0714fc9a56ce"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "11368090da739852715fd19aa626e9979fcbef29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cde4876448a38c9f47f6a92a72efab9848d7482", "patch": "@@ -19,6 +19,17 @@\n \n 2002-06-13  Jeffrey Law  <law@redhat.com>\n \n+\t* emit-rtl.c (static_regno_reg_rtx): Define.\n+\t(init_emit_once): Initialize static_regno_reg_rtx.\n+\t(init_emit): Copy static_regno_reg_rtx into regno_reg_rtx instead\n+\tof building new hard reg objects once per function.\n+\t(gen_rtx_REG): Try to share hard regs.\n+\t* regclass.c (init_fake_stack_mems): New function broken out from\n+\tinit_regs.\n+\t* rtl.h (init_fake_stack_mems): Declare.\n+\t* toplev.c (lang_independent_init): Call init_regs before\n+\tinit_emit_once.  Call init_fake_stack_mems after init_emit_once.\n+\n \t* i386.md (extenddfxf2, extenddftf2): Fix typo/thinko.\n \n \t* alias.c (argument_registers): Remove."}, {"sha": "5186c854dc38ff5b466b08b9deb07df01d01e05d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6cde4876448a38c9f47f6a92a72efab9848d7482", "patch": "@@ -92,6 +92,12 @@ static int no_line_numbers;\n \n rtx global_rtl[GR_MAX];\n \n+/* Commonly used RTL for hard registers.  These objects are not necessarily\n+   unique, so we allocate them separately from global_rtl.  They are\n+   initialized once per compilation unit, then copied into regno_reg_rtx\n+   at the beginning of each function.  */\n+static GTY(()) rtx static_regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n+\n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n    record a copy of const[012]_rtx.  */\n@@ -527,6 +533,15 @@ gen_rtx_REG (mode, regno)\n \treturn stack_pointer_rtx;\n     }\n \n+  /* If the per-function register table has been set up, try to re-use\n+     an existing entry in that table to avoid useless generation of RTL.  */\n+  if (cfun\n+      && cfun->emit\n+      && regno_reg_rtx\n+      && regno < FIRST_PSEUDO_REGISTER\n+      && reg_raw_mode[regno] == mode)\n+    return regno_reg_rtx[regno];\n+\n   return gen_raw_REG (mode, regno);\n }\n \n@@ -5067,7 +5082,6 @@ void\n init_emit ()\n {\n   struct function *f = cfun;\n-  int i;\n \n   f->emit = (struct emit_status *) ggc_alloc (sizeof (struct emit_status));\n   first_insn = NULL;\n@@ -5098,13 +5112,13 @@ init_emit ()\n \t\t\t\t  * sizeof (tree));\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n+  memcpy (regno_reg_rtx,\n+\t  static_regno_reg_rtx,\n+\t  FIRST_PSEUDO_REGISTER * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   init_virtual_regs (f->emit);\n \n-\n   /* Indicate that the virtual registers and stack locations are\n      all pointers.  */\n   REG_POINTER (stack_pointer_rtx) = 1;\n@@ -5238,6 +5252,11 @@ init_emit_once (line_numbers)\n     gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n   virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n \n+  /* Initialize RTL for commonly used hard registers.  These are\n+     copied into regno_reg_rtx as we begin to compile each function.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    static_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n+\n #ifdef INIT_EXPANDERS\n   /* This is to initialize {init|mark|free}_machine_status before the first\n      call to push_function_context_to.  This is needed by the Chill front"}, {"sha": "6a7acb9793da317015cf5dc635766ac3ebc532fb", "filename": "gcc/regclass.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=6cde4876448a38c9f47f6a92a72efab9848d7482", "patch": "@@ -601,11 +601,16 @@ init_regs ()\n   init_reg_sets_1 ();\n \n   init_reg_modes ();\n+}\n+\n+/* Initialize some fake stack-frame MEM references for use in\n+   memory_move_secondary_cost.  */\n \n+void\n+init_fake_stack_mems ()\n+{\n #ifdef HAVE_SECONDARY_RELOADS\n   {\n-    /* Make some fake stack-frame MEM references for use in\n-       memory_move_secondary_cost.  */\n     int i;\n \n     for (i = 0; i < MAX_MACHINE_MODE; i++)"}, {"sha": "f198c8d4890e2042cf5427afa71a4e58543d2adc", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6cde4876448a38c9f47f6a92a72efab9848d7482", "patch": "@@ -2026,6 +2026,7 @@ extern int reg_classes_intersect_p\tPARAMS ((enum reg_class, enum reg_class));\n extern int reg_class_subset_p\t\tPARAMS ((enum reg_class, enum reg_class));\n extern void globalize_reg\t\tPARAMS ((int));\n extern void init_regs\t\t\tPARAMS ((void));\n+extern void init_fake_stack_mems\tPARAMS ((void));\n extern void init_reg_sets\t\tPARAMS ((void));\n extern void regset_release_memory\tPARAMS ((void));\n extern void regclass_init\t\tPARAMS ((void));"}, {"sha": "388954ec8a6755a3e5bcfbf0f7ed28bd611c5ade", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cde4876448a38c9f47f6a92a72efab9848d7482/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6cde4876448a38c9f47f6a92a72efab9848d7482", "patch": "@@ -5035,6 +5035,9 @@ lang_independent_init ()\n   init_stringpool ();\n   init_obstacks ();\n \n+  /* init_emit_once uses reg_raw_mode and therefore must be called\n+     after init_regs which initialized reg_raw_mode.  */\n+  init_regs ();\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n #ifdef VMS_DEBUGGING_INFO\n@@ -5043,7 +5046,7 @@ lang_independent_init ()\n #endif\n \t\t    || flag_test_coverage\n \t\t    || warn_notreached);\n-  init_regs ();\n+  init_fake_stack_mems ();\n   init_alias_once ();\n   init_loop ();\n   init_reload ();"}]}