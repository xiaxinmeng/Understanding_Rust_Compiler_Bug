{"sha": "e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjZWZkZDlkMGE3MmVkMzcyZGEyODk2NjVhYTA0YjFkYTQ2ZGQ5Yw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-06-30T11:43:55Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-06-30T11:43:55Z"}, "message": "re PR tree-optimization/36648 (segfault in global constructor with -O3)\n\n\tPR tree-optimization/36648\n\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound): Divide\n\tnumber of prolog iterations by step. Fix the comment.\n\nFrom-SVN: r137272", "tree": {"sha": "0e4073cf8b4d9f6d0452db545138ce59f7532485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e4073cf8b4d9f6d0452db545138ce59f7532485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "183ae5958ebc357ebc7f4ca229fb499013430e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183ae5958ebc357ebc7f4ca229fb499013430e25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/183ae5958ebc357ebc7f4ca229fb499013430e25"}], "stats": {"total": 64, "additions": 46, "deletions": 18}, "files": [{"sha": "a7832ec0adc5e13daeb5157d9c3c3eff7ade12be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "patch": "@@ -1,3 +1,9 @@\n+2008-06-30  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/36648\n+\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound): Divide\n+\tnumber of prolog iterations by step. Fix the comment.\n+\n 2008-06-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/36671"}, {"sha": "a23526877dddbafa081dc95891c2b52e63d19035", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "patch": "@@ -1,3 +1,8 @@\n+2008-06-30  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/36648\n+\t* g++.dg/vect/pr36648.cc: New testcase.\n+\n 2008-06-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/36655"}, {"sha": "b2933034b5509f2c7bf47e82e65319b1f01ffced", "filename": "gcc/testsuite/g++.dg/vect/pr36648.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc?ref=e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+struct vector\n+{\n+  vector() : x(0), y(0), z(0) { }\n+  float x,y,z;\n+};\n+\n+struct Foo\n+{\n+  int dummy;\n+  /* Misaligned access.  */\n+  vector array_of_vectors[4];\n+};\n+\n+Foo foo;\n+\n+int main() { }\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } }*/\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "1fa786da0b9618add6b5af571dc7420d43960317", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cefdd9d0a72ed372da289665aa04b1da46dd9c/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=e2cefdd9d0a72ed372da289665aa04b1da46dd9c", "patch": "@@ -6725,16 +6725,14 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n    Else, compute address misalignment in bytes:\n      addr_mis = addr & (vectype_size - 1)\n \n-   prolog_niters = min ( LOOP_NITERS , (VF - addr_mis/elem_size)&(VF-1) )\n-   \n-   (elem_size = element type size; an element is the scalar element \n-\twhose type is the inner type of the vectype)  \n+   prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)\n \n-   For interleaving,\n+   (elem_size = element type size; an element is the scalar element whose type\n+   is the inner type of the vectype)\n \n-   prolog_niters = min ( LOOP_NITERS , \n-                        (VF/group_size - addr_mis/elem_size)&(VF/group_size-1) )\n-\t where group_size is the size of the interleaved group.\n+   When the step of the data-ref in the loop is not 1 (as in interleaved data\n+   and SLP), the number of iterations of the prolog must be divided by the step\n+   (which is equal to the size of interleaved group).\n \n    The above formulas assume that VF == number of elements in the vector. This\n    may not hold when there are multiple-types in the loop.\n@@ -6756,18 +6754,12 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n   tree niters_type = TREE_TYPE (loop_niters);\n-  int group_size = 1;\n+  int step = 1;\n   int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n   int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n   if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n-    {\n-      /* For interleaved access element size must be multiplied by the size of\n-\t the interleaved group.  */\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (\n-\t\t\t\t\t       DR_GROUP_FIRST_DR (stmt_info)));\n-      element_size *= group_size;\n-    }\n+    step = DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_DR (stmt_info)));\n \n   pe = loop_preheader_edge (loop); \n \n@@ -6778,8 +6770,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n-      iters = build_int_cst (niters_type, \n-\t\t\t     (nelements - elem_misalign)&(nelements/group_size-1));\n+\n+      iters = build_int_cst (niters_type,\n+                     (((nelements - elem_misalign) & (nelements - 1)) / step));\n     }\n   else\n     {"}]}