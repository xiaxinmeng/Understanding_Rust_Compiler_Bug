{"sha": "ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "node_id": "C_kwDOANBUbNoAKGNlMjQzYzllZWZjMjcyOGNiODc0M2ViYmNiODRjM2UwODIzNmYwNmE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-04T14:13:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-04T14:13:06Z"}, "message": "range-op-float: Fix reverse ops of comparisons [PR109386]\n\nI've missed one of my recent range-op-float.cc changes (likely the\nr13-6967 one) caused\nFAIL: libphobos.phobos/std/math/algebraic.d execution test\nFAIL: libphobos.phobos_shared/std/math/algebraic.d execution test\nregressions, distilled into a C testcase below.\n\nIn the testcase, we have\n!(u >= v)\ncondition where both u and v are results of fabs*, which guards\nt1 = u u<= __FLT_MAX__;\nand\nt2 = v u<= __FLT_MAX__;\ncomparisons.  From false u >= v where u and v have [0.0, +Inf] NAN\nranges we (incorrectly deduce that one of them is [nextafterf (0.0, 1.0), +Inf] NAN\nand the other is [0.0, nextafterf (+Inf, 0.0)] NAN and from that deduce that\none of the comparisons is always true, because UNLE_EXPR with the maximum\nrepresentable number are false only if the value is +Inf and our ranges tell\nthat is not possible.\n\nThe bug is that the u >= v comparison determines a sensible range only when\nit is true - we then know neither operand can be NAN and it behaves\ncorrectly.  But when the comparison is false, our current code gives\nsensible answers only if the other op can't be NAN.  If it can be NAN,\nwhenever it is NAN, the comparison is always false regardless of the other\nvalue, so the other value needs to be VARYING.\nNow, foperator_unordered_lt::op1_range etc. had code to deal with that\nfor op?.known_nan (), but as the testcase shows, it is enough if it may be a\nNAN at runtime to make it VARYING.\n\nSo, the following patch replaces for all those BRS_FALSE cases of the normal\nnon-equality comparisons if (opOTHER.known_isnan ()) r.set_varying (type);\nto do it also if maybe_isnan ().\n\nFor the unordered or ... comparisons, it is similar for BRS_TRUE.  Those\ncomparisons are true whenever either operand is NAN, or if neither is NAN,\nthe corresponding normal comparison.  So, if those comparisons are true\nand other operand might be a NAN, we can't tell (VARYING), if it is false,\ncurrently handling is correct.\n\n2023-04-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/109386\n\t* range-op-float.cc (foperator_lt::op1_range, foperator_lt::op2_range,\n\tfoperator_le::op1_range, foperator_le::op2_range,\n\tfoperator_gt::op1_range, foperator_gt::op2_range,\n\tfoperator_ge::op1_range, foperator_ge::op2_range): Make r varying for\n\tBRS_FALSE case even if the other op is maybe_isnan, not just\n\tknown_isnan.\n\t(foperator_unordered_lt::op1_range, foperator_unordered_lt::op2_range,\n\tfoperator_unordered_le::op1_range, foperator_unordered_le::op2_range,\n\tfoperator_unordered_gt::op1_range, foperator_unordered_gt::op2_range,\n\tfoperator_unordered_ge::op1_range, foperator_unordered_ge::op2_range):\n\tMake r varying for BRS_TRUE case even if the other op is maybe_isnan,\n\tnot just known_isnan.\n\n\t* gcc.c-torture/execute/ieee/pr109386.c: New test.", "tree": {"sha": "400e3143fb170e1d1d09a74bd5feeca49e216398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400e3143fb170e1d1d09a74bd5feeca49e216398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce243c9eefc2728cb8743ebbcb84c3e08236f06a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1aca26b707471ce8051bd03b3fb2217bcdf2df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1aca26b707471ce8051bd03b3fb2217bcdf2df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1aca26b707471ce8051bd03b3fb2217bcdf2df0"}], "stats": {"total": 53, "additions": 37, "deletions": 16}, "files": [{"sha": "e0e91bad44d6d1d7739768ccf662c882ba49b7ea", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce243c9eefc2728cb8743ebbcb84c3e08236f06a/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce243c9eefc2728cb8743ebbcb84c3e08236f06a/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "patch": "@@ -886,7 +886,7 @@ foperator_lt::op1_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of x < NAN, we know nothing about x.\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else\n \tbuild_ge (r, type, op2);\n@@ -923,7 +923,7 @@ foperator_lt::op2_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of NAN < x, we know nothing about x.\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else\n \tbuild_le (r, type, op1);\n@@ -998,7 +998,7 @@ foperator_le::op1_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of x <= NAN, we know nothing about x.\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else\n \tbuild_gt (r, type, op2);\n@@ -1031,7 +1031,7 @@ foperator_le::op2_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of NAN <= x, we know nothing about x.\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1112,7 +1112,7 @@ foperator_gt::op1_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of x > NAN, we know nothing about x.\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1151,7 +1151,7 @@ foperator_gt::op2_range (frange &r,\n \n     case BRS_FALSE:\n       // On The FALSE side of NAN > x, we know nothing about x.\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1228,7 +1228,7 @@ foperator_ge::op1_range (frange &r,\n \n     case BRS_FALSE:\n       // On the FALSE side of x >= NAN, we know nothing about x.\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1262,7 +1262,7 @@ foperator_ge::op2_range (frange &r, tree type,\n \n     case BRS_FALSE:\n       // On the FALSE side of NAN >= x, we know nothing about x.\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1618,7 +1618,7 @@ foperator_unordered_lt::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1652,7 +1652,7 @@ foperator_unordered_lt::op2_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1726,7 +1726,7 @@ foperator_unordered_le::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1759,7 +1759,7 @@ foperator_unordered_le::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1835,7 +1835,7 @@ foperator_unordered_gt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1870,7 +1870,7 @@ foperator_unordered_gt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;\n@@ -1946,7 +1946,7 @@ foperator_unordered_ge::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op2.known_isnan ())\n+      if (op2.known_isnan () || op2.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op2.undefined_p ())\n \treturn false;\n@@ -1980,7 +1980,7 @@ foperator_unordered_ge::op2_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (op1.known_isnan ())\n+      if (op1.known_isnan () || op1.maybe_isnan ())\n \tr.set_varying (type);\n       else if (op1.undefined_p ())\n \treturn false;"}, {"sha": "98895d1e8aeed6cd06a23dddedba709d8ce2c6b3", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/pr109386.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce243c9eefc2728cb8743ebbcb84c3e08236f06a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce243c9eefc2728cb8743ebbcb84c3e08236f06a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fpr109386.c?ref=ce243c9eefc2728cb8743ebbcb84c3e08236f06a", "patch": "@@ -0,0 +1,21 @@\n+/* PR tree-optimization/109386 */\n+\n+static inline float\n+foo (float x, float y)\n+{\n+  float u = __builtin_fabsf (x);\n+  float v = __builtin_fabsf (y);\n+  if (!(u >= v))\n+    {\n+      if (__builtin_isinf (v)) return v;\n+      if (__builtin_isinf (u)) return u;\n+    }\n+  return 42.0f;\n+}\n+\n+int\n+main ()\n+{\n+  if (!__builtin_isinf (foo (__builtin_inff (), __builtin_nanf (\"\"))))\n+    __builtin_abort ();\n+}"}]}