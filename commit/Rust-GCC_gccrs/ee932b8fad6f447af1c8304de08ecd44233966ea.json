{"sha": "ee932b8fad6f447af1c8304de08ecd44233966ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MzJiOGZhZDZmNDQ3YWYxYzgzMDRkZTA4ZWNkNDQyMzM5NjZlYQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-06-29T22:29:30Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-06-29T22:29:30Z"}, "message": "recog.c (peep2_do_rebuild_jump_labels, [...]): New static variables.\n\n\t* recog.c (peep2_do_rebuild_jump_labels, peep2_do_cleanup_cfg): New\n\tstatic variables.\n\t(peep2_buf_position): New static function.\n\t(peep2_regno_dead_p, peep2_reg_dead_p, peep2_find_free_register,\n\tpeephole2_optimize): Use it.\n\t(peep2_attempt, peep2_update_life): New static functions, broken out\n\tof peephole2_optimize.\n\t(peep2_fill_buffer): New static function.\n\t(peephole2_optimize): Change the main loop to try to fill the buffer\n\twith the maximum number of insns before matching them against\n\tpeepholes.  Use a forward scan.  Remove special case for targets with\n\tconditional execution.\n\t* genrecog.c (change_state): Delete dead code.\n\t* config/i386/i386.md (peephole2 for arithmetic ops with memory):\n\tRewrite so as not to expect the second insn to have had a peephole\n\tapplied yet.\n\nFrom-SVN: r161570", "tree": {"sha": "4390e59ed928be9192c181a328f04d0eb045311c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4390e59ed928be9192c181a328f04d0eb045311c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee932b8fad6f447af1c8304de08ecd44233966ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee932b8fad6f447af1c8304de08ecd44233966ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee932b8fad6f447af1c8304de08ecd44233966ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee932b8fad6f447af1c8304de08ecd44233966ea/comments", "author": null, "committer": null, "parents": [{"sha": "68d8db775f3dd767387136cd3baf47cba087d9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d8db775f3dd767387136cd3baf47cba087d9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d8db775f3dd767387136cd3baf47cba087d9a6"}], "stats": {"total": 557, "additions": 310, "deletions": 247}, "files": [{"sha": "42e0295a95af96b1917869efd0b8c2d6616ce6b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee932b8fad6f447af1c8304de08ecd44233966ea", "patch": "@@ -1,3 +1,22 @@\n+2010-06-30  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* recog.c (peep2_do_rebuild_jump_labels, peep2_do_cleanup_cfg): New\n+\tstatic variables.\n+\t(peep2_buf_position): New static function.\n+\t(peep2_regno_dead_p, peep2_reg_dead_p, peep2_find_free_register,\n+\tpeephole2_optimize): Use it.\n+\t(peep2_attempt, peep2_update_life): New static functions, broken out\n+\tof peephole2_optimize.\n+\t(peep2_fill_buffer): New static function.\n+\t(peephole2_optimize): Change the main loop to try to fill the buffer\n+\twith the maximum number of insns before matching them against\n+\tpeepholes.  Use a forward scan.  Remove special case for targets with\n+\tconditional execution.\n+\t* genrecog.c (change_state): Delete dead code.\n+\t* config/i386/i386.md (peephole2 for arithmetic ops with memory):\n+\tRewrite so as not to expect the second insn to have had a peephole\n+\tapplied yet.\n+\n 2010-06-29  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* genhooks.c (emit_findices): Cast field precision to int."}, {"sha": "7003f5225f3c73342a076ef70e61e1dc56b0a289", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ee932b8fad6f447af1c8304de08ecd44233966ea", "patch": "@@ -17558,15 +17558,14 @@\n ;;  leal    (%edx,%eax,4), %eax\n \n (define_peephole2\n-  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+  [(match_scratch:SI 5 \"r\")\n+   (parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t\t   (ashift (match_operand 1 \"register_operand\" \"\")\n \t\t\t   (match_operand 2 \"const_int_operand\" \"\")))\n \t       (clobber (reg:CC FLAGS_REG))])\n-   (set (match_operand 3 \"register_operand\")\n-        (match_operand 4 \"x86_64_general_operand\" \"\"))\n-   (parallel [(set (match_operand 5 \"register_operand\" \"\")\n-\t\t   (plus (match_operand 6 \"register_operand\" \"\")\n-\t\t\t (match_operand 7 \"register_operand\" \"\")))\n+   (parallel [(set (match_operand 3 \"register_operand\" \"\")\n+\t\t   (plus (match_dup 0)\n+\t\t\t (match_operand 4 \"x86_64_general_operand\" \"\")))\n \t\t   (clobber (reg:CC FLAGS_REG))])]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) <= 3\n    /* Validate MODE for lea.  */\n@@ -17576,30 +17575,21 @@\n        || GET_MODE (operands[0]) == SImode\n        || (TARGET_64BIT && GET_MODE (operands[0]) == DImode))\n    /* We reorder load and the shift.  */\n-   && !rtx_equal_p (operands[1], operands[3])\n-   && !reg_overlap_mentioned_p (operands[0], operands[4])\n-   /* Last PLUS must consist of operand 0 and 3.  */\n-   && !rtx_equal_p (operands[0], operands[3])\n-   && (rtx_equal_p (operands[3], operands[6])\n-       || rtx_equal_p (operands[3], operands[7]))\n-   && (rtx_equal_p (operands[0], operands[6])\n-       || rtx_equal_p (operands[0], operands[7]))\n-   /* The intermediate operand 0 must die or be same as output.  */\n-   && (rtx_equal_p (operands[0], operands[5])\n-       || peep2_reg_dead_p (3, operands[0]))\"\n-  [(set (match_dup 3) (match_dup 4))\n+   && !reg_overlap_mentioned_p (operands[0], operands[4])\"\n+  [(set (match_dup 5) (match_dup 4))\n    (set (match_dup 0) (match_dup 1))]\n {\n-  enum machine_mode mode = GET_MODE (operands[5]) == DImode ? DImode : SImode;\n+  enum machine_mode mode = GET_MODE (operands[1]) == DImode ? DImode : SImode;\n   int scale = 1 << INTVAL (operands[2]);\n   rtx index = gen_lowpart (Pmode, operands[1]);\n-  rtx base = gen_lowpart (Pmode, operands[3]);\n-  rtx dest = gen_lowpart (mode, operands[5]);\n+  rtx base = gen_lowpart (Pmode, operands[5]);\n+  rtx dest = gen_lowpart (mode, operands[3]);\n \n   operands[1] = gen_rtx_PLUS (Pmode, base,\n   \t\t\t      gen_rtx_MULT (Pmode, index, GEN_INT (scale)));\n   if (mode != Pmode)\n     operands[1] = gen_rtx_SUBREG (mode, operands[1], 0);\n+  operands[5] = base;\n   operands[0] = dest;\n })\n \f"}, {"sha": "bc7767f192c5c758d1ebe5fe07868d70c309b9ba", "filename": "gcc/genrecog.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=ee932b8fad6f447af1c8304de08ecd44233966ea", "patch": "@@ -1761,20 +1761,11 @@ change_state (const char *oldpos, const char *newpos, const char *indent)\n   int odepth = strlen (oldpos);\n   int ndepth = strlen (newpos);\n   int depth;\n-  int old_has_insn, new_has_insn;\n \n   /* Pop up as many levels as necessary.  */\n   for (depth = odepth; strncmp (oldpos, newpos, depth) != 0; --depth)\n     continue;\n \n-  /* Hunt for the last [A-Z] in both strings.  */\n-  for (old_has_insn = odepth - 1; old_has_insn >= 0; --old_has_insn)\n-    if (ISUPPER (oldpos[old_has_insn]))\n-      break;\n-  for (new_has_insn = ndepth - 1; new_has_insn >= 0; --new_has_insn)\n-    if (ISUPPER (newpos[new_has_insn]))\n-      break;\n-\n   /* Go down to desired level.  */\n   while (depth < ndepth)\n     {"}, {"sha": "eb456c06f45bf5130427e518b16ecf28ae555680", "filename": "gcc/recog.c", "status": "modified", "additions": 280, "deletions": 217, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee932b8fad6f447af1c8304de08ecd44233966ea/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ee932b8fad6f447af1c8304de08ecd44233966ea", "patch": "@@ -2958,6 +2958,10 @@ struct peep2_insn_data\n \n static struct peep2_insn_data peep2_insn_data[MAX_INSNS_PER_PEEP2 + 1];\n static int peep2_current;\n+\n+static bool peep2_do_rebuild_jump_labels;\n+static bool peep2_do_cleanup_cfg;\n+\n /* The number of instructions available to match a peep2.  */\n int peep2_current_count;\n \n@@ -2966,6 +2970,16 @@ int peep2_current_count;\n    DF_LIVE_OUT for the block.  */\n #define PEEP2_EOB\tpc_rtx\n \n+/* Wrap N to fit into the peep2_insn_data buffer.  */\n+\n+static int\n+peep2_buf_position (int n)\n+{\n+  if (n >= MAX_INSNS_PER_PEEP2 + 1)\n+    n -= MAX_INSNS_PER_PEEP2 + 1;\n+  return n;\n+}\n+\n /* Return the Nth non-note insn after `current', or return NULL_RTX if it\n    does not exist.  Used by the recognizer to find the next insn to match\n    in a multi-insn pattern.  */\n@@ -2975,9 +2989,7 @@ peep2_next_insn (int n)\n {\n   gcc_assert (n <= peep2_current_count);\n \n-  n += peep2_current;\n-  if (n >= MAX_INSNS_PER_PEEP2 + 1)\n-    n -= MAX_INSNS_PER_PEEP2 + 1;\n+  n = peep2_buf_position (peep2_current + n);\n \n   return peep2_insn_data[n].insn;\n }\n@@ -2990,9 +3002,7 @@ peep2_regno_dead_p (int ofs, int regno)\n {\n   gcc_assert (ofs < MAX_INSNS_PER_PEEP2 + 1);\n \n-  ofs += peep2_current;\n-  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n-    ofs -= MAX_INSNS_PER_PEEP2 + 1;\n+  ofs = peep2_buf_position (peep2_current + ofs);\n \n   gcc_assert (peep2_insn_data[ofs].insn != NULL_RTX);\n \n@@ -3008,9 +3018,7 @@ peep2_reg_dead_p (int ofs, rtx reg)\n \n   gcc_assert (ofs < MAX_INSNS_PER_PEEP2 + 1);\n \n-  ofs += peep2_current;\n-  if (ofs >= MAX_INSNS_PER_PEEP2 + 1)\n-    ofs -= MAX_INSNS_PER_PEEP2 + 1;\n+  ofs = peep2_buf_position (peep2_current + ofs);\n \n   gcc_assert (peep2_insn_data[ofs].insn != NULL_RTX);\n \n@@ -3045,12 +3053,8 @@ peep2_find_free_register (int from, int to, const char *class_str,\n   gcc_assert (from < MAX_INSNS_PER_PEEP2 + 1);\n   gcc_assert (to < MAX_INSNS_PER_PEEP2 + 1);\n \n-  from += peep2_current;\n-  if (from >= MAX_INSNS_PER_PEEP2 + 1)\n-    from -= MAX_INSNS_PER_PEEP2 + 1;\n-  to += peep2_current;\n-  if (to >= MAX_INSNS_PER_PEEP2 + 1)\n-    to -= MAX_INSNS_PER_PEEP2 + 1;\n+  from = peep2_buf_position (peep2_current + from);\n+  to = peep2_buf_position (peep2_current + to);\n \n   gcc_assert (peep2_insn_data[from].insn != NULL_RTX);\n   REG_SET_TO_HARD_REG_SET (live, peep2_insn_data[from].live_before);\n@@ -3059,8 +3063,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n     {\n       HARD_REG_SET this_live;\n \n-      if (++from >= MAX_INSNS_PER_PEEP2 + 1)\n-\tfrom = 0;\n+      from = peep2_buf_position (from + 1);\n       gcc_assert (peep2_insn_data[from].insn != NULL_RTX);\n       REG_SET_TO_HARD_REG_SET (this_live, peep2_insn_data[from].live_before);\n       IOR_HARD_REG_SET (live, this_live);\n@@ -3153,19 +3156,234 @@ peep2_reinit_state (regset live)\n   COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);\n }\n \n+/* While scanning basic block BB, we found a match of length MATCH_LEN,\n+   starting at INSN.  Perform the replacement, removing the old insns and\n+   replacing them with ATTEMPT.  Returns the last insn emitted.  */\n+\n+static rtx\n+peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n+{\n+  int i;\n+  rtx last, note, before_try, x;\n+  bool was_call = false;\n+\n+  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n+     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other\n+     cfg-related call notes.  */\n+  for (i = 0; i <= match_len; ++i)\n+    {\n+      int j;\n+      rtx old_insn, new_insn, note;\n+\n+      j = peep2_buf_position (peep2_current + i);\n+      old_insn = peep2_insn_data[j].insn;\n+      if (!CALL_P (old_insn))\n+\tcontinue;\n+      was_call = true;\n+\n+      new_insn = attempt;\n+      while (new_insn != NULL_RTX)\n+\t{\n+\t  if (CALL_P (new_insn))\n+\t    break;\n+\t  new_insn = NEXT_INSN (new_insn);\n+\t}\n+\n+      gcc_assert (new_insn != NULL_RTX);\n+\n+      CALL_INSN_FUNCTION_USAGE (new_insn)\n+\t= CALL_INSN_FUNCTION_USAGE (old_insn);\n+\n+      for (note = REG_NOTES (old_insn);\n+\t   note;\n+\t   note = XEXP (note, 1))\n+\tswitch (REG_NOTE_KIND (note))\n+\t  {\n+\t  case REG_NORETURN:\n+\t  case REG_SETJMP:\n+\t    add_reg_note (new_insn, REG_NOTE_KIND (note),\n+\t\t\t  XEXP (note, 0));\n+\t    break;\n+\t  default:\n+\t    /* Discard all other reg notes.  */\n+\t    break;\n+\t  }\n+\n+      /* Croak if there is another call in the sequence.  */\n+      while (++i <= match_len)\n+\t{\n+\t  j = peep2_buf_position (peep2_current + i);\n+\t  old_insn = peep2_insn_data[j].insn;\n+\t  gcc_assert (!CALL_P (old_insn));\n+\t}\n+      break;\n+    }\n+\n+  i = peep2_buf_position (peep2_current + match_len);\n+\n+  note = find_reg_note (peep2_insn_data[i].insn, REG_EH_REGION, NULL_RTX);\n+\n+  /* Replace the old sequence with the new.  */\n+  last = emit_insn_after_setloc (attempt,\n+\t\t\t\t peep2_insn_data[i].insn,\n+\t\t\t\t INSN_LOCATOR (peep2_insn_data[i].insn));\n+  before_try = PREV_INSN (insn);\n+  delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n+\n+  /* Re-insert the EH_REGION notes.  */\n+  if (note || (was_call && nonlocal_goto_handler_labels))\n+    {\n+      edge eh_edge;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (eh_edge, ei, bb->succs)\n+\tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n+\t  break;\n+\n+      if (note)\n+\tcopy_reg_eh_region_note_backward (note, last, before_try);\n+\n+      if (eh_edge)\n+\tfor (x = last; x != before_try; x = PREV_INSN (x))\n+\t  if (x != BB_END (bb)\n+\t      && (can_throw_internal (x)\n+\t\t  || can_nonlocal_goto (x)))\n+\t    {\n+\t      edge nfte, nehe;\n+\t      int flags;\n+\n+\t      nfte = split_block (bb, x);\n+\t      flags = (eh_edge->flags\n+\t\t       & (EDGE_EH | EDGE_ABNORMAL));\n+\t      if (CALL_P (x))\n+\t\tflags |= EDGE_ABNORMAL_CALL;\n+\t      nehe = make_edge (nfte->src, eh_edge->dest,\n+\t\t\t\tflags);\n+\n+\t      nehe->probability = eh_edge->probability;\n+\t      nfte->probability\n+\t\t= REG_BR_PROB_BASE - nehe->probability;\n+\n+\t      peep2_do_cleanup_cfg |= purge_dead_edges (nfte->dest);\n+\t      bb = nfte->src;\n+\t      eh_edge = nehe;\n+\t    }\n+\n+      /* Converting possibly trapping insn to non-trapping is\n+\t possible.  Zap dummy outgoing edges.  */\n+      peep2_do_cleanup_cfg |= purge_dead_edges (bb);\n+    }\n+\n+  /* If we generated a jump instruction, it won't have\n+     JUMP_LABEL set.  Recompute after we're done.  */\n+  for (x = last; x != before_try; x = PREV_INSN (x))\n+    if (JUMP_P (x))\n+      {\n+\tpeep2_do_rebuild_jump_labels = true;\n+\tbreak;\n+      }\n+\n+  return last;\n+}\n+\n+/* After performing a replacement in basic block BB, fix up the life\n+   information in our buffer.  LAST is the last of the insns that we\n+   emitted as a replacement.  PREV is the insn before the start of\n+   the replacement.  MATCH_LEN is the number of instructions that were\n+   matched, and which now need to be replaced in the buffer.  */\n+\n+static void\n+peep2_update_life (basic_block bb, int match_len, rtx last, rtx prev)\n+{\n+  int i = peep2_buf_position (peep2_current + match_len + 1);\n+  rtx x;\n+  regset_head live;\n+\n+  INIT_REG_SET (&live);\n+  COPY_REG_SET (&live, peep2_insn_data[i].live_before);\n+\n+  gcc_assert (peep2_current_count >= match_len + 1);\n+  peep2_current_count -= match_len + 1;\n+\n+  x = last;\n+  do\n+    {\n+      if (INSN_P (x))\n+\t{\n+\t  df_insn_rescan (x);\n+\t  if (peep2_current_count < MAX_INSNS_PER_PEEP2)\n+\t    {\n+\t      peep2_current_count++;\n+\t      if (--i < 0)\n+\t\ti = MAX_INSNS_PER_PEEP2;\n+\t      peep2_insn_data[i].insn = x;\n+\t      df_simulate_one_insn_backwards (bb, x, &live);\n+\t      COPY_REG_SET (peep2_insn_data[i].live_before, &live);\n+\t    }\n+\t}\n+      x = PREV_INSN (x);\n+    }\n+  while (x != prev);\n+  CLEAR_REG_SET (&live);\n+\n+  peep2_current = i;\n+}\n+\n+/* Add INSN, which is in BB, at the end of the peep2 insn buffer if possible.\n+   Return true if we added it, false otherwise.  The caller will try to match\n+   peepholes against the buffer if we return false; otherwise it will try to\n+   add more instructions to the buffer.  */\n+\n+static bool\n+peep2_fill_buffer (basic_block bb, rtx insn, regset live)\n+{\n+  int pos;\n+\n+  /* Once we have filled the maximum number of insns the buffer can hold,\n+     allow the caller to match the insns against peepholes.  We wait until\n+     the buffer is full in case the target has similar peepholes of different\n+     length; we always want to match the longest if possible.  */\n+  if (peep2_current_count == MAX_INSNS_PER_PEEP2)\n+    return false;\n+\n+  /* If an insn has RTX_FRAME_RELATED_P set, peephole substitution would lose\n+     the REG_FRAME_RELATED_EXPR that is attached.  */\n+  if (RTX_FRAME_RELATED_P (insn))\n+    {\n+      /* Let the buffer drain first.  */\n+      if (peep2_current_count > 0)\n+\treturn false;\n+      /* Step over the insn then return true without adding the insn\n+\t to the buffer; this will cause us to process the next\n+\t insn.  */\n+      df_simulate_one_insn_forwards (bb, insn, live);\n+      return true;\n+    }\n+\n+  pos = peep2_buf_position (peep2_current + peep2_current_count);\n+  peep2_insn_data[pos].insn = insn;\n+  COPY_REG_SET (peep2_insn_data[pos].live_before, live);\n+  peep2_current_count++;\n+\n+  df_simulate_one_insn_forwards (bb, insn, live);\n+  return true;\n+}\n+\n /* Perform the peephole2 optimization pass.  */\n \n static void\n peephole2_optimize (void)\n {\n-  rtx insn, prev;\n+  rtx insn;\n   bitmap live;\n   int i;\n   basic_block bb;\n-  bool do_cleanup_cfg = false;\n-  bool do_rebuild_jump_labels = false;\n+\n+  peep2_do_cleanup_cfg = false;\n+  peep2_do_rebuild_jump_labels = false;\n \n   df_set_flags (DF_LR_RUN_DCE);\n+  df_note_add_problem ();\n   df_analyze ();\n \n   /* Initialize the regsets we're going to use.  */\n@@ -3175,222 +3393,67 @@ peephole2_optimize (void)\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n+      bool past_end = false;\n+      int pos;\n+\n       rtl_profile_for_bb (bb);\n \n       /* Start up propagation.  */\n-      bitmap_copy (live, DF_LR_OUT (bb));\n-      df_simulate_initialize_backwards (bb, live);\n+      bitmap_copy (live, DF_LR_IN (bb));\n+      df_simulate_initialize_forwards (bb, live);\n       peep2_reinit_state (live);\n \n-      for (insn = BB_END (bb); ; insn = prev)\n+      insn = BB_HEAD (bb);\n+      for (;;)\n \t{\n-\t  prev = PREV_INSN (insn);\n-\t  if (NONDEBUG_INSN_P (insn))\n-\t    {\n-\t      rtx attempt, before_try, x;\n-\t      int match_len;\n-\t      rtx note;\n-\t      bool was_call = false;\n-\n-\t      /* Record this insn.  */\n-\t      if (--peep2_current < 0)\n-\t\tpeep2_current = MAX_INSNS_PER_PEEP2;\n-\t      if (peep2_current_count < MAX_INSNS_PER_PEEP2\n-\t\t  && peep2_insn_data[peep2_current].insn == NULL_RTX)\n-\t\tpeep2_current_count++;\n-\t      peep2_insn_data[peep2_current].insn = insn;\n-\t      df_simulate_one_insn_backwards (bb, insn, live);\n-\t      COPY_REG_SET (peep2_insn_data[peep2_current].live_before, live);\n-\n-\t      if (RTX_FRAME_RELATED_P (insn))\n-\t\t{\n-\t\t  /* If an insn has RTX_FRAME_RELATED_P set, peephole\n-\t\t     substitution would lose the\n-\t\t     REG_FRAME_RELATED_EXPR that is attached.  */\n-\t\t  peep2_reinit_state (live);\n-\t\t  attempt = NULL;\n-\t\t}\n-\t      else\n-\t\t/* Match the peephole.  */\n-\t\tattempt = peephole2_insns (PATTERN (insn), insn, &match_len);\n+\t  rtx attempt, head;\n+\t  int match_len;\n \n-\t      if (attempt != NULL)\n-\t\t{\n-\t\t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n-\t\t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other\n-\t\t     cfg-related call notes.  */\n-\t\t  for (i = 0; i <= match_len; ++i)\n-\t\t    {\n-\t\t      int j;\n-\t\t      rtx old_insn, new_insn, note;\n-\n-\t\t      j = i + peep2_current;\n-\t\t      if (j >= MAX_INSNS_PER_PEEP2 + 1)\n-\t\t\tj -= MAX_INSNS_PER_PEEP2 + 1;\n-\t\t      old_insn = peep2_insn_data[j].insn;\n-\t\t      if (!CALL_P (old_insn))\n-\t\t\tcontinue;\n-\t\t      was_call = true;\n-\n-\t\t      new_insn = attempt;\n-\t\t      while (new_insn != NULL_RTX)\n-\t\t\t{\n-\t\t\t  if (CALL_P (new_insn))\n-\t\t\t    break;\n-\t\t\t  new_insn = NEXT_INSN (new_insn);\n-\t\t\t}\n-\n-\t\t      gcc_assert (new_insn != NULL_RTX);\n-\n-\t\t      CALL_INSN_FUNCTION_USAGE (new_insn)\n-\t\t\t= CALL_INSN_FUNCTION_USAGE (old_insn);\n-\n-\t\t      for (note = REG_NOTES (old_insn);\n-\t\t\t   note;\n-\t\t\t   note = XEXP (note, 1))\n-\t\t\tswitch (REG_NOTE_KIND (note))\n-\t\t\t  {\n-\t\t\t  case REG_NORETURN:\n-\t\t\t  case REG_SETJMP:\n-\t\t\t    add_reg_note (new_insn, REG_NOTE_KIND (note),\n-\t\t\t\t\t  XEXP (note, 0));\n-\t\t\t    break;\n-\t\t\t  default:\n-\t\t\t    /* Discard all other reg notes.  */\n-\t\t\t    break;\n-\t\t\t  }\n-\n-\t\t      /* Croak if there is another call in the sequence.  */\n-\t\t      while (++i <= match_len)\n-\t\t\t{\n-\t\t\t  j = i + peep2_current;\n-\t\t\t  if (j >= MAX_INSNS_PER_PEEP2 + 1)\n-\t\t\t    j -= MAX_INSNS_PER_PEEP2 + 1;\n-\t\t\t  old_insn = peep2_insn_data[j].insn;\n-\t\t\t  gcc_assert (!CALL_P (old_insn));\n-\t\t\t}\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  i = match_len + peep2_current;\n-\t\t  if (i >= MAX_INSNS_PER_PEEP2 + 1)\n-\t\t    i -= MAX_INSNS_PER_PEEP2 + 1;\n-\n-\t\t  note = find_reg_note (peep2_insn_data[i].insn,\n-\t\t\t\t\tREG_EH_REGION, NULL_RTX);\n-\n-\t\t  /* Replace the old sequence with the new.  */\n-\t\t  attempt = emit_insn_after_setloc (attempt,\n-\t\t\t\t\t\t    peep2_insn_data[i].insn,\n-\t\t\t\t       INSN_LOCATOR (peep2_insn_data[i].insn));\n-\t\t  before_try = PREV_INSN (insn);\n-\t\t  delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n-\n-\t\t  /* Re-insert the EH_REGION notes.  */\n-\t\t  if (note || (was_call && nonlocal_goto_handler_labels))\n-\t\t    {\n-\t\t      edge eh_edge;\n-\t\t      edge_iterator ei;\n-\n-\t\t      FOR_EACH_EDGE (eh_edge, ei, bb->succs)\n-\t\t\tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n-\t\t\t  break;\n+\t  if (!past_end && !NONDEBUG_INSN_P (insn))\n+\t    {\n+\t    next_insn:\n+\t      insn = NEXT_INSN (insn);\n+\t      if (insn == NEXT_INSN (BB_END (bb)))\n+\t\tpast_end = true;\n+\t      continue;\n+\t    }\n+\t  if (!past_end && peep2_fill_buffer (bb, insn, live))\n+\t    goto next_insn;\n \n-\t\t      if (note)\n-\t\t\tcopy_reg_eh_region_note_backward (note, attempt,\n-\t\t\t\t\t\t\t  before_try);\n-\n-\t\t      if (eh_edge)\n-\t\t\tfor (x = attempt ; x != before_try ; x = PREV_INSN (x))\n-\t\t\t  if (x != BB_END (bb)\n-\t\t\t      && (can_throw_internal (x)\n-\t\t\t\t  || can_nonlocal_goto (x)))\n-\t\t\t    {\n-\t\t\t      edge nfte, nehe;\n-\t\t\t      int flags;\n-\n-\t\t\t      nfte = split_block (bb, x);\n-\t\t\t      flags = (eh_edge->flags\n-\t\t\t\t       & (EDGE_EH | EDGE_ABNORMAL));\n-\t\t\t      if (CALL_P (x))\n-\t\t\t\tflags |= EDGE_ABNORMAL_CALL;\n-\t\t\t      nehe = make_edge (nfte->src, eh_edge->dest,\n-\t\t\t\t\t\tflags);\n-\n-\t\t\t      nehe->probability = eh_edge->probability;\n-\t\t\t      nfte->probability\n-\t\t\t\t= REG_BR_PROB_BASE - nehe->probability;\n-\n-\t\t\t      do_cleanup_cfg |= purge_dead_edges (nfte->dest);\n-\t\t\t      bb = nfte->src;\n-\t\t\t      eh_edge = nehe;\n-\t\t\t    }\n-\n-\t\t      /* Converting possibly trapping insn to non-trapping is\n-\t\t\t possible.  Zap dummy outgoing edges.  */\n-\t\t      do_cleanup_cfg |= purge_dead_edges (bb);\n-\t\t    }\n+\t  /* If we did not fill an empty buffer, it signals the end of the\n+\t     block.  */\n+\t  if (peep2_current_count == 0)\n+\t    break;\n \n-\t\t  if (targetm.have_conditional_execution ())\n-\t\t    {\n-\t\t      for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n-\t\t\tpeep2_insn_data[i].insn = NULL_RTX;\n-\t\t      peep2_insn_data[peep2_current].insn = PEEP2_EOB;\n-\t\t      peep2_current_count = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Back up lifetime information past the end of the\n-\t\t\t newly created sequence.  */\n-\t\t      if (++i >= MAX_INSNS_PER_PEEP2 + 1)\n-\t\t\ti = 0;\n-\t\t      bitmap_copy (live, peep2_insn_data[i].live_before);\n-\n-\t\t      /* Update life information for the new sequence.  */\n-\t\t      x = attempt;\n-\t\t      do\n-\t\t\t{\n-\t\t\t  if (INSN_P (x))\n-\t\t\t    {\n-\t\t\t      if (--i < 0)\n-\t\t\t\ti = MAX_INSNS_PER_PEEP2;\n-\t\t\t      if (peep2_current_count < MAX_INSNS_PER_PEEP2\n-\t\t\t\t  && peep2_insn_data[i].insn == NULL_RTX)\n-\t\t\t\tpeep2_current_count++;\n-\t\t\t      peep2_insn_data[i].insn = x;\n-\t\t\t      df_insn_rescan (x);\n-\t\t\t      df_simulate_one_insn_backwards (bb, x, live);\n-\t\t\t      bitmap_copy (peep2_insn_data[i].live_before,\n-\t\t\t\t\t   live);\n-\t\t\t    }\n-\t\t\t  x = PREV_INSN (x);\n-\t\t\t}\n-\t\t      while (x != prev);\n+\t  /* The buffer filled to the current maximum, so try to match.  */\n \n-\t\t      peep2_current = i;\n-\t\t    }\n+\t  pos = peep2_buf_position (peep2_current + peep2_current_count);\n+\t  peep2_insn_data[pos].insn = PEEP2_EOB;\n+\t  COPY_REG_SET (peep2_insn_data[pos].live_before, live);\n \n-\t\t  /* If we generated a jump instruction, it won't have\n-\t\t     JUMP_LABEL set.  Recompute after we're done.  */\n-\t\t  for (x = attempt; x != before_try; x = PREV_INSN (x))\n-\t\t    if (JUMP_P (x))\n-\t\t      {\n-\t\t        do_rebuild_jump_labels = true;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t}\n+\t  /* Match the peephole.  */\n+\t  head = peep2_insn_data[peep2_current].insn;\n+\t  attempt = peephole2_insns (PATTERN (head), head, &match_len);\n+\t  if (attempt != NULL)\n+\t    {\n+\t      rtx last;\n+\t      last = peep2_attempt (bb, head, match_len, attempt);\n+\t      peep2_update_life (bb, match_len, last, PREV_INSN (attempt));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If no match, advance the buffer by one insn.  */\n+\t      peep2_current = peep2_buf_position (peep2_current + 1);\n+\t      peep2_current_count--;\n \t    }\n-\n-\t  if (insn == BB_HEAD (bb))\n-\t    break;\n \t}\n     }\n \n   default_rtl_profile ();\n   for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n     BITMAP_FREE (peep2_insn_data[i].live_before);\n   BITMAP_FREE (live);\n-  if (do_rebuild_jump_labels)\n+  if (peep2_do_rebuild_jump_labels)\n     rebuild_jump_labels (get_insns ());\n }\n #endif /* HAVE_peephole2 */"}]}