{"sha": "5fd9b17875e5e720108ed599b262ad9464576956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkOWIxNzg3NWU1ZTcyMDEwOGVkNTk5YjI2MmFkOTQ2NDU3Njk1Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-20T04:52:59Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-20T04:52:59Z"}, "message": "alias.c, [...]: Replace calls via (*targetm.foo) () with targetm.foo ().\n\n\t* alias.c, attribs.c, bt-load.c, builtins.c, c-common.c,\n\tc-decl.c, c-objc-common.c, c-typeck.c, calls.c, cfglayout.c,\n\tcse.c, dbxout.c, dwarf2out.c, except.c, final.c,\n\thaifa-sched.c, integrate.c, passes.c, rtlanal.c, sched-rgn.c,\n\tsched-vis.c, simplify-rtx.c, stor-layout.c, tree.c, varasm.c,\n\tvmsdbgout.c: Replace calls via (*targetm.foo) () with\n\ttargetm.foo ().\n\nFrom-SVN: r79729", "tree": {"sha": "80dae71541c28dcbf4d7456f50781a1d0823bc15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80dae71541c28dcbf4d7456f50781a1d0823bc15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd9b17875e5e720108ed599b262ad9464576956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd9b17875e5e720108ed599b262ad9464576956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd9b17875e5e720108ed599b262ad9464576956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd9b17875e5e720108ed599b262ad9464576956/comments", "author": null, "committer": null, "parents": [{"sha": "86e7df90ace6a43c5e641c179431cbd53ea29abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e7df90ace6a43c5e641c179431cbd53ea29abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e7df90ace6a43c5e641c179431cbd53ea29abe"}], "stats": {"total": 282, "additions": 146, "deletions": 136}, "files": [{"sha": "4be5285eed5edd2d996d06f6258d6894b668bb36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1,3 +1,13 @@\n+2004-03-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c, attribs.c, bt-load.c, builtins.c, c-common.c,\n+\tc-decl.c, c-objc-common.c, c-typeck.c, calls.c, cfglayout.c,\n+\tcse.c, dbxout.c, dwarf2out.c, except.c, final.c,\n+\thaifa-sched.c, integrate.c, passes.c, rtlanal.c, sched-rgn.c,\n+\tsched-vis.c, simplify-rtx.c, stor-layout.c, tree.c, varasm.c,\n+\tvmsdbgout.c: Replace calls via (*targetm.foo) () with\n+\ttargetm.foo ().\n+\n 2004-03-19  Ziemowit Laski  <zlaski@apple.com>\n \n \t* config/rs6000/altivec.h (vec_dst, vec_dstst, vec_dststt,"}, {"sha": "2c7770d32f6b2ada1cf961cc9c93e857e44259d0", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -2635,7 +2635,7 @@ mark_constant_function (void)\n       || DECL_IS_PURE (current_function_decl)\n       || TREE_THIS_VOLATILE (current_function_decl)\n       || current_function_has_nonlocal_goto\n-      || !(*targetm.binds_local_p) (current_function_decl))\n+      || !targetm.binds_local_p (current_function_decl))\n     return;\n \n   /* A loop might not return which counts as a side effect.  */"}, {"sha": "5d8450ff6018a0204ef9098e57ccfa4e5f9d5a28", "filename": "gcc/attribs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1,6 +1,6 @@\n /* Functions dealing with attribute handling, used by most front ends.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003 Free Software Foundation, Inc.\n+   2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -145,7 +145,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n   if (!attributes_initialized)\n     init_attributes ();\n \n-  (*targetm.insert_attributes) (*node, &attributes);\n+  targetm.insert_attributes (*node, &attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n     {"}, {"sha": "4aa60667dfd072a948f9b4951746f87d9e79b676", "filename": "gcc/bt-load.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1267,7 +1267,7 @@ migrate_btr_def (btr_def def, int min_cost)\n   bitmap_copy (live_range, def->live_range);\n \n #ifdef INSN_SCHEDULING\n-  if ((*targetm.sched.use_dfa_pipeline_interface) ())\n+  if (targetm.sched.use_dfa_pipeline_interface ())\n     def_latency = insn_default_latency (def->insn);\n   else\n     def_latency = result_ready_cost (def->insn);\n@@ -1414,12 +1414,12 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n void\n branch_target_load_optimize (rtx insns, bool after_prologue_epilogue_gen)\n {\n-  enum reg_class class = (*targetm.branch_target_register_class) ();\n+  enum reg_class class = targetm.branch_target_register_class ();\n   if (class != NO_REGS)\n     {\n       /* Initialize issue_rate.  */\n       if (targetm.sched.issue_rate)\n-\tissue_rate = (*targetm.sched.issue_rate) ();\n+\tissue_rate = targetm.sched.issue_rate ();\n       else\n \tissue_rate = 1;\n "}, {"sha": "012b5a57bd6505127a0df0ba329773a8bc673621", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -4961,7 +4961,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n   emit_queue ();\n \n   if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n-    return (*targetm.expand_builtin) (exp, target, subtarget, mode, ignore);\n+    return targetm.expand_builtin (exp, target, subtarget, mode, ignore);\n \n   /* When not optimizing, generate calls to library functions for a certain\n      set of builtins.  */"}, {"sha": "e21d5bd3f596721b9b0a24521c3297196987f209", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -3401,7 +3401,7 @@ c_common_nodes_and_builtins (void)\n #include \"builtins.def\"\n #undef DEF_BUILTIN\n \n-  (*targetm.init_builtins) ();\n+  targetm.init_builtins ();\n \n   main_identifier_node = get_identifier (\"main\");\n }\n@@ -4614,7 +4614,7 @@ handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n \n       else if ((TREE_CODE (type) == POINTER_TYPE\n \t\t|| TREE_CODE (type) == REFERENCE_TYPE)\n-\t       && !(*targetm.valid_pointer_mode) (mode))\n+\t       && !targetm.valid_pointer_mode (mode))\n \terror (\"invalid pointer mode `%s'\", p);\n       else\n \t{"}, {"sha": "50ea380e3f27cdf9d9ef289386dbf0dfaab3151c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1268,7 +1268,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n     }\n \n   DECL_ATTRIBUTES (newdecl)\n-    = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n+    = targetm.merge_decl_attributes (olddecl, newdecl);\n \n   /* Merge the data types specified in the two decls.  */\n   TREE_TYPE (newdecl)"}, {"sha": "575407102fbacbfa3ec470eefdb2d4fc21a896d5", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -86,7 +86,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n \n   /* Don't auto-inline anything that might not be bound within\n      this unit of translation.  */\n-  if (!DECL_DECLARED_INLINE_P (fn) && !(*targetm.binds_local_p) (fn))\n+  if (!DECL_DECLARED_INLINE_P (fn) && !targetm.binds_local_p (fn))\n     {\n       if (do_warning)\n \twarning (\"%Jfunction '%F' can never be inlined because it might not \""}, {"sha": "50ae16ff7bbc1636f2aeeafa444e316ae3d31674", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -226,7 +226,7 @@ common_type (tree t1, tree t2)\n     return t1;\n \n   /* Merge the attributes.  */\n-  attributes = (*targetm.merge_type_attributes) (t1, t2);\n+  attributes = targetm.merge_type_attributes (t1, t2);\n \n   /* Treat an enum type as the unsigned integer type of the same width.  */\n \n@@ -502,7 +502,7 @@ comptypes (tree type1, tree type2, int flags)\n     return 1;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  if (! (attrval = (*targetm.comp_type_attributes) (t1, t2)))\n+  if (! (attrval = targetm.comp_type_attributes (t1, t2)))\n      return 0;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -577,8 +577,8 @@ comptypes (tree type1, tree type2, int flags)\n \n     case VECTOR_TYPE:\n       /* The target might allow certain vector types to be compatible.  */\n-      val = (*targetm.vector_opaque_p) (t1)\n-\t|| (*targetm.vector_opaque_p) (t2)\n+      val = targetm.vector_opaque_p (t1)\n+\t|| targetm.vector_opaque_p (t2)\n \t|| TYPE_MODE (t1) == TYPE_MODE (t2);\n       break;\n \n@@ -3393,8 +3393,8 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n       int target_cmp = 0;   /* Cache comp_target_types () result.  */\n \n       /* Opaque pointers are treated like void pointers.  */\n-      is_opaque_pointer = ((*targetm.vector_opaque_p) (type)\n-                           || (*targetm.vector_opaque_p) (rhstype))\n+      is_opaque_pointer = (targetm.vector_opaque_p (type)\n+                           || targetm.vector_opaque_p (rhstype))\n         && TREE_CODE (ttl) == VECTOR_TYPE\n         && TREE_CODE (ttr) == VECTOR_TYPE;\n \n@@ -4345,7 +4345,7 @@ really_start_incremental_init (tree type)\n   if (type == 0)\n     type = TREE_TYPE (constructor_decl);\n \n-  if ((*targetm.vector_opaque_p) (type))\n+  if (targetm.vector_opaque_p (type))\n     error (\"opaque vector types cannot be initialized\");\n \n   p->type = constructor_type;"}, {"sha": "0d429f657670f81be113f669f15b744d15f46d6c", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -2514,7 +2514,7 @@ expand_call (tree exp, rtx target, int ignore)\n       || structure_value_addr != NULL_RTX\n       /* Check whether the target is able to optimize the call\n \t into a sibcall.  */\n-      || !(*targetm.function_ok_for_sibcall) (fndecl, exp)\n+      || !targetm.function_ok_for_sibcall (fndecl, exp)\n       /* Functions that do not return exactly once may not be sibcall\n          optimized.  */\n       || (flags & (ECF_RETURNS_TWICE | ECF_LONGJMP | ECF_NORETURN))"}, {"sha": "aa79d6ec5494838e05c9cc0c457a3e26d8ac6696", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -907,7 +907,7 @@ cfg_layout_can_duplicate_bb_p (basic_block bb)\n       rtx insn = BB_HEAD (bb);\n       while (1)\n \t{\n-\t  if (INSN_P (insn) && (*targetm.cannot_copy_insn_p) (insn))\n+\t  if (INSN_P (insn) && targetm.cannot_copy_insn_p (insn))\n \t    return false;\n \t  if (insn == BB_END (bb))\n \t    break;"}, {"sha": "9e4cab8cd9097f6c8b6a0a79c30d85a85959a4ab", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -7697,7 +7697,7 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n \t\t\t\t       XEXP (SET_SRC (set), 1)))\n \t\t\t   \n \t\t{\n-\t\t  comp_mode = (*targetm.cc_modes_compatible) (mode, set_mode);\n+\t\t  comp_mode = targetm.cc_modes_compatible (mode, set_mode);\n \t\t  if (comp_mode != VOIDmode\n \t\t      && (can_change_mode || comp_mode == mode))\n \t\t    found = true;\n@@ -7815,7 +7815,7 @@ cse_condition_code_reg (void)\n   rtx cc_reg_2;\n   basic_block bb;\n \n-  if (! (*targetm.fixed_condition_code_regs) (&cc_regno_1, &cc_regno_2))\n+  if (! targetm.fixed_condition_code_regs (&cc_regno_1, &cc_regno_2))\n     return;\n \n   cc_reg_1 = gen_rtx_REG (CCmode, cc_regno_1);"}, {"sha": "89ba1cf6a8600e7b9b73dfd2ca954889094f3475", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -452,7 +452,7 @@ dbxout_function_end (void)\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n   ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, \"Lscope\", scope_labelno);\n-  (*targetm.asm_out.internal_label) (asmfile, \"Lscope\", scope_labelno);\n+  targetm.asm_out.internal_label (asmfile, \"Lscope\", scope_labelno);\n   scope_labelno++;\n \n   /* By convention, GCC will mark the end of a function with an N_FUN\n@@ -520,7 +520,7 @@ dbxout_init (const char *input_file_name)\n   assemble_name (asmfile, ltext_label_name);\n   fputc ('\\n', asmfile);\n   text_section ();\n-  (*targetm.asm_out.internal_label) (asmfile, \"Ltext\", 0);\n+  targetm.asm_out.internal_label (asmfile, \"Ltext\", 0);\n #endif /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n \n #ifdef DBX_OUTPUT_GCC_MARKER\n@@ -729,7 +729,7 @@ dbxout_source_file (FILE *file, const char *filename)\n \t; /* Don't change section amid function.  */\n       else\n \ttext_section ();\n-      (*targetm.asm_out.internal_label) (file, \"Ltext\", source_label_number);\n+      targetm.asm_out.internal_label (file, \"Ltext\", source_label_number);\n       source_label_number++;\n       lastfile = filename;\n     }\n@@ -757,7 +757,7 @@ static void\n dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   emit_pending_bincls_if_required ();\n-  (*targetm.asm_out.internal_label) (asmfile, \"LBB\", n);\n+  targetm.asm_out.internal_label (asmfile, \"LBB\", n);\n }\n \n /* Describe the end line-number of an internal block within a function.  */\n@@ -766,7 +766,7 @@ static void\n dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   emit_pending_bincls_if_required ();\n-  (*targetm.asm_out.internal_label) (asmfile, \"LBE\", n);\n+  targetm.asm_out.internal_label (asmfile, \"LBE\", n);\n }\n \n /* Output dbx data for a function definition."}, {"sha": "3cc1782c83598e15791a3d55c923c50e2142982f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -149,7 +149,7 @@ collect2_eh_frame_section (void)\n \n   data_section ();\n   ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n-  (*targetm.asm_out.globalize_label) (asm_out_file, IDENTIFIER_POINTER (label));\n+  targetm.asm_out.globalize_label (asm_out_file, IDENTIFIER_POINTER (label));\n   ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));\n }\n \n@@ -1958,7 +1958,7 @@ output_call_frame_info (int for_eh)\n       if ((fde_table[i].nothrow || fde_table[i].all_throwers_are_sibcalls)\n           && !fde_table[i].uses_eh_lsda\n \t  && ! DECL_ONE_ONLY (fde_table[i].decl))\n-\t(*targetm.asm_out.unwind_label) (asm_out_file, fde_table[i].decl,\n+\ttargetm.asm_out.unwind_label (asm_out_file, fde_table[i].decl,\n \t\t\t\t\t /* empty */ 1);\n \n   /* If we don't have any functions we'll want to unwind out of, don't\n@@ -1988,7 +1988,7 @@ output_call_frame_info (int for_eh)\n     app_enable ();\n \n   if (for_eh)\n-    (*targetm.asm_out.eh_frame_section) ();\n+    targetm.asm_out.eh_frame_section ();\n   else\n     named_section_flags (DEBUG_FRAME_SECTION, SECTION_DEBUG);\n \n@@ -2123,8 +2123,8 @@ output_call_frame_info (int for_eh)\n \t  && !fde->uses_eh_lsda)\n \tcontinue;\n \n-      (*targetm.asm_out.unwind_label) (asm_out_file, fde->decl, /* empty */ 0);\n-      (*targetm.asm_out.internal_label) (asm_out_file, FDE_LABEL, for_eh + i * 2);\n+      targetm.asm_out.unwind_label (asm_out_file, fde->decl, /* empty */ 0);\n+      targetm.asm_out.internal_label (asm_out_file, FDE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n       dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n@@ -6632,7 +6632,7 @@ output_die_symbol (dw_die_ref die)\n     /* We make these global, not weak; if the target doesn't support\n        .linkonce, it doesn't support combining the sections, so debugging\n        will break.  */\n-    (*targetm.asm_out.globalize_label) (asm_out_file, sym);\n+    targetm.asm_out.globalize_label (asm_out_file, sym);\n \n   ASM_OUTPUT_LABEL (asm_out_file, sym);\n }\n@@ -8230,7 +8230,7 @@ reg_loc_descriptor (rtx rtl)\n     return 0;\n \n   reg = reg_number (rtl);\n-  regs = (*targetm.dwarf_register_span) (rtl);\n+  regs = targetm.dwarf_register_span (rtl);\n \n   if (hard_regno_nregs[reg][GET_MODE (rtl)] > 1\n       || regs)\n@@ -8405,7 +8405,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n      actually within the array.  That's *not* necessarily the same as the\n      zeroth element of the array.  */\n \n-  rtl = (*targetm.delegitimize_address) (rtl);\n+  rtl = targetm.delegitimize_address (rtl);\n \n   switch (GET_CODE (rtl))\n     {\n@@ -8879,7 +8879,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \tmode = GET_MODE (rtl);\n \trtl = XEXP (rtl, 0);\n \n-\trtl = (*targetm.delegitimize_address) (rtl);\n+\trtl = targetm.delegitimize_address (rtl);\n \n \tindirect_p = 1;\n \tret = mem_loc_descriptor (rtl, mode, true);\n@@ -9664,7 +9664,7 @@ rtl_for_decl_location (tree decl)\n \t          && TREE_CODE (decl) == VAR_DECL\n \t\t  && TREE_STATIC (decl))))\n \t{\n-\t  rtl = (*targetm.delegitimize_address) (rtl);\n+\t  rtl = targetm.delegitimize_address (rtl);\n \t  return rtl;\n \t}\n       rtl = NULL_RTX;\n@@ -9771,7 +9771,7 @@ rtl_for_decl_location (tree decl)\n     }\n \n   if (rtl)\n-    rtl = (*targetm.delegitimize_address) (rtl);\n+    rtl = targetm.delegitimize_address (rtl);\n \n   /* If we don't look past the constant pool, we risk emitting a\n      reference to a constant pool entry that isn't referenced from\n@@ -13052,7 +13052,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n       else if (DECL_SECTION_NAME (current_function_decl))\n \t{\n \t  dw_separate_line_info_ref line_info;\n-\t  (*targetm.asm_out.internal_label) (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n+\t  targetm.asm_out.internal_label (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n \t\t\t\t     separate_line_info_table_in_use);\n \n \t  /* Expand the line info table if necessary.  */\n@@ -13082,7 +13082,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \t{\n \t  dw_line_info_ref line_info;\n \n-\t  (*targetm.asm_out.internal_label) (asm_out_file, LINE_CODE_LABEL,\n+\t  targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL,\n \t\t\t\t     line_info_table_in_use);\n \n \t  /* Expand the line info table if necessary.  */\n@@ -13590,7 +13590,7 @@ dwarf2out_finish (const char *filename)\n \n   /* Output a terminator label for the .text section.  */\n   text_section ();\n-  (*targetm.asm_out.internal_label) (asm_out_file, TEXT_END_LABEL, 0);\n+  targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);\n \n   /* Output the source line correspondence table.  We must do this\n      even if there is no line information.  Otherwise, on an empty"}, {"sha": "36e3f43dca0aad0be7e255c9517c82fd14289c4c", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -3738,7 +3738,7 @@ output_function_exception_table (void)\n   /* Note that varasm still thinks we're in the function's code section.\n      The \".endp\" directive that will immediately follow will take us back.  */\n #else\n-  (*targetm.asm_out.exception_section) ();\n+  targetm.asm_out.exception_section ();\n #endif\n \n   have_tt_data = (VARRAY_ACTIVE_SIZE (cfun->eh->ttype_data) > 0\n@@ -3759,7 +3759,7 @@ output_function_exception_table (void)\n       assemble_align (tt_format_size * BITS_PER_UNIT);\n     }\n \n-  (*targetm.asm_out.internal_label) (asm_out_file, \"LLSDA\",\n+  targetm.asm_out.internal_label (asm_out_file, \"LLSDA\",\n \t\t\t     current_function_funcdef_no);\n \n   /* The LSDA header.  */"}, {"sha": "b53e9a8e931dc68ae20a60946ebffe43d299d2f0", "filename": "gcc/final.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1380,7 +1380,7 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n     }\n \n   /* First output the function prologue: code to set up the stack frame.  */\n-  (*targetm.asm_out.function_prologue) (file, get_frame_size ());\n+  targetm.asm_out.function_prologue (file, get_frame_size ());\n \n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n@@ -1418,7 +1418,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n       int align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);\n       data_section ();\n       ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));\n-      (*targetm.asm_out.internal_label) (file, \"LP\", current_function_funcdef_no);\n+      targetm.asm_out.internal_label (file, \"LP\", current_function_funcdef_no);\n       assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, align, 1);\n     }\n \n@@ -1474,7 +1474,7 @@ final_end_function (void)\n \n   /* Finally, output the function epilogue:\n      code to restore the stack frame and return to the caller.  */\n-  (*targetm.asm_out.function_epilogue) (asm_out_file, get_frame_size ());\n+  targetm.asm_out.function_epilogue (asm_out_file, get_frame_size ());\n \n   /* And debug output.  */\n   (*debug_hooks->end_epilogue) (last_linenum, last_filename);\n@@ -1609,7 +1609,7 @@ output_alternate_entry_point (FILE *file, rtx insn)\n       ASM_WEAKEN_LABEL (file, name);\n #endif\n     case LABEL_GLOBAL_ENTRY:\n-      (*targetm.asm_out.globalize_label) (file, name);\n+      targetm.asm_out.globalize_label (file, name);\n     case LABEL_STATIC_ENTRY:\n #ifdef ASM_OUTPUT_TYPE_DIRECTIVE\n       ASM_OUTPUT_TYPE_DIRECTIVE (file, name, \"function\");\n@@ -1701,7 +1701,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_PROLOGUE_END:\n-\t  (*targetm.asm_out.function_end_prologue) (file);\n+\t  targetm.asm_out.function_end_prologue (file);\n \t  profile_after_prologue (file);\n \n \t  if ((*seen & (SEEN_EMITTED | SEEN_NOTE)) == SEEN_NOTE)\n@@ -1715,7 +1715,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_EPILOGUE_BEG:\n-\t  (*targetm.asm_out.function_begin_epilogue) (file);\n+\t  targetm.asm_out.function_begin_epilogue (file);\n \t  break;\n \n \tcase NOTE_INSN_FUNCTION_BEG:\n@@ -1901,7 +1901,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t      ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn),\n \t\t\t\t     NEXT_INSN (insn));\n #else\n-\t      (*targetm.asm_out.internal_label) (file, \"L\", CODE_LABEL_NUMBER (insn));\n+\t      targetm.asm_out.internal_label (file, \"L\", CODE_LABEL_NUMBER (insn));\n #endif\n #endif\n \t      break;\n@@ -1910,7 +1910,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       if (LABEL_ALT_ENTRY_P (insn))\n \toutput_alternate_entry_point (file, insn);\n       else\n-\t(*targetm.asm_out.internal_label) (file, \"L\", CODE_LABEL_NUMBER (insn));\n+\ttargetm.asm_out.internal_label (file, \"L\", CODE_LABEL_NUMBER (insn));\n       break;\n \n     default:"}, {"sha": "a87d7ad209707f3b09f3813d692683107bb8f5a9", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -875,7 +875,7 @@ insn_cost (rtx insn, rtx link, rtx used)\n       else\n \t{\n \t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t      && targetm.sched.use_dfa_pipeline_interface ())\n \t    cost = insn_default_latency (insn);\n \t  else\n \t    cost = result_ready_cost (insn);\n@@ -899,7 +899,7 @@ insn_cost (rtx insn, rtx link, rtx used)\n   else\n     {\n       if (targetm.sched.use_dfa_pipeline_interface\n-\t  && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t  && targetm.sched.use_dfa_pipeline_interface ())\n \t{\n \t  if (INSN_CODE (insn) >= 0)\n \t    {\n@@ -918,7 +918,7 @@ insn_cost (rtx insn, rtx link, rtx used)\n \t}\n \n       if (targetm.sched.adjust_cost)\n-\tcost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n+\tcost = targetm.sched.adjust_cost (used, link, insn, cost);\n \n       if (cost < 0)\n \tcost = 0;\n@@ -1210,25 +1210,25 @@ adjust_priority (rtx prev)\n \n   if (targetm.sched.adjust_priority)\n     INSN_PRIORITY (prev) =\n-      (*targetm.sched.adjust_priority) (prev, INSN_PRIORITY (prev));\n+      targetm.sched.adjust_priority (prev, INSN_PRIORITY (prev));\n }\n \n /* Advance time on one cycle.  */\n HAIFA_INLINE static void\n advance_one_cycle (void)\n {\n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       if (targetm.sched.dfa_pre_cycle_insn)\n \tstate_transition (curr_state,\n-\t\t\t  (*targetm.sched.dfa_pre_cycle_insn) ());\n+\t\t\t  targetm.sched.dfa_pre_cycle_insn ());\n \n       state_transition (curr_state, NULL);\n \n       if (targetm.sched.dfa_post_cycle_insn)\n \tstate_transition (curr_state,\n-\t\t\t  (*targetm.sched.dfa_post_cycle_insn) ());\n+\t\t\t  targetm.sched.dfa_post_cycle_insn ());\n     }\n }\n \n@@ -1250,11 +1250,11 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n   int premature_issue = 0;\n \n   if (!targetm.sched.use_dfa_pipeline_interface\n-      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+      || !targetm.sched.use_dfa_pipeline_interface ())\n     unit = insn_unit (insn);\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ()\n+      && targetm.sched.use_dfa_pipeline_interface ()\n       && sched_verbose >= 1)\n     {\n       char buf[2048];\n@@ -1278,7 +1278,7 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n     }\n \n   if (!targetm.sched.use_dfa_pipeline_interface\n-      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+      || !targetm.sched.use_dfa_pipeline_interface ())\n     {\n       if (sched_verbose && unit == -1)\n \tvisualize_no_unit (insn);\n@@ -1808,7 +1808,7 @@ queue_to_ready (struct ready_list *ready)\n \t}\n \n       if ((!targetm.sched.use_dfa_pipeline_interface\n-\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t   || !targetm.sched.use_dfa_pipeline_interface ())\n \t  && sched_verbose && stalls)\n \tvisualize_stall_cycles (stalls);\n \n@@ -2194,7 +2194,7 @@ choose_ready (struct ready_list *ready)\n   int lookahead = 0;\n \n   if (targetm.sched.first_cycle_multipass_dfa_lookahead)\n-    lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n+    lookahead = targetm.sched.first_cycle_multipass_dfa_lookahead ();\n   if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0)))\n     return ready_remove_first (ready);\n   else\n@@ -2219,7 +2219,7 @@ choose_ready (struct ready_list *ready)\n \t  ready_try [i]\n \t    = (INSN_CODE (insn) < 0\n \t       || (targetm.sched.first_cycle_multipass_dfa_lookahead_guard\n-\t\t   && !(*targetm.sched.first_cycle_multipass_dfa_lookahead_guard) (insn)));\n+\t\t   && !targetm.sched.first_cycle_multipass_dfa_lookahead_guard (insn)));\n \t}\n       if (max_issue (ready, &index) == 0)\n \treturn ready_remove_first (ready);\n@@ -2272,7 +2272,7 @@ schedule_block (int b, int rgn_n_insns)\n     }\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     state_reset (curr_state);\n   else\n     clear_units ();\n@@ -2284,7 +2284,7 @@ schedule_block (int b, int rgn_n_insns)\n   ready.n_ready = 0;\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       /* It is used for first cycle multipass scheduling.  */\n       temp_state = alloca (dfa_state_size);\n@@ -2298,7 +2298,7 @@ schedule_block (int b, int rgn_n_insns)\n   (*current_sched_info->init_ready_list) (&ready);\n \n   if (targetm.sched.md_init)\n-    (*targetm.sched.md_init) (sched_dump, sched_verbose, ready.veclen);\n+    targetm.sched.md_init (sched_dump, sched_verbose, ready.veclen);\n \n   /* We start inserting insns after PREV_HEAD.  */\n   last_scheduled_insn = prev_head;\n@@ -2309,7 +2309,7 @@ schedule_block (int b, int rgn_n_insns)\n   q_size = 0;\n \n   if (!targetm.sched.use_dfa_pipeline_interface\n-      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+      || !targetm.sched.use_dfa_pipeline_interface ())\n     max_insn_queue_index_macro_value = INSN_QUEUE_SIZE - 1;\n   else\n     max_insn_queue_index_macro_value = max_insn_queue_index;\n@@ -2370,9 +2370,9 @@ schedule_block (int b, int rgn_n_insns)\n \t  && (ready.n_ready == 0\n \t      || !SCHED_GROUP_P (ready_element (&ready, 0))))\n \tcan_issue_more =\n-\t  (*targetm.sched.reorder) (sched_dump, sched_verbose,\n-\t\t\t\t    ready_lastpos (&ready),\n-\t\t\t\t    &ready.n_ready, clock_var);\n+\t  targetm.sched.reorder (sched_dump, sched_verbose,\n+\t\t\t\t ready_lastpos (&ready),\n+\t\t\t\t &ready.n_ready, clock_var);\n       else\n \tcan_issue_more = issue_rate;\n \n@@ -2391,7 +2391,7 @@ schedule_block (int b, int rgn_n_insns)\n \t    }\n \n \t  if (!targetm.sched.use_dfa_pipeline_interface\n-\t      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t      || !targetm.sched.use_dfa_pipeline_interface ())\n \t    {\n \t      if (ready.n_ready == 0 || !can_issue_more\n \t\t  || !(*current_sched_info->schedule_more_p) ())\n@@ -2427,9 +2427,9 @@ schedule_block (int b, int rgn_n_insns)\n \t\tinsn = ready_remove_first (&ready);\n \n \t      if (targetm.sched.dfa_new_cycle\n-\t\t  && (*targetm.sched.dfa_new_cycle) (sched_dump, sched_verbose,\n-\t\t\t\t\t\t     insn, last_clock_var,\n-\t\t\t\t\t\t     clock_var, &sort_p))\n+\t\t  && targetm.sched.dfa_new_cycle (sched_dump, sched_verbose,\n+\t\t\t\t\t\t  insn, last_clock_var,\n+\t\t\t\t\t\t  clock_var, &sort_p))\n \t\t{\n \t\t  ready_add (&ready, insn);\n \t\t  break;\n@@ -2465,7 +2465,7 @@ schedule_block (int b, int rgn_n_insns)\n \t\t\t  rtx bubble;\n \n \t\t\t  for (j = 0;\n-\t\t\t       (bubble = (*targetm.sched.dfa_bubble) (j))\n+\t\t\t       (bubble = targetm.sched.dfa_bubble (j))\n \t\t\t\t != NULL_RTX;\n \t\t\t       j++)\n \t\t\t    {\n@@ -2538,7 +2538,7 @@ schedule_block (int b, int rgn_n_insns)\n \t  last_scheduled_insn = move_insn (insn, last_scheduled_insn);\n \n \t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t      && targetm.sched.use_dfa_pipeline_interface ())\n \t    {\n \t      if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n \t\tcycle_issued_insns++;\n@@ -2547,7 +2547,7 @@ schedule_block (int b, int rgn_n_insns)\n \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n-\t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n+\t      targetm.sched.variable_issue (sched_dump, sched_verbose,\n \t\t\t\t\t       insn, can_issue_more);\n \t  /* A naked CLOBBER or USE generates no instruction, so do\n \t     not count them against the issue rate.  */\n@@ -2573,30 +2573,30 @@ schedule_block (int b, int rgn_n_insns)\n \t\t  || !SCHED_GROUP_P (ready_element (&ready, 0))))\n \t    {\n \t      can_issue_more =\n-\t\t(*targetm.sched.reorder2) (sched_dump, sched_verbose,\n-\t\t\t\t\t   ready.n_ready\n-\t\t\t\t\t   ? ready_lastpos (&ready) : NULL,\n-\t\t\t\t\t   &ready.n_ready, clock_var);\n+\t\ttargetm.sched.reorder2 (sched_dump, sched_verbose,\n+\t\t\t\t\tready.n_ready\n+\t\t\t\t\t? ready_lastpos (&ready) : NULL,\n+\t\t\t\t\t&ready.n_ready, clock_var);\n \t    }\n \t}\n \n       if ((!targetm.sched.use_dfa_pipeline_interface\n-\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t   || !targetm.sched.use_dfa_pipeline_interface ())\n \t  && sched_verbose)\n \t/* Debug info.  */\n \tvisualize_scheduled_insns (clock_var);\n     }\n \n   if (targetm.sched.md_finish)\n-    (*targetm.sched.md_finish) (sched_dump, sched_verbose);\n+    targetm.sched.md_finish (sched_dump, sched_verbose);\n \n   /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n       if (!targetm.sched.use_dfa_pipeline_interface\n-\t  || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t  || !targetm.sched.use_dfa_pipeline_interface ())\n \tprint_block_visualization (\"\");\n     }\n \n@@ -2665,7 +2665,7 @@ schedule_block (int b, int rgn_n_insns)\n   free (ready.vec);\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       free (ready_try);\n       for (i = 0; i <= rgn_n_insns; i++)\n@@ -2738,7 +2738,7 @@ sched_init (FILE *dump_file)\n \n   /* Initialize issue_rate.  */\n   if (targetm.sched.issue_rate)\n-    issue_rate = (*targetm.sched.issue_rate) ();\n+    issue_rate = targetm.sched.issue_rate ();\n   else\n     issue_rate = 1;\n \n@@ -2759,17 +2759,17 @@ sched_init (FILE *dump_file)\n     h_i_d [i].cost = -1;\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       if (targetm.sched.init_dfa_pre_cycle_insn)\n-\t(*targetm.sched.init_dfa_pre_cycle_insn) ();\n+\ttargetm.sched.init_dfa_pre_cycle_insn ();\n \n       if (targetm.sched.init_dfa_post_cycle_insn)\n-\t(*targetm.sched.init_dfa_post_cycle_insn) ();\n+\ttargetm.sched.init_dfa_post_cycle_insn ();\n \n       if (targetm.sched.first_cycle_multipass_dfa_lookahead\n \t  && targetm.sched.init_dfa_bubbles)\n-\t(*targetm.sched.init_dfa_bubbles) ();\n+\ttargetm.sched.init_dfa_bubbles ();\n \n       dfa_start ();\n       dfa_state_size = state_size ();\n@@ -2832,7 +2832,7 @@ sched_init (FILE *dump_file)\n     }\n \n   if ((!targetm.sched.use_dfa_pipeline_interface\n-       || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+       || !targetm.sched.use_dfa_pipeline_interface ())\n       && sched_verbose)\n     /* Find units used in this function, for visualization.  */\n     init_target_units ();\n@@ -2858,7 +2858,7 @@ sched_init (FILE *dump_file)\n     find_insn_reg_weight (b->index);\n \n   if (targetm.sched.md_init_global)\n-      (*targetm.sched.md_init_global) (sched_dump, sched_verbose, old_max_uid);\n+      targetm.sched.md_init_global (sched_dump, sched_verbose, old_max_uid);\n }\n \n /* Free global data used during insn scheduling.  */\n@@ -2869,7 +2869,7 @@ sched_finish (void)\n   free (h_i_d);\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       free (curr_state);\n       dfa_finish ();\n@@ -2880,6 +2880,6 @@ sched_finish (void)\n     free (line_note_head);\n \n   if (targetm.sched.md_finish_global)\n-      (*targetm.sched.md_finish_global) (sched_dump, sched_verbose);\n+      targetm.sched.md_finish_global (sched_dump, sched_verbose);\n }\n #endif /* INSN_SCHEDULING */"}, {"sha": "b9f4681189350523b49c3957969f3fe1c66e7340", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -130,7 +130,7 @@ function_attribute_inlinable_p (tree fndecl)\n \n \t  for (i = 0; targetm.attribute_table[i].name != NULL; i++)\n \t    if (is_attribute_p (targetm.attribute_table[i].name, name))\n-\t      return (*targetm.function_attribute_inlinable_p) (fndecl);\n+\t      return targetm.function_attribute_inlinable_p (fndecl);\n \t}\n     }\n "}, {"sha": "f70cb856a7ed4ccbfc90634580404795c863f3b9", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -556,7 +556,7 @@ rest_of_handle_machine_reorg (tree decl, rtx insns)\n   timevar_push (TV_MACH_DEP);\n   open_dump_file (DFI_mach, decl);\n \n-  (*targetm.machine_dependent_reorg) ();\n+  targetm.machine_dependent_reorg ();\n \n   close_dump_file (DFI_mach, print_rtl, insns);\n   timevar_pop (TV_MACH_DEP);\n@@ -2086,7 +2086,7 @@ rest_of_compilation (tree decl)\n \n   timevar_pop (TV_FINAL);\n \n-  if ((*targetm.binds_local_p) (current_function_decl))\n+  if (targetm.binds_local_p (current_function_decl))\n     {\n       int pref = cfun->preferred_stack_boundary;\n       if (cfun->recursive_call_emit"}, {"sha": "3f3a4289d6364e766d6d47979a5d995f5f84dc5c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -3841,7 +3841,7 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n       break;\n \n     default:\n-      if ((*targetm.rtx_costs) (x, code, outer_code, &total))\n+      if (targetm.rtx_costs (x, code, outer_code, &total))\n \treturn total;\n       break;\n     }\n@@ -3881,7 +3881,7 @@ address_cost (rtx x, enum machine_mode mode)\n   if (!memory_address_p (mode, x))\n     return 1000;\n \n-  return (*targetm.address_cost) (x);\n+  return targetm.address_cost (x);\n }\n \n /* If the target doesn't override, compute the cost as with arithmetic.  */"}, {"sha": "2cb89a40488a4a696ccb4246e81131c1dfddbe27", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1761,7 +1761,7 @@ init_ready_list (struct ready_list *ready)\n \n \t  if (targetm.sched.adjust_priority)\n \t    INSN_PRIORITY (insn) =\n-\t      (*targetm.sched.adjust_priority) (insn, INSN_PRIORITY (insn));\n+\t      targetm.sched.adjust_priority (insn, INSN_PRIORITY (insn));\n \t}\n       target_n_insns++;\n     }\n@@ -1788,10 +1788,10 @@ init_ready_list (struct ready_list *ready)\n \t    if (!CANT_MOVE (insn)\n \t\t&& (!IS_SPECULATIVE_INSN (insn)\n \t\t    || ((((!targetm.sched.use_dfa_pipeline_interface\n-\t\t\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t\t   || !targetm.sched.use_dfa_pipeline_interface ())\n \t\t\t  && insn_issue_delay (insn) <= 3)\n \t\t\t || (targetm.sched.use_dfa_pipeline_interface\n-\t\t\t     && (*targetm.sched.use_dfa_pipeline_interface) ()\n+\t\t\t     && targetm.sched.use_dfa_pipeline_interface ()\n \t\t\t     && (recog_memoized (insn) < 0\n \t\t\t         || min_insn_conflict_delay (curr_state,\n \t\t\t\t\t\t\t     insn, insn) <= 3)))\n@@ -1803,7 +1803,7 @@ init_ready_list (struct ready_list *ready)\n \n \t\t  if (targetm.sched.adjust_priority)\n \t\t    INSN_PRIORITY (insn) =\n-\t\t      (*targetm.sched.adjust_priority) (insn, INSN_PRIORITY (insn));\n+\t\t      targetm.sched.adjust_priority (insn, INSN_PRIORITY (insn));\n \t\t}\n \t  }\n       }\n@@ -1887,12 +1887,12 @@ new_ready (rtx next)\n \t  || (IS_SPECULATIVE_INSN (next)\n \t      && (0\n \t\t  || (targetm.sched.use_dfa_pipeline_interface\n-\t\t      && (*targetm.sched.use_dfa_pipeline_interface) ()\n+\t\t      && targetm.sched.use_dfa_pipeline_interface ()\n \t\t      && recog_memoized (next) >= 0\n \t\t      && min_insn_conflict_delay (curr_state, next,\n \t\t\t\t\t\t  next) > 3)\n \t\t  || ((!targetm.sched.use_dfa_pipeline_interface\n-\t\t       || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t       || !targetm.sched.use_dfa_pipeline_interface ())\n \t\t      && insn_issue_delay (next) > 3)\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || !is_exception_free (next, INSN_BB (next), target_bb)))))\n@@ -2293,7 +2293,7 @@ debug_dependencies (void)\n \t\t   BB_TO_BLOCK (bb), bb);\n \n \t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t      && targetm.sched.use_dfa_pipeline_interface ())\n \t    {\n \t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n \t\t       \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\",\n@@ -2333,7 +2333,7 @@ debug_dependencies (void)\n \t\t}\n \n \t      if (targetm.sched.use_dfa_pipeline_interface\n-\t\t  && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t  && targetm.sched.use_dfa_pipeline_interface ())\n \t\t{\n \t\t  fprintf (sched_dump,\n \t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d   \","}, {"sha": "b7544d2ef8eaf8de71093e187f9786f8796da630", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -126,7 +126,7 @@ get_visual_tbl_length (void)\n   char *s;\n \n   if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+      && targetm.sched.use_dfa_pipeline_interface ())\n     {\n       visual_tbl_line_length = 1;\n       return 1; /* Can't return 0 because that will cause problems"}, {"sha": "0058589dc438158c1a929666d8c52112986c83f9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -132,7 +132,7 @@ avoid_constant_pool_reference (rtx x)\n   addr = XEXP (x, 0);\n \n   /* Call target hook to avoid the effects of -fpic etc....  */\n-  addr = (*targetm.delegitimize_address) (addr);\n+  addr = targetm.delegitimize_address (addr);\n \n   if (GET_CODE (addr) == LO_SUM)\n     addr = XEXP (addr, 1);"}, {"sha": "2b039db4d4bc6a2c48423b69b01cb9ffafb4802d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -394,7 +394,7 @@ layout_decl (tree decl, unsigned int known_align)\n \t     field.  */\n \t  if (integer_zerop (DECL_SIZE (decl))\n \t      && ! DECL_PACKED (decl)\n-\t      && ! (*targetm.ms_bitfield_layout_p) (DECL_FIELD_CONTEXT (decl)))\n+\t      && ! targetm.ms_bitfield_layout_p (DECL_FIELD_CONTEXT (decl)))\n \t    {\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n \t      if (PCC_BITFIELD_TYPE_MATTERS)"}, {"sha": "ed7771a8804d5d1f025411bc67e9ccb8eafa22b0", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -303,7 +303,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \n       /* Default to no attributes for type, but let target change that.  */\n       TYPE_ATTRIBUTES (t) = NULL_TREE;\n-      (*targetm.set_default_type_attributes) (t);\n+      targetm.set_default_type_attributes (t);\n \n       /* We have not yet computed the alias set for this type.  */\n       TYPE_ALIAS_SET (t) = -1;\n@@ -5131,7 +5131,7 @@ build_common_tree_nodes_2 (int short_double)\n   layout_type (complex_long_double_type_node);\n \n   {\n-    tree t = (*targetm.build_builtin_va_list) ();\n+    tree t = targetm.build_builtin_va_list ();\n \n     /* Many back-ends define record types without setting TYPE_NAME.\n        If we copied the record type here, we'd keep the original"}, {"sha": "6256421455b3a2fe8d3f07ded7ba0e0d9dab7dfc", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -348,7 +348,7 @@ named_section_flags (const char *name, unsigned int flags)\n       if (! set_named_section_flags (name, flags))\n \tabort ();\n \n-      (*targetm.asm_out.named_section) (name, flags);\n+      targetm.asm_out.named_section (name, flags);\n \n       if (flags & SECTION_FORGET)\n \tin_section = no_section;\n@@ -402,7 +402,7 @@ resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n       && targetm.have_named_sections\n       && (flag_function_or_data_sections\n \t  || DECL_ONE_ONLY (decl)))\n-    (*targetm.asm_out.unique_section) (decl, reloc);\n+    targetm.asm_out.unique_section (decl, reloc);\n }\n \n #ifdef BSS_SECTION_ASM_OP\n@@ -432,7 +432,7 @@ asm_output_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n \t\tunsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n \t\tunsigned HOST_WIDE_INT rounded)\n {\n-  (*targetm.asm_out.globalize_label) (file, name);\n+  targetm.asm_out.globalize_label (file, name);\n   bss_section ();\n #ifdef ASM_DECLARE_OBJECT_NAME\n   last_assemble_variable_decl = decl;\n@@ -499,7 +499,7 @@ variable_section (tree decl, int reloc)\n   if (IN_NAMED_SECTION (decl))\n     named_section (decl, NULL, reloc);\n   else\n-    (*targetm.asm_out.select_section) (decl, reloc, DECL_ALIGN (decl));\n+    targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n }\n \n /* Tell assembler to switch to the section for string merging.  */\n@@ -1610,7 +1610,7 @@ assemble_external_libcall (rtx fun)\n   if (! SYMBOL_REF_USED (fun))\n     {\n       SYMBOL_REF_USED (fun) = 1;\n-      (*targetm.asm_out.external_libcall) (fun);\n+      targetm.asm_out.external_libcall (fun);\n     }\n }\n \n@@ -1741,7 +1741,7 @@ assemble_trampoline_template (void)\n       ASM_OUTPUT_ALIGN (asm_out_file, align);\n     }\n \n-  (*targetm.asm_out.internal_label) (asm_out_file, \"LTRAMP\", 0);\n+  targetm.asm_out.internal_label (asm_out_file, \"LTRAMP\", 0);\n   TRAMPOLINE_TEMPLATE (asm_out_file);\n \n   /* Record the rtl to refer to it.  */\n@@ -1833,7 +1833,7 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n   aligned_p = (align >= MIN (size * BITS_PER_UNIT, BIGGEST_ALIGNMENT));\n \n   /* See if the target hook can handle this kind of object.  */\n-  if ((*targetm.asm_out.integer) (x, size, aligned_p))\n+  if (targetm.asm_out.integer (x, size, aligned_p))\n     return true;\n \n   /* If the object is a multi-byte one, try splitting it up.  Split\n@@ -2371,7 +2371,7 @@ build_constant_desc (tree exp)\n      information.  This call might invalidate our local variable\n      SYMBOL; we can't use it afterward.  */\n \n-  (*targetm.encode_section_info) (exp, rtl, true);\n+  targetm.encode_section_info (exp, rtl, true);\n \n   desc->rtl = rtl;\n \n@@ -2474,7 +2474,7 @@ output_constant_def_contents (rtx symbol)\n   if (IN_NAMED_SECTION (exp))\n     named_section (exp, NULL, reloc);\n   else\n-    (*targetm.asm_out.select_section) (exp, reloc, align);\n+    targetm.asm_out.select_section (exp, reloc, align);\n \n   if (align > BITS_PER_UNIT)\n     {\n@@ -2723,7 +2723,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   void **slot;\n \n   /* If we're not allowed to drop X into the constant pool, don't.  */\n-  if ((*targetm.cannot_force_const_mem) (x))\n+  if (targetm.cannot_force_const_mem (x))\n     return NULL_RTX;\n \n   /* Lookup the value in the hashtable.  */\n@@ -2964,7 +2964,7 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n     }\n \n   /* First switch to correct section.  */\n-  (*targetm.asm_out.select_rtx_section) (desc->mode, x, desc->align);\n+  targetm.asm_out.select_rtx_section (desc->mode, x, desc->align);\n \n #ifdef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n   ASM_OUTPUT_SPECIAL_POOL_ENTRY (asm_out_file, x, desc->mode,\n@@ -2974,7 +2974,7 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n   assemble_align (desc->align);\n \n   /* Output the label.  */\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"LC\", desc->labelno);\n+  targetm.asm_out.internal_label (asm_out_file, \"LC\", desc->labelno);\n \n   /* Output the data.  */\n   output_constant_pool_2 (desc->mode, x, desc->align);\n@@ -4109,7 +4109,7 @@ globalize_decl (tree decl)\n     ASM_MAKE_LABEL_LINKONCE (asm_out_file, name);\n #endif\n \n-  (*targetm.asm_out.globalize_label) (asm_out_file, name);\n+  targetm.asm_out.globalize_label (asm_out_file, name);\n }\n \n /* Emit an assembler directive to make the symbol for DECL an alias to\n@@ -4283,7 +4283,7 @@ decl_tls_model (tree decl)\n       return kind;\n     }\n \n-  is_local = (*targetm.binds_local_p) (decl);\n+  is_local = targetm.binds_local_p (decl);\n   if (!flag_pic)\n     {\n       if (is_local)\n@@ -4586,7 +4586,7 @@ categorize_decl_for_section (tree decl, int reloc, int shlib)\n     }\n \n   /* If the target uses small data sections, select it.  */\n-  else if ((*targetm.in_small_data_p) (decl))\n+  else if (targetm.in_small_data_p (decl))\n     {\n       if (ret == SECCAT_BSS)\n \tret = SECCAT_SBSS;\n@@ -4828,9 +4828,9 @@ default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n   flags = 0;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     flags |= SYMBOL_FLAG_FUNCTION;\n-  if ((*targetm.binds_local_p) (decl))\n+  if (targetm.binds_local_p (decl))\n     flags |= SYMBOL_FLAG_LOCAL;\n-  if ((*targetm.in_small_data_p) (decl))\n+  if (targetm.in_small_data_p (decl))\n     flags |= SYMBOL_FLAG_SMALL;\n   if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n     flags |= decl_tls_model (decl) << SYMBOL_FLAG_TLS_SHIFT;"}, {"sha": "64562518e9d8f2435ad2423f07184bc0292c6d50", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd9b17875e5e720108ed599b262ad9464576956/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=5fd9b17875e5e720108ed599b262ad9464576956", "patch": "@@ -1323,7 +1323,7 @@ vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)\n     (*dwarf2_debug_hooks.begin_block) (line, blocknum);\n \n   if (debug_info_level > DINFO_LEVEL_TERSE)\n-    (*targetm.asm_out.internal_label) (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);\n+    targetm.asm_out.internal_label (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);\n }\n \n /* Output a marker (i.e. a label) for the end of the generated code for a\n@@ -1336,7 +1336,7 @@ vmsdbgout_end_block (register unsigned line, register unsigned blocknum)\n     (*dwarf2_debug_hooks.end_block) (line, blocknum);\n \n   if (debug_info_level > DINFO_LEVEL_TERSE)\n-    (*targetm.asm_out.internal_label) (asm_out_file, BLOCK_END_LABEL, blocknum);\n+    targetm.asm_out.internal_label (asm_out_file, BLOCK_END_LABEL, blocknum);\n }\n \n /* Not implemented in VMS Debug.  */\n@@ -1516,8 +1516,8 @@ vmsdbgout_source_line (register unsigned line, register const char *filename)\n     {\n       dst_line_info_ref line_info;\n \n-      (*targetm.asm_out.internal_label) (asm_out_file, LINE_CODE_LABEL,\n-\t\t\t\t line_info_table_in_use);\n+      targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL,\n+\t\t\t\t      line_info_table_in_use);\n \n       /* Expand the line info table if necessary.  */\n       if (line_info_table_in_use == line_info_table_allocated)\n@@ -1673,7 +1673,7 @@ vmsdbgout_finish (const char *main_input_filename ATTRIBUTE_UNUSED)\n \n   /* Output a terminator label for the .text section.  */\n   text_section ();\n-  (*targetm.asm_out.internal_label) (asm_out_file, TEXT_END_LABEL, 0);\n+  targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);\n \n   /* Output debugging information.\n      Warning! Do not change the name of the .vmsdebug section without"}]}