{"sha": "a05a89fa702b1614c871153f5c067dfc08e457b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1YTg5ZmE3MDJiMTYxNGM4NzExNTNmNWMwNjdkZmMwOGU0NTdiMA==", "commit": {"author": {"name": "Cong Hou", "email": "congh@google.com", "date": "2013-11-07T19:29:45Z"}, "committer": {"name": "Cong Hou", "email": "congh@gcc.gnu.org", "date": "2013-11-07T19:29:45Z"}, "message": "re PR tree-optimization/56764 (vect_prune_runtime_alias_test_list not smart enough)\n\n2013-11-07  Cong Hou  <congh@google.com>\n\n\tPR tree-optimization/56764\n\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n  \tCombine alias checks if it is possible to amortize the runtime\n  \toverhead.  Return the number of alias checks after merging.\n  \t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):\n    \tUse the function vect_create_cond_for_alias_checks () to check\n    \tthe number of alias checks.\n\n2013-11-07  Cong Hou  <congh@google.com>\n\n    \t* gcc.dg/vect/vect-alias-check.c: New.\n\nFrom-SVN: r204538", "tree": {"sha": "ce9a066296eee210133c1bff32f548ab6ed8aa4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce9a066296eee210133c1bff32f548ab6ed8aa4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a05a89fa702b1614c871153f5c067dfc08e457b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05a89fa702b1614c871153f5c067dfc08e457b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05a89fa702b1614c871153f5c067dfc08e457b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05a89fa702b1614c871153f5c067dfc08e457b0/comments", "author": null, "committer": null, "parents": [{"sha": "6d0b710573662ba451996d0a7d9bf0174229b8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0b710573662ba451996d0a7d9bf0174229b8c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0b710573662ba451996d0a7d9bf0174229b8c3"}], "stats": {"total": 562, "additions": 386, "deletions": 176}, "files": [{"sha": "5808ee5ce96c52e7a2cace7e6df5c911cdc5989d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -1,3 +1,13 @@\n+2013-11-07  Cong Hou  <congh@google.com>\n+\n+\tPR tree-optimization/56764\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n+\tCombine alias checks if it is possible to amortize the runtime\n+\toverhead.  Return the number of alias checks after merging.\n+\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list):\n+\tUse the function vect_create_cond_for_alias_checks () to check\n+\tthe number of alias checks.\n+\n 2013-11-07  Jeff Law  <law@redhat.com>\n \n \t* varpool.c (ctor_for_folding): Fix typo in comment."}, {"sha": "6cb4b9822ef3248b20462e422055495eaad85d51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -1,3 +1,7 @@\n+2013-11-07  Cong Hou  <congh@google.com>\n+\n+\t* gcc.dg/vect/vect-alias-check.c: New.\n+\n 2013-11-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/tree-ssa/loop-39.c: New test."}, {"sha": "64a4e0ce05c50930eb584efa0f1f9cdbdd071e8a", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check.c?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize --param=vect-max-version-for-alias-checks=2 -fdump-tree-vect-details\" } */\n+\n+/* A test case showing three potential alias checks between\n+   a[i] and b[i], b[i+7], b[i+14]. With alias checks merging\n+   enabled, those tree checks can be merged into one, and the\n+   loop will be vectorized with vect-max-version-for-alias-checks=2.  */\n+\n+void foo (int *a, int *b)\n+{\n+  int i;\n+  for (i = 0; i < 1000; ++i)\n+    a[i] = b[i] + b[i+7] + b[i+14];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b2a31b1de4a32282bdbd4cc180ac10788e6e6e44", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 289, "deletions": 75, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -135,41 +135,6 @@ vect_get_smallest_scalar_type (gimple stmt, HOST_WIDE_INT *lhs_size_unit,\n }\n \n \n-/* Check if data references pointed by DR_I and DR_J are same or\n-   belong to same interleaving group.  Return FALSE if drs are\n-   different, otherwise return TRUE.  */\n-\n-static bool\n-vect_same_range_drs (data_reference_p dr_i, data_reference_p dr_j)\n-{\n-  gimple stmt_i = DR_STMT (dr_i);\n-  gimple stmt_j = DR_STMT (dr_j);\n-\n-  if (operand_equal_p (DR_REF (dr_i), DR_REF (dr_j), 0)\n-      || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_i))\n-\t    && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_j))\n-\t    && (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_i))\n-\t\t== GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_j)))))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* If address ranges represented by DDR_I and DDR_J are equal,\n-   return TRUE, otherwise return FALSE.  */\n-\n-static bool\n-vect_vfa_range_equal (ddr_p ddr_i, ddr_p ddr_j)\n-{\n-  if ((vect_same_range_drs (DDR_A (ddr_i), DDR_A (ddr_j))\n-       && vect_same_range_drs (DDR_B (ddr_i), DDR_B (ddr_j)))\n-      || (vect_same_range_drs (DDR_A (ddr_i), DDR_B (ddr_j))\n-\t  && vect_same_range_drs (DDR_B (ddr_i), DDR_A (ddr_j))))\n-    return true;\n-  else\n-    return false;\n-}\n-\n /* Insert DDR into LOOP_VINFO list of ddrs that may alias and need to be\n    tested at run-time.  Return TRUE if DDR was successfully inserted.\n    Return false if versioning is not supported.  */\n@@ -2654,69 +2619,320 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   return true;\n }\n \n+\n+/* Operator == between two dr_addr_with_seg_len objects.\n+\n+   This equality operator is used to make sure two data refs\n+   are the same one so that we will consider to combine the\n+   aliasing checks of those two pairs of data dependent data\n+   refs.  */\n+\n+static bool\n+operator == (const dr_addr_with_seg_len& d1,\n+\t     const dr_addr_with_seg_len& d2)\n+{\n+  return operand_equal_p (d1.basic_addr, d2.basic_addr, 0)\n+\t && compare_tree (d1.offset, d2.offset) == 0\n+\t && compare_tree (d1.seg_len, d2.seg_len) == 0;\n+}\n+\n+/* Function comp_dr_addr_with_seg_len_pair.\n+\n+   Comparison function for sorting objects of dr_addr_with_seg_len_pair_t\n+   so that we can combine aliasing checks in one scan.  */\n+\n+static int\n+comp_dr_addr_with_seg_len_pair (const void *p1_, const void *p2_)\n+{\n+  const dr_addr_with_seg_len_pair_t* p1 =\n+    (const dr_addr_with_seg_len_pair_t *) p1_;\n+  const dr_addr_with_seg_len_pair_t* p2 =\n+    (const dr_addr_with_seg_len_pair_t *) p2_;\n+\n+  const dr_addr_with_seg_len &p11 = p1->first,\n+\t\t\t     &p12 = p1->second,\n+\t\t\t     &p21 = p2->first,\n+\t\t\t     &p22 = p2->second;\n+\n+  int comp_res = compare_tree (p11.basic_addr, p21.basic_addr);\n+  if (comp_res != 0)\n+    return comp_res;\n+\n+  comp_res = compare_tree (p12.basic_addr, p22.basic_addr);\n+  if (comp_res != 0)\n+    return comp_res;\n+\n+  if (TREE_CODE (p11.offset) != INTEGER_CST\n+      || TREE_CODE (p21.offset) != INTEGER_CST)\n+    {\n+      comp_res = compare_tree (p11.offset, p21.offset);\n+      if (comp_res != 0)\n+\treturn comp_res;\n+    }\n+  if (tree_int_cst_compare (p11.offset, p21.offset) < 0)\n+    return -1;\n+  if (tree_int_cst_compare (p11.offset, p21.offset) > 0)\n+    return 1;\n+  if (TREE_CODE (p12.offset) != INTEGER_CST\n+      || TREE_CODE (p22.offset) != INTEGER_CST)\n+    {\n+      comp_res = compare_tree (p12.offset, p22.offset);\n+      if (comp_res != 0)\n+\treturn comp_res;\n+    }\n+  if (tree_int_cst_compare (p12.offset, p22.offset) < 0)\n+    return -1;\n+  if (tree_int_cst_compare (p12.offset, p22.offset) > 0)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+template <class T> static void\n+swap (T& a, T& b)\n+{\n+  T c (a);\n+  a = b;\n+  b = c;\n+}\n+\n+/* Function vect_vfa_segment_size.\n+\n+   Create an expression that computes the size of segment\n+   that will be accessed for a data reference.  The functions takes into\n+   account that realignment loads may access one more vector.\n+\n+   Input:\n+     DR: The data reference.\n+     LENGTH_FACTOR: segment length to consider.\n+\n+   Return an expression whose value is the size of segment which will be\n+   accessed by DR.  */\n+\n+static tree\n+vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n+{\n+  tree segment_length;\n+\n+  if (integer_zerop (DR_STEP (dr)))\n+    segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n+  else\n+    segment_length = size_binop (MULT_EXPR,\n+                                 fold_convert (sizetype, DR_STEP (dr)),\n+                                 fold_convert (sizetype, length_factor));\n+\n+  if (vect_supportable_dr_alignment (dr, false)\n+        == dr_explicit_realign_optimized)\n+    {\n+      tree vector_size = TYPE_SIZE_UNIT\n+\t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));\n+\n+      segment_length = size_binop (PLUS_EXPR, segment_length, vector_size);\n+    }\n+  return segment_length;\n+}\n+\n /* Function vect_prune_runtime_alias_test_list.\n \n    Prune a list of ddrs to be tested at run-time by versioning for alias.\n+   Merge several alias checks into one if possible.\n    Return FALSE if resulting list of ddrs is longer then allowed by\n    PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS, otherwise return TRUE.  */\n \n bool\n vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n {\n-  vec<ddr_p>  ddrs =\n+  vec<ddr_p> may_alias_ddrs =\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n-  unsigned i, j;\n+  vec<dr_addr_with_seg_len_pair_t>& comp_alias_ddrs =\n+    LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n+  int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n+\n+  ddr_p ddr;\n+  unsigned int i;\n+  tree length_factor;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_prune_runtime_alias_test_list ===\\n\");\n \n-  for (i = 0; i < ddrs.length (); )\n+  if (may_alias_ddrs.is_empty ())\n+    return true;\n+\n+  /* Basically, for each pair of dependent data refs store_ptr_0\n+     and load_ptr_0, we create an expression:\n+\n+     ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n+     || (load_ptr_0 + load_segment_length_0) <= store_ptr_0))\n+\n+     for aliasing checks.  However, in some cases we can decrease\n+     the number of checks by combining two checks into one.  For\n+     example, suppose we have another pair of data refs store_ptr_0\n+     and load_ptr_1, and if the following condition is satisfied:\n+\n+     load_ptr_0 < load_ptr_1  &&\n+     load_ptr_1 - load_ptr_0 - load_segment_length_0 < store_segment_length_0\n+\n+     (this condition means, in each iteration of vectorized loop,\n+     the accessed memory of store_ptr_0 cannot be between the memory\n+     of load_ptr_0 and load_ptr_1.)\n+\n+     we then can use only the following expression to finish the\n+     alising checks between store_ptr_0 & load_ptr_0 and\n+     store_ptr_0 & load_ptr_1:\n+\n+     ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n+     || (load_ptr_1 + load_segment_length_1 <= store_ptr_0))\n+\n+     Note that we only consider that load_ptr_0 and load_ptr_1 have the\n+     same basic address.  */\n+\n+  comp_alias_ddrs.create (may_alias_ddrs.length ());\n+\n+  /* First, we collect all data ref pairs for aliasing checks.  */\n+  FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n     {\n-      bool found;\n-      ddr_p ddr_i;\n+      struct data_reference *dr_a, *dr_b;\n+      gimple dr_group_first_a, dr_group_first_b;\n+      tree segment_length_a, segment_length_b;\n+      gimple stmt_a, stmt_b;\n+\n+      dr_a = DDR_A (ddr);\n+      stmt_a = DR_STMT (DDR_A (ddr));\n+      dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n+      if (dr_group_first_a)\n+\t{\n+\t  stmt_a = dr_group_first_a;\n+\t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n+\t}\n \n-      ddr_i = ddrs[i];\n-      found = false;\n+      dr_b = DDR_B (ddr);\n+      stmt_b = DR_STMT (DDR_B (ddr));\n+      dr_group_first_b = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n+      if (dr_group_first_b)\n+\t{\n+\t  stmt_b = dr_group_first_b;\n+\t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n+\t}\n \n-      for (j = 0; j < i; j++)\n-        {\n-\t  ddr_p ddr_j = ddrs[j];\n+      if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))\n+\tlength_factor = scalar_loop_iters;\n+      else\n+\tlength_factor = size_int (vect_factor);\n+      segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n+      segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n+\n+      dr_addr_with_seg_len_pair_t dr_with_seg_len_pair\n+\t  (dr_addr_with_seg_len\n+\t       (dr_a, DR_BASE_ADDRESS (dr_a),\n+\t\tsize_binop (PLUS_EXPR, DR_OFFSET (dr_a), DR_INIT (dr_a)),\n+\t\tsegment_length_a),\n+\t   dr_addr_with_seg_len\n+\t       (dr_b, DR_BASE_ADDRESS (dr_b),\n+\t\tsize_binop (PLUS_EXPR, DR_OFFSET (dr_b), DR_INIT (dr_b)),\n+\t\tsegment_length_b));\n+\n+      if (compare_tree (dr_with_seg_len_pair.first.basic_addr,\n+\t\t\tdr_with_seg_len_pair.second.basic_addr) > 0)\n+\tswap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n+\n+      comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n+    }\n \n-\t  if (vect_vfa_range_equal (ddr_i, ddr_j))\n+  /* Second, we sort the collected data ref pairs so that we can scan\n+     them once to combine all possible aliasing checks.  */\n+  comp_alias_ddrs.qsort (comp_dr_addr_with_seg_len_pair);\n+\n+  /* Third, we scan the sorted dr pairs and check if we can combine\n+     alias checks of two neighbouring dr pairs.  */\n+  for (size_t i = 1; i < comp_alias_ddrs.length (); ++i)\n+    {\n+      /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n+      dr_addr_with_seg_len *dr_a1 = &comp_alias_ddrs[i-1].first,\n+\t\t\t   *dr_b1 = &comp_alias_ddrs[i-1].second,\n+\t\t\t   *dr_a2 = &comp_alias_ddrs[i].first,\n+\t\t\t   *dr_b2 = &comp_alias_ddrs[i].second;\n+\n+      /* Remove duplicate data ref pairs.  */\n+      if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n+\t{\n+\t  if (dump_enabled_p ())\n \t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t                   \"found equal ranges \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t                     DR_REF (DDR_A (ddr_i)));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t                     DR_REF (DDR_B (ddr_i)));\n-\t\t  dump_printf (MSG_NOTE,  \" and \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t                     DR_REF (DDR_A (ddr_j)));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t                     DR_REF (DDR_B (ddr_j)));\n-\t\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      found = true;\n-\t      break;\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"found equal ranges \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t DR_REF (dr_a1->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t DR_REF (dr_b1->dr));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t DR_REF (dr_a2->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t\t\t DR_REF (dr_b2->dr));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n+\n+\t  comp_alias_ddrs.ordered_remove (i--);\n+\t  continue;\n \t}\n \n-      if (found)\n-      {\n-\tddrs.ordered_remove (i);\n-\tcontinue;\n-      }\n-      i++;\n+      if (*dr_a1 == *dr_a2 || *dr_b1 == *dr_b2)\n+\t{\n+\t  /* We consider the case that DR_B1 and DR_B2 are same memrefs,\n+\t     and DR_A1 and DR_A2 are two consecutive memrefs.  */\n+\t  if (*dr_a1 == *dr_a2)\n+\t    {\n+\t      swap (dr_a1, dr_b1);\n+\t      swap (dr_a2, dr_b2);\n+\t    }\n+\n+\t  if (!operand_equal_p (dr_a1->basic_addr, dr_a2->basic_addr, 0)\n+\t      || !host_integerp (dr_a1->offset, 0)\n+\t      || !host_integerp (dr_a2->offset, 0))\n+\t    continue;\n+\n+\t  HOST_WIDE_INT diff = TREE_INT_CST_LOW (dr_a2->offset) -\n+\t\t\t       TREE_INT_CST_LOW (dr_a1->offset);\n+\n+\n+\t  /* Now we check if the following condition is satisfied:\n+\n+\t     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n+\n+\t     where DIFF = DR_A2->OFFSET - DR_A1->OFFSET.  However,\n+\t     SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n+\t     have to make a best estimation.  We can get the minimum value\n+\t     of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n+\t     then either of the following two conditions can guarantee the\n+\t     one above:\n+\n+\t     1: DIFF <= MIN_SEG_LEN_B\n+\t     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B\n+\n+\t     */\n+\n+\t  HOST_WIDE_INT\n+\t  min_seg_len_b = (TREE_CODE (dr_b1->seg_len) == INTEGER_CST) ?\n+\t\t\t      TREE_INT_CST_LOW (dr_b1->seg_len) :\n+\t\t\t      vect_factor;\n+\n+\t  if (diff <= min_seg_len_b\n+\t      || (TREE_CODE (dr_a1->seg_len) == INTEGER_CST\n+\t\t  && diff - (HOST_WIDE_INT) TREE_INT_CST_LOW (dr_a1->seg_len) <\n+\t\t     min_seg_len_b))\n+\t    {\n+\t      dr_a1->seg_len = size_binop (PLUS_EXPR,\n+\t\t\t\t\t   dr_a2->seg_len, size_int (diff));\n+\t      comp_alias_ddrs.ordered_remove (i--);\n+\t    }\n+\t}\n     }\n \n-  if (ddrs.length () >\n-       (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n+  if ((int) comp_alias_ddrs.length () >\n+      PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n     {\n       if (dump_enabled_p ())\n \t{\n@@ -2725,8 +2941,6 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t                   \"generated checks exceeded.\\n\");\n \t}\n \n-      LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).truncate (0);\n-\n       return false;\n     }\n "}, {"sha": "fb34664960e00f8e5d9f31a31cf83291a92021bc", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 30, "deletions": 101, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -2219,44 +2219,6 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n     *cond_expr = part_cond_expr;\n }\n \n-\n-/* Function vect_vfa_segment_size.\n-\n-   Create an expression that computes the size of segment\n-   that will be accessed for a data reference.  The functions takes into\n-   account that realignment loads may access one more vector.\n-\n-   Input:\n-     DR: The data reference.\n-     LENGTH_FACTOR: segment length to consider.\n-\n-   Return an expression whose value is the size of segment which will be\n-   accessed by DR.  */\n-\n-static tree\n-vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n-{\n-  tree segment_length;\n-\n-  if (integer_zerop (DR_STEP (dr)))\n-    segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n-  else\n-    segment_length = size_binop (MULT_EXPR,\n-                                 fold_convert (sizetype, DR_STEP (dr)),\n-                                 fold_convert (sizetype, length_factor));\n-\n-  if (vect_supportable_dr_alignment (dr, false)\n-        == dr_explicit_realign_optimized)\n-    {\n-      tree vector_size = TYPE_SIZE_UNIT\n-\t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));\n-\n-      segment_length = size_binop (PLUS_EXPR, segment_length, vector_size);\n-    }\n-  return segment_length;\n-}\n-\n-\n /* Function vect_create_cond_for_alias_checks.\n \n    Create a conditional expression that represents the run-time checks for\n@@ -2265,28 +2227,24 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n \n    Input:\n    COND_EXPR  - input conditional expression.  New conditions will be chained\n-                with logical AND operation.\n+                with logical AND operation.  If it is NULL, then the function\n+                is used to return the number of alias checks.\n    LOOP_VINFO - field LOOP_VINFO_MAY_ALIAS_STMTS contains the list of ddrs\n \t        to be checked.\n \n    Output:\n    COND_EXPR - conditional expression.\n \n-   The returned value is the conditional expression to be used in the if\n+   The returned COND_EXPR is the conditional expression to be used in the if\n    statement that controls which version of the loop gets executed at runtime.\n */\n \n-static void\n+void\n vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n {\n-  vec<ddr_p>  may_alias_ddrs =\n-    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n-  int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n-\n-  ddr_p ddr;\n-  unsigned int i;\n-  tree part_cond_expr, length_factor;\n+  vec<dr_addr_with_seg_len_pair_t> comp_alias_ddrs =\n+    LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n+  tree part_cond_expr;\n \n   /* Create expression\n      ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n@@ -2297,70 +2255,39 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n      ((store_ptr_n + store_segment_length_n) <= load_ptr_n)\n      || (load_ptr_n + load_segment_length_n) <= store_ptr_n))  */\n \n-  if (may_alias_ddrs.is_empty ())\n+  if (comp_alias_ddrs.is_empty ())\n     return;\n \n-  FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n+  for (size_t i = 0, s = comp_alias_ddrs.length (); i < s; ++i)\n     {\n-      struct data_reference *dr_a, *dr_b;\n-      gimple dr_group_first_a, dr_group_first_b;\n-      tree addr_base_a, addr_base_b;\n-      tree segment_length_a, segment_length_b;\n-      gimple stmt_a, stmt_b;\n-      tree seg_a_min, seg_a_max, seg_b_min, seg_b_max;\n-\n-      dr_a = DDR_A (ddr);\n-      stmt_a = DR_STMT (DDR_A (ddr));\n-      dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n-      if (dr_group_first_a)\n-        {\n-\t  stmt_a = dr_group_first_a;\n-\t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n-\t}\n-\n-      dr_b = DDR_B (ddr);\n-      stmt_b = DR_STMT (DDR_B (ddr));\n-      dr_group_first_b = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n-      if (dr_group_first_b)\n-        {\n-\t  stmt_b = dr_group_first_b;\n-\t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n-\t}\n+      const dr_addr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n+      const dr_addr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n+      tree segment_length_a = dr_a.seg_len;\n+      tree segment_length_b = dr_b.seg_len;\n \n-      addr_base_a\n-\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_a),\n-\t\t\t\t   size_binop (PLUS_EXPR, DR_OFFSET (dr_a),\n-\t\t\t\t\t       DR_INIT (dr_a)));\n-      addr_base_b\n-\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_b),\n-\t\t\t\t   size_binop (PLUS_EXPR, DR_OFFSET (dr_b),\n-\t\t\t\t\t       DR_INIT (dr_b)));\n-\n-      if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))\n-\tlength_factor = scalar_loop_iters;\n-      else\n-\tlength_factor = size_int (vect_factor);\n-      segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n-      segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n+      tree addr_base_a\n+\t= fold_build_pointer_plus (dr_a.basic_addr, dr_a.offset);\n+      tree addr_base_b\n+\t= fold_build_pointer_plus (dr_b.basic_addr, dr_b.offset);\n \n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"create runtime check for data references \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));\n+\t\t\t   \"create runtime check for data references \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a.dr));\n \t  dump_printf (MSG_NOTE, \" and \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));\n-          dump_printf (MSG_NOTE, \"\\n\");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b.dr));\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n-      seg_a_min = addr_base_a;\n-      seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n-      if (tree_int_cst_compare (DR_STEP (dr_a), size_zero_node) < 0)\n+      tree seg_a_min = addr_base_a;\n+      tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n+      if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n \tseg_a_min = seg_a_max, seg_a_max = addr_base_a;\n \n-      seg_b_min = addr_base_b;\n-      seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n-      if (tree_int_cst_compare (DR_STEP (dr_b), size_zero_node) < 0)\n+      tree seg_b_min = addr_base_b;\n+      tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n+      if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n \tseg_b_min = seg_b_max, seg_b_max = addr_base_b;\n \n       part_cond_expr =\n@@ -2378,7 +2305,9 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"created %u versioning for alias checks.\\n\",\n-\t\t     may_alias_ddrs.length ());\n+\t\t     comp_alias_ddrs.length ());\n+\n+  comp_alias_ddrs.release ();\n }\n \n "}, {"sha": "bbd50e1d993bd7d7d4bea76e088858852d6709d7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05a89fa702b1614c871153f5c067dfc08e457b0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a05a89fa702b1614c871153f5c067dfc08e457b0", "patch": "@@ -175,6 +175,36 @@ typedef struct _slp_oprnd_info\n \n \n \n+/* This struct is used to store the information of a data reference,\n+   including the data ref itself, its basic address, the access offset\n+   and the segment length for aliasing checks.  This is used to generate\n+   alias checks.  */\n+\n+struct dr_addr_with_seg_len\n+{\n+  dr_addr_with_seg_len (data_reference* d, tree addr, tree off, tree len)\n+    : dr (d), basic_addr (addr), offset (off), seg_len (len) {}\n+\n+  data_reference *dr;\n+  tree basic_addr;\n+  tree offset;\n+  tree seg_len;\n+};\n+\n+/* This struct contains two dr_addr_with_seg_len objects with aliasing data\n+   refs.  Two comparisons are generated from them.  */\n+\n+struct dr_addr_with_seg_len_pair_t\n+{\n+  dr_addr_with_seg_len_pair_t (const dr_addr_with_seg_len& d1,\n+\t\t\t       const dr_addr_with_seg_len& d2)\n+    : first (d1), second (d2) {}\n+\n+  dr_addr_with_seg_len first;\n+  dr_addr_with_seg_len second;\n+};\n+\n+\n typedef struct _vect_peel_info\n {\n   int npeel;\n@@ -274,6 +304,10 @@ typedef struct _loop_vec_info {\n      for a run-time aliasing check.  */\n   vec<ddr_p> may_alias_ddrs;\n \n+  /* Data Dependence Relations defining address ranges together with segment\n+     lengths from which the run-time aliasing check is built.  */\n+  vec<dr_addr_with_seg_len_pair_t> comp_alias_ddrs;\n+\n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */\n   vec<gimple> may_misalign_stmts;\n@@ -336,6 +370,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_MAY_MISALIGN_STMTS(L)   (L)->may_misalign_stmts\n #define LOOP_VINFO_LOC(L)                  (L)->loop_line_number\n #define LOOP_VINFO_MAY_ALIAS_DDRS(L)       (L)->may_alias_ddrs\n+#define LOOP_VINFO_COMP_ALIAS_DDRS(L)      (L)->comp_alias_ddrs\n #define LOOP_VINFO_GROUPED_STORES(L)       (L)->grouped_stores\n #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor"}]}