{"sha": "4039fb351c2611af9db36bf80fa8ba868525768a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzOWZiMzUxYzI2MTFhZjlkYjM2YmY4MGZhOGJhODY4NTI1NzY4YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-12-06T22:39:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-12-06T22:39:58Z"}, "message": "decl.c (make_packable_type): Revert last change.\n\n\t* decl.c (make_packable_type): Revert last change.\n\t(gnat_to_gnu_field): Avoid setting size and position multiple times.\n\t* utils.c (finish_record_type): Retrieve the real name of the type.\n\nFrom-SVN: r130665", "tree": {"sha": "1571923bdf04a948d01ee9887380c0f17bb6f2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1571923bdf04a948d01ee9887380c0f17bb6f2a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4039fb351c2611af9db36bf80fa8ba868525768a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4039fb351c2611af9db36bf80fa8ba868525768a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4039fb351c2611af9db36bf80fa8ba868525768a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4039fb351c2611af9db36bf80fa8ba868525768a/comments", "author": null, "committer": null, "parents": [{"sha": "4c42b3d84fb4bd1539147b3aa1834d935818b869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c42b3d84fb4bd1539147b3aa1834d935818b869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c42b3d84fb4bd1539147b3aa1834d935818b869"}], "stats": {"total": 72, "additions": 39, "deletions": 33}, "files": [{"sha": "6bd8835478706989dddb1c395d25cb6d7d84445d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4039fb351c2611af9db36bf80fa8ba868525768a", "patch": "@@ -1,3 +1,9 @@\n+2007-12-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (make_packable_type): Revert last change.\n+\t(gnat_to_gnu_field): Avoid setting size and position multiple times.\n+\t* utils.c (finish_record_type): Retrieve the real name of the type.\n+\n 2007-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* trans.c (lvalue_required_p): Take base node directly instead\n@@ -80,7 +86,7 @@\n \n 2007-11-25  Richard Guenther  <rguenther@suse.de>\n \n-\tutils.c (gnat_pushlevel): Use BLOCK_CHAIN.\n+\t* utils.c (gnat_pushlevel): Use BLOCK_CHAIN.\n \t(gnat_poplevel): Likewise.\n \n 2007-11-25  Eric Botcazou  <ebotcazou@adacore.com>"}, {"sha": "7c18a50739b95893d174ecf29ddb0f2aade3049f", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=4039fb351c2611af9db36bf80fa8ba868525768a", "patch": "@@ -5198,19 +5198,14 @@ static tree\n make_packable_type (tree type)\n {\n   tree new_type = make_node (TREE_CODE (type));\n-  tree name = TYPE_NAME (type);\n   tree field_list = NULL_TREE;\n   tree old_field;\n \n-  if (name && TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-\n-  /* Copy the name and flags from the old type to that of the new and set\n-     the alignment to try for an integral type.  For QUAL_UNION_TYPE,\n-     also copy the size.  */\n-  TYPE_NAME (new_type) = name;\n-  TYPE_JUSTIFIED_MODULAR_P (new_type)\n-    = TYPE_JUSTIFIED_MODULAR_P (type);\n+  /* Copy the name and flags from the old type to that of the new.  Note\n+     that we rely on the pointer equality created here for TYPE_NAME at\n+     the end of gnat_to_gnu.  For QUAL_UNION_TYPE, also copy the size.  */\n+  TYPE_NAME (new_type) = TYPE_NAME (type);\n+  TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n \n   if (TREE_CODE (type) == RECORD_TYPE)\n@@ -5221,6 +5216,7 @@ make_packable_type (tree type)\n       TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n     }\n \n+  /* Set the alignment to try for an integral type.  */\n   TYPE_ALIGN (new_type) = ceil_alignment (tree_low_cst (TYPE_SIZE (type), 1));\n   TYPE_USER_ALIGN (new_type) = 1;\n \n@@ -5599,9 +5595,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n {\n   tree gnu_field_id = get_entity_name (gnat_field);\n   tree gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n-  tree gnu_pos = 0;\n-  tree gnu_size = 0;\n-  tree gnu_field;\n+  tree gnu_field, gnu_size, gnu_pos;\n   bool needs_strict_alignment\n     = (Is_Aliased (gnat_field) || Strict_Alignment (Etype (gnat_field))\n        || Treat_As_Volatile (gnat_field));\n@@ -5613,18 +5607,17 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   else\n     packed = adjust_packed (gnu_field_type, gnu_record_type, packed);\n \n-  /* For packed records, this is one of the few occasions on which we use\n-     the official RM size for discrete or fixed-point components, instead\n-     of the normal GNAT size stored in Esize. See description in Einfo:\n-     \"Handling of Type'Size Values\" for further details.  */\n-\n-  if (packed == 1)\n-    gnu_size = validate_size (RM_Size (Etype (gnat_field)), gnu_field_type,\n-\t\t\t      gnat_field, FIELD_DECL, false, true);\n-\n+  /* If a size is specified, use it.  Otherwise, if the record type is packed,\n+     use the official RM size.  See \"Handling of Type'Size Values\" in Einfo\n+     for further details.  */\n   if (Known_Static_Esize (gnat_field))\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n+  else if (packed == 1)\n+    gnu_size = validate_size (RM_Size (Etype (gnat_field)), gnu_field_type,\n+\t\t\t      gnat_field, FIELD_DECL, false, true);\n+  else\n+    gnu_size = NULL_TREE;\n \n   /* If we have a specified size that's smaller than that of the field type,\n      or a position is specified, and the field type is also a record that's\n@@ -5656,8 +5649,8 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       && compare_tree_int (TYPE_SIZE (gnu_field_type), BIGGEST_ALIGNMENT) <= 0\n       && (packed == 1\n \t  || (gnu_size\n-\t      && tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type)))\n-\t  || (Present (Component_Clause (gnat_field)) && gnu_size != 0)))\n+\t      && (tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type))\n+\t\t  || Present (Component_Clause (gnat_field))))))\n     {\n       /* See what the alternate type and size would be.  */\n       tree gnu_packable_type = make_packable_type (gnu_field_type);\n@@ -5689,7 +5682,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t{\n \t  gnu_field_type = gnu_packable_type;\n \n-\t  if (gnu_size == 0)\n+\t  if (!gnu_size)\n \t    gnu_size = rm_size (gnu_field_type);\n \t}\n     }\n@@ -5797,6 +5790,9 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       gnu_size = TYPE_SIZE (gnu_field_type);\n     }\n \n+  else\n+    gnu_pos = NULL_TREE;\n+\n   /* We need to make the size the maximum for the type if it is\n      self-referential and an unconstrained type.  In that case, we can't\n      pack the field since we can't make a copy to align it.  */\n@@ -5809,11 +5805,8 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       packed = 0;\n     }\n \n-  /* If no size is specified (or if there was an error), don't specify a\n-     position.  */\n-  if (!gnu_size)\n-    gnu_pos = NULL_TREE;\n-  else\n+  /* If a size is specified, adjust the field's type to it.  */\n+  if (gnu_size)\n     {\n       /* If the field's type is justified modular, we would need to remove\n \t the wrapper to (better) meet the layout requirements.  However we\n@@ -5834,6 +5827,10 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t\t\t       \"PAD\", false, definition, true);\n     }\n \n+  /* Otherwise (or if there was an error), don't specify a position.  */\n+  else\n+    gnu_pos = NULL_TREE;\n+\n   gcc_assert (TREE_CODE (gnu_field_type) != RECORD_TYPE\n \t      || !TYPE_CONTAINS_TEMPLATE_P (gnu_field_type));\n "}, {"sha": "33448fc9363f32683b1924a10b4610d432b10c1f", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039fb351c2611af9db36bf80fa8ba868525768a/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=4039fb351c2611af9db36bf80fa8ba868525768a", "patch": "@@ -747,16 +747,19 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n \t\t    bool do_not_finalize)\n {\n   enum tree_code code = TREE_CODE (record_type);\n+  tree name = TYPE_NAME (record_type);\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n   bool var_size = false;\n   bool had_size = TYPE_SIZE (record_type) != 0;\n   bool had_size_unit = TYPE_SIZE_UNIT (record_type) != 0;\n   tree field;\n \n+  if (name && TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+\n   TYPE_FIELDS (record_type) = fieldlist;\n-  TYPE_STUB_DECL (record_type)\n-    = build_decl (TYPE_DECL, TYPE_NAME (record_type), record_type);\n+  TYPE_STUB_DECL (record_type) = build_decl (TYPE_DECL, name, record_type);\n \n   /* We don't need both the typedef name and the record name output in\n      the debugging information, since they are the same.  */"}]}