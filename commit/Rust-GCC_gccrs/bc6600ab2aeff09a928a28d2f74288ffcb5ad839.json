{"sha": "bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM2NjAwYWIyYWVmZjA5YTkyOGEyOGQyZjc0Mjg4ZmZjYjVhZDgzOQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-03-28T15:18:59Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-03-28T15:18:59Z"}, "message": "string_intrinsics.c: #include <assert.h>\n\n2009-03-28  Daniel Kraft  <d@domob.eu>\n\n\t* intrinsics/string_intrinsics.c: #include <assert.h>\n\t* intrinsics/string_intrinsics_inc.c (string_trim): Use string_len_trim\n\tinstead of calculating the length directly.\n\t(string_len_trim): For KIND=1, speed search up.\n\n2009-03-28  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/trim_1.f90: New test.\n\nFrom-SVN: r145192", "tree": {"sha": "edcb71475fc72529d3a9569925700265df2ab20f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edcb71475fc72529d3a9569925700265df2ab20f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f1873a1cffee3fc59a1a0f479b58b8a82bc4e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1873a1cffee3fc59a1a0f479b58b8a82bc4e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1873a1cffee3fc59a1a0f479b58b8a82bc4e2c"}], "stats": {"total": 113, "additions": 101, "deletions": 12}, "files": [{"sha": "bbc57f7dd65dfeb71dfd77678163ace4a0935508", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "patch": "@@ -1,3 +1,7 @@\n+2009-03-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/trim_1.f90: New test.\n+\n 2009-03-28  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/Warray-bounds.c: Do not use redundant stores."}, {"sha": "ac1e1f2032dd9eceb067e27480e58201e3dc4c70", "filename": "gcc/testsuite/gfortran.dg/trim_1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_1.f90?ref=bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+\n+! Torture-test TRIM and LEN_TRIM for correctness.\n+\n+\n+! Given a total string length and a trimmed length, construct an\n+! appropriate string and check gfortran gets it right.\n+\n+SUBROUTINE check_trim (full_len, trimmed_len)\n+  IMPLICIT NONE\n+  INTEGER, INTENT(IN) :: full_len, trimmed_len\n+  CHARACTER(LEN=full_len) :: string\n+\n+  string = \"\"\n+  IF (trimmed_len > 0) THEN\n+    string(trimmed_len:trimmed_len) = \"x\"\n+  END IF\n+\n+  IF (LEN (string) /= full_len &\n+      .OR. LEN_TRIM (string) /= trimmed_len &\n+      .OR. LEN (TRIM (string)) /= trimmed_len &\n+      .OR. TRIM (string) /= string (1:trimmed_len)) THEN\n+    PRINT *, full_len, trimmed_len\n+    PRINT *, LEN (string), LEN_TRIM (string)\n+    CALL abort ()\n+  END IF\n+END SUBROUTINE check_trim\n+\n+\n+! The main program, check with various combinations.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: i, j\n+\n+  DO i = 0, 20\n+    DO j = 0, i\n+      CALL check_trim (i, j)\n+    END DO\n+  END DO\n+END PROGRAM main"}, {"sha": "45779d673fdefcb9c79fcfb65c48a182aa7d4629", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "patch": "@@ -1,3 +1,10 @@\n+2009-03-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* intrinsics/string_intrinsics.c: #include <assert.h>\n+\t* intrinsics/string_intrinsics_inc.c (string_trim): Use string_len_trim\n+\tinstead of calculating the length directly.\n+\t(string_len_trim): For KIND=1, speed search up.\n+\n 2009-03-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/39528"}, {"sha": "491b45e21df2217794cb039e7f05ffc87e694ef4", "filename": "libgfortran/intrinsics/string_intrinsics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics.c?ref=bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02110-1301, USA.  */\n \n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n \n /* Helper function to set parts of wide strings to a constant (usually"}, {"sha": "5497991c76b56edf8e0cd65534d856e7495bda28", "filename": "libgfortran/intrinsics/string_intrinsics_inc.c", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6600ab2aeff09a928a28d2f74288ffcb5ad839/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c?ref=bc6600ab2aeff09a928a28d2f74288ffcb5ad839", "patch": "@@ -165,15 +165,7 @@ void\n string_trim (gfc_charlen_type *len, CHARTYPE **dest, gfc_charlen_type slen,\n \t     const CHARTYPE *src)\n {\n-  gfc_charlen_type i;\n-\n-  /* Determine length of result string.  */\n-  for (i = slen - 1; i >= 0; i--)\n-    {\n-      if (src[i] != ' ')\n-        break;\n-    }\n-  *len = i + 1;\n+  *len = string_len_trim (slen, src);\n \n   if (*len == 0)\n     *dest = &zero_length_string;\n@@ -193,13 +185,57 @@ string_trim (gfc_charlen_type *len, CHARTYPE **dest, gfc_charlen_type slen,\n gfc_charlen_type\n string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n {\n+  const gfc_charlen_type long_len = (gfc_charlen_type) sizeof (unsigned long);\n   gfc_charlen_type i;\n \n-  for (i = len - 1; i >= 0; i--)\n+  i = len - 1;\n+\n+  /* If we've got the standard (KIND=1) character type, we scan the string in\n+     long word chunks to speed it up (until a long word is hit that does not\n+     consist of ' 's).  */\n+  if (sizeof (CHARTYPE) == 1 && i >= long_len)\n     {\n-      if (s[i] != ' ')\n-        break;\n+      int starting;\n+      unsigned long blank_longword;\n+\n+      /* Handle the first characters until we're aligned on a long word\n+\t boundary.  Actually, s + i + 1 must be properly aligned, because\n+\t s + i will be the last byte of a long word read.  */\n+      starting = ((unsigned long) (s + i + 1)) % long_len;\n+      i -= starting;\n+      for (; starting > 0; --starting)\n+\tif (s[i + starting] != ' ')\n+\t  return i + starting + 1;\n+\n+      /* Handle the others in a batch until first non-blank long word is\n+\t found.  Here again, s + i is the last byte of the current chunk,\n+\t to it starts at s + i - sizeof (long) + 1.  */\n+\n+#if __SIZEOF_LONG__ == 4\n+      blank_longword = 0x20202020L;\n+#elif __SIZEOF_LONG__ == 8\n+      blank_longword = 0x2020202020202020L;\n+#else\n+      #error Invalid size of long!\n+#endif\n+\n+      while (i >= long_len)\n+\t{\n+\t  i -= long_len;\n+\t  if (*((unsigned long*) (s + i + 1)) != blank_longword)\n+\t    {\n+\t      i += long_len;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Now continue for the last characters with naive approach below.  */\n+      assert (i >= 0);\n     }\n+\n+  /* Simply look for the first non-blank character.  */\n+  while (i >= 0 && s[i] == ' ')\n+    --i;\n   return i + 1;\n }\n "}]}