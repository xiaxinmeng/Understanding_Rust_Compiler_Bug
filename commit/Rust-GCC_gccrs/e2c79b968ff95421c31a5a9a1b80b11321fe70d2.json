{"sha": "e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjNzliOTY4ZmY5NTQyMWMzMWE1YTlhMWI4MGIxMTMyMWZlNzBkMg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-14T11:25:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-14T13:04:45Z"}, "message": "libstdc++: Change [cmp.alg] assertions to constraints\n\nThis moves the same_as<decay_t<_Tp>, decay_t<_Up>> checks from the\n[cmp.alg] function bodies into their constraints.\n\nAlso add a test for the compare_xxx_order_fallback algorithms.\n\nlibstdc++-v3/ChangeLog:\n\n\t* libsupc++/compare (__decayed_same_as): New helper concept.\n\t(strong_order, weak_order, partial_order): Constrain with new\n\tconcept instead of using static_assert.\n\t(compare_strong_order_fallback, compare_weak_order_fallback)\n\t(compare_partial_order_fallback): Likewise. Do not deduce return\n\ttypes. Remove redundant if-constexpr checks.\n\t* testsuite/18_support/comparisons/algorithms/fallback.cc: New test.", "tree": {"sha": "dacfd8c42bfc427196f773c6952a30eda8507dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dacfd8c42bfc427196f773c6952a30eda8507dde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c79b968ff95421c31a5a9a1b80b11321fe70d2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a893b26f7311fe65b604f12a8fa5d5d64f5454e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a893b26f7311fe65b604f12a8fa5d5d64f5454e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a893b26f7311fe65b604f12a8fa5d5d64f5454e2"}], "stats": {"total": 81, "additions": 57, "deletions": 24}, "files": [{"sha": "b1f342113f1ef46d8a062d8f620ef80d3c9094d1", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c79b968ff95421c31a5a9a1b80b11321fe70d2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c79b968ff95421c31a5a9a1b80b11321fe70d2/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "patch": "@@ -600,6 +600,9 @@ namespace std\n \t  // FIXME: || floating_point<remove_reference_t<_Tp>>\n \t  || __cmp3way<strong_ordering, _Tp, _Up>;\n \n+    template<typename _Tp, typename _Up>\n+      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;\n+\n     class _Strong_order\n     {\n       template<typename _Tp, typename _Up>\n@@ -620,14 +623,12 @@ namespace std\n       friend class _Strong_fallback;\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __strongly_ordered<_Tp, _Up>\n \tconstexpr strong_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  /* FIXME:\n \t  if constexpr (floating_point<decay_t<_Tp>>)\n \t    return __cmp_cust::__fp_strong_order(__e, __f);\n@@ -669,14 +670,12 @@ namespace std\n       friend class _Weak_fallback;\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __weakly_ordered<_Tp, _Up>\n \tconstexpr weak_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  if constexpr (floating_point<decay_t<_Tp>>)\n \t    return __cmp_cust::__fp_weak_ordering(__e, __f);\n \t  else if constexpr (__adl_weak<_Tp, _Up>)\n@@ -716,14 +715,12 @@ namespace std\n       friend class _Partial_fallback;\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __partially_ordered<_Tp, _Up>\n \tconstexpr partial_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  if constexpr (__adl_partial<_Tp, _Up>)\n \t    return partial_ordering(partial_order(static_cast<_Tp&&>(__e),\n \t\t\t\t\t\t  static_cast<_Up&&>(__f)));\n@@ -759,18 +756,16 @@ namespace std\n \t}\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n-\tconstexpr decltype(auto)\n+\tconstexpr strong_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  if constexpr (__strongly_ordered<_Tp, _Up>)\n \t    return _Strong_order{}(static_cast<_Tp&&>(__e),\n \t\t\t\t   static_cast<_Up&&>(__f));\n-\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t  else // __op_eq_lt<_Tp, _Up>\n \t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n \t      ? strong_ordering::equal\n \t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)\n@@ -793,18 +788,16 @@ namespace std\n \t}\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n-\tconstexpr decltype(auto)\n+\tconstexpr weak_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  if constexpr (__weakly_ordered<_Tp, _Up>)\n \t    return _Weak_order{}(static_cast<_Tp&&>(__e),\n \t\t\t\t static_cast<_Up&&>(__f));\n-\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t  else // __op_eq_lt<_Tp, _Up>\n \t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n \t      ? weak_ordering::equivalent\n \t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)\n@@ -827,18 +820,16 @@ namespace std\n \t}\n \n     public:\n-      template<typename _Tp, typename _Up>\n+      template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __partially_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n-\tconstexpr decltype(auto)\n+\tconstexpr partial_ordering\n \toperator()(_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n-\n \t  if constexpr (__partially_ordered<_Tp, _Up>)\n \t    return _Partial_order{}(static_cast<_Tp&&>(__e),\n \t\t\t\t    static_cast<_Up&&>(__f));\n-\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t  else // __op_eq_lt<_Tp, _Up>\n \t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n \t      ? partial_ordering::equivalent\n \t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)"}, {"sha": "ae458528f179d319a7abfdf567d0c11114355036", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/fallback.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c79b968ff95421c31a5a9a1b80b11321fe70d2/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c79b968ff95421c31a5a9a1b80b11321fe70d2/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc?ref=e2c79b968ff95421c31a5a9a1b80b11321fe70d2", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+\n+using std::strong_ordering;\n+using std::partial_ordering;\n+\n+namespace adl\n+{\n+  struct S { };\n+  void strong_ordering(const S&, const S&);\n+  bool operator==(const S&, S&) { return true; }\n+  bool operator<(const S&, S&) { return true; }\n+}\n+\n+template<typename T, typename U>\n+  concept has_strong_order_fallback = requires (T& t, U& u) {\n+    std::compare_strong_order_fallback(t, u);\n+  };\n+\n+template<typename T, typename U>\n+  concept has_weak_order_fallback = requires (T& t, U& u) {\n+    std::compare_weak_order_fallback(t, u);\n+  };\n+\n+template<typename T, typename U>\n+  concept has_partial_order_fallback = requires (T& t, U& u) {\n+    std::compare_partial_order_fallback(t, u);\n+  };\n+\n+using adl::S;\n+\n+static_assert( has_strong_order_fallback<S, S> );\n+static_assert( has_strong_order_fallback<const S, S> );\n+static_assert( ! has_strong_order_fallback<const S, const S> );\n+static_assert( has_weak_order_fallback<S, S> );\n+static_assert( has_weak_order_fallback<const S, S> );\n+static_assert( ! has_weak_order_fallback<const S, const S> );\n+static_assert( has_partial_order_fallback<S, S> );\n+static_assert( has_partial_order_fallback<const S, S> );\n+static_assert( ! has_partial_order_fallback<const S, const S> );"}]}