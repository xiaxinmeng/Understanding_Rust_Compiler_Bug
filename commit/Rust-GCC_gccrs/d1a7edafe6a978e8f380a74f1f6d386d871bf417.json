{"sha": "d1a7edafe6a978e8f380a74f1f6d386d871bf417", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFhN2VkYWZlNmE5NzhlOGYzODBhNzRmMWY2ZDM4NmQ4NzFiZjQxNw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-05-28T16:37:08Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-05-28T16:37:08Z"}, "message": "re PR rtl-optimization/15649 (ICE with __builtin_isgreater and -ffast-math)\n\ngcc/ChangeLog:\n2004-05-27  Paolo Bonzini  <bonzini@gnu.org>\n\t    Roger Sayle  <roger@eyesopen.com>\n\n\tPR rtl-optimization/15649\n\tAdd LTGT_EXPR and improve pretty-printing of unordered\n\tcomparisons.\n\t* c-common.c (c_common_truthvalue_conversion):\n\tHandle LTGT_EXPR.\n\t* c-typeck.c (build_binary_op): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* expr.c (expand_expr_real_1, do_store_flag): Likewise.\n\t* predict.c (tree_predict_by_opcode): Likewise.\n\t* real.c (real_compare): Likewise.\n\t* tree-cfg.c (verify_expr): Likewise.\n\t* tree-inline.c (estimate_num_insns_1): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\tHandle ORDERED_EXPR, UNORDERED_EXPR.\n\t(op_symbol): Print unordered comparisons differently\n\tthan ordered ones.\n\t* tree.def (LTGT_EXPR): New '<' tree code.\n\t* doc/c-tree.texi (Expressions): Document floating-point\n\tcomparison nodes.\n\n\tFold comparisons between floating point values.\n\t* fold-const.c (enum comparison_code): New, from\n\t#define'd constants.  Define compcodes for unordered\n\tcomparisons and for invalid transformations.\n\t(invert_tree_comparison): Add \"honor_nans\" parameter.\n\t(fold_truthop): Revamp to work on floating-point types too.\n\t(comparison_to_compcode): Support unordered comparisons.\n\tUse new enum comparison_code.\n\t(compcode_to_comparison): Likewise.\n\t(combine_compcodes): New function.\n\t(invert_truthvalue): Let invert_tree_comparison decide\n\twhether it is valid to fold the comparison.  Fold ORDERED\n\tand UNORDERED even if flag_unsafe_math_optimizations is off,\n\tand the remaining even if flag_unsafe_math_optimizations\n\tis off but we are under -fno-trapping-math.\n\t(fold_relational_const): Integer modes do not honor NaNs.\n\ngcc/testsuite/ChangeLog:\n2004-05-27  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* gcc.c-torture/compare-fp-1.c, gcc.c-torture/compare-fp-2.c,\n\tgcc.c-torture/compare-fp-3.c, gcc.c-torture/compare-fp-4.c,\n\tgcc.c-torture/compare-fp-3.x, gcc.c-torture/compare-fp-4.x,\n\tgcc.c-torture/pr15649-1.c: New.\n\nCo-Authored-By: Roger Sayle <roger@eyesopen.com>\n\nFrom-SVN: r82365", "tree": {"sha": "7ddeb479040eb4166d908a90967e3c0027eb6800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ddeb479040eb4166d908a90967e3c0027eb6800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1a7edafe6a978e8f380a74f1f6d386d871bf417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a7edafe6a978e8f380a74f1f6d386d871bf417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a7edafe6a978e8f380a74f1f6d386d871bf417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a7edafe6a978e8f380a74f1f6d386d871bf417/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2966b00e88d24531be8ff24ac6c82d5cf70ae116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2966b00e88d24531be8ff24ac6c82d5cf70ae116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2966b00e88d24531be8ff24ac6c82d5cf70ae116"}], "stats": {"total": 947, "additions": 856, "deletions": 91}, "files": [{"sha": "3951b0252494fd961d4cc61c3435d747d1a7e17c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -1,3 +1,43 @@\n+2004-05-28  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/15649\n+\tAdd LTGT_EXPR and improve pretty-printing of unordered\n+\tcomparisons.\n+\t* c-common.c (c_common_truthvalue_conversion):\n+\tHandle LTGT_EXPR.\n+\t* c-typeck.c (build_binary_op): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* expr.c (expand_expr_real_1, do_store_flag): Likewise.\n+\t* predict.c (tree_predict_by_opcode): Likewise.\n+\t* real.c (real_compare): Likewise.\n+\t* tree-cfg.c (verify_expr): Likewise.\n+\t* tree-inline.c (estimate_num_insns_1): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\tHandle ORDERED_EXPR, UNORDERED_EXPR.\n+\t(op_symbol): Print unordered comparisons differently\n+\tthan ordered ones.\n+\t* tree.def (LTGT_EXPR): New '<' tree code.\n+\t* doc/c-tree.texi (Expressions): Document floating-point\n+\tcomparison nodes.\n+\n+\tFold comparisons between floating point values.\n+\t* fold-const.c (enum comparison_code): New, from\n+\t#define'd constants.  Define compcodes for unordered\n+\tcomparisons and for invalid transformations.\n+\t(invert_tree_comparison): Add \"honor_nans\" parameter.\n+\t(fold_truthop): Revamp to work on floating-point types too.\n+\t(comparison_to_compcode): Support unordered comparisons.\n+\tUse new enum comparison_code.\n+\t(compcode_to_comparison): Likewise.\n+\t(combine_compcodes): New function.\n+\t(invert_truthvalue): Let invert_tree_comparison decide\n+\twhether it is valid to fold the comparison.  Fold ORDERED\n+\tand UNORDERED even if flag_unsafe_math_optimizations is off,\n+\tand the remaining even if flag_unsafe_math_optimizations\n+\tis off but we are under -fno-trapping-math.\n+\t(fold_relational_const): Integer modes do not honor NaNs.\n+\t\n 2004-05-28  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (arm_output_epilogue): Remove redundant code."}, {"sha": "7f1e07a0d0c9f6512d98effc1aa3d218e9019839", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -2582,7 +2582,7 @@ c_common_truthvalue_conversion (tree expr)\n \n   switch (TREE_CODE (expr))\n     {\n-    case EQ_EXPR:   case NE_EXPR:   case UNEQ_EXPR:\n+    case EQ_EXPR:   case NE_EXPR:   case UNEQ_EXPR: case LTGT_EXPR:\n     case LE_EXPR:   case GE_EXPR:   case LT_EXPR:   case GT_EXPR:\n     case UNLE_EXPR: case UNGE_EXPR: case UNLT_EXPR: case UNGT_EXPR:\n     case ORDERED_EXPR: case UNORDERED_EXPR:"}, {"sha": "ddc2d0803bee61f9bef24c9ca8af47d68d29d264", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -6798,6 +6798,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n+    case LTGT_EXPR:\n       build_type = integer_type_node;\n       if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n \t{"}, {"sha": "0e0b1af5c74e7307baf62cd807a71c74a92d31d0", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -1745,6 +1745,12 @@ This macro returns the attributes on the type @var{type}.\n @tindex GE_EXPR\n @tindex EQ_EXPR\n @tindex NE_EXPR\n+@tindex UNLT_EXPR\n+@tindex UNLE_EXPR\n+@tindex UNGT_EXPR\n+@tindex UNGE_EXPR\n+@tindex UNEQ_EXPR\n+@tindex LTGT_EXPR\n @tindex INIT_EXPR\n @tindex MODIFY_EXPR\n @tindex COMPONENT_REF\n@@ -2106,6 +2112,39 @@ operators.  The first and second operand with either be both of integral\n type or both of floating type.  The result type of these expressions\n will always be of integral or boolean type.\n \n+Floating-point comparison may have a fourth possible outcome for a\n+comparison, other than less, greater or equal: this is @dfn{unordered},\n+and two floating-point values are unordered if one of them is\n+a @dfn{not-a-number} (@dfn{NaN}) value.  In this case, all of these\n+nodes will be false but @code{NE_EXPR}, and the first four of these\n+nodes will also raise an invalid operation trap.\n+\n+@item ORDERED_EXPR\n+@itemx UNORDERED_EXPR\n+@item UNLT_EXPR\n+@itemx UNLE_EXPR\n+@itemx UNGT_EXPR\n+@itemx UNGE_EXPR\n+@itemx UNEQ_EXPR\n+@itemx LTGT_EXPR\n+\n+These nodes represent other relational operations that are only used\n+with floating types.\n+\n+If the outcome of the comparison is unordered, all of these special\n+comparisons will be true but @code{ORDERED_EXPR} and @code{LTGT_EXPR}.\n+Only @code{LTGT_EXPR} is expected to generate an invalid floating-point\n+operation trap when the outcome is unordered.\n+\n+@code{ORDERED_EXPR} is true if neither of its operands is a NaN,\n+while its negation @code{UNORDERED_EXPR} is true if at least one of\n+its operands is a NaN.\n+\n+For floating operations, inverting one of the standard comparison nodes \n+will result in one of these nodes, with its name prefixed by\n+@code{UN}---the only exception is @code{NE_EXPR}, whose negation is\n+@code{LTGT_EXPR}.\n+\n @item MODIFY_EXPR\n These nodes represent assignment.  The left-hand side is the first\n operand; the right-hand side is the second operand.  The left-hand side"}, {"sha": "c6756281e64624119c0edcfb2e646f3efbf43271", "filename": "gcc/dojump.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -525,7 +525,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \n     {\n       enum rtx_code rcode1;\n-      enum tree_code tcode2;\n+      enum tree_code tcode1 = UNORDERED_EXPR, tcode2;\n \n       case UNLT_EXPR:\n         rcode1 = UNLT;\n@@ -547,6 +547,13 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         rcode1 = UNEQ;\n         tcode2 = EQ_EXPR;\n         goto unordered_bcc;\n+      case LTGT_EXPR:\n+\t/* It is ok for LTGT_EXPR to trap when the result is unordered,\n+\t   so expand to (a < b) || (a > b).  */\n+        rcode1 = LTGT;\n+        tcode1 = LT_EXPR;\n+        tcode2 = GT_EXPR;\n+        goto unordered_bcc;\n \n       unordered_bcc:\n         mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n@@ -560,8 +567,8 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n             tree cmp0, cmp1;\n \n             /* If the target doesn't support combined unordered\n-               compares, decompose into UNORDERED + comparison.  */\n-            cmp0 = fold (build (UNORDERED_EXPR, TREE_TYPE (exp), op0, op1));\n+               compares, decompose into two comparisons.  */\n+            cmp0 = fold (build (tcode1, TREE_TYPE (exp), op0, op1));\n             cmp1 = fold (build (tcode2, TREE_TYPE (exp), op0, op1));\n             exp = build (TRUTH_ORIF_EXPR, TREE_TYPE (exp), cmp0, cmp1);\n             do_jump (exp, if_false_label, if_true_label);"}, {"sha": "a4357cdcfdbedc4f66ee6bca4ddb2ad5ede88b48", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -8305,6 +8305,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n+    case LTGT_EXPR:\n       temp = do_store_flag (exp,\n \t\t\t    modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n \t\t\t    tmode != VOIDmode ? tmode : mode, 0);\n@@ -9815,6 +9816,9 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n     case UNEQ_EXPR:\n       code = UNEQ;\n       break;\n+    case LTGT_EXPR:\n+      code = LTGT;\n+      break;\n \n     default:\n       abort ();"}, {"sha": "98e98f78a7c794ba98b02e29fd816c62286bf665", "filename": "gcc/fold-const.c", "status": "modified", "additions": 206, "deletions": 74, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -58,6 +58,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"md5.h\"\n \n+/* The following constants represent a bit based encoding of GCC's\n+   comparison operators.  This encoding simplifies transformations\n+   on relational comparison operators, such as AND and OR.  */\n+enum comparison_code {\n+  COMPCODE_FALSE = 0,\n+  COMPCODE_LT = 1,\n+  COMPCODE_EQ = 2,\n+  COMPCODE_LE = 3,\n+  COMPCODE_GT = 4,\n+  COMPCODE_LTGT = 5,\n+  COMPCODE_GE = 6,\n+  COMPCODE_ORD = 7,\n+  COMPCODE_UNORD = 8,\n+  COMPCODE_UNLT = 9,\n+  COMPCODE_UNEQ = 10,\n+  COMPCODE_UNLE = 11,\n+  COMPCODE_UNGT = 12,\n+  COMPCODE_NE = 13,\n+  COMPCODE_UNGE = 14,\n+  COMPCODE_TRUE = 15\n+};\n+\n static void encode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n static void decode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n static bool negate_mathfn_p (enum built_in_function);\n@@ -69,10 +91,12 @@ static tree const_binop (enum tree_code, tree, tree, int);\n static hashval_t size_htab_hash (const void *);\n static int size_htab_eq (const void *, const void *);\n static tree fold_convert_const (enum tree_code, tree, tree);\n-static enum tree_code invert_tree_comparison (enum tree_code);\n+static enum tree_code invert_tree_comparison (enum tree_code, bool);\n static enum tree_code swap_tree_comparison (enum tree_code);\n-static int comparison_to_compcode (enum tree_code);\n-static enum tree_code compcode_to_comparison (int);\n+static enum comparison_code comparison_to_compcode (enum tree_code);\n+static enum tree_code compcode_to_comparison (enum comparison_code);\n+static tree combine_comparisons (enum tree_code, enum tree_code,\n+\t\t\t\t enum tree_code, tree, tree, tree);\n static int truth_value_p (enum tree_code);\n static int operand_equal_for_comparison_p (tree, tree, tree);\n static int twoval_comparison_p (tree, tree *, tree *, int *);\n@@ -115,18 +139,6 @@ static tree fold_abs_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_relational_hi_lo (enum tree_code *, const tree, tree *, tree *);\n \n-/* The following constants represent a bit based encoding of GCC's\n-   comparison operators.  This encoding simplifies transformations\n-   on relational comparison operators, such as AND and OR.  */\n-#define COMPCODE_FALSE   0\n-#define COMPCODE_LT      1\n-#define COMPCODE_EQ      2\n-#define COMPCODE_LE      3\n-#define COMPCODE_GT      4\n-#define COMPCODE_NE      5\n-#define COMPCODE_GE      6\n-#define COMPCODE_TRUE    7\n-\n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n    and SUM1.  Then this yields nonzero if overflow occurred during the\n@@ -2057,25 +2069,45 @@ pedantic_non_lvalue (tree x)\n \f\n /* Given a tree comparison code, return the code that is the logical inverse\n    of the given code.  It is not safe to do this for floating-point\n-   comparisons, except for NE_EXPR and EQ_EXPR.  */\n+   comparisons, except for NE_EXPR and EQ_EXPR, so we receive a machine mode\n+   as well: if reversing the comparison is unsafe, return ERROR_MARK.  */\n \n static enum tree_code\n-invert_tree_comparison (enum tree_code code)\n+invert_tree_comparison (enum tree_code code, bool honor_nans)\n {\n+  if (honor_nans && flag_trapping_math)\n+    return ERROR_MARK;\n+\n   switch (code)\n     {\n     case EQ_EXPR:\n       return NE_EXPR;\n     case NE_EXPR:\n       return EQ_EXPR;\n     case GT_EXPR:\n-      return LE_EXPR;\n+      return honor_nans ? UNLE_EXPR : LE_EXPR;\n     case GE_EXPR:\n-      return LT_EXPR;\n+      return honor_nans ? UNLT_EXPR : LT_EXPR;\n     case LT_EXPR:\n-      return GE_EXPR;\n+      return honor_nans ? UNGE_EXPR : GE_EXPR;\n     case LE_EXPR:\n+      return honor_nans ? UNGT_EXPR : GT_EXPR;\n+    case LTGT_EXPR:\n+      return UNEQ_EXPR;\n+    case UNEQ_EXPR:\n+      return LTGT_EXPR;\n+    case UNGT_EXPR:\n+      return LE_EXPR;\n+    case UNGE_EXPR:\n+      return LT_EXPR;\n+    case UNLT_EXPR:\n+      return GE_EXPR;\n+    case UNLE_EXPR:\n       return GT_EXPR;\n+    case ORDERED_EXPR:\n+      return UNORDERED_EXPR;\n+    case UNORDERED_EXPR:\n+      return ORDERED_EXPR;\n     default:\n       abort ();\n     }\n@@ -2110,7 +2142,7 @@ swap_tree_comparison (enum tree_code code)\n    into a compcode bit-based encoding.  This function is the inverse of\n    compcode_to_comparison.  */\n \n-static int\n+static enum comparison_code\n comparison_to_compcode (enum tree_code code)\n {\n   switch (code)\n@@ -2127,6 +2159,22 @@ comparison_to_compcode (enum tree_code code)\n       return COMPCODE_NE;\n     case GE_EXPR:\n       return COMPCODE_GE;\n+    case ORDERED_EXPR:\n+      return COMPCODE_ORD;\n+    case UNORDERED_EXPR:\n+      return COMPCODE_UNORD;\n+    case UNLT_EXPR:\n+      return COMPCODE_UNLT;\n+    case UNEQ_EXPR:\n+      return COMPCODE_UNEQ;\n+    case UNLE_EXPR:\n+      return COMPCODE_UNLE;\n+    case UNGT_EXPR:\n+      return COMPCODE_UNGT;\n+    case LTGT_EXPR:\n+      return COMPCODE_LTGT;\n+    case UNGE_EXPR:\n+      return COMPCODE_UNGE;\n     default:\n       abort ();\n     }\n@@ -2137,7 +2185,7 @@ comparison_to_compcode (enum tree_code code)\n    inverse of comparison_to_compcode.  */\n \n static enum tree_code\n-compcode_to_comparison (int code)\n+compcode_to_comparison (enum comparison_code code)\n {\n   switch (code)\n     {\n@@ -2153,11 +2201,111 @@ compcode_to_comparison (int code)\n       return NE_EXPR;\n     case COMPCODE_GE:\n       return GE_EXPR;\n+    case COMPCODE_ORD:\n+      return ORDERED_EXPR;\n+    case COMPCODE_UNORD:\n+      return UNORDERED_EXPR;\n+    case COMPCODE_UNLT:\n+      return UNLT_EXPR;\n+    case COMPCODE_UNEQ:\n+      return UNEQ_EXPR;\n+    case COMPCODE_UNLE:\n+      return UNLE_EXPR;\n+    case COMPCODE_UNGT:\n+      return UNGT_EXPR;\n+    case COMPCODE_LTGT:\n+      return LTGT_EXPR;\n+    case COMPCODE_UNGE:\n+      return UNGE_EXPR;\n     default:\n       abort ();\n     }\n }\n \n+/* Return a tree for the comparison which is the combination of\n+   doing the AND or OR (depending on CODE) of the two operations LCODE\n+   and RCODE on the identical operands LL_ARG and LR_ARG.  Take into account\n+   the possibility of trapping if the mode has NaNs, and return NULL_TREE\n+   if this makes the transformation invalid.  */\n+\n+tree\n+combine_comparisons (enum tree_code code, enum tree_code lcode,\n+\t\t     enum tree_code rcode, tree truth_type,\n+\t\t     tree ll_arg, tree lr_arg)\n+{\n+  bool honor_nans = HONOR_NANS (TYPE_MODE (TREE_TYPE (ll_arg)));\n+  enum comparison_code lcompcode = comparison_to_compcode (lcode);\n+  enum comparison_code rcompcode = comparison_to_compcode (rcode);\n+  enum comparison_code compcode;\n+\n+  switch (code)\n+    {\n+    case TRUTH_AND_EXPR: case TRUTH_ANDIF_EXPR:\n+      compcode = lcompcode & rcompcode;\n+      break;\n+\n+    case TRUTH_OR_EXPR: case TRUTH_ORIF_EXPR:\n+      compcode = lcompcode | rcompcode;\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  if (!honor_nans)\n+    {\n+      /* Eliminate unordered comparisons, as well as LTGT and ORD\n+\t which are not used unless the mode has NaNs.  */\n+      compcode &= ~COMPCODE_UNORD;\n+      if (compcode == COMPCODE_LTGT)\n+\tcompcode = COMPCODE_NE;\n+      else if (compcode == COMPCODE_ORD)\n+\tcompcode = COMPCODE_TRUE;\n+    }\n+   else if (flag_trapping_math)\n+     {\n+\t/* Check that the original operation and the optimized ones will trap \n+\t   under the same condition.  */\n+\tbool ltrap = (lcompcode & COMPCODE_UNORD) == 0\n+\t\t     && (lcompcode != COMPCODE_EQ)\n+\t\t     && (lcompcode != COMPCODE_ORD);\n+\tbool rtrap = (rcompcode & COMPCODE_UNORD) == 0\n+\t\t     && (rcompcode != COMPCODE_EQ)\n+\t\t     && (rcompcode != COMPCODE_ORD);\n+\tbool trap = (compcode & COMPCODE_UNORD) == 0\n+\t\t    && (compcode != COMPCODE_EQ)\n+\t\t    && (compcode != COMPCODE_ORD);\n+\n+        /* In a short-circuited boolean expression the LHS might be\n+\t   such that the RHS, if evaluated, will never trap.  For\n+\t   example, in ORD (x, y) && (x < y), we evaluate the RHS only\n+\t   if neither x nor y is NaN.  (This is a mixed blessing: for\n+\t   example, the expression above will never trap, hence\n+\t   optimizing it to x < y would be invalid).  */\n+        if ((code == TRUTH_ORIF_EXPR && (lcompcode & COMPCODE_UNORD))\n+            || (code == TRUTH_ANDIF_EXPR && !(lcompcode & COMPCODE_UNORD)))\n+          rtrap = false;\n+\n+        /* If the comparison was short-circuited, and only the RHS\n+\t   trapped, we may now generate a spurious trap.  */\n+\tif (rtrap && !ltrap\n+\t    && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR))\n+\t  return NULL_TREE;\n+\n+\t/* If we changed the conditions that cause a trap, we lose.  */\n+\tif ((ltrap || rtrap) != trap)\n+\t  return NULL_TREE;\n+      }\n+\n+  if (compcode == COMPCODE_TRUE)\n+    return fold_convert (truth_type, integer_one_node);\n+  else if (compcode == COMPCODE_FALSE)\n+    return fold_convert (truth_type, integer_zero_node);\n+  else\n+    return fold (build2 (compcode_to_comparison (compcode),\n+\t\t\t truth_type, ll_arg, lr_arg));\n+}\n+\n /* Return nonzero if CODE is a tree code that represents a truth value.  */\n \n static int\n@@ -2680,8 +2828,10 @@ pedantic_omit_one_operand (tree type, tree result, tree omitted)\n \f\n /* Return a simplified tree node for the truth-negation of ARG.  This\n    never alters ARG itself.  We assume that ARG is an operation that\n-   returns a truth value (0 or 1).  */\n+   returns a truth value (0 or 1).\n \n+   FIXME: one would think we would fold the result, but it causes\n+   problems with the dominator optimizer.  */\n tree\n invert_truthvalue (tree arg)\n {\n@@ -2697,22 +2847,22 @@ invert_truthvalue (tree arg)\n \n   if (TREE_CODE_CLASS (code) == '<')\n     {\n-      if (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n-\t  && !flag_unsafe_math_optimizations\n-\t  && code != NE_EXPR\n-\t  && code != EQ_EXPR)\n-\treturn build1 (TRUTH_NOT_EXPR, type, arg);\n-      else if (code == UNORDERED_EXPR\n-\t       || code == ORDERED_EXPR\n-\t       || code == UNEQ_EXPR\n-\t       || code == UNLT_EXPR\n-\t       || code == UNLE_EXPR\n-\t       || code == UNGT_EXPR\n-\t       || code == UNGE_EXPR)\n+      tree op_type = TREE_TYPE (TREE_OPERAND (arg, 0));\n+      if (FLOAT_TYPE_P (op_type)\n+\t  && flag_trapping_math\n+\t  && code != ORDERED_EXPR && code != UNORDERED_EXPR\n+\t  && code != NE_EXPR && code != EQ_EXPR)\n \treturn build1 (TRUTH_NOT_EXPR, type, arg);\n       else\n-\treturn build2 (invert_tree_comparison (code), type,\n-\t\t       TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n+\t{\n+\t  code = invert_tree_comparison (code,\n+\t\t\t\t\t HONOR_NANS (TYPE_MODE (op_type)));\n+\t  if (code == ERROR_MARK)\n+\t    return build1 (TRUTH_NOT_EXPR, type, arg);\n+\t  else\n+\t    return build2 (code, type,\n+\t\t\t   TREE_OPERAND (arg, 0), TREE_OPERAND (arg, 1));\n+\t}\n     }\n \n   switch (code)\n@@ -4011,56 +4161,38 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n   if (TREE_CODE_CLASS (lcode) != '<' || TREE_CODE_CLASS (rcode) != '<')\n     return 0;\n \n-  code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)\n-\t  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR);\n-\n   ll_arg = TREE_OPERAND (lhs, 0);\n   lr_arg = TREE_OPERAND (lhs, 1);\n   rl_arg = TREE_OPERAND (rhs, 0);\n   rr_arg = TREE_OPERAND (rhs, 1);\n \n   /* Simplify (x<y) && (x==y) into (x<=y) and related optimizations.  */\n   if (simple_operand_p (ll_arg)\n-      && simple_operand_p (lr_arg)\n-      && !FLOAT_TYPE_P (TREE_TYPE (ll_arg)))\n+      && simple_operand_p (lr_arg))\n     {\n-      int compcode;\n-\n+      tree result;\n       if (operand_equal_p (ll_arg, rl_arg, 0)\n           && operand_equal_p (lr_arg, rr_arg, 0))\n-        {\n-          int lcompcode, rcompcode;\n-\n-          lcompcode = comparison_to_compcode (lcode);\n-          rcompcode = comparison_to_compcode (rcode);\n-          compcode = (code == TRUTH_AND_EXPR)\n-                     ? lcompcode & rcompcode\n-                     : lcompcode | rcompcode;\n-        }\n+\t{\n+          result = combine_comparisons (code, lcode, rcode,\n+\t\t\t\t\ttruth_type, ll_arg, lr_arg);\n+\t  if (result)\n+\t    return result;\n+\t}\n       else if (operand_equal_p (ll_arg, rr_arg, 0)\n                && operand_equal_p (lr_arg, rl_arg, 0))\n-        {\n-          int lcompcode, rcompcode;\n-\n-          rcode = swap_tree_comparison (rcode);\n-          lcompcode = comparison_to_compcode (lcode);\n-          rcompcode = comparison_to_compcode (rcode);\n-          compcode = (code == TRUTH_AND_EXPR)\n-                     ? lcompcode & rcompcode\n-                     : lcompcode | rcompcode;\n-        }\n-      else\n-\tcompcode = -1;\n-\n-      if (compcode == COMPCODE_TRUE)\n-\treturn fold_convert (truth_type, integer_one_node);\n-      else if (compcode == COMPCODE_FALSE)\n-\treturn fold_convert (truth_type, integer_zero_node);\n-      else if (compcode != -1)\n-\treturn build2 (compcode_to_comparison (compcode),\n-\t\t       truth_type, ll_arg, lr_arg);\n+\t{\n+          result = combine_comparisons (code, lcode,\n+\t\t\t\t\tswap_tree_comparison (rcode),\n+\t\t\t\t\ttruth_type, ll_arg, lr_arg);\n+\t  if (result)\n+\t    return result;\n+\t}\n     }\n \n+  code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)\n+\t  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR);\n+\n   /* If the RHS can be evaluated unconditionally and its operands are\n      simple, it wins to evaluate the RHS unconditionally on machines\n      with expensive branches.  In this case, this isn't a comparison\n@@ -9856,7 +9988,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n   if (code == NE_EXPR || code == GE_EXPR)\n     {\n       invert = 1;\n-      code = invert_tree_comparison (code);\n+      code = invert_tree_comparison (code, false);\n     }\n \n   /* Compute a result for LT or EQ if args permit;"}, {"sha": "7d97040e1f88e7cf486280dc6713ae0516681d11", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -865,6 +865,7 @@ tree_predict_by_opcode (basic_block bb)\n \tbreak;\n \n       case NE_EXPR:\n+      case LTGT_EXPR:\n \t/* Floating point comparisons appears to behave in a very\n \t   unpredictable way because of special role of = tests in\n \t   FP code.  */"}, {"sha": "e702b2d675ae27320771d0d54cb8002f4f568b29", "filename": "gcc/real.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -1080,6 +1080,8 @@ real_compare (int icode, const REAL_VALUE_TYPE *op0,\n       return do_compare (op0, op1, 1) >= 0;\n     case UNEQ_EXPR:\n       return do_compare (op0, op1, 0) == 0;\n+    case LTGT_EXPR:\n+      return do_compare (op0, op1, 0) != 0;\n \n     default:\n       abort ();"}, {"sha": "c966980940600c342272dc477bd4a45e12ec76cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -1,3 +1,10 @@\n+2004-05-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* gcc.c-torture/compare-fp-1.c, gcc.c-torture/compare-fp-2.c,\n+\tgcc.c-torture/compare-fp-3.c, gcc.c-torture/compare-fp-4.c,\n+\tgcc.c-torture/compare-fp-3.x, gcc.c-torture/compare-fp-4.x,\n+\tgcc.c-torture/pr15649-1.c: New.\n+\n 2004-05-27  Adam Nemet  <anemet@lnxw.com>\n \n \tPR c++/12883"}, {"sha": "81642534cc34f4debd7b509ea1452ad0f465c9f5", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-1.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-1.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,189 @@\n+/* Copyright (C) 2004 Free Software Foundation.\n+\n+   Test for correctness of composite floating-point comparisons.\n+\n+   Written by Paolo Bonzini, 26th May 2004.  */\n+\n+extern void abort (void);\n+\n+#define TEST(c) if ((c) != ok) abort ();\n+#define ORD(a, b) (!__builtin_isunordered ((a), (b)))\n+#define UNORD(a, b) (__builtin_isunordered ((a), (b)))\n+#define UNEQ(a, b) (__builtin_isunordered ((a), (b)) || ((a) == (b)))\n+#define UNLT(a, b) (__builtin_isunordered ((a), (b)) || ((a) < (b)))\n+#define UNLE(a, b) (__builtin_isunordered ((a), (b)) || ((a) <= (b)))\n+#define UNGT(a, b) (__builtin_isunordered ((a), (b)) || ((a) > (b)))\n+#define UNGE(a, b) (__builtin_isunordered ((a), (b)) || ((a) >= (b)))\n+#define LTGT(a, b) (__builtin_islessgreater ((a), (b)))\n+\n+float pinf;\n+float ninf;\n+float NaN;\n+\n+int iuneq (float x, float y, int ok)\n+{\n+  TEST (UNEQ (x, y));\n+  TEST (!LTGT (x, y));\n+  TEST (UNLE (x, y) && UNGE (x,y));\n+}\n+\n+int ieq (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNEQ (x, y));\n+}\n+\n+int iltgt (float x, float y, int ok)\n+{\n+  TEST (!UNEQ (x, y)); /* Not optimizable. */\n+  TEST (LTGT (x, y)); /* Same, __builtin_islessgreater does not trap. */\n+  TEST (ORD (x, y) && (UNLT (x, y) || UNGT (x,y)));\n+}\n+\n+int ine (float x, float y, int ok)\n+{\n+  TEST (UNLT (x, y) || UNGT (x, y));\n+}\n+\n+int iunlt (float x, float y, int ok)\n+{\n+  TEST (UNLT (x, y));\n+  TEST (UNORD (x, y) || (x < y));\n+}\n+\n+int ilt (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNLT (x, y)); /* Not optimized */\n+  TEST ((x <= y) && (x != y));\n+  TEST ((x <= y) && (y != x));\n+  TEST ((x != y) && (x <= y)); /* Not optimized */\n+  TEST ((y != x) && (x <= y)); /* Not optimized */\n+}\n+\n+int iunle (float x, float y, int ok)\n+{\n+  TEST (UNLE (x, y));\n+  TEST (UNORD (x, y) || (x <= y));\n+}\n+\n+int ile (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNLE (x, y)); /* Not optimized */\n+  TEST ((x < y) || (x == y));\n+  TEST ((y > x) || (x == y));\n+  TEST ((x == y) || (x < y)); /* Not optimized */\n+  TEST ((y == x) || (x < y)); /* Not optimized */\n+}\n+\n+int iungt (float x, float y, int ok)\n+{\n+  TEST (UNGT (x, y));\n+  TEST (UNORD (x, y) || (x > y));\n+}\n+\n+int igt (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNGT (x, y)); /* Not optimized */\n+  TEST ((x >= y) && (x != y));\n+  TEST ((x >= y) && (y != x));\n+  TEST ((x != y) && (x >= y)); /* Not optimized */\n+  TEST ((y != x) && (x >= y)); /* Not optimized */\n+}\n+\n+int iunge (float x, float y, int ok)\n+{\n+  TEST (UNGE (x, y));\n+  TEST (UNORD (x, y) || (x >= y));\n+}\n+\n+int ige (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNGE (x, y)); /* Not optimized */\n+  TEST ((x > y) || (x == y));\n+  TEST ((y < x) || (x == y));\n+  TEST ((x == y) || (x > y)); /* Not optimized */\n+  TEST ((y == x) || (x > y)); /* Not optimized */\n+}\n+\n+int\n+main ()\n+{\n+  pinf = __builtin_inf ();\n+  ninf = -__builtin_inf ();\n+  NaN = __builtin_nan (\"\");\n+\n+  iuneq (ninf, pinf, 0);\n+  iuneq (NaN, NaN, 1);\n+  iuneq (pinf, ninf, 0);\n+  iuneq (1, 4, 0);\n+  iuneq (3, 3, 1);\n+  iuneq (5, 2, 0);\n+\n+  ieq (1, 4, 0);\n+  ieq (3, 3, 1);\n+  ieq (5, 2, 0);\n+\n+  iltgt (ninf, pinf, 1);\n+  iltgt (NaN, NaN, 0);\n+  iltgt (pinf, ninf, 1);\n+  iltgt (1, 4, 1);\n+  iltgt (3, 3, 0);\n+  iltgt (5, 2, 1);\n+\n+  ine (1, 4, 1);\n+  ine (3, 3, 0);\n+  ine (5, 2, 1);\n+\n+  iunlt (NaN, ninf, 1);\n+  iunlt (pinf, NaN, 1);\n+  iunlt (pinf, ninf, 0);\n+  iunlt (pinf, pinf, 0);\n+  iunlt (ninf, ninf, 0);\n+  iunlt (1, 4, 1);\n+  iunlt (3, 3, 0);\n+  iunlt (5, 2, 0);\n+\n+  ilt (1, 4, 1);\n+  ilt (3, 3, 0);\n+  ilt (5, 2, 0);\n+\n+  iunle (NaN, ninf, 1);\n+  iunle (pinf, NaN, 1);\n+  iunle (pinf, ninf, 0);\n+  iunle (pinf, pinf, 1);\n+  iunle (ninf, ninf, 1);\n+  iunle (1, 4, 1);\n+  iunle (3, 3, 1);\n+  iunle (5, 2, 0);\n+\n+  ile (1, 4, 1);\n+  ile (3, 3, 1);\n+  ile (5, 2, 0);\n+\n+  iungt (NaN, ninf, 1);\n+  iungt (pinf, NaN, 1);\n+  iungt (pinf, ninf, 1);\n+  iungt (pinf, pinf, 0);\n+  iungt (ninf, ninf, 0);\n+  iungt (1, 4, 0);\n+  iungt (3, 3, 0);\n+  iungt (5, 2, 1);\n+\n+  igt (1, 4, 0);\n+  igt (3, 3, 0);\n+  igt (5, 2, 1);\n+\n+  iunge (NaN, ninf, 1);\n+  iunge (pinf, NaN, 1);\n+  iunge (ninf, pinf, 0);\n+  iunge (pinf, pinf, 1);\n+  iunge (ninf, ninf, 1);\n+  iunge (1, 4, 0);\n+  iunge (3, 3, 1);\n+  iunge (5, 2, 1);\n+\n+  ige (1, 4, 0);\n+  ige (3, 3, 1);\n+  ige (5, 2, 1);\n+\n+  return 0;\n+}"}, {"sha": "1f78a435a925283109aa847500df3f5b77d84878", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-2.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2004 Free Software Foundation.\n+\n+   Ensure that the composite comparison optimization doesn't misfire\n+   and attempt to combine an integer comparison with a floating-point one.\n+\n+   Written by Paolo Bonzini, 26th May 2004.  */\n+\n+extern void abort (void);\n+\n+int\n+foo (double x, double y)\n+{\n+  /* If miscompiled the following may become false.  */\n+  return (x > y) && ((int)x == (int)y);\n+}\n+\n+int\n+main ()\n+{\n+  if (! foo (1.3,1.0))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "03e6ff2c50667e5718087acb8838bc02ef916be1", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-3.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,97 @@\n+/* Copyright (C) 2004 Free Software Foundation.\n+\n+   Test for composite comparison always true/false optimization.\n+\n+   Written by Paolo Bonzini, 26th May 2004.  */\n+\n+extern void link_error0 ();\n+extern void link_error1 ();\n+\n+void\n+test1 (float x, float y)\n+{\n+  if ((x==y) && (x!=y))\n+    link_error0();\n+}\n+\n+void\n+test2 (float x, float y)\n+{\n+  if ((x<y) && (x>y))\n+    link_error0();\n+}\n+\n+void\n+test3 (float x, float y)\n+{\n+  if ((x<y) && (y<x))\n+    link_error0();\n+}\n+\n+void \n+test4 (float x, float y)\n+{\n+  if ((x==y) || (x!=y))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+test5 (float x, float y)\n+{\n+  if (__builtin_isunordered (x, y) || (x>=y) || (x<y))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+test6 (float x, float y)\n+{\n+  if (__builtin_isunordered (y, x) || (x<=y) || (y<x))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+test7 (float x, float y)\n+{\n+  if (__builtin_isunordered (x, y) || !__builtin_isunordered (x, y))\n+    {\n+    }\n+  else\n+    link_error1 ();\n+}\n+\n+void\n+all_tests (float x, float y)\n+{\n+  test1 (x, y);\n+  test2 (x, y);\n+  test3 (x, y);\n+  test4 (x, y);\n+  test5 (x, y);\n+  test6 (x, y);\n+  test7 (x, y);\n+}\n+\n+int\n+main ()\n+{\n+  all_tests (0, 0);\n+  all_tests (1, 2);\n+  all_tests (4, 3);\n+\n+  return 0;\n+}\n+\n+#ifndef __OPTIMIZE__\n+void link_error0() {}\n+void link_error1() {}\n+#endif /* ! __OPTIMIZE__ */\n+"}, {"sha": "3fc750e85af014e406b1360a1836f305b8e36527", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-3.x", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-3.x?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,2 @@\n+set options \"-fno-trapping-math\"\n+return 0"}, {"sha": "40fc9c0c3947b7ccf47c59a2ff63f926949a180f", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-4.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,190 @@\n+/* Copyright (C) 2004 Free Software Foundation.\n+\n+   Test for correctness of composite floating-point comparisons.\n+\n+   Written by Paolo Bonzini, 26th May 2004.  */\n+\n+extern void abort (void);\n+\n+#define TEST(c) if ((c) != ok) abort ();\n+#define ORD(a, b) (((a) < (b)) || (a) >= (b))\n+#define UNORD(a, b) (!ORD ((a), (b)))\n+#define UNEQ(a, b) (!LTGT ((a), (b)))\n+#define UNLT(a, b) (((a) < (b)) || __builtin_isunordered ((a), (b)))\n+#define UNLE(a, b) (((a) <= (b)) || __builtin_isunordered ((a), (b)))\n+#define UNGT(a, b) (((a) > (b)) || __builtin_isunordered ((a), (b)))\n+#define UNGE(a, b) (((a) >= (b)) || __builtin_isunordered ((a), (b)))\n+#define LTGT(a, b) (((a) < (b)) || (a) > (b))\n+\n+float pinf;\n+float ninf;\n+float NaN;\n+\n+int iuneq (float x, float y, int ok)\n+{\n+  TEST (UNEQ (x, y));\n+  TEST (!LTGT (x, y));\n+  TEST (UNLE (x, y) && UNGE (x,y));\n+}\n+\n+int ieq (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNEQ (x, y));\n+}\n+\n+int iltgt (float x, float y, int ok)\n+{\n+  TEST (!UNEQ (x, y));\n+  TEST (LTGT (x, y));\n+  TEST (ORD (x, y) && (UNLT (x, y) || UNGT (x,y)));\n+}\n+\n+int ine (float x, float y, int ok)\n+{\n+  TEST (UNLT (x, y) || UNGT (x, y));\n+  TEST ((x < y) || (x > y) || UNORD (x, y));\n+}\n+\n+int iunlt (float x, float y, int ok)\n+{\n+  TEST (UNLT (x, y));\n+  TEST (UNORD (x, y) || (x < y));\n+}\n+\n+int ilt (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNLT (x, y));\n+  TEST ((x <= y) && (x != y));\n+  TEST ((x <= y) && (y != x));\n+  TEST ((x != y) && (x <= y));\n+  TEST ((y != x) && (x <= y));\n+}\n+\n+int iunle (float x, float y, int ok)\n+{\n+  TEST (UNLE (x, y));\n+  TEST (UNORD (x, y) || (x <= y));\n+}\n+\n+int ile (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNLE (x, y));\n+  TEST ((x < y) || (x == y));\n+  TEST ((y > x) || (x == y));\n+  TEST ((x == y) || (x < y));\n+  TEST ((y == x) || (x < y));\n+}\n+\n+int iungt (float x, float y, int ok)\n+{\n+  TEST (UNGT (x, y));\n+  TEST (UNORD (x, y) || (x > y));\n+}\n+\n+int igt (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNGT (x, y));\n+  TEST ((x >= y) && (x != y));\n+  TEST ((x >= y) && (y != x));\n+  TEST ((x != y) && (x >= y));\n+  TEST ((y != x) && (x >= y));\n+}\n+\n+int iunge (float x, float y, int ok)\n+{\n+  TEST (UNGE (x, y));\n+  TEST (UNORD (x, y) || (x >= y));\n+}\n+\n+int ige (float x, float y, int ok)\n+{\n+  TEST (ORD (x, y) && UNGE (x, y));\n+  TEST ((x > y) || (x == y));\n+  TEST ((y < x) || (x == y));\n+  TEST ((x == y) || (x > y));\n+  TEST ((y == x) || (x > y));\n+}\n+\n+int\n+main ()\n+{\n+  pinf = __builtin_inf ();\n+  ninf = -__builtin_inf ();\n+  NaN = __builtin_nan (\"\");\n+\n+  iuneq (ninf, pinf, 0);\n+  iuneq (NaN, NaN, 1);\n+  iuneq (pinf, ninf, 0);\n+  iuneq (1, 4, 0);\n+  iuneq (3, 3, 1);\n+  iuneq (5, 2, 0);\n+\n+  ieq (1, 4, 0);\n+  ieq (3, 3, 1);\n+  ieq (5, 2, 0);\n+\n+  iltgt (ninf, pinf, 1);\n+  iltgt (NaN, NaN, 0);\n+  iltgt (pinf, ninf, 1);\n+  iltgt (1, 4, 1);\n+  iltgt (3, 3, 0);\n+  iltgt (5, 2, 1);\n+\n+  ine (1, 4, 1);\n+  ine (3, 3, 0);\n+  ine (5, 2, 1);\n+\n+  iunlt (NaN, ninf, 1);\n+  iunlt (pinf, NaN, 1);\n+  iunlt (pinf, ninf, 0);\n+  iunlt (pinf, pinf, 0);\n+  iunlt (ninf, ninf, 0);\n+  iunlt (1, 4, 1);\n+  iunlt (3, 3, 0);\n+  iunlt (5, 2, 0);\n+\n+  ilt (1, 4, 1);\n+  ilt (3, 3, 0);\n+  ilt (5, 2, 0);\n+\n+  iunle (NaN, ninf, 1);\n+  iunle (pinf, NaN, 1);\n+  iunle (pinf, ninf, 0);\n+  iunle (pinf, pinf, 1);\n+  iunle (ninf, ninf, 1);\n+  iunle (1, 4, 1);\n+  iunle (3, 3, 1);\n+  iunle (5, 2, 0);\n+\n+  ile (1, 4, 1);\n+  ile (3, 3, 1);\n+  ile (5, 2, 0);\n+\n+  iungt (NaN, ninf, 1);\n+  iungt (pinf, NaN, 1);\n+  iungt (pinf, ninf, 1);\n+  iungt (pinf, pinf, 0);\n+  iungt (ninf, ninf, 0);\n+  iungt (1, 4, 0);\n+  iungt (3, 3, 0);\n+  iungt (5, 2, 1);\n+\n+  igt (1, 4, 0);\n+  igt (3, 3, 0);\n+  igt (5, 2, 1);\n+\n+  iunge (NaN, ninf, 1);\n+  iunge (pinf, NaN, 1);\n+  iunge (ninf, pinf, 0);\n+  iunge (pinf, pinf, 1);\n+  iunge (ninf, ninf, 1);\n+  iunge (1, 4, 0);\n+  iunge (3, 3, 1);\n+  iunge (5, 2, 1);\n+\n+  ige (1, 4, 0);\n+  ige (3, 3, 1);\n+  ige (5, 2, 1);\n+\n+  return 0;\n+}"}, {"sha": "3fc750e85af014e406b1360a1836f305b8e36527", "filename": "gcc/testsuite/gcc.c-torture/execute/compare-fp-4.x", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fcompare-fp-4.x?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,2 @@\n+set options \"-fno-trapping-math\"\n+return 0"}, {"sha": "090209c916c99a4f6d4e70b7027ad16a2eb56a7c", "filename": "gcc/testsuite/gcc.dg/pr15649-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15649-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15649-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15649-1.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ffast-math -O2\" } */\n+\n+double foo (double x)\n+{\n+  return __builtin_isgreater (x, 0.0) ? 0.0 : x;\n+}"}, {"sha": "9b9fde5833cb96090db64be0276ec902280736cf", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -3194,6 +3194,7 @@ verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n+    case LTGT_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:"}, {"sha": "380f640af477ccab686c46a34e7f40fd57fbb880", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -1324,6 +1324,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n+    case LTGT_EXPR:\n \n     case CONVERT_EXPR:\n "}, {"sha": "ce1f750125a3aab7f62463b7cf52132704271669", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -905,6 +905,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n       {\n \tconst char *op = op_symbol (node);\n \top0 = TREE_OPERAND (node, 0);\n@@ -999,14 +1002,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_character (buffer, '>');\n       break;\n \n-    case UNORDERED_EXPR:\n-      NIY;\n-      break;\n-\n-    case ORDERED_EXPR:\n-      NIY;\n-      break;\n-\n     case IN_EXPR:\n       NIY;\n       break;\n@@ -1681,6 +1676,14 @@ op_prio (tree op)\n     case NE_EXPR:\n       return 9;\n \n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n     case LT_EXPR:\n     case LE_EXPR:\n     case GT_EXPR:\n@@ -1786,28 +1789,41 @@ op_symbol (tree op)\n     case BIT_AND_EXPR:\n       return \"&\";\n \n+    case ORDERED_EXPR:\n+      return \"ord\";\n+    case UNORDERED_EXPR:\n+      return \"unord\";\n+\n     case EQ_EXPR:\n-    case UNEQ_EXPR:\n       return \"==\";\n+    case UNEQ_EXPR:\n+      return \"u==\";\n \n     case NE_EXPR:\n       return \"!=\";\n \n     case LT_EXPR:\n-    case UNLT_EXPR:\n       return \"<\";\n+    case UNLT_EXPR:\n+      return \"u<\";\n \n     case LE_EXPR:\n-    case UNLE_EXPR:\n       return \"<=\";\n+    case UNLE_EXPR:\n+      return \"u<=\";\n \n     case GT_EXPR:\n-    case UNGT_EXPR:\n       return \">\";\n+    case UNGT_EXPR:\n+      return \"u>\";\n \n     case GE_EXPR:\n-    case UNGE_EXPR:\n       return \">=\";\n+    case UNGE_EXPR:\n+      return \"u>=\";\n+\n+    case LTGT_EXPR:\n+      return \"<>\";\n \n     case LSHIFT_EXPR:\n       return \"<<\";"}, {"sha": "b43950d824e461d4621194fcc67c6f2c08e47b6d", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a7edafe6a978e8f380a74f1f6d386d871bf417/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d1a7edafe6a978e8f380a74f1f6d386d871bf417", "patch": "@@ -681,6 +681,9 @@ DEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\n DEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\n DEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n \n+/* This is the reverse of uneq_expr.  */\n+DEFTREECODE (LTGT_EXPR, \"ltgt_expr\", '<', 2)\n+\n /* Operations for Pascal sets.  Not used now.  */\n DEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)\n DEFTREECODE (SET_LE_EXPR, \"set_le_expr\", '<', 2)"}]}