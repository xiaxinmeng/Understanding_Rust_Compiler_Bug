{"sha": "303ae446cf2ab1469d83e83f4cc5168c899c3cee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAzYWU0NDZjZjJhYjE0NjlkODNlODNmNGNjNTE2OGM4OTljM2NlZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-09-12T17:03:48Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-09-12T17:03:48Z"}, "message": "Initial revision\n\nFrom-SVN: r104179", "tree": {"sha": "0170290cacbeeb8eeda7d908ab69045d66908688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0170290cacbeeb8eeda7d908ab69045d66908688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/303ae446cf2ab1469d83e83f4cc5168c899c3cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303ae446cf2ab1469d83e83f4cc5168c899c3cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/303ae446cf2ab1469d83e83f4cc5168c899c3cee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303ae446cf2ab1469d83e83f4cc5168c899c3cee/comments", "author": null, "committer": null, "parents": [{"sha": "c4bea017edcaa8e18a00af00128a48800db92801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bea017edcaa8e18a00af00128a48800db92801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4bea017edcaa8e18a00af00128a48800db92801"}], "stats": {"total": 14036, "additions": 14036, "deletions": 0}, "files": [{"sha": "46b8638107fbd5317d7dc6576cd337e78f48346c", "filename": "zlib/contrib/ada/buffer_demo.adb", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fada%2Fbuffer_demo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fada%2Fbuffer_demo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fada%2Fbuffer_demo.adb?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,106 @@\n+----------------------------------------------------------------\n+--  ZLib for Ada thick binding.                               --\n+--                                                            --\n+--  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --\n+--                                                            --\n+--  Open source license information is in the zlib.ads file.  --\n+----------------------------------------------------------------\n+--\n+--  $Id: buffer_demo.adb,v 1.3 2004/09/06 06:55:35 vagul Exp $\n+\n+--  This demo program provided by Dr Steve Sangwine <sjs@essex.ac.uk>\n+--\n+--  Demonstration of a problem with Zlib-Ada (already fixed) when a buffer\n+--  of exactly the correct size is used for decompressed data, and the last\n+--  few bytes passed in to Zlib are checksum bytes.\n+\n+--  This program compresses a string of text, and then decompresses the\n+--  compressed text into a buffer of the same size as the original text.\n+\n+with Ada.Streams; use Ada.Streams;\n+with Ada.Text_IO;\n+\n+with ZLib; use ZLib;\n+\n+procedure Buffer_Demo is\n+   EOL  : Character renames ASCII.LF;\n+   Text : constant String\n+     := \"Four score and seven years ago our fathers brought forth,\" & EOL &\n+        \"upon this continent, a new nation, conceived in liberty,\" & EOL &\n+        \"and dedicated to the proposition that `all men are created equal'.\";\n+\n+   Source : Stream_Element_Array (1 .. Text'Length);\n+   for Source'Address use Text'Address;\n+\n+begin\n+   Ada.Text_IO.Put (Text);\n+   Ada.Text_IO.New_Line;\n+   Ada.Text_IO.Put_Line\n+     (\"Uncompressed size : \" & Positive'Image (Text'Length) & \" bytes\");\n+\n+   declare\n+      Compressed_Data : Stream_Element_Array (1 .. Text'Length);\n+      L               : Stream_Element_Offset;\n+   begin\n+      Compress : declare\n+         Compressor : Filter_Type;\n+         I : Stream_Element_Offset;\n+      begin\n+         Deflate_Init (Compressor);\n+\n+         --  Compress the whole of T at once.\n+\n+         Translate (Compressor, Source, I, Compressed_Data, L, Finish);\n+         pragma Assert (I = Source'Last);\n+\n+         Close (Compressor);\n+\n+         Ada.Text_IO.Put_Line\n+           (\"Compressed size :   \"\n+            & Stream_Element_Offset'Image (L) & \" bytes\");\n+      end Compress;\n+\n+      --  Now we decompress the data, passing short blocks of data to Zlib\n+      --  (because this demonstrates the problem - the last block passed will\n+      --  contain checksum information and there will be no output, only a\n+      --  check inside Zlib that the checksum is correct).\n+\n+      Decompress : declare\n+         Decompressor : Filter_Type;\n+\n+         Uncompressed_Data : Stream_Element_Array (1 .. Text'Length);\n+\n+         Block_Size : constant := 4;\n+         --  This makes sure that the last block contains\n+         --  only Adler checksum data.\n+\n+         P : Stream_Element_Offset := Compressed_Data'First - 1;\n+         O : Stream_Element_Offset;\n+      begin\n+         Inflate_Init (Decompressor);\n+\n+         loop\n+            Translate\n+              (Decompressor,\n+               Compressed_Data\n+                 (P + 1 .. Stream_Element_Offset'Min (P + Block_Size, L)),\n+               P,\n+               Uncompressed_Data\n+                 (Total_Out (Decompressor) + 1 .. Uncompressed_Data'Last),\n+               O,\n+               No_Flush);\n+\n+               Ada.Text_IO.Put_Line\n+                 (\"Total in : \" & Count'Image (Total_In (Decompressor)) &\n+                  \", out : \" & Count'Image (Total_Out (Decompressor)));\n+\n+               exit when P = L;\n+         end loop;\n+\n+         Ada.Text_IO.New_Line;\n+         Ada.Text_IO.Put_Line\n+           (\"Decompressed text matches original text : \"\n+             & Boolean'Image (Uncompressed_Data = Source));\n+      end Decompress;\n+   end;\n+end Buffer_Demo;"}, {"sha": "ed19cc9dcd9feb29bfd2ba3e5ac8b471222da9e2", "filename": "zlib/contrib/dotzlib/DotZLib.build", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.build", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.build", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.build?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,33 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n+<project name=\"DotZLib\" default=\"build\" basedir=\"./DotZLib\">\r\n+\t<description>A .Net wrapper library around ZLib1.dll</description>\r\n+\r\n+\t<property name=\"nunit.location\" value=\"c:/program files/NUnit V2.1/bin\" />\r\n+\t<property name=\"build.root\" value=\"bin\" />\r\n+\t\r\n+\t<property name=\"debug\" value=\"true\" />\r\n+\t<property name=\"nunit\" value=\"true\" />\r\n+\r\n+\t<property name=\"build.folder\" value=\"${build.root}/debug/\" if=\"${debug}\" />\r\n+\t<property name=\"build.folder\" value=\"${build.root}/release/\" unless=\"${debug}\" />\r\n+\r\n+\t<target name=\"clean\" description=\"Remove all generated files\">\r\n+\t\t<delete dir=\"${build.root}\" failonerror=\"false\" />\r\n+\t</target>\r\n+\r\n+\t<target name=\"build\" description=\"compiles the source code\">\r\n+\t\t\r\n+\t\t<mkdir dir=\"${build.folder}\" />\r\n+\t\t<csc target=\"library\" output=\"${build.folder}DotZLib.dll\" debug=\"${debug}\">\r\n+\t\t\t<references basedir=\"${nunit.location}\">\r\n+\t\t\t\t<includes if=\"${nunit}\" name=\"nunit.framework.dll\" />\r\n+\t\t\t</references>\r\n+\t\t\t<sources>\r\n+\t\t\t\t<includes name=\"*.cs\" />\r\n+\t\t\t\t<excludes name=\"UnitTests.cs\" unless=\"${nunit}\" />\r\n+\t\t\t</sources>\r\n+\t\t\t<arg value=\"/d:nunit\" if=\"${nunit}\" />\r\n+\t\t</csc>\r\n+\t</target>\r\n+\r\n+</project>\n\\ No newline at end of file"}, {"sha": "0bc7df76e407dcc69094483a6e9507240fe257ab", "filename": "zlib/contrib/dotzlib/DotZLib.chm", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.chm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.chm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.chm?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee"}, {"sha": "ac45ca048bdae8b5741164b46ef439948f18ade8", "filename": "zlib/contrib/dotzlib/DotZLib.sln", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib.sln?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,21 @@\n+Microsoft Visual Studio Solution File, Format Version 8.00\r\n+Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"DotZLib\", \"DotZLib\\DotZLib.csproj\", \"{BB1EE0B1-1808-46CB-B786-949D91117FC5}\"\r\n+\tProjectSection(ProjectDependencies) = postProject\r\n+\tEndProjectSection\r\n+EndProject\r\n+Global\r\n+\tGlobalSection(SolutionConfiguration) = preSolution\r\n+\t\tDebug = Debug\r\n+\t\tRelease = Release\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectConfiguration) = postSolution\r\n+\t\t{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.ActiveCfg = Debug|.NET\r\n+\t\t{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.Build.0 = Debug|.NET\r\n+\t\t{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.ActiveCfg = Release|.NET\r\n+\t\t{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.Build.0 = Release|.NET\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ExtensibilityAddIns) = postSolution\r\n+\tEndGlobalSection\r\n+EndGlobal\r"}, {"sha": "6fc0fdcc24ece4144a29443e1631d238b6e59b3c", "filename": "zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FAssemblyInfo.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FAssemblyInfo.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FAssemblyInfo.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,58 @@\n+using System.Reflection;\r\n+using System.Runtime.CompilerServices;\r\n+\r\n+//\r\n+// General Information about an assembly is controlled through the following \r\n+// set of attributes. Change these attribute values to modify the information\r\n+// associated with an assembly.\r\n+//\r\n+[assembly: AssemblyTitle(\"DotZLib\")]\r\n+[assembly: AssemblyDescription(\".Net bindings for ZLib compression dll 1.2.x\")]\r\n+[assembly: AssemblyConfiguration(\"\")]\r\n+[assembly: AssemblyCompany(\"Henrik Ravn\")]\r\n+[assembly: AssemblyProduct(\"\")]\r\n+[assembly: AssemblyCopyright(\"(c) 2004 by Henrik Ravn\")]\r\n+[assembly: AssemblyTrademark(\"\")]\r\n+[assembly: AssemblyCulture(\"\")]\t\t\r\n+\r\n+//\r\n+// Version information for an assembly consists of the following four values:\r\n+//\r\n+//      Major Version\r\n+//      Minor Version \r\n+//      Build Number\r\n+//      Revision\r\n+//\r\n+// You can specify all the values or you can default the Revision and Build Numbers \r\n+// by using the '*' as shown below:\r\n+\r\n+[assembly: AssemblyVersion(\"1.0.*\")]\r\n+\r\n+//\r\n+// In order to sign your assembly you must specify a key to use. Refer to the \r\n+// Microsoft .NET Framework documentation for more information on assembly signing.\r\n+//\r\n+// Use the attributes below to control which key is used for signing. \r\n+//\r\n+// Notes: \r\n+//   (*) If no key is specified, the assembly is not signed.\r\n+//   (*) KeyName refers to a key that has been installed in the Crypto Service\r\n+//       Provider (CSP) on your machine. KeyFile refers to a file which contains\r\n+//       a key.\r\n+//   (*) If the KeyFile and the KeyName values are both specified, the \r\n+//       following processing occurs:\r\n+//       (1) If the KeyName can be found in the CSP, that key is used.\r\n+//       (2) If the KeyName does not exist and the KeyFile does exist, the key \r\n+//           in the KeyFile is installed into the CSP and used.\r\n+//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.\r\n+//       When specifying the KeyFile, the location of the KeyFile should be\r\n+//       relative to the project output directory which is\r\n+//       %Project Directory%\\obj\\<configuration>. For example, if your KeyFile is\r\n+//       located in the project directory, you would specify the AssemblyKeyFile \r\n+//       attribute as [assembly: AssemblyKeyFile(\"..\\\\..\\\\mykey.snk\")]\r\n+//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework\r\n+//       documentation for more information on this.\r\n+//\r\n+[assembly: AssemblyDelaySign(false)]\r\n+[assembly: AssemblyKeyFile(\"\")]\r\n+[assembly: AssemblyKeyName(\"\")]\r"}, {"sha": "dfe7e90a8a1e040bf89ce9d01eda9ea53dafa6ce", "filename": "zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FChecksumImpl.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FChecksumImpl.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FChecksumImpl.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,202 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Runtime.InteropServices;\r\n+using System.Text;\r\n+\r\n+\r\n+namespace DotZLib\r\n+{\r\n+    #region ChecksumGeneratorBase\r\n+    /// <summary>\r\n+    /// Implements the common functionality needed for all <see cref=\"ChecksumGenerator\"/>s\r\n+    /// </summary>\r\n+    /// <example></example>\r\n+    public abstract class ChecksumGeneratorBase : ChecksumGenerator\r\n+    {\r\n+        /// <summary>\r\n+        /// The value of the current checksum\r\n+        /// </summary>\r\n+        protected uint _current;\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the checksum generator base - the current checksum is \r\n+        /// set to zero\r\n+        /// </summary>\r\n+        public ChecksumGeneratorBase()\r\n+        {\r\n+            _current = 0;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the checksum generator basewith a specified value\r\n+        /// </summary>\r\n+        /// <param name=\"initialValue\">The value to set the current checksum to</param>\r\n+        public ChecksumGeneratorBase(uint initialValue)\r\n+        {\r\n+            _current = initialValue;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Resets the current checksum to zero\r\n+        /// </summary>\r\n+        public void Reset() { _current = 0; }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the current checksum value\r\n+        /// </summary>\r\n+        public uint Value { get { return _current; } }\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with part of an array of bytes\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        /// <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n+        /// <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n+        /// <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n+        /// <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r\n+        /// <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one. \r\n+        /// This is therefore the only method a derived class has to implement</remarks>\r\n+        public abstract void Update(byte[] data, int offset, int count);\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with an array of bytes.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        public void Update(byte[] data)\r\n+        {\r\n+            Update(data, 0, data.Length);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with the data from a string\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The string to update the checksum with</param>\r\n+        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>\r\n+        public void Update(string data)\r\n+        {\r\n+\t\t\tUpdate(Encoding.UTF8.GetBytes(data));\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with the data from a string, using a specific encoding\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The string to update the checksum with</param>\r\n+        /// <param name=\"encoding\">The encoding to use</param>\r\n+        public void Update(string data, Encoding encoding)\r\n+        {\r\n+            Update(encoding.GetBytes(data));\r\n+        }\r\n+\r\n+    }\r\n+    #endregion\r\n+\r\n+    #region CRC32\r\n+    /// <summary>\r\n+    /// Implements a CRC32 checksum generator\r\n+    /// </summary>\r\n+    public sealed class CRC32Checksum : ChecksumGeneratorBase    \r\n+    {\r\n+        #region DLL imports\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern uint crc32(uint crc, int data, uint length);\r\n+\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the CRC32 checksum generator\r\n+        /// </summary>\r\n+        public CRC32Checksum() : base() {}\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the CRC32 checksum generator with a specified value\r\n+        /// </summary>\r\n+        /// <param name=\"initialValue\">The value to set the current checksum to</param>\r\n+        public CRC32Checksum(uint initialValue) : base(initialValue) {}\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with part of an array of bytes\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        /// <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n+        /// <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n+        /// <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n+        /// <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r\n+        public override void Update(byte[] data, int offset, int count)\r\n+        {\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > data.Length) throw new ArgumentException();\r\n+            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);\r\n+            try\r\n+            {\r\n+                _current = crc32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);\r\n+            }\r\n+            finally\r\n+            {\r\n+                hData.Free();\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+    #endregion\r\n+\r\n+    #region Adler\r\n+    /// <summary>\r\n+    /// Implements a checksum generator that computes the Adler checksum on data\r\n+    /// </summary>\r\n+    public sealed class AdlerChecksum : ChecksumGeneratorBase    \r\n+    {\r\n+        #region DLL imports\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern uint adler32(uint adler, int data, uint length);\r\n+\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the Adler checksum generator\r\n+        /// </summary>\r\n+        public AdlerChecksum() : base() {}\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the Adler checksum generator with a specified value\r\n+        /// </summary>\r\n+        /// <param name=\"initialValue\">The value to set the current checksum to</param>\r\n+        public AdlerChecksum(uint initialValue) : base(initialValue) {}\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with part of an array of bytes\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        /// <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n+        /// <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n+        /// <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n+        /// <exception cref=\"NullReferenceException\"><c>data</c> is a null reference</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r\n+        public override void Update(byte[] data, int offset, int count)\r\n+        {\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > data.Length) throw new ArgumentException();\r\n+            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);\r\n+            try\r\n+            {\r\n+                _current = adler32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);\r\n+            }\r\n+            finally\r\n+            {\r\n+                hData.Free();\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+    #endregion\r\n+\r\n+}\n\\ No newline at end of file"}, {"sha": "16997e906b681080f3c2a83085930d8988639d57", "filename": "zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCircularBuffer.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCircularBuffer.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCircularBuffer.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,83 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Diagnostics;\r\n+\r\n+namespace DotZLib\r\n+{\r\n+\r\n+\t/// <summary>\r\n+\t/// This class implements a circular buffer\r\n+\t/// </summary>\r\n+\tinternal class CircularBuffer\r\n+\t{\r\n+        #region Private data\r\n+        private int _capacity;\r\n+        private int _head;\r\n+        private int _tail;\r\n+        private int _size;\r\n+        private byte[] _buffer;\r\n+        #endregion\r\n+\r\n+        public CircularBuffer(int capacity)\r\n+        {    \r\n+            Debug.Assert( capacity > 0 );\r\n+            _buffer = new byte[capacity];\r\n+            _capacity = capacity;\r\n+            _head = 0;\r\n+            _tail = 0;\r\n+            _size = 0;\r\n+        }\r\n+\r\n+        public int Size { get { return _size; } }\r\n+\r\n+        public int Put(byte[] source, int offset, int count)\r\n+        {\r\n+            Debug.Assert( count > 0 );\r\n+            int trueCount = Math.Min(count, _capacity - Size);\r\n+            for (int i = 0; i < trueCount; ++i)\r\n+                _buffer[(_tail+i) % _capacity] = source[offset+i];\r\n+            _tail += trueCount;\r\n+            _tail %= _capacity;\r\n+            _size += trueCount;\r\n+            return trueCount;\r\n+        }\r\n+\r\n+        public bool Put(byte b)\r\n+        {\r\n+            if (Size == _capacity) // no room\r\n+                return false;\r\n+            _buffer[_tail++] = b;\r\n+            _tail %= _capacity;\r\n+            ++_size;\r\n+            return true;\r\n+        }\r\n+\r\n+        public int Get(byte[] destination, int offset, int count)\r\n+        {\r\n+            int trueCount = Math.Min(count,Size);\r\n+            for (int i = 0; i < trueCount; ++i)\r\n+                destination[offset + i] = _buffer[(_head+i) % _capacity];\r\n+            _head += trueCount;\r\n+            _head %= _capacity;\r\n+            _size -= trueCount;\r\n+            return trueCount;\r\n+        }\r\n+\r\n+        public int Get()\r\n+        {\r\n+            if (Size == 0)\r\n+                return -1;\r\n+\r\n+            int result = (int)_buffer[_head++ % _capacity];\r\n+            --_size;\r\n+            return result;\r\n+        }\r\n+\r\n+    }\r\n+}\r"}, {"sha": "954db7db05f0ef1a11012dc22573b2027b9548c4", "filename": "zlib/contrib/dotzlib/DotZLib/CodecBase.cs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCodecBase.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCodecBase.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FCodecBase.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,198 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Runtime.InteropServices;\r\n+\r\n+namespace DotZLib\r\n+{\r\n+\t/// <summary>\r\n+\t/// Implements the common functionality needed for all <see cref=\"Codec\"/>s\r\n+\t/// </summary>\r\n+\tpublic abstract class CodecBase : Codec, IDisposable\r\n+\t{\r\n+\r\n+        #region Data members\r\n+\r\n+        /// <summary>\r\n+        /// Instance of the internal zlib buffer structure that is \r\n+        /// passed to all functions in the zlib dll\r\n+        /// </summary>\r\n+        internal ZStream _ztream = new ZStream();\r\n+\r\n+        /// <summary>\r\n+        /// True if the object instance has been disposed, false otherwise\r\n+        /// </summary>\r\n+        protected bool _isDisposed = false;\r\n+\r\n+        /// <summary>\r\n+        /// The size of the internal buffers\r\n+        /// </summary>\r\n+        protected const int kBufferSize = 16384;\r\n+\r\n+        private byte[] _outBuffer = new byte[kBufferSize];\r\n+        private byte[] _inBuffer = new byte[kBufferSize];\r\n+\r\n+        private GCHandle _hInput;\r\n+        private GCHandle _hOutput;\r\n+\r\n+        private uint _checksum = 0;\r\n+\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the <c>CodeBase</c> class. \r\n+        /// </summary>\r\n+\t\tpublic CodecBase()\r\n+\t\t{\r\n+            try\r\n+            {\r\n+                _hInput = GCHandle.Alloc(_inBuffer, GCHandleType.Pinned);\r\n+                _hOutput = GCHandle.Alloc(_outBuffer, GCHandleType.Pinned);\r\n+            }\r\n+            catch (Exception)\r\n+            {\r\n+                CleanUp(false);\r\n+                throw;\r\n+            }\r\n+        }\r\n+\r\n+\r\n+        #region Codec Members\r\n+\r\n+        /// <summary>\r\n+        /// Occurs when more processed data are available.\r\n+        /// </summary>\r\n+        public event DataAvailableHandler DataAvailable;\r\n+\r\n+        /// <summary>\r\n+        /// Fires the <see cref=\"DataAvailable\"/> event\r\n+        /// </summary>\r\n+        protected void OnDataAvailable()\r\n+        {\r\n+            if (_ztream.total_out > 0)\r\n+            {\r\n+                if (DataAvailable != null)\r\n+                    DataAvailable( _outBuffer, 0, (int)_ztream.total_out); \r\n+                resetOutput();\r\n+            }\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        public void Add(byte[] data)\r\n+        {\r\n+            Add(data,0,data.Length);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n+        /// <param name=\"count\">The number of bytes to add</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        /// <remarks>This must be implemented by a derived class</remarks>\r\n+        public abstract void Add(byte[] data, int offset, int count);\r\n+\r\n+        /// <summary>\r\n+        /// Finishes up any pending data that needs to be processed and handled.\r\n+        /// </summary>\r\n+        /// <remarks>This must be implemented by a derived class</remarks>\r\n+        public abstract void Finish();\r\n+\r\n+        /// <summary>\r\n+        /// Gets the checksum of the data that has been added so far\r\n+        /// </summary>\r\n+        public uint Checksum { get { return _checksum; } }\r\n+\r\n+        #endregion\r\n+\r\n+        #region Destructor & IDisposable stuff\r\n+\r\n+        /// <summary>\r\n+        /// Destroys this instance\r\n+        /// </summary>\r\n+        ~CodecBase()\r\n+        {\r\n+            CleanUp(false);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Releases any unmanaged resources and calls the <see cref=\"CleanUp()\"/> method of the derived class\r\n+        /// </summary>\r\n+        public void Dispose()\r\n+        {\r\n+            CleanUp(true);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Performs any codec specific cleanup\r\n+        /// </summary>\r\n+        /// <remarks>This must be implemented by a derived class</remarks>\r\n+        protected abstract void CleanUp();\r\n+\r\n+        // performs the release of the handles and calls the dereived CleanUp()\r\n+        private void CleanUp(bool isDisposing)\r\n+        {\r\n+            if (!_isDisposed)\r\n+            {\r\n+                CleanUp();\r\n+                if (_hInput.IsAllocated)\r\n+                    _hInput.Free();\r\n+                if (_hOutput.IsAllocated)\r\n+                    _hOutput.Free();\r\n+\r\n+                _isDisposed = true;\r\n+            }\r\n+        }\r\n+\r\n+\r\n+        #endregion\r\n+\r\n+        #region Helper methods\r\n+\r\n+        /// <summary>\r\n+        /// Copies a number of bytes to the internal codec buffer - ready for proccesing\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The byte array that contains the data to copy</param>\r\n+        /// <param name=\"startIndex\">The index of the first byte to copy</param>\r\n+        /// <param name=\"count\">The number of bytes to copy from <c>data</c></param>\r\n+        protected void copyInput(byte[] data, int startIndex, int count)\r\n+        {\r\n+            Array.Copy(data, startIndex, _inBuffer,0, count);\r\n+            _ztream.next_in = _hInput.AddrOfPinnedObject();\r\n+            _ztream.total_in = 0;\r\n+            _ztream.avail_in = (uint)count;\r\n+\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Resets the internal output buffers to a known state - ready for processing\r\n+        /// </summary>\r\n+        protected void resetOutput()\r\n+        {\r\n+            _ztream.total_out = 0;\r\n+            _ztream.avail_out = kBufferSize;\r\n+            _ztream.next_out = _hOutput.AddrOfPinnedObject();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Updates the running checksum property\r\n+        /// </summary>\r\n+        /// <param name=\"newSum\">The new checksum value</param>\r\n+        protected void setChecksum(uint newSum)\r\n+        {\r\n+            _checksum = newSum;\r\n+        }\r\n+        #endregion\r\n+\r\n+    }\r\n+}\r"}, {"sha": "d7b8dcccac623a9a60f24931ef422632cfb2bde3", "filename": "zlib/contrib/dotzlib/DotZLib/Deflater.cs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDeflater.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDeflater.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDeflater.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,106 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Diagnostics;\r\n+using System.Runtime.InteropServices;\r\n+\r\n+namespace DotZLib\r\n+{\r\n+\r\n+    /// <summary>\r\n+    /// Implements a data compressor, using the deflate algorithm in the ZLib dll\r\n+    /// </summary>\r\n+\tpublic sealed class Deflater : CodecBase\r\n+\t{\r\n+        #region Dll imports\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]\r\n+        private static extern int deflateInit_(ref ZStream sz, int level, string vs, int size);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int deflate(ref ZStream sz, int flush);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int deflateReset(ref ZStream sz);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int deflateEnd(ref ZStream sz);\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Constructs an new instance of the <c>Deflater</c>\r\n+        /// </summary>\r\n+        /// <param name=\"level\">The compression level to use for this <c>Deflater</c></param>\r\n+\t\tpublic Deflater(CompressLevel level) : base()\r\n+\t\t{\r\n+            int retval = deflateInit_(ref _ztream, (int)level, Info.Version, Marshal.SizeOf(_ztream));\r\n+            if (retval != 0)\r\n+                throw new ZLibException(retval, \"Could not initialize deflater\");\r\n+\r\n+            resetOutput();\r\n+\t\t}\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n+        /// <param name=\"count\">The number of bytes to add</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        public override void Add(byte[] data, int offset, int count)\r\n+        {\r\n+            if (data == null) throw new ArgumentNullException();\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > data.Length) throw new ArgumentException();\r\n+            \r\n+            int total = count;\r\n+            int inputIndex = offset;\r\n+            int err = 0;\r\n+\r\n+            while (err >= 0 && inputIndex < total)\r\n+            {\r\n+                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));\r\n+                while (err >= 0 && _ztream.avail_in > 0)\r\n+                {\r\n+                    err = deflate(ref _ztream, (int)FlushTypes.None);\r\n+                    if (err == 0)\r\n+                        while (_ztream.avail_out == 0)\r\n+                        {\r\n+                            OnDataAvailable();\r\n+                            err = deflate(ref _ztream, (int)FlushTypes.None);\r\n+                        }\r\n+                    inputIndex += (int)_ztream.total_in;\r\n+                }\r\n+            }\r\n+            setChecksum( _ztream.adler );\r\n+        }\r\n+\r\n+\r\n+        /// <summary>\r\n+        /// Finishes up any pending data that needs to be processed and handled.\r\n+        /// </summary>\r\n+        public override void Finish()\r\n+        {\r\n+            int err;\r\n+            do \r\n+            {\r\n+                err = deflate(ref _ztream, (int)FlushTypes.Finish);\r\n+                OnDataAvailable();\r\n+            }\r\n+            while (err == 0);\r\n+            setChecksum( _ztream.adler );\r\n+            deflateReset(ref _ztream);\r\n+            resetOutput();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Closes the internal zlib deflate stream\r\n+        /// </summary>\r\n+        protected override void CleanUp() { deflateEnd(ref _ztream); }\r\n+\r\n+    }\r\n+}\r"}, {"sha": "410deb08851e94f87026fb5de0c0d6f8cb92b066", "filename": "zlib/contrib/dotzlib/DotZLib/DotZLib.cs", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,288 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.IO;\r\n+using System.Runtime.InteropServices;\r\n+using System.Text;\r\n+\r\n+\r\n+namespace DotZLib\r\n+{\r\n+\r\n+    #region Internal types\r\n+\r\n+    /// <summary>\r\n+    /// Defines constants for the various flush types used with zlib\r\n+    /// </summary>\r\n+    internal enum FlushTypes \r\n+    {\r\n+        None,  Partial,  Sync,  Full,  Finish,  Block\r\n+    }\r\n+\r\n+    #region ZStream structure\r\n+    // internal mapping of the zlib zstream structure for marshalling\r\n+    [StructLayoutAttribute(LayoutKind.Sequential, Pack=4, Size=0, CharSet=CharSet.Ansi)]\r\n+    internal struct ZStream\r\n+    {\r\n+        public IntPtr next_in;\r\n+        public uint avail_in;\r\n+        public uint total_in;\r\n+\r\n+        public IntPtr next_out;\r\n+        public uint avail_out;\r\n+        public uint total_out;\r\n+\r\n+        [MarshalAs(UnmanagedType.LPStr)]\r\n+        string msg; \r\n+        uint state;\r\n+\r\n+        uint zalloc;\r\n+        uint zfree;\r\n+        uint opaque;\r\n+\r\n+        int data_type;\r\n+        public uint adler;\r\n+        uint reserved;\r\n+    }\r\n+\r\n+    #endregion\r\n+    \r\n+    #endregion\r\n+\r\n+    #region Public enums\r\n+    /// <summary>\r\n+    /// Defines constants for the available compression levels in zlib\r\n+    /// </summary>\r\n+    public enum CompressLevel : int\r\n+    {\r\n+        /// <summary>\r\n+        /// The default compression level with a reasonable compromise between compression and speed\r\n+        /// </summary>\r\n+        Default = -1,   \r\n+        /// <summary>\r\n+        /// No compression at all. The data are passed straight through.\r\n+        /// </summary>\r\n+        None = 0,\r\n+        /// <summary>\r\n+        /// The maximum compression rate available.\r\n+        /// </summary>\r\n+        Best = 9,   \r\n+        /// <summary>\r\n+        /// The fastest available compression level.\r\n+        /// </summary>\r\n+        Fastest = 1\r\n+    }\r\n+    #endregion\r\n+\r\n+    #region Exception classes\r\n+    /// <summary>\r\n+    /// The exception that is thrown when an error occurs on the zlib dll\r\n+    /// </summary>\r\n+    public class ZLibException : ApplicationException\r\n+    {\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the <see cref=\"ZLibException\"/> class with a specified \r\n+        /// error message and error code\r\n+        /// </summary>\r\n+        /// <param name=\"errorCode\">The zlib error code that caused the exception</param>\r\n+        /// <param name=\"msg\">A message that (hopefully) describes the error</param>\r\n+        public ZLibException(int errorCode, string msg) : base(String.Format(\"ZLib error {0} {1}\", errorCode, msg))\r\n+        {\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Initializes a new instance of the <see cref=\"ZLibException\"/> class with a specified \r\n+        /// error code\r\n+        /// </summary>\r\n+        /// <param name=\"errorCode\">The zlib error code that caused the exception</param>\r\n+        public ZLibException(int errorCode) : base(String.Format(\"ZLib error {0}\", errorCode))\r\n+        {\r\n+        }\r\n+    }\r\n+    #endregion\r\n+\r\n+    #region Interfaces\r\n+\r\n+    /// <summary>\r\n+    /// Declares methods and properties that enables a running checksum to be calculated \r\n+    /// </summary>\r\n+    public interface ChecksumGenerator\r\n+    {\r\n+        /// <summary>\r\n+        /// Gets the current value of the checksum\r\n+        /// </summary>\r\n+        uint Value { get; }\r\n+\r\n+        /// <summary>\r\n+        /// Clears the current checksum to 0\r\n+        /// </summary>\r\n+        void Reset();\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with an array of bytes\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        void Update(byte[] data);\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with part of an array of bytes\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The data to update the checksum with</param>\r\n+        /// <param name=\"offset\">Where in <c>data</c> to start updating</param>\r\n+        /// <param name=\"count\">The number of bytes from <c>data</c> to use</param>\r\n+        /// <exception cref=\"ArgumentException\">The sum of offset and count is larger than the length of <c>data</c></exception>\r\n+        /// <exception cref=\"ArgumentNullException\"><c>data</c> is a null reference</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">Offset or count is negative.</exception>\r\n+        void Update(byte[] data, int offset, int count);\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with the data from a string\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The string to update the checksum with</param>\r\n+        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>\r\n+        void Update(string data);\r\n+\r\n+        /// <summary>\r\n+        /// Updates the current checksum with the data from a string, using a specific encoding\r\n+        /// </summary>\r\n+        /// <param name=\"data\">The string to update the checksum with</param>\r\n+        /// <param name=\"encoding\">The encoding to use</param>\r\n+        void Update(string data, Encoding encoding);\r\n+    }\r\n+\r\n+\r\n+    /// <summary>\r\n+    /// Represents the method that will be called from a codec when new data\r\n+    /// are available.\r\n+    /// </summary>\r\n+    /// <paramref name=\"data\">The byte array containing the processed data</paramref>\r\n+    /// <paramref name=\"startIndex\">The index of the first processed byte in <c>data</c></paramref>\r\n+    /// <paramref name=\"count\">The number of processed bytes available</paramref>\r\n+    /// <remarks>On return from this method, the data may be overwritten, so grab it while you can. \r\n+    /// You cannot assume that startIndex will be zero.\r\n+    /// </remarks>\r\n+    public delegate void DataAvailableHandler(byte[] data, int startIndex, int count);\r\n+\r\n+    /// <summary>\r\n+    /// Declares methods and events for implementing compressors/decompressors\r\n+    /// </summary>\r\n+    public interface Codec\r\n+    {\r\n+        /// <summary>\r\n+        /// Occurs when more processed data are available.\r\n+        /// </summary>\r\n+        event DataAvailableHandler DataAvailable;\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        void Add(byte[] data);\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n+        /// <param name=\"count\">The number of bytes to add</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        void Add(byte[] data, int offset, int count);\r\n+\r\n+        /// <summary>\r\n+        /// Finishes up any pending data that needs to be processed and handled.\r\n+        /// </summary>\r\n+        void Finish();\r\n+\r\n+        /// <summary>\r\n+        /// Gets the checksum of the data that has been added so far\r\n+        /// </summary>\r\n+        uint Checksum { get; }\r\n+\r\n+\r\n+    }\r\n+\r\n+    #endregion\r\n+\r\n+    #region Classes\r\n+    /// <summary>\r\n+    /// Encapsulates general information about the ZLib library\r\n+    /// </summary>\r\n+    public class Info\r\n+    {\r\n+        #region DLL imports\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern uint zlibCompileFlags();\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern string zlibVersion();\r\n+        #endregion\r\n+\r\n+        #region Private stuff\r\n+        private uint _flags;\r\n+\r\n+        // helper function that unpacks a bitsize mask\r\n+        private static int bitSize(uint bits)\r\n+        {\r\n+            switch (bits)\r\n+            {\r\n+                case 0: return 16;\r\n+                case 1: return 32;\r\n+                case 2: return 64;\r\n+            }\r\n+            return -1;\r\n+        }\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Constructs an instance of the <c>Info</c> class.\r\n+        /// </summary>\r\n+        public Info()\r\n+        {\r\n+            _flags = zlibCompileFlags();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// True if the library is compiled with debug info\r\n+        /// </summary>\r\n+        public bool HasDebugInfo { get { return 0 != (_flags & 0x100); } }\r\n+\r\n+        /// <summary>\r\n+        /// True if the library is compiled with assembly optimizations\r\n+        /// </summary>\r\n+        public bool UsesAssemblyCode { get { return 0 != (_flags & 0x200); } }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the size of the unsigned int that was compiled into Zlib\r\n+        /// </summary>\r\n+        public int SizeOfUInt { get { return bitSize(_flags & 3); } }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the size of the unsigned long that was compiled into Zlib\r\n+        /// </summary>\r\n+        public int SizeOfULong { get { return bitSize((_flags >> 2) & 3); } }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the size of the pointers that were compiled into Zlib\r\n+        /// </summary>\r\n+        public int SizeOfPointer { get { return bitSize((_flags >> 4) & 3); } }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the size of the z_off_t type that was compiled into Zlib\r\n+        /// </summary>\r\n+        public int SizeOfOffset { get { return bitSize((_flags >> 6) & 3); } }\r\n+\r\n+        /// <summary>\r\n+        /// Gets the version of ZLib as a string, e.g. \"1.2.1\"\r\n+        /// </summary>\r\n+        public static string Version { get { return zlibVersion(); } }\r\n+    }\r\n+\r\n+    #endregion\r\n+\r\n+}\r"}, {"sha": "71eeb8590af1715896813f9696bebf7d4d806d19", "filename": "zlib/contrib/dotzlib/DotZLib/DotZLib.csproj", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.csproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.csproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FDotZLib.csproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,141 @@\n+<VisualStudioProject>\r\n+    <CSHARP\r\n+        ProjectType = \"Local\"\r\n+        ProductVersion = \"7.10.3077\"\r\n+        SchemaVersion = \"2.0\"\r\n+        ProjectGuid = \"{BB1EE0B1-1808-46CB-B786-949D91117FC5}\"\r\n+    >\r\n+        <Build>\r\n+            <Settings\r\n+                ApplicationIcon = \"\"\r\n+                AssemblyKeyContainerName = \"\"\r\n+                AssemblyName = \"DotZLib\"\r\n+                AssemblyOriginatorKeyFile = \"\"\r\n+                DefaultClientScript = \"JScript\"\r\n+                DefaultHTMLPageLayout = \"Grid\"\r\n+                DefaultTargetSchema = \"IE50\"\r\n+                DelaySign = \"false\"\r\n+                OutputType = \"Library\"\r\n+                PreBuildEvent = \"\"\r\n+                PostBuildEvent = \"\"\r\n+                RootNamespace = \"DotZLib\"\r\n+                RunPostBuildEvent = \"OnBuildSuccess\"\r\n+                StartupObject = \"\"\r\n+            >\r\n+                <Config\r\n+                    Name = \"Debug\"\r\n+                    AllowUnsafeBlocks = \"false\"\r\n+                    BaseAddress = \"285212672\"\r\n+                    CheckForOverflowUnderflow = \"false\"\r\n+                    ConfigurationOverrideFile = \"\"\r\n+                    DefineConstants = \"DEBUG;TRACE\"\r\n+                    DocumentationFile = \"docs\\DotZLib.xml\"\r\n+                    DebugSymbols = \"true\"\r\n+                    FileAlignment = \"4096\"\r\n+                    IncrementalBuild = \"false\"\r\n+                    NoStdLib = \"false\"\r\n+                    NoWarn = \"1591\"\r\n+                    Optimize = \"false\"\r\n+                    OutputPath = \"bin\\Debug\\\"\r\n+                    RegisterForComInterop = \"false\"\r\n+                    RemoveIntegerChecks = \"false\"\r\n+                    TreatWarningsAsErrors = \"false\"\r\n+                    WarningLevel = \"4\"\r\n+                />\r\n+                <Config\r\n+                    Name = \"Release\"\r\n+                    AllowUnsafeBlocks = \"false\"\r\n+                    BaseAddress = \"285212672\"\r\n+                    CheckForOverflowUnderflow = \"false\"\r\n+                    ConfigurationOverrideFile = \"\"\r\n+                    DefineConstants = \"TRACE\"\r\n+                    DocumentationFile = \"docs\\DotZLib.xml\"\r\n+                    DebugSymbols = \"false\"\r\n+                    FileAlignment = \"4096\"\r\n+                    IncrementalBuild = \"false\"\r\n+                    NoStdLib = \"false\"\r\n+                    NoWarn = \"\"\r\n+                    Optimize = \"true\"\r\n+                    OutputPath = \"bin\\Release\\\"\r\n+                    RegisterForComInterop = \"false\"\r\n+                    RemoveIntegerChecks = \"false\"\r\n+                    TreatWarningsAsErrors = \"false\"\r\n+                    WarningLevel = \"4\"\r\n+                />\r\n+            </Settings>\r\n+            <References>\r\n+                <Reference\r\n+                    Name = \"System\"\r\n+                    AssemblyName = \"System\"\r\n+                    HintPath = \"C:\\WINNT\\Microsoft.NET\\Framework\\v1.1.4322\\System.dll\"\r\n+                />\r\n+                <Reference\r\n+                    Name = \"System.Data\"\r\n+                    AssemblyName = \"System.Data\"\r\n+                    HintPath = \"C:\\WINNT\\Microsoft.NET\\Framework\\v1.1.4322\\System.Data.dll\"\r\n+                />\r\n+                <Reference\r\n+                    Name = \"System.XML\"\r\n+                    AssemblyName = \"System.Xml\"\r\n+                    HintPath = \"C:\\WINNT\\Microsoft.NET\\Framework\\v1.1.4322\\System.XML.dll\"\r\n+                />\r\n+                <Reference\r\n+                    Name = \"nunit.framework\"\r\n+                    AssemblyName = \"nunit.framework\"\r\n+                    HintPath = \"E:\\apps\\NUnit V2.1\\\\bin\\nunit.framework.dll\"\r\n+                    AssemblyFolderKey = \"hklm\\dn\\nunit.framework\"\r\n+                />\r\n+            </References>\r\n+        </Build>\r\n+        <Files>\r\n+            <Include>\r\n+                <File\r\n+                    RelPath = \"AssemblyInfo.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"ChecksumImpl.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"CircularBuffer.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"CodecBase.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"Deflater.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"DotZLib.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"GZipStream.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"Inflater.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+                <File\r\n+                    RelPath = \"UnitTests.cs\"\r\n+                    SubType = \"Code\"\r\n+                    BuildAction = \"Compile\"\r\n+                />\r\n+            </Include>\r\n+        </Files>\r\n+    </CSHARP>\r\n+</VisualStudioProject>\r\n+\r"}, {"sha": "f861675b518ff730019e08af9869ace8d475a768", "filename": "zlib/contrib/dotzlib/DotZLib/GZipStream.cs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FGZipStream.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FGZipStream.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FGZipStream.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,301 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.IO;\r\n+using System.Runtime.InteropServices;\r\n+\r\n+namespace DotZLib\r\n+{\r\n+\t/// <summary>\r\n+\t/// Implements a compressed <see cref=\"Stream\"/>, in GZip (.gz) format.\r\n+\t/// </summary>\r\n+\tpublic class GZipStream : Stream, IDisposable\r\n+\t{\r\n+        #region Dll Imports\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]\r\n+        private static extern IntPtr gzopen(string name, string mode);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int gzclose(IntPtr gzFile);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int gzwrite(IntPtr gzFile, int data, int length);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int gzread(IntPtr gzFile, int data, int length);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int gzgetc(IntPtr gzFile);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int gzputc(IntPtr gzFile, int c);\r\n+\r\n+        #endregion\r\n+\r\n+        #region Private data\r\n+        private IntPtr _gzFile;\r\n+        private bool _isDisposed = false;\r\n+        private bool _isWriting;\r\n+        #endregion\r\n+\r\n+        #region Constructors\r\n+        /// <summary>\r\n+        /// Creates a new file as a writeable GZipStream\r\n+        /// </summary>\r\n+        /// <param name=\"fileName\">The name of the compressed file to create</param>\r\n+        /// <param name=\"level\">The compression level to use when adding data</param>\r\n+        /// <exception cref=\"ZLibException\">If an error occurred in the internal zlib function</exception>\r\n+\t\tpublic GZipStream(string fileName, CompressLevel level)\r\n+\t\t{\r\n+            _isWriting = true;\r\n+            _gzFile = gzopen(fileName, String.Format(\"wb{0}\", (int)level));\r\n+            if (_gzFile == IntPtr.Zero)\r\n+                throw new ZLibException(-1, \"Could not open \" + fileName);\r\n+\t\t}\r\n+\r\n+        /// <summary>\r\n+        /// Opens an existing file as a readable GZipStream\r\n+        /// </summary>\r\n+        /// <param name=\"fileName\">The name of the file to open</param>\r\n+        /// <exception cref=\"ZLibException\">If an error occurred in the internal zlib function</exception>\r\n+        public GZipStream(string fileName)\r\n+        {\r\n+            _isWriting = false;\r\n+            _gzFile = gzopen(fileName, \"rb\");\r\n+            if (_gzFile == IntPtr.Zero)\r\n+                throw new ZLibException(-1, \"Could not open \" + fileName);\r\n+\r\n+        }\r\n+        #endregion\r\n+\r\n+        #region Access properties\r\n+        /// <summary>\r\n+        /// Returns true of this stream can be read from, false otherwise\r\n+        /// </summary>\r\n+        public override bool CanRead\r\n+        {\r\n+            get\r\n+            {\r\n+                return !_isWriting;\r\n+            }\r\n+        }\r\n+    \r\n+\r\n+        /// <summary>\r\n+        /// Returns false.\r\n+        /// </summary>\r\n+        public override bool CanSeek\r\n+        {\r\n+            get\r\n+            {\r\n+                return false;\r\n+            }\r\n+        }\r\n+    \r\n+        /// <summary>\r\n+        /// Returns true if this tsream is writeable, false otherwise\r\n+        /// </summary>\r\n+        public override bool CanWrite\r\n+        {\r\n+            get\r\n+            {\r\n+                return _isWriting;\r\n+            }\r\n+        }\r\n+        #endregion\r\n+    \r\n+        #region Destructor & IDispose stuff\r\n+\r\n+        /// <summary>\r\n+        /// Destroys this instance\r\n+        /// </summary>\r\n+        ~GZipStream()\r\n+        {\r\n+            cleanUp(false);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Closes the external file handle\r\n+        /// </summary>\r\n+        public void Dispose()\r\n+        {\r\n+            cleanUp(true);\r\n+        }\r\n+\r\n+        // Does the actual closing of the file handle.\r\n+        private void cleanUp(bool isDisposing)\r\n+        {\r\n+            if (!_isDisposed)\r\n+            {\r\n+                gzclose(_gzFile);\r\n+                _isDisposed = true;\r\n+            }\r\n+        }\r\n+        #endregion\r\n+    \r\n+        #region Basic reading and writing\r\n+        /// <summary>\r\n+        /// Attempts to read a number of bytes from the stream.\r\n+        /// </summary>\r\n+        /// <param name=\"buffer\">The destination data buffer</param>\r\n+        /// <param name=\"offset\">The index of the first destination byte in <c>buffer</c></param>\r\n+        /// <param name=\"count\">The number of bytes requested</param>\r\n+        /// <returns>The number of bytes read</returns>\r\n+        /// <exception cref=\"ArgumentNullException\">If <c>buffer</c> is null</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">If <c>count</c> or <c>offset</c> are negative</exception>\r\n+        /// <exception cref=\"ArgumentException\">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>\r\n+        /// <exception cref=\"NotSupportedException\">If this stream is not readable.</exception>\r\n+        /// <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r\n+        public override int Read(byte[] buffer, int offset, int count)\r\n+        {\r\n+            if (!CanRead) throw new NotSupportedException();\r\n+            if (buffer == null) throw new ArgumentNullException();\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > buffer.Length) throw new ArgumentException();\r\n+            if (_isDisposed) throw new ObjectDisposedException(\"GZipStream\");\r\n+\r\n+            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);\r\n+            int result;\r\n+            try\r\n+            {\r\n+                result = gzread(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);\r\n+                if (result < 0)\r\n+                    throw new IOException();\r\n+            }\r\n+            finally\r\n+            {\r\n+                h.Free();\r\n+            }\r\n+            return result;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Attempts to read a single byte from the stream.\r\n+        /// </summary>\r\n+        /// <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>\r\n+        public override int ReadByte()\r\n+        {\r\n+            if (!CanRead) throw new NotSupportedException();\r\n+            if (_isDisposed) throw new ObjectDisposedException(\"GZipStream\");\r\n+            return gzgetc(_gzFile);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Writes a number of bytes to the stream\r\n+        /// </summary>\r\n+        /// <param name=\"buffer\"></param>\r\n+        /// <param name=\"offset\"></param>\r\n+        /// <param name=\"count\"></param>\r\n+        /// <exception cref=\"ArgumentNullException\">If <c>buffer</c> is null</exception>\r\n+        /// <exception cref=\"ArgumentOutOfRangeException\">If <c>count</c> or <c>offset</c> are negative</exception>\r\n+        /// <exception cref=\"ArgumentException\">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>\r\n+        /// <exception cref=\"NotSupportedException\">If this stream is not writeable.</exception>\r\n+        /// <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r\n+        public override void Write(byte[] buffer, int offset, int count)\r\n+        {\r\n+            if (!CanWrite) throw new NotSupportedException();\r\n+            if (buffer == null) throw new ArgumentNullException();\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > buffer.Length) throw new ArgumentException();\r\n+            if (_isDisposed) throw new ObjectDisposedException(\"GZipStream\");\r\n+\r\n+            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);\r\n+            try\r\n+            {\r\n+                int result = gzwrite(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);\r\n+                if (result < 0)\r\n+                    throw new IOException();\r\n+            }\r\n+            finally\r\n+            {\r\n+                h.Free();\r\n+            }\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Writes a single byte to the stream\r\n+        /// </summary>\r\n+        /// <param name=\"value\">The byte to add to the stream.</param>\r\n+        /// <exception cref=\"NotSupportedException\">If this stream is not writeable.</exception>\r\n+        /// <exception cref=\"ObjectDisposedException\">If this stream has been disposed.</exception>\r\n+        public override void WriteByte(byte value)\r\n+        {\r\n+            if (!CanWrite) throw new NotSupportedException();\r\n+            if (_isDisposed) throw new ObjectDisposedException(\"GZipStream\");\r\n+\r\n+            int result = gzputc(_gzFile, (int)value);\r\n+            if (result < 0)\r\n+                throw new IOException();\r\n+        }\r\n+        #endregion\r\n+\r\n+        #region Position & length stuff\r\n+        /// <summary>\r\n+        /// Not supported.\r\n+        /// </summary>\r\n+        /// <param name=\"value\"></param>\r\n+        /// <exception cref=\"NotSupportedException\">Always thrown</exception>\r\n+        public override void SetLength(long value)\r\n+        {\r\n+            throw new NotSupportedException();\r\n+        }\r\n+    \r\n+        /// <summary>\r\n+        ///  Not suppported.\r\n+        /// </summary>\r\n+        /// <param name=\"offset\"></param>\r\n+        /// <param name=\"origin\"></param>\r\n+        /// <returns></returns>\r\n+        /// <exception cref=\"NotSupportedException\">Always thrown</exception>\r\n+        public override long Seek(long offset, SeekOrigin origin)\r\n+        {\r\n+            throw new NotSupportedException();\r\n+        }\r\n+    \r\n+        /// <summary>\r\n+        /// Flushes the <c>GZipStream</c>.\r\n+        /// </summary>\r\n+        /// <remarks>In this implementation, this method does nothing. This is because excessive\r\n+        /// flushing may degrade the achievable compression rates.</remarks>\r\n+        public override void Flush()\r\n+        {\r\n+            // left empty on purpose\r\n+        }\r\n+    \r\n+        /// <summary>\r\n+        /// Gets/sets the current position in the <c>GZipStream</c>. Not suppported.\r\n+        /// </summary>\r\n+        /// <remarks>In this implementation this property is not supported</remarks>\r\n+        /// <exception cref=\"NotSupportedException\">Always thrown</exception>\r\n+        public override long Position\r\n+        {\r\n+            get\r\n+            {\r\n+                throw new NotSupportedException();\r\n+            }\r\n+            set\r\n+            {\r\n+                throw new NotSupportedException();\r\n+            }\r\n+        }\r\n+    \r\n+        /// <summary>\r\n+        /// Gets the size of the stream. Not suppported.\r\n+        /// </summary>\r\n+        /// <remarks>In this implementation this property is not supported</remarks>\r\n+        /// <exception cref=\"NotSupportedException\">Always thrown</exception>\r\n+        public override long Length\r\n+        {\r\n+            get\r\n+            {\r\n+                throw new NotSupportedException();\r\n+            }\r\n+        }\r\n+        #endregion\r\n+    }\r\n+}\r"}, {"sha": "4e60cda078b5ab212c1f682fe3005aaacea6c491", "filename": "zlib/contrib/dotzlib/DotZLib/Inflater.cs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FInflater.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FInflater.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FInflater.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,105 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Diagnostics;\r\n+using System.Runtime.InteropServices;\r\n+\r\n+namespace DotZLib\r\n+{\r\n+    \r\n+    /// <summary>\r\n+    /// Implements a data decompressor, using the inflate algorithm in the ZLib dll\r\n+    /// </summary>\r\n+    public class Inflater : CodecBase\r\n+\t{\r\n+        #region Dll imports\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]\r\n+        private static extern int inflateInit_(ref ZStream sz, string vs, int size);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int inflate(ref ZStream sz, int flush);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int inflateReset(ref ZStream sz);\r\n+\r\n+        [DllImport(\"ZLIB1.dll\", CallingConvention=CallingConvention.Cdecl)]\r\n+        private static extern int inflateEnd(ref ZStream sz);\r\n+        #endregion\r\n+\r\n+        /// <summary>\r\n+        /// Constructs an new instance of the <c>Inflater</c>\r\n+        /// </summary>\r\n+        public Inflater() : base()\r\n+\t\t{\r\n+            int retval = inflateInit_(ref _ztream, Info.Version, Marshal.SizeOf(_ztream));\r\n+            if (retval != 0)\r\n+                throw new ZLibException(retval, \"Could not initialize inflater\");\r\n+\r\n+            resetOutput();\r\n+        }\r\n+\r\n+\r\n+        /// <summary>\r\n+        /// Adds more data to the codec to be processed.\r\n+        /// </summary>\r\n+        /// <param name=\"data\">Byte array containing the data to be added to the codec</param>\r\n+        /// <param name=\"offset\">The index of the first byte to add from <c>data</c></param>\r\n+        /// <param name=\"count\">The number of bytes to add</param>\r\n+        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>\r\n+        public override void Add(byte[] data, int offset, int count)\r\n+        {\r\n+            if (data == null) throw new ArgumentNullException();\r\n+            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();\r\n+            if ((offset+count) > data.Length) throw new ArgumentException();\r\n+\r\n+            int total = count;\r\n+            int inputIndex = offset;\r\n+            int err = 0;\r\n+\r\n+            while (err >= 0 && inputIndex < total)\r\n+            {\r\n+                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));\r\n+                err = inflate(ref _ztream, (int)FlushTypes.None);\r\n+                if (err == 0)\r\n+                    while (_ztream.avail_out == 0)\r\n+                    {\r\n+                        OnDataAvailable();\r\n+                        err = inflate(ref _ztream, (int)FlushTypes.None);\r\n+                    }\r\n+\r\n+                inputIndex += (int)_ztream.total_in;\r\n+            }\r\n+            setChecksum( _ztream.adler );\r\n+        }\r\n+\r\n+\r\n+        /// <summary>\r\n+        /// Finishes up any pending data that needs to be processed and handled.\r\n+        /// </summary>\r\n+        public override void Finish()\r\n+        {\r\n+            int err;\r\n+            do \r\n+            {\r\n+                err = inflate(ref _ztream, (int)FlushTypes.Finish);\r\n+                OnDataAvailable();\r\n+            }\r\n+            while (err == 0);\r\n+            setChecksum( _ztream.adler );\r\n+            inflateReset(ref _ztream);\r\n+            resetOutput();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Closes the internal zlib inflate stream\r\n+        /// </summary>\r\n+        protected override void CleanUp() { inflateEnd(ref _ztream); }\r\n+\r\n+\r\n+\t}\r\n+}\r"}, {"sha": "8dc00db92dde21d3547fbe67016791f36a5d9e7f", "filename": "zlib/contrib/dotzlib/DotZLib/UnitTests.cs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FDotZLib%2FUnitTests.cs?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,274 @@\n+//\r\n+// \ufffd Copyright Henrik Ravn 2004\r\n+//\r\n+// Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r\n+//\r\n+\r\n+using System;\r\n+using System.Collections;\r\n+using System.IO;\r\n+\r\n+// uncomment the define below to include unit tests\r\n+//#define nunit\r\n+#if nunit\r\n+using NUnit.Framework;\r\n+\r\n+// Unit tests for the DotZLib class library\r\n+// ----------------------------------------\r\n+//\r\n+// Use this with NUnit 2 from http://www.nunit.org\r\n+//\r\n+\r\n+namespace DotZLibTests\r\n+{\r\n+    using DotZLib;\r\n+\r\n+    // helper methods\r\n+    internal class Utils\r\n+    {\r\n+        public static bool byteArrEqual( byte[] lhs, byte[] rhs )\r\n+        {\r\n+            if (lhs.Length != rhs.Length)\r\n+                return false;\r\n+            for (int i = lhs.Length-1; i >= 0; --i)\r\n+                if (lhs[i] != rhs[i])\r\n+                    return false;\r\n+            return true;\r\n+        }\r\n+\r\n+    }\r\n+\r\n+\r\n+    [TestFixture]\r\n+    public class CircBufferTests\r\n+    {\r\n+        #region Circular buffer tests\r\n+        [Test]\r\n+        public void SinglePutGet()\r\n+        {\r\n+            CircularBuffer buf = new CircularBuffer(10);\r\n+            Assert.AreEqual( 0, buf.Size );\r\n+            Assert.AreEqual( -1, buf.Get() );\r\n+\r\n+            Assert.IsTrue(buf.Put( 1 ));\r\n+            Assert.AreEqual( 1, buf.Size );\r\n+            Assert.AreEqual( 1, buf.Get() );\r\n+            Assert.AreEqual( 0, buf.Size );\r\n+            Assert.AreEqual( -1, buf.Get() );\r\n+        }\r\n+\r\n+        [Test]\r\n+        public void BlockPutGet()\r\n+        {\r\n+            CircularBuffer buf = new CircularBuffer(10);\r\n+            byte[] arr = {1,2,3,4,5,6,7,8,9,10};\r\n+            Assert.AreEqual( 10, buf.Put(arr,0,10) );\r\n+            Assert.AreEqual( 10, buf.Size );\r\n+            Assert.IsFalse( buf.Put(11) );\r\n+            Assert.AreEqual( 1, buf.Get() );\r\n+            Assert.IsTrue( buf.Put(11) );\r\n+\r\n+            byte[] arr2 = (byte[])arr.Clone();\r\n+            Assert.AreEqual( 9, buf.Get(arr2,1,9) );\r\n+            Assert.IsTrue( Utils.byteArrEqual(arr,arr2) );\r\n+        }\r\n+\r\n+        #endregion\r\n+    }\r\n+\r\n+    [TestFixture]\r\n+    public class ChecksumTests\r\n+    {\r\n+        #region CRC32 Tests\r\n+        [Test]\r\n+        public void CRC32_Null()\r\n+        {\r\n+            CRC32Checksum crc32 = new CRC32Checksum();\r\n+            Assert.AreEqual( 0, crc32.Value );\r\n+\r\n+            crc32 = new CRC32Checksum(1);\r\n+            Assert.AreEqual( 1, crc32.Value );\r\n+\r\n+            crc32 = new CRC32Checksum(556);\r\n+            Assert.AreEqual( 556, crc32.Value );\r\n+        }\r\n+\r\n+        [Test]\r\n+        public void CRC32_Data()\r\n+        {\r\n+            CRC32Checksum crc32 = new CRC32Checksum();\r\n+            byte[] data = { 1,2,3,4,5,6,7 };\r\n+            crc32.Update(data);\r\n+            Assert.AreEqual( 0x70e46888, crc32.Value  );\r\n+\r\n+            crc32 = new CRC32Checksum();\r\n+            crc32.Update(\"penguin\");\r\n+            Assert.AreEqual( 0x0e5c1a120, crc32.Value );\r\n+\r\n+            crc32 = new CRC32Checksum(1);\r\n+            crc32.Update(\"penguin\");\r\n+            Assert.AreEqual(0x43b6aa94, crc32.Value);\r\n+\r\n+        }\r\n+        #endregion\r\n+\r\n+        #region Adler tests\r\n+\r\n+        [Test]\r\n+        public void Adler_Null()\r\n+        {\r\n+            AdlerChecksum adler = new AdlerChecksum();\r\n+            Assert.AreEqual(0, adler.Value);\r\n+\r\n+            adler = new AdlerChecksum(1);\r\n+            Assert.AreEqual( 1, adler.Value );\r\n+\r\n+            adler = new AdlerChecksum(556);\r\n+            Assert.AreEqual( 556, adler.Value );\r\n+        }\r\n+\r\n+        [Test]\r\n+        public void Adler_Data()\r\n+        {\r\n+            AdlerChecksum adler = new AdlerChecksum(1);\r\n+            byte[] data = { 1,2,3,4,5,6,7 };\r\n+            adler.Update(data);\r\n+            Assert.AreEqual( 0x5b001d, adler.Value  );\r\n+\r\n+            adler = new AdlerChecksum();\r\n+            adler.Update(\"penguin\");\r\n+            Assert.AreEqual(0x0bcf02f6, adler.Value );\r\n+\r\n+            adler = new AdlerChecksum(1);\r\n+            adler.Update(\"penguin\");\r\n+            Assert.AreEqual(0x0bd602f7, adler.Value);\r\n+\r\n+        }\r\n+        #endregion\r\n+    }\r\n+\r\n+    [TestFixture]\r\n+    public class InfoTests\r\n+    {\r\n+        #region Info tests\r\n+        [Test]\r\n+        public void Info_Version()\r\n+        {\r\n+            Info info = new Info();\r\n+            Assert.AreEqual(\"1.2.3\", Info.Version);\r\n+            Assert.AreEqual(32, info.SizeOfUInt);\r\n+            Assert.AreEqual(32, info.SizeOfULong);\r\n+            Assert.AreEqual(32, info.SizeOfPointer);\r\n+            Assert.AreEqual(32, info.SizeOfOffset);\r\n+        }\r\n+        #endregion\r\n+    }\r\n+\r\n+    [TestFixture]\r\n+    public class DeflateInflateTests\r\n+    {\r\n+        #region Deflate tests\r\n+        [Test]\r\n+        public void Deflate_Init()\r\n+        {\r\n+            using (Deflater def = new Deflater(CompressLevel.Default))\r\n+            {\r\n+            }\r\n+        }\r\n+\r\n+        private ArrayList compressedData = new ArrayList();\r\n+        private uint adler1;\r\n+\r\n+        private ArrayList uncompressedData = new ArrayList();\r\n+        private uint adler2;\r\n+\r\n+        public void CDataAvail(byte[] data, int startIndex, int count)\r\n+        {\r\n+            for (int i = 0; i < count; ++i)\r\n+                compressedData.Add(data[i+startIndex]);\r\n+        }\r\n+\r\n+        [Test]\r\n+        public void Deflate_Compress()\r\n+        {\r\n+            compressedData.Clear();\r\n+\r\n+            byte[] testData = new byte[35000];\r\n+            for (int i = 0; i < testData.Length; ++i)\r\n+                testData[i] = 5;\r\n+\r\n+            using (Deflater def = new Deflater((CompressLevel)5))\r\n+            {\r\n+                def.DataAvailable += new DataAvailableHandler(CDataAvail);\r\n+                def.Add(testData);\r\n+                def.Finish();\r\n+                adler1 = def.Checksum;\r\n+            }\r\n+        }\r\n+        #endregion\r\n+\r\n+        #region Inflate tests\r\n+        [Test]\r\n+        public void Inflate_Init()\r\n+        {\r\n+            using (Inflater inf = new Inflater())\r\n+            {\r\n+            }\r\n+        }\r\n+\r\n+        private void DDataAvail(byte[] data, int startIndex, int count)\r\n+        {\r\n+            for (int i = 0; i < count; ++i)\r\n+                uncompressedData.Add(data[i+startIndex]);\r\n+        }\r\n+\r\n+        [Test]\r\n+        public void Inflate_Expand()\r\n+        { \r\n+            uncompressedData.Clear();\r\n+\r\n+            using (Inflater inf = new Inflater())\r\n+            {\r\n+                inf.DataAvailable += new DataAvailableHandler(DDataAvail);\r\n+                inf.Add((byte[])compressedData.ToArray(typeof(byte)));\r\n+                inf.Finish();\r\n+                adler2 = inf.Checksum;\r\n+            }\r\n+            Assert.AreEqual( adler1, adler2 );\r\n+        }\r\n+        #endregion\r\n+    }\r\n+\r\n+    [TestFixture]\r\n+    public class GZipStreamTests\r\n+    {\r\n+        #region GZipStream test\r\n+        [Test]\r\n+        public void GZipStream_WriteRead()\r\n+        {\r\n+            using (GZipStream gzOut = new GZipStream(\"gzstream.gz\", CompressLevel.Best))\r\n+            {\r\n+                BinaryWriter writer = new BinaryWriter(gzOut);\r\n+                writer.Write(\"hi there\");\r\n+                writer.Write(Math.PI);\r\n+                writer.Write(42);\r\n+            }\r\n+\r\n+            using (GZipStream gzIn = new GZipStream(\"gzstream.gz\"))\r\n+            {\r\n+                BinaryReader reader = new BinaryReader(gzIn);\r\n+                string s = reader.ReadString();\r\n+                Assert.AreEqual(\"hi there\",s);\r\n+                double d = reader.ReadDouble();\r\n+                Assert.AreEqual(Math.PI, d);\r\n+                int i = reader.ReadInt32();\r\n+                Assert.AreEqual(42,i);\r\n+            }\r\n+\r\n+        }\r\n+        #endregion\r\n+\t}\r\n+}\r\n+\r\n+#endif\n\\ No newline at end of file"}, {"sha": "30aac2cf4793f3aad92ef0a3c88731198c39566e", "filename": "zlib/contrib/dotzlib/LICENSE_1_0.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FLICENSE_1_0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2FLICENSE_1_0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2FLICENSE_1_0.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,23 @@\n+Boost Software License - Version 1.0 - August 17th, 2003\r\n+\r\n+Permission is hereby granted, free of charge, to any person or organization\r\n+obtaining a copy of the software and accompanying documentation covered by\r\n+this license (the \"Software\") to use, reproduce, display, distribute,\r\n+execute, and transmit the Software, and to prepare derivative works of the\r\n+Software, and to permit third-parties to whom the Software is furnished to\r\n+do so, all subject to the following:\r\n+\r\n+The copyright notices in the Software and this entire statement, including\r\n+the above license grant, this restriction and the following disclaimer,\r\n+must be included in all copies of the Software, in whole or in part, and\r\n+all derivative works of the Software, unless such copies or derivative\r\n+works are solely in the form of machine-executable object code generated by\r\n+a source language processor.\r\n+\r\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n+FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\r\n+SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\r\n+FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n+DEALINGS IN THE SOFTWARE.\n\\ No newline at end of file"}, {"sha": "210f4b00192684ae2e1f051d7f50306ea79e7719", "filename": "zlib/contrib/dotzlib/readme.txt", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fdotzlib%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdotzlib%2Freadme.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,58 @@\n+This directory contains a .Net wrapper class library for the ZLib1.dll\r\n+\r\n+The wrapper includes support for inflating/deflating memory buffers, \r\n+.Net streaming wrappers for the gz streams part of zlib, and wrappers\r\n+for the checksum parts of zlib. See DotZLib/UnitTests.cs for examples.\r\n+\r\n+Directory structure:\r\n+--------------------\r\n+\r\n+LICENSE_1_0.txt       - License file.\r\n+readme.txt            - This file.\r\n+DotZLib.chm           - Class library documentation\r\n+DotZLib.build         - NAnt build file\r\n+DotZLib.sln           - Microsoft Visual Studio 2003 solution file\r\n+\r\n+DotZLib\\*.cs          - Source files for the class library\r\n+\r\n+Unit tests:\r\n+-----------\r\n+The file DotZLib/UnitTests.cs contains unit tests for use with NUnit 2.1 or higher.\r\n+To include unit tests in the build, define nunit before building.\r\n+\r\n+\r\n+Build instructions:\r\n+-------------------\r\n+\r\n+1. Using Visual Studio.Net 2003:\r\n+   Open DotZLib.sln in VS.Net and build from there. Output file (DotZLib.dll)\r\n+   will be found ./DotZLib/bin/release or ./DotZLib/bin/debug, depending on \r\n+   you are building the release or debug version of the library. Check \r\n+   DotZLib/UnitTests.cs for instructions on how to include unit tests in the\r\n+   build.\r\n+   \r\n+2. Using NAnt:\r\n+   Open a command prompt with access to the build environment and run nant\r\n+   in the same directory as the DotZLib.build file.\r\n+   You can define 2 properties on the nant command-line to control the build:\r\n+   debug={true|false} to toggle between release/debug builds (default=true).\r\n+   nunit={true|false} to include or esclude unit tests (default=true).\r\n+   Also the target clean will remove binaries.\r\n+   Output file (DotZLib.dll) will be found in either ./DotZLib/bin/release \r\n+   or ./DotZLib/bin/debug, depending on whether you are building the release \r\n+   or debug version of the library.\r\n+\r\n+   Examples: \r\n+     nant -D:debug=false -D:nunit=false\r\n+       will build a release mode version of the library without unit tests.\r\n+     nant\r\n+       will build a debug version of the library with unit tests \r\n+     nant clean\r\n+       will remove all previously built files.\r\n+\r\n+\r\n+---------------------------------\r\n+Copyright (c) Henrik Ravn 2004\r\n+\r\n+Use, modification and distribution are subject to the Boost Software License, Version 1.0. \r\n+(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\r"}, {"sha": "8f9343d0afde424e852148fe93c57d39e4e1133e", "filename": "zlib/contrib/masmx64/bld_ml64.bat", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fbld_ml64.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fbld_ml64.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Fbld_ml64.bat?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,2 @@\n+ml64.exe /Flinffasx64 /c /Zi inffasx64.asm\r\n+ml64.exe /Flgvmat64   /c /Zi gvmat64.asm\r"}, {"sha": "790d65554a187a321bde709c97b1d0122d732bff", "filename": "zlib/contrib/masmx64/gvmat64.asm", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.asm?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,513 @@\n+;uInt longest_match_x64(\r\n+;    deflate_state *s,\r\n+;    IPos cur_match);                             /* current match */\r\n+\r\n+; gvmat64.asm -- Asm portion of the optimized longest_match for 32 bits x86\r\n+; Copyright (C) 1995-2005 Jean-loup Gailly, Brian Raiter and Gilles Vollant.\r\n+;\r\n+; File written by Gilles Vollant, by converting to assembly the longest_match\r\n+;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.\r\n+;\r\n+;  and by taking inspiration on asm686 with masm, optimised assembly code\r\n+;        from Brian Raiter, written 1998\r\n+;\r\n+;         http://www.zlib.net\r\n+;         http://www.winimage.com/zLibDll\r\n+;         http://www.muppetlabs.com/~breadbox/software/assembly.html\r\n+;\r\n+; to compile this file for infozip Zip, I use option:\r\n+;   ml64.exe /Flgvmat64 /c /Zi /DINFOZIP gvmat64.asm\r\n+;\r\n+; to compile this file for zLib, I use option:\r\n+;   ml64.exe /Flgvmat64 /c /Zi gvmat64.asm\r\n+; Be carrefull to adapt zlib1222add below to your version of zLib\r\n+;   (if you use a version of zLib before 1.0.4 or after 1.2.2.2, change\r\n+;    value of zlib1222add later)\r\n+;\r\n+; This file compile with Microsoft Macro Assembler (x64) for AMD64\r\n+;\r\n+;   ml64.exe is given with Visual Studio 2005 and Windows 2003 server DDK\r\n+;\r\n+;   (you can get Windows 2003 server DDK with ml64 and cl for AMD64 from\r\n+;      http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)\r\n+;\r\n+\r\n+\r\n+;uInt longest_match(s, cur_match)\r\n+;    deflate_state *s;\r\n+;    IPos cur_match;                             /* current match */\r\n+.code\r\n+longest_match PROC\r\n+\r\n+\r\n+;LocalVarsSize   equ 88\r\n+ LocalVarsSize   equ 72\r\n+\r\n+; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12\r\n+; free register :  r14,r15\r\n+; register can be saved : rsp\r\n+\r\n+ chainlenwmask   equ  rsp + 8 - LocalVarsSize    ; high word: current chain len\r\n+                                                 ; low word: s->wmask\r\n+;window          equ  rsp + xx - LocalVarsSize   ; local copy of s->window ; stored in r10\r\n+;windowbestlen   equ  rsp + xx - LocalVarsSize   ; s->window + bestlen , use r10+r11\r\n+;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w\r\n+;scanend         equ  rsp + xx - LocalVarsSize   ; last two bytes of string use ebx\r\n+;scanalign       equ  rsp + xx - LocalVarsSize   ; dword-misalignment of string r13\r\n+;bestlen         equ  rsp + xx - LocalVarsSize   ; size of best match so far -> r11d\r\n+;scan            equ  rsp + xx - LocalVarsSize   ; ptr to string wanting match -> r9\r\n+IFDEF INFOZIP\r\n+ELSE\r\n+ nicematch       equ  (rsp + 16 - LocalVarsSize) ; a good enough match size\r\n+ENDIF\r\n+\r\n+save_rdi        equ  rsp + 24 - LocalVarsSize\r\n+save_rsi        equ  rsp + 32 - LocalVarsSize\r\n+save_rbx        equ  rsp + 40 - LocalVarsSize\r\n+save_rbp        equ  rsp + 48 - LocalVarsSize\r\n+save_r12        equ  rsp + 56 - LocalVarsSize\r\n+save_r13        equ  rsp + 64 - LocalVarsSize\r\n+;save_r14        equ  rsp + 72 - LocalVarsSize\r\n+;save_r15        equ  rsp + 80 - LocalVarsSize\r\n+\r\n+\r\n+\r\n+;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\r\n+;  in the deflate_state structure since the asm code was first written\r\n+;  (if you compile with zlib 1.0.4 or older, remove the +4).\r\n+;  Note : these value are good with a 8 bytes boundary pack structure\r\n+\r\n+\r\n+    MAX_MATCH           equ     258\r\n+    MIN_MATCH           equ     3\r\n+    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\r\n+\r\n+\r\n+;;; Offsets for fields in the deflate_state structure. These numbers\r\n+;;; are calculated from the definition of deflate_state, with the\r\n+;;; assumption that the compiler will dword-align the fields. (Thus,\r\n+;;; changing the definition of deflate_state could easily cause this\r\n+;;; program to crash horribly, without so much as a warning at\r\n+;;; compile time. Sigh.)\r\n+\r\n+;  all the +zlib1222add offsets are due to the addition of fields\r\n+;  in zlib in the deflate_state structure since the asm code was first written\r\n+;  (if you compile with zlib 1.0.4 or older, use \"zlib1222add equ (-4)\").\r\n+;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use \"zlib1222add equ 0\").\r\n+;  if you compile with zlib 1.2.2.2 or later , use \"zlib1222add equ 8\").\r\n+\r\n+\r\n+IFDEF INFOZIP\r\n+\r\n+_DATA   SEGMENT\r\n+COMM    window_size:DWORD\r\n+; WMask ; 7fff\r\n+COMM    window:BYTE:010040H\r\n+COMM    prev:WORD:08000H\r\n+; MatchLen : unused\r\n+; PrevMatch : unused\r\n+COMM    strstart:DWORD\r\n+COMM    match_start:DWORD\r\n+; Lookahead : ignore\r\n+COMM    prev_length:DWORD ; PrevLen\r\n+COMM    max_chain_length:DWORD\r\n+COMM    good_match:DWORD\r\n+COMM    nice_match:DWORD\r\n+prev_ad equ OFFSET prev\r\n+window_ad equ OFFSET window\r\n+nicematch equ nice_match\r\n+_DATA ENDS\r\n+WMask equ 07fffh\r\n+\r\n+ELSE\r\n+\r\n+  IFNDEF zlib1222add\r\n+    zlib1222add equ 8\r\n+  ENDIF\r\n+dsWSize         equ 56+zlib1222add+(zlib1222add/2)\r\n+dsWMask         equ 64+zlib1222add+(zlib1222add/2)\r\n+dsWindow        equ 72+zlib1222add\r\n+dsPrev          equ 88+zlib1222add\r\n+dsMatchLen      equ 128+zlib1222add\r\n+dsPrevMatch     equ 132+zlib1222add\r\n+dsStrStart      equ 140+zlib1222add\r\n+dsMatchStart    equ 144+zlib1222add\r\n+dsLookahead     equ 148+zlib1222add\r\n+dsPrevLen       equ 152+zlib1222add\r\n+dsMaxChainLen   equ 156+zlib1222add\r\n+dsGoodMatch     equ 172+zlib1222add\r\n+dsNiceMatch     equ 176+zlib1222add\r\n+\r\n+window_size     equ [ rcx + dsWSize]\r\n+WMask           equ [ rcx + dsWMask]\r\n+window_ad       equ [ rcx + dsWindow]\r\n+prev_ad         equ [ rcx + dsPrev]\r\n+strstart        equ [ rcx + dsStrStart]\r\n+match_start     equ [ rcx + dsMatchStart]\r\n+Lookahead       equ [ rcx + dsLookahead] ; 0ffffffffh on infozip\r\n+prev_length     equ [ rcx + dsPrevLen]\r\n+max_chain_length equ [ rcx + dsMaxChainLen]\r\n+good_match      equ [ rcx + dsGoodMatch]\r\n+nice_match      equ [ rcx + dsNiceMatch]\r\n+ENDIF\r\n+\r\n+; parameter 1 in r8(deflate state s), param 2 in rdx (cur match)\r\n+\r\n+; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and\r\n+; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp\r\n+;\r\n+; All registers must be preserved across the call, except for\r\n+;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.\r\n+\r\n+\r\n+\r\n+;;; Save registers that the compiler may be using, and adjust esp to\r\n+;;; make room for our stack frame.\r\n+\r\n+\r\n+;;; Retrieve the function arguments. r8d will hold cur_match\r\n+;;; throughout the entire function. edx will hold the pointer to the\r\n+;;; deflate_state structure during the function's setup (before\r\n+;;; entering the main loop.\r\n+\r\n+; parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)\r\n+\r\n+; this clear high 32 bits of r8, which can be garbage in both r8 and rdx\r\n+\r\n+        mov [save_rdi],rdi\r\n+        mov [save_rsi],rsi\r\n+        mov [save_rbx],rbx\r\n+        mov [save_rbp],rbp\r\n+IFDEF INFOZIP\r\n+        mov r8d,ecx\r\n+ELSE\r\n+        mov r8d,edx\r\n+ENDIF\r\n+        mov [save_r12],r12\r\n+        mov [save_r13],r13\r\n+;        mov [save_r14],r14\r\n+;        mov [save_r15],r15\r\n+\r\n+\r\n+;;; uInt wmask = s->w_mask;\r\n+;;; unsigned chain_length = s->max_chain_length;\r\n+;;; if (s->prev_length >= s->good_match) {\r\n+;;;     chain_length >>= 2;\r\n+;;; }\r\n+\r\n+        mov edi, prev_length\r\n+        mov esi, good_match\r\n+        mov eax, WMask\r\n+        mov ebx, max_chain_length\r\n+        cmp edi, esi\r\n+        jl  LastMatchGood\r\n+        shr ebx, 2\r\n+LastMatchGood:\r\n+\r\n+;;; chainlen is decremented once beforehand so that the function can\r\n+;;; use the sign flag instead of the zero flag for the exit test.\r\n+;;; It is then shifted into the high word, to make room for the wmask\r\n+;;; value, which it will always accompany.\r\n+\r\n+        dec ebx\r\n+        shl ebx, 16\r\n+        or  ebx, eax\r\n+\r\n+;;; on zlib only\r\n+;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r\n+\r\n+IFDEF INFOZIP\r\n+        mov [chainlenwmask], ebx\r\n+; on infozip nice_match = [nice_match]\r\n+ELSE\r\n+        mov eax, nice_match\r\n+        mov [chainlenwmask], ebx\r\n+        mov r10d, Lookahead\r\n+        cmp r10d, eax\r\n+        cmovnl r10d, eax\r\n+        mov [nicematch],r10d\r\n+ENDIF\r\n+\r\n+;;; register Bytef *scan = s->window + s->strstart;\r\n+        mov r10, window_ad\r\n+        mov ebp, strstart\r\n+        lea r13, [r10 + rbp]\r\n+\r\n+;;; Determine how many bytes the scan ptr is off from being\r\n+;;; dword-aligned.\r\n+\r\n+         mov r9,r13\r\n+         neg r13\r\n+         and r13,3\r\n+\r\n+;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\r\n+;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;\r\n+IFDEF INFOZIP\r\n+        mov eax,07efah ; MAX_DIST = (WSIZE-MIN_LOOKAHEAD) (0x8000-(3+8+1))\r\n+ELSE\r\n+        mov eax, window_size\r\n+        sub eax, MIN_LOOKAHEAD\r\n+ENDIF\r\n+        xor edi,edi\r\n+        sub ebp, eax\r\n+\r\n+        mov r11d, prev_length\r\n+\r\n+        cmovng ebp,edi\r\n+\r\n+;;; int best_len = s->prev_length;\r\n+\r\n+\r\n+;;; Store the sum of s->window + best_len in esi locally, and in esi.\r\n+\r\n+       lea  rsi,[r10+r11]\r\n+\r\n+;;; register ush scan_start = *(ushf*)scan;\r\n+;;; register ush scan_end   = *(ushf*)(scan+best_len-1);\r\n+;;; Posf *prev = s->prev;\r\n+\r\n+        movzx r12d,word ptr [r9]\r\n+        movzx ebx, word ptr [r9 + r11 - 1]\r\n+\r\n+        mov rdi, prev_ad\r\n+\r\n+;;; Jump into the main loop.\r\n+\r\n+        mov edx, [chainlenwmask]\r\n+\r\n+        cmp bx,word ptr [rsi + r8 - 1]\r\n+        jz  LookupLoopIsZero\r\n+\r\n+LookupLoop1:\r\n+        and r8d, edx\r\n+\r\n+        movzx   r8d, word ptr [rdi + r8*2]\r\n+        cmp r8d, ebp\r\n+        jbe LeaveNow\r\n+        sub edx, 00010000h\r\n+        js  LeaveNow\r\n+\r\n+LoopEntry1:\r\n+        cmp bx,word ptr [rsi + r8 - 1]\r\n+        jz  LookupLoopIsZero\r\n+\r\n+LookupLoop2:\r\n+        and r8d, edx\r\n+\r\n+        movzx   r8d, word ptr [rdi + r8*2]\r\n+        cmp r8d, ebp\r\n+        jbe LeaveNow\r\n+        sub edx, 00010000h\r\n+        js  LeaveNow\r\n+\r\n+LoopEntry2:\r\n+        cmp bx,word ptr [rsi + r8 - 1]\r\n+        jz  LookupLoopIsZero\r\n+\r\n+LookupLoop4:\r\n+        and r8d, edx\r\n+\r\n+        movzx   r8d, word ptr [rdi + r8*2]\r\n+        cmp r8d, ebp\r\n+        jbe LeaveNow\r\n+        sub edx, 00010000h\r\n+        js  LeaveNow\r\n+\r\n+LoopEntry4:\r\n+\r\n+        cmp bx,word ptr [rsi + r8 - 1]\r\n+        jnz LookupLoop1\r\n+        jmp LookupLoopIsZero\r\n+\r\n+\r\n+;;; do {\r\n+;;;     match = s->window + cur_match;\r\n+;;;     if (*(ushf*)(match+best_len-1) != scan_end ||\r\n+;;;         *(ushf*)match != scan_start) continue;\r\n+;;;     [...]\r\n+;;; } while ((cur_match = prev[cur_match & wmask]) > limit\r\n+;;;          && --chain_length != 0);\r\n+;;;\r\n+;;; Here is the inner loop of the function. The function will spend the\r\n+;;; majority of its time in this loop, and majority of that time will\r\n+;;; be spent in the first ten instructions.\r\n+;;;\r\n+;;; Within this loop:\r\n+;;; ebx = scanend\r\n+;;; r8d = curmatch\r\n+;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)\r\n+;;; esi = windowbestlen - i.e., (window + bestlen)\r\n+;;; edi = prev\r\n+;;; ebp = limit\r\n+\r\n+LookupLoop:\r\n+        and r8d, edx\r\n+\r\n+        movzx   r8d, word ptr [rdi + r8*2]\r\n+        cmp r8d, ebp\r\n+        jbe LeaveNow\r\n+        sub edx, 00010000h\r\n+        js  LeaveNow\r\n+\r\n+LoopEntry:\r\n+\r\n+        cmp bx,word ptr [rsi + r8 - 1]\r\n+        jnz LookupLoop1\r\n+LookupLoopIsZero:\r\n+        cmp     r12w, word ptr [r10 + r8]\r\n+        jnz LookupLoop1\r\n+\r\n+\r\n+;;; Store the current value of chainlen.\r\n+        mov [chainlenwmask], edx\r\n+\r\n+;;; Point edi to the string under scrutiny, and esi to the string we\r\n+;;; are hoping to match it up with. In actuality, esi and edi are\r\n+;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is\r\n+;;; initialized to -(MAX_MATCH_8 - scanalign).\r\n+\r\n+        lea rsi,[r8+r10]\r\n+        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)\r\n+        lea rsi, [rsi + r13 + 0108h] ;MAX_MATCH_8]\r\n+        lea rdi, [r9 + r13 + 0108h] ;MAX_MATCH_8]\r\n+\r\n+        prefetcht1 [rsi+rdx]\r\n+        prefetcht1 [rdi+rdx]\r\n+\r\n+\r\n+;;; Test the strings for equality, 8 bytes at a time. At the end,\r\n+;;; adjust rdx so that it is offset to the exact byte that mismatched.\r\n+;;;\r\n+;;; We already know at this point that the first three bytes of the\r\n+;;; strings match each other, and they can be safely passed over before\r\n+;;; starting the compare loop. So what this code does is skip over 0-3\r\n+;;; bytes, as much as necessary in order to dword-align the edi\r\n+;;; pointer. (rsi will still be misaligned three times out of four.)\r\n+;;;\r\n+;;; It should be confessed that this loop usually does not represent\r\n+;;; much of the total running time. Replacing it with a more\r\n+;;; straightforward \"rep cmpsb\" would not drastically degrade\r\n+;;; performance.\r\n+\r\n+\r\n+LoopCmps:\r\n+        mov rax, [rsi + rdx]\r\n+        xor rax, [rdi + rdx]\r\n+        jnz LeaveLoopCmps\r\n+\r\n+        mov rax, [rsi + rdx + 8]\r\n+        xor rax, [rdi + rdx + 8]\r\n+        jnz LeaveLoopCmps8\r\n+\r\n+\r\n+        mov rax, [rsi + rdx + 8+8]\r\n+        xor rax, [rdi + rdx + 8+8]\r\n+        jnz LeaveLoopCmps16\r\n+\r\n+        add rdx,8+8+8\r\n+\r\n+        jmp short LoopCmps\r\n+LeaveLoopCmps16: add rdx,8\r\n+LeaveLoopCmps8: add rdx,8\r\n+LeaveLoopCmps:\r\n+\r\n+        test    eax, 0000FFFFh\r\n+        jnz LenLower\r\n+\r\n+        test eax,0ffffffffh\r\n+\r\n+        jnz LenLower32\r\n+\r\n+        add rdx,4\r\n+        shr rax,32\r\n+        or ax,ax\r\n+        jnz LenLower\r\n+\r\n+LenLower32:\r\n+        shr eax,16\r\n+        add rdx,2\r\n+LenLower:   sub al, 1\r\n+        adc rdx, 0\r\n+;;; Calculate the length of the match. If it is longer than MAX_MATCH,\r\n+;;; then automatically accept it as the best possible match and leave.\r\n+\r\n+        lea rax, [rdi + rdx]\r\n+        sub rax, r9\r\n+        cmp eax, MAX_MATCH\r\n+        jge LenMaximum\r\n+\r\n+;;; If the length of the match is not longer than the best match we\r\n+;;; have so far, then forget it and return to the lookup loop.\r\n+;///////////////////////////////////\r\n+\r\n+        cmp eax, r11d\r\n+        jg  LongerMatch\r\n+\r\n+        lea rsi,[r10+r11]\r\n+\r\n+        mov rdi, prev_ad\r\n+        mov edx, [chainlenwmask]\r\n+        jmp LookupLoop\r\n+\r\n+;;;         s->match_start = cur_match;\r\n+;;;         best_len = len;\r\n+;;;         if (len >= nice_match) break;\r\n+;;;         scan_end = *(ushf*)(scan+best_len-1);\r\n+\r\n+LongerMatch:\r\n+        mov r11d, eax\r\n+        mov match_start, r8d\r\n+        cmp eax, [nicematch]\r\n+        jge LeaveNow\r\n+\r\n+        lea rsi,[r10+rax]\r\n+\r\n+        movzx   ebx, word ptr [r9 + rax - 1]\r\n+        mov rdi, prev_ad\r\n+        mov edx, [chainlenwmask]\r\n+        jmp LookupLoop\r\n+\r\n+;;; Accept the current string, with the maximum possible length.\r\n+\r\n+LenMaximum:\r\n+        mov r11d,MAX_MATCH\r\n+        mov match_start, r8d\r\n+\r\n+;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\r\n+;;; return s->lookahead;\r\n+\r\n+LeaveNow:\r\n+IFDEF INFOZIP\r\n+        mov eax,r11d\r\n+ELSE\r\n+        mov eax, Lookahead\r\n+        cmp r11d, eax\r\n+        cmovng eax, r11d\r\n+ENDIF\r\n+\r\n+;;; Restore the stack and return from whence we came.\r\n+\r\n+\r\n+        mov rsi,[save_rsi]\r\n+        mov rdi,[save_rdi]\r\n+        mov rbx,[save_rbx]\r\n+        mov rbp,[save_rbp]\r\n+        mov r12,[save_r12]\r\n+        mov r13,[save_r13]\r\n+;        mov r14,[save_r14]\r\n+;        mov r15,[save_r15]\r\n+\r\n+\r\n+        ret 0\r\n+; please don't remove this string !\r\n+; Your can freely use gvmat64 in any free or commercial app\r\n+; but it is far better don't remove the string in the binary!\r\n+    db     0dh,0ah,\"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005\",0dh,0ah,0\r\n+longest_match   ENDP\r\n+\r\n+match_init PROC\r\n+  ret 0\r\n+match_init ENDP\r\n+\r\n+\r\n+END\r"}, {"sha": "a49ca029c63e24f907d7cd5d6eaa25f016c9aea5", "filename": "zlib/contrib/masmx64/gvmat64.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Fgvmat64.obj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee"}, {"sha": "3af764de9c8e6fb454043b6bc2bc3638bcd9a5b6", "filename": "zlib/contrib/masmx64/inffas8664.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffas8664.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffas8664.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Finffas8664.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,186 @@\n+/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding\r\n+ * version for AMD64 on Windows using Microsoft C compiler\r\n+ *\r\n+ * Copyright (C) 1995-2003 Mark Adler\r\n+ * For conditions of distribution and use, see copyright notice in zlib.h\r\n+ *\r\n+ * Copyright (C) 2003 Chris Anderson <christop@charm.net>\r\n+ * Please use the copyright conditions above.\r\n+ *\r\n+ * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant\r\n+ *\r\n+ * inffas8664.c call function inffas8664fnc in inffasx64.asm\r\n+ *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c\r\n+ *\r\n+ * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also\r\n+ * slightly quicker on x86 systems because, instead of using rep movsb to copy\r\n+ * data, it uses rep movsw, which moves data in 2-byte chunks instead of single\r\n+ * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates\r\n+ * from http://fedora.linux.duke.edu/fc1_x86_64\r\n+ * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with\r\n+ * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,\r\n+ * when decompressing mozilla-source-1.3.tar.gz.\r\n+ *\r\n+ * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from\r\n+ * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at\r\n+ * the moment.  I have successfully compiled and tested this code with gcc2.96,\r\n+ * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S\r\n+ * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX\r\n+ * enabled.  I will attempt to merge the MMX code into this version.  Newer\r\n+ * versions of this and inffast.S can be found at\r\n+ * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/\r\n+ *\r\n+ */\r\n+\r\n+#include <stdio.h>\r\n+#include \"zutil.h\"\r\n+#include \"inftrees.h\"\r\n+#include \"inflate.h\"\r\n+#include \"inffast.h\"\r\n+\r\n+/* Mark Adler's comments from inffast.c: */\r\n+\r\n+/*\r\n+   Decode literal, length, and distance codes and write out the resulting\r\n+   literal and match bytes until either not enough input or output is\r\n+   available, an end-of-block is encountered, or a data error is encountered.\r\n+   When large enough input and output buffers are supplied to inflate(), for\r\n+   example, a 16K input buffer and a 64K output buffer, more than 95% of the\r\n+   inflate execution time is spent in this routine.\r\n+\r\n+   Entry assumptions:\r\n+\r\n+        state->mode == LEN\r\n+        strm->avail_in >= 6\r\n+        strm->avail_out >= 258\r\n+        start >= strm->avail_out\r\n+        state->bits < 8\r\n+\r\n+   On return, state->mode is one of:\r\n+\r\n+        LEN -- ran out of enough output space or enough available input\r\n+        TYPE -- reached end of block code, inflate() to interpret next block\r\n+        BAD -- error in block data\r\n+\r\n+   Notes:\r\n+\r\n+    - The maximum input bits used by a length/distance pair is 15 bits for the\r\n+      length code, 5 bits for the length extra, 15 bits for the distance code,\r\n+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\r\n+      Therefore if strm->avail_in >= 6, then there is enough input to avoid\r\n+      checking for available input while decoding.\r\n+\r\n+    - The maximum bytes that a single length/distance pair can output is 258\r\n+      bytes, which is the maximum length that can be coded.  inflate_fast()\r\n+      requires strm->avail_out >= 258 for each loop to avoid checking for\r\n+      output space.\r\n+ */\r\n+\r\n+\r\n+\r\n+    typedef struct inffast_ar {\r\n+/* 64   32                               x86  x86_64 */\r\n+/* ar offset                              register */\r\n+/*  0    0 */ void *esp;                /* esp save */\r\n+/*  8    4 */ void *ebp;                /* ebp save */\r\n+/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */\r\n+/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */\r\n+/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */\r\n+/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */\r\n+/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */\r\n+/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */\r\n+/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */\r\n+/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */\r\n+/* 80   40 */ size_t /*unsigned long */hold;       /* edx rdx  local strm->hold */\r\n+/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */\r\n+/* 92   48 */ unsigned wsize;           /*          window size */\r\n+/* 96   52 */ unsigned write;           /*          window write index */\r\n+/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */\r\n+/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */\r\n+/*108   64 */ unsigned len;             /*     r14  match length */\r\n+/*112   68 */ unsigned dist;            /*     r15  match distance */\r\n+/*116   72 */ unsigned status;          /*          set when state chng*/\r\n+    } type_ar;\r\n+#ifdef ASMINF\r\n+\r\n+void inflate_fast(strm, start)\r\n+z_streamp strm;\r\n+unsigned start;         /* inflate()'s starting value for strm->avail_out */\r\n+{\r\n+    struct inflate_state FAR *state;\r\n+    type_ar ar;\r\n+    void inffas8664fnc(struct inffast_ar * par);\r\n+\r\n+    \r\n+\r\n+#if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))\r\n+#define PAD_AVAIL_IN 6\r\n+#define PAD_AVAIL_OUT 258    \r\n+#else\r\n+#define PAD_AVAIL_IN 5\r\n+#define PAD_AVAIL_OUT 257\r\n+#endif\r\n+\r\n+    /* copy state to local variables */\r\n+    state = (struct inflate_state FAR *)strm->state;\r\n+\r\n+    ar.in = strm->next_in;\r\n+    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);\r\n+    ar.out = strm->next_out;\r\n+    ar.beg = ar.out - (start - strm->avail_out);\r\n+    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);\r\n+    ar.wsize = state->wsize;\r\n+    ar.write = state->write;\r\n+    ar.window = state->window;\r\n+    ar.hold = state->hold;\r\n+    ar.bits = state->bits;\r\n+    ar.lcode = state->lencode;\r\n+    ar.dcode = state->distcode;\r\n+    ar.lmask = (1U << state->lenbits) - 1;\r\n+    ar.dmask = (1U << state->distbits) - 1;\r\n+\r\n+    /* decode literals and length/distances until end-of-block or not enough\r\n+       input data or output space */\r\n+\r\n+    /* align in on 1/2 hold size boundary */\r\n+    while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {\r\n+        ar.hold += (unsigned long)*ar.in++ << ar.bits;\r\n+        ar.bits += 8;\r\n+    }\r\n+\r\n+    inffas8664fnc(&ar);\r\n+\r\n+    if (ar.status > 1) {\r\n+        if (ar.status == 2)\r\n+            strm->msg = \"invalid literal/length code\";\r\n+        else if (ar.status == 3)\r\n+            strm->msg = \"invalid distance code\";\r\n+        else\r\n+            strm->msg = \"invalid distance too far back\";\r\n+        state->mode = BAD;\r\n+    }\r\n+    else if ( ar.status == 1 ) {\r\n+        state->mode = TYPE;\r\n+    }\r\n+\r\n+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\r\n+    ar.len = ar.bits >> 3;\r\n+    ar.in -= ar.len;\r\n+    ar.bits -= ar.len << 3;\r\n+    ar.hold &= (1U << ar.bits) - 1;\r\n+\r\n+    /* update state and return */\r\n+    strm->next_in = ar.in;\r\n+    strm->next_out = ar.out;\r\n+    strm->avail_in = (unsigned)(ar.in < ar.last ?\r\n+                                PAD_AVAIL_IN + (ar.last - ar.in) :\r\n+                                PAD_AVAIL_IN - (ar.in - ar.last));\r\n+    strm->avail_out = (unsigned)(ar.out < ar.end ?\r\n+                                 PAD_AVAIL_OUT + (ar.end - ar.out) :\r\n+                                 PAD_AVAIL_OUT - (ar.out - ar.end));\r\n+    state->hold = (unsigned long)ar.hold;\r\n+    state->bits = ar.bits;\r\n+    return;\r\n+}\r\n+\r\n+#endif\r"}, {"sha": "b5d93a272abc46d4676b4a0f5ced980bbbd2bbfd", "filename": "zlib/contrib/masmx64/inffasx64.asm", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.asm?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,392 @@\n+; inffasx64.asm is a hand tuned assembler version of inffast.c - fast decoding\r\n+; version for AMD64 on Windows using Microsoft C compiler\r\n+;\r\n+; inffasx64.asm is automatically convert from AMD64 portion of inffas86.c\r\n+; inffasx64.asm is called by inffas8664.c, which contain more info.\r\n+\r\n+\r\n+; to compile this file, I use option\r\n+;   ml64.exe /Flinffasx64 /c /Zi inffasx64.asm\r\n+;   with Microsoft Macro Assembler (x64) for AMD64\r\n+;\r\n+;   ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK\r\n+;\r\n+;   (you can get Windows 2003 server DDK with ml64 and cl.exe for AMD64 from \r\n+;      http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)\r\n+;\r\n+\r\n+.code\r\n+inffas8664fnc PROC\r\n+\r\n+; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and\r\n+; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp\r\n+;\r\n+; All registers must be preserved across the call, except for\r\n+;   rax, rcx, rdx, r8, r-9, r10, and r11, which are scratch.\r\n+\r\n+\r\n+\tmov [rsp-8],rsi\r\n+\tmov [rsp-16],rdi\r\n+\tmov [rsp-24],r12\r\n+\tmov [rsp-32],r13\r\n+\tmov [rsp-40],r14\r\n+\tmov [rsp-48],r15\r\n+\tmov [rsp-56],rbx\r\n+\r\n+\tmov rax,rcx\r\n+\r\n+\tmov\t[rax+8], rbp       ; /* save regs rbp and rsp */\r\n+\tmov\t[rax], rsp\r\n+\r\n+\tmov\trsp, rax          ; /* make rsp point to &ar */\r\n+\r\n+\tmov\trsi, [rsp+16]      ; /* rsi  = in */\r\n+\tmov\trdi, [rsp+32]      ; /* rdi  = out */\r\n+\tmov\tr9, [rsp+24]       ; /* r9   = last */\r\n+\tmov\tr10, [rsp+48]      ; /* r10  = end */\r\n+\tmov\trbp, [rsp+64]      ; /* rbp  = lcode */\r\n+\tmov\tr11, [rsp+72]      ; /* r11  = dcode */\r\n+\tmov\trdx, [rsp+80]      ; /* rdx  = hold */\r\n+\tmov\tebx, [rsp+88]      ; /* ebx  = bits */\r\n+\tmov\tr12d, [rsp+100]    ; /* r12d = lmask */\r\n+\tmov\tr13d, [rsp+104]    ; /* r13d = dmask */\r\n+                                          ; /* r14d = len */\r\n+                                          ; /* r15d = dist */\r\n+\r\n+\r\n+\tcld\r\n+\tcmp\tr10, rdi\r\n+\tje\tL_one_time           ; /* if only one decode left */\r\n+\tcmp\tr9, rsi\r\n+\r\n+    jne L_do_loop\r\n+\r\n+\r\n+L_one_time:\r\n+\tmov\tr8, r12           ; /* r8 = lmask */\r\n+\tcmp\tbl, 32\r\n+\tja\tL_get_length_code_one_time\r\n+\r\n+\tlodsd                         ; /* eax = *(uint *)in++ */\r\n+\tmov\tcl, bl            ; /* cl = bits, needs it for shifting */\r\n+\tadd\tbl, 32             ; /* bits += 32 */\r\n+\tshl\trax, cl\r\n+\tor\trdx, rax          ; /* hold |= *((uint *)in)++ << bits */\r\n+\tjmp\tL_get_length_code_one_time\r\n+\r\n+ALIGN 4\r\n+L_while_test:\r\n+\tcmp\tr10, rdi\r\n+\tjbe\tL_break_loop\r\n+\tcmp\tr9, rsi\r\n+\tjbe\tL_break_loop\r\n+\r\n+L_do_loop:\r\n+\tmov\tr8, r12           ; /* r8 = lmask */\r\n+\tcmp\tbl, 32\r\n+\tja\tL_get_length_code    ; /* if (32 < bits) */\r\n+\r\n+\tlodsd                         ; /* eax = *(uint *)in++ */\r\n+\tmov\tcl, bl            ; /* cl = bits, needs it for shifting */\r\n+\tadd\tbl, 32             ; /* bits += 32 */\r\n+\tshl\trax, cl\r\n+\tor\trdx, rax          ; /* hold |= *((uint *)in)++ << bits */\r\n+\r\n+L_get_length_code:\r\n+\tand\tr8, rdx            ; /* r8 &= hold */\r\n+\tmov\teax, [rbp+r8*4]  ; /* eax = lcode[hold & lmask] */\r\n+\r\n+\tmov\tcl, ah            ; /* cl = this.bits */\r\n+\tsub\tbl, ah            ; /* bits -= this.bits */\r\n+\tshr\trdx, cl           ; /* hold >>= this.bits */\r\n+\r\n+\ttest\tal, al\r\n+\tjnz\tL_test_for_length_base ; /* if (op != 0) 45.7% */\r\n+\r\n+\tmov\tr8, r12            ; /* r8 = lmask */\r\n+\tshr\teax, 16            ; /* output this.val char */\r\n+\tstosb\r\n+\r\n+L_get_length_code_one_time:\r\n+\tand\tr8, rdx            ; /* r8 &= hold */\r\n+\tmov\teax, [rbp+r8*4] ; /* eax = lcode[hold & lmask] */\r\n+\r\n+L_dolen:\r\n+\tmov\tcl, ah            ; /* cl = this.bits */\r\n+\tsub\tbl, ah            ; /* bits -= this.bits */\r\n+\tshr\trdx, cl           ; /* hold >>= this.bits */\r\n+\r\n+\ttest\tal, al\r\n+\tjnz\tL_test_for_length_base ; /* if (op != 0) 45.7% */\r\n+\r\n+\tshr\teax, 16            ; /* output this.val char */\r\n+\tstosb\r\n+\tjmp\tL_while_test\r\n+\r\n+ALIGN 4\r\n+L_test_for_length_base:\r\n+\tmov\tr14d, eax         ; /* len = this */\r\n+\tshr\tr14d, 16           ; /* len = this.val */\r\n+\tmov\tcl, al\r\n+\r\n+\ttest\tal, 16\r\n+\tjz\tL_test_for_second_level_length ; /* if ((op & 16) == 0) 8% */\r\n+\tand\tcl, 15             ; /* op &= 15 */\r\n+\tjz\tL_decode_distance    ; /* if (!op) */\r\n+\r\n+L_add_bits_to_len:\r\n+\tsub\tbl, cl\r\n+\txor\teax, eax\r\n+\tinc\teax\r\n+\tshl\teax, cl\r\n+\tdec\teax\r\n+\tand\teax, edx          ; /* eax &= hold */\r\n+\tshr\trdx, cl\r\n+\tadd\tr14d, eax         ; /* len += hold & mask[op] */\r\n+\r\n+L_decode_distance:\r\n+\tmov\tr8, r13           ; /* r8 = dmask */\r\n+\tcmp\tbl, 32\r\n+\tja\tL_get_distance_code  ; /* if (32 < bits) */\r\n+\r\n+\tlodsd                         ; /* eax = *(uint *)in++ */\r\n+\tmov\tcl, bl            ; /* cl = bits, needs it for shifting */\r\n+\tadd\tbl, 32             ; /* bits += 32 */\r\n+\tshl\trax, cl\r\n+\tor\trdx, rax          ; /* hold |= *((uint *)in)++ << bits */\r\n+\r\n+L_get_distance_code:\r\n+\tand\tr8, rdx           ; /* r8 &= hold */\r\n+\tmov\teax, [r11+r8*4] ; /* eax = dcode[hold & dmask] */\r\n+\r\n+L_dodist:\r\n+\tmov\tr15d, eax         ; /* dist = this */\r\n+\tshr\tr15d, 16           ; /* dist = this.val */\r\n+\tmov\tcl, ah\r\n+\tsub\tbl, ah            ; /* bits -= this.bits */\r\n+\tshr\trdx, cl           ; /* hold >>= this.bits */\r\n+\tmov\tcl, al            ; /* cl = this.op */\r\n+\r\n+\ttest\tal, 16             ; /* if ((op & 16) == 0) */\r\n+\tjz\tL_test_for_second_level_dist\r\n+\tand\tcl, 15             ; /* op &= 15 */\r\n+\tjz\tL_check_dist_one\r\n+\r\n+L_add_bits_to_dist:\r\n+\tsub\tbl, cl\r\n+\txor\teax, eax\r\n+\tinc\teax\r\n+\tshl\teax, cl\r\n+\tdec\teax                 ; /* (1 << op) - 1 */\r\n+\tand\teax, edx          ; /* eax &= hold */\r\n+\tshr\trdx, cl\r\n+\tadd\tr15d, eax         ; /* dist += hold & ((1 << op) - 1) */\r\n+\r\n+L_check_window:\r\n+\tmov\tr8, rsi           ; /* save in so from can use it's reg */\r\n+\tmov\trax, rdi\r\n+\tsub\trax, [rsp+40]      ; /* nbytes = out - beg */\r\n+\r\n+\tcmp\teax, r15d\r\n+\tjb\tL_clip_window        ; /* if (dist > nbytes) 4.2% */\r\n+\r\n+\tmov\tecx, r14d         ; /* ecx = len */\r\n+\tmov\trsi, rdi\r\n+\tsub\trsi, r15          ; /* from = out - dist */\r\n+\r\n+\tsar\tecx, 1\r\n+\tjnc\tL_copy_two           ; /* if len % 2 == 0 */\r\n+\r\n+\trep     movsw\r\n+\tmov\tal, [rsi]\r\n+\tmov\t[rdi], al\r\n+\tinc\trdi\r\n+\r\n+\tmov\trsi, r8           ; /* move in back to %rsi, toss from */\r\n+\tjmp\tL_while_test\r\n+\r\n+L_copy_two:\r\n+\trep     movsw\r\n+\tmov\trsi, r8           ; /* move in back to %rsi, toss from */\r\n+\tjmp\tL_while_test\r\n+\r\n+ALIGN 4\r\n+L_check_dist_one:\r\n+\tcmp\tr15d, 1            ; /* if dist 1, is a memset */\r\n+\tjne\tL_check_window\r\n+\tcmp\t[rsp+40], rdi      ; /* if out == beg, outside window */\r\n+\tje\tL_check_window\r\n+\r\n+\tmov\tecx, r14d         ; /* ecx = len */\r\n+\tmov\tal, [rdi-1]\r\n+\tmov\tah, al\r\n+\r\n+\tsar\tecx, 1\r\n+\tjnc\tL_set_two\r\n+\tmov\t[rdi], al\r\n+\tinc\trdi\r\n+\r\n+L_set_two:\r\n+\trep     stosw\r\n+\tjmp\tL_while_test\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_length:\r\n+\ttest\tal, 64\r\n+\tjnz\tL_test_for_end_of_block ; /* if ((op & 64) != 0) */\r\n+\r\n+\txor\teax, eax\r\n+\tinc\teax\r\n+\tshl\teax, cl\r\n+\tdec\teax\r\n+\tand\teax, edx         ; /* eax &= hold */\r\n+\tadd\teax, r14d        ; /* eax += len */\r\n+\tmov\teax, [rbp+rax*4] ; /* eax = lcode[val+(hold&mask[op])]*/\r\n+\tjmp\tL_dolen\r\n+\r\n+ALIGN 4\r\n+L_test_for_second_level_dist:\r\n+\ttest\tal, 64\r\n+\tjnz\tL_invalid_distance_code ; /* if ((op & 64) != 0) */\r\n+\r\n+\txor\teax, eax\r\n+\tinc\teax\r\n+\tshl\teax, cl\r\n+\tdec\teax\r\n+\tand\teax, edx         ; /* eax &= hold */\r\n+\tadd\teax, r15d        ; /* eax += dist */\r\n+\tmov\teax, [r11+rax*4] ; /* eax = dcode[val+(hold&mask[op])]*/\r\n+\tjmp\tL_dodist\r\n+\r\n+ALIGN 4\r\n+L_clip_window:\r\n+\tmov\tecx, eax         ; /* ecx = nbytes */\r\n+\tmov\teax, [rsp+92]     ; /* eax = wsize, prepare for dist cmp */\r\n+\tneg\tecx                ; /* nbytes = -nbytes */\r\n+\r\n+\tcmp\teax, r15d\r\n+\tjb\tL_invalid_distance_too_far ; /* if (dist > wsize) */\r\n+\r\n+\tadd\tecx, r15d         ; /* nbytes = dist - nbytes */\r\n+\tcmp\tdword ptr [rsp+96], 0\r\n+\tjne\tL_wrap_around_window ; /* if (write != 0) */\r\n+\r\n+\tmov\trsi, [rsp+56]     ; /* from  = window */\r\n+\tsub\teax, ecx         ; /* eax  -= nbytes */\r\n+\tadd\trsi, rax         ; /* from += wsize - nbytes */\r\n+\r\n+\tmov\teax, r14d        ; /* eax = len */\r\n+\tcmp\tr14d, ecx\r\n+\tjbe\tL_do_copy           ; /* if (nbytes >= len) */\r\n+\r\n+\tsub\teax, ecx         ; /* eax -= nbytes */\r\n+\trep     movsb\r\n+\tmov\trsi, rdi\r\n+\tsub\trsi, r15         ; /* from = &out[ -dist ] */\r\n+\tjmp\tL_do_copy\r\n+\r\n+ALIGN 4\r\n+L_wrap_around_window:\r\n+\tmov\teax, [rsp+96]     ; /* eax = write */\r\n+\tcmp\tecx, eax\r\n+\tjbe\tL_contiguous_in_window ; /* if (write >= nbytes) */\r\n+\r\n+\tmov\tesi, [rsp+92]     ; /* from  = wsize */\r\n+\tadd\trsi, [rsp+56]     ; /* from += window */\r\n+\tadd\trsi, rax         ; /* from += write */\r\n+\tsub\trsi, rcx         ; /* from -= nbytes */\r\n+\tsub\tecx, eax         ; /* nbytes -= write */\r\n+\r\n+\tmov\teax, r14d        ; /* eax = len */\r\n+\tcmp\teax, ecx\r\n+\tjbe\tL_do_copy           ; /* if (nbytes >= len) */\r\n+\r\n+\tsub\teax, ecx         ; /* len -= nbytes */\r\n+\trep     movsb\r\n+\tmov\trsi, [rsp+56]     ; /* from = window */\r\n+\tmov\tecx, [rsp+96]     ; /* nbytes = write */\r\n+\tcmp\teax, ecx\r\n+\tjbe\tL_do_copy           ; /* if (nbytes >= len) */\r\n+\r\n+\tsub\teax, ecx         ; /* len -= nbytes */\r\n+\trep     movsb\r\n+\tmov\trsi, rdi\r\n+\tsub\trsi, r15         ; /* from = out - dist */\r\n+\tjmp\tL_do_copy\r\n+\r\n+ALIGN 4\r\n+L_contiguous_in_window:\r\n+\tmov\trsi, [rsp+56]     ; /* rsi = window */\r\n+\tadd\trsi, rax\r\n+\tsub\trsi, rcx         ; /* from += write - nbytes */\r\n+\r\n+\tmov\teax, r14d        ; /* eax = len */\r\n+\tcmp\teax, ecx\r\n+\tjbe\tL_do_copy           ; /* if (nbytes >= len) */\r\n+\r\n+\tsub\teax, ecx         ; /* len -= nbytes */\r\n+\trep     movsb\r\n+\tmov\trsi, rdi\r\n+\tsub\trsi, r15         ; /* from = out - dist */\r\n+\tjmp\tL_do_copy           ; /* if (nbytes >= len) */\r\n+\r\n+ALIGN 4\r\n+L_do_copy:\r\n+\tmov\tecx, eax         ; /* ecx = len */\r\n+\trep     movsb\r\n+\r\n+\tmov\trsi, r8          ; /* move in back to %esi, toss from */\r\n+\tjmp\tL_while_test\r\n+\r\n+L_test_for_end_of_block:\r\n+\ttest\tal, 32\r\n+\tjz\tL_invalid_literal_length_code\r\n+\tmov\tdword ptr [rsp+116], 1\r\n+\tjmp\tL_break_loop_with_status\r\n+\r\n+L_invalid_literal_length_code:\r\n+\tmov\tdword ptr [rsp+116], 2\r\n+\tjmp\tL_break_loop_with_status\r\n+\r\n+L_invalid_distance_code:\r\n+\tmov\tdword ptr [rsp+116], 3\r\n+\tjmp\tL_break_loop_with_status\r\n+\r\n+L_invalid_distance_too_far:\r\n+\tmov\tdword ptr [rsp+116], 4\r\n+\tjmp\tL_break_loop_with_status\r\n+\r\n+L_break_loop:\r\n+\tmov\tdword ptr [rsp+116], 0\r\n+\r\n+L_break_loop_with_status:\r\n+; /* put in, out, bits, and hold back into ar and pop esp */\r\n+\tmov\t[rsp+16], rsi     ; /* in */\r\n+\tmov\t[rsp+32], rdi     ; /* out */\r\n+\tmov\t[rsp+88], ebx     ; /* bits */\r\n+\tmov\t[rsp+80], rdx     ; /* hold */\r\n+\r\n+\tmov\trax, [rsp]       ; /* restore rbp and rsp */\r\n+\tmov\trbp, [rsp+8]\r\n+\tmov\trsp, rax\r\n+\r\n+\r\n+\r\n+\tmov rsi,[rsp-8]\r\n+\tmov rdi,[rsp-16]\r\n+\tmov r12,[rsp-24]\r\n+\tmov r13,[rsp-32]\r\n+\tmov r14,[rsp-40]\r\n+\tmov r15,[rsp-48]\r\n+\tmov rbx,[rsp-56]\r\n+\t\r\n+    ret 0\r\n+;          :\r\n+;          : \"m\" (ar)\r\n+;          : \"memory\", \"%rax\", \"%rbx\", \"%rcx\", \"%rdx\", \"%rsi\", \"%rdi\",\r\n+;            \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\"\r\n+;    );\r\n+\r\n+inffas8664fnc \tENDP\r\n+;_TEXT\tENDS\r\n+END\r"}, {"sha": "8df5d82616098e1f791526c3cd9875b24f5ad8c0", "filename": "zlib/contrib/masmx64/inffasx64.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Finffasx64.obj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee"}, {"sha": "ee03115c5a78b0a9e6f17bcb84ac17e00e5ef2b8", "filename": "zlib/contrib/masmx64/readme.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx64%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx64%2Freadme.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,28 @@\n+Summary\r\n+-------\r\n+This directory contains ASM implementations of the functions\r\n+longest_match() and inflate_fast(), for 64 bits x86 (both AMD64 and Intel EM64t),\r\n+for use with Microsoft Macro Assembler (x64) for AMD64 and Microsoft C++ 64 bits.\r\n+\r\n+gvmat64.asm is written by Gilles Vollant (2005), by using Brian Raiter 686/32 bits\r\n+   assembly optimized version from Jean-loup Gailly original longest_match function\r\n+\r\n+inffasx64.asm and inffas8664.c were written by Chris Anderson, by optimizing\r\n+   original function from Mark Adler\r\n+\r\n+Use instructions\r\n+----------------\r\n+Copy these files into the zlib source directory.\r\n+\r\n+define ASMV and ASMINF in your project. Include inffas8664.c in your source tree,\r\n+and inffasx64.obj and gvmat64.obj as object to link.\r\n+\r\n+\r\n+Build instructions\r\n+------------------\r\n+run bld_64.bat with Microsoft Macro Assembler (x64) for AMD64 (ml64.exe)\r\n+\r\n+ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK\r\n+\r\n+You can get Windows 2003 server DDK with ml64 and cl for AMD64 from \r\n+  http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)\r"}, {"sha": "99144d07af04ecb6189190e755d238c11445eb64", "filename": "zlib/contrib/masmx86/bld_ml32.bat", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Fbld_ml32.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Fbld_ml32.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fbld_ml32.bat?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,2 @@\n+ml /coff /Zi /c /Flgvmat32.lst  gvmat32.asm \r\n+ml /coff /Zi /c /Flinffas32.lst inffas32.asm \r"}, {"sha": "ebb326238aed552f381eacbfa69f9ed48d3eb1a3", "filename": "zlib/contrib/masmx86/gvmat32.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Fgvmat32.obj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee"}, {"sha": "bd6664d111d573b4aa7a4d4a182d33b90d705700", "filename": "zlib/contrib/masmx86/inffas32.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Finffas32.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fmasmx86%2Finffas32.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fmasmx86%2Finffas32.obj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee"}, {"sha": "8a50ee43925080b8e4b53131e0b4509d0e210f33", "filename": "zlib/contrib/minizip/mztools.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fminizip%2Fmztools.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fminizip%2Fmztools.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fmztools.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,281 @@\n+/*\n+  Additional tools for Minizip\n+  Code: Xavier Roche '2004\n+  License: Same as ZLIB (www.gzip.org)\n+*/\n+\n+/* Code */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"zlib.h\"\n+#include \"unzip.h\"\n+\n+#define READ_8(adr)  ((unsigned char)*(adr))\n+#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )\n+#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )\n+\n+#define WRITE_8(buff, n) do { \\\n+  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \\\n+} while(0)\n+#define WRITE_16(buff, n) do { \\\n+  WRITE_8((unsigned char*)(buff), n); \\\n+  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \\\n+} while(0)\n+#define WRITE_32(buff, n) do { \\\n+  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \\\n+  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \\\n+} while(0)\n+\n+extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)\n+const char* file;\n+const char* fileOut;\n+const char* fileOutTmp;\n+uLong* nRecovered;\n+uLong* bytesRecovered;\n+{\n+  int err = Z_OK;\n+  FILE* fpZip = fopen(file, \"rb\");\n+  FILE* fpOut = fopen(fileOut, \"wb\");\n+  FILE* fpOutCD = fopen(fileOutTmp, \"wb\");\n+  if (fpZip != NULL &&  fpOut != NULL) {\n+    int entries = 0;\n+    uLong totalBytes = 0;\n+    char header[30];\n+    char filename[256];\n+    char extra[1024];\n+    int offset = 0;\n+    int offsetCD = 0;\n+    while ( fread(header, 1, 30, fpZip) == 30 ) {\n+      int currentOffset = offset;\n+\n+      /* File entry */\n+      if (READ_32(header) == 0x04034b50) {\n+        unsigned int version = READ_16(header + 4);\n+        unsigned int gpflag = READ_16(header + 6);\n+        unsigned int method = READ_16(header + 8);\n+        unsigned int filetime = READ_16(header + 10);\n+        unsigned int filedate = READ_16(header + 12);\n+        unsigned int crc = READ_32(header + 14); /* crc */\n+        unsigned int cpsize = READ_32(header + 18); /* compressed size */\n+        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */\n+        unsigned int fnsize = READ_16(header + 26); /* file name length */\n+        unsigned int extsize = READ_16(header + 28); /* extra field length */\n+        filename[0] = extra[0] = '\\0';\n+        \n+        /* Header */\n+        if (fwrite(header, 1, 30, fpOut) == 30) {\n+          offset += 30;\n+        } else {\n+          err = Z_ERRNO;\n+          break;\n+        }\n+        \n+        /* Filename */\n+        if (fnsize > 0) {\n+          if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n+            if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n+              offset += fnsize;\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        } else {\n+          err = Z_STREAM_ERROR;\n+          break;\n+        }\n+\n+        /* Extra field */\n+        if (extsize > 0) {\n+          if (fread(extra, 1, extsize, fpZip) == extsize) {\n+            if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n+              offset += extsize;\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+        \n+        /* Data */\n+        {\n+          int dataSize = cpsize;\n+          if (dataSize == 0) {\n+            dataSize = uncpsize;\n+          }\n+          if (dataSize > 0) {\n+            char* data = malloc(dataSize);\n+            if (data != NULL) {\n+              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {\n+                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {\n+                  offset += dataSize;\n+                  totalBytes += dataSize;\n+                } else {\n+                  err = Z_ERRNO;\n+                }\n+              } else {\n+                err = Z_ERRNO;\n+              }\n+              free(data);\n+              if (err != Z_OK) {\n+                break;\n+              }\n+            } else {\n+              err = Z_MEM_ERROR;\n+              break;\n+            }\n+          }\n+        }\n+        \n+        /* Central directory entry */\n+        {\n+          char header[46];\n+          char* comment = \"\";\n+          int comsize = (int) strlen(comment);\n+          WRITE_32(header, 0x02014b50);\n+          WRITE_16(header + 4, version);\n+          WRITE_16(header + 6, version);\n+          WRITE_16(header + 8, gpflag);\n+          WRITE_16(header + 10, method);\n+          WRITE_16(header + 12, filetime);\n+          WRITE_16(header + 14, filedate);\n+          WRITE_32(header + 16, crc);\n+          WRITE_32(header + 20, cpsize);\n+          WRITE_32(header + 24, uncpsize);\n+          WRITE_16(header + 28, fnsize);\n+          WRITE_16(header + 30, extsize);\n+          WRITE_16(header + 32, comsize);\n+          WRITE_16(header + 34, 0);     /* disk # */\n+          WRITE_16(header + 36, 0);     /* int attrb */\n+          WRITE_32(header + 38, 0);     /* ext attrb */\n+          WRITE_32(header + 42, currentOffset);\n+          /* Header */\n+          if (fwrite(header, 1, 46, fpOutCD) == 46) {\n+            offsetCD += 46;\n+            \n+            /* Filename */\n+            if (fnsize > 0) {\n+              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {\n+                offsetCD += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_STREAM_ERROR;\n+              break;\n+            }\n+            \n+            /* Extra field */\n+            if (extsize > 0) {\n+              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {\n+                offsetCD += extsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+            \n+            /* Comment field */\n+            if (comsize > 0) {\n+              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {\n+                offsetCD += comsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+            \n+            \n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+\n+        /* Success */\n+        entries++;\n+\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    /* Final central directory  */\n+    {\n+      int entriesZip = entries;\n+      char header[22];\n+      char* comment = \"\"; // \"ZIP File recovered by zlib/minizip/mztools\";\n+      int comsize = (int) strlen(comment);\n+      if (entriesZip > 0xffff) {\n+        entriesZip = 0xffff;\n+      }\n+      WRITE_32(header, 0x06054b50);\n+      WRITE_16(header + 4, 0);    /* disk # */\n+      WRITE_16(header + 6, 0);    /* disk # */\n+      WRITE_16(header + 8, entriesZip);   /* hack */\n+      WRITE_16(header + 10, entriesZip);  /* hack */\n+      WRITE_32(header + 12, offsetCD);    /* size of CD */\n+      WRITE_32(header + 16, offset);      /* offset to CD */\n+      WRITE_16(header + 20, comsize);     /* comment */\n+      \n+      /* Header */\n+      if (fwrite(header, 1, 22, fpOutCD) == 22) {\n+        \n+        /* Comment field */\n+        if (comsize > 0) {\n+          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {\n+            err = Z_ERRNO;\n+          }\n+        }\n+        \n+      } else {\n+        err = Z_ERRNO;\n+      }\n+    }\n+\n+    /* Final merge (file + central directory) */\n+    fclose(fpOutCD);\n+    if (err == Z_OK) {\n+      fpOutCD = fopen(fileOutTmp, \"rb\");\n+      if (fpOutCD != NULL) {\n+        int nRead;\n+        char buffer[8192];\n+        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {\n+          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+        fclose(fpOutCD);\n+      }\n+    }\n+    \n+    /* Close */\n+    fclose(fpZip);\n+    fclose(fpOut);\n+    \n+    /* Wipe temporary file */\n+    (void)remove(fileOutTmp);\n+    \n+    /* Number of recovered entries */\n+    if (err == Z_OK) {\n+      if (nRecovered != NULL) {\n+        *nRecovered = entries;\n+      }\n+      if (bytesRecovered != NULL) {\n+        *bytesRecovered = totalBytes;\n+      }\n+    }\n+  } else {\n+    err = Z_STREAM_ERROR;\n+  }\n+  return err;\n+}"}, {"sha": "eee78dc56b565b51df368cc65bb5df01c329387e", "filename": "zlib/contrib/minizip/mztools.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fminizip%2Fmztools.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fminizip%2Fmztools.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fmztools.h?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,31 @@\n+/*\n+  Additional tools for Minizip\n+  Code: Xavier Roche '2004\n+  License: Same as ZLIB (www.gzip.org)\n+*/\n+\n+#ifndef _zip_tools_H\n+#define _zip_tools_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifndef _ZLIB_H\n+#include \"zlib.h\"\n+#endif\n+\n+#include \"unzip.h\"\n+\n+/* Repair a ZIP file (missing central directory) \n+   file: file to recover\n+   fileOut: output file after recovery\n+   fileOutTmp: temporary file name used for recovery\n+*/\n+extern int ZEXPORT unzRepair(const char* file, \n+                             const char* fileOut, \n+                             const char* fileOutTmp, \n+                             uLong* nRecovered,\n+                             uLong* bytesRecovered);\n+\n+#endif"}, {"sha": "62258f1495611695ab35009e67183b42a35c4728", "filename": "zlib/contrib/testzlib/testzlib.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Ftestzlib%2Ftestzlib.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,10 @@\n+To build testzLib with Visual Studio 2005:\r\n+\r\n+copy to a directory file from :\r\n+- root of zLib tree\r\n+- contrib/testzlib\r\n+- contrib/masmx86\r\n+- contrib/masmx64\r\n+- contrib/vstudio/vc7\r\n+\r\n+and open testzlib8.sln\n\\ No newline at end of file"}, {"sha": "97bc3e8c86de547e9e13332ea8aa1203939626de", "filename": "zlib/contrib/vstudio/vc7/testzlib.vcproj", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Ftestzlib.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Ftestzlib.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc7%2Ftestzlib.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,126 @@\n+<?xml version=\"1.0\" encoding = \"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"7.00\"\r\n+\tName=\"testZlibDll\"\r\n+\tProjectGUID=\"{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}\"\r\n+\tKeyword=\"Win32Proj\">\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"/>\r\n+\t</Platforms>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"Debug\"\r\n+\t\t\tIntermediateDirectory=\"Debug\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"TRUE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"3\"\r\n+\t\t\t\tRuntimeLibrary=\"5\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"Release\"\r\n+\t\t\tIntermediateDirectory=\"Release\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\">\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"TRUE\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"TRUE\"\r\n+\t\t\t\tRuntimeLibrary=\"4\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"TRUE\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"TRUE\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"TRUE\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\">\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\testzlib\\testzlib.c\">\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\">\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\">\r\n+\t\t</Filter>\r\n+\t\t<File\r\n+\t\t\tRelativePath=\"ReleaseDll\\zlibwapi.lib\">\r\n+\t\t</File>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "4af53e8a3113120a5af82f032e3df471cd848667", "filename": "zlib/contrib/vstudio/vc8/miniunz.vcproj", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminiunz.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminiunz.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminiunz.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,566 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"miniunz\"\r\n+\tProjectGUID=\"{C52F9E7B-498A-42BE-8DB4-85A15694382A}\"\r\n+\tKeyword=\"Win32Proj\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/miniunz.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/miniunz.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/miniunz.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\MiniUnzip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\MiniUnzip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/miniunz.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\miniunz.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "85f64c4d2ac1ab74c68328e91c7f0ffd7edb1d77", "filename": "zlib/contrib/vstudio/vc8/minizip.vcproj", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminizip.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminizip.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fminizip.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,563 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"minizip\"\r\n+\tProjectGUID=\"{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+\tKeyword=\"Win32Proj\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\MiniZip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\MiniZip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/minizip.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\$(ConfigurationName)\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/minizip.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\$(ConfigurationName)\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/minizip.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\MiniZip$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\MiniZip$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\$(ConfigurationName)\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\$(ConfigurationName)\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/minizip.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\minizip.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "68c3539911b4248c11439f0490a79848917dbea4", "filename": "zlib/contrib/vstudio/vc8/testzlib.vcproj", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlib.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlib.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlib.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,948 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"testzlib\"\r\n+\tProjectGUID=\"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+\tRootNamespace=\"testzlib\"\r\n+\tKeyword=\"Win32Proj\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerOutput=\"4\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx64\\gvmat64.obj ..\\..\\masmx64\\inffasx64.obj\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerOutput=\"4\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx64\\gvmat64.obj ..\\..\\masmx64\\inffasx64.obj\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\TestZlib$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\TestZlib$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\adler32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\compress.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\crc32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx86\\gvmat32c.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Win64 (AMD64)\"\r\n+\t\t\t\t\tExcludedFromBuild=\"TRUE\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win64 (AMD64)\"\r\n+\t\t\t\t\tExcludedFromBuild=\"TRUE\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseAsm|Win64 (AMD64)\"\r\n+\t\t\t\t\tExcludedFromBuild=\"TRUE\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infback.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx64\\inffas8664.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\testzlib\\testzlib.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\trees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\uncompr.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "f38ab5e08ae4b32a185c3a50d79f8a08406ad9c2", "filename": "zlib/contrib/vstudio/vc8/testzlibdll.vcproj", "status": "added", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlibdll.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlibdll.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Ftestzlibdll.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,567 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"TestZlibDll\"\r\n+\tProjectGUID=\"{C52F9E7B-498A-42BE-8DB4-85A15694366A}\"\r\n+\tKeyword=\"Win32Proj\"\r\n+\tSignManifests=\"true\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tMinimalRebuild=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllDebug\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/testzlib.pdb\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x86\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"x64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\TestZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\TestZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"1\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tCharacterSet=\"2\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"2\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tOmitFramePointers=\"true\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\minizip\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tBasicRuntimeChecks=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tUsePrecompiledHeader=\"0\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"ia64\\ZlibDllRelease\\zlibwapi.lib\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)/testzlib.exe\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tSubSystem=\"1\"\r\n+\t\t\t\tOptimizeReferences=\"2\"\r\n+\t\t\t\tEnableCOMDATFolding=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;def;odl;idl;hpj;bat;asm\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\testzlib\\testzlib.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "72cb8b4c31e2f867f87526db67cbe95f130db348", "filename": "zlib/contrib/vstudio/vc8/zlib.rc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlib.rc?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,32 @@\n+#include <windows.h>\r\n+\r\n+#define IDR_VERSION1  1\r\n+IDR_VERSION1\tVERSIONINFO\tMOVEABLE IMPURE LOADONCALL DISCARDABLE\r\n+  FILEVERSION\t 1,2,3,0\r\n+  PRODUCTVERSION 1,2,3,0\r\n+  FILEFLAGSMASK\tVS_FFI_FILEFLAGSMASK\r\n+  FILEFLAGS\t0\r\n+  FILEOS\tVOS_DOS_WINDOWS32\r\n+  FILETYPE\tVFT_DLL\r\n+  FILESUBTYPE\t0\t// not used\r\n+BEGIN\r\n+  BLOCK \"StringFileInfo\"\r\n+  BEGIN\r\n+    BLOCK \"040904E4\"\r\n+    //language ID = U.S. English, char set = Windows, Multilingual\r\n+\r\n+    BEGIN\r\n+      VALUE \"FileDescription\", \"zlib data compression library\\0\"\r\n+      VALUE \"FileVersion\",\t\"1.2.3.0\\0\"\r\n+      VALUE \"InternalName\",\t\"zlib\\0\"\r\n+      VALUE \"OriginalFilename\",\t\"zlib.dll\\0\"\r\n+      VALUE \"ProductName\",\t\"ZLib.DLL\\0\"\r\n+      VALUE \"Comments\",\"DLL support by Alessandro Iacopetti & Gilles Vollant\\0\"\r\n+      VALUE \"LegalCopyright\", \"(C) 1995-2003 Jean-loup Gailly & Mark Adler\\0\"\r\n+    END\r\n+  END\r\n+  BLOCK \"VarFileInfo\"\r\n+  BEGIN\r\n+    VALUE \"Translation\", 0x0409, 1252\r\n+  END\r\n+END\r"}, {"sha": "fb97037acf61378ba1e296564149bcd1555de9ed", "filename": "zlib/contrib/vstudio/vc8/zlibstat.vcproj", "status": "added", "additions": 870, "deletions": 0, "changes": 870, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibstat.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibstat.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibstat.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,870 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"zlibstat\"\r\n+\tProjectGUID=\"{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:X86 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:AMD64 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDetect64BitPortabilityProblems=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"1\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:IA64 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ASMV;ASMINF\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:X86 /NODEFAULTLIB\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj \"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ASMV;ASMINF;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:AMD64 /NODEFAULTLIB\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx64\\gvmat64.obj ..\\..\\masmx64\\inffasx64.obj \"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:IA64 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"0\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:X86 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:AMD64 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibStat$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibStat$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"4\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibstat.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLibrarianTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:IA64 /NODEFAULTLIB\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibstat.lib\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\adler32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\compress.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\crc32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx86\\gvmat32c.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\gzio.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infback.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx64\\inffas8664.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\ioapi.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\trees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\uncompr.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\unzip.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\zip.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlib.rc\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlibvc.def\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "a40e71541f384290000fe86b79347c2da292843a", "filename": "zlib/contrib/vstudio/vc8/zlibvc.def", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.def?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,92 @@\n+\r\n+VERSION\t\t1.23\r\n+\r\n+HEAPSIZE\t1048576,8192\r\n+\r\n+EXPORTS\r\n+        adler32                                  @1\r\n+        compress                                 @2\r\n+        crc32                                    @3\r\n+        deflate                                  @4\r\n+        deflateCopy                              @5\r\n+        deflateEnd                               @6\r\n+        deflateInit2_                            @7\r\n+        deflateInit_                             @8\r\n+        deflateParams                            @9\r\n+        deflateReset                             @10\r\n+        deflateSetDictionary                     @11\r\n+        gzclose                                  @12\r\n+        gzdopen                                  @13\r\n+        gzerror                                  @14\r\n+        gzflush                                  @15\r\n+        gzopen                                   @16\r\n+        gzread                                   @17\r\n+        gzwrite                                  @18\r\n+        inflate                                  @19\r\n+        inflateEnd                               @20\r\n+        inflateInit2_                            @21\r\n+        inflateInit_                             @22\r\n+        inflateReset                             @23\r\n+        inflateSetDictionary                     @24\r\n+        inflateSync                              @25\r\n+        uncompress                               @26\r\n+        zlibVersion                              @27\r\n+        gzprintf                                 @28\r\n+        gzputc                                   @29\r\n+        gzgetc                                   @30\r\n+        gzseek                                   @31\r\n+        gzrewind                                 @32\r\n+        gztell                                   @33\r\n+        gzeof                                    @34\r\n+        gzsetparams                              @35\r\n+        zError                                   @36\r\n+        inflateSyncPoint                         @37\r\n+        get_crc_table                            @38\r\n+        compress2                                @39\r\n+        gzputs                                   @40\r\n+        gzgets                                   @41\r\n+        inflateCopy                              @42\r\n+        inflateBackInit_                         @43\r\n+        inflateBack                              @44\r\n+        inflateBackEnd                           @45\r\n+        compressBound                            @46\r\n+        deflateBound                             @47\r\n+        gzclearerr                               @48\r\n+        gzungetc                                 @49\r\n+        zlibCompileFlags                         @50\r\n+        deflatePrime                             @51\r\n+\r\n+        unzOpen                                  @61\r\n+        unzClose                                 @62\r\n+        unzGetGlobalInfo                         @63\r\n+        unzGetCurrentFileInfo                    @64\r\n+        unzGoToFirstFile                         @65\r\n+        unzGoToNextFile                          @66\r\n+        unzOpenCurrentFile                       @67\r\n+        unzReadCurrentFile                       @68\r\n+        unzOpenCurrentFile3                      @69\r\n+        unztell                                  @70\r\n+        unzeof                                   @71\r\n+        unzCloseCurrentFile                      @72\r\n+        unzGetGlobalComment                      @73\r\n+        unzStringFileNameCompare                 @74\r\n+        unzLocateFile                            @75\r\n+        unzGetLocalExtrafield                    @76\r\n+        unzOpen2                                 @77\r\n+        unzOpenCurrentFile2                      @78\r\n+        unzOpenCurrentFilePassword               @79\r\n+\r\n+        zipOpen                                  @80\r\n+        zipOpenNewFileInZip                      @81\r\n+        zipWriteInFileInZip                      @82\r\n+        zipCloseFileInZip                        @83\r\n+        zipClose                                 @84\r\n+        zipOpenNewFileInZip2                     @86\r\n+        zipCloseFileInZipRaw                     @87\r\n+        zipOpen2                                 @88\r\n+        zipOpenNewFileInZip3                     @89\r\n+\r\n+        unzGetFilePos                            @100\r\n+        unzGoToFilePos                           @101\r\n+\r\n+        fill_win32_filefunc                      @110\r"}, {"sha": "a815a5549f6de2a3e2e6ac1104ededb66c23cf03", "filename": "zlib/contrib/vstudio/vc8/zlibvc.sln", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.sln", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.sln", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.sln?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,144 @@\n+\ufeff\r\n+Microsoft Visual Studio Solution File, Format Version 9.00\r\n+# Visual Studio 2005\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"zlibvc\", \"zlibvc.vcproj\", \"{8FD826F8-3739-44E6-8CC8-997122E53B8D}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"zlibstat\", \"zlibstat.vcproj\", \"{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"testzlib\", \"testzlib.vcproj\", \"{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"TestZlibDll\", \"testzlibdll.vcproj\", \"{C52F9E7B-498A-42BE-8DB4-85A15694366A}\"\r\n+\tProjectSection(ProjectDependencies) = postProject\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}\r\n+\tEndProjectSection\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"minizip\", \"minizip.vcproj\", \"{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}\"\r\n+\tProjectSection(ProjectDependencies) = postProject\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}\r\n+\tEndProjectSection\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"miniunz\", \"miniunz.vcproj\", \"{C52F9E7B-498A-42BE-8DB4-85A15694382A}\"\r\n+\tProjectSection(ProjectDependencies) = postProject\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}\r\n+\tEndProjectSection\r\n+EndProject\r\n+Global\r\n+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n+\t\tDebug|Itanium = Debug|Itanium\r\n+\t\tDebug|Win32 = Debug|Win32\r\n+\t\tDebug|x64 = Debug|x64\r\n+\t\tRelease|Itanium = Release|Itanium\r\n+\t\tRelease|Win32 = Release|Win32\r\n+\t\tRelease|x64 = Release|x64\r\n+\t\tReleaseWithoutAsm|Itanium = ReleaseWithoutAsm|Itanium\r\n+\t\tReleaseWithoutAsm|Win32 = ReleaseWithoutAsm|Win32\r\n+\t\tReleaseWithoutAsm|x64 = ReleaseWithoutAsm|x64\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.ActiveCfg = ReleaseWithoutAsm|x64\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.Build.0 = ReleaseWithoutAsm|x64\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64\r\n+\t\t{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.Build.0 = Release|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64\r\n+\t\t{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64\r\n+\t\t{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.Build.0 = Release|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium\r\n+\t\t{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.ActiveCfg = Debug|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.Build.0 = Debug|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.Build.0 = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.Build.0 = Release|x64\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium\r\n+\t\t{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium\r\n+\tEndGlobalSection\r\n+\tGlobalSection(SolutionProperties) = preSolution\r\n+\t\tHideSolutionNode = FALSE\r\n+\tEndGlobalSection\r\n+EndGlobal\r"}, {"sha": "e717011df7eec92f469f8b5d479a5abbf021b655", "filename": "zlib/contrib/vstudio/vc8/zlibvc.vcproj", "status": "added", "additions": 1219, "deletions": 0, "changes": 1219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.vcproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.vcproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvstudio%2Fvc8%2Fzlibvc.vcproj?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,1219 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\r\n+<VisualStudioProject\r\n+\tProjectType=\"Visual C++\"\r\n+\tVersion=\"8,00\"\r\n+\tName=\"zlibvc\"\r\n+\tProjectGUID=\"{8FD826F8-3739-44E6-8CC8-997122E53B8D}\"\r\n+\t>\r\n+\t<Platforms>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Win32\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"x64\"\r\n+\t\t/>\r\n+\t\t<Platform\r\n+\t\t\tName=\"Itanium\"\r\n+\t\t/>\r\n+\t</Platforms>\r\n+\t<ToolFiles>\r\n+\t</ToolFiles>\r\n+\t<Configurations>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI,ASMV,ASMINF\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"1\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"4\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI,ASMV,ASMINF;WIN64\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx64\\gvmat64.obj ..\\..\\masmx64\\inffasx64.obj \"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tOptimization=\"0\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;WIN64\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"3\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tDebugInformationFormat=\"3\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_DEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"2\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tGenerateDebugInformation=\"true\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Win32\"\r\n+\t\t\tOutputDirectory=\"x86\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x86\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"1\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;ASMV;ASMINF\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalOptions=\"/MACHINE:I386\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx86\\gvmat32.obj ..\\..\\masmx86\\inffas32.obj \"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|x64\"\r\n+\t\t\tOutputDirectory=\"x64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"x64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"3\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;ASMV;ASMINF;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tAdditionalDependencies=\"..\\..\\masmx64\\gvmat64.obj ..\\..\\masmx64\\inffasx64.obj \"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"17\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t\t<Configuration\r\n+\t\t\tName=\"Release|Itanium\"\r\n+\t\t\tOutputDirectory=\"ia64\\ZlibDll$(ConfigurationName)\"\r\n+\t\t\tIntermediateDirectory=\"ia64\\ZlibDll$(ConfigurationName)\\Tmp\"\r\n+\t\t\tConfigurationType=\"2\"\r\n+\t\t\tInheritedPropertySheets=\"UpgradeFromVC70.vsprops\"\r\n+\t\t\tUseOfMFC=\"0\"\r\n+\t\t\tATLMinimizesCRunTimeLibraryUsage=\"false\"\r\n+\t\t\tWholeProgramOptimization=\"1\"\r\n+\t\t\t>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCustomBuildTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCMIDLTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tMkTypLibCompatible=\"true\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tTargetEnvironment=\"2\"\r\n+\t\t\t\tTypeLibraryName=\"$(OutDir)/zlibvc.tlb\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\tInlineFunctionExpansion=\"1\"\r\n+\t\t\t\tAdditionalIncludeDirectories=\"..\\..\\..;..\\..\\masmx86\"\r\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;WIN64\"\r\n+\t\t\t\tStringPooling=\"true\"\r\n+\t\t\t\tExceptionHandling=\"0\"\r\n+\t\t\t\tRuntimeLibrary=\"2\"\r\n+\t\t\t\tBufferSecurityCheck=\"false\"\r\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\r\n+\t\t\t\tPrecompiledHeaderFile=\"$(IntDir)/zlibvc.pch\"\r\n+\t\t\t\tAssemblerOutput=\"2\"\r\n+\t\t\t\tAssemblerListingLocation=\"$(IntDir)\\\"\r\n+\t\t\t\tObjectFile=\"$(IntDir)\\\"\r\n+\t\t\t\tProgramDataBaseFileName=\"$(OutDir)\\\"\r\n+\t\t\t\tBrowseInformation=\"0\"\r\n+\t\t\t\tWarningLevel=\"3\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCResourceCompilerTool\"\r\n+\t\t\t\tPreprocessorDefinitions=\"NDEBUG\"\r\n+\t\t\t\tCulture=\"1036\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPreLinkEventTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCLinkerTool\"\r\n+\t\t\t\tOutputFile=\"$(OutDir)\\zlibwapi.dll\"\r\n+\t\t\t\tLinkIncremental=\"1\"\r\n+\t\t\t\tSuppressStartupBanner=\"true\"\r\n+\t\t\t\tGenerateManifest=\"false\"\r\n+\t\t\t\tIgnoreAllDefaultLibraries=\"false\"\r\n+\t\t\t\tModuleDefinitionFile=\".\\zlibvc.def\"\r\n+\t\t\t\tProgramDatabaseFile=\"$(OutDir)/zlibwapi.pdb\"\r\n+\t\t\t\tGenerateMapFile=\"true\"\r\n+\t\t\t\tMapFileName=\"$(OutDir)/zlibwapi.map\"\r\n+\t\t\t\tSubSystem=\"2\"\r\n+\t\t\t\tOptimizeForWindows98=\"1\"\r\n+\t\t\t\tImportLibrary=\"$(OutDir)/zlibwapi.lib\"\r\n+\t\t\t\tTargetMachine=\"5\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCALinkTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCManifestTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCXDCMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCBscMakeTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCFxCopTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCAppVerifierTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCWebDeploymentTool\"\r\n+\t\t\t/>\r\n+\t\t\t<Tool\r\n+\t\t\t\tName=\"VCPostBuildEventTool\"\r\n+\t\t\t/>\r\n+\t\t</Configuration>\r\n+\t</Configurations>\r\n+\t<References>\r\n+\t</References>\r\n+\t<Files>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Source Files\"\r\n+\t\t\tFilter=\"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\adler32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\compress.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\crc32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx86\\gvmat32c.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|x64\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\gzio.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infback.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\masmx64\\inffas8664.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Debug|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"ReleaseWithoutAsm|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\tExcludedFromBuild=\"true\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inflate.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\ioapi.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\iowin32.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\trees.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\uncompr.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\unzip.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|x64\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\minizip\\zip.c\"\r\n+\t\t\t\t>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Win32\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|x64\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t\t<FileConfiguration\r\n+\t\t\t\t\tName=\"Release|Itanium\"\r\n+\t\t\t\t\t>\r\n+\t\t\t\t\t<Tool\r\n+\t\t\t\t\t\tName=\"VCCLCompilerTool\"\r\n+\t\t\t\t\t\tAdditionalIncludeDirectories=\"\"\r\n+\t\t\t\t\t\tPreprocessorDefinitions=\"ZLIB_INTERNAL\"\r\n+\t\t\t\t\t/>\r\n+\t\t\t\t</FileConfiguration>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlib.rc\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\".\\zlibvc.def\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.c\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Header Files\"\r\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;fi;fd\"\r\n+\t\t\t>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\deflate.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infblock.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infcodes.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inffast.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\inftrees.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\infutil.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zconf.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zlib.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t\t<File\r\n+\t\t\t\tRelativePath=\"..\\..\\..\\zutil.h\"\r\n+\t\t\t\t>\r\n+\t\t\t</File>\r\n+\t\t</Filter>\r\n+\t\t<Filter\r\n+\t\t\tName=\"Resource Files\"\r\n+\t\t\tFilter=\"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\"\r\n+\t\t\t>\r\n+\t\t</Filter>\r\n+\t</Files>\r\n+\t<Globals>\r\n+\t</Globals>\r\n+</VisualStudioProject>\r"}, {"sha": "5632d7a4cc37a4873b1036712c8818064819c4bd", "filename": "zlib/examples/README.examples", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2FREADME.examples", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2FREADME.examples", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2FREADME.examples?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,42 @@\n+This directory contains examples of the use of zlib.\n+\n+fitblk.c\n+    compress just enough input to nearly fill a requested output size\n+    - zlib isn't designed to do this, but fitblk does it anyway\n+\n+gun.c\n+    uncompress a gzip file\n+    - illustrates the use of inflateBack() for high speed file-to-file\n+      decompression using call-back functions\n+    - is approximately twice as fast as gzip -d\n+    - also provides Unix uncompress functionality, again twice as fast\n+\n+gzappend.c\n+    append to a gzip file\n+    - illustrates the use of the Z_BLOCK flush parameter for inflate()\n+    - illustrates the use of deflatePrime() to start at any bit\n+\n+gzjoin.c\n+    join gzip files without recalculating the crc or recompressing\n+    - illustrates the use of the Z_BLOCK flush parameter for inflate()\n+    - illustrates the use of crc32_combine()\n+\n+gzlog.c\n+gzlog.h\n+    efficiently maintain a message log file in gzip format\n+    - illustrates use of raw deflate and Z_SYNC_FLUSH\n+    - illustrates use of gzip header extra field\n+\n+zlib_how.html\n+    painfully comprehensive description of zpipe.c (see below)\n+    - describes in excruciating detail the use of deflate() and inflate()\n+\n+zpipe.c\n+    reads and writes zlib streams from stdin to stdout\n+    - illustrates the proper use of deflate() and inflate()\n+    - deeply commented in zlib_how.html (see above)\n+\n+zran.c\n+    index a zlib or gzip stream and randomly access it\n+    - illustrates the use of Z_BLOCK, inflatePrime(), and\n+      inflateSetDictionary() to provide random access"}, {"sha": "c61de5c99672d1e35168a9fe73690aa05b9e5dd2", "filename": "zlib/examples/fitblk.c", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Ffitblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Ffitblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Ffitblk.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,233 @@\n+/* fitblk.c: example of fitting compressed output to a specified size\n+   Not copyrighted -- provided to the public domain\n+   Version 1.1  25 November 2004  Mark Adler */\n+\n+/* Version history:\n+   1.0  24 Nov 2004  First version\n+   1.1  25 Nov 2004  Change deflateInit2() to deflateInit()\n+                     Use fixed-size, stack-allocated raw buffers\n+                     Simplify code moving compression to subroutines\n+                     Use assert() for internal errors\n+                     Add detailed description of approach\n+ */\n+\n+/* Approach to just fitting a requested compressed size:\n+\n+   fitblk performs three compression passes on a portion of the input\n+   data in order to determine how much of that input will compress to\n+   nearly the requested output block size.  The first pass generates\n+   enough deflate blocks to produce output to fill the requested\n+   output size plus a specfied excess amount (see the EXCESS define\n+   below).  The last deflate block may go quite a bit past that, but\n+   is discarded.  The second pass decompresses and recompresses just\n+   the compressed data that fit in the requested plus excess sized\n+   buffer.  The deflate process is terminated after that amount of\n+   input, which is less than the amount consumed on the first pass.\n+   The last deflate block of the result will be of a comparable size\n+   to the final product, so that the header for that deflate block and\n+   the compression ratio for that block will be about the same as in\n+   the final product.  The third compression pass decompresses the\n+   result of the second step, but only the compressed data up to the\n+   requested size minus an amount to allow the compressed stream to\n+   complete (see the MARGIN define below).  That will result in a\n+   final compressed stream whose length is less than or equal to the\n+   requested size.  Assuming sufficient input and a requested size\n+   greater than a few hundred bytes, the shortfall will typically be\n+   less than ten bytes.\n+\n+   If the input is short enough that the first compression completes\n+   before filling the requested output size, then that compressed\n+   stream is return with no recompression.\n+\n+   EXCESS is chosen to be just greater than the shortfall seen in a\n+   two pass approach similar to the above.  That shortfall is due to\n+   the last deflate block compressing more efficiently with a smaller\n+   header on the second pass.  EXCESS is set to be large enough so\n+   that there is enough uncompressed data for the second pass to fill\n+   out the requested size, and small enough so that the final deflate\n+   block of the second pass will be close in size to the final deflate\n+   block of the third and final pass.  MARGIN is chosen to be just\n+   large enough to assure that the final compression has enough room\n+   to complete in all cases.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"zlib.h\"\n+\n+#define local static\n+\n+/* print nastygram and leave */\n+local void quit(char *why)\n+{\n+    fprintf(stderr, \"fitblk abort: %s\\n\", why);\n+    exit(1);\n+}\n+\n+#define RAWLEN 4096    /* intermediate uncompressed buffer size */\n+\n+/* compress from file to def until provided buffer is full or end of\n+   input reached; return last deflate() return value, or Z_ERRNO if\n+   there was read error on the file */\n+local int partcompress(FILE *in, z_streamp def)\n+{\n+    int ret, flush;\n+    unsigned char raw[RAWLEN];\n+\n+    flush = Z_NO_FLUSH;\n+    do {\n+        def->avail_in = fread(raw, 1, RAWLEN, in);\n+        if (ferror(in))\n+            return Z_ERRNO;\n+        def->next_in = raw;\n+        if (feof(in))\n+            flush = Z_FINISH;\n+        ret = deflate(def, flush);\n+        assert(ret != Z_STREAM_ERROR);\n+    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);\n+    return ret;\n+}\n+\n+/* recompress from inf's input to def's output; the input for inf and\n+   the output for def are set in those structures before calling;\n+   return last deflate() return value, or Z_MEM_ERROR if inflate()\n+   was not able to allocate enough memory when it needed to */\n+local int recompress(z_streamp inf, z_streamp def)\n+{\n+    int ret, flush;\n+    unsigned char raw[RAWLEN];\n+\n+    flush = Z_NO_FLUSH;\n+    do {\n+        /* decompress */\n+        inf->avail_out = RAWLEN;\n+        inf->next_out = raw;\n+        ret = inflate(inf, Z_NO_FLUSH);\n+        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n+               ret != Z_NEED_DICT);\n+        if (ret == Z_MEM_ERROR)\n+            return ret;\n+\n+        /* compress what was decompresed until done or no room */\n+        def->avail_in = RAWLEN - inf->avail_out;\n+        def->next_in = raw;\n+        if (inf->avail_out != 0)\n+            flush = Z_FINISH;\n+        ret = deflate(def, flush);\n+        assert(ret != Z_STREAM_ERROR);\n+    } while (ret != Z_STREAM_END && def->avail_out != 0);\n+    return ret;\n+}\n+\n+#define EXCESS 256      /* empirically determined stream overage */\n+#define MARGIN 8        /* amount to back off for completion */\n+\n+/* compress from stdin to fixed-size block on stdout */\n+int main(int argc, char **argv)\n+{\n+    int ret;                /* return code */\n+    unsigned size;          /* requested fixed output block size */\n+    unsigned have;          /* bytes written by deflate() call */\n+    unsigned char *blk;     /* intermediate and final stream */\n+    unsigned char *tmp;     /* close to desired size stream */\n+    z_stream def, inf;      /* zlib deflate and inflate states */\n+\n+    /* get requested output size */\n+    if (argc != 2)\n+        quit(\"need one argument: size of output block\");\n+    ret = strtol(argv[1], argv + 1, 10);\n+    if (argv[1][0] != 0)\n+        quit(\"argument must be a number\");\n+    if (ret < 8)            /* 8 is minimum zlib stream size */\n+        quit(\"need positive size of 8 or greater\");\n+    size = (unsigned)ret;\n+\n+    /* allocate memory for buffers and compression engine */\n+    blk = malloc(size + EXCESS);\n+    def.zalloc = Z_NULL;\n+    def.zfree = Z_NULL;\n+    def.opaque = Z_NULL;\n+    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n+    if (ret != Z_OK || blk == NULL)\n+        quit(\"out of memory\");\n+\n+    /* compress from stdin until output full, or no more input */\n+    def.avail_out = size + EXCESS;\n+    def.next_out = blk;\n+    ret = partcompress(stdin, &def);\n+    if (ret == Z_ERRNO)\n+        quit(\"error reading input\");\n+\n+    /* if it all fit, then size was undersubscribed -- done! */\n+    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n+        /* write block to stdout */\n+        have = size + EXCESS - def.avail_out;\n+        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n+            quit(\"error writing output\");\n+\n+        /* clean up and print results to stderr */\n+        ret = deflateEnd(&def);\n+        assert(ret != Z_STREAM_ERROR);\n+        free(blk);\n+        fprintf(stderr,\n+                \"%u bytes unused out of %u requested (all input)\\n\",\n+                size - have, size);\n+        return 0;\n+    }\n+\n+    /* it didn't all fit -- set up for recompression */\n+    inf.zalloc = Z_NULL;\n+    inf.zfree = Z_NULL;\n+    inf.opaque = Z_NULL;\n+    inf.avail_in = 0;\n+    inf.next_in = Z_NULL;\n+    ret = inflateInit(&inf);\n+    tmp = malloc(size + EXCESS);\n+    if (ret != Z_OK || tmp == NULL)\n+        quit(\"out of memory\");\n+    ret = deflateReset(&def);\n+    assert(ret != Z_STREAM_ERROR);\n+\n+    /* do first recompression close to the right amount */\n+    inf.avail_in = size + EXCESS;\n+    inf.next_in = blk;\n+    def.avail_out = size + EXCESS;\n+    def.next_out = tmp;\n+    ret = recompress(&inf, &def);\n+    if (ret == Z_MEM_ERROR)\n+        quit(\"out of memory\");\n+\n+    /* set up for next reocmpression */\n+    ret = inflateReset(&inf);\n+    assert(ret != Z_STREAM_ERROR);\n+    ret = deflateReset(&def);\n+    assert(ret != Z_STREAM_ERROR);\n+\n+    /* do second and final recompression (third compression) */\n+    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n+    inf.next_in = tmp;\n+    def.avail_out = size;\n+    def.next_out = blk;\n+    ret = recompress(&inf, &def);\n+    if (ret == Z_MEM_ERROR)\n+        quit(\"out of memory\");\n+    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n+\n+    /* done -- write block to stdout */\n+    have = size - def.avail_out;\n+    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n+        quit(\"error writing output\");\n+\n+    /* clean up and print results to stderr */\n+    free(tmp);\n+    ret = inflateEnd(&inf);\n+    assert(ret != Z_STREAM_ERROR);\n+    ret = deflateEnd(&def);\n+    assert(ret != Z_STREAM_ERROR);\n+    free(blk);\n+    fprintf(stderr,\n+            \"%u bytes unused out of %u requested (%lu input)\\n\",\n+            size - have, size, def.total_in);\n+    return 0;\n+}"}, {"sha": "bfec590a0028226c5c5dfe525c66e91a20fdac7b", "filename": "zlib/examples/gun.c", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgun.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgun.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fgun.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,693 @@\n+/* gun.c -- simple gunzip to give an example of the use of inflateBack()\n+ * Copyright (C) 2003, 2005 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+   Version 1.3  12 June 2005  Mark Adler */\n+\n+/* Version history:\n+   1.0  16 Feb 2003  First version for testing of inflateBack()\n+   1.1  21 Feb 2005  Decompress concatenated gzip streams\n+                     Remove use of \"this\" variable (C++ keyword)\n+                     Fix return value for in()\n+                     Improve allocation failure checking\n+                     Add typecasting for void * structures\n+                     Add -h option for command version and usage\n+                     Add a bunch of comments\n+   1.2  20 Mar 2005  Add Unix compress (LZW) decompression\n+                     Copy file attributes from input file to output file\n+   1.3  12 Jun 2005  Add casts for error messages [Oberhumer]\n+ */\n+\n+/*\n+   gun [ -t ] [ name ... ]\n+\n+   decompresses the data in the named gzip files.  If no arguments are given,\n+   gun will decompress from stdin to stdout.  The names must end in .gz, -gz,\n+   .z, -z, _z, or .Z.  The uncompressed data will be written to a file name\n+   with the suffix stripped.  On success, the original file is deleted.  On\n+   failure, the output file is deleted.  For most failures, the command will\n+   continue to process the remaining names on the command line.  A memory\n+   allocation failure will abort the command.  If -t is specified, then the\n+   listed files or stdin will be tested as gzip files for integrity (without\n+   checking for a proper suffix), no output will be written, and no files\n+   will be deleted.\n+\n+   Like gzip, gun allows concatenated gzip streams and will decompress them,\n+   writing all of the uncompressed data to the output.  Unlike gzip, gun allows\n+   an empty file on input, and will produce no error writing an empty output\n+   file.\n+\n+   gun will also decompress files made by Unix compress, which uses LZW\n+   compression.  These files are automatically detected by virtue of their\n+   magic header bytes.  Since the end of Unix compress stream is marked by the\n+   end-of-file, they cannot be concantenated.  If a Unix compress stream is\n+   encountered in an input file, it is the last stream in that file.\n+\n+   Like gunzip and uncompress, the file attributes of the orignal compressed\n+   file are maintained in the final uncompressed file, to the extent that the\n+   user permissions allow it.\n+\n+   On my Mac OS X PowerPC G4, gun is almost twice as fast as gunzip (version\n+   1.2.4) is on the same file, when gun is linked with zlib 1.2.2.  Also the\n+   LZW decompression provided by gun is about twice as fast as the standard\n+   Unix uncompress command.\n+ */\n+\n+/* external functions and related types and constants */\n+#include <stdio.h>          /* fprintf() */\n+#include <stdlib.h>         /* malloc(), free() */\n+#include <string.h>         /* strerror(), strcmp(), strlen(), memcpy() */\n+#include <errno.h>          /* errno */\n+#include <fcntl.h>          /* open() */\n+#include <unistd.h>         /* read(), write(), close(), chown(), unlink() */\n+#include <sys/types.h>\n+#include <sys/stat.h>       /* stat(), chmod() */\n+#include <utime.h>          /* utime() */\n+#include \"zlib.h\"           /* inflateBackInit(), inflateBack(), */\n+                            /* inflateBackEnd(), crc32() */\n+\n+/* function declaration */\n+#define local static\n+\n+/* buffer constants */\n+#define SIZE 32768U         /* input and output buffer sizes */\n+#define PIECE 16384         /* limits i/o chunks for 16-bit int case */\n+\n+/* structure for infback() to pass to input function in() -- it maintains the\n+   input file and a buffer of size SIZE */\n+struct ind {\n+    int infile;\n+    unsigned char *inbuf;\n+};\n+\n+/* Load input buffer, assumed to be empty, and return bytes loaded and a\n+   pointer to them.  read() is called until the buffer is full, or until it\n+   returns end-of-file or error.  Return 0 on error. */\n+local unsigned in(void *in_desc, unsigned char **buf)\n+{\n+    int ret;\n+    unsigned len;\n+    unsigned char *next;\n+    struct ind *me = (struct ind *)in_desc;\n+\n+    next = me->inbuf;\n+    *buf = next;\n+    len = 0;\n+    do {\n+        ret = PIECE;\n+        if ((unsigned)ret > SIZE - len)\n+            ret = (int)(SIZE - len);\n+        ret = (int)read(me->infile, next, ret);\n+        if (ret == -1) {\n+            len = 0;\n+            break;\n+        }\n+        next += ret;\n+        len += ret;\n+    } while (ret != 0 && len < SIZE);\n+    return len;\n+}\n+\n+/* structure for infback() to pass to output function out() -- it maintains the\n+   output file, a running CRC-32 check on the output and the total number of\n+   bytes output, both for checking against the gzip trailer.  (The length in\n+   the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and\n+   the output is greater than 4 GB.) */\n+struct outd {\n+    int outfile;\n+    int check;                  /* true if checking crc and total */\n+    unsigned long crc;\n+    unsigned long total;\n+};\n+\n+/* Write output buffer and update the CRC-32 and total bytes written.  write()\n+   is called until all of the output is written or an error is encountered.\n+   On success out() returns 0.  For a write failure, out() returns 1.  If the\n+   output file descriptor is -1, then nothing is written.\n+ */\n+local int out(void *out_desc, unsigned char *buf, unsigned len)\n+{\n+    int ret;\n+    struct outd *me = (struct outd *)out_desc;\n+\n+    if (me->check) {\n+        me->crc = crc32(me->crc, buf, len);\n+        me->total += len;\n+    }\n+    if (me->outfile != -1)\n+        do {\n+            ret = PIECE;\n+            if ((unsigned)ret > len)\n+                ret = (int)len;\n+            ret = (int)write(me->outfile, buf, ret);\n+            if (ret == -1)\n+                return 1;\n+            buf += ret;\n+            len -= ret;\n+        } while (len != 0);\n+    return 0;\n+}\n+\n+/* next input byte macro for use inside lunpipe() and gunpipe() */\n+#define NEXT() (have ? 0 : (have = in(indp, &next)), \\\n+                last = have ? (have--, (int)(*next++)) : -1)\n+\n+/* memory for gunpipe() and lunpipe() --\n+   the first 256 entries of prefix[] and suffix[] are never used, could\n+   have offset the index, but it's faster to waste the memory */\n+unsigned char inbuf[SIZE];              /* input buffer */\n+unsigned char outbuf[SIZE];             /* output buffer */\n+unsigned short prefix[65536];           /* index to LZW prefix string */\n+unsigned char suffix[65536];            /* one-character LZW suffix */\n+unsigned char match[65280 + 2];         /* buffer for reversed match or gzip\n+                                           32K sliding window */\n+\n+/* throw out what's left in the current bits byte buffer (this is a vestigial\n+   aspect of the compressed data format derived from an implementation that\n+   made use of a special VAX machine instruction!) */\n+#define FLUSHCODE() \\\n+    do { \\\n+        left = 0; \\\n+        rem = 0; \\\n+        if (chunk > have) { \\\n+            chunk -= have; \\\n+            have = 0; \\\n+            if (NEXT() == -1) \\\n+                break; \\\n+            chunk--; \\\n+            if (chunk > have) { \\\n+                chunk = have = 0; \\\n+                break; \\\n+            } \\\n+        } \\\n+        have -= chunk; \\\n+        next += chunk; \\\n+        chunk = 0; \\\n+    } while (0)\n+\n+/* Decompress a compress (LZW) file from indp to outfile.  The compress magic\n+   header (two bytes) has already been read and verified.  There are have bytes\n+   of buffered input at next.  strm is used for passing error information back\n+   to gunpipe().\n+\n+   lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of\n+   file, read error, or write error (a write error indicated by strm->next_in\n+   not equal to Z_NULL), or Z_DATA_ERROR for invalid input.\n+ */\n+local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,\n+                  int outfile, z_stream *strm)\n+{\n+    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n+    int chunk;                  /* bytes left in current chunk */\n+    int left;                   /* bits left in rem */\n+    unsigned rem;               /* unused bits from input */\n+    int bits;                   /* current bits per code */\n+    unsigned code;              /* code, table traversal index */\n+    unsigned mask;              /* mask for current bits codes */\n+    int max;                    /* maximum bits per code for this stream */\n+    int flags;                  /* compress flags, then block compress flag */\n+    unsigned end;               /* last valid entry in prefix/suffix tables */\n+    unsigned temp;              /* current code */\n+    unsigned prev;              /* previous code */\n+    unsigned final;             /* last character written for previous code */\n+    unsigned stack;             /* next position for reversed string */\n+    unsigned outcnt;            /* bytes in output buffer */\n+    struct outd outd;           /* output structure */\n+\n+    /* set up output */\n+    outd.outfile = outfile;\n+    outd.check = 0;\n+\n+    /* process remainder of compress header -- a flags byte */\n+    flags = NEXT();\n+    if (last == -1)\n+        return Z_BUF_ERROR;\n+    if (flags & 0x60) {\n+        strm->msg = (char *)\"unknown lzw flags set\";\n+        return Z_DATA_ERROR;\n+    }\n+    max = flags & 0x1f;\n+    if (max < 9 || max > 16) {\n+        strm->msg = (char *)\"lzw bits out of range\";\n+        return Z_DATA_ERROR;\n+    }\n+    if (max == 9)                           /* 9 doesn't really mean 9 */\n+        max = 10;\n+    flags &= 0x80;                          /* true if block compress */\n+\n+    /* clear table */\n+    bits = 9;\n+    mask = 0x1ff;\n+    end = flags ? 256 : 255;\n+\n+    /* set up: get first 9-bit code, which is the first decompressed byte, but\n+       don't create a table entry until the next code */\n+    if (NEXT() == -1)                       /* no compressed data is ok */\n+        return Z_OK;\n+    final = prev = (unsigned)last;          /* low 8 bits of code */\n+    if (NEXT() == -1)                       /* missing a bit */\n+        return Z_BUF_ERROR;\n+    if (last & 1) {                         /* code must be < 256 */\n+        strm->msg = (char *)\"invalid lzw code\";\n+        return Z_DATA_ERROR;\n+    }\n+    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n+    left = 7;\n+    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n+    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n+    outcnt = 1;\n+\n+    /* decode codes */\n+    stack = 0;\n+    for (;;) {\n+        /* if the table will be full after this, increment the code size */\n+        if (end >= mask && bits < max) {\n+            FLUSHCODE();\n+            bits++;\n+            mask <<= 1;\n+            mask++;\n+        }\n+\n+        /* get a code of length bits */\n+        if (chunk == 0)                     /* decrement chunk modulo bits */\n+            chunk = bits;\n+        code = rem;                         /* low bits of code */\n+        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n+            /* write remaining buffered output */\n+            if (outcnt && out(&outd, outbuf, outcnt)) {\n+                strm->next_in = outbuf;     /* signal write error */\n+                return Z_BUF_ERROR;\n+            }\n+            return Z_OK;\n+        }\n+        code += (unsigned)last << left;     /* middle (or high) bits of code */\n+        left += 8;\n+        chunk--;\n+        if (bits > left) {                  /* need more bits */\n+            if (NEXT() == -1)               /* can't end in middle of code */\n+                return Z_BUF_ERROR;\n+            code += (unsigned)last << left; /* high bits of code */\n+            left += 8;\n+            chunk--;\n+        }\n+        code &= mask;                       /* mask to current code length */\n+        left -= bits;                       /* number of unused bits */\n+        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n+\n+        /* process clear code (256) */\n+        if (code == 256 && flags) {\n+            FLUSHCODE();\n+            bits = 9;                       /* initialize bits and mask */\n+            mask = 0x1ff;\n+            end = 255;                      /* empty table */\n+            continue;                       /* get next code */\n+        }\n+\n+        /* special code to reuse last match */\n+        temp = code;                        /* save the current code */\n+        if (code > end) {\n+            /* Be picky on the allowed code here, and make sure that the code\n+               we drop through (prev) will be a valid index so that random\n+               input does not cause an exception.  The code != end + 1 check is\n+               empirically derived, and not checked in the original uncompress\n+               code.  If this ever causes a problem, that check could be safely\n+               removed.  Leaving this check in greatly improves gun's ability\n+               to detect random or corrupted input after a compress header.\n+               In any case, the prev > end check must be retained. */\n+            if (code != end + 1 || prev > end) {\n+                strm->msg = (char *)\"invalid lzw code\";\n+                return Z_DATA_ERROR;\n+            }\n+            match[stack++] = (unsigned char)final;\n+            code = prev;\n+        }\n+\n+        /* walk through linked list to generate output in reverse order */\n+        while (code >= 256) {\n+            match[stack++] = suffix[code];\n+            code = prefix[code];\n+        }\n+        match[stack++] = (unsigned char)code;\n+        final = code;\n+\n+        /* link new table entry */\n+        if (end < mask) {\n+            end++;\n+            prefix[end] = (unsigned short)prev;\n+            suffix[end] = (unsigned char)final;\n+        }\n+\n+        /* set previous code for next iteration */\n+        prev = temp;\n+\n+        /* write output in forward order */\n+        while (stack > SIZE - outcnt) {\n+            while (outcnt < SIZE)\n+                outbuf[outcnt++] = match[--stack];\n+            if (out(&outd, outbuf, outcnt)) {\n+                strm->next_in = outbuf; /* signal write error */\n+                return Z_BUF_ERROR;\n+            }\n+            outcnt = 0;\n+        }\n+        do {\n+            outbuf[outcnt++] = match[--stack];\n+        } while (stack);\n+\n+        /* loop for next code with final and prev as the last match, rem and\n+           left provide the first 0..7 bits of the next code, end is the last\n+           valid table entry */\n+    }\n+}\n+\n+/* Decompress a gzip file from infile to outfile.  strm is assumed to have been\n+   successfully initialized with inflateBackInit().  The input file may consist\n+   of a series of gzip streams, in which case all of them will be decompressed\n+   to the output file.  If outfile is -1, then the gzip stream(s) integrity is\n+   checked and nothing is written.\n+\n+   The return value is a zlib error code: Z_MEM_ERROR if out of memory,\n+   Z_DATA_ERROR if the header or the compressed data is invalid, or if the\n+   trailer CRC-32 check or length doesn't match, Z_BUF_ERROR if the input ends\n+   prematurely or a write error occurs, or Z_ERRNO if junk (not a another gzip\n+   stream) follows a valid gzip stream.\n+ */\n+local int gunpipe(z_stream *strm, int infile, int outfile)\n+{\n+    int ret, first, last;\n+    unsigned have, flags, len;\n+    unsigned char *next;\n+    struct ind ind, *indp;\n+    struct outd outd;\n+\n+    /* setup input buffer */\n+    ind.infile = infile;\n+    ind.inbuf = inbuf;\n+    indp = &ind;\n+\n+    /* decompress concatenated gzip streams */\n+    have = 0;                               /* no input data read in yet */\n+    first = 1;                              /* looking for first gzip header */\n+    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n+    for (;;) {\n+        /* look for the two magic header bytes for a gzip stream */\n+        if (NEXT() == -1) {\n+            ret = Z_OK;\n+            break;                          /* empty gzip stream is ok */\n+        }\n+        if (last != 31 || (NEXT() != 139 && last != 157)) {\n+            strm->msg = (char *)\"incorrect header check\";\n+            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n+            break;                          /* not a gzip or compress header */\n+        }\n+        first = 0;                          /* next non-header is junk */\n+\n+        /* process a compress (LZW) file -- can't be concatenated after this */\n+        if (last == 157) {\n+            ret = lunpipe(have, next, indp, outfile, strm);\n+            break;\n+        }\n+\n+        /* process remainder of gzip header */\n+        ret = Z_BUF_ERROR;\n+        if (NEXT() != 8) {                  /* only deflate method allowed */\n+            if (last == -1) break;\n+            strm->msg = (char *)\"unknown compression method\";\n+            ret = Z_DATA_ERROR;\n+            break;\n+        }\n+        flags = NEXT();                     /* header flags */\n+        NEXT();                             /* discard mod time, xflgs, os */\n+        NEXT();\n+        NEXT();\n+        NEXT();\n+        NEXT();\n+        NEXT();\n+        if (last == -1) break;\n+        if (flags & 0xe0) {\n+            strm->msg = (char *)\"unknown header flags set\";\n+            ret = Z_DATA_ERROR;\n+            break;\n+        }\n+        if (flags & 4) {                    /* extra field */\n+            len = NEXT();\n+            len += (unsigned)(NEXT()) << 8;\n+            if (last == -1) break;\n+            while (len > have) {\n+                len -= have;\n+                have = 0;\n+                if (NEXT() == -1) break;\n+                len--;\n+            }\n+            if (last == -1) break;\n+            have -= len;\n+            next += len;\n+        }\n+        if (flags & 8)                      /* file name */\n+            while (NEXT() != 0 && last != -1)\n+                ;\n+        if (flags & 16)                     /* comment */\n+            while (NEXT() != 0 && last != -1)\n+                ;\n+        if (flags & 2) {                    /* header crc */\n+            NEXT();\n+            NEXT();\n+        }\n+        if (last == -1) break;\n+\n+        /* set up output */\n+        outd.outfile = outfile;\n+        outd.check = 1;\n+        outd.crc = crc32(0L, Z_NULL, 0);\n+        outd.total = 0;\n+\n+        /* decompress data to output */\n+        strm->next_in = next;\n+        strm->avail_in = have;\n+        ret = inflateBack(strm, in, indp, out, &outd);\n+        if (ret != Z_STREAM_END) break;\n+        next = strm->next_in;\n+        have = strm->avail_in;\n+        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n+\n+        /* check trailer */\n+        ret = Z_BUF_ERROR;\n+        if (NEXT() != (outd.crc & 0xff) ||\n+            NEXT() != ((outd.crc >> 8) & 0xff) ||\n+            NEXT() != ((outd.crc >> 16) & 0xff) ||\n+            NEXT() != ((outd.crc >> 24) & 0xff)) {\n+            /* crc error */\n+            if (last != -1) {\n+                strm->msg = (char *)\"incorrect data check\";\n+                ret = Z_DATA_ERROR;\n+            }\n+            break;\n+        }\n+        if (NEXT() != (outd.total & 0xff) ||\n+            NEXT() != ((outd.total >> 8) & 0xff) ||\n+            NEXT() != ((outd.total >> 16) & 0xff) ||\n+            NEXT() != ((outd.total >> 24) & 0xff)) {\n+            /* length error */\n+            if (last != -1) {\n+                strm->msg = (char *)\"incorrect length check\";\n+                ret = Z_DATA_ERROR;\n+            }\n+            break;\n+        }\n+\n+        /* go back and look for another gzip stream */\n+    }\n+\n+    /* clean up and return */\n+    return ret;\n+}\n+\n+/* Copy file attributes, from -> to, as best we can.  This is best effort, so\n+   no errors are reported.  The mode bits, including suid, sgid, and the sticky\n+   bit are copied (if allowed), the owner's user id and group id are copied\n+   (again if allowed), and the access and modify times are copied. */\n+local void copymeta(char *from, char *to)\n+{\n+    struct stat was;\n+    struct utimbuf when;\n+\n+    /* get all of from's Unix meta data, return if not a regular file */\n+    if (stat(from, &was) != 0 || (was.st_mode & S_IFMT) != S_IFREG)\n+        return;\n+\n+    /* set to's mode bits, ignore errors */\n+    (void)chmod(to, was.st_mode & 07777);\n+\n+    /* copy owner's user and group, ignore errors */\n+    (void)chown(to, was.st_uid, was.st_gid);\n+\n+    /* copy access and modify times, ignore errors */\n+    when.actime = was.st_atime;\n+    when.modtime = was.st_mtime;\n+    (void)utime(to, &when);\n+}\n+\n+/* Decompress the file inname to the file outnname, of if test is true, just\n+   decompress without writing and check the gzip trailer for integrity.  If\n+   inname is NULL or an empty string, read from stdin.  If outname is NULL or\n+   an empty string, write to stdout.  strm is a pre-initialized inflateBack\n+   structure.  When appropriate, copy the file attributes from inname to\n+   outname.\n+\n+   gunzip() returns 1 if there is an out-of-memory error or an unexpected\n+   return code from gunpipe().  Otherwise it returns 0.\n+ */\n+local int gunzip(z_stream *strm, char *inname, char *outname, int test)\n+{\n+    int ret;\n+    int infile, outfile;\n+\n+    /* open files */\n+    if (inname == NULL || *inname == 0) {\n+        inname = \"-\";\n+        infile = 0;     /* stdin */\n+    }\n+    else {\n+        infile = open(inname, O_RDONLY, 0);\n+        if (infile == -1) {\n+            fprintf(stderr, \"gun cannot open %s\\n\", inname);\n+            return 0;\n+        }\n+    }\n+    if (test)\n+        outfile = -1;\n+    else if (outname == NULL || *outname == 0) {\n+        outname = \"-\";\n+        outfile = 1;    /* stdout */\n+    }\n+    else {\n+        outfile = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0666);\n+        if (outfile == -1) {\n+            close(infile);\n+            fprintf(stderr, \"gun cannot create %s\\n\", outname);\n+            return 0;\n+        }\n+    }\n+    errno = 0;\n+\n+    /* decompress */\n+    ret = gunpipe(strm, infile, outfile);\n+    if (outfile > 2) close(outfile);\n+    if (infile > 2) close(infile);\n+\n+    /* interpret result */\n+    switch (ret) {\n+    case Z_OK:\n+    case Z_ERRNO:\n+        if (infile > 2 && outfile > 2) {\n+            copymeta(inname, outname);          /* copy attributes */\n+            unlink(inname);\n+        }\n+        if (ret == Z_ERRNO)\n+            fprintf(stderr, \"gun warning: trailing garbage ignored in %s\\n\",\n+                    inname);\n+        break;\n+    case Z_DATA_ERROR:\n+        if (outfile > 2) unlink(outname);\n+        fprintf(stderr, \"gun data error on %s: %s\\n\", inname, strm->msg);\n+        break;\n+    case Z_MEM_ERROR:\n+        if (outfile > 2) unlink(outname);\n+        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n+        return 1;\n+    case Z_BUF_ERROR:\n+        if (outfile > 2) unlink(outname);\n+        if (strm->next_in != Z_NULL) {\n+            fprintf(stderr, \"gun write error on %s: %s\\n\",\n+                    outname, strerror(errno));\n+        }\n+        else if (errno) {\n+            fprintf(stderr, \"gun read error on %s: %s\\n\",\n+                    inname, strerror(errno));\n+        }\n+        else {\n+            fprintf(stderr, \"gun unexpected end of file on %s\\n\",\n+                    inname);\n+        }\n+        break;\n+    default:\n+        if (outfile > 2) unlink(outname);\n+        fprintf(stderr, \"gun internal error--aborting\\n\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+/* Process the gun command line arguments.  See the command syntax near the\n+   beginning of this source file. */\n+int main(int argc, char **argv)\n+{\n+    int ret, len, test;\n+    char *outname;\n+    unsigned char *window;\n+    z_stream strm;\n+\n+    /* initialize inflateBack state for repeated use */\n+    window = match;                         /* reuse LZW match buffer */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    ret = inflateBackInit(&strm, 15, window);\n+    if (ret != Z_OK) {\n+        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n+        return 1;\n+    }\n+\n+    /* decompress each file to the same name with the suffix removed */\n+    argc--;\n+    argv++;\n+    test = 0;\n+    if (argc && strcmp(*argv, \"-h\") == 0) {\n+        fprintf(stderr, \"gun 1.3 (12 Jun 2005)\\n\");\n+        fprintf(stderr, \"Copyright (c) 2005 Mark Adler\\n\");\n+        fprintf(stderr, \"usage: gun [-t] [file1.gz [file2.Z ...]]\\n\");\n+        return 0;\n+    }\n+    if (argc && strcmp(*argv, \"-t\") == 0) {\n+        test = 1;\n+        argc--;\n+        argv++;\n+    }\n+    if (argc)\n+        do {\n+            if (test)\n+                outname = NULL;\n+            else {\n+                len = (int)strlen(*argv);\n+                if (strcmp(*argv + len - 3, \".gz\") == 0 ||\n+                    strcmp(*argv + len - 3, \"-gz\") == 0)\n+                    len -= 3;\n+                else if (strcmp(*argv + len - 2, \".z\") == 0 ||\n+                    strcmp(*argv + len - 2, \"-z\") == 0 ||\n+                    strcmp(*argv + len - 2, \"_z\") == 0 ||\n+                    strcmp(*argv + len - 2, \".Z\") == 0)\n+                    len -= 2;\n+                else {\n+                    fprintf(stderr, \"gun error: no gz type on %s--skipping\\n\",\n+                            *argv);\n+                    continue;\n+                }\n+                outname = malloc(len + 1);\n+                if (outname == NULL) {\n+                    fprintf(stderr, \"gun out of memory error--aborting\\n\");\n+                    ret = 1;\n+                    break;\n+                }\n+                memcpy(outname, *argv, len);\n+                outname[len] = 0;\n+            }\n+            ret = gunzip(&strm, *argv, outname, test);\n+            if (outname != NULL) free(outname);\n+            if (ret) break;\n+        } while (argv++, --argc);\n+    else\n+        ret = gunzip(&strm, NULL, NULL, test);\n+\n+    /* clean up */\n+    inflateBackEnd(&strm);\n+    return ret;\n+}"}, {"sha": "e9e878e116033e9ff2c05e2f1c8ab45ca45278bb", "filename": "zlib/examples/gzappend.c", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzappend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzappend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fgzappend.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,500 @@\n+/* gzappend -- command to append to a gzip file\n+\n+  Copyright (C) 2003 Mark Adler, all rights reserved\n+  version 1.1, 4 Nov 2003\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.0  19 Oct 2003     - First version\n+ * 1.1   4 Nov 2003     - Expand and clarify some comments and notes\n+ *                      - Add version and copyright to help\n+ *                      - Send help to stdout instead of stderr\n+ *                      - Add some preemptive typecasts\n+ *                      - Add L to constants in lseek() calls\n+ *                      - Remove some debugging information in error messages\n+ *                      - Use new data_type definition for zlib 1.2.1\n+ *                      - Simplfy and unify file operations\n+ *                      - Finish off gzip file in gztack()\n+ *                      - Use deflatePrime() instead of adding empty blocks\n+ *                      - Keep gzip file clean on appended file read errors\n+ *                      - Use in-place rotate instead of auxiliary buffer\n+ *                        (Why you ask?  Because it was fun to write!)\n+ */\n+\n+/*\n+   gzappend takes a gzip file and appends to it, compressing files from the\n+   command line or data from stdin.  The gzip file is written to directly, to\n+   avoid copying that file, in case it's large.  Note that this results in the\n+   unfriendly behavior that if gzappend fails, the gzip file is corrupted.\n+\n+   This program was written to illustrate the use of the new Z_BLOCK option of\n+   zlib 1.2.x's inflate() function.  This option returns from inflate() at each\n+   block boundary to facilitate locating and modifying the last block bit at\n+   the start of the final deflate block.  Also whether using Z_BLOCK or not,\n+   another required feature of zlib 1.2.x is that inflate() now provides the\n+   number of unusued bits in the last input byte used.  gzappend will not work\n+   with versions of zlib earlier than 1.2.1.\n+\n+   gzappend first decompresses the gzip file internally, discarding all but\n+   the last 32K of uncompressed data, and noting the location of the last block\n+   bit and the number of unused bits in the last byte of the compressed data.\n+   The gzip trailer containing the CRC-32 and length of the uncompressed data\n+   is verified.  This trailer will be later overwritten.\n+\n+   Then the last block bit is cleared by seeking back in the file and rewriting\n+   the byte that contains it.  Seeking forward, the last byte of the compressed\n+   data is saved along with the number of unused bits to initialize deflate.\n+\n+   A deflate process is initialized, using the last 32K of the uncompressed\n+   data from the gzip file to initialize the dictionary.  If the total\n+   uncompressed data was less than 32K, then all of it is used to initialize\n+   the dictionary.  The deflate output bit buffer is also initialized with the\n+   last bits from the original deflate stream.  From here on, the data to\n+   append is simply compressed using deflate, and written to the gzip file.\n+   When that is complete, the new CRC-32 and uncompressed length are written\n+   as the trailer of the gzip file.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include \"zlib.h\"\n+\n+#define local static\n+#define LGCHUNK 14\n+#define CHUNK (1U << LGCHUNK)\n+#define DSIZE 32768U\n+\n+/* print an error message and terminate with extreme prejudice */\n+local void bye(char *msg1, char *msg2)\n+{\n+    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n+    exit(1);\n+}\n+\n+/* return the greatest common divisor of a and b using Euclid's algorithm,\n+   modified to be fast when one argument much greater than the other, and\n+   coded to avoid unnecessary swapping */\n+local unsigned gcd(unsigned a, unsigned b)\n+{\n+    unsigned c;\n+\n+    while (a && b)\n+        if (a > b) {\n+            c = b;\n+            while (a - c >= c)\n+                c <<= 1;\n+            a -= c;\n+        }\n+        else {\n+            c = a;\n+            while (b - c >= c)\n+                c <<= 1;\n+            b -= c;\n+        }\n+    return a + b;\n+}\n+\n+/* rotate list[0..len-1] left by rot positions, in place */\n+local void rotate(unsigned char *list, unsigned len, unsigned rot)\n+{\n+    unsigned char tmp;\n+    unsigned cycles;\n+    unsigned char *start, *last, *to, *from;\n+\n+    /* normalize rot and handle degenerate cases */\n+    if (len < 2) return;\n+    if (rot >= len) rot %= len;\n+    if (rot == 0) return;\n+\n+    /* pointer to last entry in list */\n+    last = list + (len - 1);\n+\n+    /* do simple left shift by one */\n+    if (rot == 1) {\n+        tmp = *list;\n+        memcpy(list, list + 1, len - 1);\n+        *last = tmp;\n+        return;\n+    }\n+\n+    /* do simple right shift by one */\n+    if (rot == len - 1) {\n+        tmp = *last;\n+        memmove(list + 1, list, len - 1);\n+        *list = tmp;\n+        return;\n+    }\n+\n+    /* otherwise do rotate as a set of cycles in place */\n+    cycles = gcd(len, rot);             /* number of cycles */\n+    do {\n+        start = from = list + cycles;   /* start index is arbitrary */\n+        tmp = *from;                    /* save entry to be overwritten */\n+        for (;;) {\n+            to = from;                  /* next step in cycle */\n+            from += rot;                /* go right rot positions */\n+            if (from > last) from -= len;   /* (pointer better not wrap) */\n+            if (from == start) break;   /* all but one shifted */\n+            *to = *from;                /* shift left */\n+        }\n+        *to = tmp;                      /* complete the circle */\n+    } while (--cycles);\n+}\n+\n+/* structure for gzip file read operations */\n+typedef struct {\n+    int fd;                     /* file descriptor */\n+    int size;                   /* 1 << size is bytes in buf */\n+    unsigned left;              /* bytes available at next */\n+    unsigned char *buf;         /* buffer */\n+    unsigned char *next;        /* next byte in buffer */\n+    char *name;                 /* file name for error messages */\n+} file;\n+\n+/* reload buffer */\n+local int readin(file *in)\n+{\n+    int len;\n+\n+    len = read(in->fd, in->buf, 1 << in->size);\n+    if (len == -1) bye(\"error reading \", in->name);\n+    in->left = (unsigned)len;\n+    in->next = in->buf;\n+    return len;\n+}\n+\n+/* read from file in, exit if end-of-file */\n+local int readmore(file *in)\n+{\n+    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n+    return 0;\n+}\n+\n+#define read1(in) (in->left == 0 ? readmore(in) : 0, \\\n+                   in->left--, *(in->next)++)\n+\n+/* skip over n bytes of in */\n+local void skip(file *in, unsigned n)\n+{\n+    unsigned bypass;\n+\n+    if (n > in->left) {\n+        n -= in->left;\n+        bypass = n & ~((1U << in->size) - 1);\n+        if (bypass) {\n+            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n+                bye(\"seeking \", in->name);\n+            n -= bypass;\n+        }\n+        readmore(in);\n+        if (n > in->left)\n+            bye(\"unexpected end of \", in->name);\n+    }\n+    in->left -= n;\n+    in->next += n;\n+}\n+\n+/* read a four-byte unsigned integer, little-endian, from in */\n+unsigned long read4(file *in)\n+{\n+    unsigned long val;\n+\n+    val = read1(in);\n+    val += (unsigned)read1(in) << 8;\n+    val += (unsigned long)read1(in) << 16;\n+    val += (unsigned long)read1(in) << 24;\n+    return val;\n+}\n+\n+/* skip over gzip header */\n+local void gzheader(file *in)\n+{\n+    int flags;\n+    unsigned n;\n+\n+    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n+    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n+    flags = read1(in);\n+    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n+    skip(in, 6);\n+    if (flags & 4) {\n+        n = read1(in);\n+        n += (unsigned)(read1(in)) << 8;\n+        skip(in, n);\n+    }\n+    if (flags & 8) while (read1(in) != 0) ;\n+    if (flags & 16) while (read1(in) != 0) ;\n+    if (flags & 2) skip(in, 2);\n+}\n+\n+/* decompress gzip file \"name\", return strm with a deflate stream ready to\n+   continue compression of the data in the gzip file, and return a file\n+   descriptor pointing to where to write the compressed data -- the deflate\n+   stream is initialized to compress using level \"level\" */\n+local int gzscan(char *name, z_stream *strm, int level)\n+{\n+    int ret, lastbit, left, full;\n+    unsigned have;\n+    unsigned long crc, tot;\n+    unsigned char *window;\n+    off_t lastoff, end;\n+    file gz;\n+\n+    /* open gzip file */\n+    gz.name = name;\n+    gz.fd = open(name, O_RDWR, 0);\n+    if (gz.fd == -1) bye(\"cannot open \", name);\n+    gz.buf = malloc(CHUNK);\n+    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n+    gz.size = LGCHUNK;\n+    gz.left = 0;\n+\n+    /* skip gzip header */\n+    gzheader(&gz);\n+\n+    /* prepare to decompress */\n+    window = malloc(DSIZE);\n+    if (window == NULL) bye(\"out of memory\", \"\");\n+    strm->zalloc = Z_NULL;\n+    strm->zfree = Z_NULL;\n+    strm->opaque = Z_NULL;\n+    ret = inflateInit2(strm, -15);\n+    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n+\n+    /* decompress the deflate stream, saving append information */\n+    lastbit = 0;\n+    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n+    left = 0;\n+    strm->avail_in = gz.left;\n+    strm->next_in = gz.next;\n+    crc = crc32(0L, Z_NULL, 0);\n+    have = full = 0;\n+    do {\n+        /* if needed, get more input */\n+        if (strm->avail_in == 0) {\n+            readmore(&gz);\n+            strm->avail_in = gz.left;\n+            strm->next_in = gz.next;\n+        }\n+\n+        /* set up output to next available section of sliding window */\n+        strm->avail_out = DSIZE - have;\n+        strm->next_out = window + have;\n+\n+        /* inflate and check for errors */\n+        ret = inflate(strm, Z_BLOCK);\n+        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n+        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n+        if (ret == Z_DATA_ERROR)\n+            bye(\"invalid compressed data--format violated in\", name);\n+\n+        /* update crc and sliding window pointer */\n+        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n+        if (strm->avail_out)\n+            have = DSIZE - strm->avail_out;\n+        else {\n+            have = 0;\n+            full = 1;\n+        }\n+\n+        /* process end of block */\n+        if (strm->data_type & 128) {\n+            if (strm->data_type & 64)\n+                left = strm->data_type & 0x1f;\n+            else {\n+                lastbit = strm->data_type & 0x1f;\n+                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n+            }\n+        }\n+    } while (ret != Z_STREAM_END);\n+    inflateEnd(strm);\n+    gz.left = strm->avail_in;\n+    gz.next = strm->next_in;\n+\n+    /* save the location of the end of the compressed data */\n+    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n+\n+    /* check gzip trailer and save total for deflate */\n+    if (crc != read4(&gz))\n+        bye(\"invalid compressed data--crc mismatch in \", name);\n+    tot = strm->total_out;\n+    if ((tot & 0xffffffffUL) != read4(&gz))\n+        bye(\"invalid compressed data--length mismatch in\", name);\n+\n+    /* if not at end of file, warn */\n+    if (gz.left || readin(&gz))\n+        fprintf(stderr,\n+            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n+\n+    /* clear last block bit */\n+    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n+    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n+    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n+    lseek(gz.fd, -1L, SEEK_CUR);\n+    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n+\n+    /* if window wrapped, build dictionary from window by rotating */\n+    if (full) {\n+        rotate(window, DSIZE, have);\n+        have = DSIZE;\n+    }\n+\n+    /* set up deflate stream with window, crc, total_in, and leftover bits */\n+    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n+    if (ret != Z_OK) bye(\"out of memory\", \"\");\n+    deflateSetDictionary(strm, window, have);\n+    strm->adler = crc;\n+    strm->total_in = tot;\n+    if (left) {\n+        lseek(gz.fd, --end, SEEK_SET);\n+        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n+        deflatePrime(strm, 8 - left, *gz.buf);\n+    }\n+    lseek(gz.fd, end, SEEK_SET);\n+\n+    /* clean up and return */\n+    free(window);\n+    free(gz.buf);\n+    return gz.fd;\n+}\n+\n+/* append file \"name\" to gzip file gd using deflate stream strm -- if last\n+   is true, then finish off the deflate stream at the end */\n+local void gztack(char *name, int gd, z_stream *strm, int last)\n+{\n+    int fd, len, ret;\n+    unsigned left;\n+    unsigned char *in, *out;\n+\n+    /* open file to compress and append */\n+    fd = 0;\n+    if (name != NULL) {\n+        fd = open(name, O_RDONLY, 0);\n+        if (fd == -1)\n+            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n+                    name);\n+    }\n+\n+    /* allocate buffers */\n+    in = fd == -1 ? NULL : malloc(CHUNK);\n+    out = malloc(CHUNK);\n+    if (out == NULL) bye(\"out of memory\", \"\");\n+\n+    /* compress input file and append to gzip file */\n+    do {\n+        /* get more input */\n+        len = fd == -1 ? 0 : read(fd, in, CHUNK);\n+        if (len == -1) {\n+            fprintf(stderr,\n+                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n+                    name);\n+            len = 0;\n+        }\n+        strm->avail_in = (unsigned)len;\n+        strm->next_in = in;\n+        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n+\n+        /* compress and write all available output */\n+        do {\n+            strm->avail_out = CHUNK;\n+            strm->next_out = out;\n+            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n+            left = CHUNK - strm->avail_out;\n+            while (left) {\n+                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n+                if (len == -1) bye(\"writing gzip file\", \"\");\n+                left -= (unsigned)len;\n+            }\n+        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n+    } while (len != 0);\n+\n+    /* write trailer after last entry */\n+    if (last) {\n+        deflateEnd(strm);\n+        out[0] = (unsigned char)(strm->adler);\n+        out[1] = (unsigned char)(strm->adler >> 8);\n+        out[2] = (unsigned char)(strm->adler >> 16);\n+        out[3] = (unsigned char)(strm->adler >> 24);\n+        out[4] = (unsigned char)(strm->total_in);\n+        out[5] = (unsigned char)(strm->total_in >> 8);\n+        out[6] = (unsigned char)(strm->total_in >> 16);\n+        out[7] = (unsigned char)(strm->total_in >> 24);\n+        len = 8;\n+        do {\n+            ret = write(gd, out + 8 - len, len);\n+            if (ret == -1) bye(\"writing gzip file\", \"\");\n+            len -= ret;\n+        } while (len);\n+        close(gd);\n+    }\n+\n+    /* clean up and return */\n+    free(out);\n+    if (in != NULL) free(in);\n+    if (fd > 0) close(fd);\n+}\n+\n+/* process the compression level option if present, scan the gzip file, and\n+   append the specified files, or append the data from stdin if no other file\n+   names are provided on the command line -- the gzip file must be writable\n+   and seekable */\n+int main(int argc, char **argv)\n+{\n+    int gd, level;\n+    z_stream strm;\n+\n+    /* ignore command name */\n+    argv++;\n+\n+    /* provide usage if no arguments */\n+    if (*argv == NULL) {\n+        printf(\"gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\\n\");\n+        printf(\n+            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n+        return 0;\n+    }\n+\n+    /* set compression level */\n+    level = Z_DEFAULT_COMPRESSION;\n+    if (argv[0][0] == '-') {\n+        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n+            bye(\"invalid compression level\", \"\");\n+        level = argv[0][1] - '0';\n+        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n+    }\n+\n+    /* prepare to append to gzip file */\n+    gd = gzscan(*argv++, &strm, level);\n+\n+    /* append files on command line, or from stdin if none */\n+    if (*argv == NULL)\n+        gztack(NULL, gd, &strm, 1);\n+    else\n+        do {\n+            gztack(*argv, gd, &strm, argv[1] == NULL);\n+        } while (*++argv != NULL);\n+    return 0;\n+}"}, {"sha": "129347ce3cac2d293508f09cf6683458486b2b63", "filename": "zlib/examples/gzjoin.c", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzjoin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzjoin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fgzjoin.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,448 @@\n+/* gzjoin -- command to join gzip files into one gzip file\n+\n+  Copyright (C) 2004 Mark Adler, all rights reserved\n+  version 1.0, 11 Dec 2004\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.0  11 Dec 2004     - First version\n+ * 1.1  12 Jun 2005     - Changed ssize_t to long for portability\n+ */\n+\n+/*\n+   gzjoin takes one or more gzip files on the command line and writes out a\n+   single gzip file that will uncompress to the concatenation of the\n+   uncompressed data from the individual gzip files.  gzjoin does this without\n+   having to recompress any of the data and without having to calculate a new\n+   crc32 for the concatenated uncompressed data.  gzjoin does however have to\n+   decompress all of the input data in order to find the bits in the compressed\n+   data that need to be modified to concatenate the streams.\n+\n+   gzjoin does not do an integrity check on the input gzip files other than\n+   checking the gzip header and decompressing the compressed data.  They are\n+   otherwise assumed to be complete and correct.\n+\n+   Each joint between gzip files removes at least 18 bytes of previous trailer\n+   and subsequent header, and inserts an average of about three bytes to the\n+   compressed data in order to connect the streams.  The output gzip file\n+   has a minimal ten-byte gzip header with no file name or modification time.\n+\n+   This program was written to illustrate the use of the Z_BLOCK option of\n+   inflate() and the crc32_combine() function.  gzjoin will not compile with\n+   versions of zlib earlier than 1.2.3.\n+ */\n+\n+#include <stdio.h>      /* fputs(), fprintf(), fwrite(), putc() */\n+#include <stdlib.h>     /* exit(), malloc(), free() */\n+#include <fcntl.h>      /* open() */\n+#include <unistd.h>     /* close(), read(), lseek() */\n+#include \"zlib.h\"\n+    /* crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() */\n+\n+#define local static\n+\n+/* exit with an error (return a value to allow use in an expression) */\n+local int bail(char *why1, char *why2)\n+{\n+    fprintf(stderr, \"gzjoin error: %s%s, output incomplete\\n\", why1, why2);\n+    exit(1);\n+    return 0;\n+}\n+\n+/* -- simple buffered file input with access to the buffer -- */\n+\n+#define CHUNK 32768         /* must be a power of two and fit in unsigned */\n+\n+/* bin buffered input file type */\n+typedef struct {\n+    char *name;             /* name of file for error messages */\n+    int fd;                 /* file descriptor */\n+    unsigned left;          /* bytes remaining at next */\n+    unsigned char *next;    /* next byte to read */\n+    unsigned char *buf;     /* allocated buffer of length CHUNK */\n+} bin;\n+\n+/* close a buffered file and free allocated memory */\n+local void bclose(bin *in)\n+{\n+    if (in != NULL) {\n+        if (in->fd != -1)\n+            close(in->fd);\n+        if (in->buf != NULL)\n+            free(in->buf);\n+        free(in);\n+    }\n+}\n+\n+/* open a buffered file for input, return a pointer to type bin, or NULL on\n+   failure */\n+local bin *bopen(char *name)\n+{\n+    bin *in;\n+\n+    in = malloc(sizeof(bin));\n+    if (in == NULL)\n+        return NULL;\n+    in->buf = malloc(CHUNK);\n+    in->fd = open(name, O_RDONLY, 0);\n+    if (in->buf == NULL || in->fd == -1) {\n+        bclose(in);\n+        return NULL;\n+    }\n+    in->left = 0;\n+    in->next = in->buf;\n+    in->name = name;\n+    return in;\n+}\n+\n+/* load buffer from file, return -1 on read error, 0 or 1 on success, with\n+   1 indicating that end-of-file was reached */\n+local int bload(bin *in)\n+{\n+    long len;\n+\n+    if (in == NULL)\n+        return -1;\n+    if (in->left != 0)\n+        return 0;\n+    in->next = in->buf;\n+    do {\n+        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);\n+        if (len < 0)\n+            return -1;\n+        in->left += (unsigned)len;\n+    } while (len != 0 && in->left < CHUNK);\n+    return len == 0 ? 1 : 0;\n+}\n+\n+/* get a byte from the file, bail if end of file */\n+#define bget(in) (in->left ? 0 : bload(in), \\\n+                  in->left ? (in->left--, *(in->next)++) : \\\n+                    bail(\"unexpected end of file on \", in->name))\n+\n+/* get a four-byte little-endian unsigned integer from file */\n+local unsigned long bget4(bin *in)\n+{\n+    unsigned long val;\n+\n+    val = bget(in);\n+    val += (unsigned long)(bget(in)) << 8;\n+    val += (unsigned long)(bget(in)) << 16;\n+    val += (unsigned long)(bget(in)) << 24;\n+    return val;\n+}\n+\n+/* skip bytes in file */\n+local void bskip(bin *in, unsigned skip)\n+{\n+    /* check pointer */\n+    if (in == NULL)\n+        return;\n+\n+    /* easy case -- skip bytes in buffer */\n+    if (skip <= in->left) {\n+        in->left -= skip;\n+        in->next += skip;\n+        return;\n+    }\n+\n+    /* skip what's in buffer, discard buffer contents */\n+    skip -= in->left;\n+    in->left = 0;\n+\n+    /* seek past multiples of CHUNK bytes */\n+    if (skip > CHUNK) {\n+        unsigned left;\n+\n+        left = skip & (CHUNK - 1);\n+        if (left == 0) {\n+            /* exact number of chunks: seek all the way minus one byte to check\n+               for end-of-file with a read */\n+            lseek(in->fd, skip - 1, SEEK_CUR);\n+            if (read(in->fd, in->buf, 1) != 1)\n+                bail(\"unexpected end of file on \", in->name);\n+            return;\n+        }\n+\n+        /* skip the integral chunks, update skip with remainder */\n+        lseek(in->fd, skip - left, SEEK_CUR);\n+        skip = left;\n+    }\n+\n+    /* read more input and skip remainder */\n+    bload(in);\n+    if (skip > in->left)\n+        bail(\"unexpected end of file on \", in->name);\n+    in->left -= skip;\n+    in->next += skip;\n+}\n+\n+/* -- end of buffered input functions -- */\n+\n+/* skip the gzip header from file in */\n+local void gzhead(bin *in)\n+{\n+    int flags;\n+\n+    /* verify gzip magic header and compression method */\n+    if (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)\n+        bail(in->name, \" is not a valid gzip file\");\n+\n+    /* get and verify flags */\n+    flags = bget(in);\n+    if ((flags & 0xe0) != 0)\n+        bail(\"unknown reserved bits set in \", in->name);\n+\n+    /* skip modification time, extra flags, and os */\n+    bskip(in, 6);\n+\n+    /* skip extra field if present */\n+    if (flags & 4) {\n+        unsigned len;\n+\n+        len = bget(in);\n+        len += (unsigned)(bget(in)) << 8;\n+        bskip(in, len);\n+    }\n+\n+    /* skip file name if present */\n+    if (flags & 8)\n+        while (bget(in) != 0)\n+            ;\n+\n+    /* skip comment if present */\n+    if (flags & 16)\n+        while (bget(in) != 0)\n+            ;\n+\n+    /* skip header crc if present */\n+    if (flags & 2)\n+        bskip(in, 2);\n+}\n+\n+/* write a four-byte little-endian unsigned integer to out */\n+local void put4(unsigned long val, FILE *out)\n+{\n+    putc(val & 0xff, out);\n+    putc((val >> 8) & 0xff, out);\n+    putc((val >> 16) & 0xff, out);\n+    putc((val >> 24) & 0xff, out);\n+}\n+\n+/* Load up zlib stream from buffered input, bail if end of file */\n+local void zpull(z_streamp strm, bin *in)\n+{\n+    if (in->left == 0)\n+        bload(in);\n+    if (in->left == 0)\n+        bail(\"unexpected end of file on \", in->name);\n+    strm->avail_in = in->left;\n+    strm->next_in = in->next;\n+}\n+\n+/* Write header for gzip file to out and initialize trailer. */\n+local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)\n+{\n+    fwrite(\"\\x1f\\x8b\\x08\\0\\0\\0\\0\\0\\0\\xff\", 1, 10, out);\n+    *crc = crc32(0L, Z_NULL, 0);\n+    *tot = 0;\n+}\n+\n+/* Copy the compressed data from name, zeroing the last block bit of the last\n+   block if clr is true, and adding empty blocks as needed to get to a byte\n+   boundary.  If clr is false, then the last block becomes the last block of\n+   the output, and the gzip trailer is written.  crc and tot maintains the\n+   crc and length (modulo 2^32) of the output for the trailer.  The resulting\n+   gzip file is written to out.  gzinit() must be called before the first call\n+   of gzcopy() to write the gzip header and to initialize crc and tot. */\n+local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,\n+                  FILE *out)\n+{\n+    int ret;                /* return value from zlib functions */\n+    int pos;                /* where the \"last block\" bit is in byte */\n+    int last;               /* true if processing the last block */\n+    bin *in;                /* buffered input file */\n+    unsigned char *start;   /* start of compressed data in buffer */\n+    unsigned char *junk;    /* buffer for uncompressed data -- discarded */\n+    z_off_t len;            /* length of uncompressed data (support > 4 GB) */\n+    z_stream strm;          /* zlib inflate stream */\n+\n+    /* open gzip file and skip header */\n+    in = bopen(name);\n+    if (in == NULL)\n+        bail(\"could not open \", name);\n+    gzhead(in);\n+\n+    /* allocate buffer for uncompressed data and initialize raw inflate\n+       stream */\n+    junk = malloc(CHUNK);\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, -15);\n+    if (junk == NULL || ret != Z_OK)\n+        bail(\"out of memory\", \"\");\n+\n+    /* inflate and copy compressed data, clear last-block bit if requested */\n+    len = 0;\n+    zpull(&strm, in);\n+    start = strm.next_in;\n+    last = start[0] & 1;\n+    if (last && clr)\n+        start[0] &= ~1;\n+    strm.avail_out = 0;\n+    for (;;) {\n+        /* if input used and output done, write used input and get more */\n+        if (strm.avail_in == 0 && strm.avail_out != 0) {\n+            fwrite(start, 1, strm.next_in - start, out);\n+            start = in->buf;\n+            in->left = 0;\n+            zpull(&strm, in);\n+        }\n+\n+        /* decompress -- return early when end-of-block reached */\n+        strm.avail_out = CHUNK;\n+        strm.next_out = junk;\n+        ret = inflate(&strm, Z_BLOCK);\n+        switch (ret) {\n+        case Z_MEM_ERROR:\n+            bail(\"out of memory\", \"\");\n+        case Z_DATA_ERROR:\n+            bail(\"invalid compressed data in \", in->name);\n+        }\n+\n+        /* update length of uncompressed data */\n+        len += CHUNK - strm.avail_out;\n+\n+        /* check for block boundary (only get this when block copied out) */\n+        if (strm.data_type & 128) {\n+            /* if that was the last block, then done */\n+            if (last)\n+                break;\n+\n+            /* number of unused bits in last byte */\n+            pos = strm.data_type & 7;\n+\n+            /* find the next last-block bit */\n+            if (pos != 0) {\n+                /* next last-block bit is in last used byte */\n+                pos = 0x100 >> pos;\n+                last = strm.next_in[-1] & pos;\n+                if (last && clr)\n+                    strm.next_in[-1] &= ~pos;\n+            }\n+            else {\n+                /* next last-block bit is in next unused byte */\n+                if (strm.avail_in == 0) {\n+                    /* don't have that byte yet -- get it */\n+                    fwrite(start, 1, strm.next_in - start, out);\n+                    start = in->buf;\n+                    in->left = 0;\n+                    zpull(&strm, in);\n+                }\n+                last = strm.next_in[0] & 1;\n+                if (last && clr)\n+                    strm.next_in[0] &= ~1;\n+            }\n+        }\n+    }\n+\n+    /* update buffer with unused input */\n+    in->left = strm.avail_in;\n+    in->next = strm.next_in;\n+\n+    /* copy used input, write empty blocks to get to byte boundary */\n+    pos = strm.data_type & 7;\n+    fwrite(start, 1, in->next - start - 1, out);\n+    last = in->next[-1];\n+    if (pos == 0 || !clr)\n+        /* already at byte boundary, or last file: write last byte */\n+        putc(last, out);\n+    else {\n+        /* append empty blocks to last byte */\n+        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */\n+        if (pos & 1) {\n+            /* odd -- append an empty stored block */\n+            putc(last, out);\n+            if (pos == 1)\n+                putc(0, out);               /* two more bits in block header */\n+            fwrite(\"\\0\\0\\xff\\xff\", 1, 4, out);\n+        }\n+        else {\n+            /* even -- append 1, 2, or 3 empty fixed blocks */\n+            switch (pos) {\n+            case 6:\n+                putc(last | 8, out);\n+                last = 0;\n+            case 4:\n+                putc(last | 0x20, out);\n+                last = 0;\n+            case 2:\n+                putc(last | 0x80, out);\n+                putc(0, out);\n+            }\n+        }\n+    }\n+\n+    /* update crc and tot */\n+    *crc = crc32_combine(*crc, bget4(in), len);\n+    *tot += (unsigned long)len;\n+\n+    /* clean up */\n+    inflateEnd(&strm);\n+    free(junk);\n+    bclose(in);\n+\n+    /* write trailer if this is the last gzip file */\n+    if (!clr) {\n+        put4(*crc, out);\n+        put4(*tot, out);\n+    }\n+}\n+\n+/* join the gzip files on the command line, write result to stdout */\n+int main(int argc, char **argv)\n+{\n+    unsigned long crc, tot;     /* running crc and total uncompressed length */\n+\n+    /* skip command name */\n+    argc--;\n+    argv++;\n+\n+    /* show usage if no arguments */\n+    if (argc == 0) {\n+        fputs(\"gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\\n\",\n+              stderr);\n+        return 0;\n+    }\n+\n+    /* join gzip files on command line and write to stdout */\n+    gzinit(&crc, &tot, stdout);\n+    while (argc--)\n+        gzcopy(*argv++, argc, &crc, &tot, stdout);\n+\n+    /* done */\n+    return 0;\n+}"}, {"sha": "f71f817c8b6e129de06d61c4851fa99a00d8f690", "filename": "zlib/examples/gzlog.c", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzlog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzlog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fgzlog.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,413 @@\n+/*\n+ * gzlog.c\n+ * Copyright (C) 2004 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in gzlog.h\n+ * version 1.0, 26 Nov 2004\n+ *\n+ */\n+\n+#include <string.h>             /* memcmp() */\n+#include <stdlib.h>             /* malloc(), free(), NULL */\n+#include <sys/types.h>          /* size_t, off_t */\n+#include <unistd.h>             /* read(), close(), sleep(), ftruncate(), */\n+                                /* lseek() */\n+#include <fcntl.h>              /* open() */\n+#include <sys/file.h>           /* flock() */\n+#include \"zlib.h\"               /* deflateInit2(), deflate(), deflateEnd() */\n+\n+#include \"gzlog.h\"              /* interface */\n+#define local static\n+\n+/* log object structure */\n+typedef struct {\n+    int id;                 /* object identifier */\n+    int fd;                 /* log file descriptor */\n+    off_t extra;            /* offset of extra \"ap\" subfield */\n+    off_t mark_off;         /* offset of marked data */\n+    off_t last_off;         /* offset of last block */\n+    unsigned long crc;      /* uncompressed crc */\n+    unsigned long len;      /* uncompressed length (modulo 2^32) */\n+    unsigned stored;        /* length of current stored block */\n+} gz_log;\n+\n+#define GZLOGID 19334       /* gz_log object identifier */\n+\n+#define LOCK_RETRY 1            /* retry lock once a second */\n+#define LOCK_PATIENCE 1200      /* try about twenty minutes before forcing */\n+\n+/* acquire a lock on a file */\n+local int lock(int fd)\n+{\n+    int patience;\n+\n+    /* try to lock every LOCK_RETRY seconds for LOCK_PATIENCE seconds */\n+    patience = LOCK_PATIENCE;\n+    do {\n+        if (flock(fd, LOCK_EX + LOCK_NB) == 0)\n+            return 0;\n+        (void)sleep(LOCK_RETRY);\n+        patience -= LOCK_RETRY;\n+    } while (patience > 0);\n+\n+    /* we've run out of patience -- give up */\n+    return -1;\n+}\n+\n+/* release lock */\n+local void unlock(int fd)\n+{\n+    (void)flock(fd, LOCK_UN);\n+}\n+\n+/* release a log object */\n+local void log_clean(gz_log *log)\n+{\n+    unlock(log->fd);\n+    (void)close(log->fd);\n+    free(log);\n+}\n+\n+/* read an unsigned long from a byte buffer little-endian */\n+local unsigned long make_ulg(unsigned char *buf)\n+{\n+    int n;\n+    unsigned long val;\n+\n+    val = (unsigned long)(*buf++);\n+    for (n = 8; n < 32; n += 8)\n+        val += (unsigned long)(*buf++) << n;\n+    return val;\n+}\n+\n+/* read an off_t from a byte buffer little-endian */\n+local off_t make_off(unsigned char *buf)\n+{\n+    int n;\n+    off_t val;\n+\n+    val = (off_t)(*buf++);\n+    for (n = 8; n < 64; n += 8)\n+        val += (off_t)(*buf++) << n;\n+    return val;\n+}\n+\n+/* write an unsigned long little-endian to byte buffer */\n+local void dice_ulg(unsigned long val, unsigned char *buf)\n+{\n+    int n;\n+\n+    for (n = 0; n < 4; n++) {\n+        *buf++ = val & 0xff;\n+        val >>= 8;\n+    }\n+}\n+\n+/* write an off_t little-endian to byte buffer */\n+local void dice_off(off_t val, unsigned char *buf)\n+{\n+    int n;\n+\n+    for (n = 0; n < 8; n++) {\n+        *buf++ = val & 0xff;\n+        val >>= 8;\n+    }\n+}\n+\n+/* initial, empty gzip file for appending */\n+local char empty_gz[] = {\n+    0x1f, 0x8b,                 /* magic gzip id */\n+    8,                          /* compression method is deflate */\n+    4,                          /* there is an extra field */\n+    0, 0, 0, 0,                 /* no modification time provided */\n+    0, 0xff,                    /* no extra flags, no OS */\n+    20, 0, 'a', 'p', 16, 0,     /* extra field with \"ap\" subfield */\n+    32, 0, 0, 0, 0, 0, 0, 0,    /* offset of uncompressed data */\n+    32, 0, 0, 0, 0, 0, 0, 0,    /* offset of last block */\n+    1, 0, 0, 0xff, 0xff,        /* empty stored block (last) */\n+    0, 0, 0, 0,                 /* crc */\n+    0, 0, 0, 0                  /* uncompressed length */\n+};\n+\n+/* initialize a log object with locking */\n+void *gzlog_open(char *path)\n+{\n+    unsigned xlen;\n+    unsigned char temp[20];\n+    unsigned sub_len;\n+    int good;\n+    gz_log *log;\n+\n+    /* allocate log structure */\n+    log = malloc(sizeof(gz_log));\n+    if (log == NULL)\n+        return NULL;\n+    log->id = GZLOGID;\n+\n+    /* open file, creating it if necessary, and locking it */\n+    log->fd = open(path, O_RDWR | O_CREAT, 0600);\n+    if (log->fd < 0) {\n+        free(log);\n+        return NULL;\n+    }\n+    if (lock(log->fd)) {\n+        close(log->fd);\n+        free(log);\n+        return NULL;\n+    }\n+\n+    /* if file is empty, write new gzip stream */\n+    if (lseek(log->fd, 0, SEEK_END) == 0) {\n+        if (write(log->fd, empty_gz, sizeof(empty_gz)) != sizeof(empty_gz)) {\n+            log_clean(log);\n+            return NULL;\n+        }\n+    }\n+\n+    /* check gzip header */\n+    (void)lseek(log->fd, 0, SEEK_SET);\n+    if (read(log->fd, temp, 12) != 12 || temp[0] != 0x1f ||\n+        temp[1] != 0x8b || temp[2] != 8 || (temp[3] & 4) == 0) {\n+        log_clean(log);\n+        return NULL;\n+    }\n+\n+    /* process extra field to find \"ap\" sub-field */\n+    xlen = temp[10] + (temp[11] << 8);\n+    good = 0;\n+    while (xlen) {\n+        if (xlen < 4 || read(log->fd, temp, 4) != 4)\n+            break;\n+        sub_len = temp[2];\n+        sub_len += temp[3] << 8;\n+        xlen -= 4;\n+        if (memcmp(temp, \"ap\", 2) == 0 && sub_len == 16) {\n+            good = 1;\n+            break;\n+        }\n+        if (xlen < sub_len)\n+            break;\n+        (void)lseek(log->fd, sub_len, SEEK_CUR);\n+        xlen -= sub_len;\n+    }\n+    if (!good) {\n+        log_clean(log);\n+        return NULL;\n+    }\n+\n+    /* read in \"ap\" sub-field */\n+    log->extra = lseek(log->fd, 0, SEEK_CUR);\n+    if (read(log->fd, temp, 16) != 16) {\n+        log_clean(log);\n+        return NULL;\n+    }\n+    log->mark_off = make_off(temp);\n+    log->last_off = make_off(temp + 8);\n+\n+    /* get crc, length of gzip file */\n+    (void)lseek(log->fd, log->last_off, SEEK_SET);\n+    if (read(log->fd, temp, 13) != 13 ||\n+        memcmp(temp, \"\\001\\000\\000\\377\\377\", 5) != 0) {\n+        log_clean(log);\n+        return NULL;\n+    }\n+    log->crc = make_ulg(temp + 5);\n+    log->len = make_ulg(temp + 9);\n+\n+    /* set up to write over empty last block */\n+    (void)lseek(log->fd, log->last_off + 5, SEEK_SET);\n+    log->stored = 0;\n+    return (void *)log;\n+}\n+\n+/* maximum amount to put in a stored block before starting a new one */\n+#define MAX_BLOCK 16384\n+\n+/* write a block to a log object */\n+int gzlog_write(void *obj, char *data, size_t len)\n+{\n+    size_t some;\n+    unsigned char temp[5];\n+    gz_log *log;\n+\n+    /* check object */\n+    log = (gz_log *)obj;\n+    if (log == NULL || log->id != GZLOGID)\n+        return 1;\n+\n+    /* write stored blocks until all of the input is written */\n+    do {\n+        some = MAX_BLOCK - log->stored;\n+        if (some > len)\n+            some = len;\n+        if (write(log->fd, data, some) != some)\n+            return 1;\n+        log->crc = crc32(log->crc, data, some);\n+        log->len += some;\n+        len -= some;\n+        data += some;\n+        log->stored += some;\n+\n+        /* if the stored block is full, end it and start another */\n+        if (log->stored == MAX_BLOCK) {\n+            (void)lseek(log->fd, log->last_off, SEEK_SET);\n+            temp[0] = 0;\n+            dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),\n+                     temp + 1);\n+            if (write(log->fd, temp, 5) != 5)\n+                return 1;\n+            log->last_off = lseek(log->fd, log->stored, SEEK_CUR);\n+            (void)lseek(log->fd, 5, SEEK_CUR);\n+            log->stored = 0;\n+        }\n+    } while (len);\n+    return 0;\n+}\n+\n+/* recompress the remaining stored deflate data in place */\n+local int recomp(gz_log *log)\n+{\n+    z_stream strm;\n+    size_t len, max;\n+    unsigned char *in;\n+    unsigned char *out;\n+    unsigned char temp[16];\n+\n+    /* allocate space and read it all in (it's around 1 MB) */\n+    len = log->last_off - log->mark_off;\n+    max = len + (len >> 12) + (len >> 14) + 11;\n+    out = malloc(max);\n+    if (out == NULL)\n+        return 1;\n+    in = malloc(len);\n+    if (in == NULL) {\n+        free(out);\n+        return 1;\n+    }\n+    (void)lseek(log->fd, log->mark_off, SEEK_SET);\n+    if (read(log->fd, in, len) != len) {\n+        free(in);\n+        free(out);\n+        return 1;\n+    }\n+\n+    /* recompress in memory, decoding stored data as we go */\n+    /* note: this assumes that unsigned is four bytes or more */\n+    /*       consider not making that assumption */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    if (deflateInit2(&strm, Z_BEST_COMPRESSION, Z_DEFLATED, -15, 8,\n+        Z_DEFAULT_STRATEGY) != Z_OK) {\n+        free(in);\n+        free(out);\n+        return 1;\n+    }\n+    strm.next_in = in;\n+    strm.avail_out = max;\n+    strm.next_out = out;\n+    while (len >= 5) {\n+        if (strm.next_in[0] != 0)\n+            break;\n+        strm.avail_in = strm.next_in[1] + (strm.next_in[2] << 8);\n+        strm.next_in += 5;\n+        len -= 5;\n+        if (strm.avail_in != 0) {\n+            if (len < strm.avail_in)\n+                break;\n+            len -= strm.avail_in;\n+            (void)deflate(&strm, Z_NO_FLUSH);\n+            if (strm.avail_in != 0 || strm.avail_out == 0)\n+                break;\n+        }\n+    }\n+    (void)deflate(&strm, Z_SYNC_FLUSH);\n+    (void)deflateEnd(&strm);\n+    free(in);\n+    if (len != 0 || strm.avail_out == 0) {\n+        free(out);\n+        return 1;\n+    }\n+\n+    /* overwrite stored data with compressed data */\n+    (void)lseek(log->fd, log->mark_off, SEEK_SET);\n+    len = max - strm.avail_out;\n+    if (write(log->fd, out, len) != len) {\n+        free(out);\n+        return 1;\n+    }\n+    free(out);\n+\n+    /* write last empty block, crc, and length */\n+    log->mark_off = log->last_off = lseek(log->fd, 0, SEEK_CUR);\n+    temp[0] = 1;\n+    dice_ulg(0xffffL << 16, temp + 1);\n+    dice_ulg(log->crc, temp + 5);\n+    dice_ulg(log->len, temp + 9);\n+    if (write(log->fd, temp, 13) != 13)\n+        return 1;\n+\n+    /* truncate file to discard remaining stored data and old trailer */\n+    ftruncate(log->fd, lseek(log->fd, 0, SEEK_CUR));\n+\n+    /* update extra field to point to new last empty block */\n+    (void)lseek(log->fd, log->extra, SEEK_SET);\n+    dice_off(log->mark_off, temp);\n+    dice_off(log->last_off, temp + 8);\n+    if (write(log->fd, temp, 16) != 16)\n+        return 1;\n+    return 0;\n+}\n+\n+/* maximum accumulation of stored blocks before compressing */\n+#define MAX_STORED 1048576\n+\n+/* close log object */\n+int gzlog_close(void *obj)\n+{\n+    unsigned char temp[8];\n+    gz_log *log;\n+\n+    /* check object */\n+    log = (gz_log *)obj;\n+    if (log == NULL || log->id != GZLOGID)\n+        return 1;\n+\n+    /* go to start of most recent block being written */\n+    (void)lseek(log->fd, log->last_off, SEEK_SET);\n+\n+    /* if some stuff was put there, update block */\n+    if (log->stored) {\n+        temp[0] = 0;\n+        dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),\n+                 temp + 1);\n+        if (write(log->fd, temp, 5) != 5)\n+            return 1;\n+        log->last_off = lseek(log->fd, log->stored, SEEK_CUR);\n+    }\n+\n+    /* write last block (empty) */\n+    if (write(log->fd, \"\\001\\000\\000\\377\\377\", 5) != 5)\n+        return 1;\n+\n+    /* write updated crc and uncompressed length */\n+    dice_ulg(log->crc, temp);\n+    dice_ulg(log->len, temp + 4);\n+    if (write(log->fd, temp, 8) != 8)\n+        return 1;\n+\n+    /* put offset of that last block in gzip extra block */\n+    (void)lseek(log->fd, log->extra + 8, SEEK_SET);\n+    dice_off(log->last_off, temp);\n+    if (write(log->fd, temp, 8) != 8)\n+        return 1;\n+\n+    /* if more than 1 MB stored, then time to compress it */\n+    if (log->last_off - log->mark_off > MAX_STORED) {\n+        if (recomp(log))\n+            return 1;\n+    }\n+\n+    /* unlock and close file */\n+    log_clean(log);\n+    return 0;\n+}"}, {"sha": "a800bd539178467ec030226615aca237d7e8b501", "filename": "zlib/examples/gzlog.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzlog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fgzlog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fgzlog.h?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,58 @@\n+/* gzlog.h\n+  Copyright (C) 2004 Mark Adler, all rights reserved\n+  version 1.0, 26 Nov 2004\n+\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the author be held liable for any damages\n+  arising from the use of this software.\n+\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+\n+  1. The origin of this software must not be misrepresented; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+  2. Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+  3. This notice may not be removed or altered from any source distribution.\n+\n+  Mark Adler    madler@alumni.caltech.edu\n+ */\n+\n+/*\n+   The gzlog object allows writing short messages to a gzipped log file,\n+   opening the log file locked for small bursts, and then closing it.  The log\n+   object works by appending stored data to the gzip file until 1 MB has been\n+   accumulated.  At that time, the stored data is compressed, and replaces the\n+   uncompressed data in the file.  The log file is truncated to its new size at\n+   that time.  After closing, the log file is always valid gzip file that can\n+   decompressed to recover what was written.\n+\n+   A gzip header \"extra\" field contains two file offsets for appending.  The\n+   first points to just after the last compressed data.  The second points to\n+   the last stored block in the deflate stream, which is empty.  All of the\n+   data between those pointers is uncompressed.\n+ */\n+\n+/* Open a gzlog object, creating the log file if it does not exist.  Return\n+   NULL on error.  Note that gzlog_open() could take a long time to return if\n+   there is difficulty in locking the file. */\n+void *gzlog_open(char *path);\n+\n+/* Write to a gzlog object.  Return non-zero on error.  This function will\n+   simply write data to the file uncompressed.  Compression of the data\n+   will not occur until gzlog_close() is called.  It is expected that\n+   gzlog_write() is used for a short message, and then gzlog_close() is\n+   called.  If a large amount of data is to be written, then the application\n+   should write no more than 1 MB at a time with gzlog_write() before\n+   calling gzlog_close() and then gzlog_open() again. */\n+int gzlog_write(void *log, char *data, size_t len);\n+\n+/* Close a gzlog object.  Return non-zero on error.  The log file is locked\n+   until this function is called.  This function will compress stored data\n+   at the end of the gzip file if at least 1 MB has been accumulated.  Note\n+   that the file will not be a valid gzip file until this function completes.\n+ */\n+int gzlog_close(void *log);"}, {"sha": "40998dbf08a25c315af0f91ea4ac68a025f1a7c1", "filename": "zlib/examples/zlib_how.html", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzlib_how.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzlib_how.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fzlib_how.html?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,523 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\n+  \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n+<html>\n+<head>\n+<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n+<title>zlib Usage Example</title>\n+<!--  Copyright (c) 2004 Mark Adler.  -->\n+</head>\n+<body bgcolor=\"#FFFFFF\" text=\"#000000\" link=\"#0000FF\" vlink=\"#00A000\">\n+<h2 align=\"center\"> zlib Usage Example </h2>\n+We often get questions about how the <tt>deflate()</tt> and <tt>inflate()</tt> functions should be used.\n+Users wonder when they should provide more input, when they should use more output,\n+what to do with a <tt>Z_BUF_ERROR</tt>, how to make sure the process terminates properly, and\n+so on.  So for those who have read <tt>zlib.h</tt> (a few times), and\n+would like further edification, below is an annotated example in C of simple routines to compress and decompress\n+from an input file to an output file using <tt>deflate()</tt> and <tt>inflate()</tt> respectively.  The\n+annotations are interspersed between lines of the code.  So please read between the lines.\n+We hope this helps explain some of the intricacies of <em>zlib</em>.\n+<p>\n+Without further adieu, here is the program <a href=\"zpipe.c\"><tt>zpipe.c</tt></a>:\n+<pre><b>\n+/* zpipe.c: example of proper use of zlib's inflate() and deflate()\n+   Not copyrighted -- provided to the public domain\n+   Version 1.2  9 November 2004  Mark Adler */\n+\n+/* Version history:\n+   1.0  30 Oct 2004  First version\n+   1.1   8 Nov 2004  Add void casting for unused return values\n+                     Use switch statement for inflate() return values\n+   1.2   9 Nov 2004  Add assertions to document zlib guarantees\n+ */\n+</b></pre><!-- -->\n+We now include the header files for the required definitions.  From\n+<tt>stdio.h</tt> we use <tt>fopen()</tt>, <tt>fread()</tt>, <tt>fwrite()</tt>,\n+<tt>feof()</tt>, <tt>ferror()</tt>, and <tt>fclose()</tt> for file i/o, and\n+<tt>fputs()</tt> for error messages.  From <tt>string.h</tt> we use\n+<tt>strcmp()</tt> for command line argument processing.\n+From <tt>assert.h</tt> we use the <tt>assert()</tt> macro.\n+From <tt>zlib.h</tt>\n+we use the basic compression functions <tt>deflateInit()</tt>,\n+<tt>deflate()</tt>, and <tt>deflateEnd()</tt>, and the basic decompression\n+functions <tt>inflateInit()</tt>, <tt>inflate()</tt>, and\n+<tt>inflateEnd()</tt>.\n+<pre><b>\n+#include &lt;stdio.h&gt;\n+#include &lt;string.h&gt;\n+#include &lt;assert.h&gt;\n+#include \"zlib.h\"\n+</b></pre><!-- -->\n+<tt>CHUNK</tt> is simply the buffer size for feeding data to and pulling data\n+from the <em>zlib</em> routines.  Larger buffer sizes would be more efficient,\n+especially for <tt>inflate()</tt>.  If the memory is available, buffers sizes\n+on the order of 128K or 256K bytes should be used.\n+<pre><b>\n+#define CHUNK 16384\n+</b></pre><!-- -->\n+The <tt>def()</tt> routine compresses data from an input file to an output file.  The output data\n+will be in the <em>zlib</em> format, which is different from the <em>gzip</em> or <em>zip</em>\n+formats.  The <em>zlib</em> format has a very small header of only two bytes to identify it as\n+a <em>zlib</em> stream and to provide decoding information, and a four-byte trailer with a fast\n+check value to verify the integrity of the uncompressed data after decoding.\n+<pre><b>\n+/* Compress from file source to file dest until EOF on source.\n+   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n+   allocated for processing, Z_STREAM_ERROR if an invalid compression\n+   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the\n+   version of the library linked do not match, or Z_ERRNO if there is\n+   an error reading or writing the files. */\n+int def(FILE *source, FILE *dest, int level)\n+{\n+</b></pre>\n+Here are the local variables for <tt>def()</tt>.  <tt>ret</tt> will be used for <em>zlib</em>\n+return codes.  <tt>flush</tt> will keep track of the current flushing state for <tt>deflate()</tt>,\n+which is either no flushing, or flush to completion after the end of the input file is reached.\n+<tt>have</tt> is the amount of data returned from <tt>deflate()</tt>.  The <tt>strm</tt> structure\n+is used to pass information to and from the <em>zlib</em> routines, and to maintain the\n+<tt>deflate()</tt> state.  <tt>in</tt> and <tt>out</tt> are the input and output buffers for\n+<tt>deflate()</tt>.\n+<pre><b>\n+    int ret, flush;\n+    unsigned have;\n+    z_stream strm;\n+    char in[CHUNK];\n+    char out[CHUNK];\n+</b></pre><!-- -->\n+The first thing we do is to initialize the <em>zlib</em> state for compression using\n+<tt>deflateInit()</tt>.  This must be done before the first use of <tt>deflate()</tt>.\n+The <tt>zalloc</tt>, <tt>zfree</tt>, and <tt>opaque</tt> fields in the <tt>strm</tt>\n+structure must be initialized before calling <tt>deflateInit()</tt>.  Here they are\n+set to the <em>zlib</em> constant <tt>Z_NULL</tt> to request that <em>zlib</em> use\n+the default memory allocation routines.  An application may also choose to provide\n+custom memory allocation routines here.  <tt>deflateInit()</tt> will allocate on the\n+order of 256K bytes for the internal state.\n+(See <a href=\"zlib_tech.html\"><em>zlib Technical Details</em></a>.)\n+<p>\n+<tt>deflateInit()</tt> is called with a pointer to the structure to be initialized and\n+the compression level, which is an integer in the range of -1 to 9.  Lower compression\n+levels result in faster execution, but less compression.  Higher levels result in\n+greater compression, but slower execution.  The <em>zlib</em> constant Z_DEFAULT_COMPRESSION,\n+equal to -1,\n+provides a good compromise between compression and speed and is equivalent to level 6.\n+Level 0 actually does no compression at all, and in fact expands the data slightly to produce\n+the <em>zlib</em> format (it is not a byte-for-byte copy of the input).\n+More advanced applications of <em>zlib</em>\n+may use <tt>deflateInit2()</tt> here instead.  Such an application may want to reduce how\n+much memory will be used, at some price in compression.  Or it may need to request a\n+<em>gzip</em> header and trailer instead of a <em>zlib</em> header and trailer, or raw\n+encoding with no header or trailer at all.\n+<p>\n+We must check the return value of <tt>deflateInit()</tt> against the <em>zlib</em> constant\n+<tt>Z_OK</tt> to make sure that it was able to\n+allocate memory for the internal state, and that the provided arguments were valid.\n+<tt>deflateInit()</tt> will also check that the version of <em>zlib</em> that the <tt>zlib.h</tt>\n+file came from matches the version of <em>zlib</em> actually linked with the program.  This\n+is especially important for environments in which <em>zlib</em> is a shared library.\n+<p>\n+Note that an application can initialize multiple, independent <em>zlib</em> streams, which can\n+operate in parallel.  The state information maintained in the structure allows the <em>zlib</em>\n+routines to be reentrant.\n+<pre><b>\n+    /* allocate deflate state */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    ret = deflateInit(&amp;strm, level);\n+    if (ret != Z_OK)\n+        return ret;\n+</b></pre><!-- -->\n+With the pleasantries out of the way, now we can get down to business.  The outer <tt>do</tt>-loop\n+reads all of the input file and exits at the bottom of the loop once end-of-file is reached.\n+This loop contains the only call of <tt>deflate()</tt>.  So we must make sure that all of the\n+input data has been processed and that all of the output data has been generated and consumed\n+before we fall out of the loop at the bottom.\n+<pre><b>\n+    /* compress until end of file */\n+    do {\n+</b></pre>\n+We start off by reading data from the input file.  The number of bytes read is put directly\n+into <tt>avail_in</tt>, and a pointer to those bytes is put into <tt>next_in</tt>.  We also\n+check to see if end-of-file on the input has been reached.  If we are at the end of file, then <tt>flush</tt> is set to the\n+<em>zlib</em> constant <tt>Z_FINISH</tt>, which is later passed to <tt>deflate()</tt> to\n+indicate that this is the last chunk of input data to compress.  We need to use <tt>feof()</tt>\n+to check for end-of-file as opposed to seeing if fewer than <tt>CHUNK</tt> bytes have been read.  The\n+reason is that if the input file length is an exact multiple of <tt>CHUNK</tt>, we will miss\n+the fact that we got to the end-of-file, and not know to tell <tt>deflate()</tt> to finish\n+up the compressed stream.  If we are not yet at the end of the input, then the <em>zlib</em>\n+constant <tt>Z_NO_FLUSH</tt> will be passed to <tt>deflate</tt> to indicate that we are still\n+in the middle of the uncompressed data.\n+<p>\n+If there is an error in reading from the input file, the process is aborted with\n+<tt>deflateEnd()</tt> being called to free the allocated <em>zlib</em> state before returning\n+the error.  We wouldn't want a memory leak, now would we?  <tt>deflateEnd()</tt> can be called\n+at any time after the state has been initialized.  Once that's done, <tt>deflateInit()</tt> (or\n+<tt>deflateInit2()</tt>) would have to be called to start a new compression process.  There is\n+no point here in checking the <tt>deflateEnd()</tt> return code.  The deallocation can't fail.\n+<pre><b>\n+        strm.avail_in = fread(in, 1, CHUNK, source);\n+        if (ferror(source)) {\n+            (void)deflateEnd(&amp;strm);\n+            return Z_ERRNO;\n+        }\n+        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n+        strm.next_in = in;\n+</b></pre><!-- -->\n+The inner <tt>do</tt>-loop passes our chunk of input data to <tt>deflate()</tt>, and then\n+keeps calling <tt>deflate()</tt> until it is done producing output.  Once there is no more\n+new output, <tt>deflate()</tt> is guaranteed to have consumed all of the input, i.e.,\n+<tt>avail_in</tt> will be zero.\n+<pre><b>\n+        /* run deflate() on input until output buffer not full, finish\n+           compression if all of source has been read in */\n+        do {\n+</b></pre>\n+Output space is provided to <tt>deflate()</tt> by setting <tt>avail_out</tt> to the number\n+of available output bytes and <tt>next_out</tt> to a pointer to that space.\n+<pre><b>\n+            strm.avail_out = CHUNK;\n+            strm.next_out = out;\n+</b></pre>\n+Now we call the compression engine itself, <tt>deflate()</tt>.  It takes as many of the\n+<tt>avail_in</tt> bytes at <tt>next_in</tt> as it can process, and writes as many as\n+<tt>avail_out</tt> bytes to <tt>next_out</tt>.  Those counters and pointers are then\n+updated past the input data consumed and the output data written.  It is the amount of\n+output space available that may limit how much input is consumed.\n+Hence the inner loop to make sure that\n+all of the input is consumed by providing more output space each time.  Since <tt>avail_in</tt>\n+and <tt>next_in</tt> are updated by <tt>deflate()</tt>, we don't have to mess with those\n+between <tt>deflate()</tt> calls until it's all used up.\n+<p>\n+The parameters to <tt>deflate()</tt> are a pointer to the <tt>strm</tt> structure containing\n+the input and output information and the internal compression engine state, and a parameter\n+indicating whether and how to flush data to the output.  Normally <tt>deflate</tt> will consume\n+several K bytes of input data before producing any output (except for the header), in order\n+to accumulate statistics on the data for optimum compression.  It will then put out a burst of\n+compressed data, and proceed to consume more input before the next burst.  Eventually,\n+<tt>deflate()</tt>\n+must be told to terminate the stream, complete the compression with provided input data, and\n+write out the trailer check value.  <tt>deflate()</tt> will continue to compress normally as long\n+as the flush parameter is <tt>Z_NO_FLUSH</tt>.  Once the <tt>Z_FINISH</tt> parameter is provided,\n+<tt>deflate()</tt> will begin to complete the compressed output stream.  However depending on how\n+much output space is provided, <tt>deflate()</tt> may have to be called several times until it\n+has provided the complete compressed stream, even after it has consumed all of the input.  The flush\n+parameter must continue to be <tt>Z_FINISH</tt> for those subsequent calls.\n+<p>\n+There are other values of the flush parameter that are used in more advanced applications.  You can\n+force <tt>deflate()</tt> to produce a burst of output that encodes all of the input data provided\n+so far, even if it wouldn't have otherwise, for example to control data latency on a link with\n+compressed data.  You can also ask that <tt>deflate()</tt> do that as well as erase any history up to\n+that point so that what follows can be decompressed independently, for example for random access\n+applications.  Both requests will degrade compression by an amount depending on how often such\n+requests are made.\n+<p>\n+<tt>deflate()</tt> has a return value that can indicate errors, yet we do not check it here.  Why\n+not?  Well, it turns out that <tt>deflate()</tt> can do no wrong here.  Let's go through\n+<tt>deflate()</tt>'s return values and dispense with them one by one.  The possible values are\n+<tt>Z_OK</tt>, <tt>Z_STREAM_END</tt>, <tt>Z_STREAM_ERROR</tt>, or <tt>Z_BUF_ERROR</tt>.  <tt>Z_OK</tt>\n+is, well, ok.  <tt>Z_STREAM_END</tt> is also ok and will be returned for the last call of\n+<tt>deflate()</tt>.  This is already guaranteed by calling <tt>deflate()</tt> with <tt>Z_FINISH</tt>\n+until it has no more output.  <tt>Z_STREAM_ERROR</tt> is only possible if the stream is not\n+initialized properly, but we did initialize it properly.  There is no harm in checking for\n+<tt>Z_STREAM_ERROR</tt> here, for example to check for the possibility that some\n+other part of the application inadvertently clobbered the memory containing the <em>zlib</em> state.\n+<tt>Z_BUF_ERROR</tt> will be explained further below, but\n+suffice it to say that this is simply an indication that <tt>deflate()</tt> could not consume\n+more input or produce more output.  <tt>deflate()</tt> can be called again with more output space\n+or more available input, which it will be in this code.\n+<pre><b>\n+            ret = deflate(&amp;strm, flush);    /* no bad return value */\n+            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n+</b></pre>\n+Now we compute how much output <tt>deflate()</tt> provided on the last call, which is the\n+difference between how much space was provided before the call, and how much output space\n+is still available after the call.  Then that data, if any, is written to the output file.\n+We can then reuse the output buffer for the next call of <tt>deflate()</tt>.  Again if there\n+is a file i/o error, we call <tt>deflateEnd()</tt> before returning to avoid a memory leak.\n+<pre><b>\n+            have = CHUNK - strm.avail_out;\n+            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n+                (void)deflateEnd(&amp;strm);\n+                return Z_ERRNO;\n+            }\n+</b></pre>\n+The inner <tt>do</tt>-loop is repeated until the last <tt>deflate()</tt> call fails to fill the\n+provided output buffer.  Then we know that <tt>deflate()</tt> has done as much as it can with\n+the provided input, and that all of that input has been consumed.  We can then fall out of this\n+loop and reuse the input buffer.\n+<p>\n+The way we tell that <tt>deflate()</tt> has no more output is by seeing that it did not fill\n+the output buffer, leaving <tt>avail_out</tt> greater than zero.  However suppose that\n+<tt>deflate()</tt> has no more output, but just so happened to exactly fill the output buffer!\n+<tt>avail_out</tt> is zero, and we can't tell that <tt>deflate()</tt> has done all it can.\n+As far as we know, <tt>deflate()</tt>\n+has more output for us.  So we call it again.  But now <tt>deflate()</tt> produces no output\n+at all, and <tt>avail_out</tt> remains unchanged as <tt>CHUNK</tt>.  That <tt>deflate()</tt> call\n+wasn't able to do anything, either consume input or produce output, and so it returns\n+<tt>Z_BUF_ERROR</tt>.  (See, I told you I'd cover this later.)  However this is not a problem at\n+all.  Now we finally have the desired indication that <tt>deflate()</tt> is really done,\n+and so we drop out of the inner loop to provide more input to <tt>deflate()</tt>.\n+<p>\n+With <tt>flush</tt> set to <tt>Z_FINISH</tt>, this final set of <tt>deflate()</tt> calls will\n+complete the output stream.  Once that is done, subsequent calls of <tt>deflate()</tt> would return\n+<tt>Z_STREAM_ERROR</tt> if the flush parameter is not <tt>Z_FINISH</tt>, and do no more processing\n+until the state is reinitialized.\n+<p>\n+Some applications of <em>zlib</em> have two loops that call <tt>deflate()</tt>\n+instead of the single inner loop we have here.  The first loop would call\n+without flushing and feed all of the data to <tt>deflate()</tt>.  The second loop would call\n+<tt>deflate()</tt> with no more\n+data and the <tt>Z_FINISH</tt> parameter to complete the process.  As you can see from this\n+example, that can be avoided by simply keeping track of the current flush state.\n+<pre><b>\n+        } while (strm.avail_out == 0);\n+        assert(strm.avail_in == 0);     /* all input will be used */\n+</b></pre><!-- -->\n+Now we check to see if we have already processed all of the input file.  That information was\n+saved in the <tt>flush</tt> variable, so we see if that was set to <tt>Z_FINISH</tt>.  If so,\n+then we're done and we fall out of the outer loop.  We're guaranteed to get <tt>Z_STREAM_END</tt>\n+from the last <tt>deflate()</tt> call, since we ran it until the last chunk of input was\n+consumed and all of the output was generated.\n+<pre><b>\n+        /* done when last data in file processed */\n+    } while (flush != Z_FINISH);\n+    assert(ret == Z_STREAM_END);        /* stream will be complete */\n+</b></pre><!-- -->\n+The process is complete, but we still need to deallocate the state to avoid a memory leak\n+(or rather more like a memory hemorrhage if you didn't do this).  Then\n+finally we can return with a happy return value.\n+<pre><b>\n+    /* clean up and return */\n+    (void)deflateEnd(&amp;strm);\n+    return Z_OK;\n+}\n+</b></pre><!-- -->\n+Now we do the same thing for decompression in the <tt>inf()</tt> routine. <tt>inf()</tt>\n+decompresses what is hopefully a valid <em>zlib</em> stream from the input file and writes the\n+uncompressed data to the output file.  Much of the discussion above for <tt>def()</tt>\n+applies to <tt>inf()</tt> as well, so the discussion here will focus on the differences between\n+the two.\n+<pre><b>\n+/* Decompress from file source to file dest until stream ends or EOF.\n+   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n+   allocated for processing, Z_DATA_ERROR if the deflate data is\n+   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and\n+   the version of the library linked do not match, or Z_ERRNO if there\n+   is an error reading or writing the files. */\n+int inf(FILE *source, FILE *dest)\n+{\n+</b></pre>\n+The local variables have the same functionality as they do for <tt>def()</tt>.  The\n+only difference is that there is no <tt>flush</tt> variable, since <tt>inflate()</tt>\n+can tell from the <em>zlib</em> stream itself when the stream is complete.\n+<pre><b>\n+    int ret;\n+    unsigned have;\n+    z_stream strm;\n+    char in[CHUNK];\n+    char out[CHUNK];\n+</b></pre><!-- -->\n+The initialization of the state is the same, except that there is no compression level,\n+of course, and two more elements of the structure are initialized.  <tt>avail_in</tt>\n+and <tt>next_in</tt> must be initialized before calling <tt>inflateInit()</tt>.  This\n+is because the application has the option to provide the start of the zlib stream in\n+order for <tt>inflateInit()</tt> to have access to information about the compression\n+method to aid in memory allocation.  In the current implementation of <em>zlib</em>\n+(up through versions 1.2.x), the method-dependent memory allocations are deferred to the first call of\n+<tt>inflate()</tt> anyway.  However those fields must be initialized since later versions\n+of <em>zlib</em> that provide more compression methods may take advantage of this interface.\n+In any case, no decompression is performed by <tt>inflateInit()</tt>, so the\n+<tt>avail_out</tt> and <tt>next_out</tt> fields do not need to be initialized before calling.\n+<p>\n+Here <tt>avail_in</tt> is set to zero and <tt>next_in</tt> is set to <tt>Z_NULL</tt> to\n+indicate that no input data is being provided.\n+<pre><b>\n+    /* allocate inflate state */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit(&amp;strm);\n+    if (ret != Z_OK)\n+        return ret;\n+</b></pre><!-- -->\n+The outer <tt>do</tt>-loop decompresses input until <tt>inflate()</tt> indicates\n+that it has reached the end of the compressed data and has produced all of the uncompressed\n+output.  This is in contrast to <tt>def()</tt> which processes all of the input file.\n+If end-of-file is reached before the compressed data self-terminates, then the compressed\n+data is incomplete and an error is returned.\n+<pre><b>\n+    /* decompress until deflate stream ends or end of file */\n+    do {\n+</b></pre>\n+We read input data and set the <tt>strm</tt> structure accordingly.  If we've reached the\n+end of the input file, then we leave the outer loop and report an error, since the\n+compressed data is incomplete.  Note that we may read more data than is eventually consumed\n+by <tt>inflate()</tt>, if the input file continues past the <em>zlib</em> stream.\n+For applications where <em>zlib</em> streams are embedded in other data, this routine would\n+need to be modified to return the unused data, or at least indicate how much of the input\n+data was not used, so the application would know where to pick up after the <em>zlib</em> stream.\n+<pre><b>\n+        strm.avail_in = fread(in, 1, CHUNK, source);\n+        if (ferror(source)) {\n+            (void)inflateEnd(&amp;strm);\n+            return Z_ERRNO;\n+        }\n+        if (strm.avail_in == 0)\n+            break;\n+        strm.next_in = in;\n+</b></pre><!-- -->\n+The inner <tt>do</tt>-loop has the same function it did in <tt>def()</tt>, which is to\n+keep calling <tt>inflate()</tt> until has generated all of the output it can with the\n+provided input.\n+<pre><b>\n+        /* run inflate() on input until output buffer not full */\n+        do {\n+</b></pre>\n+Just like in <tt>def()</tt>, the same output space is provided for each call of <tt>inflate()</tt>.\n+<pre><b>\n+            strm.avail_out = CHUNK;\n+            strm.next_out = out;\n+</b></pre>\n+Now we run the decompression engine itself.  There is no need to adjust the flush parameter, since\n+the <em>zlib</em> format is self-terminating. The main difference here is that there are\n+return values that we need to pay attention to.  <tt>Z_DATA_ERROR</tt>\n+indicates that <tt>inflate()</tt> detected an error in the <em>zlib</em> compressed data format,\n+which means that either the data is not a <em>zlib</em> stream to begin with, or that the data was\n+corrupted somewhere along the way since it was compressed.  The other error to be processed is\n+<tt>Z_MEM_ERROR</tt>, which can occur since memory allocation is deferred until <tt>inflate()</tt>\n+needs it, unlike <tt>deflate()</tt>, whose memory is allocated at the start by <tt>deflateInit()</tt>.\n+<p>\n+Advanced applications may use\n+<tt>deflateSetDictionary()</tt> to prime <tt>deflate()</tt> with a set of likely data to improve the\n+first 32K or so of compression.  This is noted in the <em>zlib</em> header, so <tt>inflate()</tt>\n+requests that that dictionary be provided before it can start to decompress.  Without the dictionary,\n+correct decompression is not possible.  For this routine, we have no idea what the dictionary is,\n+so the <tt>Z_NEED_DICT</tt> indication is converted to a <tt>Z_DATA_ERROR</tt>.\n+<p>\n+<tt>inflate()</tt> can also return <tt>Z_STREAM_ERROR</tt>, which should not be possible here,\n+but could be checked for as noted above for <tt>def()</tt>.  <tt>Z_BUF_ERROR</tt> does not need to be\n+checked for here, for the same reasons noted for <tt>def()</tt>.  <tt>Z_STREAM_END</tt> will be\n+checked for later.\n+<pre><b>\n+            ret = inflate(&amp;strm, Z_NO_FLUSH);\n+            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n+            switch (ret) {\n+            case Z_NEED_DICT:\n+                ret = Z_DATA_ERROR;     /* and fall through */\n+            case Z_DATA_ERROR:\n+            case Z_MEM_ERROR:\n+                (void)inflateEnd(&amp;strm);\n+                return ret;\n+            }\n+</b></pre>\n+The output of <tt>inflate()</tt> is handled identically to that of <tt>deflate()</tt>.\n+<pre><b>\n+            have = CHUNK - strm.avail_out;\n+            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n+                (void)inflateEnd(&amp;strm);\n+                return Z_ERRNO;\n+            }\n+</b></pre>\n+The inner <tt>do</tt>-loop ends when <tt>inflate()</tt> has no more output as indicated\n+by not filling the output buffer, just as for <tt>deflate()</tt>.  In this case, we cannot\n+assert that <tt>strm.avail_in</tt> will be zero, since the deflate stream may end before the file\n+does.\n+<pre><b>\n+        } while (strm.avail_out == 0);\n+</b></pre><!-- -->\n+The outer <tt>do</tt>-loop ends when <tt>inflate()</tt> reports that it has reached the\n+end of the input <em>zlib</em> stream, has completed the decompression and integrity\n+check, and has provided all of the output.  This is indicated by the <tt>inflate()</tt>\n+return value <tt>Z_STREAM_END</tt>.  The inner loop is guaranteed to leave <tt>ret</tt>\n+equal to <tt>Z_STREAM_END</tt> if the last chunk of the input file read contained the end\n+of the <em>zlib</em> stream.  So if the return value is not <tt>Z_STREAM_END</tt>, the\n+loop continues to read more input.\n+<pre><b>\n+        /* done when inflate() says it's done */\n+    } while (ret != Z_STREAM_END);\n+</b></pre><!-- -->\n+At this point, decompression successfully completed, or we broke out of the loop due to no\n+more data being available from the input file.  If the last <tt>inflate()</tt> return value\n+is not <tt>Z_STREAM_END</tt>, then the <em>zlib</em> stream was incomplete and a data error\n+is returned.  Otherwise, we return with a happy return value.  Of course, <tt>inflateEnd()</tt>\n+is called first to avoid a memory leak.\n+<pre><b>\n+    /* clean up and return */\n+    (void)inflateEnd(&amp;strm);\n+    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n+}\n+</b></pre><!-- -->\n+That ends the routines that directly use <em>zlib</em>.  The following routines make this\n+a command-line program by running data through the above routines from <tt>stdin</tt> to\n+<tt>stdout</tt>, and handling any errors reported by <tt>def()</tt> or <tt>inf()</tt>.\n+<p>\n+<tt>zerr()</tt> is used to interpret the possible error codes from <tt>def()</tt>\n+and <tt>inf()</tt>, as detailed in their comments above, and print out an error message.\n+Note that these are only a subset of the possible return values from <tt>deflate()</tt>\n+and <tt>inflate()</tt>.\n+<pre><b>\n+/* report a zlib or i/o error */\n+void zerr(int ret)\n+{\n+    fputs(\"zpipe: \", stderr);\n+    switch (ret) {\n+    case Z_ERRNO:\n+        if (ferror(stdin))\n+            fputs(\"error reading stdin\\n\", stderr);\n+        if (ferror(stdout))\n+            fputs(\"error writing stdout\\n\", stderr);\n+        break;\n+    case Z_STREAM_ERROR:\n+        fputs(\"invalid compression level\\n\", stderr);\n+        break;\n+    case Z_DATA_ERROR:\n+        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n+        break;\n+    case Z_MEM_ERROR:\n+        fputs(\"out of memory\\n\", stderr);\n+        break;\n+    case Z_VERSION_ERROR:\n+        fputs(\"zlib version mismatch!\\n\", stderr);\n+    }\n+}\n+</b></pre><!-- -->\n+Here is the <tt>main()</tt> routine used to test <tt>def()</tt> and <tt>inf()</tt>.  The\n+<tt>zpipe</tt> command is simply a compression pipe from <tt>stdin</tt> to <tt>stdout</tt>, if\n+no arguments are given, or it is a decompression pipe if <tt>zpipe -d</tt> is used.  If any other\n+arguments are provided, no compression or decompression is performed.  Instead a usage\n+message is displayed.  Examples are <tt>zpipe < foo.txt > foo.txt.z</tt> to compress, and\n+<tt>zpipe -d < foo.txt.z > foo.txt</tt> to decompress.\n+<pre><b>\n+/* compress or decompress from stdin to stdout */\n+int main(int argc, char **argv)\n+{\n+    int ret;\n+\n+    /* do compression if no arguments */\n+    if (argc == 1) {\n+        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n+        if (ret != Z_OK)\n+            zerr(ret);\n+        return ret;\n+    }\n+\n+    /* do decompression if -d specified */\n+    else if (argc == 2 &amp;&amp; strcmp(argv[1], \"-d\") == 0) {\n+        ret = inf(stdin, stdout);\n+        if (ret != Z_OK)\n+            zerr(ret);\n+        return ret;\n+    }\n+\n+    /* otherwise, report usage */\n+    else {\n+        fputs(\"zpipe usage: zpipe [-d] &lt; source &gt; dest\\n\", stderr);\n+        return 1;\n+    }\n+}\n+</b></pre>\n+<hr>\n+<i>Copyright (c) 2004 by Mark Adler<br>Last modified 13 November 2004</i>\n+</body>\n+</html>"}, {"sha": "26abb56a9ca63e3090759cc9b28169ef060e6c4f", "filename": "zlib/examples/zpipe.c", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzpipe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzpipe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fzpipe.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,191 @@\n+/* zpipe.c: example of proper use of zlib's inflate() and deflate()\n+   Not copyrighted -- provided to the public domain\n+   Version 1.2  9 November 2004  Mark Adler */\n+\n+/* Version history:\n+   1.0  30 Oct 2004  First version\n+   1.1   8 Nov 2004  Add void casting for unused return values\n+                     Use switch statement for inflate() return values\n+   1.2   9 Nov 2004  Add assertions to document zlib guarantees\n+   1.3   6 Apr 2005  Remove incorrect assertion in inf()\n+ */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <assert.h>\n+#include \"zlib.h\"\n+\n+#define CHUNK 16384\n+\n+/* Compress from file source to file dest until EOF on source.\n+   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n+   allocated for processing, Z_STREAM_ERROR if an invalid compression\n+   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the\n+   version of the library linked do not match, or Z_ERRNO if there is\n+   an error reading or writing the files. */\n+int def(FILE *source, FILE *dest, int level)\n+{\n+    int ret, flush;\n+    unsigned have;\n+    z_stream strm;\n+    char in[CHUNK];\n+    char out[CHUNK];\n+\n+    /* allocate deflate state */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    ret = deflateInit(&strm, level);\n+    if (ret != Z_OK)\n+        return ret;\n+\n+    /* compress until end of file */\n+    do {\n+        strm.avail_in = fread(in, 1, CHUNK, source);\n+        if (ferror(source)) {\n+            (void)deflateEnd(&strm);\n+            return Z_ERRNO;\n+        }\n+        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n+        strm.next_in = in;\n+\n+        /* run deflate() on input until output buffer not full, finish\n+           compression if all of source has been read in */\n+        do {\n+            strm.avail_out = CHUNK;\n+            strm.next_out = out;\n+            ret = deflate(&strm, flush);    /* no bad return value */\n+            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n+            have = CHUNK - strm.avail_out;\n+            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n+                (void)deflateEnd(&strm);\n+                return Z_ERRNO;\n+            }\n+        } while (strm.avail_out == 0);\n+        assert(strm.avail_in == 0);     /* all input will be used */\n+\n+        /* done when last data in file processed */\n+    } while (flush != Z_FINISH);\n+    assert(ret == Z_STREAM_END);        /* stream will be complete */\n+\n+    /* clean up and return */\n+    (void)deflateEnd(&strm);\n+    return Z_OK;\n+}\n+\n+/* Decompress from file source to file dest until stream ends or EOF.\n+   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be\n+   allocated for processing, Z_DATA_ERROR if the deflate data is\n+   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and\n+   the version of the library linked do not match, or Z_ERRNO if there\n+   is an error reading or writing the files. */\n+int inf(FILE *source, FILE *dest)\n+{\n+    int ret;\n+    unsigned have;\n+    z_stream strm;\n+    char in[CHUNK];\n+    char out[CHUNK];\n+\n+    /* allocate inflate state */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit(&strm);\n+    if (ret != Z_OK)\n+        return ret;\n+\n+    /* decompress until deflate stream ends or end of file */\n+    do {\n+        strm.avail_in = fread(in, 1, CHUNK, source);\n+        if (ferror(source)) {\n+            (void)inflateEnd(&strm);\n+            return Z_ERRNO;\n+        }\n+        if (strm.avail_in == 0)\n+            break;\n+        strm.next_in = in;\n+\n+        /* run inflate() on input until output buffer not full */\n+        do {\n+            strm.avail_out = CHUNK;\n+            strm.next_out = out;\n+            ret = inflate(&strm, Z_NO_FLUSH);\n+            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n+            switch (ret) {\n+            case Z_NEED_DICT:\n+                ret = Z_DATA_ERROR;     /* and fall through */\n+            case Z_DATA_ERROR:\n+            case Z_MEM_ERROR:\n+                (void)inflateEnd(&strm);\n+                return ret;\n+            }\n+            have = CHUNK - strm.avail_out;\n+            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n+                (void)inflateEnd(&strm);\n+                return Z_ERRNO;\n+            }\n+        } while (strm.avail_out == 0);\n+\n+        /* done when inflate() says it's done */\n+    } while (ret != Z_STREAM_END);\n+\n+    /* clean up and return */\n+    (void)inflateEnd(&strm);\n+    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n+}\n+\n+/* report a zlib or i/o error */\n+void zerr(int ret)\n+{\n+    fputs(\"zpipe: \", stderr);\n+    switch (ret) {\n+    case Z_ERRNO:\n+        if (ferror(stdin))\n+            fputs(\"error reading stdin\\n\", stderr);\n+        if (ferror(stdout))\n+            fputs(\"error writing stdout\\n\", stderr);\n+        break;\n+    case Z_STREAM_ERROR:\n+        fputs(\"invalid compression level\\n\", stderr);\n+        break;\n+    case Z_DATA_ERROR:\n+        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n+        break;\n+    case Z_MEM_ERROR:\n+        fputs(\"out of memory\\n\", stderr);\n+        break;\n+    case Z_VERSION_ERROR:\n+        fputs(\"zlib version mismatch!\\n\", stderr);\n+    }\n+}\n+\n+/* compress or decompress from stdin to stdout */\n+int main(int argc, char **argv)\n+{\n+    int ret;\n+\n+    /* do compression if no arguments */\n+    if (argc == 1) {\n+        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n+        if (ret != Z_OK)\n+            zerr(ret);\n+        return ret;\n+    }\n+\n+    /* do decompression if -d specified */\n+    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n+        ret = inf(stdin, stdout);\n+        if (ret != Z_OK)\n+            zerr(ret);\n+        return ret;\n+    }\n+\n+    /* otherwise, report usage */\n+    else {\n+        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n+        return 1;\n+    }\n+}"}, {"sha": "8c7717eb2cd8283cab5cae400ddb23b616c785c9", "filename": "zlib/examples/zran.c", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fexamples%2Fzran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexamples%2Fzran.c?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,404 @@\n+/* zran.c -- example of zlib/gzip stream indexing and random access\n+ * Copyright (C) 2005 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+   Version 1.0  29 May 2005  Mark Adler */\n+\n+/* Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()\n+   for random access of a compressed file.  A file containing a zlib or gzip\n+   stream is provided on the command line.  The compressed stream is decoded in\n+   its entirety, and an index built with access points about every SPAN bytes\n+   in the uncompressed output.  The compressed file is left open, and can then\n+   be read randomly, having to decompress on the average SPAN/2 uncompressed\n+   bytes before getting to the desired block of data.\n+\n+   An access point can be created at the start of any deflate block, by saving\n+   the starting file offset and bit of that block, and the 32K bytes of\n+   uncompressed data that precede that block.  Also the uncompressed offset of\n+   that block is saved to provide a referece for locating a desired starting\n+   point in the uncompressed stream.  build_index() works by decompressing the\n+   input zlib or gzip stream a block at a time, and at the end of each block\n+   deciding if enough uncompressed data has gone by to justify the creation of\n+   a new access point.  If so, that point is saved in a data structure that\n+   grows as needed to accommodate the points.\n+\n+   To use the index, an offset in the uncompressed data is provided, for which\n+   the latest accees point at or preceding that offset is located in the index.\n+   The input file is positioned to the specified location in the index, and if\n+   necessary the first few bits of the compressed data is read from the file.\n+   inflate is initialized with those bits and the 32K of uncompressed data, and\n+   the decompression then proceeds until the desired offset in the file is\n+   reached.  Then the decompression continues to read the desired uncompressed\n+   data from the file.\n+\n+   Another approach would be to generate the index on demand.  In that case,\n+   requests for random access reads from the compressed data would try to use\n+   the index, but if a read far enough past the end of the index is required,\n+   then further index entries would be generated and added.\n+\n+   There is some fair bit of overhead to starting inflation for the random\n+   access, mainly copying the 32K byte dictionary.  So if small pieces of the\n+   file are being accessed, it would make sense to implement a cache to hold\n+   some lookahead and avoid many calls to extract() for small lengths.\n+\n+   Another way to build an index would be to use inflateCopy().  That would\n+   not be constrained to have access points at block boundaries, but requires\n+   more memory per access point, and also cannot be saved to file due to the\n+   use of pointers in the state.  The approach here allows for storage of the\n+   index in a file.\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"zlib.h\"\n+\n+#define local static\n+\n+#define SPAN 1048576L       /* desired distance between access points */\n+#define WINSIZE 32768U      /* sliding window size */\n+#define CHUNK 16384         /* file input buffer size */\n+\n+/* access point entry */\n+struct point {\n+    off_t out;          /* corresponding offset in uncompressed data */\n+    off_t in;           /* offset in input file of first full byte */\n+    int bits;           /* number of bits (1-7) from byte at in - 1, or 0 */\n+    unsigned char window[WINSIZE];  /* preceding 32K of uncompressed data */\n+};\n+\n+/* access point list */\n+struct access {\n+    int have;           /* number of list entries filled in */\n+    int size;           /* number of list entries allocated */\n+    struct point *list; /* allocated list */\n+};\n+\n+/* Deallocate an index built by build_index() */\n+local void free_index(struct access *index)\n+{\n+    if (index != NULL) {\n+        free(index->list);\n+        free(index);\n+    }\n+}\n+\n+/* Add an entry to the access point list.  If out of memory, deallocate the\n+   existing list and return NULL. */\n+local struct access *addpoint(struct access *index, int bits,\n+    off_t in, off_t out, unsigned left, unsigned char *window)\n+{\n+    struct point *next;\n+\n+    /* if list is empty, create it (start with eight points) */\n+    if (index == NULL) {\n+        index = malloc(sizeof(struct access));\n+        if (index == NULL) return NULL;\n+        index->list = malloc(sizeof(struct point) << 3);\n+        if (index->list == NULL) {\n+            free(index);\n+            return NULL;\n+        }\n+        index->size = 8;\n+        index->have = 0;\n+    }\n+\n+    /* if list is full, make it bigger */\n+    else if (index->have == index->size) {\n+        index->size <<= 1;\n+        next = realloc(index->list, sizeof(struct point) * index->size);\n+        if (next == NULL) {\n+            free_index(index);\n+            return NULL;\n+        }\n+        index->list = next;\n+    }\n+\n+    /* fill in entry and increment how many we have */\n+    next = index->list + index->have;\n+    next->bits = bits;\n+    next->in = in;\n+    next->out = out;\n+    if (left)\n+        memcpy(next->window, window + WINSIZE - left, left);\n+    if (left < WINSIZE)\n+        memcpy(next->window + left, window, WINSIZE - left);\n+    index->have++;\n+\n+    /* return list, possibly reallocated */\n+    return index;\n+}\n+\n+/* Make one entire pass through the compressed stream and build an index, with\n+   access points about every span bytes of uncompressed output -- span is\n+   chosen to balance the speed of random access against the memory requirements\n+   of the list, about 32K bytes per access point.  Note that data after the end\n+   of the first zlib or gzip stream in the file is ignored.  build_index()\n+   returns the number of access points on success (>= 1), Z_MEM_ERROR for out\n+   of memory, Z_DATA_ERROR for an error in the input file, or Z_ERRNO for a\n+   file read error.  On success, *built points to the resulting index. */\n+local int build_index(FILE *in, off_t span, struct access **built)\n+{\n+    int ret;\n+    off_t totin, totout;        /* our own total counters to avoid 4GB limit */\n+    off_t last;                 /* totout value of last access point */\n+    struct access *index;       /* access points being generated */\n+    z_stream strm;\n+    unsigned char input[CHUNK];\n+    unsigned char window[WINSIZE];\n+\n+    /* initialize inflate */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */\n+    if (ret != Z_OK)\n+        return ret;\n+\n+    /* inflate the input, maintain a sliding window, and build an index -- this\n+       also validates the integrity of the compressed data using the check\n+       information at the end of the gzip or zlib stream */\n+    totin = totout = last = 0;\n+    index = NULL;               /* will be allocated by first addpoint() */\n+    strm.avail_out = 0;\n+    do {\n+        /* get some compressed data from input file */\n+        strm.avail_in = fread(input, 1, CHUNK, in);\n+        if (ferror(in)) {\n+            ret = Z_ERRNO;\n+            goto build_index_error;\n+        }\n+        if (strm.avail_in == 0) {\n+            ret = Z_DATA_ERROR;\n+            goto build_index_error;\n+        }\n+        strm.next_in = input;\n+\n+        /* process all of that, or until end of stream */\n+        do {\n+            /* reset sliding window if necessary */\n+            if (strm.avail_out == 0) {\n+                strm.avail_out = WINSIZE;\n+                strm.next_out = window;\n+            }\n+\n+            /* inflate until out of input, output, or at end of block --\n+               update the total input and output counters */\n+            totin += strm.avail_in;\n+            totout += strm.avail_out;\n+            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */\n+            totin -= strm.avail_in;\n+            totout -= strm.avail_out;\n+            if (ret == Z_NEED_DICT)\n+                ret = Z_DATA_ERROR;\n+            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n+                goto build_index_error;\n+            if (ret == Z_STREAM_END)\n+                break;\n+\n+            /* if at end of block, consider adding an index entry (note that if\n+               data_type indicates an end-of-block, then all of the\n+               uncompressed data from that block has been delivered, and none\n+               of the compressed data after that block has been consumed,\n+               except for up to seven bits) -- the totout == 0 provides an\n+               entry point after the zlib or gzip header, and assures that the\n+               index always has at least one access point; we avoid creating an\n+               access point after the last block by checking bit 6 of data_type\n+             */\n+            if ((strm.data_type & 128) && !(strm.data_type & 64) &&\n+                (totout == 0 || totout - last > span)) {\n+                index = addpoint(index, strm.data_type & 7, totin,\n+                                 totout, strm.avail_out, window);\n+                if (index == NULL) {\n+                    ret = Z_MEM_ERROR;\n+                    goto build_index_error;\n+                }\n+                last = totout;\n+            }\n+        } while (strm.avail_in != 0);\n+    } while (ret != Z_STREAM_END);\n+\n+    /* clean up and return index (release unused entries in list) */\n+    (void)inflateEnd(&strm);\n+    index = realloc(index, sizeof(struct point) * index->have);\n+    index->size = index->have;\n+    *built = index;\n+    return index->size;\n+\n+    /* return error */\n+  build_index_error:\n+    (void)inflateEnd(&strm);\n+    if (index != NULL)\n+        free_index(index);\n+    return ret;\n+}\n+\n+/* Use the index to read len bytes from offset into buf, return bytes read or\n+   negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past\n+   the end of the uncompressed data, then extract() will return a value less\n+   than len, indicating how much as actually read into buf.  This function\n+   should not return a data error unless the file was modified since the index\n+   was generated.  extract() may also return Z_ERRNO if there is an error on\n+   reading or seeking the input file. */\n+local int extract(FILE *in, struct access *index, off_t offset,\n+                  unsigned char *buf, int len)\n+{\n+    int ret, skip;\n+    z_stream strm;\n+    struct point *here;\n+    unsigned char input[CHUNK];\n+    unsigned char discard[WINSIZE];\n+\n+    /* proceed only if something reasonable to do */\n+    if (len < 0)\n+        return 0;\n+\n+    /* find where in stream to start */\n+    here = index->list;\n+    ret = index->have;\n+    while (--ret && here[1].out <= offset)\n+        here++;\n+\n+    /* initialize file and inflate state to start there */\n+    strm.zalloc = Z_NULL;\n+    strm.zfree = Z_NULL;\n+    strm.opaque = Z_NULL;\n+    strm.avail_in = 0;\n+    strm.next_in = Z_NULL;\n+    ret = inflateInit2(&strm, -15);         /* raw inflate */\n+    if (ret != Z_OK)\n+        return ret;\n+    ret = fseeko(in, here->in - (here->bits ? 1 : 0), SEEK_SET);\n+    if (ret == -1)\n+        goto extract_ret;\n+    if (here->bits) {\n+        ret = getc(in);\n+        if (ret == -1) {\n+            ret = ferror(in) ? Z_ERRNO : Z_DATA_ERROR;\n+            goto extract_ret;\n+        }\n+        (void)inflatePrime(&strm, here->bits, ret >> (8 - here->bits));\n+    }\n+    (void)inflateSetDictionary(&strm, here->window, WINSIZE);\n+\n+    /* skip uncompressed bytes until offset reached, then satisfy request */\n+    offset -= here->out;\n+    strm.avail_in = 0;\n+    skip = 1;                               /* while skipping to offset */\n+    do {\n+        /* define where to put uncompressed data, and how much */\n+        if (offset == 0 && skip) {          /* at offset now */\n+            strm.avail_out = len;\n+            strm.next_out = buf;\n+            skip = 0;                       /* only do this once */\n+        }\n+        if (offset > WINSIZE) {             /* skip WINSIZE bytes */\n+            strm.avail_out = WINSIZE;\n+            strm.next_out = discard;\n+            offset -= WINSIZE;\n+        }\n+        else if (offset != 0) {             /* last skip */\n+            strm.avail_out = (unsigned)offset;\n+            strm.next_out = discard;\n+            offset = 0;\n+        }\n+\n+        /* uncompress until avail_out filled, or end of stream */\n+        do {\n+            if (strm.avail_in == 0) {\n+                strm.avail_in = fread(input, 1, CHUNK, in);\n+                if (ferror(in)) {\n+                    ret = Z_ERRNO;\n+                    goto extract_ret;\n+                }\n+                if (strm.avail_in == 0) {\n+                    ret = Z_DATA_ERROR;\n+                    goto extract_ret;\n+                }\n+                strm.next_in = input;\n+            }\n+            ret = inflate(&strm, Z_NO_FLUSH);       /* normal inflate */\n+            if (ret == Z_NEED_DICT)\n+                ret = Z_DATA_ERROR;\n+            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n+                goto extract_ret;\n+            if (ret == Z_STREAM_END)\n+                break;\n+        } while (strm.avail_out != 0);\n+\n+        /* if reach end of stream, then don't keep trying to get more */\n+        if (ret == Z_STREAM_END)\n+            break;\n+\n+        /* do until offset reached and requested data read, or stream ends */\n+    } while (skip);\n+\n+    /* compute number of uncompressed bytes read after offset */\n+    ret = skip ? 0 : len - strm.avail_out;\n+\n+    /* clean up and return bytes read or error */\n+  extract_ret:\n+    (void)inflateEnd(&strm);\n+    return ret;\n+}\n+\n+/* Demonstrate the use of build_index() and extract() by processing the file\n+   provided on the command line, and the extracting 16K from about 2/3rds of\n+   the way through the uncompressed output, and writing that to stdout. */\n+int main(int argc, char **argv)\n+{\n+    int len;\n+    off_t offset;\n+    FILE *in;\n+    struct access *index;\n+    unsigned char buf[CHUNK];\n+\n+    /* open input file */\n+    if (argc != 2) {\n+        fprintf(stderr, \"usage: zran file.gz\\n\");\n+        return 1;\n+    }\n+    in = fopen(argv[1], \"rb\");\n+    if (in == NULL) {\n+        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n+        return 1;\n+    }\n+\n+    /* build index */\n+    len = build_index(in, SPAN, &index);\n+    if (len < 0) {\n+        fclose(in);\n+        switch (len) {\n+        case Z_MEM_ERROR:\n+            fprintf(stderr, \"zran: out of memory\\n\");\n+            break;\n+        case Z_DATA_ERROR:\n+            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n+            break;\n+        case Z_ERRNO:\n+            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n+            break;\n+        default:\n+            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n+        }\n+        return 1;\n+    }\n+    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n+\n+    /* use index by reading some bytes from an arbitrary offset */\n+    offset = (index->list[index->have - 1].out << 1) / 3;\n+    len = extract(in, index, offset, buf, CHUNK);\n+    if (len < 0)\n+        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n+                len == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n+    else {\n+        fwrite(buf, 1, len, stdout);\n+        fprintf(stderr, \"zran: extracted %d bytes at %llu\\n\", len, offset);\n+    }\n+\n+    /* clean up and exit */\n+    free_index(index);\n+    fclose(in);\n+    return 0;\n+}"}, {"sha": "c2a1fb54b2f4498d2cd98b4dc6a2309219676760", "filename": "zlib/make_vms.com", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fmake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fmake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmake_vms.com?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,461 @@\n+$! make libz under VMS written by\n+$! Martin P.J. Zinser\n+$! <zinser@zinser.no-ip.info or zinser@sysdev.deutsche-boerse.com>\n+$!\n+$ on error then goto err_exit\n+$!\n+$!\n+$! Just some general constants...\n+$!\n+$ true  = 1\n+$ false = 0\n+$ tmpnam = \"temp_\" + f$getjpi(\"\",\"pid\")\n+$ SAY = \"WRITE SYS$OUTPUT\"\n+$!\n+$! Setup variables holding \"config\" information\n+$!\n+$ Make     = \"\"\n+$ name     = \"Zlib\"\n+$ version  = \"?.?.?\"\n+$ v_string = \"ZLIB_VERSION\"\n+$ v_file   = \"zlib.h\"\n+$ ccopt    = \"\"\n+$ lopts    = \"\"\n+$ linkonly = false\n+$ optfile  = name + \".opt\"\n+$ its_decc = false\n+$ its_vaxc = false\n+$ its_gnuc = false\n+$ axp      = f$getsyi(\"HW_MODEL\").ge.1024\n+$ s_case   = false\n+$! Check for MMK/MMS\n+$!\n+$ If F$Search (\"Sys$System:MMS.EXE\") .nes. \"\" Then Make = \"MMS\"\n+$ If F$Type (MMK) .eqs. \"STRING\" Then Make = \"MMK\"\n+$!\n+$!\n+$ gosub find_version\n+$!\n+$ gosub check_opts\n+$!\n+$! Look for the compiler used\n+$!\n+$ gosub check_compiler\n+$ if its_decc\n+$ then\n+$   ccopt = \"/prefix=all\" + ccopt\n+$   if f$trnlnm(\"SYS\") .eqs. \"\"\n+$   then\n+$     if axp\n+$     then\n+$       define sys sys$library:\n+$     else\n+$       ccopt = \"/decc\" + ccopt\n+$       define sys decc$library_include:\n+$     endif\n+$   endif\n+$ endif\n+$ if its_vaxc .or. its_gnuc\n+$ then\n+$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n+$ endif\n+$!\n+$! Build the thing plain or with mms\n+$!\n+$ write sys$output \"Compiling Zlib sources ...\"\n+$ if make.eqs.\"\"\n+$  then\n+$   dele example.obj;*,minigzip.obj;*\n+$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n+                adler32.c zlib.h zconf.h\n+$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n+                compress.c zlib.h zconf.h\n+$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n+                crc32.c zlib.h zconf.h\n+$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n+                deflate.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE gzio.OBJ \"CC ''CCOPT' gzio\" -\n+                gzio.c zutil.h zlib.h zconf.h\n+$   CALL MAKE infback.OBJ \"CC ''CCOPT' infback\" -\n+                infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h\n+$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n+                inffast.c zutil.h zlib.h zconf.h inffast.h\n+$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n+                inflate.c zutil.h zlib.h zconf.h infblock.h\n+$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n+                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n+                trees.c deflate.h zutil.h zlib.h zconf.h\n+$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n+                uncompr.c zlib.h zconf.h\n+$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n+                zutil.c zutil.h zlib.h zconf.h\n+$   write sys$output \"Building Zlib ...\"\n+$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n+$   write sys$output \"Building example...\"\n+$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n+                example.c zlib.h zconf.h\n+$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n+$   if f$search(\"x11vms:xvmsutils.olb\") .nes. \"\"\n+$   then\n+$     write sys$output \"Building minigzip...\"\n+$     CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n+                minigzip.c zlib.h zconf.h\n+$     call make minigzip.exe -\n+                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" -\n+                minigzip.obj libz.olb\n+$   endif\n+$  else\n+$   gosub crea_mms\n+$   SAY \"Make ''name' ''version' with ''Make' \"\n+$   'make'\n+$  endif\n+$!\n+$! Alpha gets a shareable image\n+$!\n+$ If axp\n+$ Then\n+$   gosub crea_olist\n+$   write sys$output \"Creating libzshr.exe\"\n+$   call anal_obj_axp modules.opt _link.opt\n+$   if s_case\n+$   then\n+$      open/append optf modules.opt\n+$      write optf \"case_sensitive=YES\"\n+$      close optf\n+$   endif\n+$   LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,_link.opt/opt\n+$ endif\n+$ write sys$output \"Zlib build completed\"\n+$ exit\n+$CC_ERR:\n+$ write sys$output \"C compiler required to build ''name'\"\n+$ goto err_exit\n+$ERR_EXIT:\n+$ set message/facil/ident/sever/text\n+$ write sys$output \"Exiting...\"\n+$ exit 2\n+$!\n+$!\n+$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n+$ V = 'F$Verify(0)\n+$! P1 = What we are trying to make\n+$! P2 = Command to make it\n+$! P3 - P8  What it depends on\n+$\n+$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n+$ Time = F$CvTime(F$File(P1,\"RDT\"))\n+$arg=3\n+$Loop:\n+$       Argument = P'arg\n+$       If Argument .Eqs. \"\" Then Goto Exit\n+$       El=0\n+$Loop2:\n+$       File = F$Element(El,\" \",Argument)\n+$       If File .Eqs. \" \" Then Goto Endl\n+$       AFile = \"\"\n+$Loop3:\n+$       OFile = AFile\n+$       AFile = F$Search(File)\n+$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n+$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n+$       Goto Loop3\n+$NextEL:\n+$       El = El + 1\n+$       Goto Loop2\n+$EndL:\n+$ arg=arg+1\n+$ If arg .Le. 8 Then Goto Loop\n+$ Goto Exit\n+$\n+$Makeit:\n+$ VV=F$VERIFY(0)\n+$ write sys$output P2\n+$ 'P2\n+$ VV='F$Verify(VV)\n+$Exit:\n+$ If V Then Set Verify\n+$ENDSUBROUTINE\n+$!------------------------------------------------------------------------------\n+$!\n+$! Check command line options and set symbols accordingly\n+$!\n+$ CHECK_OPTS:\n+$ i = 1\n+$ OPT_LOOP:\n+$ if i .lt. 9\n+$ then\n+$   cparm = f$edit(p'i',\"upcase\")\n+$   if cparm .eqs. \"DEBUG\"\n+$   then\n+$     ccopt = ccopt + \"/noopt/deb\"\n+$     lopts = lopts + \"/deb\"\n+$   endif\n+$   if f$locate(\"CCOPT=\",cparm) .lt. f$length(cparm)\n+$   then\n+$     start = f$locate(\"=\",cparm) + 1\n+$     len   = f$length(cparm) - start\n+$     ccopt = ccopt + f$extract(start,len,cparm)\n+$     if f$locate(\"AS_IS\",f$edit(ccopt,\"UPCASE\")) .lt. f$length(ccopt) -\n+         then s_case = true\n+$   endif\n+$   if cparm .eqs. \"LINK\" then linkonly = true\n+$   if f$locate(\"LOPTS=\",cparm) .lt. f$length(cparm)\n+$   then\n+$     start = f$locate(\"=\",cparm) + 1\n+$     len   = f$length(cparm) - start\n+$     lopts = lopts + f$extract(start,len,cparm)\n+$   endif\n+$   if f$locate(\"CC=\",cparm) .lt. f$length(cparm)\n+$   then\n+$     start  = f$locate(\"=\",cparm) + 1\n+$     len    = f$length(cparm) - start\n+$     cc_com = f$extract(start,len,cparm)\n+      if (cc_com .nes. \"DECC\") .and. -\n+         (cc_com .nes. \"VAXC\") .and. -\n+\t (cc_com .nes. \"GNUC\")\n+$     then\n+$       write sys$output \"Unsupported compiler choice ''cc_com' ignored\"\n+$       write sys$output \"Use DECC, VAXC, or GNUC instead\"\n+$     else\n+$     \tif cc_com .eqs. \"DECC\" then its_decc = true\n+$     \tif cc_com .eqs. \"VAXC\" then its_vaxc = true\n+$     \tif cc_com .eqs. \"GNUC\" then its_gnuc = true\n+$     endif\n+$   endif\n+$   if f$locate(\"MAKE=\",cparm) .lt. f$length(cparm)\n+$   then\n+$     start  = f$locate(\"=\",cparm) + 1\n+$     len    = f$length(cparm) - start\n+$     mmks = f$extract(start,len,cparm)\n+$     if (mmks .eqs. \"MMK\") .or. (mmks .eqs. \"MMS\")\n+$     then\n+$       make = mmks\n+$     else\n+$       write sys$output \"Unsupported make choice ''mmks' ignored\"\n+$       write sys$output \"Use MMK or MMS instead\"\n+$     endif\n+$   endif\n+$   i = i + 1\n+$   goto opt_loop\n+$ endif\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! Look for the compiler used\n+$!\n+$CHECK_COMPILER:\n+$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))\n+$ then\n+$   its_decc = (f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\") .nes. \"\")\n+$   its_vaxc = .not. its_decc .and. (F$Search(\"SYS$System:VAXC.Exe\") .nes. \"\")\n+$   its_gnuc = .not. (its_decc .or. its_vaxc) .and. (f$trnlnm(\"gnu_cc\") .nes. \"\")\n+$ endif\n+$!\n+$! Exit if no compiler available\n+$!\n+$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))\n+$ then goto CC_ERR\n+$ else\n+$   if its_decc then write sys$output \"CC compiler check ... Compaq C\"\n+$   if its_vaxc then write sys$output \"CC compiler check ... VAX C\"\n+$   if its_gnuc then write sys$output \"CC compiler check ... GNU C\"\n+$ endif\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! If MMS/MMK are available dump out the descrip.mms if required\n+$!\n+$CREA_MMS:\n+$ write sys$output \"Creating descrip.mms...\"\n+$ create descrip.mms\n+$ open/append out descrip.mms\n+$ copy sys$input: out\n+$ deck\n+# descrip.mms: MMS description file for building zlib on VMS\n+# written by Martin P.J. Zinser\n+# <zinser@zinser.no-ip.info or zinser@sysdev.deutsche-boerse.com>\n+\n+OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj, infback.obj\\\n+       deflate.obj, trees.obj, zutil.obj, inflate.obj, \\\n+       inftrees.obj, inffast.obj\n+\n+$ eod\n+$ write out \"CFLAGS=\", ccopt\n+$ write out \"LOPTS=\", lopts\n+$ copy sys$input: out\n+$ deck\n+\n+all : example.exe minigzip.exe libz.olb\n+        @ write sys$output \" Example applications available\"\n+\n+libz.olb : libz.olb($(OBJS))\n+\t@ write sys$output \" libz available\"\n+\n+example.exe : example.obj libz.olb\n+              link $(LOPTS) example,libz.olb/lib\n+\n+minigzip.exe : minigzip.obj libz.olb\n+              link $(LOPTS) minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\n+\n+clean :\n+\tdelete *.obj;*,libz.olb;*,*.opt;*,*.exe;*\n+\n+\n+# Other dependencies.\n+adler32.obj  : adler32.c zutil.h zlib.h zconf.h\n+compress.obj : compress.c zlib.h zconf.h\n+crc32.obj    : crc32.c zutil.h zlib.h zconf.h\n+deflate.obj  : deflate.c deflate.h zutil.h zlib.h zconf.h\n+example.obj  : example.c zlib.h zconf.h\n+gzio.obj     : gzio.c zutil.h zlib.h zconf.h\n+inffast.obj  : inffast.c zutil.h zlib.h zconf.h inftrees.h inffast.h\n+inflate.obj  : inflate.c zutil.h zlib.h zconf.h\n+inftrees.obj : inftrees.c zutil.h zlib.h zconf.h inftrees.h\n+minigzip.obj : minigzip.c zlib.h zconf.h\n+trees.obj    : trees.c deflate.h zutil.h zlib.h zconf.h\n+uncompr.obj  : uncompr.c zlib.h zconf.h\n+zutil.obj    : zutil.c zutil.h zlib.h zconf.h\n+infback.obj  : infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h\n+$ eod\n+$ close out\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! Read list of core library sources from makefile.in and create options\n+$! needed to build shareable image\n+$!\n+$CREA_OLIST:\n+$ open/read min makefile.in\n+$ open/write mod modules.opt\n+$ src_check = \"OBJS =\"\n+$MRLOOP:\n+$ read/end=mrdone min rec\n+$ if (f$extract(0,6,rec) .nes. src_check) then goto mrloop\n+$ rec = rec - src_check\n+$ gosub extra_filnam\n+$ if (f$element(1,\"\\\",rec) .eqs. \"\\\") then goto mrdone\n+$MRSLOOP:\n+$ read/end=mrdone min rec\n+$ gosub extra_filnam\n+$ if (f$element(1,\"\\\",rec) .nes. \"\\\") then goto mrsloop\n+$MRDONE:\n+$ close min\n+$ close mod\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! Take record extracted in crea_olist and split it into single filenames\n+$!\n+$EXTRA_FILNAM:\n+$ myrec = f$edit(rec - \"\\\", \"trim,compress\")\n+$ i = 0\n+$FELOOP:\n+$ srcfil = f$element(i,\" \", myrec)\n+$ if (srcfil .nes. \" \")\n+$ then\n+$   write mod f$parse(srcfil,,,\"NAME\"), \".obj\"\n+$   i = i + 1\n+$   goto feloop\n+$ endif\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! Find current Zlib version number\n+$!\n+$FIND_VERSION:\n+$ open/read h_in 'v_file'\n+$hloop:\n+$ read/end=hdone h_in rec\n+$ rec = f$edit(rec,\"TRIM\")\n+$ if (f$extract(0,1,rec) .nes. \"#\") then goto hloop\n+$ rec = f$edit(rec - \"#\", \"TRIM\")\n+$ if f$element(0,\" \",rec) .nes. \"define\" then goto hloop\n+$ if f$element(1,\" \",rec) .eqs. v_string\n+$ then\n+$   version = 'f$element(2,\" \",rec)'\n+$   goto hdone\n+$ endif\n+$ goto hloop\n+$hdone:\n+$ close h_in\n+$ return\n+$!------------------------------------------------------------------------------\n+$!\n+$! Analyze Object files for OpenVMS AXP to extract Procedure and Data\n+$! information to build a symbol vector for a shareable image\n+$! All the \"brains\" of this logic was suggested by Hartmut Becker\n+$! (Hartmut.Becker@compaq.com). All the bugs were introduced by me\n+$! (zinser@decus.de), so if you do have problem reports please do not\n+$! bother Hartmut/HP, but get in touch with me\n+$!\n+$ ANAL_OBJ_AXP: Subroutine\n+$ V = 'F$Verify(0)\n+$ SAY := \"WRITE_ SYS$OUTPUT\"\n+$\n+$ IF F$SEARCH(\"''P1'\") .EQS. \"\"\n+$ THEN\n+$    SAY \"ANAL_OBJ_AXP-E-NOSUCHFILE:  Error, inputfile ''p1' not available\"\n+$    goto exit_aa\n+$ ENDIF\n+$ IF \"''P2'\" .EQS. \"\"\n+$ THEN\n+$    SAY \"ANAL_OBJ_AXP:  Error, no output file provided\"\n+$    goto exit_aa\n+$ ENDIF\n+$\n+$ open/read in 'p1\n+$ create a.tmp\n+$ open/append atmp a.tmp\n+$ loop:\n+$ read/end=end_loop in line\n+$ f= f$search(line)\n+$ if f .eqs. \"\"\n+$ then\n+$\twrite sys$output \"ANAL_OBJ_AXP-w-nosuchfile, ''line'\"\n+$\tgoto loop\n+$ endif\n+$ define/user sys$output nl:\n+$ define/user sys$error nl:\n+$ anal/obj/gsd 'f /out=x.tmp\n+$ open/read xtmp x.tmp\n+$ XLOOP:\n+$ read/end=end_xloop xtmp xline\n+$ xline = f$edit(xline,\"compress\")\n+$ write atmp xline\n+$ goto xloop\n+$ END_XLOOP:\n+$ close xtmp\n+$ goto loop\n+$ end_loop:\n+$ close in\n+$ close atmp\n+$ if f$search(\"a.tmp\") .eqs. \"\" -\n+\tthen $ exit\n+$ ! all global definitions\n+$ search a.tmp \"symbol:\",\"EGSY$V_DEF 1\",\"EGSY$V_NORM 1\"/out=b.tmp\n+$ ! all procedures\n+$ search b.tmp \"EGSY$V_NORM 1\"/wind=(0,1) /out=c.tmp\n+$ search c.tmp \"symbol:\"/out=d.tmp\n+$ define/user sys$output nl:\n+$ edito/edt/command=sys$input d.tmp\n+sub/symbol: \"/symbol_vector=(/whole\n+sub/\"/=PROCEDURE)/whole\n+exit\n+$ ! all data\n+$ search b.tmp \"EGSY$V_DEF 1\"/wind=(0,1) /out=e.tmp\n+$ search e.tmp \"symbol:\"/out=f.tmp\n+$ define/user sys$output nl:\n+$ edito/edt/command=sys$input f.tmp\n+sub/symbol: \"/symbol_vector=(/whole\n+sub/\"/=DATA)/whole\n+exit\n+$ sort/nodupl d.tmp,f.tmp 'p2'\n+$ delete a.tmp;*,b.tmp;*,c.tmp;*,d.tmp;*,e.tmp;*,f.tmp;*\n+$ if f$search(\"x.tmp\") .nes. \"\" -\n+\tthen $ delete x.tmp;*\n+$!\n+$ EXIT_AA:\n+$ if V then set verify\n+$ endsubroutine\n+$!------------------------------------------------------------------------------"}, {"sha": "57efe58124eed661c2ff5827258772ab97a44bdc", "filename": "zlib/old/visual-basic.txt", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fold%2Fvisual-basic.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fold%2Fvisual-basic.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fold%2Fvisual-basic.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,160 @@\n+See below some functions declarations for Visual Basic.\n+\n+Frequently Asked Question:\n+\n+Q: Each time I use the compress function I get the -5 error (not enough\n+   room in the output buffer).\n+\n+A: Make sure that the length of the compressed buffer is passed by\n+   reference (\"as any\"), not by value (\"as long\"). Also check that\n+   before the call of compress this length is equal to the total size of\n+   the compressed buffer and not zero.\n+\n+\n+From: \"Jon Caruana\" <jon-net@usa.net>\n+Subject: Re: How to port zlib declares to vb?\n+Date: Mon, 28 Oct 1996 18:33:03 -0600\n+\n+Got the answer! (I haven't had time to check this but it's what I got, and\n+looks correct):\n+\n+He has the following routines working:\n+        compress\n+        uncompress\n+        gzopen\n+        gzwrite\n+        gzread\n+        gzclose\n+\n+Declares follow: (Quoted from Carlos Rios <c_rios@sonda.cl>, in Vb4 form)\n+\n+#If Win16 Then   'Use Win16 calls.\n+Declare Function compress Lib \"ZLIB.DLL\" (ByVal compr As\n+        String, comprLen As Any, ByVal buf As String, ByVal buflen\n+        As Long) As Integer\n+Declare Function uncompress Lib \"ZLIB.DLL\" (ByVal uncompr\n+        As String, uncomprLen As Any, ByVal compr As String, ByVal\n+        lcompr As Long) As Integer\n+Declare Function gzopen Lib \"ZLIB.DLL\" (ByVal filePath As\n+        String, ByVal mode As String) As Long\n+Declare Function gzread Lib \"ZLIB.DLL\" (ByVal file As\n+        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n+        As Integer\n+Declare Function gzwrite Lib \"ZLIB.DLL\" (ByVal file As\n+        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)\n+        As Integer\n+Declare Function gzclose Lib \"ZLIB.DLL\" (ByVal file As\n+        Long) As Integer\n+#Else\n+Declare Function compress Lib \"ZLIB32.DLL\"\n+        (ByVal compr As String, comprLen As Any, ByVal buf As\n+        String, ByVal buflen As Long) As Integer\n+Declare Function uncompress Lib \"ZLIB32.DLL\"\n+        (ByVal uncompr As String, uncomprLen As Any, ByVal compr As\n+        String, ByVal lcompr As Long) As Long\n+Declare Function gzopen Lib \"ZLIB32.DLL\"\n+        (ByVal file As String, ByVal mode As String) As Long\n+Declare Function gzread Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long, ByVal uncompr As String, ByVal\n+        uncomprLen As Long) As Long\n+Declare Function gzwrite Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long, ByVal uncompr As String, ByVal\n+        uncomprLen As Long) As Long\n+Declare Function gzclose Lib \"ZLIB32.DLL\"\n+        (ByVal file As Long) As Long\n+#End If\n+\n+-Jon Caruana\n+jon-net@usa.net\n+Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member\n+\n+\n+Here is another example from Michael <michael_borgsys@hotmail.com> that he\n+says conforms to the VB guidelines, and that solves the problem of not\n+knowing the uncompressed size by storing it at the end of the file:\n+\n+'Calling the functions:\n+'bracket meaning: <parameter> [optional] {Range of possible values}\n+'Call subCompressFile(<path with filename to compress> [, <path with\n+filename to write to>, [level of compression {1..9}]])\n+'Call subUncompressFile(<path with filename to compress>)\n+\n+Option Explicit\n+Private lngpvtPcnSml As Long 'Stores value for 'lngPercentSmaller'\n+Private Const SUCCESS As Long = 0\n+Private Const strFilExt As String = \".cpr\"\n+Private Declare Function lngfncCpr Lib \"zlib.dll\" Alias \"compress2\" (ByRef\n+dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long,\n+ByVal level As Integer) As Long\n+Private Declare Function lngfncUcp Lib \"zlib.dll\" Alias \"uncompress\" (ByRef\n+dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long)\n+As Long\n+\n+Public Sub subCompressFile(ByVal strargOriFilPth As String, Optional ByVal\n+strargCprFilPth As String, Optional ByVal intLvl As Integer = 9)\n+    Dim strCprPth As String\n+    Dim lngOriSiz As Long\n+    Dim lngCprSiz As Long\n+    Dim bytaryOri() As Byte\n+    Dim bytaryCpr() As Byte\n+    lngOriSiz = FileLen(strargOriFilPth)\n+    ReDim bytaryOri(lngOriSiz - 1)\n+    Open strargOriFilPth For Binary Access Read As #1\n+        Get #1, , bytaryOri()\n+    Close #1\n+    strCprPth = IIf(strargCprFilPth = \"\", strargOriFilPth, strargCprFilPth)\n+'Select file path and name\n+    strCprPth = strCprPth & IIf(Right(strCprPth, Len(strFilExt)) =\n+strFilExt, \"\", strFilExt) 'Add file extension if not exists\n+    lngCprSiz = (lngOriSiz * 1.01) + 12 'Compression needs temporary a bit\n+more space then original file size\n+    ReDim bytaryCpr(lngCprSiz - 1)\n+    If lngfncCpr(bytaryCpr(0), lngCprSiz, bytaryOri(0), lngOriSiz, intLvl) =\n+SUCCESS Then\n+        lngpvtPcnSml = (1# - (lngCprSiz / lngOriSiz)) * 100\n+        ReDim Preserve bytaryCpr(lngCprSiz - 1)\n+        Open strCprPth For Binary Access Write As #1\n+            Put #1, , bytaryCpr()\n+            Put #1, , lngOriSiz 'Add the the original size value to the end\n+(last 4 bytes)\n+        Close #1\n+    Else\n+        MsgBox \"Compression error\"\n+    End If\n+    Erase bytaryCpr\n+    Erase bytaryOri\n+End Sub\n+\n+Public Sub subUncompressFile(ByVal strargFilPth As String)\n+    Dim bytaryCpr() As Byte\n+    Dim bytaryOri() As Byte\n+    Dim lngOriSiz As Long\n+    Dim lngCprSiz As Long\n+    Dim strOriPth As String\n+    lngCprSiz = FileLen(strargFilPth)\n+    ReDim bytaryCpr(lngCprSiz - 1)\n+    Open strargFilPth For Binary Access Read As #1\n+        Get #1, , bytaryCpr()\n+    Close #1\n+    'Read the original file size value:\n+    lngOriSiz = bytaryCpr(lngCprSiz - 1) * (2 ^ 24) _\n+              + bytaryCpr(lngCprSiz - 2) * (2 ^ 16) _\n+              + bytaryCpr(lngCprSiz - 3) * (2 ^ 8) _\n+              + bytaryCpr(lngCprSiz - 4)\n+    ReDim Preserve bytaryCpr(lngCprSiz - 5) 'Cut of the original size value\n+    ReDim bytaryOri(lngOriSiz - 1)\n+    If lngfncUcp(bytaryOri(0), lngOriSiz, bytaryCpr(0), lngCprSiz) = SUCCESS\n+Then\n+        strOriPth = Left(strargFilPth, Len(strargFilPth) - Len(strFilExt))\n+        Open strOriPth For Binary Access Write As #1\n+            Put #1, , bytaryOri()\n+        Close #1\n+    Else\n+        MsgBox \"Uncompression error\"\n+    End If\n+    Erase bytaryCpr\n+    Erase bytaryOri\n+End Sub\n+Public Property Get lngPercentSmaller() As Long\n+    lngPercentSmaller = lngpvtPcnSml\n+End Property"}, {"sha": "1c029e4a34019956bbfdf55e7062b89a36da6b9e", "filename": "zlib/projects/README.projects", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2FREADME.projects", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2FREADME.projects", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2FREADME.projects?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,41 @@\n+This directory contains project files for building zlib under various\n+Integrated Development Environments (IDE).\n+\n+If you wish to submit a new project to this directory, you should comply\n+to the following requirements.  Otherwise (e.g. if you wish to integrate\n+a custom piece of code that changes the zlib interface or its behavior),\n+please consider submitting the project to the contrib directory.\n+\n+\n+Requirements\n+============\n+\n+- The project must build zlib using the source files from the official\n+  zlib source distribution, exclusively.\n+\n+- If the project produces redistributable builds (e.g. shared objects\n+  or DLL files), these builds must be compatible to those produced by\n+  makefiles, if such makefiles exist in the zlib distribution.\n+  In particular, if the project produces a DLL build for the Win32\n+  platform, this build must comply to the officially-ammended Win32 DLL\n+  Application Binary Interface (ABI), described in win32/DLL_FAQ.txt.\n+\n+- The project may provide additional build targets, which depend on\n+  3rd-party (unofficially-supported) software, present in the contrib\n+  directory.  For example, it is possible to provide an \"ASM build\",\n+  besides the officially-supported build, and have ASM source files\n+  among its dependencies.\n+\n+- If there are significant differences between the project files created\n+  by different versions of an IDE (e.g. Visual C++ 6.0 vs. 7.0), the name\n+  of the project directory should contain the version number of the IDE\n+  for which the project is intended (e.g. \"visualc6\" for Visual C++ 6.0,\n+  or \"visualc7\" for Visual C++ 7.0 and 7.1).\n+\n+\n+Current projects\n+================\n+\n+visualc6/   by Simon-Pierre Cadieux <methodex@methodex.ca>\n+            and Cosmin Truta <cosmint@cs.ubbcluj.ro>\n+        Project for Microsoft Visual C++ 6.0"}, {"sha": "d0296c272c31c82545b0d287c0b9a4198c834854", "filename": "zlib/projects/visualc6/README.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2FREADME.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2FREADME.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2Fvisualc6%2FREADME.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,73 @@\n+Microsoft Developer Studio Project Files, Format Version 6.00 for zlib.\r\n+\r\n+Copyright (C) 2000-2004 Simon-Pierre Cadieux.\r\n+Copyright (C) 2004 Cosmin Truta.\r\n+For conditions of distribution and use, see copyright notice in zlib.h.\r\n+\r\n+\r\n+This project builds the zlib binaries as follows:\r\n+\r\n+* Win32_DLL_Release\\zlib1.dll       DLL build\r\n+* Win32_DLL_Debug\\zlib1d.dll        DLL build (debug version)\r\n+* Win32_DLL_ASM_Release\\zlib1.dll   DLL build using ASM code\r\n+* Win32_DLL_ASM_Debug\\zlib1d.dll    DLL build using ASM code (debug version)\r\n+* Win32_LIB_Release\\zlib.lib        static build\r\n+* Win32_LIB_Debug\\zlibd.lib         static build (debug version)\r\n+* Win32_LIB_ASM_Release\\zlib.lib    static build using ASM code\r\n+* Win32_LIB_ASM_Debug\\zlibd.lib     static build using ASM code (debug version)\r\n+\r\n+\r\n+For more information regarding the DLL builds, please see the DLL FAQ\r\n+in ..\\..\\win32\\DLL_FAQ.txt.\r\n+\r\n+\r\n+To build and test:\r\n+\r\n+1) On the main menu, select \"File | Open Workspace\".\r\n+   Open \"zlib.dsw\".\r\n+\r\n+2) Select \"Build | Set Active Configuration\".\r\n+   Choose the configuration you wish to build.\r\n+\r\n+3) Select \"Build | Clean\".\r\n+\r\n+4) Select \"Build | Build ... (F7)\".  Ignore warning messages about\r\n+   not being able to find certain include files (e.g. alloc.h).\r\n+\r\n+5) If you built one of the sample programs (example or minigzip),\r\n+   select \"Build | Execute ... (Ctrl+F5)\".\r\n+\r\n+\r\n+To use:\r\n+\r\n+1) Select \"Project | Settings (Alt+F7)\".\r\n+   Make note of the configuration names used in your project.\r\n+   Usually, these names are \"Win32 Release\" and \"Win32 Debug\".\r\n+\r\n+2) In the Workspace window, select the \"FileView\" tab.\r\n+   Right-click on the root item \"Workspace '...'\".\r\n+   Select \"Insert Project into Workspace\".\r\n+   Switch on the checkbox \"Dependency of:\", and select the name\r\n+   of your project.  Open \"zlib.dsp\".\r\n+\r\n+3) Select \"Build | Configurations\".\r\n+   For each configuration of your project:\r\n+   3.1) Choose the zlib configuration you wish to use.\r\n+   3.2) Click on \"Add\".\r\n+   3.3) Set the new zlib configuration name to the name used by\r\n+        the configuration from the current iteration.\r\n+\r\n+4) Select \"Build | Set Active Configuration\".\r\n+   Choose the configuration you wish to build.\r\n+\r\n+5) Select \"Build | Build ... (F7)\".\r\n+\r\n+6) If you built an executable program, select\r\n+   \"Build | Execute ... (Ctrl+F5)\".\r\n+\r\n+\r\n+Note:\r\n+\r\n+To build the ASM-enabled code, you need Microsoft Assembler\r\n+(ML.EXE).  You can get it by downloading and installing the\r\n+latest Processor Pack for Visual C++ 6.0.\r"}, {"sha": "e072a37ff00b6e76264f0ea71a2d1e52b5213253", "filename": "zlib/projects/visualc6/example.dsp", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fexample.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fexample.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2Fvisualc6%2Fexample.dsp?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,278 @@\n+# Microsoft Developer Studio Project File - Name=\"example\" - Package Owner=<4>\r\n+# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n+# ** DO NOT EDIT **\r\n+\r\n+# TARGTYPE \"Win32 (x86) Console Application\" 0x0103\r\n+\r\n+CFG=example - Win32 LIB Debug\r\n+!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n+!MESSAGE use the Export Makefile command and run\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"example.mak\".\r\n+!MESSAGE \r\n+!MESSAGE You can specify a configuration when running NMAKE\r\n+!MESSAGE by defining the macro CFG on the command line. For example:\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"example.mak\" CFG=\"example - Win32 LIB Debug\"\r\n+!MESSAGE \r\n+!MESSAGE Possible choices for configuration are:\r\n+!MESSAGE \r\n+!MESSAGE \"example - Win32 DLL Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 DLL Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 DLL ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 LIB Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 LIB Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 LIB ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"example - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \r\n+\r\n+# Begin Project\r\n+# PROP AllowPerConfigDependencies 0\r\n+# PROP Scc_ProjName \"\"\r\n+# PROP Scc_LocalPath \"\"\r\n+CPP=cl.exe\r\n+RSC=rc.exe\r\n+\r\n+!IF  \"$(CFG)\" == \"example - Win32 DLL Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"example___Win32_DLL_Release\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_DLL_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"example___Win32_DLL_Debug\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_DLL_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"example___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 DLL ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"example___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"example___Win32_LIB_Release\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_LIB_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"example___Win32_LIB_Debug\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_LIB_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"example___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"example - Win32 LIB ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"example___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"example___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ENDIF \r\n+\r\n+# Begin Target\r\n+\r\n+# Name \"example - Win32 DLL Release\"\r\n+# Name \"example - Win32 DLL Debug\"\r\n+# Name \"example - Win32 DLL ASM Release\"\r\n+# Name \"example - Win32 DLL ASM Debug\"\r\n+# Name \"example - Win32 LIB Release\"\r\n+# Name \"example - Win32 LIB Debug\"\r\n+# Name \"example - Win32 LIB ASM Release\"\r\n+# Name \"example - Win32 LIB ASM Debug\"\r\n+# Begin Group \"Source Files\"\r\n+\r\n+# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\example.c\r\n+# End Source File\r\n+# End Group\r\n+# Begin Group \"Header Files\"\r\n+\r\n+# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zconf.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zlib.h\r\n+# End Source File\r\n+# End Group\r\n+# End Target\r\n+# End Project\r"}, {"sha": "f32024eaf5f9ef2558cd2f29794ba2b1ea072cf4", "filename": "zlib/projects/visualc6/minigzip.dsp", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fminigzip.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fminigzip.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2Fvisualc6%2Fminigzip.dsp?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,278 @@\n+# Microsoft Developer Studio Project File - Name=\"minigzip\" - Package Owner=<4>\r\n+# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n+# ** DO NOT EDIT **\r\n+\r\n+# TARGTYPE \"Win32 (x86) Console Application\" 0x0103\r\n+\r\n+CFG=minigzip - Win32 LIB Debug\r\n+!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n+!MESSAGE use the Export Makefile command and run\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"minigzip.mak\".\r\n+!MESSAGE \r\n+!MESSAGE You can specify a configuration when running NMAKE\r\n+!MESSAGE by defining the macro CFG on the command line. For example:\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"minigzip.mak\" CFG=\"minigzip - Win32 LIB Debug\"\r\n+!MESSAGE \r\n+!MESSAGE Possible choices for configuration are:\r\n+!MESSAGE \r\n+!MESSAGE \"minigzip - Win32 DLL Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 DLL Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 DLL ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 LIB Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 LIB Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 LIB ASM Release\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \"minigzip - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Console Application\")\r\n+!MESSAGE \r\n+\r\n+# Begin Project\r\n+# PROP AllowPerConfigDependencies 0\r\n+# PROP Scc_ProjName \"\"\r\n+# PROP Scc_LocalPath \"\"\r\n+CPP=cl.exe\r\n+RSC=rc.exe\r\n+\r\n+!IF  \"$(CFG)\" == \"minigzip - Win32 DLL Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"minigzip___Win32_DLL_Release\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"minigzip___Win32_DLL_Debug\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"minigzip___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 DLL ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"minigzip___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"minigzip___Win32_LIB_Release\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"minigzip___Win32_LIB_Debug\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"minigzip___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386\r\n+# ADD LINK32 /nologo /subsystem:console /machine:I386\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"minigzip - Win32 LIB ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"minigzip___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"minigzip___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept\r\n+\r\n+!ENDIF \r\n+\r\n+# Begin Target\r\n+\r\n+# Name \"minigzip - Win32 DLL Release\"\r\n+# Name \"minigzip - Win32 DLL Debug\"\r\n+# Name \"minigzip - Win32 DLL ASM Release\"\r\n+# Name \"minigzip - Win32 DLL ASM Debug\"\r\n+# Name \"minigzip - Win32 LIB Release\"\r\n+# Name \"minigzip - Win32 LIB Debug\"\r\n+# Name \"minigzip - Win32 LIB ASM Release\"\r\n+# Name \"minigzip - Win32 LIB ASM Debug\"\r\n+# Begin Group \"Source Files\"\r\n+\r\n+# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\minigzip.c\r\n+# End Source File\r\n+# End Group\r\n+# Begin Group \"Header Files\"\r\n+\r\n+# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zconf.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zlib.h\r\n+# End Source File\r\n+# End Group\r\n+# End Target\r\n+# End Project\r"}, {"sha": "0fe0604ccd76a78b3e592243602b2dfdc1416dae", "filename": "zlib/projects/visualc6/zlib.dsp", "status": "added", "additions": 609, "deletions": 0, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsp?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,609 @@\n+# Microsoft Developer Studio Project File - Name=\"zlib\" - Package Owner=<4>\r\n+# Microsoft Developer Studio Generated Build File, Format Version 6.00\r\n+# ** DO NOT EDIT **\r\n+\r\n+# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\r\n+# TARGTYPE \"Win32 (x86) Static Library\" 0x0104\r\n+\r\n+CFG=zlib - Win32 LIB Debug\r\n+!MESSAGE This is not a valid makefile. To build this project using NMAKE,\r\n+!MESSAGE use the Export Makefile command and run\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"zlib.mak\".\r\n+!MESSAGE \r\n+!MESSAGE You can specify a configuration when running NMAKE\r\n+!MESSAGE by defining the macro CFG on the command line. For example:\r\n+!MESSAGE \r\n+!MESSAGE NMAKE /f \"zlib.mak\" CFG=\"zlib - Win32 LIB Debug\"\r\n+!MESSAGE \r\n+!MESSAGE Possible choices for configuration are:\r\n+!MESSAGE \r\n+!MESSAGE \"zlib - Win32 DLL Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n+!MESSAGE \"zlib - Win32 DLL Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n+!MESSAGE \"zlib - Win32 DLL ASM Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n+!MESSAGE \"zlib - Win32 DLL ASM Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\r\n+!MESSAGE \"zlib - Win32 LIB Release\" (based on \"Win32 (x86) Static Library\")\r\n+!MESSAGE \"zlib - Win32 LIB Debug\" (based on \"Win32 (x86) Static Library\")\r\n+!MESSAGE \"zlib - Win32 LIB ASM Release\" (based on \"Win32 (x86) Static Library\")\r\n+!MESSAGE \"zlib - Win32 LIB ASM Debug\" (based on \"Win32 (x86) Static Library\")\r\n+!MESSAGE \r\n+\r\n+# Begin Project\r\n+# PROP AllowPerConfigDependencies 0\r\n+# PROP Scc_ProjName \"\"\r\n+# PROP Scc_LocalPath \"\"\r\n+\r\n+!IF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"zlib___Win32_DLL_Release\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+MTL=midl.exe\r\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386\r\n+# ADD LINK32 /nologo /dll /machine:I386 /out:\"Win32_DLL_Release\\zlib1.dll\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"zlib___Win32_DLL_Debug\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+MTL=midl.exe\r\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n+# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /dll /debug /machine:I386 /out:\"Win32_DLL_Debug\\zlib1d.dll\" /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"zlib___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Release\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+MTL=midl.exe\r\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n+# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386\r\n+# ADD LINK32 /nologo /dll /machine:I386 /out:\"Win32_DLL_ASM_Release\\zlib1.dll\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"zlib___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_DLL_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_DLL_ASM_Debug\"\r\n+# PROP Ignore_Export_Lib 0\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+MTL=midl.exe\r\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n+# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LINK32=link.exe\r\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept\r\n+# ADD LINK32 /nologo /dll /debug /machine:I386 /out:\"Win32_DLL_ASM_Debug\\zlib1d.dll\" /pdbtype:sept\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"zlib___Win32_LIB_Release\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Release\"\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LIB32=link.exe -lib\r\n+# ADD BASE LIB32 /nologo\r\n+# ADD LIB32 /nologo\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"zlib___Win32_LIB_Debug\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_Debug\"\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LIB32=link.exe -lib\r\n+# ADD BASE LIB32 /nologo\r\n+# ADD LIB32 /nologo /out:\"Win32_LIB_Debug\\zlibd.lib\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 0\r\n+# PROP BASE Output_Dir \"zlib___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_ASM_Release\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 0\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Release\"\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /FD /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MD /W3 /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"NDEBUG\"\r\n+# ADD RSC /l 0x409 /d \"NDEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LIB32=link.exe -lib\r\n+# ADD BASE LIB32 /nologo\r\n+# ADD LIB32 /nologo\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n+\r\n+# PROP BASE Use_MFC 0\r\n+# PROP BASE Use_Debug_Libraries 1\r\n+# PROP BASE Output_Dir \"zlib___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Intermediate_Dir \"zlib___Win32_LIB_ASM_Debug\"\r\n+# PROP BASE Target_Dir \"\"\r\n+# PROP Use_MFC 0\r\n+# PROP Use_Debug_Libraries 1\r\n+# PROP Output_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Intermediate_Dir \"Win32_LIB_ASM_Debug\"\r\n+# PROP Target_Dir \"\"\r\n+CPP=cl.exe\r\n+# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /FD /GZ /c\r\n+# SUBTRACT BASE CPP /YX /Yc /Yu\r\n+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D \"WIN32\" /D \"_DEBUG\" /D \"ASMV\" /D \"ASMINF\" /FD /GZ /c\r\n+# SUBTRACT CPP /YX /Yc /Yu\r\n+RSC=rc.exe\r\n+# ADD BASE RSC /l 0x409 /d \"_DEBUG\"\r\n+# ADD RSC /l 0x409 /d \"_DEBUG\"\r\n+BSC32=bscmake.exe\r\n+# ADD BASE BSC32 /nologo\r\n+# ADD BSC32 /nologo\r\n+LIB32=link.exe -lib\r\n+# ADD BASE LIB32 /nologo\r\n+# ADD LIB32 /nologo /out:\"Win32_LIB_ASM_Debug\\zlibd.lib\"\r\n+\r\n+!ENDIF \r\n+\r\n+# Begin Target\r\n+\r\n+# Name \"zlib - Win32 DLL Release\"\r\n+# Name \"zlib - Win32 DLL Debug\"\r\n+# Name \"zlib - Win32 DLL ASM Release\"\r\n+# Name \"zlib - Win32 DLL ASM Debug\"\r\n+# Name \"zlib - Win32 LIB Release\"\r\n+# Name \"zlib - Win32 LIB Debug\"\r\n+# Name \"zlib - Win32 LIB ASM Release\"\r\n+# Name \"zlib - Win32 LIB ASM Debug\"\r\n+# Begin Group \"Source Files\"\r\n+\r\n+# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;idl;hpj;bat\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\adler32.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\compress.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\crc32.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\deflate.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\gzio.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\infback.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inffast.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inflate.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inftrees.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\trees.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\uncompr.c\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\win32\\zlib.def\r\n+\r\n+!IF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ENDIF \r\n+\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zutil.c\r\n+# End Source File\r\n+# End Group\r\n+# Begin Group \"Header Files\"\r\n+\r\n+# PROP Default_Filter \"h;hpp;hxx;hm;inl\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\crc32.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\deflate.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inffast.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inffixed.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inflate.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\inftrees.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\trees.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zconf.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zlib.h\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\zutil.h\r\n+# End Source File\r\n+# End Group\r\n+# Begin Group \"Resource Files\"\r\n+\r\n+# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\win32\\zlib1.rc\r\n+# End Source File\r\n+# End Group\r\n+# Begin Group \"Assembler Files (Unsupported)\"\r\n+\r\n+# PROP Default_Filter \"asm;obj;c;cpp;cxx;h;hpp;hxx\"\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n+\r\n+!IF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_DLL_ASM_Release\r\n+InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n+InputName=gvmat32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_DLL_ASM_Debug\r\n+InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n+InputName=gvmat32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_LIB_ASM_Release\r\n+InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n+InputName=gvmat32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_LIB_ASM_Debug\r\n+InputPath=..\\..\\contrib\\masmx86\\gvmat32.asm\r\n+InputName=gvmat32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ENDIF \r\n+\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\contrib\\masmx86\\gvmat32c.c\r\n+\r\n+!IF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n+\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n+\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n+\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n+\r\n+# ADD CPP /I \"..\\..\"\r\n+\r\n+!ENDIF \r\n+\r\n+# End Source File\r\n+# Begin Source File\r\n+\r\n+SOURCE=..\\..\\contrib\\masmx86\\inffas32.asm\r\n+\r\n+!IF  \"$(CFG)\" == \"zlib - Win32 DLL Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Release\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_DLL_ASM_Release\r\n+InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n+InputName=inffas32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 DLL ASM Debug\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_DLL_ASM_Debug\r\n+InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n+InputName=inffas32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Release\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB Debug\"\r\n+\r\n+# PROP Exclude_From_Build 1\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Release\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_LIB_ASM_Release\r\n+InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n+InputName=inffas32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ELSEIF  \"$(CFG)\" == \"zlib - Win32 LIB ASM Debug\"\r\n+\r\n+# Begin Custom Build - Assembling...\r\n+IntDir=.\\Win32_LIB_ASM_Debug\r\n+InputPath=..\\..\\contrib\\masmx86\\inffas32.asm\r\n+InputName=inffas32\r\n+\r\n+\"$(IntDir)\\$(InputName).obj\" : $(SOURCE) \"$(INTDIR)\" \"$(OUTDIR)\"\r\n+\tml.exe /nologo /c /coff /Cx /Zi /Fo\"$(IntDir)\\$(InputName).obj\" \"$(InputPath)\"\r\n+\r\n+# End Custom Build\r\n+\r\n+!ENDIF \r\n+\r\n+# End Source File\r\n+# End Group\r\n+# Begin Source File\r\n+\r\n+SOURCE=.\\README.txt\r\n+# End Source File\r\n+# End Target\r\n+# End Project\r"}, {"sha": "3a771fce07d16f68c4dfffd6f90d7ea8973d6c76", "filename": "zlib/projects/visualc6/zlib.dsw", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fprojects%2Fvisualc6%2Fzlib.dsw?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,59 @@\n+Microsoft Developer Studio Workspace File, Format Version 6.00\r\n+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\r\n+\r\n+###############################################################################\r\n+\r\n+Project: \"example\"=.\\example.dsp - Package Owner=<4>\r\n+\r\n+Package=<5>\r\n+{{{\r\n+}}}\r\n+\r\n+Package=<4>\r\n+{{{\r\n+    Begin Project Dependency\r\n+    Project_Dep_Name zlib\r\n+    End Project Dependency\r\n+}}}\r\n+\r\n+###############################################################################\r\n+\r\n+Project: \"minigzip\"=.\\minigzip.dsp - Package Owner=<4>\r\n+\r\n+Package=<5>\r\n+{{{\r\n+}}}\r\n+\r\n+Package=<4>\r\n+{{{\r\n+    Begin Project Dependency\r\n+    Project_Dep_Name zlib\r\n+    End Project Dependency\r\n+}}}\r\n+\r\n+###############################################################################\r\n+\r\n+Project: \"zlib\"=.\\zlib.dsp - Package Owner=<4>\r\n+\r\n+Package=<5>\r\n+{{{\r\n+}}}\r\n+\r\n+Package=<4>\r\n+{{{\r\n+}}}\r\n+\r\n+###############################################################################\r\n+\r\n+Global:\r\n+\r\n+Package=<5>\r\n+{{{\r\n+}}}\r\n+\r\n+Package=<3>\r\n+{{{\r\n+}}}\r\n+\r\n+###############################################################################\r\n+\r"}, {"sha": "579a5fc9e0fd7a04e11e156a6341bf68e209e154", "filename": "zlib/win32/VisualC.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fwin32%2FVisualC.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/303ae446cf2ab1469d83e83f4cc5168c899c3cee/zlib%2Fwin32%2FVisualC.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fwin32%2FVisualC.txt?ref=303ae446cf2ab1469d83e83f4cc5168c899c3cee", "patch": "@@ -0,0 +1,3 @@\n+\n+To build zlib using the Microsoft Visual C++ environment,\n+use the appropriate project from the projects/ directory."}]}