{"sha": "994fe6604bda9582b9ccc58f105f553dfb4b792a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0ZmU2NjA0YmRhOTU4MmI5Y2NjNThmMTA1ZjU1M2RmYjRiNzkyYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2001-08-11T21:09:37Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2001-08-11T21:09:37Z"}, "message": "Coding style cleanup.\n\nFrom-SVN: r44811", "tree": {"sha": "3943ca89968607260a483bab2be123a9fce1c32f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3943ca89968607260a483bab2be123a9fce1c32f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/994fe6604bda9582b9ccc58f105f553dfb4b792a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994fe6604bda9582b9ccc58f105f553dfb4b792a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994fe6604bda9582b9ccc58f105f553dfb4b792a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994fe6604bda9582b9ccc58f105f553dfb4b792a/comments", "author": null, "committer": null, "parents": [{"sha": "f314b9b1682cb72cde6561b8e05eba08d94e1edd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f314b9b1682cb72cde6561b8e05eba08d94e1edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f314b9b1682cb72cde6561b8e05eba08d94e1edd"}], "stats": {"total": 812, "additions": 511, "deletions": 301}, "files": [{"sha": "70e5228bd2b4bf3952614e609112926c1c77f8b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -1,3 +1,9 @@\n+2001-08-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+ \n+\t* s390.c, s390.h, s390.md, s390-protos.h, linux.h, t-linux: \n+\tClean up code: add missing comments and prototypes, fix warnings,\n+        remove obsolete code, fix spacing to conform to coding style.\n+\n 2001-08-11  Ulrich Weigand  <uweigand@de.ibm.com>\n  \n  \t* config/s390/s390.c (targetm): Define TARGET_ASM_OPEN_PAREN"}, {"sha": "31b657ce78d1c34ad1f5ef2648a90e9d73fc087c", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -154,7 +154,7 @@ do { fprintf ((FILE), \"%s\\t\", ASM_QUAD);          \t\t\t\\\n #undef ASM_OUTPUT_INT\n #define ASM_OUTPUT_INT(FILE, VALUE)             \\\n do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n-  output_addr_const (FILE,(VALUE));             \\\n+  output_addr_const (FILE, (VALUE));            \\\n   putc ('\\n',FILE);                             \\\n  } while (0)\n \n@@ -163,7 +163,7 @@ do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n \n #define ASM_OUTPUT_SHORT(FILE, VALUE)           \\\n ( fprintf (FILE, \"%s \", ASM_SHORT),             \\\n-  output_addr_const (FILE,(VALUE)),             \\\n+  output_addr_const (FILE, (VALUE)),            \\\n   putc ('\\n',FILE))\n \n #define ASM_OUTPUT_CHAR(FILE, VALUE)            \\\n@@ -284,7 +284,7 @@ do {                                                                    \\\n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n \n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)  \\\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)  \\\n   (fputs (\".globl \", FILE), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)"}, {"sha": "5027e749859e650b3044f15f8a4275c08b35696d", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -19,70 +19,56 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Declare functions in s390.c and linux.c */\n+/* Declare functions in s390.c.  */\n \n-#ifdef RTX_CODE\n-\n-#ifdef TREE_CODE\n-extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx, int));\n-extern void s390_va_start PARAMS ((int, tree, rtx));\n-\n-#endif /* TREE_CODE */\n+extern void optimization_options PARAMS ((int, int));\n+extern int s390_arg_frame_offset PARAMS ((void));\n+extern void s390_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+extern void s390_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n+#ifdef RTX_CODE\n+extern int const0_operand PARAMS ((rtx, enum machine_mode));\n+extern int const1_operand PARAMS ((rtx, enum machine_mode));\n+extern int larl_operand PARAMS ((rtx, enum machine_mode));\n extern int fp_operand PARAMS ((rtx, enum machine_mode));\n extern int s_operand PARAMS ((rtx, enum machine_mode));\n-extern int larl_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_im8_operand PARAMS ((rtx, enum machine_mode));\n-extern int r_or_s_operand PARAMS ((rtx, enum machine_mode)); \n+extern int r_or_s_operand PARAMS ((rtx, enum machine_mode));\n extern int r_or_s_or_im8_operand PARAMS ((rtx, enum machine_mode));\n extern int r_or_x_or_im16_operand PARAMS ((rtx, enum machine_mode));\n+extern int r_or_im8_operand PARAMS ((rtx, enum machine_mode));\n+extern int tmxx_operand PARAMS ((rtx, enum machine_mode));\n extern int bras_sym_operand PARAMS ((rtx, enum machine_mode));\n extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int dead_p PARAMS ((rtx, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, char));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n+\n+extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_constant_p PARAMS ((rtx));\n+extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n+extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n+extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n \n-extern int unsigned_comparison_operator PARAMS ((rtx));\n-extern int unsigned_jump_follows_p PARAMS ((rtx));\n-\n-extern void update_cc PARAMS ((rtx, rtx));\n-\n-extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n extern int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-\n extern int s390_stop_dump_lit_p PARAMS ((rtx));\n extern void s390_dump_literal_pool PARAMS ((rtx, rtx));\n-extern void s390_expand_eh_epilogue PARAMS ((rtx, rtx, rtx));\n-extern void s390_asm_output_external_libcall PARAMS ((FILE *, rtx));\n-\n+extern void s390_trampoline_template PARAMS ((FILE *));\n+extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern void s390_function_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t       tree, int));\n-extern struct rtx_def *s390_function_arg PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode, tree, int));\n-extern int s390_function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode, tree, int));\n+extern void s390_asm_output_pool_prologue PARAMS ((FILE *, const char *, tree, int));\n extern int s390_function_arg_pass_by_reference PARAMS ((enum machine_mode, tree));\n-extern void setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t    enum machine_mode, tree,\n-\t\t\t\t\t    int *, int));\n-extern struct rtx_def *s390_va_arg PARAMS ((tree, tree));\n-extern union tree_node *s390_build_va_list PARAMS ((void));\n-extern void s390_asm_output_pool_prologue PARAMS ((FILE *, char *, tree, int));\n-extern void encode_section_info PARAMS ((tree));\n-\n+extern void s390_function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern tree s390_build_va_list PARAMS ((void));\n+#ifdef RTX_CODE\n+extern rtx s390_function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern void s390_va_start PARAMS ((int, tree, rtx));\n+extern rtx s390_va_arg PARAMS ((tree, tree));\n+#endif /* RTX_CODE */\n #endif /* TREE_CODE */\n \n-\n-extern void s390_trampoline_template PARAMS ((FILE *));\n-extern void s390_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void s390_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void s390_final_chunkify PARAMS ((int));\n-extern int s390_arg_frame_offset PARAMS ((void));"}, {"sha": "c3917505445c6f80f4b68bd17751cba8c70401fc", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 434, "deletions": 221, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -70,6 +70,14 @@ int  s390_function_count = 0;\n    emitted.  */\n rtx s390_compare_op0, s390_compare_op1;\n \n+/* Structure used to hold the components of a S/390 memory\n+   address.  A legitimate address on S/390 is of the general\n+   form\n+          base + index + displacement\n+   where any of the components is optional.\n+\n+   base and index are registers of the class ADDR_REGS,\n+   displacement is an unsigned 12-bit immediate constant.  */\n \n struct s390_address\n {\n@@ -78,30 +86,41 @@ struct s390_address\n   rtx disp;\n };\n \n-static int s390_match_ccmode_set \n-  PARAMS ((rtx set, int req_mode));\n-static int base_n_index_p \n-  PARAMS ((rtx op));\n-static int check_mode \n-  PARAMS ((register rtx op, enum machine_mode *mode));\n-static int s390_decompose_address \n-  PARAMS ((register rtx addr, struct s390_address *out, int strict));\n-static int check_mode \n-  PARAMS ((register rtx op, enum machine_mode *mode));\n+static int s390_match_ccmode_set PARAMS ((rtx, enum machine_mode));\n+static int base_n_index_p PARAMS ((rtx));\n+static int check_mode PARAMS ((rtx, enum machine_mode *));\n+static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n+static void output_branch_condition PARAMS ((FILE *, rtx));\n+static void output_inverse_branch_condition PARAMS ((FILE *, rtx));\n+static int reg_used_in_mem_p PARAMS ((int, rtx));\n+static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n+static int other_chunk PARAMS ((int *, int, int));\n+static int far_away PARAMS ((int, int));\n+static rtx check_and_change_labels PARAMS ((rtx, int *));\n+static void s390_final_chunkify PARAMS ((int));\n+static int save_fprs_p PARAMS ((void));\n+static int cur_is_leaf_function PARAMS ((void));\n+static int save_fprs PARAMS ((FILE *, long, int));\n+static int restore_fprs PARAMS ((FILE *, long, int));\n+static void s390_output_constant_pool PARAMS ((FILE *));\n+static rtx s390_force_const_mem_late PARAMS ((rtx));\n+static rtx s390_force_const_mem_symbol PARAMS ((const char *, int, int));\n+static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n+\n  \n-/* Return TRUE or FALSE depending on whether every SET in INSN that\n-   set the CC register has source and destination with matching CC modes, \n-   and that the CC mode is at least as constrained as REQ_MODE.  */\n+/* Return true if SET either doesn't set the CC register, or else\n+   the source and destination have matching CC modes and that \n+   CC mode is at least as constrained as REQ_MODE.  */\n  \n static int\n s390_match_ccmode_set (set, req_mode)\n      rtx set;\n-     int req_mode;\n+     enum machine_mode req_mode;\n {\n-  unsigned int set_mode;\n+  enum machine_mode set_mode;\n \n   if (GET_CODE (set) != SET)\n-    abort();\n+    abort ();\n \n   if (GET_CODE (SET_DEST (set)) != REG || !CC_REGNO_P (REGNO (SET_DEST (set))))\n     return 1;\n@@ -132,10 +151,14 @@ s390_match_ccmode_set (set, req_mode)\n   return (GET_MODE (SET_SRC (set)) == set_mode);\n }\n \n+/* Return true if every SET in INSN that sets the CC register \n+   has source and destination with matching CC modes and that \n+   CC mode is at least as constrained as REQ_MODE.  */\n+ \n int\n s390_match_ccmode (insn, req_mode)\n      rtx insn;\n-     int req_mode;\n+     enum machine_mode req_mode;\n {\n   int i;\n \n@@ -154,10 +177,17 @@ s390_match_ccmode (insn, req_mode)\n   return 1;\n }\n \n+/* Change optimizations to be performed, depending on the \n+   optimization level.\n+\n+   LEVEL is the optimization level specified; 2 if `-O2' is\n+   specified, 1 if `-O' is specified, and 0 if neither is specified.\n+\n+   SIZE is non-zero if `-Os' is specified and zero otherwise. */\n \n void\n optimization_options (level, size)\n-     int level;\n+     int level ATTRIBUTE_UNUSED;\n      int size ATTRIBUTE_UNUSED;\n {\n #ifdef HAVE_decrement_and_branch_on_count\n@@ -183,7 +213,9 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n };\n \n \n-/* Match exactly zero.  */\n+/* Return true if OP a (const_int 0) operand.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n  \n int\n const0_operand (op, mode)\n@@ -193,7 +225,9 @@ const0_operand (op, mode)\n   return op == CONST0_RTX (mode);\n }\n \n-/* Match exactly one.  */\n+/* Return true if OP a (const_int 1) operand.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n  \n int\n const1_operand (op, mode)\n@@ -202,12 +236,12 @@ const1_operand (op, mode)\n {\n   return op == CONST1_RTX (mode);\n }\n- \n \n-/* Return 1 if OP needs base and index register.  */\n+/* Return true if OP needs base and index register.  */\n \n static int \n-base_n_index_p (rtx op)\n+base_n_index_p (op)\n+     register rtx op;\n {\n   if ((GET_CODE (op) == PLUS) &&\n       (GET_CODE (XEXP (op, 0)) == PLUS ||\n@@ -217,7 +251,8 @@ base_n_index_p (rtx op)\n   return 0;\n }\n \n-/* Check mode and mode of op, set it to mode of op, if VOIDmode.  */ \n+/* Return true if the mode of operand OP matches MODE.\n+   If MODE is set to VOIDmode, set it to the mode of OP.  */ \n \n static int\n check_mode (op, mode)\n@@ -234,8 +269,7 @@ check_mode (op, mode)\n   return 1;\n }\n \n-\n-/* Return 1 if OP a valid operand for the LARL instruction.\n+/* Return true if OP a valid operand for the LARL instruction.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n@@ -244,9 +278,6 @@ larl_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  rtx sym;\n-  register enum rtx_code code = GET_CODE (op);\n-\n   if (! check_mode (op, &mode))\n     return 0;\n \n@@ -291,7 +322,7 @@ larl_operand (op, mode)\n   return 0;\n }\n \n-/* Return 1 if OP is a valid FP-Register.\n+/* Return true if OP is a valid FP-Register.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n@@ -309,7 +340,9 @@ fp_operand (op, mode)\n     return 0;\n }\n \n-/* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.  */\n+/* Return true if OP is a valid S operand for an RS, SI or SS type instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n s_operand (op, mode)\n@@ -330,7 +363,9 @@ s_operand (op, mode)\n }\n \n /* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n-   instruction.  */\n+   instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n r_or_s_operand (op, mode)\n@@ -351,8 +386,10 @@ r_or_s_operand (op, mode)\n   return register_operand (op, mode);\n }\n \n-/* Return 1 if OP is a valid R or S or immediate operand for \n-   RS, SI or SS type instruction.  */\n+/* Return true if OP is a valid R or S or immediate operand for \n+   RS, SI or SS type instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n r_or_s_or_im8_operand (op, mode)\n@@ -373,8 +410,10 @@ r_or_s_or_im8_operand (op, mode)\n   return register_operand (op, mode) || immediate_operand (op, mode);\n }\n \n-/* Return 1 if OP is a valid R or X or 16 bit immediate operand for \n-   RX, RR or RI type instruction.  */\n+/* Return true if OP is a valid R or X or 16 bit immediate operand for \n+   RX, RR or RI type instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n r_or_x_or_im16_operand (op, mode)\n@@ -390,8 +429,9 @@ r_or_x_or_im16_operand (op, mode)\n   return register_operand (op, mode) || memory_operand (op, mode);\n }\n \n-/* Return 1 if OP is a valid R or 8 bit immediate operand for \n-   !!!!!!! type instruction.  */\n+/* Return true if OP is a valid R or 8 bit immediate operand.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n r_or_im8_operand (op, mode)\n@@ -407,14 +447,16 @@ r_or_im8_operand (op, mode)\n   return register_operand (op, mode) || memory_operand (op, mode);\n }\n \n-/* Return 1 if OP is a valid operand for the 'test under mask'\n+/* Return true if OP is a valid operand for the 'test under mask'\n    instruction with 16 bit immediate.  \n-   The value should only have set bits in one halfword.  */ \n+   The value should only have set bits in one halfword.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n tmxx_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   rtx con;\n   if (GET_CODE (op) == CONST_INT)\n@@ -431,7 +473,7 @@ tmxx_operand (op, mode)\n \t  c = (unsigned HOST_WIDEST_INT) INTVAL (con);\n \t  \n \t  return ((c & 0xffff) ? ((c & 0xffffffffffff0000ULL)==0) : \n-\t\t  (c & 0xffff0000) ? ((c & 0xffffffff0000ffffULL)==0) :\n+\t\t  (c & 0xffff0000U) ? ((c & 0xffffffff0000ffffULL)==0) :\n \t\t  (c & 0xffff00000000ULL) ? ((c & 0xffff0000ffffffffULL)==0) :\n \t\t  (c & 0xffff000000000000ULL) ? ((c & 0xffffffffffffULL)==0) : 1);\n \t\t  \n@@ -440,15 +482,14 @@ tmxx_operand (op, mode)\n   return 0;\n }\n \n-\n-/* Return 1 if valid operand for BRAS\n+/* Return true if OP is a valid operand for the BRAS instruction.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n int\n bras_sym_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   register enum rtx_code code = GET_CODE (op);\n \n@@ -465,8 +506,10 @@ bras_sym_operand (op, mode)\n }\n \n \f\n-/* Return 1 if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested.  */\n+/* Return true if OP is a load multiple operation.  It is known to be a\n+   PARALLEL and the first section will be tested. \n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n load_multiple_operation (op, mode)\n@@ -509,7 +552,10 @@ load_multiple_operation (op, mode)\n   return 1;\n }\n \n-/* Similar, but tests for store multiple.  */\n+/* Return true if OP is a store multiple operation.  It is known to be a\n+   PARALLEL and the first section will be tested. \n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n \n int\n store_multiple_operation (op, mode)\n@@ -551,13 +597,13 @@ store_multiple_operation (op, mode)\n }\n \n \n-/* Returns 1 if OP contains a symbol reference */\n+/* Return true if OP contains a symbol reference */\n \n int\n symbolic_reference_mentioned_p (op)\n      rtx op;\n {\n-  register char *fmt;\n+  register const char *fmt;\n   register int i;\n \n   if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n@@ -583,6 +629,10 @@ symbolic_reference_mentioned_p (op)\n }\n \n \n+/* Return true if OP is a legitimate general operand when \n+   generating PIC code.  It is given that flag_pic is on \n+   and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n int\n legitimate_pic_operand_p (op)\n      register rtx op;\n@@ -601,6 +651,9 @@ legitimate_pic_operand_p (op)\n   return 0;\n }\n \n+/* Returns true if the constant value OP is a legitimate general operand.\n+   It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n int\n legitimate_constant_p (op)\n      register rtx op;\n@@ -632,22 +685,16 @@ legitimate_constant_p (op)\n }\n \n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On S/390, legitimate addresses are:\n-\tbase\t\t\t\tl    reg,(base)\n-\tdisplacement\t\t\tl    reg,disp\n-\tbase + displacement\t\tl    reg,disp(base)\n-\tindex + base\t\t\tl    reg,(base,index),reg\n-\t(index + base) + displacement\tl    reg,disp(base,index)\n-\n-   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n-   convert common non-canonical forms to canonical form so that they will\n-   be recognized.  */\n+/* Decompose a RTL expression ADDR for a memory address into\n+   its components, returned in OUT.  The boolean STRICT \n+   specifies whether strict register checking applies.\n+   Returns 0 if ADDR is not a valid memory address, nonzero\n+   otherwise.  If OUT is NULL, don't return the components,\n+   but check for validity only.\n \n+   Note: Only addresses in canonical form are recognized.\n+   LEGITIMIZE_ADDRESS should convert non-canonical forms to the\n+   canonical form so that they will be recognized.  */\n \n static int\n s390_decompose_address (addr, out, strict)\n@@ -766,7 +813,7 @@ s390_decompose_address (addr, out, strict)\n           /* In some cases, we can accept an additional\n              small constant offset.  Split these off here.  */\n \n-          int offset = 0;\n+          unsigned int offset = 0;\n \n           if (GET_CODE (disp) == CONST\n               && GET_CODE (XEXP (disp, 0)) == PLUS\n@@ -821,9 +868,12 @@ s390_decompose_address (addr, out, strict)\n   return TRUE;\n }\n \n+/* Return nonzero if ADDR is a valid memory address.\n+   STRICT specifies whether strict register checking applies.  */\n+\n int\n legitimate_address_p (mode, addr, strict)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      register rtx addr;\n      int strict;\n {\n@@ -956,7 +1006,7 @@ legitimize_pic_address (orig, reg)\n \t  if (GET_CODE (addr) == UNSPEC)\n \t    {\n \t      if (XVECLEN (addr, 0) != 1)\n-                abort();\n+                abort ();\n               switch (XINT (addr, 1))\n                 {\n                   /* If someone moved an @GOT or lt-relative UNSPEC\n@@ -1002,7 +1052,7 @@ legitimize_pic_address (orig, reg)\n                 }\n \t    }\n \t  else if (GET_CODE (addr) != PLUS)\n-\t    abort();\n+\t    abort ();\n \t}\n       if (GET_CODE (addr) == PLUS)\n \t{\n@@ -1076,9 +1126,9 @@ legitimize_pic_address (orig, reg)\n \t           && GET_CODE (op1) == CONST_INT)\n             {\n \t      if (XVECLEN (op0, 0) != 1)\n-                abort();\n+                abort ();\n               if (XINT (op0, 1) != 100)\n-                abort();\n+                abort ();\n \n               new = force_const_mem (SImode, orig);\n             }\n@@ -1125,18 +1175,13 @@ emit_pic_move (operands, mode)\n     operands[1] = legitimize_pic_address (operands[1], temp);\n }\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n+/* Try machine-dependent ways of modifying an illegitimate address X\n    to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n \n    OLDX is the address as it was before break_out_memory_refs was called.\n    In some cases it is useful to look at this to decide what needs to be done.\n \n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n+   MODE is the mode of the operand pointed to by X.\n \n    When -fpic is used, special handling is needed for symbolic references.\n    See comments by legitimize_pic_address for details.  */\n@@ -1145,7 +1190,7 @@ rtx\n legitimize_address (x, oldx, mode)\n      register rtx x;\n      register rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (flag_pic && SYMBOLIC_CONST (x))\n     return legitimize_pic_address (x, 0);\n@@ -1154,10 +1199,13 @@ legitimize_address (x, oldx, mode)\n }\n \n \n-/* Output branch conditions.  */\n+/* Output branch condition code of CODE in assembler\n+   syntax to stdio stream FILE.  */\n \n static void\n-output_branch_condition (FILE *file, rtx code)\n+output_branch_condition (file, code)\n+     FILE *file;\n+     rtx code;\n {\n   switch (GET_CODE (code)) \n     {\n@@ -1188,8 +1236,13 @@ output_branch_condition (FILE *file, rtx code)\n     }\n }\n \n+/* Output the inverse of the branch condition code of CODE \n+   in assembler syntax to stdio stream FILE.  */\n+\n static void\n-output_inverse_branch_condition (FILE *file, rtx code)\n+output_inverse_branch_condition (file, code)\n+     FILE *file;\n+     rtx code;\n {\n   switch (GET_CODE (code)) \n     {\n@@ -1220,10 +1273,13 @@ output_inverse_branch_condition (FILE *file, rtx code)\n     }\n }\n \n-/* Output a symbolic constant.  */\n+/* Output symbolic constant X in assembler syntax to \n+   stdio stream FILE.  */\n \n void\n-s390_output_symbolic_const (FILE *file, rtx x)\n+s390_output_symbolic_const (file, x)\n+     FILE *file;\n+     rtx x;\n {\n   switch (GET_CODE (x))\n     {\n@@ -1303,10 +1359,13 @@ s390_output_symbolic_const (FILE *file, rtx x)\n     }\n }\n \n-/* Output an address operand.  */\n+/* Output address operand ADDR in assembler syntax to \n+   stdio stream FILE.  */\n \n void\n-print_operand_address (FILE *file, rtx addr)\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n {\n   struct s390_address ad;\n \n@@ -1325,10 +1384,28 @@ print_operand_address (FILE *file, rtx addr)\n     fprintf (file, \"(%s)\", reg_names[REGNO (ad.base)]);\n }\n \n-/* Output an operand.  */\n+/* Output operand X in assembler syntax to stdio stream FILE.  \n+   CODE specified the format flag.  The following format flags \n+   are recognized:\n+\n+    'C': print opcode suffix for branch condition.\n+    'D': print opcode suffix for inverse branch condition.\n+    'Y': print current constant pool address (pc-relative).\n+    'y': print current constant pool address (absolute).\n+    'O': print only the displacement of a memory reference.\n+    'R': print only the base register of a memory reference.\n+    'N': print the second word of a DImode operand.\n+    'M': print the second word of a TImode operand.\n+\n+    'b': print integer X as if it's a unsigned byte.\n+    'x': print integer X as if it's a unsigned word.\n+    'h': print integer X as if it's a signed word.  */\n \n void\n-print_operand (FILE *file, rtx x, char code)\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n {\n   switch (code)\n     {\n@@ -1355,7 +1432,7 @@ print_operand (FILE *file, rtx x, char code)\n         if (GET_CODE (x) != MEM\n             || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n             || ad.indx)\n-          abort();\n+          abort ();\n \n         if (ad.disp)\n           s390_output_symbolic_const (file, ad.disp);\n@@ -1371,7 +1448,7 @@ print_operand (FILE *file, rtx x, char code)\n         if (GET_CODE (x) != MEM\n             || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n             || ad.indx)\n-          abort();\n+          abort ();\n \n         if (ad.base)\n           fprintf (file, \"%s\", reg_names[REGNO (ad.base)]);\n@@ -1386,7 +1463,7 @@ print_operand (FILE *file, rtx x, char code)\n       else if (GET_CODE (x) == MEM)\n \tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 4));\n       else\n-        abort();\n+        abort ();\n       break;\n \n     case 'M':\n@@ -1395,7 +1472,7 @@ print_operand (FILE *file, rtx x, char code)\n       else if (GET_CODE (x) == MEM)\n \tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 8));\n       else\n-        abort();\n+        abort ();\n       break;\n     }\n \n@@ -1437,11 +1514,13 @@ print_operand (FILE *file, rtx x, char code)\n \n #define DEBUG_SCHED 0\n \n-/* True, if register regno is used  for forming a memory address in\n-   a expression x.  */\n+/* Returns true if register REGNO is used  for forming \n+   a memory address in expression X.  */\n \n static int\n-reg_used_in_mem_p (int regno, rtx x)\n+reg_used_in_mem_p (regno, x)\n+     int regno;\n+     rtx x;\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -1469,11 +1548,13 @@ reg_used_in_mem_p (int regno, rtx x)\n   return 0;\n }\n \n-/* Returns true, if expression dep_rtx sets a address register\n-   used by instruction insn to address memory.  */\n+/* Returns true if expression DEP_RTX sets a address register\n+   used by instruction INSN to address memory.  */\n \n static int \n-addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n+addr_generation_dependency_p (dep_rtx, insn)\n+     rtx dep_rtx; \n+     rtx insn;\n {\n   rtx target;\n \n@@ -1496,16 +1577,23 @@ addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n }\n \n \n-/* Data dependencies are all handled without delay. But if an register\n-   is changed for a memory access, at least 4 cycle need to be put\n-   between the set of the register and the use. Because of that,\n-   the delays specified in the .md file needs to check and adjust\n-   to the right cost.  */\n+/* Return the modified cost of the dependency of instruction INSN\n+   on instruction DEP_INSN through the link LINK.  COST is the \n+   default cost of that dependency.\n+\n+   Data dependencies are all handled without delay.  However, if a\n+   register is modified and subsequently used as base or index \n+   register of a memory reference, at least 4 cycles need to pass\n+   between setting and using the register to avoid pipeline stalls.  */\n \n int\n-s390_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost )\n+s390_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n {\n-  rtx dep_rtx, dest, x;\n+  rtx dep_rtx;\n   int i;\n \n   /* If the dependence is an anti-dependence, there is no cost.  For an\n@@ -1575,20 +1663,30 @@ s390_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost )\n      - in this case, a branch from one chunk to other chunk needs\n        a reload of base register at the code label branched to.  */\n \n-\n-\n-rtx s390_pool_start_insn = NULL_RTX;\n-\n-/* Count of actual pool in function (-1 -> before function).  */\n-\n+/* Index of constant pool chunk that is currently being processed.\n+   Set to -1 before function output has started.  */\n int s390_pool_count = -1;\n \n+/* First insn using the constant pool chunk that is currently being\n+   processed.  */\n+rtx s390_pool_start_insn = NULL_RTX;\n \n+/* UID of last insn using the constant pool chunk that is currently \n+   being processed.  */\n static int pool_stop_uid;\n \n+/* Called from the ASM_OUTPUT_POOL_PROLOGUE macro to \n+   prepare for printing a literal pool chunk to stdio stream FILE.  \n \n+   FNAME and FNDECL specify the name and type of the current function.\n+   SIZE is the size in bytes of the current literal pool.  */\n+ \n void \n-s390_asm_output_pool_prologue (FILE *file, char *fname, tree fndecl, int size)\n+s390_asm_output_pool_prologue (file, fname, fndecl, size)\n+     FILE *file;\n+     const char *fname ATTRIBUTE_UNUSED;\n+     tree fndecl;\n+     int size ATTRIBUTE_UNUSED;\n {\n \n   if (s390_pool_count>0) {\n@@ -1600,7 +1698,7 @@ s390_asm_output_pool_prologue (FILE *file, char *fname, tree fndecl, int size)\n \tfprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", \n \t\t reg_names[BASE_REGISTER],\n \t\t s390_function_count, s390_pool_count);\n-\treadonly_data_section();\n+\treadonly_data_section ();\n \tASM_OUTPUT_ALIGN (file, floor_log2 (3));\n \tfprintf (file, \".LT%X_%X:\\t# Pool %d\\n\",\n \t\t s390_function_count, s390_pool_count, s390_pool_count);\n@@ -1614,12 +1712,15 @@ s390_asm_output_pool_prologue (FILE *file, char *fname, tree fndecl, int size)\n     function_section (fndecl);\n }\n \n-/* Check if other addr is in different chunk than my addr,\n-   return symbol_ref to other pool in that case.  */\n-\n+/* Return true if OTHER_ADDR is in different chunk than MY_ADDR.\n+   LTORG points to a list of all literal pools inserted\n+   into the current function.  */\n \n static int\n-other_chunk (int *ltorg, int my_addr, int other_addr)\n+other_chunk (ltorg, my_addr, other_addr)\n+     int *ltorg;\n+     int my_addr;\n+     int other_addr;\n {\n   int ad, i=0, j=0;\n \n@@ -1639,10 +1740,13 @@ other_chunk (int *ltorg, int my_addr, int other_addr)\n   return 1;\n }\n \n-/* Check, if other label is to far away to branch relative.  */\n+/* Return true if OTHER_ADDR is too far away from MY_ADDR\n+   to use a relative branch instruction.  */\n \n static int \n-far_away (int my_addr, int other_addr)\n+far_away (my_addr, other_addr)\n+     int my_addr;\n+     int other_addr;\n {\n   /* In 64 bit mode we can jump +- 4GB.  */\n   if (TARGET_64BIT)\n@@ -1652,10 +1756,18 @@ far_away (int my_addr, int other_addr)\n   return 0;\n }\n \n-\n+/* Go through all insns in the current function (starting\n+   at INSN), replacing branch insn if necessary.  A branch\n+   needs to be modified if either the distance to the \n+   target is too far to use a relative branch, or if the\n+   target uses a different literal pool than the origin.\n+   LTORG_UIDS points to a list of all literal pool insns\n+   that have been inserted.  */\n \n static rtx \n-check_and_change_labels (rtx insn, int *ltorg_uids)\n+check_and_change_labels (insn, ltorg_uids)\n+     rtx insn;\n+     int *ltorg_uids;\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   rtx target, jump;\n@@ -1792,13 +1904,18 @@ check_and_change_labels (rtx insn, int *ltorg_uids)\n   return insn;\n }\n \n-static int chunk_max=0;\n+/* Called from s390_function_prologue to make final adjustments\n+   before outputting code.  CHUNKIFY specifies whether we need\n+   to use multiple literal pools (because the total size of the\n+   literals exceeds 4K).  */\n \n-void\n-s390_final_chunkify (int chunkify)\n+static void\n+s390_final_chunkify (chunkify)\n+     int chunkify;\n {\n   rtx insn, ninsn, tmp;\n-  int addr, naddr, uids;\n+  int addr, naddr = 0, uids;\n+  int chunk_max = 0;\n \n   const char *asms;\n \n@@ -1850,7 +1967,7 @@ s390_final_chunkify (int chunkify)\n \t\t  fprintf (stderr, \"s390 multiple literalpool support:\"\n \t\t\t   \"\\n No code label between this insn %X %X\",\n \t\t\t   naddr, INSN_ADDRESSES (INSN_UID (tmp)));\n-\t\t  abort();\n+\t\t  abort ();\n \t\t}\n \t    }\n \t  if (tmp == NULL) \n@@ -1905,12 +2022,11 @@ s390_final_chunkify (int chunkify)\n   pool_stop_uid = ltorg_uids[0];\n }\n \n-/* Return 1 if next literal pool is reached (check for ltorg insn)\n-   maybe should use unspec insn.  */\n-\n+/* Return true if INSN is a 'ltorg' insn.  */\n \n int \n-s390_stop_dump_lit_p (rtx insn)\n+s390_stop_dump_lit_p (insn)\n+    rtx insn;\n {\n   rtx body=PATTERN (insn);\n   if (GET_CODE (body) == PARALLEL\n@@ -1926,8 +2042,13 @@ s390_stop_dump_lit_p (rtx insn)\n     return 0;   \n }\n \n+/* Output literal pool chunk to be used for insns\n+   between insn ACT_INSN and the insn with UID STOP.  */\n+\n void\n-s390_dump_literal_pool (rtx act_insn, rtx stop)\n+s390_dump_literal_pool (act_insn, stop)\n+     rtx act_insn;\n+     rtx stop;\n {\n   s390_pool_start_insn = act_insn;\n   pool_stop_uid = INTVAL (stop);\n@@ -1942,16 +2063,20 @@ extern char *dwarf2out_cfi_label PARAMS ((void));\n #endif\n \n /* Flag set in prologue, used in epilog to know\n-  if stack is allocated or not.  */\n-\n+   if stack is allocated or not.  */\n static int leaf_function_flag;\n-rtx s390_got_label;\n+\n+/* Symbol references needed by the profile code;\n+   set up by the function prologue routine if necessary.  */\n rtx s390_profile[10];\n+\n+/* Number of elements of current constant pool.  */\n int s390_nr_constants;\n \n-/* Returns 1 if floating point registers need to be saved.  */\n+/* Return true if floating point registers need to be saved.  */\n \n-static int save_fprs_p()\n+static int \n+save_fprs_p ()\n {\n   int i;\n   if (!TARGET_64BIT)\n@@ -1964,8 +2089,8 @@ static int save_fprs_p()\n   return 0;\n }\n \n-/* Current function is a leaf function, without automatics,\n-   alloca or vararg stuff.  */\n+/* Return true if urrent function is a leaf function, \n+   without automatics, alloca or vararg stuff.  */\n \n static int\n cur_is_leaf_function ()\n@@ -1980,10 +2105,11 @@ cur_is_leaf_function ()\n   return 0;\n }\n \n-/* Calculate offset between argument pointer and frame pointer \n-   initialy after prologue.  */\n+/* Return offset between argument pointer and frame pointer \n+   initially after prologue.  */\n \n-int s390_arg_frame_offset ()\n+int \n+s390_arg_frame_offset ()\n {\n   int lsize =  get_frame_size () + current_function_outgoing_args_size\n     + save_fprs_p () * 64;\n@@ -1994,9 +2120,15 @@ int s390_arg_frame_offset ()\n     return 2*STACK_POINTER_OFFSET + lsize;\n }\n \n-/* Save Floating point register on current stack.  */\n+/* Output code to stdio stream FILE to save floating point \n+   registers on current stack, at offset OFFSET to the frame\n+   pointer register FP.  */\n \n-static int save_fprs(FILE *file, long offset, int fp)\n+static int \n+save_fprs (file, offset, fp)\n+     FILE *file;\n+     long offset;\n+     int fp;\n {\n   int i;\n \n@@ -2007,22 +2139,30 @@ static int save_fprs(FILE *file, long offset, int fp)\n     {\n       if (regs_ever_live[i] == 1)\n \t{\n-\t  fprintf (file, \"\\tstd\\t%s,%d(%s)\\n\", reg_names[i], \n+\t  fprintf (file, \"\\tstd\\t%s,%ld(%s)\\n\", reg_names[i], \n \t\t   (i-24) * 8 + offset, reg_names[fp]); \n \t}\n     }\n+\n+  return 1;\n }\n \n-/* Restore Floating point register on current stack.  */\n+/* Output code to stdio stream FILE to restore floating point \n+   registers from current stack, at offset OFFSET to the frame\n+   pointer register FP.  */\n \n-static int restore_fprs(FILE *file, long offset, int fp)\n+static int \n+restore_fprs (file, offset, fp)\n+     FILE *file;\n+     long offset;\n+     int fp;\n {\n   int i;\n \n   if (!TARGET_64BIT)\n     return 0;\n \n-  if (!save_fprs_p())\n+  if (!save_fprs_p ())\n     return 0;\n \n   if (offset < 0) \n@@ -2038,16 +2178,19 @@ static int restore_fprs(FILE *file, long offset, int fp)\n     {\n       if (regs_ever_live[i] == 1)\n \t{\n-\t  fprintf (file, \"\\tld\\t%s,%d(%s)\\n\", reg_names[i], \n+\t  fprintf (file, \"\\tld\\t%s,%ld(%s)\\n\", reg_names[i], \n \t\t   (i-24) * 8 + offset, reg_names[fp]); \n \t}\n     }\n+\n+  return 1;\n }\n \n-/* Output constant pool in function prologue (31 bit) or in readonly section.  */ \n+/* Output main constant pool to stdio stream FILE.  */ \n \n-static int\n-s390_output_constant_pool(FILE* file)\n+static void\n+s390_output_constant_pool (file)\n+     FILE *file;\n {\n   /* Output constant pool.  */\n   if (s390_nr_constants || regs_ever_live[BASE_REGISTER])\n@@ -2057,7 +2200,7 @@ s390_output_constant_pool(FILE* file)\n \t{\n \t  fprintf (file, \"\\tlarl\\t%s,.LT%X_%X\\n\", reg_names[BASE_REGISTER],\n \t\t   s390_function_count, s390_pool_count);\n-\t  readonly_data_section();\n+\t  readonly_data_section ();\n \t  ASM_OUTPUT_ALIGN (file, floor_log2 (3));\n \t}\n       else\n@@ -2070,17 +2213,20 @@ s390_output_constant_pool(FILE* file)\n       fprintf (file, \".LTN%X_%X:\\n\", s390_function_count,\n \t       s390_pool_count);\n       if (TARGET_64BIT)\n-\tfunction_section(current_function_decl);\n+\tfunction_section (current_function_decl);\n       \n       regs_ever_live[BASE_REGISTER] = 1;\n     }\n }\n \n-\n-/* This function generates the assembly code for function entry.  */\n+/* Add constant CTX to the constant pool at a late time \n+   (after the initial pass to count the number of constants\n+   was already done).  Returns the resulting constant \n+   pool reference.  */\n \n static rtx\n-s390_force_const_mem_late (rtx cst)\n+s390_force_const_mem_late (cst)\n+     rtx cst;\n {\n   cst = force_const_mem (Pmode, cst);\n \n@@ -2092,8 +2238,17 @@ s390_force_const_mem_late (rtx cst)\n   return cst;\n }\n \n+/* Add a reference to the symbol NAME to the constant pool.\n+   FUNC specifies whether NAME refers to a function, while\n+   GLOBAL specifies whether NAME is a global symbol.  Depending\n+   on these flags, the appopriate PLT or GOT references are\n+   generated.  Returns the constant pool reference.  */\n+\n static rtx\n-s390_force_const_mem_symbol (char *name, int func, int global)\n+s390_force_const_mem_symbol (name, func, global)\n+     const char *name;\n+     int func;\n+     int global;\n {\n   rtx symbol;\n \n@@ -2121,15 +2276,19 @@ s390_force_const_mem_symbol (char *name, int func, int global)\n   return s390_force_const_mem_late (symbol);\n }\n \n-/* This function generates the assembly code for function entry.  */\n+/* Output the function prologue assembly code to the \n+   stdio stream FILE.  The local frame size is passed\n+   in LSIZE.  */\n \n void\n-s390_function_prologue (FILE *file, HOST_WIDE_INT lsize)\n+s390_function_prologue (file, lsize)\n+     FILE *file;\n+     HOST_WIDE_INT lsize;\n {\n   extern int profile_label_no;\n   int i, j;\n   long frame_size;\n-  rtx stack_label = 0, got_label = 0, tmp;\n+  rtx stack_label = 0, got_label = 0;\n   char *l;\n   char b64[2] = \" \";\n   b64[0] = TARGET_64BIT ? 'g' : '\\0';\n@@ -2335,14 +2494,13 @@ s390_function_prologue (FILE *file, HOST_WIDE_INT lsize)\n \t}\n \n       \n-      if (save_fprs_p() && frame_size > 4095) \n+      if (save_fprs_p () && frame_size > 4095) \n \t{\n \t  int fp = 1;\n-\t  int offset = 0;\n \t  fprintf (file, \"\\tlgr\\t%s,%s\\n\", reg_names[fp], \n \t\t   reg_names[STACK_POINTER_REGNUM]); \n \t  fprintf (file, \"\\taghi\\t%s,-64\\n\", reg_names[fp]);\n-\t  save_fprs(file, 0, fp);\n+\t  save_fprs (file, 0, fp);\n \t}\n \n       /* Decrement stack.  */\n@@ -2370,7 +2528,7 @@ s390_function_prologue (FILE *file, HOST_WIDE_INT lsize)\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\ta%shi\\t%s,-%d\\n\",b64, \n+\t  fprintf (file, \"\\ta%shi\\t%s,-%ld\\n\",b64, \n \t\t   reg_names[STACK_POINTER_REGNUM], frame_size);\n \t}\n #ifdef INCOMING_RETURN_ADDR_RTX\n@@ -2432,10 +2590,14 @@ s390_function_prologue (FILE *file, HOST_WIDE_INT lsize)\n   return;\n }\n \n-/* This function generates the assembly code for function exit.  */\n+/* Output the function epilogue assembly code to the \n+   stdio stream FILE.  The local frame size is passed\n+   in LSIZE.  */\n \n void\n-s390_function_epilogue (FILE *file, HOST_WIDE_INT lsize)\n+s390_function_epilogue (file, lsize)\n+     FILE *file;\n+     HOST_WIDE_INT lsize;\n {\n /* Register is call clobbered and not used for eh or return.  */\n #define FREE_REG 4\n@@ -2532,21 +2694,15 @@ s390_function_epilogue (FILE *file, HOST_WIDE_INT lsize)\n   return;\n }\n \n-/* For structs of odd size the address is passed as reference. \n-   Complex number are also passes on the stack. \n-\n-   Note: We don't use mode, since a struct with the following format \n-   is BLKmode, but has size 4.\n-   struct \n-     {\n-       char a;\n-       char b[3]\n-     }. \n-   The ABI states, that this value has to be passed in register.  */\n \n+/* Return the size in bytes of a function argument of \n+   type TYPE and/or mode MODE.  At least one of TYPE or\n+   MODE must be specified.  */\n \n static int\n-s390_function_arg_size (enum machine_mode mode, tree type)\n+s390_function_arg_size (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n {\n   if (type)\n     return int_size_in_bytes (type);\n@@ -2556,11 +2712,19 @@ s390_function_arg_size (enum machine_mode mode, tree type)\n     return GET_MODE_SIZE (mode);\n \n   /* If we have neither type nor mode, abort */\n-  fatal_error (\"no type info available for BLKmode\\n\");\n+  abort ();\n }\n \n+/* Return 1 if a function argument of type TYPE and mode MODE\n+   is to be passed by reference.  The ABI specifies that only\n+   structures of size 1, 2, 4, or 8 bytes are passed by value,\n+   all other structures (and complex numbers) are passed by\n+   reference.  */\n+\n int\n-s390_function_arg_pass_by_reference (enum machine_mode mode, tree type)\n+s390_function_arg_pass_by_reference (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n {\n   int size = s390_function_arg_size (mode, type);\n \n@@ -2579,11 +2743,16 @@ s390_function_arg_pass_by_reference (enum machine_mode mode, tree type)\n \n /* Update the data in CUM to advance over an argument of mode MODE and\n    data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.).  */\n+   may not be available.).  The boolean NAMED specifies whether the\n+   argument is a named argument (as opposed to an unnamed argument\n+   matching an ellipsis).  */\n \n void\n-s390_function_arg_advance (CUMULATIVE_ARGS * cum,\n-\t\t      enum machine_mode mode, tree type, int named)\n+s390_function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named ATTRIBUTE_UNUSED;\n {\n   if (! TARGET_SOFT_FLOAT && (mode == DFmode || mode == SFmode))\n     {\n@@ -2600,17 +2769,31 @@ s390_function_arg_advance (CUMULATIVE_ARGS * cum,\n     }\n }\n \n-\n-\n-/* Define where to put the arguments to a function.  Value is zero to push\n-   the argument on the stack, or a hard register in which to store the\n-   argument. Gprs 2-6 and Fprs 0 and 2 are used as arguments.\n-   All integral values go into register, until all are used up, the rest\n-   goes onto stack. The same is valid for floating-point values.  */\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  \n+\n+   On S/390, we use general purpose registers 2 through 6 to\n+   pass integer, pointer, and certain structure arguments, and\n+   floating point registers 0 and 2 (0, 2, 4, and 6 on 64-bit)\n+   to pass floating point arguments.  All remaining arguments\n+   are pushed to the stack.  */\n \n rtx\n-s390_function_arg (CUMULATIVE_ARGS * cum,\n-\t      enum machine_mode mode, tree type, int named)\n+s390_function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named ATTRIBUTE_UNUSED;\n {\n   if (s390_function_arg_pass_by_reference (mode, type))\n       return 0;\n@@ -2635,14 +2818,27 @@ s390_function_arg (CUMULATIVE_ARGS * cum,\n }\n \n \n-/* Builtin va_list stuff\n-   va_list is a structure of four elements:\n-      __gpr:  number of named args passed in general purpose register \n-      __gpr:  number of named args passed in floating purpose register \n-      __overflow_arg_area:  address of area, where arguments are passed\n-                          if they do not fit in gprs 2 to 6 and fpr 0 and 2\n-      __reg_save_area:  address, where register passed args are saved \n-                      in prologue.  */\n+/* Create and return the va_list datatype.\n+\n+   On S/390, va_list is an array type equivalent to\n+\n+      typedef struct __va_list_tag\n+        {\n+            long __gpr;\n+            long __fpr;\n+            void *__overflow_arg_area;\n+            void *__reg_save_area;\n+            \n+        } va_list[1];\n+\n+   where __gpr and __fpr hold the number of general purpose\n+   or floating point arguments used up to now, respectively,\n+   __overflow_arg_area points to the stack location of the \n+   next argument passed on the stack, and __reg_save_area\n+   always points to the start of the register area in the\n+   call frame of the current function.  The function prologue\n+   saves all registers used for argument passing into this\n+   area if the function uses variable arguments.  */\n \n tree\n s390_build_va_list ()\n@@ -2681,17 +2877,25 @@ s390_build_va_list ()\n   return build_array_type (record, build_index_type (size_zero_node));\n }\n \n-/* Builtin va_start \n-   The va_list struct is set with the values.\n-   gpr: compile time known got out of  current_function_args_info\n-   fpr: compile time known got out of  current_function_args_info\n-   overflow_arg_area: address passed with register 7 (incoming args register)\n-                  (setup in prologue)\n-   reg_save_area: address of save area where first 5 gprs and 2 fprs sare \n-                  saved (saved in prologue).  */\n+/* Implement va_start by filling the va_list structure VALIST.\n+   STDARG_P is true if implementing __builtin_stdarg_va_start,\n+   false if implementing __builtin_varargs_va_start.  NEXTARG\n+   points to the first anonymous stack argument.\n+\n+   The following global variables are used to initalize\n+   the va_list structure:\n+\n+     current_function_args_info:\n+       holds number of gprs and fprs used for named arguments.\n+     current_function_arg_offset_rtx:\n+       holds the offset of the first anonymous stack argument\n+       (relative to the virtual arg pointer).  */\n \n void\n-s390_va_start (int stdarg_p, tree valist, rtx nextarg)\n+s390_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n {\n   HOST_WIDE_INT n_gpr, n_fpr;\n   int off;\n@@ -2748,10 +2952,11 @@ s390_va_start (int stdarg_p, tree valist, rtx nextarg)\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n-\n-/* Builtin va_arg.  \n+/* Implement va_arg by updating the va_list structure \n+   VALIST as required to retrieve an argument of type\n+   TYPE, and returning that argument. \n    \n-   Works like following:\n+   Generates code equivalent to:\n    \n    if (integral value) {\n      if (size  <= 4 && args.gpr < 5 ||\n@@ -2771,9 +2976,10 @@ s390_va_start (int stdarg_p, tree valist, rtx nextarg)\n        ret = **args.overflow_arg_area++;\n    } */\n \n-\n rtx\n-s390_va_arg (tree valist, tree type)\n+s390_va_arg (valist, type)\n+     tree valist;\n+     tree type;\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, reg, t, u;\n@@ -2932,13 +3138,16 @@ s390_va_arg (tree valist, tree type)\n   return addr_rtx;\n }\n \n-/* Implementation of Trampoline\n-   Gpr 1 is used as base register and for the jump\n-   to the nested function. \n-   Gpr 0 is static chain.  */\n+\n+/* Output assembly code for the trampoline template to\n+   stdio stream FILE.\n+\n+   On S/390, we use gpr 1 internally in the trampoline code;\n+   gpr 0 is used to hold the static chain.  */\n \n void\n-s390_trampoline_template (FILE * file)\n+s390_trampoline_template (file)\n+     FILE *file;\n {\n   if (TARGET_64BIT)\n     {\n@@ -2960,6 +3169,10 @@ s390_trampoline_template (FILE * file)\n     }\n }\n \n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n void\n s390_initialize_trampoline (addr, fnaddr, cxt)\n      rtx addr;\n@@ -2969,9 +3182,9 @@ s390_initialize_trampoline (addr, fnaddr, cxt)\n   emit_move_insn (gen_rtx \n \t\t  (MEM, Pmode,\n \t\t   memory_address (Pmode, \n-\t\t   plus_constant (addr,(TARGET_64BIT ? 20 : 12) ))), cxt);\n+\t\t   plus_constant (addr, (TARGET_64BIT ? 20 : 12) ))), cxt);\n   emit_move_insn (gen_rtx\n \t\t  (MEM, Pmode,\n \t\t   memory_address (Pmode, \n-\t\t   plus_constant (addr,(TARGET_64BIT ? 28 : 16) ))), fnaddr);\n+\t\t   plus_constant (addr, (TARGET_64BIT ? 28 : 16) ))), fnaddr);\n }"}, {"sha": "066811a8c4ef23970b9bb059e266cbdfa0561e19", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -48,22 +48,22 @@ extern int target_flags;\n    An empty string NAME is used to identify the default VALUE.  */\n \n #define TARGET_SWITCHES           \t\t       \t\t       \\\n-{ { \"hard-float\",    1,N_(\"Use hardware fp\")},         \t\t       \\\n-  { \"soft-float\",   -1,N_(\"Don't use hardware fp\")},\t      \t       \\\n-  { \"backchain\",     2,N_(\"Set backchain\")},           \t\t       \\\n-  { \"no-backchain\", -2,N_(\"Don't set backchain (faster, but debug harder\")}, \\\n-  { \"small-exec\",    4,N_(\"Use bras for execucable < 64k\")},           \\\n-  { \"no-small-exec\",-4,N_(\"Don't use bras\")},            \t       \\\n-  { \"debug\",         8,N_(\"Additional debug prints\")},        \t       \\\n-  { \"no-debug\",     -8,N_(\"Don't print additional debug prints\")},     \\\n-  { \"64\",           16,N_(\"64 bit mode\")},         \t               \\\n-  { \"31\",          -16,N_(\"31 bit mode\")},                             \\\n-  { \"mvcle\",        32,N_(\"mvcle use\")},         \t               \\\n-  { \"no-mvcle\",    -32,N_(\"mvc&ex\")},                                  \\\n+{ { \"hard-float\",    1, N_(\"Use hardware fp\")},         \t\t       \\\n+  { \"soft-float\",   -1, N_(\"Don't use hardware fp\")},\t      \t       \\\n+  { \"backchain\",     2, N_(\"Set backchain\")},           \t\t       \\\n+  { \"no-backchain\", -2, N_(\"Don't set backchain (faster, but debug harder\")}, \\\n+  { \"small-exec\",    4, N_(\"Use bras for execucable < 64k\")},           \\\n+  { \"no-small-exec\",-4, N_(\"Don't use bras\")},            \t       \\\n+  { \"debug\",         8, N_(\"Additional debug prints\")},        \t       \\\n+  { \"no-debug\",     -8, N_(\"Don't print additional debug prints\")},     \\\n+  { \"64\",           16, N_(\"64 bit mode\")},         \t               \\\n+  { \"31\",          -16, N_(\"31 bit mode\")},                             \\\n+  { \"mvcle\",        32, N_(\"mvcle use\")},         \t               \\\n+  { \"no-mvcle\",    -32, N_(\"mvc&ex\")},                                  \\\n   { \"\", TARGET_DEFAULT, 0 } }\n \n /* Define this to change the optimizations performed by default.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) optimization_options(LEVEL,SIZE)\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) optimization_options(LEVEL, SIZE)\n \n /* The current function count for create unique internal labels.  */\n \n@@ -213,7 +213,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n \n /* Standard register usage.  */\n  \n-#define INT_REGNO_P(N)   ( (N) >= 0 && (N) < 16 )\n+#define INT_REGNO_P(N)   ( (int)(N) >= 0 && (N) < 16 )\n #ifdef IEEE_FLOAT\n #define FLOAT_REGNO_P(N) ( (N) >= 16 && (N) < 32 )\n #else\n@@ -682,14 +682,14 @@ CUMULATIVE_ARGS;\n    may not be available.) */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)                    \\\n-  s390_function_arg_advance(&CUM, MODE, TYPE, NAMED)\n+  s390_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n /* Define where to put the arguments to a function.  Value is zero to push\n    the argument on the stack, or a hard register in which to store the\n    argument.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)   \\\n-  s390_function_arg(&CUM, MODE, TYPE, NAMED)\n+  s390_function_arg (&CUM, MODE, TYPE, NAMED)\n \n /* Define where to expect the arguments of a function.  Value is zero, if\n    the argument is on the stack, or a hard register in which the argument\n@@ -808,7 +808,7 @@ CUMULATIVE_ARGS;\n #define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n do {                                     \t\t\t\\\n   extern rtx s390_profile[];  \t\t\t\t\t\\\n-  extern s390_pool_count;     \t\t\t\t\t\\\n+  extern int s390_pool_count;     \t\t\t\t\\\n   rtx tmp;                                    \t\t\t\\\n   static char label[128];                     \t\t\t\\\n   fprintf (FILE, \"# function profiler \\n\");   \t\t\t\\\n@@ -1101,7 +1101,7 @@ do\t\t\t\t\t\t\t\t\t           \\\n       {\t\t\t\t\t\t                                   \\\n     \trtx tmp[1];\t                                                           \\\n \tfprintf (FILE, \"# block profiler %d block %d \\n\",                          \\\n-\t\t\t profile_block_flag,BLOCKNO); \t                           \\\n+\t\t\t profile_block_flag, BLOCKNO); \t                           \\\n \toutput_asm_insn (\"ipm   14\", tmp);              \t\t           \\\n \toutput_asm_insn (\"aghi  15,-224\", tmp);                           \t   \\\n \toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);             \t\t   \\\n@@ -1325,7 +1325,7 @@ do {                                                                       \\\n   ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n \n #define REGNO_OK_FOR_FP_P(REGNO)                                        \\\n-  FLOAT_REGNO_P(REGNO)\n+  FLOAT_REGNO_P (REGNO)\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.  */\n@@ -1531,7 +1531,7 @@ do {                                                                       \\\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n \n-#define Pmode (TARGET_64BIT ? DImode : SImode)\n+#define Pmode ((enum machine_mode) (TARGET_64BIT ? DImode : SImode))\n \n /* A function address in a call instruction is a byte address (for\n    indexing purposes) so give the MEM rtx a byte's mode.  */\n@@ -1689,7 +1689,7 @@ do {                                                                       \\\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison. */\n  \n-#define SELECT_CC_MODE(OP,X,Y)              \\\n+#define SELECT_CC_MODE(OP, X, Y)            \\\n  (   (OP) == EQ  || (OP) == NE  ? CCZmode   \\\n    : (OP) == LE  || (OP) == LT  ||          \\\n      (OP) == GE  || (OP) == GT  ? CCSmode   \\\n@@ -1703,8 +1703,6 @@ do {                                                                       \\\n    since it hasn't been defined!  */\n  \n extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n- \n-extern int s390_match_ccmode PARAMS ((struct rtx_def *, int));\n \n \n /* How to refer to registers in assembler output.  This sequence is\n@@ -1809,7 +1807,7 @@ extern int s390_nr_constants;\n     /* Mark entries referenced by other entries */\t\t\t\\\n     for (pool = first_pool; pool; pool = pool->next)\t\t       \t\\\n       if (pool->mark)\t\t\t\t\t\t\t\\\n-        mark_constants(pool->constant);\t\t\t\t\t\\\n+        mark_constants (pool->constant);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t       \t\\\n     s390_asm_output_pool_prologue (FILE, FUNNAME, fndecl, size);     \t\\\n }"}, {"sha": "f17bf5c41784372296231122610159ec6a6dea08", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -796,6 +796,9 @@\n \n       case 4: /* m <- m */\n         return \\\"mvc\\\\t%O0(16,%R0),%1\\\";\n+\n+      default:\n+        abort();\n     }\n }\"\n   [(set_attr \"op_type\" \"NN,NN,RS,RS,SS\")\n@@ -873,6 +876,9 @@\n \n       case 4: /* m <- m */\n         return \\\"mvc\\\\t%O0(8,%R0),%1\\\";\n+\n+      default:\n+        abort();\n      }\n }\"\n   [(set_attr \"op_type\" \"NN,NN,RS,RS,SS\")\n@@ -1085,6 +1091,9 @@\n \n       case 6: /* m <- m */\n         return \\\"mvc\\\\t%O0(8,%R0),%1\\\";\n+\n+      default:\n+        abort();\n      }\n }\"\n   [(set_attr \"op_type\" \"RR,RX,RX,RS,RS,NN,SS\")\n@@ -1132,6 +1141,9 @@\n \n       case 3: /* m <- m */\n         return \\\"mvc\\\\t%O0(8,%R0),%1\\\";\n+\n+      default:\n+        abort();\n     }\n }\"\n   [(set_attr \"op_type\" \"NN,RS,RS,SS\")\n@@ -2442,7 +2454,7 @@\n \n   operands[1] = force_reg (DFmode,operands[1]);\n   emit_insn (gen_cmpdf (operands[1], force_const_mem (DFmode,\n-\tCONST_DOUBLE_FROM_REAL_VALUE (0x80000000, DFmode))));\n+\tCONST_DOUBLE_FROM_REAL_VALUE (0x80000000ULL, DFmode))));\n   emit_jump_insn (gen_blt (label1));\n   emit_insn (gen_subdf3 (temp, operands[1], force_const_mem (DFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x100000000ULL, DFmode))));\n@@ -2583,7 +2595,7 @@\n \n   operands[1] = force_reg (SFmode, operands[1]);\n   emit_insn (gen_cmpsf (operands[1], force_const_mem (SFmode,\n-\tCONST_DOUBLE_FROM_REAL_VALUE (0x80000000, SFmode))));\n+\tCONST_DOUBLE_FROM_REAL_VALUE (0x80000000ULL, SFmode))));\n   emit_jump_insn (gen_blt (label1));\n   emit_insn (gen_subsf3 (temp, operands[1], force_const_mem (SFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x100000000ULL, SFmode))));\n@@ -2669,7 +2681,7 @@\n       rtx temp  = assign_stack_local (BLKmode, 2 * UNITS_PER_WORD, BITS_PER_WORD);\n       rtx two31 = force_const_mem (DFmode,\n                                    gen_rtx (CONST_DOUBLE, VOIDmode, cc0_rtx,\n-                                            0x80000000, 0x4E000000));\n+                                            0x80000000U, 0x4E000000U));\n \n       emit_insn (gen_floatsidf2_ibm (operands[0], operands[1], two31, temp));\n       DONE;"}, {"sha": "91585b77b3f99992f96b2393fa1e6662a7cc20a7", "filename": "gcc/config/s390/t-linux", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994fe6604bda9582b9ccc58f105f553dfb4b792a/gcc%2Fconfig%2Fs390%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-linux?ref=994fe6604bda9582b9ccc58f105f553dfb4b792a", "patch": "@@ -1,11 +1,6 @@\n # The crtbegin and crtend must not depend on a small GOT\n CRTSTUFF_T_CFLAGS = -O2 -fPIC\n \n-linux.o: $(srcdir)/config/s390/linux.c $(CONFIG_H) \n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/s390/linux.c\n-\n # Compile libgcc2.a with pic.\n TARGET_LIBGCC2_CFLAGS = -fPIC -include $(srcdir)/config/s390/fixdfdi.h\n \n-\n-"}]}