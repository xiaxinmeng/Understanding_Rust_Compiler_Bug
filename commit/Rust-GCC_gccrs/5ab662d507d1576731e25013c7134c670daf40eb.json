{"sha": "5ab662d507d1576731e25013c7134c670daf40eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiNjYyZDUwN2QxNTc2NzMxZTI1MDEzYzcxMzRjNjcwZGFmNDBlYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-11-25T14:03:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-25T14:03:44Z"}, "message": "nvptx.c (walk_args_for_params): Delete.\n\n\t* config/nvptx/nvptx.c (walk_args_for_params): Delete.\n\t(nvptx_declare_function_name): Move assignments next to register\n\tdeclarations, and process params here.\n\nFrom-SVN: r230869", "tree": {"sha": "af038684aa28b37791c4e74c03738c2519d26cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af038684aa28b37791c4e74c03738c2519d26cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ab662d507d1576731e25013c7134c670daf40eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab662d507d1576731e25013c7134c670daf40eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab662d507d1576731e25013c7134c670daf40eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab662d507d1576731e25013c7134c670daf40eb/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75837d7b135b23fa6d8a5cb349501914be8e34bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75837d7b135b23fa6d8a5cb349501914be8e34bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75837d7b135b23fa6d8a5cb349501914be8e34bc"}], "stats": {"total": 157, "additions": 75, "deletions": 82}, "files": [{"sha": "b0c09fb481164363c8e330e45dc88ed3cd2fe55f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab662d507d1576731e25013c7134c670daf40eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab662d507d1576731e25013c7134c670daf40eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ab662d507d1576731e25013c7134c670daf40eb", "patch": "@@ -1,3 +1,9 @@\n+2015-11-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (walk_args_for_params): Delete.\n+\t(nvptx_declare_function_name): Move assignments next to register\n+\tdeclarations, and process params here.\n+\n 2015-11-25  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_declare_alias): Rename and globalize"}, {"sha": "bc67332569ee3ed2103839f36b7c1e177e56777d", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 69, "deletions": 82, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab662d507d1576731e25013c7134c670daf40eb/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab662d507d1576731e25013c7134c670daf40eb/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=5ab662d507d1576731e25013c7134c670daf40eb", "patch": "@@ -436,59 +436,6 @@ nvptx_write_function_decl (std::stringstream &s, const char *name, const_tree de\n     }\n }\n \n-/* Walk either ARGTYPES or ARGS if the former is null, and write out part of\n-   the function header to FILE.  If WRITE_COPY is false, write reg\n-   declarations, otherwise write the copy from the incoming argument to that\n-   reg.  RETURN_IN_MEM indicates whether to start counting arg numbers at 1\n-   instead of 0.  */\n-\n-static void\n-walk_args_for_param (FILE *file, tree argtypes, tree args, bool write_copy,\n-\t\t     bool return_in_mem)\n-{\n-  int i;\n-\n-  bool args_from_decl = false;\n-  if (argtypes == 0)\n-    args_from_decl = true;\n-  else\n-    args = argtypes;\n-\n-  for (i = return_in_mem ? 1 : 0; args != NULL_TREE; args = TREE_CHAIN (args))\n-    {\n-      tree type = args_from_decl ? TREE_TYPE (args) : TREE_VALUE (args);\n-      machine_mode mode = TYPE_MODE (type);\n-      int count = 1;\n-\n-      if (mode == VOIDmode)\n-\tbreak;\n-\n-      if (!PASS_IN_REG_P (mode, type))\n-\tmode = Pmode;\n-\n-      machine_mode split = maybe_split_mode (mode);\n-      if (split != VOIDmode)\n-\t{\n-\t  count = 2;\n-\t  mode = split;\n-\t}\n-      else if (argtypes == NULL && !AGGREGATE_TYPE_P (type) && mode == SFmode)\n-\tmode = DFmode;\n-\n-      mode = arg_promotion (mode);\n-      while (count--)\n-\t{\n-\t  i++;\n-\t  if (write_copy)\n-\t    fprintf (file, \"\\tld.param%s %%ar%d, [%%in_ar%d];\\n\",\n-\t\t     nvptx_ptx_type_from_mode (mode, false), i, i);\n-\t  else\n-\t    fprintf (file, \"\\t.reg%s %%ar%d;\\n\",\n-\t\t     nvptx_ptx_type_from_mode (mode, false), i);\n-\t}\n-    }\n-}\n-\n /* Write a .func or .kernel declaration (not a definition) along with\n    a helper comment for use by ld.  S is the stream to write to, DECL\n    the decl for the function with name NAME.  */\n@@ -589,6 +536,7 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n {\n   tree fntype = TREE_TYPE (decl);\n   tree result_type = TREE_TYPE (fntype);\n+  int argno  = 0;\n \n   name = nvptx_name_replacement (name);\n \n@@ -613,12 +561,54 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \n   fprintf (file, \"\\n{\\n\");\n \n-  /* Ensure all arguments that should live in a register have one\n-     declared.  We'll emit the copies below.  */\n-  walk_args_for_param (file, TYPE_ARG_TYPES (fntype), DECL_ARGUMENTS (decl),\n-\t\t       false, return_in_mem);\n   if (return_in_mem)\n-    fprintf (file, \"\\t.reg.u%d %%ar1;\\n\", GET_MODE_BITSIZE (Pmode));\n+    {\n+      ++argno;\n+      fprintf (file, \"\\t.reg.u%d %%ar%d;\\n\", GET_MODE_BITSIZE (Pmode), argno);\n+      fprintf (file, \"\\tld.param.u%d %%ar%d, [%%in_ar%d];\\n\",\n+\t       GET_MODE_BITSIZE (Pmode), argno, argno);\n+    }\n+\n+  /* Declare and initialize incoming arguments.  */\n+  tree args = DECL_ARGUMENTS (decl);\n+  bool prototyped = false;\n+  if (TYPE_ARG_TYPES (fntype))\n+    {\n+      args = TYPE_ARG_TYPES (fntype);\n+      prototyped = true;\n+    }\n+\n+  for (; args != NULL_TREE; args = TREE_CHAIN (args))\n+    {\n+      tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n+      machine_mode mode = TYPE_MODE (type);\n+      int count = 1;\n+\n+      if (mode == VOIDmode)\n+\tbreak;\n+\n+      if (!PASS_IN_REG_P (mode, type))\n+\tmode = Pmode;\n+\n+      machine_mode split = maybe_split_mode (mode);\n+      if (split != VOIDmode)\n+\t{\n+\t  count = 2;\n+\t  mode = split;\n+\t}\n+      else if (!prototyped && !AGGREGATE_TYPE_P (type) && mode == SFmode)\n+\tmode = DFmode;\n+\n+      mode = arg_promotion (mode);\n+      while (count--)\n+\t{\n+\t  ++argno;\n+\t  fprintf (file, \"\\t.reg%s %%ar%d;\\n\",\n+\t\t   nvptx_ptx_type_from_mode (mode, false), argno);\n+\t  fprintf (file, \"\\tld.param%s %%ar%d, [%%in_ar%d];\\n\",\n+\t\t   nvptx_ptx_type_from_mode (mode, false), argno, argno);\n+\t}\n+    }\n \n   /* C++11 ABI causes us to return a reference to the passed in\n      pointer for return_in_mem.  */\n@@ -631,7 +621,11 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n     }\n \n   if (stdarg_p (fntype))\n-    fprintf (file, \"\\t.reg.u%d %%argp;\\n\", GET_MODE_BITSIZE (Pmode));\n+    {\n+      fprintf (file, \"\\t.reg.u%d %%argp;\\n\", GET_MODE_BITSIZE (Pmode));\n+      fprintf (file, \"\\tld.param.u%d %%argp, [%%in_argp];\\n\",\n+\t       GET_MODE_BITSIZE (Pmode));\n+    }\n \n   fprintf (file, \"\\t.reg.u%d %s;\\n\", GET_MODE_BITSIZE (Pmode),\n \t   reg_names[OUTGOING_STATIC_CHAIN_REGNUM]);\n@@ -665,13 +659,23 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   if (sz == 0)\n     sz = 1;\n   if (cfun->machine->has_call_with_varargs)\n-    fprintf (file, \"\\t.reg.u%d %%outargs;\\n\"\n-\t     \"\\t.local.align 8 .b8 %%outargs_ar[\" HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n-\t     BITS_PER_WORD, sz);\n+    {\n+      fprintf (file, \"\\t.reg.u%d %%outargs;\\n\"\n+\t       \"\\t.local.align 8 .b8 %%outargs_ar[\"\n+\t       HOST_WIDE_INT_PRINT_DEC\"];\\n\",\n+\t       BITS_PER_WORD, sz);\n+      fprintf (file, \"\\tcvta.local.u%d %%outargs, %%outargs_ar;\\n\",\n+\t       BITS_PER_WORD);\n+    }\n+\n   if (cfun->machine->punning_buffer_size > 0)\n-    fprintf (file, \"\\t.reg.u%d %%punbuffer;\\n\"\n-\t     \"\\t.local.align 8 .b8 %%punbuffer_ar[%d];\\n\",\n-\t     BITS_PER_WORD, cfun->machine->punning_buffer_size);\n+    {\n+      fprintf (file, \"\\t.reg.u%d %%punbuffer;\\n\"\n+\t       \"\\t.local.align 8 .b8 %%punbuffer_ar[%d];\\n\",\n+\t       BITS_PER_WORD, cfun->machine->punning_buffer_size);\n+      fprintf (file, \"\\tcvta.local.u%d %%punbuffer, %%punbuffer_ar;\\n\",\n+\t       BITS_PER_WORD);\n+    }\n \n   /* Declare a local variable for the frame.  */\n   sz = get_frame_size ();\n@@ -686,23 +690,6 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \t       BITS_PER_WORD);\n     }\n \n-  if (cfun->machine->has_call_with_varargs)\n-      fprintf (file, \"\\tcvta.local.u%d %%outargs, %%outargs_ar;\\n\",\n-\t       BITS_PER_WORD);\n-  if (cfun->machine->punning_buffer_size > 0)\n-      fprintf (file, \"\\tcvta.local.u%d %%punbuffer, %%punbuffer_ar;\\n\",\n-\t       BITS_PER_WORD);\n-\n-  /* Now emit any copies necessary for arguments.  */\n-  walk_args_for_param (file, TYPE_ARG_TYPES (fntype), DECL_ARGUMENTS (decl),\n-\t\t       true, return_in_mem);\n-  if (return_in_mem)\n-    fprintf (file, \"\\tld.param.u%d %%ar1, [%%in_ar1];\\n\",\n-\t     GET_MODE_BITSIZE (Pmode));\n-  if (stdarg_p (fntype))\n-    fprintf (file, \"\\tld.param.u%d %%argp, [%%in_argp];\\n\",\n-\t     GET_MODE_BITSIZE (Pmode));\n-\n   /* Emit axis predicates. */\n   if (cfun->machine->axis_predicate[0])\n     nvptx_init_axis_predicate (file,"}]}