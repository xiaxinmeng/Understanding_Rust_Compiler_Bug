{"sha": "5a66a7661d4f7686ea0e4dea661926f7fee21653", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE2NmE3NjYxZDRmNzY4NmVhMGU0ZGVhNjYxOTI2ZjdmZWUyMTY1Mw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-06-24T09:27:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-24T09:27:21Z"}, "message": "gnatcmd.adb, [...] (Units_Table): Removed, since no longer useful.\n\n2009-06-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, clean.adb,\n\tprj-nmsc.adb, prj-env.adb, prj-proc.adb (Units_Table): Removed, since\n\tno longer useful.\n\t(Source_Data.Lang_Kind): Removed, since it duplicates information\n\talready available through Language.Config.\n\t(Source_Data.Compile): Removed, since information is already available\n\tthrough the language.\n\t(Is_Compilable): New subprogram.\n\t(Source_Data.Dependency): Removed, since already available through\n\tthe language.\n\t(Source_Data.Object_Exist, Object_Linked): Removed since available\n\tthrough the language already.\n\t(Unit_Data.File_Names): Is now also set in multi_language mode, to\n\tbring the two modes closer in the resulting data structures.\n\t(Source_Data.Unit): Now a direct pointer to the unit data, rather than\n\tjust the name that would point into a hash table.\n\t(Get_Language_From_Name): New subprogram.\n\nFrom-SVN: r148901", "tree": {"sha": "7ef9d1e9dfb650841e5c6382e473c3bd67fdfa35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ef9d1e9dfb650841e5c6382e473c3bd67fdfa35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a66a7661d4f7686ea0e4dea661926f7fee21653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a66a7661d4f7686ea0e4dea661926f7fee21653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a66a7661d4f7686ea0e4dea661926f7fee21653", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a66a7661d4f7686ea0e4dea661926f7fee21653/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "852dba8059832d76c74e1e6f31d65a9302a0baa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dba8059832d76c74e1e6f31d65a9302a0baa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852dba8059832d76c74e1e6f31d65a9302a0baa7"}], "stats": {"total": 1203, "additions": 572, "deletions": 631}, "files": [{"sha": "94ac0243f86565b731564406bdc6a952518a0f9f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -1,3 +1,23 @@\n+2009-06-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads, clean.adb,\n+\tprj-nmsc.adb, prj-env.adb, prj-proc.adb (Units_Table): Removed, since\n+\tno longer useful.\n+\t(Source_Data.Lang_Kind): Removed, since it duplicates information\n+\talready available through Language.Config.\n+\t(Source_Data.Compile): Removed, since information is already available\n+\tthrough the language.\n+\t(Is_Compilable): New subprogram.\n+\t(Source_Data.Dependency): Removed, since already available through\n+\tthe language.\n+\t(Source_Data.Object_Exist, Object_Linked): Removed since available\n+\tthrough the language already.\n+\t(Unit_Data.File_Names): Is now also set in multi_language mode, to\n+\tbring the two modes closer in the resulting data structures.\n+\t(Source_Data.Unit): Now a direct pointer to the unit data, rather than\n+\tjust the name that would point into a hash table.\n+\t(Get_Language_From_Name): New subprogram.\n+\n 2009-06-24  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Type_Conversion): Handle entities that are"}, {"sha": "fa03e5cfac9b051474b33e7f6852f6557406b765", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -540,7 +540,7 @@ package body Clean is\n       Last : Natural;\n \n       Delete_File : Boolean;\n-      Unit        : Unit_Data;\n+      Unit        : Unit_Index;\n \n    begin\n       if Project.Library\n@@ -570,13 +570,11 @@ package body Clean is\n                      Canonical_Case_File_Name (Name (1 .. Last));\n                      Delete_File := False;\n \n-                     --  Compare with source file names of the project\n+                     Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n \n-                     for Index in\n-                       1 .. Unit_Table.Last (Project_Tree.Units)\n-                     loop\n-                        Unit := Project_Tree.Units.Table (Index);\n+                     --  Compare with source file names of the project\n \n+                     while Unit /= No_Unit_Index loop\n                         if Unit.File_Names (Impl) /= null\n                           and then Ultimate_Extending_Project_Of\n                             (Unit.File_Names (Impl).Project) = Project\n@@ -599,6 +597,8 @@ package body Clean is\n                            Delete_File := True;\n                            exit;\n                         end if;\n+\n+                        Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n                      end loop;\n \n                      if Delete_File then\n@@ -733,15 +733,13 @@ package body Clean is\n \n                      if Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n                         declare\n-                           Unit : Unit_Data;\n+                           Unit : Unit_Index;\n                         begin\n                            --  Compare with ALI file names of the project\n \n-                           for\n-                             Index in 1 .. Unit_Table.Last (Project_Tree.Units)\n-                           loop\n-                              Unit := Project_Tree.Units.Table (Index);\n-\n+                           Unit := Units_Htable.Get_First\n+                             (Project_Tree.Units_HT);\n+                           while Unit /= No_Unit_Index loop\n                               if Unit.File_Names (Impl) /= null\n                                 and then Unit.File_Names (Impl).Project /=\n                                 No_Project\n@@ -781,6 +779,9 @@ package body Clean is\n                                     exit;\n                                  end if;\n                               end if;\n+\n+                              Unit := Units_Htable.Get_Next\n+                                (Project_Tree.Units_HT);\n                            end loop;\n                         end;\n                      end if;\n@@ -817,7 +818,7 @@ package body Clean is\n       --  Name of the executable file\n \n       Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-      U_Data      : Unit_Data;\n+      Unit        : Unit_Index;\n       File_Name1  : File_Name_Type;\n       Index1      : Int;\n       File_Name2  : File_Name_Type;\n@@ -879,40 +880,35 @@ package body Clean is\n                if Has_Ada_Sources (Project)\n                  or else Project.Extends /= No_Project\n                then\n-                  for Unit in Unit_Table.First ..\n-                    Unit_Table.Last (Project_Tree.Units)\n-                  loop\n-                     U_Data := Project_Tree.Units.Table (Unit);\n+                  Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n+                  while Unit /= No_Unit_Index loop\n                      File_Name1 := No_File;\n                      File_Name2 := No_File;\n \n                      --  If either the spec or the body is a source of the\n                      --  project, check for the corresponding ALI file in the\n                      --  object directory.\n \n-                     if (U_Data.File_Names (Impl) /= null\n+                     if (Unit.File_Names (Impl) /= null\n                          and then\n                            In_Extension_Chain\n-                             (U_Data.File_Names (Impl).Project, Project))\n+                             (Unit.File_Names (Impl).Project, Project))\n                        or else\n-                         (U_Data.File_Names (Spec) /= null\n+                         (Unit.File_Names (Spec) /= null\n                           and then In_Extension_Chain\n-                            (U_Data.File_Names\n-                               (Spec).Project, Project))\n+                            (Unit.File_Names (Spec).Project, Project))\n                      then\n-                        if U_Data.File_Names (Impl) /= null then\n-                           File_Name1 := U_Data.File_Names (Impl).File;\n-                           Index1     := U_Data.File_Names (Impl).Index;\n+                        if Unit.File_Names (Impl) /= null then\n+                           File_Name1 := Unit.File_Names (Impl).File;\n+                           Index1     := Unit.File_Names (Impl).Index;\n                         else\n                            File_Name1 := No_File;\n                            Index1     := 0;\n                         end if;\n \n-                        if U_Data.File_Names (Spec) /= null then\n-                           File_Name2 :=\n-                             U_Data.File_Names (Spec).File;\n-                           Index2     :=\n-                             U_Data.File_Names (Spec).Index;\n+                        if Unit.File_Names (Spec) /= null then\n+                           File_Name2 := Unit.File_Names (Spec).File;\n+                           Index2     := Unit.File_Names (Spec).Index;\n                         else\n                            File_Name2 := No_File;\n                            Index2     := 0;\n@@ -1031,6 +1027,8 @@ package body Clean is\n                            end if;\n                         end;\n                      end if;\n+\n+                     Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n                   end loop;\n                end if;\n "}, {"sha": "f19bdd07de4bab8f711bf08ac628a89794c78455", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -306,7 +306,7 @@ procedure GNATCmd is\n \n    procedure Check_Files is\n       Add_Sources : Boolean := True;\n-      Unit_Data   : Prj.Unit_Data;\n+      Unit        : Prj.Unit_Index;\n       Subunit     : Boolean := False;\n       FD          : File_Descriptor := Invalid_FD;\n       Status      : Integer;\n@@ -409,27 +409,24 @@ procedure GNATCmd is\n                end loop;\n             end if;\n \n-            for Unit in Unit_Table.First ..\n-                        Unit_Table.Last (Project_Tree.Units)\n-            loop\n-               Unit_Data := Project_Tree.Units.Table (Unit);\n-\n+            Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n+            while Unit /= No_Unit_Index loop\n                --  For gnatls, we only need to put the library units, body or\n                --  spec, but not the subunits.\n \n                if The_Command = List then\n-                  if Unit_Data.File_Names (Impl) /= null\n-                    and then Unit_Data.File_Names (Impl).Path.Name /= Slash\n+                  if Unit.File_Names (Impl) /= null\n+                    and then Unit.File_Names (Impl).Path.Name /= Slash\n                   then\n                      --  There is a body, check if it is for this project\n \n                      if All_Projects or else\n-                        Unit_Data.File_Names (Impl).Project = Project\n+                        Unit.File_Names (Impl).Project = Project\n                      then\n                         Subunit := False;\n \n-                        if Unit_Data.File_Names (Spec) = null\n-                          or else Unit_Data.File_Names (Spec).Path.Name = Slash\n+                        if Unit.File_Names (Spec) = null\n+                          or else Unit.File_Names (Spec).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check if\n                            --  this is a subunit, because gnatls will complain\n@@ -439,7 +436,7 @@ procedure GNATCmd is\n                               Src_Ind : constant Source_File_Index :=\n                                           Sinput.P.Load_Project_File\n                                             (Get_Name_String\n-                                              (Unit_Data.File_Names\n+                                              (Unit.File_Names\n                                                 (Impl).Path.Name));\n                            begin\n                               Subunit :=\n@@ -452,25 +449,25 @@ procedure GNATCmd is\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'\n                                (Get_Name_String\n-                                    (Unit_Data.File_Names\n+                                    (Unit.File_Names\n                                          (Impl).Display_File));\n                         end if;\n                      end if;\n \n-                  elsif Unit_Data.File_Names (Spec) /= null\n-                    and then Unit_Data.File_Names (Spec).Path.Name /= Slash\n+                  elsif Unit.File_Names (Spec) /= null\n+                    and then Unit.File_Names (Spec).Path.Name /= Slash\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n                      if All_Projects or else\n-                        Unit_Data.File_Names (Spec).Project = Project\n+                        Unit.File_Names (Spec).Project = Project\n                      then\n                         Last_Switches.Increment_Last;\n                         Last_Switches.Table (Last_Switches.Last) :=\n                           new String'\n                             (Get_Name_String\n-                                 (Unit_Data.File_Names\n+                                 (Unit.File_Names\n                                       (Spec).Display_File));\n                      end if;\n                   end if;\n@@ -481,19 +478,19 @@ procedure GNATCmd is\n                --  but not the subunits.\n \n                elsif The_Command = Stack then\n-                  if Unit_Data.File_Names (Impl) /= null\n-                    and then Unit_Data.File_Names (Impl).Path.Name /= Slash\n+                  if Unit.File_Names (Impl) /= null\n+                    and then Unit.File_Names (Impl).Path.Name /= Slash\n                   then\n                      --  There is a body. Check if .ci files for this project\n                      --  must be added.\n \n                      if Check_Project\n-                         (Unit_Data.File_Names (Impl).Project, Project)\n+                         (Unit.File_Names (Impl).Project, Project)\n                      then\n                         Subunit := False;\n \n-                        if Unit_Data.File_Names (Spec) = null\n-                          or else Unit_Data.File_Names (Spec).Path.Name = Slash\n+                        if Unit.File_Names (Spec) = null\n+                          or else Unit.File_Names (Spec).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check\n                            --  if this is a subunit, because .ci files are not\n@@ -503,7 +500,7 @@ procedure GNATCmd is\n                               Src_Ind : constant Source_File_Index :=\n                                           Sinput.P.Load_Project_File\n                                             (Get_Name_String\n-                                              (Unit_Data.File_Names\n+                                              (Unit.File_Names\n                                                 (Impl).Path.Name));\n                            begin\n                               Subunit :=\n@@ -516,38 +513,38 @@ procedure GNATCmd is\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'\n                                (Get_Name_String\n-                                    (Unit_Data.File_Names\n+                                    (Unit.File_Names\n                                        (Impl).Project.\n                                          Object_Directory.Name)      &\n                                 Directory_Separator                  &\n                                 MLib.Fil.Ext_To\n                                   (Get_Name_String\n-                                     (Unit_Data.File_Names\n+                                     (Unit.File_Names\n                                         (Impl).Display_File),\n                                    \"ci\"));\n                         end if;\n                      end if;\n \n-                  elsif Unit_Data.File_Names (Spec) /= null\n-                    and then Unit_Data.File_Names (Spec).Path.Name /= Slash\n+                  elsif Unit.File_Names (Spec) /= null\n+                    and then Unit.File_Names (Spec).Path.Name /= Slash\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n                      if Check_Project\n-                       (Unit_Data.File_Names (Spec).Project, Project)\n+                       (Unit.File_Names (Spec).Project, Project)\n                      then\n                         Last_Switches.Increment_Last;\n                         Last_Switches.Table (Last_Switches.Last) :=\n                           new String'\n                             (Get_Name_String\n-                                 (Unit_Data.File_Names\n+                                 (Unit.File_Names\n                                    (Spec).Project.\n                                       Object_Directory.Name)         &\n                              Dir_Separator                           &\n                              MLib.Fil.Ext_To\n                                (Get_Name_String\n-                                  (Unit_Data.File_Names (Spec).File),\n+                                  (Unit.File_Names (Spec).File),\n                                 \"ci\"));\n                      end if;\n                   end if;\n@@ -558,13 +555,13 @@ procedure GNATCmd is\n                   --  specified.\n \n                   for Kind in Spec_Or_Body loop\n-                     if Unit_Data.File_Names (Kind) /= null\n+                     if Unit.File_Names (Kind) /= null\n                        and then Check_Project\n-                         (Unit_Data.File_Names (Kind).Project, Project)\n-                       and then Unit_Data.File_Names (Kind).Path.Name /= Slash\n+                         (Unit.File_Names (Kind).Project, Project)\n+                       and then Unit.File_Names (Kind).Path.Name /= Slash\n                      then\n                         Get_Name_String\n-                          (Unit_Data.File_Names (Kind).Path.Display_Name);\n+                          (Unit.File_Names (Kind).Path.Display_Name);\n \n                         if FD /= Invalid_FD then\n                            Name_Len := Name_Len + 1;\n@@ -581,12 +578,14 @@ procedure GNATCmd is\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'\n                                (Get_Name_String\n-                                    (Unit_Data.File_Names\n+                                    (Unit.File_Names\n                                          (Kind).Path.Display_Name));\n                         end if;\n                      end if;\n                   end loop;\n                end if;\n+\n+               Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n             end loop;\n          end;\n \n@@ -758,7 +757,7 @@ procedure GNATCmd is\n       --  Used to read file if there is an error, it is good enough to display\n       --  just 250 characters if the first line of the file is very long.\n \n-      Udata : Unit_Data;\n+      Unit  : Unit_Index;\n       Path  : Path_Name_Type;\n \n    begin\n@@ -817,27 +816,26 @@ procedure GNATCmd is\n             Get_Line (File, Line, Last);\n             Path := No_Path;\n \n-            for Unit in Unit_Table.First ..\n-                        Unit_Table.Last (Project_Tree.Units)\n-            loop\n-               Udata := Project_Tree.Units.Table (Unit);\n-\n-               if Udata.File_Names (Spec) /= null\n+            Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n+            while Unit /= No_Unit_Index loop\n+               if Unit.File_Names (Spec) /= null\n                  and then\n-                   Get_Name_String (Udata.File_Names (Spec).File) =\n+                   Get_Name_String (Unit.File_Names (Spec).File) =\n                       Line (1 .. Last)\n                then\n-                  Path := Udata.File_Names (Spec).Path.Name;\n+                  Path := Unit.File_Names (Spec).Path.Name;\n                   exit;\n \n-               elsif Udata.File_Names (Impl) /= null\n+               elsif Unit.File_Names (Impl) /= null\n                  and then\n-                   Get_Name_String (Udata.File_Names (Impl).File) =\n+                   Get_Name_String (Unit.File_Names (Impl).File) =\n                      Line (1 .. Last)\n                then\n-                  Path := Udata.File_Names (Impl).Path.Name;\n+                  Path := Unit.File_Names (Impl).Path.Name;\n                   exit;\n                end if;\n+\n+               Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n             end loop;\n \n             Last_Switches.Increment_Last;"}, {"sha": "4eb20f3418f75a3facf733880e671ccc07cd1c4a", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 151, "deletions": 160, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -1465,19 +1465,16 @@ package body Make is\n          Sfile : File_Name_Type) return Boolean\n       is\n          UID    : Prj.Unit_Index;\n-         U_Data : Unit_Data;\n \n       begin\n          UID := Units_Htable.Get (Project_Tree.Units_HT, Uname);\n \n          if UID /= Prj.No_Unit_Index then\n-            U_Data := Project_Tree.Units.Table (UID);\n-\n-            if (U_Data.File_Names (Impl) = null\n-                or else U_Data.File_Names (Impl).File /= Sfile)\n+            if (UID.File_Names (Impl) = null\n+                or else UID.File_Names (Impl).File /= Sfile)\n               and then\n-                (U_Data.File_Names (Spec) = null\n-                 or else U_Data.File_Names (Spec).File /= Sfile)\n+                (UID.File_Names (Spec) = null\n+                 or else UID.File_Names (Spec).File /= Sfile)\n             then\n                Verbose_Msg (Uname, \"sources do not include \", Name_Id (Sfile));\n                return True;\n@@ -1942,12 +1939,11 @@ package body Make is\n                ALI_Project := No_Project;\n \n                declare\n-                  Udata : Prj.Unit_Data;\n+                  Udata : Prj.Unit_Index;\n \n                begin\n-                  for U in 1 .. Unit_Table.Last (Project_Tree.Units) loop\n-                     Udata := Project_Tree.Units.Table (U);\n-\n+                  Udata := Units_Htable.Get_First (Project_Tree.Units_HT);\n+                  while Udata /= No_Unit_Index loop\n                      if Udata.File_Names (Impl) /= null\n                        and then Udata.File_Names (Impl).File = Source_File\n                      then\n@@ -1962,6 +1958,8 @@ package body Make is\n                           Udata.File_Names (Spec).Project;\n                         exit;\n                      end if;\n+\n+                     Udata := Units_Htable.Get_Next (Project_Tree.Units_HT);\n                   end loop;\n                end;\n \n@@ -2035,6 +2033,7 @@ package body Make is\n                      Projects : array (1 .. Num_Ext) of Project_Id;\n                      Dep      : Sdep_Record;\n                      OK       : Boolean := True;\n+                     UID      : Unit_Index;\n \n                   begin\n                      Proj := ALI_Project;\n@@ -2051,28 +2050,20 @@ package body Make is\n                        ALIs.Table (ALI).Last_Sdep\n                      loop\n                         Dep := Sdep.Table (D);\n-\n+                        UID  := Units_Htable.Get_First (Project_Tree.Units_HT);\n                         Proj := No_Project;\n \n                         Unit_Loop :\n-                        for\n-                          UID in 1 .. Unit_Table.Last (Project_Tree.Units)\n-                        loop\n-                           if Project_Tree.Units.Table (UID).\n-                             File_Names (Impl) /= null\n-                             and then Project_Tree.Units.Table (UID).\n-                             File_Names (Impl).File = Dep.Sfile\n+                        while UID /= null loop\n+                           if UID.File_Names (Impl) /= null\n+                             and then UID.File_Names (Impl).File = Dep.Sfile\n                            then\n-                              Proj := Project_Tree.Units.Table (UID).\n-                                File_Names (Impl).Project;\n+                              Proj := UID.File_Names (Impl).Project;\n \n-                           elsif Project_Tree.Units.Table (UID).\n-                             File_Names (Spec) /= null\n-                             and then Project_Tree.Units.Table (UID).\n-                             File_Names (Spec).File = Dep.Sfile\n+                           elsif UID.File_Names (Spec) /= null\n+                             and then UID.File_Names (Spec).File = Dep.Sfile\n                            then\n-                              Proj := Project_Tree.Units.Table (UID).\n-                                File_Names (Spec).Project;\n+                              Proj := UID.File_Names (Spec).Project;\n                            end if;\n \n                            --  If a source is in a project, check if it is one\n@@ -2088,6 +2079,9 @@ package body Make is\n \n                               exit Unit_Loop;\n                            end if;\n+\n+                           UID :=\n+                             Units_Htable.Get_Next (Project_Tree.Units_HT);\n                         end loop Unit_Loop;\n                      end loop D_Chk;\n \n@@ -3605,7 +3599,6 @@ package body Make is\n                            declare\n                               Unit_Name : Name_Id;\n                               Uid       : Prj.Unit_Index;\n-                              Udata     : Unit_Data;\n \n                            begin\n                               Get_Name_String (Uname);\n@@ -3616,26 +3609,24 @@ package body Make is\n                                   (Project_Tree.Units_HT, Unit_Name);\n \n                               if Uid /= Prj.No_Unit_Index then\n-                                 Udata := Project_Tree.Units.Table (Uid);\n-\n-                                 if Udata.File_Names (Impl) /= null\n+                                 if Uid.File_Names (Impl) /= null\n                                    and then\n-                                     Udata.File_Names (Impl).Path.Name /=\n+                                     Uid.File_Names (Impl).Path.Name /=\n                                        Slash\n                                  then\n-                                    Sfile := Udata.File_Names (Impl).File;\n+                                    Sfile := Uid.File_Names (Impl).File;\n                                     Source_Index :=\n-                                      Udata.File_Names (Impl).Index;\n+                                      Uid.File_Names (Impl).Index;\n \n-                                 elsif Udata.File_Names (Spec) /= null\n+                                 elsif Uid.File_Names (Spec) /= null\n                                    and then\n-                                     Udata.File_Names\n+                                     Uid.File_Names\n                                        (Spec).Path.Name /= Slash\n                                  then\n                                     Sfile :=\n-                                      Udata.File_Names (Spec).File;\n+                                      Uid.File_Names (Spec).File;\n                                     Source_Index :=\n-                                      Udata.File_Names (Spec).Index;\n+                                      Uid.File_Names (Spec).Index;\n                                  end if;\n                               end if;\n                            end;\n@@ -4384,6 +4375,7 @@ package body Make is\n \n          Bytes : Integer;\n          OK    : Boolean := True;\n+         Unit  : Unit_Index;\n \n          Status : Boolean;\n          --  For call to Close\n@@ -4396,139 +4388,137 @@ package body Make is\n \n             --  Traverse all units\n \n-            for J in Unit_Table.First ..\n-                     Unit_Table.Last (Project_Tree.Units)\n-            loop\n-               declare\n-                  Unit : constant Unit_Data := Project_Tree.Units.Table (J);\n-               begin\n-                  if Unit.Name /= No_Name then\n+            Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n \n-                     --  If there is a body, put it in the mapping\n+            while Unit /= No_Unit_Index loop\n+               if Unit.Name /= No_Name then\n \n-                     if Unit.File_Names (Impl) /= No_Source\n-                       and then Unit.File_Names (Impl).Project /=\n-                                                            No_Project\n-                     then\n-                        Get_Name_String (Unit.Name);\n-                        Add_Str_To_Name_Buffer (\"%b\");\n-                        ALI_Unit := Name_Find;\n-                        ALI_Name :=\n-                          Lib_File_Name\n-                            (Unit.File_Names (Impl).Display_File);\n-                        ALI_Project := Unit.File_Names (Impl).Project;\n-\n-                        --  Otherwise, if there is a spec, put it in the\n-                        --  mapping.\n-\n-                     elsif Unit.File_Names (Spec) /= No_Source\n-                       and then Unit.File_Names (Spec).Project /=\n-                                                                No_Project\n-                     then\n-                        Get_Name_String (Unit.Name);\n-                        Add_Str_To_Name_Buffer (\"%s\");\n-                        ALI_Unit := Name_Find;\n-                        ALI_Name :=\n-                          Lib_File_Name\n-                            (Unit.File_Names (Spec).Display_File);\n-                        ALI_Project := Unit.File_Names (Spec).Project;\n+                  --  If there is a body, put it in the mapping\n \n-                     else\n-                        ALI_Name := No_File;\n-                     end if;\n+                  if Unit.File_Names (Impl) /= No_Source\n+                    and then Unit.File_Names (Impl).Project /=\n+                    No_Project\n+                  then\n+                     Get_Name_String (Unit.Name);\n+                     Add_Str_To_Name_Buffer (\"%b\");\n+                     ALI_Unit := Name_Find;\n+                     ALI_Name :=\n+                       Lib_File_Name\n+                         (Unit.File_Names (Impl).Display_File);\n+                     ALI_Project := Unit.File_Names (Impl).Project;\n+\n+                     --  Otherwise, if there is a spec, put it in the\n+                     --  mapping.\n+\n+                  elsif Unit.File_Names (Spec) /= No_Source\n+                    and then Unit.File_Names (Spec).Project /=\n+                    No_Project\n+                  then\n+                     Get_Name_String (Unit.Name);\n+                     Add_Str_To_Name_Buffer (\"%s\");\n+                     ALI_Unit := Name_Find;\n+                     ALI_Name :=\n+                       Lib_File_Name\n+                         (Unit.File_Names (Spec).Display_File);\n+                     ALI_Project := Unit.File_Names (Spec).Project;\n \n-                     --  If we have something to put in the mapping then do it\n-                     --  now. However, if the project is extended, we don't put\n-                     --  anything in the mapping file, because we do not know\n-                     --  where the ALI file is: it might be in the extended\n-                     --  project obj dir as well as in the extending project\n-                     --  obj dir.\n+                  else\n+                     ALI_Name := No_File;\n+                  end if;\n \n-                     if ALI_Name /= No_File\n-                       and then ALI_Project.Extended_By = No_Project\n-                       and then ALI_Project.Extends = No_Project\n-                     then\n-                        --  First check if the ALI file exists. If it does not,\n-                        --  do not put the unit in the mapping file.\n+                  --  If we have something to put in the mapping then do it\n+                  --  now. However, if the project is extended, we don't put\n+                  --  anything in the mapping file, because we do not know\n+                  --  where the ALI file is: it might be in the extended\n+                  --  project obj dir as well as in the extending project\n+                  --  obj dir.\n+\n+                  if ALI_Name /= No_File\n+                    and then ALI_Project.Extended_By = No_Project\n+                    and then ALI_Project.Extends = No_Project\n+                  then\n+                     --  First check if the ALI file exists. If it does not,\n+                     --  do not put the unit in the mapping file.\n+\n+                     declare\n+                        ALI : constant String := Get_Name_String (ALI_Name);\n+\n+                     begin\n+                        --  For library projects, use the library directory,\n+                        --  for other projects, use the object directory.\n+\n+                        if ALI_Project.Library then\n+                           Get_Name_String (ALI_Project.Library_Dir.Name);\n+                        else\n+                           Get_Name_String\n+                             (ALI_Project.Object_Directory.Name);\n+                        end if;\n+\n+                        if Name_Buffer (Name_Len) /=\n+                          Directory_Separator\n+                        then\n+                           Add_Char_To_Name_Buffer (Directory_Separator);\n+                        end if;\n+\n+                        Add_Str_To_Name_Buffer (ALI);\n+                        Add_Char_To_Name_Buffer (ASCII.LF);\n \n                         declare\n-                           ALI : constant String := Get_Name_String (ALI_Name);\n+                           ALI_Path_Name : constant String :=\n+                             Name_Buffer (1 .. Name_Len);\n \n                         begin\n-                           --  For library projects, use the library directory,\n-                           --  for other projects, use the object directory.\n+                           if Is_Regular_File\n+                             (ALI_Path_Name (1 .. ALI_Path_Name'Last - 1))\n+                           then\n \n-                           if ALI_Project.Library then\n-                              Get_Name_String (ALI_Project.Library_Dir.Name);\n-                           else\n-                              Get_Name_String\n-                                (ALI_Project.Object_Directory.Name);\n-                           end if;\n+                              --  First line is the unit name\n \n-                           if Name_Buffer (Name_Len) /=\n-                                Directory_Separator\n-                           then\n-                              Add_Char_To_Name_Buffer (Directory_Separator);\n-                           end if;\n+                              Get_Name_String (ALI_Unit);\n+                              Add_Char_To_Name_Buffer (ASCII.LF);\n+                              Bytes :=\n+                                Write\n+                                  (Mapping_FD,\n+                                   Name_Buffer (1)'Address,\n+                                   Name_Len);\n+                              OK := Bytes = Name_Len;\n \n-                           Add_Str_To_Name_Buffer (ALI);\n-                           Add_Char_To_Name_Buffer (ASCII.LF);\n+                              exit when not OK;\n \n-                           declare\n-                              ALI_Path_Name : constant String :=\n-                                                Name_Buffer (1 .. Name_Len);\n+                              --  Second line it the ALI file name\n \n-                           begin\n-                              if Is_Regular_File\n-                                (ALI_Path_Name (1 .. ALI_Path_Name'Last - 1))\n-                              then\n-\n-                                 --  First line is the unit name\n-\n-                                 Get_Name_String (ALI_Unit);\n-                                 Add_Char_To_Name_Buffer (ASCII.LF);\n-                                 Bytes :=\n-                                   Write\n-                                     (Mapping_FD,\n-                                      Name_Buffer (1)'Address,\n-                                      Name_Len);\n-                                 OK := Bytes = Name_Len;\n-\n-                                 exit when not OK;\n-\n-                                 --  Second line it the ALI file name\n-\n-                                 Get_Name_String (ALI_Name);\n-                                 Add_Char_To_Name_Buffer (ASCII.LF);\n-                                 Bytes :=\n-                                   Write\n-                                     (Mapping_FD,\n-                                      Name_Buffer (1)'Address,\n-                                      Name_Len);\n-                                 OK := Bytes = Name_Len;\n-\n-                                 exit when not OK;\n-\n-                                 --  Third line it the ALI path name\n-\n-                                 Bytes :=\n-                                   Write\n-                                     (Mapping_FD,\n-                                      ALI_Path_Name (1)'Address,\n-                                      ALI_Path_Name'Length);\n-                                 OK := Bytes = ALI_Path_Name'Length;\n-\n-                                 --  If OK is False, it means we were unable\n-                                 --  to write a line. No point in continuing\n-                                 --  with the other units.\n-\n-                                 exit when not OK;\n-                              end if;\n-                           end;\n+                              Get_Name_String (ALI_Name);\n+                              Add_Char_To_Name_Buffer (ASCII.LF);\n+                              Bytes :=\n+                                Write\n+                                  (Mapping_FD,\n+                                   Name_Buffer (1)'Address,\n+                                   Name_Len);\n+                              OK := Bytes = Name_Len;\n+\n+                              exit when not OK;\n+\n+                              --  Third line it the ALI path name\n+\n+                              Bytes :=\n+                                Write\n+                                  (Mapping_FD,\n+                                   ALI_Path_Name (1)'Address,\n+                                   ALI_Path_Name'Length);\n+                              OK := Bytes = ALI_Path_Name'Length;\n+\n+                              --  If OK is False, it means we were unable\n+                              --  to write a line. No point in continuing\n+                              --  with the other units.\n+\n+                              exit when not OK;\n+                           end if;\n                         end;\n-                     end if;\n+                     end;\n                   end if;\n-               end;\n+               end if;\n+\n+               Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n             end loop;\n \n             Close (Mapping_FD, Status);\n@@ -6968,7 +6958,7 @@ package body Make is\n       Into_Q       : Boolean)\n    is\n       Put_In_Q : Boolean := Into_Q;\n-      Unit     : Unit_Data;\n+      Unit     : Unit_Index;\n       Sfile    : File_Name_Type;\n       Index    : Int;\n \n@@ -7010,10 +7000,9 @@ package body Make is\n    begin\n       --  For all the sources in the project files,\n \n-      for Id in Unit_Table.First ..\n-                Unit_Table.Last (Project_Tree.Units)\n-      loop\n-         Unit  := Project_Tree.Units.Table (Id);\n+      Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n+\n+      while Unit /= null loop\n          Sfile := No_File;\n          Index := 0;\n \n@@ -7126,6 +7115,8 @@ package body Make is\n                Init_Q;\n             end if;\n          end if;\n+\n+         Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n       end loop;\n    end Insert_Project_Sources;\n "}, {"sha": "1be2f786ed8594b5532b8e20c21c943314edf688", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -936,18 +936,16 @@ package body MLib.Prj is\n          --  Bind is False, so that First_ALI is set.\n \n          declare\n-            Unit : Unit_Data;\n+            Unit : Unit_Index;\n \n          begin\n             Library_ALIs.Reset;\n             Interface_ALIs.Reset;\n             Processed_ALIs.Reset;\n \n-            for Source in Unit_Table.First ..\n-                          Unit_Table.Last (In_Tree.Units)\n-            loop\n-               Unit := In_Tree.Units.Table (Source);\n+            Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n \n+            while Unit /= No_Unit_Index loop\n                if Unit.File_Names (Impl) /= null\n                  and then Unit.File_Names (Impl).Path.Name /= Slash\n                then\n@@ -988,6 +986,8 @@ package body MLib.Prj is\n                   Add_ALI_For (Unit.File_Names (Spec).File);\n                   exit when not Bind;\n                end if;\n+\n+               Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n             end loop;\n          end;\n \n@@ -1406,6 +1406,7 @@ package body MLib.Prj is\n                                                       B_Start.all);\n                                     Fname    : File_Name_Type;\n                                     Proj     : Project_Id;\n+                                    Index    : Unit_Index;\n \n                                  begin\n                                     if Is_Regular_File (ALI_Path) then\n@@ -1417,35 +1418,26 @@ package body MLib.Prj is\n                                        --  the library.\n \n                                        if not Add_It then\n-                                          for Index in\n-                                            1 .. Unit_Table.Last\n-                                                   (In_Tree.Units)\n-                                          loop\n-                                             if In_Tree.Units.Table\n-                                                 (Index).File_Names\n-                                                   (Impl) /= null\n+                                          Index := Units_Htable.Get_First\n+                                            (In_Tree.Units_HT);\n+                                          while Index /= null loop\n+                                             if Index.File_Names (Impl) /=\n+                                               null\n                                              then\n                                                 Proj :=\n-                                                  In_Tree.Units.Table (Index).\n-                                                  File_Names\n-                                                    (Impl).Project;\n+                                                  Index.File_Names (Impl)\n+                                                  .Project;\n                                                 Fname :=\n-                                                  In_Tree.Units.Table (Index).\n-                                                   File_Names (Impl).File;\n+                                                  Index.File_Names (Impl).File;\n \n-                                             elsif\n-                                               In_Tree.Units.Table\n-                                                 (Index).File_Names\n-                                                 (Spec) /= null\n+                                             elsif Index.File_Names (Spec) /=\n+                                               null\n                                              then\n                                                 Proj :=\n-                                                  In_Tree.Units.Table\n-                                                    (Index).File_Names\n-                                                     (Spec).Project;\n+                                                  Index.File_Names (Spec)\n+                                                  .Project;\n                                                 Fname :=\n-                                                  In_Tree.Units.Table\n-                                                    (Index).File_Names\n-                                                     (Spec).File;\n+                                                  Index.File_Names (Spec).File;\n \n                                              else\n                                                 Proj := No_Project;\n@@ -1478,6 +1470,9 @@ package body MLib.Prj is\n                                              end if;\n \n                                              exit when Add_It;\n+\n+                                             Index := Units_Htable.Get_Next\n+                                               (In_Tree.Units_HT);\n                                           end loop;\n                                        end if;\n \n@@ -1830,16 +1825,13 @@ package body MLib.Prj is\n                        and then Name (Last - 3 .. Last) = \".ali\"\n                      then\n                         declare\n-                           Unit : Unit_Data;\n+                           Unit : Unit_Index;\n \n                         begin\n                            --  Compare with ALI file names of the project\n \n-                           for Index in\n-                             1 .. Unit_Table.Last (In_Tree.Units)\n-                           loop\n-                              Unit := In_Tree.Units.Table (Index);\n-\n+                           Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n+                           while Unit /= No_Unit_Index loop\n                               if Unit.File_Names (Impl) /= null\n                                 and then Unit.File_Names (Impl).Project /=\n                                 No_Project\n@@ -1880,6 +1872,8 @@ package body MLib.Prj is\n                                     exit;\n                                  end if;\n                               end if;\n+\n+                              Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n                            end loop;\n                         end;\n                      end if;\n@@ -1959,7 +1953,7 @@ package body MLib.Prj is\n             declare\n                Dir    : Dir_Type;\n                Delete : Boolean := False;\n-               Unit   : Unit_Data;\n+               Unit   : Unit_Index;\n \n                Name : String (1 .. 200);\n                Last : Natural;\n@@ -1980,9 +1974,8 @@ package body MLib.Prj is\n \n                      --  Compare with source file names of the project\n \n-                     for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n-                        Unit := In_Tree.Units.Table (Index);\n-\n+                     Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n+                     while Unit /= No_Unit_Index loop\n                         if Unit.File_Names (Impl) /= null\n                           and then Ultimate_Extending_Project_Of\n                             (Unit.File_Names (Impl).Project) = For_Project\n@@ -2007,6 +2000,8 @@ package body MLib.Prj is\n                            Delete := True;\n                            exit;\n                         end if;\n+\n+                        Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n                      end loop;\n                   end if;\n \n@@ -2163,7 +2158,7 @@ package body MLib.Prj is\n       First_Unit  : ALI.Unit_Id;\n       Second_Unit : ALI.Unit_Id;\n \n-      Data : Unit_Data;\n+      Data : Unit_Index;\n \n       Copy_Subunits : Boolean := False;\n       --  When True, indicates that subunits, if any, need to be copied too\n@@ -2186,12 +2181,10 @@ package body MLib.Prj is\n          pragma Warnings (Off, Success);\n \n       begin\n-         Unit_Loop :\n-         for Index in Unit_Table.First ..\n-                      Unit_Table.Last (In_Tree.Units)\n-         loop\n-            Data := In_Tree.Units.Table (Index);\n+         Data := Units_Htable.Get_First (In_Tree.Units_HT);\n \n+         Unit_Loop :\n+         while Data /= No_Unit_Index loop\n             --  Find and copy the immediate or inherited source\n \n             for J in Data.File_Names'Range loop\n@@ -2209,6 +2202,8 @@ package body MLib.Prj is\n                   exit Unit_Loop;\n                end if;\n             end loop;\n+\n+            Data := Units_Htable.Get_Next (In_Tree.Units_HT);\n          end loop Unit_Loop;\n       end Copy;\n "}, {"sha": "6ef82572292a0eb08dcb9ee66ebc47b10dac595e", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -397,7 +397,7 @@ package body Prj.Env is\n       File_Name : Path_Name_Type  := No_Path;\n       File      : File_Descriptor := Invalid_FD;\n \n-      Current_Unit : Unit_Index := Unit_Table.First;\n+      Current_Unit : Unit_Index := Units_Htable.Get_First (In_Tree.Units_HT);\n \n       First_Project : Project_List;\n \n@@ -673,34 +673,26 @@ package body Prj.Env is\n \n          --  Visit all the units and process those that need an SFN pragma\n \n-         while\n-           Current_Unit <= Unit_Table.Last (In_Tree.Units)\n-         loop\n-            declare\n-               Unit : constant Unit_Data :=\n-                 In_Tree.Units.Table (Current_Unit);\n-\n-            begin\n-               if Unit.File_Names (Spec) /= null\n-                 and then Unit.File_Names (Spec).Naming_Exception\n-               then\n-                  Put (Unit.Name,\n-                       Unit.File_Names (Spec).File,\n-                       Spec,\n-                       Unit.File_Names (Spec).Index);\n-               end if;\n+         while Current_Unit /= No_Unit_Index loop\n+            if Current_Unit.File_Names (Spec) /= null\n+              and then Current_Unit.File_Names (Spec).Naming_Exception\n+            then\n+               Put (Current_Unit.Name,\n+                    Current_Unit.File_Names (Spec).File,\n+                    Spec,\n+                    Current_Unit.File_Names (Spec).Index);\n+            end if;\n \n-               if Unit.File_Names (Impl) /= null\n-                 and then Unit.File_Names (Impl).Naming_Exception\n-               then\n-                  Put (Unit.Name,\n-                       Unit.File_Names (Impl).File,\n-                       Impl,\n-                       Unit.File_Names (Impl).Index);\n-               end if;\n+            if Current_Unit.File_Names (Impl) /= null\n+              and then Current_Unit.File_Names (Impl).Naming_Exception\n+            then\n+               Put (Current_Unit.Name,\n+                    Current_Unit.File_Names (Impl).File,\n+                    Impl,\n+                    Current_Unit.File_Names (Impl).Index);\n+            end if;\n \n-               Current_Unit := Current_Unit + 1;\n-            end;\n+            Current_Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n          end loop;\n \n          --  If there are no non standard naming scheme, issue the GNAT\n@@ -746,19 +738,19 @@ package body Prj.Env is\n    --------------------\n \n    procedure Create_Mapping (In_Tree : Project_Tree_Ref) is\n-      The_Unit_Data : Unit_Data;\n+      Unit          : Unit_Index;\n       Data          : Source_Id;\n \n    begin\n       Fmap.Reset_Tables;\n \n-      for Unit in 1 .. Unit_Table.Last (In_Tree.Units) loop\n-         The_Unit_Data := In_Tree.Units.Table (Unit);\n+      Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n \n+      while Unit /= No_Unit_Index loop\n          --  Process only if the unit has a valid name\n \n-         if The_Unit_Data.Name /= No_Name then\n-            Data := The_Unit_Data.File_Names (Spec);\n+         if Unit.Name /= No_Name then\n+            Data := Unit.File_Names (Spec);\n \n             --  If there is a spec, put it in the mapping\n \n@@ -767,13 +759,13 @@ package body Prj.Env is\n                   Fmap.Add_Forbidden_File_Name (Data.File);\n                else\n                   Fmap.Add_To_File_Map\n-                    (Unit_Name => Unit_Name_Type (The_Unit_Data.Name),\n+                    (Unit_Name => Unit_Name_Type (Unit.Name),\n                      File_Name => Data.File,\n                      Path_Name => File_Name_Type (Data.Path.Name));\n                end if;\n             end if;\n \n-            Data := The_Unit_Data.File_Names (Impl);\n+            Data := Unit.File_Names (Impl);\n \n             --  If there is a body (or subunit) put it in the mapping\n \n@@ -782,12 +774,14 @@ package body Prj.Env is\n                   Fmap.Add_Forbidden_File_Name (Data.File);\n                else\n                   Fmap.Add_To_File_Map\n-                    (Unit_Name => Unit_Name_Type (The_Unit_Data.Name),\n+                    (Unit_Name => Unit_Name_Type (Unit.Name),\n                      File_Name => Data.File,\n                      Path_Name => File_Name_Type (Data.Path.Name));\n                end if;\n             end if;\n          end if;\n+\n+         Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n       end loop;\n    end Create_Mapping;\n \n@@ -810,7 +804,7 @@ package body Prj.Env is\n \n       Source        : Source_Id;\n       Suffix        : File_Name_Type;\n-      The_Unit_Data : Unit_Data;\n+      Unit          : Unit_Index;\n       Data          : Source_Id;\n       Iter          : Source_Iterator;\n \n@@ -850,7 +844,7 @@ package body Prj.Env is\n       begin\n          --  Line with the unit name\n \n-         Get_Name_String (The_Unit_Data.Name);\n+         Get_Name_String (Unit.Name);\n          Name_Len := Name_Len + 1;\n          Name_Buffer (Name_Len) := '%';\n          Name_Len := Name_Len + 1;\n@@ -926,13 +920,12 @@ package body Prj.Env is\n \n       if Language = No_Name then\n          if In_Tree.Private_Part.Fill_Mapping_File then\n-            for Unit in 1 .. Unit_Table.Last (In_Tree.Units) loop\n-               The_Unit_Data := In_Tree.Units.Table (Unit);\n-\n+            Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n+            while Unit /= null loop\n                --  Case of unit has a valid name\n \n-               if The_Unit_Data.Name /= No_Name then\n-                  Data := The_Unit_Data.File_Names (Spec);\n+               if Unit.Name /= No_Name then\n+                  Data := Unit.File_Names (Spec);\n \n                   --  If there is a spec, put it mapping in the file if it is\n                   --  from a project in the closure of Project.\n@@ -943,7 +936,7 @@ package body Prj.Env is\n                      Put_Data (Spec => True);\n                   end if;\n \n-                  Data := The_Unit_Data.File_Names (Impl);\n+                  Data := Unit.File_Names (Impl);\n \n                   --  If there is a body (or subunit) put its mapping in the\n                   --  file if it is from a project in the closure of Project.\n@@ -954,6 +947,8 @@ package body Prj.Env is\n                      Put_Data (Spec => False);\n                   end if;\n                end if;\n+\n+               Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n             end loop;\n          end if;\n \n@@ -980,8 +975,8 @@ package body Prj.Env is\n                        and then Source.Replaced_By = No_Source\n                        and then Source.Path.Name /= No_Path\n                      then\n-                        if Source.Unit /= No_Name then\n-                           Get_Name_String (Source.Unit);\n+                        if Source.Unit /= No_Unit_Index then\n+                           Get_Name_String (Source.Unit.Name);\n \n                            if Source.Kind = Spec then\n                               Suffix :=\n@@ -1111,8 +1106,7 @@ package body Prj.Env is\n                              Name &\n                              Body_Suffix_Of (In_Tree, \"ada\", Project.Naming);\n \n-      Unit : Unit_Data;\n-\n+      Unit              : Unit_Index;\n       The_Original_Name : Name_Id;\n       The_Spec_Name     : Name_Id;\n       The_Body_Name     : Name_Id;\n@@ -1154,13 +1148,9 @@ package body Prj.Env is\n \n       loop\n          --  Loop through units\n-         --  Should have comment explaining reverse ???\n-\n-         for Current in reverse Unit_Table.First ..\n-                                Unit_Table.Last (In_Tree.Units)\n-         loop\n-            Unit := In_Tree.Units.Table (Current);\n \n+         Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n+         while Unit /= null loop\n             --  Check for body\n \n             if not Main_Project_Only\n@@ -1290,6 +1280,8 @@ package body Prj.Env is\n                   end if;\n                end;\n             end if;\n+\n+            Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n          end loop;\n \n          --  If we are not in an extending project, give up\n@@ -1405,16 +1397,13 @@ package body Prj.Env is\n \n       declare\n          Original_Name : String := Source_File_Name;\n-         Unit          : Unit_Data;\n+         Unit          : Unit_Index;\n \n       begin\n          Canonical_Case_File_Name (Original_Name);\n+         Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n \n-         for Id in Unit_Table.First ..\n-                   Unit_Table.Last (In_Tree.Units)\n-         loop\n-            Unit := In_Tree.Units.Table (Id);\n-\n+         while Unit /= null loop\n             if Unit.File_Names (Spec) /= null\n               and then Unit.File_Names (Spec).File /= No_File\n               and then\n@@ -1460,6 +1449,8 @@ package body Prj.Env is\n \n                return;\n             end if;\n+\n+            Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n          end loop;\n       end;\n \n@@ -1490,15 +1481,14 @@ package body Prj.Env is\n    --  Could use some comments in this body ???\n \n    procedure Print_Sources (In_Tree : Project_Tree_Ref) is\n-      Unit : Unit_Data;\n+      Unit : Unit_Index;\n \n    begin\n       Write_Line (\"List of Sources:\");\n \n-      for Id in Unit_Table.First ..\n-                Unit_Table.Last (In_Tree.Units)\n-      loop\n-         Unit := In_Tree.Units.Table (Id);\n+      Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n+\n+      while Unit /= No_Unit_Index loop\n          Write_Str  (\"   \");\n          Write_Line (Namet.Get_Name_String (Unit.Name));\n \n@@ -1534,6 +1524,8 @@ package body Prj.Env is\n             Write_Line\n               (Namet.Get_Name_String (Unit.File_Names (Impl).File));\n          end if;\n+\n+         Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n       end loop;\n \n       Write_Line (\"end of List of Sources.\");\n@@ -1557,7 +1549,7 @@ package body Prj.Env is\n       Extended_Body_Name : String :=\n         Name & Body_Suffix_Of (In_Tree, \"ada\", Main_Project.Naming);\n \n-      Unit : Unit_Data;\n+      Unit : Unit_Index;\n \n       Current_Name      : File_Name_Type;\n       The_Original_Name : File_Name_Type;\n@@ -1580,11 +1572,9 @@ package body Prj.Env is\n       Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n       The_Body_Name := Name_Find;\n \n-      for Current in reverse Unit_Table.First ..\n-                             Unit_Table.Last (In_Tree.Units)\n-      loop\n-         Unit := In_Tree.Units.Table (Current);\n+      Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n \n+      while Unit /= null loop\n          --  Case of a body present\n \n          if Unit.File_Names (Impl) /= null then\n@@ -1618,6 +1608,8 @@ package body Prj.Env is\n                exit;\n             end if;\n          end if;\n+\n+         Unit := Units_Htable.Get_Next (In_Tree.Units_HT);\n       end loop;\n \n       --  Get the ultimate extending project"}, {"sha": "7565420a59093d10556ec27507f97adb76d46cd7", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 129, "deletions": 217, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -233,7 +233,6 @@ package body Prj.Nmsc is\n       Kind                : Source_Kind;\n       File_Name           : File_Name_Type;\n       Display_File        : File_Name_Type;\n-      Lang_Kind           : Language_Kind;\n       Naming_Exception    : Boolean := False;\n       Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Language_List := null;\n@@ -665,7 +664,6 @@ package body Prj.Nmsc is\n       Kind                : Source_Kind;\n       File_Name           : File_Name_Type;\n       Display_File        : File_Name_Type;\n-      Lang_Kind           : Language_Kind;\n       Naming_Exception    : Boolean := False;\n       Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Language_List := null;\n@@ -675,6 +673,7 @@ package body Prj.Nmsc is\n       Source_To_Replace   : Source_Id := No_Source)\n    is\n       Config   : constant Language_Config := Lang_Id.Config;\n+      UData    : Unit_Index;\n \n    begin\n       Id := new Source_Data;\n@@ -683,7 +682,7 @@ package body Prj.Nmsc is\n          Write_Str (\"Adding source File: \");\n          Write_Str (Get_Name_String (File_Name));\n \n-         if Lang_Kind = Unit_Based then\n+         if Lang_Id.Config.Kind = Unit_Based then\n             Write_Str (\" Unit: \");\n             --  ??? in gprclean, it seems we sometimes pass an empty Unit name\n             --  (see test extended_projects)\n@@ -699,29 +698,45 @@ package body Prj.Nmsc is\n \n       Id.Project             := Project;\n       Id.Language            := Lang_Id;\n-      Id.Lang_Kind           := Lang_Kind;\n-      Id.Compiled            := Lang_Id.Config.Compiler_Driver /=\n-                                                             Empty_File_Name;\n       Id.Kind                := Kind;\n       Id.Alternate_Languages := Alternate_Languages;\n       Id.Other_Part          := Other_Part;\n \n-      Id.Object_Exists       := Config.Object_Generated;\n-      Id.Object_Linked       := Config.Objects_Linked;\n-\n       if Other_Part /= No_Source then\n          Other_Part.Other_Part := Id;\n       end if;\n \n-      Id.Unit                := Unit;\n+      --  Add the source id to the Unit_Sources_HT hash table, if the unit name\n+      --  is not null.\n+\n+      if Unit /= No_Name then\n+         Unit_Sources_Htable.Set (In_Tree.Unit_Sources_HT, Unit, Id);\n+\n+         --  ??? Record_Unit has already fetched that earlier, so this isn't\n+         --  the most efficient way. But we can't really pass a parameter since\n+         --  Process_Exceptions_Unit_Based and Check_File haven't looked it up.\n+\n+         UData := Units_Htable.Get (In_Tree.Units_HT, Unit);\n+         if UData = No_Unit_Index then\n+            UData      := new Unit_Data;\n+            UData.Name := Unit;\n+            Units_Htable.Set (In_Tree.Units_HT, Unit, UData);\n+         end if;\n+\n+         UData.File_Names (Kind) := Id;\n+         Id.Unit                 := UData;\n+      end if;\n+\n       Id.Index               := Index;\n       Id.File                := File_Name;\n       Id.Display_File        := Display_File;\n-      Id.Dependency          := Lang_Id.Config.Dependency_Kind;\n-      Id.Dep_Name            := Dependency_Name (File_Name, Id.Dependency);\n+      Id.Dep_Name            := Dependency_Name\n+        (File_Name, Lang_Id.Config.Dependency_Kind);\n       Id.Naming_Exception    := Naming_Exception;\n \n-      if Id.Compiled and then Id.Object_Exists then\n+      if Is_Compilable (Id)\n+        and then Config.Object_Generated\n+      then\n          Id.Object   := Object_Name (File_Name, Config.Object_File_Suffix);\n          Id.Switches := Switches_Name (File_Name);\n       end if;\n@@ -731,13 +746,6 @@ package body Prj.Nmsc is\n          Source_Paths_Htable.Set (In_Tree.Source_Paths_HT, Path.Name, Id);\n       end if;\n \n-      --  Add the source id to the Unit_Sources_HT hash table, if the unit name\n-      --  is not null.\n-\n-      if Unit /= No_Name then\n-         Unit_Sources_Htable.Set (In_Tree.Unit_Sources_HT, Unit, Id);\n-      end if;\n-\n       --  Add the source to the language list\n \n       Id.Next_In_Lang := Lang_Id.First_Source;\n@@ -1152,13 +1160,6 @@ package body Prj.Nmsc is\n       Prev_Index : Language_Ptr := No_Language_Index;\n       --  The index of the previous language\n \n-      Current_Language : Name_Id := No_Name;\n-      --  The name of the language\n-\n-      procedure Get_Language_Index_Of (Language : Name_Id);\n-      --  Get the language index of Language, if Language is one of the\n-      --  languages of the project.\n-\n       procedure Process_Project_Level_Simple_Attributes;\n       --  Process the simple attributes at the project level\n \n@@ -1168,35 +1169,6 @@ package body Prj.Nmsc is\n       procedure Process_Packages;\n       --  Read the packages of the project\n \n-      ---------------------------\n-      -- Get_Language_Index_Of --\n-      ---------------------------\n-\n-      procedure Get_Language_Index_Of (Language : Name_Id) is\n-         Real_Language : Name_Id;\n-\n-      begin\n-         Get_Name_String (Language);\n-         To_Lower (Name_Buffer (1 .. Name_Len));\n-         Real_Language := Name_Find;\n-\n-         --  Nothing to do if the language is the same as the current language\n-\n-         if Current_Language /= Real_Language then\n-            Lang_Index := Project.Languages;\n-            while Lang_Index /= No_Language_Index loop\n-               exit when Lang_Index.Name = Real_Language;\n-               Lang_Index := Lang_Index.Next;\n-            end loop;\n-\n-            if Lang_Index = No_Language_Index then\n-               Current_Language := No_Name;\n-            else\n-               Current_Language := Real_Language;\n-            end if;\n-         end if;\n-      end Get_Language_Index_Of;\n-\n       ----------------------\n       -- Process_Packages --\n       ----------------------\n@@ -1249,7 +1221,8 @@ package body Prj.Nmsc is\n \n                      --  Get the name of the language\n \n-                     Get_Language_Index_Of (Element.Index);\n+                     Lang_Index := Get_Language_From_Name\n+                       (Project, Get_Name_String (Element.Index));\n \n                      if Lang_Index /= No_Language_Index then\n                         case Current_Array.Name is\n@@ -1357,7 +1330,8 @@ package body Prj.Nmsc is\n \n                      --  Get the name of the language\n \n-                     Get_Language_Index_Of (Element.Index);\n+                     Lang_Index := Get_Language_From_Name\n+                       (Project, Get_Name_String (Element.Index));\n \n                      if Lang_Index /= No_Language_Index then\n                         case Current_Array.Name is\n@@ -1698,7 +1672,8 @@ package body Prj.Nmsc is\n \n                   --  Get the name of the language\n \n-                  Get_Language_Index_Of (Element.Index);\n+                  Lang_Index := Get_Language_From_Name\n+                    (Project, Get_Name_String (Element.Index));\n \n                   if Lang_Index /= No_Language_Index then\n                      case Current_Array.Name is\n@@ -2215,7 +2190,8 @@ package body Prj.Nmsc is\n \n                --  Get the name of the language\n \n-               Get_Language_Index_Of (Element.Index);\n+               Lang_Index := Get_Language_From_Name\n+                 (Project, Get_Name_String (Element.Index));\n \n                if Lang_Index /= No_Language_Index then\n                   case Current_Array.Name is\n@@ -2370,16 +2346,14 @@ package body Prj.Nmsc is\n \n       Lang_Index := Project.Languages;\n       while Lang_Index /= No_Language_Index loop\n-         Current_Language := Lang_Index.Display_Name;\n-\n          --  For all languages, Compiler_Driver needs to be specified. This is\n          --  only necessary if we do intend to compiler (not in GPS for\n          --  instance)\n \n          if Compiler_Driver_Mandatory\n            and then Lang_Index.Config.Compiler_Driver = No_File\n          then\n-            Error_Msg_Name_1 := Current_Language;\n+            Error_Msg_Name_1 := Lang_Index.Display_Name;\n             Error_Msg\n               (Project,\n                In_Tree,\n@@ -2432,7 +2406,7 @@ package body Prj.Nmsc is\n             if Lang_Index.Config.Naming_Data.Spec_Suffix = No_File and then\n               Lang_Index.Config.Naming_Data.Body_Suffix = No_File\n             then\n-               Error_Msg_Name_1 := Current_Language;\n+               Error_Msg_Name_1 := Lang_Index.Display_Name;\n                Error_Msg\n                  (Project,\n                   In_Tree,\n@@ -2900,8 +2874,7 @@ package body Prj.Nmsc is\n                      Kind             => Kind,\n                      File_Name        => File_Name,\n                      Display_File     => File_Name_Type (Element.Value),\n-                     Naming_Exception => True,\n-                     Lang_Kind        => File_Based);\n+                     Naming_Exception => True);\n \n                else\n                   --  Check if the file name is already recorded for another\n@@ -3011,14 +2984,18 @@ package body Prj.Nmsc is\n             if Unit /= No_Name then\n \n                --  Check if the source already exists\n+               --  ??? In Ada_Only mode (Record_Unit), we use a htable for\n+               --  efficiency\n \n                Source_To_Replace := No_Source;\n                Iter := For_Each_Source (In_Tree);\n \n                loop\n                   Source := Prj.Element (Iter);\n                   exit when Source = No_Source\n-                    or else (Source.Unit = Unit and then Source.Index = Index);\n+                    or else (Source.Unit /= null\n+                             and then Source.Unit.Name = Unit\n+                             and then Source.Index = Index);\n                   Next (Iter);\n                end loop;\n \n@@ -3030,8 +3007,10 @@ package body Prj.Nmsc is\n                         Next (Iter);\n                         Source := Prj.Element (Iter);\n \n-                        exit when Source = No_Source or else\n-                          (Source.Unit = Unit and then Source.Index = Index);\n+                        exit when Source = No_Source\n+                          or else (Source.Unit /= null\n+                                   and then Source.Unit.Name = Unit\n+                                   and then Source.Index = Index);\n                      end loop;\n                   end if;\n \n@@ -3067,7 +3046,6 @@ package body Prj.Nmsc is\n                      Kind         => Kind,\n                      File_Name    => File_Name,\n                      Display_File => File_Name_Type (Element.Value.Value),\n-                     Lang_Kind    => Unit_Based,\n                      Other_Part   => Other_Part,\n                      Unit         => Unit,\n                      Index        => Index,\n@@ -3426,7 +3404,7 @@ package body Prj.Nmsc is\n                loop\n                   Src_Id := Prj.Element (Iter);\n                   exit when Src_Id = No_Source\n-                    or else Src_Id.Lang_Kind /= File_Based\n+                    or else Src_Id.Language.Config.Kind /= File_Based\n                     or else Src_Id.Kind /= Spec;\n                   Next (Iter);\n                end loop;\n@@ -4451,8 +4429,7 @@ package body Prj.Nmsc is\n             Interfaces     : String_List_Id := Lib_Interfaces.Values;\n             Interface_ALIs : String_List_Id := Nil_String;\n             Unit           : Name_Id;\n-            The_Unit_Id    : Unit_Index;\n-            UData          : Unit_Data;\n+            UData          : Unit_Index;\n \n             procedure Add_ALI_For (Source : File_Name_Type);\n             --  Add an ALI file name to the list of Interface ALIs\n@@ -4526,10 +4503,9 @@ package body Prj.Nmsc is\n                   Error_Msg_Name_1 := Unit;\n \n                   if Get_Mode = Ada_Only then\n-                     The_Unit_Id :=\n-                       Units_Htable.Get (In_Tree.Units_HT, Unit);\n+                     UData := Units_Htable.Get (In_Tree.Units_HT, Unit);\n \n-                     if The_Unit_Id = No_Unit_Index then\n+                     if UData = No_Unit_Index then\n                         Error_Msg\n                           (Project, In_Tree,\n                            \"unknown unit %%\",\n@@ -4539,12 +4515,8 @@ package body Prj.Nmsc is\n                      else\n                         --  Check that the unit is part of the project\n \n-                        UData := In_Tree.Units.Table (The_Unit_Id);\n-\n                         if UData.File_Names (Impl) /= null\n-                          and then\n-                            UData.File_Names (Impl).Path.Name /=\n-                             Slash\n+                          and then UData.File_Names (Impl).Path.Name /= Slash\n                         then\n                            if Check_Project\n                              (UData.File_Names (Impl).Project,\n@@ -4625,8 +4597,10 @@ package body Prj.Nmsc is\n                      Iter := For_Each_Source (In_Tree, Project);\n \n                      loop\n-                        while Prj.Element (Iter) /= No_Source and then\n-                           Prj.Element (Iter).Unit /= Unit\n+                        while Prj.Element (Iter) /= No_Source\n+                          and then\n+                            (Prj.Element (Iter).Unit = null\n+                             or else Prj.Element (Iter).Unit.Name /= Unit)\n                         loop\n                            Next (Iter);\n                         end loop;\n@@ -6928,9 +6902,9 @@ package body Prj.Nmsc is\n             if Source.Naming_Exception\n               and then Source.Path = No_Path_Information\n             then\n-               if Source.Unit /= No_Name then\n+               if Source.Unit /= No_Unit_Index then\n                   Error_Msg_Name_1 := Name_Id (Source.Display_File);\n-                  Error_Msg_Name_2 := Name_Id (Source.Unit);\n+                  Error_Msg_Name_2 := Name_Id (Source.Unit.Name);\n                   Error_Msg\n                     (Project, In_Tree,\n                      \"source file %% for unit %% not found\",\n@@ -7360,7 +7334,7 @@ package body Prj.Nmsc is\n \n                --  Check if this is a subunit\n \n-               if Name_Loc.Source.Unit /= No_Name\n+               if Name_Loc.Source.Unit /= No_Unit_Index\n                  and then Name_Loc.Source.Kind = Impl\n                then\n                   Src_Ind := Sinput.P.Load_Project_File\n@@ -7411,7 +7385,8 @@ package body Prj.Nmsc is\n                exit when Source = No_Source;\n \n                if Unit /= No_Name\n-                 and then Source.Unit = Unit\n+                 and then Source.Unit /= No_Unit_Index\n+                 and then Source.Unit.Name = Unit\n                  and then\n                    ((Source.Kind = Spec and then Kind = Impl)\n                        or else\n@@ -7420,7 +7395,8 @@ package body Prj.Nmsc is\n                   Other_Part := Source;\n \n                elsif (Unit /= No_Name\n-                      and then Source.Unit = Unit\n+                      and then Source.Unit /= No_Unit_Index\n+                      and then Source.Unit.Name = Unit\n                       and then\n                         (Source.Kind = Kind\n                            or else\n@@ -7494,7 +7470,6 @@ package body Prj.Nmsc is\n                   In_Tree             => In_Tree,\n                   Project             => Project,\n                   Lang_Id             => Language,\n-                  Lang_Kind           => Lang_Kind,\n                   Kind                => Kind,\n                   Alternate_Languages => Alternate_Languages,\n                   File_Name           => File_Name,\n@@ -7687,26 +7662,26 @@ package body Prj.Nmsc is\n               (Name     => Source.File,\n                Location => No_Location,\n                Source   => Source,\n-               Except   => Source.Unit /= No_Name,\n+               Except   => Source.Unit /= No_Unit_Index,\n                Found    => False));\n \n          --  If this is an Ada exception, record in table Unit_Exceptions\n \n-         if Source.Unit /= No_Name then\n+         if Source.Unit /= No_Unit_Index then\n             declare\n                Unit_Except : Unit_Exception :=\n-                                Unit_Exceptions.Get (Source.Unit);\n+                                Unit_Exceptions.Get (Source.Unit.Name);\n \n             begin\n-               Unit_Except.Name := Source.Unit;\n+               Unit_Except.Name := Source.Unit.Name;\n \n                if Source.Kind = Spec then\n                   Unit_Except.Spec := Source.File;\n                else\n                   Unit_Except.Impl := Source.File;\n                end if;\n \n-               Unit_Exceptions.Set (Source.Unit, Unit_Except);\n+               Unit_Exceptions.Set (Source.Unit.Name, Unit_Except);\n             end;\n          end if;\n \n@@ -7738,105 +7713,65 @@ package body Prj.Nmsc is\n       procedure Mark_Excluded_Sources is\n          Source   : Source_Id := No_Source;\n          OK       : Boolean;\n-         Unit     : Unit_Data;\n          Excluded : File_Found := Excluded_Sources_Htable.Get_First;\n-\n-         procedure Exclude\n-           (Extended : Project_Id;\n-            Index    : Unit_Index;\n-            Kind     : Spec_Or_Body);\n-         --  If the current file (Excluded) belongs to the current project or\n-         --  one that the current project extends, then mark this file/unit as\n-         --  excluded. It is an error to locally remove a file from another\n-         --  project.\n-\n-         -------------\n-         -- Exclude --\n-         -------------\n-\n-         procedure Exclude\n-           (Extended : Project_Id;\n-            Index    : Unit_Index;\n-            Kind     : Spec_Or_Body)\n-         is\n-         begin\n-            if Extended = Project\n-              or else Is_Extending (Project, Extended)\n-            then\n-               OK := True;\n-\n-               if Index /= No_Unit_Index then\n-                  Unit.File_Names (Kind).Path.Name    := Slash;\n-                  Unit.File_Names (Kind).Naming_Exception := False;\n-                  In_Tree.Units.Table (Index) := Unit;\n-               end if;\n-\n-               if Source /= No_Source then\n-                  Source.Locally_Removed := True;\n-                  Source.In_Interfaces := False;\n-               end if;\n-\n-               if Current_Verbosity = High then\n-                  Write_Str (\"Removing file \");\n-                  Write_Line (Get_Name_String (Excluded.File));\n-               end if;\n-\n-               Add_Forbidden_File_Name (Excluded.File);\n-\n-            else\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"cannot remove a source from another project\",\n-                  Excluded.Location);\n-            end if;\n-         end Exclude;\n-\n-      --  Start of processing for Mark_Excluded_Sources\n-\n+         Index    : Unit_Index;\n       begin\n          while Excluded /= No_File_Found loop\n             OK     := False;\n \n-            case Get_Mode is\n-            when Ada_Only =>\n+            --  ??? Don't we have a hash table to map files to Source_Id ?\n+            Iter := For_Each_Source (In_Tree);\n+            loop\n+               Source := Prj.Element (Iter);\n+               exit when Source = No_Source;\n \n-               --  ??? This loop could be the same as for Multi_Language if\n-               --  we were setting In_Tree.First_Source when we search for\n-               --  Ada sources (basically once we have removed the use of\n-               --  Project.Ada_Sources).\n+               if Source.File = Excluded.File then\n+                  if Source.Project = Project\n+                    or else Is_Extending (Project, Source.Project)\n+                  then\n+                     OK := True;\n+\n+                     if Source.Unit /= No_Unit_Index then\n+                        Index :=\n+                          Units_Htable.Get\n+                            (In_Tree.Units_HT, Source.Unit.Name);\n+                        if Index.File_Names (Source.Kind) /= null then\n+                           Index.File_Names (Source.Kind).Path.Name := Slash;\n+                           Index.File_Names (Source.Kind).Naming_Exception :=\n+                             False;\n+\n+                           --  ??? Should we simply set (can be done from the\n+                           --  source)\n+                           --  Index.File_Names (Source.Kind) := null;\n+                        end if;\n+                     end if;\n \n-               For_Each_Unit :\n-               for Index in Unit_Table.First ..\n-                 Unit_Table.Last (In_Tree.Units)\n-               loop\n-                  Unit := In_Tree.Units.Table (Index);\n+                     if Source /= No_Source then\n+                        Source.Locally_Removed := True;\n+                        Source.In_Interfaces := False;\n+                     end if;\n \n-                  for Kind in Spec_Or_Body'Range loop\n-                     if Unit.File_Names (Kind) /= null\n-                       and then Unit.File_Names (Kind).File = Excluded.File\n-                     then\n-                        Exclude (Unit.File_Names (Kind).Project, Index, Kind);\n-                        exit For_Each_Unit;\n+                     if Current_Verbosity = High then\n+                        Write_Str (\"Removing file \");\n+                        Write_Line (Get_Name_String (Excluded.File));\n                      end if;\n-                  end loop;\n-               end loop For_Each_Unit;\n \n-            when Multi_Language =>\n-               Iter := For_Each_Source (In_Tree);\n-               loop\n-                  Source := Prj.Element (Iter);\n-                  exit when Source = No_Source;\n+                     Add_Forbidden_File_Name (Excluded.File);\n \n-                  if Source.File = Excluded.File then\n-                     Exclude (Source.Project, No_Unit_Index, Spec);\n-                     exit;\n+                  else\n+                     Error_Msg\n+                       (Project, In_Tree,\n+                        \"cannot remove a source from another project\",\n+                        Excluded.Location);\n                   end if;\n \n-                  Next (Iter);\n-               end loop;\n+                  exit;\n+               end if;\n \n-               OK := OK or Excluded.Found;\n-            end case;\n+               Next (Iter);\n+            end loop;\n+\n+            OK := OK or Excluded.Found;\n \n             if not OK then\n                Err_Vars.Error_Msg_File_1 := Excluded.File;\n@@ -7898,10 +7833,11 @@ package body Prj.Nmsc is\n                Src_Id := Prj.Element (Iter);\n                exit when Src_Id = No_Source;\n \n-               if Src_Id.Compiled and then Src_Id.Object_Exists\n+               if Is_Compilable (Src_Id)\n+                 and then Src_Id.Language.Config.Object_Generated\n                  and then Is_Extending (Project, Src_Id.Project)\n                then\n-                  if Src_Id.Unit = No_Name then\n+                  if Src_Id.Unit = No_Unit_Index then\n                      if Src_Id.Kind = Impl then\n                         Check_Object (Src_Id);\n                      end if;\n@@ -8081,10 +8017,9 @@ package body Prj.Nmsc is\n          Unit_Kind    : Spec_Or_Body;\n          Needs_Pragma : Boolean)\n       is\n-         The_Unit      : Unit_Index :=\n+         --  ??? Add_Source will look it up again, can we do that only once ?\n+         UData         : constant Unit_Index :=\n                            Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n-         UData         : Unit_Data;\n-         Kind          : Source_Kind;\n          Source        : Source_Id;\n          To_Record     : Boolean := False;\n          The_Location  : Source_Ptr := Location;\n@@ -8101,16 +8036,13 @@ package body Prj.Nmsc is\n          --  unit kind (spec or body), or what is in the unit list is a unit of\n          --  a project we are extending.\n \n-         if The_Unit /= No_Unit_Index then\n-            UData := In_Tree.Units.Table (The_Unit);\n-\n+         if UData /= No_Unit_Index then\n             if UData.File_Names (Unit_Kind) = null\n               or else\n-                ((UData.File_Names (Unit_Kind).File = Canonical_File\n-                  and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n-                 or else UData.File_Names (Unit_Kind).File = No_File\n-                 or else Is_Extending\n-                   (Project.Extends, UData.File_Names (Unit_Kind).Project))\n+                (UData.File_Names (Unit_Kind).File = Canonical_File\n+                 and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n+              or else Is_Extending\n+                (Project.Extends, UData.File_Names (Unit_Kind).Project)\n             then\n                if UData.File_Names (Unit_Kind) /= null\n                  and then UData.File_Names (Unit_Kind).Path.Name = Slash\n@@ -8120,7 +8052,6 @@ package body Prj.Nmsc is\n                end if;\n \n                To_Record       := True;\n-               Source_Recorded := True;\n \n             --  If the same file is already in the list, do not add it again\n \n@@ -8180,43 +8111,26 @@ package body Prj.Nmsc is\n                   Location);\n \n             else\n-               UData.Name := Unit_Name;\n-               Unit_Table.Increment_Last (In_Tree.Units);\n-               The_Unit := Unit_Table.Last (In_Tree.Units);\n-               Units_Htable.Set (In_Tree.Units_HT, Unit_Name, The_Unit);\n-\n-               Source_Recorded := True;\n                To_Record := True;\n             end if;\n          end if;\n \n          if To_Record then\n             Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n-\n-            case Unit_Kind is\n-               when Impl      =>\n-                  Kind := Impl;\n-               when Spec  =>\n-                  Kind := Spec;\n-            end case;\n-\n             Add_Source\n               (Id                  => Source,\n                In_Tree             => In_Tree,\n                Project             => Project,\n                Lang_Id             => Ada_Language,\n-               Lang_Kind           => Unit_Based,\n                File_Name           => Canonical_File,\n                Display_File        => File_Name,\n                Unit                => Unit_Name,\n                Path                => (Canonical_Path, Path_Name),\n                Naming_Exception    => Needs_Pragma,\n-               Kind                => Kind,\n+               Kind                => Unit_Kind,\n                Index               => Unit_Ind,\n                Other_Part          => No_Source);  --  ??? Can we find file ?\n-\n-            UData.File_Names (Unit_Kind) := Source;\n-            In_Tree.Units.Table (The_Unit) := UData;\n+            Source_Recorded := True;\n          end if;\n       end Record_Unit;\n \n@@ -8415,8 +8329,7 @@ package body Prj.Nmsc is\n    is\n       Conv          : Array_Element_Id;\n       Unit          : Name_Id;\n-      The_Unit_Id   : Unit_Index;\n-      The_Unit_Data : Unit_Data;\n+      The_Unit_Data : Unit_Index;\n       Location      : Source_Ptr;\n \n    begin\n@@ -8427,14 +8340,13 @@ package body Prj.Nmsc is\n          Get_Name_String (Unit);\n          To_Lower (Name_Buffer (1 .. Name_Len));\n          Unit := Name_Find;\n-         The_Unit_Id := Units_Htable.Get (In_Tree.Units_HT, Unit);\n+         The_Unit_Data := Units_Htable.Get (In_Tree.Units_HT, Unit);\n          Location := In_Tree.Array_Elements.Table (Conv).Value.Location;\n \n-         if The_Unit_Id = No_Unit_Index then\n+         if The_Unit_Data = No_Unit_Index then\n             Error_Msg (Project, In_Tree, \"?unknown unit %%\", Location);\n \n          else\n-            The_Unit_Data := In_Tree.Units.Table (The_Unit_Id);\n             Error_Msg_Name_2 :=\n               In_Tree.Array_Elements.Table (Conv).Value.Value;\n "}, {"sha": "e5097908274600d13046d098ac60be691401335b", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -321,9 +321,8 @@ package body Prj.Proc is\n             Source1 := Prj.Element (Iter);\n             exit when Source1 = No_Source;\n \n-            Name := Source1.Unit;\n-\n-            if Name /= No_Name then\n+            if Source1.Unit /= No_Unit_Index then\n+               Name := Source1.Unit.Name;\n                Source2 := Unit_Htable.Get (Name);\n \n                if Source2 = No_Source then"}, {"sha": "d3c29c9d3704f4f10cbabf8d8617ed1d18fd4bb0", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -149,6 +149,9 @@ package body Prj is\n    procedure Free_List (Languages : in out Language_List);\n    --  Free memory allocated for the list of languages or sources\n \n+   procedure Free_Units (Table : in out Units_Htable.Instance);\n+   --  Free memory allocated for unit information in the project\n+\n    procedure Language_Changed (Iter : in out Source_Iterator);\n    procedure Project_Changed (Iter : in out Source_Iterator);\n    --  Called when a new project or language was selected for this iterator.\n@@ -638,21 +641,10 @@ package body Prj is\n \n    function Is_A_Language\n      (Project       : Project_Id;\n-      Language_Name : Name_Id) return Boolean\n-   is\n-      Lang_Ind : Language_Ptr;\n-\n+      Language_Name : Name_Id) return Boolean is\n    begin\n-      Lang_Ind := Project.Languages;\n-      while Lang_Ind /= No_Language_Index loop\n-         if Lang_Ind.Name = Language_Name then\n-            return True;\n-         end if;\n-\n-         Lang_Ind := Lang_Ind.Next;\n-      end loop;\n-\n-      return False;\n+      return Get_Language_From_Name\n+        (Project, Get_Name_String (Language_Name)) /= null;\n    end Is_A_Language;\n \n    ------------------\n@@ -860,6 +852,11 @@ package body Prj is\n       while Source /= No_Source loop\n          Tmp := Source.Next_In_Lang;\n          Free_List (Source.Alternate_Languages);\n+\n+         if Source.Unit /= null then\n+            Source.Unit.File_Names (Source.Kind) := null;\n+         end if;\n+\n          Unchecked_Free (Source);\n          Source := Tmp;\n       end loop;\n@@ -907,6 +904,32 @@ package body Prj is\n       end loop;\n    end Free_List;\n \n+   ----------------\n+   -- Free_Units --\n+   ----------------\n+\n+   procedure Free_Units (Table : in out Units_Htable.Instance) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Unit_Data, Unit_Index);\n+      Unit : Unit_Index;\n+   begin\n+      Unit := Units_Htable.Get_First (Table);\n+\n+      while Unit /= No_Unit_Index loop\n+         if Unit.File_Names (Spec) /= null then\n+            Unit.File_Names (Spec).Unit := No_Unit_Index;\n+         end if;\n+         if Unit.File_Names (Impl) /= null then\n+            Unit.File_Names (Impl).Unit := No_Unit_Index;\n+         end if;\n+\n+         Unchecked_Free (Unit);\n+         Unit := Units_Htable.Get_Next (Table);\n+      end loop;\n+\n+      Units_Htable.Reset (Table);\n+   end Free_Units;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -923,12 +946,11 @@ package body Prj is\n          Array_Element_Table.Free (Tree.Array_Elements);\n          Array_Table.Free (Tree.Arrays);\n          Package_Table.Free (Tree.Packages);\n-         Unit_Table.Free (Tree.Units);\n-         Units_Htable.Reset (Tree.Units_HT);\n          Source_Paths_Htable.Reset (Tree.Source_Paths_HT);\n          Unit_Sources_Htable.Reset (Tree.Unit_Sources_HT);\n \n          Free_List (Tree.Projects, Free_Project => True);\n+         Free_Units (Tree.Units_HT);\n \n          --  Private part\n \n@@ -961,12 +983,11 @@ package body Prj is\n       Array_Element_Table.Init      (Tree.Array_Elements);\n       Array_Table.Init              (Tree.Arrays);\n       Package_Table.Init            (Tree.Packages);\n-      Unit_Table.Init               (Tree.Units);\n-      Units_Htable.Reset            (Tree.Units_HT);\n       Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n       Unit_Sources_Htable.Reset     (Tree.Unit_Sources_HT);\n \n       Free_List (Tree.Projects, Free_Project => True);\n+      Free_Units (Tree.Units_HT);\n \n       --  Private part table\n \n@@ -1427,6 +1448,42 @@ package body Prj is\n       For_All_Projects (Project, Dummy);\n    end Compute_All_Imported_Projects;\n \n+   -------------------\n+   -- Is_Compilable --\n+   -------------------\n+\n+   function Is_Compilable (Source : Source_Id) return Boolean is\n+   begin\n+      return Source.Language.Config.Compiler_Driver /= Empty_File_Name;\n+   end Is_Compilable;\n+\n+   ----------------------------\n+   -- Get_Language_From_Name --\n+   ----------------------------\n+\n+   function Get_Language_From_Name\n+     (Project : Project_Id; Name : String) return Language_Ptr\n+   is\n+      N : Name_Id;\n+      Result : Language_Ptr;\n+   begin\n+      Name_Len := Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Name;\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      N := Name_Find;\n+\n+      Result := Project.Languages;\n+      while Result /= No_Language_Index loop\n+         if Result.Name = N then\n+            return Result;\n+         end if;\n+\n+         Result := Result.Next;\n+      end loop;\n+\n+      return No_Language_Index;\n+   end Get_Language_From_Name;\n+\n begin\n    --  Make sure that the standard config and user project file extensions are\n    --  compatible with canonical case file naming."}, {"sha": "3dd629634c1f78fdd5e36754f5b3560f9624c619", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 23, "deletions": 44, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a66a7661d4f7686ea0e4dea661926f7fee21653/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=5a66a7661d4f7686ea0e4dea661926f7fee21653", "patch": "@@ -307,6 +307,11 @@ package Prj is\n    No_Language_Index : constant Language_Ptr := null;\n    --  Constant indicating that there is no language data\n \n+   function Get_Language_From_Name\n+     (Project : Project_Id; Name : String) return Language_Ptr;\n+   --  Get a language from a project. This might return null if no such\n+   --  language exists in the project\n+\n    Max_Header_Num : constant := 6150;\n    type Header_Num is range 0 .. Max_Header_Num;\n    --  Size for hash table below. The upper bound is an arbitrary value, the\n@@ -392,6 +397,11 @@ package Prj is\n    type Source_Data;\n    type Source_Id is access all Source_Data;\n \n+   function Is_Compilable (Source : Source_Id) return Boolean;\n+   pragma Inline (Is_Compilable);\n+   --  Return True if we know how to compile Source (ie if a compiler is\n+   --  defined). This doesn't indicate whether the source should be compiled\n+\n    No_Source : constant Source_Id := null;\n \n    type Path_Syntax_Kind is\n@@ -615,6 +625,17 @@ package Prj is\n    end record;\n \n    type Source_Kind is (Spec, Impl, Sep);\n+   subtype Spec_Or_Body is Source_Kind range Spec .. Impl;\n+\n+   type File_Names_Data is array (Spec_Or_Body) of Source_Id;\n+   type Unit_Data is record\n+      Name       : Name_Id := No_Name;\n+      File_Names : File_Names_Data;\n+   end record;\n+   type Unit_Index is access Unit_Data;\n+   No_Unit_Index : constant Unit_Index := null;\n+   --  Name and File and Path names of a unit, with a reference to its\n+   --  GNAT Project File(s).\n \n    type Source_Data is record\n       Project             : Project_Id            := No_Project;\n@@ -624,13 +645,6 @@ package Prj is\n       --  Index of the language. This is an index into\n       --  Project_Tree.Languages_Data.\n \n-      Lang_Kind           : Language_Kind         := File_Based;\n-      --  Kind of the language\n-      --  ??? Should be in Language itself\n-\n-      Compiled            : Boolean               := True;\n-      --  False when there is no compiler for the language\n-\n       In_Interfaces       : Boolean               := True;\n       --  False when the source is not included in interfaces, when attribute\n       --  Interfaces is declared.\n@@ -645,14 +659,11 @@ package Prj is\n       Kind                : Source_Kind           := Spec;\n       --  Kind of the source: spec, body or subunit\n \n-      Dependency          : Dependency_File_Kind  := None;\n-      --  Kind of dependency: none, Makefile fragment or ALI file\n-\n       Other_Part          : Source_Id             := No_Source;\n       --  Source ID for the other part, if any: for a spec, indicates its body;\n       --  for a body, indicates its spec.\n \n-      Unit                : Name_Id               := No_Name;\n+      Unit                : Unit_Index               := No_Unit_Index;\n       --  Name of the unit, if language is unit based\n \n       Index               : Int                   := 0;\n@@ -686,13 +697,6 @@ package Prj is\n       --  Project where the object file is. This might be different from\n       --  Project when using extending project files.\n \n-      Object_Exists       : Boolean               := True;\n-      --  True if an object file exists\n-\n-      Object_Linked          : Boolean            := True;\n-      --  False if the object file is not use to link executables or included\n-      --  in libraries.\n-\n       Object              : File_Name_Type        := No_File;\n       --  File name of the object file\n \n@@ -737,15 +741,12 @@ package Prj is\n    No_Source_Data : constant Source_Data :=\n                       (Project                => No_Project,\n                        Language               => No_Language_Index,\n-                       Lang_Kind              => File_Based,\n-                       Compiled               => True,\n                        In_Interfaces          => True,\n                        Declared_In_Interfaces => False,\n                        Alternate_Languages    => null,\n                        Kind                   => Spec,\n-                       Dependency             => None,\n                        Other_Part             => No_Source,\n-                       Unit                   => No_Name,\n+                       Unit                   => No_Unit_Index,\n                        Index                  => 0,\n                        Locally_Removed        => False,\n                        Get_Object             => False,\n@@ -755,8 +756,6 @@ package Prj is\n                        Path                   => No_Path_Information,\n                        Source_TS              => Empty_Time_Stamp,\n                        Object_Project         => No_Project,\n-                       Object_Exists          => True,\n-                       Object_Linked          => True,\n                        Object                 => No_File,\n                        Current_Object_Path    => No_Path,\n                        Object_Path            => No_Path,\n@@ -1345,25 +1344,6 @@ package Prj is\n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr\n \n-   subtype Spec_Or_Body is Source_Kind range Spec .. Impl;\n-   type File_Names_Data is array (Spec_Or_Body) of Source_Id;\n-   type Unit_Index is new Nat;\n-   No_Unit_Index : constant Unit_Index := 0;\n-   type Unit_Data is record\n-      Name       : Name_Id    := No_Name;\n-      File_Names : File_Names_Data;\n-   end record;\n-   --  Name and File and Path names of a unit, with a reference to its\n-   --  GNAT Project File(s).\n-\n-   package Unit_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Unit_Data,\n-      Table_Index_Type     => Unit_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 100,\n-      Table_Increment      => 100);\n-   --  Table of all units in a project tree\n-\n    package Units_Htable is new Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Unit_Index,\n@@ -1417,7 +1397,6 @@ package Prj is\n          Arrays            : Array_Table.Instance;\n          Packages          : Package_Table.Instance;\n          Projects          : Project_List;\n-         Units             : Unit_Table.Instance;\n          Units_HT          : Units_Htable.Instance;\n          Source_Paths_HT   : Source_Paths_Htable.Instance;\n          Unit_Sources_HT   : Unit_Sources_Htable.Instance;"}]}