{"sha": "ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM1ZTY5ZGE1NjU5MzM1YjhmOGQ5NDJiMjliZDAxZGM3Mzg0YjZhZA==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2003-02-10T12:34:24Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2003-02-10T12:34:24Z"}, "message": "Makefile.in (sreal.o): Added.\n\n\t* Makefile.in (sreal.o): Added.\n\t(predict.o): Depends on sreal.h instead of real.h.\n\t* sreal.c: New file.\n\t* sreal.h: New file.\n\t* predict.c: Use sreal.c instead of real.c.\n\nFrom-SVN: r62630", "tree": {"sha": "8de9fc53d7c5e025943cb8ddb54de48abc65a501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8de9fc53d7c5e025943cb8ddb54de48abc65a501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/comments", "author": null, "committer": null, "parents": [{"sha": "637df4f4ba4066794c61f17133d820400fa34c8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637df4f4ba4066794c61f17133d820400fa34c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637df4f4ba4066794c61f17133d820400fa34c8a"}], "stats": {"total": 782, "additions": 721, "deletions": 61}, "files": [{"sha": "f1879ddcb1e12fc4e3812514e3685350f8341d0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "patch": "@@ -1,3 +1,11 @@\n+2003-02-10  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* Makefile.in (sreal.o): Added.\n+\t(predict.o): Depends on sreal.h instead of real.h.\n+\t* sreal.c: New file.\n+\t* sreal.h: New file.\n+\t* predict.c: Use sreal.c instead of real.c.\n+\n 2003-02-10  Nick Clifton  <nickc@redhat.com>\n \n \t* Contributed support for the Cirrus EP9312 \"Maverick\""}, {"sha": "57233cfe775eadfd9f10e6344692eeebbf8d0179", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "patch": "@@ -782,7 +782,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n- sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\t   \\\n+ sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n  alloc-pool.o et-forest.o\t\t\t\t\t\t   \\\n@@ -1685,9 +1685,10 @@ recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) function.\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(RECOG_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \\\n    varray.h function.h $(TM_P_H) $(GGC_H) gt-reg-stack.h\n+sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h \\\n+   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) sreal.h \\\n    $(PARAMS_H) $(TARGET_H) cfgloop.h\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "3a8ac17a9bf2a2ebf72cea805d59fba41c6dae47", "filename": "gcc/predict.c", "status": "modified", "additions": 52, "deletions": 59, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "patch": "@@ -48,16 +48,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"predict.h\"\n #include \"profile.h\"\n-#include \"real.h\"\n+#include \"sreal.h\"\n #include \"params.h\"\n #include \"target.h\"\n #include \"loop.h\"\n #include \"cfgloop.h\"\n \n /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n \t\t   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */\n-static REAL_VALUE_TYPE real_zero, real_one, real_almost_one, real_br_prob_base,\n-\t\t       real_inv_br_prob_base, real_one_half, real_bb_freq_max;\n+static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n+\t     real_inv_br_prob_base, real_one_half, real_bb_freq_max;\n \n /* Random guesstimation given names.  */\n #define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 10 - 1)\n@@ -905,7 +905,7 @@ note_prediction_to_br_prob ()\n typedef struct block_info_def\n {\n   /* Estimated frequency of execution of basic_block.  */\n-  REAL_VALUE_TYPE frequency;\n+  sreal frequency;\n \n   /* To keep queue of basic blocks to process.  */\n   basic_block next;\n@@ -923,7 +923,7 @@ typedef struct edge_info_def\n   /* In case edge is an loopback edge, the probability edge will be reached\n      in case header is.  Estimated number of iterations of the loop can be\n      then computed as 1 / (1 - back_edge_prob).  */\n-  REAL_VALUE_TYPE back_edge_prob;\n+  sreal back_edge_prob;\n   /* True if the edge is an loopback edge in the natural loop.  */\n   int back_edge:1;\n } *edge_info;\n@@ -968,7 +968,7 @@ propagate_freq (loop)\n   last = head;\n   for (bb = head; bb; bb = nextbb)\n     {\n-      REAL_VALUE_TYPE cyclic_probability, frequency;\n+      sreal cyclic_probability, frequency;\n \n       memcpy (&cyclic_probability, &real_zero, sizeof (real_zero));\n       memcpy (&frequency, &real_zero, sizeof (real_zero));\n@@ -988,40 +988,42 @@ propagate_freq (loop)\n \t  for (e = bb->pred; e; e = e->pred_next)\n \t    if (EDGE_INFO (e)->back_edge)\n \t      {\n-\t\tREAL_ARITHMETIC (cyclic_probability, PLUS_EXPR,\n-\t\t\t\t cyclic_probability,\n-\t\t\t\t EDGE_INFO (e)->back_edge_prob);\n+\t\tsreal_add (&cyclic_probability, &cyclic_probability,\n+\t\t\t   &EDGE_INFO (e)->back_edge_prob);\n \t      }\n \t    else if (!(e->flags & EDGE_DFS_BACK))\n \t      {\n-\t\tREAL_VALUE_TYPE tmp;\n+\t\tsreal tmp;\n \n \t\t/*  frequency += (e->probability\n \t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n \t\t\t\t  REG_BR_PROB_BASE);  */\n \n-\t\tREAL_VALUE_FROM_INT (tmp, e->probability, 0,\n-\t\t\t\t     TYPE_MODE (double_type_node));\n-\t\tREAL_ARITHMETIC (tmp, MULT_EXPR, tmp,\n-\t\t\t\t BLOCK_INFO (e->src)->frequency);\n-\t\tREAL_ARITHMETIC (tmp, MULT_EXPR, tmp, real_inv_br_prob_base);\n-\t\tREAL_ARITHMETIC (frequency, PLUS_EXPR, frequency, tmp);\n+\t\tsreal_init (&tmp, e->probability, 0);\n+\t\tsreal_mul (&tmp, &tmp, &BLOCK_INFO (e->src)->frequency);\n+\t\tsreal_mul (&tmp, &tmp, &real_inv_br_prob_base);\n+\t\tsreal_add (&frequency, &frequency, &tmp);\n \t      }\n \n-\t  if (REAL_VALUES_IDENTICAL (cyclic_probability, real_zero))\n-\t    memcpy (&BLOCK_INFO (bb)->frequency, &frequency, sizeof (frequency));\n+\t  if (sreal_compare (&cyclic_probability, &real_zero) == 0)\n+\t    {\n+\t      memcpy (&BLOCK_INFO (bb)->frequency, &frequency,\n+\t\t      sizeof (frequency));\n+\t    }\n \t  else\n \t    {\n-\t      if (REAL_VALUES_LESS (real_almost_one, cyclic_probability))\n-\t\tmemcpy (&cyclic_probability, &real_almost_one, sizeof (real_zero));\n+\t      if (sreal_compare (&cyclic_probability, &real_almost_one) > 0)\n+\t\t{\n+\t\t  memcpy (&cyclic_probability, &real_almost_one,\n+\t\t\t  sizeof (real_almost_one));\n+\t\t}\n \n-\t      /* BLOCK_INFO (bb)->frequency = frequency / (1 - cyclic_probability)\n-\t       */\n+\t      /* BLOCK_INFO (bb)->frequency = frequency \n+\t\t\t\t\t      / (1 - cyclic_probability) */\n \n-\t      REAL_ARITHMETIC (cyclic_probability, MINUS_EXPR, real_one,\n-\t\t\t   cyclic_probability);\n-\t      REAL_ARITHMETIC (BLOCK_INFO (bb)->frequency,\n-\t\t\t       RDIV_EXPR, frequency, cyclic_probability);\n+\t      sreal_sub (&cyclic_probability, &real_one, &cyclic_probability);\n+\t      sreal_div (&BLOCK_INFO (bb)->frequency,\n+\t\t\t &frequency, &cyclic_probability);\n \t    }\n \t}\n \n@@ -1031,18 +1033,16 @@ propagate_freq (loop)\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (e->dest == head)\n \t  {\n-\t    REAL_VALUE_TYPE tmp;\n+\t    sreal tmp;\n \n \t    /* EDGE_INFO (e)->back_edge_prob\n \t\t  = ((e->probability * BLOCK_INFO (bb)->frequency)\n \t\t     / REG_BR_PROB_BASE); */\n-\t    REAL_VALUE_FROM_INT (tmp, e->probability, 0,\n-\t\t\t\t TYPE_MODE (double_type_node));\n-\t    REAL_ARITHMETIC (tmp, MULT_EXPR, tmp,\n-\t\t\t     BLOCK_INFO (bb)->frequency);\n-\t    REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n-\t\t\t     MULT_EXPR, tmp, real_inv_br_prob_base);\n \n+\t    sreal_init (&tmp, e->probability, 0);\n+\t    sreal_mul (&tmp, &tmp, &BLOCK_INFO (bb)->frequency);\n+\t    sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n+\t\t       &tmp, &real_inv_br_prob_base);\n \t  }\n \n       /* Propagate to successor blocks.  */\n@@ -1160,21 +1160,19 @@ estimate_bb_frequencies (loops)\n      struct loops *loops;\n {\n   basic_block bb;\n-  REAL_VALUE_TYPE freq_max;\n-  enum machine_mode double_mode = TYPE_MODE (double_type_node);\n+  sreal freq_max;\n \n   if (flag_branch_probabilities)\n     counts_to_freqs ();\n   else\n     {\n-      REAL_VALUE_FROM_INT (real_zero, 0, 0, double_mode);\n-      REAL_VALUE_FROM_INT (real_one, 1, 0, double_mode);\n-      REAL_VALUE_FROM_INT (real_br_prob_base, REG_BR_PROB_BASE, 0, double_mode);\n-      REAL_VALUE_FROM_INT (real_bb_freq_max, BB_FREQ_MAX, 0, double_mode);\n-      REAL_VALUE_FROM_INT (real_one_half, 2, 0, double_mode);\n-      REAL_ARITHMETIC (real_one_half, RDIV_EXPR, real_one, real_one_half);\n-      REAL_ARITHMETIC (real_inv_br_prob_base, RDIV_EXPR, real_one, real_br_prob_base);\n-      REAL_ARITHMETIC (real_almost_one, MINUS_EXPR, real_one, real_inv_br_prob_base);\n+      sreal_init (&real_zero, 0, 0);\n+      sreal_init (&real_one, 1, 0);\n+      sreal_init (&real_br_prob_base, REG_BR_PROB_BASE, 0);\n+      sreal_init (&real_bb_freq_max, BB_FREQ_MAX, 0);\n+      sreal_init (&real_one_half, 1, -1);\n+      sreal_div (&real_inv_br_prob_base, &real_one, &real_br_prob_base);\n+      sreal_sub (&real_almost_one, &real_one, &real_inv_br_prob_base);\n \n       mark_dfs_back_edges ();\n       /* Fill in the probability values in flowgraph based on the REG_BR_PROB\n@@ -1215,11 +1213,10 @@ estimate_bb_frequencies (loops)\n \t  BLOCK_INFO (bb)->tovisit = 0;\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n-\t      REAL_VALUE_FROM_INT (EDGE_INFO (e)->back_edge_prob,\n-\t\t\t\t   e->probability, 0, double_mode);\n-\t      REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n-\t\t\t       MULT_EXPR, EDGE_INFO (e)->back_edge_prob,\n-\t\t\t       real_inv_br_prob_base);\n+\t      sreal_init (&EDGE_INFO (e)->back_edge_prob, e->probability, 0);\n+\t      sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n+\t\t\t &EDGE_INFO (e)->back_edge_prob,\n+\t\t\t &real_inv_br_prob_base);\n \t    }\n \t}\n \n@@ -1229,21 +1226,17 @@ estimate_bb_frequencies (loops)\n \n       memcpy (&freq_max, &real_zero, sizeof (real_zero));\n       FOR_EACH_BB (bb)\n-\tif (REAL_VALUES_LESS\n-\t    (freq_max, BLOCK_INFO (bb)->frequency))\n-\t  memcpy (&freq_max, &BLOCK_INFO (bb)->frequency,\n-\t\t  sizeof (freq_max));\n-\n-      REAL_ARITHMETIC (freq_max, RDIV_EXPR, real_bb_freq_max, freq_max);\n+\tif (sreal_compare (&freq_max, &BLOCK_INFO (bb)->frequency) < 0)\n+\t  memcpy (&freq_max, &BLOCK_INFO (bb)->frequency, sizeof (freq_max));\n \n+      sreal_div (&freq_max, &real_bb_freq_max, &freq_max);\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n \t{\n-\t  REAL_VALUE_TYPE tmp;\n+\t  sreal tmp;\n \n-\t  REAL_ARITHMETIC (tmp, MULT_EXPR, BLOCK_INFO (bb)->frequency,\n-\t\t\t   freq_max);\n-\t  REAL_ARITHMETIC (tmp, PLUS_EXPR, tmp, real_one_half);\n-\t  bb->frequency = REAL_VALUE_UNSIGNED_FIX (tmp);\n+\t  sreal_mul (&tmp, &BLOCK_INFO (bb)->frequency, &freq_max);\n+\t  sreal_add (&tmp, &tmp, &real_one_half);\n+\t  bb->frequency = sreal_to_int (&tmp);\n \t}\n \n       free_aux_for_blocks ();"}, {"sha": "54648eafeec1251ead377e74f90ad6e18ad60a89", "filename": "gcc/sreal.c", "status": "added", "additions": 591, "deletions": 0, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "patch": "@@ -0,0 +1,591 @@\n+/* Simple data type for positive real numbers for the GNU compiler.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This library supports positive real numbers and 0;\n+   inf and nan are NOT supported.\n+   It is written to be simple and fast.\n+\n+   Value of sreal is\n+\tx = sig * 2 ^ exp\n+   where \n+\tsig = significant\n+\t  (for < 64-bit machines sig = sig_lo + sig_hi * 2 ^ SREAL_PART_BITS)\n+\texp = exponent\n+\n+   One HOST_WIDE_INT is used for the significant on 64-bit (and more than\n+   64-bit) machines,\n+   otherwise two HOST_WIDE_INTs are used for the significant.\n+   Only a half of significant bits is used (in normalized sreals) so that we do\n+   not have problems with overflow, for example when c->sig = a->sig * b->sig.\n+   So the precission for 64-bit and 32-bit machines is 32-bit.\n+\t\t\t\n+   Invariant: The numbers are normalized before and after each call of sreal_*.\n+\n+   Normalized sreals:\n+   All numbers (except zero) meet following conditions:\n+\t SREAL_MIN_SIG <= sig && sig <= SREAL_MAX_SIG\n+\t-SREAL_MAX_EXP <= exp && exp <= SREAL_MAX_EXP \n+\n+   If the number would be too large, it is set to upper bounds of these\n+   conditions.\n+\n+   If the number is zero or would be too small it meets following conditions:\n+\tsig == 0 && exp == -SREAL_MAX_EXP\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"sreal.h\"\n+\n+void dump_sreal\t\t\tPARAMS ((FILE *, sreal *));\n+static inline void copy\t\tPARAMS ((sreal *, sreal *));\n+static inline void shift_right\tPARAMS ((sreal *, int));\n+static void normalize\t\tPARAMS ((sreal *));\n+\n+/* Print the content of struct sreal.  */\n+\n+void\n+dump_sreal (file, x)\n+     FILE *file;\n+     sreal *x;\n+{\n+#if SREAL_PART_BITS < 32\n+  fprintf (file, \"((\");\n+  fprintf (file, HOST_WIDE_INT_PRINT_UNSIGNED, x->sig_hi);\n+  fprintf (file, \" * 2^16 + \");\n+  fprintf (file, HOST_WIDE_INT_PRINT_UNSIGNED, x->sig_lo);\n+  fprintf (file, \") * 2^%d)\", x->exp);\n+#else\n+  fprintf (file, \"(\");\n+  fprintf (file, HOST_WIDE_INT_PRINT_UNSIGNED, x->sig);\n+  fprintf (file, \" * 2^%d)\", x->exp);\n+#endif\n+}\n+\n+/* Copy the sreal number.  */\n+\n+static inline void\n+copy (r, a)\n+     sreal *r;\n+     sreal *a;\n+{\n+#if SREAL_PART_BITS < 32\n+  r->sig_lo = a->sig_lo;\n+  r->sig_hi = a->sig_hi;\n+#else\n+  r->sig = a->sig;\n+#endif\n+  r->exp = a->exp;\n+}\n+\n+/* Shift X right by S bits.  Needed: 0 < S <= SREAL_BITS.\n+   When the most significant bit shifted out is 1, add 1 to X (rounding).  */\n+\n+static inline void\n+shift_right (x, s)\n+     sreal *x;\n+     int s;\n+{\n+#ifdef ENABLE_CHECKING\n+  if (s <= 0 || s > SREAL_BITS)\n+    abort ();\n+  if (x->exp + s > SREAL_MAX_EXP)\n+    {\n+      /* Exponent should never be so large because shift_right is used only by\n+\t sreal_add and sreal_sub ant thus the number cannot be shifted out from\n+\t exponent range.  */\n+      abort ();\n+    }\n+#endif\n+\n+  x->exp += s;\n+\n+#if SREAL_PART_BITS < 32\n+  if (s > SREAL_PART_BITS)\n+    {\n+      s -= SREAL_PART_BITS;\n+      x->sig_hi += (uhwi) 1 << (s - 1);\n+      x->sig_lo = x->sig_hi >> s;\n+      x->sig_hi = 0;\n+    }\n+  else\n+    {\n+      x->sig_lo += (uhwi) 1 << (s - 1);\n+      if (x->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n+\t{\n+\t  x->sig_hi++;\n+\t  x->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n+\t}\n+      x->sig_lo >>= s;\n+      x->sig_lo |= (x->sig_hi & (((uhwi) 1 << s) - 1)) << (SREAL_PART_BITS - s);\n+      x->sig_hi >>= s;\n+    }\n+#else\n+  x->sig += (uhwi) 1 << (s - 1);\n+  x->sig >>= s;\n+#endif\n+}\n+\n+/* Normalize *X.  */\n+\n+static void\n+normalize (x)\n+     sreal *x;\n+{\n+#if SREAL_PART_BITS < 32\n+  int shift;\n+  HOST_WIDE_INT mask;\n+  \n+  if (x->sig_lo == 0 && x->sig_hi == 0)\n+    {\n+      x->exp = -SREAL_MAX_EXP;\n+    }\n+  else if (x->sig_hi < SREAL_MIN_SIG)\n+    {\n+      if (x->sig_hi == 0)\n+\t{\n+\t  /* Move lower part of significant to higher part.  */\n+\t  x->sig_hi = x->sig_lo;\n+\t  x->sig_lo = 0;\n+\t  x->exp -= SREAL_PART_BITS;\n+\t}\n+      shift = 0;\n+      while (x->sig_hi < SREAL_MIN_SIG)\n+\t{\n+\t  x->sig_hi <<= 1;\n+\t  x->exp--;\n+\t  shift++;\n+\t}\n+      /* Check underflow.  */\n+      if (x->exp < -SREAL_MAX_EXP)\n+\t{\n+\t  x->exp = -SREAL_MAX_EXP;\n+\t  x->sig_hi = 0;\n+\t  x->sig_lo = 0;\n+\t}\n+      else if (shift)\n+\t{\n+\t  mask = (1 << SREAL_PART_BITS) - (1 << (SREAL_PART_BITS - shift));\n+\t  x->sig_hi |= (x->sig_lo & mask) >> (SREAL_PART_BITS - shift);\n+\t  x->sig_lo = (x->sig_lo << shift) & (((uhwi) 1 << SREAL_PART_BITS) - 1);\n+\t}\n+    }\n+  else if (x->sig_hi > SREAL_MAX_SIG)\n+    {\n+      unsigned HOST_WIDE_INT tmp = x->sig_hi;\n+\n+      /* Find out how many bits will be shifted.  */\n+      shift = 0;\n+      do\n+\t{\n+\t  tmp >>= 1;\n+\t  shift++;\n+\t}\n+      while (tmp > SREAL_MAX_SIG);\n+\n+      /* Round the number.  */\n+      x->sig_lo += (uhwi) 1 << (shift - 1);\n+\n+      x->sig_lo >>= shift;\n+      x->sig_lo += ((x->sig_hi & (((uhwi) 1 << shift) - 1))\n+\t\t    << (SREAL_PART_BITS - shift));\n+      x->sig_hi >>= shift;\n+      x->exp += shift;\n+      if (x->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n+\t{\n+\t  x->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n+\t  x->sig_hi++;\n+\t  if (x->sig_hi > SREAL_MAX_SIG)\n+\t    {\n+\t      /* x->sig_hi was SREAL_MAX_SIG before increment\n+\t\t so now last bit is zero.  */\n+\t      x->sig_hi >>= 1;\n+\t      x->sig_lo >>= 1;\n+\t      x->exp++;\n+\t    }\n+\t}\n+\n+      /* Check overflow.  */\n+      if (x->exp > SREAL_MAX_EXP)\n+\t{\n+\t  x->exp = SREAL_MAX_EXP;\n+\t  x->sig_hi = SREAL_MAX_SIG;\n+\t  x->sig_lo = SREAL_MAX_SIG;\n+\t}\n+    }\n+#else\n+  if (x->sig == 0)\n+    {\n+      x->exp = -SREAL_MAX_EXP;\n+    }\n+  else if (x->sig < SREAL_MIN_SIG)\n+    {\n+      do\n+\t{\n+\t  x->sig <<= 1;\n+\t  x->exp--;\n+\t}\n+      while (x->sig < SREAL_MIN_SIG);\n+\n+      /* Check underflow.  */\n+      if (x->exp < -SREAL_MAX_EXP)\n+\t{\n+\t  x->exp = -SREAL_MAX_EXP;\n+\t  x->sig = 0;\n+\t}\n+    }\n+  else if (x->sig > SREAL_MAX_SIG)\n+    {\n+      int last_bit;\n+      do\n+\t{\n+\t  last_bit = x->sig & 1;\n+\t  x->sig >>= 1;\n+\t  x->exp++;\n+\t}\n+      while (x->sig > SREAL_MAX_SIG);\n+\n+      /* Round the number.  */\n+      x->sig += last_bit;\n+      if (x->sig > SREAL_MAX_SIG)\n+\t{\n+\t  x->sig >>= 1;\n+\t  x->exp++;\n+\t}\n+\n+      /* Check overflow.  */\n+      if (x->exp > SREAL_MAX_EXP)\n+\t{\n+\t  x->exp = SREAL_MAX_EXP;\n+\t  x->sig = SREAL_MAX_SIG;\n+\t}\n+    }\n+#endif\n+}\n+\n+/* Set *R to SIG * 2 ^ EXP.  Return R.  */\n+\n+sreal *\n+sreal_init (r, sig, exp)\n+     sreal *r;\n+     unsigned HOST_WIDE_INT sig;\n+     signed int exp;\n+{\n+#if SREAL_PART_BITS < 32\n+  r->sig_lo = 0;\n+  r->sig_hi = sig;\n+  r->exp = exp - 16;\n+#else\n+  r->sig = sig;\n+  r->exp = exp;\n+#endif\n+  normalize (r);\n+  return r;\n+}\n+\n+/* Return integer value of *R.  */\n+\n+HOST_WIDE_INT\n+sreal_to_int (r)\n+     sreal *r;\n+{\n+#if SREAL_PART_BITS < 32\n+  if (r->exp <= -SREAL_BITS)\n+    return 0;\n+  if (r->exp >= 0)\n+    return MAX_HOST_WIDE_INT;\n+  return ((r->sig_hi << SREAL_PART_BITS) + r->sig_lo) >> -r->exp;\n+#else\n+  if (r->exp <= -SREAL_BITS)\n+    return 0;\n+  if (r->exp >= SREAL_PART_BITS)\n+    return MAX_HOST_WIDE_INT;\n+  if (r->exp > 0)\n+    return r->sig << r->exp;\n+  if (r->exp < 0)\n+    return r->sig >> -r->exp;\n+  return r->sig;\n+#endif\n+}\n+\n+/* Compare *A and *B. Return -1 if *A < *B, 1 if *A > *B and 0 if *A == *B.  */\n+\n+int\n+sreal_compare (a, b)\n+     sreal *a;\n+     sreal *b;\n+{\n+  if (a->exp > b->exp)\n+    return 1;\n+  if (a->exp < b->exp)\n+    return -1;\n+#if SREAL_PART_BITS < 32\n+  if (a->sig_hi > b->sig_hi)\n+    return 1;\n+  if (a->sig_hi < b->sig_hi)\n+    return -1;\n+  if (a->sig_lo > b->sig_lo)\n+    return 1;\n+  if (a->sig_lo < b->sig_lo)\n+    return -1;\n+#else\n+  if (a->sig > b->sig)\n+    return 1;\n+  if (a->sig < b->sig)\n+    return -1;\n+#endif\n+  return 0;\n+}\n+\n+/* *R = *A + *B.  Return R.  */\n+\n+sreal *\n+sreal_add (r, a, b)\n+  sreal *r;\n+  sreal *a;\n+  sreal *b;\n+{\n+  int dexp;\n+  sreal tmp;\n+  sreal *bb;\n+\n+  if (sreal_compare (a, b) < 0)\n+    {\n+      sreal *swap;\n+      swap = a;\n+      a = b;\n+      b = swap;\n+    }\n+\n+  dexp = a->exp - b->exp;\n+  r->exp = a->exp;\n+  if (dexp > SREAL_BITS)\n+    {\n+#if SREAL_PART_BITS < 32\n+      r->sig_hi = a->sig_hi;\n+      r->sig_lo = a->sig_lo;\n+#else\n+      r->sig = a->sig;\n+#endif\n+      return r;\n+    }\n+\n+  if (dexp == 0)\n+    bb = b;\n+  else\n+    {\n+      copy (&tmp, b);\n+      shift_right (&tmp, dexp);\n+      bb = &tmp;\n+    }\n+\n+#if SREAL_PART_BITS < 32\n+  r->sig_hi = a->sig_hi + bb->sig_hi;\n+  r->sig_lo = a->sig_lo + bb->sig_lo;\n+  if (r->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n+    {\n+      r->sig_hi++;\n+      r->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n+    }\n+#else\n+  r->sig = a->sig + bb->sig;\n+#endif\n+  normalize (r);\n+  return r;\n+}\n+\n+/* *R = *A - *B.  Return R.  */\n+\n+sreal *\n+sreal_sub (r, a, b)\n+  sreal *r;\n+  sreal *a;\n+  sreal *b;\n+{\n+  int dexp;\n+  sreal tmp;\n+  sreal *bb;\n+\n+  if (sreal_compare (a, b) < 0)\n+    {\n+      abort ();\n+    }\n+\n+  dexp = a->exp - b->exp;\n+  r->exp = a->exp;\n+  if (dexp > SREAL_BITS)\n+    {\n+#if SREAL_PART_BITS < 32\n+      r->sig_hi = a->sig_hi;\n+      r->sig_lo = a->sig_lo;\n+#else\n+      r->sig = a->sig;\n+#endif\n+      return r;\n+    }\n+  if (dexp == 0)\n+    bb = b;\n+  else\n+    {\n+      copy (&tmp, b);\n+      shift_right (&tmp, dexp);\n+      bb = &tmp;\n+    }\n+\n+#if SREAL_PART_BITS < 32\n+  if (a->sig_lo < bb->sig_lo)\n+    {\n+      r->sig_hi = a->sig_hi - bb->sig_hi - 1;\n+      r->sig_lo = a->sig_lo + ((uhwi) 1 << SREAL_PART_BITS) - bb->sig_lo;\n+    }\n+  else\n+    {\n+      r->sig_hi = a->sig_hi - bb->sig_hi;\n+      r->sig_lo = a->sig_lo - bb->sig_lo;\n+    }\n+#else\n+  r->sig = a->sig - bb->sig;\n+#endif\n+  normalize (r);\n+  return r;\n+}\n+\n+/* *R = *A * *B.  Return R.  */\n+\n+sreal *\n+sreal_mul (r, a, b)\n+     sreal *r;\n+     sreal *a;\n+     sreal *b;\n+{\n+#if SREAL_PART_BITS < 32\n+  if (a->sig_hi < SREAL_MIN_SIG || b->sig_hi < SREAL_MIN_SIG)\n+    {\n+      r->sig_lo = 0;\n+      r->sig_hi = 0;\n+      r->exp = -SREAL_MAX_EXP;\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT tmp1, tmp2, tmp3;\n+      if (sreal_compare (a, b) < 0)\n+\t{\n+\t  sreal *swap;\n+\t  swap = a;\n+\t  a = b;\n+\t  b = swap;\n+\t}\n+\n+      r->exp = a->exp + b->exp + SREAL_PART_BITS;\n+\n+      tmp1 = a->sig_lo * b->sig_lo;\n+      tmp2 = a->sig_lo * b->sig_hi;\n+      tmp3 = a->sig_hi * b->sig_lo + (tmp1 >> SREAL_PART_BITS);\n+\n+      r->sig_hi = a->sig_hi * b->sig_hi;\n+      r->sig_hi += (tmp2 >> SREAL_PART_BITS) + (tmp3 >> SREAL_PART_BITS);\n+      tmp2 &= ((uhwi) 1 << SREAL_PART_BITS) - 1;\n+      tmp3 &= ((uhwi) 1 << SREAL_PART_BITS) - 1;\n+      tmp1 = tmp2 + tmp3;\n+\n+      r->sig_lo = tmp1 & (((uhwi) 1 << SREAL_PART_BITS) - 1);\n+      r->sig_hi += tmp1 >> SREAL_PART_BITS;\n+\n+      normalize (r);\n+    }\n+#else\n+  if (a->sig < SREAL_MIN_SIG || b->sig < SREAL_MIN_SIG)\n+    {\n+      r->sig = 0;\n+      r->exp = -SREAL_MAX_EXP;\n+    }\n+  else\n+    {\n+      r->sig = a->sig * b->sig;\n+      r->exp = a->exp + b->exp;\n+      normalize (r);\n+    }\n+#endif\n+  return r;\n+}\n+\n+/* *R = *A / *B.  Return R.  */\n+\n+sreal *\n+sreal_div (r, a, b)\n+     sreal *r;\n+     sreal *a;\n+     sreal *b;\n+{\n+#if SREAL_PART_BITS < 32\n+  unsigned HOST_WIDE_INT tmp, tmp1, tmp2;\n+\n+  if (b->sig_hi < SREAL_MIN_SIG)\n+    {\n+      abort ();\n+    }\n+  else if (a->sig_hi < SREAL_MIN_SIG)\n+    {\n+      r->sig_hi = 0;\n+      r->sig_lo = 0;\n+      r->exp = -SREAL_MAX_EXP;\n+    }\n+  else\n+    {\n+      /* Since division by the whole number is pretty ugly to write\n+\t we are dividing by first 3/4 of bits of number.  */\n+\n+      tmp1 = (a->sig_hi << SREAL_PART_BITS) + a->sig_lo;\n+      tmp2 = ((b->sig_hi << (SREAL_PART_BITS / 2))\n+\t      + (b->sig_lo >> (SREAL_PART_BITS / 2)));\n+      if (b->sig_lo & ((uhwi) 1 << ((SREAL_PART_BITS / 2) - 1)))\n+\ttmp2++;\n+\n+      r->sig_lo = 0;\n+      tmp = tmp1 / tmp2;\n+      tmp1 = (tmp1 % tmp2) << (SREAL_PART_BITS / 2);\n+      r->sig_hi = tmp << SREAL_PART_BITS;\n+\n+      tmp = tmp1 / tmp2;\n+      tmp1 = (tmp1 % tmp2) << (SREAL_PART_BITS / 2);\n+      r->sig_hi += tmp << (SREAL_PART_BITS / 2);\n+\n+      tmp = tmp1 / tmp2;\n+      r->sig_hi += tmp;\n+\n+      r->exp = a->exp - b->exp - SREAL_BITS - SREAL_PART_BITS / 2;\n+      normalize (r);\n+    }\n+#else\n+  if (b->sig == 0)\n+    {\n+      abort ();\n+    }\n+  else\n+    {\n+      r->sig = (a->sig << SREAL_PART_BITS) / b->sig;\n+      r->exp = a->exp - b->exp - SREAL_PART_BITS;\n+      normalize (r);\n+    }\n+#endif\n+  return r;\n+}"}, {"sha": "ac90fececa3ab2f1ad7fbf754ea8a584dafced88", "filename": "gcc/sreal.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5e69da5659335b8f8d942b29bd01dc7384b6ad/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=ac5e69da5659335b8f8d942b29bd01dc7384b6ad", "patch": "@@ -0,0 +1,67 @@\n+/* Definitions for simple data type for positive real numbers.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_SREAL_H\n+#define GCC_SREAL_H\n+\n+/* SREAL_PART_BITS has to be an even number.  */\n+#if (HOST_BITS_PER_WIDE_INT / 2) % 2 == 1\n+#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2 - 1)\n+#else\n+#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2)\n+#endif\n+\n+#define uhwi unsigned HOST_WIDE_INT\n+#define MAX_HOST_WIDE_INT (((uhwi) 1 << (HOST_BITS_PER_WIDE_INT - 1)) - 1)\n+\n+#define SREAL_MIN_SIG ((uhwi) 1 << (SREAL_PART_BITS - 1))\n+#define SREAL_MAX_SIG (((uhwi) 1 << SREAL_PART_BITS) - 1)\n+#define SREAL_MAX_EXP (INT_MAX / 4)\n+\n+#if SREAL_PART_BITS < 32\n+#define SREAL_BITS (SREAL_PART_BITS * 2)\n+#else\n+#define SREAL_BITS SREAL_PART_BITS\n+#endif\n+\n+/* Structure for holding a simple real number.  */\n+typedef struct sreal\n+{\n+#if SREAL_PART_BITS < 32\n+  unsigned HOST_WIDE_INT sig_lo;\t/* Significant (lower part).  */\n+  unsigned HOST_WIDE_INT sig_hi;\t/* Significant (higher part).  */\n+#else\n+  unsigned HOST_WIDE_INT sig;\t\t/* Significant.  */\n+#endif\n+  signed int exp;\t\t\t/* Exponent.  */\n+} sreal;\n+\n+extern void dump_sreal\t\t\tPARAMS ((FILE *, sreal *));\n+extern sreal *sreal_init\t\tPARAMS ((sreal *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t signed int));\n+extern HOST_WIDE_INT sreal_to_int\tPARAMS ((sreal *));\n+extern int sreal_compare\t\tPARAMS ((sreal *, sreal *));\n+extern sreal *sreal_add\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n+extern sreal *sreal_sub\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n+extern sreal *sreal_mul\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n+extern sreal *sreal_div\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n+\n+#endif"}]}