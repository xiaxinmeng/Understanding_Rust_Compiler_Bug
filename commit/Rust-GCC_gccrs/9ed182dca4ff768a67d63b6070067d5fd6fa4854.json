{"sha": "9ed182dca4ff768a67d63b6070067d5fd6fa4854", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVkMTgyZGNhNGZmNzY4YTY3ZDYzYjYwNzAwNjdkNWZkNmZhNDg1NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-07-16T21:16:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-16T21:16:06Z"}, "message": "decl.c (qualify_lookup): Handle templates.\n\n\t* decl.c (qualify_lookup): Handle templates.\n\t* decl2.c (do_using_directive): Don't pass ancestor.\n\t* decl.c (push_using_directive): Calculate ancestor.\n\t* decl2.c (do_nonmember_using_decl): Allow for type shadowing.\n\t* decl.c (pushdecl): Move type shadowing handling from here...\n\t(duplicate_decls): ...to here.\n\t* decl.c (set_identifier_local_value_with_scope): New fn.\n\t(pushdecl): Use it.\n\t(set_identifier_local_value, lookup_type_current_level): New fns.\n\t* decl2.c (do_local_using_decl): Handle types and binding level\n\tstuff properly.\n\nFrom-SVN: r21223", "tree": {"sha": "1e93c1b7ac99ea5e5037ac1ffe84d6b6f6abf378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e93c1b7ac99ea5e5037ac1ffe84d6b6f6abf378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ed182dca4ff768a67d63b6070067d5fd6fa4854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed182dca4ff768a67d63b6070067d5fd6fa4854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ed182dca4ff768a67d63b6070067d5fd6fa4854", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed182dca4ff768a67d63b6070067d5fd6fa4854/comments", "author": null, "committer": null, "parents": [{"sha": "3cab3dc87eec39db26713b537427a4664d4dbe4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cab3dc87eec39db26713b537427a4664d4dbe4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cab3dc87eec39db26713b537427a4664d4dbe4c"}], "stats": {"total": 164, "additions": 115, "deletions": 49}, "files": [{"sha": "20e6653c630ddd32374aff7f3920f9533d51ac9d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ed182dca4ff768a67d63b6070067d5fd6fa4854", "patch": "@@ -1,5 +1,19 @@\n 1998-07-16  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl.c (qualify_lookup): Handle templates.\n+\n+\t* decl2.c (do_using_directive): Don't pass ancestor.\n+\t* decl.c (push_using_directive): Calculate ancestor.\n+\n+\t* decl2.c (do_nonmember_using_decl): Allow for type shadowing.\n+\t* decl.c (pushdecl): Move type shadowing handling from here...\n+\t(duplicate_decls): ...to here.\n+\t* decl.c (set_identifier_local_value_with_scope): New fn.\n+\t(pushdecl): Use it.\n+\t(set_identifier_local_value, lookup_type_current_level): New fns.\n+\t* decl2.c (do_local_using_decl): Handle types and binding level\n+\tstuff properly.\n+\n \t* init.c (build_offset_ref): Don't call mark_used on an OVERLOAD.\n \t* decl.c (select_decl): Extract a lone function from an OVERLOAD.\n \t(lookup_namespace_name): Likewise."}, {"sha": "f6c1e23bdd6f337dba0b82f5f905496b8c4e7b61", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9ed182dca4ff768a67d63b6070067d5fd6fa4854", "patch": "@@ -2379,7 +2379,7 @@ extern void pushdecl_nonclass_level\t\tPROTO((tree));\n #endif\n extern tree pushdecl_namespace_level            PROTO((tree));\n extern tree push_using_decl                     PROTO((tree, tree));\n-extern tree push_using_directive                PROTO((tree, tree));\n+extern tree push_using_directive                PROTO((tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern tree push_using_decl                     PROTO((tree, tree));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n@@ -2403,9 +2403,11 @@ extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree lookup_function_nonclass            PROTO((tree, tree));\n extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n+extern tree lookup_type_current_level\t\tPROTO((tree));\n extern tree lookup_name_namespace_only          PROTO((tree));\n extern void begin_only_namespace_names          PROTO((void));\n extern void end_only_namespace_names            PROTO((void));\n+extern tree namespace_ancestor\t\t\tPROTO((tree, tree));\n extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree,int));\n extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree,int));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));"}, {"sha": "478d75b0e011b93f8e297cbe487a6fba8e078c80", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 79, "deletions": 33, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9ed182dca4ff768a67d63b6070067d5fd6fa4854", "patch": "@@ -2159,6 +2159,26 @@ set_identifier_type_value (id, type)\n   set_identifier_type_value_with_scope (id, type, inner_binding_level);\n }\n \n+void\n+set_identifier_local_value_with_scope (id, val, b)\n+     tree id, val;\n+     struct binding_level *b;\n+{\n+  tree oldlocal;\n+  my_friendly_assert (! b->namespace_p, 980716);\n+\n+  oldlocal = IDENTIFIER_LOCAL_VALUE (id);\n+  b->shadowed = tree_cons (id, oldlocal, b->shadowed);\n+  IDENTIFIER_LOCAL_VALUE (id) = val;\n+}\n+\n+void\n+set_identifier_local_value (id, val)\n+     tree id, val;\n+{\n+  set_identifier_local_value_with_scope (id, val, current_binding_level);\n+}\n+\n /* Return the type associated with id. */\n \n tree\n@@ -2646,12 +2666,30 @@ duplicate_decls (newdecl, olddecl)\n     }\n   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n     {\n+      if ((TREE_CODE (olddecl) == TYPE_DECL && DECL_ARTIFICIAL (olddecl)\n+\t   && TREE_CODE (newdecl) != TYPE_DECL\n+\t   && ! (TREE_CODE (newdecl) == TEMPLATE_DECL\n+\t\t && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL))\n+\t  || (TREE_CODE (newdecl) == TYPE_DECL && DECL_ARTIFICIAL (newdecl)\n+\t      && TREE_CODE (olddecl) != TYPE_DECL\n+\t      && ! (TREE_CODE (olddecl) == TEMPLATE_DECL\n+\t\t    && (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl))\n+\t\t\t== TYPE_DECL))))\n+\t{\n+\t  /* We do nothing special here, because C++ does such nasty\n+\t     things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n+\t     get shadowed, and know that if we need to find a TYPE_DECL\n+\t     for a given name, we can look in the IDENTIFIER_TYPE_VALUE\n+\t     slot of the identifier.  */\n+\t  return 0;\n+\t}\n+\n       if ((TREE_CODE (newdecl) == FUNCTION_DECL\n \t   && DECL_FUNCTION_TEMPLATE_P (olddecl))\n \t  || (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && DECL_FUNCTION_TEMPLATE_P (newdecl)))\n \treturn 0;\n-      \n+\n       cp_error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n \tolddecl = TREE_VALUE (olddecl);\n@@ -3319,24 +3357,7 @@ pushdecl (x)\n \t    }\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n-\t      if ((TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t)\n-\t\t   && TREE_CODE (x) != TYPE_DECL\n-\t\t   && ! (TREE_CODE (x) == TEMPLATE_DECL\n-\t\t\t && TREE_CODE (DECL_TEMPLATE_RESULT (x)) == TYPE_DECL))\n-\t\t  || (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-\t\t      && TREE_CODE (t) != TYPE_DECL\n-\t\t      && ! (TREE_CODE (t) == TEMPLATE_DECL\n-\t\t\t    && (TREE_CODE (DECL_TEMPLATE_RESULT (t))\n-\t\t\t\t== TYPE_DECL))))\n-\t\t{\n-\t\t  /* We do nothing special here, because C++ does such nasty\n-\t\t     things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n-\t\t     get shadowed, and know that if we need to find a TYPE_DECL\n-\t\t     for a given name, we can look in the IDENTIFIER_TYPE_VALUE\n-\t\t     slot of the identifier.  */\n-\t\t  ;\n-\t\t}\n-\t      else if (duplicate_decls (x, t))\n+\t      if (duplicate_decls (x, t))\n \t\treturn t;\n \t    }\n \t  else if (duplicate_decls (x, t))\n@@ -3519,10 +3540,7 @@ pushdecl (x)\n \t  if (TREE_CODE (x) != TYPE_DECL\n \t      || t == NULL_TREE\n \t      || ! DECL_ARTIFICIAL (x))\n-\t    {\n-\t      b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n-\t      IDENTIFIER_LOCAL_VALUE (name) = x;\n-\t    }\n+\t    set_identifier_local_value_with_scope (name, x, b);\n \n \t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n \t  if (TREE_CODE (x) == TYPE_DECL)\n@@ -3851,21 +3869,21 @@ push_using_decl (scope, name)\n    TREE_LIST otherwise.  */\n \n tree\n-push_using_directive (used, ancestor)\n+push_using_directive (used)\n      tree used;\n-     tree ancestor;\n {\n   tree ud = current_binding_level->using_directives;\n-  tree iter;\n+  tree iter, ancestor;\n   \n   /* Check if we already have this. */\n   if (purpose_member (used, ud) != NULL_TREE)\n     return NULL_TREE;\n \n   /* Recursively add all namespaces used. */\n   for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n-    push_using_directive (TREE_PURPOSE (iter), ancestor);\n+    push_using_directive (TREE_PURPOSE (iter));\n \n+  ancestor = namespace_ancestor (current_decl_namespace (), used);\n   ud = current_binding_level->using_directives;\n   ud = perm_tree_cons (used, ancestor, ud);\n   current_binding_level->using_directives = ud;\n@@ -4859,7 +4877,10 @@ qualify_lookup (val, flags)\n     return val;\n   if (LOOKUP_NAMESPACES_ONLY (flags) && TREE_CODE (val) != NAMESPACE_DECL)\n     return NULL_TREE;\n-  if (LOOKUP_TYPES_ONLY (flags) && TREE_CODE (val) != TYPE_DECL)\n+  if (LOOKUP_TYPES_ONLY (flags) && TREE_CODE (val) != TYPE_DECL\n+      && ! ((flags & LOOKUP_TEMPLATES_EXPECTED)\n+\t    && TREE_CODE (val) == TEMPLATE_DECL\n+\t    && DECL_CLASS_TEMPLATE_P (val)))\n     return NULL_TREE;\n   return val;\n }\n@@ -5133,16 +5154,41 @@ lookup_name_current_level (name)\n       struct binding_level *b = current_binding_level;\n       while (1)\n \t{\n-\t  for (t = b->names; t; t = TREE_CHAIN (t))\n-\t    if (DECL_NAME (t) == name || DECL_ASSEMBLER_NAME (t) == name)\n-\t      goto out;\n+\t  if (purpose_member (name, b->shadowed))\n+\t    return IDENTIFIER_LOCAL_VALUE (name);\n+\t  if (b->keep == 2)\n+\t    b = b->level_chain;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  return t;\n+}\n+\n+/* Like lookup_name_current_level, but for types.  */\n+\n+tree\n+lookup_type_current_level (name)\n+     tree name;\n+{\n+  register tree t = NULL_TREE;\n+\n+  my_friendly_assert (! current_binding_level->namespace_p, 980716);\n+\n+  if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n+      && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n+    {\n+      struct binding_level *b = current_binding_level;\n+      while (1)\n+\t{\n+\t  if (purpose_member (name, b->type_shadowed))\n+\t    return REAL_IDENTIFIER_TYPE_VALUE (name);\n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n \t  else\n \t    break;\n \t}\n-    out:\n-      ;\n     }\n \n   return t;"}, {"sha": "6713c65834b610e13032b596a963fa05e41118d9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed182dca4ff768a67d63b6070067d5fd6fa4854/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9ed182dca4ff768a67d63b6070067d5fd6fa4854", "patch": "@@ -58,7 +58,6 @@ static int finish_vtable_vardecl PROTO((tree, tree));\n static int prune_vtable_vardecl PROTO((tree, tree));\n static void finish_sigtable_vardecl PROTO((tree, tree));\n static int is_namespace_ancestor PROTO((tree, tree));\n-static tree namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree,int));\n static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n@@ -3839,7 +3838,7 @@ is_namespace_ancestor (root, child)\n /* Return the namespace that is the common ancestor \n    of two given namespaces. */\n \n-static tree\n+tree\n namespace_ancestor (ns1, ns2)\n      tree ns1, ns2;\n {\n@@ -4495,10 +4494,16 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n   if (BINDING_VALUE (decls) && is_overloaded_fn (BINDING_VALUE (decls)))\n     {\n       tree tmp, tmp1;\n+\n+      if (oldval && !is_overloaded_fn (oldval))\n+\t{\n+\t  duplicate_decls (OVL_CURRENT (BINDING_VALUE (decls)), oldval);\n+\t  oldval = NULL_TREE;\n+\t}\n+\n       *newval = oldval;\n       for (tmp = BINDING_VALUE (decls); tmp; tmp = OVL_NEXT (tmp))\n \t{\n-\n \t  /* Compare each new function with each old one.\n \t     If the old function was also used, there is no conflict. */\n \t  for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n@@ -4522,8 +4527,8 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n   else \n     {\n       *newval = BINDING_VALUE (decls);\n-      if (oldval && oldval != *newval && !duplicate_decls (*newval, oldval))\n-\t*newval = oldval;\n+      if (oldval)\n+\tduplicate_decls (*newval, oldval);\n     } \n \n   *newtype = BINDING_TYPE (decls);\n@@ -4563,27 +4568,28 @@ do_toplevel_using_decl (decl)\n   return;\n }\n \n+/* Process a using-declaration at function scope.  */\n+\n void\n do_local_using_decl (decl)\n      tree decl;\n {\n   tree scope, name;\n   tree oldval, oldtype, newval, newtype;\n+\n   decl = validate_nonmember_using_decl (decl, &scope, &name);\n   if (decl == NULL_TREE)\n     return;\n \n-  /* XXX nested values */\n-  oldval = IDENTIFIER_LOCAL_VALUE (name);\n-  /* XXX get local type */\n-  oldtype = NULL_TREE;\n+  oldval = lookup_name_current_level (name);\n+  oldtype = lookup_type_current_level (name);\n \n   do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n \n   if (newval)\n-    /* XXX update bindings */\n-    IDENTIFIER_LOCAL_VALUE (name) = newval;\n-  /* XXX type */\n+    set_identifier_local_value (name, newval);\n+  if (newtype)\n+    set_identifier_type_value (name, newtype);\n }\n \n tree\n@@ -4638,9 +4644,7 @@ do_using_directive (namespace)\n     }\n   namespace = ORIGINAL_NAMESPACE (namespace);\n   if (!toplevel_bindings_p ())\n-    push_using_directive\n-      (namespace, namespace_ancestor (current_decl_namespace(), \n-\t\t\t\t      current_namespace));\n+    push_using_directive (namespace);\n   else\n     /* direct usage */\n     add_using_namespace (current_namespace, namespace, 0);"}]}