{"sha": "10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxNzRkZGY1ZDBlMGUyMjkzZTU0ZWJjMTRmOWM0OWE5OTgzZGU5OA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-08-19T10:17:33Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-08-19T10:17:33Z"}, "message": "tree-ssa-structalias.c (create_variable_info_for): Also mark first field in a struct.\n\n        * tree-ssa-structalias.c (create_variable_info_for): Also mark\n        first field in a struct.\n        (intra_create_variable_infos): Don't deal with flag_argument_noalias.\n\nfortran/\n        * trans-expr.c (gfc_conv_substring): Don't evaluate casted decl early,\n        change order of length calculation to (end - start) + 1.\n        (gfc_get_interface_mapping_array): Adjust call to\n        gfc_get_nodesc_array_type.\n        * trans-array.c (gfc_trans_create_temp_array,\n        gfc_build_constant_array_constructor, gfc_conv_expr_descriptor): Ditto.\n        * trans-stmt.c (gfc_trans_pointer_assign_need_temp): Ditto.\n        * trans.c (gfc_add_modify): Assignment between base type and nontarget\n        type are equal enough.\n        (gfc_call_malloc): Use prvoid_type_node for return value of\n        __builtin_malloc.\n        (gfc_allocate_with_status): Ditto.\n        * trans-types.c (gfc_array_descriptor_base): Double size of this array.\n        (gfc_init_types): Build prvoid_type_node.\n        (gfc_build_array_type): New bool parameter \"restricted\".\n        (gfc_get_nodesc_array_type): Ditto, build restrict qualified pointers,\n        if it's true.\n        (gfc_get_array_descriptor_base): Ditto.\n        (gfc_get_array_type_bounds): Ditto.\n        (gfc_sym_type): Use symbol attributes to feed calls to above functions.\n        (gfc_get_derived_type): Ditto.\n        * trans.h (struct lang_type): Add nontarget_type member.\n        * trans-types.h (prvoid_type_node): Declare.\n        (gfc_get_array_type_bounds, gfc_get_nodesc_array_type): Declare new\n        parameter.\n        * trans-decl.c (gfc_finish_var_decl): Give scalars that can't be\n        aliased a type with a different alias set than the base type.\n        (gfc_build_dummy_array_decl): Adjust call to gfc_get_nodesc_array_type.\n\ntestsuite/\n        * gfortran.dg/vect/vect-gems.f90: New test.\n        * gcc.dg/tree-ssa/alias-1.c: Remove, it checks something broken.\n\nFrom-SVN: r150934", "tree": {"sha": "b794f6439d5a67d4ade17d342bf5bd2bff70ce2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b794f6439d5a67d4ade17d342bf5bd2bff70ce2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "693d54f279d5c1d8694f47a6bcbf6718c618a1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693d54f279d5c1d8694f47a6bcbf6718c618a1fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/693d54f279d5c1d8694f47a6bcbf6718c618a1fe"}], "stats": {"total": 313, "additions": 219, "deletions": 94}, "files": [{"sha": "9df0297b0c63ce63c0047a93a5c1cb47660fa3af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -1,3 +1,9 @@\n+2009-08-18  Michael Matz  <matz@suse.de>\n+\n+\t* tree-ssa-structalias.c (create_variable_info_for): Also mark\n+\tfirst field in a struct.\n+\t(intra_create_variable_infos): Don't deal with flag_argument_noalias.\n+\n 2009-08-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Allocate insn"}, {"sha": "4eb6ea24428055a58a38914cde1532b1f0ab00bd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -1,3 +1,34 @@\n+2009-08-18  Michael Matz  <matz@suse.de>\n+\n+\t* trans-expr.c (gfc_conv_substring): Don't evaluate casted decl early,\n+\tchange order of length calculation to (end - start) + 1.\n+\t(gfc_get_interface_mapping_array): Adjust call to\n+\tgfc_get_nodesc_array_type.\n+\t* trans-array.c (gfc_trans_create_temp_array,\n+\tgfc_build_constant_array_constructor, gfc_conv_expr_descriptor): Ditto.\n+\t* trans-stmt.c (gfc_trans_pointer_assign_need_temp): Ditto.\n+\t* trans.c (gfc_add_modify): Assignment between base type and nontarget\n+\ttype are equal enough.\n+\t(gfc_call_malloc): Use prvoid_type_node for return value of\n+\t__builtin_malloc.\n+\t(gfc_allocate_with_status): Ditto.\n+\t* trans-types.c (gfc_array_descriptor_base): Double size of this array.\n+\t(gfc_init_types): Build prvoid_type_node.\n+\t(gfc_build_array_type): New bool parameter \"restricted\".\n+\t(gfc_get_nodesc_array_type): Ditto, build restrict qualified pointers,\n+\tif it's true.\n+\t(gfc_get_array_descriptor_base): Ditto.\n+\t(gfc_get_array_type_bounds): Ditto.\n+\t(gfc_sym_type): Use symbol attributes to feed calls to above functions.\n+\t(gfc_get_derived_type): Ditto.\n+\t* trans.h (struct lang_type): Add nontarget_type member.\n+\t* trans-types.h (prvoid_type_node): Declare.\n+\t(gfc_get_array_type_bounds, gfc_get_nodesc_array_type): Declare new\n+\tparameter.\n+\t* trans-decl.c (gfc_finish_var_decl): Give scalars that can't be\n+\taliased a type with a different alias set than the base type.\n+\t(gfc_build_dummy_array_decl): Adjust call to gfc_get_nodesc_array_type.\n+\n 2009-08-18  Janus Weil  <janus@gcc.gnu.org>\n \t    Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "31c59c6ee8461a4b4d8991551f36ae701c20d91b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -725,7 +725,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n   /* Initialize the descriptor.  */\n   type =\n     gfc_get_array_type_bounds (eltype, info->dimen, loop->from, loop->to, 1,\n-\t\t\t       GFC_ARRAY_UNKNOWN);\n+\t\t\t       GFC_ARRAY_UNKNOWN, true);\n   desc = gfc_create_var (type, \"atmp\");\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n \n@@ -1715,7 +1715,7 @@ gfc_build_constant_array_constructor (gfc_expr * expr, tree type)\n \tas.upper[i] = gfc_int_expr (tmp - 1);\n       }\n \n-  tmptype = gfc_get_nodesc_array_type (type, &as, PACKED_STATIC);\n+  tmptype = gfc_get_nodesc_array_type (type, &as, PACKED_STATIC, true);\n \n   init = build_constructor_from_list (tmptype, nreverse (list));\n \n@@ -5250,7 +5250,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  parmtype = gfc_get_element_type (TREE_TYPE (desc));\n \t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n \t\t\t\t\t\tloop.from, loop.to, 0,\n-\t\t\t\t\t\tGFC_ARRAY_UNKNOWN);\n+\t\t\t\t\t\tGFC_ARRAY_UNKNOWN, false);\n \t  parm = gfc_create_var (parmtype, \"parm\");\n \t}\n "}, {"sha": "6a4c3e45cc983e828f6921a4e880ea76df8aa2b7", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -578,6 +578,29 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   if (sym->attr.threadprivate\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n+\n+  if (!sym->attr.target\n+      && !sym->attr.pointer\n+      && !sym->attr.proc_pointer\n+      /* For now, don't bother with aggregate types.  We would need\n+         to adjust DECL_CONTEXT of all field decls.  */\n+      && !AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      tree type = TREE_TYPE (decl);\n+      if (!TYPE_LANG_SPECIFIC (type))\n+\tTYPE_LANG_SPECIFIC (type) = (struct lang_type *)\n+\t  ggc_alloc_cleared (sizeof (struct lang_type));\n+      if (!TYPE_LANG_SPECIFIC (type)->nontarget_type)\n+\t{\n+\t  alias_set_type set = new_alias_set ();\n+\t  type = build_distinct_type_copy (type);\n+\t  TYPE_ALIAS_SET (type) = set;\n+\t  TYPE_LANG_SPECIFIC (type)->nontarget_type = type;\n+\t}\n+      else\n+\ttype = TYPE_LANG_SPECIFIC (type)->nontarget_type;\n+      TREE_TYPE (decl) = type;\n+    }\n }\n \n \n@@ -840,7 +863,8 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n \t}\n \n       type = gfc_typenode_for_spec (&sym->ts);\n-      type = gfc_get_nodesc_array_type (type, sym->as, packed);\n+      type = gfc_get_nodesc_array_type (type, sym->as, packed,\n+\t\t\t\t\t!sym->attr.target);\n     }\n   else\n     {"}, {"sha": "7672f0b092d1e9b704569fc837c98e72452ea6ff", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -374,8 +374,10 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n     gfc_conv_string_parameter (se);\n   else\n     {\n+      tmp = start.expr;\n+      STRIP_NOPS (tmp);\n       /* Avoid multiple evaluation of substring start.  */\n-      if (!CONSTANT_CLASS_P (start.expr) && !DECL_P (start.expr))\n+      if (!CONSTANT_CLASS_P (tmp) && !DECL_P (tmp))\n \tstart.expr = gfc_evaluate_now (start.expr, &se->pre);\n \n       /* Change the start of the string.  */\n@@ -397,7 +399,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       gfc_conv_expr_type (&end, ref->u.ss.end, gfc_charlen_type_node);\n       gfc_add_block_to_block (&se->pre, &end.pre);\n     }\n-  if (!CONSTANT_CLASS_P (end.expr) && !DECL_P (end.expr))\n+  tmp = end.expr;\n+  STRIP_NOPS (tmp);\n+  if (!CONSTANT_CLASS_P (tmp) && !DECL_P (tmp))\n     end.expr = gfc_evaluate_now (end.expr, &se->pre);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n@@ -440,9 +444,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n     }\n \n   tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node,\n-\t\t     build_int_cst (gfc_charlen_type_node, 1),\n-\t\t     start.expr);\n-  tmp = fold_build2 (PLUS_EXPR, gfc_charlen_type_node, end.expr, tmp);\n+\t\t     end.expr, start.expr);\n+  tmp = fold_build2 (PLUS_EXPR, gfc_charlen_type_node,\n+\t\t     build_int_cst (gfc_charlen_type_node, 1), tmp);\n   tmp = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tmp,\n \t\t     build_int_cst (gfc_charlen_type_node, 0));\n   se->string_length = tmp;\n@@ -1611,7 +1615,9 @@ gfc_get_interface_mapping_array (stmtblock_t * block, gfc_symbol * sym,\n   tree var;\n \n   type = gfc_typenode_for_spec (&sym->ts);\n-  type = gfc_get_nodesc_array_type (type, sym->as, packed);\n+  type = gfc_get_nodesc_array_type (type, sym->as, packed,\n+\t\t\t\t    !sym->attr.target && !sym->attr.pointer\n+\t\t\t\t    && !sym->attr.proc_pointer);\n \n   var = gfc_create_var (type, \"ifm\");\n   gfc_add_modify (block, var, fold_convert (type, data));"}, {"sha": "66aecb195200cfc4586ae0cca4ef9790d13fe17f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -2694,7 +2694,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       parmtype = gfc_get_element_type (TREE_TYPE (desc));\n       parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n                                             loop.from, loop.to, 1,\n-\t\t\t\t\t    GFC_ARRAY_UNKNOWN);\n+\t\t\t\t\t    GFC_ARRAY_UNKNOWN, true);\n \n       /* Allocate temporary for nested forall construct.  */\n       tmp1 = allocate_temp_for_forall_nest (nested_forall_info, parmtype,"}, {"sha": "4a293998800782b4a268a243032d8b8465677211", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -59,6 +59,7 @@ tree gfc_array_index_type;\n tree gfc_array_range_type;\n tree gfc_character1_type_node;\n tree pvoid_type_node;\n+tree prvoid_type_node;\n tree ppvoid_type_node;\n tree pchar_type_node;\n tree pfunc_type_node;\n@@ -67,7 +68,7 @@ tree gfc_charlen_type_node;\n \n static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n-static GTY(()) tree gfc_array_descriptor_base[GFC_MAX_DIMENSIONS];\n+static GTY(()) tree gfc_array_descriptor_base[2 * GFC_MAX_DIMENSIONS];\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n    after the target has a chance to process command-line options.  */\n@@ -866,6 +867,7 @@ gfc_init_types (void)\n #undef PUSH_TYPE\n \n   pvoid_type_node = build_pointer_type (void_type_node);\n+  prvoid_type_node = build_qualified_type (pvoid_type_node, TYPE_QUAL_RESTRICT);\n   ppvoid_type_node = build_pointer_type (pvoid_type_node);\n   pchar_type_node = build_pointer_type (gfc_character1_type_node);\n   pfunc_type_node\n@@ -1202,7 +1204,7 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n \n static tree\n gfc_build_array_type (tree type, gfc_array_spec * as,\n-\t\t      enum gfc_array_kind akind)\n+\t\t      enum gfc_array_kind akind, bool restricted)\n {\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n@@ -1220,7 +1222,8 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n \n   if (as->type == AS_ASSUMED_SHAPE)\n     akind = GFC_ARRAY_ASSUMED_SHAPE;\n-  return gfc_get_array_type_bounds (type, as->rank, lbound, ubound, 0, akind);\n+  return gfc_get_array_type_bounds (type, as->rank, lbound, ubound, 0, akind,\n+\t\t\t\t    restricted);\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n@@ -1365,7 +1368,8 @@ gfc_get_dtype (tree type)\n    to the value of PACKED.  */\n \n tree\n-gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n+gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n+\t\t\t   bool restricted)\n {\n   tree range;\n   tree type;\n@@ -1474,6 +1478,10 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n   /* TODO: use main type if it is unbounded.  */\n   GFC_TYPE_ARRAY_DATAPTR_TYPE (type) =\n     build_pointer_type (build_array_type (etype, range));\n+  if (restricted)\n+    GFC_TYPE_ARRAY_DATAPTR_TYPE (type) =\n+      build_qualified_type (GFC_TYPE_ARRAY_DATAPTR_TYPE (type),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n \n   if (known_stride)\n     {\n@@ -1519,6 +1527,8 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n       /* For dummy arrays and automatic (heap allocated) arrays we\n \t want a pointer to the array.  */\n       type = build_pointer_type (type);\n+      if (restricted)\n+\ttype = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n       GFC_ARRAY_TYPE_P (type) = 1;\n       TYPE_LANG_SPECIFIC (type) = TYPE_LANG_SPECIFIC (TREE_TYPE (type));\n     }\n@@ -1528,14 +1538,15 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n /* Return or create the base type for an array descriptor.  */\n \n static tree\n-gfc_get_array_descriptor_base (int dimen)\n+gfc_get_array_descriptor_base (int dimen, bool restricted)\n {\n   tree fat_type, fieldlist, decl, arraytype;\n   char name[16 + GFC_RANK_DIGITS + 1];\n+  int idx = 2 * (dimen - 1) + restricted;\n \n   gcc_assert (dimen >= 1 && dimen <= GFC_MAX_DIMENSIONS);\n-  if (gfc_array_descriptor_base[dimen - 1])\n-    return gfc_array_descriptor_base[dimen - 1];\n+  if (gfc_array_descriptor_base[idx])\n+    return gfc_array_descriptor_base[idx];\n \n   /* Build the type node.  */\n   fat_type = make_node (RECORD_TYPE);\n@@ -1545,7 +1556,8 @@ gfc_get_array_descriptor_base (int dimen)\n \n   /* Add the data member as the first element of the descriptor.  */\n   decl = build_decl (input_location,\n-\t\t     FIELD_DECL, get_identifier (\"data\"), ptr_type_node);\n+\t\t     FIELD_DECL, get_identifier (\"data\"),\n+\t\t     restricted ? prvoid_type_node : ptr_type_node);\n \n   DECL_CONTEXT (decl) = fat_type;\n   fieldlist = decl;\n@@ -1585,7 +1597,7 @@ gfc_get_array_descriptor_base (int dimen)\n   gfc_finish_type (fat_type);\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (fat_type)) = 1;\n \n-  gfc_array_descriptor_base[dimen - 1] = fat_type;\n+  gfc_array_descriptor_base[idx] = fat_type;\n   return fat_type;\n }\n \n@@ -1594,15 +1606,18 @@ gfc_get_array_descriptor_base (int dimen)\n tree\n gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \t\t\t   tree * ubound, int packed,\n-\t\t\t   enum gfc_array_kind akind)\n+\t\t\t   enum gfc_array_kind akind, bool restricted)\n {\n   char name[8 + GFC_RANK_DIGITS + GFC_MAX_SYMBOL_LEN];\n   tree fat_type, base_type, arraytype, lower, upper, stride, tmp, rtype;\n   const char *type_name;\n   int n;\n \n-  base_type = gfc_get_array_descriptor_base (dimen);\n+  base_type = gfc_get_array_descriptor_base (dimen, restricted);\n   fat_type = build_distinct_type_copy (base_type);\n+  /* Make sure that nontarget and target array type have the same canonical\n+     type (and same stub decl for debug info).  */\n+  base_type = gfc_get_array_descriptor_base (dimen, false);\n   TYPE_CANONICAL (fat_type) = base_type;\n   TYPE_STUB_DECL (fat_type) = TYPE_STUB_DECL (base_type);\n \n@@ -1684,6 +1699,8 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n     rtype = gfc_array_range_type;\n   arraytype = build_array_type (etype, rtype);\n   arraytype = build_pointer_type (arraytype);\n+  if (restricted)\n+    arraytype = build_qualified_type (arraytype, TYPE_QUAL_RESTRICT);\n   GFC_TYPE_ARRAY_DATAPTR_TYPE (fat_type) = arraytype;\n \n   /* This will generate the base declarations we need to emit debug\n@@ -1723,6 +1740,7 @@ gfc_sym_type (gfc_symbol * sym)\n {\n   tree type;\n   int byref;\n+  bool restricted;\n \n   /* Procedure Pointers inside COMMON blocks.  */\n   if (sym->attr.proc_pointer && sym->attr.in_common)\n@@ -1757,6 +1775,8 @@ gfc_sym_type (gfc_symbol * sym)\n   else\n     byref = 0;\n \n+  restricted = !sym->attr.target && !sym->attr.pointer\n+               && !sym->attr.proc_pointer;\n   if (sym->attr.dimension)\n     {\n       if (gfc_is_nodesc_array (sym))\n@@ -1769,7 +1789,8 @@ gfc_sym_type (gfc_symbol * sym)\n \t    {\n \t      type = gfc_get_nodesc_array_type (type, sym->as,\n \t\t\t\t\t\tbyref ? PACKED_FULL\n-\t\t\t\t\t\t      : PACKED_STATIC);\n+\t\t\t\t\t\t      : PACKED_STATIC,\n+\t\t\t\t\t\trestricted);\n \t      byref = 0;\n \t    }\n         }\n@@ -1780,7 +1801,7 @@ gfc_sym_type (gfc_symbol * sym)\n \t    akind = GFC_ARRAY_POINTER;\n \t  else if (sym->attr.allocatable)\n \t    akind = GFC_ARRAY_ALLOCATABLE;\n-\t  type = gfc_build_array_type (type, sym->as, akind);\n+\t  type = gfc_build_array_type (type, sym->as, akind, restricted);\n \t}\n     }\n   else\n@@ -1801,7 +1822,11 @@ gfc_sym_type (gfc_symbol * sym)\n       if (sym->attr.optional || sym->ns->proc_name->attr.entry_master)\n \ttype = build_pointer_type (type);\n       else\n-\ttype = build_reference_type (type);\n+\t{\n+\t  type = build_reference_type (type);\n+\t  if (restricted)\n+\t    type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n+\t}\n     }\n \n   return (type);\n@@ -2100,11 +2125,14 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t\takind = GFC_ARRAY_ALLOCATABLE;\n \t      /* Pointers to arrays aren't actually pointer types.  The\n \t         descriptors are separate, but the data is common.  */\n-\t      field_type = gfc_build_array_type (field_type, c->as, akind);\n+\t      field_type = gfc_build_array_type (field_type, c->as, akind,\n+\t\t\t\t\t\t !c->attr.target\n+\t\t\t\t\t\t && !c->attr.pointer);\n \t    }\n \t  else\n \t    field_type = gfc_get_nodesc_array_type (field_type, c->as,\n-\t\t\t\t\t\t    PACKED_STATIC);\n+\t\t\t\t\t\t    PACKED_STATIC,\n+\t\t\t\t\t\t    !c->attr.target);\n \t}\n       else if (c->attr.pointer)\n \tfield_type = build_pointer_type (field_type);"}, {"sha": "87feea3dfaff4c21ac36779e35eab841a3cb0f2c", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -29,6 +29,7 @@ extern GTY(()) tree gfc_array_range_type;\n extern GTY(()) tree gfc_character1_type_node;\n extern GTY(()) tree ppvoid_type_node;\n extern GTY(()) tree pvoid_type_node;\n+extern GTY(()) tree prvoid_type_node;\n extern GTY(()) tree pchar_type_node;\n \n /* This is the type used to hold the lengths of character variables.\n@@ -72,8 +73,8 @@ tree gfc_build_uint_type (int);\n \n tree gfc_get_element_type (tree);\n tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int,\n-\t\t\t\tenum gfc_array_kind);\n-tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed);\n+\t\t\t\tenum gfc_array_kind, bool);\n+tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed, bool);\n \n /* Add a field of given name and type to a UNION_TYPE or RECORD_TYPE.  */\n tree gfc_add_field_to_struct (tree *, tree, tree, tree);"}, {"sha": "f4a215aeeaf27fa94199b03740023c1ae332d982", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -159,11 +159,21 @@ gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n   tree tmp;\n \n #ifdef ENABLE_CHECKING\n+  tree t1, t2;\n+  t1 = TREE_TYPE (rhs);\n+  t2 = TREE_TYPE (lhs);\n+  /* ??? This is actually backwards, we should test the \"base\" type\n+     from which the nontarget_type was copied, but we don't have this\n+     backlink.  This will do for now, it's for checking anyway.  */\n+  if (TYPE_LANG_SPECIFIC (t1))\n+    t1 = TYPE_LANG_SPECIFIC (t1)->nontarget_type;\n+  if (TYPE_LANG_SPECIFIC (t2))\n+    t2 = TYPE_LANG_SPECIFIC (t2)->nontarget_type;\n   /* Make sure that the types of the rhs and the lhs are the same\n      for scalar assignments.  We should probably have something\n      similar for aggregates, but right now removing that check just\n      breaks everything.  */\n-  gcc_assert (TREE_TYPE (rhs) == TREE_TYPE (lhs)\n+  gcc_assert (t1 == t2\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n@@ -509,7 +519,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n     size = fold_convert (size_type_node, size);\n \n   /* Create a variable to hold the result.  */\n-  res = gfc_create_var (pvoid_type_node, NULL);\n+  res = gfc_create_var (prvoid_type_node, NULL);\n \n   /* size < 0 ?  */\n   negative = fold_build2 (LT_EXPR, boolean_type_node, size,\n@@ -529,9 +539,9 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n \t\t      build_int_cst (size_type_node, 1));\n \n   gfc_add_modify (&block2, res,\n-\t\t  build_call_expr_loc (input_location,\n-\t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1,\n-\t\t       size));\n+\t\t  fold_convert (prvoid_type_node,\n+\t\t\t\tbuild_call_expr_loc (input_location,\n+\t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1, size)));\n   null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n \t\t\t     build_int_cst (pvoid_type_node, 0));\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n@@ -601,7 +611,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n     size = fold_convert (size_type_node, size);\n \n   /* Create a variable to hold the result.  */\n-  res = gfc_create_var (pvoid_type_node, NULL);\n+  res = gfc_create_var (prvoid_type_node, NULL);\n \n   /* Set the optional status variable to zero.  */\n   if (status != NULL_TREE && !integer_zerop (status))\n@@ -633,7 +643,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t\t      fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n       gfc_add_modify (&set_status_block, res,\n-\t\t\t   build_int_cst (pvoid_type_node, 0));\n+\t\t\t   build_int_cst (prvoid_type_node, 0));\n \n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n \t\t\t build_int_cst (TREE_TYPE (status), 0));\n@@ -644,11 +654,12 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   /* The allocation itself.  */\n   gfc_start_block (&alloc_block);\n   gfc_add_modify (&alloc_block, res,\n-\t\t  build_call_expr_loc (input_location,\n+\t\t  fold_convert (prvoid_type_node,\n+\t\t\t\tbuild_call_expr_loc (input_location,\n \t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1,\n \t\t\t\t\tfold_build2 (MAX_EXPR, size_type_node,\n \t\t\t\t\t\t     size,\n-\t\t\t\t\t\t     build_int_cst (size_type_node, 1))));\n+\t\t\t\t\t\t     build_int_cst (size_type_node, 1)))));\n \n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t\t\t\t(\"Out of memory\"));\n@@ -671,7 +682,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \n   tmp = fold_build3 (COND_EXPR, void_type_node,\n \t\t     fold_build2 (EQ_EXPR, boolean_type_node, res,\n-\t\t\t\t  build_int_cst (pvoid_type_node, 0)),\n+\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n \t\t     tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&alloc_block, tmp);\n \n@@ -723,7 +734,7 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n     size = fold_convert (size_type_node, size);\n \n   /* Create a variable to hold the result.  */\n-  res = gfc_create_var (pvoid_type_node, NULL);\n+  res = gfc_create_var (type, NULL);\n   null_mem = fold_build2 (EQ_EXPR, boolean_type_node, mem,\n \t\t\t  build_int_cst (type, 0));\n "}, {"sha": "643f28b37f4f55eaa38caf386e814ca09c9a2f41", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -629,6 +629,7 @@ struct GTY(())\tlang_type\t {\n   tree dataptr_type;\n   tree span;\n   tree base_decl[2];\n+  tree nontarget_type;\n };\n \n struct GTY(()) lang_decl {"}, {"sha": "e766efcc3e455f6483057d25aba95a5796938d7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -1,3 +1,8 @@\n+2009-08-18  Michael Matz  <matz@suse.de>\n+\n+\t* gfortran.dg/vect/vect-gems.f90: New test.\n+\t* gcc.dg/tree-ssa/alias-1.c: Remove, it checks something broken.\n+\n 2009-08-18  DJ Delorie  <dj@redhat.com>\n \n \t* lib/wrapper.exp: Move load of target-libpath.exp from here..."}, {"sha": "6e88eb1ce23613c0c488e679266f17eab1de3b18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-1.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/693d54f279d5c1d8694f47a6bcbf6718c618a1fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/693d54f279d5c1d8694f47a6bcbf6718c618a1fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-1.c?ref=693d54f279d5c1d8694f47a6bcbf6718c618a1fe", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-options \"-O2 -fargument-noalias-global -fdump-tree-optimized\" } */\n-int f;\n-void link_error ();\n-\n-void g(int *i)\n-{\n-  *i = 0;\n-  f = 1;\n-  if (*i != 0)\n-    link_error ();\n-}\n-\n-\n-/* We should have removed the link_error on the tree level as we told GCC\n-   that *i cannot point to f via the option -fargument-noalias-global. */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\"} } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "019b41558446d736821fe2ed7ea84da807e474f7", "filename": "gcc/testsuite/gfortran.dg/vect/vect-gems.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-gems.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-gems.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-gems.f90?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_double }\n+\n+MODULE UPML_mod\n+\n+IMPLICIT NONE\n+\n+PUBLIC UPMLupdateE\n+\n+PRIVATE\n+\n+real(kind=8), dimension(:,:,:), allocatable :: Dx_ilow\n+\n+real(kind=8), dimension(:), allocatable :: aye, aze\n+real(kind=8), dimension(:), allocatable :: bye, bze\n+real(kind=8), dimension(:), allocatable :: fxh, cxh\n+\n+real(kind=8) :: epsinv\n+real(kind=8) :: dxinv, dyinv, dzinv\n+\n+integer :: xstart, ystart, zstart, xstop, ystop, zstop\n+\n+CONTAINS\n+\n+SUBROUTINE UPMLupdateE(nx,ny,nz,Hx,Hy,Hz,Ex,Ey,Ez)\n+\n+integer, intent(in) :: nx, ny, nz\n+real(kind=8), intent(inout),                                                &\n+         dimension(xstart:xstop+1,ystart:ystop+1,zstart:zstop+1) :: Ex, Ey, Ez\n+real(kind=8), intent(inout),                                                &\n+         allocatable :: Hx(:,:,:), Hy(:,:,:), Hz(:,:,:)\n+\n+integer :: i, j, k\n+real(kind=8) :: Dxold, Dyold, Dzold\n+\n+do k=zstart+1,zstop\n+  do j=ystart+1,ystop\n+    do i=xstart+1,0\n+\n+      Dxold = Dx_ilow(i,j,k)\n+\n+      Dx_ilow(i,j,k) = aye(j) * Dx_ilow(i,j,k) +                              &\n+                       bye(j) * ((Hz(i,j,k  )-Hz(i,j-1,k))*dyinv +            &\n+                                 (Hy(i,j,k-1)-Hy(i,j,k  ))*dzinv)\n+\n+      Ex(i,j,k) = aze(k) * Ex(i,j,k) +                                        &\n+                  bze(k) * (cxh(i)*Dx_ilow(i,j,k) - fxh(i)*Dxold) * epsinv\n+    end do\n+  end do\n+end do\n+\n+END SUBROUTINE UPMLupdateE\n+\n+END MODULE UPML_mod\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } }\n+! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "72e10835bb567dde3fdb1370a6c54aafbd392478", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10174ddf5d0e0e2293e54ebc14f9c49a9983de98/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=10174ddf5d0e0e2293e54ebc14f9c49a9983de98", "patch": "@@ -4519,6 +4519,13 @@ create_variable_info_for (tree decl, const char *name)\n       vi->size = fo->size;\n       vi->offset = fo->offset;\n       vi->may_have_pointers = fo->may_have_pointers;\n+      if (vi->is_global_var\n+\t  && (!flag_whole_program || !in_ipa_mode)\n+\t  && vi->may_have_pointers)\n+\t{\n+\t  if (fo->only_restrict_pointers)\n+\t    make_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t}\n       for (i = VEC_length (fieldoff_s, fieldstack) - 1;\n \t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo);\n \t   i--)\n@@ -4611,43 +4618,8 @@ intra_create_variable_infos (void)\n       if (!could_have_pointers (t))\n \tcontinue;\n \n-      /* If flag_argument_noalias is set, then function pointer\n-\t arguments are guaranteed not to point to each other.  In that\n-\t case, create an artificial variable PARM_NOALIAS and the\n-\t constraint ARG = &PARM_NOALIAS.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (t)) && flag_argument_noalias > 0)\n-\t{\n-\t  varinfo_t vi;\n-\t  var_ann_t ann;\n-\n-\t  vi = make_constraint_from_heapvar (get_vi_for_tree (t),\n-\t\t\t\t\t     \"PARM_NOALIAS\");\n-\t  ann = get_var_ann (vi->decl);\n-\t  if (flag_argument_noalias == 1)\n-\t    {\n-\t      ann->noalias_state = NO_ALIAS;\n-\t      make_copy_constraint (vi, nonlocal_id);\n-\t    }\n-\t  else if (flag_argument_noalias == 2)\n-\t    {\n-\t      ann->noalias_state = NO_ALIAS_GLOBAL;\n-\t      make_constraint_from (vi, vi->id);\n-\t    }\n-\t  else if (flag_argument_noalias == 3)\n-\t    {\n-\t      ann->noalias_state = NO_ALIAS_ANYTHING;\n-\t      make_constraint_from (vi, vi->id);\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-      else\n-\t{\n-\t  varinfo_t arg_vi = get_vi_for_tree (t);\n-\n-\t  for (p = arg_vi; p; p = p->next)\n-\t    make_constraint_from (p, nonlocal_id);\n-\t}\n+      for (p = get_vi_for_tree (t); p; p = p->next)\n+\tmake_constraint_from (p, nonlocal_id);\n       if (POINTER_TYPE_P (TREE_TYPE (t))\n \t  && TYPE_RESTRICT (TREE_TYPE (t)))\n \tmake_constraint_from_restrict (get_vi_for_tree (t), \"PARM_RESTRICT\");"}]}