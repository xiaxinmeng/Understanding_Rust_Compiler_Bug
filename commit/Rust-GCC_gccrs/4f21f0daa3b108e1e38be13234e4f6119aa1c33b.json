{"sha": "4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyMWYwZGFhM2IxMDhlMWUzOGJlMTMyMzRlNGY2MTE5YWExYzMzYg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-06-13T08:36:47Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-06-13T08:36:47Z"}, "message": "frontend-passes.c (remove_trim): New function.\n\n2011-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* frontend-passes.c (remove_trim):  New function.\n\t(optimize_assignment):  Use it.\n\t(optimize_comparison):  Likewise.  Return correct status\n\tfor previous change.\n\n2011-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/trim_optimize_8.f90:  New test case.\n\nFrom-SVN: r174983", "tree": {"sha": "691183784964b2e8e6e27bcd2e1e73b4a0358794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/691183784964b2e8e6e27bcd2e1e73b4a0358794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/comments", "author": null, "committer": null, "parents": [{"sha": "29f85237429f703cba263de53a491426b1642d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f85237429f703cba263de53a491426b1642d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f85237429f703cba263de53a491426b1642d1c"}], "stats": {"total": 104, "additions": 61, "deletions": 43}, "files": [{"sha": "af621be59e8f2029d04f641a6a236823617d8db3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "patch": "@@ -1,3 +1,10 @@\n+2011-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* frontend-passes.c (remove_trim):  New function.\n+\t(optimize_assignment):  Use it.\n+\t(optimize_comparison):  Likewise.  Return correct status\n+\tfor previous change.\n+\n 2011-06-12  Tobias Burnus\n \n \tPR fortran/49324"}, {"sha": "4d8c77a12694beb6d27190fcc50afeb083fcb819", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "patch": "@@ -486,6 +486,35 @@ optimize_binop_array_assignment (gfc_code *c, gfc_expr **rhs, bool seen_op)\n   return false;\n }\n \n+/* Remove unneeded TRIMs at the end of expressions.  */\n+\n+static bool\n+remove_trim (gfc_expr *rhs)\n+{\n+  bool ret;\n+\n+  ret = false;\n+\n+  /* Check for a // b // trim(c).  Looping is probably not\n+     necessary because the parser usually generates\n+     (// (// a b ) trim(c) ) , but better safe than sorry.  */\n+\n+  while (rhs->expr_type == EXPR_OP\n+\t && rhs->value.op.op == INTRINSIC_CONCAT)\n+    rhs = rhs->value.op.op2;\n+\n+  while (rhs->expr_type == EXPR_FUNCTION && rhs->value.function.isym\n+\t && rhs->value.function.isym->id == GFC_ISYM_TRIM)\n+    {\n+      strip_function_call (rhs);\n+      /* Recursive call to catch silly stuff like trim ( a // trim(b)).  */\n+      remove_trim (rhs);\n+      ret = true;\n+    }\n+\n+  return ret;\n+}\n+\n /* Optimizations for an assignment.  */\n \n static void\n@@ -499,24 +528,7 @@ optimize_assignment (gfc_code * c)\n   /* Optimize away a = trim(b), where a is a character variable.  */\n \n   if (lhs->ts.type == BT_CHARACTER)\n-    {\n-      /* Check for a // b // trim(c).  Looping is probably not\n-\t necessary because the parser usually generates\n-\t (// (// a b ) trim(c) ) , but better safe than sorry.  */\n-\n-      while (rhs->expr_type == EXPR_OP\n-\t     && rhs->value.op.op == INTRINSIC_CONCAT)\n-\trhs = rhs->value.op.op2;\n-\n-      if (rhs->expr_type == EXPR_FUNCTION &&\n-\t  rhs->value.function.isym &&\n-\t  rhs->value.function.isym->id == GFC_ISYM_TRIM)\n-\t{\n-\t  strip_function_call (rhs);\n-\t  optimize_assignment (c);\n-\t  return;\n-\t}\n-    }\n+    remove_trim (rhs);\n \n   if (lhs->rank > 0 && gfc_check_dependency (lhs, rhs, true) == 0)\n     optimize_binop_array_assignment (c, &rhs, false);\n@@ -639,36 +651,17 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \n   /* Strip off unneeded TRIM calls from string comparisons.  */\n \n-  change = false;\n-\n-  if (op1->expr_type == EXPR_FUNCTION \n-      && op1->value.function.isym\n-      && op1->value.function.isym->id == GFC_ISYM_TRIM)\n-    {\n-      strip_function_call (op1);\n-      change = true;\n-    }\n-\n-  if (op2->expr_type == EXPR_FUNCTION \n-      && op2->value.function.isym\n-      && op2->value.function.isym->id == GFC_ISYM_TRIM)\n-    {\n-      strip_function_call (op2);\n-      change = true;\n-    }\n+  change = remove_trim (op1);\n \n-  if (change)\n-    {\n-      optimize_comparison (e, op);\n-      return true;\n-    }\n+  if (remove_trim (op2))\n+    change = true;\n \n   /* An expression of type EXPR_CONSTANT is only valid for scalars.  */\n   /* TODO: A scalar constant may be acceptable in some cases (the scalarizer\n      handles them well). However, there are also cases that need a non-scalar\n      argument. For example the any intrinsic. See PR 45380.  */\n   if (e->rank > 0)\n-    return false;\n+    return change;\n \n   /* Don't compare REAL or COMPLEX expressions when honoring NaNs.  */\n \n@@ -698,7 +691,7 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t\t\t&& op2_left->expr_type == EXPR_CONSTANT\n \t\t\t&& op1_left->value.character.length\n \t\t\t   != op2_left->value.character.length)\n-\t\t    return false;\n+\t\t    return change;\n \t\t  else\n \t\t    {\n \t\t      free (op1_left);\n@@ -787,7 +780,7 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n \t}\n     }\n \n-  return false;\n+  return change;\n }\n \n /* Optimize a trim function by replacing it with an equivalent substring"}, {"sha": "c3f3a15c4409ab49ed8051aaff0cb132d64721bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "patch": "@@ -1,3 +1,7 @@\n+2011-06-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/trim_optimize_8.f90:  New test case.\n+\n 2011-06-13 Jakub Jelinek  <jakub@redhat.com>\n \t   Ira Rosen  <ira.rosen@linaro.org>\n "}, {"sha": "60dfd193a487360e1a6d75ff5addcd185df28870", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_8.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f21f0daa3b108e1e38be13234e4f6119aa1c33b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_8.f90?ref=4f21f0daa3b108e1e38be13234e4f6119aa1c33b", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fdump-tree-original\" }\n+! Check that trailing trims are also removed from assignment of\n+! expressions involving concatenations of strings .\n+program main\n+  character(2) :: a,b\n+  character(8) :: d\n+  a = 'a '\n+  b = 'b '\n+  if (trim(a // trim(b)) /= 'a b ') call abort\n+  if (trim (trim(a) // trim(b)) /= 'ab ') call abort\n+end\n+! { dg-final { scan-tree-dump-times \"string_len_trim\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}