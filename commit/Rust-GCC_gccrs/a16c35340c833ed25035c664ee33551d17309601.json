{"sha": "a16c35340c833ed25035c664ee33551d17309601", "node_id": "C_kwDOANBUbNoAKGExNmMzNTM0MGM4MzNlZDI1MDM1YzY2NGVlMzM1NTFkMTczMDk2MDE", "commit": {"author": {"name": "liushuyu", "email": "liushuyu011@gmail.com", "date": "2022-09-02T22:08:39Z"}, "committer": {"name": "liushuyu", "email": "liushuyu011@gmail.com", "date": "2022-09-27T04:12:08Z"}, "message": "expand: eager evaluate macros inside builtin macros", "tree": {"sha": "dcf1829b39977c431bfd8ebd72c4e3b8b4a3697e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf1829b39977c431bfd8ebd72c4e3b8b4a3697e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a16c35340c833ed25035c664ee33551d17309601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16c35340c833ed25035c664ee33551d17309601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16c35340c833ed25035c664ee33551d17309601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16c35340c833ed25035c664ee33551d17309601/comments", "author": {"login": "liushuyu", "id": 6829345, "node_id": "MDQ6VXNlcjY4MjkzNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6829345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liushuyu", "html_url": "https://github.com/liushuyu", "followers_url": "https://api.github.com/users/liushuyu/followers", "following_url": "https://api.github.com/users/liushuyu/following{/other_user}", "gists_url": "https://api.github.com/users/liushuyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/liushuyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liushuyu/subscriptions", "organizations_url": "https://api.github.com/users/liushuyu/orgs", "repos_url": "https://api.github.com/users/liushuyu/repos", "events_url": "https://api.github.com/users/liushuyu/events{/privacy}", "received_events_url": "https://api.github.com/users/liushuyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "liushuyu", "id": 6829345, "node_id": "MDQ6VXNlcjY4MjkzNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6829345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liushuyu", "html_url": "https://github.com/liushuyu", "followers_url": "https://api.github.com/users/liushuyu/followers", "following_url": "https://api.github.com/users/liushuyu/following{/other_user}", "gists_url": "https://api.github.com/users/liushuyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/liushuyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liushuyu/subscriptions", "organizations_url": "https://api.github.com/users/liushuyu/orgs", "repos_url": "https://api.github.com/users/liushuyu/repos", "events_url": "https://api.github.com/users/liushuyu/events{/privacy}", "received_events_url": "https://api.github.com/users/liushuyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed1bbaa40527c561b25b5dadb963ca404f2da37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed1bbaa40527c561b25b5dadb963ca404f2da37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed1bbaa40527c561b25b5dadb963ca404f2da37"}], "stats": {"total": 230, "additions": 181, "deletions": 49}, "files": [{"sha": "492faea558aaaca906f5b48aafffa2d5048f99c7", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=a16c35340c833ed25035c664ee33551d17309601", "patch": "@@ -31,6 +31,7 @@ namespace Rust {\n typedef std::string Identifier;\n typedef int TupleIndex;\n struct Session;\n+struct MacroExpander;\n \n namespace AST {\n // foward decl: ast visitor\n@@ -951,6 +952,8 @@ class Expr : public Node\n \n   virtual Location get_locus () const = 0;\n \n+  virtual bool is_literal () const { return false; }\n+\n   // HACK: strictly not needed, but faster than full downcast clone\n   virtual bool is_expr_without_block () const = 0;\n \n@@ -1471,6 +1474,7 @@ struct MacroInvocData\n   // One way of parsing the macro. Probably not applicable for all macros.\n   std::vector<std::unique_ptr<MetaItemInner> > parsed_items;\n   bool parsed_to_meta_item = false;\n+  MacroExpander *expander = nullptr;\n \n public:\n   std::string as_string () const;\n@@ -1495,6 +1499,7 @@ struct MacroInvocData\n     path = other.path;\n     token_tree = other.token_tree;\n     parsed_to_meta_item = other.parsed_to_meta_item;\n+    expander = other.expander;\n \n     parsed_items.reserve (other.parsed_items.size ());\n     for (const auto &e : other.parsed_items)\n@@ -1523,6 +1528,13 @@ struct MacroInvocData\n   SimplePath &get_path () { return path; }\n   const SimplePath &get_path () const { return path; }\n \n+  void set_expander (MacroExpander *new_expander) { expander = new_expander; }\n+  MacroExpander *get_expander ()\n+  {\n+    rust_assert (expander);\n+    return expander;\n+  }\n+\n   void\n   set_meta_item_output (std::vector<std::unique_ptr<MetaItemInner> > new_items)\n   {"}, {"sha": "c764f9c4c66c4b6dee0ed1eb360ad541610e563c", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=a16c35340c833ed25035c664ee33551d17309601", "patch": "@@ -67,6 +67,8 @@ class LiteralExpr : public ExprWithoutBlock\n \n   Location get_locus () const override final { return locus; }\n \n+  bool is_literal () const override final { return true; }\n+\n   Literal get_literal () const { return literal; }\n \n   void accept_vis (ASTVisitor &vis) override;"}, {"sha": "a843fe4c4a42b53ea805a87f404018f49b637b02", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 161, "deletions": 45, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=a16c35340c833ed25035c664ee33551d17309601", "patch": "@@ -17,12 +17,14 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-macro-builtins.h\"\n+#include \"rust-ast.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-expr.h\"\n #include \"rust-session-manager.h\"\n #include \"rust-macro-invoc-lexer.h\"\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n+#include \"rust-attribute-visitor.h\"\n \n namespace Rust {\n namespace {\n@@ -61,13 +63,119 @@ macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n   return last_token_id;\n }\n \n+/* Expand and extract an expression from the macro */\n+\n+static inline AST::ASTFragment\n+try_expand_macro_expression (AST::Expr *expr, MacroExpander *expander)\n+{\n+  rust_assert (expander);\n+\n+  auto vis = Rust::AttrVisitor (*expander);\n+  expr->accept_vis (vis);\n+  return expander->take_expanded_fragment (vis);\n+}\n+\n+/* Expand and then extract a string literal from the macro */\n+\n+static std::unique_ptr<AST::LiteralExpr>\n+try_extract_string_literal_from_fragment (const Location &parent_locus,\n+\t\t\t\t\t  std::unique_ptr<AST::Expr> &node)\n+{\n+  auto maybe_lit = static_cast<AST::LiteralExpr *> (node.get ());\n+  if (!node || !node->is_literal ()\n+      || maybe_lit->get_lit_type () != AST::Literal::STRING)\n+    {\n+      rust_error_at (parent_locus, \"argument must be a string literal\");\n+      if (node)\n+\trust_inform (node->get_locus (), \"expanded from here\");\n+      return nullptr;\n+    }\n+  return std::unique_ptr<AST::LiteralExpr> (\n+    static_cast<AST::LiteralExpr *> (node->clone_expr ().release ()));\n+}\n+\n+static std::unique_ptr<AST::LiteralExpr>\n+try_expand_single_string_literal (AST::Expr *input_expr,\n+\t\t\t\t  const Location &invoc_locus,\n+\t\t\t\t  MacroExpander *expander)\n+{\n+  auto nodes = try_expand_macro_expression (input_expr, expander);\n+  if (nodes.is_error () || nodes.is_expression_fragment ())\n+    {\n+      rust_error_at (input_expr->get_locus (),\n+\t\t     \"argument must be a string literal\");\n+      return nullptr;\n+    }\n+  auto expr = nodes.take_expression_fragment ();\n+  return try_extract_string_literal_from_fragment (input_expr->get_locus (),\n+\t\t\t\t\t\t   expr);\n+}\n+\n+static std::vector<std::unique_ptr<AST::Expr>>\n+try_expand_many_expr (Parser<MacroInvocLexer> &parser,\n+\t\t      const Location &invoc_locus, const TokenId last_token_id,\n+\t\t      MacroExpander *expander, bool &has_error)\n+{\n+  auto restrictions = Rust::ParseRestrictions ();\n+  // stop parsing when encountered a braces/brackets\n+  restrictions.expr_can_be_null = true;\n+  // we can't use std::optional, so...\n+  auto result = std::vector<std::unique_ptr<AST::Expr>> ();\n+  auto empty_expr = std::vector<std::unique_ptr<AST::Expr>> ();\n+\n+  auto first_token = parser.peek_current_token ()->get_id ();\n+  if (first_token == COMMA)\n+    {\n+      rust_error_at (parser.peek_current_token ()->get_locus (),\n+\t\t     \"expected expression, found %<,%>\");\n+      has_error = true;\n+      return empty_expr;\n+    }\n+\n+  while (parser.peek_current_token ()->get_id () != last_token_id\n+\t && parser.peek_current_token ()->get_id () != END_OF_FILE)\n+    {\n+      auto expr = parser.parse_expr (AST::AttrVec (), restrictions);\n+      // something must be so wrong that the expression could not be parsed\n+      rust_assert (expr);\n+      auto nodes = try_expand_macro_expression (expr.get (), expander);\n+      if (nodes.is_error ())\n+\t{\n+\t  // not macro\n+\t  result.push_back (std::move (expr));\n+\t}\n+      else if (!nodes.is_expression_fragment ())\n+\t{\n+\t  rust_error_at (expr->get_locus (), \"expected expression\");\n+\t  has_error = true;\n+\t  return empty_expr;\n+\t}\n+      else\n+\t{\n+\t  result.push_back (nodes.take_expression_fragment ());\n+\t}\n+\n+      auto next_token = parser.peek_current_token ();\n+      if (!parser.skip_token (COMMA) && next_token->get_id () != last_token_id)\n+\t{\n+\t  rust_error_at (next_token->get_locus (), \"expected token: %<,%>\");\n+\t  // TODO: is this recoverable? to avoid crashing the parser in the next\n+\t  // fragment we have to exit early here\n+\t  has_error = true;\n+\t  return empty_expr;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n /* Parse a single string literal from the given delimited token tree,\n    and return the LiteralExpr for it. Allow for an optional trailing comma,\n    but otherwise enforce that these are the only tokens.  */\n \n std::unique_ptr<AST::LiteralExpr>\n parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n-\t\t\t     Location invoc_locus)\n+\t\t\t     Location invoc_locus, MacroExpander *expander)\n {\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n   Parser<MacroInvocLexer> parser (lex);\n@@ -89,7 +197,13 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n   else if (parser.peek_current_token ()->get_id () == last_token_id)\n     rust_error_at (invoc_locus, \"macro takes 1 argument\");\n   else\n-    rust_error_at (invoc_locus, \"argument must be a string literal\");\n+    {\n+      // when the expression does not seem to be a string literal, we then try\n+      // to parse/expand it as macro to see if it expands to a string literal\n+      auto expr = parser.parse_expr ();\n+      lit_expr\n+\t= try_expand_single_string_literal (expr.get (), invoc_locus, expander);\n+    }\n \n   parser.skip_token (last_token_id);\n \n@@ -188,7 +302,8 @@ MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+\t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::ASTFragment::create_error ();\n \n@@ -230,7 +345,8 @@ MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+\t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::ASTFragment::create_error ();\n \n@@ -252,7 +368,8 @@ AST::ASTFragment\n MacroBuiltin::compile_error (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+\t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::ASTFragment::create_error ();\n \n@@ -278,23 +395,30 @@ MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n \n   /* NOTE: concat! could accept no argument, so we don't have any checks here */\n-  while (parser.peek_current_token ()->get_id () != last_token_id)\n+  auto expanded_expr = try_expand_many_expr (parser, invoc_locus, last_token_id,\n+\t\t\t\t\t     invoc.get_expander (), has_error);\n+  for (auto &expr : expanded_expr)\n     {\n-      auto lit_expr = parser.parse_literal_expr ();\n-      if (lit_expr)\n+      if (!expr->is_literal ())\n \t{\n-\t  str += lit_expr->as_string ();\n+\t  has_error = true;\n+\t  rust_error_at (expr->get_locus (), \"expected a literal\");\n+\t  // diagnostics copied from rustc\n+\t  rust_inform (expr->get_locus (),\n+\t\t       \"only literals (like %<\\\"foo\\\"%>, %<42%> and \"\n+\t\t       \"%<3.14%>) can be passed to %<concat!()%>\");\n+\t  continue;\n \t}\n-      else\n+      auto *literal = static_cast<AST::LiteralExpr *> (expr.get ());\n+      if (literal->get_lit_type () == AST::Literal::BYTE\n+\t  || literal->get_lit_type () == AST::Literal::BYTE_STRING)\n \t{\n-\t  auto current_token = parser.peek_current_token ();\n-\t  rust_error_at (current_token->get_locus (),\n-\t\t\t \"argument must be a constant literal\");\n \t  has_error = true;\n-\t  // Just crash if the current token can't be skipped\n-\t  rust_assert (parser.skip_token (current_token->get_id ()));\n+\t  rust_error_at (expr->get_locus (),\n+\t\t\t \"cannot concatenate a byte string literal\");\n+\t  continue;\n \t}\n-      parser.maybe_skip_token (COMMA);\n+      str += literal->as_string ();\n     }\n \n   parser.skip_token (last_token_id);\n@@ -317,45 +441,36 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n   Parser<MacroInvocLexer> parser (lex);\n \n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+  std::unique_ptr<AST::LiteralExpr> error_expr = nullptr;\n+  std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n+  bool has_error = false;\n \n-  if (parser.peek_current_token ()->get_id () != STRING_LITERAL)\n+  auto expanded_expr = try_expand_many_expr (parser, invoc_locus, last_token_id,\n+\t\t\t\t\t     invoc.get_expander (), has_error);\n+  if (has_error)\n+    return AST::ASTFragment::create_error ();\n+  if (expanded_expr.size () < 1 || expanded_expr.size () > 2)\n     {\n-      if (parser.peek_current_token ()->get_id () == last_token_id)\n-\trust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n-      else\n-\trust_error_at (parser.peek_current_token ()->get_locus (),\n-\t\t       \"argument must be a string literal\");\n+      rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n       return AST::ASTFragment::create_error ();\n     }\n-\n-  auto lit_expr = parser.parse_literal_expr ();\n-  auto comma_skipped = parser.maybe_skip_token (COMMA);\n-\n-  std::unique_ptr<AST::LiteralExpr> error_expr = nullptr;\n-\n-  if (parser.peek_current_token ()->get_id () != last_token_id)\n+  if (expanded_expr.size () > 0)\n     {\n-      if (!comma_skipped)\n+      if (!(lit_expr\n+\t    = try_extract_string_literal_from_fragment (invoc_locus,\n+\t\t\t\t\t\t\texpanded_expr[0])))\n \t{\n-\t  rust_error_at (parser.peek_current_token ()->get_locus (),\n-\t\t\t \"expected token: %<,%>\");\n \t  return AST::ASTFragment::create_error ();\n \t}\n-      if (parser.peek_current_token ()->get_id () != STRING_LITERAL)\n+    }\n+  if (expanded_expr.size () > 1)\n+    {\n+      if (!(error_expr\n+\t    = try_extract_string_literal_from_fragment (invoc_locus,\n+\t\t\t\t\t\t\texpanded_expr[1])))\n \t{\n-\t  rust_error_at (parser.peek_current_token ()->get_locus (),\n-\t\t\t \"argument must be a string literal\");\n \t  return AST::ASTFragment::create_error ();\n \t}\n-\n-      error_expr = parser.parse_literal_expr ();\n-      parser.maybe_skip_token (COMMA);\n-    }\n-\n-  if (parser.peek_current_token ()->get_id () != last_token_id)\n-    {\n-      rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n-      return AST::ASTFragment::create_error ();\n     }\n \n   parser.skip_token (last_token_id);\n@@ -421,7 +536,8 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+\t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::ASTFragment::create_error ();\n "}, {"sha": "e7a7b846ed42ebcc95e7e2e88c2b3978d7b79876", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16c35340c833ed25035c664ee33551d17309601/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=a16c35340c833ed25035c664ee33551d17309601", "patch": "@@ -163,6 +163,7 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n   rust_assert (ok);\n \n   auto fragment = AST::ASTFragment::create_error ();\n+  invoc_data.set_expander (this);\n \n   if (rules_def->is_builtin ())\n     fragment"}, {"sha": "8a84934f94980bda62986c03db439cf6ced70348", "filename": "gcc/testsuite/rust/compile/builtin_macro_concat.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16c35340c833ed25035c664ee33551d17309601/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16c35340c833ed25035c664ee33551d17309601/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_concat.rs?ref=a16c35340c833ed25035c664ee33551d17309601", "patch": "@@ -6,12 +6,13 @@ macro_rules! concat {\n fn main() {\n     let not_literal = \"identifier\";\n     concat!();\n-    concat! (,); // { dg-error \"argument must be a constant literal\" }\n-    concat!(not_literal); // { dg-error \"argument must be a constant literal\" }\n+    concat! (,); // { dg-error \"expected expression, found .,.\" }\n+    concat!(not_literal); // { dg-error \"expected a literal\" }\n     concat!(\"message\");\n     concat!(\"message\",);\n     concat!(\"message\", 1, true, false, 1.0, 10usize, 2000u64);\n     concat!(\"message\", 1, true, false, 1.0, 10usize, 2000u64,);\n-    concat! (\"m\", not_literal); // { dg-error \"argument must be a constant literal\" }\n-    concat!(not_literal invalid 'm' !!,); // { dg-error \"argument must be a constant literal\" }\n+    concat! (\"m\", not_literal); // { dg-error \"expected a literal\" }\n+    concat!(not_literal invalid 'm' !!,); // { dg-error \"expected token: .,.\" }\n+                                          // { dg-error \"expected a literal\" \"\" { target *-*-* } .-1 }\n }"}]}