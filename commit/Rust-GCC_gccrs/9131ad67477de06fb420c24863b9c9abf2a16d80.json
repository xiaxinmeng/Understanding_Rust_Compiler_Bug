{"sha": "9131ad67477de06fb420c24863b9c9abf2a16d80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzMWFkNjc0NzdkZTA2ZmI0MjBjMjQ4NjNiOWM5YWJmMmExNmQ4MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-19T21:52:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-19T21:52:41Z"}, "message": "Use backend interface for temporary variables.\n\n\t* go-gcc.cc (Gcc_backend::temporary_variable): New function.\n\nFrom-SVN: r172737", "tree": {"sha": "09b4493c30f3ccd5ea96ddd3dd3b139abdffcd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09b4493c30f3ccd5ea96ddd3dd3b139abdffcd5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9131ad67477de06fb420c24863b9c9abf2a16d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9131ad67477de06fb420c24863b9c9abf2a16d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9131ad67477de06fb420c24863b9c9abf2a16d80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9131ad67477de06fb420c24863b9c9abf2a16d80/comments", "author": null, "committer": null, "parents": [{"sha": "f067961248ea104024f8b313ae39b3b95af1f8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f067961248ea104024f8b313ae39b3b95af1f8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f067961248ea104024f8b313ae39b3b95af1f8b5"}], "stats": {"total": 223, "additions": 152, "deletions": 71}, "files": [{"sha": "37d6b6c0d16c2f8c42fde9a26772cae40ebd4475", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -1,3 +1,7 @@\n+2011-04-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::temporary_variable): New function.\n+\n 2011-04-19  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (class Bblock): Define."}, {"sha": "7b7923d06f95fc5f7656363d6a91050809d0e91b", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -255,6 +255,10 @@ class Gcc_backend : public Backend\n   parameter_variable(Bfunction*, const std::string& name, Btype* type,\n \t\t     source_location);\n \n+  Bvariable*\n+  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n+\t\t     source_location, Bstatement**);\n+\n   // Labels.\n \n   Blabel*\n@@ -702,6 +706,68 @@ Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n   return new Bvariable(decl);\n }\n \n+// Make a temporary variable.\n+\n+Bvariable*\n+Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n+\t\t\t\tBtype* btype, Bexpression* binit,\n+\t\t\t\tbool is_address_taken,\n+\t\t\t\tsource_location location,\n+\t\t\t\tBstatement** pstatement)\n+{\n+  tree type_tree = btype->get_tree();\n+  tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree();\n+  if (type_tree == error_mark_node || init_tree == error_mark_node)\n+    {\n+      *pstatement = this->error_statement();\n+      return this->error_variable();\n+    }\n+\n+  tree var;\n+  // We can only use create_tmp_var if the type is not addressable.\n+  if (!TREE_ADDRESSABLE(type_tree))\n+    var = create_tmp_var(type_tree, \"GOTMP\");\n+  else\n+    {\n+      gcc_assert(bblock != NULL);\n+      var = build_decl(location, VAR_DECL,\n+\t\t       create_tmp_var_name(\"GOTMP\"),\n+\t\t       type_tree);\n+      DECL_ARTIFICIAL(var) = 1;\n+      DECL_IGNORED_P(var) = 1;\n+      TREE_USED(var) = 1;\n+      // FIXME: Permitting function to be NULL here is a temporary\n+      // measure until we have a proper representation of the init\n+      // function.\n+      if (function != NULL)\n+\tDECL_CONTEXT(var) = function->get_tree();\n+      else\n+\t{\n+\t  gcc_assert(current_function_decl != NULL_TREE);\n+\t  DECL_CONTEXT(var) = current_function_decl;\n+\t}\n+\n+      // We have to add this variable to the BLOCK and the BIND_EXPR.\n+      tree bind_tree = bblock->get_tree();\n+      gcc_assert(TREE_CODE(bind_tree) == BIND_EXPR);\n+      tree block_tree = BIND_EXPR_BLOCK(bind_tree);\n+      gcc_assert(TREE_CODE(block_tree) == BLOCK);\n+      DECL_CHAIN(var) = BLOCK_VARS(block_tree);\n+      BLOCK_VARS(block_tree) = var;\n+      BIND_EXPR_VARS(bind_tree) = BLOCK_VARS(block_tree);\n+    }\n+\n+  if (init_tree != NULL_TREE)\n+    DECL_INITIAL(var) = fold_convert_loc(location, type_tree, init_tree);\n+\n+  if (is_address_taken)\n+    TREE_ADDRESSABLE(var) = 1;\n+\n+  *pstatement = this->make_statement(build1_loc(location, DECL_EXPR,\n+\t\t\t\t\t\tvoid_type_node, var));\n+  return new Bvariable(var);\n+}\n+\n // Make a label.\n \n Blabel*"}, {"sha": "4377332ed09807fa25e9dbcabdafcb1f9b6a458e", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -246,6 +246,22 @@ class Backend\n   parameter_variable(Bfunction* function, const std::string& name,\n \t\t     Btype* type, source_location location) = 0;\n \n+  // Create a temporary variable.  A temporary variable has no name,\n+  // just a type.  We pass in FUNCTION and BLOCK in case they are\n+  // needed.  If INIT is not NULL, the variable should be initialized\n+  // to that value.  Otherwise the initial value is irrelevant--the\n+  // backend does not have to explicitly initialize it to zero.\n+  // ADDRESS_IS_TAKEN is true if the programs needs to take the\n+  // address of this temporary variable.  LOCATION is the location of\n+  // the statement or expression which requires creating the temporary\n+  // variable, and may not be very useful.  This function should\n+  // return a variable which can be referenced later and should set\n+  // *PSTATEMENT to a statement which initializes the variable.\n+  virtual Bvariable*\n+  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,\n+\t\t     bool address_is_taken, source_location location,\n+\t\t     Bstatement** pstatement) = 0;\n+\n   // Labels.\n   \n   // Create a new label.  NAME will be empty if this is a label"}, {"sha": "5f885ab5b3c01845ab6ded9dc264762213f60e01", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -1029,9 +1029,22 @@ Temporary_reference_expression::do_address_taken(bool)\n // Get a tree referring to the variable.\n \n tree\n-Temporary_reference_expression::do_get_tree(Translate_context*)\n+Temporary_reference_expression::do_get_tree(Translate_context* context)\n {\n-  return this->statement_->get_decl();\n+  Bvariable* bvar = this->statement_->get_backend_variable(context);\n+\n+  // The gcc backend can't represent the same set of recursive types\n+  // that the Go frontend can.  In some cases this means that a\n+  // temporary variable won't have the right backend type.  Correct\n+  // that here by adding a type cast.  We need to use base() to push\n+  // the circularity down one level.\n+  tree ret = var_to_tree(bvar);\n+  if (POINTER_TYPE_P(TREE_TYPE(ret)) && VOID_TYPE_P(TREE_TYPE(TREE_TYPE(ret))))\n+    {\n+      tree type_tree = this->type()->base()->get_tree(context->gogo());\n+      ret = fold_convert_loc(this->location(), type_tree, ret);\n+    }\n+  return ret;\n }\n \n // Make a reference to a temporary variable.\n@@ -8952,7 +8965,7 @@ Call_expression::do_get_tree(Translate_context* context)\n \n   // This is to support builtin math functions when using 80387 math.\n   tree excess_type = NULL_TREE;\n-  if (DECL_P(fndecl)\n+  if (TREE_CODE(fndecl) == FUNCTION_DECL\n       && DECL_IS_BUILTIN(fndecl)\n       && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL\n       && nargs > 0"}, {"sha": "eef93981aaae9c7fc1b5554cb79270402cc20c56", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 42, "deletions": 56, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -311,19 +311,6 @@ Temporary_statement::type() const\n   return this->type_ != NULL ? this->type_ : this->init_->type();\n }\n \n-// Return the tree for the temporary variable.\n-\n-tree\n-Temporary_statement::get_decl() const\n-{\n-  if (this->decl_ == NULL)\n-    {\n-      gcc_assert(saw_errors());\n-      return error_mark_node;\n-    }\n-  return this->decl_;\n-}\n-\n // Traversal.\n \n int\n@@ -400,53 +387,52 @@ Temporary_statement::do_check_types(Gogo*)\n tree\n Temporary_statement::do_get_tree(Translate_context* context)\n {\n-  gcc_assert(this->decl_ == NULL_TREE);\n-  tree type_tree = this->type()->get_tree(context->gogo());\n-  tree init_tree = (this->init_ == NULL\n-\t\t    ? NULL_TREE\n-\t\t    : this->init_->get_tree(context));\n-  if (type_tree == error_mark_node || init_tree == error_mark_node)\n-    {\n-      this->decl_ = error_mark_node;\n-      return error_mark_node;\n-    }\n-  // We can only use create_tmp_var if the type is not addressable.\n-  if (!TREE_ADDRESSABLE(type_tree))\n+  gcc_assert(this->bvariable_ == NULL);\n+\n+  // FIXME: Permitting FUNCTION to be NULL here is a temporary measure\n+  // until we have a better representation of the init function.\n+  Named_object* function = context->function();\n+  Bfunction* bfunction;\n+  if (function == NULL)\n+    bfunction = NULL;\n+  else\n+    bfunction = tree_to_function(function->func_value()->get_decl());\n+\n+  Btype* btype = tree_to_type(this->type()->get_tree(context->gogo()));\n+\n+  Bexpression* binit;\n+  if (this->init_ == NULL)\n+    binit = NULL;\n+  else if (this->type_ == NULL)\n+    binit = tree_to_expr(this->init_->get_tree(context));\n+  else\n     {\n-      this->decl_ = create_tmp_var(type_tree, \"GOTMP\");\n-      DECL_SOURCE_LOCATION(this->decl_) = this->location();\n+      Expression* init = Expression::make_cast(this->type_, this->init_,\n+\t\t\t\t\t       this->location());\n+      context->gogo()->lower_expression(context->function(), &init);\n+      binit = tree_to_expr(init->get_tree(context));\n     }\n-  else\n+\n+  Bstatement* statement;\n+  this->bvariable_ =\n+    context->backend()->temporary_variable(bfunction, context->bblock(),\n+\t\t\t\t\t   btype, binit,\n+\t\t\t\t\t   this->is_address_taken_,\n+\t\t\t\t\t   this->location(), &statement);\n+  return stat_to_tree(statement);\n+}\n+\n+// Return the backend variable.\n+\n+Bvariable*\n+Temporary_statement::get_backend_variable(Translate_context* context) const\n+{\n+  if (this->bvariable_ == NULL)\n     {\n-      gcc_assert(context->function() != NULL && context->block() != NULL);\n-      tree decl = build_decl(this->location(), VAR_DECL,\n-\t\t\t     create_tmp_var_name(\"GOTMP\"),\n-\t\t\t     type_tree);\n-      DECL_ARTIFICIAL(decl) = 1;\n-      DECL_IGNORED_P(decl) = 1;\n-      TREE_USED(decl) = 1;\n-      gcc_assert(current_function_decl != NULL_TREE);\n-      DECL_CONTEXT(decl) = current_function_decl;\n-\n-      // We have to add this variable to the BLOCK and the BIND_EXPR.\n-      tree bind_tree = block_to_tree(context->bblock());\n-      gcc_assert(bind_tree != NULL_TREE && TREE_CODE(bind_tree) == BIND_EXPR);\n-      tree block_tree = BIND_EXPR_BLOCK(bind_tree);\n-      gcc_assert(TREE_CODE(block_tree) == BLOCK);\n-      DECL_CHAIN(decl) = BLOCK_VARS(block_tree);\n-      BLOCK_VARS(block_tree) = decl;\n-      BIND_EXPR_VARS(bind_tree) = BLOCK_VARS(block_tree);\n-\n-      this->decl_ = decl;\n+      gcc_assert(saw_errors());\n+      return context->backend()->error_variable();\n     }\n-  if (init_tree != NULL_TREE)\n-    DECL_INITIAL(this->decl_) =\n-      Expression::convert_for_assignment(context, this->type(),\n-\t\t\t\t\t this->init_->type(), init_tree,\n-\t\t\t\t\t this->location());\n-  if (this->is_address_taken_)\n-    TREE_ADDRESSABLE(this->decl_) = 1;\n-  return this->build_stmt_1(DECL_EXPR, this->decl_);\n+  return this->bvariable_;\n }\n \n // Make and initialize a temporary variable in BLOCK."}, {"sha": "2310ef1d705eece950a7a6dc16229d98f07cad3a", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9131ad67477de06fb420c24863b9c9abf2a16d80/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=9131ad67477de06fb420c24863b9c9abf2a16d80", "patch": "@@ -41,6 +41,7 @@ class Select_clauses;\n class Typed_identifier_list;\n class Bexpression;\n class Bstatement;\n+class Bvariable;\n \n // This class is used to traverse assignments made by a statement\n // which makes assignments.\n@@ -475,28 +476,23 @@ class Temporary_statement : public Statement\n  public:\n   Temporary_statement(Type* type, Expression* init, source_location location)\n     : Statement(STATEMENT_TEMPORARY, location),\n-      type_(type), init_(init), decl_(NULL), is_address_taken_(false)\n+      type_(type), init_(init), bvariable_(NULL), is_address_taken_(false)\n   { }\n \n   // Return the type of the temporary variable.\n   Type*\n   type() const;\n \n-  // Return the initialization expression.\n-  Expression*\n-  init() const\n-  { return this->init_; }\n-\n   // Record that something takes the address of this temporary\n   // variable.\n   void\n   set_is_address_taken()\n   { this->is_address_taken_ = true; }\n \n-  // Return the tree for the temporary variable itself.  This should\n-  // not be called until after the statement itself has been expanded.\n-  tree\n-  get_decl() const;\n+  // Return the temporary variable.  This should not be called until\n+  // after the statement itself has been converted.\n+  Bvariable*\n+  get_backend_variable(Translate_context*) const;\n \n  protected:\n   int\n@@ -519,8 +515,8 @@ class Temporary_statement : public Statement\n   Type* type_;\n   // The initial value of the temporary variable.  This may be NULL.\n   Expression* init_;\n-  // The DECL for the temporary variable.\n-  tree decl_;\n+  // The backend representation of the temporary variable.\n+  Bvariable* bvariable_;\n   // True if something takes the address of this temporary variable.\n   bool is_address_taken_;\n };"}]}