{"sha": "0666767eb4cc864f00ba34d97b9d58f8dc650bba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY2Njc2N2ViNGNjODY0ZjAwYmEzNGQ5N2I5ZDU4ZjhkYzY1MGJiYQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-10T19:55:10Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-10T23:37:06Z"}, "message": "coroutines: Revise await expansions [PR94528]\n\nThe expansions for await expressions were specific to particular\ncases, this revises it to be more generic.\n\na: Revise co_await statement walkers.\n\nWe want to process the co_awaits one statement at a time.\nWe also want to be able to determine the insertion points for\nnew bind scopes needed to cater for temporaries that are\ncaptured by reference and have lifetimes that need extension\nto the end of the full expression.  Likewise, the handling of\ncaptured references in the evaluation of conditions might\nresult in the need to make a frame copy.\n\nThis reorganises the statement walking code to make it easier to\nextend for these purposes.\n\nb: Factor reference-captured temp code.\n\nWe want to be able to use the code that writes a new bind expr\nwith vars (and their initializers) from several places, so split\nthat out of the maybe_promote_captured_temps() function into a\nnew replace_statement_captures ().  Update some comments.\n\nc: Generalize await statement expansion.\n\nThis revises the expansion to avoid the need to expand conditionally\non the tree type.  It resolves PR 94528.\n\ngcc/cp/ChangeLog:\n\n2020-04-10  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94538\n\t* coroutines.cc (co_await_expander): Remove.\n\t(expand_one_await_expression): New.\n\t(process_one_statement): New.\n\t(await_statement_expander): New.\n\t(build_actor_fn): Revise to use per-statement expander.\n\t(struct susp_frame_data): Reorder and comment.\n\t(register_awaits): Factor code.\n\t(replace_statement_captures): New, factored from...\n\t(maybe_promote_captured_temps):.. here.\n\t(await_statement_walker): Revise to process per statement.\n\t(morph_fn_to_coro): Use revised susp_frame_data layout.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-10  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94538\n\t* g++.dg/coroutines/pr94528.C: New test.", "tree": {"sha": "fda2709526ce8a15a6a8d36ff84121b502471ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fda2709526ce8a15a6a8d36ff84121b502471ec9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0666767eb4cc864f00ba34d97b9d58f8dc650bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0666767eb4cc864f00ba34d97b9d58f8dc650bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0666767eb4cc864f00ba34d97b9d58f8dc650bba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0666767eb4cc864f00ba34d97b9d58f8dc650bba/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c25d7adb1a5664982449dda0e7f9ca63cf4735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c25d7adb1a5664982449dda0e7f9ca63cf4735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c25d7adb1a5664982449dda0e7f9ca63cf4735"}], "stats": {"total": 540, "additions": 332, "deletions": 208}, "files": [{"sha": "79c292a821a74029dd504cca3b51155dadf254fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0666767eb4cc864f00ba34d97b9d58f8dc650bba", "patch": "@@ -1,3 +1,18 @@\n+2020-04-10  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94538\n+\t* coroutines.cc (co_await_expander): Remove.\n+\t(expand_one_await_expression): New.\n+\t(process_one_statement): New.\n+\t(await_statement_expander): New.\n+\t(build_actor_fn): Revise to use per-statement expander.\n+\t(struct susp_frame_data): Reorder and comment.\n+\t(register_awaits): Factor code.\n+\t(replace_statement_captures): New, factored from...\n+\t(maybe_promote_captured_temps):.. here.\n+\t(await_statement_walker): Revise to process per statement.\n+\t(morph_fn_to_coro): Use revised susp_frame_data layout.\n+\n 2020-04-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94149"}, {"sha": "57172853639cb5a5d0910f8c1ed4070849789238", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 248, "deletions": 208, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=0666767eb4cc864f00ba34d97b9d58f8dc650bba", "patch": "@@ -1359,6 +1359,13 @@ struct coro_aw_data\n   unsigned index;  /* This is our current resume index.  */\n };\n \n+/* Lighweight search for the first await expression in tree-walk order.\n+   returns:\n+     The first await expression found in STMT.\n+     NULL_TREE if there are none.\n+   So can be used to determine if the statement needs to be processed for\n+   awaits.  */\n+\n static tree\n co_await_find_in_subtree (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n {\n@@ -1371,57 +1378,33 @@ co_await_find_in_subtree (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   return NULL_TREE;\n }\n \n-/* When we come here:\n-    the first operand is the [currently unused] handle for suspend.\n-    the second operand is the var to be copy-initialized\n-    the third operand is 'o' (the initializer for the second)\n-\t\t\t      as defined in [await.expr] (3.3)\n-    the fourth operand is the mode as per the comment on build_co_await ().\n+/* Starting with a statment:\n \n-   When we leave:\n-   the IFN_CO_YIELD carries the labels of the resume and destroy\n-   branch targets for this await.  */\n+   stmt => some tree containing one or more await expressions.\n \n-static tree\n-co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n-{\n-  if (STATEMENT_CLASS_P (*stmt) || !EXPR_P (*stmt))\n-    return NULL_TREE;\n+   We replace the statement with:\n+   <STATEMENT_LIST> {\n+      initialise awaitable\n+      if (!ready)\n+\t{\n+\t  suspension context.\n+\t}\n+      resume:\n+\trevised statement with one await expression rewritten to its\n+\tawait_resume() return value.\n+   }\n+\n+   We then recurse into the initializer and the revised statement\n+   repeating this replacement until there are no more await expressions\n+   in either.  */\n \n+static tree *\n+expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n+{\n   coro_aw_data *data = (coro_aw_data *) d;\n-  enum tree_code stmt_code = TREE_CODE (*stmt);\n-  tree stripped_stmt = *stmt;\n-  tree *buried_stmt = NULL;\n-  tree saved_co_await = NULL_TREE;\n-  enum tree_code sub_code = NOP_EXPR;\n-\n-  if (stmt_code == MODIFY_EXPR || stmt_code == INIT_EXPR)\n-    {\n-      sub_code = TREE_CODE (TREE_OPERAND (stripped_stmt, 1));\n-      if (sub_code == CO_AWAIT_EXPR)\n-\tsaved_co_await = TREE_OPERAND (stripped_stmt, 1); /* Get the RHS.  */\n-      else if (tree r\n-\t       = cp_walk_tree (&TREE_OPERAND (stripped_stmt, 1),\n-\t\t\t       co_await_find_in_subtree, &buried_stmt, NULL))\n-\tsaved_co_await = r;\n-    }\n-  else if (stmt_code == CALL_EXPR)\n-    {\n-      if (tree r = cp_walk_tree (&stripped_stmt, co_await_find_in_subtree,\n-\t\t\t\t &buried_stmt, NULL))\n-\tsaved_co_await = r;\n-    }\n-  else if ((stmt_code == CONVERT_EXPR || stmt_code == NOP_EXPR)\n-\t   && TREE_CODE (TREE_OPERAND (stripped_stmt, 0)) == CO_AWAIT_EXPR)\n-    saved_co_await = TREE_OPERAND (stripped_stmt, 0);\n-  else if (stmt_code == CO_AWAIT_EXPR)\n-    saved_co_await = stripped_stmt;\n-\n-  if (!saved_co_await)\n-    return NULL_TREE;\n \n-  /* We want to splice in the await_resume() value in some cases.  */\n   tree saved_statement = *stmt;\n+  tree saved_co_await = *await_expr;\n \n   tree actor = data->actor_fn;\n   location_t loc = EXPR_LOCATION (*stmt);\n@@ -1454,14 +1437,17 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   tree stmt_list = NULL;\n   tree t_expr = STRIP_NOPS (expr);\n   tree r;\n+  tree *await_init = NULL;\n   if (t_expr == var)\n     dtor = NULL_TREE;\n   else\n     {\n       /* Initialize the var from the provided 'o' expression.  */\n       r = build2 (INIT_EXPR, await_type, var, expr);\n       r = coro_build_cvt_void_expr_stmt (r, loc);\n-      append_to_statement_list (r, &stmt_list);\n+      append_to_statement_list_force (r, &stmt_list);\n+      /* We have an initializer, which might itself contain await exprs.  */\n+      await_init = tsi_stmt_ptr (tsi_last (stmt_list));\n     }\n \n   /* Use the await_ready() call to test if we need to suspend.  */\n@@ -1597,46 +1583,77 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   if (REFERENCE_REF_P (resume_call))\n     /* Sink to await_resume call_expr.  */\n     resume_call = TREE_OPERAND (resume_call, 0);\n-  switch (stmt_code)\n-    {\n-    default: /* not likely to work .. but... */\n-      append_to_statement_list (resume_call, &stmt_list);\n-      break;\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      TREE_OPERAND (stripped_stmt, 0) = resume_call;\n-      append_to_statement_list (saved_statement, &stmt_list);\n-      break;\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-    case CALL_EXPR:\n-      /* Replace the use of co_await by the resume expr.  */\n-      if (sub_code == CO_AWAIT_EXPR)\n-\t{\n-\t  /* We're updating the interior of a possibly <(void) expr>cleanup.  */\n-\t  TREE_OPERAND (stripped_stmt, 1) = resume_call;\n-\t  append_to_statement_list (saved_statement, &stmt_list);\n-\t}\n-      else if (buried_stmt != NULL)\n-\t{\n-\t  *buried_stmt = resume_call;\n-\t  append_to_statement_list (saved_statement, &stmt_list);\n-\t}\n-      else\n-\t{\n-\t  error_at (loc, \"failed to substitute the resume method in %qE\",\n-\t\t    saved_statement);\n-\t  append_to_statement_list (saved_statement, &stmt_list);\n-\t}\n-      break;\n-    }\n+\n+  *await_expr = resume_call; /* Replace the co_await expr with its result.  */\n+  append_to_statement_list_force (saved_statement, &stmt_list);\n+  /* Get a pointer to the revised statment.  */\n+  tree *revised = tsi_stmt_ptr (tsi_last (stmt_list));\n   if (needs_dtor)\n     append_to_statement_list (dtor, &stmt_list);\n   data->index += 2;\n+\n+  /* Replace the original statement with the expansion.  */\n   *stmt = stmt_list;\n+\n+  /* Now, if the awaitable had an initializer, expand any awaits that might\n+     be embedded in it.  */\n+  tree *aw_expr_ptr;\n+  if (await_init &&\n+      cp_walk_tree (await_init, co_await_find_in_subtree, &aw_expr_ptr, NULL))\n+    expand_one_await_expression (await_init, aw_expr_ptr, d);\n+\n+  /* Expand any more await expressions in the the original statement.  */\n+  if (cp_walk_tree (revised, co_await_find_in_subtree, &aw_expr_ptr, NULL))\n+    expand_one_await_expression (revised, aw_expr_ptr, d);\n+\n+  return NULL;\n+}\n+\n+/* Check to see if a statement contains at least one await expression, if\n+   so, then process that.  */\n+\n+static tree\n+process_one_statement (tree *stmt, void *d)\n+{\n+  tree *aw_expr_ptr;\n+  if (cp_walk_tree (stmt, co_await_find_in_subtree, &aw_expr_ptr, NULL))\n+    expand_one_await_expression (stmt, aw_expr_ptr, d);\n   return NULL_TREE;\n }\n \n+static tree\n+await_statement_expander (tree *stmt, int *do_subtree, void *d)\n+{\n+  tree res = NULL_TREE;\n+\n+  /* Process a statement at a time.  */\n+  if (TREE_CODE (*stmt) == BIND_EXPR)\n+    res = cp_walk_tree (&BIND_EXPR_BODY (*stmt), await_statement_expander,\n+\t\t\td, NULL);\n+  else if (TREE_CODE (*stmt) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator i;\n+      for (i = tsi_start (*stmt); !tsi_end_p (i); tsi_next (&i))\n+\t{\n+\t  res = cp_walk_tree (tsi_stmt_ptr (i), await_statement_expander,\n+\t\t\t      d, NULL);\n+\t  if (res)\n+\t    return res;\n+\t}\n+      *do_subtree = 0; /* Done subtrees.  */\n+    }\n+  else if (STATEMENT_CLASS_P (*stmt))\n+    return NULL_TREE; /* Process the sub-trees.  */\n+  else if (EXPR_P (*stmt))\n+    {\n+      process_one_statement (stmt, d);\n+      *do_subtree = 0; /* Done subtrees.  */\n+    }\n+\n+  /* Continue statement walk, where required.  */\n+  return res;\n+}\n+\n /* Suspend point hash_map.  */\n \n struct suspend_point_info\n@@ -2398,7 +2415,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   coro_aw_data data = {actor, actor_fp, resume_pt_number, i_a_r_c,\n \t\t       ash, del_promise_label, ret_label,\n \t\t       continue_label, continuation, 2};\n-  cp_walk_tree (&actor_body, co_await_expander, &data, NULL);\n+  cp_walk_tree (&actor_body, await_statement_expander, &data, NULL);\n \n   actor_body = pop_stmt_list (actor_body);\n   BIND_EXPR_BODY (actor_bind) = actor_body;\n@@ -2564,16 +2581,21 @@ coro_make_frame_entry (tree *field_list, const char *name, tree fld_type,\n   return id;\n }\n \n+/* This data set is used when analyzing statements for await expressions.  */\n struct susp_frame_data\n {\n-  tree *field_list;\n-  tree handle_type;\n-  hash_set<tree> captured_temps;\n-  vec<tree, va_gc> *to_replace;\n-  vec<tree, va_gc> *block_stack;\n-  unsigned count;\n-  unsigned saw_awaits;\n-  bool captures_temporary;\n+  /* Function-wide.  */\n+  tree *field_list; /* The current coroutine frame field list.  */\n+  tree handle_type; /* The self-handle type for this coroutine.  */\n+  vec<tree, va_gc> *block_stack; /* Track block scopes.  */\n+  vec<tree, va_gc> *bind_stack;  /* Track current bind expr.  */\n+  unsigned await_number;\t /* Which await in the function.  */\n+  unsigned condition_number;\t /* Which replaced condition in the fn.  */\n+  /* Temporary values for one statement or expression being analyzed.  */\n+  hash_set<tree> captured_temps; /* The suspend captured these temps.  */\n+  vec<tree, va_gc> *to_replace;  /* The VAR decls to replace.  */\n+  unsigned saw_awaits;\t\t /* Count of awaits in this statement  */\n+  bool captures_temporary;\t /* This expr captures temps by ref.  */\n };\n \n /* Walk the sub-tree looking for call expressions that both capture\n@@ -2704,19 +2726,15 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   if (TREE_CODE (*stmt) != CO_AWAIT_EXPR && TREE_CODE (*stmt) != CO_YIELD_EXPR)\n     return NULL_TREE;\n \n-  /* co_yield is syntactic sugar, re-write it to co_await.  */\n   tree aw_expr = *stmt;\n   location_t aw_loc = EXPR_LOCATION (aw_expr); /* location of the co_xxxx.  */\n+  /* co_yield is syntactic sugar, re-write it to co_await.  */\n   if (TREE_CODE (aw_expr) == CO_YIELD_EXPR)\n     {\n       aw_expr = TREE_OPERAND (aw_expr, 1);\n       *stmt = aw_expr;\n     }\n \n-  /* Count how many awaits full expression contains.  This is not the same\n-     as the counter used for the function-wide await point number.  */\n-  data->saw_awaits++;\n-\n   /* If the awaitable is a parm or a local variable, then we already have\n      a frame copy, so don't make a new one.  */\n   tree aw = TREE_OPERAND (aw_expr, 1);\n@@ -2731,15 +2749,18 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n     {\n       /* The required field has the same type as the proxy stored in the\n \t await expr.  */\n-      char *nam = xasprintf (\"__aw_s.%d\", data->count);\n+      char *nam = xasprintf (\"__aw_s.%d\", data->await_number);\n       aw_field_nam = coro_make_frame_entry (data->field_list, nam,\n \t\t\t\t\t    aw_field_type, aw_loc);\n       free (nam);\n     }\n \n   register_await_info (aw_expr, aw_field_type, aw_field_nam);\n \n-  data->count++; /* Each await suspend context is unique.  */\n+  /* Count how many awaits the current expression contains.  */\n+  data->saw_awaits++;\n+  /* Each await suspend context is unique, this is a function-wide value.  */\n+  data->await_number++;\n \n   /* We now need to know if to take special action on lifetime extension\n      of temporaries captured by reference.  This can only happen if such\n@@ -2760,6 +2781,100 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n    We don't want to incur the effort of checking for this unless we have\n    an await expression in the current full expression.  */\n \n+/* This takes the statement which contains one or more temporaries that have\n+   been 'captured' by reference in the initializer(s) of co_await(s).\n+   The statement is replaced by a bind expression that has actual variables\n+   to replace the temporaries.  These variables will be added to the coro-\n+   frame in the same manner as user-authored ones.  */\n+\n+static void\n+replace_statement_captures (tree *stmt, void *d)\n+{\n+  susp_frame_data *awpts = (susp_frame_data *) d;\n+  location_t sloc = EXPR_LOCATION (*stmt);\n+  tree aw_bind\n+    = build3_loc (sloc, BIND_EXPR, void_type_node, NULL, NULL, NULL);\n+\n+  /* Any cleanup point expression might no longer be necessary, since we\n+     are removing one or more temporaries.  */\n+  tree aw_statement_current = *stmt;\n+  if (TREE_CODE (aw_statement_current) == CLEANUP_POINT_EXPR)\n+    aw_statement_current = TREE_OPERAND (aw_statement_current, 0);\n+\n+  /* Collected the scope vars we need move the temps to regular. */\n+  tree aw_bind_body = push_stmt_list ();\n+  tree varlist = NULL_TREE;\n+  int vnum = -1;\n+  while (!awpts->to_replace->is_empty ())\n+    {\n+      tree to_replace = awpts->to_replace->pop ();\n+      tree orig_temp;\n+      if (TREE_CODE (to_replace) == CO_AWAIT_EXPR)\n+\t{\n+\t  orig_temp = TREE_OPERAND (to_replace, 3);\n+\t  orig_temp = TREE_VEC_ELT (orig_temp, 2);\n+\t  orig_temp = TREE_OPERAND (orig_temp, 0);\n+\t}\n+      else\n+\torig_temp = TREE_OPERAND (to_replace, 0);\n+\n+      tree var_type = TREE_TYPE (orig_temp);\n+      gcc_checking_assert (same_type_p (TREE_TYPE (to_replace), var_type));\n+      /* Build a variable to hold the captured value, this will be included\n+\t in the frame along with any user-authored locals.  */\n+      char *nam = xasprintf (\"aw_%d.tmp.%d\", awpts->await_number, ++vnum);\n+      tree newvar = build_lang_decl (VAR_DECL, get_identifier (nam), var_type);\n+      free (nam);\n+      /* If we have better location than the whole expression use that, else\n+\t fall back to the expression loc.  */\n+      DECL_CONTEXT (newvar) = DECL_CONTEXT (orig_temp);\n+      if (DECL_SOURCE_LOCATION (orig_temp))\n+\tsloc = DECL_SOURCE_LOCATION (orig_temp);\n+     else\n+\tsloc = EXPR_LOCATION (*stmt);\n+      DECL_SOURCE_LOCATION (newvar) = sloc;\n+      DECL_CHAIN (newvar) = varlist;\n+      varlist = newvar; /* Chain it onto the list for the bind expr.  */\n+      /* Declare and initialize it in the new bind scope.  */\n+      add_decl_expr (newvar);\n+      tree new_s = build2_loc (sloc, INIT_EXPR, var_type, newvar, to_replace);\n+      new_s = coro_build_cvt_void_expr_stmt (new_s, sloc);\n+      add_stmt (new_s);\n+\n+     /* Replace all instances of that temp in the original expr.  */\n+      proxy_replace pr = {to_replace, newvar};\n+       cp_walk_tree (&aw_statement_current, replace_proxy, &pr, NULL);\n+    }\n+\n+  /* What's left should be the original statement with any co_await captured\n+     temporaries broken out.  Other temporaries might remain so see if we\n+     need to wrap the revised statement in a cleanup.  */\n+  aw_statement_current = maybe_cleanup_point_expr_void (aw_statement_current);\n+  add_stmt (aw_statement_current);\n+\n+  BIND_EXPR_BODY (aw_bind) = pop_stmt_list (aw_bind_body);\n+  awpts->captured_temps.empty ();\n+\n+  BIND_EXPR_VARS (aw_bind) = nreverse (varlist);\n+  tree b_block = make_node (BLOCK);\n+  if (!awpts->block_stack->is_empty ())\n+    {\n+      tree s_block = awpts->block_stack->last ();\n+      if (s_block)\n+\t{\n+\tBLOCK_SUPERCONTEXT (b_block) = s_block;\n+\tBLOCK_CHAIN (b_block) = BLOCK_SUBBLOCKS (s_block);\n+\tBLOCK_SUBBLOCKS (s_block) = b_block;\n+\t}\n+    }\n+  BIND_EXPR_BLOCK (aw_bind) = b_block;\n+  *stmt = aw_bind;\n+}\n+\n+/* This is called for single statements from the co-await statement walker.\n+   It checks to see if the statement contains any co-awaits and, if so,\n+   whether any of these 'capture' a temporary by reference.  */\n+\n static tree\n maybe_promote_captured_temps (tree *stmt, void *d)\n {\n@@ -2769,90 +2884,19 @@ maybe_promote_captured_temps (tree *stmt, void *d)\n \n   /* When register_awaits sees an await, it walks the initializer for\n      that await looking for temporaries captured by reference and notes\n-     them in awpts->captured_temps.  We only need to take any action here\n-     if the statement contained any awaits, and any of those had temporaries\n-     captured by reference in the initializers for their class.  */\n-\n-  tree res = cp_walk_tree (stmt, register_awaits, d, &visited);\n-  if (!res && awpts->saw_awaits > 0 && !awpts->captured_temps.is_empty ())\n-    {\n-      location_t sloc = EXPR_LOCATION (*stmt);\n-      tree aw_bind\n-\t= build3_loc (sloc, BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-\n-      /* Any cleanup point expression might no longer be necessary, since we\n-\t are removing one or more temporaries.  */\n-      tree aw_statement_current = *stmt;\n-      if (TREE_CODE (aw_statement_current) == CLEANUP_POINT_EXPR)\n-\taw_statement_current = TREE_OPERAND (aw_statement_current, 0);\n-\n-      /* Collected the scope vars we need move the temps to regular. */\n-      tree aw_bind_body = push_stmt_list ();\n-      tree varlist = NULL_TREE;\n-      int vnum = -1;\n-      while (!awpts->to_replace->is_empty ())\n-\t{\n-\t  size_t bufsize = sizeof (\"__aw_.tmp.\") + 20;\n-\t  char *buf = (char *) alloca (bufsize);\n-\t  snprintf (buf, bufsize, \"__aw_%d.tmp.%d\", awpts->count, ++vnum);\n-\t  tree to_replace = awpts->to_replace->pop ();\n-\t  tree orig_temp;\n-\t  if (TREE_CODE (to_replace) == CO_AWAIT_EXPR)\n-\t    {\n-\t      orig_temp = TREE_OPERAND (to_replace, 3);\n-\t      orig_temp = TREE_VEC_ELT (orig_temp, 2);\n-\t      orig_temp = TREE_OPERAND (orig_temp, 0);\n-\t    }\n-\t  else\n-\t    orig_temp = TREE_OPERAND (to_replace, 0);\n-\n-\t  tree var_type = TREE_TYPE (orig_temp);\n-\t  gcc_assert (same_type_p (TREE_TYPE (to_replace), var_type));\n-\t  tree newvar\n-\t    = build_lang_decl (VAR_DECL, get_identifier (buf), var_type);\n-\t  DECL_CONTEXT (newvar) = DECL_CONTEXT (orig_temp);\n-\t  if (DECL_SOURCE_LOCATION (orig_temp))\n-\t    sloc = DECL_SOURCE_LOCATION (orig_temp);\n-\t  DECL_SOURCE_LOCATION (newvar) = sloc;\n-\t  DECL_CHAIN (newvar) = varlist;\n-\t  varlist = newvar; /* Chain it onto the list for the bind expr.  */\n-\t  /* Declare and initialze it in the new bind scope.  */\n-\t  add_decl_expr (newvar);\n-\t  tree stmt\n-\t    = build2_loc (sloc, INIT_EXPR, var_type, newvar, to_replace);\n-\t  stmt = coro_build_cvt_void_expr_stmt (stmt, sloc);\n-\t  add_stmt (stmt);\n-\t  proxy_replace pr = {to_replace, newvar};\n-\t  /* Replace all instances of that temp in the original expr.  */\n-\t  cp_walk_tree (&aw_statement_current, replace_proxy, &pr, NULL);\n-\t}\n+     them in awpts->captured_temps.  */\n \n-      /* What's left should be the original statement with any co_await\n-\t captured temporaries broken out.  Other temporaries might remain\n-\t so see if we need to wrap the revised statement in a cleanup.  */\n-      aw_statement_current =\n-\tmaybe_cleanup_point_expr_void (aw_statement_current);\n-      add_stmt (aw_statement_current);\n-      BIND_EXPR_BODY (aw_bind) = pop_stmt_list (aw_bind_body);\n-      awpts->captured_temps.empty ();\n-\n-      BIND_EXPR_VARS (aw_bind) = nreverse (varlist);\n-      tree b_block = make_node (BLOCK);\n-      if (!awpts->block_stack->is_empty ())\n-\t{\n-\t  tree s_block = awpts->block_stack->last ();\n-\t  if (s_block)\n-\t    {\n-\t      BLOCK_SUPERCONTEXT (b_block) = s_block;\n-\t      BLOCK_CHAIN (b_block) = BLOCK_SUBBLOCKS (s_block);\n-\t      BLOCK_SUBBLOCKS (s_block) = b_block;\n-\t    }\n-\t}\n-      BIND_EXPR_BLOCK (aw_bind) = b_block;\n+  if (tree res = cp_walk_tree (stmt, register_awaits, d, &visited))\n+    return res; /* We saw some reason to abort the tree walk.  */\n \n-      *stmt = aw_bind;\n-    }\n-  return res;\n+  /* We only need to take any action here if the statement contained any\n+     awaits and any of those had temporaries captured by reference in their\n+     initializers. */\n+\n+  if (awpts->saw_awaits > 0 && !awpts->captured_temps.is_empty ())\n+    replace_statement_captures (stmt, d);\n+\n+  return NULL_TREE;\n }\n \n static tree\n@@ -2861,45 +2905,39 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n   tree res = NULL_TREE;\n   susp_frame_data *awpts = (susp_frame_data *) d;\n \n-  /* We might need to insert a new bind expression, and want to link it\n-     into the correct scope, so keep a note of the current block scope.  */\n+  /* Process a statement at a time.  */\n   if (TREE_CODE (*stmt) == BIND_EXPR)\n     {\n-      tree *body = &BIND_EXPR_BODY (*stmt);\n+      /* We might need to insert a new bind expression, and want to link it\n+\t into the correct scope, so keep a note of the current block scope.  */\n       tree blk = BIND_EXPR_BLOCK (*stmt);\n       vec_safe_push (awpts->block_stack, blk);\n-\n-      if (TREE_CODE (*body) == STATEMENT_LIST)\n-\t{\n-\t  tree_stmt_iterator i;\n-\t  for (i = tsi_start (*body); !tsi_end_p (i); tsi_next (&i))\n-\t    {\n-\t      tree *new_stmt = tsi_stmt_ptr (i);\n-\t      if (STATEMENT_CLASS_P (*new_stmt) || !EXPR_P (*new_stmt)\n-\t\t  || TREE_CODE (*new_stmt) == BIND_EXPR)\n-\t\tres = cp_walk_tree (new_stmt, await_statement_walker, d, NULL);\n-\t      else\n-\t\tres = maybe_promote_captured_temps (new_stmt, d);\n-\t      if (res)\n-\t\treturn res;\n-\t    }\n-\t  *do_subtree = 0; /* Done subtrees.  */\n-\t}\n-      else if (!STATEMENT_CLASS_P (*body) && EXPR_P (*body)\n-\t       && TREE_CODE (*body) != BIND_EXPR)\n+      res = cp_walk_tree (&BIND_EXPR_BODY (*stmt), await_statement_walker,\n+\t\t\t  d, NULL);\n+      awpts->block_stack->pop ();\n+      *do_subtree = 0; /* Done subtrees.  */\n+    }\n+  else if (TREE_CODE (*stmt) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator i;\n+      for (i = tsi_start (*stmt); !tsi_end_p (i); tsi_next (&i))\n \t{\n-\t  res = maybe_promote_captured_temps (body, d);\n-\t  *do_subtree = 0; /* Done subtrees.  */\n+\t  res = cp_walk_tree (tsi_stmt_ptr (i), await_statement_walker,\n+\t\t\t      d, NULL);\n+\t  if (res)\n+\t    return res;\n \t}\n-      awpts->block_stack->pop ();\n+      *do_subtree = 0; /* Done subtrees.  */\n     }\n-  else if (!STATEMENT_CLASS_P (*stmt) && EXPR_P (*stmt)\n-\t   && TREE_CODE (*stmt) != BIND_EXPR)\n+  else if (STATEMENT_CLASS_P (*stmt))\n+    return NULL_TREE; /* Process the subtrees.  */\n+  else if (EXPR_P (*stmt))\n     {\n       res = maybe_promote_captured_temps (stmt, d);\n       *do_subtree = 0; /* Done subtrees.  */\n     }\n-  /* If it wasn't a statement list, or a single statement, continue.  */\n+ \n+  /* Continue recursion, if needed.  */\n   return res;\n }\n \n@@ -3273,9 +3311,11 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      to promote any temporaries that are captured by reference (to regular\n      vars) they will get added to the coro frame along with other locals.  */\n   susp_frame_data body_aw_points\n-    = {&field_list, handle_type, hash_set<tree> (), NULL, NULL, 0, 0, false};\n-  body_aw_points.to_replace = make_tree_vector ();\n+    = {&field_list, handle_type, NULL, NULL, 0, 0,\n+       hash_set<tree> (), NULL, 0, false};\n   body_aw_points.block_stack = make_tree_vector ();\n+  body_aw_points.bind_stack = make_tree_vector ();\n+  body_aw_points.to_replace = make_tree_vector ();\n   cp_walk_tree (&fnbody, await_statement_walker, &body_aw_points, NULL);\n \n   /* Final suspend is mandated.  */\n@@ -3914,7 +3954,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Actor ...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n \t\t  &local_var_uses, param_dtor_list, initial_await, final_await,\n-\t\t  body_aw_points.count, frame_size);\n+\t\t  body_aw_points.await_number, frame_size);\n \n   /* Destroyer ... */\n   build_destroy_fn (fn_start, coro_frame_type, destroy, actor);"}, {"sha": "33ebac754ad76c6463e57925bf5311e722b8aad7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0666767eb4cc864f00ba34d97b9d58f8dc650bba", "patch": "@@ -1,3 +1,8 @@\n+2020-04-10  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94538\n+\t* g++.dg/coroutines/pr94528.C: New test.\n+\n 2020-04-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94149"}, {"sha": "80e7273f1789989f2651be1bd2abb591f88b5a03", "filename": "gcc/testsuite/g++.dg/coroutines/pr94528.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr94528.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0666767eb4cc864f00ba34d97b9d58f8dc650bba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr94528.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr94528.C?ref=0666767eb4cc864f00ba34d97b9d58f8dc650bba", "patch": "@@ -0,0 +1,64 @@\n+//  { dg-additional-options \"-std=c++20 -fpreprocessed -w\" }\n+namespace std {\n+inline namespace {\n+template <typename _Result, typename> struct coroutine_traits {\n+  using promise_type = _Result::promise_type;\n+};\n+template <typename = void> struct coroutine_handle;\n+template <> struct coroutine_handle<> { public: };\n+template <typename> struct coroutine_handle : coroutine_handle<> {};\n+struct suspend_always {\n+  bool await_ready();\n+  void await_suspend(coroutine_handle<>);\n+  void await_resume();\n+};\n+} // namespace\n+} // namespace std\n+namespace coro = std;\n+namespace cppcoro {\n+class task {\n+private:\n+  struct awaitable_base {\n+    coro::coroutine_handle<> m_coroutine;\n+    bool await_ready() const noexcept;\n+    void await_suspend(coro::coroutine_handle<> awaitingCoroutine) noexcept;\n+  };\n+\n+public:\n+  auto operator co_await() const &noexcept {\n+    struct awaitable : awaitable_base {\n+      decltype(auto) await_resume() {}\n+    };\n+    return awaitable{m_coroutine};\n+  }\n+\n+private:\n+  coro::coroutine_handle<> m_coroutine;\n+};\n+class shared_task;\n+class shared_task_promise_base {\n+  struct final_awaiter {\n+    bool await_ready() const noexcept;\n+    template <typename PROMISE>\n+    void await_suspend(coro::coroutine_handle<PROMISE> h) noexcept;\n+    void await_resume() noexcept;\n+  };\n+\n+public:\n+  coro::suspend_always initial_suspend() noexcept;\n+  final_awaiter final_suspend() noexcept;\n+  void unhandled_exception() noexcept;\n+};\n+class shared_task_promise : public shared_task_promise_base {\n+public:\n+  shared_task get_return_object() noexcept;\n+  void return_void() noexcept;\n+};\n+class shared_task {\n+public:\n+  using promise_type = shared_task_promise;\n+};\n+auto make_shared_task(cppcoro::task awaitable) -> shared_task {\n+  co_return co_await static_cast<cppcoro::task &&>(awaitable);\n+}\n+} // namespace cppcoro"}]}