{"sha": "112f7223d17a7e98e996af22e1b474855e7cae48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEyZjcyMjNkMTdhN2U5OGU5OTZhZjIyZTFiNDc0ODU1ZTdjYWU0OA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-02-01T17:14:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-02-01T17:14:32Z"}, "message": "* reload.c: Revert 2003-01-31 change.\n\nFrom-SVN: r62249", "tree": {"sha": "f6f34c5988b057dc5538a5a0a2d61070b2e3e522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6f34c5988b057dc5538a5a0a2d61070b2e3e522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/112f7223d17a7e98e996af22e1b474855e7cae48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112f7223d17a7e98e996af22e1b474855e7cae48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112f7223d17a7e98e996af22e1b474855e7cae48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112f7223d17a7e98e996af22e1b474855e7cae48/comments", "author": null, "committer": null, "parents": [{"sha": "064994a3f25f1c2ff8462ed81f513b50d7d1a1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/064994a3f25f1c2ff8462ed81f513b50d7d1a1b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/064994a3f25f1c2ff8462ed81f513b50d7d1a1b0"}], "stats": {"total": 55, "additions": 17, "deletions": 38}, "files": [{"sha": "a36da64ac734823de112673c0ae25fba3f83e301", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112f7223d17a7e98e996af22e1b474855e7cae48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112f7223d17a7e98e996af22e1b474855e7cae48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=112f7223d17a7e98e996af22e1b474855e7cae48", "patch": "@@ -1,3 +1,7 @@\n+2003-02-01  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c: Revert 2003-01-31 change.\n+\n Sat Feb  1 14:14:40 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (combine_simplify_rtx):  Use reversed_comparison_code_parts."}, {"sha": "46d0d6417df02b41b73bb22c36dbaa8c3ac30b96", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112f7223d17a7e98e996af22e1b474855e7cae48/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112f7223d17a7e98e996af22e1b474855e7cae48/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=112f7223d17a7e98e996af22e1b474855e7cae48", "patch": "@@ -274,7 +274,6 @@ static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n static rtx find_reloads_subreg_address PARAMS ((rtx, int, int,\n \t\t\t\t\t\tenum reload_type, int, rtx));\n static void copy_replacements_1 PARAMS ((rtx *, rtx *, int));\n-static bool have_replacement_p\tPARAMS ((rtx *));\n static int find_inc_amount\tPARAMS ((rtx, rtx));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n@@ -2690,10 +2689,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  recog_data.operand[i] = *recog_data.operand_loc[i];\n \t  substed_operand[i] = recog_data.operand[i];\n-\n-\t  /* Address operands are reloaded in their existing mode,\n-\t     no matter what is specified in the machine description.  */\n-\t  operand_mode[i] = GET_MODE (recog_data.operand[i]);\n \t}\n       else if (code == MEM)\n \t{\n@@ -3307,6 +3302,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   the address into a base register.  */\n \t\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n \t\t\tbadop = 0;\n+\n+\t\t\t/* Address constraints are reloaded in Pmode, no matter\n+\t\t\t   what mode is given in the machine description.  */\n+\t\t\toperand_mode[i] = Pmode;\n \t\t\tbreak;\n \t\t      }\n \n@@ -3877,20 +3876,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    return 0;\n \t  }\n       }\n-\n-    /* Generate optional reloads only when optimizing, and only\n-       on the last pass through reload.  Also, make sure we do not\n-       make an optional reload where we already have a mandatory\n-       one; this can happen in the case of address operands.\n-\n-       To check for mandatory reloads, we use have_replacement_p.\n-       Note that this works only on the last pass through reload.  */\n-    else if (!optimize || !replace \n-\t     || have_replacement_p (recog_data.operand_loc[i]))\n-      ; /* Do nothing.  */\n-\n     else if (goal_alternative_matched[i] < 0\n-\t     && goal_alternative_matches[i] < 0)\n+\t     && goal_alternative_matches[i] < 0\n+\t     && optimize)\n       {\n \t/* For each non-matching operand that's a MEM or a pseudo-register\n \t   that didn't get a hard register, make an optional reload.\n@@ -3940,10 +3928,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   reload, check if this is actually a pseudo register reference;\n \t   we then need to emit a USE and/or a CLOBBER so that reload\n \t   inheritance will do the right thing.  */\n-\telse if (GET_CODE (operand) == MEM\n-\t\t || (GET_CODE (operand) == REG\n-\t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t     && reg_renumber [REGNO (operand)] < 0))\n+\telse if (replace\n+\t\t && (GET_CODE (operand) == MEM\n+\t\t     || (GET_CODE (operand) == REG\n+\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t && reg_renumber [REGNO (operand)] < 0)))\n \t  {\n \t    operand = *recog_data.operand_loc[i];\n \n@@ -3966,7 +3955,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     && goal_alternative_win[goal_alternative_matches[i]]\n \t     && modified[i] == RELOAD_READ\n \t     && modified[goal_alternative_matches[i]] == RELOAD_WRITE\n-\t     && ! no_input_reloads && ! no_output_reloads)\n+\t     && ! no_input_reloads && ! no_output_reloads\n+\t     && optimize)\n       {\n \t/* Similarly, make an optional reload for a pair of matching\n \t   objects that are in MEM or a pseudo that didn't get a hard reg.  */\n@@ -6140,21 +6130,6 @@ find_replacement (loc)\n \n   return *loc;\n }\n-\n-/* Return true if some replacement was scheduled at LOC.  */\n-\n-static bool\n-have_replacement_p (loc)\n-     rtx *loc;\n-{\n-  struct replacement *r;\n-\n-  for (r = &replacements[0]; r < &replacements[n_replacements]; r++)\n-    if (r->where == loc)\n-      return true;\n-\n-  return false;\n-}\n \f\n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X"}]}