{"sha": "c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhMmMyNWQxMjZmM2RiMmFmYmIxZWU5ZmZiNjQyOGZkZTVlNDU4Yg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-11-21T22:56:36Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-11-21T22:56:36Z"}, "message": "re PR middle-end/42025 (ICE verify_stmts failed (non-trivial conversion at assignment))\n\n2009-11-21  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/42025\n\t* tree-sra.c (access_precludes_ipa_sra_p): New function.\n\t(splice_param_accesses): Check all accesses by calling\n\taccess_precludes_ipa_sra_p.\n\t(sra_ipa_modify_expr): Rename argument erite to dont_convert and do\n\tnot convert types if it is true.\n\t(sra_ipa_modify_assign): Convert types in case of mismatch.\n\n\t* testsuite/gcc.c-torture/compile/pr42025-1.c: New test.\n\t* testsuite/gcc.c-torture/compile/pr42025-2.c: New test.\n\nFrom-SVN: r154413", "tree": {"sha": "c9831b13704bd5b311b01731f5f6a2446781196a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9831b13704bd5b311b01731f5f6a2446781196a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bcd9e00d09ab3ded9935c7f086c93e6c22759440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd9e00d09ab3ded9935c7f086c93e6c22759440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcd9e00d09ab3ded9935c7f086c93e6c22759440"}], "stats": {"total": 158, "additions": 140, "deletions": 18}, "files": [{"sha": "5f5a2e6a03dc797a6469fdbe77db2acc24703a4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "patch": "@@ -1,3 +1,13 @@\n+2009-11-21  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42025\n+\t* tree-sra.c (access_precludes_ipa_sra_p): New function.\n+\t(splice_param_accesses): Check all accesses by calling\n+\taccess_precludes_ipa_sra_p.\n+\t(sra_ipa_modify_expr): Rename argument erite to dont_convert and do\n+\tnot convert types if it is true.\n+\t(sra_ipa_modify_assign): Convert types in case of mismatch.\n+\n 2009-11-21  Kaushik Phatak  <kaushik.phatak@kpitcummins.com>\n \n \t* config/sh/sh.md (cmpeqsi_t-1): Use logical_operand predicate"}, {"sha": "a23042d8447091448564d3098fffcdacac3d4aee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "patch": "@@ -1,3 +1,9 @@\n+2009-11-21  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42025\n+\t* gcc.c-torture/compile/pr42025-1.c: New test.\n+\t* gcc.c-torture/compile/pr42025-2.c: New test.\n+\n 2009-11-21  Adam Nemet  <adambnemet@gmail.com>\n \n \t* gcc.target/mips/mult-1.c: Forbid octeon."}, {"sha": "f19123eafa6e22924091c4965ea01730c750328c", "filename": "gcc/testsuite/gcc.c-torture/compile/pr42025-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-1.c?ref=c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "patch": "@@ -0,0 +1,24 @@\n+typedef void* Ptr;\n+\n+struct A\n+{\n+  int i;\n+  union\n+  {\n+    Ptr p;\n+    char *q;\n+  } u;\n+};\n+\n+static void foo(struct A *p, char *q)\n+{\n+  if (p->i)\n+    p->u.p = 0;\n+  else\n+    p->u.q = q;\n+}\n+\n+void bar(struct A *p, char *q)\n+{\n+  foo(p, q);\n+}"}, {"sha": "14cb36d1c0e1c184a3f88bd3f01df14fe3a6ac9b", "filename": "gcc/testsuite/gcc.c-torture/compile/pr42025-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42025-2.c?ref=c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "patch": "@@ -0,0 +1,32 @@\n+typedef struct\n+{\n+  void *p;\n+} Ptr;\n+\n+struct A\n+{\n+  int i;\n+  union\n+  {\n+    Ptr p;\n+    char *q;\n+  } u;\n+};\n+\n+extern Ptr get_stuff (void);\n+extern void use_stuff (char *);\n+\n+static void foo(struct A p, char *q)\n+{\n+  if (p.i)\n+    p.u.p = get_stuff ();\n+  else\n+    p.u.q = q;\n+\n+  use_stuff (p.u.q);\n+}\n+\n+void bar(struct A *p, char *q)\n+{\n+  foo(*p, q);\n+}"}, {"sha": "fe82d9851be2247f731114463de4e07c783839c9", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=c6a2c25d126f3db2afbb1ee9ffb6428fde5e458b", "patch": "@@ -3042,6 +3042,27 @@ unmodified_by_ref_scalar_representative (tree parm)\n   return repr;\n }\n \n+/* Return true iff this access precludes IPA-SRA of the parameter it is\n+   associated with. */\n+\n+static bool\n+access_precludes_ipa_sra_p (struct access *access)\n+{\n+  /* Avoid issues such as the second simple testcase in PR 42025.  The problem\n+     is incompatible assign in a call statement (and possibly even in asm\n+     statements).  This can be relaxed by using a new temporary but only for\n+     non-TREE_ADDRESSABLE types and is probably not worth the complexity. (In\n+     intraprocedural SRA we deal with this by keeping the old aggregate around,\n+     something we cannot do in IPA-SRA.)  */\n+  if (access->write\n+      && (is_gimple_call (access->stmt)\n+\t  || gimple_code (access->stmt) == GIMPLE_ASM))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n /* Sort collected accesses for parameter PARM, identify representatives for\n    each accessed region and link them together.  Return NULL if there are\n    different but overlapping accesses, return the special ptr value meaning\n@@ -3073,6 +3094,8 @@ splice_param_accesses (tree parm, bool *ro_grp)\n       bool modification;\n       access = VEC_index (access_p, access_vec, i);\n       modification = access->write;\n+      if (access_precludes_ipa_sra_p (access))\n+\treturn NULL;\n \n       /* Access is about to become group representative unless we find some\n \t nasty overlap which would preclude us from breaking this parameter\n@@ -3093,6 +3116,9 @@ splice_param_accesses (tree parm, bool *ro_grp)\n \t  else if (ac2->size != access->size)\n \t    return NULL;\n \n+\t  if (access_precludes_ipa_sra_p (ac2))\n+\t    return NULL;\n+\n \t  modification |= ac2->write;\n \t  ac2->group_representative = access;\n \t  ac2->next_sibling = access->next_sibling;\n@@ -3523,13 +3549,19 @@ replace_removed_params_ssa_names (gimple stmt, void *data)\n   return true;\n }\n \n-/* Callback for scan_function.  If the expression *EXPR should be replaced by a\n-   reduction of a parameter, do so.  DATA is a pointer to a vector of\n-   adjustments.  */\n+/* Callback for scan_function and helper to sra_ipa_modify_assign.  If the\n+   expression *EXPR should be replaced by a reduction of a parameter, do so.\n+   DATA is a pointer to a vector of adjustments.  DONT_CONVERT specifies\n+   whether the function should care about type incompatibility the current and\n+   new expressions.  If it is true, the function will leave incompatibility\n+   issues to the caller.\n+\n+   When called directly by scan_function, DONT_CONVERT is true when the EXPR is\n+   a write (LHS) expression.  */\n \n static bool\n sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t     bool write ATTRIBUTE_UNUSED, void *data)\n+\t\t     bool dont_convert, void *data)\n {\n   ipa_parm_adjustment_vec adjustments;\n   int i, len;\n@@ -3543,10 +3575,10 @@ sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n   if (TREE_CODE (*expr) == BIT_FIELD_REF\n       || TREE_CODE (*expr) == IMAGPART_EXPR\n       || TREE_CODE (*expr) == REALPART_EXPR)\n-    expr = &TREE_OPERAND (*expr, 0);\n-  while (TREE_CODE (*expr) == NOP_EXPR\n-\t || TREE_CODE (*expr) == VIEW_CONVERT_EXPR)\n-    expr = &TREE_OPERAND (*expr, 0);\n+    {\n+      expr = &TREE_OPERAND (*expr, 0);\n+      dont_convert = false;\n+    }\n \n   base = get_ref_base_and_extent (*expr, &offset, &size, &max_size);\n   if (!base || size == -1 || max_size == -1)\n@@ -3594,34 +3626,52 @@ sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (!useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+  if (!dont_convert\n+      && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n     {\n       tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n       *expr = vce;\n     }\n-    else\n-      *expr = src;\n+  else\n+    *expr = src;\n   return true;\n }\n \n /* Callback for scan_function to process assign statements.  Performs\n    essentially the same function like sra_ipa_modify_expr.  */\n \n static enum scan_assign_result\n-sra_ipa_modify_assign (gimple *stmt_ptr,\n-\t\t       gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED, void *data)\n+sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi, void *data)\n {\n   gimple stmt = *stmt_ptr;\n-  bool any = false;\n+  tree *lhs_p, *rhs_p;\n+  bool any;\n \n   if (!gimple_assign_single_p (stmt))\n     return SRA_SA_NONE;\n \n-  any |= sra_ipa_modify_expr (gimple_assign_rhs1_ptr (stmt), gsi, false,\n-\t\t\t      data);\n-  any |= sra_ipa_modify_expr (gimple_assign_lhs_ptr (stmt), gsi, true, data);\n+  rhs_p = gimple_assign_rhs1_ptr (stmt);\n+  lhs_p = gimple_assign_lhs_ptr (stmt);\n+\n+  any = sra_ipa_modify_expr (rhs_p, gsi, true, data);\n+  any |= sra_ipa_modify_expr (lhs_p, gsi, true, data);\n+  if (any)\n+    {\n+      if (!useless_type_conversion_p (TREE_TYPE (*lhs_p), TREE_TYPE (*rhs_p)))\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\t  tree vce = fold_build1_loc (loc, VIEW_CONVERT_EXPR,\n+\t\t\t\t      TREE_TYPE (*lhs_p), *rhs_p);\n+\t  tree tmp = force_gimple_operand_gsi (gsi, vce, true, NULL_TREE,\n+\t\t\t\t\t       true, GSI_SAME_STMT);\n+\n+\t  gimple_assign_set_rhs_from_tree (gsi, tmp);\n+\t}\n+\n+      return SRA_SA_PROCESSED;\n+    }\n \n-  return any ? SRA_SA_PROCESSED : SRA_SA_NONE;\n+  return SRA_SA_NONE;\n }\n \n /* Call gimple_debug_bind_reset_value on all debug statements describing"}]}