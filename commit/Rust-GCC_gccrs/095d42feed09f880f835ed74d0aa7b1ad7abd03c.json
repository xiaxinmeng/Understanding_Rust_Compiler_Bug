{"sha": "095d42feed09f880f835ed74d0aa7b1ad7abd03c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1ZDQyZmVlZDA5Zjg4MGY4MzVlZDc0ZDBhYTdiMWFkN2FiZDAzYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-04T13:33:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-07T07:47:36Z"}, "message": "code generate live lanes in basic-block vectorization\n\nThe following adds the capability to code-generate live lanes in\nbasic-block vectorization using lane extracts from vector stmts\nrather than keeping the original scalar code around for those.\nThis eventually makes previously not profitable vectorizations\nprofitable (the live scalar code was appropriately costed so\nare the lane extracts now), without considering the cost model\nthis patch doesn't add or remove any basic-block vectorization\ncapabilities.\n\nThe patch re/ab-uses STMT_VINFO_LIVE_P in basic-block vectorization\nmode to tell whether a live lane is vectorized or whether it is\nprovided by means of keeping the scalar code live.\n\nThe patch is a first step towards vectorizing sequences of\nstmts that do not end up in stores or vector constructors though.\n\nBootstrapped and tested on x86_64-unknown-linux-gnu.\n\n2020-09-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vectorizable_live_operation): Adjust.\n\t* tree-vect-loop.c (vectorizable_live_operation): Vectorize\n\tlive lanes out of basic-block vectorization nodes.\n\t* tree-vect-slp.c (vect_bb_slp_mark_live_stmts): New function.\n\t(vect_slp_analyze_operations): Analyze live lanes and their\n\tvectorization possibility after the whole SLP graph is final.\n\t(vect_bb_slp_scalar_cost): Adjust for vectorized live lanes.\n\t* tree-vect-stmts.c (can_vectorize_live_stmts): Adjust.\n\t(vect_transform_stmt): Call can_vectorize_live_stmts also for\n\tbasic-block vectorization.\n\n\t* gcc.dg/vect/bb-slp-46.c: New testcase.\n\t* gcc.dg/vect/bb-slp-47.c: Likewise.\n\t* gcc.dg/vect/bb-slp-32.c: Adjust.", "tree": {"sha": "ac7563d6514c5e7d246968efe8c9653d7b79fbf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac7563d6514c5e7d246968efe8c9653d7b79fbf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095d42feed09f880f835ed74d0aa7b1ad7abd03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095d42feed09f880f835ed74d0aa7b1ad7abd03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095d42feed09f880f835ed74d0aa7b1ad7abd03c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095d42feed09f880f835ed74d0aa7b1ad7abd03c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d30869a8d4886aee4020be3b28b15b1b15c8d9ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30869a8d4886aee4020be3b28b15b1b15c8d9ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30869a8d4886aee4020be3b28b15b1b15c8d9ad"}], "stats": {"total": 451, "additions": 332, "deletions": 119}, "files": [{"sha": "020b6365e022446c6db138cd8f76c3665e8e45cf", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-32.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -7,16 +7,21 @@ int foo (int *p, int a, int b)\n {\n   int x[4];\n   int tem0, tem1, tem2, tem3;\n+  int sum = 0;\n   tem0 = p[0] + 1 + a;\n+  sum += tem0;\n   x[0] = tem0;\n   tem1 = p[1] + 2 + b;\n+  sum += tem1;\n   x[1] = tem1;\n   tem2 = p[2] + 3 + b;\n+  sum += tem2;\n   x[2] = tem2;\n   tem3 = p[3] + 4 + a;\n+  sum += tem3;\n   x[3] = tem3;\n   bar (x);\n-  return tem0 + tem1 + tem2 + tem3;\n+  return sum;\n }\n \n /* { dg-final { scan-tree-dump \"vectorization is not profitable\" \"slp2\" { xfail  { vect_no_align && { ! vect_hw_misalign } } } } } */"}, {"sha": "4e4571ef6400ad9fb2e488a43d02c54f1e3f4d49", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-46.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-46.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fdump-tree-optimized\" } */\n+\n+int a[4], b[4];\n+int foo ()\n+{\n+  int tem0 = a[0] + b[0];\n+  int temx = tem0 * 17;  /* this fails without a real need */\n+  int tem1 = a[1] + b[1];\n+  int tem2 = a[2] + b[2];\n+  int tem3 = a[3] + b[3];\n+  int temy = tem3 * 13;\n+  a[0] = tem0;\n+  a[1] = tem1;\n+  a[2] = tem2;\n+  a[3] = tem3;\n+  return temx + temy;\n+}\n+\n+/* We should extract the live lane from the vectorized add rather than\n+   keeping the original scalar add.\n+   ???  Because of a too conservative check we fail for temx here.  */\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" } } */\n+/* { dg-final { scan-tree-dump \"extracting lane for live stmt\" \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"extracting lane for live stmt\" 2 \"slp2\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ \" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ \" 2 \"optimized\" { xfail *-*-* } } } */"}, {"sha": "9583b09cfbd444f2d81332bcf6a6311fb69ccab1", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-47.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-47.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+int bar();\n+int foo (int *a, int b, int c)\n+{\n+  int tem0 = bar ();\n+  int tem1 = tem0 + b;\n+  int tem3 = tem1 + c;\n+  a[0] = tem3;\n+  a[1] = tem3 + 1;\n+  a[2] = tem3 + 2;\n+  a[3] = tem3 + 3;\n+  return tem1;\n+}"}, {"sha": "a0c3c5cc858fef99f734500d86a32e2f74966d56", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 149, "deletions": 94, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -8012,14 +8012,14 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n    it can be supported.  */\n \n bool\n-vectorizable_live_operation (loop_vec_info loop_vinfo,\n+vectorizable_live_operation (vec_info *vinfo,\n \t\t\t     stmt_vec_info stmt_info,\n \t\t\t     gimple_stmt_iterator *gsi,\n \t\t\t     slp_tree slp_node, slp_instance slp_node_instance,\n \t\t\t     int slp_index, bool vec_stmt_p,\n-\t\t\t     stmt_vector_for_cost *)\n+\t\t\t     stmt_vector_for_cost *cost_vec)\n {\n-  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   imm_use_iterator imm_iter;\n   tree lhs, lhs_type, bitsize, vec_bitsize;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -8064,10 +8064,6 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n       return true;\n     }\n \n-  /* FORNOW.  CHECKME.  */\n-  if (nested_in_vect_loop_p (loop, stmt_info))\n-    return false;\n-\n   /* If STMT is not relevant and it is a simple assignment and its inputs are\n      invariant then it can remain in place, unvectorized.  The original last\n      scalar value that it computes will be used.  */\n@@ -8090,12 +8086,11 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n     {\n       gcc_assert (slp_index >= 0);\n \n-      int num_scalar = SLP_TREE_LANES (slp_node);\n-      int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-\n       /* Get the last occurrence of the scalar index from the concatenation of\n \t all the slp vectors. Calculate which slp vector it is and the index\n \t within.  */\n+      int num_scalar = SLP_TREE_LANES (slp_node);\n+      int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       poly_uint64 pos = (num_vec * nunits) - num_scalar + slp_index;\n \n       /* Calculate which vector contains the result, and which lane of\n@@ -8113,7 +8108,7 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n   if (!vec_stmt_p)\n     {\n       /* No transformation required.  */\n-      if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n+      if (loop_vinfo && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n \t{\n \t  if (!direct_internal_fn_supported_p (IFN_EXTRACT_LAST, vectype,\n \t\t\t\t\t       OPTIMIZE_FOR_SPEED))\n@@ -8150,31 +8145,35 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n \t\t\t\t     1, vectype, NULL);\n \t    }\n \t}\n+      /* ???  Enable for loop costing as well.  */\n+      if (!loop_vinfo)\n+\trecord_stmt_cost (cost_vec, 1, vec_to_scalar, stmt_info, NULL_TREE,\n+\t\t\t  0, vect_epilogue);\n       return true;\n     }\n \n   /* Use the lhs of the original scalar statement.  */\n   gimple *stmt = vect_orig_stmt (stmt_info)->stmt;\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"extracting lane for live \"\n+\t\t     \"stmt %G\", stmt);\n \n-  lhs = (is_a <gphi *> (stmt)) ? gimple_phi_result (stmt)\n-\t: gimple_get_lhs (stmt);\n+  lhs = gimple_get_lhs (stmt);\n   lhs_type = TREE_TYPE (lhs);\n \n   bitsize = vector_element_bits_tree (vectype);\n   vec_bitsize = TYPE_SIZE (vectype);\n \n   /* Get the vectorized lhs of STMT and the lane to use (counted in bits).  */\n   tree vec_lhs, bitstart;\n+  gimple *vec_stmt;\n   if (slp_node)\n     {\n-      gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n+      gcc_assert (!loop_vinfo || !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n \n       /* Get the correct slp vectorized stmt.  */\n-      gimple *vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry];\n-      if (gphi *phi = dyn_cast <gphi *> (vec_stmt))\n-\tvec_lhs = gimple_phi_result (phi);\n-      else\n-\tvec_lhs = gimple_get_lhs (vec_stmt);\n+      vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry];\n+      vec_lhs = gimple_get_lhs (vec_stmt);\n \n       /* Get entry to use.  */\n       bitstart = bitsize_int (vec_index);\n@@ -8183,102 +8182,158 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n   else\n     {\n       /* For multiple copies, get the last copy.  */\n-      vec_lhs = gimple_get_lhs (STMT_VINFO_VEC_STMTS (stmt_info).last ());\n+      vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info).last ();\n+      vec_lhs = gimple_get_lhs (vec_stmt);\n \n       /* Get the last lane in the vector.  */\n       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);\n     }\n \n-  /* Ensure the VEC_LHS for lane extraction stmts satisfy loop-closed PHI\n-     requirement, insert one phi node for it.  It looks like:\n-\t loop;\n-       BB:\n-\t # lhs' = PHI <lhs>\n-     ==>\n-\t loop;\n-       BB:\n-\t # vec_lhs' = PHI <vec_lhs>\n-\t new_tree = lane_extract <vec_lhs', ...>;\n-\t lhs' = new_tree;  */\n+  if (loop_vinfo)\n+    {\n+      /* Ensure the VEC_LHS for lane extraction stmts satisfy loop-closed PHI\n+\t requirement, insert one phi node for it.  It looks like:\n+\t   loop;\n+\t BB:\n+\t   # lhs' = PHI <lhs>\n+\t ==>\n+\t   loop;\n+\t BB:\n+\t   # vec_lhs' = PHI <vec_lhs>\n+\t   new_tree = lane_extract <vec_lhs', ...>;\n+\t   lhs' = new_tree;  */\n+\n+      class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      basic_block exit_bb = single_exit (loop)->dest;\n+      gcc_assert (single_pred_p (exit_bb));\n+\n+      tree vec_lhs_phi = copy_ssa_name (vec_lhs);\n+      gimple *phi = create_phi_node (vec_lhs_phi, exit_bb);\n+      SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, vec_lhs);\n+\n+      gimple_seq stmts = NULL;\n+      tree new_tree;\n+      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\t{\n+\t  /* Emit:\n \n-  basic_block exit_bb = single_exit (loop)->dest;\n-  gcc_assert (single_pred_p (exit_bb));\n+\t       SCALAR_RES = EXTRACT_LAST <VEC_LHS, MASK>\n \n-  tree vec_lhs_phi = copy_ssa_name (vec_lhs);\n-  gimple *phi = create_phi_node (vec_lhs_phi, exit_bb);\n-  SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, vec_lhs);\n+\t     where VEC_LHS is the vectorized live-out result and MASK is\n+\t     the loop mask for the final iteration.  */\n+\t  gcc_assert (ncopies == 1 && !slp_node);\n+\t  tree scalar_type = TREE_TYPE (STMT_VINFO_VECTYPE (stmt_info));\n+\t  tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo),\n+\t\t\t\t\t  1, vectype, 0);\n+\t  tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST, scalar_type,\n+\t\t\t\t\t  mask, vec_lhs_phi);\n \n-  gimple_seq stmts = NULL;\n-  tree new_tree;\n-  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n-    {\n-      /* Emit:\n+\t  /* Convert the extracted vector element to the scalar type.  */\n+\t  new_tree = gimple_convert (&stmts, lhs_type, scalar_res);\n+\t}\n+      else\n+\t{\n+\t  tree bftype = TREE_TYPE (vectype);\n+\t  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n+\t    bftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);\n+\t  new_tree = build3 (BIT_FIELD_REF, bftype,\n+\t\t\t     vec_lhs_phi, bitsize, bitstart);\n+\t  new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),\n+\t\t\t\t\t   &stmts, true, NULL_TREE);\n+\t}\n \n-\t   SCALAR_RES = EXTRACT_LAST <VEC_LHS, MASK>\n+      if (stmts)\n+\t{\n+\t  gimple_stmt_iterator exit_gsi = gsi_after_labels (exit_bb);\n+\t  gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n-\t where VEC_LHS is the vectorized live-out result and MASK is\n-\t the loop mask for the final iteration.  */\n-      gcc_assert (ncopies == 1 && !slp_node);\n-      tree scalar_type = TREE_TYPE (STMT_VINFO_VECTYPE (stmt_info));\n-      tree mask = vect_get_loop_mask (gsi, &LOOP_VINFO_MASKS (loop_vinfo), 1,\n-\t\t\t\t      vectype, 0);\n-      tree scalar_res = gimple_build (&stmts, CFN_EXTRACT_LAST, scalar_type,\n-\t\t\t\t      mask, vec_lhs_phi);\n+\t  /* Remove existing phi from lhs and create one copy from new_tree.  */\n+\t  tree lhs_phi = NULL_TREE;\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_phis (exit_bb);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *phi = gsi_stmt (gsi);\n+\t      if ((gimple_phi_arg_def (phi, 0) == lhs))\n+\t\t{\n+\t\t  remove_phi_node (&gsi, false);\n+\t\t  lhs_phi = gimple_phi_result (phi);\n+\t\t  gimple *copy = gimple_build_assign (lhs_phi, new_tree);\n+\t\t  gsi_insert_before (&exit_gsi, copy, GSI_SAME_STMT);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n \n-      /* Convert the extracted vector element to the required scalar type.  */\n-      new_tree = gimple_convert (&stmts, lhs_type, scalar_res);\n+      /* Replace use of lhs with newly computed result.  If the use stmt is a\n+\t single arg PHI, just replace all uses of PHI result.  It's necessary\n+\t because lcssa PHI defining lhs may be before newly inserted stmt.  */\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n+\tif (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n+\t    && !is_gimple_debug (use_stmt))\n+\t  {\n+\t    if (gimple_code (use_stmt) == GIMPLE_PHI\n+\t\t&& gimple_phi_num_args (use_stmt) == 1)\n+\t      {\n+\t\treplace_uses_by (gimple_phi_result (use_stmt), new_tree);\n+\t      }\n+\t    else\n+\t      {\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t    SET_USE (use_p, new_tree);\n+\t      }\n+\t    update_stmt (use_stmt);\n+\t  }\n     }\n   else\n     {\n+      /* For basic-block vectorization simply insert the lane-extraction.  */\n       tree bftype = TREE_TYPE (vectype);\n       if (VECTOR_BOOLEAN_TYPE_P (vectype))\n \tbftype = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 1);\n-      new_tree = build3 (BIT_FIELD_REF, bftype, vec_lhs_phi, bitsize, bitstart);\n+      tree new_tree = build3 (BIT_FIELD_REF, bftype,\n+\t\t\t      vec_lhs, bitsize, bitstart);\n+      gimple_seq stmts = NULL;\n       new_tree = force_gimple_operand (fold_convert (lhs_type, new_tree),\n \t\t\t\t       &stmts, true, NULL_TREE);\n-    }\n \n-  if (stmts)\n-    {\n-      gimple_stmt_iterator exit_gsi = gsi_after_labels (exit_bb);\n-      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n+      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n \n-      /* Remove existing phi from lhs and create one copy from new_tree.  */\n-      tree lhs_phi = NULL_TREE;\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_phis (exit_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *phi = gsi_stmt (gsi);\n-\t  if ((gimple_phi_arg_def (phi, 0) == lhs))\n-\t    {\n-\t      remove_phi_node (&gsi, false);\n-\t      lhs_phi = gimple_phi_result (phi);\n-\t      gimple *copy = gimple_build_assign (lhs_phi, new_tree);\n-\t      gsi_insert_before (&exit_gsi, copy, GSI_SAME_STMT);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* Replace use of lhs with newly computed result.  If the use stmt is a\n-     single arg PHI, just replace all uses of PHI result.  It's necessary\n-     because lcssa PHI defining lhs may be before newly inserted stmt.  */\n-  use_operand_p use_p;\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n-    if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n-\t&& !is_gimple_debug (use_stmt))\n-    {\n-      if (gimple_code (use_stmt) == GIMPLE_PHI\n-\t  && gimple_phi_num_args (use_stmt) == 1)\n-\t{\n-\t  replace_uses_by (gimple_phi_result (use_stmt), new_tree);\n-\t}\n-      else\n-\t{\n-\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t    SET_USE (use_p, new_tree);\n-\t}\n-      update_stmt (use_stmt);\n+      /* Replace use of lhs with newly computed result.  If the use stmt is a\n+\t single arg PHI, just replace all uses of PHI result.  It's necessary\n+\t because lcssa PHI defining lhs may be before newly inserted stmt.  */\n+      use_operand_p use_p;\n+      stmt_vec_info use_stmt_info;\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n+\tif (!is_gimple_debug (use_stmt)\n+\t    && (!(use_stmt_info = vinfo->lookup_stmt (use_stmt))\n+\t\t|| !PURE_SLP_STMT (vect_stmt_to_vectorize (use_stmt_info))))\n+\t  {\n+\t    /* ???  This can happen when the live lane ends up being\n+\t       used in a vector construction code-generated by an\n+\t       external SLP node (and code-generation for that already\n+\t       happened).  See gcc.dg/vect/bb-slp-47.c.\n+\t       Doing this is what would happen if that vector CTOR\n+\t       were not code-generated yet so it is not too bad.\n+\t       ???  In fact we'd likely want to avoid this situation\n+\t       in the first place.  */\n+\t    if (gimple_code (use_stmt) != GIMPLE_PHI\n+\t\t&& !vect_stmt_dominates_stmt_p (gsi_stmt (*gsi), use_stmt))\n+\t      {\n+\t\tgcc_assert (is_gimple_assign (use_stmt)\n+\t\t\t    && gimple_assign_rhs_code (use_stmt) == CONSTRUCTOR);\n+\t\tif (dump_enabled_p ())\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"Using original scalar computation for \"\n+\t\t\t\t   \"live lane because use preceeds vector \"\n+\t\t\t\t   \"def\\n\");\n+\t\tcontinue;\n+\t      }\n+\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t      SET_USE (use_p, new_tree);\n+\t    update_stmt (use_stmt);\n+\t  }\n     }\n \n   return true;"}, {"sha": "c89ed04f4793e5083f91ef7313c1dd08581eccf1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 129, "deletions": 16, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -2970,6 +2970,101 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n }\n \n \n+/* Mark lanes of NODE that are live outside of the basic-block vectorized\n+   region and that can be vectorized using vectorizable_live_operation\n+   with STMT_VINFO_LIVE_P.  Not handled live operations will cause the\n+   scalar code computing it to be retained.  */\n+\n+static void\n+vect_bb_slp_mark_live_stmts (bb_vec_info bb_vinfo, slp_tree node,\n+\t\t\t     slp_instance instance,\n+\t\t\t     stmt_vector_for_cost *cost_vec,\n+\t\t\t     hash_set<stmt_vec_info> &svisited)\n+{\n+  unsigned i;\n+  stmt_vec_info stmt_info;\n+  stmt_vec_info last_stmt = vect_find_last_scalar_stmt_in_slp (node);\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+    {\n+      stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n+      if (svisited.contains (orig_stmt_info))\n+\tcontinue;\n+      bool mark_visited = true;\n+      gimple *orig_stmt = orig_stmt_info->stmt;\n+      ssa_op_iter op_iter;\n+      def_operand_p def_p;\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n+\t{\n+\t  imm_use_iterator use_iter;\n+\t  gimple *use_stmt;\n+\t  stmt_vec_info use_stmt_info;\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n+\t    if (!is_gimple_debug (use_stmt))\n+\t      {\n+\t\tuse_stmt_info = bb_vinfo->lookup_stmt (use_stmt);\n+\t\tif (!use_stmt_info\n+\t\t    || !PURE_SLP_STMT (vect_stmt_to_vectorize (use_stmt_info)))\n+\t\t  {\n+\t\t    STMT_VINFO_LIVE_P (stmt_info) = true;\n+\t\t    if (vectorizable_live_operation (bb_vinfo, stmt_info,\n+\t\t\t\t\t\t     NULL, node, instance, i,\n+\t\t\t\t\t\t     false, cost_vec))\n+\t\t      /* ???  So we know we can vectorize the live stmt\n+\t\t\t from one SLP node.  If we cannot do so from all\n+\t\t\t or none consistently we'd have to record which\n+\t\t\t SLP node (and lane) we want to use for the live\n+\t\t\t operation.  So make sure we can code-generate\n+\t\t\t from all nodes.  */\n+\t\t      mark_visited = false;\n+\t\t    else\n+\t\t      STMT_VINFO_LIVE_P (stmt_info) = false;\n+\t\t    BREAK_FROM_IMM_USE_STMT (use_iter);\n+\t\t  }\n+\t      }\n+\t  /* We have to verify whether we can insert the lane extract\n+\t     before all uses.  The following is a conservative approximation.\n+\t     We cannot put this into vectorizable_live_operation because\n+\t     iterating over all use stmts from inside a FOR_EACH_IMM_USE_STMT\n+\t     doesn't work.\n+\t     Note that while the fact that we emit code for loads at the\n+\t     first load should make this a non-problem leafs we construct\n+\t     from scalars are vectorized after the last scalar def.\n+\t     ???  If we'd actually compute the insert location during\n+\t     analysis we could use sth less conservative than the last\n+\t     scalar stmt in the node for the dominance check.  */\n+\t  /* ???  What remains is \"live\" uses in vector CTORs in the same\n+\t     SLP graph which is where those uses can end up code-generated\n+\t     right after their definition instead of close to their original\n+\t     use.  But that would restrict us to code-generate lane-extracts\n+\t     from the latest stmt in a node.  So we compensate for this\n+\t     during code-generation, simply not replacing uses for those\n+\t     hopefully rare cases.  */\n+\t  if (STMT_VINFO_LIVE_P (stmt_info))\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n+\t      if (!is_gimple_debug (use_stmt)\n+\t\t  && (!(use_stmt_info = bb_vinfo->lookup_stmt (use_stmt))\n+\t\t      || !PURE_SLP_STMT (vect_stmt_to_vectorize (use_stmt_info)))\n+\t\t  && !vect_stmt_dominates_stmt_p (last_stmt->stmt, use_stmt))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Cannot determine insertion place for \"\n+\t\t\t\t     \"lane extract\\n\");\n+\t\t  STMT_VINFO_LIVE_P (stmt_info) = false;\n+\t\t  mark_visited = true;\n+\t\t}\n+\t}\n+      if (mark_visited)\n+\tsvisited.add (orig_stmt_info);\n+    }\n+\n+  slp_tree child;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+      vect_bb_slp_mark_live_stmts (bb_vinfo, child, instance,\n+\t\t\t\t   cost_vec, svisited);\n+}\n+\n /* Analyze statements in SLP instances of VINFO.  Return true if the\n    operations are supported. */\n \n@@ -3019,6 +3114,19 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t}\n     }\n \n+  /* Compute vectorizable live stmts.  */\n+  if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo))\n+    {\n+      hash_set<stmt_vec_info> svisited;\n+      stmt_vector_for_cost cost_vec;\n+      cost_vec.create (2);\n+      for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n+\tvect_bb_slp_mark_live_stmts (bb_vinfo, SLP_INSTANCE_TREE (instance),\n+\t\t\t\t     instance, &cost_vec, svisited);\n+      add_stmt_costs (vinfo, vinfo->target_cost_data, &cost_vec);\n+      cost_vec.release ();\n+    }\n+\n   return !vinfo->slp_instances.is_empty ();\n }\n \n@@ -3048,31 +3156,36 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n       if ((*life)[i])\n \tcontinue;\n \n+      stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n+      gimple *orig_stmt = orig_stmt_info->stmt;\n+\n       /* If there is a non-vectorized use of the defs then the scalar\n          stmt is kept live in which case we do not account it or any\n \t required defs in the SLP children in the scalar cost.  This\n \t way we make the vectorization more costly when compared to\n \t the scalar cost.  */\n-      stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n-      gimple *orig_stmt = orig_stmt_info->stmt;\n-      FOR_EACH_SSA_DEF_OPERAND (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n+      if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{\n-\t  imm_use_iterator use_iter;\n-\t  gimple *use_stmt;\n-\t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n-\t    if (!is_gimple_debug (use_stmt))\n-\t      {\n-\t\tstmt_vec_info use_stmt_info = vinfo->lookup_stmt (use_stmt);\n-\t\tif (!use_stmt_info\n-\t\t    || !PURE_SLP_STMT (vect_stmt_to_vectorize (use_stmt_info)))\n+\t  FOR_EACH_SSA_DEF_OPERAND (def_p, orig_stmt, op_iter, SSA_OP_DEF)\n+\t    {\n+\t      imm_use_iterator use_iter;\n+\t      gimple *use_stmt;\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n+\t\tif (!is_gimple_debug (use_stmt))\n \t\t  {\n-\t\t    (*life)[i] = true;\n-\t\t    BREAK_FROM_IMM_USE_STMT (use_iter);\n+\t\t    stmt_vec_info use_stmt_info = vinfo->lookup_stmt (use_stmt);\n+\t\t    if (!use_stmt_info\n+\t\t\t|| !PURE_SLP_STMT\n+\t\t\t      (vect_stmt_to_vectorize (use_stmt_info)))\n+\t\t      {\n+\t\t\t(*life)[i] = true;\n+\t\t\tBREAK_FROM_IMM_USE_STMT (use_iter);\n+\t\t      }\n \t\t  }\n-\t      }\n+\t    }\n+\t  if ((*life)[i])\n+\t    continue;\n \t}\n-      if ((*life)[i])\n-\tcontinue;\n \n       /* Count scalar stmts only once.  */\n       if (gimple_visited_p (orig_stmt))"}, {"sha": "a7ffe72378ffeea36e4ba4f44e8da863c421ca9e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -10532,7 +10532,7 @@ vectorizable_comparison (vec_info *vinfo,\n    GSI and VEC_STMT_P are as for vectorizable_live_operation.  */\n \n static bool\n-can_vectorize_live_stmts (loop_vec_info loop_vinfo,\n+can_vectorize_live_stmts (vec_info *vinfo,\n \t\t\t  stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t  slp_tree slp_node, slp_instance slp_node_instance,\n \t\t\t  bool vec_stmt_p,\n@@ -10545,15 +10545,15 @@ can_vectorize_live_stmts (loop_vec_info loop_vinfo,\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, slp_stmt_info)\n \t{\n \t  if (STMT_VINFO_LIVE_P (slp_stmt_info)\n-\t      && !vectorizable_live_operation (loop_vinfo,\n+\t      && !vectorizable_live_operation (vinfo,\n \t\t\t\t\t       slp_stmt_info, gsi, slp_node,\n \t\t\t\t\t       slp_node_instance, i,\n \t\t\t\t\t       vec_stmt_p, cost_vec))\n \t    return false;\n \t}\n     }\n   else if (STMT_VINFO_LIVE_P (stmt_info)\n-\t   && !vectorizable_live_operation (loop_vinfo, stmt_info, gsi,\n+\t   && !vectorizable_live_operation (vinfo, stmt_info, gsi,\n \t\t\t\t\t    slp_node, slp_node_instance, -1,\n \t\t\t\t\t    vec_stmt_p, cost_vec))\n     return false;\n@@ -10923,10 +10923,8 @@ vect_transform_stmt (vec_info *vinfo,\n \n   /* Handle stmts whose DEF is used outside the loop-nest that is\n      being vectorized.  */\n-  if (is_a <loop_vec_info> (vinfo))\n-    done = can_vectorize_live_stmts (as_a <loop_vec_info> (vinfo),\n-\t\t\t\t     stmt_info, gsi, slp_node,\n-\t\t\t\t     slp_node_instance, true, NULL);\n+  done = can_vectorize_live_stmts (vinfo, stmt_info, gsi, slp_node,\n+\t\t\t\t   slp_node_instance, true, NULL);\n   gcc_assert (done);\n \n   return false;"}, {"sha": "fb1111c8615e83ce926db15d9702b44023b5b799", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095d42feed09f880f835ed74d0aa7b1ad7abd03c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=095d42feed09f880f835ed74d0aa7b1ad7abd03c", "patch": "@@ -1990,7 +1990,7 @@ extern stmt_vec_info info_for_reduction (vec_info *, stmt_vec_info);\n extern class loop *vect_transform_loop (loop_vec_info, gimple *);\n extern opt_loop_vec_info vect_analyze_loop_form (class loop *,\n \t\t\t\t\t\t vec_info_shared *);\n-extern bool vectorizable_live_operation (loop_vec_info,\n+extern bool vectorizable_live_operation (vec_info *,\n \t\t\t\t\t stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, slp_instance, int,\n \t\t\t\t\t bool, stmt_vector_for_cost *);"}]}