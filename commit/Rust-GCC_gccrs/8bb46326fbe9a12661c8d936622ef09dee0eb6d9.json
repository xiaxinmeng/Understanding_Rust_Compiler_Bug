{"sha": "8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJiNDYzMjZmYmU5YTEyNjYxYzhkOTM2NjIyZWYwOWRlZTBlYjZkOQ==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-03-29T16:10:22Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-03-29T16:10:22Z"}, "message": "tree-ssanames.c (duplicate_ssa_name_ptr_info): New function.\n\n        * tree-ssanames.c (duplicate_ssa_name_ptr_info): New function.\n        (duplicate_ssa_name): Call duplicate_ssa_name_ptr_info.\n        * tree-vect-analyze.c (vect_object_analysis): additional parm\n        pass back a \"struct ptr_info_def *\" with the points-to info.\n        (vect_analyze_data_refs): set the STMT_VINFO_PTR_INFO for the\n        statement using info returned from vect_object_analysis.\n        * tree-vect-transform.c (update_vuses_to_preheader): New function.\n        (vect_create_data_ref_ptr): Remove updates to vars_to_rename\n        for virtual uses and defs when creating a replacement vector\n        reference.  Call duplicate_ssa_name_ptr_info to define points-to\n        info for vector pointer replacement using STMT_VINFO_PTR_INFO.\n        (vectorizable_store): copy_virtual_operands and update\n        definition statements.\n        (vectorizable_load): copy_virtual_operands.  Remove call to\n        mark_call_clobbered_vars_to_rename for call to \"const\" builtin.\n        * tree-vectorizer.c (vectorize_loops): Remove calls to\n        rewrite_into_ssa and bitmap_clear (vars_to_rename).\n        (new_stmt_vec_info): initialize STMT_VINFO_PTR_INFO for stmt.\n        * tree-vectorizer.h (_stmt_vec_info): add field ptr_info and\n        define macro STMT_VINFO_PTR_INFO for use in accessing.\n        * tree.h add export of duplicate_ssa_name_ptr_info.\n        * rs6000.c (altivec_init_builtins): Declare builtin function\n        __builtin_altivec_mask_for_load to be \"const\".\n\nFrom-SVN: r97164", "tree": {"sha": "3b6e04f8be928ef4cb17b708c1898650d3020a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b6e04f8be928ef4cb17b708c1898650d3020a60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/comments", "author": null, "committer": null, "parents": [{"sha": "1a612e0a6cc76824017ca688693c9340114f1a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a612e0a6cc76824017ca688693c9340114f1a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a612e0a6cc76824017ca688693c9340114f1a76"}], "stats": {"total": 465, "additions": 409, "deletions": 56}, "files": [{"sha": "0d5849a489a9aeacac4d18d960aefd4f952b541c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -1,3 +1,29 @@\n+2005-03-29  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* tree-ssanames.c (duplicate_ssa_name_ptr_info): New function.\n+\t(duplicate_ssa_name): Call duplicate_ssa_name_ptr_info.\n+\t* tree-vect-analyze.c (vect_object_analysis): additional parm\n+\tpass back a \"struct ptr_info_def *\" with the points-to info.\n+\t(vect_analyze_data_refs): set the STMT_VINFO_PTR_INFO for the\n+\tstatement using info returned from vect_object_analysis.\n+\t* tree-vect-transform.c (update_vuses_to_preheader): New function.\n+\t(vect_create_data_ref_ptr): Remove updates to vars_to_rename\n+\tfor virtual uses and defs when creating a replacement vector\n+\treference.  Call duplicate_ssa_name_ptr_info to define points-to\n+\tinfo for vector pointer replacement using STMT_VINFO_PTR_INFO.\n+\t(vectorizable_store): copy_virtual_operands and update\n+\tdefinition statements.\n+\t(vectorizable_load): copy_virtual_operands.  Remove call to\n+\tmark_call_clobbered_vars_to_rename for call to \"const\" builtin.\n+\t* tree-vectorizer.c (vectorize_loops): Remove calls to\n+\trewrite_into_ssa and bitmap_clear (vars_to_rename).\n+\t(new_stmt_vec_info): initialize STMT_VINFO_PTR_INFO for stmt.\n+\t* tree-vectorizer.h (_stmt_vec_info): add field ptr_info and\n+\tdefine macro STMT_VINFO_PTR_INFO for use in accessing.\n+\t* tree.h add export of duplicate_ssa_name_ptr_info.\n+\t* rs6000.c (altivec_init_builtins): Declare builtin function\n+\t__builtin_altivec_mask_for_load to be \"const\".\n+\n 2005-03-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/20622"}, {"sha": "3ac7c833c785c921177f0996d56758b1f17ac816", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -7665,9 +7665,11 @@ altivec_init_builtins (void)\n          targetm.vectorize.builtin_mask_for_load.  */\n \n       decl = lang_hooks.builtin_function (\"__builtin_altivec_mask_for_load\",\n-\t\t\t\t\t  v16qi_ftype_long_pcvoid,\n-\t\t\t\t\t  ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n-\t\t\t\t\t  BUILT_IN_MD, NULL, NULL_TREE);\n+                               v16qi_ftype_long_pcvoid,\n+                               ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n+                               BUILT_IN_MD, NULL,\n+                               tree_cons (get_identifier (\"const\"),\n+                                          NULL_TREE, NULL_TREE));\n       /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n       altivec_builtin_mask_for_load = decl;\n     }"}, {"sha": "ccbd3cb97c37bca08871ddd235fbf2efdf836b12", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -1,3 +1,8 @@\n+2005-03-29  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* f95-lang.c (builtin_function): Process the attrs parameter\n+\tand apply the \"const\" attribute to the builtin if found.\n+\n 2005-03-27  Steven G. Kargl  <kargls@comcast.net>\n \n \t* intrinsic.texi: Document AIMAG, AINT, ALL"}, {"sha": "2fb06a9537a85c85d30c77f3a4578f001bf99fe7", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -680,7 +680,7 @@ builtin_function (const char *name,\n \t\t  int function_code,\n \t\t  enum built_in_class class,\n \t\t  const char *library_name,\n-\t\t  tree attrs ATTRIBUTE_UNUSED)\n+\t\t  tree attrs)\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n@@ -691,6 +691,17 @@ builtin_function (const char *name,\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;\n+\n+  /* Possibly apply some default attributes to this built-in function.  */\n+  if (attrs)\n+    {\n+      /* FORNOW the only supported attribute is \"const\".  If others need\n+         to be supported then see the more general solution in procedure\n+         builtin_function in c-decl.c  */\n+      if (lookup_attribute ( \"const\", attrs ))\n+        TREE_READONLY (decl) = 1;\n+    }\n+\n   return decl;\n }\n "}, {"sha": "dba8cc6a10cd4b0be46b471db9cef8214cbd3cd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -1,3 +1,13 @@\n+2005-03-29  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* gfortran.dg/vect: New directory.\n+\t* gfortran.dg/vect/vect.exp: New.\n+\t* gfortran.dg/vect/vect-1.f90: New test.\n+\t* gfortran.dg/vect/vect-2.f90: New test.\n+\t* gfortran.dg/vect/vect-3.f90: New test.\n+\t* gfortran.dg/vect/vect-4.f90: New test.\n+\t* gfortran.dg/vect/vect-5.f90: New test.\n+\n 2005-03-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/20622"}, {"sha": "90b37e4688f1a5d12e9382844239bd3723b6b3ce", "filename": "gcc/testsuite/gfortran.dg/vect/vect-1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-1.f90?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+DIMENSION A(1000000), B(1000000), C(1000000)\n+READ*, X, Y\n+A = LOG(X); B = LOG(Y); C = A + B\n+PRINT*, C(500000)\n+END\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } }"}, {"sha": "f9cc35e6965911e9e9a76abaa018acaf8531846e", "filename": "gcc/testsuite/gfortran.dg/vect/vect-2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+SUBROUTINE FOO(A, B, C)\n+DIMENSION A(1000000), B(1000000), C(1000000)\n+READ*, X, Y\n+A = LOG(X); B = LOG(Y); C = A + B\n+PRINT*, C(500000)\n+END\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } }"}, {"sha": "26b9c79f642eba6e2e5f2b0564180d6b6263e10e", "filename": "gcc/testsuite/gfortran.dg/vect/vect-3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+SUBROUTINE SAXPY(X, Y, A, N)\n+DIMENSION X(N), Y(N)\n+Y = Y + A * X\n+END\n+\n+! fail to vectorize due to failure to compute number of iterations (PR tree-optimization/18527)\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } \n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail *-*-* } } } \n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail *-*-* } } } "}, {"sha": "76594389cf253f7bc85497c5b7fb342c2d205c36", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+SUBROUTINE SAXPY(X, Y, A)\n+DIMENSION X(64), Y(64)\n+Y = Y + A * X\n+END\n+\n+! fail to vectorize until the patch that ignores dependence-distance 0 is \n+! brought from autovect. \n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } \n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail *-*-* } } }"}, {"sha": "44d8b6298274b8479bc87d12653c2f06c8856c83", "filename": "gcc/testsuite/gfortran.dg/vect/vect-5.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,40 @@\n+! { dg-require-effective-target vect_int }\n+\n+        Subroutine foo (N, M)\n+        Integer N\n+        Integer M\n+        integer A(8,16)\n+        integer B(8)\n+\n+        B = (/ 2, 3, 5, 7, 11, 13, 17, 23 /)\n+\n+        ! Unknown loop bound. J depends on I.\n+\n+        do I = 1, N\n+          do J = I, M\n+            A(J,2) = B(J)\n+          end do\n+        end do\n+\n+        do I = 1, N\n+          do J = I, M\n+            if (A(J,2) /= B(J)) then\n+              call abort ()\n+              endif\n+          end do\n+        end do\n+\n+        Return\n+        end\n+\n+\n+        program main\n+\n+        Call foo (16, 8)\n+\n+        stop\n+        end\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } }"}, {"sha": "2b84fe4ed23d709d25e267cc6d064005ccd3ab24", "filename": "gcc/testsuite/gfortran.dg/vect/vect.exp", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -0,0 +1,99 @@\n+# Copyright (C) 1997, 2004 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+load_lib target-supports.exp\n+\n+# Set up flags used for tests that don't specify options.\n+set DEFAULT_VECTCFLAGS \"\"\n+\n+# These flags are used for all targets.\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \\\n+  \"-ftree-vectorizer-verbose=3\" \"-fdump-tree-vect-stats\"\n+\n+# If the target system supports vector instructions, the default action\n+# for a test is 'run', otherwise it's 'compile'.  Save current default.\n+# Executing vector instructions on a system without hardware vector support\n+# is also disabled by a call to check_vect, but disabling execution here is\n+# more efficient.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+# Skip these tests for targets that do not support generating vector\n+# code.  Set additional target-dependent vector flags, which can be\n+# overridden by using dg-options in individual tests.\n+if [istarget \"powerpc*-*-*\"] {\n+    # If there are powerpc targets to skip, do it here.\n+\n+    lappend DEFAULT_VECTCFLAGS \"-maltivec\"\n+    if [check_vmx_hw_available] {\n+\tset dg-do-what-default run\n+    } else {\n+\tif [is-effective-target ilp32] {\n+\t    # Specify a cpu that supports VMX for compile-only tests.\n+\t    lappend DEFAULT_VECTCFLAGS \"-mcpu=7400\"\n+\t}\n+\tset dg-do-what-default compile\n+    }\n+} elseif { [istarget \"i?86-*-*\"] || [istarget \"x86_64-*-*\"] } {\n+    lappend DEFAULT_VECTCFLAGS \"-msse2\"\n+    set dg-do-what-default run\n+} elseif [istarget \"mipsisa64*-*-*\"] {\n+    lappend DEFAULT_VECTCFLAGS \"-mpaired-single\"\n+    set dg-do-what-default run\n+} elseif [istarget \"sparc*-*-*\"] {\n+    lappend DEFAULT_VECTCFLAGS \"-mcpu=ultrasparc\" \"-mvis\"\n+    set dg-do-what-default run\n+} elseif [istarget \"alpha*-*-*\"] {\n+    lappend DEFAULT_VECTCFLAGS \"-mmax\"\n+    if [check_alpha_max_hw_available] {\n+\tset dg-do-what-default run\n+    } else {\n+\tset dg-do-what-default compile\n+    }\n+} elseif [istarget \"ia64-*-*\"] {\n+    set dg-do-what-default run\n+} else {\n+    return\n+}\n+\n+# Return 1 if the effective target is LP64 or if the effective target\n+# does not support a vector alignment mechanism.\n+\n+proc check_effective_target_lp64_or_vect_no_align { } {\n+    if { [is-effective-target lp64]\n+          || [is-effective-target vect_no_align] } {\n+        set answer 1\n+    } else {\n+        set answer 0\n+    }\n+    return $answer\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95} ]] $DEFAULT_VECTCFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "a89d6087f3882f4c71d60fe08a656fe3ed18bd4f", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -279,22 +279,38 @@ duplicate_ssa_name (tree name, tree stmt)\n {\n   tree new_name = make_ssa_name (SSA_NAME_VAR (name), stmt);\n   struct ptr_info_def *old_ptr_info = SSA_NAME_PTR_INFO (name);\n+\n+  if (old_ptr_info)\n+    duplicate_ssa_name_ptr_info (new_name, old_ptr_info);\n+\n+  return new_name;\n+}\n+\n+\n+/* Creates a duplicate of the ptr_info_def at PTR_INFO for use by\n+   the ssa name NAME.  */\n+\n+void\n+duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n+{\n   struct ptr_info_def *new_ptr_info;\n \n-  if (!old_ptr_info)\n-    return new_name;\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n+  gcc_assert (!SSA_NAME_PTR_INFO (name));\n+\n+  if (!ptr_info)\n+    return;\n \n   new_ptr_info = ggc_alloc (sizeof (struct ptr_info_def));\n-  *new_ptr_info = *old_ptr_info;\n+  *new_ptr_info = *ptr_info;\n \n-  if (old_ptr_info->pt_vars)\n+  if (ptr_info->pt_vars)\n     {\n       new_ptr_info->pt_vars = BITMAP_GGC_ALLOC ();\n-      bitmap_copy (new_ptr_info->pt_vars, old_ptr_info->pt_vars);\n+      bitmap_copy (new_ptr_info->pt_vars, ptr_info->pt_vars);\n     }\n \n-  SSA_NAME_PTR_INFO (new_name) = new_ptr_info;\n-  return new_name;\n+  SSA_NAME_PTR_INFO (name) = new_ptr_info;\n }\n \n "}, {"sha": "97ad2314b65d9ccf9c9a4c14e41552951ef9ceec", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -71,7 +71,8 @@ static bool vect_base_addr_differ_p (struct data_reference *,\n \t\t\t\t     struct data_reference *drb, bool *);\n static tree vect_object_analysis (tree, tree, bool, tree, \n \t\t\t\t  struct data_reference **, tree *, tree *, \n-\t\t\t\t  tree *, bool *, tree *, subvar_t *);\n+\t\t\t\t  tree *, bool *, tree *, struct ptr_info_def **,\n+\t\t\t\t  subvar_t *);\n static tree vect_address_analysis (tree, tree, bool, tree, \n \t\t\t\t   struct data_reference *, tree *, tree *, \n \t\t\t\t   tree *, bool *);\n@@ -1476,6 +1477,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n   tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n   tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n   tree dummy;\n+  struct ptr_info_def *dummy1;\n   subvar_t dummy2;\n \n   switch (TREE_CODE (expr))\n@@ -1529,7 +1531,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n       base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt,\n \t\t\t\t\t   is_read, vectype, &dr, offset, \n \t\t\t\t\t   misalign, step, base_aligned, \n-\t\t\t\t\t   &dummy, &dummy2);\n+\t\t\t\t\t   &dummy, &dummy1, &dummy2);\n       return base_address;\n \n     case SSA_NAME:\n@@ -1608,6 +1610,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n    STEP - evolution of the DR_REF in the loop\n    BASE_ALIGNED - indicates if BASE is aligned\n    MEMTAG - memory tag for aliasing purposes\n+   PTR_INFO - NULL or points-to aliasing info from a pointer SSA_NAME\n    SUBVAR - Sub-variables of the variable\n  \n    If something unexpected is encountered (an unsupported form of data-ref),\n@@ -1618,7 +1621,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t\t      tree vectype, struct data_reference **dr,\n \t\t      tree *offset, tree *misalign, tree *step,\n \t\t      bool *base_aligned, tree *memtag,\n-\t\t      subvar_t *subvars)\n+\t\t      struct ptr_info_def **ptr_info, subvar_t *subvars)\n {\n   tree base = NULL_TREE, base_address = NULL_TREE;\n   tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n@@ -1635,6 +1638,8 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *ptr_dr = NULL;\n   tree access_fn, evolution_part, address_to_analyze;\n+\n+  *ptr_info = NULL;\n    \n   /* Part 1: */\n   /* Case 1. handled_component_p refs.  */\n@@ -1722,9 +1727,13 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \n   /* Part 1:  Case 3. INDIRECT_REFs.  */\n   else if (TREE_CODE (memref) == INDIRECT_REF)\n-    {      \n+    {\n+      tree ptr_ref = TREE_OPERAND (memref, 0);\n+      if (TREE_CODE (ptr_ref) == SSA_NAME)\n+        *ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n+\n       /* 3.1 get the access function.  */\n-      access_fn = analyze_scalar_evolution (loop, TREE_OPERAND (memref, 0));\n+      access_fn = analyze_scalar_evolution (loop, ptr_ref);\n       if (!access_fn)\n \t{\n \t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n@@ -1849,7 +1858,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n            Call get_inner_reference for refs handled in this function.\n            Call vect_addr_analysis(addr) to analyze pointer type expressions.\n       Set ref_stmt.base, ref_stmt.initial_offset, ref_stmt.alignment,  \n-      ref_stmt.memtag and ref_stmt.step accordingly. \n+      ref_stmt.memtag, ref_stmt.ptr_info and ref_stmt.step accordingly. \n    2- vect_analyze_dependences(): apply dependence testing using ref_stmt.DR\n    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n@@ -1887,6 +1896,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  tree memref = NULL;\n \t  tree scalar_type, vectype;\t  \n \t  tree base, offset, misalign, step, tag;\n+\t  struct ptr_info_def *ptr_info;\n \t  bool base_aligned;\n \t  subvar_t subvars = NULL;\n \n@@ -1952,7 +1962,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  dr = NULL; \n \t  base = vect_object_analysis (memref, stmt, is_read, vectype, &dr, \n \t\t\t\t       &offset, &misalign, &step, \n-\t\t\t\t       &base_aligned, &tag, &subvars);\n+\t\t\t\t       &base_aligned, &tag, &ptr_info,\n+\t\t\t\t       &subvars);\n \t  if (!base)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n@@ -1969,6 +1980,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n \t  STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned;\n \t  STMT_VINFO_MEMTAG (stmt_info) = tag;\n+\t  STMT_VINFO_PTR_INFO (stmt_info) = ptr_info;\n \t  STMT_VINFO_SUBVARS (stmt_info) = subvars;\n \t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);"}, {"sha": "4940f2d941948fd111a42f1f24538e2c4f59b28e", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 117, "deletions": 35, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -57,6 +57,7 @@ static tree vect_get_vec_def_for_operand (tree, tree);\n static tree vect_init_vector (tree, tree);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n+static void update_vuses_to_preheader (tree, struct loop*);\n \n /* Utility function dealing with loop peeling (not peeling itself).  */\n static void vect_generate_tmps_on_preheader \n@@ -304,11 +305,6 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree vect_ptr_type;\n   tree vect_ptr;\n   tree tag;\n-  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n-  int nvuses, nv_may_defs, nv_must_defs;\n-  int i;\n   tree new_temp;\n   tree vec_stmt;\n   tree new_stmt_list = NULL_TREE;\n@@ -348,38 +344,14 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   add_referenced_tmp_var (vect_ptr);\n   \n   \n-  /** (2) Handle aliasing information of the new vector-pointer:  **/\n+  /** (2) Add aliasing information to the new vector-pointer:\n+          (The points-to info (SSA_NAME_PTR_INFO) may be defined later.)  **/\n   \n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n   get_var_ann (vect_ptr)->type_mem_tag = tag;\n   get_var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n \n-  /* Mark for renaming all aliased variables\n-     (i.e, the may-aliases of the type-mem-tag).  */\n-  nvuses = NUM_VUSES (vuses);\n-  nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n-  nv_must_defs = NUM_V_MUST_DEFS (v_must_defs);\n-\n-  for (i = 0; i < nvuses; i++)\n-    {\n-      tree use = VUSE_OP (vuses, i);\n-      if (TREE_CODE (use) == SSA_NAME)\n-        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (use))->uid);\n-    }\n-  for (i = 0; i < nv_may_defs; i++)\n-    {\n-      tree def = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (TREE_CODE (def) == SSA_NAME)\n-        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n-    }\n-  for (i = 0; i < nv_must_defs; i++)\n-    {\n-      tree def = V_MUST_DEF_RESULT (v_must_defs, i);\n-      if (TREE_CODE (def) == SSA_NAME)\n-        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n-    }\n-\n \n   /** (3) Calculate the initial address the vector-pointer, and set\n           the vector-pointer to point to it before the loop:  **/\n@@ -405,7 +377,13 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   /** (4) Handle the updating of the vector-pointer inside the loop: **/\n \n   if (only_init) /* No update in loop is required.  */\n-    return vect_ptr_init;\n+    {\n+      /* Copy the points-to information if it exists. */\n+      if (STMT_VINFO_PTR_INFO (stmt_info))\n+        duplicate_ssa_name_ptr_info (vect_ptr_init,\n+                                     STMT_VINFO_PTR_INFO (stmt_info));\n+      return vect_ptr_init;\n+    }\n \n   idx = vect_create_index_for_vector_ref (loop_vinfo);\n \n@@ -436,6 +414,9 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n   data_ref_ptr = TREE_OPERAND (vec_stmt, 0);\n \n+  /* Copy the points-to information if it exists. */\n+  if (STMT_VINFO_PTR_INFO (stmt_info))\n+    duplicate_ssa_name_ptr_info (data_ref_ptr, STMT_VINFO_PTR_INFO (stmt_info));\n   return data_ref_ptr;\n }\n \n@@ -865,6 +846,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n+  v_may_def_optype v_may_defs;\n+  int nv_may_defs, i;\n \n   /* Is vectorizable store? */\n \n@@ -922,6 +905,20 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   *vec_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd1);\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n \n+  /* Copy the V_MAY_DEFS representing the aliasing of the original array\n+     element's definition to the vector's definition then update the\n+     defining statement.  The original is being deleted so the same\n+     SSA_NAMEs can be used.  */\n+  copy_virtual_operands (*vec_stmt, stmt);\n+  v_may_defs = STMT_V_MAY_DEF_OPS (*vec_stmt);\n+  nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n+\t    \n+  for (i = 0; i < nv_may_defs; i++)\n+    {\n+      tree ssa_name = V_MAY_DEF_RESULT (v_may_defs, i);\n+      SSA_NAME_DEF_STMT (ssa_name) = *vec_stmt;\n+    }\n+\n   return true;\n }\n \n@@ -1023,6 +1020,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      copy_virtual_operands (new_stmt, stmt);\n     }\n   else if (alignment_support_cheme == dr_unaligned_software_pipeline)\n     {\n@@ -1060,6 +1058,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n       gcc_assert (!new_bb);\n       msq_init = TREE_OPERAND (new_stmt, 0);\n+      copy_virtual_operands (new_stmt, stmt);\n+      update_vuses_to_preheader (new_stmt, loop);\n \n \n       /* <2> Create lsq = *(floor(p2')) in the loop  */ \n@@ -1074,6 +1074,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       TREE_OPERAND (new_stmt, 0) = new_temp;\n       vect_finish_stmt_generation (stmt, new_stmt, bsi);\n       lsq = TREE_OPERAND (new_stmt, 0);\n+      copy_virtual_operands (new_stmt, stmt);\n \n \n       /* <3> */\n@@ -1092,9 +1093,12 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  gcc_assert (!new_bb);\n \t  magic = TREE_OPERAND (new_stmt, 0);\n \n-\t  /* Since we have just created a CALL_EXPR, we may need to\n-\t     rename call-clobbered variables.  */\n-\t  mark_call_clobbered_vars_to_rename ();\n+\t  /* The result of the CALL_EXPR to this builtin is determined from\n+\t     the value of the parameter and no global variables are touched\n+\t     which makes the builtin a \"const\" function.  Requiring the\n+\t     builtin to have the \"const\" attribute makes it unnecessary\n+\t     to call mark_call_clobbered_vars_to_rename.  */\n+\t  gcc_assert (TREE_READONLY (builtin_decl));\n \t}\n       else\n \t{\n@@ -1268,6 +1272,84 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n }\n \n \n+/* Function update_vuses_to_preheader.\n+\n+   Input:\n+   STMT - a statement with potential VUSEs.\n+   LOOP - the loop whose preheader will contain STMT.\n+\n+   It's possible to vectorize a loop even though an SSA_NAME from a VUSE\n+   appears to be defined in a V_MAY_DEF in another statement in a loop.\n+   One such case is when the VUSE is at the dereference of a __restricted__\n+   pointer in a load and the V_MAY_DEF is at the dereference of a different\n+   __restricted__ pointer in a store.  Vectorization may result in\n+   copy_virtual_uses being called to copy the problematic VUSE to a new\n+   statement that is being inserted in the loop preheader.  This procedure\n+   is called to change the SSA_NAME in the new statement's VUSE from the\n+   SSA_NAME updated in the loop to the related SSA_NAME available on the\n+   path entering the loop.\n+\n+   When this function is called, we have the following situation:\n+\n+        # vuse <name1>\n+        S1: vload\n+    do {\n+        # name1 = phi < name0 , name2>\n+\n+        # vuse <name1>\n+        S2: vload\n+\n+        # name2 = vdef <name1>\n+        S3: vstore\n+\n+    }while...\n+\n+   Stmt S1 was created in the loop preheader block as part of misaligned-load\n+   handling. This function fixes the name of the vuse of S1 from 'name1' to\n+   'name0'.  */\n+\n+static void\n+update_vuses_to_preheader (tree stmt, struct loop *loop)\n+{\n+  basic_block header_bb = loop->header;\n+  edge preheader_e = loop_preheader_edge (loop);\n+  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n+  int nvuses = NUM_VUSES (vuses);\n+  int i;\n+\n+  for (i = 0; i < nvuses; i++)\n+    {\n+      tree ssa_name = VUSE_OP (vuses, i);\n+      tree def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n+      tree name_var = SSA_NAME_VAR (ssa_name);\n+      basic_block bb = bb_for_stmt (def_stmt);\n+\n+      /* For a use before any definitions, def_stmt is a NOP_EXPR.  */\n+      if (!IS_EMPTY_STMT (def_stmt)\n+\t  && flow_bb_inside_loop_p (loop, bb))\n+        {\n+          /* If the block containing the statement defining the SSA_NAME\n+             is in the loop then it's necessary to find the definition\n+             outside the loop using the PHI nodes of the header.  */\n+\t  tree phi;\n+\t  bool updated = false;\n+\n+\t  for (phi = phi_nodes (header_bb); phi; phi = TREE_CHAIN (phi))\n+\t    {\n+\t      if (SSA_NAME_VAR (PHI_RESULT (phi)) == name_var)\n+\t\t{\n+\t\t  SET_VUSE_OP (vuses, i, \n+\t\t\t       PHI_ARG_DEF (phi, preheader_e->dest_idx));\n+\t\t  updated = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  gcc_assert (updated);\n+\t}\n+    }\n+}\n+\n+\n /*   Function vect_update_ivs_after_vectorizer.\n \n      \"Advance\" the induction variables of LOOP to the value they should take"}, {"sha": "9df3a68d7896b5266e386df3f887f22b24ad3578", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -1167,6 +1167,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n   STMT_VINFO_MEMTAG (res) = NULL;\n+  STMT_VINFO_PTR_INFO (res) = NULL;\n   STMT_VINFO_SUBVARS (res) = NULL;\n   STMT_VINFO_VECT_DR_BASE_ADDRESS (res) = NULL;\n   STMT_VINFO_VECT_INIT_OFFSET (res) = NULL_TREE;\n@@ -1618,7 +1619,5 @@ vectorize_loops (struct loops *loops)\n       loop->aux = NULL;\n     }\n \n-  rewrite_into_ssa (false);\n   rewrite_into_loop_closed_ssa (NULL); /* FORNOW */\n-  bitmap_clear (vars_to_rename);\n }"}, {"sha": "dee7a4ebc540f7b32789c2ea4b7e6d8ac77620ae", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -178,6 +178,7 @@ typedef struct _stmt_vec_info {\n \n   /* Aliasing information.  */\n   tree memtag;\n+  struct ptr_info_def *ptr_info;\n   subvar_t subvars;\n \n   /** The following fields are used to store the information about \n@@ -220,7 +221,8 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n #define STMT_VINFO_MEMTAG(S)              (S)->memtag\n-#define STMT_VINFO_SUBVARS(S)              (S)->subvars\n+#define STMT_VINFO_PTR_INFO(S)            (S)->ptr_info\n+#define STMT_VINFO_SUBVARS(S)             (S)->subvars\n #define STMT_VINFO_VECT_DR_BASE_ADDRESS(S)(S)->base_address\n #define STMT_VINFO_VECT_INIT_OFFSET(S)    (S)->initial_offset\n #define STMT_VINFO_VECT_STEP(S)           (S)->step"}, {"sha": "d09034c167af70105444b65a796e33edfea96391", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb46326fbe9a12661c8d936622ef09dee0eb6d9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8bb46326fbe9a12661c8d936622ef09dee0eb6d9", "patch": "@@ -2801,6 +2801,7 @@ extern void init_ssanames (void);\n extern void fini_ssanames (void);\n extern tree make_ssa_name (tree, tree);\n extern tree duplicate_ssa_name (tree, tree);\n+extern void duplicate_ssa_name_ptr_info (tree, struct ptr_info_def *);\n extern void release_ssa_name (tree);\n extern void release_defs (tree);\n extern void replace_ssa_name_symbol (tree, tree);"}]}