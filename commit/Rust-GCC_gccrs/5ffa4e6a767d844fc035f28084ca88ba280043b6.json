{"sha": "5ffa4e6a767d844fc035f28084ca88ba280043b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZmYTRlNmE3NjdkODQ0ZmMwMzVmMjgwODRjYTg4YmEyODAwNDNiNg==", "commit": {"author": {"name": "Felix Yang", "email": "felix.yang@huawei.com", "date": "2014-10-14T00:12:51Z"}, "committer": {"name": "Fei Yang", "email": "fyang@gcc.gnu.org", "date": "2014-10-14T00:12:51Z"}, "message": "ira.c (struct equivalence): Change member \"is_arg_equivalence\" and \"replace\" into boolean bitfields...\n\ngcc/\n        * ira.c (struct equivalence): Change member \"is_arg_equivalence\" and\n        \"replace\" into boolean bitfields; turn member \"loop_depth\" into a short\n        integer; add new member \"no_equiv\" and \"reserved\".\n        (no_equiv): Set no_equiv of struct equivalence if register is marked\n        as having no known equivalence.\n        (update_equiv_regs): Check all definitions for a multiple-set\n        register to make sure that the RHS have the same value.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r216169", "tree": {"sha": "5a7d0385364f5bf5b4afa660272a91c56c46957f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a7d0385364f5bf5b4afa660272a91c56c46957f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ffa4e6a767d844fc035f28084ca88ba280043b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffa4e6a767d844fc035f28084ca88ba280043b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffa4e6a767d844fc035f28084ca88ba280043b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffa4e6a767d844fc035f28084ca88ba280043b6/comments", "author": null, "committer": null, "parents": [{"sha": "74d98c1e9beaa02e00241d846d9053843acadbe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d98c1e9beaa02e00241d846d9053843acadbe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d98c1e9beaa02e00241d846d9053843acadbe1"}], "stats": {"total": 74, "additions": 60, "deletions": 14}, "files": [{"sha": "c0f0638cc9cdf79aa9fd287425422e3e33664bd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffa4e6a767d844fc035f28084ca88ba280043b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffa4e6a767d844fc035f28084ca88ba280043b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ffa4e6a767d844fc035f28084ca88ba280043b6", "patch": "@@ -1,3 +1,14 @@\n+2014-10-14  Felix Yang  <felix.yang@huawei.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* ira.c (struct equivalence): Change member \"is_arg_equivalence\" and\n+\t\"replace\" into boolean bitfields; turn member \"loop_depth\" into a short\n+\tinteger; add new member \"no_equiv\" and \"reserved\".\n+\t(no_equiv): Set no_equiv of struct equivalence if register is marked\n+\tas having no known equivalence.\n+\t(update_equiv_regs): Check all definitions for a multiple-set\n+\tregister to make sure that the RHS have the same value.\n+\n 2014-10-13  Richard Henderson  <rth@redhat.com>\n \n \t* combine-stack-adj.c (no_unhandled_cfa): New."}, {"sha": "ebd2c216ce8ab5ff82794ce22050033dcf3c5066", "filename": "gcc/ira.c", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffa4e6a767d844fc035f28084ca88ba280043b6/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffa4e6a767d844fc035f28084ca88ba280043b6/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=5ffa4e6a767d844fc035f28084ca88ba280043b6", "patch": "@@ -2902,12 +2902,14 @@ struct equivalence\n \n   /* Loop depth is used to recognize equivalences which appear\n      to be present within the same loop (or in an inner loop).  */\n-  int loop_depth;\n+  short loop_depth;\n   /* Nonzero if this had a preexisting REG_EQUIV note.  */\n-  int is_arg_equivalence;\n+  unsigned char is_arg_equivalence : 1;\n   /* Set when an attempt should be made to replace a register\n      with the associated src_p entry.  */\n-  char replace;\n+  unsigned char replace : 1;\n+  /* Set if this register has no known equivalence.  */\n+  unsigned char no_equiv : 1;\n };\n \n /* reg_equiv[N] (where N is a pseudo reg number) is the equivalence\n@@ -3255,6 +3257,7 @@ no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED,\n   if (!REG_P (reg))\n     return;\n   regno = REGNO (reg);\n+  reg_equiv[regno].no_equiv = 1;\n   list = reg_equiv[regno].init_insns;\n   if (list && list->insn () == NULL)\n     return;\n@@ -3381,7 +3384,7 @@ update_equiv_regs (void)\n \n \t  /* If this insn contains more (or less) than a single SET,\n \t     only mark all destinations as having no known equivalence.  */\n-\t  if (set == 0)\n+\t  if (set == NULL_RTX)\n \t    {\n \t      note_stores (PATTERN (insn), no_equiv, NULL);\n \t      continue;\n@@ -3476,16 +3479,49 @@ update_equiv_regs (void)\n \t  if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n \t    note = NULL_RTX;\n \n-\t  if (DF_REG_DEF_COUNT (regno) != 1\n-\t      && (! note\n+\t  if (DF_REG_DEF_COUNT (regno) != 1)\n+\t    {\n+\t      bool equal_p = true;\n+\t      rtx_insn_list *list;\n+\n+\t      /* If we have already processed this pseudo and determined it\n+\t\t can not have an equivalence, then honor that decision.  */\n+\t      if (reg_equiv[regno].no_equiv)\n+\t\tcontinue;\n+\n+\t      if (! note\n \t\t  || rtx_varies_p (XEXP (note, 0), 0)\n \t\t  || (reg_equiv[regno].replacement\n \t\t      && ! rtx_equal_p (XEXP (note, 0),\n-\t\t\t\t\treg_equiv[regno].replacement))))\n-\t    {\n-\t      no_equiv (dest, set, NULL);\n-\t      continue;\n+\t\t\t\t\treg_equiv[regno].replacement)))\n+\t\t{\n+\t\t  no_equiv (dest, set, NULL);\n+\t\t  continue;\n+\t\t}\n+\n+\t      list = reg_equiv[regno].init_insns;\n+\t      for (; list; list = list->next ())\n+\t\t{\n+\t\t  rtx note_tmp;\n+\t\t  rtx_insn *insn_tmp;\n+\n+\t\t  insn_tmp = list->insn ();\n+\t\t  note_tmp = find_reg_note (insn_tmp, REG_EQUAL, NULL_RTX);\n+\t\t  gcc_assert (note_tmp);\n+\t\t  if (! rtx_equal_p (XEXP (note, 0), XEXP (note_tmp, 0)))\n+\t\t    {\n+\t\t      equal_p = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (! equal_p)\n+\t\t{\n+\t\t  no_equiv (dest, set, NULL);\n+\t\t  continue;\n+\t\t}\n \t    }\n+\n \t  /* Record this insn as initializing this register.  */\n \t  reg_equiv[regno].init_insns\n \t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n@@ -3514,10 +3550,9 @@ update_equiv_regs (void)\n \t     a register used only in one basic block from a MEM.  If so, and the\n \t     MEM remains unchanged for the life of the register, add a REG_EQUIV\n \t     note.  */\n-\n \t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \n-\t  if (note == 0 && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n+\t  if (note == NULL_RTX && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n \t      && MEM_P (SET_SRC (set))\n \t      && validate_equiv_mem (insn, dest, SET_SRC (set)))\n \t    note = set_unique_reg_note (insn, REG_EQUIV, copy_rtx (SET_SRC (set)));\n@@ -3547,7 +3582,7 @@ update_equiv_regs (void)\n \n \t      reg_equiv[regno].replacement = x;\n \t      reg_equiv[regno].src_p = &SET_SRC (set);\n-\t      reg_equiv[regno].loop_depth = loop_depth;\n+\t      reg_equiv[regno].loop_depth = (short) loop_depth;\n \n \t      /* Don't mess with things live during setjmp.  */\n \t      if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n@@ -3677,7 +3712,7 @@ update_equiv_regs (void)\n \t\t  rtx equiv_insn;\n \n \t\t  if (! reg_equiv[regno].replace\n-\t\t      || reg_equiv[regno].loop_depth < loop_depth\n+\t\t      || reg_equiv[regno].loop_depth < (short) loop_depth\n \t\t      /* There is no sense to move insns if live range\n \t\t\t shrinkage or register pressure-sensitive\n \t\t\t scheduling were done because it will not"}]}