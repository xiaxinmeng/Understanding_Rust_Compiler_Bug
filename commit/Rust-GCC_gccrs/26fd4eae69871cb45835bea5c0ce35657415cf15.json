{"sha": "26fd4eae69871cb45835bea5c0ce35657415cf15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZmZDRlYWU2OTg3MWNiNDU4MzViZWE1YzBjZTM1NjU3NDE1Y2YxNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-01-26T14:47:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-01-26T14:47:48Z"}, "message": "[multiple changes]\n\n2004-01-26  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch3.adb (Build_Slice_Assignment): New TSS procedure for\n\tone-dimensional array an slice assignments, when component type is\n\tcontrolled.\n\n\t* exp_ch5.adb (Expand_Assign_Array): If array is one-dimensional,\n\tcomponent type is controlled, and control_actions are in effect, use\n\tTSS procedure rather than generating inline code.\n\n\t* exp_tss.ads (TSS_Slice_Assign): New TSS procedure for one-dimensional\n\tarrays with controlled components.\n\n2004-01-26  Vincent Celier  <celier@gnat.com>\n\n\t* gnatcmd.adb (GNATCmd): Add specification of argument file on the\n\tcommand line for the non VMS case.\n\n\t* gnatlink.adb (Process_Binder_File): When building object file, if\n\tGNU linker is used, put all object paths between quotes, to prevent ld\n\terror when there are unusual characters (such as '!') in the paths.\n\n\t* Makefile.generic: When there are sources in Ada and the main is in\n\tC/C++, invoke gnatmake with -B, instead of -z.\n\n\t* vms_conv.adb (Preprocess_Command_Data): New procedure, extracted\n\tfrom VMS_Conversion.\n\t(Process_Argument): New procedure, extracted from VMS_Conversion. Add\n\tspecification of argument file on the command line.\n\n2004-01-26  Bernard Banner  <banner@gnat.com>\n\n\t* Makefile.in: Enable GMEM_LIB and SYMLIB for x86_64\n\n2004-01-26  Ed Schonberg  <schonberg@gnat.com>\n\n\t* snames.adb: Update copyright notice.\n\tAdd info on slice assignment for controlled arrays.\n\nFrom-SVN: r76634", "tree": {"sha": "966853aeb51ebcb01d4672b5d9fcb8065248a86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/966853aeb51ebcb01d4672b5d9fcb8065248a86d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26fd4eae69871cb45835bea5c0ce35657415cf15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fd4eae69871cb45835bea5c0ce35657415cf15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26fd4eae69871cb45835bea5c0ce35657415cf15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fd4eae69871cb45835bea5c0ce35657415cf15/comments", "author": null, "committer": null, "parents": [{"sha": "ecf67f46ef7dd6b67bebb0ea96f6cd3cade10e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf67f46ef7dd6b67bebb0ea96f6cd3cade10e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecf67f46ef7dd6b67bebb0ea96f6cd3cade10e33"}], "stats": {"total": 2165, "additions": 1382, "deletions": 783}, "files": [{"sha": "3e2838d81bef5cfb26c672eda0b4946268ebde19", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -1,3 +1,42 @@\n+2004-01-26  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_ch3.adb (Build_Slice_Assignment): New TSS procedure for\n+\tone-dimensional array an slice assignments, when component type is\n+\tcontrolled.\n+\n+\t* exp_ch5.adb (Expand_Assign_Array): If array is one-dimensional,\n+\tcomponent type is controlled, and control_actions are in effect, use\n+\tTSS procedure rather than generating inline code.\n+\n+\t* exp_tss.ads (TSS_Slice_Assign): New TSS procedure for one-dimensional\n+\tarrays with controlled components.\n+\n+2004-01-26  Vincent Celier  <celier@gnat.com>\n+\n+\t* gnatcmd.adb (GNATCmd): Add specification of argument file on the\n+\tcommand line for the non VMS case.\n+\n+\t* gnatlink.adb (Process_Binder_File): When building object file, if\n+\tGNU linker is used, put all object paths between quotes, to prevent ld\n+\terror when there are unusual characters (such as '!') in the paths.\n+\n+\t* Makefile.generic: When there are sources in Ada and the main is in\n+\tC/C++, invoke gnatmake with -B, instead of -z.\n+\n+\t* vms_conv.adb (Preprocess_Command_Data): New procedure, extracted\n+\tfrom VMS_Conversion.\n+\t(Process_Argument): New procedure, extracted from VMS_Conversion. Add\n+\tspecification of argument file on the command line.\n+\n+2004-01-26  Bernard Banner  <banner@gnat.com>\n+\n+\t* Makefile.in: Enable GMEM_LIB and SYMLIB for x86_64\n+\n+2004-01-26  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* snames.adb: Update copyright notice.\n+\tAdd info on slice assignment for controlled arrays.\n+\n 2004-01-23  Robert Dewar  <dewar@gnat.com>\n \n \t* exp_aggr.adb: Minor reformatting"}, {"sha": "6be62317c07682882aea01aa477547e1360d2938", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -337,21 +337,16 @@ internal-build: $(LINKER) archive-objects force\n \n else\n # C/C++ main\n-# The trick here is to force gnatmake to bind/link, even if there is no\n-# Ada main program. To achieve this effect, we use the -z switch, which is\n-# close enough to our needs, and the usual -n gnatbind switch and --LINK=\n-# gnatlink switch.\n \n link: $(LINKER) archive-objects force\n-\t$(GNATMAKE) $(EXEC_RULE) -z -P$(PROJECT_FILE) $(ADA_SOURCES) \\\n-\t\t -bargs -n -largs $(LARGS) $(LDFLAGS)\n+\t$(GNATMAKE) $(EXEC_RULE) -B -P$(PROJECT_FILE) $(ADA_SOURCES) \\\n+\t\t -largs $(MAIN_OBJECT) $(LARGS) $(LDFLAGS)\n \n internal-build: $(LINKER) archive-objects force\n-\t@echo $(GNATMAKE) -z -P$(PROJECT_FILE) $(ADA_SOURCES) $(EXEC_RULE) $(ADAFLAGS)\n-\t@$(GNATMAKE) $(EXEC_RULE) -z \\\n-\t\t -P$(PROJECT_FILE) $(ADA_SOURCES) $(ADAFLAGS) \\\n-\t\t -bargs -n \\\n-\t\t -largs $(LARGS) $(LDFLAGS)\n+\t@echo $(GNATMAKE) -B -P$(PROJECT_FILE) $(ADA_SOURCES) $(EXEC_RULE) $(ADAFLAGS)\n+\t@$(GNATMAKE) $(EXEC_RULE) \\\n+\t\t -B -P$(PROJECT_FILE) $(ADA_SOURCES) $(ADAFLAGS) \\\n+\t\t -largs $(MAIN_OBJECT) $(LARGS) $(LDFLAGS)\n endif\n \n else"}, {"sha": "f9abc3ad12658a15716f8668c07f0e5069feec14", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -1287,11 +1287,13 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   system.ads<5nsystem.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5lml-tgt.adb\n-  MISCLIB=\n+  SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n   PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n   LIBRARY_VERSION := $(LIB_VERSION)\n+\n endif\n \n # The runtime library for gnat comprises two directories.  One contains the"}, {"sha": "111e14b3508b5ca8c0d94288bfba8147bdd81821", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -114,6 +114,12 @@ package body Exp_Ch3 is\n    --  Build record initialization procedure. N is the type declaration\n    --  node, and Pe is the corresponding entity for the record type.\n \n+   procedure Build_Slice_Assignment (Typ : Entity_Id);\n+   --  Build assignment procedure for one-dimensional arrays of controlled\n+   --  types. Other array and slice assignments are expanded in-line, but\n+   --  the code expansion for controlled components (when control actions\n+   --  are active) can lead to very large blocks that GCC3 handles poorly.\n+\n    procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n    --  Create An Equality function for the non-tagged variant record 'Typ'\n    --  and attach it to the TSS list\n@@ -2474,6 +2480,287 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Record_Init_Proc;\n \n+   ----------------------------\n+   -- Build_Slice_Assignment --\n+   ----------------------------\n+\n+   --  Generates the following subprogram:\n+   --    procedure Assign\n+   --     (Source,   Target   : Array_Type,\n+   --      Left_Lo,  Left_Hi, Right_Lo, Right_Hi : Index;\n+   --      Rev :     Boolean)\n+   --    is\n+   --       Li1 : Index;\n+   --       Ri1 : Index;\n+   --    begin\n+   --       if Rev  then\n+   --          Li1 := Left_Hi;\n+   --          Ri1 := Right_Hi;\n+   --       else\n+   --          Li1 := Left_Lo;\n+   --          Ri1 := Right_Lo;\n+   --       end if;\n+   --\n+   --       loop\n+   --             Target (Li1) := Source (Ri1);\n+   --             if Rev then\n+   --                exit when Li2 = Left_Lo;\n+   --                Li2 := Index'pred (Li2);\n+   --                Ri2 := Index'pred (Ri2);\n+   --             else\n+   --                exit when Li2 = Left_Hi;\n+   --                Li2 := Index'succ (Li2);\n+   --                Ri2 := Index'succ (Ri2);\n+   --             end if;\n+   --       end loop;\n+   --    end Assign;\n+\n+   procedure Build_Slice_Assignment (Typ : Entity_Id) is\n+      Loc   : constant Source_Ptr := Sloc (Typ);\n+      Index : constant Entity_Id  := Base_Type (Etype (First_Index (Typ)));\n+\n+      --  Build formal parameters of procedure\n+\n+      Larray   : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('A'));\n+      Rarray   : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('R'));\n+      Left_Lo  : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('L'));\n+      Left_Hi  : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('L'));\n+      Right_Lo : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('R'));\n+      Right_Hi : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('R'));\n+      Rev      : constant Entity_Id :=\n+                   Make_Defining_Identifier\n+                     (Loc, Chars => New_Internal_Name ('D'));\n+      Proc_Name : constant Entity_Id :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => Make_TSS_Name (Typ, TSS_Slice_Assign));\n+\n+      Lnn :  constant Entity_Id :=\n+               Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n+      Rnn :  constant Entity_Id :=\n+               Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+      --  subscripts for left and right sides\n+\n+      Decls  : List_Id;\n+      Loops  : Node_Id;\n+      Stats  : List_Id;\n+\n+   begin\n+\n+      --  Build declarations for indices.\n+\n+      Decls := New_List;\n+\n+      Append_To (Decls,\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Lnn,\n+           Object_Definition  =>\n+             New_Occurrence_Of (Index, Loc)));\n+\n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Rnn,\n+          Object_Definition  =>\n+            New_Occurrence_Of (Index, Loc)));\n+\n+      Stats := New_List;\n+\n+      --  Build initializations for indices.\n+\n+      declare\n+         F_Init : constant List_Id := New_List;\n+         B_Init : constant List_Id := New_List;\n+\n+      begin\n+         Append_To (F_Init,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Lnn, Loc),\n+             Expression => New_Occurrence_Of (Left_Lo, Loc)));\n+\n+         Append_To (F_Init,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Rnn, Loc),\n+             Expression => New_Occurrence_Of (Right_Lo, Loc)));\n+\n+         Append_To (B_Init,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Lnn, Loc),\n+             Expression => New_Occurrence_Of (Left_Hi, Loc)));\n+\n+         Append_To (B_Init,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Rnn, Loc),\n+             Expression => New_Occurrence_Of (Right_Hi, Loc)));\n+\n+         Append_To (Stats,\n+           Make_If_Statement (Loc,\n+             Condition => New_Occurrence_Of (Rev, Loc),\n+             Then_Statements => B_Init,\n+             Else_Statements => F_Init));\n+      end;\n+\n+      --  Now construct the assignment statement\n+\n+      Loops :=\n+        Make_Loop_Statement (Loc,\n+          Statements => New_List (\n+            Make_Assignment_Statement (Loc,\n+              Name =>\n+                Make_Indexed_Component (Loc,\n+                  Prefix => New_Occurrence_Of (Larray, Loc),\n+                  Expressions => New_List (New_Occurrence_Of (Lnn, Loc))),\n+              Expression =>\n+                Make_Indexed_Component (Loc,\n+                  Prefix => New_Occurrence_Of (Rarray, Loc),\n+                  Expressions => New_List (New_Occurrence_Of (Rnn, Loc))))),\n+          End_Label  => Empty);\n+\n+      --  Build the increment/decrement statements.\n+\n+      declare\n+         F_Ass : constant List_Id := New_List;\n+         B_Ass : constant List_Id := New_List;\n+\n+      begin\n+         Append_To (F_Ass,\n+           Make_Exit_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n+                 Right_Opnd => New_Occurrence_Of (Left_Hi, Loc))));\n+\n+         Append_To (B_Ass,\n+           Make_Exit_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n+                 Right_Opnd => New_Occurrence_Of (Left_Lo, Loc))));\n+\n+         Append_To (F_Ass,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Lnn, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Occurrence_Of (Index, Loc),\n+                 Attribute_Name => Name_Succ,\n+                 Expressions => New_List (\n+                   New_Occurrence_Of (Lnn, Loc)))));\n+\n+         Append_To (F_Ass,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Rnn, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Occurrence_Of (Index, Loc),\n+                 Attribute_Name => Name_Succ,\n+                 Expressions => New_List (\n+                   New_Occurrence_Of (Rnn, Loc)))));\n+\n+         Append_To (B_Ass,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Lnn, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Occurrence_Of (Index, Loc),\n+                 Attribute_Name => Name_Pred,\n+                   Expressions => New_List (\n+                     New_Occurrence_Of (Lnn, Loc)))));\n+\n+         Append_To (B_Ass,\n+           Make_Assignment_Statement (Loc,\n+             Name => New_Occurrence_Of (Rnn, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Occurrence_Of (Index, Loc),\n+                 Attribute_Name => Name_Pred,\n+                 Expressions => New_List (\n+                   New_Occurrence_Of (Rnn, Loc)))));\n+\n+         Append_To (Statements (Loops),\n+           Make_If_Statement (Loc,\n+             Condition => New_Occurrence_Of (Rev, Loc),\n+             Then_Statements => B_Ass,\n+             Else_Statements => F_Ass));\n+      end;\n+\n+      Append_To (Stats, Loops);\n+\n+      declare\n+         Spec      : Node_Id;\n+         Formals   : List_Id := New_List;\n+\n+      begin\n+         Formals := New_List (\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Larray,\n+             Out_Present => True,\n+             Parameter_Type =>\n+               New_Reference_To (Base_Type (Typ), Loc)),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Rarray,\n+             Parameter_Type =>\n+               New_Reference_To (Base_Type (Typ), Loc)),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Left_Lo,\n+             Parameter_Type =>\n+               New_Reference_To (Index, Loc)),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Left_Hi,\n+             Parameter_Type =>\n+               New_Reference_To (Index, Loc)),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Right_Lo,\n+             Parameter_Type =>\n+               New_Reference_To (Index, Loc)),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Right_Hi,\n+             Parameter_Type =>\n+               New_Reference_To (Index, Loc)));\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Rev,\n+             Parameter_Type =>\n+               New_Reference_To (Standard_Boolean, Loc)));\n+\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => Proc_Name,\n+             Parameter_Specifications => Formals);\n+\n+         Discard_Node (\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Decls,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stats)));\n+      end;\n+\n+      Set_TSS (Typ, Proc_Name);\n+      Set_Is_Pure (Proc_Name);\n+   end Build_Slice_Assignment;\n+\n    ------------------------------------\n    -- Build_Variant_Record_Equality --\n    ------------------------------------\n@@ -3483,6 +3770,12 @@ package body Exp_Ch3 is\n \n          if Typ = Base and then Has_Controlled_Component (Base) then\n             Build_Controlling_Procs (Base);\n+\n+            if not Is_Limited_Type (Component_Type (Typ))\n+              and then Number_Dimensions (Typ) = 1\n+            then\n+               Build_Slice_Assignment (Typ);\n+            end if;\n          end if;\n \n       --  For packed case, there is a default initialization, except"}, {"sha": "ac0a7f77a612bf35970e077424b18704600068c1", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 106, "deletions": 16, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@ with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Pakd; use Exp_Pakd;\n+with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n@@ -160,6 +161,10 @@ package body Exp_Ch5 is\n       --  This switch is set to True if the array move must be done using\n       --  an explicit front end generated loop.\n \n+      procedure Apply_Dereference (Arg : in out Node_Id);\n+      --  If the argument is an access to an array, and the assignment is\n+      --  converted into a procedure call, apply explicit dereference.\n+\n       function Has_Address_Clause (Exp : Node_Id) return Boolean;\n       --  Test if Exp is a reference to an array whose declaration has\n       --  an address clause, or it is a slice of such an array.\n@@ -185,6 +190,20 @@ package body Exp_Ch5 is\n       --  generate a front end loop, which is not so terrible.\n       --  It would really be better if backend handled this ???\n \n+      -----------------------\n+      -- Apply_Dereference --\n+      -----------------------\n+\n+      procedure Apply_Dereference (Arg : in out Node_Id) is\n+         Typ : constant Entity_Id := Etype (Arg);\n+      begin\n+         if Is_Access_Type (Typ) then\n+            Rewrite (Arg, Make_Explicit_Dereference (Loc,\n+              Prefix => Relocate_Node (Arg)));\n+            Analyze_And_Resolve (Arg, Designated_Type (Typ));\n+         end if;\n+      end Apply_Dereference;\n+\n       ------------------------\n       -- Has_Address_Clause --\n       ------------------------\n@@ -704,10 +723,47 @@ package body Exp_Ch5 is\n          --  Cases where either Forwards_OK or Backwards_OK is true\n \n          if Forwards_OK (N) or else Backwards_OK (N) then\n-            Rewrite (N,\n-              Expand_Assign_Array_Loop\n-                (N, Larray, Rarray, L_Type, R_Type, Ndim,\n-                 Rev => not Forwards_OK (N)));\n+            if Controlled_Type (Component_Type (L_Type))\n+              and then Base_Type (L_Type) = Base_Type (R_Type)\n+              and then Ndim = 1\n+              and then not No_Ctrl_Actions (N)\n+            then\n+               declare\n+                  Proc : constant Entity_Id :=\n+                           TSS (Base_Type (L_Type), TSS_Slice_Assign);\n+                  Actuals : List_Id;\n+\n+               begin\n+                  Apply_Dereference (Larray);\n+                  Apply_Dereference (Rarray);\n+                  Actuals := New_List (\n+                    Duplicate_Subexpr (Larray,   Name_Req => True),\n+                    Duplicate_Subexpr (Rarray,   Name_Req => True),\n+                    Duplicate_Subexpr (Left_Lo,  Name_Req => True),\n+                    Duplicate_Subexpr (Left_Hi,  Name_Req => True),\n+                    Duplicate_Subexpr (Right_Lo, Name_Req => True),\n+                    Duplicate_Subexpr (Right_Hi, Name_Req => True));\n+\n+                  if Forwards_OK (N) then\n+                     Append_To (Actuals,\n+                       New_Occurrence_Of (Standard_False, Loc));\n+                  else\n+                     Append_To (Actuals,\n+                       New_Occurrence_Of (Standard_True, Loc));\n+                  end if;\n+\n+                  Rewrite (N,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name => New_Reference_To (Proc, Loc),\n+                      Parameter_Associations => Actuals));\n+               end;\n+\n+            else\n+               Rewrite (N,\n+                 Expand_Assign_Array_Loop\n+                   (N, Larray, Rarray, L_Type, R_Type, Ndim,\n+                    Rev => not Forwards_OK (N)));\n+            end if;\n \n          --  Case of both are false with No_Implicit_Conditionals\n \n@@ -806,19 +862,53 @@ package body Exp_Ch5 is\n                    Right_Opnd => Cright_Lo);\n             end if;\n \n-            Rewrite (N,\n-              Make_Implicit_If_Statement (N,\n-                Condition => Condition,\n+            if Controlled_Type (Component_Type (L_Type))\n+              and then Base_Type (L_Type) = Base_Type (R_Type)\n+              and then Ndim = 1\n+              and then not No_Ctrl_Actions (N)\n+            then\n \n-                Then_Statements => New_List (\n-                  Expand_Assign_Array_Loop\n-                   (N, Larray, Rarray, L_Type, R_Type, Ndim,\n-                    Rev => False)),\n+               --  Call TSS procedure for array assignment, passing the\n+               --  the explicit bounds of right- and left-hand side.\n \n-                Else_Statements => New_List (\n-                  Expand_Assign_Array_Loop\n-                   (N, Larray, Rarray, L_Type, R_Type, Ndim,\n-                    Rev => True))));\n+               declare\n+                  Proc     : constant Node_Id :=\n+                               TSS (Base_Type (L_Type), TSS_Slice_Assign);\n+                  Actuals : List_Id;\n+\n+               begin\n+                  Apply_Dereference (Larray);\n+                  Apply_Dereference (Rarray);\n+                  Actuals := New_List (\n+                    Duplicate_Subexpr (Larray,   Name_Req => True),\n+                    Duplicate_Subexpr (Rarray,   Name_Req => True),\n+                    Duplicate_Subexpr (Left_Lo,  Name_Req => True),\n+                    Duplicate_Subexpr (Left_Hi,  Name_Req => True),\n+                    Duplicate_Subexpr (Right_Lo, Name_Req => True),\n+                    Duplicate_Subexpr (Right_Hi, Name_Req => True));\n+                  Append_To (Actuals, Condition);\n+\n+                  Rewrite (N,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name => New_Reference_To (Proc, Loc),\n+                      Parameter_Associations => Actuals));\n+               end;\n+\n+            else\n+               Rewrite (N,\n+                 Make_Implicit_If_Statement (N,\n+                   Condition => Condition,\n+\n+                   Then_Statements => New_List (\n+                     Expand_Assign_Array_Loop\n+                      (N, Larray, Rarray, L_Type, R_Type, Ndim,\n+                       Rev => False)),\n+\n+                   Else_Statements => New_List (\n+                     Expand_Assign_Array_Loop\n+                      (N, Larray, Rarray, L_Type, R_Type, Ndim,\n+                       Rev => True))));\n+            end if;\n          end if;\n \n          Analyze (N, Suppress => All_Checks);"}, {"sha": "a85fff07d3737d90f7c3469436f9372cc6707049", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,6 +81,7 @@ package Exp_Tss is\n    TSS_RAS_Access         : constant TNT := \"RA\";  -- RAs type access\n    TSS_RAS_Dereference    : constant TNT := \"RD\";  -- RAs type deference\n    TSS_Rep_To_Pos         : constant TNT := \"RP\";  -- Rep to Pos conversion\n+   TSS_Slice_Assign       : constant TNT := \"SA\";  -- Slice assignment\n    TSS_Stream_Input       : constant TNT := \"SI\";  -- Stream Input attribute\n    TSS_Stream_Output      : constant TNT := \"SO\";  -- Stream Output attribute\n    TSS_Stream_Read        : constant TNT := \"SR\";  -- Stream Read attribute\n@@ -95,6 +96,7 @@ package Exp_Tss is\n       TSS_RAS_Access,\n       TSS_RAS_Dereference,\n       TSS_Rep_To_Pos,\n+      TSS_Slice_Assign,\n       TSS_Stream_Input,\n       TSS_Stream_Output,\n       TSS_Stream_Read,"}, {"sha": "1e04140f10a2f0d84a6aedf372493415dd31842f", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -493,10 +493,66 @@ begin\n                end;\n          end;\n \n+         --  Get the arguments from the command line and from the eventual\n+         --  argument file(s) specified on the command line.\n+\n          for Arg in Command_Arg + 1 .. Argument_Count loop\n-            Last_Switches.Increment_Last;\n-            Last_Switches.Table (Last_Switches.Last) :=\n-              new String'(Argument (Arg));\n+            declare\n+               The_Arg : constant String := Argument (Arg);\n+            begin\n+               --  Check if an argument file is specified\n+\n+               if The_Arg (The_Arg'First) = '@' then\n+                  declare\n+                     Arg_File : Ada.Text_IO.File_Type;\n+                     Line     : String (1 .. 256);\n+                     Last     : Natural;\n+\n+                  begin\n+                     --  Open the file. Fail if the file cannot be found.\n+\n+                     begin\n+                        Open\n+                          (Arg_File, In_File,\n+                           The_Arg (The_Arg'First + 1 .. The_Arg'Last));\n+\n+                     exception\n+                        when others =>\n+                           Put\n+                             (Standard_Error, \"Cannot open argument file \"\"\");\n+                           Put\n+                             (Standard_Error,\n+                              The_Arg (The_Arg'First + 1 .. The_Arg'Last));\n+\n+                           Put_Line (Standard_Error, \"\"\"\");\n+                           raise Error_Exit;\n+                     end;\n+\n+                     --  Read line by line and put the content of each\n+                     --  non empty line in the Last_Switches table.\n+\n+                     while not End_Of_File (Arg_File) loop\n+                        Get_Line (Arg_File, Line, Last);\n+\n+                        if Last /= 0 then\n+                           Last_Switches.Increment_Last;\n+                           Last_Switches.Table (Last_Switches.Last) :=\n+                             new String'(Line (1 .. Last));\n+                        end if;\n+                     end loop;\n+\n+                     Close (Arg_File);\n+                  end;\n+\n+               else\n+                  --  It is not an argument file; just put the argument in\n+                  --  the Last_Switches table.\n+\n+                  Last_Switches.Increment_Last;\n+                  Last_Switches.Table (Last_Switches.Last) :=\n+                    new String'(The_Arg);\n+               end if;\n+            end;\n          end loop;\n       end if;\n    end if;"}, {"sha": "afd325876d305f96efa387e49fe492a11bd8f997", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -673,6 +673,11 @@ procedure Gnatlink is\n       --  Predicate indicating whether this target uses the GNU linker. In\n       --  this case we must output a GNU linker compatible response file.\n \n+      Opening : aliased constant String := \"\"\"\";\n+      Closing : aliased constant String := '\"' & ASCII.LF;\n+      --  Needed to quote object paths in object list files when GNU linker\n+      --  is used.\n+\n       procedure Get_Next_Line;\n       --  Read the next line from the binder file without the line\n       --  terminator.\n@@ -883,6 +888,8 @@ procedure Gnatlink is\n          --  If target is using the GNU linker we must add a special header\n          --  and footer in the response file.\n          --  The syntax is : INPUT (object1.o object2.o ... )\n+         --  Because the GNU linker does not like name with characters such\n+         --  as '!', we must put the object paths between double quotes.\n \n          if Using_GNU_Linker then\n             declare\n@@ -895,9 +902,22 @@ procedure Gnatlink is\n          end if;\n \n          for J in Objs_Begin .. Objs_End loop\n+            --  Opening quote for GNU linker\n+            if Using_GNU_Linker then\n+               Status := Write (Tname_FD, Opening'Address, 1);\n+            end if;\n+\n             Status := Write (Tname_FD, Linker_Objects.Table (J).all'Address,\n-              Linker_Objects.Table (J).all'Length);\n-            Status := Write (Tname_FD, ASCII.LF'Address, 1);\n+                             Linker_Objects.Table (J).all'Length);\n+\n+            --  Closing quote for GNU linker\n+\n+            if Using_GNU_Linker then\n+               Status := Write (Tname_FD, Closing'Address, 2);\n+\n+            else\n+               Status := Write (Tname_FD, ASCII.LF'Address, 1);\n+            end if;\n \n             Response_File_Objects.Increment_Last;\n             Response_File_Objects.Table (Response_File_Objects.Last) :="}, {"sha": "a922c9d9a0426b007d22cbaf2e09b783ea0e6e99", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -690,6 +690,7 @@ package body Snames is\n    --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\n    --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\n    --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\n+   --    xxxSA   array/slice assignment for controlled comp. arrays (Exp_TSS)\n    --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\n    --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\n    --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)"}, {"sha": "c632e7327891318ec67d25bbbc4354737a911678", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 848, "deletions": 747, "changes": 1595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fd4eae69871cb45835bea5c0ce35657415cf15/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=26fd4eae69871cb45835bea5c0ce35657415cf15", "patch": "@@ -40,6 +40,9 @@ package body VMS_Conv is\n    Arg_Num : Natural;\n    --  Argument number\n \n+   Arg_File : Ada.Text_IO.File_Type;\n+   --  A file where arguments are read from\n+\n    Commands : Item_Ptr;\n    --  Pointer to head of list of command items, one for each command, with\n    --  the end of the list marked by a null pointer.\n@@ -119,6 +122,14 @@ package body VMS_Conv is\n    --  updating Ptr appropriatelly. Note that in the case of use of ! the\n    --  result may be to remove a previously placed switch.\n \n+   procedure Preprocess_Command_Data;\n+   --  Preprocess the string form of the command and options list into the\n+   --  internal form.\n+\n+   procedure Process_Argument (The_Command : in out Command_Type);\n+   --  Process one argument from the command line, or one line from\n+   --  from a command line file. For the first call, set The_Command.\n+\n    procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr);\n    --  Check that N is a valid command or option name, i.e. that it is of the\n    --  form of an Ada identifier with upper case letters and underscores.\n@@ -736,61 +747,12 @@ package body VMS_Conv is\n       end loop;\n    end Place_Unix_Switches;\n \n-   --------------------------------\n-   -- Validate_Command_Or_Option --\n-   --------------------------------\n-\n-   procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr) is\n-   begin\n-      pragma Assert (N'Length > 0);\n-\n-      for J in N'Range loop\n-         if N (J) = '_' then\n-            pragma Assert (N (J - 1) /= '_');\n-            null;\n-         else\n-            pragma Assert (Is_Upper (N (J)) or else Is_Digit (N (J)));\n-            null;\n-         end if;\n-      end loop;\n-   end Validate_Command_Or_Option;\n-\n-   --------------------------\n-   -- Validate_Unix_Switch --\n-   --------------------------\n+   -----------------------------\n+   -- Preprocess_Command_Data --\n+   -----------------------------\n \n-   procedure Validate_Unix_Switch (S : VMS_Data.String_Ptr) is\n+   procedure Preprocess_Command_Data is\n    begin\n-      if S (S'First) = '`' then\n-         return;\n-      end if;\n-\n-      pragma Assert (S (S'First) = '-' or else S (S'First) = '!');\n-\n-      for J in S'First + 1 .. S'Last loop\n-         pragma Assert (S (J) /= ' ');\n-\n-         if S (J) = '!' then\n-            pragma Assert (S (J - 1) = ',' and then S (J + 1) = '-');\n-            null;\n-         end if;\n-      end loop;\n-   end Validate_Unix_Switch;\n-\n-   --------------------\n-   -- VMS_Conversion --\n-   --------------------\n-\n-   --  This function is *far* too long and *far* too heavily nested, it\n-   --  needs procedural abstraction ???\n-\n-   procedure VMS_Conversion (The_Command : out Command_Type) is\n-   begin\n-      Buffer.Init;\n-\n-      --  First we must preprocess the string form of the command and options\n-      --  list into the internal form that we use.\n-\n       for C in Real_Command_Type loop\n          declare\n             Command : constant Item_Ptr := new Command_Item;\n@@ -1016,288 +978,475 @@ package body VMS_Conv is\n             end loop;\n          end;\n       end loop;\n+   end Preprocess_Command_Data;\n \n-      --  If no parameters, give complete list of commands\n-\n-      if Argument_Count = 0 then\n-         Output_Version;\n-         New_Line;\n-         Put_Line (\"List of available commands\");\n-         New_Line;\n+   ----------------------\n+   -- Process_Argument --\n+   ----------------------\n \n-         while Commands /= null loop\n-            Put (Commands.Usage.all);\n-            Set_Col (53);\n-            Put_Line (Commands.Unix_String.all);\n-            Commands := Commands.Next;\n+   procedure Process_Argument (The_Command : in out Command_Type) is\n+      Argv    : String_Access;\n+      Arg_Idx : Integer;\n+\n+      function Get_Arg_End\n+        (Argv    : String;\n+         Arg_Idx : Integer) return Integer;\n+      --  Begins looking at Arg_Idx + 1 and returns the index of the\n+      --  last character before a slash or else the index of the last\n+      --  character in the string Argv.\n+\n+      -----------------\n+      -- Get_Arg_End --\n+      -----------------\n+\n+      function Get_Arg_End\n+        (Argv    : String;\n+         Arg_Idx : Integer) return Integer\n+      is\n+      begin\n+         for J in Arg_Idx + 1 .. Argv'Last loop\n+            if Argv (J) = '/' then\n+               return J - 1;\n+            end if;\n          end loop;\n \n-         raise Normal_Exit;\n-      end if;\n+         return Argv'Last;\n+      end Get_Arg_End;\n \n-      Arg_Num := 1;\n+      --  Start of processing for Process_Argument\n \n-      --  Loop through arguments\n+   begin\n+      --  If an argument file is open, read the next non empty line\n \n-      while Arg_Num <= Argument_Count loop\n+      if Is_Open (Arg_File) then\n+         declare\n+            Line : String (1 .. 256);\n+            Last : Natural;\n+         begin\n+            loop\n+               Get_Line (Arg_File, Line, Last);\n+               exit when Last /= 0 or else End_Of_File (Arg_File);\n+            end loop;\n \n-         Process_Argument : declare\n-            Argv    : String_Access;\n-            Arg_Idx : Integer;\n-\n-            function Get_Arg_End\n-              (Argv    : String;\n-               Arg_Idx : Integer) return Integer;\n-            --  Begins looking at Arg_Idx + 1 and returns the index of the\n-            --  last character before a slash or else the index of the last\n-            --  character in the string Argv.\n-\n-            -----------------\n-            -- Get_Arg_End --\n-            -----------------\n-\n-            function Get_Arg_End\n-              (Argv    : String;\n-               Arg_Idx : Integer) return Integer\n-            is\n-            begin\n-               for J in Arg_Idx + 1 .. Argv'Last loop\n-                  if Argv (J) = '/' then\n-                     return J - 1;\n-                  end if;\n-               end loop;\n+            --  If the end of the argument file has been reached, close it\n \n-               return Argv'Last;\n-            end Get_Arg_End;\n+            if End_Of_File (Arg_File) then\n+               Close (Arg_File);\n \n-         --  Start of processing for Process_Argument\n+               --  If the last line was empty, return after increasing Arg_Num\n+               --  to go to the next argument on the comment line.\n \n-         begin\n-            Argv := new String'(Argument (Arg_Num));\n-            Arg_Idx := Argv'First;\n+               if Last = 0 then\n+                  Arg_Num := Arg_Num + 1;\n+                  return;\n+               end if;\n+            end if;\n \n-            <<Tryagain_After_Coalesce>>\n-            loop\n-               declare\n-                  Next_Arg_Idx : Integer;\n-                  Arg          : String_Access;\n+            Argv := new String'(Line (1 .. Last));\n+            Arg_Idx := 1;\n \n-               begin\n-                  Next_Arg_Idx := Get_Arg_End (Argv.all, Arg_Idx);\n-                  Arg := new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n+            if Argv (1) = '@' then\n+               Put_Line (Standard_Error, \"argument file cannot contain @cmd\");\n+               raise Error_Exit;\n+            end if;\n+         end;\n \n-                  --  The first one must be a command name\n+      else\n+         --  No argument file is open, get the argument on the command line\n \n-                  if Arg_Num = 1 and then Arg_Idx = Argv'First then\n-                     Command := Matching_Name (Arg.all, Commands);\n+         Argv := new String'(Argument (Arg_Num));\n+         Arg_Idx := Argv'First;\n \n-                     if Command = null then\n-                        raise Error_Exit;\n-                     end if;\n+         --  Check if this is the specification of an argument file\n \n-                     The_Command := Command.Command;\n+         if Argv (Arg_Idx) = '@' then\n+            --  The first argument on the command line cannot be an argument\n+            --  file.\n \n-                     --  Give usage information if only command given\n+            if Arg_Num = 1 then\n+               Put_Line\n+                 (Standard_Error,\n+                  \"Cannot specify argument line before command\");\n+               raise Error_Exit;\n+            end if;\n \n-                     if Argument_Count = 1\n-                       and then Next_Arg_Idx = Argv'Last\n-                     then\n-                        Output_Version;\n-                        New_Line;\n-                        Put_Line\n-                          (\"List of available qualifiers and options\");\n-                        New_Line;\n+            --  Open the file, after conversion of the name to canonical form.\n+            --  Fail if file is not found.\n \n-                        Put (Command.Usage.all);\n-                        Set_Col (53);\n-                        Put_Line (Command.Unix_String.all);\n+            declare\n+               Canonical_File_Name : String_Access :=\n+                 To_Canonical_File_Spec (Argv (Arg_Idx + 1 .. Argv'Last));\n+            begin\n+               Open (Arg_File, In_File, Canonical_File_Name.all);\n+               Free (Canonical_File_Name);\n+               return;\n+\n+            exception\n+               when others =>\n+                  Put (Standard_Error, \"Cannot open argument file \"\"\");\n+                  Put (Standard_Error, Argv (Arg_Idx + 1 .. Argv'Last));\n+                  Put_Line (Standard_Error, \"\"\"\");\n+                  raise Error_Exit;\n+            end;\n+         end if;\n+      end if;\n \n-                        declare\n-                           Sw : Item_Ptr := Command.Switches;\n+      <<Tryagain_After_Coalesce>>\n+      loop\n+         declare\n+            Next_Arg_Idx : Integer;\n+            Arg          : String_Access;\n \n-                        begin\n-                           while Sw /= null loop\n-                              Put (\"   \");\n-                              Put (Sw.Name.all);\n+         begin\n+            Next_Arg_Idx := Get_Arg_End (Argv.all, Arg_Idx);\n+            Arg := new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n \n-                              case Sw.Translation is\n+            --  The first one must be a command name\n \n-                                 when T_Other =>\n-                                    Set_Col (53);\n-                                    Put_Line (Sw.Unix_String.all &\n-                                              \"/<other>\");\n+            if Arg_Num = 1 and then Arg_Idx = Argv'First then\n+               Command := Matching_Name (Arg.all, Commands);\n \n-                                 when T_Direct =>\n-                                    Set_Col (53);\n-                                    Put_Line (Sw.Unix_String.all);\n+               if Command = null then\n+                  raise Error_Exit;\n+               end if;\n \n-                                 when T_Directories =>\n-                                    Put (\"=(direc,direc,..direc)\");\n-                                    Set_Col (53);\n-                                    Put (Sw.Unix_String.all);\n-                                    Put (\" direc \");\n-                                    Put (Sw.Unix_String.all);\n-                                    Put_Line (\" direc ...\");\n+               The_Command := Command.Command;\n \n-                                 when T_Directory =>\n-                                    Put (\"=directory\");\n-                                    Set_Col (53);\n-                                    Put (Sw.Unix_String.all);\n+               --  Give usage information if only command given\n \n-                                    if Sw.Unix_String (Sw.Unix_String'Last)\n-                                    /= '='\n-                                    then\n-                                       Put (' ');\n-                                    end if;\n+               if Argument_Count = 1\n+                 and then Next_Arg_Idx = Argv'Last\n+               then\n+                  Output_Version;\n+                  New_Line;\n+                  Put_Line\n+                    (\"List of available qualifiers and options\");\n+                  New_Line;\n+\n+                  Put (Command.Usage.all);\n+                  Set_Col (53);\n+                  Put_Line (Command.Unix_String.all);\n+\n+                  declare\n+                     Sw : Item_Ptr := Command.Switches;\n+\n+                  begin\n+                     while Sw /= null loop\n+                        Put (\"   \");\n+                        Put (Sw.Name.all);\n+\n+                        case Sw.Translation is\n+\n+                           when T_Other =>\n+                              Set_Col (53);\n+                              Put_Line (Sw.Unix_String.all &\n+                                        \"/<other>\");\n+\n+                           when T_Direct =>\n+                              Set_Col (53);\n+                              Put_Line (Sw.Unix_String.all);\n+\n+                           when T_Directories =>\n+                              Put (\"=(direc,direc,..direc)\");\n+                              Set_Col (53);\n+                              Put (Sw.Unix_String.all);\n+                              Put (\" direc \");\n+                              Put (Sw.Unix_String.all);\n+                              Put_Line (\" direc ...\");\n+\n+                           when T_Directory =>\n+                              Put (\"=directory\");\n+                              Set_Col (53);\n+                              Put (Sw.Unix_String.all);\n+\n+                              if Sw.Unix_String (Sw.Unix_String'Last)\n+                              /= '='\n+                              then\n+                                 Put (' ');\n+                              end if;\n+\n+                              Put_Line (\"directory \");\n+\n+                           when T_File | T_No_Space_File =>\n+                              Put (\"=file\");\n+                              Set_Col (53);\n+                              Put (Sw.Unix_String.all);\n+\n+                              if Sw.Translation = T_File\n+                                and then Sw.Unix_String\n+                                  (Sw.Unix_String'Last) /= '='\n+                              then\n+                                 Put (' ');\n+                              end if;\n+\n+                              Put_Line (\"file \");\n+\n+                           when T_Numeric =>\n+                              Put (\"=nnn\");\n+                              Set_Col (53);\n+\n+                              if Sw.Unix_String\n+                                (Sw.Unix_String'First) = '`'\n+                              then\n+                                 Put (Sw.Unix_String\n+                                        (Sw.Unix_String'First + 1\n+                                         .. Sw.Unix_String'Last));\n+                              else\n+                                 Put (Sw.Unix_String.all);\n+                              end if;\n+\n+                              Put_Line (\"nnn\");\n+\n+                           when T_Alphanumplus =>\n+                              Put (\"=xyz\");\n+                              Set_Col (53);\n+\n+                              if Sw.Unix_String\n+                                (Sw.Unix_String'First) = '`'\n+                              then\n+                                 Put (Sw.Unix_String\n+                                        (Sw.Unix_String'First + 1\n+                                         .. Sw.Unix_String'Last));\n+                              else\n+                                 Put (Sw.Unix_String.all);\n+                              end if;\n+\n+                              Put_Line (\"xyz\");\n+\n+                           when T_String =>\n+                              Put (\"=\");\n+                              Put ('\"');\n+                              Put (\"<string>\");\n+                              Put ('\"');\n+                              Set_Col (53);\n+\n+                              Put (Sw.Unix_String.all);\n+\n+                              if Sw.Unix_String\n+                                (Sw.Unix_String'Last) /= '='\n+                              then\n+                                 Put (' ');\n+                              end if;\n+\n+                              Put (\"<string>\");\n+                              New_Line;\n+\n+                           when T_Commands =>\n+                              Put (\" (switches for \");\n+                              Put (Sw.Unix_String\n+                                     (Sw.Unix_String'First + 7\n+                                      .. Sw.Unix_String'Last));\n+                              Put (')');\n+                              Set_Col (53);\n+                              Put (Sw.Unix_String\n+                                     (Sw.Unix_String'First\n+                                      .. Sw.Unix_String'First + 5));\n+                              Put_Line (\" switches\");\n+\n+                           when T_Options =>\n+                              declare\n+                                 Opt : Item_Ptr := Sw.Options;\n \n-                                    Put_Line (\"directory \");\n+                              begin\n+                                 Put_Line (\"=(option,option..)\");\n \n-                                 when T_File | T_No_Space_File =>\n-                                    Put (\"=file\");\n-                                    Set_Col (53);\n-                                    Put (Sw.Unix_String.all);\n+                                 while Opt /= null loop\n+                                    Put (\"      \");\n+                                    Put (Opt.Name.all);\n \n-                                    if Sw.Translation = T_File\n-                                      and then Sw.Unix_String\n-                                                (Sw.Unix_String'Last) /= '='\n-                                    then\n-                                       Put (' ');\n+                                    if Opt = Sw.Options then\n+                                       Put (\" (D)\");\n                                     end if;\n \n-                                    Put_Line (\"file \");\n-\n-                                 when T_Numeric =>\n-                                    Put (\"=nnn\");\n                                     Set_Col (53);\n+                                    Put_Line (Opt.Unix_String.all);\n+                                    Opt := Opt.Next;\n+                                 end loop;\n+                              end;\n \n-                                    if Sw.Unix_String\n-                                         (Sw.Unix_String'First) = '`'\n-                                    then\n-                                       Put (Sw.Unix_String\n-                                              (Sw.Unix_String'First + 1\n-                                               .. Sw.Unix_String'Last));\n-                                    else\n-                                       Put (Sw.Unix_String.all);\n-                                    end if;\n+                        end case;\n \n-                                    Put_Line (\"nnn\");\n+                        Sw := Sw.Next;\n+                     end loop;\n+                  end;\n \n-                                 when T_Alphanumplus =>\n-                                    Put (\"=xyz\");\n-                                    Set_Col (53);\n+                  raise Normal_Exit;\n+               end if;\n \n-                                    if Sw.Unix_String\n-                                         (Sw.Unix_String'First) = '`'\n-                                    then\n-                                       Put (Sw.Unix_String\n-                                              (Sw.Unix_String'First + 1\n-                                               .. Sw.Unix_String'Last));\n-                                    else\n-                                       Put (Sw.Unix_String.all);\n-                                    end if;\n+               --  Special handling for internal debugging switch /?\n \n-                                    Put_Line (\"xyz\");\n+            elsif Arg.all = \"/?\" then\n+               Display_Command := True;\n \n-                                 when T_String =>\n-                                    Put (\"=\");\n-                                    Put ('\"');\n-                                    Put (\"<string>\");\n-                                    Put ('\"');\n-                                    Set_Col (53);\n+               --  Copy -switch unchanged\n \n-                                    Put (Sw.Unix_String.all);\n+            elsif Arg (Arg'First) = '-' then\n+               Place (' ');\n+               Place (Arg.all);\n \n-                                    if Sw.Unix_String\n-                                         (Sw.Unix_String'Last) /= '='\n-                                    then\n-                                       Put (' ');\n-                                    end if;\n+               --  Copy quoted switch with quotes stripped\n \n-                                    Put (\"<string>\");\n-                                    New_Line;\n+            elsif Arg (Arg'First) = '\"' then\n+               if Arg (Arg'Last) /= '\"' then\n+                  Put (Standard_Error, \"misquoted argument: \");\n+                  Put_Line (Standard_Error, Arg.all);\n+                  Errors := Errors + 1;\n \n-                                 when T_Commands =>\n-                                    Put (\" (switches for \");\n-                                    Put (Sw.Unix_String\n-                                           (Sw.Unix_String'First + 7\n-                                            .. Sw.Unix_String'Last));\n-                                    Put (')');\n-                                    Set_Col (53);\n-                                    Put (Sw.Unix_String\n-                                           (Sw.Unix_String'First\n-                                            .. Sw.Unix_String'First + 5));\n-                                    Put_Line (\" switches\");\n+               else\n+                  Place (' ');\n+                  Place (Arg (Arg'First + 1 .. Arg'Last - 1));\n+               end if;\n \n-                                 when T_Options =>\n-                                    declare\n-                                       Opt : Item_Ptr := Sw.Options;\n+               --  Parameter Argument\n \n-                                    begin\n-                                       Put_Line (\"=(option,option..)\");\n+            elsif Arg (Arg'First) /= '/'\n+              and then Make_Commands_Active = null\n+            then\n+               Param_Count := Param_Count + 1;\n \n-                                       while Opt /= null loop\n-                                          Put (\"      \");\n-                                          Put (Opt.Name.all);\n+               if Param_Count <= Command.Params'Length then\n \n-                                          if Opt = Sw.Options then\n-                                             Put (\" (D)\");\n-                                          end if;\n+                  case Command.Params (Param_Count) is\n \n-                                          Set_Col (53);\n-                                          Put_Line (Opt.Unix_String.all);\n-                                          Opt := Opt.Next;\n-                                       end loop;\n-                                    end;\n+                     when File | Optional_File =>\n+                        declare\n+                           Normal_File : constant String_Access :=\n+                             To_Canonical_File_Spec\n+                               (Arg.all);\n \n-                              end case;\n+                        begin\n+                           Place (' ');\n+                           Place_Lower (Normal_File.all);\n \n-                              Sw := Sw.Next;\n-                           end loop;\n+                           if Is_Extensionless (Normal_File.all)\n+                             and then Command.Defext /= \"   \"\n+                           then\n+                              Place ('.');\n+                              Place (Command.Defext);\n+                           end if;\n                         end;\n \n-                        raise Normal_Exit;\n-                     end if;\n+                     when Unlimited_Files =>\n+                        declare\n+                           Normal_File : constant String_Access :=\n+                             To_Canonical_File_Spec\n+                               (Arg.all);\n \n-                     --  Special handling for internal debugging switch /?\n+                           File_Is_Wild : Boolean := False;\n+                           File_List    : String_Access_List_Access;\n \n-                  elsif Arg.all = \"/?\" then\n-                     Display_Command := True;\n+                        begin\n+                           for J in Arg'Range loop\n+                              if Arg (J) = '*'\n+                                or else Arg (J) = '%'\n+                              then\n+                                 File_Is_Wild := True;\n+                              end if;\n+                           end loop;\n \n-                     --  Copy -switch unchanged\n+                           if File_Is_Wild then\n+                              File_List := To_Canonical_File_List\n+                                (Arg.all, False);\n \n-                  elsif Arg (Arg'First) = '-' then\n-                     Place (' ');\n-                     Place (Arg.all);\n+                              for J in File_List.all'Range loop\n+                                 Place (' ');\n+                                 Place_Lower (File_List.all (J).all);\n+                              end loop;\n \n-                     --  Copy quoted switch with quotes stripped\n+                           else\n+                              Place (' ');\n+                              Place_Lower (Normal_File.all);\n+\n+                              if Is_Extensionless (Normal_File.all)\n+                                and then Command.Defext /= \"   \"\n+                              then\n+                                 Place ('.');\n+                                 Place (Command.Defext);\n+                              end if;\n+                           end if;\n \n-                  elsif Arg (Arg'First) = '\"' then\n-                     if Arg (Arg'Last) /= '\"' then\n-                        Put (Standard_Error, \"misquoted argument: \");\n-                        Put_Line (Standard_Error, Arg.all);\n-                        Errors := Errors + 1;\n+                           Param_Count := Param_Count - 1;\n+                        end;\n \n-                     else\n+                     when Other_As_Is =>\n                         Place (' ');\n-                        Place (Arg (Arg'First + 1 .. Arg'Last - 1));\n-                     end if;\n+                        Place (Arg.all);\n \n-                     --  Parameter Argument\n+                     when Unlimited_As_Is =>\n+                        Place (' ');\n+                        Place (Arg.all);\n+                        Param_Count := Param_Count - 1;\n+\n+                     when Files_Or_Wildcard =>\n+\n+                        --  Remove spaces from a comma separated list\n+                        --  of file names and adjust control variables\n+                        --  accordingly.\n+\n+                        while Arg_Num < Argument_Count and then\n+                          (Argv (Argv'Last) = ',' xor\n+                             Argument (Arg_Num + 1)\n+                             (Argument (Arg_Num + 1)'First) = ',')\n+                        loop\n+                           Argv := new String'\n+                             (Argv.all & Argument (Arg_Num + 1));\n+                           Arg_Num := Arg_Num + 1;\n+                           Arg_Idx := Argv'First;\n+                           Next_Arg_Idx :=\n+                             Get_Arg_End (Argv.all, Arg_Idx);\n+                           Arg := new String'\n+                             (Argv (Arg_Idx .. Next_Arg_Idx));\n+                        end loop;\n \n-                  elsif Arg (Arg'First) /= '/'\n-                    and then Make_Commands_Active = null\n-                  then\n-                     Param_Count := Param_Count + 1;\n+                        --  Parse the comma separated list of VMS\n+                        --  filenames and place them on the command\n+                        --  line as space separated Unix style\n+                        --  filenames. Lower case and add default\n+                        --  extension as appropriate.\n \n-                     if Param_Count <= Command.Params'Length then\n+                        declare\n+                           Arg1_Idx : Integer := Arg'First;\n+\n+                           function Get_Arg1_End\n+                             (Arg     : String;\n+                              Arg_Idx : Integer) return Integer;\n+                           --  Begins looking at Arg_Idx + 1 and\n+                           --  returns the index of the last character\n+                           --  before a comma or else the index of the\n+                           --  last character in the string Arg.\n+\n+                           ------------------\n+                           -- Get_Arg1_End --\n+                           ------------------\n+\n+                           function Get_Arg1_End\n+                             (Arg     : String;\n+                              Arg_Idx : Integer) return Integer\n+                           is\n+                           begin\n+                              for J in Arg_Idx + 1 .. Arg'Last loop\n+                                 if Arg (J) = ',' then\n+                                    return J - 1;\n+                                 end if;\n+                              end loop;\n \n-                        case Command.Params (Param_Count) is\n+                              return Arg'Last;\n+                           end Get_Arg1_End;\n \n-                           when File | Optional_File =>\n+                        begin\n+                           loop\n                               declare\n-                                 Normal_File : constant String_Access :=\n-                                                 To_Canonical_File_Spec\n-                                                   (Arg.all);\n+                                 Next_Arg1_Idx :\n+                                 constant Integer :=\n+                                   Get_Arg1_End (Arg.all, Arg1_Idx);\n+\n+                                 Arg1 :\n+                                 constant String :=\n+                                   Arg (Arg1_Idx .. Next_Arg1_Idx);\n+\n+                                 Normal_File :\n+                                 constant String_Access :=\n+                                   To_Canonical_File_Spec (Arg1);\n \n                               begin\n                                  Place (' ');\n@@ -1309,584 +1458,536 @@ package body VMS_Conv is\n                                     Place ('.');\n                                     Place (Command.Defext);\n                                  end if;\n+\n+                                 Arg1_Idx := Next_Arg1_Idx + 1;\n                               end;\n \n-                           when Unlimited_Files =>\n-                              declare\n-                                 Normal_File : constant String_Access :=\n-                                                 To_Canonical_File_Spec\n-                                                   (Arg.all);\n+                              exit when Arg1_Idx > Arg'Last;\n \n-                                 File_Is_Wild : Boolean := False;\n-                                 File_List    : String_Access_List_Access;\n+                              --  Don't allow two or more commas in\n+                              --  a row\n \n-                              begin\n-                                 for J in Arg'Range loop\n-                                    if Arg (J) = '*'\n-                                      or else Arg (J) = '%'\n-                                    then\n-                                       File_Is_Wild := True;\n-                                    end if;\n-                                 end loop;\n+                              if Arg (Arg1_Idx) = ',' then\n+                                 Arg1_Idx := Arg1_Idx + 1;\n+                                 if Arg1_Idx > Arg'Last or else\n+                                   Arg (Arg1_Idx) = ','\n+                                 then\n+                                    Put_Line\n+                                      (Standard_Error,\n+                                       \"Malformed Parameter: \" &\n+                                       Arg.all);\n+                                    Put (Standard_Error, \"usage: \");\n+                                    Put_Line (Standard_Error,\n+                                              Command.Usage.all);\n+                                    raise Error_Exit;\n+                                 end if;\n+                              end if;\n \n-                                 if File_Is_Wild then\n-                                    File_List := To_Canonical_File_List\n-                                      (Arg.all, False);\n+                           end loop;\n+                        end;\n+                  end case;\n+               end if;\n \n-                                    for J in File_List.all'Range loop\n-                                       Place (' ');\n-                                       Place_Lower (File_List.all (J).all);\n-                                    end loop;\n+               --  Qualifier argument\n \n-                                 else\n-                                    Place (' ');\n-                                    Place_Lower (Normal_File.all);\n+            else\n+               --  This code is too heavily nested, should be\n+               --  separated out as separate subprogram ???\n \n-                                    if Is_Extensionless (Normal_File.all)\n-                                      and then Command.Defext /= \"   \"\n-                                    then\n-                                       Place ('.');\n-                                       Place (Command.Defext);\n-                                    end if;\n-                                 end if;\n+               declare\n+                  Sw   : Item_Ptr;\n+                  SwP  : Natural;\n+                  P2   : Natural;\n+                  Endp : Natural := 0; -- avoid warning!\n+                  Opt  : Item_Ptr;\n \n-                                 Param_Count := Param_Count - 1;\n-                              end;\n+               begin\n+                  SwP := Arg'First;\n+                  while SwP < Arg'Last\n+                    and then Arg (SwP + 1) /= '='\n+                  loop\n+                     SwP := SwP + 1;\n+                  end loop;\n \n-                           when Other_As_Is =>\n-                              Place (' ');\n-                              Place (Arg.all);\n+                  --  At this point, the switch name is in\n+                  --  Arg (Arg'First..SwP) and if that is not the\n+                  --  whole switch, then there is an equal sign at\n+                  --  Arg (SwP + 1) and the rest of Arg is what comes\n+                  --  after the equal sign.\n+\n+                  --  If make commands are active, see if we have\n+                  --  another COMMANDS_TRANSLATION switch belonging\n+                  --  to gnatmake.\n+\n+                  if Make_Commands_Active /= null then\n+                     Sw :=\n+                       Matching_Name\n+                         (Arg (Arg'First .. SwP),\n+                          Command.Switches,\n+                          Quiet => True);\n+\n+                     if Sw /= null\n+                       and then Sw.Translation = T_Commands\n+                     then\n+                        null;\n \n-                           when Unlimited_As_Is =>\n-                              Place (' ');\n-                              Place (Arg.all);\n-                              Param_Count := Param_Count - 1;\n+                     else\n+                        Sw :=\n+                          Matching_Name\n+                            (Arg (Arg'First .. SwP),\n+                             Make_Commands_Active.Switches,\n+                             Quiet => False);\n+                     end if;\n+\n+                     --  For case of GNAT MAKE or CHOP, if we cannot\n+                     --  find the switch, then see if it is a\n+                     --  recognized compiler switch instead, and if\n+                     --  so process the compiler switch.\n+\n+                  elsif Command.Name.all = \"MAKE\"\n+                    or else Command.Name.all = \"CHOP\" then\n+                     Sw :=\n+                       Matching_Name\n+                         (Arg (Arg'First .. SwP),\n+                          Command.Switches,\n+                          Quiet => True);\n+\n+                     if Sw = null then\n+                        Sw :=\n+                          Matching_Name\n+                            (Arg (Arg'First .. SwP),\n+                             Matching_Name\n+                               (\"COMPILE\", Commands).Switches,\n+                             Quiet => False);\n+                     end if;\n+\n+                     --  For all other cases, just search the relevant\n+                     --  command.\n+\n+                  else\n+                     Sw :=\n+                       Matching_Name\n+                         (Arg (Arg'First .. SwP),\n+                          Command.Switches,\n+                          Quiet => False);\n+                  end if;\n+\n+                  if Sw /= null then\n+                     case Sw.Translation is\n+\n+                        when T_Direct =>\n+                           Place_Unix_Switches (Sw.Unix_String);\n+                           if SwP < Arg'Last\n+                             and then Arg (SwP + 1) = '='\n+                           then\n+                              Put (Standard_Error,\n+                                   \"qualifier options ignored: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                           end if;\n+\n+                        when T_Directories =>\n+                           if SwP + 1 > Arg'Last then\n+                              Put (Standard_Error,\n+                                   \"missing directories for: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                              Errors := Errors + 1;\n+\n+                           elsif Arg (SwP + 2) /= '(' then\n+                              SwP := SwP + 2;\n+                              Endp := Arg'Last;\n \n-                           when Files_Or_Wildcard =>\n+                           elsif Arg (Arg'Last) /= ')' then\n \n-                              --  Remove spaces from a comma separated list\n-                              --  of file names and adjust control variables\n-                              --  accordingly.\n+                              --  Remove spaces from a comma separated\n+                              --  list of file names and adjust\n+                              --  control variables accordingly.\n \n-                              while Arg_Num < Argument_Count and then\n+                              if Arg_Num < Argument_Count and then\n                                 (Argv (Argv'Last) = ',' xor\n                                    Argument (Arg_Num + 1)\n                                    (Argument (Arg_Num + 1)'First) = ',')\n-                              loop\n-                                 Argv := new String'\n-                                   (Argv.all & Argument (Arg_Num + 1));\n+                              then\n+                                 Argv :=\n+                                   new String'(Argv.all\n+                                               & Argument\n+                                                 (Arg_Num + 1));\n                                  Arg_Num := Arg_Num + 1;\n                                  Arg_Idx := Argv'First;\n                                  Next_Arg_Idx :=\n                                    Get_Arg_End (Argv.all, Arg_Idx);\n                                  Arg := new String'\n                                    (Argv (Arg_Idx .. Next_Arg_Idx));\n-                              end loop;\n+                                 goto Tryagain_After_Coalesce;\n+                              end if;\n+\n+                              Put (Standard_Error,\n+                                   \"incorrectly parenthesized \" &\n+                                   \"or malformed argument: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                              Errors := Errors + 1;\n \n-                              --  Parse the comma separated list of VMS\n-                              --  filenames and place them on the command\n-                              --  line as space separated Unix style\n-                              --  filenames. Lower case and add default\n-                              --  extension as appropriate.\n+                           else\n+                              SwP := SwP + 3;\n+                              Endp := Arg'Last - 1;\n+                           end if;\n \n+                           while SwP <= Endp loop\n                               declare\n-                                 Arg1_Idx : Integer := Arg'First;\n-\n-                                 function Get_Arg1_End\n-                                   (Arg     : String;\n-                                    Arg_Idx : Integer) return Integer;\n-                                 --  Begins looking at Arg_Idx + 1 and\n-                                 --  returns the index of the last character\n-                                 --  before a comma or else the index of the\n-                                 --  last character in the string Arg.\n-\n-                                 ------------------\n-                                 -- Get_Arg1_End --\n-                                 ------------------\n-\n-                                 function Get_Arg1_End\n-                                   (Arg     : String;\n-                                    Arg_Idx : Integer) return Integer\n-                                 is\n-                                 begin\n-                                    for J in Arg_Idx + 1 .. Arg'Last loop\n-                                       if Arg (J) = ',' then\n-                                          return J - 1;\n-                                       end if;\n-                                    end loop;\n+                                 Dir_Is_Wild       : Boolean := False;\n+                                 Dir_Maybe_Is_Wild : Boolean := False;\n \n-                                    return Arg'Last;\n-                                 end Get_Arg1_End;\n+                                 Dir_List : String_Access_List_Access;\n \n                               begin\n+                                 P2 := SwP;\n+\n+                                 while P2 < Endp\n+                                   and then Arg (P2 + 1) /= ','\n                                  loop\n-                                    declare\n-                                       Next_Arg1_Idx :\n-                                       constant Integer :=\n-                                         Get_Arg1_End (Arg.all, Arg1_Idx);\n-\n-                                       Arg1 :\n-                                       constant String :=\n-                                         Arg (Arg1_Idx .. Next_Arg1_Idx);\n-\n-                                       Normal_File :\n-                                       constant String_Access :=\n-                                         To_Canonical_File_Spec (Arg1);\n-\n-                                    begin\n-                                       Place (' ');\n-                                       Place_Lower (Normal_File.all);\n-\n-                                       if Is_Extensionless (Normal_File.all)\n-                                         and then Command.Defext /= \"   \"\n-                                       then\n-                                          Place ('.');\n-                                          Place (Command.Defext);\n-                                       end if;\n-\n-                                       Arg1_Idx := Next_Arg1_Idx + 1;\n-                                    end;\n-\n-                                    exit when Arg1_Idx > Arg'Last;\n-\n-                                    --  Don't allow two or more commas in\n-                                    --  a row\n-\n-                                    if Arg (Arg1_Idx) = ',' then\n-                                       Arg1_Idx := Arg1_Idx + 1;\n-                                       if Arg1_Idx > Arg'Last or else\n-                                         Arg (Arg1_Idx) = ','\n-                                       then\n-                                          Put_Line\n-                                            (Standard_Error,\n-                                             \"Malformed Parameter: \" &\n-                                             Arg.all);\n-                                          Put (Standard_Error, \"usage: \");\n-                                          Put_Line (Standard_Error,\n-                                                    Command.Usage.all);\n-                                          raise Error_Exit;\n-                                       end if;\n+                                    --  A wildcard directory spec on\n+                                    --  VMS will contain either * or\n+                                    --  % or ...\n+\n+                                    if Arg (P2) = '*' then\n+                                       Dir_Is_Wild := True;\n+\n+                                    elsif Arg (P2) = '%' then\n+                                       Dir_Is_Wild := True;\n+\n+                                    elsif Dir_Maybe_Is_Wild\n+                                      and then Arg (P2) = '.'\n+                                      and then Arg (P2 + 1) = '.'\n+                                    then\n+                                       Dir_Is_Wild := True;\n+                                       Dir_Maybe_Is_Wild := False;\n+\n+                                    elsif Dir_Maybe_Is_Wild then\n+                                       Dir_Maybe_Is_Wild := False;\n+\n+                                    elsif Arg (P2) = '.'\n+                                      and then Arg (P2 + 1) = '.'\n+                                    then\n+                                       Dir_Maybe_Is_Wild := True;\n+\n                                     end if;\n \n+                                    P2 := P2 + 1;\n                                  end loop;\n+\n+                                 if Dir_Is_Wild then\n+                                    Dir_List :=\n+                                      To_Canonical_File_List\n+                                        (Arg (SwP .. P2), True);\n+\n+                                    for J in Dir_List.all'Range loop\n+                                       Place_Unix_Switches\n+                                         (Sw.Unix_String);\n+                                       Place_Lower\n+                                         (Dir_List.all (J).all);\n+                                    end loop;\n+\n+                                 else\n+                                    Place_Unix_Switches\n+                                      (Sw.Unix_String);\n+                                    Place_Lower\n+                                      (To_Canonical_Dir_Spec\n+                                         (Arg (SwP .. P2), False).all);\n+                                 end if;\n+\n+                                 SwP := P2 + 2;\n                               end;\n-                        end case;\n-                     end if;\n+                           end loop;\n \n-                     --  Qualifier argument\n+                        when T_Directory =>\n+                           if SwP + 1 > Arg'Last then\n+                              Put (Standard_Error,\n+                                   \"missing directory for: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                              Errors := Errors + 1;\n \n-                  else\n-                     --  This code is too heavily nested, should be\n-                     --  separated out as separate subprogram ???\n-\n-                     declare\n-                        Sw   : Item_Ptr;\n-                        SwP  : Natural;\n-                        P2   : Natural;\n-                        Endp : Natural := 0; -- avoid warning!\n-                        Opt  : Item_Ptr;\n-\n-                     begin\n-                        SwP := Arg'First;\n-                        while SwP < Arg'Last\n-                          and then Arg (SwP + 1) /= '='\n-                        loop\n-                           SwP := SwP + 1;\n-                        end loop;\n+                           else\n+                              Place_Unix_Switches (Sw.Unix_String);\n \n-                        --  At this point, the switch name is in\n-                        --  Arg (Arg'First..SwP) and if that is not the\n-                        --  whole switch, then there is an equal sign at\n-                        --  Arg (SwP + 1) and the rest of Arg is what comes\n-                        --  after the equal sign.\n+                              --  Some switches end in \"=\". No space\n+                              --  here\n \n-                        --  If make commands are active, see if we have\n-                        --  another COMMANDS_TRANSLATION switch belonging\n-                        --  to gnatmake.\n+                              if Sw.Unix_String\n+                                (Sw.Unix_String'Last) /= '='\n+                              then\n+                                 Place (' ');\n+                              end if;\n \n-                        if Make_Commands_Active /= null then\n-                           Sw :=\n-                             Matching_Name\n-                               (Arg (Arg'First .. SwP),\n-                                Command.Switches,\n-                                Quiet => True);\n+                              Place_Lower\n+                                (To_Canonical_Dir_Spec\n+                                   (Arg (SwP + 2 .. Arg'Last),\n+                                    False).all);\n+                           end if;\n \n-                           if Sw /= null\n-                             and then Sw.Translation = T_Commands\n-                           then\n-                              null;\n+                        when T_File | T_No_Space_File =>\n+                           if SwP + 1 > Arg'Last then\n+                              Put (Standard_Error,\n+                                   \"missing file for: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                              Errors := Errors + 1;\n \n                            else\n-                              Sw :=\n-                                Matching_Name\n-                                  (Arg (Arg'First .. SwP),\n-                                   Make_Commands_Active.Switches,\n-                                   Quiet => False);\n-                           end if;\n+                              Place_Unix_Switches (Sw.Unix_String);\n \n-                           --  For case of GNAT MAKE or CHOP, if we cannot\n-                           --  find the switch, then see if it is a\n-                           --  recognized compiler switch instead, and if\n-                           --  so process the compiler switch.\n+                              --  Some switches end in \"=\". No space\n+                              --  here.\n \n-                        elsif Command.Name.all = \"MAKE\"\n-                          or else Command.Name.all = \"CHOP\" then\n-                           Sw :=\n-                             Matching_Name\n-                               (Arg (Arg'First .. SwP),\n-                                Command.Switches,\n-                                Quiet => True);\n+                              if Sw.Translation = T_File\n+                                and then Sw.Unix_String\n+                                  (Sw.Unix_String'Last) /= '='\n+                              then\n+                                 Place (' ');\n+                              end if;\n \n-                           if Sw = null then\n-                              Sw :=\n-                                Matching_Name\n-                                  (Arg (Arg'First .. SwP),\n-                                   Matching_Name\n-                                     (\"COMPILE\", Commands).Switches,\n-                                   Quiet => False);\n+                              Place_Lower\n+                                (To_Canonical_File_Spec\n+                                   (Arg (SwP + 2 .. Arg'Last)).all);\n                            end if;\n \n-                           --  For all other cases, just search the relevant\n-                           --  command.\n-\n-                        else\n-                           Sw :=\n-                             Matching_Name\n-                               (Arg (Arg'First .. SwP),\n-                                Command.Switches,\n-                                Quiet => False);\n-                        end if;\n+                        when T_Numeric =>\n+                           if OK_Integer (Arg (SwP + 2 .. Arg'Last)) then\n+                              Place_Unix_Switches (Sw.Unix_String);\n+                              Place (Arg (SwP + 2 .. Arg'Last));\n \n-                        if Sw /= null then\n-                           case Sw.Translation is\n+                           else\n+                              Put (Standard_Error, \"argument for \");\n+                              Put (Standard_Error, Sw.Name.all);\n+                              Put_Line\n+                                (Standard_Error, \" must be numeric\");\n+                              Errors := Errors + 1;\n+                           end if;\n \n-                              when T_Direct =>\n-                                 Place_Unix_Switches (Sw.Unix_String);\n-                                 if SwP < Arg'Last\n-                                   and then Arg (SwP + 1) = '='\n-                                 then\n-                                    Put (Standard_Error,\n-                                         \"qualifier options ignored: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                 end if;\n+                        when T_Alphanumplus =>\n+                           if OK_Alphanumerplus\n+                             (Arg (SwP + 2 .. Arg'Last))\n+                           then\n+                              Place_Unix_Switches (Sw.Unix_String);\n+                              Place (Arg (SwP + 2 .. Arg'Last));\n \n-                              when T_Directories =>\n-                                 if SwP + 1 > Arg'Last then\n-                                    Put (Standard_Error,\n-                                         \"missing directories for: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                    Errors := Errors + 1;\n+                           else\n+                              Put (Standard_Error, \"argument for \");\n+                              Put (Standard_Error, Sw.Name.all);\n+                              Put_Line (Standard_Error,\n+                                        \" must be alphanumeric\");\n+                              Errors := Errors + 1;\n+                           end if;\n \n-                                 elsif Arg (SwP + 2) /= '(' then\n-                                    SwP := SwP + 2;\n-                                    Endp := Arg'Last;\n+                        when T_String =>\n \n-                                 elsif Arg (Arg'Last) /= ')' then\n+                           --  A String value must be extended to the\n+                           --  end of the Argv, otherwise strings like\n+                           --  \"foo/bar\" get split at the slash.\n \n-                                    --  Remove spaces from a comma separated\n-                                    --  list of file names and adjust\n-                                    --  control variables accordingly.\n+                           --  The begining and ending of the string\n+                           --  are flagged with embedded nulls which\n+                           --  are removed when building the Spawn\n+                           --  call. Nulls are use because they won't\n+                           --  show up in a /? output. Quotes aren't\n+                           --  used because that would make it\n+                           --  difficult to embed them.\n \n-                                    if Arg_Num < Argument_Count and then\n-                                      (Argv (Argv'Last) = ',' xor\n-                                         Argument (Arg_Num + 1)\n-                                         (Argument (Arg_Num + 1)'First) = ',')\n-                                    then\n-                                       Argv :=\n-                                         new String'(Argv.all\n-                                                     & Argument\n-                                                       (Arg_Num + 1));\n-                                       Arg_Num := Arg_Num + 1;\n-                                       Arg_Idx := Argv'First;\n-                                       Next_Arg_Idx :=\n-                                         Get_Arg_End (Argv.all, Arg_Idx);\n-                                       Arg := new String'\n-                                         (Argv (Arg_Idx .. Next_Arg_Idx));\n-                                       goto Tryagain_After_Coalesce;\n-                                    end if;\n+                           Place_Unix_Switches (Sw.Unix_String);\n \n-                                    Put (Standard_Error,\n-                                         \"incorrectly parenthesized \" &\n-                                         \"or malformed argument: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                    Errors := Errors + 1;\n+                           if Next_Arg_Idx /= Argv'Last then\n+                              Next_Arg_Idx := Argv'Last;\n+                              Arg := new String'\n+                                (Argv (Arg_Idx .. Next_Arg_Idx));\n \n-                                 else\n-                                    SwP := SwP + 3;\n-                                    Endp := Arg'Last - 1;\n-                                 end if;\n+                              SwP := Arg'First;\n+                              while SwP < Arg'Last and then\n+                              Arg (SwP + 1) /= '=' loop\n+                                 SwP := SwP + 1;\n+                              end loop;\n+                           end if;\n \n-                                 while SwP <= Endp loop\n-                                    declare\n-                                       Dir_Is_Wild       : Boolean := False;\n-                                       Dir_Maybe_Is_Wild : Boolean := False;\n-\n-                                       Dir_List : String_Access_List_Access;\n-\n-                                    begin\n-                                       P2 := SwP;\n-\n-                                       while P2 < Endp\n-                                         and then Arg (P2 + 1) /= ','\n-                                       loop\n-                                          --  A wildcard directory spec on\n-                                          --  VMS will contain either * or\n-                                          --  % or ...\n-\n-                                          if Arg (P2) = '*' then\n-                                             Dir_Is_Wild := True;\n-\n-                                          elsif Arg (P2) = '%' then\n-                                             Dir_Is_Wild := True;\n-\n-                                          elsif Dir_Maybe_Is_Wild\n-                                            and then Arg (P2) = '.'\n-                                            and then Arg (P2 + 1) = '.'\n-                                          then\n-                                             Dir_Is_Wild := True;\n-                                             Dir_Maybe_Is_Wild := False;\n-\n-                                          elsif Dir_Maybe_Is_Wild then\n-                                             Dir_Maybe_Is_Wild := False;\n-\n-                                          elsif Arg (P2) = '.'\n-                                            and then Arg (P2 + 1) = '.'\n-                                          then\n-                                             Dir_Maybe_Is_Wild := True;\n-\n-                                          end if;\n-\n-                                          P2 := P2 + 1;\n-                                       end loop;\n-\n-                                       if Dir_Is_Wild then\n-                                          Dir_List :=\n-                                            To_Canonical_File_List\n-                                              (Arg (SwP .. P2), True);\n-\n-                                          for J in Dir_List.all'Range loop\n-                                             Place_Unix_Switches\n-                                               (Sw.Unix_String);\n-                                             Place_Lower\n-                                               (Dir_List.all (J).all);\n-                                          end loop;\n-\n-                                       else\n-                                          Place_Unix_Switches\n-                                            (Sw.Unix_String);\n-                                          Place_Lower\n-                                            (To_Canonical_Dir_Spec\n-                                               (Arg (SwP .. P2), False).all);\n-                                       end if;\n-\n-                                       SwP := P2 + 2;\n-                                    end;\n-                                 end loop;\n+                           Place (ASCII.NUL);\n+                           Place (Arg (SwP + 2 .. Arg'Last));\n+                           Place (ASCII.NUL);\n \n-                              when T_Directory =>\n-                                 if SwP + 1 > Arg'Last then\n-                                    Put (Standard_Error,\n-                                         \"missing directory for: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                    Errors := Errors + 1;\n+                        when T_Commands =>\n \n-                                 else\n-                                    Place_Unix_Switches (Sw.Unix_String);\n+                           --  Output -largs/-bargs/-cargs\n \n-                                    --  Some switches end in \"=\". No space\n-                                    --  here\n+                           Place (' ');\n+                           Place (Sw.Unix_String\n+                                    (Sw.Unix_String'First ..\n+                                       Sw.Unix_String'First + 5));\n \n-                                    if Sw.Unix_String\n-                                         (Sw.Unix_String'Last) /= '='\n-                                    then\n-                                       Place (' ');\n-                                    end if;\n+                           if Sw.Unix_String\n+                             (Sw.Unix_String'First + 7 ..\n+                                Sw.Unix_String'Last) = \"MAKE\"\n+                           then\n+                              Make_Commands_Active := null;\n \n-                                    Place_Lower\n-                                      (To_Canonical_Dir_Spec\n-                                         (Arg (SwP + 2 .. Arg'Last),\n-                                          False).all);\n-                                 end if;\n+                           else\n+                              --  Set source of new commands, also\n+                              --  setting this non-null indicates that\n+                              --  we are in the special commands mode\n+                              --  for processing the -xargs case.\n \n-                              when T_File | T_No_Space_File =>\n-                                 if SwP + 1 > Arg'Last then\n-                                    Put (Standard_Error,\n-                                         \"missing file for: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                    Errors := Errors + 1;\n+                              Make_Commands_Active :=\n+                                Matching_Name\n+                                  (Sw.Unix_String\n+                                       (Sw.Unix_String'First + 7 ..\n+                                            Sw.Unix_String'Last),\n+                                   Commands);\n+                           end if;\n \n-                                 else\n-                                    Place_Unix_Switches (Sw.Unix_String);\n+                        when T_Options =>\n+                           if SwP + 1 > Arg'Last then\n+                              Place_Unix_Switches\n+                                (Sw.Options.Unix_String);\n+                              SwP := Endp + 1;\n \n-                                    --  Some switches end in \"=\". No space\n-                                    --  here.\n+                           elsif Arg (SwP + 2) /= '(' then\n+                              SwP := SwP + 2;\n+                              Endp := Arg'Last;\n \n-                                    if Sw.Translation = T_File\n-                                      and then Sw.Unix_String\n-                                                 (Sw.Unix_String'Last) /= '='\n-                                    then\n-                                       Place (' ');\n-                                    end if;\n+                           elsif Arg (Arg'Last) /= ')' then\n+                              Put (Standard_Error,\n+                                   \"incorrectly parenthesized argument: \");\n+                              Put_Line (Standard_Error, Arg.all);\n+                              Errors := Errors + 1;\n+                              SwP := Endp + 1;\n \n-                                    Place_Lower\n-                                      (To_Canonical_File_Spec\n-                                         (Arg (SwP + 2 .. Arg'Last)).all);\n-                                 end if;\n+                           else\n+                              SwP := SwP + 3;\n+                              Endp := Arg'Last - 1;\n+                           end if;\n \n-                              when T_Numeric =>\n-                                 if OK_Integer (Arg (SwP + 2 .. Arg'Last)) then\n-                                    Place_Unix_Switches (Sw.Unix_String);\n-                                    Place (Arg (SwP + 2 .. Arg'Last));\n+                           while SwP <= Endp loop\n+                              P2 := SwP;\n \n-                                 else\n-                                    Put (Standard_Error, \"argument for \");\n-                                    Put (Standard_Error, Sw.Name.all);\n-                                    Put_Line\n-                                      (Standard_Error, \" must be numeric\");\n-                                    Errors := Errors + 1;\n-                                 end if;\n+                              while P2 < Endp\n+                                and then Arg (P2 + 1) /= ','\n+                              loop\n+                                 P2 := P2 + 1;\n+                              end loop;\n \n-                              when T_Alphanumplus =>\n-                                 if OK_Alphanumerplus\n-                                      (Arg (SwP + 2 .. Arg'Last))\n-                                 then\n-                                    Place_Unix_Switches (Sw.Unix_String);\n-                                    Place (Arg (SwP + 2 .. Arg'Last));\n+                              --  Option name is in Arg (SwP .. P2)\n \n-                                 else\n-                                    Put (Standard_Error, \"argument for \");\n-                                    Put (Standard_Error, Sw.Name.all);\n-                                    Put_Line (Standard_Error,\n-                                              \" must be alphanumeric\");\n-                                    Errors := Errors + 1;\n-                                 end if;\n+                              Opt := Matching_Name (Arg (SwP .. P2),\n+                                                    Sw.Options);\n \n-                              when T_String =>\n+                              if Opt /= null then\n+                                 Place_Unix_Switches\n+                                   (Opt.Unix_String);\n+                              end if;\n \n-                                 --  A String value must be extended to the\n-                                 --  end of the Argv, otherwise strings like\n-                                 --  \"foo/bar\" get split at the slash.\n+                              SwP := P2 + 2;\n+                           end loop;\n \n-                                 --  The begining and ending of the string\n-                                 --  are flagged with embedded nulls which\n-                                 --  are removed when building the Spawn\n-                                 --  call. Nulls are use because they won't\n-                                 --  show up in a /? output. Quotes aren't\n-                                 --  used because that would make it\n-                                 --  difficult to embed them.\n+                        when T_Other =>\n+                           Place_Unix_Switches\n+                             (new String'(Sw.Unix_String.all &\n+                                          Arg.all));\n \n-                                 Place_Unix_Switches (Sw.Unix_String);\n+                     end case;\n+                  end if;\n+               end;\n+            end if;\n \n-                                 if Next_Arg_Idx /= Argv'Last then\n-                                    Next_Arg_Idx := Argv'Last;\n-                                    Arg := new String'\n-                                      (Argv (Arg_Idx .. Next_Arg_Idx));\n+            Arg_Idx := Next_Arg_Idx + 1;\n+         end;\n \n-                                    SwP := Arg'First;\n-                                    while SwP < Arg'Last and then\n-                                    Arg (SwP + 1) /= '=' loop\n-                                       SwP := SwP + 1;\n-                                    end loop;\n-                                 end if;\n+         exit when Arg_Idx > Argv'Last;\n \n-                                 Place (ASCII.NUL);\n-                                 Place (Arg (SwP + 2 .. Arg'Last));\n-                                 Place (ASCII.NUL);\n+      end loop;\n \n-                              when T_Commands =>\n+      if not Is_Open (Arg_File) then\n+         Arg_Num := Arg_Num + 1;\n+      end if;\n+   end Process_Argument;\n \n-                                 --  Output -largs/-bargs/-cargs\n+   --------------------------------\n+   -- Validate_Command_Or_Option --\n+   --------------------------------\n \n-                                 Place (' ');\n-                                 Place (Sw.Unix_String\n-                                          (Sw.Unix_String'First ..\n-                                             Sw.Unix_String'First + 5));\n+   procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr) is\n+   begin\n+      pragma Assert (N'Length > 0);\n \n-                                 if Sw.Unix_String\n-                                      (Sw.Unix_String'First + 7 ..\n-                                         Sw.Unix_String'Last) = \"MAKE\"\n-                                 then\n-                                    Make_Commands_Active := null;\n+      for J in N'Range loop\n+         if N (J) = '_' then\n+            pragma Assert (N (J - 1) /= '_');\n+            null;\n+         else\n+            pragma Assert (Is_Upper (N (J)) or else Is_Digit (N (J)));\n+            null;\n+         end if;\n+      end loop;\n+   end Validate_Command_Or_Option;\n \n-                                 else\n-                                    --  Set source of new commands, also\n-                                    --  setting this non-null indicates that\n-                                    --  we are in the special commands mode\n-                                    --  for processing the -xargs case.\n-\n-                                    Make_Commands_Active :=\n-                                      Matching_Name\n-                                        (Sw.Unix_String\n-                                             (Sw.Unix_String'First + 7 ..\n-                                                  Sw.Unix_String'Last),\n-                                         Commands);\n-                                 end if;\n+   --------------------------\n+   -- Validate_Unix_Switch --\n+   --------------------------\n \n-                              when T_Options =>\n-                                 if SwP + 1 > Arg'Last then\n-                                    Place_Unix_Switches\n-                                      (Sw.Options.Unix_String);\n-                                    SwP := Endp + 1;\n+   procedure Validate_Unix_Switch (S : VMS_Data.String_Ptr) is\n+   begin\n+      if S (S'First) = '`' then\n+         return;\n+      end if;\n \n-                                 elsif Arg (SwP + 2) /= '(' then\n-                                    SwP := SwP + 2;\n-                                    Endp := Arg'Last;\n+      pragma Assert (S (S'First) = '-' or else S (S'First) = '!');\n \n-                                 elsif Arg (Arg'Last) /= ')' then\n-                                    Put\n-                                      (Standard_Error,\n-                                       \"incorrectly parenthesized \" &\n-                                       \"argument: \");\n-                                    Put_Line (Standard_Error, Arg.all);\n-                                    Errors := Errors + 1;\n-                                    SwP := Endp + 1;\n+      for J in S'First + 1 .. S'Last loop\n+         pragma Assert (S (J) /= ' ');\n \n-                                 else\n-                                    SwP := SwP + 3;\n-                                    Endp := Arg'Last - 1;\n-                                 end if;\n+         if S (J) = '!' then\n+            pragma Assert (S (J - 1) = ',' and then S (J + 1) = '-');\n+            null;\n+         end if;\n+      end loop;\n+   end Validate_Unix_Switch;\n \n-                                 while SwP <= Endp loop\n-                                    P2 := SwP;\n+   --------------------\n+   -- VMS_Conversion --\n+   --------------------\n \n-                                    while P2 < Endp\n-                                      and then Arg (P2 + 1) /= ','\n-                                    loop\n-                                       P2 := P2 + 1;\n-                                    end loop;\n+   procedure VMS_Conversion (The_Command : out Command_Type) is\n+      Result : Command_Type := Undefined;\n+      Result_Set : Boolean := False;\n+   begin\n+      Buffer.Init;\n \n-                                    --  Option name is in Arg (SwP .. P2)\n+      --  First we must preprocess the string form of the command and options\n+      --  list into the internal form that we use.\n \n-                                    Opt := Matching_Name (Arg (SwP .. P2),\n-                                                          Sw.Options);\n+      Preprocess_Command_Data;\n \n-                                    if Opt /= null then\n-                                       Place_Unix_Switches\n-                                         (Opt.Unix_String);\n-                                    end if;\n+      --  If no parameters, give complete list of commands\n \n-                                    SwP := P2 + 2;\n-                                 end loop;\n+      if Argument_Count = 0 then\n+         Output_Version;\n+         New_Line;\n+         Put_Line (\"List of available commands\");\n+         New_Line;\n \n-                              when T_Other =>\n-                                 Place_Unix_Switches\n-                                   (new String'(Sw.Unix_String.all &\n-                                                Arg.all));\n+         while Commands /= null loop\n+            Put (Commands.Usage.all);\n+            Set_Col (53);\n+            Put_Line (Commands.Unix_String.all);\n+            Commands := Commands.Next;\n+         end loop;\n \n-                           end case;\n-                        end if;\n-                     end;\n-                  end if;\n+         raise Normal_Exit;\n+      end if;\n \n-                  Arg_Idx := Next_Arg_Idx + 1;\n-               end;\n+      Arg_Num := 1;\n \n-               exit when Arg_Idx > Argv'Last;\n+      --  Loop through arguments\n \n-            end loop;\n-         end Process_Argument;\n+      while Arg_Num <= Argument_Count loop\n+         Process_Argument (Result);\n \n-         Arg_Num := Arg_Num + 1;\n+         if not Result_Set then\n+            The_Command := Result;\n+            Result_Set := True;\n+         end if;\n       end loop;\n \n       --  Gross error checking that the number of parameters is correct."}]}