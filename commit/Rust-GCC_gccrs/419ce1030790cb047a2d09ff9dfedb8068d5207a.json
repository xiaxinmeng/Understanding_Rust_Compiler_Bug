{"sha": "419ce1030790cb047a2d09ff9dfedb8068d5207a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5Y2UxMDMwNzkwY2IwNDdhMmQwOWZmOWRmZWRiODA2OGQ1MjA3YQ==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2007-09-05T19:54:29Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2007-09-05T19:54:29Z"}, "message": "re PR tree-optimization/21513 (__builtin_expect getting in the way of uninitialized warnings)\n\n\tPR tree-optimization/21513\n\t* builtins.c (build_builtin_expect_predicate): New function.\n\t(fold_builtin_expect): Add argument for expected value.\n\tDistribute __builtin_expect over short-circuiting operations.\n\tFold nested builtin_expects.\n\t(fold_builtin_2): Adjust call to fold_builtin_expect.\n\nFrom-SVN: r128147", "tree": {"sha": "184a821dcb939189e91df3789499e8794503c38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/184a821dcb939189e91df3789499e8794503c38b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/419ce1030790cb047a2d09ff9dfedb8068d5207a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419ce1030790cb047a2d09ff9dfedb8068d5207a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419ce1030790cb047a2d09ff9dfedb8068d5207a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419ce1030790cb047a2d09ff9dfedb8068d5207a/comments", "author": null, "committer": null, "parents": [{"sha": "e3d66ec31ed8c4df6e2123fb374756e6a28ddd2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d66ec31ed8c4df6e2123fb374756e6a28ddd2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d66ec31ed8c4df6e2123fb374756e6a28ddd2c"}], "stats": {"total": 94, "additions": 81, "deletions": 13}, "files": [{"sha": "6f0ea1852267612d56389b2cd22caa5bef4b9e62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419ce1030790cb047a2d09ff9dfedb8068d5207a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419ce1030790cb047a2d09ff9dfedb8068d5207a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=419ce1030790cb047a2d09ff9dfedb8068d5207a", "patch": "@@ -1,3 +1,12 @@\n+2007-09-05  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\tPR tree-optimization/21513\n+\t* builtins.c (build_builtin_expect_predicate): New function.\n+\t(fold_builtin_expect): Add argument for expected value.\n+\tDistribute __builtin_expect over short-circuiting operations.\n+\tFold nested builtin_expects.\n+\t(fold_builtin_2): Adjust call to fold_builtin_expect.\n+\n 2007-09-05  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n \n \tPR web/32965"}, {"sha": "166792c4a40e3707c1a4b8b0e217c0ace4b06e14", "filename": "gcc/builtins.c", "status": "modified", "additions": 72, "deletions": 13, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/419ce1030790cb047a2d09ff9dfedb8068d5207a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/419ce1030790cb047a2d09ff9dfedb8068d5207a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=419ce1030790cb047a2d09ff9dfedb8068d5207a", "patch": "@@ -145,7 +145,7 @@ static rtx expand_builtin_sprintf (tree, rtx, enum machine_mode);\n static tree stabilize_va_list (tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n static tree fold_builtin_constant_p (tree);\n-static tree fold_builtin_expect (tree);\n+static tree fold_builtin_expect (tree, tree);\n static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (tree);\n static tree fold_builtin_inf (tree, int);\n@@ -7054,21 +7054,80 @@ fold_builtin_constant_p (tree arg)\n   return NULL_TREE;\n }\n \n-/* Fold a call to __builtin_expect with argument ARG, if we expect that a\n-   comparison against the argument will fold to a constant.  In practice,\n-   this means a true constant or the address of a non-weak symbol.  */\n+/* Create builtin_expect with PRED and EXPECTED as its arguments and\n+   return it as a truthvalue.  */\n \n static tree\n-fold_builtin_expect (tree arg)\n+build_builtin_expect_predicate (tree pred, tree expected)\n {\n-  tree inner;\n+  tree fn, arg_types, pred_type, expected_type, call_expr, ret_type;\n \n-  /* If the argument isn't invariant, then there's nothing we can do.  */\n-  if (!TREE_INVARIANT (arg))\n+  fn = built_in_decls[BUILT_IN_EXPECT];\n+  arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  ret_type = TREE_TYPE (TREE_TYPE (fn));\n+  pred_type = TREE_VALUE (arg_types);\n+  expected_type = TREE_VALUE (TREE_CHAIN (arg_types));\n+\n+  pred = fold_convert (pred_type, pred);\n+  expected = fold_convert (expected_type, expected);\n+  call_expr = build_call_expr (fn, 2, pred, expected);\n+\n+  return build2 (NE_EXPR, TREE_TYPE (pred), call_expr,\n+\t\t build_int_cst (ret_type, 0));\n+}\n+\n+/* Fold a call to builtin_expect with arguments ARG0 and ARG1.  Return\n+   NULL_TREE if no simplification is possible.  */\n+\n+static tree\n+fold_builtin_expect (tree arg0, tree arg1)\n+{\n+  tree inner, fndecl;\n+  enum tree_code code;\n+\n+  /* If this is a builtin_expect within a builtin_expect keep the\n+     inner one.  See through a comparison against a constant.  It\n+     might have been added to create a thruthvalue.  */\n+  inner = arg0;\n+  if (COMPARISON_CLASS_P (inner)\n+      && TREE_CODE (TREE_OPERAND (inner, 1)) == INTEGER_CST)\n+    inner = TREE_OPERAND (inner, 0);\n+\n+  if (TREE_CODE (inner) == CALL_EXPR\n+      && (fndecl = get_callee_fndecl (inner))\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT)\n+    return arg0;\n+\n+  /* Distribute the expected value over short-circuiting operators.\n+     See through the cast from truthvalue_type_node to long.  */\n+  inner = arg0;\n+  while (TREE_CODE (inner) == NOP_EXPR\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (inner))\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (inner, 0))))\n+    inner = TREE_OPERAND (inner, 0);\n+\n+  code = TREE_CODE (inner);\n+  if (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (inner, 0);\n+      tree op1 = TREE_OPERAND (inner, 1);\n+\n+      op0 = build_builtin_expect_predicate (op0, arg1);\n+      op1 = build_builtin_expect_predicate (op1, arg1);\n+      inner = build2 (code, TREE_TYPE (inner), op0, op1);\n+\n+      return fold_convert (TREE_TYPE (arg0), inner);\n+    }\n+\n+  /* If the argument isn't invariant then there's nothing else we can do.  */\n+  if (!TREE_INVARIANT (arg0))\n     return NULL_TREE;\n \n-  /* If we're looking at an address of a weak decl, then do not fold.  */\n-  inner = arg;\n+  /* If we expect that a comparison against the argument will fold to\n+     a constant return the constant.  In practice, this means a true\n+     constant or the address of a non-weak symbol.  */\n+  inner = arg0;\n   STRIP_NOPS (inner);\n   if (TREE_CODE (inner) == ADDR_EXPR)\n     {\n@@ -7082,8 +7141,8 @@ fold_builtin_expect (tree arg)\n \treturn NULL_TREE;\n     }\n \n-  /* Otherwise, ARG already has the proper type for the return value.  */\n-  return arg;\n+  /* Otherwise, ARG0 already has the proper type for the return value.  */\n+  return arg0;\n }\n \n /* Fold a call to __builtin_classify_type with argument ARG.  */\n@@ -10110,7 +10169,7 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n       return fold_builtin_strpbrk (arg0, arg1, type);\n \n     case BUILT_IN_EXPECT:\n-      return fold_builtin_expect (arg0);\n+      return fold_builtin_expect (arg0, arg1);\n \n     CASE_FLT_FN (BUILT_IN_POW):\n       return fold_builtin_pow (fndecl, arg0, arg1, type);"}]}