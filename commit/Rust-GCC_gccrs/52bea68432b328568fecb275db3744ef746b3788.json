{"sha": "52bea68432b328568fecb275db3744ef746b3788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiZWE2ODQzMmIzMjg1NjhmZWNiMjc1ZGIzNzQ0ZWY3NDZiMzc4OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-01-28T18:00:04Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-01-28T18:00:04Z"}, "message": "Delete a superfluous and buggy optimization\n\nFrom-SVN: r31670", "tree": {"sha": "e04349b8743f6e57eb670c2cf762bb930a1b9a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04349b8743f6e57eb670c2cf762bb930a1b9a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52bea68432b328568fecb275db3744ef746b3788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bea68432b328568fecb275db3744ef746b3788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52bea68432b328568fecb275db3744ef746b3788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bea68432b328568fecb275db3744ef746b3788/comments", "author": null, "committer": null, "parents": [{"sha": "b9ff48144498c9cc2b5f3fd6bd03391579bd24cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9ff48144498c9cc2b5f3fd6bd03391579bd24cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9ff48144498c9cc2b5f3fd6bd03391579bd24cd"}], "stats": {"total": 124, "additions": 5, "deletions": 119}, "files": [{"sha": "a482aaf9db270fed0017ade89a00581b10b6088c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bea68432b328568fecb275db3744ef746b3788/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bea68432b328568fecb275db3744ef746b3788/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52bea68432b328568fecb275db3744ef746b3788", "patch": "@@ -1,3 +1,8 @@\n+2000-01-28  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* jump.c (jump_optimize_1): Delete an optimization that is also done\n+\tby merge_blocks in flow.\n+\n 2000-01-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* diagnostic.c (build_message_string, output_printf,"}, {"sha": "0119d52a1efb5b8798d7fbb47eb17e0f0a883379", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bea68432b328568fecb275db3744ef746b3788/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bea68432b328568fecb275db3744ef746b3788/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=52bea68432b328568fecb275db3744ef746b3788", "patch": "@@ -1995,125 +1995,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n #endif\n \t  else\n \t    {\n-\t      /* Look for   if (foo) bar; else break;  */\n-\t      /* The insns look like this:\n-\t\t insn = condjump label1;\n-\t\t ...range1 (some insns)...\n-\t\t jump label2;\n-\t\t label1:\n-\t\t ...range2 (some insns)...\n-\t\t jump somewhere unconditionally\n-\t\t label2:  */\n-\t      {\n-\t\trtx label1 = next_label (insn);\n-\t\trtx range1end = label1 ? prev_active_insn (label1) : 0;\n-\t\t/* Don't do this optimization on the first round, so that\n-\t\t   jump-around-a-jump gets simplified before we ask here\n-\t\t   whether a jump is unconditional.\n-\n-\t\t   Also don't do it when we are called after reload since\n-\t\t   it will confuse reorg.  */\n-\t\tif (! first\n-\t\t    && (reload_completed ? ! flag_delayed_branch : 1)\n-\t\t    /* Make sure INSN is something we can invert.  */\n-\t\t    && condjump_p (insn)\n-\t\t    && label1 != 0\n-\t\t    && JUMP_LABEL (insn) == label1\n-\t\t    && LABEL_NUSES (label1) == 1\n-\t\t    && GET_CODE (range1end) == JUMP_INSN\n-\t\t    && simplejump_p (range1end))\n-\t\t  {\n-\t\t    rtx label2 = next_label (label1);\n-\t\t    rtx range2end = label2 ? prev_active_insn (label2) : 0;\n-\t\t    if (range1end != range2end\n-\t\t\t&& JUMP_LABEL (range1end) == label2\n-\t\t\t&& GET_CODE (range2end) == JUMP_INSN\n-\t\t\t&& GET_CODE (NEXT_INSN (range2end)) == BARRIER\n-\t\t\t/* Invert the jump condition, so we\n-\t\t\t   still execute the same insns in each case.  */\n-\t\t\t&& invert_jump (insn, label1))\n-\t\t      {\n-\t\t\trtx range1beg = next_active_insn (insn);\n-\t\t\trtx range2beg = next_active_insn (label1);\n-\t\t\trtx range1after, range2after;\n-\t\t\trtx range1before, range2before;\n-\t\t\trtx rangenext;\n-\n-\t\t\t/* Include in each range any notes before it, to be\n-\t\t\t   sure that we get the line number note if any, even\n-\t\t\t   if there are other notes here.  */\n-\t\t\twhile (PREV_INSN (range1beg)\n-\t\t\t       && GET_CODE (PREV_INSN (range1beg)) == NOTE)\n-\t\t\t  range1beg = PREV_INSN (range1beg);\n-\n-\t\t\twhile (PREV_INSN (range2beg)\n-\t\t\t       && GET_CODE (PREV_INSN (range2beg)) == NOTE)\n-\t\t\t  range2beg = PREV_INSN (range2beg);\n-\n-\t\t\t/* Don't move NOTEs for blocks or loops; shift them\n-\t\t\t   outside the ranges, where they'll stay put.  */\n-\t\t\trange1beg = squeeze_notes (range1beg, range1end);\n-\t\t\trange2beg = squeeze_notes (range2beg, range2end);\n-\n-\t\t\t/* Get current surrounds of the 2 ranges.  */\n-\t\t\trange1before = PREV_INSN (range1beg);\n-\t\t\trange2before = PREV_INSN (range2beg);\n-\t\t\trange1after = NEXT_INSN (range1end);\n-\t\t\trange2after = NEXT_INSN (range2end);\n-\n-\t\t\t/* Splice range2 where range1 was.  */\n-\t\t\tNEXT_INSN (range1before) = range2beg;\n-\t\t\tPREV_INSN (range2beg) = range1before;\n-\t\t\tNEXT_INSN (range2end) = range1after;\n-\t\t\tPREV_INSN (range1after) = range2end;\n-\t\t\t/* Splice range1 where range2 was.  */\n-\t\t\tNEXT_INSN (range2before) = range1beg;\n-\t\t\tPREV_INSN (range1beg) = range2before;\n-\t\t\tNEXT_INSN (range1end) = range2after;\n-\t\t\tPREV_INSN (range2after) = range1end;\n-\n-\t\t\t/* Check for loop notes between the end of\n-\t\t\t   range2, and the next code label.  If there is one,\n-\t\t\t   then what we have really seen is\n-\t\t\t   if (foo) break; end_of_loop;\n-\t\t\t   and moved the break sequence outside the loop.\n-\t\t\t   We must move LOOP_END, LOOP_VTOP and LOOP_CONT\n-\t\t\t   notes (in order) to where the loop really ends now,\n-\t\t\t   or we will confuse loop optimization.  Stop if we\n-\t\t\t   find a LOOP_BEG note first, since we don't want to\n-\t\t\t   move the notes in that case.  */\n-\t\t\tfor (;range2after != label2; range2after = rangenext)\n-\t\t\t  {\n-\t\t\t    rangenext = NEXT_INSN (range2after);\n-\t\t\t    if (GET_CODE (range2after) == NOTE)\n-\t\t\t      {\n-\t\t\t\tint kind = NOTE_LINE_NUMBER (range2after);\n-\t\t\t\tif (kind == NOTE_INSN_LOOP_END\n-\t\t\t\t    || kind == NOTE_INSN_LOOP_VTOP\n-\t\t\t\t    || kind == NOTE_INSN_LOOP_CONT)\n-\t\t\t\t  {\n-\t\t\t\t    NEXT_INSN (PREV_INSN (range2after))\n-\t\t\t\t      = rangenext;\n-\t\t\t\t    PREV_INSN (rangenext)\n-\t\t\t\t      = PREV_INSN (range2after);\n-\t\t\t\t    PREV_INSN (range2after) \n-\t\t\t\t      = PREV_INSN (range1beg);\n-\t\t\t\t    NEXT_INSN (range2after) = range1beg;\n-\t\t\t\t    NEXT_INSN (PREV_INSN (range1beg))\n-\t\t\t\t      = range2after;\n-\t\t\t\t    PREV_INSN (range1beg) = range2after;\n-\t\t\t\t  }\n-\t\t\t\telse if (NOTE_LINE_NUMBER (range2after)\n-\t\t\t\t\t == NOTE_INSN_LOOP_BEG)\n-\t\t\t\t  break;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\tchanged = 1;\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n \t      /* Now that the jump has been tensioned,\n \t\t try cross jumping: check for identical code\n \t\t before the jump and before its target label.  */"}]}