{"sha": "0b55e9321430150f742bc7be3f7da16b1a3872d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1NWU5MzIxNDMwMTUwZjc0MmJjN2JlM2Y3ZGExNmIxYTM4NzJkNQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-28T20:49:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-28T20:49:37Z"}, "message": "expmed.c (expand_smod_pow2): New function to expand signed remainder by a constant power of 2, such as \"x % 16\".\n\n\n\t* expmed.c (expand_smod_pow2): New function to expand signed\n\tremainder by a constant power of 2, such as \"x % 16\".\n\t(expand_divmod): Call new expand_smod_pow2 when appropriate.\n\tMinor corrections to comments, e.g. wrapping long lines.\n\nFrom-SVN: r83815", "tree": {"sha": "20aed07aae396652217e2491603ed7111c8fbe05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20aed07aae396652217e2491603ed7111c8fbe05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b55e9321430150f742bc7be3f7da16b1a3872d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b55e9321430150f742bc7be3f7da16b1a3872d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b55e9321430150f742bc7be3f7da16b1a3872d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b55e9321430150f742bc7be3f7da16b1a3872d5/comments", "author": null, "committer": null, "parents": [{"sha": "3b50d22e799b48d8ae4d6cc5ed7bbc9d4c0dc39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b50d22e799b48d8ae4d6cc5ed7bbc9d4c0dc39f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b50d22e799b48d8ae4d6cc5ed7bbc9d4c0dc39f"}], "stats": {"total": 90, "additions": 84, "deletions": 6}, "files": [{"sha": "f86f11afb4b8ddd69d0f4b4b1d06235a1ba54446", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b55e9321430150f742bc7be3f7da16b1a3872d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b55e9321430150f742bc7be3f7da16b1a3872d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b55e9321430150f742bc7be3f7da16b1a3872d5", "patch": "@@ -1,3 +1,10 @@\n+2004-06-28  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (expand_smod_pow2): New function to expand signed\n+\tremainder by a constant power of 2, such as \"x % 16\".\n+\t(expand_divmod): Call new expand_smod_pow2 when appropriate.\n+\tMinor corrections to comments, e.g. wrapping long lines.\n+\n 2004-06-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* Makefile.in (vec.o): Fix dependencies."}, {"sha": "6316f9982c0e13be46e7bfba84280696bf2c3325", "filename": "gcc/expmed.c", "status": "modified", "additions": 77, "deletions": 6, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b55e9321430150f742bc7be3f7da16b1a3872d5/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b55e9321430150f742bc7be3f7da16b1a3872d5/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0b55e9321430150f742bc7be3f7da16b1a3872d5", "patch": "@@ -51,6 +51,7 @@ static rtx lshift_value (enum machine_mode, rtx, int, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, int);\n static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx);\n+static rtx expand_smod_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n \n /* Nonzero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead.\n@@ -3055,6 +3056,72 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n   return expand_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t     unsignedp, max_cost);\n }\n+\n+\n+/* Expand signed modulus of OP0 by a power of two D in mode MODE.  */\n+\n+static rtx\n+expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n+{\n+  unsigned HOST_WIDE_INT mask;\n+  rtx result, temp, label;\n+  int logd;\n+\n+  logd = floor_log2 (d);\n+  result = gen_reg_rtx (mode);\n+\n+  /* Avoid conditional branches when they're expensive.  */\n+  if (BRANCH_COST >= 2\n+      && !optimize_size)\n+    {\n+      rtx signmask = emit_store_flag (result, LT, op0, const0_rtx,\n+\t\t\t\t      mode, 0, -1);\n+      if (signmask)\n+\t{\n+\t  signmask = force_reg (mode, signmask);\n+\t  temp = expand_binop (mode, xor_optab, op0, signmask,\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t  temp = expand_binop (mode, sub_optab, temp, signmask,\n+\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  mask = ((HOST_WIDE_INT) 1 << logd) - 1;\n+\t  temp = expand_binop (mode, and_optab, temp, GEN_INT (mask),\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t  temp = expand_binop (mode, xor_optab, temp, signmask,\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t  temp = expand_binop (mode, sub_optab, temp, signmask,\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t  return temp;\n+\t}\n+    }\n+\n+  /* Mask contains the mode's signbit and the significant bits of the\n+     modulus.  By including the signbit in the operation, many targets\n+     can avoid an explicit compare operation in the following comparison\n+     against zero.  */\n+\n+  mask = (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)\n+\t | (((HOST_WIDE_INT) 1 << logd) - 1);\n+\n+  temp = expand_binop (mode, and_optab, op0, GEN_INT (mask), result,\n+\t\t       1, OPTAB_LIB_WIDEN);\n+  if (temp != result)\n+    emit_move_insn (result, temp);\n+\n+  label = gen_label_rtx ();\n+  do_cmp_and_jump (result, const0_rtx, GE, mode, label);\n+\n+  temp = expand_binop (mode, sub_optab, result, const1_rtx, result,\n+\t\t       0, OPTAB_LIB_WIDEN);\n+  mask = (HOST_WIDE_INT) -1 << logd;\n+  temp = expand_binop (mode, ior_optab, temp, GEN_INT (mask), result,\n+\t\t       1, OPTAB_LIB_WIDEN);\n+  temp = expand_binop (mode, add_optab, temp, const1_rtx, result,\n+\t\t       0, OPTAB_LIB_WIDEN);\n+  if (temp != result)\n+    emit_move_insn (result, temp);\n+  emit_label (label);\n+  return result;\n+}\n \f\n /* Emit the code to divide OP0 by OP1, putting the result in TARGET\n    if that is convenient, and returning where the result is.\n@@ -3451,10 +3518,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n \t\t\t && (rem_flag ? smod_pow2_cheap[compute_mode]\n \t\t\t\t      : sdiv_pow2_cheap[compute_mode])\n-\t\t\t /* ??? The cheap metric is computed only for\n-\t\t\t    word_mode.  If this operation is wider, this may\n-\t\t\t    not be so.  Assume true if the optab has an\n-\t\t\t    expander for this mode.  */\n+\t\t\t /* We assume that cheap metric is true if the\n+\t\t\t    optab has an expander for this mode.  */\n \t\t\t && (((rem_flag ? smod_optab : sdiv_optab)\n \t\t\t      ->handlers[compute_mode].insn_code\n \t\t\t      != CODE_FOR_nothing)\n@@ -3463,6 +3528,12 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t  ;\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n \t\t  {\n+\t\t    if (rem_flag)\n+\t\t      {\n+\t\t\tremainder = expand_smod_pow2 (compute_mode, op0, d);\n+\t\t\tif (remainder)\n+\t\t\t  return gen_lowpart (mode, remainder);\n+\t\t      }\n \t\t    lgup = floor_log2 (abs_d);\n \t\t    if (BRANCH_COST < 1 || (abs_d != 2 && BRANCH_COST < 3))\n \t\t      {\n@@ -3496,8 +3567,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t\t tquotient, 0);\n \t\t      }\n \n-\t\t    /* We have computed OP0 / abs(OP1).  If OP1 is negative, negate\n-\t\t       the quotient.  */\n+\t\t    /* We have computed OP0 / abs(OP1).  If OP1 is negative,\n+\t\t       negate the quotient.  */\n \t\t    if (d < 0)\n \t\t      {\n \t\t\tinsn = get_last_insn ();"}]}