{"sha": "dda2da581957d0c0614197a7f0021c95c707f005", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhMmRhNTgxOTU3ZDBjMDYxNDE5N2E3ZjAwMjFjOTVjNzA3ZjAwNQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-09-23T16:29:38Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-23T16:29:38Z"}, "message": "re PR debug/41248 (VTA: Assertion at 2910 of cfgexpand.c (expand_debug_locations))\n\ngcc/ChangeLog:\nPR debug/41248\n* cfgexpand.c (convert_debug_memory_address): New.\n(expand_debug_expr): Convert base address and offset to the same\nmode.  Use it to convert addresses to other modes.  Accept\nptr_mode addresses.\ngcc/testsuite/ChangeLog:\nPR debug/41248\n* gcc.dg/pr41248.c: New.\n\nFrom-SVN: r152087", "tree": {"sha": "e387ca644e57ba37c6ba41648c7681b7f3ae5c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e387ca644e57ba37c6ba41648c7681b7f3ae5c2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dda2da581957d0c0614197a7f0021c95c707f005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda2da581957d0c0614197a7f0021c95c707f005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dda2da581957d0c0614197a7f0021c95c707f005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda2da581957d0c0614197a7f0021c95c707f005/comments", "author": null, "committer": null, "parents": [{"sha": "b646ba3f1c134c4fc22b000caff77725ccec1791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b646ba3f1c134c4fc22b000caff77725ccec1791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b646ba3f1c134c4fc22b000caff77725ccec1791"}], "stats": {"total": 99, "additions": 97, "deletions": 2}, "files": [{"sha": "22941d311abdc6b603f162cf608ec62a1fe02ba8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dda2da581957d0c0614197a7f0021c95c707f005", "patch": "@@ -1,3 +1,11 @@\n+2009-09-23  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41248\n+\t* cfgexpand.c (convert_debug_memory_address): New.\n+\t(expand_debug_expr): Convert base address and offset to the same\n+\tmode.  Use it to convert addresses to other modes.  Accept\n+\tptr_mode addresses.\n+\n 2009-09-23  Richard Guenther  <rguenther@suse.de>\n \n \t* alias.c (ao_ref_from_mem): Correct for negative MEM_OFFSET"}, {"sha": "f4a9f5e478c8f115261cac07c2aea128814e6e8e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=dda2da581957d0c0614197a7f0021c95c707f005", "patch": "@@ -2234,6 +2234,38 @@ unwrap_constant (rtx x)\n   return ret;\n }\n \n+/* Convert X to MODE, that must be Pmode or ptr_mode, without emitting\n+   any rtl.  */\n+\n+static rtx\n+convert_debug_memory_address (enum machine_mode mode, rtx x)\n+{\n+  enum machine_mode xmode = GET_MODE (x);\n+\n+#ifndef POINTERS_EXTEND_UNSIGNED\n+  gcc_assert (mode == Pmode);\n+  gcc_assert (xmode == mode || xmode == VOIDmode);\n+#else\n+  gcc_assert (mode == Pmode || mode == ptr_mode);\n+\n+  if (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode)\n+    return x;\n+\n+  if (GET_MODE_BITSIZE (mode) < GET_MODE_BITSIZE (xmode))\n+    x = simplify_gen_subreg (mode, x, xmode,\n+\t\t\t     subreg_lowpart_offset\n+\t\t\t     (mode, xmode));\n+  else if (POINTERS_EXTEND_UNSIGNED > 0)\n+    x = gen_rtx_ZERO_EXTEND (mode, x);\n+  else if (!POINTERS_EXTEND_UNSIGNED)\n+    x = gen_rtx_SIGN_EXTEND (mode, x);\n+  else\n+    gcc_unreachable ();\n+#endif /* POINTERS_EXTEND_UNSIGNED */\n+\n+  return x;\n+}\n+\n /* Return an RTX equivalent to the value of the tree expression\n    EXP.  */\n \n@@ -2410,6 +2442,7 @@ expand_debug_expr (tree exp)\n \treturn NULL;\n \n       gcc_assert (GET_MODE (op0) == Pmode\n+\t\t  || GET_MODE (op0) == ptr_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n \t\t  || GET_CODE (op0) == CONST_DOUBLE);\n \n@@ -2436,6 +2469,7 @@ expand_debug_expr (tree exp)\n \treturn NULL;\n \n       gcc_assert (GET_MODE (op0) == Pmode\n+\t\t  || GET_MODE (op0) == ptr_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n \t\t  || GET_CODE (op0) == CONST_DOUBLE);\n \n@@ -2468,13 +2502,32 @@ expand_debug_expr (tree exp)\n \n \tif (offset)\n \t  {\n+\t    enum machine_mode addrmode, offmode;\n+\n \t    gcc_assert (MEM_P (op0));\n \n+\t    op0 = XEXP (op0, 0);\n+\t    addrmode = GET_MODE (op0);\n+\t    if (addrmode == VOIDmode)\n+\t      addrmode = Pmode;\n+\n \t    op1 = expand_debug_expr (offset);\n \t    if (!op1)\n \t      return NULL;\n \n-\t    op0 = gen_rtx_MEM (mode, gen_rtx_PLUS (Pmode, XEXP (op0, 0), op1));\n+\t    offmode = GET_MODE (op1);\n+\t    if (offmode == VOIDmode)\n+\t      offmode = TYPE_MODE (TREE_TYPE (offset));\n+\n+\t    if (addrmode != offmode)\n+\t      op1 = simplify_gen_subreg (addrmode, op1, offmode,\n+\t\t\t\t\t subreg_lowpart_offset (addrmode,\n+\t\t\t\t\t\t\t\toffmode));\n+\n+\t    /* Don't use offset_address here, we don't need a\n+\t       recognizable address, and we don't want to generate\n+\t       code.  */\n+\t    op0 = gen_rtx_MEM (mode, gen_rtx_PLUS (addrmode, op0, op1));\n \t  }\n \n \tif (MEM_P (op0))\n@@ -2785,7 +2838,9 @@ expand_debug_expr (tree exp)\n       if (!op0 || !MEM_P (op0))\n \treturn NULL;\n \n-      return XEXP (op0, 0);\n+      op0 = convert_debug_memory_address (mode, XEXP (op0, 0));\n+\n+      return op0;\n \n     case VECTOR_CST:\n       exp = build_constructor_from_list (TREE_TYPE (exp),"}, {"sha": "4c8e14e3332f0a9fc5ac1bda6a81903816dd33ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dda2da581957d0c0614197a7f0021c95c707f005", "patch": "@@ -1,3 +1,8 @@\n+2009-09-23  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41248\n+\t* gcc.dg/pr41248.c: New.\n+\n  2009-09-23  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR debug/41065"}, {"sha": "0d5a74919ee6d64b9c426079ca64c0eddfe523ed", "filename": "gcc/testsuite/gcc.dg/pr41248.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41248.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda2da581957d0c0614197a7f0021c95c707f005/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41248.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41248.c?ref=dda2da581957d0c0614197a7f0021c95c707f005", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g\" } */\n+\n+struct __gcov_var {\n+   unsigned int offset;\n+   unsigned int buffer[(1 << 10) + 1];\n+} __gcov_var;\n+unsigned int * gcov_write_words (unsigned int words) {\n+   unsigned int *result;\n+   result = &__gcov_var.buffer[__gcov_var.offset];\n+   return result;\n+}\n+\n+struct gcov_ctr_summary { };\n+struct gcov_summary {\n+   unsigned int checksum;\n+   struct gcov_ctr_summary ctrs[1];\n+};\n+void __gcov_write_unsigned (unsigned int);\n+void __gcov_write_summary (unsigned int tag,\n+\t\t\t   const struct gcov_summary *summary)\n+{\n+   unsigned ix;\n+   const struct gcov_ctr_summary *csum;\n+   __gcov_write_unsigned (summary->checksum);\n+   for (csum = summary->ctrs, ix = 1; ix--; csum++) { }\n+}"}]}