{"sha": "685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1YzgzNDBmZjdiNWNmZWY3YmY0MWMzYjVlMGQ3OWFkN2Y3YTM3Yg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2015-11-10T02:23:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2015-11-10T02:23:34Z"}, "message": "PR c++/67913 - new expression with negative size not diagnosed\n\nPR c++/67913 - new expression with negative size not diagnosed\nPR c++/67927 - array new expression with excessive number of elements\n               not diagnosed \n\ngcc/cp/\n\t* call.c (build_operator_new_call): Do not assume size_check\n\tis non-null, analogously to the top half of the function.\n\t* init.c (build_new_1): Detect and diagnose array sizes in\n\texcess of the maximum of roughly SIZE_MAX / 2.\n\tInsert a runtime check only for arrays with a non-constant size.\n\t(build_new): Detect and diagnose negative array sizes.\n\ngcc/testsuite/\n\t* init/new45.C: New test to verify that operator new is invoked\n\twith or without overhead for a cookie.\n\t* init/new44.C: New test for placement new expressions for arrays\n\twith excessive number of elements.\n\t* init/new43.C: New test for placement new expressions for arrays\n\twith negative number of elements.\n\t* other/new-size-type.C: Expect array new expression with\n\tan excessive number of elements to be rejected.\n\nFrom-SVN: r230081", "tree": {"sha": "2e5bacc1d2b331365198e4be6156f26598c36370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e5bacc1d2b331365198e4be6156f26598c36370"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36fa0f5f6875c49560c15dbeaed2b3c95c26687a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36fa0f5f6875c49560c15dbeaed2b3c95c26687a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36fa0f5f6875c49560c15dbeaed2b3c95c26687a"}], "stats": {"total": 916, "additions": 896, "deletions": 20}, "files": [{"sha": "fee374a9953b631b3968133ed360038fa21d4dd9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -1,3 +1,14 @@\n+2015-10-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67913\n+\tPR c++/67927\n+\t* call.c (build_operator_new_call): Do not assume size_check\n+\tis non-null, analogously to the top half of the function.\n+\t* init.c (build_new_1): Detect and diagnose array sizes in\n+\texcess of the maximum of roughly SIZE_MAX / 2.\n+\tInsert a runtime check only for arrays with a non-constant size.\n+\t(build_new): Detect and diagnose negative array sizes.\n+\n 2015-11-09  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n \t    James Norris  <jnorris@codesourcery.com>"}, {"sha": "13d84384462f2bdf1182e125edf135f17b204f42", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -4235,10 +4235,13 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n \t {\n \t   /* Update the total size.  */\n \t   *size = size_binop (PLUS_EXPR, original_size, *cookie_size);\n-\t   /* Set to (size_t)-1 if the size check fails.  */\n-\t   gcc_assert (size_check != NULL_TREE);\n-\t   *size = fold_build3 (COND_EXPR, sizetype, size_check,\n-\t\t\t\t*size, TYPE_MAX_VALUE (sizetype));\n+\t   if (size_check)\n+\t     {\n+\t       /* Set to (size_t)-1 if the size check fails.  */\n+\t       gcc_assert (size_check != NULL_TREE);\n+\t       *size = fold_build3 (COND_EXPR, sizetype, size_check,\n+\t\t\t\t    *size, TYPE_MAX_VALUE (sizetype));\n+\t    }\n \t   /* Update the argument list to reflect the adjusted size.  */\n \t   (**args)[0] = *size;\n \t }"}, {"sha": "2e11acb6a67d0cc769f977187d62a71f72905061", "filename": "gcc/cp/init.c", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -2482,7 +2482,11 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n-   build_raw_new_expr.  This may change PLACEMENT and INIT.  */\n+   build_raw_new_expr.  This may change PLACEMENT and INIT.\n+   TYPE is the type of the object being constructed, possibly an array\n+   of NELTS elements when NELTS is non-null (in \"new T[NELTS]\", T may\n+   be an array of the form U[inner], with the whole expression being\n+   \"new U[NELTS][inner]\").  */\n \n static tree\n build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n@@ -2502,13 +2506,16 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n      type.)  */\n   tree pointer_type;\n   tree non_const_pointer_type;\n+  /* The most significant array bound in int[OUTER_NELTS][inner].  */\n   tree outer_nelts = NULL_TREE;\n-  /* For arrays, a bounds checks on the NELTS parameter. */\n+  /* For arrays with a non-constant number of elements, a bounds checks\n+     on the NELTS parameter to avoid integer overflow at runtime. */\n   tree outer_nelts_check = NULL_TREE;\n   bool outer_nelts_from_type = false;\n+  /* Number of the \"inner\" elements in \"new T[OUTER_NELTS][inner]\".  */\n   offset_int inner_nelts_count = 1;\n   tree alloc_call, alloc_expr;\n-  /* Size of the inner array elements. */\n+  /* Size of the inner array elements (those with constant dimensions). */\n   offset_int inner_size;\n   /* The address returned by the call to \"operator new\".  This node is\n      a VAR_DECL and is therefore reusable.  */\n@@ -2702,20 +2709,41 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t}\n \n       max_outer_nelts = wi::udiv_trunc (max_size, inner_size);\n-      /* Only keep the top-most seven bits, to simplify encoding the\n-\t constant in the instruction stream.  */\n-      {\n-\tunsigned shift = (max_outer_nelts.get_precision ()) - 7\n-\t  - wi::clz (max_outer_nelts);\n-\tmax_outer_nelts = wi::lshift (wi::lrshift (max_outer_nelts, shift),\n-\t\t\t\t      shift);\n-      }\n       max_outer_nelts_tree = wide_int_to_tree (sizetype, max_outer_nelts);\n \n       size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n-      outer_nelts_check = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t       outer_nelts,\n-\t\t\t\t       max_outer_nelts_tree);\n+\n+      if (TREE_CONSTANT (outer_nelts))\n+\t{\n+\t  if (tree_int_cst_lt (max_outer_nelts_tree, outer_nelts))\n+\t    {\n+\t      /* When the array size is constant, check it at compile time\n+\t\t to make sure it doesn't exceed the implementation-defined\n+\t\t maximum, as required by C++ 14 (in C++ 11 this requirement\n+\t\t isn't explicitly stated but it's enforced anyway -- see\n+\t\t grokdeclarator in cp/decl.c).  */\n+\t      if (complain & tf_error)\n+\t\terror (\"size of array is too large\");\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else\n+ \t{\n+\t  /* When a runtime check is necessary because the array size\n+\t     isn't constant, keep only the top-most seven bits (starting\n+\t     with the most significant non-zero bit) of the maximum size\n+\t     to compare the array size against, to simplify encoding the\n+\t     constant maximum size in the instruction stream.  */\n+\n+\t  unsigned shift = (max_outer_nelts.get_precision ()) - 7\n+\t    - wi::clz (max_outer_nelts);\n+\t  max_outer_nelts = wi::lshift (wi::lrshift (max_outer_nelts, shift),\n+\t\t\t\t        shift);\n+\n+          outer_nelts_check = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   outer_nelts,\n+\t\t\t\t\t   max_outer_nelts_tree);\n+\t}\n     }\n \n   alloc_fn = NULL_TREE;\n@@ -3290,6 +3318,23 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n           else\n             return error_mark_node;\n         }\n+\n+      /* Try to determine the constant value only for the purposes\n+\t of the diagnostic below but continue to use the original\n+\t value and handle const folding later.  */\n+      const_tree cst_nelts = maybe_constant_value (nelts);\n+\n+      /* The expression in a noptr-new-declarator is erroneous if it's of\n+\t non-class type and its value before converting to std::size_t is\n+\t less than zero. ... If the expression is a constant expression,\n+\t the program is ill-fomed.  */\n+      if (TREE_CONSTANT (cst_nelts) && tree_int_cst_sgn (cst_nelts) == -1)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"size of array is negative\");\n+\t  return error_mark_node;\n+\t}\n+\n       nelts = mark_rvalue_use (nelts);\n       nelts = cp_save_expr (cp_convert (sizetype, nelts, complain));\n     }"}, {"sha": "a6f6ed839978f24dd0e52ee53b30b33900a58a89", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -1,3 +1,19 @@\n+2015-10-19  Martin Sebor  <msebor@redhat.com>\n+\n+\t* init/new45.C: New test to verify that operator new is invoked\n+\twith or without overhead for a cookie.\n+\n+\tPR c++/67927\n+\t* init/new44.C: New test for placement new expressions for arrays\n+\twith excessive number of elements.\n+\n+\tPR c++/67913\n+\t* init/new43.C: New test for placement new expressions for arrays\n+\twith negative number of elements.\n+\n+\t* other/new-size-type.C: Expect array new expression with\n+\tan excessive number of elements to be rejected.\n+\n 2015-11-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-c++-common/goacc/routine-1.c: New."}, {"sha": "9b0866720fe13658b2458e22e70f5729236a77ee", "filename": "gcc/testsuite/g++.dg/init/new43.C", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew43.C?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do compile } */\n+\n+// Test for PR c++/67913 - new expression with negative size not diagnosed.\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void*);\n+void* operator new[] (size_t, void*);\n+\n+struct A {\n+    int a [4];\n+};\n+\n+struct B {\n+    int a [4];\n+\n+    void* operator new (size_t, void*);\n+    void* operator new[] (size_t, void*);\n+};\n+\n+void* operator new (size_t, B*);\n+void* operator new[] (size_t, B*);\n+\n+void *p;\n+\n+void test_literal ()\n+{\n+    char c;\n+    (void)c;\n+\n+    B b;\n+\n+    // Verify integer literal.\n+    p = new char [-1];           // { dg-error \"size of array is negative\" }\n+    p = new char [2][-3];        // { dg-error \"size of array is negative\" }\n+    p = new char [-4][5];        // { dg-error \"size of array is negative\" }\n+    p = new char [-6][-7];       // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) char [-1];       // { dg-error \"size of array is negative\" }\n+    p = new (p) char [2][-3];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [-4][5];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [-6][-7];   // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) A [-1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) A [2][-3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [-4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [-6][-7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) B [-1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) B [2][-3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [-4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [-6][-7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (&b) B [-1];          // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [2][-3];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [-4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [-6][-7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new char [1 - 2];         // { dg-error \"size of array is negative\" }\n+    p = new (p) char [2 - 3];     // { dg-error \"size of array is negative\" }\n+    p = new A [2 < 1 ? -1 : -2];  // { dg-error \"size of array is negative\" }\n+    p = new (p) B [2 - 3 * 2];    // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [1][2 - 3 * 2];// { dg-error \"size of array is negative\" }\n+}\n+\n+void test_constant_expression ()\n+{\n+    char c;\n+    (void)c;\n+\n+    B b;\n+\n+    static const signed char i1 = -1;\n+    static const signed short i2 = -2;\n+    static const signed int i3 = -3;\n+    static const signed long i4 = -4;\n+    static const signed long long i5 = -5;\n+    static const int i6 = -6;\n+    static const int i7 = -7;\n+\n+    // Verify constant expression.\n+    p = new char [i1];           // { dg-error \"size of array is negative\" }\n+    p = new char [2][i3];        // { dg-error \"size of array is negative\" }\n+    p = new char [i4][5];        // { dg-error \"size of array is negative\" }\n+    p = new char [i6][i7];       // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) char [i1];       // { dg-error \"size of array is negative\" }\n+    p = new (p) char [2][i3];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [i4][5];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [i6][i7];   // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) A [i1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) A [2][i3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [i4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [i6][i7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) B [i1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) B [2][i3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [i4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [i6][i7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (&b) B [i1];          // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [2][i3];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [i4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [i6][i7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new short [i1 - 2];       // { dg-error \"size of array is negative\" }\n+    p = new (p) bool [i2 - 3];    // { dg-error \"size of array is negative\" }\n+    p = new A [2 < 1 ? i1 : i2];  // { dg-error \"size of array is negative\" }\n+    p = new (p) B [2 + i3 * 2];   // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [1][i1 - 3 * 2];// { dg-error \"size of array is negative\" }\n+}\n+\n+void test_constexpr ()\n+{\n+    B b;\n+\n+#if __cplusplus >= 201103L\n+\n+    // Verify that a constant expression that is \"a prvalue core constant\n+    // expression whose value is an object where, for that object and its\n+    // subobjects each non-static data member of reference type refers to\n+    // an object with static storage duration.\"\n+    static constexpr struct S {\n+        int i_;\n+        constexpr S (int i): i_ (i) { }\n+        constexpr operator int () const { return i_; }\n+    } s1 (-1), s2 (-2), s3 (-3), s4 (-4), s5 (-5), s6 (-6), s7 (-7);\n+#else\n+    // C++ 11 constexpr is not available, fall back on plain ole enum.\n+    enum { s1 = -1, s2 = -2, s3 = -3, s4 = -4, s5 = -5, s6 = -6, s7 = -7 };\n+#endif\n+\n+    // Verify constant expression.\n+    p = new char [s1];           // { dg-error \"size of array is negative\" }\n+    p = new char [2][s3];        // { dg-error \"size of array is negative\" }\n+    p = new char [s4][5];        // { dg-error \"size of array is negative\" }\n+    p = new char [s6][s7];       // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) char [s1];       // { dg-error \"size of array is negative\" }\n+    p = new (p) char [2][s3];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [s4][5];    // { dg-error \"size of array is negative\" }\n+    p = new (p) char [s6][s7];   // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) A [s1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) A [2][s3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [s4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) A [s6][s7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (p) B [s1];          // { dg-error \"size of array is negative\" }\n+    p = new (p) B [2][s3];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [s4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (p) B [s6][s7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new (&b) B [s1];          // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [2][s3];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [s4][5];       // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [s6][s7];      // { dg-error \"size of array is negative\" }\n+\n+    p = new int [s1 + s2];           // { dg-error \"size of array is negative\" }\n+    p = new (p) long [2 * s3];       // { dg-error \"size of array is negative\" }\n+    p = new A [s2 < s1 ? s1 : s2];   // { dg-error \"size of array is negative\" }\n+    p = new (p) B [s7 - s2 * 2];     // { dg-error \"size of array is negative\" }\n+    p = new (&b) B [9][s4 - s1 * 2]; // { dg-error \"size of array is negative\" }\n+}"}, {"sha": "d6ff86a16c70296e2451f9393f60acf3b4ecd68d", "filename": "gcc/testsuite/g++.dg/init/new44.C", "status": "added", "additions": 532, "deletions": 0, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew44.C?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -0,0 +1,532 @@\n+// { dg-do compile }\n+\n+// Test for PR c++/67927 - array new expression with excessive number\n+// of elements not diagnosed.\n+\n+// GCC uses a different maximum value at compile time and at runtime:\n+// 1) The compile-time maximum, MAX, is SIZE_MAX / 2 minus the size\n+//    of a cookie (sizeof (size_t)).  Exceeding the compile-time\n+//    maximum is ill-formed and diagnosed.  This test verifies this\n+//    diagnostic.\n+// 2) The runtime runtime maximum is the most significant 7 bits,\n+//    starting with the first most significant non-zero bit, of\n+//    the dividend of the compile-time constant MAX and the product\n+//    of the constant array dimensions and the element size, minus\n+//    the size of the \"cookie.\"  This is also roughly (though not\n+//    exactly) SIZE_MAX / 2.  Exceeding the runtime maximum is\n+//    diagnosed at runtime by throwing a bad_array_new_length\n+//    exception.\n+//    The cookie is the number of elements in the array, and is\n+//    only added for non-POD types, but the its size factors into\n+//    the maximum size formula regardless.\n+\n+// See also PR c++/19351 - integer overflow in operator new[].\n+\n+// For convenience.\n+#define MAX __SIZE_MAX__\n+\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void*);\n+void* operator new[] (size_t, void*);\n+\n+void *p;\n+\n+// Exercise new expression with one-dimensional arrays of char.\n+static void __attribute__ ((used))\n+test_one_dim_char_array ()\n+{\n+    p = new char [MAX];                 // { dg-error \"size of array\" }\n+    p = new char [MAX - 1];             // { dg-error \"size of array\" }\n+    p = new char [MAX - 2];             // { dg-error \"size of array\" }\n+    p = new char [MAX - 99];            // { dg-error \"size of array\" }\n+    p = new char [MAX / 2];             // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 1];         // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 2];         // { dg-error \"size of array\" }\n+\n+    // Avoid testing the expressions below since whether or not they\n+    // are accepted depends on the precision of size_t (which also\n+    // determines the size of the cookie).\n+    // p = new char [MAX / 2 - 3];\n+    // p = new char [MAX / 2 - 4];\n+    // p = new char [MAX / 2 - 5];\n+    // p = new char [MAX / 2 - 6];\n+\n+    // The following expressions are accepted on ILP32 as well LP64\n+    // (they will be diagnosed on LP128 if there ever is such a data\n+    // model).\n+    p = new char [MAX / 2 - 7];         // okay\n+    p = new char [MAX / 2 - 8];         // okay\n+}\n+\n+static void __attribute__ ((used))\n+test_one_dim_short_array ()\n+{\n+    p = new short [MAX];                // { dg-error \"size of array\" }\n+    p = new short [MAX - 1];            // { dg-error \"size of array\" }\n+    p = new short [MAX - 2];            // { dg-error \"size of array\" }\n+    p = new short [MAX - 99];           // { dg-error \"size of array\" }\n+    p = new short [MAX / 2];            // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 1];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 2];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 3];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 4];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 5];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 6];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 7];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 2 - 8];        // { dg-error \"size of array\" }\n+    p = new short [MAX / 4];            // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new short [MAX / 4 - 1];\n+\n+    p = new short [MAX / 4 - 4];        // okay\n+}\n+\n+// Exercise new expression with two-dimensional arrays or char.\n+static void __attribute__ ((used))\n+test_two_dim_char_array ()\n+{\n+    p = new char [1][MAX];              // { dg-error \"size of array\" }\n+    p = new char [1][MAX - 1];          // { dg-error \"size of array\" }\n+    p = new char [1][MAX - 2];          // { dg-error \"size of array\" }\n+    p = new char [1][MAX - 99];         // { dg-error \"size of array\" }\n+    p = new char [1][MAX / 2];          // { dg-error \"size of array\" }\n+    p = new char [1][MAX / 2 - 1];      // { dg-error \"size of array\" }\n+    p = new char [1][MAX / 2 - 2];      // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [1][MAX / 2 - 3];\n+    // p = new char [1][MAX / 2 - 4];\n+    // p = new char [1][MAX / 2 - 5];\n+    // p = new char [1][MAX / 2 - 6];\n+\n+    p = new char [1][MAX / 2 - 7];      // okay\n+    p = new char [1][MAX / 2 - 8];      // okay\n+\n+    p = new char [2][MAX];              // { dg-error \"size of array\" }\n+    p = new char [2][MAX - 1];          // { dg-error \"size of array\" }\n+    p = new char [2][MAX - 2];          // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2];          // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 1];      // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 2];      // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 7];      // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 8];      // { dg-error \"size of array\" }\n+\n+    p = new char [MAX][MAX];            // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX - 1];        // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX - 2];        // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2];        // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2 - 1];    // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2 - 2];    // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2 - 7];    // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2 - 8];    // { dg-error \"size of array\" }\n+    p = new char [MAX][2];              // { dg-error \"size of array\" }\n+    p = new char [MAX][1];              // { dg-error \"size of array\" }\n+    p = new char [MAX / 2][1];          // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 1][1];      // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 2][1];      // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [MAX / 2 - 3][1];\n+    // p = new char [MAX / 2 - 4][1];\n+    // p = new char [MAX / 2 - 5][1];\n+    // p = new char [MAX / 2 - 6][1];\n+\n+    p = new char [MAX / 2 - 7][1];      // okay\n+    p = new char [MAX / 2 - 8][1];      // okay\n+}\n+\n+\n+// Exercise new expression with three-dimensional arrays.\n+static __attribute__ ((used)) void\n+test_three_dim_char_array ()\n+{\n+    p = new char [1][1][MAX];           // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX - 1];       // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX - 2];       // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX - 99];      // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX / 2];       // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX / 2 - 1];   // { dg-error \"size of array\" }\n+    p = new char [1][1][MAX / 2 - 2];   // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [1][1][MAX / 2 - 3];\n+    // p = new char [1][1][MAX / 2 - 4];\n+    // p = new char [1][1][MAX / 2 - 5];\n+    // p = new char [1][1][MAX / 2 - 6];\n+\n+    p = new char [1][1][MAX / 2 - 7];   // okay\n+    p = new char [1][1][MAX / 2 - 8];   // okay\n+\n+    p = new char [1][2][MAX];           // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX - 1];       // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX - 2];       // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX - 99];      // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2];       // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 1];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 2];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 3];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 4];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 5];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 6];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 7];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 2 - 8];   // { dg-error \"size of array\" }\n+    p = new char [1][2][MAX / 4];       // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [1][2][MAX / 4 - 1];\n+    // p = new char [1][2][MAX / 4 - 2];\n+\n+    p = new char [1][2][MAX / 4 - 3];   // okay\n+    p = new char [1][2][MAX / 4 - 4];   // okay\n+\n+    p = new char [2][1][MAX];           // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX - 1];       // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX - 2];       // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX - 99];      // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2];       // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 1];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 2];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 3];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 4];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 5];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 6];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 7];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 2 - 8];   // { dg-error \"size of array\" }\n+    p = new char [2][1][MAX / 4];       // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [2][1][MAX / 4 - 1];\n+    // p = new char [2][1][MAX / 4 - 2];\n+\n+    p = new char [2][1][MAX / 4 - 3];   // okay\n+    p = new char [2][1][MAX / 4 - 4];   // okay\n+\n+    p = new char [2][2][MAX];           // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX - 1];       // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX - 2];       // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX - 99];      // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2];       // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 1];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 2];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 3];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 4];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 5];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 6];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 7];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 2 - 8];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 4];       // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 4 - 1];   // { dg-error \"size of array\" }\n+    p = new char [2][2][MAX / 4 - 2];   // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [2][2][MAX / 8];\n+    // p = new char [2][2][MAX / 8 - 1];\n+\n+    p = new char [2][2][MAX / 8 - 2];\n+    p = new char [2][2][MAX / 8 - 3];\n+\n+    p = new char [2][MAX][2];           // { dg-error \"size of array\" }\n+    p = new char [2][MAX - 1][2];       // { dg-error \"size of array\" }\n+    p = new char [2][MAX - 2][2];       // { dg-error \"size of array\" }\n+    p = new char [2][MAX - 99][2];      // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2][2];       // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 1][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 2][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 3][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 4][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 5][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 6][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 7][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 2 - 8][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 4][2];       // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 4 - 1][2];   // { dg-error \"size of array\" }\n+    p = new char [2][MAX / 4 - 2][2];   // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [2][MAX / 8][2];\n+    // p = new char [2][MAX / 8 - 1][2];\n+\n+    p = new char [2][MAX / 8 - 2][2];\n+    p = new char [2][MAX / 8 - 3][2];\n+\n+    p = new char [MAX][2][2];           // { dg-error \"size of array\" }\n+    p = new char [MAX - 1][2][2];       // { dg-error \"size of array\" }\n+    p = new char [MAX - 2][2][2];       // { dg-error \"size of array\" }\n+    p = new char [MAX - 99][2][2];      // { dg-error \"size of array\" }\n+    p = new char [MAX / 2][2][2];       // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 1][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 2][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 3][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 4][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 5][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 6][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 7][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 2 - 8][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 4][2][2];       // { dg-error \"size of array\" }\n+    p = new char [MAX / 4 - 1][2][2];   // { dg-error \"size of array\" }\n+    p = new char [MAX / 4 - 2][2][2];   // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new char [MAX / 8][2][2];\n+    // p = new char [MAX / 8 - 1][2][2];\n+\n+    p = new char [MAX / 8 - 2][2][2];\n+    p = new char [MAX / 8 - 3][2][2];\n+\n+    p = new char [MAX][MAX][MAX];         // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX][MAX / 2];     // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2][MAX];     // { dg-error \"size of array\" }\n+    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error \"size of array\" }\n+    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error \"size of array\" }\n+}\n+\n+// Exercise new expression with N-dimensional arrays where N is\n+// sizeof(size_t).\n+static __attribute__ ((used)) void\n+test_N_dim_char_array ()\n+{\n+#if __SIZEOF_SIZE_T__ == 8\n+    enum { N = 256 };\n+#else\n+    enum { N = 16 };\n+#endif\n+\n+    p = new char        [N][N][N][N][N][N][N];\n+    p = new char [N / 2][2][N][N][N][N][N][N];\n+    p = new char [N - 1][N / 2][N][N][N][N][N][N];\n+    p = new char [N / 2][N][N][N][N][N][N][N];  // { dg-error \"size of array\" }\n+    p = new char [N - 1][N][N][N][N][N][N][N];  // { dg-error \"size of array\" }\n+    p = new char [N]    [N][N][N][N][N][N][N];  // { dg-error \"size of array\" }\n+}\n+\n+typedef struct Byte {\n+    char c;\n+\n+    void* operator new (size_t, void*);\n+    void* operator new[] (size_t, void*);\n+} B;\n+\n+void* operator new (size_t, B*);\n+void* operator new[] (size_t, B*);\n+\n+// Exercise placement new expression with one-dimensional arrays of a struct.\n+static void __attribute__ ((used))\n+test_one_dim_byte_array (void *p)\n+{\n+    p = new (p) B [MAX];                // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 1];            // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 2];            // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 99];           // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2];            // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 1];        // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 2];        // { dg-error \"size of array\" }\n+\n+    // Avoid testing the expressions below since whether or not they\n+    // are accepted depends on the precision of size_t (which determines\n+    // the size of the cookie).\n+    // p = new (p) B [MAX / 2 - 3];\n+    // p = new (p) B [MAX / 2 - 4];\n+    // p = new (p) B [MAX / 2 - 5];\n+    // p = new (p) B [MAX / 2 - 6];\n+\n+    // The following expressions are accepted on ILP32 as well LP64\n+    // (they will be diagnosed on LP128 if there ever is such a data\n+    // model).\n+    p = new (p) B [MAX / 2 - 7];         // okay\n+    p = new (p) B [MAX / 2 - 8];         // okay\n+}\n+\n+// Exercise placement new expression with two-dimensional arrays.\n+static void __attribute__ ((used))\n+test_placement_two_dim_byte_struct_array (void *p)\n+{\n+    p = new (p) B [1][MAX];             // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX - 1];         // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX - 2];         // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX - 99];        // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX / 2];         // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX / 2 - 1];     // { dg-error \"size of array\" }\n+    p = new (p) B [1][MAX / 2 - 2];     // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [1][MAX / 2 - 3];\n+    // p = new (p) B [1][MAX / 2 - 4];\n+    // p = new (p) B [1][MAX / 2 - 5];\n+    // p = new (p) B [1][MAX / 2 - 6];\n+\n+    p = new (p) B [1][MAX / 2 - 7];      // okay\n+    p = new (p) B [1][MAX / 2 - 8];      // okay\n+\n+    p = new (p) B [2][MAX];             // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX - 1];         // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX - 2];         // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2];         // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 1];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 2];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 7];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 8];     // { dg-error \"size of array\" }\n+\n+    p = new (p) B [MAX][MAX];           // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX - 1];       // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX - 2];       // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX / 2];       // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX / 2 - 1];   // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX / 2 - 2];   // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX / 2 - 7];   // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][MAX / 2 - 8];   // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][2];             // { dg-error \"size of array\" }\n+    p = new (p) B [MAX][1];             // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2][1];         // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 1][1];     // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 2][1];     // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [MAX / 2 - 3][1];\n+    // p = new (p) B [MAX / 2 - 4][1];\n+    // p = new (p) B [MAX / 2 - 5][1];\n+    // p = new (p) B [MAX / 2 - 6][1];\n+\n+    p = new (p) B [MAX / 2 - 7][1];      // okay\n+    p = new (p) B [MAX / 2 - 8][1];      // okay\n+}\n+\n+\n+// Exercise placement new expression with three-dimensional arrays.\n+static __attribute__ ((used)) void\n+test_placement_three_dim_byte_struct_array (void *p)\n+{\n+    p = new (p) B [1][1][MAX];          // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX - 1];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX - 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX - 99];     // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX / 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX / 2 - 1];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][1][MAX / 2 - 2];  // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [1][1][MAX / 2 - 3];\n+    // p = new (p) B [1][1][MAX / 2 - 4];\n+    // p = new (p) B [1][1][MAX / 2 - 5];\n+    // p = new (p) B [1][1][MAX / 2 - 6];\n+\n+    p = new (p) B [1][1][MAX / 2 - 7];   // okay\n+    p = new (p) B [1][1][MAX / 2 - 8];   // okay\n+\n+    p = new (p) B [1][2][MAX];          // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX - 1];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX - 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX - 99];     // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error \"size of array\" }\n+    p = new (p) B [1][2][MAX / 4];      // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [1][2][MAX / 4 - 1];\n+    // p = new (p) B [1][2][MAX / 4 - 2];\n+\n+    p = new (p) B [1][2][MAX / 4 - 3];   // okay\n+    p = new (p) B [1][2][MAX / 4 - 4];   // okay\n+\n+    p = new (p) B [2][1][MAX];          // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX - 1];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX - 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX - 99];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 1];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 3];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 4];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 5];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 6];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 7];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 2 - 8];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][1][MAX / 4];      // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [2][1][MAX / 4 - 1];\n+    // p = new (p) B [2][1][MAX / 4 - 2];\n+\n+    p = new (p) B [2][1][MAX / 4 - 3];   // okay\n+    p = new (p) B [2][1][MAX / 4 - 4];   // okay\n+\n+    p = new (p) B [2][2][MAX];          // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX - 1];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX - 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX - 99];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 4];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 4 - 1];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][2][MAX / 4 - 2];  // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [2][2][MAX / 8];\n+    // p = new (p) B [2][2][MAX / 8 - 1];\n+\n+    p = new (p) B [2][2][MAX / 8 - 2];\n+    p = new (p) B [2][2][MAX / 8 - 3];\n+\n+    p = new (p) B [2][MAX][2];          // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX - 1][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX - 2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX - 99][2];     // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 4][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 4 - 1][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [2][MAX / 4 - 2][2];  // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [2][MAX / 8][2];\n+    // p = new (p) B [2][MAX / 8 - 1][2];\n+\n+    p = new (p) B [2][MAX / 8 - 2][2];\n+    p = new (p) B [2][MAX / 8 - 3][2];\n+\n+    p = new (p) B [MAX][2][2];          // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 1][2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 2][2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [MAX - 99][2][2];     // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2][2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 1][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 2][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 3][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 4][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 5][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 6][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 7][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 2 - 8][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 4][2][2];      // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 4 - 1][2][2];  // { dg-error \"size of array\" }\n+    p = new (p) B [MAX / 4 - 2][2][2];  // { dg-error \"size of array\" }\n+\n+    // Avoid exercising data model-dependent expressions.\n+    // p = new (p) B [MAX / 8][2][2];\n+    // p = new (p) B [MAX / 8 - 1][2][2];\n+\n+    p = new (p) B [MAX / 8 - 2][2][2];\n+    p = new (p) B [MAX / 8 - 3][2][2];\n+}"}, {"sha": "92dac18a32e7950f52160b122b557b9a0e148d1e", "filename": "gcc/testsuite/g++.dg/init/new45.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew45.C?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -0,0 +1,106 @@\n+// { dg-do compile }\n+// { dg-options \"-O1\" }\n+// { dg-final { scan-assembler-not \"abort\" } }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" {\n+    void abort ();\n+    void* malloc (size_t);\n+}\n+\n+struct UDClass {\n+    static int n;\n+    UDClass () { ++n; }\n+    virtual ~UDClass () { --n; }\n+};\n+\n+int UDClass::n;\n+\n+struct POD {\n+    char buf [sizeof (UDClass)];\n+};\n+\n+enum { N = 123 };\n+\n+inline __attribute__ ((always_inline))\n+void* operator new[] (size_t n)\n+{\n+    // Verify that array new is invoked with an argument large enough\n+    // for the array and a size_t cookie to store the number of elements.\n+    // (This holds for classes with user-defined types but not POD types).\n+    if (n != N * sizeof (UDClass) + sizeof n) abort ();\n+    return malloc (n);\n+}\n+\n+inline __attribute__ ((always_inline))\n+void* operator new[] (size_t n, void *p)\n+{\n+    // Verify that the default placement array new is invoked with\n+    // an argument just large enough for the array (and no cookie),\n+    // regardless of whether the type is a POD or class with a user\n+    // defined ctor.\n+    if (n != N * sizeof (UDClass)) abort ();\n+    return p;\n+}\n+\n+inline __attribute__ ((always_inline))\n+void* operator new[] (size_t n, POD *p)\n+{\n+    // Verify that placement array new overload for a POD type is\n+    // invoked with an argument large enough for the array and\n+    // a cookie.\n+    if (n != N * sizeof (POD)) abort ();\n+    return p;\n+}\n+\n+inline __attribute__ ((always_inline))\n+void* operator new[] (size_t n, UDClass *p)\n+{\n+    // Verify that placement array new overload for a class type with\n+    // a user-defined ctor and dtor is invoked with an argument large\n+    // enough for the array and a cookie.\n+    if (n != N * sizeof (UDClass) + sizeof n) abort ();\n+    return p;\n+}\n+\n+// UDClassllocate a sufficiently large buffer to construct arrays into.\n+static unsigned char buf [N * N];\n+\n+POD* test_new_POD ()\n+{\n+    // Avoid testing PODs since for those, the global new is invoked\n+    // without the overhead of a cookie.\n+    // return new POD [N];\n+    return 0;\n+}\n+\n+POD* test_default_placement_new_POD ()\n+{\n+    // Vefify that no overhead is allocated.\n+    return new (buf) POD [N];\n+}\n+\n+POD* test_overloaded_placement_new_POD ()\n+{\n+    // Vefify that no overhead is allocated.\n+    return new ((POD*)buf) POD [N];\n+}\n+\n+UDClass* test_new_UDClass ()\n+{\n+    // Vefify that space for a cookie is allocated.\n+    return new UDClass [N];\n+}\n+\n+UDClass* test_default_placement_new_UDClass ()\n+{\n+    // Vefify that no overhead is allocated.\n+    return new (buf) UDClass [N];\n+}\n+\n+UDClass* test_overloaded_placement_new_UDClass ()\n+{\n+    // Vefify that space for a cookie is allocated.\n+    return new ((UDClass*)buf) UDClass [N];\n+}"}, {"sha": "ad4dc102c3bd0518bba89cc2255b1cda7c9732d2", "filename": "gcc/testsuite/g++.dg/other/new-size-type.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnew-size-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnew-size-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnew-size-type.C?ref=685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "patch": "@@ -5,6 +5,5 @@\n const char*\n foo()\n {\n-    return new char[~static_cast<size_t>(0)];// { dg-bogus \"large\" }\n+    return new char[~static_cast<size_t>(0)];// { dg-error \"size of array\" }\n }\n-"}]}