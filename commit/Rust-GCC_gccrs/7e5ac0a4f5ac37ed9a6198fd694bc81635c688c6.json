{"sha": "7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1YWMwYTRmNWFjMzdlZDlhNjE5OGZkNjk0YmM4MTYzNWM2ODhjNg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-09-14T19:50:20Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-09-14T19:50:20Z"}, "message": "hashtable.h (_Hashtable<>::_M_rehash): Take and restore hash policy _M_prev_resize on exception.\n\n2011-09-14  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash): Take and restore\n\thash policy _M_prev_resize on exception.\n\t(_Hashtable<>::_M_insert_bucket): Capture hash policy next resize\n\tbefore using it and use latter method to have it restored on exception.\n\t(_Hashtable<>::_M_insert(_Arg&& __v, std::false_type): Likewise.\n\t(_Hashtable<>::insert(_InputIterator, _InputIterator): Likewise.\n\t(_Hashtable<>::rehash): Likewise.\n\t* testsuite/23_containers/unordered_set/insert/hash_policy.cc: New.\n\t* testsuite/23_containers/unordered_multiset/insert/hash_policy.cc:\n\tLikewise.\n\n\nCo-Authored-By: Paolo Carlini <paolo.carlini@oracle.com>\n\nFrom-SVN: r178861", "tree": {"sha": "e57293aee651dc24fd4a5d2b5324dcce635cc539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e57293aee651dc24fd4a5d2b5324dcce635cc539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/comments", "author": null, "committer": null, "parents": [{"sha": "700cf92e7575733adbc4a8200b602179a3194a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700cf92e7575733adbc4a8200b602179a3194a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700cf92e7575733adbc4a8200b602179a3194a16"}], "stats": {"total": 260, "additions": 237, "deletions": 23}, "files": [{"sha": "8de9659bf88fe99d41b77951182d5cebe07d64c3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "patch": "@@ -1,3 +1,17 @@\n+2011-09-14  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash): Take and restore\n+\thash policy _M_prev_resize on exception.\n+\t(_Hashtable<>::_M_insert_bucket): Capture hash policy next resize\n+\tbefore using it and use latter method to have it restored on exception.\n+\t(_Hashtable<>::_M_insert(_Arg&& __v, std::false_type): Likewise.\n+\t(_Hashtable<>::insert(_InputIterator, _InputIterator): Likewise.\n+\t(_Hashtable<>::rehash): Likewise.\n+\t* testsuite/23_containers/unordered_set/insert/hash_policy.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/insert/hash_policy.cc:\n+\tLikewise.\n+\n 2011-09-13  Paul Brook  <paul@codesourcery.com>\n  \n \t* libsupc++/eh_arm.cc (__cxa_end_cleanup): Add C6X implementation."}, {"sha": "b097ee78cb56dbf57a38987682be2944aae3d47b", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "patch": "@@ -458,8 +458,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // reserve, if present, comes from _Rehash_base.\n \n     private:\n-      // Unconditionally change size of bucket array to n.\n-      void _M_rehash(size_type __n);\n+      // Unconditionally change size of bucket array to n, restore hash policy\n+      // resize value to __next_resize on exception.\n+      void _M_rehash(size_type __n, size_type __next_resize);\n     };\n \n \n@@ -743,7 +744,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_rehash_policy = __pol;\n       size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n       if (__n_bkt > _M_bucket_count)\n-\t_M_rehash(__n_bkt);\n+\t_M_rehash(__n_bkt, __pol._M_next_resize);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -910,6 +911,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_insert_bucket(_Arg&& __v, size_type __n,\n \t\t       typename _Hashtable::_Hash_code_type __code)\n       {\n+\tconst size_type __saved_next_resize = _M_rehash_policy._M_next_resize;\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n@@ -920,14 +922,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n \t  }\n \n-\t// Allocate the new node before doing the rehash so that we don't\n-\t// do a rehash if the allocation throws.\n-\t_Node* __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n-\n+\t_Node* __new_node = 0;\n \t__try\n \t  {\n+\t    // Allocate the new node before doing the rehash so that we\n+\t    // don't do a rehash if the allocation throws.\n+\t    __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n \t    if (__do_rehash.first)\n-\t      _M_rehash(__do_rehash.second);\n+\t      _M_rehash(__do_rehash.second, __saved_next_resize);\n \n \t    __new_node->_M_next = _M_buckets[__n];\n \t    this->_M_store_code(__new_node, __code);\n@@ -939,7 +941,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_deallocate_node(__new_node);\n+\t    if (!__new_node)\n+\t      _M_rehash_policy._M_next_resize = __saved_next_resize;\n+\t    else\n+\t      _M_deallocate_node(__new_node);\n \t    __throw_exception_again;\n \t  }\n       }\n@@ -981,11 +986,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n       _M_insert(_Arg&& __v, std::false_type)\n       {\n+\tconst size_type __saved_next_resize = _M_rehash_policy._M_next_resize;\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \tif (__do_rehash.first)\n-\t  _M_rehash(__do_rehash.second);\n+\t  _M_rehash(__do_rehash.second, __saved_next_resize);\n \n \tconst key_type& __k = this->_M_extract(__v);\n \ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n@@ -1024,11 +1030,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       insert(_InputIterator __first, _InputIterator __last)\n       {\n \tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tconst size_type __saved_next_resize = _M_rehash_policy._M_next_resize;\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, __n_elt);\n \tif (__do_rehash.first)\n-\t  _M_rehash(__do_rehash.second);\n+\t  _M_rehash(__do_rehash.second, __saved_next_resize);\n \n \tfor (; __first != __last; ++__first)\n \t  this->insert(*__first);\n@@ -1184,9 +1191,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     rehash(size_type __n)\n     {\n+      const size_type __saved_next_resize = _M_rehash_policy._M_next_resize;\n       _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n \t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n-\t\t\t\t\t\t\t      + 1)));\n+\t\t\t\t\t\t\t      + 1)),\n+\t\t__saved_next_resize);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1196,11 +1205,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_rehash(size_type __n)\n+    _M_rehash(size_type __n, size_type __next_resize)\n     {\n-      _Node** __new_array = _M_allocate_buckets(__n);\n+      _Node** __new_array = 0;\n       __try\n \t{\n+\t  __new_array = _M_allocate_buckets(__n);\n \t  _M_begin_bucket_index = __n;\n \t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n \t    while (_Node* __p = _M_buckets[__i])\n@@ -1218,15 +1228,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       __catch(...)\n \t{\n-\t  // A failure here means that a hash function threw an exception.\n-\t  // We can't restore the previous state without calling the hash\n-\t  // function again, so the only sensible recovery is to delete\n-\t  // everything.\n-\t  _M_deallocate_nodes(__new_array, __n);\n-\t  _M_deallocate_buckets(__new_array, __n);\n-\t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n-\t  _M_element_count = 0;\n-\t  _M_begin_bucket_index = _M_bucket_count;\n+\t  if (__new_array)\n+\t    {\n+\t      // A failure here means that a hash function threw an exception.\n+\t      // We can't restore the previous state without calling the hash\n+\t      // function again, so the only sensible recovery is to delete\n+\t      // everything.\n+\t      _M_deallocate_nodes(__new_array, __n);\n+\t      _M_deallocate_buckets(__new_array, __n);\n+\t      _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+\t      _M_element_count = 0;\n+\t      _M_begin_bucket_index = _M_bucket_count;\n+\t      _M_rehash_policy._M_next_resize = 0;\n+\t    }\n+\t  else\n+\t    // A failure here means that buckets allocation failed.  We only\n+\t    // have to restore hash policy previous state.\n+\t    _M_rehash_policy._M_next_resize = __next_resize;\n \t  __throw_exception_again;\n \t}\n     }"}, {"sha": "0950c13c80fc83aa39c0996bfc5a9dfe95cfab1c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/hash_policy.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fhash_policy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fhash_policy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fhash_policy.cc?ref=7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <limits>\n+#include <ext/throw_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::numeric_limits<size_t> nl_size_t;\n+  std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t  __gnu_cxx::throw_allocator_limit<int> > us;\n+  const int nb = 100;\n+  int scheduled_throw_counter = 0;\n+  std::size_t thrown_exceptions = 0;\n+  for (int i = 0; i != nb; ++i)\n+    {\n+      if ((float)(us.size() + 1)\n+\t  / (float)us.bucket_count() >= us.max_load_factor())\n+\t{\n+\t  // We are going to need a rehash, lets introduce allocation issues:\n+\t  __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n+\t}\n+      try\n+\t{\n+\t  us.insert(i / 2);\n+\t  scheduled_throw_counter = 0;\n+\t}\n+      catch (const __gnu_cxx::forced_error&)\n+\t{\n+\t  ++thrown_exceptions;\n+\t  --i;\n+\t}\n+      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      __gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n+    }\n+\n+  VERIFY( thrown_exceptions != 0 );\n+  // Check that all values have been inserted:\n+  for (int i = 0; i != nb / 2; ++i)\n+    {\n+      VERIFY( us.count(i) == 2 );\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3d3f55abc782dfd47706590acce18cdc36834938", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/hash_policy.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc?ref=7e5ac0a4f5ac37ed9a6198fd694bc81635c688c6", "patch": "@@ -0,0 +1,113 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <vector>\n+#include <limits>\n+#include <ext/throw_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::numeric_limits<std::size_t> nl_size_t;\n+  std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t     __gnu_cxx::throw_allocator_limit<int> > us;\n+  const int nb = 100;\n+  int scheduled_throw_counter = 0;\n+  std::size_t thrown_exceptions = 0;\n+  for (int i = 0; i != nb; ++i)\n+    {\n+      if ((float)(us.size() + 1)\n+\t  / (float)us.bucket_count() >= us.max_load_factor())\n+\t{\n+\t  // We are going to need a rehash, lets introduce allocation issues:\n+\t  __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n+\t}\n+      try\n+\t{\n+\t  VERIFY(us.insert(i).second);\n+\t  scheduled_throw_counter = 0;\n+\t}\n+      catch (const __gnu_cxx::forced_error&)\n+\t{\n+\t  ++thrown_exceptions;\n+\t  --i;\n+\t}\n+      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      __gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n+    }\n+\n+  VERIFY( thrown_exceptions != 0 );\n+  // Check that all values have been inserted:\n+  for (int i = 0; i != nb; ++i)\n+    {\n+      VERIFY( us.count(i) == 1 );\n+    }\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::numeric_limits<std::size_t> nl_size_t;\n+  std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t     __gnu_cxx::throw_allocator_limit<int> > us;\n+  const int nb = 100;\n+  int scheduled_throw_counter = 0;\n+  std::size_t thrown_exceptions = 0;\n+  for (int i = 0; i != nb; ++i)\n+    {\n+      if ((float)(us.size() + 2)\n+\t  / (float)us.bucket_count() >= us.max_load_factor())\n+\t{\n+\t  // We are going to need a rehash, lets introduce allocation issues:\n+\t  __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n+\t}\n+      try\n+\t{\n+\t  std::vector<int> v = { i, i };\n+\t  // Check the insert range robustness\n+\t  us.insert(v.begin(), v.end());\n+\t  scheduled_throw_counter = 0;\n+\t}\n+      catch (const __gnu_cxx::forced_error&)\n+\t{\n+\t  ++thrown_exceptions;\n+\t  --i;\n+\t}\n+      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      __gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n+    }\n+\n+  VERIFY( thrown_exceptions != 0 );\n+  // Check that all values have been inserted:\n+  for (int i = 0; i != nb; ++i)\n+    {\n+      VERIFY( us.count(i) == 1 );\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}