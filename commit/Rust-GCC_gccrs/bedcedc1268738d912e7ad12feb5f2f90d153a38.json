{"sha": "bedcedc1268738d912e7ad12feb5f2f90d153a38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkY2VkYzEyNjg3MzhkOTEyZTdhZDEyZmViNWYyZjkwZDE1M2EzOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-01T05:59:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-01T05:59:35Z"}, "message": "compiler: Fix handling of indirection of circular types.\n\nFrom-SVN: r184686", "tree": {"sha": "3796fd8ead0dc2f1f8429200607e9b225820f1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3796fd8ead0dc2f1f8429200607e9b225820f1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bedcedc1268738d912e7ad12feb5f2f90d153a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedcedc1268738d912e7ad12feb5f2f90d153a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bedcedc1268738d912e7ad12feb5f2f90d153a38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedcedc1268738d912e7ad12feb5f2f90d153a38/comments", "author": null, "committer": null, "parents": [{"sha": "ce842ad6cdd96ec4475cd81b6258ae3c6c46f771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce842ad6cdd96ec4475cd81b6258ae3c6c46f771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce842ad6cdd96ec4475cd81b6258ae3c6c46f771"}], "stats": {"total": 40, "additions": 22, "deletions": 18}, "files": [{"sha": "a2097e002eb078eeb4b06c6bdf4465861e05468d", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedcedc1268738d912e7ad12feb5f2f90d153a38/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedcedc1268738d912e7ad12feb5f2f90d153a38/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=bedcedc1268738d912e7ad12feb5f2f90d153a38", "patch": "@@ -4705,29 +4705,33 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t// need to check for nil.  We don't bother to check for small\n \t// structs because we expect the system to crash on a nil\n \t// pointer dereference.\n-\tHOST_WIDE_INT s = int_size_in_bytes(TREE_TYPE(TREE_TYPE(expr)));\n-\tif (s == -1 || s >= 4096)\n+\ttree target_type_tree = TREE_TYPE(TREE_TYPE(expr));\n+\tif (!VOID_TYPE_P(target_type_tree))\n \t  {\n-\t    if (!DECL_P(expr))\n-\t      expr = save_expr(expr);\n-\t    tree compare = fold_build2_loc(loc.gcc_location(), EQ_EXPR,\n-                                           boolean_type_node,\n-\t\t\t\t\t   expr,\n-\t\t\t\t\t   fold_convert(TREE_TYPE(expr),\n-\t\t\t\t\t\t\tnull_pointer_node));\n-\t    tree crash = Gogo::runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n-\t\t\t\t\t     loc);\n-\t    expr = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-                                   TREE_TYPE(expr), build3(COND_EXPR,\n-                                                           void_type_node,\n-                                                           compare, crash,\n-                                                           NULL_TREE),\n-\t\t\t\t   expr);\n+\t    HOST_WIDE_INT s = int_size_in_bytes(target_type_tree);\n+\t    if (s == -1 || s >= 4096)\n+\t      {\n+\t\tif (!DECL_P(expr))\n+\t\t  expr = save_expr(expr);\n+\t\ttree compare = fold_build2_loc(loc.gcc_location(), EQ_EXPR,\n+\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       expr,\n+\t\t\t\t\t       fold_convert(TREE_TYPE(expr),\n+\t\t\t\t\t\t\t    null_pointer_node));\n+\t\ttree crash = Gogo::runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t\t\t\t loc);\n+\t\texpr = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n+\t\t\t\t       TREE_TYPE(expr), build3(COND_EXPR,\n+\t\t\t\t\t\t\t       void_type_node,\n+\t\t\t\t\t\t\t       compare, crash,\n+\t\t\t\t\t\t\t       NULL_TREE),\n+\t\t\t\t       expr);\n+\t      }\n \t  }\n \n \t// If the type of EXPR is a recursive pointer type, then we\n \t// need to insert a cast before indirecting.\n-\tif (TREE_TYPE(TREE_TYPE(expr)) == ptr_type_node)\n+\tif (VOID_TYPE_P(target_type_tree))\n \t  {\n \t    Type* pt = this->expr_->type()->points_to();\n \t    tree ind = type_to_tree(pt->get_backend(context->gogo()));"}]}