{"sha": "81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmZDRjNmViMzNmMDhlNmE2MjY4MGZiYjE3OGVmM2JjMGIyZDk0OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T21:48:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T21:48:14Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r910", "tree": {"sha": "fa2abd66df2398e473b872d1f8625e22a2492845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa2abd66df2398e473b872d1f8625e22a2492845"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948/comments", "author": null, "committer": null, "parents": [{"sha": "4be1e76885aa25d8ac1c103f9f2e05924530007e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be1e76885aa25d8ac1c103f9f2e05924530007e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4be1e76885aa25d8ac1c103f9f2e05924530007e"}], "stats": {"total": 392, "additions": 279, "deletions": 113}, "files": [{"sha": "f535989fcbff505b7d173ed012eb116c893c4b27", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 279, "deletions": 113, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=81fd4c6eb33f08e6a62680fbb178ef3bc0b2d948", "patch": "@@ -90,9 +90,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n \n-static struct obstack obstack, obstack1;\n+static struct obstack obstack, obstack1, obstack2;\n struct obstack *rtl_obstack = &obstack;\n struct obstack *hash_obstack = &obstack1;\n+struct obstack *temp_obstack = &obstack2;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -233,7 +234,7 @@ static rtx true_rtx, false_rtx;\n \n /* Used to reduce calls to `strcmp' */\n \n-static char *alternative_name = \"alternative\";\n+static char *alternative_name;\n \n /* Simplify an expression.  Only call the routine if there is something to\n    simplify.  */\n@@ -250,14 +251,15 @@ static rtx attr_rtx ();\n static char *attr_printf ();\n static char *attr_string ();\n static rtx check_attr_test ();\n-static void check_attr_value ();\n+static rtx check_attr_value ();\n static rtx convert_set_attr_alternative ();\n static rtx convert_set_attr ();\n static void check_defs ();\n static rtx convert_const_symbol_ref ();\n static rtx make_canonical ();\n static struct attr_value *get_attr_value ();\n static rtx copy_rtx_unchanging ();\n+static rtx copy_boolean ();\n static void expand_delays ();\n static rtx operate_exp ();\n static void expand_units ();\n@@ -375,8 +377,13 @@ attr_hash_add_string (hashcode, str)\n   attr_hash_table[hashcode % RTL_HASH_SIZE] = h;\n }\n \n-/* Generate an RTL expression, but allow sharing.  Like gen_rtx, but the \n-   mode is not used:\n+/* Generate an RTL expression, but avoid duplicates.\n+   Set the RTX_INTEGRATED_P flag for these permanent objects.\n+\n+   In some cases we cannot uniquify; then we return an ordinary\n+   impermanent rtx with RTX_INTEGRATED_P clear.\n+\n+   Args are like gen_rtx, but without the mode:\n \n    rtx attr_rtx (code, [element1, ..., elementn])  */\n \n@@ -405,6 +412,15 @@ attr_rtx (va_alist)\n     {\n       rtx arg0 = va_arg (p, rtx);\n \n+      /* A permanent object cannot point to impermanent ones.  */\n+      if (! RTX_INTEGRATED_P (arg0))\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XEXP (rt_val, 0) = arg0;\n+\t  va_end (p);\n+\t  return rt_val;\n+\t}\n+\n       hashcode = ((int) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n@@ -426,6 +442,16 @@ attr_rtx (va_alist)\n       rtx arg0 = va_arg (p, rtx);\n       rtx arg1 = va_arg (p, rtx);\n \n+      /* A permanent object cannot point to impermanent ones.  */\n+      if (! RTX_INTEGRATED_P (arg0) || ! RTX_INTEGRATED_P (arg1))\n+\t{\n+\t  rt_val = rtx_alloc (code);\n+\t  XEXP (rt_val, 0) = arg0;\n+\t  XEXP (rt_val, 1) = arg1;\n+\t  va_end (p);\n+\t  return rt_val;\n+\t}\n+\n       hashcode = ((int) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n@@ -447,6 +473,9 @@ attr_rtx (va_alist)\n     {\n       char * arg0 = va_arg (p, char *);\n \n+      if (code == SYMBOL_REF)\n+\targ0 = attr_string (arg0, strlen (arg0));\n+\n       hashcode = ((int) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n@@ -465,8 +494,8 @@ attr_rtx (va_alist)\n \t   && GET_RTX_FORMAT (code)[0] == 's'\n \t   && GET_RTX_FORMAT (code)[1] == 's')\n     {\n-      char * arg0 = va_arg (p, char *);\n-      char * arg1 = va_arg (p, char *);\n+      char *arg0 = va_arg (p, char *);\n+      char *arg1 = va_arg (p, char *);\n \n       hashcode = ((int) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n@@ -484,8 +513,18 @@ attr_rtx (va_alist)\n \t  XSTR (rt_val, 1) = arg1;\n \t}\n     }\n+  else if (code == CONST_INT)\n+    {\n+      int arg0 = va_arg (p, int);\n+      if (arg0 == 0)\n+\treturn false_rtx;\n+      if (arg0 == 1)\n+\treturn true_rtx;\n+      goto nohash;\n+    }\n   else\n     {\n+    nohash:\n       rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n       \n       fmt = GET_RTX_FORMAT (code);\t/* Find the right format...  */\n@@ -524,6 +563,7 @@ attr_rtx (va_alist)\n   rtl_obstack = old_obstack;\n   va_end (p);\n   attr_hash_add_rtx (hashcode, rt_val);\n+  RTX_INTEGRATED_P (rt_val) = 1;\n   return rt_val;\n \n  found:\n@@ -577,6 +617,21 @@ attr_printf (len, fmt, arg1, arg2, arg3)\n }\n #endif /* not HAVE_VPRINTF */\n \n+rtx\n+attr_eq (name, value)\n+     char *name, *value;\n+{\n+  return attr_rtx (EQ_ATTR, attr_string (name, strlen (name)),\n+\t\t   attr_string (value, strlen (value)));\n+}\n+\n+char *\n+attr_numeral (n)\n+     int n;\n+{\n+  return XSTR (make_numeric_value (n), 0);\n+}\n+\n /* Return a permanent (possibly shared) copy of a string STR (not assumed\n    to be null terminated) with LEN bytes.  */\n \n@@ -599,7 +654,7 @@ attr_string (str, len)\n \n   /* Search the table for the string.  */\n   for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n-    if (h->hashcode == -hashcode\n+    if (h->hashcode == -hashcode && h->u.str[0] == str[0]\n \t&& !strncmp (h->u.str, str, len))\n       return h->u.str;\t\t\t/* <-- return if found.  */\n \n@@ -611,6 +666,88 @@ attr_string (str, len)\n \n   return new_str;\t\t\t/* Return the new string.  */\n }\n+\n+/* Check two rtx's for equality of contents,\n+   taking advantage of the fact that if both are hashed\n+   then they can't be equal unless they are the same object.  */\n+\n+int\n+attr_equal_p (x, y)\n+     rtx x, y;\n+{\n+  return (x == y || (! (RTX_INTEGRATED_P (x) && RTX_INTEGRATED_P (y))\n+\t\t     && rtx_equal_p (x, y)));\n+}\n+\f\n+/* Copy an attribute value expression,\n+   descending to all depths, but not copying any\n+   permanent hashed subexpressions.  */\n+\n+rtx\n+attr_copy_rtx (orig)\n+     register rtx orig;\n+{\n+  register rtx copy;\n+  register int i, j;\n+  register RTX_CODE code;\n+  register char *format_ptr;\n+\n+  /* No need to copy a permanent object.  */\n+  if (RTX_INTEGRATED_P (orig))\n+    return orig;\n+\n+  code = GET_CODE (orig);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return orig;\n+    }\n+\n+  copy = rtx_alloc (code);\n+  PUT_MODE (copy, GET_MODE (orig));\n+  copy->in_struct = orig->in_struct;\n+  copy->volatil = orig->volatil;\n+  copy->unchanging = orig->unchanging;\n+  copy->integrated = orig->integrated;\n+  \n+  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  if (XEXP (orig, i) != NULL)\n+\t    XEXP (copy, i) = attr_copy_rtx (XEXP (orig, i));\n+\t  break;\n+\n+\tcase 'E':\n+\tcase 'V':\n+\t  XVEC (copy, i) = XVEC (orig, i);\n+\t  if (XVEC (orig, i) != NULL)\n+\t    {\n+\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t      for (j = 0; j < XVECLEN (copy, i); j++)\n+\t\tXVECEXP (copy, i, j) = attr_copy_rtx (XVECEXP (orig, i, j));\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  XINT (copy, i) = XINT (orig, i);\n+\t  break;\n+\t}\n+    }\n+  return copy;\n+}\n \f\n /* Given a test expression for an attribute, ensure it is validly formed.\n    IS_CONST indicates whether the expression is constant for each compiler\n@@ -642,9 +779,8 @@ check_attr_test (exp, is_const)\n       /* Handle negation test.  */\n       if (XSTR (exp, 1)[0] == '!')\n \treturn check_attr_test (attr_rtx (NOT,\n-\t\t\t\t\t  attr_rtx (EQ_ATTR,\n-\t\t\t\t\t\t    XSTR (exp, 0),\n-\t\t\t\t\t\t    &XSTR(exp, 1)[1])),\n+\t\t\t\t\t  attr_eq (XSTR (exp, 0),\n+\t\t\t\t\t\t   &XSTR (exp, 1)[1])),\n \t\t\t\tis_const);\n \n       else if (n_comma_elts (XSTR (exp, 1)) == 1)\n@@ -667,7 +803,9 @@ check_attr_test (exp, is_const)\n \t    fatal (\"Constant expression uses insn attribute `%s' in EQ_ATTR\",\n \t\t   XEXP (exp, 0));\n \n-\t  XSTR (exp, 0) = attr->name;\n+\t  /* Copy this just to make it permanent,\n+\t     so expressions using it can be permanent too.  */\n+\t  exp = attr_eq (XSTR (exp, 0), XSTR (exp, 1));\n \n \t  if (attr->is_numeric)\n \t    {\n@@ -695,7 +833,7 @@ check_attr_test (exp, is_const)\n \t  name_ptr = XSTR (exp, 1);\n \t  while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t    {\n-\t      newexp = attr_rtx (EQ_ATTR, XSTR (exp, 0), p);\n+\t      newexp = attr_eq (XSTR (exp, 0), p);\n \t      orexp = insert_right_side (IOR, orexp, newexp, -2);\n \t    }\n \n@@ -724,10 +862,18 @@ check_attr_test (exp, is_const)\n       if (is_const)\n \tfatal (\"RTL operator \\\"%s\\\" not valid in constant attribute test\",\n \t       GET_RTX_NAME (MATCH_OPERAND));\n+      /* These cases can't be simplified.  */\n+      RTX_UNCHANGING_P (exp) = 1;\n+      break;\n \n     case LE:  case LT:  case GT:  case GE:\n     case LEU: case LTU: case GTU: case GEU:\n     case NE:  case EQ:\n+      if (GET_CODE (XEXP (exp, 0)) == SYMBOL_REF\n+\t  && GET_CODE (XEXP (exp, 1)) == SYMBOL_REF)\n+\texp = attr_rtx (GET_CODE (exp),\n+\t\t\tattr_rtx (SYMBOL_REF, XSTR (XEXP (exp, 0), 0)),\n+\t\t\tattr_rtx (SYMBOL_REF, XSTR (XEXP (exp, 1), 0)));\n       /* These cases can't be simplified.  */\n       RTX_UNCHANGING_P (exp) = 1;\n       break;\n@@ -737,7 +883,7 @@ check_attr_test (exp, is_const)\n \t{\n \t  /* These cases are valid for constant attributes, but can't be\n \t     simplified.  */\n-\t  exp = copy_rtx (exp);\n+\t  exp = attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n \t  RTX_UNCHANGING_P (exp) = 1;\n \t  break;\n \t}\n@@ -751,9 +897,11 @@ check_attr_test (exp, is_const)\n \f\n /* Given an expression, ensure that it is validly formed and that all named\n    attribute values are valid for the given attribute.  Issue a fatal error\n-   if not.  If no attribute is specified, assume a numeric attribute.  */\n+   if not.  If no attribute is specified, assume a numeric attribute.\n \n-static void\n+   Return a perhaps modified replacement expression for the value.  */\n+\n+static rtx\n check_attr_value (exp, attr)\n      rtx exp;\n      struct attr_desc *attr;\n@@ -797,14 +945,14 @@ check_attr_value (exp, attr)\n \tfatal (\"Unknown value `%s' for `%s' attribute\",\n \t       XSTR (exp, 0), attr ? attr->name : \"internal\");\n \n-      return;\n+      break;\n \n     case IF_THEN_ELSE:\n       XEXP (exp, 0) = check_attr_test (XEXP (exp, 0),\n \t\t\t\t       attr ? attr->is_const : 0);\n-      check_attr_value (XEXP (exp, 1), attr);\n-      check_attr_value (XEXP (exp, 2), attr);\n-      return;\n+      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n+      XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n+      break;\n \n     case COND:\n       if (XVECLEN (exp, 0) % 2 != 0)\n@@ -814,23 +962,26 @@ check_attr_value (exp, attr)\n \t{\n \t  XVECEXP (exp, 0, i) = check_attr_test (XVECEXP (exp, 0, i),\n \t\t\t\t\t\t attr ? attr->is_const : 0);\n-\t  check_attr_value (XVECEXP (exp, 0, i + 1), attr);\n+\t  XVECEXP (exp, 0, i + 1)\n+\t    = check_attr_value (XVECEXP (exp, 0, i + 1), attr);\n \t}\n \n-      check_attr_value (XEXP (exp, 1), attr);\n-      return;\n+      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n+      break;\n \n     case SYMBOL_REF:\n       if (attr && attr->is_const)\n \t/* A constant SYMBOL_REF is valid as a constant attribute test and\n \t   is expanded later by make_canonical into a COND.  */\n-\treturn;\n+\treturn attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n       /* Otherwise, fall through... */\n \n     default:\n       fatal (\"Illegal operation `%s' for attribute value\",\n \t     GET_RTX_NAME (GET_CODE (exp)));\n     }\n+\n+  return exp;\n }\n \f\n /* Given an SET_ATTR_ALTERNATIVE expression, convert to the canonical SET.\n@@ -858,12 +1009,15 @@ convert_set_attr_alternative (exp, num_alt, insn_code, insn_index)\n   for (i = 0; i < num_alt - 1; i++)\n     {\n       char *p;\n-      p = attr_printf (3, \"%d\", i);\n+      p = attr_numeral (i);\n \n+      XVECEXP (condexp, 0, 2 * i) = attr_eq (alternative_name, p);\n+#if 0\n       /* Sharing this EQ_ATTR rtl causes trouble.  */   \n       XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ_ATTR);\n       XSTR (XVECEXP (condexp, 0, 2 * i), 0) = alternative_name;\n       XSTR (XVECEXP (condexp, 0, 2 * i), 1) = p;\n+#endif\n       XVECEXP (condexp, 0, 2 * i + 1) = XVECEXP (exp, 1, i);\n     }\n \n@@ -955,7 +1109,7 @@ check_defs ()\n \t\t   XSTR (XEXP (value, 0), 0), id->insn_index);\n \n \t  XVECEXP (id->def, id->vec_idx, i) = value;\n-\t  check_attr_value (XEXP (value, 1), attr);\n+\t  XEXP (value, 1) = check_attr_value (XEXP (value, 1), attr);\n \t}\n     }\n }\n@@ -987,23 +1141,24 @@ convert_const_symbol_ref (exp, attr)\n \n   for (i = num_alt - 2; av = av->next, i >= 0; i--)\n     {\n-      char * p;\n+      char *p, *string;\n       rtx value;\n \n-      XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ);\n-      XEXP (XVECEXP (condexp, 0, 2 * i), 0) = exp;\n-      XEXP (XVECEXP (condexp, 0, 2 * i), 1) = value = rtx_alloc (SYMBOL_REF);\n-      RTX_UNCHANGING_P (value) = 1;\n-      XSTR (value, 0) = p = (char *) xmalloc (2\n-\t\t\t\t\t      + strlen (attr->name)\n-\t\t\t\t\t      + strlen (XSTR (av->value, 0)));\n+      string = p = (char *) xmalloc (2\n+\t\t\t\t     + strlen (attr->name)\n+\t\t\t\t     + strlen (XSTR (av->value, 0)));\n       strcpy (p, attr->name);\n       strcat (p, \"_\");\n       strcat (p, XSTR (av->value, 0));\n       for (; *p != '\\0'; p++)\n \tif (*p >= 'a' && *p <= 'z')\n \t  *p -= 'a' - 'A';\n \n+      value = attr_rtx (SYMBOL_REF, string);\n+      RTX_UNCHANGING_P (value) = 1;\n+      \n+      XVECEXP (condexp, 0, 2 * i) = attr_eq (exp, value);\n+\n       XVECEXP (condexp, 0, 2 * i + 1) = av->value;\n     }\n \n@@ -1044,7 +1199,7 @@ make_canonical (attr, exp)\n \tbreak;\n       exp = convert_const_symbol_ref (exp, attr);\n       RTX_UNCHANGING_P (exp) = 1;\n-      check_attr_value (exp, attr);\n+      exp = check_attr_value (exp, attr);\n       /* Goto COND case since this is now a COND.  Note that while the\n          new expression is rescanned, all symbol_ref notes are mared as\n \t unchanging.  */\n@@ -1074,6 +1229,7 @@ make_canonical (attr, exp)\n \n \tfor (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t  {\n+\t    XVECEXP (exp, 0, i) = copy_boolean (XVECEXP (exp, 0, i));\n \t    XVECEXP (exp, 0, i + 1)\n \t      = make_canonical (attr, XVECEXP (exp, 0, i + 1));\n \t    if (! rtx_equal_p (XVECEXP (exp, 0, i + 1), defval))\n@@ -1087,6 +1243,16 @@ make_canonical (attr, exp)\n \n   return exp;\n }\n+\n+static rtx\n+copy_boolean (exp)\n+     rtx exp;\n+{\n+  if (GET_CODE (exp) == AND || GET_CODE (exp) == IOR)\n+    return attr_rtx (GET_CODE (exp), copy_boolean (XEXP (exp, 0)),\n+\t\t     copy_boolean (XEXP (exp, 1)));\n+  return exp;\n+}\n \f\n /* Given a value and an attribute description, return a `struct attr_value *'\n    that represents that value.  This is either an existing structure, if the\n@@ -1437,7 +1603,7 @@ expand_units ()\n \t     and busy cost.  Then make an attribute for use in the conflict\n \t     function.  */\n \t  op->condexp = check_attr_test (op->condexp, 0);\n-\t  check_attr_value (op->busyexp, 0);\n+\t  op->busyexp = check_attr_value (op->busyexp, 0);\n \t  str = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n \t\t\t     unit->name, op->num);\n \t  make_internal_attr (str, make_canonical (0, op->busyexp));\n@@ -1704,24 +1870,23 @@ simplify_cond (exp, insn_code, insn_index)\n   char *spacer, *first_spacer;\n \n   /* This lets us free all storage allocated below, if appropriate.  */\n-  first_spacer = (char *) obstack_next_free (rtl_obstack);\n+  first_spacer = (char *) obstack_finish (rtl_obstack);\n \n   bcopy (&XVECEXP (exp, 0, 0), tests, len * sizeof (rtx));\n \n   /* See if default value needs simplification.  */\n   if (GET_CODE (defval) == COND)\n     new_defval = simplify_cond (defval, insn_code, insn_index);\n \n-  /* Simplify now, just to see what tests we can get rid of.  */\n+  /* Simplify the subexpressions, and see what tests we can get rid of.  */\n \n-  /* Work from back to front, so if all values match the default,\n-     we get rid of all of them.  */\n-  for (i = len - 2; i >= 0; i -= 2)\n+  for (i = 0; i < len; i += 2)\n     {\n       rtx newtest, newval;\n \n       /* Simplify this test.  */\n       newtest = SIMPLIFY_TEST_EXP (tests[i], insn_code, insn_index);\n+      tests[i] = newtest;\n \n       newval = tests[i + 1];\n       /* See if this value may need simplification.  */\n@@ -1743,78 +1908,64 @@ simplify_cond (exp, insn_code, insn_index)\n \t  /* If test is false, discard it and its value.  */\n \t  for (j = i; j < len - 2; j++)\n \t    tests[j] = tests[j + 2];\n+\t  len -= 2;\n+\t}\n \n+      else if (i > 0 && attr_equal_p (newval, tests[i - 1]))\n+\t{\n+\t  /* If this value and the value for the prev test are the same,\n+\t     merge the tests.  */\n+\n+\t  tests[i - 2]\n+\t    = insert_right_side (IOR, tests[i - 2], newtest,\n+\t\t\t\t insn_code, insn_index);\n+\n+\t  /* Delete this test/value.  */\n+\t  for (j = i; j < len - 2; j++)\n+\t    tests[j] = tests[j + 2];\n \t  len -= 2;\n \t}\n \n-      /* If this is the last condition in a COND and our value is the same\n-\t as the default value, our test isn't needed.  */\n-      else if (i == len - 2 && rtx_equal_p (newval, new_defval))\n-\tlen -= 2;\n+      else\n+\ttests[i + 1] = newval;\n     }\n \n-  obstack_free (rtl_obstack, first_spacer);\n+  /* If the last test in a COND has the same value\n+     as the default value, that test isn't needed.  */\n+\n+  while (len > 0 && attr_equal_p (tests[len - 1], new_defval))\n+    len -= 2;\n+\n+  /* See if we changed anything.  */\n+  if (len != XVECLEN (exp, 0) || new_defval != XEXP (exp, 1))\n+    allsame = 0;\n+  else\n+    for (i = 0; i < len; i++)\n+      if (! attr_equal_p (tests[i], XVECEXP (exp, 0, i)))\n+\t{\n+\t  allsame = 0;\n+\t  break;\n+\t}\n \n   if (len == 0)\n     {\n+      obstack_free (rtl_obstack, first_spacer);\n       if (GET_CODE (defval) == COND)\n \treturn simplify_cond (defval, insn_code, insn_index);\n       return defval;\n     }\n+  else if (allsame)\n+    {\n+      obstack_free (rtl_obstack, first_spacer);\n+      return exp;\n+    }\n   else\n     {\n-      rtx newexp;\n-\n-      /* Simplify again, for real this time.  */\n-\n-      if (GET_CODE (defval) == COND)\n-\tdefval = simplify_cond (defval, insn_code, insn_index);\n-\n-      for (i = len - 2; i >= 0; i -= 2)\n-\t{\n-\t  /* See if this value may need simplification.  */\n-\t  if (GET_CODE (tests[i + 1]) == COND)\n-\t    tests[i + 1] = simplify_cond (tests[i + 1], insn_code, insn_index);\n-\n-\t  /* Simplify this test.  */\n-\t  tests[i] = SIMPLIFY_TEST_EXP (tests[i], insn_code, insn_index);\n-\n-\t  /* If this value and the value for the next test are the same, merge the\n-\t     tests.  */\n-\t  if (i != len - 2\n-\t      && rtx_equal_p (tests[i + 1], tests[i + 3]))\n-\t    {\n-\t      /* Merge following test into this one.  */\n-\t      tests[i]\n-\t\t= insert_right_side (IOR, tests[i], tests[i + 2],\n-\t\t\t\t     insn_code, insn_index);\n-\n-\t      /* Delete the following test/value.  */\n-\t      for (j = i + 2; j < len - 2; j++)\n-\t\ttests[j] = tests[j + 2];\n-\t      len -= 2;\n-\t    }\n-\t}\n-\n-      /* See if we changed anything.  */\n-      if (len != XVECLEN (exp, 0) || defval != XEXP (exp, 1))\n-\tallsame = 0;\n-      else\n-\tfor (i = 0; i < len; i++)\n-\t  if (! rtx_equal_p (tests[i], XVECEXP (exp, 0, i)))\n-\t    {\n-\t      allsame = 0;\n-\t      break;\n-\t    }\n-\n-      if (allsame)\n-\treturn exp;\n-\n-      newexp = rtx_alloc (COND);\n+      rtx newexp = rtx_alloc (COND);\n \n       XVEC (newexp, 0) = rtvec_alloc (len);\n       bcopy (tests, &XVECEXP (newexp, 0, 0), len * sizeof (rtx));\n-      XEXP (newexp, 1) = defval;\n+      XEXP (newexp, 1) = new_defval;\n       return newexp;\n     }\n }\n@@ -1891,7 +2042,7 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n     return true_rtx;\n   if (code == IOR && exp == false_rtx)\n     return term;\n-  if (rtx_equal_p (exp, term))\n+  if (attr_equal_p (exp, term))\n     return exp;\n \n   if (GET_CODE (term) == code)\n@@ -1968,9 +2119,7 @@ make_alternative_compare (mask)\n   for (i = 0; (mask & (1 << i)) == 0; i++)\n     ;\n \n-  alternative = attr_printf (3, \"%d\", i);\n-\n-  newexp = attr_rtx (EQ_ATTR, alternative_name, alternative);\n+  newexp = attr_rtx (EQ_ATTR, alternative_name, attr_numeral (i));\n   RTX_UNCHANGING_P (newexp) = 1;\n \n   return newexp;\n@@ -2174,23 +2323,23 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \n   else if (GET_CODE (exp) == NOT && GET_CODE (*pterm) == NOT)\n     {\n-      if (rtx_equal_p (XEXP (exp, 0), XEXP (*pterm, 0)))\n+      if (attr_equal_p (XEXP (exp, 0), XEXP (*pterm, 0)))\n \treturn true_rtx;\n     }\n \n   else if (GET_CODE (exp) == NOT)\n     {\n-      if (rtx_equal_p (XEXP (exp, 0), *pterm))\n+      if (attr_equal_p (XEXP (exp, 0), *pterm))\n \treturn false_rtx;\n     }\n \n   else if (GET_CODE (*pterm) == NOT)\n     {\n-      if (rtx_equal_p (XEXP (*pterm, 0), exp))\n+      if (attr_equal_p (XEXP (*pterm, 0), exp))\n \treturn false_rtx;\n     }\n \n-  else if (rtx_equal_p (exp, *pterm))\n+  else if (attr_equal_p (exp, *pterm))\n     return true_rtx;\n \n   return exp;\n@@ -2244,13 +2393,13 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \t}\n     }\n \n-  if (rtx_equal_p (exp, *pterm))\n+  if (attr_equal_p (exp, *pterm))\n     return false_rtx;\n \n-  else if (GET_CODE (exp) == NOT && rtx_equal_p (XEXP (exp, 0), *pterm))\n+  else if (GET_CODE (exp) == NOT && attr_equal_p (XEXP (exp, 0), *pterm))\n     return true_rtx;\n \n-  else if (GET_CODE (*pterm) == NOT && rtx_equal_p (XEXP (*pterm, 0), exp))\n+  else if (GET_CODE (*pterm) == NOT && attr_equal_p (XEXP (*pterm, 0), exp))\n     return true_rtx;\n \n   else if (GET_CODE (*pterm) == EQ_ATTR && GET_CODE (exp) == NOT\n@@ -2286,7 +2435,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n   struct insn_ent *ie;\n   int i;\n   rtx newexp = exp;\n-  char *spacer = (char *) obstack_next_free (rtl_obstack);\n+  char *spacer = (char *) obstack_finish (rtl_obstack);\n \n   static rtx loser = 0;\n   static int count = 0;\n@@ -2425,7 +2574,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n        */\n \n       else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n-\t  && rtx_equal_p (XEXP (left, 0), XEXP (right, 0)))\n+\t  && attr_equal_p (XEXP (left, 0), XEXP (right, 0)))\n \t{\n \t  newexp = attr_rtx (IOR, XEXP (left, 1), XEXP (right, 1));\n \n@@ -2565,19 +2714,26 @@ optimize_attrs ()\n \tfor (av = attr->first_value; av; av = av->next)\n \t    for (ie = av->first_insn; ie; ie = nextie)\n \t      {\n+\t\tstruct obstack *old = rtl_obstack;\n+\t\tchar *spacer = (char *) obstack_finish (temp_obstack);\n+\n \t\tnextie = ie->next;\n \t\tif (GET_CODE (av->value) != COND)\n \t\t  continue;\n \n+\t\trtl_obstack = temp_obstack;\n \t\tnewexp = simplify_cond (av->value, ie->insn_code,\n \t\t\t\t\tie->insn_index);\n+\t\trtl_obstack = old;\n \t\tif (newexp != av->value)\n \t\t  {\n+\t\t    newexp = attr_copy_rtx (newexp);\n \t\t    remove_insn_ent (av, ie);\n \t\t    insert_insn_ent (get_attr_value (newexp, attr,\n \t\t\t\t\t\t     ie->insn_code), ie);\n \t\t    something_changed = 1;\n \t\t  }\n+\t\tobstack_free (temp_obstack, spacer);\n \t      }\n     }\n }\n@@ -2629,7 +2785,7 @@ gen_attr (exp)\n     fatal (\"`length' attribute must take numeric values\");\n \n   /* Set up the default value. */\n-  check_attr_value (XEXP (exp, 2), attr);\n+  XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n   attr->default_val = get_attr_value (XEXP (exp, 2), attr, -2);\n }\n \f\n@@ -3826,7 +3982,7 @@ find_attr (name, create)\n \n   /* Otherwise, do it the slow way.  */\n   for (attr = attrs; attr; attr = attr->next)\n-    if (! strcmp (name, attr->name))\n+    if (name[0] == attr->name[0] && ! strcmp (name, attr->name))\n       return attr;\n \n   if (! create)\n@@ -3962,6 +4118,9 @@ copy_rtx_unchanging (orig)\n   register rtx copy;\n   register RTX_CODE code;\n \n+  if (RTX_UNCHANGING_P (orig))\n+    return orig;\n+\n   code = GET_CODE (orig);\n \n   switch (code)\n@@ -4016,6 +4175,7 @@ main (argc, argv)\n \n   obstack_init (rtl_obstack);\n   obstack_init (hash_obstack);\n+  obstack_init (temp_obstack);\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");\n@@ -4030,9 +4190,14 @@ main (argc, argv)\n   init_rtl ();\n \n   /* Set up true and false rtx's */\n-  true_rtx = attr_rtx (CONST_INT, 1);\n-  false_rtx = attr_rtx (CONST_INT, 0);\n+  true_rtx = rtx_alloc (CONST_INT);\n+  XINT (true_rtx, 0) = 1;\n+  false_rtx = rtx_alloc (CONST_INT);\n+  XINT (false_rtx, 0) = 0;\n   RTX_UNCHANGING_P (true_rtx) = RTX_UNCHANGING_P (false_rtx) = 1;\n+  RTX_INTEGRATED_P (true_rtx) = RTX_INTEGRATED_P (false_rtx) = 1;\n+\n+  alternative_name = attr_string (\"alternative\", strlen (\"alternative\"));\n \n   printf (\"/* Generated automatically by the program `genattrtab'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n@@ -4116,7 +4281,8 @@ from the machine description file `md'.  */\\n\\n\");\n   check_defs ();\n   for (attr = attrs; attr; attr = attr->next)\n     {\n-      check_attr_value (attr->default_val->value, attr);\n+      attr->default_val->value\n+\t= check_attr_value (attr->default_val->value, attr);\n       fill_attr (attr);\n     }\n "}]}