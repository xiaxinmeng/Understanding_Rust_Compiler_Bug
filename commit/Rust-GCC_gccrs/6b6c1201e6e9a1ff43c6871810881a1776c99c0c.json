{"sha": "6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2YzEyMDFlNmU5YTFmZjQzYzY4NzE4MTA4ODFhMTc3NmM5OWMwYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-09T06:17:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-09T06:17:35Z"}, "message": "ia64-protos.h (ia64_expand_prediction): Declare.\n\n        * config/ia64/ia64-protos.h (ia64_expand_prediction): Declare.\n        * config/ia64/ia64.c (ia64_print_operand_address): Handle 'j'.\n        (ia64_expand_prediction): New.\n        (emit_insn_group_barriers): Don't look at notes.  Emit barriers\n        as needed after calls.\n        (ia64_epilogue_uses): Mark b0 used.\n        * config/ia64/ia64.md (beq_true, beq_false): Remove.\n        (bne_true, bne_false): Remove.\n        (eq_return, eq_not_return, ne_return, ne_not_return): Remove.\n        (br_true, br_false): New.  Use predicate_operator and\n        ia64_expand_prediction.\n        (return_true, return_false): Likewise.\n        (call_internal): Use ia64_expand_prediction.  Don't emit stop bit.\n        (call_internal1, call_value_internal): Likewise.\n        (call_value_internal1, call_multiple_values_internal1): Likewise.\n\nFrom-SVN: r33793", "tree": {"sha": "2538b7dcffc58c905dc76c25fa26a3f13e4bb6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2538b7dcffc58c905dc76c25fa26a3f13e4bb6cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/comments", "author": null, "committer": null, "parents": [{"sha": "c66f079e8d2c33f5996fc0b7383153336a957efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66f079e8d2c33f5996fc0b7383153336a957efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66f079e8d2c33f5996fc0b7383153336a957efd"}], "stats": {"total": 304, "additions": 204, "deletions": 100}, "files": [{"sha": "95ee45790391d09a696b1ba0fe267758118468a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "patch": "@@ -1,3 +1,40 @@\n+2000-05-08  Richard Henderson  <rth@cygnus.com>\n+\n+\t* final.c (current_insn_predicate): New.\n+\t(final_scan_insn): Set it.\n+\t* output.h (current_insn_predicate): Declare.\n+\n+\t* ifcvt.c (cond_exec_process_insns): New argument prob_val.\n+\tAttach it to call insns.\n+\t(cond_exec_process_if_block): Track probability for true and\n+\tfalse branches.\n+\t(dead_or_predicable): Likewise.\n+\n+\t* predict.c (PROB_NEVER, PROB_VERY_UNLIKELY): New.\n+\t(PROB_UNLIKELY, PROB_EVEN, PROB_LIKELY): New.\n+\t(PROB_VERY_LIKELY, PROB_ALWAYS): New.\n+\t(estimate_probability, expected_value_to_br_prob): Use them.\n+\n+\t* config/ia64/ia64-protos.h (ia64_expand_prediction): Declare.\n+\t* config/ia64/ia64.c (ia64_print_operand_address): Handle 'j'.\n+\t(ia64_expand_prediction): New.\n+\t(emit_insn_group_barriers): Don't look at notes.  Emit barriers\n+\tas needed after calls.\n+\t(ia64_epilogue_uses): Mark b0 used.\n+\t* config/ia64/ia64.md (beq_true, beq_false): Remove.\n+\t(bne_true, bne_false): Remove.\n+\t(eq_return, eq_not_return, ne_return, ne_not_return): Remove.\n+\t(br_true, br_false): New.  Use predicate_operator and\n+\tia64_expand_prediction.\n+\t(return_true, return_false): Likewise.\n+\t(call_internal): Use ia64_expand_prediction.  Don't emit stop bit.\n+\t(call_internal1, call_value_internal): Likewise.\n+\t(call_value_internal1, call_multiple_values_internal1): Likewise.\n+\n+\t* config/ia64/ia64.c (ia64_direct_return): Require frame size zero.\n+\n+\t* config/ia64/ia64.md (extendsfdf2): Split only after reload.\n+\n 2000-05-08  Richard Henderson  <rth@cygnus.com>\n \n \t* rtlanal.c (may_trap_p): Consider old-style and volatile"}, {"sha": "d8f75e0cd0deda044d2a5f9ff198804922bdd25c", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "patch": "@@ -61,6 +61,7 @@ extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n \t\t\t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t\t\t  rtx));\n extern void ia64_reorg PARAMS((rtx));\n+extern const char *ia64_expand_prediction PARAMS((rtx, const char *));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "66688f6b09f8654707ef0e8c8d9aebf68ebe4aef", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 104, "deletions": 21, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "patch": "@@ -1695,6 +1695,7 @@ ia64_print_operand_address (stream, address)\n         a floating point register emitted normally.\n    I\tInvert a predicate register by adding 1.\n    J    Select the proper predicate register for a condition.\n+   j    Select the inverse predicate register for a condition.\n    O\tAppend .acq for volatile load.\n    P\tPostincrement of a MEM.\n    Q\tAppend .rel for volatile store.\n@@ -1755,7 +1756,15 @@ ia64_print_operand (file, x, code)\n       return;\n \n     case 'J':\n-      fputs (reg_names [REGNO (XEXP (x, 0)) + (GET_CODE (x) == EQ)], file);\n+    case 'j':\n+      {\n+\tunsigned int regno = REGNO (XEXP (x, 0));\n+\tif (GET_CODE (x) == EQ)\n+\t  regno += 1;\n+\tif (code == 'j')\n+\t  regno ^= 1;\n+        fputs (reg_names [regno], file);\n+      }\n       return;\n \n     case 'O':\n@@ -1864,6 +1873,47 @@ ia64_print_operand (file, x, code)\n   return;\n }\n \n+/* For conditional branches, returns or calls, substitute\n+   sptk, dptk, dpnt, or spnt for %s.  */\n+\n+const char *\n+ia64_expand_prediction (insn, template)\n+     rtx insn;\n+     const char *template;\n+{\n+  static char const pred_name[4][5] = {\n+\t\"spnt\", \"dpnt\", \"dptk\", \"sptk\"\n+  };\n+  static char new_template[64];\n+\n+  int pred_val, pred_which;\n+  rtx note;\n+\n+  note = find_reg_note (insn, REG_BR_PROB, 0);\n+  if (note)\n+    {\n+      pred_val = INTVAL (XEXP (note, 0));\n+\n+      /* Guess top and bottom 10% statically predicted.  */\n+      if (pred_val < REG_BR_PROB_BASE / 10)\n+\tpred_which = 0;\n+      else if (pred_val < REG_BR_PROB_BASE / 2)\n+\tpred_which = 1;\n+      else if (pred_val < REG_BR_PROB_BASE * 9 / 10)\n+\tpred_which = 2;\n+      else\n+\tpred_which = 3;\n+    }\n+  else\n+    pred_which = 2;\n+\n+  if (strlen (template) >= sizeof (new_template) - 3)\n+    abort ();\n+\n+  sprintf (new_template, template, pred_name[pred_which]);\n+\n+  return new_template;\n+}\n \f\n \n /* This function returns the register class required for a secondary\n@@ -2654,41 +2704,68 @@ static void\n emit_insn_group_barriers (insns)\n      rtx insns;\n {\n-  int need_barrier = 0;\n-  int exception_nesting;\n-  struct reg_flags flags;\n   rtx insn, prev_insn;\n \n   memset (rws_sum, 0, sizeof (rws_sum));\n \n   prev_insn = 0;\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {\n+      int need_barrier = 0;\n+      struct reg_flags flags;\n+\n       memset (&flags, 0, sizeof (flags));\n       switch (GET_CODE (insn))\n \t{\n \tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n-\t    {\n-\t    case NOTE_INSN_EH_REGION_BEG:\n-\t      exception_nesting++;\n-\t      break;\n+\t  break;\n \n-\t    case NOTE_INSN_EH_REGION_END:\n-\t      exception_nesting--;\n-\t      break;\n+\tcase CALL_INSN:\n+\t  flags.is_branch = 1;\n+\t  memset (rws_insn, 0, sizeof (rws_insn));\n+\t  need_barrier = rtx_needs_barrier (PATTERN (insn), flags, 0);\n \n-\t    case NOTE_INSN_EPILOGUE_BEG:\n-\t      break;\n+\t  if (need_barrier)\n+\t    {\n+\t      /* PREV_INSN null can happen if the very first insn is a\n+\t\t volatile asm.  */\n+\t      if (prev_insn)\n+\t\temit_insn_after (gen_insn_group_barrier (), prev_insn);\n+\t      memcpy (rws_sum, rws_insn, sizeof (rws_sum));\n+\t    }\n \n-\t    default:\n-\t      break;\n+\t  /* A call must end a group, otherwise the assembler might pack\n+\t     it in with a following branch and then the function return\n+\t     goes to the wrong place.  Do this unconditionally for \n+\t     unconditional calls, simply because it (1) looks nicer and\n+\t     (2) keeps the data structures more accurate for the insns\n+\t     following the call.  */\n+\n+\t  need_barrier = 1;\n+\t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+\t    {\n+\t      rtx next_insn = insn;\n+\t      do\n+\t\tnext_insn = next_nonnote_insn (next_insn);\n+\t      while (next_insn\n+\t\t     && GET_CODE (next_insn) == INSN\n+\t\t     && (GET_CODE (PATTERN (next_insn)) == USE\n+\t\t\t || GET_CODE (PATTERN (next_insn)) == CLOBBER));\n+\t      if (next_insn && GET_CODE (next_insn) != JUMP_INSN)\n+\t\tneed_barrier = 0;\n+\t    }\n+\t  if (need_barrier)\n+\t    {\n+\t      emit_insn_after (gen_insn_group_barrier (), insn);\n+\t      memset (rws_sum, 0, sizeof (rws_sum));\n+\t      prev_insn = NULL_RTX;\n \t    }\n \t  break;\n-\n+\t\n \tcase JUMP_INSN:\n-\tcase CALL_INSN:\n \t  flags.is_branch = 1;\n+\t  /* FALLTHRU */\n+\n \tcase INSN:\n \t  if (GET_CODE (PATTERN (insn)) == USE)\n \t    /* Don't care about USE \"insns\"---those are used to\n@@ -2698,7 +2775,7 @@ emit_insn_group_barriers (insns)\n \t  else\n \t    {\n \t      memset (rws_insn, 0, sizeof (rws_insn));\n-\t      need_barrier = rtx_needs_barrier (PATTERN (insn), flags, 0);\n+\t      need_barrier |= rtx_needs_barrier (PATTERN (insn), flags, 0);\n \n \t      /* Check to see if the previous instruction was a volatile\n \t\t asm.  */\n@@ -2713,7 +2790,6 @@ emit_insn_group_barriers (insns)\n \t\t    emit_insn_after (gen_insn_group_barrier (), prev_insn);\n \t\t  memcpy (rws_sum, rws_insn, sizeof (rws_sum));\n \t\t}\n-\t      need_barrier = 0;\n \t      prev_insn = insn;\n \t    }\n \t  break;\n@@ -2753,7 +2829,9 @@ ia64_epilogue_uses (regno)\n      from such a call, we need to make sure the function restores the\n      original gp-value, even if the function itself does not use the\n      gp anymore.  */\n-  if (regno == R_GR(1) && TARGET_CONST_GP && !(TARGET_AUTO_PIC || TARGET_NO_PIC))\n+  if (regno == R_GR (1)\n+      && TARGET_CONST_GP\n+      && !(TARGET_AUTO_PIC || TARGET_NO_PIC))\n     return 1;\n \n   /* For functions defined with the syscall_linkage attribute, all input\n@@ -2768,6 +2846,11 @@ ia64_epilogue_uses (regno)\n \t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n     return 1;\n \n+  /* Conditional return patterns can't represent the use of `b0' as\n+     the return address, so we force the value live this way.  */\n+  if (regno == R_BR (0))\n+    return 1;\n+\n   return 0;\n }\n "}, {"sha": "7ccf89dd11019c6a1212c238d725f845d7d83061", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 62, "deletions": 79, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6c1201e6e9a1ff43c6871810881a1776c99c0c/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=6b6c1201e6e9a1ff43c6871810881a1776c99c0c", "patch": "@@ -2134,53 +2134,29 @@\n   operands[3] = ia64_compare_op1;\n }\")\n \n-;; ??? Need a way to choose between dpnt and dptk.  Currently, I assume that\n-;; equality tests will likely fail, and inequality tests will likely succeed.\n-\n-(define_insn \"*beq_true\"\n+(define_insn \"*br_true\"\n   [(set (pc)\n-\t(if_then_else (eq:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"predicate_operator\"\n+\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"(%I0) br.cond.dpnt %l1\"\n+  \"* return ia64_expand_prediction (insn, \\\"(%%J0) br.cond.%s %%l2\\\");\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"*beq_false\"\n+(define_insn \"*br_false\"\n   [(set (pc)\n-\t(if_then_else (eq:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n+\t(if_then_else (match_operator 0 \"predicate_operator\"\n+\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t (const_int 0)])\n \t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"(%0) br.cond.dptk %l1\"\n-  [(set_attr \"type\" \"B\")\n-   (set_attr \"predicable\" \"no\")])\n-\n-(define_insn \"*bne_true\"\n-  [(set (pc)\n-\t(if_then_else (ne:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n   \"\"\n-  \"(%0) br.cond.dptk %l1\"\n+  \"* return ia64_expand_prediction (insn, \\\"(%%j0) br.cond.%s %%l2\\\");\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n-\n-(define_insn \"*bne_false\"\n-  [(set (pc)\n-\t(if_then_else (ne:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"(%I0) br.cond.dpnt %l1\"\n-  [(set_attr \"type\" \"B\")\n-   (set_attr \"predicable\" \"no\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -2716,16 +2692,19 @@\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n-;; ??? A call must end a group, otherwise, the assembler might pack it in\n-;; a group with a following branch, and then the function return goes to the\n-;; wrong place.  We could perhaps handle this in emit_insn_group_barriers.\n-\n (define_insn \"call_internal\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n   \"\"\n-  \"br.call.sptk.many %2 = %0 ;;\"\n+  \"*\n+{\n+  operands[3] = current_insn_predicate;\n+  if (operands[3] != NULL_RTX)\n+    return ia64_expand_prediction (insn, \\\"(%%J3) br.call.%s.many %2 = %0\\\");\n+  else\n+    return \\\"br.call.sptk.many %2 = %0\\\";\n+}\"\n   [(set_attr \"type\" \"B\")])\n \n (define_insn \"*call_internal1\"\n@@ -2734,7 +2713,14 @@\n    (use (reg:DI 1))\n    (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n   \"\"\n-  \"br.call.sptk.many %2 = %0 ;;\"\n+  \"*\n+{\n+  operands[3] = current_insn_predicate;\n+  if (operands[3] != NULL_RTX)\n+    return ia64_expand_prediction (insn, \\\"(%%J3) br.call.%s.many %2 = %0\\\");\n+  else\n+    return \\\"br.call.sptk.many %2 = %0\\\";\n+}\"\n   [(set_attr \"type\" \"B\")])\n \n ;; Subroutine call instruction returning a value.  Operand 0 is the hard\n@@ -2928,17 +2914,20 @@\n       = gen_rtx_SET (VOIDmode, XEXP (XVECEXP (operands[0], 0, i), 0), call);\n }\")\n \n-;; ??? A call must end a group, otherwise, the assembler might pack it in\n-;; a group with a following branch, and then the function return goes to the\n-;; wrong place.  We could perhaps handle this in emit_insn_group_barriers.\n-\n (define_insn \"call_value_internal\"\n   [(set (match_operand 0 \"register_operand\" \"=rf\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"bi\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n   \"\"\n-  \"br.call.sptk.many %3 = %1 ;;\"\n+  \"*\n+{\n+  operands[4] = current_insn_predicate;\n+  if (operands[4] != NULL_RTX)\n+    return ia64_expand_prediction (insn, \\\"(%%J4) br.call.%s.many %3 = %1\\\");\n+  else\n+    return \\\"br.call.sptk.many %3 = %1\\\";\n+}\"\n   [(set_attr \"type\" \"B\")])\n \n (define_insn \"*call_value_internal1\"\n@@ -2948,7 +2937,14 @@\n    (use (reg:DI 1))\n    (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n   \"\"\n-  \"br.call.sptk.many %3 = %1 ;;\"\n+  \"*\n+{\n+  operands[4] = current_insn_predicate;\n+  if (operands[4] != NULL_RTX)\n+    return ia64_expand_prediction (insn, \\\"(%%J4) br.call.%s.many %3 = %1\\\");\n+  else\n+    return \\\"br.call.sptk.many %3 = %1\\\";\n+}\"\n   [(set_attr \"type\" \"B\")])\n \n (define_insn \"*call_multiple_values_internal1\"\n@@ -2959,7 +2955,14 @@\n \t\t    (use (reg:DI 1))\n \t\t    (clobber (match_operand:DI 4 \"register_operand\" \"=b\"))])]\n   \"\"\n-  \"br.call.sptk.many %4 = %2 ;;\"\n+  \"*\n+{\n+  operands[5] = current_insn_predicate;\n+  if (operands[5] != NULL_RTX)\n+    return ia64_expand_prediction (insn, \\\"(%%J5) br.call.%s.many %4 = %2\\\");\n+  else\n+    return \\\"br.call.sptk.many %4 = %2\\\";\n+}\"\n   [(set_attr \"type\" \"B\")])\n \n ;; Call subroutine returning any type.\n@@ -3004,47 +3007,27 @@\n   \"br.ret.sptk.many rp\"\n   [(set_attr \"type\" \"B\")])\n \n-(define_insn \"*eq_return\"\n-  [(set (pc)\n-\t(if_then_else (eq:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n-\t\t      (return)\n-\t\t      (pc)))]\n-  \"ia64_direct_return ()\"\n-  \"(%I0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")\n-   (set_attr \"predicable\" \"no\")])\n-\n-(define_insn \"*eq_not_return\"\n-  [(set (pc)\n-\t(if_then_else (eq:CC (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t     (const_int 0))\n-\t\t      (pc)\n-\t\t      (return)))]\n-  \"ia64_direct_return ()\"\n-  \"(%0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")\n-   (set_attr \"predicable\" \"no\")])\n-\n-(define_insn \"*ne_return\"\n+(define_insn \"*return_true\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t  (const_int 0))\n+\t(if_then_else (match_operator 0 \"predicate_operator\"\n+\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t (const_int 0)])\n \t\t      (return)\n \t\t      (pc)))]\n   \"ia64_direct_return ()\"\n-  \"(%0) br.ret.sptk.many rp\"\n+  \"* return ia64_expand_prediction (insn, \\\"(%%J0) br.ret.%s.many rp\\\");\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_insn \"*ne_not_return\"\n+(define_insn \"*return_false\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CC 0 \"register_operand\" \"c\")\n-\t\t\t  (const_int 0))\n+\t(if_then_else (match_operator 0 \"predicate_operator\"\n+\t\t\t[(match_operand:CC 1 \"register_operand\" \"c\")\n+\t\t\t (const_int 0)])\n \t\t      (pc)\n \t\t      (return)))]\n   \"ia64_direct_return ()\"\n-  \"(%I0) br.ret.sptk.many rp\"\n+  \"* return ia64_expand_prediction (insn, \\\"(%%j0) br.ret.%s.many rp\\\");\"\n   [(set_attr \"type\" \"B\")\n    (set_attr \"predicable\" \"no\")])\n "}]}