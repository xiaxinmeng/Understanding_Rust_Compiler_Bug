{"sha": "db2767b644667cdb0beefc7c98c643e605512405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIyNzY3YjY0NDY2N2NkYjBiZWVmYzdjOThjNjQzZTYwNTUxMjQwNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-04-22T21:02:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-04-22T21:02:01Z"}, "message": "pt.c (tsubst): Decrease the template-level of TEMPLATE_TEMPLATE_PARMS.\n\n\t * pt.c (tsubst): Decrease the template-level of\n\t TEMPLATE_TEMPLATE_PARMS.  Likewise for the DECL_INITIAL of a\n\t TEMPLATE_PARM_INDEX.\n\t (template_decl_level): New function.\n\t (unify): Make sure to record unifications for template\n\t parameters, even when the parameters exactly match the arguments.\n\t Combine duplicated code for TEMPLATE_TEMPLATE_PARMs and\n\t TEMPLATE_TYPE_PARMS.  Don't try to unify template parameters that\n\t aren't from the level we're currently working on.\n\nFrom-SVN: r19378", "tree": {"sha": "9f38d9c184acc8ee76a7f015f6616c5329af210d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f38d9c184acc8ee76a7f015f6616c5329af210d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db2767b644667cdb0beefc7c98c643e605512405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2767b644667cdb0beefc7c98c643e605512405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db2767b644667cdb0beefc7c98c643e605512405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2767b644667cdb0beefc7c98c643e605512405/comments", "author": null, "committer": null, "parents": [{"sha": "693e265fc07aa9119906a3ed03318599ae6b5bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693e265fc07aa9119906a3ed03318599ae6b5bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/693e265fc07aa9119906a3ed03318599ae6b5bc5"}], "stats": {"total": 231, "additions": 142, "deletions": 89}, "files": [{"sha": "949da95b65b7ff0124f001e9fc784ee61c013ff0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2767b644667cdb0beefc7c98c643e605512405/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2767b644667cdb0beefc7c98c643e605512405/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db2767b644667cdb0beefc7c98c643e605512405", "patch": "@@ -4,6 +4,16 @@ Wed Apr 22 13:24:48 1998  Mark Mitchell  <mmitchell@usa.net>\n \tthe DECL_RESULTs of a member TEMPLATE_DECL, not just the\n \tTEMPLATE_DECL.\n \n+\t * pt.c (tsubst): Decrease the template-level of\n+\t TEMPLATE_TEMPLATE_PARMS.  Likewise for the DECL_INITIAL of a\n+\t TEMPLATE_PARM_INDEX.\n+\t (template_decl_level): New function.\n+\t (unify): Make sure to record unifications for template\n+\t parameters, even when the parameters exactly match the arguments.\n+\t Combine duplicated code for TEMPLATE_TEMPLATE_PARMs and\n+\t TEMPLATE_TYPE_PARMS.  Don't try to unify template parameters that\n+\t aren't from the level we're currently working on.\n+\n Tue Apr 21 22:00:04 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* errfn.c (cp_thing): Use xrealloc, not xmalloc, to copy memory."}, {"sha": "b6e695d6420e3373f371df51dabc4d746735aca9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 132, "deletions": 89, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2767b644667cdb0beefc7c98c643e605512405/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2767b644667cdb0beefc7c98c643e605512405/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db2767b644667cdb0beefc7c98c643e605512405", "patch": "@@ -3944,17 +3944,15 @@ tsubst (t, args, in_decl)\n \ttree parms;\n \ttree* new_parms;\n \ttree spec;\n+\tint is_template_template_parm = DECL_TEMPLATE_TEMPLATE_PARM_P (t);\n \n-\tif (TREE_CODE (decl) == TYPE_DECL\n-\t    && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TEMPLATE_PARM)\n-\t  /* There is no tsubst'ing to be done in a template template\n-\t     parameter.  */\n-\t  return t;\n-\n-\t/* We might already have an instance of this template. */\n-\tspec = retrieve_specialization (t, args);\n-\tif (spec != NULL_TREE)\n-\t  return spec;\n+\tif (!is_template_template_parm)\n+\t  {\n+\t    /* We might already have an instance of this template. */\n+\t    spec = retrieve_specialization (t, args);\n+\t    if (spec != NULL_TREE)\n+\t      return spec;\n+\t  }\n \n \t/* Make a new template decl.  It will be similar to the\n \t   original, but will record the current template arguments. \n@@ -3966,6 +3964,15 @@ tsubst (t, args, in_decl)\n \tmy_friendly_assert (DECL_LANG_SPECIFIC (tmpl) != 0, 0);\n \tDECL_CHAIN (tmpl) = NULL_TREE;\n \tTREE_CHAIN (tmpl) = NULL_TREE;\n+\n+\tif (is_template_template_parm)\n+\t  {\n+\t    tree new_decl = tsubst (decl, args, in_decl);\n+\t    DECL_RESULT (tmpl) = new_decl;\n+\t    TREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n+\t    return tmpl;\n+\t  }\n+\n \tDECL_CONTEXT (tmpl) = tsubst (DECL_CONTEXT (t),\n \t\t\t\t      args, in_decl);\n \tDECL_CLASS_CONTEXT (tmpl) = tsubst (DECL_CLASS_CONTEXT (t),\n@@ -4311,7 +4318,11 @@ tsubst (t, args, in_decl)\n       {\n \ttree r = copy_node (t);\n \tTREE_TYPE (r) = type;\n-\tDECL_INITIAL (r) = TREE_TYPE (r);\n+\tif (TREE_CODE (DECL_INITIAL (r)) != TEMPLATE_PARM_INDEX)\n+\t  DECL_INITIAL (r) = TREE_TYPE (r);\n+\telse\n+\t  DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args, in_decl);\n+\n \tDECL_CONTEXT (r) = NULL_TREE;\n #ifdef PROMOTE_PROTOTYPES\n \tif ((TREE_CODE (type) == INTEGER_TYPE\n@@ -5565,6 +5576,27 @@ type_unification_real (tparms, targs, parms, args, subr,\n   return 0;\n }\n \n+/* Returns the level of DECL, which declares a template parameter.  */\n+\n+static int\n+template_decl_level (decl)\n+     tree decl;\n+{\n+  switch (TREE_CODE (decl))\n+    {\n+    case TYPE_DECL:\n+    case TEMPLATE_DECL:\n+      return TEMPLATE_TYPE_LEVEL (TREE_TYPE (decl));\n+\n+    case PARM_DECL:\n+      return TEMPLATE_PARM_LEVEL (DECL_INITIAL (decl));\n+\n+    default:\n+      my_friendly_abort (0);\n+      break;\n+    }\n+}\n+\n /* Tail recursion is your friend.  */\n \n static int\n@@ -5575,6 +5607,7 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n {\n   int idx;\n   tree targ;\n+  tree tparm;\n \n   /* I don't think this will do the right thing with respect to types.\n      But the only case I've seen it in so far has been array bounds, where\n@@ -5587,7 +5620,11 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n     return 1;\n   if (arg == unknown_type_node)\n     return 1;\n-  if (arg == parm)\n+  /* If PARM uses template parameters, then we can't bail out here,\n+     even in ARG == PARM, since we won't record unifications for the\n+     template parameters.  We might need them if we're trying to\n+     figure out which of two things is more specialized.  */\n+  if (arg == parm && !uses_template_parms (parm))\n     return 0;\n \n   /* We can't remove cv-quals when strict.  */\n@@ -5606,53 +5643,24 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n       return 0;\n \n     case TEMPLATE_TYPE_PARM:\n-      idx = TEMPLATE_TYPE_IDX (parm);\n-      targ = TREE_VEC_ELT (targs, idx);\n-      /* Check for mixed types and values.  */\n-      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n-\treturn 1;\n-\n-      if (!strict && targ != NULL_TREE \n-\t  && explicit_mask && explicit_mask[idx])\n-\t/* An explicit template argument.  Don't even try to match\n-\t   here; the overload resolution code will manage check to\n-\t   see whether the call is legal.  */ \n-\treturn 0;\n-\n-      if (strict && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n-\t\t     || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n-\treturn 1;\n-#if 0\n-      /* Template type parameters cannot contain cv-quals; i.e.\n-         template <class T> void f (T& a, T& b) will not generate\n-\t void f (const int& a, const int& b).  */\n-      if (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n-\t  || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))\n-\treturn 1;\n-      arg = TYPE_MAIN_VARIANT (arg);\n-#else\n-      {\n-\tint constp = TYPE_READONLY (arg) > TYPE_READONLY (parm);\n-\tint volatilep = TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm);\n-\targ = cp_build_type_variant (arg, constp, volatilep);\n-      }\n-#endif\n-      /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targ != NULL_TREE \n-\t  && (comptypes (targ, arg, 1)\n-\t      || (explicit_mask && explicit_mask[idx])))\n-\treturn 0;\n-      else if (targ)\n-\treturn 1;\n-      TREE_VEC_ELT (targs, idx) = arg;\n-      return 0;\n-\n     case TEMPLATE_TEMPLATE_PARM:\n+      tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n+\n+      if (TEMPLATE_TYPE_LEVEL (parm)\n+\t  != template_decl_level (tparm))\n+\t/* The PARM is not one we're trying to unify.  Just check\n+\t   to see if it matches ARG.  */\n+\treturn (TREE_CODE (arg) == TREE_CODE (parm)\n+\t\t&& comptypes (parm, arg, 1) == 0) ? 0 : 1;\n       idx = TEMPLATE_TYPE_IDX (parm);\n       targ = TREE_VEC_ELT (targs, idx);\n+      tparm = TREE_VALUE (TREE_VEC_ELT (tparms, idx));\n \n       /* Check for mixed types and values.  */\n-      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TEMPLATE_DECL)\n+      if ((TREE_CODE (parm) == TEMPLATE_TYPE_PARM\n+\t   && TREE_CODE (tparm) != TYPE_DECL)\n+\t  || (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM \n+\t      && TREE_CODE (tparm) != TEMPLATE_DECL))\n \treturn 1;\n \n       if (!strict && targ != NULL_TREE \n@@ -5662,51 +5670,76 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t   see whether the call is legal.  */ \n \treturn 0;\n \n-      if (CLASSTYPE_TEMPLATE_INFO (parm))\n+      if (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n \t{\n-\t  /* We arrive here when PARM does not involve template \n-\t     specialization.  */\n-\n-\t  /* ARG must be constructed from a template class.  */\n-\t  if (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg))\n-\t    return 1;\n+\t  if (CLASSTYPE_TEMPLATE_INFO (parm))\n+\t    {\n+\t      /* We arrive here when PARM does not involve template \n+\t\t specialization.  */\n \n-\t  {\n-\t    tree parmtmpl = CLASSTYPE_TI_TEMPLATE (parm);\n-\t    tree parmvec = CLASSTYPE_TI_ARGS (parm);\n-\t    tree argvec = CLASSTYPE_TI_ARGS (arg);\n-\t    tree argtmplvec\n-\t      = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n-\t    int i;\n+\t      /* ARG must be constructed from a template class.  */\n+\t      if (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg))\n+\t\treturn 1;\n \n-\t    /* The parameter and argument roles have to be switched here \n-\t       in order to handle default arguments properly.  For example, \n-\t\t template<template <class> class TT> void f(TT<int>) \n-\t       should be able to accept vector<int> which comes from \n-\t\t template <class T, class Allcator = allocator> \n+\t      {\n+\t\ttree parmtmpl = CLASSTYPE_TI_TEMPLATE (parm);\n+\t\ttree parmvec = CLASSTYPE_TI_ARGS (parm);\n+\t\ttree argvec = CLASSTYPE_TI_ARGS (arg);\n+\t\ttree argtmplvec\n+\t\t  = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n+\t\tint i;\n+\n+\t\t/* The parameter and argument roles have to be switched here \n+\t\t   in order to handle default arguments properly.  For example, \n+\t\t   template<template <class> class TT> void f(TT<int>) \n+\t\t   should be able to accept vector<int> which comes from \n+\t\t   template <class T, class Allcator = allocator> \n \t\t   class vector.  */\n \n-\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1, 0)\n-\t\t== error_mark_node)\n-\t      return 1;\n+\t\tif (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1, 0)\n+\t\t    == error_mark_node)\n+\t\t  return 1;\n \t  \n-\t    /* Deduce arguments T, i from TT<T> or TT<i>.  */\n-\t    for (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n-\t      {\n-\t\ttree t = TREE_VEC_ELT (parmvec, i);\n-\t\tif (TREE_CODE (t) != TEMPLATE_TYPE_PARM\n-\t\t    && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n-\t\t    && TREE_CODE (t) != TEMPLATE_PARM_INDEX)\n-\t\t  continue;\n+\t\t/* Deduce arguments T, i from TT<T> or TT<i>.  */\n+\t\tfor (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n+\t\t  {\n+\t\t    tree t = TREE_VEC_ELT (parmvec, i);\n+\t\t    if (TREE_CODE (t) != TEMPLATE_TYPE_PARM\n+\t\t\t&& TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n+\t\t\t&& TREE_CODE (t) != TEMPLATE_PARM_INDEX)\n+\t\t      continue;\n \n-\t\t/* This argument can be deduced.  */\n+\t\t    /* This argument can be deduced.  */\n \n-\t\tif (unify (tparms, targs, ntparms, t, \n-\t\t\t   TREE_VEC_ELT (argvec, i), strict, explicit_mask))\n-\t\t  return 1;\n+\t\t    if (unify (tparms, targs, ntparms, t, \n+\t\t\t       TREE_VEC_ELT (argvec, i), strict, explicit_mask))\n+\t\t      return 1;\n+\t\t  }\n \t      }\n+\t      arg = CLASSTYPE_TI_TEMPLATE (arg);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (strict && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n+\t\t\t || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+\t    return 1;\n+\n+#if 0\n+\t  /* Template type parameters cannot contain cv-quals; i.e.\n+\t     template <class T> void f (T& a, T& b) will not generate\n+\t     void f (const int& a, const int& b).  */\n+\t  if (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n+\t      || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))\n+\t    return 1;\n+\t  arg = TYPE_MAIN_VARIANT (arg);\n+#else\n+\t  {\n+\t    int constp = TYPE_READONLY (arg) > TYPE_READONLY (parm);\n+\t    int volatilep = TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm);\n+\t    arg = cp_build_type_variant (arg, constp, volatilep);\n \t  }\n-\t  arg = CLASSTYPE_TI_TEMPLATE (arg);\n+#endif\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */\n@@ -5720,8 +5753,18 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n       return 0;\n \n     case TEMPLATE_PARM_INDEX:\n+      tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n+\n+      if (TEMPLATE_PARM_LEVEL (parm) \n+\t  != template_decl_level (tparm))\n+\t/* The PARM is not one we're trying to unify.  Just check\n+\t   to see if it matches ARG.  */\n+\treturn (TREE_CODE (arg) == TREE_CODE (parm)\n+\t\t&& cp_tree_equal (parm, arg) == 0) ? 0 : 1;\n+\n       idx = TEMPLATE_PARM_IDX (parm);\n       targ = TREE_VEC_ELT (targs, idx);\n+\n       if (targ)\n \t{\n \t  int i = cp_tree_equal (targ, arg);"}]}