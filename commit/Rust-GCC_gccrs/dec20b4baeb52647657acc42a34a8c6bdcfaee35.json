{"sha": "dec20b4baeb52647657acc42a34a8c6bdcfaee35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVjMjBiNGJhZWI1MjY0NzY1N2FjYzQyYTM0YThjNmJkY2ZhZWUzNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:46:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:46:17Z"}, "message": "(save_expr): Don't evaluate something containing a PLACEHOLDER_EXPR.\n\n(contains_placeholder_p, substitute_in_{expr,type}): New functions.\n\nFrom-SVN: r5581", "tree": {"sha": "fcf2ea1f7a1f7a08f12b36bacba72f55f1eef78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcf2ea1f7a1f7a08f12b36bacba72f55f1eef78f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dec20b4baeb52647657acc42a34a8c6bdcfaee35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec20b4baeb52647657acc42a34a8c6bdcfaee35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec20b4baeb52647657acc42a34a8c6bdcfaee35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec20b4baeb52647657acc42a34a8c6bdcfaee35/comments", "author": null, "committer": null, "parents": [{"sha": "7380d7072744087f40c014b95d13e3df770de084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7380d7072744087f40c014b95d13e3df770de084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7380d7072744087f40c014b95d13e3df770de084"}], "stats": {"total": 291, "additions": 291, "deletions": 0}, "files": [{"sha": "4f190f52498c512561316e4a9670e7bc5ad2daef", "filename": "gcc/tree.c", "status": "modified", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec20b4baeb52647657acc42a34a8c6bdcfaee35/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec20b4baeb52647657acc42a34a8c6bdcfaee35/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dec20b4baeb52647657acc42a34a8c6bdcfaee35", "patch": "@@ -1847,6 +1847,18 @@ save_expr (expr)\n       || TREE_CODE (t) == SAVE_EXPR)\n     return t;\n \n+  /* If T contains a PLACEHOLDER_EXPR, we must evaluate it each time, since\n+     it means that the size or offset of some field of an object depends on\n+     the value within another field.\n+\n+     Note that it must not be the case that T contains both a PLACEHOLDER_EXPR\n+     and some variable since it would then need to be both evaluated once and\n+     evaluated more than once.  Front-ends must assure this case cannot\n+     happen by surrounding any such subexpressions in their own SAVE_EXPR\n+     and forcing evaluation at the proper time.  */\n+  if (contains_placeholder_p (t))\n+    return t;\n+\n   t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL_TREE);\n \n   /* This expression might be placed ahead of a jump to ensure that the\n@@ -1855,7 +1867,286 @@ save_expr (expr)\n   TREE_SIDE_EFFECTS (t) = 1;\n   return t;\n }\n+\f\n+/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n+   or offset that depends on a field within a record.\n+\n+   Note that we only allow such expressions within simple arithmetic\n+   or a COND_EXPR.  */\n+\n+int\n+contains_placeholder_p (exp)\n+     tree exp;\n+{\n+  register enum tree_code code = TREE_CODE (exp);\n+  tree inner;\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case 'r':\n+      for (inner = TREE_OPERAND (exp, 0);\n+\t   TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+      return TREE_CODE (inner) == PLACEHOLDER_EXPR;\n+\n+    case '1':\n+    case '2':  case '<':\n+    case 'e':\n+      switch (tree_code_length[(int) code])\n+\t{\n+\tcase 1:\n+\t  return contains_placeholder_p (TREE_OPERAND (exp, 0));\n+\tcase 2:\n+\t  return (code != RTL_EXPR\n+\t\t  && ! (code == SAVE_EXPR && SAVE_EXPR_RTL (exp) != 0)\n+\t\t  && code != WITH_RECORD_EXPR\n+\t\t  && (contains_placeholder_p (TREE_OPERAND (exp, 0))\n+\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 1))));\n+\tcase 3:\n+\t  return (code == COND_EXPR\n+\t\t  && (contains_placeholder_p (TREE_OPERAND (exp, 0))\n+\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 1))\n+\t\t      || contains_placeholder_p (TREE_OPERAND (exp, 2))));\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n+   return a tree with all occurrences of references to F in a\n+   PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n+   contains only arithmetic expressions.  */\n+\n+tree\n+substitute_in_expr (exp, f, r)\n+     tree exp;\n+     tree f;\n+     tree r;\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree inner;\n \n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case 'c':\n+    case 'd':\n+      return exp;\n+\n+    case 'x':\n+      if (code == PLACEHOLDER_EXPR)\n+\treturn exp;\n+      break;\n+\n+    case '1':\n+    case '2':\n+    case '<':\n+    case 'e':\n+      switch (tree_code_length[(int) code])\n+\t{\n+\tcase 1:\n+\t  return fold (build1 (code, TREE_TYPE (exp),\n+\t\t\t       substitute_in_expr (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t\t   f, r)));\n+\n+\tcase 2:\n+\t  if (code == RTL_EXPR)\n+\t    abort ();\n+\n+\t  return fold (build (code, TREE_TYPE (exp),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 1),\n+\t\t\t\t\t\t  f, r)));\n+\n+\tcase 3:\n+\t  if (code != COND_EXPR)\n+\t    abort ();\n+\n+\t  return fold (build (code, TREE_TYPE (exp),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 1), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 2),\n+\t\t\t\t\t\t  f, r)));\n+\t}\n+\n+      break;\n+\n+    case 'r':\n+      switch (code)\n+\t{\n+\tcase COMPONENT_REF:\n+\t  /* If this expression is getting a value from a PLACEHOLDER_EXPR\n+\t     and it is the right field, replace it with R.  */\n+\t  for (inner = TREE_OPERAND (exp, 0);\n+\t       TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n+\t       inner = TREE_OPERAND (inner, 0))\n+\t    ;\n+\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n+\t      && TREE_OPERAND (exp, 1) == f)\n+\t    return r;\n+\n+\t  return fold (build (code, TREE_TYPE (exp),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t\t\t      TREE_OPERAND (exp, 1)));\n+\tcase BIT_FIELD_REF:\n+\t  return fold (build (code, TREE_TYPE (exp),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 1), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 2), f, r)));\n+\tcase INDIRECT_REF:\n+\tcase BUFFER_REF:\n+\t  return fold (build1 (code, TREE_TYPE (exp),\n+\t\t\t       substitute_in_expr (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t\t f, r)));\n+\tcase OFFSET_REF:\n+\t  return fold (build (code, TREE_TYPE (exp),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 0), f, r),\n+\t\t\t      substitute_in_expr (TREE_OPERAND (exp, 1), f, r)));\n+\t}\n+    }\n+\n+  /* If it wasn't one of the cases we handle, give up.  */\n+\n+  abort ();\n+}\n+\f\n+/* Given a type T, a FIELD_DECL F, and a replacement value R,\n+   return a new type with all size expressions that contain F\n+   updated by replacing F with R.  */\n+\n+tree\n+substitute_in_type (t, f, r)\n+     tree t, f, r;\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+    case VOID_TYPE:\n+      return t;\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+      if ((TREE_CODE (TYPE_MIN_VALUE (t)) != INTEGER_CST\n+\t   && contains_placeholder_p (TYPE_MIN_VALUE (t)))\n+\t  || (TREE_CODE (TYPE_MAX_VALUE (t)) != INTEGER_CST\n+\t      && contains_placeholder_p (TYPE_MAX_VALUE (t))))\n+\treturn build_range_type (t,\n+\t\t\t\t substitute_in_expr (TYPE_MIN_VALUE (t), f, r),\n+\t\t\t\t substitute_in_expr (TYPE_MAX_VALUE (t), f, r));\n+      return t;\n+\n+    case REAL_TYPE:\n+      if ((TREE_CODE (TYPE_MIN_VALUE (t)) != INTEGER_CST\n+\t   && contains_placeholder_p (TYPE_MIN_VALUE (t)))\n+\t  || (TREE_CODE (TYPE_MAX_VALUE (t)) != INTEGER_CST\n+\t      && contains_placeholder_p (TYPE_MAX_VALUE (t))))\n+\t{\n+\t  t = build_type_copy (t);\n+\t  TYPE_MIN_VALUE (t) = substitute_in_expr (TYPE_MIN_VALUE (t), f, r);\n+\t  TYPE_MAX_VALUE (t) = substitute_in_expr (TYPE_MAX_VALUE (t), f, r);\n+\t}\n+      return t;\n+\n+    case COMPLEX_TYPE:\n+      return build_complex_type (substitute_in_type (TREE_TYPE (t), f, r));\n+\n+    case OFFSET_TYPE:\n+    case METHOD_TYPE:\n+    case REFERENCE_TYPE:\n+    case FILE_TYPE:\n+    case SET_TYPE:\n+    case STRING_TYPE:\n+    case FUNCTION_TYPE:\n+    case LANG_TYPE:\n+      /* Don't know how to do these yet.  */\n+      abort ();\n+\n+    case ARRAY_TYPE:\n+      t = build_array_type (substitute_in_type (TREE_TYPE (t), f, r),\n+\t\t\t    substitute_in_type (TYPE_DOMAIN (t), f, r));\n+      TYPE_SIZE (t) = 0;\n+      layout_type (t);\n+      return t;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree new = copy_node (t);\n+\ttree field;\n+\ttree last_field = 0;\n+\n+\t/* Start out with no fields, make new fields, and chain them\n+\t   in.  */\n+\n+\tTYPE_FIELDS (new) = 0;\n+\tTYPE_SIZE (new) = 0;\n+\n+\tfor (field = TYPE_FIELDS (t); field;\n+\t     field = TREE_CHAIN (field))\n+\t  {\n+\t    tree new_field = copy_node (field);\n+\n+\t    TREE_TYPE (new_field)\n+\t      = substitute_in_type (TREE_TYPE (new_field), f, r);\n+\n+\t    /* If this is an anonymous field and the type of this field is\n+\t       a UNION_TYPE or RECORD_TYPE with no elements, ignore it.  If\n+\t       the type just has one element, treat that as the field. \n+\t       But don't do this if we are processing a QUAL_UNION_TYPE.  */\n+\t    if (TREE_CODE (t) != QUAL_UNION_TYPE && DECL_NAME (new_field) == 0\n+\t\t&& (TREE_CODE (TREE_TYPE (new_field)) == UNION_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (new_field)) == RECORD_TYPE))\n+\t      {\n+\t\tif (TYPE_FIELDS (TREE_TYPE (new_field)) == 0)\n+\t\t  continue;\n+\n+\t\tif (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_field))) == 0)\n+\t\t  new_field = TYPE_FIELDS (TREE_TYPE (new_field));\n+\t      }\n+\n+\t    DECL_CONTEXT (new_field) = new;\n+\t    DECL_SIZE (new_field) = 0;\n+\n+\t    if (TREE_CODE (t) == QUAL_UNION_TYPE)\n+\t      {\n+\t\t/* Do the substitution inside the qualifier and if we find\n+\t\t   that this field will not be present, omit it.  */\n+\t\tDECL_QUALIFIER (new_field)\n+\t\t  = substitute_in_expr (DECL_QUALIFIER (field), f, r);\n+\t\tif (integer_zerop (DECL_QUALIFIER (new_field)))\n+\t\t  continue;\n+\t      }\n+\n+\t    if (last_field == 0)\n+\t      TYPE_FIELDS (new) = new_field;\n+\t    else\n+\t      TREE_CHAIN (last_field) = new_field;\n+\n+\t    last_field = new_field;\n+\n+\t    /* If this is a qualified type and this field will always be\n+\t       present, we are done.  */\n+\t    if (TREE_CODE (t) == QUAL_UNION_TYPE\n+\t\t&& integer_onep (DECL_QUALIFIER (new_field)))\n+\t      break;\n+\t  }\n+\n+\t/* If this used to be a qualified union type, but we now know what\n+\t   field will be present, make this a normal union.  */\n+\tif (TREE_CODE (new) == QUAL_UNION_TYPE\n+\t    && (TYPE_FIELDS (new) == 0\n+\t\t|| integer_onep (DECL_QUALIFIER (TYPE_FIELDS (new)))))\n+\t  TREE_SET_CODE (new, UNION_TYPE);\n+\n+\tlayout_type (new);\n+\treturn new;\n+      }\n+    }\n+}\n+\f\n /* Stabilize a reference so that we can use it any number of times\n    without causing its operands to be evaluated more than once.\n    Returns the stabilized reference."}]}