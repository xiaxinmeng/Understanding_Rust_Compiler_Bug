{"sha": "916fa4f033247e40c1fc7bad3211427766d3dca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2ZmE0ZjAzMzI0N2U0MGMxZmM3YmFkMzIxMTQyNzc2NmQzZGNhMw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2007-05-04T07:21:20Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2007-05-04T07:21:20Z"}, "message": "haifa-sched.c (rtx_vec_t): New typedef.\n\n* haifa-sched.c (rtx_vec_t): New typedef.\n(contributes_to_priority_p): Extract piece of priority () into new\nstatic function.\n(priority): Use the function.  Add assertion.\n(rank_for_schedule, set_priorities): Add assertion to check that\ninsn's priority is initialized.\n(clear_priorities, calc_priorities): Change signature.  Make it update\nall relevant insns.  Update all callers ('add_to_speculative_block ()'\nand 'create_block_check_twin ()').\n* sched-int.h (struct haifa_insn_data): Remove field 'priority_known'.\nAdd new field 'priority_status'.\n(INSN_PRIORITY_STATUS): New macro.\n(INSN_PRIORITY_KNOWN): Change to use INSN_PRIORITY_STATUS.\n\nFrom-SVN: r124410", "tree": {"sha": "26fd4a2f3e219cdad90c93bb12aee00782e48f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26fd4a2f3e219cdad90c93bb12aee00782e48f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916fa4f033247e40c1fc7bad3211427766d3dca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916fa4f033247e40c1fc7bad3211427766d3dca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916fa4f033247e40c1fc7bad3211427766d3dca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916fa4f033247e40c1fc7bad3211427766d3dca3/comments", "author": null, "committer": null, "parents": [{"sha": "b640bd8f20ea23a3c74ba23d5f3bdc2a4b37d1d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b640bd8f20ea23a3c74ba23d5f3bdc2a4b37d1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b640bd8f20ea23a3c74ba23d5f3bdc2a4b37d1d6"}], "stats": {"total": 151, "additions": 102, "deletions": 49}, "files": [{"sha": "4ac2d44091ef4c14c9d1f3d80e04e08770b8738f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=916fa4f033247e40c1fc7bad3211427766d3dca3", "patch": "@@ -1,3 +1,19 @@\n+2007-05-04  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n+\n+\t* haifa-sched.c (rtx_vec_t): New typedef.\n+\t(contributes_to_priority_p): Extract piece of priority () into new\n+\tstatic function.\n+\t(priority): Use the function.  Add assertion.\n+\t(rank_for_schedule, set_priorities): Add assertion to check that\n+\tinsn's priority is initialized.\n+\t(clear_priorities, calc_priorities): Change signature.  Make it update\n+\tall relevant insns.  Update all callers ('add_to_speculative_block ()'\n+\tand 'create_block_check_twin ()').\n+\t* sched-int.h (struct haifa_insn_data): Remove field 'priority_known'.\n+\tAdd new field 'priority_status'.\n+\t(INSN_PRIORITY_STATUS): New macro.\n+\t(INSN_PRIORITY_KNOWN): Change to use INSN_PRIORITY_STATUS.\n+\n 2007-05-04  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \t* sched-ebb.c (debug_ebb_dependencies): New static function."}, {"sha": "fdc92ec27c65893cbb6770d040e3f22ae558f344", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 80, "deletions": 46, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=916fa4f033247e40c1fc7bad3211427766d3dca3", "patch": "@@ -487,6 +487,9 @@ haifa_classify_insn (rtx insn)\n   return insn_class;\n }\n \n+/* A typedef for rtx vector.  */\n+typedef VEC(rtx, heap) *rtx_vec_t;\n+\n /* Forward declarations.  */\n \n static int priority (rtx);\n@@ -575,9 +578,9 @@ static void init_glat1 (basic_block);\n static void attach_life_info1 (basic_block);\n static void free_glat (void);\n static void sched_remove_insn (rtx);\n-static void clear_priorities (rtx);\n+static void clear_priorities (rtx, rtx_vec_t *);\n+static void calc_priorities (rtx_vec_t);\n static void add_jump_dependencies (rtx, rtx);\n-static void calc_priorities (rtx);\n #ifdef ENABLE_CHECKING\n static int has_edge_p (VEC(edge,gc) *, int);\n static void check_cfg (rtx, rtx);\n@@ -703,8 +706,30 @@ dep_cost (dep_t link)\n   return cost;\n }\n \n-/* Compute the priority number for INSN.  */\n+/* Return 'true' if DEP should be included in priority calculations.  */\n+static bool\n+contributes_to_priority_p (dep_t dep)\n+{\n+  /* Critical path is meaningful in block boundaries only.  */\n+  if (!current_sched_info->contributes_to_priority (DEP_CON (dep),\n+\t\t\t\t\t\t    DEP_PRO (dep)))\n+    return false;\n+\n+  /* If flag COUNT_SPEC_IN_CRITICAL_PATH is set,\n+     then speculative instructions will less likely be\n+     scheduled.  That is because the priority of\n+     their producers will increase, and, thus, the\n+     producers will more likely be scheduled, thus,\n+     resolving the dependence.  */\n+  if ((current_sched_info->flags & DO_SPECULATION)\n+      && !(spec_info->flags & COUNT_SPEC_IN_CRITICAL_PATH)\n+      && (DEP_STATUS (dep) & SPECULATIVE))\n+    return false;\n \n+  return true;\n+}\n+\n+/* Compute the priority number for INSN.  */\n static int\n priority (rtx insn)\n {\n@@ -713,7 +738,10 @@ priority (rtx insn)\n   if (! INSN_P (insn))\n     return 0;\n \n-  if (! INSN_PRIORITY_KNOWN (insn))\n+  /* We should not be insterested in priority of an already scheduled insn.  */\n+  gcc_assert (QUEUE_INDEX (insn) != QUEUE_SCHEDULED);\n+\n+  if (!INSN_PRIORITY_KNOWN (insn))\n     {\n       int this_priority = 0;\n \n@@ -760,20 +788,7 @@ priority (rtx insn)\n \t\t    {\n \t\t      int cost;\n \n-\t\t      /* Critical path is meaningful in block boundaries\n-\t\t\t only.  */\n-\t\t      if (! (*current_sched_info->contributes_to_priority)\n-\t\t\t  (next, insn)\n-\t\t\t  /* If flag COUNT_SPEC_IN_CRITICAL_PATH is set,\n-\t\t\t     then speculative instructions will less likely be\n-\t\t\t     scheduled.  That is because the priority of\n-\t\t\t     their producers will increase, and, thus, the\n-\t\t\t     producers will more likely be scheduled, thus,\n-\t\t\t     resolving the dependence.  */\n-\t\t\t  || ((current_sched_info->flags & DO_SPECULATION)\n-\t\t\t      && (DEP_STATUS (dep) & SPECULATIVE)\n-\t\t\t      && !(spec_info->flags\n-\t\t\t\t   & COUNT_SPEC_IN_CRITICAL_PATH)))\n+\t\t      if (!contributes_to_priority_p (dep))\n \t\t\tcontinue;\n \n \t\t      if (twin == insn)\n@@ -799,7 +814,7 @@ priority (rtx insn)\n \t  while (twin != prev_first);\n \t}\n       INSN_PRIORITY (insn) = this_priority;\n-      INSN_PRIORITY_KNOWN (insn) = 1;\n+      INSN_PRIORITY_STATUS (insn) = 1;\n     }\n \n   return INSN_PRIORITY (insn);\n@@ -832,6 +847,9 @@ rank_for_schedule (const void *x, const void *y)\n   if (SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n     return SCHED_GROUP_P (tmp2) ? 1 : -1;\n \n+  /* Make sure that priority of TMP and TMP2 are initialized.  */\n+  gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n+\n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n \n@@ -2541,9 +2559,10 @@ set_priorities (rtx head, rtx tail)\n       n_insn++;\n       (void) priority (insn);\n \n-      if (INSN_PRIORITY_KNOWN (insn))\n-\tsched_max_insns_priority =\n-\t  MAX (sched_max_insns_priority, INSN_PRIORITY (insn)); \n+      gcc_assert (INSN_PRIORITY_KNOWN (insn));\n+\n+      sched_max_insns_priority = MAX (sched_max_insns_priority,\n+\t\t\t\t      INSN_PRIORITY (insn));\n     }\n \n   current_sched_info->sched_max_insns_priority = sched_max_insns_priority;\n@@ -3224,6 +3243,7 @@ add_to_speculative_block (rtx insn)\n   ds_t ts;\n   dep_link_t link;\n   rtx twins = NULL;\n+  rtx_vec_t priorities_roots;\n \n   ts = TODO_SPEC (insn);\n   gcc_assert (!(ts & ~BE_IN_SPEC));\n@@ -3255,7 +3275,8 @@ add_to_speculative_block (rtx insn)\n \tlink = DEP_LINK_NEXT (link);\n     }\n \n-  clear_priorities (insn);\n+  priorities_roots = NULL;\n+  clear_priorities (insn, &priorities_roots);\n  \n   do\n     {\n@@ -3342,13 +3363,15 @@ add_to_speculative_block (rtx insn)\n       rtx twin;\n \n       twin = XEXP (twins, 0);\n-      calc_priorities (twin);\n       add_back_forw_dep (twin, insn, REG_DEP_OUTPUT, DEP_OUTPUT);\n \n       twin = XEXP (twins, 1);\n       free_INSN_LIST_node (twins);\n       twins = twin;      \n     }\n+\n+  calc_priorities (priorities_roots);\n+  VEC_free (rtx, heap, priorities_roots);\n }\n \n /* Extends and fills with zeros (only the new part) array pointed to by P.  */\n@@ -3793,8 +3816,11 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     /* Fix priorities.  If MUTATE_P is nonzero, this is not necessary,\n        because it'll be done later in add_to_speculative_block.  */\n     {\n-      clear_priorities (twin);\n-      calc_priorities (twin);\n+      rtx_vec_t priorities_roots = NULL;\n+\n+      clear_priorities (twin, &priorities_roots);\n+      calc_priorities (priorities_roots);\n+      VEC_free (rtx, heap, priorities_roots);\n     }\n }\n \n@@ -4281,42 +4307,50 @@ sched_remove_insn (rtx insn)\n   remove_insn (insn);\n }\n \n-/* Clear priorities of all instructions, that are\n-   forward dependent on INSN.  */\n+/* Clear priorities of all instructions, that are forward dependent on INSN.\n+   Store in vector pointed to by ROOTS_PTR insns on which priority () should\n+   be invoked to initialize all cleared priorities.  */\n static void\n-clear_priorities (rtx insn)\n+clear_priorities (rtx insn, rtx_vec_t *roots_ptr)\n {\n   dep_link_t link;\n+  bool insn_is_root_p = true;\n+\n+  gcc_assert (QUEUE_INDEX (insn) != QUEUE_SCHEDULED);\n \n   FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n     {\n-      rtx pro = DEP_LINK_PRO (link);\n+      dep_t dep = DEP_LINK_DEP (link);\n+      rtx pro = DEP_PRO (dep);\n \n-      if (INSN_PRIORITY_KNOWN (pro))\n+      if (INSN_PRIORITY_STATUS (pro) >= 0\n+\t  && QUEUE_INDEX (insn) != QUEUE_SCHEDULED)\n \t{\n-\t  INSN_PRIORITY_KNOWN (pro) = 0;\n-\t  clear_priorities (pro);\n+\t  /* If DEP doesn't contribute to priority then INSN itself should\n+\t     be added to priority roots.  */\n+\t  if (contributes_to_priority_p (dep))\n+\t    insn_is_root_p = false;\n+\n+\t  INSN_PRIORITY_STATUS (pro) = -1;\n+\t  clear_priorities (pro, roots_ptr);\n \t}\n     }\n+\n+  if (insn_is_root_p)\n+    VEC_safe_push (rtx, heap, *roots_ptr, insn);\n }\n \n /* Recompute priorities of instructions, whose priorities might have been\n-   changed due to changes in INSN.  */\n+   changed.  ROOTS is a vector of instructions whose priority computation will\n+   trigger initialization of all cleared priorities.  */\n static void\n-calc_priorities (rtx insn)\n+calc_priorities (rtx_vec_t roots)\n {\n-  dep_link_t link;\n-\n-  FOR_EACH_DEP_LINK (link, INSN_BACK_DEPS (insn))\n-    {\n-      rtx pro = DEP_LINK_PRO (link);\n+  int i;\n+  rtx insn;\n \n-      if (!INSN_PRIORITY_KNOWN (pro))\n-\t{\n-\t  priority (pro);\n-\t  calc_priorities (pro);\n-\t}\n-    }\n+  for (i = 0; VEC_iterate (rtx, roots, i, insn); i++)\n+    priority (insn);\n }\n \n "}, {"sha": "db5f1e4a87f55ad65d749a337b741e0dbc6f76b9", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916fa4f033247e40c1fc7bad3211427766d3dca3/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=916fa4f033247e40c1fc7bad3211427766d3dca3", "patch": "@@ -537,8 +537,10 @@ struct haifa_insn_data\n   unsigned int fed_by_spec_load : 1;\n   unsigned int is_load_insn : 1;\n \n-  /* Nonzero if priority has been computed already.  */\n-  unsigned int priority_known : 1;\n+  /* '> 0' if priority is valid,\n+     '== 0' if priority was not yet computed,\n+     '< 0' if priority in invalid and should be recomputed.  */\n+  signed char priority_status;\n \n   /* Nonzero if instruction has internal dependence\n      (e.g. add_dependence was invoked with (insn == elem)).  */\n@@ -574,7 +576,8 @@ extern regset *glat_start, *glat_end;\n #define CANT_MOVE(insn)\t\t(h_i_d[INSN_UID (insn)].cant_move)\n #define INSN_DEP_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].dep_count)\n #define INSN_PRIORITY(INSN)\t(h_i_d[INSN_UID (INSN)].priority)\n-#define INSN_PRIORITY_KNOWN(INSN) (h_i_d[INSN_UID (INSN)].priority_known)\n+#define INSN_PRIORITY_STATUS(INSN) (h_i_d[INSN_UID (INSN)].priority_status)\n+#define INSN_PRIORITY_KNOWN(INSN) (INSN_PRIORITY_STATUS (INSN) > 0)\n #define INSN_REG_WEIGHT(INSN)\t(h_i_d[INSN_UID (INSN)].reg_weight)\n #define HAS_INTERNAL_DEP(INSN)  (h_i_d[INSN_UID (INSN)].has_internal_dep)\n #define TODO_SPEC(INSN)         (h_i_d[INSN_UID (INSN)].todo_spec)"}]}