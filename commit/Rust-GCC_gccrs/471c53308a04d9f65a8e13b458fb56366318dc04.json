{"sha": "471c53308a04d9f65a8e13b458fb56366318dc04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcxYzUzMzA4YTA0ZDlmNjVhOGUxM2I0NThmYjU2MzY2MzE4ZGMwNA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2019-11-07T01:01:07Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2019-11-07T01:01:07Z"}, "message": "Move string concatenation for C into the parser.\n\nThis patch is another piece of preparation for C2x attributes support.\n\nC2x attributes require unbounded lookahead in the parser, because the\ntoken sequence '[[' that starts a C2x attribute is also valid in\nObjective-C in some of the same contexts, so it is necessary to see\nwhether the matching ']]' are consecutive tokens or not to determine\nwhether those tokens start an attribute.\n\nUnbounded lookahead means lexing an unbounded number of tokens before\nthey are parsed.  c_lex_one_token does various context-sensitive\nprocessing of tokens that cannot be done at that lookahead time,\nbecause it depends on information (such as whether particular\nidentifiers are typedefs) that may be different at the time it is\nrelevant than at the time the lookahead is needed (recall that more or\nless arbitrary C code, including declarations and statements, can\nappear inside expressions in GNU C).\n\nMost of that context-sensitive processing is not a problem, simply\nbecause it is not needed for lookahead purposes so can be deferred\nuntil the tokens lexed during lookahead are parsed.  However, the\nearliest piece of context-sensitive processing is the handling of\nstring literals based on flags passed to c_lex_with_flags, which\ndetermine whether adjacent literals are concatenated and whether\ntranslation to the execution character set occurs.\n\nBecause the choice of whether to translate to the execution character\nset is context-sensitive, this means that unbounded lookahead requires\nthe C parser to move to the approach used by the C++ parser, where\nstring literals are generally not translated or concatenated from\nwithin c_lex_with_flags, but only later in the parser once it knows\nwhether translation is needed.  (Translation requires the tokens in\ntheir form before concatenation.)\n\nThus, this patch makes that change to the C parser.  Flags in the\nparser are still used for two special cases similar to C++: the\nhandling of an initial #pragma pch_preprocess, and arranging for\nstrings inside attributes not to be translated (the latter is made\nmore logically correct by saving and restoring the flags, as in the\nC++ parser, rather than assuming that the state outside the attribute\nwas always to translate string literals, which might not be the case\nin corner cases involving declarations and attributes inside\nattributes).\n\nThe consequent change to pragma_lex to use c_parser_string_literal\nmakes it disallow wide strings and disable translation in that\ncontext, which also follows C++ and is more logically correct than the\nprevious state without special handling in that regard.  Translation\nto the execution character set is always disabled when string\nconstants are handled in the GIMPLE parser.\n\nAlthough the handling of strings is now a lot closer to that in C++,\nthere are still some differences, in particular regarding the handling\nof locations.  See c-c++-common/Wformat-pr88257.c, which has different\nexpected multiline diagnostic output for C and C++, for example; I'm\nnot sure whether the C or C++ output is better there (C++ has a more\ncomplete range than C, C mentions a macro definition location that C++\ndoesn't), but I tried to keep the locations the same as those\npreviously used by the C front end, as far as possible, to minimize\nthe testsuite changes needed, rather than possibly making them closer\nto those used with C++.\n\nThe only changes needed for tests of user-visible diagnostics were for\nthe wording of one diagnostic changing to match C++ (as a consequence\nof having a check for wide strings based on a flag in a general\nstring-handling function rather than in a function specific to asm).\nHowever, although locations are extremely similar to what they were\nbefore, I couldn't make them completely identical in all cases.  (My\nunderstanding of the implementation reason for the differences is as\nfollows: lex_string uses src_loc from each cpp_token; the C parser is\nusing the virtual location from cpp_get_token_with_location as called\nby c_lex_with_flags, and while passing that through\nlinemap_resolve_location with LRK_MACRO_DEFINITION_LOCATION, as this\npatch does, produces something very close to what lex_string uses,\nit's not completely identical in some cases.)\n\nThis results in changes being needed to two of the gcc.dg/plugin tests\nthat use a plugin to test details of how string locations are handled.\nBecause the tests being changed are for ICEs and the only change is to\nthe details of the particular non-user-visible error that code gives\nin cases it can't handle (one involving __FILE__, one involving a\nstring literal from stringizing), I think it's OK to change that\nnon-user-visible error and that the new errors are no worse than the\nold ones.  So these particular errors are now different for C and C++\n(some other messages in those tests already had differences between C\nand C++).\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\ngcc/c:\n\t* c-parser.c (c_parser): Remove lex_untranslated_string.  Add\n\tlex_joined_string and translate_strings_p.\n\t(c_lex_one_token): Pass 0 or C_LEX_STRING_NO_JOIN to\n\tc_lex_with_flags.\n\t(c_parser_string_literal): New function.\n\t(c_parser_static_assert_declaration_no_semi): Use\n\tc_parser_string_literal.  Do not set lex_untranslated_string.\n\t(c_parser_asm_string_literal): Use c_parser_string_literal.\n\t(c_parser_simple_asm_expr): Do not set lex_untranslated_string.\n\t(c_parser_gnu_attributes): Set and restore translate_strings_p\n\tinstead of lex_untranslated_string.\n\t(c_parser_asm_statement): Do not set lex_untranslated_string.\n\t(c_parser_asm_operands): Likewise.\n\t(c_parser_has_attribute_expression): Set and restore\n\ttranslate_strings_p instead of lex_untranslated_string.\n\t(c_parser_postfix_expression): Use c_parser_string_literal.\n\t(pragma_lex): Likewise.\n\t(c_parser_pragma_pch_preprocess): Set lex_joined_string.\n\t(c_parse_file): Set translate_strings_p.\n\t* gimple-parser.c (c_parser_gimple_postfix_expression)\n\t(c_parser_gimple_or_rtl_pass_list): Use c_parser_string_literal.\n\t* c-parser.c (c_parser_string_literal): Declare function.\n\ngcc/testsuite:\n\t* gcc.dg/asm-wide-1.c, gcc.dg/diagnostic-token-ranges.c,\n\tgcc.dg/plugin/diagnostic-test-string-literals-1.c,\n\tgcc.dg/plugin/diagnostic-test-string-literals-2.c: Update expected\n\tdiagnostics.\n\nFrom-SVN: r277903", "tree": {"sha": "240ddd729d1e0f52d11fba5710599cc6a5d48533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/240ddd729d1e0f52d11fba5710599cc6a5d48533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/471c53308a04d9f65a8e13b458fb56366318dc04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471c53308a04d9f65a8e13b458fb56366318dc04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/471c53308a04d9f65a8e13b458fb56366318dc04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/471c53308a04d9f65a8e13b458fb56366318dc04/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fa38297b22d826f53f0b1894a1847eca3503dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fa38297b22d826f53f0b1894a1847eca3503dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74fa38297b22d826f53f0b1894a1847eca3503dc"}], "stats": {"total": 342, "additions": 261, "deletions": 81}, "files": [{"sha": "c7bb22dc7a2135b9f897af2fc6605ec82cbc4f1d", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -1,3 +1,28 @@\n+2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.c (c_parser): Remove lex_untranslated_string.  Add\n+\tlex_joined_string and translate_strings_p.\n+\t(c_lex_one_token): Pass 0 or C_LEX_STRING_NO_JOIN to\n+\tc_lex_with_flags.\n+\t(c_parser_string_literal): New function.\n+\t(c_parser_static_assert_declaration_no_semi): Use\n+\tc_parser_string_literal.  Do not set lex_untranslated_string.\n+\t(c_parser_asm_string_literal): Use c_parser_string_literal.\n+\t(c_parser_simple_asm_expr): Do not set lex_untranslated_string.\n+\t(c_parser_gnu_attributes): Set and restore translate_strings_p\n+\tinstead of lex_untranslated_string.\n+\t(c_parser_asm_statement): Do not set lex_untranslated_string.\n+\t(c_parser_asm_operands): Likewise.\n+\t(c_parser_has_attribute_expression): Set and restore\n+\ttranslate_strings_p instead of lex_untranslated_string.\n+\t(c_parser_postfix_expression): Use c_parser_string_literal.\n+\t(pragma_lex): Likewise.\n+\t(c_parser_pragma_pch_preprocess): Set lex_joined_string.\n+\t(c_parse_file): Set translate_strings_p.\n+\t* gimple-parser.c (c_parser_gimple_postfix_expression)\n+\t(c_parser_gimple_or_rtl_pass_list): Use c_parser_string_literal.\n+\t* c-parser.c (c_parser_string_literal): Declare function.\n+\n 2019-11-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-parser.c (c_finish_omp_declare_variant): Use"}, {"sha": "4f044127a7e2f8b551fc0bf7c583ab0248d1fa21", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 211, "deletions": 63, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -185,8 +185,15 @@ struct GTY(()) c_parser {\n   BOOL_BITFIELD in_pragma : 1;\n   /* True if we're parsing the outermost block of an if statement.  */\n   BOOL_BITFIELD in_if_block : 1;\n-  /* True if we want to lex an untranslated string.  */\n-  BOOL_BITFIELD lex_untranslated_string : 1;\n+  /* True if we want to lex a translated, joined string (for an\n+     initial #pragma pch_preprocess).  Otherwise the parser is\n+     responsible for concatenating strings and translating to the\n+     execution character set as needed.  */\n+  BOOL_BITFIELD lex_joined_string : 1;\n+  /* True if, when the parser is concatenating string literals, it\n+     should translate them to the execution character set (false\n+     inside attributes).  */\n+  BOOL_BITFIELD translate_strings_p : 1;\n \n   /* Objective-C specific parser/lexer information.  */\n \n@@ -253,8 +260,8 @@ c_lex_one_token (c_parser *parser, c_token *token)\n \n   token->type = c_lex_with_flags (&token->value, &token->location,\n \t\t\t\t  &token->flags,\n-\t\t\t\t  (parser->lex_untranslated_string\n-\t\t\t\t   ? C_LEX_STRING_NO_TRANSLATE : 0));\n+\t\t\t\t  (parser->lex_joined_string\n+\t\t\t\t   ? 0 : C_LEX_STRING_NO_JOIN));\n   token->id_kind = C_ID_NONE;\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n@@ -2481,7 +2488,6 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n   location_t value_tok_loc = c_parser_peek_token (parser)->location;\n   value = c_parser_expr_no_commas (parser, NULL).value;\n   value_loc = EXPR_LOC_OR_LOC (value, value_tok_loc);\n-  parser->lex_untranslated_string = true;\n   if (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n@@ -2492,13 +2498,10 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n \tcase CPP_STRING32:\n \tcase CPP_WSTRING:\n \tcase CPP_UTF8STRING:\n-\t  string = c_parser_peek_token (parser)->value;\n-\t  c_parser_consume_token (parser);\n-\t  parser->lex_untranslated_string = false;\n+\t  string = c_parser_string_literal (parser, false, true).value;\n \t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected string literal\");\n-\t  parser->lex_untranslated_string = false;\n \t  return;\n \t}\n     }\n@@ -4200,34 +4203,15 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n \n    asm-string-literal:\n      string-literal\n-\n-   ??? At present, following the old parser, the caller needs to have\n-   set lex_untranslated_string to 1.  It would be better to follow the\n-   C++ parser rather than using this kludge.  */\n+*/\n \n static tree\n c_parser_asm_string_literal (c_parser *parser)\n {\n   tree str;\n   int save_flag = warn_overlength_strings;\n   warn_overlength_strings = 0;\n-  if (c_parser_next_token_is (parser, CPP_STRING))\n-    {\n-      str = c_parser_peek_token (parser)->value;\n-      c_parser_consume_token (parser);\n-    }\n-  else if (c_parser_next_token_is (parser, CPP_WSTRING))\n-    {\n-      error_at (c_parser_peek_token (parser)->location,\n-\t\t\"wide string literal in %<asm%>\");\n-      str = build_string (1, \"\");\n-      c_parser_consume_token (parser);\n-    }\n-  else\n-    {\n-      c_parser_error (parser, \"expected string literal\");\n-      str = NULL_TREE;\n-    }\n+  str = c_parser_string_literal (parser, false, false).value;\n   warn_overlength_strings = save_flag;\n   return str;\n }\n@@ -4245,18 +4229,11 @@ c_parser_simple_asm_expr (c_parser *parser)\n {\n   tree str;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));\n-  /* ??? Follow the C++ parser rather than using the\n-     lex_untranslated_string kludge.  */\n-  parser->lex_untranslated_string = true;\n   c_parser_consume_token (parser);\n   matching_parens parens;\n   if (!parens.require_open (parser))\n-    {\n-      parser->lex_untranslated_string = false;\n-      return NULL_TREE;\n-    }\n+    return NULL_TREE;\n   str = c_parser_asm_string_literal (parser);\n-  parser->lex_untranslated_string = false;\n   if (!parens.require_close (parser))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -4457,7 +4434,6 @@ c_parser_gnu_attribute (c_parser *parser, tree attrs,\n     c_parser_consume_token (parser);\n   else\n     {\n-      parser->lex_untranslated_string = false;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t \"expected %<)%>\");\n       return error_mark_node;\n@@ -4483,20 +4459,19 @@ c_parser_gnu_attributes (c_parser *parser)\n   tree attrs = NULL_TREE;\n   while (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n     {\n-      /* ??? Follow the C++ parser rather than using the\n-\t lex_untranslated_string kludge.  */\n-      parser->lex_untranslated_string = true;\n+      bool save_translate_strings_p = parser->translate_strings_p;\n+      parser->translate_strings_p = false;\n       /* Consume the `__attribute__' keyword.  */\n       c_parser_consume_token (parser);\n       /* Look for the two `(' tokens.  */\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t{\n-\t  parser->lex_untranslated_string = false;\n+\t  parser->translate_strings_p = save_translate_strings_p;\n \t  return attrs;\n \t}\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t{\n-\t  parser->lex_untranslated_string = false;\n+\t  parser->translate_strings_p = save_translate_strings_p;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t  return attrs;\n \t}\n@@ -4518,7 +4493,7 @@ c_parser_gnu_attributes (c_parser *parser)\n \tc_parser_consume_token (parser);\n       else\n \t{\n-\t  parser->lex_untranslated_string = false;\n+\t  parser->translate_strings_p = save_translate_strings_p;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  return attrs;\n@@ -4527,12 +4502,12 @@ c_parser_gnu_attributes (c_parser *parser)\n \tc_parser_consume_token (parser);\n       else\n \t{\n-\t  parser->lex_untranslated_string = false;\n+\t  parser->translate_strings_p = save_translate_strings_p;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  return attrs;\n \t}\n-      parser->lex_untranslated_string = false;\n+      parser->translate_strings_p = save_translate_strings_p;\n     }\n \n   return attrs;\n@@ -6487,9 +6462,6 @@ c_parser_asm_statement (c_parser *parser)\n   bool is_inline = (inline_loc != UNKNOWN_LOCATION);\n   bool is_goto = (goto_loc != UNKNOWN_LOCATION);\n \n-  /* ??? Follow the C++ parser rather than using the\n-     lex_untranslated_string kludge.  */\n-  parser->lex_untranslated_string = true;\n   ret = NULL;\n \n   matching_parens parens;\n@@ -6577,7 +6549,6 @@ c_parser_asm_statement (c_parser *parser)\n \t\t\t\t\tclobbers, labels, simple, is_inline));\n \n  error:\n-  parser->lex_untranslated_string = false;\n   return ret;\n \n  error_close_paren:\n@@ -6628,16 +6599,11 @@ c_parser_asm_operands (c_parser *parser)\n       str = c_parser_asm_string_literal (parser);\n       if (str == NULL_TREE)\n \treturn NULL_TREE;\n-      parser->lex_untranslated_string = false;\n       matching_parens parens;\n       if (!parens.require_open (parser))\n-\t{\n-\t  parser->lex_untranslated_string = true;\n-\t  return NULL_TREE;\n-\t}\n+\treturn NULL_TREE;\n       expr = c_parser_expression (parser);\n       mark_exp_read (expr.value);\n-      parser->lex_untranslated_string = true;\n       if (!parens.require_close (parser))\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -6718,6 +6684,185 @@ c_parser_asm_goto_operands (c_parser *parser)\n     }\n }\n \n+/* Parse a possibly concatenated sequence of string literals.\n+   TRANSLATE says whether to translate them to the execution character\n+   set; WIDE_OK says whether any kind of prefixed string literal is\n+   permitted in this context.  This code is based on that in\n+   lex_string.  */\n+\n+struct c_expr\n+c_parser_string_literal (c_parser *parser, bool translate, bool wide_ok)\n+{\n+  struct c_expr ret;\n+  size_t count;\n+  struct obstack str_ob;\n+  struct obstack loc_ob;\n+  cpp_string str, istr, *strs;\n+  c_token *tok;\n+  location_t loc, last_tok_loc;\n+  enum cpp_ttype type;\n+  tree value, string_tree;\n+\n+  tok = c_parser_peek_token (parser);\n+  loc = tok->location;\n+  last_tok_loc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t\t   LRK_MACRO_DEFINITION_LOCATION,\n+\t\t\t\t\t   NULL);\n+  type = tok->type;\n+  switch (type)\n+    {\n+    case CPP_STRING:\n+    case CPP_WSTRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n+    case CPP_UTF8STRING:\n+      string_tree = tok->value;\n+      break;\n+\n+    default:\n+      c_parser_error (parser, \"expected string literal\");\n+      ret.set_error ();\n+      ret.value = NULL_TREE;\n+      ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL_TREE;\n+      return ret;\n+    }\n+\n+  /* Try to avoid the overhead of creating and destroying an obstack\n+     for the common case of just one string.  */\n+  switch (c_parser_peek_2nd_token (parser)->type)\n+    {\n+    default:\n+      c_parser_consume_token (parser);\n+      str.text = (const unsigned char *) TREE_STRING_POINTER (string_tree);\n+      str.len = TREE_STRING_LENGTH (string_tree);\n+      count = 1;\n+      strs = &str;\n+      break;\n+\n+    case CPP_STRING:\n+    case CPP_WSTRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n+    case CPP_UTF8STRING:\n+      gcc_obstack_init (&str_ob);\n+      gcc_obstack_init (&loc_ob);\n+      count = 0;\n+      do\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  count++;\n+\t  str.text = (const unsigned char *) TREE_STRING_POINTER (string_tree);\n+\t  str.len = TREE_STRING_LENGTH (string_tree);\n+\t  if (type != tok->type)\n+\t    {\n+\t      if (type == CPP_STRING)\n+\t\ttype = tok->type;\n+\t      else if (tok->type != CPP_STRING)\n+\t\terror (\"unsupported non-standard concatenation \"\n+\t\t       \"of string literals\");\n+\t    }\n+\t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n+\t  obstack_grow (&loc_ob, &last_tok_loc, sizeof (location_t));\n+\t  tok = c_parser_peek_token (parser);\n+\t  string_tree = tok->value;\n+\t  last_tok_loc\n+\t    = linemap_resolve_location (line_table, tok->location,\n+\t\t\t\t\tLRK_MACRO_DEFINITION_LOCATION, NULL);\n+\t}\n+      while (tok->type == CPP_STRING\n+\t     || tok->type == CPP_WSTRING\n+\t     || tok->type == CPP_STRING16\n+\t     || tok->type == CPP_STRING32\n+\t     || tok->type == CPP_UTF8STRING);\n+      strs = (cpp_string *) obstack_finish (&str_ob);\n+    }\n+\n+  if (count > 1 && !in_system_header_at (input_location))\n+    warning (OPT_Wtraditional,\n+\t     \"traditional C rejects string constant concatenation\");\n+\n+  if ((type == CPP_STRING || wide_ok)\n+      && ((translate\n+\t  ? cpp_interpret_string : cpp_interpret_string_notranslate)\n+\t  (parse_in, strs, count, &istr, type)))\n+    {\n+      value = build_string (istr.len, (const char *) istr.text);\n+      free (CONST_CAST (unsigned char *, istr.text));\n+      if (count > 1)\n+\t{\n+\t  location_t *locs = (location_t *) obstack_finish (&loc_ob);\n+\t  gcc_assert (g_string_concat_db);\n+\t  g_string_concat_db->record_string_concatenation (count, locs);\n+\t}\n+    }\n+  else\n+    {\n+      if (type != CPP_STRING && !wide_ok)\n+\t{\n+\t  error_at (loc, \"a wide string is invalid in this context\");\n+\t  type = CPP_STRING;\n+\t}\n+      /* Callers cannot generally handle error_mark_node in this\n+\t context, so return the empty string instead.  An error has\n+\t been issued, either above or from cpp_interpret_string.  */\n+      switch (type)\n+\t{\n+\tdefault:\n+\tcase CPP_STRING:\n+\tcase CPP_UTF8STRING:\n+\t  value = build_string (1, \"\");\n+\t  break;\n+\tcase CPP_STRING16:\n+\t  value = build_string (TYPE_PRECISION (char16_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\");  /* char16_t is 16 bits */\n+\t  break;\n+\tcase CPP_STRING32:\n+\t  value = build_string (TYPE_PRECISION (char32_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\\0\\0\");  /* char32_t is 32 bits */\n+\t  break;\n+\tcase CPP_WSTRING:\n+\t  value = build_string (TYPE_PRECISION (wchar_type_node)\n+\t\t\t\t/ TYPE_PRECISION (char_type_node),\n+\t\t\t\t\"\\0\\0\\0\");  /* widest supported wchar_t\n+\t\t\t\t\t       is 32 bits */\n+\t  break;\n+        }\n+    }\n+\n+  switch (type)\n+    {\n+    default:\n+    case CPP_STRING:\n+    case CPP_UTF8STRING:\n+      TREE_TYPE (value) = char_array_type_node;\n+      break;\n+    case CPP_STRING16:\n+      TREE_TYPE (value) = char16_array_type_node;\n+      break;\n+    case CPP_STRING32:\n+      TREE_TYPE (value) = char32_array_type_node;\n+      break;\n+    case CPP_WSTRING:\n+      TREE_TYPE (value) = wchar_array_type_node;\n+    }\n+  value = fix_string_type (value);\n+\n+  if (count > 1)\n+    {\n+      obstack_free (&str_ob, 0);\n+      obstack_free (&loc_ob, 0);\n+    }\n+\n+  ret.value = value;\n+  ret.original_code = STRING_CST;\n+  ret.original_type = NULL_TREE;\n+  set_c_expr_source_range (&ret, get_range_from_loc (line_table, loc));\n+  return ret;\n+}\n+\n /* Parse an expression other than a compound expression; that is, an\n    assignment expression (C90 6.3.16, C99 6.5.16, C11 6.5.16).  If\n    AFTER is not NULL then it is an Objective-C message expression which\n@@ -7700,14 +7845,14 @@ c_parser_has_attribute_expression (c_parser *parser)\n       return result;\n     }\n \n-  parser->lex_untranslated_string = true;\n+  bool save_translate_strings_p = parser->translate_strings_p;\n \n   location_t atloc = c_parser_peek_token (parser)->location;\n   /* Parse a single attribute.  Require no leading comma and do not\n      allow empty attributes.  */\n   tree attr = c_parser_gnu_attribute (parser, NULL_TREE, false, false);\n \n-  parser->lex_untranslated_string = false;\n+  parser->translate_strings_p = save_translate_strings_p;\n \n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     c_parser_consume_token (parser);\n@@ -8202,10 +8347,8 @@ c_parser_postfix_expression (c_parser *parser)\n     case CPP_STRING32:\n     case CPP_WSTRING:\n     case CPP_UTF8STRING:\n-      expr.value = c_parser_peek_token (parser)->value;\n-      set_c_expr_source_range (&expr, tok_range);\n-      expr.original_code = STRING_CST;\n-      c_parser_consume_token (parser);\n+      expr = c_parser_string_literal (parser, parser->translate_strings_p,\n+\t\t\t\t      true);\n       break;\n     case CPP_OBJC_STRING:\n       gcc_assert (c_dialect_objc ());\n@@ -11687,6 +11830,8 @@ pragma_lex (tree *value, location_t *loc)\n \n   if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)\n     ret = CPP_EOF;\n+  else if (ret == CPP_STRING)\n+    *value = c_parser_string_literal (the_parser, false, false).value;\n   else\n     {\n       if (ret == CPP_KEYWORD)\n@@ -11702,6 +11847,7 @@ c_parser_pragma_pch_preprocess (c_parser *parser)\n {\n   tree name = NULL;\n \n+  parser->lex_joined_string = true;\n   c_parser_consume_pragma (parser);\n   if (c_parser_next_token_is (parser, CPP_STRING))\n     {\n@@ -11711,6 +11857,7 @@ c_parser_pragma_pch_preprocess (c_parser *parser)\n   else\n     c_parser_error (parser, \"expected string literal\");\n   c_parser_skip_to_pragma_eol (parser);\n+  parser->lex_joined_string = false;\n \n   if (name)\n     c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n@@ -20783,6 +20930,7 @@ c_parse_file (void)\n   c_parser tparser;\n \n   memset (&tparser, 0, sizeof tparser);\n+  tparser.translate_strings_p = true;\n   tparser.tokens = &tparser.tokens_buf[0];\n   the_parser = &tparser;\n "}, {"sha": "641da2fce390cf88ee1d01aae665513346117251", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -185,6 +185,7 @@ c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n   return c_parser_peek_token (parser)->keyword == keyword;\n }\n \n+struct c_expr c_parser_string_literal (c_parser *, bool, bool);\n extern struct c_declarator *\n c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n \t\t     bool *seen_id);"}, {"sha": "ceec758ffbea9f755f2ba2974ef07ef2b9d03a6c", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -1406,10 +1406,7 @@ c_parser_gimple_postfix_expression (gimple_parser &parser)\n     case CPP_STRING32:\n     case CPP_WSTRING:\n     case CPP_UTF8STRING:\n-      expr.value = c_parser_peek_token (parser)->value;\n-      set_c_expr_source_range (&expr, tok_range);\n-      expr.original_code = STRING_CST;\n-      c_parser_consume_token (parser);\n+      expr = c_parser_string_literal (parser, false, true);\n       break;\n     case CPP_DOT:\n       expr = c_parser_gimple_call_internal (parser);\n@@ -1926,8 +1923,8 @@ c_parser_gimple_or_rtl_pass_list (c_parser *parser, c_declspecs *specs)\n \t      return;\n \t    }\n \t  pass = xstrdup (TREE_STRING_POINTER\n-\t\t\t\t(c_parser_peek_token (parser)->value));\n-\t  c_parser_consume_token (parser);\n+\t\t\t  (c_parser_string_literal (parser, false,\n+\t\t\t\t\t\t    false).value));\n \t  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<(%>\"))\n \t    return;\n \t}"}, {"sha": "e40445337f66bdcc3dde3c81adac42363db5c975", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -1,3 +1,10 @@\n+2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/asm-wide-1.c, gcc.dg/diagnostic-token-ranges.c,\n+\tgcc.dg/plugin/diagnostic-test-string-literals-1.c,\n+\tgcc.dg/plugin/diagnostic-test-string-literals-2.c: Update expected\n+\tdiagnostics.\n+\n 2019-11-06  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* gcc.dg/framework-1.c: Adjust test header path."}, {"sha": "5ddc4c7d9cfd4ea0eac3fb1fa2344db4b19e1ff0", "filename": "gcc/testsuite/gcc.dg/asm-wide-1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -3,29 +3,29 @@\n /* { dg-do compile } */\n /* { dg-options \"\" } */\n \n-int foo asm (L\"bar\"); /* { dg-error \"14:wide string literal in 'asm'\" } */\n+int foo asm (L\"bar\"); /* { dg-error \"14:a wide string is invalid in this context\" } */\n \n-asm (L\"foo\"); /* { dg-error \"6:wide string literal in 'asm'\" } */\n+asm (L\"foo\"); /* { dg-error \"6:a wide string is invalid in this context\" } */\n \n void\n f (void)\n {\n   int x = 1;\n-  asm (L\"foo\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+  asm (L\"foo\"); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   asm (\"foo\" :\n-       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   /* Extra errors from the substitution of \"\" for wide strings: */\n   /* { dg-error \"output\" \"output\" { target *-*-* } .-2 } */\n   asm (\"foo\" : [x]\n-       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   /* { dg-error \"output\" \"output\" { target *-*-* } .-1 } */\n   asm (\"foo\" : [x] \"=g\" (x),\n-       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   /* { dg-error \"output\" \"output\" { target *-*-* } .-1 } */\n   asm (\"foo\" : :\n-       L\"g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"g\" (x)); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   asm (\"foo\" : : :\n-       L\"memory\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"memory\"); /* { dg-error \"8:a wide string is invalid in this context\" } */\n   asm (\"foo\" : : : \"memory\",\n-       L\"memory\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n+       L\"memory\"); /* { dg-error \"8:a wide string is invalid in this context\" } */\n }"}, {"sha": "7d7ec0a9e0b0dd30625d0f2afd10d061b6a3a17a", "filename": "gcc/testsuite/gcc.dg/diagnostic-token-ranges.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiagnostic-token-ranges.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -67,7 +67,7 @@ foo (unknown_type param); /* { dg-error \"unknown type name 'unknown_type'\" } */\n \n void wide_string_literal_in_asm (void)\n {\n-  __asm (L\"nop\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+  __asm (L\"nop\"); /* { dg-error \"a wide string is invalid in this context\" } */\n /*\n { dg-begin-multiline-output \"\" }\n    __asm (L\"nop\");"}, {"sha": "ac4fa1b52bd3cd30e2bdb071a2b59f64876e6860", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-string-literals-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -332,7 +332,8 @@ pr87652 (const char *stem, int counter)\n \t\t\t\tOFFSET + end_idx);\t\t\\\n   } while (0)\n \n-/* { dg-error \"unable to read substring location: failed to get ordinary maps\" \"\" { target *-*-* } 329 } */\n+/* { dg-error \"unable to read substring location: unable to read source line\" \"\" { target c } 329 } */\n+/* { dg-error \"unable to read substring location: failed to get ordinary maps\" \"\" { target c++ } 329 } */\n /* { dg-begin-multiline-output \"\" }\n      __emit_string_literal_range(__FILE__\":%5d: \" format, \\\n                                  ^~~~~~~~"}, {"sha": "3e855b3cca0f5cb7215f6d5f30e4b455935285e2", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-string-literals-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/471c53308a04d9f65a8e13b458fb56366318dc04/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c?ref=471c53308a04d9f65a8e13b458fb56366318dc04", "patch": "@@ -69,7 +69,8 @@ test_pr79210 (void)\n   \"some multiline blurb with a short final line \"\n   \"here\");\n \n-  /* { dg-error \"19: unable to read substring location: line is not wide enough\" \"\" { target *-*-* } .-11 } */\n+  /* { dg-error \"19: unable to read substring location: range endpoints are on different lines\" \"\" { target c } .-11 } */\n+  /* { dg-error \"19: unable to read substring location: line is not wide enough\" \"\" { target c++ } .-12 } */\n \n #undef LPFC_VPORT_ATTR_R\n #undef lpfc_vport_param_init"}]}