{"sha": "d597b3ce68d904078ca38bca09c5e8984d934364", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5N2IzY2U2OGQ5MDQwNzhjYTM4YmNhMDljNWU4OTg0ZDkzNDM2NA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-01-21T16:14:49Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-01-21T16:14:49Z"}, "message": "re PR c++/26693 (Access checks not performed for types in templates)\n\ngcc/ChangeLog:\n2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n\n\tPR c++/26693\n\t* c-decl.c: (clone_underlying_type): Move this  ...\n\t* c-common.c (set_underlying_type): ... here.\n\tAlso, make sure the function  properly sets TYPE_STUB_DECL() on\n\tthe newly created typedef variant type.\n\t(is_typedef_decl ): New entry point.\n\t* tree.h: Added a new member member_types_needing_access_check to\n\tstruct tree_decl_non_common.\n\t(set_underlying_type): New entry point.\n\t(is_typedef_type): Likewise.\n\ngcc/cp/ChangeLog/\n2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n\n\tPR c++/26693\n\t* decl2.c (grokfield): when a typedef appears in a\n\tclass, create the typedef variant type node for it.\n\t(save_template_attributes): Creating typedef variant type node\n\t here is now useless.\n\t* decl.c (grokdeclarator): If the typedef'ed struct/class was\n\tanonymous, set the proper type name to all its type variants.\n\t* name-lookup.c (pushdecl_maybe_friend): Reuse the\n\tset_underlying_type function to install typedef variant types.\n\t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): New template accessor\n\tmacro.\n\t(append_type_to_template_for_access_check): New entry points.\n\t* semantics.c (check_accessibility_of_qualified_id):\n\tWhen a typedef that is a member of a class appears in a template,\n\tadd it to the template. It will be ...\n\t* pt.c (instantiate_class_template, instantiate_template ): ... access\n\tchecked at template instantiation time.\n\t(tsubst): Handle the case of being called with NULL args.\n\t(resolve_type_name_type): The type name should be the name of the\n\tmain type variant.\n\t(append_type_to_template_for_access_check): New entry point.\n\ngcc/testsuite/ChangeLog\n2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n\n\tPR c++/26693\n\t* g++.dg/template/typedef11.C: New test.\n\t* g++.dg/template/typedef12.C: Likewise.\n\t* g++.dg/template/typedef13.C: Likewise.\n\t* g++.dg/template/typedef14.C: Likewise.\n\t* g++.dg/template/sfinae3.C: Compile this pedantically.\n\tThe only errors expected should be the one saying the typedef is ill\n\tformed.\n\t* g++.old-deja/g++.pt/typename8.C: Likewise.\n\t* g++.dg/template/access11.C: Update this.\n\nlibstdc++-v3/ChangeLog:\n2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n\n\t* include/ext/bitmap_allocator.h: the typedefs should be made public\n\tif we want them to be accessible. This has been revealed by the patch\n\tthat fixes PR c++/26693 in g++.\n\nFrom-SVN: r143546", "tree": {"sha": "9c26f4fbfa6128e66099ace4205d1bd99cc4c3a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c26f4fbfa6128e66099ace4205d1bd99cc4c3a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d597b3ce68d904078ca38bca09c5e8984d934364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d597b3ce68d904078ca38bca09c5e8984d934364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d597b3ce68d904078ca38bca09c5e8984d934364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d597b3ce68d904078ca38bca09c5e8984d934364/comments", "author": null, "committer": null, "parents": [{"sha": "210879b85b09194934eabcf5777cf2cff6e8dedc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210879b85b09194934eabcf5777cf2cff6e8dedc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210879b85b09194934eabcf5777cf2cff6e8dedc"}], "stats": {"total": 471, "additions": 364, "deletions": 107}, "files": [{"sha": "bc4c3619059b3444b99bdf7918aa3f9d54df3a46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1,3 +1,16 @@\n+2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* c-decl.c: (clone_underlying_type): Move this  ...\n+\t* c-common.c (set_underlying_type): ... here.\n+\tAlso, make sure the function  properly sets TYPE_STUB_DECL() on\n+\tthe newly created typedef variant type.\n+\t(is_typedef_decl ): New entry point.\n+\t* tree.h: Added a new member member_types_needing_access_check to\n+\tstruct tree_decl_non_common.\n+\t(set_underlying_type): New entry point.\n+\t(is_typedef_type): Likewise.\n+\n 2009-01-21  Bingfeng Mei  <bmei@broadcom.com>\n \n \t* alias.c (walk_mems_1, walk_mems_2, insn_alias_sets_conflict_p):"}, {"sha": "f398cf859e02699b87f2d7b6a6e1439576f04a04", "filename": "gcc/c-common.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -8363,4 +8363,73 @@ warn_for_sign_compare (location_t location,\n     }\n }\n \n+/* Setup a TYPE_DECL node as a typedef representation.\n+\n+   X is a TYPE_DECL for a typedef statement.  Create a brand new\n+   ..._TYPE node (which will be just a variant of the existing\n+   ..._TYPE node with identical properties) and then install X\n+   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n+\n+   The whole point here is to end up with a situation where each\n+   and every ..._TYPE node the compiler creates will be uniquely\n+   associated with AT MOST one node representing a typedef name.\n+   This way, even though the compiler substitutes corresponding\n+   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n+   early on, later parts of the compiler can always do the reverse\n+   translation and get back the corresponding typedef name.  For\n+   example, given:\n+\n+\ttypedef struct S MY_TYPE;\n+\tMY_TYPE object;\n+\n+   Later parts of the compiler might only know that `object' was of\n+   type `struct S' if it were not for code just below.  With this\n+   code however, later parts of the compiler see something like:\n+\n+\tstruct S' == struct S\n+\ttypedef struct S' MY_TYPE;\n+\tstruct S' object;\n+\n+    And they can then deduce (from the node for type struct S') that\n+    the original object declaration was:\n+\n+\t\tMY_TYPE object;\n+\n+    Being able to do this is important for proper support of protoize,\n+    and also for generating precise symbolic debugging information\n+    which takes full account of the programmer's (typedef) vocabulary.\n+\n+    Obviously, we don't want to generate a duplicate ..._TYPE node if\n+    the TYPE_DECL node that we are now processing really represents a\n+    standard built-in type.  */\n+\n+void\n+set_underlying_type (tree x)\n+{\n+  if (DECL_IS_BUILTIN (x))\n+    {\n+      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n+\tTYPE_NAME (TREE_TYPE (x)) = x;\n+    }\n+  else if (TREE_TYPE (x) != error_mark_node\n+\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n+    {\n+      tree tt = TREE_TYPE (x);\n+      DECL_ORIGINAL_TYPE (x) = tt;\n+      tt = build_variant_type_copy (tt);\n+      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n+      TYPE_NAME (tt) = x;\n+      TREE_USED (tt) = TREE_USED (x);\n+      TREE_TYPE (x) = tt;\n+    }\n+}\n+\n+/* Returns true if X is a typedef type.  */\n+bool\n+is_typedef_decl (tree x)\n+{\n+  return (x && TREE_CODE (x) == TYPE_DECL\n+          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "8b444d4177a31073bcec06685e034c862c2a1df0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1971,67 +1971,6 @@ warn_if_shadowing (tree new_decl)\n       }\n }\n \n-\n-/* Subroutine of pushdecl.\n-\n-   X is a TYPE_DECL for a typedef statement.  Create a brand new\n-   ..._TYPE node (which will be just a variant of the existing\n-   ..._TYPE node with identical properties) and then install X\n-   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n-\n-   The whole point here is to end up with a situation where each\n-   and every ..._TYPE node the compiler creates will be uniquely\n-   associated with AT MOST one node representing a typedef name.\n-   This way, even though the compiler substitutes corresponding\n-   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n-   early on, later parts of the compiler can always do the reverse\n-   translation and get back the corresponding typedef name.  For\n-   example, given:\n-\n-\ttypedef struct S MY_TYPE;\n-\tMY_TYPE object;\n-\n-   Later parts of the compiler might only know that `object' was of\n-   type `struct S' if it were not for code just below.  With this\n-   code however, later parts of the compiler see something like:\n-\n-\tstruct S' == struct S\n-\ttypedef struct S' MY_TYPE;\n-\tstruct S' object;\n-\n-    And they can then deduce (from the node for type struct S') that\n-    the original object declaration was:\n-\n-\t\tMY_TYPE object;\n-\n-    Being able to do this is important for proper support of protoize,\n-    and also for generating precise symbolic debugging information\n-    which takes full account of the programmer's (typedef) vocabulary.\n-\n-    Obviously, we don't want to generate a duplicate ..._TYPE node if\n-    the TYPE_DECL node that we are now processing really represents a\n-    standard built-in type.  */\n-\n-static void\n-clone_underlying_type (tree x)\n-{\n-  if (DECL_IS_BUILTIN (x))\n-    {\n-      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n-\tTYPE_NAME (TREE_TYPE (x)) = x;\n-    }\n-  else if (TREE_TYPE (x) != error_mark_node\n-\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n-    {\n-      tree tt = TREE_TYPE (x);\n-      DECL_ORIGINAL_TYPE (x) = tt;\n-      tt = build_variant_type_copy (tt);\n-      TYPE_NAME (tt) = x;\n-      TREE_USED (tt) = TREE_USED (x);\n-      TREE_TYPE (x) = tt;\n-    }\n-}\n-\n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n    name already seen in the same scope).\n@@ -2254,7 +2193,7 @@ pushdecl (tree x)\n \n  skip_external_and_shadow_checks:\n   if (TREE_CODE (x) == TYPE_DECL)\n-    clone_underlying_type (x);\n+    set_underlying_type (x);\n \n   bind (name, x, scope, /*invisible=*/false, nested);\n "}, {"sha": "b2ca4cf3ec2e3440018dc28c2c4cad3e9bb3b847", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1,3 +1,27 @@\n+2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* decl2.c (grokfield): when a typedef appears in a\n+\tclass, create the typedef variant type node for it.\n+\t(save_template_attributes): Creating typedef variant type node\n+\t here is now useless.\n+\t* decl.c (grokdeclarator): If the typedef'ed struct/class was\n+\tanonymous, set the proper type name to all its type variants.\n+\t* name-lookup.c (pushdecl_maybe_friend): Reuse the\n+\tset_underlying_type function to install typedef variant types.\n+\t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): New template accessor\n+\tmacro.\n+\t(append_type_to_template_for_access_check): New entry points.\n+\t* semantics.c (check_accessibility_of_qualified_id):\n+\tWhen a typedef that is a member of a class appears in a template,\n+\tadd it to the template. It will be ...\n+\t* pt.c (instantiate_class_template, instantiate_template ): ... access\n+\tchecked at template instantiation time.\n+\t(tsubst): Handle the case of being called with NULL args.\n+\t(resolve_type_name_type): The type name should be the name of the\n+\tmain type variant.\n+\t(append_type_to_template_for_access_check): New entry point.\n+\n 2009-01-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/23287"}, {"sha": "b740700e1838de646f5162b52ce9ef9a675d9d55", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -3179,6 +3179,14 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n    && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n \n+/* The chained list of some types that are referenced in templates.\n+   These types are those which need to be access checked at\n+   template instantiation time.  For the time being, only typedef-ed types defined\n+   as class members are put here at parsing time.\n+   Other types for which access check could be required at template instantiation\n+   time could be added later.  */\n+#define MEMBER_TYPES_NEEDING_ACCESS_CHECK(NODE) DECL_ACCESS (NODE)\n+\n /* Nonzero if NODE which declares a type.  */\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n@@ -4539,6 +4547,7 @@ extern tree check_explicit_specialization\t(tree, tree, int, int);\n extern tree make_auto\t\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n+extern void append_type_to_template_for_access_check (tree, tree, tree);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, tree, bool, bool);"}, {"sha": "2163e397cd2950a2d360448b1d0b12f5abfe1cfd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -8729,6 +8729,7 @@ grokdeclarator (const cp_declarator *declarator,\n \tdecl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n       else\n \tdecl = build_decl (TYPE_DECL, unqualified_id, type);\n+\n       if (id_declarator && declarator->u.id.qualifying_scope) {\n \terror (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n \tTREE_TYPE (decl) = error_mark_node;\n@@ -8763,12 +8764,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t  && TYPE_ANONYMOUS_P (type)\n \t  && cp_type_quals (type) == TYPE_UNQUALIFIED)\n \t{\n-\t  tree oldname = TYPE_NAME (type);\n \t  tree t;\n \n \t  /* Replace the anonymous name with the real name everywhere.  */\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-\t    if (TYPE_NAME (t) == oldname)\n+\t    if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n \t      TYPE_NAME (t) = decl;\n \n \t  if (TYPE_LANG_SPECIFIC (type))"}, {"sha": "22192a001baf0338ddf2a1237800ac49554cd25f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -804,6 +804,9 @@ grokfield (const cp_declarator *declarator,\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n \n+      if (declspecs->specs[(int)ds_typedef])\n+\tset_underlying_type (value);\n+\n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n \n@@ -1125,19 +1128,6 @@ save_template_attributes (tree *attr_p, tree *decl_p)\n   if (!late_attrs)\n     return;\n \n-  /* Give this type a name so we know to look it up again at instantiation\n-     time.  */\n-  if (TREE_CODE (*decl_p) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (*decl_p) == NULL_TREE)\n-    {\n-      tree oldt = TREE_TYPE (*decl_p);\n-      tree newt = build_variant_type_copy (oldt);\n-      DECL_ORIGINAL_TYPE (*decl_p) = oldt;\n-      TREE_TYPE (*decl_p) = newt;\n-      TYPE_NAME (newt) = *decl_p;\n-      TREE_USED (newt) = TREE_USED (*decl_p);\n-    }\n-\n   if (DECL_P (*decl_p))\n     q = &DECL_ATTRIBUTES (*decl_p);\n   else"}, {"sha": "2c69cfe68a6f972385c23f2a31b99d6b448f4a2e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -847,28 +847,20 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n+\t name.  See the extensive comment of set_underlying_type ().  */\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  tree type = TREE_TYPE (x);\n-\t  if (DECL_IS_BUILTIN (x))\n-\t    {\n-\t      if (TYPE_NAME (type) == 0)\n-\t\tTYPE_NAME (type) = x;\n-\t    }\n-\t  else if (type != error_mark_node && TYPE_NAME (type) != x\n-\t\t   /* We don't want to copy the type when all we're\n-\t\t      doing is making a TYPE_DECL for the purposes of\n-\t\t      inlining.  */\n-\t\t   && (!TYPE_NAME (type)\n-\t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n-\t    {\n-\t      DECL_ORIGINAL_TYPE (x) = type;\n-\t      type = build_variant_type_copy (type);\n-\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n-\t      TYPE_NAME (type) = x;\n-\t      TREE_TYPE (x) = type;\n-\t    }\n+\n+\t  if (DECL_IS_BUILTIN (x)\n+\t      || (TREE_TYPE (x) != error_mark_node\n+\t\t  && TYPE_NAME (type) != x\n+\t\t  /* We don't want to copy the type when all we're\n+\t\t     doing is making a TYPE_DECL for the purposes of\n+\t\t     inlining.  */\n+\t\t  && (!TYPE_NAME (type)\n+\t\t      || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x))))\n+\t    set_underlying_type (x);\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)"}, {"sha": "36edb449e009c6ae0d15a31d180e980ec4bf5c36", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -7387,6 +7387,31 @@ instantiate_class_template (tree type)\n \t  && DECL_TEMPLATE_INFO (t))\n \ttsubst_default_arguments (t);\n \n+  /* Some types referenced from within the template code need to be access\n+     checked at template instantiation time, i.e now. These types were\n+     added to the template at parsing time. Let's get those and perfom\n+     the acces checks then.  */\n+  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ); t; t = TREE_CHAIN (t))\n+    {\n+      tree type_decl = TREE_PURPOSE (t);\n+      tree type_scope = TREE_VALUE (t);\n+\n+      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n+\tcontinue;\n+\n+      if (uses_template_parms (type_decl))\n+\ttype_decl = tsubst (type_decl, args, tf_error, NULL_TREE);\n+\n+      if (uses_template_parms (type_scope))\n+\ttype_scope = tsubst (type_scope, args, tf_error, NULL_TREE);\n+\n+      gcc_assert (type_decl && type_decl != error_mark_node\n+\t\t  && type_scope && type_scope != error_mark_node);\n+\n+      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n+    }\n+\n+  perform_deferred_access_checks ();\n   pop_nested_class ();\n   pop_from_top_level ();\n   pop_deferring_access_checks ();\n@@ -11869,6 +11894,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   tree fndecl;\n   tree gen_tmpl;\n   tree spec;\n+  tree t;\n   HOST_WIDE_INT saved_processing_template_decl;\n \n   if (tmpl == error_mark_node)\n@@ -11947,6 +11973,24 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   /* Now we know the specialization, compute access previously\n      deferred.  */\n   push_access_scope (fndecl);\n+\n+  /* Some types referenced from within the template code need to be access\n+     checked at template instantiation time, i.e now. These types were\n+     added to the template at parsing time. Let's get those and perfom\n+     the acces checks then.  */\n+  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (tmpl); t; t = TREE_CHAIN (t))\n+    {\n+      tree type_decl = TREE_PURPOSE (t);\n+      tree type_scope = TREE_VALUE (t);\n+\n+      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n+\tcontinue;\n+\n+      if (uses_template_parms (type_decl))\n+\ttype_decl = tsubst (type_decl, targ_ptr, tf_error, NULL_TREE);\n+\n+      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n+    }\n   perform_deferred_access_checks ();\n   pop_access_scope (fndecl);\n   pop_deferring_access_checks ();\n@@ -16633,7 +16677,15 @@ resolve_typename_type (tree type, bool only_current_p)\n   gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n   scope = TYPE_CONTEXT (type);\n-  name = TYPE_IDENTIFIER (type);\n+  /* Usually the non-qualified identifier of a TYPENAME_TYPE is\n+     TYPE_IDENTIFIER (type). But when 'type' is a typedef variant of\n+     a TYPENAME_TYPE node, then TYPE_NAME (type) is set to the TYPE_DECL representing\n+     the typedef. In that case TYPE_IDENTIFIER (type) is not the non-qualified\n+     identifier  of the TYPENAME_TYPE anymore.\n+     So by getting the TYPE_IDENTIFIER of the _main declaration_ of the\n+     TYPENAME_TYPE instead, we avoid messing up with a possible\n+     typedef variant case.  */\n+  name = TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (type));\n \n   /* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve\n      it first before we can figure out what NAME refers to.  */\n@@ -16958,4 +17010,45 @@ type_uses_auto (tree type)\n   return NULL_TREE;\n }\n \n+/* Append TYPE_DECL to the template TMPL.\n+   TMPL is eiter a class type or a FUNCTION_DECL associated\n+   to a TEMPLATE_DECL.\n+   At TMPL instanciation time, TYPE_DECL will be checked to see\n+   if it can be accessed through SCOPE.  */\n+void\n+append_type_to_template_for_access_check (tree templ,\n+                                          tree type_decl,\n+\t\t\t\t\t  tree scope)\n+{\n+  tree node, templ_decl;\n+\n+  gcc_assert (templ\n+\t      && get_template_info (templ)\n+\t      && TI_TEMPLATE (get_template_info (templ))\n+\t      && type_decl\n+\t      && (TREE_CODE (type_decl) == TYPE_DECL));\n+\n+  templ_decl = TI_TEMPLATE (get_template_info (templ));\n+  gcc_assert (templ_decl);\n+\n+  /* Make sure we don't append the type to the template twice.\n+     If this appears to be too slow, the\n+     MEMBER_TYPE_NEEDING_ACCESS_CHECK property\n+     of templ should be a hash table instead.  */\n+  for (node = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl);\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree decl = TREE_PURPOSE (node);\n+      tree type_scope = TREE_VALUE (node);\n+\n+      if (decl == type_decl && type_scope == scope)\n+\treturn;\n+    }\n+\n+  MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl) =\n+    tree_cons (type_decl, scope,\n+\t       MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl));\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "528a0c5de85c894514cebef9c991b25406ed6e68", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1529,6 +1529,30 @@ check_accessibility_of_qualified_id (tree decl,\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n \n+  /* If we are parsing a template declaration and if decl is a typedef,\n+     add it to a list tied to the template.\n+     At template instantiation time, that list will be walked and\n+     access check performed.  */\n+  if (is_typedef_decl (decl))\n+    {\n+      /* This the scope through which type_decl is accessed.\n+\t It will be useful information later to do access check for\n+\t type_decl usage.  */\n+      tree scope = nested_name_specifier ? nested_name_specifier : DECL_CONTEXT (decl);\n+      tree templ_info = NULL;\n+      tree cs = current_scope ();\n+\n+      if (cs && (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL))\n+\ttempl_info = get_template_info (cs);\n+\n+      if (templ_info\n+\t  && TI_TEMPLATE (templ_info)\n+\t  && scope\n+\t  && CLASS_TYPE_P (scope)\n+\t  && !currently_open_class (scope))\n+\tappend_type_to_template_for_access_check (current_scope (), decl, scope);\n+    }\n+\n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return;"}, {"sha": "91b8d8ae64328db49ac38c859b6d35606f625e09", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1,3 +1,16 @@\n+2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* g++.dg/template/typedef11.C: New test.\n+\t* g++.dg/template/typedef12.C: Likewise.\n+\t* g++.dg/template/typedef13.C: Likewise.\n+\t* g++.dg/template/typedef14.C: Likewise.\n+\t* g++.dg/template/sfinae3.C: Compile this pedantically.\n+\tThe only errors expected should be the one saying the typedef is ill\n+\tformed.\n+\t* g++.old-deja/g++.pt/typename8.C: Likewise.\n+\t* g++.dg/template/access11.C: Update this.\n+\n 2009-01-21  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/38887"}, {"sha": "38bd5155f65b81126d639d9779b1241c9f013f21", "filename": "gcc/testsuite/g++.dg/template/access11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -17,8 +17,8 @@ template <> struct X::Y<int> {\n   A::X x;\t\t\t// { dg-error \"this context\" }\n };\n \n-template <typename T> struct X::Y {\n+template <typename T> struct X::Y { // { dg-error \"this context\" }\n   typename T::X x;\t\t// { dg-error \"this context\" }\n };\n \n-template struct X::Y<A>;\t// { dg-message \"instantiated\" }\n+template struct X::Y<A>;\t// { dg-message \"instantiated from here\" }"}, {"sha": "349463d95fe3680f893bbbdd704148cfc69f4588", "filename": "gcc/testsuite/g++.dg/template/sfinae3.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1,5 +1,5 @@\n // PR c++/24671\n-// { dg-options \"\" }\n+// { dg-do compile }\n \n template<typename> struct A\n {\n@@ -9,9 +9,9 @@ template<typename> struct A\n \n template<typename> struct B\n {\n-  B(const B&); // { dg-message \"candidate\" }\n-  typedef typename A<char[A<B>::i]>::X Y;\n-  template<typename T> B(T, Y); // { dg-error \"call\" }\n+  B(const B&);\n+  typedef typename A<char[A<B>::i]>::X Y; // { dg-error \"forbids zero-size array\" }\n+  template<typename T> B(T, Y);\n };\n \n-B<int> b(0,0); \n+B<int> b(0,0); // { dg-message \"instantiated from here\" }"}, {"sha": "c7c7c989f729330474b0abf0fd0a6eeadad1dfb3", "filename": "gcc/testsuite/g++.dg/template/typedef11.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -0,0 +1,25 @@\n+// Author: Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+\n+class Alpha\n+{\n+  typedef int X; // { dg-error \"'typedef int Alpha::X' is private\" }\n+};\n+\n+template<int>\n+class Beta\n+{\n+    typedef int Y; // { dg-error \"'typedef int Beta<0>::Y' is private\" }\n+};\n+\n+template <int>\n+int\n+bar ()\n+{\n+  Beta<0>::Y i = 0;\n+  return Alpha::X ();\n+}\n+\n+int i = bar<0> (); // { dg-error \"within this context\" }"}, {"sha": "30605044f6f2469e639ce6a8a19ca0b3210913a4", "filename": "gcc/testsuite/g++.dg/template/typedef12.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -0,0 +1,23 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: Jason Merrill <jason@redhat.com>, PR c++/26693\n+// { dg-do compile }\n+\n+class A\n+{\n+     protected:\n+           typedef int mytype;\n+};\n+\n+template <class T> class B;\n+\n+class C: public A\n+{\n+      template <class T> friend class B;\n+};\n+\n+template <class T> class B\n+{\n+      C::mytype mem;\n+};\n+\n+B<int> b;"}, {"sha": "aa8bb3268298c6e044416a4425344644b26c106a", "filename": "gcc/testsuite/g++.dg/template/typedef13.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -0,0 +1,16 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+class A\n+{\n+  typedef int mytype; // { dg-error \"typedef int A::mytype' is private\" }\n+};\n+\n+template <class T> class B : public A\n+{ // { dg-error \"within this context\"  }\n+  mytype mem;\n+};\n+\n+B<int> b; // { dg-message \"instantiated from here\" }\n+"}, {"sha": "caa565a08cd0154a36eb9964c59b263e62089591", "filename": "gcc/testsuite/g++.dg/template/typedef14.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -0,0 +1,16 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+template <class T>\n+struct A\n+{\n+  typedef int mytype;\n+\n+  void\n+  foo ()\n+  {\n+    mytype v = ~static_cast<mytype> (0);\n+  }\n+};\n+"}, {"sha": "4861cf301ed38b5d18bf635a7a95f2c1559bb0c4", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename8.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -5,14 +5,14 @@ template < class T > class A\n public:\n   typedef typename T::myT anotherT; // { dg-error \"\" } undefined type\n \n-  anotherT t; // { dg-error \"\" } undefined type \n+  anotherT t;\n \n   A() { }\n-  A(anotherT _t) { // { dg-error \"\" } undefined type\n+  A(anotherT _t) {\n     t=_t;\n   }\n \n-  anotherT getT() { // { dg-error \"\" } undefined type\n+  anotherT getT() {\n     return t;\n   }\n };"}, {"sha": "f7ff2e6d92b3fb39096c0e3f5f95b79d2b36c55d", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -3412,6 +3412,9 @@ struct tree_target_option GTY(())\n /* Return a tree node that encapsulates the current target options.  */\n extern tree build_target_option_node (void);\n \n+extern void set_underlying_type (tree x);\n+\n+extern bool is_typedef_decl (tree x);\n \f\n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above"}, {"sha": "274171097354dfb46a188a1293b1978668d9d0dc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -1,3 +1,9 @@\n+2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/ext/bitmap_allocator.h: the typedefs should be made public\n+\tif we want them to be accessible. This has been revealed by the patch\n+\tthat fixes PR c++/26693 in g++.\n+\n 2009-01-20  Benjamin Kosnik  <bkoz@redhat.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "7768bd2396db5a3152cce89cf7a232239e132546", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d597b3ce68d904078ca38bca09c5e8984d934364/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d597b3ce68d904078ca38bca09c5e8984d934364/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=d597b3ce68d904078ca38bca09c5e8984d934364", "patch": "@@ -549,11 +549,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    */\n   class free_list\n   {\n+  public:\n     typedef size_t* \t\t\t\tvalue_type;\n     typedef __detail::__mini_vector<value_type> vector_type;\n     typedef vector_type::iterator \t\titerator;\n     typedef __mutex\t\t\t\t__mutex_type;\n \n+  private:\n     struct _LT_pointer_compare\n     {\n       bool"}]}