{"sha": "b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "node_id": "C_kwDOANBUbNoAKGI4ZmZhNzFlNDI3MWFlNTYyYzJkMzE1YjliMjRjNDk3OWJiZjgyMjc", "commit": {"author": {"name": "Anthony Sharp", "email": "anthonysharp15@gmail.com", "date": "2021-12-04T17:23:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-13T21:01:52Z"}, "message": "c++: warning for dependent template members [PR70417]\n\nAdd a helpful warning message for when the user forgets to\ninclude the \"template\" keyword after ., -> or :: when\naccessing a member in a dependent context, where the member is a\ntemplate.\n\n\tPR c++/70417\n\ngcc/c-family/ChangeLog:\n\n\t* c.opt: Added -Wmissing-template-keyword.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_id_expression): Handle\n\t-Wmissing-template-keyword.\n\t(struct saved_token_sentinel): Add modes to control what happens\n\ton destruction.\n\t(cp_parser_statement): Adjust.\n\t(cp_parser_skip_entire_template_parameter_list): New function that\n\tskips an entire template parameter list.\n\t(cp_parser_require_end_of_template_parameter_list): Rename old\n\tcp_parser_skip_to_end_of_template_parameter_list.\n\t(cp_parser_skip_to_end_of_template_parameter_list): Refactor to be\n\tcalled from one of the above two functions.\n\t(cp_parser_lambda_declarator_opt)\n\t(cp_parser_explicit_template_declaration)\n\t(cp_parser_enclosed_template_argument_list): Adjust.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Documentation for Wmissing-template-keyword.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/variadic-mem_fn2.C: Catch warning about missing\n\ttemplate keyword.\n\t* g++.dg/template/dependent-name17.C: New test.\n\t* g++.dg/template/dependent-name18.C: New test.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "aebd29fe180c0bd88e3634cb2fb5315cf645eb60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aebd29fe180c0bd88e3634cb2fb5315cf645eb60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/comments", "author": {"login": "anthonysharpy", "id": 55365296, "node_id": "MDQ6VXNlcjU1MzY1Mjk2", "avatar_url": "https://avatars.githubusercontent.com/u/55365296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anthonysharpy", "html_url": "https://github.com/anthonysharpy", "followers_url": "https://api.github.com/users/anthonysharpy/followers", "following_url": "https://api.github.com/users/anthonysharpy/following{/other_user}", "gists_url": "https://api.github.com/users/anthonysharpy/gists{/gist_id}", "starred_url": "https://api.github.com/users/anthonysharpy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anthonysharpy/subscriptions", "organizations_url": "https://api.github.com/users/anthonysharpy/orgs", "repos_url": "https://api.github.com/users/anthonysharpy/repos", "events_url": "https://api.github.com/users/anthonysharpy/events{/privacy}", "received_events_url": "https://api.github.com/users/anthonysharpy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a7d8c3f6167fd45658ddbfa32adcfd2acc98eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7d8c3f6167fd45658ddbfa32adcfd2acc98eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7d8c3f6167fd45658ddbfa32adcfd2acc98eb4"}], "stats": {"total": 270, "additions": 223, "deletions": 47}, "files": [{"sha": "dcda1cccedd74be25fe6016347c3c134fada2833", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -880,6 +880,10 @@ Wmissing-requires\n C++ ObjC++ Var(warn_missing_requires) Init(1) Warning\n Warn about likely missing requires keyword.\n \n+Wmissing-template-keyword\n+C++ ObjC++ Var(warn_missing_template_keyword) Init(1) Warning\n+Warn when the template keyword is missing after a member access token in a dependent member access expression if that member is a template.\n+\n Wmultistatement-macros\n C ObjC C++ ObjC++ Var(warn_multistatement_macros) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about unsafe macros expanding to multiple statements used as a body of a clause such as if, else, while, switch, or for."}, {"sha": "c06ed5e4dbd6474e85c2190a684dc996463de305", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 131, "deletions": 47, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -1275,30 +1275,48 @@ cp_lexer_rollback_tokens (cp_lexer* lexer)\n   lexer->next_token = lexer->saved_tokens.pop ();\n }\n \n-/* RAII wrapper around the above functions, with sanity checking.  Creating\n-   a variable saves tokens, which are committed when the variable is\n-   destroyed unless they are explicitly rolled back by calling the rollback\n-   member function.  */\n+/* Determines what saved_token_sentinel does when going out of scope.  */\n+\n+enum saved_token_sentinel_mode {\n+  STS_COMMIT,\n+  STS_ROLLBACK,\n+  STS_DONOTHING\n+};\n+\n+/* RAII wrapper around the above functions, with sanity checking (the token\n+   stream should be the same at the point of instantiation as it is at the\n+   point of destruction).\n+\n+   Creating a variable saves tokens.  MODE determines what happens when the\n+   object is destroyed.  STS_COMMIT commits tokens (default),\n+   STS_ROLLBACK rolls-back and STS_DONOTHING does nothing.  Calling\n+   rollback() will immediately roll-back tokens and set MODE to\n+   STS_DONOTHING.  */\n \n struct saved_token_sentinel\n {\n   cp_lexer *lexer;\n   unsigned len;\n-  bool commit;\n-  saved_token_sentinel(cp_lexer *lexer): lexer(lexer), commit(true)\n+  saved_token_sentinel_mode mode;\n+  saved_token_sentinel (cp_lexer *_lexer,\n+\t\t\tsaved_token_sentinel_mode _mode = STS_COMMIT)\n+    : lexer (_lexer), mode (_mode)\n   {\n     len = lexer->saved_tokens.length ();\n     cp_lexer_save_tokens (lexer);\n   }\n   void rollback ()\n   {\n     cp_lexer_rollback_tokens (lexer);\n-    commit = false;\n+    mode = STS_DONOTHING;\n   }\n-  ~saved_token_sentinel()\n+  ~saved_token_sentinel ()\n   {\n-    if (commit)\n+    if (mode == STS_COMMIT)\n       cp_lexer_commit_tokens (lexer);\n+    else if (mode == STS_ROLLBACK)\n+      cp_lexer_rollback_tokens (lexer);\n+\n     gcc_assert (lexer->saved_tokens.length () == len);\n   }\n };\n@@ -2771,7 +2789,11 @@ static void cp_parser_skip_to_end_of_block_or_statement\n   (cp_parser *);\n static bool cp_parser_skip_to_closing_brace\n   (cp_parser *);\n-static void cp_parser_skip_to_end_of_template_parameter_list\n+static bool cp_parser_skip_entire_template_parameter_list\n+  (cp_parser *);\n+static void cp_parser_require_end_of_template_parameter_list\n+  (cp_parser *);\n+static bool cp_parser_skip_to_end_of_template_parameter_list\n   (cp_parser *);\n static void cp_parser_skip_to_pragma_eol\n   (cp_parser*, cp_token *);\n@@ -6129,47 +6151,41 @@ cp_parser_id_expression (cp_parser *parser,\n \t\t\t\t\t    template_keyword_p)\n        != NULL_TREE);\n \n+  cp_expr id = NULL_TREE;\n+  tree scope = parser->scope;\n+\n+  /* Peek at the next token.  */\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* If there is a nested-name-specifier, then we are looking at\n      the first qualified-id production.  */\n   if (nested_name_specifier_p)\n     {\n-      tree saved_scope;\n       tree saved_object_scope;\n       tree saved_qualifying_scope;\n-      cp_expr unqualified_id;\n-      bool is_template;\n \n       /* See if the next token is the `template' keyword.  */\n       if (!template_p)\n-\ttemplate_p = &is_template;\n+\ttemplate_p = &template_keyword_p;\n       *template_p = cp_parser_optional_template_keyword (parser);\n       /* Name lookup we do during the processing of the\n \t unqualified-id might obliterate SCOPE.  */\n-      saved_scope = parser->scope;\n       saved_object_scope = parser->object_scope;\n       saved_qualifying_scope = parser->qualifying_scope;\n       /* Process the final unqualified-id.  */\n-      unqualified_id = cp_parser_unqualified_id (parser, *template_p,\n-\t\t\t\t\t\t check_dependency_p,\n-\t\t\t\t\t\t declarator_p,\n-\t\t\t\t\t\t /*optional_p=*/false);\n+      id = cp_parser_unqualified_id (parser, *template_p,\n+\t\t\t\t     check_dependency_p,\n+\t\t\t\t     declarator_p,\n+\t\t\t\t     /*optional_p=*/false);\n       /* Restore the SAVED_SCOPE for our caller.  */\n-      parser->scope = saved_scope;\n+      parser->scope = scope;\n       parser->object_scope = saved_object_scope;\n       parser->qualifying_scope = saved_qualifying_scope;\n-\n-      return unqualified_id;\n     }\n   /* Otherwise, if we are in global scope, then we are looking at one\n      of the other qualified-id productions.  */\n   else if (global_scope_p)\n     {\n-      cp_token *token;\n-      tree id;\n-\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-\n       /* If it's an identifier, and the next token is not a \"<\", then\n \t we can avoid the template-id case.  This is an optimization\n \t for this common case.  */\n@@ -6195,11 +6211,15 @@ cp_parser_id_expression (cp_parser *parser,\n       switch (token->type)\n \t{\n \tcase CPP_NAME:\n-\t  return cp_parser_identifier (parser);\n+\t  id = cp_parser_identifier (parser);\n+\t  break;\n \n \tcase CPP_KEYWORD:\n \t  if (token->keyword == RID_OPERATOR)\n-\t    return cp_parser_operator_function_id (parser);\n+\t    {\n+\t      id = cp_parser_operator_function_id (parser);\n+\t      break;\n+\t    }\n \t  /* Fall through.  */\n \n \tdefault:\n@@ -6208,10 +6228,44 @@ cp_parser_id_expression (cp_parser *parser,\n \t}\n     }\n   else\n-    return cp_parser_unqualified_id (parser, template_keyword_p,\n+    {\n+      if (!scope)\n+\tscope = parser->context->object_type;\n+      id = cp_parser_unqualified_id (parser, template_keyword_p,\n \t\t\t\t     /*check_dependency_p=*/true,\n \t\t\t\t     declarator_p,\n \t\t\t\t     optional_p);\n+    }\n+\n+  if (id && TREE_CODE (id) == IDENTIFIER_NODE\n+      && warn_missing_template_keyword\n+      && !template_keyword_p\n+      /* Don't warn if we're looking inside templates.  */\n+      && check_dependency_p\n+      /* In a template argument list a > could be closing\n+\t the enclosing targs.  */\n+      && !parser->in_template_argument_list_p\n+      && scope && dependentish_scope_p (scope)\n+      /* Don't confuse an ill-formed constructor declarator for a missing\n+\t template keyword in a return type.  */\n+      && !(declarator_p && constructor_name_p (id, scope))\n+      && cp_parser_nth_token_starts_template_argument_list_p (parser, 1)\n+      && warning_enabled_at (token->location,\n+\t\t\t     OPT_Wmissing_template_keyword))\n+    {\n+      saved_token_sentinel toks (parser->lexer, STS_ROLLBACK);\n+      if (cp_parser_skip_entire_template_parameter_list (parser)\n+\t  /* An operator after the > suggests that the > ends a\n+\t     template-id; a name or literal suggests that the > is an\n+\t     operator.  */\n+\t  && (cp_lexer_peek_token (parser->lexer)->type\n+\t      <= CPP_LAST_PUNCTUATOR))\n+\twarning_at (token->location, OPT_Wmissing_template_keyword,\n+\t\t    \"expected %qs keyword before dependent \"\n+\t\t    \"template name\", \"template\");\n+    }\n+\n+  return id;\n }\n \n /* Parse an unqualified-id.\n@@ -11472,7 +11526,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       cp_lexer_consume_token (parser->lexer);\n \n       template_param_list = cp_parser_template_parameter_list (parser);\n-      cp_parser_skip_to_end_of_template_parameter_list (parser);\n+      cp_parser_require_end_of_template_parameter_list (parser);\n \n       /* We may have a constrained generic lambda; parse the requires-clause\n \t immediately after the template-parameter-list and combine with any\n@@ -12353,11 +12407,11 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t{\n \t  if (saved_tokens.lexer == lexer)\n \t    {\n-\t      if (saved_tokens.commit)\n+\t      if (saved_tokens.mode == STS_COMMIT)\n \t\tcp_lexer_commit_tokens (lexer);\n \t      gcc_assert (lexer->saved_tokens.length () == saved_tokens.len);\n \t      saved_tokens.lexer = parser->lexer;\n-\t      saved_tokens.commit = false;\n+\t      saved_tokens.mode = STS_DONOTHING;\n \t      saved_tokens.len = parser->lexer->saved_tokens.length ();\n \t    }\n \t  cp_lexer_destroy (lexer);\n@@ -31493,7 +31547,7 @@ cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)\n     }\n \n   /* Look for the `>'.  */\n-  cp_parser_skip_to_end_of_template_parameter_list (parser);\n+  cp_parser_require_end_of_template_parameter_list (parser);\n \n   /* Manage template requirements */\n   if (flag_concepts)\n@@ -32017,7 +32071,7 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n \t}\n     }\n   else\n-    cp_parser_skip_to_end_of_template_parameter_list (parser);\n+    cp_parser_require_end_of_template_parameter_list (parser);\n   /* The `>' token might be a greater-than operator again now.  */\n   parser->greater_than_is_operator_p\n     = saved_greater_than_is_operator_p;\n@@ -32912,22 +32966,52 @@ cp_parser_require (cp_parser* parser,\n     }\n }\n \n-/* An error message is produced if the next token is not '>'.\n-   All further tokens are skipped until the desired token is\n-   found or '{', '}', ';' or an unbalanced ')' or ']'.  */\n+/* Skip an entire parameter list from start to finish.  The next token must\n+   be the initial \"<\" of the parameter list.  Returns true on success and\n+   false otherwise.  */\n+\n+static bool\n+cp_parser_skip_entire_template_parameter_list (cp_parser* parser)\n+{\n+  /* Consume the \"<\" because cp_parser_skip_to_end_of_template_parameter_list\n+     requires it.  */\n+  cp_lexer_consume_token (parser->lexer);\n+  return cp_parser_skip_to_end_of_template_parameter_list (parser);\n+}\n+\n+/* Ensure we are at the end of a template parameter list.  If we are, return.\n+   If we are not, something has gone wrong, in which case issue an error and\n+   skip to end of the parameter list.  */\n \n static void\n+cp_parser_require_end_of_template_parameter_list (cp_parser* parser)\n+{\n+  /* Are we ready, yet?  If not, issue error message.  */\n+  if (cp_parser_require (parser, CPP_GREATER, RT_GREATER))\n+    return;\n+\n+  cp_parser_skip_to_end_of_template_parameter_list (parser);\n+}\n+\n+/* You should only call this function from inside a template parameter list\n+   (i.e. the current token should at least be the initial \"<\" of the\n+   parameter list).  If you are skipping the entire list, it may be better to\n+   use cp_parser_skip_entire_template_parameter_list.\n+\n+   Tokens are skipped until the final \">\" is found, or if we see\n+   '{', '}', ';', or if we find an unbalanced ')' or ']'.\n+\n+   Returns true if we successfully reached the end, and false if\n+   something unexpected happened (e.g. end of file).  */\n+\n+static bool\n cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n {\n   /* Current level of '< ... >'.  */\n   unsigned level = 0;\n   /* Ignore '<' and '>' nested inside '( ... )' or '[ ... ]'.  */\n   unsigned nesting_depth = 0;\n \n-  /* Are we ready, yet?  If not, issue error message.  */\n-  if (cp_parser_require (parser, CPP_GREATER, RT_GREATER))\n-    return;\n-\n   /* Skip tokens until the desired token is found.  */\n   while (true)\n     {\n@@ -32951,7 +33035,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n                  spurious.  Just consume the `>>' and stop; we've\n                  already produced at least one error.  */\n \t      cp_lexer_consume_token (parser->lexer);\n-\t      return;\n+\t      return false;\n \t    }\n           /* Fall through for C++0x, so we handle the second `>' in\n              the `>>'.  */\n@@ -32962,7 +33046,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n \t    {\n \t      /* We've reached the token we want, consume it and stop.  */\n \t      cp_lexer_consume_token (parser->lexer);\n-\t      return;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -32974,7 +33058,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n \tcase CPP_CLOSE_PAREN:\n \tcase CPP_CLOSE_SQUARE:\n \t  if (nesting_depth-- == 0)\n-\t    return;\n+\t    return false;\n \t  break;\n \n \tcase CPP_EOF:\n@@ -32983,7 +33067,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n \tcase CPP_OPEN_BRACE:\n \tcase CPP_CLOSE_BRACE:\n \t  /* The '>' was probably forgotten, don't look further.  */\n-\t  return;\n+\t  return false;\n \n \tdefault:\n \t  break;"}, {"sha": "5504971ea81376d5ae94c3c4850a32db48c7fc55", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -8963,6 +8963,39 @@ type @samp{T}.\n \n This warning can be disabled with @option{-Wno-missing-requires}.\n \n+@item -Wno-missing-template-keyword\n+@opindex Wmissing-template-keyword\n+@opindex Wno-missing-template-keyword\n+\n+The member access tokens ., -> and :: must be followed by the @code{template}\n+keyword if the parent object is dependent and the member being named is a\n+template.\n+\n+@smallexample\n+template <class X>\n+void DoStuff (X x)\n+@{\n+  x.template DoSomeOtherStuff<X>(); // Good.\n+  x.DoMoreStuff<X>(); // Warning, x is dependent.\n+@}\n+@end smallexample\n+\n+In rare cases it is possible to get false positives. To silence this, wrap\n+the expression in parentheses. For example, the following is treated as a\n+template, even where m and N are integers:\n+\n+@smallexample\n+void NotATemplate (my_class t)\n+@{\n+  int N = 5;\n+\n+  bool test = t.m < N > (0); // Treated as a template.\n+  test = (t.m < N) > (0); // Same meaning, but not treated as a template.\n+@}\n+@end smallexample\n+\n+This warning can be disabled with @option{-Wno-missing-template-keyword}.\n+\n @item -Wno-multichar\n @opindex Wno-multichar\n @opindex Wmultichar"}, {"sha": "c343f32086d784f11a842171000732a3e8fbdf56", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-mem_fn2.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-mem_fn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-mem_fn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-mem_fn2.C?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -5,5 +5,6 @@ template <class A0, class... As> struct tuple\n   tuple<As...> tail;\n   template <int Offset, class... More> int apply(const More&... more) {\n     return tail.apply<1>(more...); // { dg-error \"\" } needs .template\n+    // { dg-warning \"keyword before dependent template name\" \"\" { target *-*-* } .-1 }\n   }\n };"}, {"sha": "ff623e2d2badc26e812d2229708d5a3ffd12ac5b", "filename": "gcc/testsuite/g++.dg/template/dependent-name17.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name17.C?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -0,0 +1,49 @@\n+// C++ PR 70317\n+// { dg-do compile }\n+// { dg-prune-output \"expected primary-expression\" }\n+\n+template<class T> class mytemplateclass\n+{\n+public:\n+  template<class U> void class_func() {}\n+  template<class U> static void class_func_static() {}\n+};\n+\n+class myclass\n+{\n+public:\n+  int testint;\n+  template<class U> void class_func() {}\n+  template<class U> static void class_func_static() {}\n+};\n+\n+template<class Y> void tests_func(mytemplateclass<Y> c, myclass c2)\n+{\n+  /* Dependent template accessors (ill-formed code).  */\n+  c.class_func<Y>(); // { dg-warning \"keyword before dependent template name\" }\n+  (&c)->class_func<Y>(); // { dg-warning \"keyword before dependent template name\" }\n+  mytemplateclass<Y>::class_func_static<Y>(); // { dg-warning \"keyword before dependent template name\" }\n+\n+  /* Dependent template accessors (well-formed code).  */\n+  c.template class_func<Y>();\n+  (&c)->template class_func<Y>();\n+  mytemplateclass<Y>::template class_func_static<Y>();\n+\n+  /* Non-dependent template accessors (well-formed code).  */\n+  c2.class_func<myclass>();\n+  (&c2)->class_func<myclass>();\n+  myclass::class_func_static<myclass>();\n+}\n+\n+int main()\n+{\n+  mytemplateclass<myclass> c;\n+  myclass c2;\n+  tests_func<myclass>(c, c2);\n+\n+  c2.testint = 53;\n+  /* Make sure this isn't treated as a template.  */\n+  bool testbool = c2.testint < 999 > 7;\n+  /* This probably will be treated as a template initially but it should still work.  */\n+  testbool = c2.testint < 123 > (50);\n+}"}, {"sha": "f6f0a27a0bdcae45fc92a60436b2ddcd25154d4c", "filename": "gcc/testsuite/g++.dg/template/dependent-name18.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ffa71e4271ae562c2d315b9b24c4979bbf8227/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name18.C?ref=b8ffa71e4271ae562c2d315b9b24c4979bbf8227", "patch": "@@ -0,0 +1,5 @@\n+template <bool B> struct A { };\n+template <class T> void f()\n+{\n+  A<T::I < T::J>();\n+}"}]}