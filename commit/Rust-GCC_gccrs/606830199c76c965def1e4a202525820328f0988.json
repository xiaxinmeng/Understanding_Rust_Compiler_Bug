{"sha": "606830199c76c965def1e4a202525820328f0988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2ODMwMTk5Yzc2Yzk2NWRlZjFlNGEyMDI1MjU4MjAzMjhmMDk4OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-02-24T13:40:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-02-24T13:40:54Z"}, "message": "loop-iv.c (implies_p): Detect additional cases where A implies B.\n\n\t* loop-iv.c (implies_p): Detect additional cases where A implies B.\n\t(determine_max_iter): Take additional LOOP arg; all callers changed.\n\tLose broken logic dealing with PLUS.  Try to limit the upper bound by\n\tone using simplifications.\n\nFrom-SVN: r122288", "tree": {"sha": "67928433b94e9ad8469534989cfdcbab20edfa74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67928433b94e9ad8469534989cfdcbab20edfa74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/606830199c76c965def1e4a202525820328f0988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606830199c76c965def1e4a202525820328f0988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606830199c76c965def1e4a202525820328f0988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606830199c76c965def1e4a202525820328f0988/comments", "author": null, "committer": null, "parents": [{"sha": "e7d406d5392e7174efa6c18644364d030543334b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d406d5392e7174efa6c18644364d030543334b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d406d5392e7174efa6c18644364d030543334b"}], "stats": {"total": 151, "additions": 112, "deletions": 39}, "files": [{"sha": "13aa77851dea984f0ad3e11b710aadd7925da6c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606830199c76c965def1e4a202525820328f0988/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606830199c76c965def1e4a202525820328f0988/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=606830199c76c965def1e4a202525820328f0988", "patch": "@@ -1,3 +1,10 @@\n+2007-02-24  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* loop-iv.c (implies_p): Detect additional cases where A implies B.\n+\t(determine_max_iter): Take additional LOOP arg; all callers changed.\n+\tLose broken logic dealing with PLUS.  Try to limit the upper bound by\n+\tone using simplifications.\n+\n 2007-02-23  DJ Delorie  <dj@redhat.com>\n \n \t* doc/tm.h (BIGGEST_ALIGNMENT): Clarify the purpose of this macro."}, {"sha": "fb0ec4525ccb28602e11b7a4de6f8026eaac4dfa", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 105, "deletions": 39, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606830199c76c965def1e4a202525820328f0988/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606830199c76c965def1e4a202525820328f0988/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=606830199c76c965def1e4a202525820328f0988", "patch": "@@ -1392,14 +1392,34 @@ implies_p (rtx a, rtx b)\n \t}\n     }\n \n+  if (b == const_true_rtx)\n+    return true;\n+\n+  if ((GET_RTX_CLASS (GET_CODE (a)) != RTX_COMM_COMPARE\n+       && GET_RTX_CLASS (GET_CODE (a)) != RTX_COMPARE)\n+      || (GET_RTX_CLASS (GET_CODE (b)) != RTX_COMM_COMPARE\n+\t  && GET_RTX_CLASS (GET_CODE (b)) != RTX_COMPARE))\n+    return false;\n+\n+  op0 = XEXP (a, 0);\n+  op1 = XEXP (a, 1);\n+  opb0 = XEXP (b, 0);\n+  opb1 = XEXP (b, 1);\n+\n+  mode = GET_MODE (op0);\n+  if (mode != GET_MODE (opb0))\n+    mode = VOIDmode;\n+  else if (mode == VOIDmode)\n+    {\n+      mode = GET_MODE (op1);\n+      if (mode != GET_MODE (opb1))\n+\tmode = VOIDmode;\n+    }\n+\n   /* A < B implies A + 1 <= B.  */\n   if ((GET_CODE (a) == GT || GET_CODE (a) == LT)\n       && (GET_CODE (b) == GE || GET_CODE (b) == LE))\n     {\n-      op0 = XEXP (a, 0);\n-      op1 = XEXP (a, 1);\n-      opb0 = XEXP (b, 0);\n-      opb1 = XEXP (b, 1);\n \n       if (GET_CODE (a) == GT)\n \t{\n@@ -1415,22 +1435,82 @@ implies_p (rtx a, rtx b)\n \t  opb1 = r;\n \t}\n \n-      mode = GET_MODE (op0);\n-      if (mode != GET_MODE (opb0))\n-\tmode = VOIDmode;\n-      else if (mode == VOIDmode)\n-\t{\n-\t  mode = GET_MODE (op1);\n-\t  if (mode != GET_MODE (opb1))\n-\t    mode = VOIDmode;\n-\t}\n-\n       if (SCALAR_INT_MODE_P (mode)\n \t  && rtx_equal_p (op1, opb1)\n \t  && simplify_gen_binary (MINUS, mode, opb0, op0) == const1_rtx)\n \treturn true;\n+      return false;\n+    }\n+\n+  /* A < B or A > B imply A != B.  TODO: Likewise\n+     A + n < B implies A != B + n if neither wraps.  */\n+  if (GET_CODE (b) == NE\n+      && (GET_CODE (a) == GT || GET_CODE (a) == GTU\n+\t  || GET_CODE (a) == LT || GET_CODE (a) == LTU))\n+    {\n+      if (rtx_equal_p (op0, opb0)\n+\t  && rtx_equal_p (op1, opb1))\n+\treturn true;\n     }\n \n+  /* For unsigned comparisons, A != 0 implies A > 0 and A >= 1.  */\n+  if (GET_CODE (a) == NE\n+      && op1 == const0_rtx)\n+    {\n+      if ((GET_CODE (b) == GTU\n+\t   && opb1 == const0_rtx)\n+\t  || (GET_CODE (b) == GEU\n+\t      && opb1 == const1_rtx))\n+\treturn rtx_equal_p (op0, opb0);\n+    }\n+\n+  /* A != N is equivalent to A - (N + 1) <u -1.  */\n+  if (GET_CODE (a) == NE\n+      && GET_CODE (op1) == CONST_INT\n+      && GET_CODE (b) == LTU\n+      && opb1 == constm1_rtx\n+      && GET_CODE (opb0) == PLUS\n+      && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+      /* Avoid overflows.  */\n+      && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n+\t  != ((unsigned HOST_WIDE_INT)1\n+\t      << (HOST_BITS_PER_WIDE_INT - 1)) - 1)\n+      && INTVAL (XEXP (opb0, 1)) + 1 == -INTVAL (op1))\n+    return rtx_equal_p (op0, XEXP (opb0, 0));\n+\n+  /* Likewise, A != N implies A - N > 0.  */\n+  if (GET_CODE (a) == NE\n+      && GET_CODE (op1) == CONST_INT)\n+    {\n+      if (GET_CODE (b) == GTU\n+\t  && GET_CODE (opb0) == PLUS\n+\t  && opb1 == const0_rtx\n+\t  && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n+\t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+\t  && rtx_equal_p (XEXP (opb0, 0), op0))\n+\treturn INTVAL (op1) == -INTVAL (XEXP (opb0, 1));\n+      if (GET_CODE (b) == GEU\n+\t  && GET_CODE (opb0) == PLUS\n+\t  && opb1 == const1_rtx\n+\t  && GET_CODE (XEXP (opb0, 1)) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n+\t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+\t  && rtx_equal_p (XEXP (opb0, 0), op0))\n+\treturn INTVAL (op1) == -INTVAL (XEXP (opb0, 1));\n+    }\n+\n+  /* A >s X, where X is positive, implies A <u Y, if Y is negative.  */\n+  if ((GET_CODE (a) == GT || GET_CODE (a) == GE)\n+      && GET_CODE (op1) == CONST_INT\n+      && ((GET_CODE (a) == GT && op1 == constm1_rtx)\n+\t  || INTVAL (op1) >= 0)\n+      && GET_CODE (b) == LTU\n+      && GET_CODE (opb1) == CONST_INT)\n+    return INTVAL (opb1) < 0;\n+\n   return false;\n }\n \n@@ -1919,10 +1999,10 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n /* Tries to estimate the maximum number of iterations.  */\n \n static unsigned HOST_WIDEST_INT\n-determine_max_iter (struct niter_desc *desc)\n+determine_max_iter (struct loop *loop, struct niter_desc *desc)\n {\n   rtx niter = desc->niter_expr;\n-  rtx mmin, mmax, left, right;\n+  rtx mmin, mmax, cmp;\n   unsigned HOST_WIDEST_INT nmax, inc;\n \n   if (GET_CODE (niter) == AND\n@@ -1952,31 +2032,17 @@ determine_max_iter (struct niter_desc *desc)\n   else\n     inc = 1;\n \n-  if (GET_CODE (niter) == PLUS)\n+  /* We could use a binary search here, but for now improving the upper\n+     bound by just one eliminates one important corner case.  */\n+  cmp = gen_rtx_fmt_ee (desc->signed_p ? LT : LTU, VOIDmode, niter, mmax);\n+  simplify_using_initial_values (loop, UNKNOWN, &cmp);\n+  if (cmp == const_true_rtx)\n     {\n-      left = XEXP (niter, 0);\n-      right = XEXP (niter, 0);\n+      nmax--;\n \n-      if (GET_CODE (right) == CONST_INT)\n-\tright = GEN_INT (-INTVAL (right));\n-    }\n-  else if (GET_CODE (niter) == MINUS)\n-    {\n-      left = XEXP (niter, 0);\n-      right = XEXP (niter, 0);\n-    }\n-  else\n-    {\n-      left = niter;\n-      right = mmin;\n+      if (dump_file)\n+\tfprintf (dump_file, \";; improved upper bound by one.\\n\");\n     }\n-\n-  if (GET_CODE (left) == CONST_INT)\n-    mmax = left;\n-  if (GET_CODE (right) == CONST_INT)\n-    mmin = right;\n-  nmax = INTVAL (mmax) - INTVAL (mmin);\n-\n   desc->niter_max = nmax / inc;\n   return nmax / inc;\n }\n@@ -2499,7 +2565,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   else\n     {\n       if (!desc->niter_max)\n-\tdesc->niter_max = determine_max_iter (desc);\n+\tdesc->niter_max = determine_max_iter (loop, desc);\n \n       /* simplify_using_initial_values does a copy propagation on the registers\n \t in the expression for the number of iterations.  This prolongs life"}]}