{"sha": "bc484e250990393e887f7239157cc85ce6fadcce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0ODRlMjUwOTkwMzkzZTg4N2Y3MjM5MTU3Y2M4NWNlNmZhZGNjZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-02-24T14:36:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-08T17:47:30Z"}, "message": "move permutation validity check\n\nThis delays the SLP permutation check to vectorizable_load and optimizes\npermutations only after all SLP instances have been generated and the\nvectorization factor is determined.\n\n2020-05-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vec_info::slp_loads): New.\n\t(vect_optimize_slp): Declare.\n\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts):  Do\n\tnothing when there are no loads.\n\t(vect_gather_slp_loads): Gather loads into a vector.\n\t(vect_supported_load_permutation_p): Remove.\n\t(vect_analyze_slp_instance): Do not verify permutation\n\tvalidity here.\n\t(vect_analyze_slp): Optimize permutations of reductions\n\tafter all SLP instances have been gathered and gather\n\tall loads.\n\t(vect_optimize_slp): New function split out from\n\tvect_supported_load_permutation_p.  Elide some permutations.\n\t(vect_slp_analyze_bb_1): Call vect_optimize_slp.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Check whether\n\tthe load can be permuted.  When generating code assert we can.\n\n\t* gcc.dg/vect/bb-slp-pr68892.c: Adjust for not supported\n\tSLP permutations becoming builds from scalars.\n\t* gcc.dg/vect/bb-slp-pr78205.c: Likewise.\n\t* gcc.dg/vect/bb-slp-34.c: Likewise.", "tree": {"sha": "e57aa7d95c2998da04902d8c0144a03dd2c7e999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e57aa7d95c2998da04902d8c0144a03dd2c7e999"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc484e250990393e887f7239157cc85ce6fadcce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc484e250990393e887f7239157cc85ce6fadcce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc484e250990393e887f7239157cc85ce6fadcce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc484e250990393e887f7239157cc85ce6fadcce/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "debfaee5d51e3c07bb88a971618de2baff35d9c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debfaee5d51e3c07bb88a971618de2baff35d9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debfaee5d51e3c07bb88a971618de2baff35d9c0"}], "stats": {"total": 360, "additions": 180, "deletions": 180}, "files": [{"sha": "21eabf82113151a514db6e5f6cebe625850f41fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -1,3 +1,23 @@\n+2020-05-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vec_info::slp_loads): New.\n+\t(vect_optimize_slp): Declare.\n+\t* tree-vect-slp.c (vect_attempt_slp_rearrange_stmts):  Do\n+\tnothing when there are no loads.\n+\t(vect_gather_slp_loads): Gather loads into a vector.\n+\t(vect_supported_load_permutation_p): Remove.\n+\t(vect_analyze_slp_instance): Do not verify permutation\n+\tvalidity here.\n+\t(vect_analyze_slp): Optimize permutations of reductions\n+\tafter all SLP instances have been gathered and gather\n+\tall loads.\n+\t(vect_optimize_slp): New function split out from\n+\tvect_supported_load_permutation_p.  Elide some permutations.\n+\t(vect_slp_analyze_bb_1): Call vect_optimize_slp.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_load): Check whether\n+\tthe load can be permuted.  When generating code assert we can.\n+\n 2020-05-08  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (rpo_avail): Change type to"}, {"sha": "9618eaab2ab8b7417822f9226f9f73d747f578b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -1,3 +1,10 @@\n+2020-05-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/bb-slp-pr68892.c: Adjust for not supported\n+\tSLP permutations becoming builds from scalars.\n+\t* gcc.dg/vect/bb-slp-pr78205.c: Likewise.\n+\t* gcc.dg/vect/bb-slp-34.c: Likewise.\n+\n 2020-05-08  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-c++-common/raw-string-6.c: Adjust EOF error location."}, {"sha": "c51c7706adcb010af71a0f5ba8e412ed382908e9", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-34.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-34.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -32,5 +32,4 @@ int main()\n   return 0;\n }\n \n-/* ??? XFAILed because we access \"excess\" elements with the permutation.  */\n-/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { target vect_perm xfail { ! { aarch64*-*-* arm*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { target vect_perm } } } */"}, {"sha": "8cd3a6a1274effd523ed5643e22a023ef373e6c1", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr68892.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr68892.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr68892.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr68892.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -13,7 +13,8 @@ void foo(void)\n   b[3] = a[3][0];\n }\n \n-/* ???  The profitability check is not reached because we give up on the\n-   gaps we access earlier.  */\n+/* ???  Due to the gaps we fall back to scalar loads which makes the\n+   vectorization profitable.  */\n /* { dg-final { scan-tree-dump \"not profitable\" \"slp2\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Basic block will be vectorized\" 0 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"BB vectorization with gaps at the end of a load is not supported\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Basic block will be vectorized\" 1 \"slp2\" } } */"}, {"sha": "f5dc534079294d07a557c2f8bcb9cf763847eb34", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr78205.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr78205.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr78205.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr78205.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -19,7 +19,9 @@ void foo ()\n }\n \n /* We may not vectorize the store to x[] as it accesses c out-of bounds\n-   but we do want to vectorize the other two store groups.  */\n+   but we do want to vectorize the other two store groups.  But we may\n+   end up using scalar loads to vectorize the last group.  */\n \n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */\n-/* { dg-final { scan-tree-dump-times \"x\\\\\\[\\[0-1\\]\\\\\\] = \" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"BB vectorization with gaps at the end of a load is not supported\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = c\\\\\\[4\\\\\\];\" 1 \"optimized\" } } */"}, {"sha": "64463b874c71fa9bbaea061f97bb8bf84fafbbce", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -2049,6 +2049,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \n       /* Update the vectorization factor based on the SLP decision.  */\n       vect_update_vf_for_slp (loop_vinfo);\n+\n+      /* Optimize the SLP graph with the vectorization factor fixed.  */\n+      vect_optimize_slp (loop_vinfo);\n     }\n \n   bool saved_can_fully_mask_p = LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo);"}, {"sha": "f9ad0821fa0e570e3fd6947f3350b389c49a21ec", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 97, "deletions": 165, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -1815,6 +1815,9 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   unsigned int lidx;\n   slp_tree node, load;\n \n+  if (SLP_INSTANCE_LOADS (slp_instn).is_empty ())\n+    return false;\n+\n   /* Compare all the permutation sequences to the first one.  We know\n      that at least one load is permuted.  */\n   node = SLP_INSTANCE_LOADS (slp_instn)[0];\n@@ -1889,7 +1892,7 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n /* Gather loads in the SLP graph NODE and populate the INST loads array.  */\n \n static void\n-vect_gather_slp_loads (slp_instance inst, slp_tree node,\n+vect_gather_slp_loads (vec<slp_tree> &loads, slp_tree node,\n \t\t       hash_set<slp_tree> &visited)\n {\n   if (visited.add (node))\n@@ -1902,152 +1905,22 @@ vect_gather_slp_loads (slp_instance inst, slp_tree node,\n       stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n \t  && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n-\tSLP_INSTANCE_LOADS (inst).safe_push (node);\n+\tloads.safe_push (node);\n     }\n   else\n     {\n       unsigned i;\n       slp_tree child;\n       FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-\tvect_gather_slp_loads (inst, child, visited);\n+\tvect_gather_slp_loads (loads, child, visited);\n     }\n }\n \n static void\n vect_gather_slp_loads (slp_instance inst, slp_tree node)\n {\n   hash_set<slp_tree> visited;\n-  vect_gather_slp_loads (inst, node, visited);\n-}\n-\n-/* Check if the required load permutations in the SLP instance\n-   SLP_INSTN are supported.  */\n-\n-static bool\n-vect_supported_load_permutation_p (vec_info *vinfo, slp_instance slp_instn)\n-{\n-  unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n-  unsigned int i, j, k, next;\n-  slp_tree node;\n-\n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"Load permutation \");\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-\tif (node->load_permutation.exists ())\n-\t  FOR_EACH_VEC_ELT (node->load_permutation, j, next)\n-\t    dump_printf (MSG_NOTE, \"%d \", next);\n-\telse\n-\t  for (k = 0; k < group_size; ++k)\n-\t    dump_printf (MSG_NOTE, \"%d \", k);\n-      dump_printf (MSG_NOTE, \"\\n\");\n-    }\n-\n-  /* In case of reduction every load permutation is allowed, since the order\n-     of the reduction statements is not important (as opposed to the case of\n-     grouped stores).  The only condition we need to check is that all the\n-     load nodes are of the same size and have the same permutation (and then\n-     rearrange all the nodes of the SLP instance according to this \n-     permutation).  */\n-\n-  /* Check that all the load nodes are of the same size.  */\n-  /* ???  Can't we assert this? */\n-  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-    if (SLP_TREE_SCALAR_STMTS (node).length () != (unsigned) group_size)\n-      return false;\n-\n-  node = SLP_INSTANCE_TREE (slp_instn);\n-  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-\n-  /* Reduction (there are no data-refs in the root).\n-     In reduction chain the order of the loads is not important.  */\n-  if (!STMT_VINFO_DATA_REF (stmt_info)\n-      && !REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    vect_attempt_slp_rearrange_stmts (slp_instn);\n-\n-  /* In basic block vectorization we allow any subchain of an interleaving\n-     chain.\n-     FORNOW: not supported in loop SLP because of realignment compications.  */\n-  if (is_a <bb_vec_info> (vinfo))\n-    {\n-      /* Check whether the loads in an instance form a subchain and thus\n-         no permutation is necessary.  */\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-        {\n-\t  if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\t    continue;\n-\t  bool subchain_p = true;\n-\t  stmt_vec_info next_load_info = NULL;\n-\t  stmt_vec_info load_info;\n-\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n-\t    {\n-\t      if (j != 0\n-\t\t  && (next_load_info != load_info\n-\t\t      || DR_GROUP_GAP (load_info) != 1))\n-\t\t{\n-\t\t  subchain_p = false;\n-\t\t  break;\n-\t\t}\n-\t      next_load_info = DR_GROUP_NEXT_ELEMENT (load_info);\n-\t    }\n-\t  if (subchain_p)\n-\t    SLP_TREE_LOAD_PERMUTATION (node).release ();\n-\t  else\n-\t    {\n-\t      stmt_vec_info group_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t      group_info = DR_GROUP_FIRST_ELEMENT (group_info);\n-\t      unsigned HOST_WIDE_INT nunits;\n-\t      unsigned k, maxk = 0;\n-\t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (node), j, k)\n-\t\tif (k > maxk)\n-\t\t  maxk = k;\n-\t      /* In BB vectorization we may not actually use a loaded vector\n-\t\t accessing elements in excess of DR_GROUP_SIZE.  */\n-\t      tree vectype = STMT_VINFO_VECTYPE (group_info);\n-\t      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n-\t\t  || maxk >= (DR_GROUP_SIZE (group_info) & ~(nunits - 1)))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"BB vectorization with gaps at the end of \"\n-\t\t\t\t     \"a load is not supported\\n\");\n-\t\t  return false;\n-\t\t}\n-\n-\t      /* Verify the permutation can be generated.  */\n-\t      vec<tree> tem;\n-\t      unsigned n_perms;\n-\t      if (!vect_transform_slp_perm_load (vinfo, node, tem, NULL,\n-\t\t\t\t\t\t 1, true, &n_perms))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t     vect_location,\n-\t\t\t\t     \"unsupported load permutation\\n\");\n-\t\t  return false;\n-\t\t}\n-\t    }\n-        }\n-      return true;\n-    }\n-\n-  /* For loop vectorization verify we can generate the permutation.  Be\n-     conservative about the vectorization factor, there are permutations\n-     that will use three vector inputs only starting from a specific factor\n-     and the vectorization factor is not yet final.\n-     ???  The SLP instance unrolling factor might not be the maximum one.  */\n-  unsigned n_perms;\n-  poly_uint64 test_vf\n-    = force_common_multiple (SLP_INSTANCE_UNROLLING_FACTOR (slp_instn),\n-\t\t\t     LOOP_VINFO_VECT_FACTOR\n-\t\t\t       (as_a <loop_vec_info> (vinfo)));\n-  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-    if (node->load_permutation.exists ()\n-\t&& !vect_transform_slp_perm_load (vinfo, node, vNULL, NULL, test_vf,\n-\t\t\t\t\t  true, &n_perms))\n-      return false;\n-\n-  return true;\n+  vect_gather_slp_loads (SLP_INSTANCE_LOADS (inst), node, visited);\n }\n \n \n@@ -2289,7 +2162,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t     \"SLP size %u vs. limit %u.\\n\",\n \t\t\t     tree_size, max_tree_size);\n \n-\t  /* Compute the load permutation.  */\n+\t  /* Check whether any load is possibly permuted.  */\n \t  slp_tree load_node;\n \t  bool loads_permuted = false;\n \t  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (new_instance), i, load_node)\n@@ -2298,43 +2171,15 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\tcontinue;\n \t      unsigned j;\n \t      stmt_vec_info load_info;\n-\t      bool this_load_permuted = false;\n-\t      stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT\n-\t\t  (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n \t      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n \t\tif (SLP_TREE_LOAD_PERMUTATION (load_node)[j] != j)\n \t\t  {\n-\t\t    this_load_permuted = true;\n+\t\t    loads_permuted = true;\n \t\t    break;\n \t\t  }\n-\t      if (!this_load_permuted\n-\t\t  /* The load requires permutation when unrolling exposes\n-\t\t     a gap either because the group is larger than the SLP\n-\t\t     group-size or because there is a gap between the groups.  */\n-\t\t  && (known_eq (unrolling_factor, 1U)\n-\t\t      || (group_size == DR_GROUP_SIZE (first_stmt_info)\n-\t\t\t  && DR_GROUP_GAP (first_stmt_info) == 0)))\n-\t\t{\n-\t\t  SLP_TREE_LOAD_PERMUTATION (load_node).release ();\n-\t\t  continue;\n-\t\t}\n-\t      loads_permuted = true;\n-\t    }\n-\n-\t  if (loads_permuted)\n-\t    {\n-\t      if (!vect_supported_load_permutation_p (vinfo, new_instance))\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"Build SLP failed: unsupported load \"\n-\t\t\t\t     \"permutation %G\", stmt_info->stmt);\n-\t\t  vect_free_slp_instance (new_instance, false);\n-\t\t  return false;\n-\t\t}\n \t    }\n \n-\t  /* If the loads and stores can be handled with load/store-lan\n+\t  /* If the loads and stores can be handled with load/store-lane\n \t     instructions do not generate this SLP instance.  */\n \t  if (is_a <loop_vec_info> (vinfo)\n \t      && loads_permuted\n@@ -2514,9 +2359,93 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n       vect_free_slp_tree ((*it).second, false);\n   delete bst_map;\n \n+  /* Optimize permutations in SLP reductions.  */\n+  slp_instance instance;\n+  FOR_EACH_VEC_ELT (vinfo->slp_instances, i, instance)\n+    {\n+      slp_tree node = SLP_INSTANCE_TREE (instance);\n+      stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+      /* Reduction (there are no data-refs in the root).\n+\t In reduction chain the order of the loads is not important.  */\n+      if (!STMT_VINFO_DATA_REF (stmt_info)\n+\t  && !REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+\tvect_attempt_slp_rearrange_stmts (instance);\n+    }\n+\n+  /* Gather all loads in the SLP graph.  */\n+  hash_set<slp_tree> visited;\n+  FOR_EACH_VEC_ELT (vinfo->slp_instances, i, instance)\n+    vect_gather_slp_loads (vinfo->slp_loads, SLP_INSTANCE_TREE (instance),\n+\t\t\t   visited);\n+\n   return opt_result::success ();\n }\n \n+void\n+vect_optimize_slp (vec_info *vinfo)\n+{\n+  slp_tree node;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (vinfo->slp_loads, i, node)\n+    {\n+      if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n+\tcontinue;\n+\n+      /* In basic block vectorization we allow any subchain of an interleaving\n+\t chain.\n+\t FORNOW: not in loop SLP because of realignment complications.  */\n+      if (is_a <bb_vec_info> (vinfo))\n+\t{\n+\t  bool subchain_p = true;\n+\t  stmt_vec_info next_load_info = NULL;\n+\t  stmt_vec_info load_info;\n+\t  unsigned j;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n+\t    {\n+\t      if (j != 0\n+\t\t  && (next_load_info != load_info\n+\t\t      || DR_GROUP_GAP (load_info) != 1))\n+\t\t{\n+\t\t  subchain_p = false;\n+\t\t  break;\n+\t\t}\n+\t      next_load_info = DR_GROUP_NEXT_ELEMENT (load_info);\n+\t    }\n+\t  if (subchain_p)\n+\t    {\n+\t      SLP_TREE_LOAD_PERMUTATION (node).release ();\n+\t      continue;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  stmt_vec_info load_info;\n+\t  bool this_load_permuted = false;\n+\t  unsigned j;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n+\t    if (SLP_TREE_LOAD_PERMUTATION (node)[j] != j)\n+\t      {\n+\t\tthis_load_permuted = true;\n+\t\tbreak;\n+\t      }\n+\t  stmt_vec_info first_stmt_info\n+\t    = DR_GROUP_FIRST_ELEMENT (SLP_TREE_SCALAR_STMTS (node)[0]);\n+\t  if (!this_load_permuted\n+\t      /* The load requires permutation when unrolling exposes\n+\t\t a gap either because the group is larger than the SLP\n+\t\t group-size or because there is a gap between the groups.  */\n+\t      && (known_eq (LOOP_VINFO_VECT_FACTOR (as_a <loop_vec_info> (vinfo)), 1U)\n+\t\t  || ((SLP_TREE_SCALAR_STMTS (node).length ()\n+\t\t       == DR_GROUP_SIZE (first_stmt_info))\n+\t\t      && DR_GROUP_GAP (first_stmt_info) == 0)))\n+\t    {\n+\t      SLP_TREE_LOAD_PERMUTATION (node).release ();\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+}\n+\n \n /* For each possible SLP instance decide whether to SLP it and calculate overall\n    unrolling factor needed to SLP the loop.  Return TRUE if decided to SLP at\n@@ -3180,6 +3109,9 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n       return false;\n     }\n \n+  /* Optimize permutations.  */\n+  vect_optimize_slp (bb_vinfo);\n+\n   vect_record_base_alignments (bb_vinfo);\n \n   /* Analyze and verify the alignment of data references and the"}, {"sha": "f7f19fee1bb7fce1eb161f48251a17257d0573a1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -8781,7 +8781,44 @@ vectorizable_load (vec_info *vinfo,\n \t}\n \n       if (slp && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n-\tslp_perm = true;\n+\t{\n+\t  slp_perm = true;\n+\n+\t  if (!loop_vinfo)\n+\t    {\n+\t      /* In BB vectorization we may not actually use a loaded vector\n+\t\t accessing elements in excess of DR_GROUP_SIZE.  */\n+\t      stmt_vec_info group_info = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+\t      group_info = DR_GROUP_FIRST_ELEMENT (group_info);\n+\t      unsigned HOST_WIDE_INT nunits;\n+\t      unsigned j, k, maxk = 0;\n+\t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (slp_node), j, k)\n+\t\tif (k > maxk)\n+\t\t  maxk = k;\n+\t      tree vectype = STMT_VINFO_VECTYPE (group_info);\n+\t      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n+\t\t  || maxk >= (DR_GROUP_SIZE (group_info) & ~(nunits - 1)))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"BB vectorization with gaps at the end of \"\n+\t\t\t\t     \"a load is not supported\\n\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\n+\t  auto_vec<tree> tem;\n+\t  unsigned n_perms;\n+\t  if (!vect_transform_slp_perm_load (vinfo, slp_node, tem, NULL, vf,\n+\t\t\t\t\t     true, &n_perms))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t vect_location,\n+\t\t\t\t \"unsupported load permutation\\n\");\n+\t      return false;\n+\t    }\n+\t}\n \n       /* Invalidate assumptions made by dependence analysis when vectorization\n \t on the unrolled body effectively re-orders stmts.  */\n@@ -9896,12 +9933,9 @@ vectorizable_load (vec_info *vinfo,\n       if (slp_perm)\n         {\n \t  unsigned n_perms;\n-          if (!vect_transform_slp_perm_load (vinfo, slp_node, dr_chain, gsi, vf,\n-\t\t\t\t\t     false, &n_perms))\n-            {\n-              dr_chain.release ();\n-              return false;\n-            }\n+\t  bool ok = vect_transform_slp_perm_load (vinfo, slp_node, dr_chain,\n+\t\t\t\t\t\t  gsi, vf, false, &n_perms);\n+\t  gcc_assert (ok);\n         }\n       else\n         {"}, {"sha": "aa8bd33b9d150e2bca791e6253c41b485288ed15", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -324,8 +324,9 @@ class vec_info {\n   /* The mapping of GIMPLE UID to stmt_vec_info.  */\n   vec<stmt_vec_info> stmt_vec_infos;\n \n-  /* All SLP instances.  */\n+  /* The SLP graph.  */\n   auto_vec<slp_instance> slp_instances;\n+  auto_vec<slp_tree> slp_loads;\n \n   /* Maps base addresses to an innermost_loop_behavior that gives the maximum\n      known alignment for that base.  */\n@@ -1858,6 +1859,7 @@ extern void vect_schedule_slp (vec_info *);\n extern opt_result vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n+extern void vect_optimize_slp (vec_info *);\n extern void vect_get_slp_defs (vec_info *, slp_tree, vec<vec<tree> > *,\n \t\t\t       unsigned n = -1U);\n extern bool vect_slp_bb (basic_block);"}]}