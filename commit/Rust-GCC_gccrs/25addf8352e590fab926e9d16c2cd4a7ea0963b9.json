{"sha": "25addf8352e590fab926e9d16c2cd4a7ea0963b9", "node_id": "C_kwDOANBUbNoAKDI1YWRkZjgzNTJlNTkwZmFiOTI2ZTlkMTZjMmNkNGE3ZWEwOTYzYjk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-11T20:14:59Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-11T20:14:59Z"}, "message": "tree: introduce range adaptor for TREE_VEC\n\nThis patch implements a simple tree wrapper, named tree_vec_range, which\nlets us idiomatically loop over all the elements of a TREE_VEC using a\nC++11 range-based for loop:\n\n  // v is a TREE_VEC\n  for (tree e : tree_vec_range (v))\n    ...\n\nThis is similar to the existing tree-based range adaptors ovl_range and\nlkp_range added to the C++ FE in r12-340-g3307b9a07a3c51.\n\nThis patch also converts some existing loops over TREE_VEC within the\nC++ FE to use tree_vec_range / range-for.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (tsubst_parameter_mapping): Convert loop over\n\tTREE_VEC into a range-based for loop using tree_vec_range.\n\t* pt.cc (iterative_hash_template_arg): Likewise.\n\t(template_parms_level_to_args): Likewise.\n\t(deducible_template_args): Likewise.\n\t(check_undeduced_parms): Likewise.\n\t(dependent_type_p_r): Likewise.\n\t(value_dependent_expression_p) <case NONTYPE_ARGUMENT_PACK>:\n\tLikewise.\n\t(dependent_template_arg_p): Likewise.\n\t* tree.cc (cp_walk_subtrees) <case NONTYPE_ARGUMENT_PACK>:\n\tLikewise.\n\ngcc/ChangeLog:\n\n\t* tree.h (TREE_VEC_BEGIN): Define.\n\t(TREE_VEC_END): Correct 'length' member access.\n\t(class tree_vec_range): Define.", "tree": {"sha": "c7bfc1219fe51540c69b99c3ed97bcf9c4673e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7bfc1219fe51540c69b99c3ed97bcf9c4673e19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25addf8352e590fab926e9d16c2cd4a7ea0963b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25addf8352e590fab926e9d16c2cd4a7ea0963b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25addf8352e590fab926e9d16c2cd4a7ea0963b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25addf8352e590fab926e9d16c2cd4a7ea0963b9/comments", "author": null, "committer": null, "parents": [{"sha": "88459c3965e2a2f62ab4d4c8b2ac8460b1a15c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88459c3965e2a2f62ab4d4c8b2ac8460b1a15c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88459c3965e2a2f62ab4d4c8b2ac8460b1a15c33"}], "stats": {"total": 86, "additions": 41, "deletions": 45}, "files": [{"sha": "591155cee22a760f88b95ff6e3d0bfb2c300310c", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=25addf8352e590fab926e9d16c2cd4a7ea0963b9", "patch": "@@ -2348,12 +2348,9 @@ tsubst_parameter_mapping (tree map, tree args, subst_info info)\n       if (TREE_CODE (new_arg) == TYPE_ARGUMENT_PACK)\n \t{\n \t  tree pack_args = ARGUMENT_PACK_ARGS (new_arg);\n-\t  for (int i = 0; i < TREE_VEC_LENGTH (pack_args); i++)\n-\t    {\n-\t      tree& pack_arg = TREE_VEC_ELT (pack_args, i);\n-\t      if (TYPE_P (pack_arg))\n-\t\tpack_arg = canonicalize_type_argument (pack_arg, complain);\n-\t    }\n+\t  for (tree& pack_arg : tree_vec_range (pack_args))\n+\t    if (TYPE_P (pack_arg))\n+\t      pack_arg = canonicalize_type_argument (pack_arg, complain);\n \t}\n       if (new_arg == error_mark_node)\n \treturn error_mark_node;"}, {"sha": "2c7c5f8bb5dedc6cefd2d639eece83a4dd517a55", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=25addf8352e590fab926e9d16c2cd4a7ea0963b9", "patch": "@@ -1811,8 +1811,8 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n       return iterative_hash_object (IDENTIFIER_HASH_VALUE (arg), val);\n \n     case TREE_VEC:\n-      for (int i = 0, len = TREE_VEC_LENGTH (arg); i < len; ++i)\n-\tval = iterative_hash_template_arg (TREE_VEC_ELT (arg, i), val);\n+      for (tree elt : tree_vec_range (arg))\n+\tval = iterative_hash_template_arg (elt, val);\n       return val;\n \n     case TYPE_PACK_EXPANSION:\n@@ -4883,15 +4883,15 @@ template_parm_to_arg (tree t)\n tree\n template_parms_level_to_args (tree parms)\n {\n-  tree a = copy_node (parms);\n-  TREE_TYPE (a) = NULL_TREE;\n-  for (int i = TREE_VEC_LENGTH (a) - 1; i >= 0; --i)\n-    TREE_VEC_ELT (a, i) = template_parm_to_arg (TREE_VEC_ELT (a, i));\n+  parms = copy_node (parms);\n+  TREE_TYPE (parms) = NULL_TREE;\n+  for (tree& parm : tree_vec_range (parms))\n+    parm = template_parm_to_arg (parm);\n \n   if (CHECKING_P)\n-    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (a, TREE_VEC_LENGTH (a));\n+    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (parms, TREE_VEC_LENGTH (parms));\n \n-  return a;\n+  return parms;\n }\n \n /* Given a set of template parameters, return them as a set of template\n@@ -22470,10 +22470,9 @@ deducible_array_bound (tree domain)\n static bool\n deducible_template_args (tree args)\n {\n-  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+  for (tree elt : tree_vec_range (args))\n     {\n       bool deducible;\n-      tree elt = TREE_VEC_ELT (args, i);\n       if (ARGUMENT_PACK_P (elt))\n \tdeducible = deducible_template_args (ARGUMENT_PACK_ARGS (elt));\n       else\n@@ -24844,12 +24843,11 @@ static bool\n check_undeduced_parms (tree targs, tree args, tree end)\n {\n   bool found = false;\n-  int i;\n-  for (i = TREE_VEC_LENGTH (targs) - 1; i >= 0; --i)\n-    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+  for (tree& targ : tree_vec_range (targs))\n+    if (targ == NULL_TREE)\n       {\n \tfound = true;\n-\tTREE_VEC_ELT (targs, i) = error_mark_node;\n+\ttarg = error_mark_node;\n       }\n   if (found)\n     {\n@@ -27288,10 +27286,9 @@ dependent_type_p_r (tree type)\n   if (TREE_CODE (type) == TYPE_ARGUMENT_PACK)\n     {\n       tree args = ARGUMENT_PACK_ARGS (type);\n-      int i, len = TREE_VEC_LENGTH (args);\n-      for (i = 0; i < len; ++i)\n-        if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-          return true;\n+      for (tree arg : tree_vec_range (args))\n+\tif (dependent_template_arg_p (arg))\n+\t  return true;\n     }\n \n   /* All TYPE_PACK_EXPANSIONs are dependent, because parameter packs must\n@@ -27574,16 +27571,10 @@ value_dependent_expression_p (tree expression)\n     case NONTYPE_ARGUMENT_PACK:\n       /* A NONTYPE_ARGUMENT_PACK is value-dependent if any packed argument\n          is value-dependent.  */\n-      {\n-        tree values = ARGUMENT_PACK_ARGS (expression);\n-        int i, len = TREE_VEC_LENGTH (values);\n-\n-        for (i = 0; i < len; ++i)\n-          if (value_dependent_expression_p (TREE_VEC_ELT (values, i)))\n-            return true;\n-\n-        return false;\n-      }\n+      for (tree arg : tree_vec_range (ARGUMENT_PACK_ARGS (expression)))\n+\tif (value_dependent_expression_p (arg))\n+\t  return true;\n+      return false;\n \n     case TRAIT_EXPR:\n       {\n@@ -28209,13 +28200,9 @@ dependent_template_arg_p (tree arg)\n   else if (ARGUMENT_PACK_P (arg))\n     {\n       tree args = ARGUMENT_PACK_ARGS (arg);\n-      int i, len = TREE_VEC_LENGTH (args);\n-      for (i = 0; i < len; ++i)\n-        {\n-          if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-            return true;\n-        }\n-\n+      for (tree arg : tree_vec_range (args))\n+\tif (dependent_template_arg_p (arg))\n+\t  return true;\n       return false;\n     }\n   else if (TYPE_P (arg))"}, {"sha": "bc38c8fbdbe6e29c85fbe4ce2e47c9d885054d7b", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=25addf8352e590fab926e9d16c2cd4a7ea0963b9", "patch": "@@ -5414,9 +5414,8 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n     case NONTYPE_ARGUMENT_PACK:\n       {\n         tree args = ARGUMENT_PACK_ARGS (*tp);\n-        int i, len = TREE_VEC_LENGTH (args);\n-        for (i = 0; i < len; i++)\n-          WALK_SUBTREE (TREE_VEC_ELT (args, i));\n+\tfor (tree arg : tree_vec_range (args))\n+\t  WALK_SUBTREE (arg);\n       }\n       break;\n "}, {"sha": "5f4b03dc5dff2483e5d2f9d411bf33e11f3d42ff", "filename": "gcc/tree.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25addf8352e590fab926e9d16c2cd4a7ea0963b9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=25addf8352e590fab926e9d16c2cd4a7ea0963b9", "patch": "@@ -1107,8 +1107,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* In a TREE_VEC node.  */\n #define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->base.u.length)\n+#define TREE_VEC_BEGIN(NODE) (&TREE_VEC_CHECK (NODE)->vec.a[0])\n #define TREE_VEC_END(NODE) \\\n-  ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a[(NODE)->vec.base.u.length]))\n+  ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a[(NODE)->base.u.length]))\n \n #define TREE_VEC_ELT(NODE,I) TREE_VEC_ELT_CHECK (NODE, I)\n \n@@ -4481,6 +4482,18 @@ extern tree make_tree_vec (int CXX_MEM_STAT_INFO);\n \n extern tree grow_tree_vec (tree v, int CXX_MEM_STAT_INFO);\n \n+/* Treat a TREE_VEC as a range of trees, e.g.\n+   for (tree e : tree_vec_range (v)) { ... }  */\n+\n+class tree_vec_range\n+{\n+  tree v;\n+public:\n+  tree_vec_range(tree v) : v(v) { }\n+  tree *begin() { return TREE_VEC_BEGIN (v); }\n+  tree *end() { return TREE_VEC_END (v); }\n+};\n+\n /* Construct various types of nodes.  */\n \n extern tree build_nt (enum tree_code, ...);"}]}