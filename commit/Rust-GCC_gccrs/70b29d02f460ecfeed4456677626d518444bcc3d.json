{"sha": "70b29d02f460ecfeed4456677626d518444bcc3d", "node_id": "C_kwDOANBUbNoAKDcwYjI5ZDAyZjQ2MGVjZmVlZDQ0NTY2Nzc2MjZkNTE4NDQ0YmNjM2Q", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-17T12:43:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-01T10:24:42Z"}, "message": "[Ada] Tidy up freezing code for instantiations (continued)\n\ngcc/ada/\n\n\t* sem_ch12.adb (Freeze_Package_Instance): Move up.", "tree": {"sha": "5fca8085ecad9a164bcb829412fa276370c7effe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fca8085ecad9a164bcb829412fa276370c7effe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70b29d02f460ecfeed4456677626d518444bcc3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b29d02f460ecfeed4456677626d518444bcc3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b29d02f460ecfeed4456677626d518444bcc3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b29d02f460ecfeed4456677626d518444bcc3d/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49b8a94b8878438cb5a08704101aee6f7319bd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b8a94b8878438cb5a08704101aee6f7319bd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b8a94b8878438cb5a08704101aee6f7319bd8b"}], "stats": {"total": 766, "additions": 383, "deletions": 383}, "files": [{"sha": "f10967a01fc7516ff2b6c2f6750f71e047463bbd", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 383, "deletions": 383, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b29d02f460ecfeed4456677626d518444bcc3d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b29d02f460ecfeed4456677626d518444bcc3d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=70b29d02f460ecfeed4456677626d518444bcc3d", "patch": "@@ -613,6 +613,24 @@ package body Sem_Ch12 is\n    --  packages, and the prefix of the formal type may be needed to resolve\n    --  the ambiguity in the instance ???\n \n+   procedure Freeze_Package_Instance\n+     (N        : Node_Id;\n+      Gen_Body : Node_Id;\n+      Gen_Decl : Node_Id;\n+      Act_Id   : Entity_Id);\n+   --  If the instantiation happens textually before the body of the generic,\n+   --  the instantiation of the body must be analyzed after the generic body,\n+   --  and not at the point of instantiation. Such early instantiations can\n+   --  happen if the generic and the instance appear in a package declaration\n+   --  because the generic body can only appear in the corresponding package\n+   --  body. Early instantiations can also appear if generic, instance and\n+   --  body are all in the declarative part of a subprogram or entry. Entities\n+   --  of packages that are early instantiations are delayed, and their freeze\n+   --  node appears after the generic body. This rather complex machinery is\n+   --  needed when nested instantiations are present, because the source does\n+   --  not carry any indication of where the corresponding instance bodies must\n+   --  be installed and frozen.\n+\n    procedure Freeze_Subprogram_Instance\n      (N         : Node_Id;\n       Gen_Body  : Node_Id;\n@@ -718,24 +736,6 @@ package body Sem_Ch12 is\n    --  package that encloses an instantiation, in which case N may denote an\n    --  arbitrary node.\n \n-   procedure Freeze_Package_Instance\n-     (N        : Node_Id;\n-      Gen_Body : Node_Id;\n-      Gen_Decl : Node_Id;\n-      Act_Id   : Entity_Id);\n-   --  If the instantiation happens textually before the body of the generic,\n-   --  the instantiation of the body must be analyzed after the generic body,\n-   --  and not at the point of instantiation. Such early instantiations can\n-   --  happen if the generic and the instance appear in a package declaration\n-   --  because the generic body can only appear in the corresponding package\n-   --  body. Early instantiations can also appear if generic, instance and\n-   --  body are all in the declarative part of a subprogram or entry. Entities\n-   --  of packages that are early instantiations are delayed, and their freeze\n-   --  node appears after the generic body. This rather complex machinery is\n-   --  needed when nested instantiations are present, because the source does\n-   --  not carry any indication of where the corresponding instance bodies must\n-   --  be installed and frozen.\n-\n    procedure Install_Formal_Packages (Par : Entity_Id);\n    --  Install the visible part of any formal of the parent that is a formal\n    --  package. Note that for the case of a formal package with a box, this\n@@ -9017,156 +9017,404 @@ package body Sem_Ch12 is\n       end if;\n    end Find_Actual_Type;\n \n-   --------------------------------\n-   -- Freeze_Subprogram_Instance --\n-   --------------------------------\n+   -----------------------------\n+   -- Freeze_Package_Instance --\n+   -----------------------------\n \n-   procedure Freeze_Subprogram_Instance\n-     (N         : Node_Id;\n-      Gen_Body  : Node_Id;\n-      Pack_Id   : Entity_Id)\n-  is\n-      function Enclosing_Package_Body (N : Node_Id) return Node_Id;\n-      --  Find innermost package body that encloses the given node, and which\n-      --  is not a compilation unit. Freeze nodes for the instance, or for its\n-      --  enclosing body, may be inserted after the enclosing_body of the\n-      --  generic unit. Used to determine proper placement of freeze node for\n-      --  both package and subprogram instances.\n+   procedure Freeze_Package_Instance\n+     (N        : Node_Id;\n+      Gen_Body : Node_Id;\n+      Gen_Decl : Node_Id;\n+      Act_Id   : Entity_Id)\n+   is\n+      function In_Same_Scope (Gen_Id, Act_Id : Node_Id) return Boolean;\n+      --  Check if the generic definition and the instantiation come from\n+      --  a common scope, in which case the instance must be frozen after\n+      --  the generic body.\n \n-      function Package_Freeze_Node (B : Node_Id) return Node_Id;\n-      --  Find entity for given package body, and locate or create a freeze\n-      --  node for it.\n+      function True_Sloc (N, Act_Unit : Node_Id) return Source_Ptr;\n+      --  If the instance is nested inside a generic unit, the Sloc of the\n+      --  instance indicates the place of the original definition, not the\n+      --  point of the current enclosing instance. Pending a better usage of\n+      --  Slocs to indicate instantiation places, we determine the place of\n+      --  origin of a node by finding the maximum sloc of any ancestor node.\n \n-      ----------------------------\n-      -- Enclosing_Package_Body --\n-      ----------------------------\n+      --  Why is this not equivalent to Top_Level_Location ???\n \n-      function Enclosing_Package_Body (N : Node_Id) return Node_Id is\n-         P : Node_Id;\n+      -------------------\n+      -- In_Same_Scope --\n+      -------------------\n+\n+      function In_Same_Scope (Gen_Id, Act_Id : Node_Id) return Boolean is\n+         Act_Scop : Entity_Id := Scope (Act_Id);\n+         Gen_Scop : Entity_Id := Scope (Gen_Id);\n \n       begin\n-         P := Parent (N);\n-         while Present (P)\n-           and then Nkind (Parent (P)) /= N_Compilation_Unit\n+         while Act_Scop /= Standard_Standard\n+           and then Gen_Scop /= Standard_Standard\n          loop\n-            if Nkind (P) = N_Package_Body then\n-               if Nkind (Parent (P)) = N_Subunit then\n-                  return Corresponding_Stub (Parent (P));\n-               else\n-                  return P;\n-               end if;\n+            if Act_Scop = Gen_Scop then\n+               return True;\n             end if;\n \n-            P := True_Parent (P);\n+            Act_Scop := Scope (Act_Scop);\n+            Gen_Scop := Scope (Gen_Scop);\n          end loop;\n \n-         return Empty;\n-      end Enclosing_Package_Body;\n+         return False;\n+      end In_Same_Scope;\n \n-      -------------------------\n-      -- Package_Freeze_Node --\n-      -------------------------\n+      ---------------\n+      -- True_Sloc --\n+      ---------------\n \n-      function Package_Freeze_Node (B : Node_Id) return Node_Id is\n-         Id : Entity_Id;\n+      function True_Sloc (N, Act_Unit : Node_Id) return Source_Ptr is\n+         N1  : Node_Id;\n+         Res : Source_Ptr;\n \n       begin\n-         if Nkind (B) = N_Package_Body then\n-            Id := Corresponding_Spec (B);\n-         else pragma Assert (Nkind (B) = N_Package_Body_Stub);\n-            Id := Corresponding_Spec (Proper_Body (Unit (Library_Unit (B))));\n-         end if;\n+         Res := Sloc (N);\n+         N1  := N;\n+         while Present (N1) and then N1 /= Act_Unit loop\n+            if Sloc (N1) > Res then\n+               Res := Sloc (N1);\n+            end if;\n \n-         Ensure_Freeze_Node (Id);\n-         return Freeze_Node (Id);\n-      end Package_Freeze_Node;\n+            N1 := Parent (N1);\n+         end loop;\n+\n+         return Res;\n+      end True_Sloc;\n \n       --  Local variables\n \n-      Enc_G  : constant Node_Id   := Enclosing_Package_Body (Gen_Body);\n-      Enc_N  : constant Node_Id   := Enclosing_Package_Body (N);\n-      Par_Id : constant Entity_Id := Scope (Get_Generic_Entity (N));\n+      Gen_Id    : constant Entity_Id := Get_Generic_Entity (N);\n+      Par_Id    : constant Entity_Id := Scope (Gen_Id);\n+      Act_Unit  : constant Node_Id   := Unit (Cunit (Get_Source_Unit (N)));\n+      Gen_Unit  : constant Node_Id   :=\n+                    Unit (Cunit (Get_Source_Unit (Gen_Decl)));\n \n-      Enc_G_F  : Node_Id;\n-      F_Node   : Node_Id;\n+      Body_Unit  : Node_Id;\n+      F_Node     : Node_Id;\n+      Must_Delay : Boolean;\n+      Orig_Body  : Node_Id;\n \n-   --  Start of processing for Freeze_Subprogram_Instance\n+   --  Start of processing for Freeze_Package_Instance\n \n    begin\n-      --  If the instance and the generic body appear within the same unit, and\n-      --  the instance precedes the generic, the freeze node for the instance\n-      --  must appear after that of the generic. If the generic is nested\n-      --  within another instance I2, then current instance must be frozen\n-      --  after I2. In both cases, the freeze nodes are those of enclosing\n-      --  packages. Otherwise, the freeze node is placed at the end of the\n-      --  current declarative part.\n-\n-      Ensure_Freeze_Node (Pack_Id);\n-      F_Node := Freeze_Node (Pack_Id);\n+      --  If the body is a subunit, the freeze point is the corresponding stub\n+      --  in the current compilation, not the subunit itself.\n \n-      if Is_Generic_Instance (Par_Id)\n-        and then Present (Freeze_Node (Par_Id))\n-        and then In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), N)\n-      then\n-         --  The parent was a premature instantiation. Insert freeze node at\n-         --  the end the current declarative part.\n+      if Nkind (Parent (Gen_Body)) = N_Subunit then\n+         Orig_Body := Corresponding_Stub (Parent (Gen_Body));\n+      else\n+         Orig_Body := Gen_Body;\n+      end if;\n \n-         if Is_Known_Guaranteed_ABE (Get_Unit_Instantiation_Node (Par_Id)) then\n-            Insert_Freeze_Node_For_Instance (N, F_Node);\n+      Body_Unit := Unit (Cunit (Get_Source_Unit (Orig_Body)));\n \n-         --  Handle the following case:\n-         --\n-         --    package Parent_Inst is new ...\n-         --    freeze Parent_Inst []\n-         --\n-         --    procedure P ...  --  this body freezes Parent_Inst\n-         --\n-         --    procedure Inst is new ...\n-         --\n-         --  In this particular scenario, the freeze node for Inst must be\n-         --  inserted in the same manner as that of Parent_Inst - before the\n-         --  next source body or at the end of the declarative list (body not\n-         --  available). If body P did not exist and Parent_Inst was frozen\n-         --  after Inst, either by a body following Inst or at the end of the\n-         --  declarative region, the freeze node for Inst must be inserted\n-         --  after that of Parent_Inst. This relation is established by\n-         --  comparing the Slocs of Parent_Inst freeze node and Inst.\n+      --  If the instantiation and the generic definition appear in the same\n+      --  package declaration, this is an early instantiation. If they appear\n+      --  in the same declarative part, it is an early instantiation only if\n+      --  the generic body appears textually later, and the generic body is\n+      --  also in the main unit.\n \n-         elsif In_Same_List (Get_Unit_Instantiation_Node (Par_Id), N)\n-           and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n-         then\n-            Insert_Freeze_Node_For_Instance (N, F_Node);\n+      --  If instance is nested within a subprogram, and the generic body\n+      --  is not, the instance is delayed because the enclosing body is. If\n+      --  instance and body are within the same scope, or the same subprogram\n+      --  body, indicate explicitly that the instance is delayed.\n \n-         else\n-            Insert_After (Freeze_Node (Par_Id), F_Node);\n-         end if;\n+      Must_Delay :=\n+        (Gen_Unit = Act_Unit\n+          and then (Nkind (Gen_Unit) in N_Generic_Package_Declaration\n+                                      | N_Package_Declaration\n+                     or else (Gen_Unit = Body_Unit\n+                               and then\n+                              True_Sloc (N, Act_Unit) < Sloc (Orig_Body)))\n+          and then Is_In_Main_Unit (Original_Node (Gen_Unit))\n+          and then In_Same_Scope (Gen_Id, Act_Id));\n \n-      --  The body enclosing the instance should be frozen after the body that\n-      --  includes the generic, because the body of the instance may make\n-      --  references to entities therein. If the two are not in the same\n-      --  declarative part, or if the one enclosing the instance is frozen\n-      --  already, freeze the instance at the end of the current declarative\n-      --  part.\n+      --  If this is an early instantiation, the freeze node is placed after\n+      --  the generic body. Otherwise, if the generic appears in an instance,\n+      --  we cannot freeze the current instance until the outer one is frozen.\n+      --  This is only relevant if the current instance is nested within some\n+      --  inner scope not itself within the outer instance. If this scope is\n+      --  a package body in the same declarative part as the outer instance,\n+      --  then that body needs to be frozen after the outer instance. Finally,\n+      --  if no delay is needed, we place the freeze node at the end of the\n+      --  current declarative part.\n \n-      elsif Is_Generic_Instance (Par_Id)\n-        and then Present (Freeze_Node (Par_Id))\n-        and then Present (Enc_N)\n+      if No (Freeze_Node (Act_Id))\n+        or else not Is_List_Member (Freeze_Node (Act_Id))\n       then\n-         if In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), Enc_N)\n-         then\n-            --  The enclosing package may contain several instances. Rather\n-            --  than computing the earliest point at which to insert its freeze\n-            --  node, we place it at the end of the declarative part of the\n-            --  parent of the generic.\n-\n-            Insert_Freeze_Node_For_Instance\n-              (Freeze_Node (Par_Id), Package_Freeze_Node (Enc_N));\n-         end if;\n+         Ensure_Freeze_Node (Act_Id);\n+         F_Node := Freeze_Node (Act_Id);\n \n-         Insert_Freeze_Node_For_Instance (N, F_Node);\n+         if Must_Delay then\n+            Insert_After (Orig_Body, F_Node);\n \n-      elsif Present (Enc_G)\n-        and then Present (Enc_N)\n+         elsif Is_Generic_Instance (Par_Id)\n+           and then Present (Freeze_Node (Par_Id))\n+           and then Scope (Act_Id) /= Par_Id\n+         then\n+            --  Freeze instance of inner generic after instance of enclosing\n+            --  generic.\n+\n+            if In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), N) then\n+\n+               --  Handle the following case:\n+\n+               --    package Parent_Inst is new ...\n+               --    freeze Parent_Inst []\n+\n+               --    procedure P ...  --  this body freezes Parent_Inst\n+\n+               --    package Inst is new ...\n+\n+               --  In this particular scenario, the freeze node for Inst must\n+               --  be inserted in the same manner as that of Parent_Inst,\n+               --  before the next source body or at the end of the declarative\n+               --  list (body not available). If body P did not exist and\n+               --  Parent_Inst was frozen after Inst, either by a body\n+               --  following Inst or at the end of the declarative region,\n+               --  the freeze node for Inst must be inserted after that of\n+               --  Parent_Inst. This relation is established by comparing\n+               --  the Slocs of Parent_Inst freeze node and Inst.\n+               --  We examine the parents of the enclosing lists to handle\n+               --  the case where the parent instance is in the visible part\n+               --  of a package declaration, and the inner instance is in\n+               --  the corresponding private part.\n+\n+               if Parent (List_Containing (Get_Unit_Instantiation_Node\n+                                                                     (Par_Id)))\n+                    = Parent (List_Containing (N))\n+                 and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n+               then\n+                  Insert_Freeze_Node_For_Instance (N, F_Node);\n+               else\n+                  Insert_After (Freeze_Node (Par_Id), F_Node);\n+               end if;\n+\n+            --  Freeze package enclosing instance of inner generic after\n+            --  instance of enclosing generic.\n+\n+            elsif Nkind (Parent (N)) in N_Package_Body | N_Subprogram_Body\n+              and then In_Same_Declarative_Part\n+                         (Parent (Freeze_Node (Par_Id)), Parent (N))\n+            then\n+               declare\n+                  Enclosing :  Entity_Id;\n+\n+               begin\n+                  Enclosing := Corresponding_Spec (Parent (N));\n+\n+                  if No (Enclosing) then\n+                     Enclosing := Defining_Entity (Parent (N));\n+                  end if;\n+\n+                  Insert_Freeze_Node_For_Instance (N, F_Node);\n+                  Ensure_Freeze_Node (Enclosing);\n+\n+                  if not Is_List_Member (Freeze_Node (Enclosing)) then\n+\n+                     --  The enclosing context is a subunit, insert the freeze\n+                     --  node after the stub.\n+\n+                     if Nkind (Parent (Parent (N))) = N_Subunit then\n+                        Insert_Freeze_Node_For_Instance\n+                          (Corresponding_Stub (Parent (Parent (N))),\n+                           Freeze_Node (Enclosing));\n+\n+                     --  The enclosing context is a package with a stub body\n+                     --  which has already been replaced by the real body.\n+                     --  Insert the freeze node after the actual body.\n+\n+                     elsif Ekind (Enclosing) = E_Package\n+                       and then Present (Body_Entity (Enclosing))\n+                       and then Was_Originally_Stub\n+                                  (Parent (Body_Entity (Enclosing)))\n+                     then\n+                        Insert_Freeze_Node_For_Instance\n+                          (Parent (Body_Entity (Enclosing)),\n+                           Freeze_Node (Enclosing));\n+\n+                     --  The parent instance has been frozen before the body of\n+                     --  the enclosing package, insert the freeze node after\n+                     --  the body.\n+\n+                     elsif In_Same_List (Freeze_Node (Par_Id), Parent (N))\n+                       and then Sloc (Freeze_Node (Par_Id)) < Sloc (Parent (N))\n+                     then\n+                        Insert_Freeze_Node_For_Instance\n+                          (Parent (N), Freeze_Node (Enclosing));\n+\n+                     else\n+                        Insert_After\n+                          (Freeze_Node (Par_Id), Freeze_Node (Enclosing));\n+                     end if;\n+                  end if;\n+               end;\n+\n+            else\n+               Insert_Freeze_Node_For_Instance (N, F_Node);\n+            end if;\n+\n+         else\n+            Insert_Freeze_Node_For_Instance (N, F_Node);\n+         end if;\n+      end if;\n+   end Freeze_Package_Instance;\n+\n+   --------------------------------\n+   -- Freeze_Subprogram_Instance --\n+   --------------------------------\n+\n+   procedure Freeze_Subprogram_Instance\n+     (N         : Node_Id;\n+      Gen_Body  : Node_Id;\n+      Pack_Id   : Entity_Id)\n+  is\n+      function Enclosing_Package_Body (N : Node_Id) return Node_Id;\n+      --  Find innermost package body that encloses the given node, and which\n+      --  is not a compilation unit. Freeze nodes for the instance, or for its\n+      --  enclosing body, may be inserted after the enclosing_body of the\n+      --  generic unit. Used to determine proper placement of freeze node for\n+      --  both package and subprogram instances.\n+\n+      function Package_Freeze_Node (B : Node_Id) return Node_Id;\n+      --  Find entity for given package body, and locate or create a freeze\n+      --  node for it.\n+\n+      ----------------------------\n+      -- Enclosing_Package_Body --\n+      ----------------------------\n+\n+      function Enclosing_Package_Body (N : Node_Id) return Node_Id is\n+         P : Node_Id;\n+\n+      begin\n+         P := Parent (N);\n+         while Present (P)\n+           and then Nkind (Parent (P)) /= N_Compilation_Unit\n+         loop\n+            if Nkind (P) = N_Package_Body then\n+               if Nkind (Parent (P)) = N_Subunit then\n+                  return Corresponding_Stub (Parent (P));\n+               else\n+                  return P;\n+               end if;\n+            end if;\n+\n+            P := True_Parent (P);\n+         end loop;\n+\n+         return Empty;\n+      end Enclosing_Package_Body;\n+\n+      -------------------------\n+      -- Package_Freeze_Node --\n+      -------------------------\n+\n+      function Package_Freeze_Node (B : Node_Id) return Node_Id is\n+         Id : Entity_Id;\n+\n+      begin\n+         if Nkind (B) = N_Package_Body then\n+            Id := Corresponding_Spec (B);\n+         else pragma Assert (Nkind (B) = N_Package_Body_Stub);\n+            Id := Corresponding_Spec (Proper_Body (Unit (Library_Unit (B))));\n+         end if;\n+\n+         Ensure_Freeze_Node (Id);\n+         return Freeze_Node (Id);\n+      end Package_Freeze_Node;\n+\n+      --  Local variables\n+\n+      Enc_G  : constant Node_Id   := Enclosing_Package_Body (Gen_Body);\n+      Enc_N  : constant Node_Id   := Enclosing_Package_Body (N);\n+      Par_Id : constant Entity_Id := Scope (Get_Generic_Entity (N));\n+\n+      Enc_G_F  : Node_Id;\n+      F_Node   : Node_Id;\n+\n+   --  Start of processing for Freeze_Subprogram_Instance\n+\n+   begin\n+      --  If the instance and the generic body appear within the same unit, and\n+      --  the instance precedes the generic, the freeze node for the instance\n+      --  must appear after that of the generic. If the generic is nested\n+      --  within another instance I2, then current instance must be frozen\n+      --  after I2. In both cases, the freeze nodes are those of enclosing\n+      --  packages. Otherwise, the freeze node is placed at the end of the\n+      --  current declarative part.\n+\n+      Ensure_Freeze_Node (Pack_Id);\n+      F_Node := Freeze_Node (Pack_Id);\n+\n+      if Is_Generic_Instance (Par_Id)\n+        and then Present (Freeze_Node (Par_Id))\n+        and then In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), N)\n+      then\n+         --  The parent was a premature instantiation. Insert freeze node at\n+         --  the end the current declarative part.\n+\n+         if Is_Known_Guaranteed_ABE (Get_Unit_Instantiation_Node (Par_Id)) then\n+            Insert_Freeze_Node_For_Instance (N, F_Node);\n+\n+         --  Handle the following case:\n+         --\n+         --    package Parent_Inst is new ...\n+         --    freeze Parent_Inst []\n+         --\n+         --    procedure P ...  --  this body freezes Parent_Inst\n+         --\n+         --    procedure Inst is new ...\n+         --\n+         --  In this particular scenario, the freeze node for Inst must be\n+         --  inserted in the same manner as that of Parent_Inst - before the\n+         --  next source body or at the end of the declarative list (body not\n+         --  available). If body P did not exist and Parent_Inst was frozen\n+         --  after Inst, either by a body following Inst or at the end of the\n+         --  declarative region, the freeze node for Inst must be inserted\n+         --  after that of Parent_Inst. This relation is established by\n+         --  comparing the Slocs of Parent_Inst freeze node and Inst.\n+\n+         elsif In_Same_List (Get_Unit_Instantiation_Node (Par_Id), N)\n+           and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n+         then\n+            Insert_Freeze_Node_For_Instance (N, F_Node);\n+\n+         else\n+            Insert_After (Freeze_Node (Par_Id), F_Node);\n+         end if;\n+\n+      --  The body enclosing the instance should be frozen after the body that\n+      --  includes the generic, because the body of the instance may make\n+      --  references to entities therein. If the two are not in the same\n+      --  declarative part, or if the one enclosing the instance is frozen\n+      --  already, freeze the instance at the end of the current declarative\n+      --  part.\n+\n+      elsif Is_Generic_Instance (Par_Id)\n+        and then Present (Freeze_Node (Par_Id))\n+        and then Present (Enc_N)\n+      then\n+         if In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), Enc_N)\n+         then\n+            --  The enclosing package may contain several instances. Rather\n+            --  than computing the earliest point at which to insert its freeze\n+            --  node, we place it at the end of the declarative part of the\n+            --  parent of the generic.\n+\n+            Insert_Freeze_Node_For_Instance\n+              (Freeze_Node (Par_Id), Package_Freeze_Node (Enc_N));\n+         end if;\n+\n+         Insert_Freeze_Node_For_Instance (N, F_Node);\n+\n+      elsif Present (Enc_G)\n+        and then Present (Enc_N)\n         and then Enc_G /= Enc_N\n         and then Earlier (N, Gen_Body)\n       then\n@@ -9771,254 +10019,6 @@ package body Sem_Ch12 is\n       end if;\n    end Insert_Freeze_Node_For_Instance;\n \n-   -----------------------------\n-   -- Freeze_Package_Instance --\n-   -----------------------------\n-\n-   procedure Freeze_Package_Instance\n-     (N        : Node_Id;\n-      Gen_Body : Node_Id;\n-      Gen_Decl : Node_Id;\n-      Act_Id   : Entity_Id)\n-   is\n-      function In_Same_Scope (Gen_Id, Act_Id : Node_Id) return Boolean;\n-      --  Check if the generic definition and the instantiation come from\n-      --  a common scope, in which case the instance must be frozen after\n-      --  the generic body.\n-\n-      function True_Sloc (N, Act_Unit : Node_Id) return Source_Ptr;\n-      --  If the instance is nested inside a generic unit, the Sloc of the\n-      --  instance indicates the place of the original definition, not the\n-      --  point of the current enclosing instance. Pending a better usage of\n-      --  Slocs to indicate instantiation places, we determine the place of\n-      --  origin of a node by finding the maximum sloc of any ancestor node.\n-\n-      --  Why is this not equivalent to Top_Level_Location ???\n-\n-      -------------------\n-      -- In_Same_Scope --\n-      -------------------\n-\n-      function In_Same_Scope (Gen_Id, Act_Id : Node_Id) return Boolean is\n-         Act_Scop : Entity_Id := Scope (Act_Id);\n-         Gen_Scop : Entity_Id := Scope (Gen_Id);\n-\n-      begin\n-         while Act_Scop /= Standard_Standard\n-           and then Gen_Scop /= Standard_Standard\n-         loop\n-            if Act_Scop = Gen_Scop then\n-               return True;\n-            end if;\n-\n-            Act_Scop := Scope (Act_Scop);\n-            Gen_Scop := Scope (Gen_Scop);\n-         end loop;\n-\n-         return False;\n-      end In_Same_Scope;\n-\n-      ---------------\n-      -- True_Sloc --\n-      ---------------\n-\n-      function True_Sloc (N, Act_Unit : Node_Id) return Source_Ptr is\n-         N1  : Node_Id;\n-         Res : Source_Ptr;\n-\n-      begin\n-         Res := Sloc (N);\n-         N1  := N;\n-         while Present (N1) and then N1 /= Act_Unit loop\n-            if Sloc (N1) > Res then\n-               Res := Sloc (N1);\n-            end if;\n-\n-            N1 := Parent (N1);\n-         end loop;\n-\n-         return Res;\n-      end True_Sloc;\n-\n-      --  Local variables\n-\n-      Gen_Id    : constant Entity_Id := Get_Generic_Entity (N);\n-      Par_Id    : constant Entity_Id := Scope (Gen_Id);\n-      Act_Unit  : constant Node_Id   := Unit (Cunit (Get_Source_Unit (N)));\n-      Gen_Unit  : constant Node_Id   :=\n-                    Unit (Cunit (Get_Source_Unit (Gen_Decl)));\n-\n-      Body_Unit  : Node_Id;\n-      F_Node     : Node_Id;\n-      Must_Delay : Boolean;\n-      Orig_Body  : Node_Id;\n-\n-   --  Start of processing for Freeze_Package_Instance\n-\n-   begin\n-      --  If the body is a subunit, the freeze point is the corresponding stub\n-      --  in the current compilation, not the subunit itself.\n-\n-      if Nkind (Parent (Gen_Body)) = N_Subunit then\n-         Orig_Body := Corresponding_Stub (Parent (Gen_Body));\n-      else\n-         Orig_Body := Gen_Body;\n-      end if;\n-\n-      Body_Unit := Unit (Cunit (Get_Source_Unit (Orig_Body)));\n-\n-      --  If the instantiation and the generic definition appear in the same\n-      --  package declaration, this is an early instantiation. If they appear\n-      --  in the same declarative part, it is an early instantiation only if\n-      --  the generic body appears textually later, and the generic body is\n-      --  also in the main unit.\n-\n-      --  If instance is nested within a subprogram, and the generic body\n-      --  is not, the instance is delayed because the enclosing body is. If\n-      --  instance and body are within the same scope, or the same subprogram\n-      --  body, indicate explicitly that the instance is delayed.\n-\n-      Must_Delay :=\n-        (Gen_Unit = Act_Unit\n-          and then (Nkind (Gen_Unit) in N_Generic_Package_Declaration\n-                                      | N_Package_Declaration\n-                     or else (Gen_Unit = Body_Unit\n-                               and then\n-                              True_Sloc (N, Act_Unit) < Sloc (Orig_Body)))\n-          and then Is_In_Main_Unit (Original_Node (Gen_Unit))\n-          and then In_Same_Scope (Gen_Id, Act_Id));\n-\n-      --  If this is an early instantiation, the freeze node is placed after\n-      --  the generic body. Otherwise, if the generic appears in an instance,\n-      --  we cannot freeze the current instance until the outer one is frozen.\n-      --  This is only relevant if the current instance is nested within some\n-      --  inner scope not itself within the outer instance. If this scope is\n-      --  a package body in the same declarative part as the outer instance,\n-      --  then that body needs to be frozen after the outer instance. Finally,\n-      --  if no delay is needed, we place the freeze node at the end of the\n-      --  current declarative part.\n-\n-      if No (Freeze_Node (Act_Id))\n-        or else not Is_List_Member (Freeze_Node (Act_Id))\n-      then\n-         Ensure_Freeze_Node (Act_Id);\n-         F_Node := Freeze_Node (Act_Id);\n-\n-         if Must_Delay then\n-            Insert_After (Orig_Body, F_Node);\n-\n-         elsif Is_Generic_Instance (Par_Id)\n-           and then Present (Freeze_Node (Par_Id))\n-           and then Scope (Act_Id) /= Par_Id\n-         then\n-            --  Freeze instance of inner generic after instance of enclosing\n-            --  generic.\n-\n-            if In_Same_Declarative_Part (Parent (Freeze_Node (Par_Id)), N) then\n-\n-               --  Handle the following case:\n-\n-               --    package Parent_Inst is new ...\n-               --    freeze Parent_Inst []\n-\n-               --    procedure P ...  --  this body freezes Parent_Inst\n-\n-               --    package Inst is new ...\n-\n-               --  In this particular scenario, the freeze node for Inst must\n-               --  be inserted in the same manner as that of Parent_Inst,\n-               --  before the next source body or at the end of the declarative\n-               --  list (body not available). If body P did not exist and\n-               --  Parent_Inst was frozen after Inst, either by a body\n-               --  following Inst or at the end of the declarative region,\n-               --  the freeze node for Inst must be inserted after that of\n-               --  Parent_Inst. This relation is established by comparing\n-               --  the Slocs of Parent_Inst freeze node and Inst.\n-               --  We examine the parents of the enclosing lists to handle\n-               --  the case where the parent instance is in the visible part\n-               --  of a package declaration, and the inner instance is in\n-               --  the corresponding private part.\n-\n-               if Parent (List_Containing (Get_Unit_Instantiation_Node\n-                                                                     (Par_Id)))\n-                    = Parent (List_Containing (N))\n-                 and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n-               then\n-                  Insert_Freeze_Node_For_Instance (N, F_Node);\n-               else\n-                  Insert_After (Freeze_Node (Par_Id), F_Node);\n-               end if;\n-\n-            --  Freeze package enclosing instance of inner generic after\n-            --  instance of enclosing generic.\n-\n-            elsif Nkind (Parent (N)) in N_Package_Body | N_Subprogram_Body\n-              and then In_Same_Declarative_Part\n-                         (Parent (Freeze_Node (Par_Id)), Parent (N))\n-            then\n-               declare\n-                  Enclosing :  Entity_Id;\n-\n-               begin\n-                  Enclosing := Corresponding_Spec (Parent (N));\n-\n-                  if No (Enclosing) then\n-                     Enclosing := Defining_Entity (Parent (N));\n-                  end if;\n-\n-                  Insert_Freeze_Node_For_Instance (N, F_Node);\n-                  Ensure_Freeze_Node (Enclosing);\n-\n-                  if not Is_List_Member (Freeze_Node (Enclosing)) then\n-\n-                     --  The enclosing context is a subunit, insert the freeze\n-                     --  node after the stub.\n-\n-                     if Nkind (Parent (Parent (N))) = N_Subunit then\n-                        Insert_Freeze_Node_For_Instance\n-                          (Corresponding_Stub (Parent (Parent (N))),\n-                           Freeze_Node (Enclosing));\n-\n-                     --  The enclosing context is a package with a stub body\n-                     --  which has already been replaced by the real body.\n-                     --  Insert the freeze node after the actual body.\n-\n-                     elsif Ekind (Enclosing) = E_Package\n-                       and then Present (Body_Entity (Enclosing))\n-                       and then Was_Originally_Stub\n-                                  (Parent (Body_Entity (Enclosing)))\n-                     then\n-                        Insert_Freeze_Node_For_Instance\n-                          (Parent (Body_Entity (Enclosing)),\n-                           Freeze_Node (Enclosing));\n-\n-                     --  The parent instance has been frozen before the body of\n-                     --  the enclosing package, insert the freeze node after\n-                     --  the body.\n-\n-                     elsif In_Same_List (Freeze_Node (Par_Id), Parent (N))\n-                       and then Sloc (Freeze_Node (Par_Id)) < Sloc (Parent (N))\n-                     then\n-                        Insert_Freeze_Node_For_Instance\n-                          (Parent (N), Freeze_Node (Enclosing));\n-\n-                     else\n-                        Insert_After\n-                          (Freeze_Node (Par_Id), Freeze_Node (Enclosing));\n-                     end if;\n-                  end if;\n-               end;\n-\n-            else\n-               Insert_Freeze_Node_For_Instance (N, F_Node);\n-            end if;\n-\n-         else\n-            Insert_Freeze_Node_For_Instance (N, F_Node);\n-         end if;\n-      end if;\n-   end Freeze_Package_Instance;\n-\n    -----------------------------\n    -- Install_Formal_Packages --\n    -----------------------------"}]}