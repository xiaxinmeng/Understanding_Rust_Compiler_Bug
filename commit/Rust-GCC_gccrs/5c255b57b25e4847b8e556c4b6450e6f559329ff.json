{"sha": "5c255b57b25e4847b8e556c4b6450e6f559329ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMyNTViNTdiMjVlNDg0N2I4ZTU1NmM0YjY0NTBlNmY1NTkzMjlmZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-09-24T21:20:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-09-24T21:20:51Z"}, "message": "ia64.c (ia64_dwarf_handle_frame_unspec): New.\n\n        * config/ia64/ia64.c (ia64_dwarf_handle_frame_unspec): New.\n        (TARGET_DWARF_HANDLE_FRAME_UNSPEC): New.\n        (do_spill): Use REG_CFA_OFFSET.\n        (ia64_expand_prologue): Use REG_CFA_ADJUST_CFA and REG_CFA_REGISTER\n        as appropriate.\n        (ia64_expand_epilogue): Likewise.\n        (process_set): Split into ...\n        (process_cfa_adjust_cfa): this,\n        (process_cfa_register): this,\n        (process_cfa_offset): and this new function.\n        (ia64_asm_unwind_emit): Use them.  Expect REG_CFA_* notes\n        instead of REG_FRAME_RELATED_EXPR.\n\nFrom-SVN: r164609", "tree": {"sha": "ca853092ccb049a5f1c56a25ff23f57cf18aded6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca853092ccb049a5f1c56a25ff23f57cf18aded6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c255b57b25e4847b8e556c4b6450e6f559329ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c255b57b25e4847b8e556c4b6450e6f559329ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c255b57b25e4847b8e556c4b6450e6f559329ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c255b57b25e4847b8e556c4b6450e6f559329ff/comments", "author": null, "committer": null, "parents": [{"sha": "42d87712de00f53891da8b73a90de180341eac18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d87712de00f53891da8b73a90de180341eac18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42d87712de00f53891da8b73a90de180341eac18"}], "stats": {"total": 570, "additions": 319, "deletions": 251}, "files": [{"sha": "012757ebaa2655583f9c4643e20165bc4443da60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c255b57b25e4847b8e556c4b6450e6f559329ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c255b57b25e4847b8e556c4b6450e6f559329ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c255b57b25e4847b8e556c4b6450e6f559329ff", "patch": "@@ -1,3 +1,18 @@\n+2010-09-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_dwarf_handle_frame_unspec): New.\n+\t(TARGET_DWARF_HANDLE_FRAME_UNSPEC): New.\n+\t(do_spill): Use REG_CFA_OFFSET.\n+\t(ia64_expand_prologue): Use REG_CFA_ADJUST_CFA and REG_CFA_REGISTER\n+\tas appropriate.\n+\t(ia64_expand_epilogue): Likewise.\n+\t(process_set): Split into ...\n+\t(process_cfa_adjust_cfa): this,\n+\t(process_cfa_register): this,\n+\t(process_cfa_offset): and this new function.\n+\t(ia64_asm_unwind_emit): Use them.  Expect REG_CFA_* notes\n+\tinstead of REG_FRAME_RELATED_EXPR.\n+\n 2010-09-24  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/i386/vx-common.h (DBX_REGISTER_NUMBER): Reinstate."}, {"sha": "61be5a45bbea60ac69bdac8b848b8f2518bc6b82", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 304, "deletions": 251, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c255b57b25e4847b8e556c4b6450e6f559329ff/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c255b57b25e4847b8e556c4b6450e6f559329ff/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5c255b57b25e4847b8e556c4b6450e6f559329ff", "patch": "@@ -230,7 +230,6 @@ static void emit_predicate_relation_info (void);\n static void ia64_reorg (void);\n static bool ia64_in_small_data_p (const_tree);\n static void process_epilogue (FILE *, rtx, bool, bool);\n-static int process_set (FILE *, rtx, rtx, bool, bool);\n \n static bool ia64_assemble_integer (rtx, unsigned int, int);\n static void ia64_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -318,6 +317,8 @@ static enum machine_mode ia64_promote_function_mode (const_tree,\n \t\t\t\t\t\t     int);\n static void ia64_trampoline_init (rtx, tree, rtx);\n static void ia64_override_options_after_change (void);\n+\n+static void ia64_dwarf_handle_frame_unspec (const char *, rtx, int);\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -527,6 +528,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ia64_gimplify_va_arg\n \n+#undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n+#define TARGET_DWARF_HANDLE_FRAME_UNSPEC  ia64_dwarf_handle_frame_unspec\n #undef TARGET_ASM_UNWIND_EMIT\n #define TARGET_ASM_UNWIND_EMIT ia64_asm_unwind_emit\n #undef TARGET_ASM_EMIT_EXCEPT_PERSONALITY\n@@ -3035,7 +3038,7 @@ do_spill (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off,\n \t  off = current_frame_info.total_size - cfa_off;\n \t}\n \n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+      add_reg_note (insn, REG_CFA_OFFSET,\n \t\t    gen_rtx_SET (VOIDmode,\n \t\t\t\t gen_rtx_MEM (GET_MODE (reg),\n \t\t\t\t\t      plus_constant (base, off)),\n@@ -3219,6 +3222,10 @@ ia64_expand_prologue (void)\n     {\n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Force the unwind info to recognize this as defining a new CFA,\n+\t rather than some temp register setup.  */\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, NULL_RTX);\n     }\n \n   if (current_frame_info.total_size != 0)\n@@ -3241,13 +3248,12 @@ ia64_expand_prologue (void)\n       if (! frame_pointer_needed)\n \t{\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  if (GET_CODE (offset) != CONST_INT)\n-\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t\t  gen_rtx_SET (VOIDmode,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       gen_rtx_PLUS (DImode,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     frame_size_rtx)));\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     gen_rtx_PLUS (DImode,\n+\t\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t\t   frame_size_rtx)));\n \t}\n \n       /* ??? At this point we must generate a magic insn that appears to\n@@ -3275,7 +3281,11 @@ ia64_expand_prologue (void)\n \n       reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\n       insn = emit_move_insn (ar_unat_save_reg, reg);\n-      RTX_FRAME_RELATED_P (insn) = (current_frame_info.r[reg_save_ar_unat] != 0);\n+      if (current_frame_info.r[reg_save_ar_unat])\n+\t{\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_REGISTER, NULL_RTX);\n+\t}\n \n       /* Even if we're not going to generate an epilogue, we still\n \t need to save the register so that EH works.  */\n@@ -3314,8 +3324,7 @@ ia64_expand_prologue (void)\n \t  /* ??? Denote pr spill/fill by a DImode move that modifies all\n \t     64 hard registers.  */\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (VOIDmode, alt_reg, reg));\n+\t  add_reg_note (insn, REG_CFA_REGISTER, NULL_RTX);\n \n \t  /* Even if we're not going to generate an epilogue, we still\n \t     need to save the register so that EH works.  */\n@@ -3361,6 +3370,7 @@ ia64_expand_prologue (void)\n \t  reg_emitted (reg_save_ar_lc);\n \t  insn = emit_move_insn (alt_reg, reg);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_REGISTER, NULL_RTX);\n \n \t  /* Even if we're not going to generate an epilogue, we still\n \t     need to save the register so that EH works.  */\n@@ -3387,6 +3397,7 @@ ia64_expand_prologue (void)\n           reg_emitted (reg_save_b0);\n \t  insn = emit_move_insn (alt_reg, reg);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_REGISTER, NULL_RTX);\n \n \t  /* Even if we're not going to generate an epilogue, we still\n \t     need to save the register so that EH works.  */\n@@ -3677,6 +3688,7 @@ ia64_expand_epilogue (int sibcall_p)\n     {\n       insn = emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, NULL);\n     }\n   else if (current_frame_info.total_size)\n     {\n@@ -3696,13 +3708,12 @@ ia64_expand_epilogue (int sibcall_p)\n \t\t\t\t    offset));\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n-      if (GET_CODE (offset) != CONST_INT)\n-\tadd_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t      gen_rtx_SET (VOIDmode,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   gen_rtx_PLUS (DImode,\n-\t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t frame_size_rtx)));\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t    gen_rtx_SET (VOIDmode,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t gen_rtx_PLUS (DImode,\n+\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t       frame_size_rtx)));\n     }\n \n   if (cfun->machine->ia64_eh_epilogue_bsp)\n@@ -3713,11 +3724,12 @@ ia64_expand_epilogue (int sibcall_p)\n   else\n     {\n       int fp = GR_REG (2);\n-      /* We need a throw away register here, r0 and r1 are reserved, so r2 is the\n-\t first available call clobbered register.  If there was a frame_pointer\n-\t register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM,\n-\t so we have to make sure we're using the string \"r2\" when emitting\n-\t the register name for the assembler.  */\n+      /* We need a throw away register here, r0 and r1 are reserved,\n+\t so r2 is the first available call clobbered register.  If\n+\t there was a frame_pointer register, we may have swapped the\n+\t names of r2 and HARD_FRAME_POINTER_REGNUM, so we have to make\n+\t sure we're using the string \"r2\" when emitting the register\n+\t name for the assembler.  */\n       if (current_frame_info.r[reg_fp] \n           && current_frame_info.r[reg_fp] == GR_REG (2))\n \tfp = HARD_FRAME_POINTER_REGNUM;\n@@ -9590,6 +9602,17 @@ ia64_dwarf2out_def_steady_cfa (rtx insn, bool frame)\n      + ARG_POINTER_CFA_OFFSET (current_function_decl));\n }\n \n+/* All we need to do here is avoid a crash in the generic dwarf2\n+   processing.  The real CFA definition is set up above.  */\n+\n+static void\n+ia64_dwarf_handle_frame_unspec (const char * ARG_UNUSED (label),\n+\t\t\t\trtx ARG_UNUSED (pattern),\n+\t\t\t\tint index)\n+{\n+  gcc_assert (index == UNSPECV_ALLOC);\n+}\n+\n /* The generic dwarf2 frame debug info generator does not define a\n    separate region for the very end of the epilogue, so refrain from\n    doing so in the IA64-specific code as well.  */\n@@ -9619,53 +9642,19 @@ process_epilogue (FILE *asm_out_file, rtx insn, bool unwind, bool frame)\n \t\t       STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n }\n \n-/* This function processes a SET pattern looking for specific patterns\n-   which result in emitting an assembly directive required for unwinding.  */\n+/* This function processes a SET pattern for REG_CFA_ADJUST_CFA.  */\n \n-static int\n-process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n+static void\n+process_cfa_adjust_cfa (FILE *asm_out_file, rtx pat, rtx insn,\n+\t\t\tbool unwind, bool frame)\n {\n-  rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n-  int src_regno, dest_regno;\n-\n-  /* Look for the ALLOC insn.  */\n-  if (GET_CODE (src) == UNSPEC_VOLATILE\n-      && XINT (src, 1) == UNSPECV_ALLOC\n-      && GET_CODE (dest) == REG)\n-    {\n-      dest_regno = REGNO (dest);\n-\n-      /* If this is the final destination for ar.pfs, then this must\n-\t be the alloc in the prologue.  */\n-      if (dest_regno == current_frame_info.r[reg_save_ar_pfs])\n-\t{\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t}\n-      else\n-\t{\n-\t  /* This must be an alloc before a sibcall.  We must drop the\n-\t     old frame info.  The easiest way to drop the old frame\n-\t     info is to ensure we had a \".restore sp\" directive\n-\t     followed by a new prologue.  If the procedure doesn't\n-\t     have a memory-stack frame, we'll issue a dummy \".restore\n-\t     sp\" now.  */\n-\t  if (current_frame_info.total_size == 0 && !frame_pointer_needed)\n-\t    /* if haven't done process_epilogue() yet, do it now */\n-\t    process_epilogue (asm_out_file, insn, unwind, frame);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.prologue\\n\");\n-\t}\n-      return 1;\n-    }\n+  rtx src = SET_SRC (pat);\n \n-  /* Look for SP = ....  */\n-  if (GET_CODE (dest) == REG && REGNO (dest) == STACK_POINTER_REGNUM)\n+  if (dest == stack_pointer_rtx)\n     {\n       if (GET_CODE (src) == PLUS)\n-        {\n+\t{\n \t  rtx op0 = XEXP (src, 0);\n \t  rtx op1 = XEXP (src, 1);\n \t  \n@@ -9675,7 +9664,8 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \t    {\n \t      gcc_assert (!frame_pointer_needed);\n \t      if (unwind)\n-\t\tfprintf (asm_out_file, \"\\t.fframe \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t\tfprintf (asm_out_file,\n+\t\t\t \"\\t.fframe \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t\t\t -INTVAL (op1));\n \t      ia64_dwarf2out_def_steady_cfa (insn, frame);\n \t    }\n@@ -9684,240 +9674,303 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \t}\n       else\n \t{\n-\t  gcc_assert (GET_CODE (src) == REG\n-\t\t      && REGNO (src) == HARD_FRAME_POINTER_REGNUM);\n+\t  gcc_assert (src == hard_frame_pointer_rtx);\n \t  process_epilogue (asm_out_file, insn, unwind, frame);\n \t}\n+    }\n+  else if (dest == hard_frame_pointer_rtx)\n+    {\n+      gcc_assert (src == stack_pointer_rtx);\n+      gcc_assert (frame_pointer_needed);\n \n-      return 1;\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n+\t\t ia64_dbx_register_number (REGNO (dest)));\n+      ia64_dwarf2out_def_steady_cfa (insn, frame);\n     }\n+  else\n+    gcc_unreachable ();\n+}\n \n-  /* Register move we need to look at.  */\n-  if (GET_CODE (dest) == REG && GET_CODE (src) == REG)\n-    {\n-      src_regno = REGNO (src);\n-      dest_regno = REGNO (dest);\n+/* This function processes a SET pattern for REG_CFA_REGISTER.  */\n \n-      switch (src_regno)\n-\t{\n-\tcase BR_REG (0):\n-\t  /* Saving return address pointer.  */\n-\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_b0]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t  return 1;\n+static void\n+process_cfa_register (FILE *asm_out_file, rtx pat, bool unwind)\n+{\n+  rtx dest = SET_DEST (pat);\n+  rtx src = SET_SRC (pat);\n \n-\tcase PR_REG (0):\n-\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_pr]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t  return 1;\n+  int dest_regno = REGNO (dest);\n+  int src_regno = REGNO (src);\n \n-\tcase AR_UNAT_REGNUM:\n-\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_unat]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t  return 1;\n+  switch (src_regno)\n+    {\n+    case BR_REG (0):\n+      /* Saving return address pointer.  */\n+      gcc_assert (dest_regno == current_frame_info.r[reg_save_b0]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n+\t\t ia64_dbx_register_number (dest_regno));\n+      break;\n \n-\tcase AR_LC_REGNUM:\n-\t  gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_lc]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t  return 1;\n+    case PR_REG (0):\n+      gcc_assert (dest_regno == current_frame_info.r[reg_save_pr]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n+\t\t ia64_dbx_register_number (dest_regno));\n+      break;\n \n-\tcase STACK_POINTER_REGNUM:\n-\t  gcc_assert (dest_regno == HARD_FRAME_POINTER_REGNUM\n-\t\t      && frame_pointer_needed);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n-\t\t     ia64_dbx_register_number (dest_regno));\n-\t  ia64_dwarf2out_def_steady_cfa (insn, frame);\n-\t  return 1;\n+    case AR_UNAT_REGNUM:\n+      gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_unat]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n+\t\t ia64_dbx_register_number (dest_regno));\n+      break;\n \n-\tdefault:\n-\t  /* Everything else should indicate being stored to memory.  */\n-\t  gcc_unreachable ();\n-\t}\n+    case AR_LC_REGNUM:\n+      gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_lc]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n+\t\t ia64_dbx_register_number (dest_regno));\n+      break;\n+\n+    default:\n+      /* Everything else should indicate being stored to memory.  */\n+      gcc_unreachable ();\n     }\n+}\n \n-  /* Memory store we need to look at.  */\n-  if (GET_CODE (dest) == MEM && GET_CODE (src) == REG)\n-    {\n-      long off;\n-      rtx base;\n-      const char *saveop;\n+/* This function processes a SET pattern for REG_CFA_OFFSET.  */\n \n-      if (GET_CODE (XEXP (dest, 0)) == REG)\n-\t{\n-\t  base = XEXP (dest, 0);\n-\t  off = 0;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (GET_CODE (XEXP (dest, 0)) == PLUS\n-\t\t      && GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT);\n-\t  base = XEXP (XEXP (dest, 0), 0);\n-\t  off = INTVAL (XEXP (XEXP (dest, 0), 1));\n-\t}\n+static void\n+process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n+{\n+  rtx dest = SET_DEST (pat);\n+  rtx src = SET_SRC (pat);\n+  int src_regno = REGNO (src);\n+  const char *saveop;\n+  HOST_WIDE_INT off;\n+  rtx base;\n \n-      if (base == hard_frame_pointer_rtx)\n-\t{\n-\t  saveop = \".savepsp\";\n-\t  off = - off;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (base == stack_pointer_rtx);\n-\t  saveop = \".savesp\";\n-\t}\n+  gcc_assert (MEM_P (dest));\n+  if (GET_CODE (XEXP (dest, 0)) == REG)\n+    {\n+      base = XEXP (dest, 0);\n+      off = 0;\n+    }\n+  else\n+    {\n+      gcc_assert (GET_CODE (XEXP (dest, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT);\n+      base = XEXP (XEXP (dest, 0), 0);\n+      off = INTVAL (XEXP (XEXP (dest, 0), 1));\n+    }\n \n-      src_regno = REGNO (src);\n-      switch (src_regno)\n-\t{\n-\tcase BR_REG (0):\n-\t  gcc_assert (!current_frame_info.r[reg_save_b0]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t%s rp, %ld\\n\", saveop, off);\n-\t  return 1;\n+  if (base == hard_frame_pointer_rtx)\n+    {\n+      saveop = \".savepsp\";\n+      off = - off;\n+    }\n+  else\n+    {\n+      gcc_assert (base == stack_pointer_rtx);\n+      saveop = \".savesp\";\n+    }\n \n-\tcase PR_REG (0):\n-\t  gcc_assert (!current_frame_info.r[reg_save_pr]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t%s pr, %ld\\n\", saveop, off);\n-\t  return 1;\n+  src_regno = REGNO (src);\n+  switch (src_regno)\n+    {\n+    case BR_REG (0):\n+      gcc_assert (!current_frame_info.r[reg_save_b0]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t%s rp, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t saveop, off);\n+      break;\n \n-\tcase AR_LC_REGNUM:\n-\t  gcc_assert (!current_frame_info.r[reg_save_ar_lc]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t%s ar.lc, %ld\\n\", saveop, off);\n-\t  return 1;\n+    case PR_REG (0):\n+      gcc_assert (!current_frame_info.r[reg_save_pr]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t%s pr, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t saveop, off);\n+      break;\n \n-\tcase AR_PFS_REGNUM:\n-\t  gcc_assert (!current_frame_info.r[reg_save_ar_pfs]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t%s ar.pfs, %ld\\n\", saveop, off);\n-\t  return 1;\n+    case AR_LC_REGNUM:\n+      gcc_assert (!current_frame_info.r[reg_save_ar_lc]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t%s ar.lc, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t saveop, off);\n+      break;\n \n-\tcase AR_UNAT_REGNUM:\n-\t  gcc_assert (!current_frame_info.r[reg_save_ar_unat]);\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t%s ar.unat, %ld\\n\", saveop, off);\n-\t  return 1;\n+    case AR_PFS_REGNUM:\n+      gcc_assert (!current_frame_info.r[reg_save_ar_pfs]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t%s ar.pfs, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t saveop, off);\n+      break;\n \n-\tcase GR_REG (4):\n-\tcase GR_REG (5):\n-\tcase GR_REG (6):\n-\tcase GR_REG (7):\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n-\t\t     1 << (src_regno - GR_REG (4)));\n-\t  return 1;\n+    case AR_UNAT_REGNUM:\n+      gcc_assert (!current_frame_info.r[reg_save_ar_unat]);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t%s ar.unat, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t\t saveop, off);\n+      break;\n \n-\tcase BR_REG (1):\n-\tcase BR_REG (2):\n-\tcase BR_REG (3):\n-\tcase BR_REG (4):\n-\tcase BR_REG (5):\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n-\t\t     1 << (src_regno - BR_REG (1)));\n-\t  return 1;\n+    case GR_REG (4):\n+    case GR_REG (5):\n+    case GR_REG (6):\n+    case GR_REG (7):\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n+\t\t 1 << (src_regno - GR_REG (4)));\n+      break;\n \n-\tcase FR_REG (2):\n-\tcase FR_REG (3):\n-\tcase FR_REG (4):\n-\tcase FR_REG (5):\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n-\t\t     1 << (src_regno - FR_REG (2)));\n-\t  return 1;\n+    case BR_REG (1):\n+    case BR_REG (2):\n+    case BR_REG (3):\n+    case BR_REG (4):\n+    case BR_REG (5):\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n+\t\t 1 << (src_regno - BR_REG (1)));\n+      break;\n \n-\tcase FR_REG (16): case FR_REG (17): case FR_REG (18): case FR_REG (19):\n-\tcase FR_REG (20): case FR_REG (21): case FR_REG (22): case FR_REG (23):\n-\tcase FR_REG (24): case FR_REG (25): case FR_REG (26): case FR_REG (27):\n-\tcase FR_REG (28): case FR_REG (29): case FR_REG (30): case FR_REG (31):\n-\t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n-\t\t     1 << (src_regno - FR_REG (12)));\n-\t  return 1;\n+    case FR_REG (2):\n+    case FR_REG (3):\n+    case FR_REG (4):\n+    case FR_REG (5):\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n+\t\t 1 << (src_regno - FR_REG (2)));\n+      break;\n \n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n+    case FR_REG (16): case FR_REG (17): case FR_REG (18): case FR_REG (19):\n+    case FR_REG (20): case FR_REG (21): case FR_REG (22): case FR_REG (23):\n+    case FR_REG (24): case FR_REG (25): case FR_REG (26): case FR_REG (27):\n+    case FR_REG (28): case FR_REG (29): case FR_REG (30): case FR_REG (31):\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n+\t\t 1 << (src_regno - FR_REG (12)));\n+      break;\n \n-  return 0;\n+    default:\n+      /* ??? For some reason we mark other general registers, even those\n+\t we can't represent in the unwind info.  Ignore them.  */\n+      break;\n+    }\n }\n \n-\n /* This function looks at a single insn and emits any directives\n    required to unwind this insn.  */\n+\n static void\n ia64_asm_unwind_emit (FILE *asm_out_file, rtx insn)\n {\n   bool unwind = (flag_unwind_tables\n \t\t || (flag_exceptions && !USING_SJLJ_EXCEPTIONS));\n   bool frame = dwarf2out_do_frame ();\n+  rtx note, pat;\n+  bool handled_one;\n+\n+  if (!unwind && !frame)\n+    return;\n \n-  if (unwind || frame)\n+  if (NOTE_INSN_BASIC_BLOCK_P (insn))\n     {\n-      rtx pat;\n+      last_block = NOTE_BASIC_BLOCK (insn)->next_bb == EXIT_BLOCK_PTR;\n \n-      if (NOTE_INSN_BASIC_BLOCK_P (insn))\n+      /* Restore unwind state from immediately before the epilogue.  */\n+      if (need_copy_state)\n \t{\n-\t  last_block = NOTE_BASIC_BLOCK (insn)->next_bb == EXIT_BLOCK_PTR;\n-\n-\t  /* Restore unwind state from immediately before the epilogue.  */\n-\t  if (need_copy_state)\n+\t  if (unwind)\n \t    {\n-\t      if (unwind)\n-\t\t{\n-\t\t  fprintf (asm_out_file, \"\\t.body\\n\");\n-\t\t  fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n-\t\t\t   cfun->machine->state_num);\n-\t\t}\n-\t      if (IA64_CHANGE_CFA_IN_EPILOGUE)\n-\t\tia64_dwarf2out_def_steady_cfa (insn, frame);\n-\t      need_copy_state = false;\n+\t      fprintf (asm_out_file, \"\\t.body\\n\");\n+\t      fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n+\t\t       cfun->machine->state_num);\n \t    }\n+\t  if (IA64_CHANGE_CFA_IN_EPILOGUE)\n+\t    ia64_dwarf2out_def_steady_cfa (insn, frame);\n+\t  need_copy_state = false;\n \t}\n+    }\n \n-      if (GET_CODE (insn) == NOTE || ! RTX_FRAME_RELATED_P (insn))\n-\treturn;\n+  if (GET_CODE (insn) == NOTE || ! RTX_FRAME_RELATED_P (insn))\n+    return;\n+\n+  /* Look for the ALLOC insn.  */\n+  if (INSN_CODE (insn) == CODE_FOR_alloc)\n+    {\n+      rtx dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+      int dest_regno = REGNO (dest);\n \n-      pat = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n-      if (pat)\n-\tpat = XEXP (pat, 0);\n+      /* If this is the final destination for ar.pfs, then this must\n+\t be the alloc in the prologue.  */\n+      if (dest_regno == current_frame_info.r[reg_save_ar_pfs])\n+\t{\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n+\t}\n       else\n-\tpat = PATTERN (insn);\n+\t{\n+\t  /* This must be an alloc before a sibcall.  We must drop the\n+\t     old frame info.  The easiest way to drop the old frame\n+\t     info is to ensure we had a \".restore sp\" directive\n+\t     followed by a new prologue.  If the procedure doesn't\n+\t     have a memory-stack frame, we'll issue a dummy \".restore\n+\t     sp\" now.  */\n+\t  if (current_frame_info.total_size == 0 && !frame_pointer_needed)\n+\t    /* if haven't done process_epilogue() yet, do it now */\n+\t    process_epilogue (asm_out_file, insn, unwind, frame);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.prologue\\n\");\n+\t}\n+      return;\n+    }\n \n-      switch (GET_CODE (pat))\n-        {\n-\tcase SET:\n-\t  process_set (asm_out_file, pat, insn, unwind, frame);\n-\t  break;\n+  handled_one = false;\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    switch (REG_NOTE_KIND (note))\n+      {\n+      case REG_CFA_ADJUST_CFA:\n+\tpat = XEXP (note, 0);\n+\tif (pat == NULL)\n+\t  pat = PATTERN (insn);\n+\tprocess_cfa_adjust_cfa (asm_out_file, pat, insn, unwind, frame);\n+\thandled_one = true;\n+\tbreak;\n \n-\tcase PARALLEL:\n-\t  {\n-\t    int par_index;\n-\t    int limit = XVECLEN (pat, 0);\n-\t    for (par_index = 0; par_index < limit; par_index++)\n-\t      {\n-\t\trtx x = XVECEXP (pat, 0, par_index);\n-\t\tif (GET_CODE (x) == SET)\n-\t\t  process_set (asm_out_file, x, insn, unwind, frame);\n-\t      }\n-\t    break;\n-\t  }\n+      case REG_CFA_OFFSET:\n+\tpat = XEXP (note, 0);\n+\tif (pat == NULL)\n+\t  pat = PATTERN (insn);\n+\tprocess_cfa_offset (asm_out_file, pat, unwind);\n+\thandled_one = true;\n+\tbreak;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+      case REG_CFA_REGISTER:\n+\tpat = XEXP (note, 0);\n+\tif (pat == NULL)\n+\t  pat = PATTERN (insn);\n+\tprocess_cfa_register (asm_out_file, pat, unwind);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_FRAME_RELATED_EXPR:\n+      case REG_CFA_DEF_CFA:\n+      case REG_CFA_EXPRESSION:\n+      case REG_CFA_RESTORE:\n+      case REG_CFA_SET_VDRAP:\n+\t/* Not used in the ia64 port.  */\n+\tgcc_unreachable ();\n+\n+      default:\n+\t/* Not a frame-related note.  */\n+\tbreak;\n+      }\n+\n+  /* All REG_FRAME_RELATED_P insns, besides ALLOC, are marked with the\n+     explicit action to take.  No guessing required.  */\n+  gcc_assert (handled_one);\n }\n \n /* Implement TARGET_ASM_EMIT_EXCEPT_PERSONALITY.  */"}]}