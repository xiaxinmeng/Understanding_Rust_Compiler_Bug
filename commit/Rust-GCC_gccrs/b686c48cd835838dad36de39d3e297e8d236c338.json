{"sha": "b686c48cd835838dad36de39d3e297e8d236c338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4NmM0OGNkODM1ODM4ZGFkMzZkZTM5ZDNlMjk3ZThkMjM2YzMzOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-20T02:38:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-20T02:38:56Z"}, "message": "alpha.c (emit_unlikely_jump, [...]): Split out from ...\n\n        * config/alpha/alpha.c (emit_unlikely_jump, emit_load_locked,\n        emit_store_conditional): Split out from ...\n        (alpha_split_atomic_op): ... here.\n        (alpha_split_compare_and_swap): New; extract from .md file.\n        (alpha_split_lock_test_and_set): Likewise.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/sync.md (sync_compare_and_swap<I48MODE>): Move\n        split code into alpha.c.\n        (sync_lock_test_and_set<I48MODE>): Likewise.\n\nFrom-SVN: r100005", "tree": {"sha": "752fb067b665acf9c4d281f624aeb5714431f180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/752fb067b665acf9c4d281f624aeb5714431f180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b686c48cd835838dad36de39d3e297e8d236c338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b686c48cd835838dad36de39d3e297e8d236c338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b686c48cd835838dad36de39d3e297e8d236c338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b686c48cd835838dad36de39d3e297e8d236c338/comments", "author": null, "committer": null, "parents": [{"sha": "ce88799c37e930e0b5e760119ea73237c43b5f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce88799c37e930e0b5e760119ea73237c43b5f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce88799c37e930e0b5e760119ea73237c43b5f61"}], "stats": {"total": 215, "additions": 123, "deletions": 92}, "files": [{"sha": "8ddd13334b153b465d36ea496ec25b55c5032e5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b686c48cd835838dad36de39d3e297e8d236c338", "patch": "@@ -1,3 +1,15 @@\n+2005-05-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (emit_unlikely_jump, emit_load_locked,\n+\temit_store_conditional): Split out from ...\n+\t(alpha_split_atomic_op): ... here.\n+\t(alpha_split_compare_and_swap): New; extract from .md file.\n+\t(alpha_split_lock_test_and_set): Likewise.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/sync.md (sync_compare_and_swap<I48MODE>): Move\n+\tsplit code into alpha.c.\n+\t(sync_lock_test_and_set<I48MODE>): Likewise.\n+\n 2005-05-19  Richard Henderson  <rth@redhat.com>\n \n \t* unwind.h, unwind-pe.h: Revert gcc_unreachable change of 05-17."}, {"sha": "ee14006f0e26ab3b8ed36843318eff27bccfa822", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=b686c48cd835838dad36de39d3e297e8d236c338", "patch": "@@ -102,6 +102,8 @@ extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n extern void alpha_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n+extern void alpha_split_compare_and_swap (rtx, rtx, rtx, rtx, rtx);\n+extern void alpha_split_lock_test_and_set (rtx, rtx, rtx, rtx);\n #endif\n \n extern rtx alpha_need_linkage (const char *, int);"}, {"sha": "56e08c5339ab29c8603d28bd03327a6c4c5a0d47", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 105, "deletions": 23, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b686c48cd835838dad36de39d3e297e8d236c338", "patch": "@@ -4448,6 +4448,48 @@ alpha_expand_builtin_vector_binop (rtx (*gen) (rtx, rtx, rtx),\n   emit_insn ((*gen) (op0, op1, op2));\n }\n \n+/* A subroutine of the atomic operation splitters.  Jump to LABEL if\n+   COND is true.  Mark the jump as unlikely to be taken.  */\n+\n+static void\n+emit_unlikely_jump (rtx cond, rtx label)\n+{\n+  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+  rtx x;\n+\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label, pc_rtx);\n+  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+}\n+\n+/* A subroutine of the atomic operation splitters.  Emit a load-locked\n+   instruction in MODE.  */\n+\n+static void\n+emit_load_locked (enum machine_mode mode, rtx reg, rtx mem)\n+{\n+  rtx (*fn) (rtx, rtx) = NULL;\n+  if (mode == SImode)\n+    fn = gen_load_locked_si;\n+  else if (mode == DImode)\n+    fn = gen_load_locked_di;\n+  emit_insn (fn (reg, mem));\n+}\n+\n+/* A subroutine of the atomic operation splitters.  Emit a store-conditional\n+   instruction in MODE.  */\n+\n+static void\n+emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n+{\n+  rtx (*fn) (rtx, rtx, rtx) = NULL;\n+  if (mode == SImode)\n+    fn = gen_store_conditional_si;\n+  else if (mode == DImode)\n+    fn = gen_store_conditional_di;\n+  emit_insn (fn (res, mem, val));\n+}\n+\n /* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n    to perform.  MEM is the memory on which to operate.  VAL is the second \n    operand of the binary operator.  BEFORE and AFTER are optional locations to\n@@ -4459,8 +4501,7 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n \t\t       rtx before, rtx after, rtx scratch)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  rtx label, cond, x;\n-  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+  rtx label, x, cond = gen_rtx_REG (DImode, REGNO (scratch));\n \n   emit_insn (gen_memory_barrier ());\n \n@@ -4470,40 +4511,81 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n \n   if (before == NULL)\n     before = scratch;\n-\n-  if (mode == SImode)\n-    emit_insn (gen_load_locked_si (before, mem));\n-  else if (mode == DImode)\n-    emit_insn (gen_load_locked_di (before, mem));\n-  else\n-    gcc_unreachable ();\n+  emit_load_locked (mode, before, mem);\n \n   if (code == NOT)\n-    {\n-      x = gen_rtx_NOT (mode, before);\n-      x = gen_rtx_AND (mode, x, val);\n-    }\n+    x = gen_rtx_AND (mode, gen_rtx_NOT (mode, before), val);\n   else\n     x = gen_rtx_fmt_ee (code, mode, before, val);\n-\n   if (after)\n     emit_insn (gen_rtx_SET (VOIDmode, after, copy_rtx (x)));\n   emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n \n-  cond = gen_rtx_REG (DImode, REGNO (scratch));\n-  if (mode == SImode)\n-    emit_insn (gen_store_conditional_si (cond, mem, scratch));\n-  else if (mode == DImode)\n-    emit_insn (gen_store_conditional_di (cond, mem, scratch));\n+  emit_store_conditional (mode, cond, mem, scratch);\n+\n+  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+  emit_unlikely_jump (x, label);\n+\n+  emit_insn (gen_memory_barrier ());\n+}\n+\n+/* Expand a compare and swap operation.  */\n+\n+void\n+alpha_split_compare_and_swap (rtx retval, rtx mem, rtx oldval, rtx newval,\n+\t\t\t      rtx scratch)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx label1, label2, x, cond = gen_lowpart (DImode, scratch);\n+\n+  emit_insn (gen_memory_barrier ());\n+\n+  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label1, 0));\n+\n+  emit_load_locked (mode, retval, mem);\n+\n+  x = gen_lowpart (DImode, retval);\n+  if (oldval == const0_rtx)\n+    x = gen_rtx_NE (DImode, x, const0_rtx);\n   else\n-    gcc_unreachable ();\n+    {\n+      x = gen_rtx_EQ (DImode, x, oldval);\n+      emit_insn (gen_rtx_SET (VOIDmode, cond, x));\n+      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+    }\n+  emit_unlikely_jump (x, label2);\n+\n+  emit_move_insn (scratch, newval);\n+  emit_store_conditional (mode, cond, mem, scratch);\n \n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);\n-  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n-  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+  emit_unlikely_jump (x, label1);\n \n   emit_insn (gen_memory_barrier ());\n+  emit_label (XEXP (label2, 0));\n+}\n+\n+/* Expand an atomic exchange operation.  */\n+\n+void\n+alpha_split_lock_test_and_set (rtx retval, rtx mem, rtx val, rtx scratch)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx label, x, cond = gen_lowpart (DImode, scratch);\n+\n+  emit_insn (gen_memory_barrier ());\n+\n+  label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  emit_load_locked (mode, retval, mem);\n+  emit_move_insn (scratch, val);\n+  emit_store_conditional (mode, cond, mem, scratch);\n+\n+  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+  emit_unlikely_jump (x, label);\n }\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of"}, {"sha": "2cba9e372f232c8e1989c862c883b6aadf858e5a", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 4, "deletions": 69, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b686c48cd835838dad36de39d3e297e8d236c338/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=b686c48cd835838dad36de39d3e297e8d236c338", "patch": "@@ -221,49 +221,8 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  rtx retval, mem, oldval, newval, scratch;\n-  rtx cond, label1, label2, x;\n-  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n-\n-  retval = operands[0];\n-  mem = operands[1];\n-  oldval = operands[2];\n-  newval = operands[3];\n-  scratch = operands[4];\n-  cond = gen_lowpart (DImode, scratch);\n-\n-  emit_insn (gen_memory_barrier ());\n-\n-  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  emit_label (XEXP (label1, 0));\n-\n-  emit_insn (gen_load_locked_<mode> (retval, mem));\n-\n-  x = gen_lowpart (DImode, retval);\n-  if (oldval == const0_rtx)\n-    x = gen_rtx_NE (DImode, x, const0_rtx);\n-  else\n-    {\n-      x = gen_rtx_EQ (DImode, x, oldval);\n-      emit_insn (gen_rtx_SET (VOIDmode, cond, x));\n-      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n-    }\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label2, pc_rtx);\n-  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n-  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n-    \n-  emit_move_insn (scratch, newval);\n-\n-  emit_insn (gen_store_conditional_<mode> (cond, mem, scratch));\n-\n-  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label1, pc_rtx);\n-  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n-  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n-\n-  emit_insn (gen_memory_barrier ());\n-  emit_label (XEXP (label2, 0));\n+  alpha_split_compare_and_swap (operands[0], operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4]);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n@@ -281,32 +240,8 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  rtx retval, mem, val, scratch;\n-  rtx cond, label1, x;\n-  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n-\n-  retval = operands[0];\n-  mem = operands[1];\n-  val = operands[2];\n-  scratch = operands[3];\n-  cond = gen_lowpart (DImode, scratch);\n-\n-  emit_insn (gen_memory_barrier ());\n-\n-  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  emit_label (XEXP (label1, 0));\n-\n-  emit_insn (gen_load_locked_<mode> (retval, mem));\n-\n-  emit_move_insn (scratch, val);\n-  \n-  emit_insn (gen_store_conditional_<mode> (cond, mem, scratch));\n-\n-  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label1, pc_rtx);\n-  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n-  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n-\n+  alpha_split_lock_test_and_set (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]);\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])"}]}