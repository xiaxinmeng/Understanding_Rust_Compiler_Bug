{"sha": "d18672f220ba9377d8f86fb228b7142e98b23a44", "node_id": "C_kwDOANBUbNoAKGQxODY3MmYyMjBiYTkzNzdkOGY4NmZiMjI4YjcxNDJlOThiMjNhNDQ", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-10-30T14:59:01Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-01T13:12:48Z"}, "message": "Add type-resolution for enum items\n\nThis patch does the type resolution to actually create the types when we\nencounter enums within toplevel HIR::Items and HIR::Stmt conext's.\n\nWe don't support actual creation of enums yet in this patch but this is\nan isolated building block.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n\nAddresses #79", "tree": {"sha": "02b816d5ae2affa2eb98e093a4c46975152b9e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02b816d5ae2affa2eb98e093a4c46975152b9e9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18672f220ba9377d8f86fb228b7142e98b23a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18672f220ba9377d8f86fb228b7142e98b23a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18672f220ba9377d8f86fb228b7142e98b23a44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18672f220ba9377d8f86fb228b7142e98b23a44/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faa1a005e92237a0188311b48455be88126e3e68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa1a005e92237a0188311b48455be88126e3e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa1a005e92237a0188311b48455be88126e3e68"}], "stats": {"total": 254, "additions": 254, "deletions": 0}, "files": [{"sha": "1ab07b3bff20ee5b02ea7a14ecf2d4b575db27e1", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=d18672f220ba9377d8f86fb228b7142e98b23a44", "patch": "@@ -0,0 +1,149 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ENUMITEM\n+#define RUST_HIR_TYPE_CHECK_ENUMITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+extern ::Backend *\n+rust_get_backend ();\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckEnumItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static TyTy::VariantDef *Resolve (HIR::EnumItem *item,\n+\t\t\t\t    int64_t last_discriminant)\n+  {\n+    TypeCheckEnumItem resolver (last_discriminant);\n+    item->accept_vis (resolver);\n+    return resolver.variant;\n+  }\n+\n+  void visit (HIR::EnumItem &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_identifier (), last_discriminant + 1);\n+  }\n+\n+  void visit (HIR::EnumItemDiscriminant &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    auto &discriminant = item.get_discriminant_expression ();\n+    auto capacity_type = TypeCheckExpr::Resolve (discriminant.get (), false);\n+    if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    TyTy::USizeType *expected_ty\n+      = new TyTy::USizeType (discriminant->get_mappings ().get_hirid ());\n+    context->insert_type (discriminant->get_mappings (), expected_ty);\n+\n+    auto unified = expected_ty->unify (capacity_type);\n+    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    auto backend = rust_get_backend ();\n+    auto folded_discriminant\n+      = ConstFold::ConstFoldExpr::fold (discriminant.get ());\n+    if (folded_discriminant == nullptr\n+\t|| backend->is_error_expression (folded_discriminant))\n+      return;\n+\n+    size_t specified_discriminant;\n+    bool ok\n+      = backend->const_size_cast (folded_discriminant, &specified_discriminant);\n+    rust_assert (ok);\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_identifier (), specified_discriminant);\n+  }\n+\n+  void visit (HIR::EnumItemTuple &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    std::vector<TyTy::StructFieldType *> fields;\n+    size_t idx = 0;\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       std::to_string (idx), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+\tidx++;\n+      }\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_identifier (),\n+\t\t\t      TyTy::VariantDef::VariantType::TUPLE, fields);\n+  }\n+\n+  void visit (HIR::EnumItemStruct &item) override\n+  {\n+    if (last_discriminant == INT64_MAX)\n+      rust_error_at (item.get_locus (), \"discriminant too big\");\n+\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       field.get_field_name (), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+      }\n+\n+    variant\n+      = new TyTy::VariantDef (item.get_identifier (),\n+\t\t\t      TyTy::VariantDef::VariantType::STRUCT, fields);\n+  }\n+\n+private:\n+  TypeCheckEnumItem (int64_t last_discriminant)\n+    : TypeCheckBase (), variant (nullptr), last_discriminant (last_discriminant)\n+  {}\n+\n+  TyTy::VariantDef *variant;\n+  int64_t last_discriminant;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ENUMITEM"}, {"sha": "7f98c46081a9772b07a27eb692524ebe1dbd7a29", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=d18672f220ba9377d8f86fb228b7142e98b23a44", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-full.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -187,6 +188,58 @@ class TypeCheckStmt : public TypeCheckBase\n     infered = type;\n   }\n \n+  void visit (HIR::Enum &enum_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : enum_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::VariantDef *> variants;\n+    int64_t discriminant_value = 0;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tTyTy::VariantDef *field_type\n+\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+\tvariants.push_back (field_type);\n+\tif (field_type->get_variant_type ()\n+\t    == TyTy::VariantDef::VariantType::NUM)\n+\t  discriminant_value = field_type->get_discriminant ();\n+      }\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (enum_decl.get_mappings (), type);\n+    infered = type;\n+  }\n+\n   void visit (HIR::StructStruct &struct_decl) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;"}, {"sha": "98f037e169621f638ed7a23826e80e0bfbf9e9ed", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18672f220ba9377d8f86fb228b7142e98b23a44/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=d18672f220ba9377d8f86fb228b7142e98b23a44", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n #include \"rust-tyty.h\"\n \n namespace Rust {\n@@ -188,6 +189,57 @@ class TypeCheckTopLevel : public TypeCheckBase\n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n+  void visit (HIR::Enum &enum_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (enum_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : enum_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::VariantDef *> variants;\n+    int64_t discriminant_value = 0;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tTyTy::VariantDef *field_type\n+\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+\tvariants.push_back (field_type);\n+\tif (field_type->get_variant_type ()\n+\t    == TyTy::VariantDef::VariantType::NUM)\n+\t  discriminant_value = field_type->get_discriminant ();\n+      }\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   enum_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (enum_decl.get_mappings (), type);\n+  }\n+\n   void visit (HIR::Union &union_decl) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;"}]}