{"sha": "4801cc61b13b55b988c1bd808444cccd3663f033", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwMWNjNjFiMTNiNTViOTg4YzFiZDgwODQ0NGNjY2QzNjYzZjAzMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2018-09-09T21:32:08Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2018-09-09T21:32:08Z"}, "message": "i386.md (float partial SSE register stall splitter): Move splitter near its instruction pattern.\n\n\t* config/i386/i386.md (float partial SSE register stall splitter): Move\n\tsplitter near its instruction pattern.\n\t(float_extend partial SSE register stall splitter): Ditto.\n\t(float_truncate partial SSE register stall splitter): Ditto.\n\nFrom-SVN: r264185", "tree": {"sha": "c7d7ecf94a7567bc161a02e691123d4e05bd2405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7d7ecf94a7567bc161a02e691123d4e05bd2405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4801cc61b13b55b988c1bd808444cccd3663f033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4801cc61b13b55b988c1bd808444cccd3663f033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4801cc61b13b55b988c1bd808444cccd3663f033", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4801cc61b13b55b988c1bd808444cccd3663f033/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8eb7aec132e688debbb0e5ce484fd06c10dec623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eb7aec132e688debbb0e5ce484fd06c10dec623", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eb7aec132e688debbb0e5ce484fd06c10dec623"}], "stats": {"total": 223, "additions": 115, "deletions": 108}, "files": [{"sha": "6dbe8147b3ecbcba71b92a94c16d67e7a4adef4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4801cc61b13b55b988c1bd808444cccd3663f033/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4801cc61b13b55b988c1bd808444cccd3663f033/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4801cc61b13b55b988c1bd808444cccd3663f033", "patch": "@@ -1,3 +1,10 @@\n+2018-09-09  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (float partial SSE register stall splitter): Move\n+\tsplitter near its instruction pattern.\n+\t(float_extend partial SSE register stall splitter): Ditto.\n+\t(float_truncate partial SSE register stall splitter): Ditto.\n+\n 2018-09-09  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tPR target/86794"}, {"sha": "059ddbd6c9710489ac29bdf635c874aeda7a6691", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4801cc61b13b55b988c1bd808444cccd3663f033/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4801cc61b13b55b988c1bd808444cccd3663f033/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4801cc61b13b55b988c1bd808444cccd3663f033", "patch": "@@ -4477,6 +4477,40 @@\n     }\n })\n \n+(define_insn \"*extendsfdf2\"\n+  [(set (match_operand:DF 0 \"nonimm_ssenomem_operand\" \"=f,m,v\")\n+        (float_extend:DF\n+\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f,vm\")))]\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return output_387_reg_move (insn, operands);\n+\n+    case 2:\n+      return \"%vcvtss2sd\\t{%1, %d0|%d0, %1}\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fmov,fmov,ssecvt\")\n+   (set_attr \"prefix\" \"orig,orig,maybe_vex\")\n+   (set_attr \"mode\" \"SF,XF,DF\")\n+   (set (attr \"enabled\")\n+     (if_then_else\n+       (match_test (\"TARGET_SSE2 && TARGET_SSE_MATH\"))\n+       (if_then_else\n+\t (eq_attr \"alternative\" \"0,1\")\n+\t (symbol_ref \"TARGET_MIX_SSE_I387\")\n+\t (symbol_ref \"true\"))\n+       (if_then_else\n+\t (eq_attr \"alternative\" \"0,1\")\n+\t (symbol_ref \"true\")\n+\t (symbol_ref \"false\"))))])\n+\n /* For converting SF(xmm2) to DF(xmm1), use the following code instead of\n    cvtss2sd:\n       unpcklps xmm2,xmm2   ; packed conversion might crash on signaling NaNs\n@@ -4544,39 +4578,31 @@\n    (set (match_dup 0) (float_extend:DF (match_dup 2)))]\n   \"operands[2] = lowpart_subreg (SFmode, operands[0], DFmode);\")\n \n-(define_insn \"*extendsfdf2\"\n-  [(set (match_operand:DF 0 \"nonimm_ssenomem_operand\" \"=f,m,v\")\n+;; Break partial reg stall for cvtss2sd.  This splitter should split\n+;; late in the pass sequence (after register rename pass),\n+;; so allocated registers won't change anymore.\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"sse_reg_operand\")\n         (float_extend:DF\n-\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f,vm\")))]\n-  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+          (match_operand:SF 1 \"nonimmediate_operand\")))]\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && (!REG_P (operands[1])\n+       || REGNO (operands[0]) != REGNO (operands[1]))\n+   && (!EXT_REX_SSE_REG_P (operands[0])\n+       || TARGET_AVX512VL)\"\n+  [(set (match_dup 0)\n+        (vec_merge:V2DF\n+\t  (vec_duplicate:V2DF\n+\t    (float_extend:DF\n+\t      (match_dup 1)))\n+\t  (match_dup 0)\n+          (const_int 1)))]\n {\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return \"%vcvtss2sd\\t{%1, %d0|%d0, %1}\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,ssecvt\")\n-   (set_attr \"prefix\" \"orig,orig,maybe_vex\")\n-   (set_attr \"mode\" \"SF,XF,DF\")\n-   (set (attr \"enabled\")\n-     (if_then_else\n-       (match_test (\"TARGET_SSE2 && TARGET_SSE_MATH\"))\n-       (if_then_else\n-\t (eq_attr \"alternative\" \"0,1\")\n-\t (symbol_ref \"TARGET_MIX_SSE_I387\")\n-\t (symbol_ref \"true\"))\n-       (if_then_else\n-\t (eq_attr \"alternative\" \"0,1\")\n-\t (symbol_ref \"true\")\n-\t (symbol_ref \"false\"))))])\n+  operands[0] = lowpart_subreg (V2DFmode, operands[0], DFmode);\n+  emit_move_insn (operands[0], CONST0_RTX (V2DFmode));\n+})\n \n (define_expand \"extend<mode>xf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\")\n@@ -4710,6 +4736,32 @@\n    (set (match_dup 0) (float_truncate:SF (match_dup 2)))]\n   \"operands[2] = lowpart_subreg (DFmode, operands[0], SFmode);\")\n \n+;; Break partial reg stall for cvtsd2ss.  This splitter should split\n+;; late in the pass sequence (after register rename pass),\n+;; so allocated registers won't change anymore.\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"sse_reg_operand\")\n+        (float_truncate:SF\n+\t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && (!REG_P (operands[1])\n+       || REGNO (operands[0]) != REGNO (operands[1]))\n+   && (!EXT_REX_SSE_REG_P (operands[0])\n+       || TARGET_AVX512VL)\"\n+  [(set (match_dup 0)\n+\t(vec_merge:V4SF\n+\t  (vec_duplicate:V4SF\n+\t    (float_truncate:SF\n+\t      (match_dup 1)))\n+\t  (match_dup 0)\n+\t  (const_int 1)))]\n+{\n+  operands[0] = lowpart_subreg (V4SFmode, operands[0], SFmode);\n+  emit_move_insn (operands[0], CONST0_RTX (V4SFmode));\n+})\n+\n ;; Conversion from XFmode to {SF,DF}mode\n \n (define_insn \"truncxf<mode>2\"\n@@ -5152,83 +5204,6 @@\n   DONE;\n })\n \n-;; Avoid partial SSE register dependency stalls.  This splitter should split\n-;; late in the pass sequence (after register rename pass), so allocated\n-;; registers won't change anymore\n-\n-(define_split\n-  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n-   && optimize_function_for_speed_p (cfun)\n-   && (!EXT_REX_SSE_REG_P (operands[0])\n-       || TARGET_AVX512VL)\"\n-  [(set (match_dup 0)\n-\t(vec_merge:<MODEF:ssevecmode>\n-\t  (vec_duplicate:<MODEF:ssevecmode>\n-\t    (float:MODEF\n-\t      (match_dup 1)))\n-\t  (match_dup 0)\n-\t  (const_int 1)))]\n-{\n-  const machine_mode vmode = <MODEF:ssevecmode>mode;\n-\n-  operands[0] = lowpart_subreg (vmode, operands[0], <MODEF:MODE>mode);\n-  emit_move_insn (operands[0], CONST0_RTX (vmode));\n-})\n-\n-;; Break partial reg stall for cvtsd2ss.  This splitter should split\n-;; late in the pass sequence (after register rename pass),\n-;; so allocated registers won't change anymore.\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"sse_reg_operand\")\n-        (float_truncate:SF\n-\t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n-   && optimize_function_for_speed_p (cfun)\n-   && (!REG_P (operands[1])\n-       || REGNO (operands[0]) != REGNO (operands[1]))\n-   && (!EXT_REX_SSE_REG_P (operands[0])\n-       || TARGET_AVX512VL)\"\n-  [(set (match_dup 0)\n-\t(vec_merge:V4SF\n-\t  (vec_duplicate:V4SF\n-\t    (float_truncate:SF\n-\t      (match_dup 1)))\n-\t  (match_dup 0)\n-\t  (const_int 1)))]\n-{\n-  operands[0] = lowpart_subreg (V4SFmode, operands[0], SFmode);\n-  emit_move_insn (operands[0], CONST0_RTX (V4SFmode));\n-})\n-\n-;; Break partial reg stall for cvtss2sd.  This splitter should split\n-;; late in the pass sequence (after register rename pass),\n-;; so allocated registers won't change anymore.\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"sse_reg_operand\")\n-        (float_extend:DF\n-          (match_operand:SF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n-   && optimize_function_for_speed_p (cfun)\n-   && (!REG_P (operands[1])\n-       || REGNO (operands[0]) != REGNO (operands[1]))\n-   && (!EXT_REX_SSE_REG_P (operands[0])\n-       || TARGET_AVX512VL)\"\n-  [(set (match_dup 0)\n-        (vec_merge:V2DF\n-\t  (vec_duplicate:V2DF\n-\t    (float_extend:DF\n-\t      (match_dup 1)))\n-\t  (match_dup 0)\n-          (const_int 1)))]\n-{\n-  operands[0] = lowpart_subreg (V2DFmode, operands[0], DFmode);\n-  emit_move_insn (operands[0], CONST0_RTX (V2DFmode));\n-})\n-\n ;; Avoid store forwarding (partial memory) stall penalty\n ;; by passing DImode value through XMM registers.  */\n \n@@ -5279,6 +5254,31 @@\n    (set_attr \"unit\" \"i387\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+;; Avoid partial SSE register dependency stalls.  This splitter should split\n+;; late in the pass sequence (after register rename pass), so allocated\n+;; registers won't change anymore\n+\n+(define_split\n+  [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n+\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n+  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && (!EXT_REX_SSE_REG_P (operands[0])\n+       || TARGET_AVX512VL)\"\n+  [(set (match_dup 0)\n+\t(vec_merge:<MODEF:ssevecmode>\n+\t  (vec_duplicate:<MODEF:ssevecmode>\n+\t    (float:MODEF\n+\t      (match_dup 1)))\n+\t  (match_dup 0)\n+\t  (const_int 1)))]\n+{\n+  const machine_mode vmode = <MODEF:ssevecmode>mode;\n+\n+  operands[0] = lowpart_subreg (vmode, operands[0], <MODEF:MODE>mode);\n+  emit_move_insn (operands[0], CONST0_RTX (vmode));\n+})\n+\n (define_expand \"floatuns<SWI12:mode><MODEF:mode>2\"\n   [(set (match_operand:MODEF 0 \"register_operand\")\n \t(unsigned_float:MODEF"}]}