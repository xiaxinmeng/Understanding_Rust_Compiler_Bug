{"sha": "d38ffc55428bbe33b33d8b14693e69cd1b63c820", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4ZmZjNTU0MjhiYmUzM2IzM2Q4YjE0NjkzZTY5Y2QxYjYzYzgyMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-03-04T21:35:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-03-04T21:35:49Z"}, "message": "basic-block.h (rediscover_loops_after_threading): Declare.\n\n   * basic-block.h (rediscover_loops_after_threading): Declare.\n        * tree-ssa-dom.c: Include cfgloop.h.\n        (tree_ssa_dominator_optimize): Discover loops and some basic\n        properties.  Remove forwarder blocks recreated by loop header\n        canonicalization.  Also mark backedges in the CFG.\n        * tree-ssa-threadupdate.c: Include cfgloop.h\n        (rediscover_loops_after_threading): Define.\n        (struct local_info): New field, JUMP_THREADED.\n        (prune_undesirable_thread_requests): New function.\n        (redirect_edges): Clear EDGE_ABNORMAL.  If edges were threaded\n        then record that fact for the callers of redirct_edges.\n        (thread_block): If BB has incoming backedges, then call\n        prune_undesirable_thraed_requests.    Note when we are\n        going to have to rediscover loop information.  Return a\n        boolean indicating if any jumps were threaded.\n        (thread_through_all_blocks): Bubble up boolean indicating\n        if any jumps were threaded.\n        * Makefile.in (tree-ssa-dom.o): Depend on cfgloop.h\n        (tree-ssa-threadupdate.o): Similarly.\n\nFrom-SVN: r95903", "tree": {"sha": "f9c9a2643a9f3afe1404b5aff6758d8e8da39b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9c9a2643a9f3afe1404b5aff6758d8e8da39b9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d38ffc55428bbe33b33d8b14693e69cd1b63c820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38ffc55428bbe33b33d8b14693e69cd1b63c820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38ffc55428bbe33b33d8b14693e69cd1b63c820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38ffc55428bbe33b33d8b14693e69cd1b63c820/comments", "author": null, "committer": null, "parents": [{"sha": "3852e8b8f21397fc719ef45ba404a58bed53a7d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3852e8b8f21397fc719ef45ba404a58bed53a7d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3852e8b8f21397fc719ef45ba404a58bed53a7d0"}], "stats": {"total": 324, "additions": 317, "deletions": 7}, "files": [{"sha": "6ce3ca2bde5fef8a8a2d86aef46b201bc251f8ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d38ffc55428bbe33b33d8b14693e69cd1b63c820", "patch": "@@ -1,3 +1,25 @@\n+2005-03-04  Jeff Law  <law@redhat.com>\n+\n+\t* basic-block.h (rediscover_loops_after_threading): Declare.\n+\t* tree-ssa-dom.c: Include cfgloop.h.\n+\t(tree_ssa_dominator_optimize): Discover loops and some basic\n+\tproperties.  Remove forwarder blocks recreated by loop header\n+\tcanonicalization.  Also mark backedges in the CFG.\n+\t* tree-ssa-threadupdate.c: Include cfgloop.h\n+\t(rediscover_loops_after_threading): Define.\n+\t(struct local_info): New field, JUMP_THREADED.\n+\t(prune_undesirable_thread_requests): New function.\n+\t(redirect_edges): Clear EDGE_ABNORMAL.  If edges were threaded\n+\tthen record that fact for the callers of redirct_edges.\n+\t(thread_block): If BB has incoming backedges, then call\n+\tprune_undesirable_thraed_requests.    Note when we are\n+\tgoing to have to rediscover loop information.  Return a\n+\tboolean indicating if any jumps were threaded.\n+\t(thread_through_all_blocks): Bubble up boolean indicating\n+\tif any jumps were threaded.\n+\t* Makefile.in (tree-ssa-dom.o): Depend on cfgloop.h\n+\t(tree-ssa-threadupdate.o): Similarly.\n+\n 2005-03-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (fold_ternary): Unroll the \"for\" loop to"}, {"sha": "273808dd54398de0c3b63778be48135f20b345eb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d38ffc55428bbe33b33d8b14693e69cd1b63c820", "patch": "@@ -1638,11 +1638,11 @@ tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h \\\n-   tree-ssa-propagate.h\n+   tree-ssa-propagate.h cfgloop.h\n tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    diagnostic.h errors.h function.h $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   $(BASIC_BLOCK_H) $(FLAGS_H)  tree-pass.h\n+   $(BASIC_BLOCK_H) $(FLAGS_H)  tree-pass.h cfgloop.h\n tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) varray.h $(GGC_H) gt-tree-ssanames.h  $(TREE_FLOW_H)\n tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "92334a39e84bb5a7d3fcebd2cfe2e2e993fecfd0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d38ffc55428bbe33b33d8b14693e69cd1b63c820", "patch": "@@ -352,6 +352,10 @@ extern int last_basic_block;\n \n extern int n_edges;\n \n+/* TRUE if we should re-run loop discovery after threading jumps, FALSE\n+   otherwise.  */\n+extern bool rediscover_loops_after_threading;\n+\n /* Signalize the status of profile information in the CFG.  */\n extern enum profile_status\n {"}, {"sha": "a14356500aa83b9e0f46e774d709b2f228882a60", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d38ffc55428bbe33b33d8b14693e69cd1b63c820", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n+#include \"cfgloop.h\"\n #include \"output.h\"\n #include \"errors.h\"\n #include \"expr.h\"\n@@ -368,6 +369,7 @@ tree_ssa_dominator_optimize (void)\n {\n   struct dom_walk_data walk_data;\n   unsigned int i;\n+  struct loops loops_info;\n \n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n@@ -407,6 +409,17 @@ tree_ssa_dominator_optimize (void)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n+  /* We need to know which edges exit loops so that we can\n+     aggressively thread through loop headers to an exit\n+     edge.  */\n+  flow_loops_find (&loops_info);\n+  mark_loop_exit_edges (&loops_info);\n+  flow_loops_free (&loops_info);\n+\n+  /* Clean up the CFG so that any forwarder blocks created by loop\n+     canonicalization are removed.  */\n+  cleanup_tree_cfg ();\n+\n   /* If we prove certain blocks are unreachable, then we want to\n      repeat the dominator optimization process as PHI nodes may\n      have turned into copies which allows better propagation of\n@@ -417,6 +430,10 @@ tree_ssa_dominator_optimize (void)\n       /* Optimize the dominator tree.  */\n       cfg_altered = false;\n \n+      /* We need accurate information regarding back edges in the CFG\n+\t for jump threading.  */\n+      mark_dfs_back_edges ();\n+\n       /* Recursively walk the dominator tree optimizing statements.  */\n       walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n \n@@ -445,8 +462,24 @@ tree_ssa_dominator_optimize (void)\n \t}\n \n       if (cfg_altered)\n-\tfree_dominance_info (CDI_DOMINATORS);\n+        free_dominance_info (CDI_DOMINATORS);\n+\n       cfg_altered |= cleanup_tree_cfg ();\n+\n+      if (rediscover_loops_after_threading)\n+\t{\n+\t  /* Rerun basic loop analysis to discover any newly\n+\t     created loops and update the set of exit edges.  */\n+\t  rediscover_loops_after_threading = false;\n+\t  flow_loops_find (&loops_info);\n+\t  mark_loop_exit_edges (&loops_info);\n+\t  flow_loops_free (&loops_info);\n+\n+\t  /* Remove any forwarder blocks inserted by loop\n+\t     header canonicalization.  */\n+\t  cleanup_tree_cfg ();\n+\t}\n+\n       calculate_dominance_info (CDI_DOMINATORS);\n \n       rewrite_ssa_into_ssa ();"}, {"sha": "d798713a43938dfc08d4f00ce689ecb98a0d27f3", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 255, "deletions": 4, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38ffc55428bbe33b33d8b14693e69cd1b63c820/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=d38ffc55428bbe33b33d8b14693e69cd1b63c820", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-flow.h\"\n #include \"tree-dump.h\"\n #include \"tree-pass.h\"\n+#include \"cfgloop.h\"\n \n /* Given a block B, update the CFG and SSA graph to reflect redirecting\n    one or more in-edges to B to instead reach the destination of an\n@@ -131,6 +132,8 @@ struct redirection_data\n /* Main data structure to hold information for duplicates of BB.  */\n static htab_t redirection_data;\n \n+bool rediscover_loops_after_threading;\n+\n /* Data structure of information to pass to hash table traversal routines.  */\n struct local_info\n {\n@@ -140,6 +143,9 @@ struct local_info\n   /* A template copy of BB with no outgoing edges or control statement that\n      we use for creating copies.  */\n   basic_block template_block;\n+\n+  /* TRUE if we thread one or more jumps, FALSE otherwise.  */\n+  bool jumps_threaded;\n };\n \n /* Remove the last statement in block BB if it is a control statement\n@@ -361,6 +367,199 @@ fixup_template_block (void **slot, void *data)\n   return 1;\n }\n \n+/* Not all jump threading requests are useful.  In particular some\n+   jump threading requests can create irreducible regions which are\n+   undesirable.\n+\n+   This routine will examine the BB's incoming edges for jump threading\n+   requests which, if acted upon, would create irreducible regions.  Any\n+   such jump threading requests found will be pruned away.  */\n+\n+static void\n+prune_undesirable_thread_requests (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool may_create_irreducible_region = false;\n+  unsigned int num_outgoing_edges_into_loop = 0;\n+\n+  /* For the heuristics below, we need to know if BB has more than\n+     one outgoing edge into a loop.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    num_outgoing_edges_into_loop += ((e->flags & EDGE_LOOP_EXIT) == 0);\n+\n+  if (num_outgoing_edges_into_loop > 1)\n+    {\n+      edge backedge = NULL;\n+\n+      /* Consider the effect of threading the edge (0, 1) to 2 on the left\n+\t CFG to produce the right CFG:\n+    \n+\n+             0            0\n+             |            |\n+             1<--+        2<--------+\n+            / \\  |        |         |\n+           2   3 |        4<----+   |\n+            \\ /  |       / \\    |   |\n+             4---+      E   1-- | --+\n+             |              |   |\n+             E              3---+\n+\n+\n+ \tThreading the (0, 1) edge to 2 effectively creates two loops\n+ \t(2, 4, 1) and (4, 1, 3) which are neither disjoint nor nested.\n+\tThis is not good.\n+\n+\tHowever, we do need to be able to thread  (0, 1) to 2 or 3\n+\tin the left CFG below (which creates the middle and right\n+\tCFGs with nested loops).\n+\n+             0          0             0\n+             |          |             |\n+             1<--+      2<----+       3<-+<-+\n+            /|   |      |     |       |  |  |\n+           2 |   |      3<-+  |       1--+  |\n+            \\|   |      |  |  |       |     |\n+             3---+      1--+--+       2-----+\n+\n+\t \n+\t A safe heuristic appears to be to only allow threading if BB\n+\t has a single incoming backedge from one of its direct successors.  */\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (e->flags & EDGE_DFS_BACK)\n+\t    {\n+\t      if (backedge)\n+\t\t{\n+\t\t  backedge = NULL;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  backedge = e;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (backedge && find_edge (bb, backedge->src))\n+\t;\n+      else\n+        may_create_irreducible_region = true;\n+    }\n+  else\n+    {\n+      edge dest = NULL;\n+\n+      /* If we thread across the loop entry block (BB) into the\n+\t loop and BB is still reached from outside the loop, then\n+\t we would create an irreducible CFG.  Consider the effect\n+\t of threading the edge (1, 4) to 5 on the left CFG to produce\n+\t the right CFG\n+\n+             0               0\n+            / \\             / \\\n+           1   2           1   2\n+            \\ /            |   |\n+             4<----+       5<->4\n+            / \\    |           |\n+           E   5---+           E\n+\n+\n+\t Threading the (1, 4) edge to 5 creates two entry points\n+\t into the loop (4, 5) (one from block 1, the other from\n+\t block 2).  A classic irreducible region. \n+\n+\t So look at all of BB's incoming edges which are not\n+\t backedges and which are not threaded to the loop exit.\n+\t If that subset of incoming edges do not all thread\n+\t to the same block, then threading any of them will create\n+\t an irreducible region.  */\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  edge e2;\n+\n+\t  /* We ignore back edges for now.  This may need refinement\n+    \t     as threading a backedge creates an inner loop which\n+\t     we would need to verify has a single entry point. \n+\n+\t     If all backedges thread to new locations, then this\n+\t     block will no longer have incoming backedges and we\n+\t     need not worry about creating irreducible regions\n+\t     by threading through BB.  I don't think this happens\n+\t     enough in practice to worry about it.  */\n+\t  if (e->flags & EDGE_DFS_BACK)\n+\t    continue;\n+\n+\t  /* If the incoming edge threads to the loop exit, then it\n+\t     is clearly safe.  */\n+\t  e2 = e->aux;\n+\t  if (e2 && (e2->flags & EDGE_LOOP_EXIT))\n+\t    continue;\n+\n+\t  /* E enters the loop header and is not threaded.  We can\n+\t     not allow any other incoming edges to thread into\n+\t     the loop as that would create an irreducible region.  */\n+\t  if (!e2)\n+\t    {\n+\t      may_create_irreducible_region = true;\n+\t      break;\n+\t    }\n+\n+\t  /* We know that this incoming edge threads to a block inside\n+\t     the loop.  This edge must thread to the same target in\n+\t     the loop as any previously seen threaded edges.  Otherwise\n+\t     we will create an irreducible region.  */\n+\t  if (!dest)\n+\t    dest = e2;\n+\t  else if (e2 != dest)\n+\t    {\n+\t      may_create_irreducible_region = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* If we might create an irreducible region, then cancel any of\n+     the jump threading requests for incoming edges which are\n+     not backedges and which do not thread to the exit block.  */\n+  if (may_create_irreducible_region)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  edge e2;\n+\n+\t  /* Ignore back edges.  */\n+\t  if (e->flags & EDGE_DFS_BACK)\n+\t    continue;\n+\n+\t  e2 = e->aux;\n+\n+\t  /* If this incoming edge was not threaded, then there is\n+\t     nothing to do.  */\n+\t  if (!e2)\n+\t    continue;\n+\n+\t  /* If this incoming edge threaded to the loop exit,\n+\t     then it can be ignored as it is safe.  */\n+\t  if (e2->flags & EDGE_LOOP_EXIT)\n+\t    continue;\n+\n+\t  if (e2)\n+\t    {\n+\t      /* This edge threaded into the loop and the jump thread\n+\t\t request must be cancelled.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Not threading jump %d --> %d to %d\\n\",\n+\t\t\t e->src->index, e->dest->index, e2->dest->index);\n+\t      e->aux = NULL;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Hash table traversal callback to redirect each incoming edge\n    associated with this hash table element to its new destination.  */\n \n@@ -417,10 +616,15 @@ redirect_edges (void **slot, void *data)\n \n \t  /* And fixup the flags on the single remaining edge.  */\n \t  EDGE_SUCC (local_info->bb, 0)->flags\n-\t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n \t  EDGE_SUCC (local_info->bb, 0)->flags |= EDGE_FALLTHRU;\n \t}\n     }\n+\n+  /* Indicate that we actually threaded one or more jumps.  */\n+  if (rd->incoming_edges)\n+    local_info->jumps_threaded = true;\n+\n   return 1;\n }\n \n@@ -453,7 +657,7 @@ redirect_edges (void **slot, void *data)\n    per block with incoming threaded edges, which can lower the\n    cost of the true incremental update algorithm.  */\n \n-static void\n+static bool\n thread_block (basic_block bb)\n {\n   /* E is an incoming edge into BB that we may or may not want to\n@@ -462,6 +666,11 @@ thread_block (basic_block bb)\n   edge_iterator ei;\n   struct local_info local_info;\n \n+  /* FOUND_BACKEDGE indicates that we found an incoming backedge\n+     into BB, in which case we may ignore certain jump threads\n+     to avoid creating irreducible regions.  */\n+  bool found_backedge = false;\n+\n   /* ALL indicates whether or not all incoming edges into BB should\n      be threaded to a duplicate of BB.  */\n   bool all = true;\n@@ -475,6 +684,17 @@ thread_block (basic_block bb)\n \t\t\t\t  redirection_data_eq,\n \t\t\t\t  free);\n \n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    found_backedge |= ((e->flags & EDGE_DFS_BACK) != 0);\n+\n+  /* If BB has incoming backedges, then threading across BB might\n+     introduce an irreducible region, which would be undesirable\n+     as that inhibits various optimizations later.  Prune away\n+     any jump threading requests which we know will result in\n+     an irreducible region.  */\n+  if (found_backedge)\n+    prune_undesirable_thread_requests (bb);\n+\n   /* Record each unique threaded destination into a hash table for\n      efficient lookups.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -487,6 +707,30 @@ thread_block (basic_block bb)\n \t{\n \t  edge e2 = e->aux;\n \n+\t  /* If we thread to a loop exit edge, then we will need to \n+\t     rediscover the loop exit edges.  While it may seem that\n+\t     the new edge is a loop exit edge, that is not the case.\n+\t     Consider threading the edge (5,6) to E in the CFG on the\n+\t     left which creates the CFG on the right:\n+\n+\n+                      0<--+            0<---+\n+                     / \\  |           / \\   |\n+                    1   2 |          1   2  |\n+                   / \\  | |         / \\  |  |\n+                  3   4 | |        3   4 6--+\n+                   \\ /  | |         \\ /\n+                    5   | |          5\n+                     \\ /  |          |\n+                      6---+          E\n+                      |\n+                      E\n+\n+\t     After threading, the edge (0, 1)  is the loop exit edge and\n+\t     the nodes 0, 2, 6 are the only nodes in the loop.  */\n+\t  if (e2->flags & EDGE_LOOP_EXIT)\n+\t    rediscover_loops_after_threading = true;\n+\n \t  /* Insert the outgoing edge into the hash table if it is not\n \t     already in the hash table.  */\n \t  lookup_redirection_data (e2, e, true);\n@@ -514,6 +758,7 @@ thread_block (basic_block bb)\n      the rest of the duplicates.  */\n   local_info.template_block = NULL;\n   local_info.bb = bb;\n+  local_info.jumps_threaded = false;\n   htab_traverse (redirection_data, create_duplicates, &local_info);\n \n   /* The template does not have an outgoing edge.  Create that outgoing\n@@ -532,6 +777,9 @@ thread_block (basic_block bb)\n   /* Done with this block.  Clear REDIRECTION_DATA.  */\n   htab_delete (redirection_data);\n   redirection_data = NULL;\n+\n+  /* Indicate to our caller whether or not any jumps were threaded.  */\n+  return local_info.jumps_threaded;\n }\n \n /* Walk through all blocks and thread incoming edges to the block's\n@@ -558,14 +806,17 @@ thread_through_all_blocks (void)\n   basic_block bb;\n   bool retval = false;\n \n+  rediscover_loops_after_threading = false;\n+\n   FOR_EACH_BB (bb)\n     {\n       if (bb_ann (bb)->incoming_edge_threaded)\n \t{\n-\t  thread_block (bb);\n-\t  retval = true;\n+\t  retval |= thread_block (bb);\n \t  bb_ann (bb)->incoming_edge_threaded = false;\n+\t  \n \t}\n     }\n+\n   return retval;\n }"}]}