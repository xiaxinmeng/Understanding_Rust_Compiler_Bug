{"sha": "08a680a8879ce9da16d808644730f7cfacaf667f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhNjgwYTg4NzljZTlkYTE2ZDgwODY0NDczMGY3Y2ZhY2FmNjY3Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-06-25T16:20:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-06-25T16:20:03Z"}, "message": "libgo: Update to Go 1.0.2 release.\n\nFrom-SVN: r188943", "tree": {"sha": "5dfe28c3f573ae57b971ed4d9a1c99a76f0a70c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dfe28c3f573ae57b971ed4d9a1c99a76f0a70c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08a680a8879ce9da16d808644730f7cfacaf667f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a680a8879ce9da16d808644730f7cfacaf667f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a680a8879ce9da16d808644730f7cfacaf667f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a680a8879ce9da16d808644730f7cfacaf667f/comments", "author": null, "committer": null, "parents": [{"sha": "72de8622ae2d5aaeb58173f454aed87640a989b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72de8622ae2d5aaeb58173f454aed87640a989b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72de8622ae2d5aaeb58173f454aed87640a989b5"}], "stats": {"total": 1257, "additions": 1088, "deletions": 169}, "files": [{"sha": "e3e47d3bd1eb37baea9ceb0d40d5df20a5d7f4e8", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -1,4 +1,4 @@\n-2ccfd4b451d3\n+5e806355a9e1\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "e511b50fd1b079066382eaf59b5de29c53a978e8", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -32,6 +32,7 @@ const (\n \thashSize            = 1 << hashBits\n \thashMask            = (1 << hashBits) - 1\n \thashShift           = (hashBits + minMatchLength - 1) / minMatchLength\n+\tmaxHashOffset       = 1 << 24\n \n \tskipNever = math.MaxInt32\n )\n@@ -106,6 +107,25 @@ func (d *compressor) fillDeflate(b []byte) int {\n \t\t\td.blockStart = math.MaxInt32\n \t\t}\n \t\td.hashOffset += windowSize\n+\t\tif d.hashOffset > maxHashOffset {\n+\t\t\tdelta := d.hashOffset - 1\n+\t\t\td.hashOffset -= delta\n+\t\t\td.chainHead -= delta\n+\t\t\tfor i, v := range d.hashPrev {\n+\t\t\t\tif v > delta {\n+\t\t\t\t\td.hashPrev[i] -= delta\n+\t\t\t\t} else {\n+\t\t\t\t\td.hashPrev[i] = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor i, v := range d.hashHead {\n+\t\t\t\tif v > delta {\n+\t\t\t\t\td.hashHead[i] -= delta\n+\t\t\t\t} else {\n+\t\t\t\t\td.hashHead[i] = 0\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \tn := copy(d.window[d.windowEnd:], b)\n \td.windowEnd += n"}, {"sha": "f1e6db2ace4f19bab5058306e39f040fdddab2d9", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -94,6 +94,50 @@ func TestDeflate(t *testing.T) {\n \t}\n }\n \n+// A sparseReader returns a stream consisting of 0s followed by 1<<16 1s.\n+// This tests missing hash references in a very large input.\n+type sparseReader struct {\n+\tl   int64\n+\tcur int64\n+}\n+\n+func (r *sparseReader) Read(b []byte) (n int, err error) {\n+\tif r.cur >= r.l {\n+\t\treturn 0, io.EOF\n+\t}\n+\tn = len(b)\n+\tcur := r.cur + int64(n)\n+\tif cur > r.l {\n+\t\tn -= int(cur - r.l)\n+\t\tcur = r.l\n+\t}\n+\tfor i := range b[0:n] {\n+\t\tif r.cur+int64(i) >= r.l-1<<16 {\n+\t\t\tb[i] = 1\n+\t\t} else {\n+\t\t\tb[i] = 0\n+\t\t}\n+\t}\n+\tr.cur = cur\n+\treturn\n+}\n+\n+func TestVeryLongSparseChunk(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Logf(\"skipping sparse chunk during short test\")\n+\t\treturn\n+\t}\n+\tw, err := NewWriter(ioutil.Discard, 1)\n+\tif err != nil {\n+\t\tt.Errorf(\"NewWriter: %v\", err)\n+\t\treturn\n+\t}\n+\tif _, err = io.Copy(w, &sparseReader{l: 23E8}); err != nil {\n+\t\tt.Errorf(\"Compress failed: %v\", err)\n+\t\treturn\n+\t}\n+}\n+\n type syncBuffer struct {\n \tbuf    bytes.Buffer\n \tmu     sync.RWMutex"}, {"sha": "aee73a7c52c75eb2f6d2c1e451c3905949debfd1", "filename": "libgo/go/crypto/aes/const.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -11,11 +11,11 @@ package aes\n // http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n \n // AES is based on the mathematical behavior of binary polynomials\n-// (polynomials over GF(2)) modulo the irreducible polynomial x\u2078 + x\u2074 + x\u00b2 + x + 1.\n+// (polynomials over GF(2)) modulo the irreducible polynomial x\u2078 + x\u2074 + x\u00b3 + x + 1.\n // Addition of these binary polynomials corresponds to binary xor.\n // Reducing mod poly corresponds to binary xor with poly every\n // time a 0x100 bit appears.\n-const poly = 1<<8 | 1<<4 | 1<<3 | 1<<1 | 1<<0 // x\u2078 + x\u2074 + x\u00b2 + x + 1\n+const poly = 1<<8 | 1<<4 | 1<<3 | 1<<1 | 1<<0 // x\u2078 + x\u2074 + x\u00b3 + x + 1\n \n // Powers of x mod poly in GF(2).\n var powx = [16]byte{"}, {"sha": "8508e3b4f8da113771a725f9ed8249144a5a333d", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -66,7 +66,9 @@ func GenerateKey(c elliptic.Curve, rand io.Reader) (priv *PrivateKey, err error)\n // hashToInt converts a hash value to an integer. There is some disagreement\n // about how this is done. [NSA] suggests that this is done in the obvious\n // manner, but [SECG] truncates the hash to the bit-length of the curve order\n-// first. We follow [SECG] because that's what OpenSSL does.\n+// first. We follow [SECG] because that's what OpenSSL does. Additionally,\n+// OpenSSL right shifts excess bits from the number if the hash is too large\n+// and we mirror that too.\n func hashToInt(hash []byte, c elliptic.Curve) *big.Int {\n \torderBits := c.Params().N.BitLen()\n \torderBytes := (orderBits + 7) / 8\n@@ -75,7 +77,7 @@ func hashToInt(hash []byte, c elliptic.Curve) *big.Int {\n \t}\n \n \tret := new(big.Int).SetBytes(hash)\n-\texcess := orderBytes*8 - orderBits\n+\texcess := len(hash)*8 - orderBits\n \tif excess > 0 {\n \t\tret.Rsh(ret, uint(excess))\n \t}"}, {"sha": "a32236e4729e58a42e21d265333210ddfa94dd2b", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -151,6 +151,7 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err error) {\n var hashPrefixes = map[crypto.Hash][]byte{\n \tcrypto.MD5:       {0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n \tcrypto.SHA1:      {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n+\tcrypto.SHA224:    {0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c},\n \tcrypto.SHA256:    {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n \tcrypto.SHA384:    {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n \tcrypto.SHA512:    {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},"}, {"sha": "54c7a3e6316bcec5a2720d9a1e0189577e689485", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -563,7 +563,7 @@ func (m *certificateMsg) unmarshal(data []byte) bool {\n \t\tif len(d) < 4 {\n \t\t\treturn false\n \t\t}\n-\t\tcertLen := uint32(d[0])<<24 | uint32(d[1])<<8 | uint32(d[2])\n+\t\tcertLen := uint32(d[0])<<16 | uint32(d[1])<<8 | uint32(d[2])\n \t\tif uint32(len(d)) < 3+certLen {\n \t\t\treturn false\n \t\t}\n@@ -575,7 +575,7 @@ func (m *certificateMsg) unmarshal(data []byte) bool {\n \tm.certificates = make([][]byte, numCerts)\n \td = data[7:]\n \tfor i := 0; i < numCerts; i++ {\n-\t\tcertLen := uint32(d[0])<<24 | uint32(d[1])<<8 | uint32(d[2])\n+\t\tcertLen := uint32(d[0])<<16 | uint32(d[1])<<8 | uint32(d[2])\n \t\tm.certificates[i] = d[3 : 3+certLen]\n \t\td = d[3+certLen:]\n \t}"}, {"sha": "c4d85e67f0c28667229388c19a061fe0540367b8", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -388,10 +388,10 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\treturn ErrUnsupportedAlgorithm\n \t}\n \n-\th := hashType.New()\n-\tif h == nil {\n+\tif !hashType.Available() {\n \t\treturn ErrUnsupportedAlgorithm\n \t}\n+\th := hashType.New()\n \n \th.Write(signed)\n \tdigest := h.Sum(nil)"}, {"sha": "ade704335d14b843ec67b3d2b151f1bbb687f968", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -7,14 +7,19 @@ package gosym\n import (\n \t\"debug/elf\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n )\n \n-var pclinetestBinary string\n+var (\n+\tpclineTempDir    string\n+\tpclinetestBinary string\n+)\n \n func dotest() bool {\n \t// For now, only works on ELF platforms.\n@@ -24,10 +29,18 @@ func dotest() bool {\n \tif pclinetestBinary != \"\" {\n \t\treturn true\n \t}\n+\tvar err error\n+\tpclineTempDir, err = ioutil.TempDir(\"\", \"pclinetest\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif strings.Contains(pclineTempDir, \" \") {\n+\t\tpanic(\"unexpected space in tempdir\")\n+\t}\n \t// This command builds pclinetest from pclinetest.asm;\n \t// the resulting binary looks like it was built from pclinetest.s,\n \t// but we have renamed it to keep it away from the go tool.\n-\tpclinetestBinary = os.TempDir() + \"/pclinetest\"\n+\tpclinetestBinary = filepath.Join(pclineTempDir, \"pclinetest\")\n \tcommand := fmt.Sprintf(\"go tool 6a -o %s.6 pclinetest.asm && go tool 6l -E main -o %s %s.6\",\n \t\tpclinetestBinary, pclinetestBinary, pclinetestBinary)\n \tcmd := exec.Command(\"sh\", \"-c\", command)\n@@ -170,6 +183,7 @@ func TestPCLine(t *testing.T) {\n \tif !dotest() {\n \t\treturn\n \t}\n+\tdefer os.RemoveAll(pclineTempDir)\n \n \tf, tab := crack(pclinetestBinary, t)\n \ttext := f.Section(\".text\")"}, {"sha": "0b842f066105d14ed3a724af215e970bb540ea84", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -318,7 +318,7 @@ func (d *decoder) Read(p []byte) (n int, err error) {\n \t}\n \tnn, d.err = io.ReadAtLeast(d.r, d.buf[d.nbuf:nn], 4-d.nbuf)\n \td.nbuf += nn\n-\tif d.nbuf < 4 {\n+\tif d.err != nil || d.nbuf < 4 {\n \t\treturn 0, d.err\n \t}\n "}, {"sha": "f9b863c364c90a75033f388b648b809f5c40ff32", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -6,9 +6,11 @@ package base64\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type testpair struct {\n@@ -226,3 +228,50 @@ func TestNewLineCharacters(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type nextRead struct {\n+\tn   int   // bytes to return\n+\terr error // error to return\n+}\n+\n+// faultInjectReader returns data from source, rate-limited\n+// and with the errors as written to nextc.\n+type faultInjectReader struct {\n+\tsource string\n+\tnextc  <-chan nextRead\n+}\n+\n+func (r *faultInjectReader) Read(p []byte) (int, error) {\n+\tnr := <-r.nextc\n+\tif len(p) > nr.n {\n+\t\tp = p[:nr.n]\n+\t}\n+\tn := copy(p, r.source)\n+\tr.source = r.source[n:]\n+\treturn n, nr.err\n+}\n+\n+// tests that we don't ignore errors from our underlying reader\n+func TestDecoderIssue3577(t *testing.T) {\n+\tnext := make(chan nextRead, 10)\n+\twantErr := errors.New(\"my error\")\n+\tnext <- nextRead{5, nil}\n+\tnext <- nextRead{10, wantErr}\n+\td := NewDecoder(StdEncoding, &faultInjectReader{\n+\t\tsource: \"VHdhcyBicmlsbGlnLCBhbmQgdGhlIHNsaXRoeSB0b3Zlcw==\", // twas brillig...\n+\t\tnextc:  next,\n+\t})\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\t_, err := ioutil.ReadAll(d)\n+\t\terrc <- err\n+\t}()\n+\tselect {\n+\tcase err := <-errc:\n+\t\tif err != wantErr {\n+\t\t\tt.Errorf(\"got error %v; want %v\", err, wantErr)\n+\t\t}\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Errorf(\"timeout; Decoder blocked without returning an error\")\n+\t}\n+}"}, {"sha": "821d9a3fe8ef1a9890836942758c0c5b675fb3cb", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -116,7 +116,7 @@ uninterpreted bytes of the value.\n All other slices and arrays are sent as an unsigned count followed by that many\n elements using the standard gob encoding for their type, recursively.\n \n-Maps are sent as an unsigned count followed by that man key, element\n+Maps are sent as an unsigned count followed by that many key, element\n pairs. Empty but non-nil maps are sent, so if the sender has allocated\n a map, the receiver will allocate a map even no elements are\n transmitted."}, {"sha": "d61f8870646cb32c58e430af9eed3e96aa965553", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -273,9 +273,14 @@ func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler,\n \t\t\t_, isUnmarshaler = v.Interface().(Unmarshaler)\n \t\t}\n \n+\t\t// Load value from interface, but only if the result will be\n+\t\t// usefully addressable.\n \t\tif iv := v; iv.Kind() == reflect.Interface && !iv.IsNil() {\n-\t\t\tv = iv.Elem()\n-\t\t\tcontinue\n+\t\t\te := iv.Elem()\n+\t\t\tif e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {\n+\t\t\t\tv = e\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n \n \t\tpv := v\n@@ -588,6 +593,11 @@ func (d *decodeState) literal(v reflect.Value) {\n // produce more helpful error messages.\n func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {\n \t// Check for unmarshaler.\n+\tif len(item) == 0 {\n+\t\t//Empty string given\n+\t\td.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\treturn\n+\t}\n \twantptr := item[0] == 'n' // null\n \tunmarshaler, pv := d.indirect(v, wantptr)\n \tif unmarshaler != nil {"}, {"sha": "6fac22c4a35747fc1ee2ffb5aec4853a726cbcad", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -638,3 +638,68 @@ func TestAnonymous(t *testing.T) {\n \t\tt.Fatal(\"Unmarshal: did set T.Y\")\n \t}\n }\n+\n+// Test that the empty string doesn't panic decoding when ,string is specified\n+// Issue 3450\n+func TestEmptyString(t *testing.T) {\n+\ttype T2 struct {\n+\t\tNumber1 int `json:\",string\"`\n+\t\tNumber2 int `json:\",string\"`\n+\t}\n+\tdata := `{\"Number1\":\"1\", \"Number2\":\"\"}`\n+\tdec := NewDecoder(strings.NewReader(data))\n+\tvar t2 T2\n+\terr := dec.Decode(&t2)\n+\tif err == nil {\n+\t\tt.Fatal(\"Decode: did not return error\")\n+\t}\n+\tif t2.Number1 != 1 {\n+\t\tt.Fatal(\"Decode: did not set Number1\")\n+\t}\n+}\n+\n+func intp(x int) *int {\n+\tp := new(int)\n+\t*p = x\n+\treturn p\n+}\n+\n+func intpp(x *int) **int {\n+\tpp := new(*int)\n+\t*pp = x\n+\treturn pp\n+}\n+\n+var interfaceSetTests = []struct {\n+\tpre  interface{}\n+\tjson string\n+\tpost interface{}\n+}{\n+\t{\"foo\", `\"bar\"`, \"bar\"},\n+\t{\"foo\", `2`, 2.0},\n+\t{\"foo\", `true`, true},\n+\t{\"foo\", `null`, nil},\n+\n+\t{nil, `null`, nil},\n+\t{new(int), `null`, nil},\n+\t{(*int)(nil), `null`, nil},\n+\t{new(*int), `null`, new(*int)},\n+\t{(**int)(nil), `null`, nil},\n+\t{intp(1), `null`, nil},\n+\t{intpp(nil), `null`, intpp(nil)},\n+\t{intpp(intp(1)), `null`, intpp(nil)},\n+}\n+\n+func TestInterfaceSet(t *testing.T) {\n+\tfor _, tt := range interfaceSetTests {\n+\t\tb := struct{ X interface{} }{tt.pre}\n+\t\tblob := `{\"X\":` + tt.json + `}`\n+\t\tif err := Unmarshal([]byte(blob), &b); err != nil {\n+\t\t\tt.Errorf(\"Unmarshal %#q: %v\", blob, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !reflect.DeepEqual(b.X, tt.post) {\n+\t\t\tt.Errorf(\"Unmarshal %#q into %#v: X=%#v, want %#v\", blob, tt.pre, b.X, tt.post)\n+\t\t}\n+\t}\n+}"}, {"sha": "b6e1cb16e5a471b198d6c620badfbbaf464dd23a", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -96,7 +96,7 @@ import (\n //\n // Channel, complex, and function values cannot be encoded in JSON.\n // Attempting to encode such a value causes Marshal to return\n-// an InvalidTypeError.\n+// an UnsupportedTypeError.\n //\n // JSON cannot represent cyclic data structures and Marshal does not\n // handle them.  Passing cyclic structures to Marshal will result in\n@@ -157,6 +157,8 @@ type Marshaler interface {\n \tMarshalJSON() ([]byte, error)\n }\n \n+// An UnsupportedTypeError is returned by Marshal when attempting\n+// to encode an unsupported value type.\n type UnsupportedTypeError struct {\n \tType reflect.Type\n }"}, {"sha": "5444ad141c5905aedc97c824e2ff6d37ad7e1280", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -620,8 +620,9 @@ func (f *FlagSet) Var(value Value, name string, usage string) {\n \tflag := &Flag{name, usage, value, value.String()}\n \t_, alreadythere := f.formal[name]\n \tif alreadythere {\n-\t\tfmt.Fprintf(f.out(), \"%s flag redefined: %s\\n\", f.name, name)\n-\t\tpanic(\"flag redefinition\") // Happens only if flags are declared with identical names\n+\t\tmsg := fmt.Sprintf(\"%s flag redefined: %s\", f.name, name)\n+\t\tfmt.Fprintln(f.out(), msg)\n+\t\tpanic(msg) // Happens only if flags are declared with identical names\n \t}\n \tif f.formal == nil {\n \t\tf.formal = make(map[string]*Flag)"}, {"sha": "a9b9c9d0c27ac2128bafedba1fb64f54a5f4d1ee", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -136,7 +136,7 @@\n \tFscanf and Fscanln read from a specified io.Reader; Sscan,\n \tSscanf and Sscanln read from an argument string.  Scanln,\n \tFscanln and Sscanln stop scanning at a newline and require that\n-\tthe items be followed by one; Sscanf, Fscanf and Sscanf require\n+\tthe items be followed by one; Scanf, Fscanf and Sscanf require\n \tnewlines in the input to match newlines in the format; the other\n \troutines treat newlines as spaces.\n "}, {"sha": "d2e75dc1c0312bf70fd79c08cc2a96db1f56474f", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -87,8 +87,12 @@ func stripTrailingWhitespace(s string) string {\n \treturn s[0:i]\n }\n \n-// Text returns the text of the comment,\n-// with the comment markers - //, /*, and */ - removed.\n+// Text returns the text of the comment.\n+// Comment markers (//, /*, and */), the first space of a line comment, and\n+// leading and trailing empty lines are removed. Multiple empty lines are\n+// reduced to one, and trailing space on lines is trimmed. Unless the result\n+// is empty, it is newline-terminated.\n+//\n func (g *CommentGroup) Text() string {\n \tif g == nil {\n \t\treturn \"\"\n@@ -104,11 +108,9 @@ func (g *CommentGroup) Text() string {\n \t\t// The parser has given us exactly the comment text.\n \t\tswitch c[1] {\n \t\tcase '/':\n-\t\t\t//-style comment\n+\t\t\t//-style comment (no newline at the end)\n \t\t\tc = c[2:]\n-\t\t\t// Remove leading space after //, if there is one.\n-\t\t\t// TODO(gri) This appears to be necessary in isolated\n-\t\t\t//           cases (bignum.RatFromString) - why?\n+\t\t\t// strip first space - required for Example tests\n \t\t\tif len(c) > 0 && c[0] == ' ' {\n \t\t\t\tc = c[1:]\n \t\t\t}"}, {"sha": "1a6a283f232bb706287c6aa004fb27af2d67f4ff", "filename": "libgo/go/go/ast/ast_test.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fast%2Fast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fast%2Fast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ast\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var comments = []struct {\n+\tlist []string\n+\ttext string\n+}{\n+\t{[]string{\"//\"}, \"\"},\n+\t{[]string{\"//   \"}, \"\"},\n+\t{[]string{\"//\", \"//\", \"//   \"}, \"\"},\n+\t{[]string{\"// foo   \"}, \"foo\\n\"},\n+\t{[]string{\"//\", \"//\", \"// foo\"}, \"foo\\n\"},\n+\t{[]string{\"// foo  bar  \"}, \"foo  bar\\n\"},\n+\t{[]string{\"// foo\", \"// bar\"}, \"foo\\nbar\\n\"},\n+\t{[]string{\"// foo\", \"//\", \"//\", \"//\", \"// bar\"}, \"foo\\n\\nbar\\n\"},\n+\t{[]string{\"// foo\", \"/* bar */\"}, \"foo\\n bar\\n\"},\n+\t{[]string{\"//\", \"//\", \"//\", \"// foo\", \"//\", \"//\", \"//\"}, \"foo\\n\"},\n+\n+\t{[]string{\"/**/\"}, \"\"},\n+\t{[]string{\"/*   */\"}, \"\"},\n+\t{[]string{\"/**/\", \"/**/\", \"/*   */\"}, \"\"},\n+\t{[]string{\"/* Foo   */\"}, \" Foo\\n\"},\n+\t{[]string{\"/* Foo  Bar  */\"}, \" Foo  Bar\\n\"},\n+\t{[]string{\"/* Foo*/\", \"/* Bar*/\"}, \" Foo\\n Bar\\n\"},\n+\t{[]string{\"/* Foo*/\", \"/**/\", \"/**/\", \"/**/\", \"// Bar\"}, \" Foo\\n\\nBar\\n\"},\n+\t{[]string{\"/* Foo*/\", \"/*\\n*/\", \"//\", \"/*\\n*/\", \"// Bar\"}, \" Foo\\n\\nBar\\n\"},\n+\t{[]string{\"/* Foo*/\", \"// Bar\"}, \" Foo\\nBar\\n\"},\n+\t{[]string{\"/* Foo\\n Bar*/\"}, \" Foo\\n Bar\\n\"},\n+}\n+\n+func TestCommentText(t *testing.T) {\n+\tfor i, c := range comments {\n+\t\tlist := make([]*Comment, len(c.list))\n+\t\tfor i, s := range c.list {\n+\t\t\tlist[i] = &Comment{Text: s}\n+\t\t}\n+\n+\t\ttext := (&CommentGroup{list}).Text()\n+\t\tif text != c.text {\n+\t\t\tt.Errorf(\"case %d: got %q; expected %q\", i, text, c.text)\n+\t\t}\n+\t}\n+}"}, {"sha": "7a81d50303dd71ba8ec6eb2f02ac0f38feeba48b", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -68,7 +68,7 @@ type Context struct {\n \n \t// ReadDir returns a slice of os.FileInfo, sorted by Name,\n \t// describing the content of the named directory.\n-\t// If ReadDir is nil, Import uses io.ReadDir.\n+\t// If ReadDir is nil, Import uses ioutil.ReadDir.\n \tReadDir func(dir string) (fi []os.FileInfo, err error)\n \n \t// OpenFile opens a file (not a directory) for reading.\n@@ -339,7 +339,7 @@ func (e *NoGoError) Error() string {\n //\t- files starting with _ or . (likely editor temporary files)\n //\t- files with build constraints not satisfied by the context\n //\n-// If an error occurs, Import returns a non-nil error also returns a non-nil\n+// If an error occurs, Import returns a non-nil error and a non-nil\n // *Package containing partial information.\n //\n func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error) {"}, {"sha": "20e505d97a89aa8babd2ee99b72ae2f6e9592bdf", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -267,13 +267,13 @@ func (p *parser) consumeComment() (comment *ast.Comment, endline int) {\n \n // Consume a group of adjacent comments, add it to the parser's\n // comments list, and return it together with the line at which\n-// the last comment in the group ends. An empty line or non-comment\n-// token terminates a comment group.\n+// the last comment in the group ends. A non-comment token or n\n+// empty lines terminate a comment group.\n //\n-func (p *parser) consumeCommentGroup() (comments *ast.CommentGroup, endline int) {\n+func (p *parser) consumeCommentGroup(n int) (comments *ast.CommentGroup, endline int) {\n \tvar list []*ast.Comment\n \tendline = p.file.Line(p.pos)\n-\tfor p.tok == token.COMMENT && endline+1 >= p.file.Line(p.pos) {\n+\tfor p.tok == token.COMMENT && p.file.Line(p.pos) <= endline+n {\n \t\tvar comment *ast.Comment\n \t\tcomment, endline = p.consumeComment()\n \t\tlist = append(list, comment)\n@@ -314,7 +314,7 @@ func (p *parser) next() {\n \t\tif p.file.Line(p.pos) == line {\n \t\t\t// The comment is on same line as the previous token; it\n \t\t\t// cannot be a lead comment but may be a line comment.\n-\t\t\tcomment, endline = p.consumeCommentGroup()\n+\t\t\tcomment, endline = p.consumeCommentGroup(0)\n \t\t\tif p.file.Line(p.pos) != endline {\n \t\t\t\t// The next token is on a different line, thus\n \t\t\t\t// the last comment group is a line comment.\n@@ -325,7 +325,7 @@ func (p *parser) next() {\n \t\t// consume successor comments, if any\n \t\tendline = -1\n \t\tfor p.tok == token.COMMENT {\n-\t\t\tcomment, endline = p.consumeCommentGroup()\n+\t\t\tcomment, endline = p.consumeCommentGroup(1)\n \t\t}\n \n \t\tif endline+1 == p.file.Line(p.pos) {\n@@ -627,10 +627,10 @@ func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \n \tdoc := p.leadComment\n \n-\t// fields\n+\t// FieldDecl\n \tlist, typ := p.parseVarList(false)\n \n-\t// optional tag\n+\t// Tag\n \tvar tag *ast.BasicLit\n \tif p.tok == token.STRING {\n \t\ttag = &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}\n@@ -645,7 +645,6 @@ func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \t} else {\n \t\t// [\"*\"] TypeName (AnonymousField)\n \t\ttyp = list[0] // we always have at least one element\n-\t\tp.resolve(typ)\n \t\tif n := len(list); n > 1 || !isTypeName(deref(typ)) {\n \t\t\tpos := typ.Pos()\n \t\t\tp.errorExpected(pos, \"anonymous field\")\n@@ -657,6 +656,7 @@ func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \n \tfield := &ast.Field{Doc: doc, Names: idents, Type: typ, Tag: tag, Comment: p.lineComment}\n \tp.declare(field, nil, scope, ast.Var, idents...)\n+\tp.resolve(typ)\n \n \treturn field\n }\n@@ -699,12 +699,15 @@ func (p *parser) parsePointerType() *ast.StarExpr {\n \treturn &ast.StarExpr{Star: star, X: base}\n }\n \n+// If the result is an identifier, it is not resolved.\n func (p *parser) tryVarType(isParam bool) ast.Expr {\n \tif isParam && p.tok == token.ELLIPSIS {\n \t\tpos := p.pos\n \t\tp.next()\n \t\ttyp := p.tryIdentOrType(isParam) // don't use parseType so we can provide better error message\n-\t\tif typ == nil {\n+\t\tif typ != nil {\n+\t\t\tp.resolve(typ)\n+\t\t} else {\n \t\t\tp.error(pos, \"'...' parameter is missing type\")\n \t\t\ttyp = &ast.BadExpr{From: pos, To: p.pos}\n \t\t}\n@@ -713,6 +716,7 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \treturn p.tryIdentOrType(false)\n }\n \n+// If the result is an identifier, it is not resolved.\n func (p *parser) parseVarType(isParam bool) ast.Expr {\n \ttyp := p.tryVarType(isParam)\n \tif typ == nil {\n@@ -724,6 +728,7 @@ func (p *parser) parseVarType(isParam bool) ast.Expr {\n \treturn typ\n }\n \n+// If any of the results are identifiers, they are not resolved.\n func (p *parser) parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"VarList\"))\n@@ -744,9 +749,7 @@ func (p *parser) parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr) {\n \t}\n \n \t// if we had a list of identifiers, it must be followed by a type\n-\tif typ = p.tryVarType(isParam); typ != nil {\n-\t\tp.resolve(typ)\n-\t}\n+\ttyp = p.tryVarType(isParam)\n \n \treturn\n }\n@@ -756,7 +759,10 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\tdefer un(trace(p, \"ParameterList\"))\n \t}\n \n+\t// ParameterDecl\n \tlist, typ := p.parseVarList(ellipsisOk)\n+\n+\t// analyze case\n \tif typ != nil {\n \t\t// IdentifierList Type\n \t\tidents := p.makeIdentList(list)\n@@ -765,10 +771,10 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t// Go spec: The scope of an identifier denoting a function\n \t\t// parameter or result variable is the function body.\n \t\tp.declare(field, nil, scope, ast.Var, idents...)\n+\t\tp.resolve(typ)\n \t\tif p.tok == token.COMMA {\n \t\t\tp.next()\n \t\t}\n-\n \t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n \t\t\tidents := p.parseIdentList()\n \t\t\ttyp := p.parseVarType(ellipsisOk)\n@@ -777,18 +783,18 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t\t// Go spec: The scope of an identifier denoting a function\n \t\t\t// parameter or result variable is the function body.\n \t\t\tp.declare(field, nil, scope, ast.Var, idents...)\n+\t\t\tp.resolve(typ)\n \t\t\tif !p.atComma(\"parameter list\") {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp.next()\n \t\t}\n-\n \t} else {\n \t\t// Type { \",\" Type } (anonymous parameters)\n \t\tparams = make([]*ast.Field, len(list))\n-\t\tfor i, x := range list {\n-\t\t\tp.resolve(x)\n-\t\t\tparams[i] = &ast.Field{Type: x}\n+\t\tfor i, typ := range list {\n+\t\t\tp.resolve(typ)\n+\t\t\tparams[i] = &ast.Field{Type: typ}\n \t\t}\n \t}\n "}, {"sha": "1b7a41b1bf15007e1ae92551f1f1703429a6287f", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 190, "deletions": 5, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -5,10 +5,12 @@\n package parser\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/token\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -25,7 +27,7 @@ func TestParse(t *testing.T) {\n \tfor _, filename := range validFiles {\n \t\t_, err := ParseFile(fset, filename, nil, DeclarationErrors)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"ParseFile(%s): %v\", filename, err)\n+\t\t\tt.Fatalf(\"ParseFile(%s): %v\", filename, err)\n \t\t}\n \t}\n }\n@@ -70,7 +72,7 @@ func TestParseExpr(t *testing.T) {\n \tsrc := \"a + b\"\n \tx, err := ParseExpr(src)\n \tif err != nil {\n-\t\tt.Errorf(\"ParseExpr(%s): %v\", src, err)\n+\t\tt.Fatalf(\"ParseExpr(%s): %v\", src, err)\n \t}\n \t// sanity check\n \tif _, ok := x.(*ast.BinaryExpr); !ok {\n@@ -81,7 +83,7 @@ func TestParseExpr(t *testing.T) {\n \tsrc = \"a + *\"\n \t_, err = ParseExpr(src)\n \tif err == nil {\n-\t\tt.Errorf(\"ParseExpr(%s): %v\", src, err)\n+\t\tt.Fatalf(\"ParseExpr(%s): %v\", src, err)\n \t}\n \n \t// it must not crash\n@@ -93,7 +95,7 @@ func TestParseExpr(t *testing.T) {\n func TestColonEqualsScope(t *testing.T) {\n \tf, err := ParseFile(fset, \"\", `package p; func f() { x, y, z := x, y, z }`, 0)\n \tif err != nil {\n-\t\tt.Errorf(\"parse: %s\", err)\n+\t\tt.Fatal(err)\n \t}\n \n \t// RHS refers to undefined globals; LHS does not.\n@@ -115,7 +117,7 @@ func TestColonEqualsScope(t *testing.T) {\n func TestVarScope(t *testing.T) {\n \tf, err := ParseFile(fset, \"\", `package p; func f() { var x, y, z = x, y, z }`, 0)\n \tif err != nil {\n-\t\tt.Errorf(\"parse: %s\", err)\n+\t\tt.Fatal(err)\n \t}\n \n \t// RHS refers to undefined globals; LHS does not.\n@@ -133,6 +135,67 @@ func TestVarScope(t *testing.T) {\n \t}\n }\n \n+func TestUnresolved(t *testing.T) {\n+\tf, err := ParseFile(fset, \"\", `\n+package p\n+//\n+func f1a(int)\n+func f2a(byte, int, float)\n+func f3a(a, b int, c float)\n+func f4a(...complex)\n+func f5a(a s1a, b ...complex)\n+//\n+func f1b(*int)\n+func f2b([]byte, (int), *float)\n+func f3b(a, b *int, c []float)\n+func f4b(...*complex)\n+func f5b(a s1a, b ...[]complex)\n+//\n+type s1a struct { int }\n+type s2a struct { byte; int; s1a }\n+type s3a struct { a, b int; c float }\n+//\n+type s1b struct { *int }\n+type s2b struct { byte; int; *float }\n+type s3b struct { a, b *s3b; c []float }\n+`, 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant := \"int \" + // f1a\n+\t\t\"byte int float \" + // f2a\n+\t\t\"int float \" + // f3a\n+\t\t\"complex \" + // f4a\n+\t\t\"complex \" + // f5a\n+\t\t//\n+\t\t\"int \" + // f1b\n+\t\t\"byte int float \" + // f2b\n+\t\t\"int float \" + // f3b\n+\t\t\"complex \" + // f4b\n+\t\t\"complex \" + // f5b\n+\t\t//\n+\t\t\"int \" + // s1a\n+\t\t\"byte int \" + // s2a\n+\t\t\"int float \" + // s3a\n+\t\t//\n+\t\t\"int \" + // s1a\n+\t\t\"byte int float \" + // s2a\n+\t\t\"float \" // s3a\n+\n+\t// collect unresolved identifiers\n+\tvar buf bytes.Buffer\n+\tfor _, u := range f.Unresolved {\n+\t\tbuf.WriteString(u.Name)\n+\t\tbuf.WriteByte(' ')\n+\t}\n+\tgot := buf.String()\n+\n+\tif got != want {\n+\t\tt.Errorf(\"\\ngot:  %s\\nwant: %s\", got, want)\n+\t}\n+}\n+\n var imports = map[string]bool{\n \t`\"a\"`:        true,\n \t\"`a`\":        true,\n@@ -177,3 +240,125 @@ func TestImports(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestCommentGroups(t *testing.T) {\n+\tf, err := ParseFile(fset, \"\", `\n+package p /* 1a */ /* 1b */      /* 1c */ // 1d\n+/* 2a\n+*/\n+// 2b\n+const pi = 3.1415\n+/* 3a */ // 3b\n+/* 3c */ const e = 2.7182\n+\n+// Example from issue 3139\n+func ExampleCount() {\n+\tfmt.Println(strings.Count(\"cheese\", \"e\"))\n+\tfmt.Println(strings.Count(\"five\", \"\")) // before & after each rune\n+\t// Output:\n+\t// 3\n+\t// 5\n+}\n+`, ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\texpected := [][]string{\n+\t\t{\"/* 1a */\", \"/* 1b */\", \"/* 1c */\", \"// 1d\"},\n+\t\t{\"/* 2a\\n*/\", \"// 2b\"},\n+\t\t{\"/* 3a */\", \"// 3b\", \"/* 3c */\"},\n+\t\t{\"// Example from issue 3139\"},\n+\t\t{\"// before & after each rune\"},\n+\t\t{\"// Output:\", \"// 3\", \"// 5\"},\n+\t}\n+\tif len(f.Comments) != len(expected) {\n+\t\tt.Fatalf(\"got %d comment groups; expected %d\", len(f.Comments), len(expected))\n+\t}\n+\tfor i, exp := range expected {\n+\t\tgot := f.Comments[i].List\n+\t\tif len(got) != len(exp) {\n+\t\t\tt.Errorf(\"got %d comments in group %d; expected %d\", len(got), i, len(exp))\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor j, exp := range exp {\n+\t\t\tgot := got[j].Text\n+\t\t\tif got != exp {\n+\t\t\t\tt.Errorf(\"got %q in group %d; expected %q\", got, i, exp)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func getField(file *ast.File, fieldname string) *ast.Field {\n+\tparts := strings.Split(fieldname, \".\")\n+\tfor _, d := range file.Decls {\n+\t\tif d, ok := d.(*ast.GenDecl); ok && d.Tok == token.TYPE {\n+\t\t\tfor _, s := range d.Specs {\n+\t\t\t\tif s, ok := s.(*ast.TypeSpec); ok && s.Name.Name == parts[0] {\n+\t\t\t\t\tif s, ok := s.Type.(*ast.StructType); ok {\n+\t\t\t\t\t\tfor _, f := range s.Fields.List {\n+\t\t\t\t\t\t\tfor _, name := range f.Names {\n+\t\t\t\t\t\t\t\tif name.Name == parts[1] {\n+\t\t\t\t\t\t\t\t\treturn f\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Don't use ast.CommentGroup.Text() - we want to see exact comment text.\n+func commentText(c *ast.CommentGroup) string {\n+\tvar buf bytes.Buffer\n+\tif c != nil {\n+\t\tfor _, c := range c.List {\n+\t\t\tbuf.WriteString(c.Text)\n+\t\t}\n+\t}\n+\treturn buf.String()\n+}\n+\n+func checkFieldComments(t *testing.T, file *ast.File, fieldname, lead, line string) {\n+\tf := getField(file, fieldname)\n+\tif f == nil {\n+\t\tt.Fatalf(\"field not found: %s\", fieldname)\n+\t}\n+\tif got := commentText(f.Doc); got != lead {\n+\t\tt.Errorf(\"got lead comment %q; expected %q\", got, lead)\n+\t}\n+\tif got := commentText(f.Comment); got != line {\n+\t\tt.Errorf(\"got line comment %q; expected %q\", got, line)\n+\t}\n+}\n+\n+func TestLeadAndLineComments(t *testing.T) {\n+\tf, err := ParseFile(fset, \"\", `\n+package p\n+type T struct {\n+\t/* F1 lead comment */\n+\t//\n+\tF1 int  /* F1 */ // line comment\n+\t// F2 lead\n+\t// comment\n+\tF2 int  // F2 line comment\n+\t// f3 lead comment\n+\tf3 int  // f3 line comment\n+}\n+`, ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tcheckFieldComments(t, f, \"T.F1\", \"/* F1 lead comment *///\", \"/* F1 */// line comment\")\n+\tcheckFieldComments(t, f, \"T.F2\", \"// F2 lead// comment\", \"// F2 line comment\")\n+\tcheckFieldComments(t, f, \"T.f3\", \"// f3 lead comment\", \"// f3 line comment\")\n+\tast.FileExports(f)\n+\tcheckFieldComments(t, f, \"T.F1\", \"/* F1 lead comment *///\", \"/* F1 */// line comment\")\n+\tcheckFieldComments(t, f, \"T.F2\", \"// F2 lead// comment\", \"// F2 line comment\")\n+\tif getField(f, \"T.f3\") != nil {\n+\t\tt.Error(\"not expected to find T.f3\")\n+\t}\n+}"}, {"sha": "f13f9a5a8436ca0e03052cd5d5da913f4035b329", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -60,8 +60,8 @@ func (p *printer) linebreak(line, min int, ws whiteSpace, newSection bool) (prin\n \n // setComment sets g as the next comment if g != nil and if node comments\n // are enabled - this mode is used when printing source code fragments such\n-// as exports only. It assumes that there are no other pending comments to\n-// intersperse.\n+// as exports only. It assumes that there is no pending comment in p.comments\n+// and at most one pending comment in the p.comment cache.\n func (p *printer) setComment(g *ast.CommentGroup) {\n \tif g == nil || !p.useNodeComments {\n \t\treturn\n@@ -74,10 +74,19 @@ func (p *printer) setComment(g *ast.CommentGroup) {\n \t\t// should never happen - handle gracefully and flush\n \t\t// all comments up to g, ignore anything after that\n \t\tp.flush(p.posFor(g.List[0].Pos()), token.ILLEGAL)\n+\t\tp.comments = p.comments[0:1]\n+\t\t// in debug mode, report error\n+\t\tp.internalError(\"setComment found pending comments\")\n \t}\n \tp.comments[0] = g\n \tp.cindex = 0\n-\tp.nextComment() // get comment ready for use\n+\t// don't overwrite any pending comment in the p.comment cache\n+\t// (there may be a pending comment when a line comment is\n+\t// immediately followed by a lead comment with no other\n+\t// tokens inbetween)\n+\tif p.commentOffset == infinity {\n+\t\tp.nextComment() // get comment ready for use\n+\t}\n }\n \n type exprListMode uint"}, {"sha": "d37e4375e4c8753d2a26a60c2246f5c78d5f8530", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -26,7 +26,7 @@ const (\n \t// Bits or'ed together to control what's printed. There is no control over the\n \t// order they appear (the order listed here) or the format they present (as\n \t// described in the comments).  A colon appears after these items:\n-\t//\t2009/0123 01:23:23.123123 /a/b/c/d.go:23: message\n+\t//\t2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n \tLdate         = 1 << iota     // the date: 2009/01/23\n \tLtime                         // the time: 01:23:23\n \tLmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime."}, {"sha": "eaa6ff0666c7a90d48468ac435d6ada257a85d8b", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -271,10 +271,10 @@ func karatsuba(z, x, y nat) {\n \t//   xd = x1 - x0\n \t//   yd = y0 - y1\n \t//\n-\t//   z1 =      xd*yd                    + z1 + z0\n-\t//      = (x1-x0)*(y0 - y1)             + z1 + z0\n-\t//      = x1*y0 - x1*y1 - x0*y0 + x0*y1 + z1 + z0\n-\t//      = x1*y0 -    z1 -    z0 + x0*y1 + z1 + z0\n+\t//   z1 =      xd*yd                    + z2 + z0\n+\t//      = (x1-x0)*(y0 - y1)             + z2 + z0\n+\t//      = x1*y0 - x1*y1 - x0*y0 + x0*y1 + z2 + z0\n+\t//      = x1*y0 -    z2 -    z0 + x0*y1 + z2 + z0\n \t//      = x1*y0                 + x0*y1\n \n \t// split x, y into \"digits\"\n@@ -318,7 +318,7 @@ func karatsuba(z, x, y nat) {\n \t// save original z2:z0\n \t// (ok to use upper half of z since we're done recursing)\n \tr := z[n*4:]\n-\tcopy(r, z)\n+\tcopy(r, z[:n*2])\n \n \t// add up all partial products\n \t//"}, {"sha": "becde5d1719483437b6afcfaf9de1e20e8f07a97", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -661,3 +661,21 @@ func TestExpNN(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func ExpHelper(b *testing.B, x, y Word) {\n+\tvar z nat\n+\tfor i := 0; i < b.N; i++ {\n+\t\tz.expWW(x, y)\n+\t}\n+}\n+\n+func BenchmarkExp3Power0x10(b *testing.B)     { ExpHelper(b, 3, 0x10) }\n+func BenchmarkExp3Power0x40(b *testing.B)     { ExpHelper(b, 3, 0x40) }\n+func BenchmarkExp3Power0x100(b *testing.B)    { ExpHelper(b, 3, 0x100) }\n+func BenchmarkExp3Power0x400(b *testing.B)    { ExpHelper(b, 3, 0x400) }\n+func BenchmarkExp3Power0x1000(b *testing.B)   { ExpHelper(b, 3, 0x1000) }\n+func BenchmarkExp3Power0x4000(b *testing.B)   { ExpHelper(b, 3, 0x4000) }\n+func BenchmarkExp3Power0x10000(b *testing.B)  { ExpHelper(b, 3, 0x10000) }\n+func BenchmarkExp3Power0x40000(b *testing.B)  { ExpHelper(b, 3, 0x40000) }\n+func BenchmarkExp3Power0x100000(b *testing.B) { ExpHelper(b, 3, 0x100000) }\n+func BenchmarkExp3Power0x400000(b *testing.B) { ExpHelper(b, 3, 0x400000) }"}, {"sha": "e9e337b9222bd6124b6f3538bb6d2a8a3a1fc111", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 79, "deletions": 36, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -22,11 +22,6 @@ import (\n \t\"net/textproto\"\n )\n \n-// TODO(bradfitz): inline these once the compiler can inline them in\n-// read-only situation (such as bytes.HasSuffix)\n-var lf = []byte(\"\\n\")\n-var crlf = []byte(\"\\r\\n\")\n-\n var emptyParams = make(map[string]string)\n \n // A Part represents a single part in a multipart body.\n@@ -36,8 +31,9 @@ type Part struct {\n \t// i.e. \"foo-bar\" changes case to \"Foo-Bar\"\n \tHeader textproto.MIMEHeader\n \n-\tbuffer *bytes.Buffer\n-\tmr     *Reader\n+\tbuffer    *bytes.Buffer\n+\tmr        *Reader\n+\tbytesRead int\n \n \tdisposition       string\n \tdispositionParams map[string]string\n@@ -113,14 +109,26 @@ func (bp *Part) populateHeaders() error {\n // Read reads the body of a part, after its headers and before the\n // next part (if any) begins.\n func (p *Part) Read(d []byte) (n int, err error) {\n+\tdefer func() {\n+\t\tp.bytesRead += n\n+\t}()\n \tif p.buffer.Len() >= len(d) {\n \t\t// Internal buffer of unconsumed data is large enough for\n \t\t// the read request.  No need to parse more at the moment.\n \t\treturn p.buffer.Read(d)\n \t}\n \tpeek, err := p.mr.bufReader.Peek(4096) // TODO(bradfitz): add buffer size accessor\n-\tunexpectedEof := err == io.EOF\n-\tif err != nil && !unexpectedEof {\n+\n+\t// Look for an immediate empty part without a leading \\r\\n\n+\t// before the boundary separator.  Some MIME code makes empty\n+\t// parts like this. Most browsers, however, write the \\r\\n\n+\t// before the subsequent boundary even for empty parts and\n+\t// won't hit this path.\n+\tif p.bytesRead == 0 && p.mr.peekBufferIsEmptyPart(peek) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tunexpectedEOF := err == io.EOF\n+\tif err != nil && !unexpectedEOF {\n \t\treturn 0, fmt.Errorf(\"multipart: Part Read: %v\", err)\n \t}\n \tif peek == nil {\n@@ -138,7 +146,7 @@ func (p *Part) Read(d []byte) (n int, err error) {\n \t\tfoundBoundary = true\n \t} else if safeCount := len(peek) - len(p.mr.nlDashBoundary); safeCount > 0 {\n \t\tnCopy = safeCount\n-\t} else if unexpectedEof {\n+\t} else if unexpectedEOF {\n \t\t// If we've run out of peek buffer and the boundary\n \t\t// wasn't found (and can't possibly fit), we must have\n \t\t// hit the end of the file unexpectedly.\n@@ -172,7 +180,10 @@ type Reader struct {\n \tcurrentPart *Part\n \tpartsRead   int\n \n-\tnl, nlDashBoundary, dashBoundaryDash, dashBoundary []byte\n+\tnl               []byte // \"\\r\\n\" or \"\\n\" (set after seeing first boundary line)\n+\tnlDashBoundary   []byte // nl + \"--boundary\"\n+\tdashBoundaryDash []byte // \"--boundary--\"\n+\tdashBoundary     []byte // \"--boundary\"\n }\n \n // NextPart returns the next part in the multipart or an error.\n@@ -185,7 +196,7 @@ func (r *Reader) NextPart() (*Part, error) {\n \texpectNewPart := false\n \tfor {\n \t\tline, err := r.bufReader.ReadSlice('\\n')\n-\t\tif err == io.EOF && bytes.Equal(line, r.dashBoundaryDash) {\n+\t\tif err == io.EOF && r.isFinalBoundary(line) {\n \t\t\t// If the buffer ends in \"--boundary--\" without the\n \t\t\t// trailing \"\\r\\n\", ReadSlice will return an error\n \t\t\t// (since it's missing the '\\n'), but this is a valid\n@@ -207,7 +218,7 @@ func (r *Reader) NextPart() (*Part, error) {\n \t\t\treturn bp, nil\n \t\t}\n \n-\t\tif hasPrefixThenNewline(line, r.dashBoundaryDash) {\n+\t\tif r.isFinalBoundary(line) {\n \t\t\t// Expected EOF\n \t\t\treturn nil, io.EOF\n \t\t}\n@@ -235,7 +246,19 @@ func (r *Reader) NextPart() (*Part, error) {\n \tpanic(\"unreachable\")\n }\n \n-func (mr *Reader) isBoundaryDelimiterLine(line []byte) bool {\n+// isFinalBoundary returns whether line is the final boundary line\n+// indiciating that all parts are over.\n+// It matches `^--boundary--[ \\t]*(\\r\\n)?$`\n+func (mr *Reader) isFinalBoundary(line []byte) bool {\n+\tif !bytes.HasPrefix(line, mr.dashBoundaryDash) {\n+\t\treturn false\n+\t}\n+\trest := line[len(mr.dashBoundaryDash):]\n+\trest = skipLWSPChar(rest)\n+\treturn len(rest) == 0 || bytes.Equal(rest, mr.nl)\n+}\n+\n+func (mr *Reader) isBoundaryDelimiterLine(line []byte) (ret bool) {\n \t// http://tools.ietf.org/html/rfc2046#section-5.1\n \t//   The boundary delimiter line is then defined as a line\n \t//   consisting entirely of two hyphen characters (\"-\",\n@@ -245,32 +268,52 @@ func (mr *Reader) isBoundaryDelimiterLine(line []byte) bool {\n \tif !bytes.HasPrefix(line, mr.dashBoundary) {\n \t\treturn false\n \t}\n-\tif bytes.HasSuffix(line, mr.nl) {\n-\t\treturn onlyHorizontalWhitespace(line[len(mr.dashBoundary) : len(line)-len(mr.nl)])\n+\trest := line[len(mr.dashBoundary):]\n+\trest = skipLWSPChar(rest)\n+\n+\t// On the first part, see our lines are ending in \\n instead of \\r\\n\n+\t// and switch into that mode if so.  This is a violation of the spec,\n+\t// but occurs in practice.\n+\tif mr.partsRead == 0 && len(rest) == 1 && rest[0] == '\\n' {\n+\t\tmr.nl = mr.nl[1:]\n+\t\tmr.nlDashBoundary = mr.nlDashBoundary[1:]\n \t}\n-\t// Violate the spec and also support newlines without the\n-\t// carriage return...\n-\tif mr.partsRead == 0 && bytes.HasSuffix(line, lf) {\n-\t\tif onlyHorizontalWhitespace(line[len(mr.dashBoundary) : len(line)-1]) {\n-\t\t\tmr.nl = mr.nl[1:]\n-\t\t\tmr.nlDashBoundary = mr.nlDashBoundary[1:]\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n+\treturn bytes.Equal(rest, mr.nl)\n }\n \n-func onlyHorizontalWhitespace(s []byte) bool {\n-\tfor _, b := range s {\n-\t\tif b != ' ' && b != '\\t' {\n-\t\t\treturn false\n-\t\t}\n+// peekBufferIsEmptyPart returns whether the provided peek-ahead\n+// buffer represents an empty part.  This is only called if we've not\n+// already read any bytes in this part and checks for the case of MIME\n+// software not writing the \\r\\n on empty parts. Some does, some\n+// doesn't.\n+//\n+// This checks that what follows the \"--boundary\" is actually the end\n+// (\"--boundary--\" with optional whitespace) or optional whitespace\n+// and then a newline, so we don't catch \"--boundaryFAKE\", in which\n+// case the whole line is part of the data.\n+func (mr *Reader) peekBufferIsEmptyPart(peek []byte) bool {\n+\t// End of parts case.\n+\t// Test whether peek matches `^--boundary--[ \\t]*(?:\\r\\n|$)`\n+\tif bytes.HasPrefix(peek, mr.dashBoundaryDash) {\n+\t\trest := peek[len(mr.dashBoundaryDash):]\n+\t\trest = skipLWSPChar(rest)\n+\t\treturn bytes.HasPrefix(rest, mr.nl) || len(rest) == 0\n \t}\n-\treturn true\n+\tif !bytes.HasPrefix(peek, mr.dashBoundary) {\n+\t\treturn false\n+\t}\n+\t// Test whether rest matches `^[ \\t]*\\r\\n`)\n+\trest := peek[len(mr.dashBoundary):]\n+\trest = skipLWSPChar(rest)\n+\treturn bytes.HasPrefix(rest, mr.nl)\n }\n \n-func hasPrefixThenNewline(s, prefix []byte) bool {\n-\treturn bytes.HasPrefix(s, prefix) &&\n-\t\t(len(s) == len(prefix)+1 && s[len(s)-1] == '\\n' ||\n-\t\t\tlen(s) == len(prefix)+2 && bytes.HasSuffix(s, crlf))\n+// skipLWSPChar returns b with leading spaces and tabs removed.\n+// RFC 822 defines:\n+//    LWSP-char = SPACE / HTAB\n+func skipLWSPChar(b []byte) []byte {\n+\tfor len(b) > 0 && (b[0] == ' ' || b[0] == '\\t') {\n+\t\tb = b[1:]\n+\t}\n+\treturn b\n }"}, {"sha": "cd65e177e852e3a80539ec6c688ef0b14338ebbd", "filename": "libgo/go/mime/multipart/multipart_test.go", "status": "modified", "additions": 213, "deletions": 32, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -10,20 +10,13 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"net/textproto\"\n \t\"os\"\n+\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n )\n \n-func TestHorizontalWhitespace(t *testing.T) {\n-\tif !onlyHorizontalWhitespace([]byte(\" \\t\")) {\n-\t\tt.Error(\"expected pass\")\n-\t}\n-\tif onlyHorizontalWhitespace([]byte(\"foo bar\")) {\n-\t\tt.Error(\"expected failure\")\n-\t}\n-}\n-\n func TestBoundaryLine(t *testing.T) {\n \tmr := NewReader(strings.NewReader(\"\"), \"myBoundary\")\n \tif !mr.isBoundaryDelimiterLine([]byte(\"--myBoundary\\r\\n\")) {\n@@ -319,29 +312,6 @@ Oh no, premature EOF!\n \t}\n }\n \n-func TestZeroLengthBody(t *testing.T) {\n-\ttestBody := strings.Replace(`\n-This is a multi-part message.  This line is ignored.\n---MyBoundary\n-foo: bar\n-\n-\n---MyBoundary--\n-`, \"\\n\", \"\\r\\n\", -1)\n-\tr := NewReader(strings.NewReader(testBody), \"MyBoundary\")\n-\tpart, err := r.NextPart()\n-\tif err != nil {\n-\t\tt.Fatalf(\"didn't get a part\")\n-\t}\n-\tn, err := io.Copy(ioutil.Discard, part)\n-\tif err != nil {\n-\t\tt.Errorf(\"error reading part: %v\", err)\n-\t}\n-\tif n != 0 {\n-\t\tt.Errorf(\"read %d bytes; expected 0\", n)\n-\t}\n-}\n-\n type slowReader struct {\n \tr io.Reader\n }\n@@ -427,3 +397,214 @@ func TestNested(t *testing.T) {\n \t\tt.Fatalf(\"final outer NextPart = %v; want io.EOF\", err)\n \t}\n }\n+\n+type headerBody struct {\n+\theader textproto.MIMEHeader\n+\tbody   string\n+}\n+\n+func formData(key, value string) headerBody {\n+\treturn headerBody{\n+\t\ttextproto.MIMEHeader{\n+\t\t\t\"Content-Type\":        {\"text/plain; charset=ISO-8859-1\"},\n+\t\t\t\"Content-Disposition\": {\"form-data; name=\" + key},\n+\t\t},\n+\t\tvalue,\n+\t}\n+}\n+\n+type parseTest struct {\n+\tname    string\n+\tin, sep string\n+\twant    []headerBody\n+}\n+\n+var parseTests = []parseTest{\n+\t// Actual body from App Engine on a blob upload. The final part (the\n+\t// Content-Type: message/external-body) is what App Engine replaces\n+\t// the uploaded file with.  The other form fields (prefixed with\n+\t// \"other\" in their form-data name) are unchanged.  A bug was\n+\t// reported with blob uploads failing when the other fields were\n+\t// empty. This was the MIME POST body that previously failed.\n+\t{\n+\t\tname: \"App Engine post\",\n+\t\tsep:  \"00151757727e9583fd04bfbca4c6\",\n+\t\tin:   \"--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherEmpty1\\r\\n\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherFoo1\\r\\n\\r\\nfoo\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherFoo2\\r\\n\\r\\nfoo\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherEmpty2\\r\\n\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherRepeatFoo\\r\\n\\r\\nfoo\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherRepeatFoo\\r\\n\\r\\nfoo\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherRepeatEmpty\\r\\n\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=otherRepeatEmpty\\r\\n\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: text/plain; charset=ISO-8859-1\\r\\nContent-Disposition: form-data; name=submit\\r\\n\\r\\nSubmit\\r\\n--00151757727e9583fd04bfbca4c6\\r\\nContent-Type: message/external-body; charset=ISO-8859-1; blob-key=AHAZQqG84qllx7HUqO_oou5EvdYQNS3Mbbkb0RjjBoM_Kc1UqEN2ygDxWiyCPulIhpHRPx-VbpB6RX4MrsqhWAi_ZxJ48O9P2cTIACbvATHvg7IgbvZytyGMpL7xO1tlIvgwcM47JNfv_tGhy1XwyEUO8oldjPqg5Q\\r\\nContent-Disposition: form-data; name=file; filename=\\\"fall.png\\\"\\r\\n\\r\\nContent-Type: image/png\\r\\nContent-Length: 232303\\r\\nX-AppEngine-Upload-Creation: 2012-05-10 23:14:02.715173\\r\\nContent-MD5: MzRjODU1ZDZhZGU1NmRlOWEwZmMwMDdlODBmZTA0NzA=\\r\\nContent-Disposition: form-data; name=file; filename=\\\"fall.png\\\"\\r\\n\\r\\n\\r\\n--00151757727e9583fd04bfbca4c6--\",\n+\t\twant: []headerBody{\n+\t\t\tformData(\"otherEmpty1\", \"\"),\n+\t\t\tformData(\"otherFoo1\", \"foo\"),\n+\t\t\tformData(\"otherFoo2\", \"foo\"),\n+\t\t\tformData(\"otherEmpty2\", \"\"),\n+\t\t\tformData(\"otherRepeatFoo\", \"foo\"),\n+\t\t\tformData(\"otherRepeatFoo\", \"foo\"),\n+\t\t\tformData(\"otherRepeatEmpty\", \"\"),\n+\t\t\tformData(\"otherRepeatEmpty\", \"\"),\n+\t\t\tformData(\"submit\", \"Submit\"),\n+\t\t\t{textproto.MIMEHeader{\n+\t\t\t\t\"Content-Type\":        {\"message/external-body; charset=ISO-8859-1; blob-key=AHAZQqG84qllx7HUqO_oou5EvdYQNS3Mbbkb0RjjBoM_Kc1UqEN2ygDxWiyCPulIhpHRPx-VbpB6RX4MrsqhWAi_ZxJ48O9P2cTIACbvATHvg7IgbvZytyGMpL7xO1tlIvgwcM47JNfv_tGhy1XwyEUO8oldjPqg5Q\"},\n+\t\t\t\t\"Content-Disposition\": {\"form-data; name=file; filename=\\\"fall.png\\\"\"},\n+\t\t\t}, \"Content-Type: image/png\\r\\nContent-Length: 232303\\r\\nX-AppEngine-Upload-Creation: 2012-05-10 23:14:02.715173\\r\\nContent-MD5: MzRjODU1ZDZhZGU1NmRlOWEwZmMwMDdlODBmZTA0NzA=\\r\\nContent-Disposition: form-data; name=file; filename=\\\"fall.png\\\"\\r\\n\\r\\n\"},\n+\t\t},\n+\t},\n+\n+\t// Single empty part, ended with --boundary immediately after headers.\n+\t{\n+\t\tname: \"single empty part, --boundary\",\n+\t\tsep:  \"abc\",\n+\t\tin:   \"--abc\\r\\nFoo: bar\\r\\n\\r\\n--abc--\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\t// Single empty part, ended with \\r\\n--boundary immediately after headers.\n+\t{\n+\t\tname: \"single empty part, \\r\\n--boundary\",\n+\t\tsep:  \"abc\",\n+\t\tin:   \"--abc\\r\\nFoo: bar\\r\\n\\r\\n\\r\\n--abc--\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\t// Final part empty.\n+\t{\n+\t\tname: \"final part empty\",\n+\t\tsep:  \"abc\",\n+\t\tin:   \"--abc\\r\\nFoo: bar\\r\\n\\r\\n--abc\\r\\nFoo2: bar2\\r\\n\\r\\n--abc--\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t\t{textproto.MIMEHeader{\"Foo2\": {\"bar2\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\t// Final part empty with newlines after final separator.\n+\t{\n+\t\tname: \"final part empty then crlf\",\n+\t\tsep:  \"abc\",\n+\t\tin:   \"--abc\\r\\nFoo: bar\\r\\n\\r\\n--abc--\\r\\n\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\t// Final part empty with lwsp-chars after final separator.\n+\t{\n+\t\tname: \"final part empty then lwsp\",\n+\t\tsep:  \"abc\",\n+\t\tin:   \"--abc\\r\\nFoo: bar\\r\\n\\r\\n--abc-- \\t\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\t// No parts (empty form as submitted by Chrome)\n+\t{\n+\t\tname: \"no parts\",\n+\t\tsep:  \"----WebKitFormBoundaryQfEAfzFOiSemeHfA\",\n+\t\tin:   \"------WebKitFormBoundaryQfEAfzFOiSemeHfA--\\r\\n\",\n+\t\twant: []headerBody{},\n+\t},\n+\n+\t// Part containing data starting with the boundary, but with additional suffix.\n+\t{\n+\t\tname: \"fake separator as data\",\n+\t\tsep:  \"sep\",\n+\t\tin:   \"--sep\\r\\nFoo: bar\\r\\n\\r\\n--sepFAKE\\r\\n--sep--\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"--sepFAKE\"},\n+\t\t},\n+\t},\n+\n+\t// Part containing a boundary with whitespace following it.\n+\t{\n+\t\tname: \"boundary with whitespace\",\n+\t\tsep:  \"sep\",\n+\t\tin:   \"--sep \\r\\nFoo: bar\\r\\n\\r\\ntext\\r\\n--sep--\",\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"text\"},\n+\t\t},\n+\t},\n+\n+\t// With ignored leading line.\n+\t{\n+\t\tname: \"leading line\",\n+\t\tsep:  \"MyBoundary\",\n+\t\tin: strings.Replace(`This is a multi-part message.  This line is ignored.\n+--MyBoundary\n+foo: bar\n+\n+\n+--MyBoundary--`, \"\\n\", \"\\r\\n\", -1),\n+\t\twant: []headerBody{\n+\t\t\t{textproto.MIMEHeader{\"Foo\": {\"bar\"}}, \"\"},\n+\t\t},\n+\t},\n+\n+\troundTripParseTest(),\n+}\n+\n+func TestParse(t *testing.T) {\n+Cases:\n+\tfor _, tt := range parseTests {\n+\t\tr := NewReader(strings.NewReader(tt.in), tt.sep)\n+\t\tgot := []headerBody{}\n+\t\tfor {\n+\t\t\tp, err := r.NextPart()\n+\t\t\tif err == io.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"in test %q, NextPart: %v\", tt.name, err)\n+\t\t\t\tcontinue Cases\n+\t\t\t}\n+\t\t\tpbody, err := ioutil.ReadAll(p)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"in test %q, error reading part: %v\", tt.name, err)\n+\t\t\t\tcontinue Cases\n+\t\t\t}\n+\t\t\tgot = append(got, headerBody{p.Header, string(pbody)})\n+\t\t}\n+\t\tif !reflect.DeepEqual(tt.want, got) {\n+\t\t\tt.Errorf(\"test %q:\\n got: %v\\nwant: %v\", tt.name, got, tt.want)\n+\t\t\tif len(tt.want) != len(got) {\n+\t\t\t\tt.Errorf(\"test %q: got %d parts, want %d\", tt.name, len(got), len(tt.want))\n+\t\t\t} else if len(got) > 1 {\n+\t\t\t\tfor pi, wantPart := range tt.want {\n+\t\t\t\t\tif !reflect.DeepEqual(wantPart, got[pi]) {\n+\t\t\t\t\t\tt.Errorf(\"test %q, part %d:\\n got: %v\\nwant: %v\", tt.name, pi, got[pi], wantPart)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func roundTripParseTest() parseTest {\n+\tt := parseTest{\n+\t\tname: \"round trip\",\n+\t\twant: []headerBody{\n+\t\t\tformData(\"empty\", \"\"),\n+\t\t\tformData(\"lf\", \"\\n\"),\n+\t\t\tformData(\"cr\", \"\\r\"),\n+\t\t\tformData(\"crlf\", \"\\r\\n\"),\n+\t\t\tformData(\"foo\", \"bar\"),\n+\t\t},\n+\t}\n+\tvar buf bytes.Buffer\n+\tw := NewWriter(&buf)\n+\tfor _, p := range t.want {\n+\t\tpw, err := w.CreatePart(p.header)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\t_, err = pw.Write([]byte(p.body))\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tw.Close()\n+\tt.in = buf.String()\n+\tt.sep = w.Boundary()\n+\treturn t\n+}"}, {"sha": "fc6c6fad8e1572417a28879ca6f2239f6ef73888", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -89,8 +89,8 @@ func FileConn(f *os.File) (c Conn, err error) {\n \n // FileListener returns a copy of the network listener corresponding\n // to the open file f.  It is the caller's responsibility to close l\n-// when finished.  Closing c does not affect l, and closing l does not\n-// affect c.\n+// when finished.  Closing l does not affect f, and closing f does not\n+// affect l.\n func FileListener(f *os.File) (l Listener, err error) {\n \tfd, err := newFileFD(f)\n \tif err != nil {"}, {"sha": "54564e0989ecd624fe157e9bf6e6c89c51a8f449", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -278,6 +278,11 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response,\n \t\treturn nil, err\n \t}\n \treq.Header.Set(\"Content-Type\", bodyType)\n+\tif c.Jar != nil {\n+\t\tfor _, cookie := range c.Jar.Cookies(req.URL) {\n+\t\t\treq.AddCookie(cookie)\n+\t\t}\n+\t}\n \tr, err = send(req, c.Transport)\n \tif err == nil && c.Jar != nil {\n \t\tc.Jar.SetCookies(req.URL, r.Cookies())"}, {"sha": "9b4261b9f61e497b7ac41a827aba861d0fcabea3", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -256,6 +256,31 @@ var echoCookiesRedirectHandler = HandlerFunc(func(w ResponseWriter, r *Request)\n \t}\n })\n \n+func TestClientSendsCookieFromJar(t *testing.T) {\n+\ttr := &recordingTransport{}\n+\tclient := &Client{Transport: tr}\n+\tclient.Jar = &TestJar{perURL: make(map[string][]*Cookie)}\n+\tus := \"http://dummy.faketld/\"\n+\tu, _ := url.Parse(us)\n+\tclient.Jar.SetCookies(u, expectedCookies)\n+\n+\tclient.Get(us) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+\n+\tclient.Head(us) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+\n+\tclient.Post(us, \"text/plain\", strings.NewReader(\"body\")) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+\n+\tclient.PostForm(us, url.Values{}) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+\n+\treq, _ := NewRequest(\"GET\", us, nil)\n+\tclient.Do(req) // Note: doesn't hit network\n+\tmatchReturnedCookies(t, expectedCookies, tr.req.Cookies())\n+}\n+\n // Just enough correctness for our redirect tests. Uses the URL.Host as the\n // scope of all cookies.\n type TestJar struct {"}, {"sha": "5ecffaface93de6a145a1f92d1101579ebcaf39b", "filename": "libgo/go/net/http/proxy_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fproxy_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -5,6 +5,7 @@\n package http\n \n import (\n+\t\"net/url\"\n \t\"os\"\n \t\"testing\"\n )\n@@ -46,3 +47,32 @@ func TestUseProxy(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var cacheKeysTests = []struct {\n+\tproxy  string\n+\tscheme string\n+\taddr   string\n+\tkey    string\n+}{\n+\t{\"\", \"http\", \"foo.com\", \"|http|foo.com\"},\n+\t{\"\", \"https\", \"foo.com\", \"|https|foo.com\"},\n+\t{\"http://foo.com\", \"http\", \"foo.com\", \"http://foo.com|http|\"},\n+\t{\"http://foo.com\", \"https\", \"foo.com\", \"http://foo.com|https|foo.com\"},\n+}\n+\n+func TestCacheKeys(t *testing.T) {\n+\tfor _, tt := range cacheKeysTests {\n+\t\tvar proxy *url.URL\n+\t\tif tt.proxy != \"\" {\n+\t\t\tu, err := url.Parse(tt.proxy)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tproxy = u\n+\t\t}\n+\t\tcm := connectMethod{proxy, tt.scheme, tt.addr}\n+\t\tif cm.String() != tt.key {\n+\t\t\tt.Fatalf(\"{%q, %q, %q} cache key %q; want %q\", tt.proxy, tt.scheme, tt.addr, cm.String(), tt.key)\n+\t\t}\n+\t}\n+}"}, {"sha": "945ecd8a4b04dbb755ac3f9909041521488d28f0", "filename": "libgo/go/net/http/response.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -202,9 +202,12 @@ func (r *Response) Write(w io.Writer) error {\n \t\t\ttext = \"status code \" + strconv.Itoa(r.StatusCode)\n \t\t}\n \t}\n-\tio.WriteString(w, \"HTTP/\"+strconv.Itoa(r.ProtoMajor)+\".\")\n-\tio.WriteString(w, strconv.Itoa(r.ProtoMinor)+\" \")\n-\tio.WriteString(w, strconv.Itoa(r.StatusCode)+\" \"+text+\"\\r\\n\")\n+\tprotoMajor, protoMinor := strconv.Itoa(r.ProtoMajor), strconv.Itoa(r.ProtoMinor)\n+\tstatusCode := strconv.Itoa(r.StatusCode) + \" \"\n+\tif strings.HasPrefix(text, statusCode) {\n+\t\ttext = text[len(statusCode):]\n+\t}\n+\tio.WriteString(w, \"HTTP/\"+protoMajor+\".\"+protoMinor+\" \"+statusCode+text+\"\\r\\n\")\n \n \t// Process Body,ContentLength,Close,Trailer\n \ttw, err := newTransferWriter(r)"}, {"sha": "6eed4887ddceb8620cc434fd9be18f34413d480e", "filename": "libgo/go/net/http/response_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"io/ioutil\"\n \t\"net/url\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -444,3 +445,17 @@ func TestLocationResponse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestResponseStatusStutter(t *testing.T) {\n+\tr := &Response{\n+\t\tStatus:     \"123 some status\",\n+\t\tStatusCode: 123,\n+\t\tProtoMajor: 1,\n+\t\tProtoMinor: 3,\n+\t}\n+\tvar buf bytes.Buffer\n+\tr.Write(&buf)\n+\tif strings.Contains(buf.String(), \"123 123\") {\n+\t\tt.Errorf(\"stutter in status: %s\", buf.String())\n+\t}\n+}"}, {"sha": "0572b4ae3477466a16a2742128af7fc9f4c6abe4", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -31,7 +31,7 @@ import (\n // Errors introduced by the HTTP server.\n var (\n \tErrWriteAfterFlush = errors.New(\"Conn.Write called after Flush\")\n-\tErrBodyNotAllowed  = errors.New(\"http: response status code does not allow body\")\n+\tErrBodyNotAllowed  = errors.New(\"http: request method or response status code does not allow body\")\n \tErrHijacked        = errors.New(\"Conn has been hijacked\")\n \tErrContentLength   = errors.New(\"Conn.Write wrote more than the declared Content-Length\")\n )"}, {"sha": "9e9d84172d00effda81bb0ee7e45739d5a161f8e", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -71,15 +71,17 @@ func newTransferWriter(r interface{}) (t *transferWriter, err error) {\n \t\t\t}\n \t\t}\n \tcase *Response:\n-\t\tt.Method = rr.Request.Method\n+\t\tif rr.Request != nil {\n+\t\t\tt.Method = rr.Request.Method\n+\t\t}\n \t\tt.Body = rr.Body\n \t\tt.BodyCloser = rr.Body\n \t\tt.ContentLength = rr.ContentLength\n \t\tt.Close = rr.Close\n \t\tt.TransferEncoding = rr.TransferEncoding\n \t\tt.Trailer = rr.Trailer\n \t\tatLeastHTTP11 = rr.ProtoAtLeast(1, 1)\n-\t\tt.ResponseToHEAD = noBodyExpected(rr.Request.Method)\n+\t\tt.ResponseToHEAD = noBodyExpected(t.Method)\n \t}\n \n \t// Sanitize Body,ContentLength,TransferEncoding"}, {"sha": "6efe191eb0b0dbf18161f258d4e00a0601f7a9af", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -450,10 +450,14 @@ type connectMethod struct {\n \n func (ck *connectMethod) String() string {\n \tproxyStr := \"\"\n+\ttargetAddr := ck.targetAddr\n \tif ck.proxyURL != nil {\n \t\tproxyStr = ck.proxyURL.String()\n+\t\tif ck.targetScheme == \"http\" {\n+\t\t\ttargetAddr = \"\"\n+\t\t}\n \t}\n-\treturn strings.Join([]string{proxyStr, ck.targetScheme, ck.targetAddr}, \"|\")\n+\treturn strings.Join([]string{proxyStr, ck.targetScheme, targetAddr}, \"|\")\n }\n \n // addr returns the first hop \"host:port\" to which we need to TCP connect."}, {"sha": "b610ccf3f048e16910c93ead22bfe566f4190e92", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -69,11 +69,12 @@ var dateLayouts []string\n func init() {\n \t// Generate layouts based on RFC 5322, section 3.3.\n \n-\tdows := [...]string{\"\", \"Mon, \"}     // day-of-week\n-\tdays := [...]string{\"2\", \"02\"}       // day = 1*2DIGIT\n-\tyears := [...]string{\"2006\", \"06\"}   // year = 4*DIGIT / 2*DIGIT\n-\tseconds := [...]string{\":05\", \"\"}    // second\n-\tzones := [...]string{\"-0700\", \"MST\"} // zone = ((\"+\" / \"-\") 4DIGIT) / \"GMT\" / ...\n+\tdows := [...]string{\"\", \"Mon, \"}   // day-of-week\n+\tdays := [...]string{\"2\", \"02\"}     // day = 1*2DIGIT\n+\tyears := [...]string{\"2006\", \"06\"} // year = 4*DIGIT / 2*DIGIT\n+\tseconds := [...]string{\":05\", \"\"}  // second\n+\t// \"-0700 (MST)\" is not in RFC 5322, but is common.\n+\tzones := [...]string{\"-0700\", \"MST\", \"-0700 (MST)\"} // zone = ((\"+\" / \"-\") 4DIGIT) / \"GMT\" / ...\n \n \tfor _, dow := range dows {\n \t\tfor _, day := range days {"}, {"sha": "fd17eb414a7370636c4d6ce769da6fd324b56659", "filename": "libgo/go/net/mail/message_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -95,6 +95,11 @@ func TestDateParsing(t *testing.T) {\n \t\t\t\"21 Nov 97 09:55:06 GMT\",\n \t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.FixedZone(\"GMT\", 0)),\n \t\t},\n+\t\t// Commonly found format not specified by RFC 5322.\n+\t\t{\n+\t\t\t\"Fri, 21 Nov 1997 09:55:06 -0600 (MDT)\",\n+\t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.FixedZone(\"\", -6*60*60)),\n+\t\t},\n \t}\n \tfor _, test := range tests {\n \t\thdr := Header{"}, {"sha": "17bf0d3a342f394b3db0b9921251829aa9c1423c", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -401,11 +401,12 @@ Error:\n }\n \n func parseAuthority(authority string) (user *Userinfo, host string, err error) {\n-\tif strings.Index(authority, \"@\") < 0 {\n+\ti := strings.LastIndex(authority, \"@\")\n+\tif i < 0 {\n \t\thost = authority\n \t\treturn\n \t}\n-\tuserinfo, host := split(authority, '@', true)\n+\tuserinfo, host := authority[:i], authority[i+1:]\n \tif strings.Index(userinfo, \":\") < 0 {\n \t\tif userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {\n \t\t\treturn"}, {"sha": "75e8abe4eb3ff74a099d77f960e1a9b2b6a32fc8", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -188,6 +188,37 @@ var urltests = []URLTest{\n \t\t},\n \t\t\"http://user:password@google.com\",\n \t},\n+\t// unescaped @ in username should not confuse host\n+\t{\n+\t\t\"http://j@ne:password@google.com\",\n+\t\t&URL{\n+\t\t\tScheme: \"http\",\n+\t\t\tUser:   UserPassword(\"j@ne\", \"password\"),\n+\t\t\tHost:   \"google.com\",\n+\t\t},\n+\t\t\"http://j%40ne:password@google.com\",\n+\t},\n+\t// unescaped @ in password should not confuse host\n+\t{\n+\t\t\"http://jane:p@ssword@google.com\",\n+\t\t&URL{\n+\t\t\tScheme: \"http\",\n+\t\t\tUser:   UserPassword(\"jane\", \"p@ssword\"),\n+\t\t\tHost:   \"google.com\",\n+\t\t},\n+\t\t\"http://jane:p%40ssword@google.com\",\n+\t},\n+\t{\n+\t\t\"http://j@ne:password@google.com/p@th?q=@go\",\n+\t\t&URL{\n+\t\t\tScheme:   \"http\",\n+\t\t\tUser:     UserPassword(\"j@ne\", \"password\"),\n+\t\t\tHost:     \"google.com\",\n+\t\t\tPath:     \"/p@th\",\n+\t\t\tRawQuery: \"q=@go\",\n+\t\t},\n+\t\t\"http://j%40ne:password@google.com/p@th?q=@go\",\n+\t},\n \t{\n \t\t\"http://www.google.com/?q=go+language#foo\",\n \t\t&URL{"}, {"sha": "9a8e1817014beb8e621017e0ae8ea6c538a47068", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -204,6 +204,12 @@ func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {\n \treturn pw, nil\n }\n \n+func (c *Cmd) closeDescriptors(closers []io.Closer) {\n+\tfor _, fd := range closers {\n+\t\tfd.Close()\n+\t}\n+}\n+\n // Run starts the specified command and waits for it to complete.\n //\n // The returned error is nil if the command runs, has no problems\n@@ -233,6 +239,8 @@ func (c *Cmd) Start() error {\n \tfor _, setupFd := range []F{(*Cmd).stdin, (*Cmd).stdout, (*Cmd).stderr} {\n \t\tfd, err := setupFd(c)\n \t\tif err != nil {\n+\t\t\tc.closeDescriptors(c.closeAfterStart)\n+\t\t\tc.closeDescriptors(c.closeAfterWait)\n \t\t\treturn err\n \t\t}\n \t\tc.childFiles = append(c.childFiles, fd)\n@@ -247,12 +255,12 @@ func (c *Cmd) Start() error {\n \t\tSys:   c.SysProcAttr,\n \t})\n \tif err != nil {\n+\t\tc.closeDescriptors(c.closeAfterStart)\n+\t\tc.closeDescriptors(c.closeAfterWait)\n \t\treturn err\n \t}\n \n-\tfor _, fd := range c.closeAfterStart {\n-\t\tfd.Close()\n-\t}\n+\tc.closeDescriptors(c.closeAfterStart)\n \n \tc.errch = make(chan error, len(c.goroutine))\n \tfor _, fn := range c.goroutine {\n@@ -301,9 +309,7 @@ func (c *Cmd) Wait() error {\n \t\t}\n \t}\n \n-\tfor _, fd := range c.closeAfterWait {\n-\t\tfd.Close()\n-\t}\n+\tc.closeDescriptors(c.closeAfterWait)\n \n \tif err != nil {\n \t\treturn err"}, {"sha": "815021bd040149f669d2f1109abd547a3d49af96", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -320,8 +320,11 @@ func walk(path string, info os.FileInfo, walkFn WalkFunc) error {\n \t}\n \n \tfor _, fileInfo := range list {\n-\t\tif err = walk(Join(path, fileInfo.Name()), fileInfo, walkFn); err != nil {\n-\t\t\treturn err\n+\t\terr = walk(Join(path, fileInfo.Name()), fileInfo, walkFn)\n+\t\tif err != nil {\n+\t\t\tif !fileInfo.IsDir() || err != SkipDir {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil"}, {"sha": "59a5812dd0bad1c7acec33e2e0304b28e491a353", "filename": "libgo/go/path/filepath/path_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -12,7 +12,7 @@ func IsAbs(path string) bool {\n }\n \n // VolumeName returns the leading volume name on Windows.\n-// It returns \"\" elsewhere\n+// It returns \"\" elsewhere.\n func VolumeName(path string) string {\n \treturn \"\"\n }"}, {"sha": "097b0d9dc82bdc3f7172b4a2994a710b2ff198e3", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -869,3 +869,34 @@ func TestDriveLetterInEvalSymlinks(t *testing.T) {\n \t\tt.Errorf(\"Results of EvalSymlinks do not match: %q and %q\", flp, fup)\n \t}\n }\n+\n+/* This test does not work gccgo, since the sources are arranged\n+   differently.\n+\n+func TestBug3486(t *testing.T) { // http://code.google.com/p/go/issues/detail?id=3486\n+\troot, err := filepath.EvalSymlinks(os.Getenv(\"GOROOT\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tlib := filepath.Join(root, \"lib\")\n+\tsrc := filepath.Join(root, \"src\")\n+\tseenSrc := false\n+\tfilepath.Walk(root, func(pth string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tswitch pth {\n+\t\tcase lib:\n+\t\t\treturn filepath.SkipDir\n+\t\tcase src:\n+\t\t\tseenSrc = true\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif !seenSrc {\n+\t\tt.Fatalf(\"%q not seen\", src)\n+\t}\n+}\n+\n+*/"}, {"sha": "87e6b1c61e41c314b49d5c0ee6c3229ec55200f0", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -512,7 +512,7 @@ func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst\n }\n \n // ReplaceAll returns a copy of src, replacing matches of the Regexp\n-// with the replacement string repl.  Inside repl, $ signs are interpreted as\n+// with the replacement text repl.  Inside repl, $ signs are interpreted as\n // in Expand, so for instance $1 represents the text of the first submatch.\n func (re *Regexp) ReplaceAll(src, repl []byte) []byte {\n \tn := 2\n@@ -726,7 +726,7 @@ func (re *Regexp) FindSubmatch(b []byte) [][]byte {\n // the submatch with the corresponding index; other names refer to\n // capturing parentheses named with the (?P<name>...) syntax.  A\n // reference to an out of range or unmatched index or a name that is not\n-// present in the regular expression is replaced with an empty string.\n+// present in the regular expression is replaced with an empty slice.\n // \n // In the $name form, name is taken to be as long as possible: $1x is\n // equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0."}, {"sha": "4c61cb3a064597bb4bb5512628f959d3b240dd0b", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -48,6 +48,9 @@ const (\n \tErrTrailingBackslash     ErrorCode = \"trailing backslash at end of expression\"\n )\n \n+// TODO: Export for Go 1.1.\n+const errUnexpectedParen ErrorCode = \"unexpected )\"\n+\n func (e ErrorCode) String() string {\n \treturn string(e)\n }\n@@ -1168,13 +1171,13 @@ func (p *parser) parseRightParen() error {\n \n \tn := len(p.stack)\n \tif n < 2 {\n-\t\treturn &Error{ErrInternalError, \"\"}\n+\t\treturn &Error{errUnexpectedParen, p.wholeRegexp}\n \t}\n \tre1 := p.stack[n-1]\n \tre2 := p.stack[n-2]\n \tp.stack = p.stack[:n-2]\n \tif re2.Op != opLeftParen {\n-\t\treturn &Error{ErrMissingParen, p.wholeRegexp}\n+\t\treturn &Error{errUnexpectedParen, p.wholeRegexp}\n \t}\n \t// Restore flags at time of paren.\n \tp.flags = re2.Flags"}, {"sha": "e247cf203ac72d03bd857baaec02a41879f9fa52", "filename": "libgo/go/regexp/syntax/parse_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -442,10 +442,18 @@ var invalidRegexps = []string{\n \t`(`,\n \t`)`,\n \t`(a`,\n+\t`a)`,\n+\t`(a))`,\n \t`(a|b|`,\n+\t`a|b|)`,\n+\t`(a|b|))`,\n \t`(a|b`,\n+\t`a|b)`,\n+\t`(a|b))`,\n \t`[a-z`,\n \t`([a-z)`,\n+\t`[a-z)`,\n+\t`([a-z]))`,\n \t`x{1001}`,\n \t`x{9876543210}`,\n \t`x{2,1}`,"}, {"sha": "09d1391d25490f1816709886745e37355e0fea89", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -20,15 +20,16 @@ func Goexit()\n \n // Caller reports file and line number information about function invocations on\n // the calling goroutine's stack.  The argument skip is the number of stack frames\n-// to ascend, with 1 identifying the caller of Caller.  (For historical reasons the\n+// to ascend, with 0 identifying the caller of Caller.  (For historical reasons the\n // meaning of skip differs between Caller and Callers.) The return values report the\n // program counter, file name, and line number within the file of the corresponding\n // call.  The boolean ok is false if it was not possible to recover the information.\n func Caller(skip int) (pc uintptr, file string, line int, ok bool)\n \n // Callers fills the slice pc with the program counters of function invocations\n // on the calling goroutine's stack.  The argument skip is the number of stack frames\n-// to skip before recording in pc, with 0 starting at the caller of Callers.\n+// to skip before recording in pc, with 0 identifying the frame for Callers itself and\n+// 1 identifying the caller of Callers.\n // It returns the number of entries written to pc.\n func Callers(skip int, pc []uintptr) int\n "}, {"sha": "67f17d866474b462f2b42140c2649ba4f2586b95", "filename": "libgo/go/strconv/itoa.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fstrconv%2Fitoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fstrconv%2Fitoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fitoa.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -4,13 +4,17 @@\n \n package strconv\n \n-// FormatUint returns the string representation of i in the given base.\n+// FormatUint returns the string representation of i in the given base,\n+// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\n+// for digit values >= 10.\n func FormatUint(i uint64, base int) string {\n \t_, s := formatBits(nil, i, base, false, false)\n \treturn s\n }\n \n-// FormatInt returns the string representation of i in the given base.\n+// FormatInt returns the string representation of i in the given base,\n+// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\n+// for digit values >= 10.\n func FormatInt(i int64, base int) string {\n \t_, s := formatBits(nil, uint64(i), base, i < 0, false)\n \treturn s"}, {"sha": "733caf5f2db27bc5d5cbda3d1bb821d9301038f9", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -41,7 +41,6 @@ func ExampleContainsAny() {\n func ExampleCount() {\n \tfmt.Println(strings.Count(\"cheese\", \"e\"))\n \tfmt.Println(strings.Count(\"five\", \"\")) // before & after each rune\n-\n \t// Output:\n \t// 3\n \t// 5"}, {"sha": "aba21ce28f55c0d0ccf9f390bdcf66f52ef60f4b", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -518,6 +518,13 @@ func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Valu\n \t\t}\n \t}\n \tif !value.Type().AssignableTo(typ) {\n+\t\tif value.Kind() == reflect.Interface && !value.IsNil() {\n+\t\t\tvalue = value.Elem()\n+\t\t\tif value.Type().AssignableTo(typ) {\n+\t\t\t\treturn value\n+\t\t\t}\n+\t\t\t// fallthrough\n+\t\t}\n \t\t// Does one dereference or indirection work? We could do more, as we\n \t\t// do with method receivers, but that gets messy and method receivers\n \t\t// are much more constrained, so it makes more sense there than here."}, {"sha": "f4ae50f0ee9dcaa7183ab3f81926a864d01a4a35", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -311,6 +311,7 @@ var execTests = []execTest{\n \t{\".VariadicFuncInt\", \"{{call .VariadicFuncInt 33 `he` `llo`}}\", \"33=<he+llo>\", tVal, true},\n \t{\"if .BinaryFunc call\", \"{{ if .BinaryFunc}}{{call .BinaryFunc `1` `2`}}{{end}}\", \"[1=2]\", tVal, true},\n \t{\"if not .BinaryFunc call\", \"{{ if not .BinaryFunc}}{{call .BinaryFunc `1` `2`}}{{else}}No{{end}}\", \"No\", tVal, true},\n+\t{\"Interface Call\", `{{stringer .S}}`, \"foozle\", map[string]interface{}{\"S\": bytes.NewBufferString(\"foozle\")}, true},\n \n \t// Erroneous function calls (check args).\n \t{\".BinaryFuncTooFew\", \"{{call .BinaryFunc `1`}}\", \"\", tVal, false},\n@@ -507,6 +508,10 @@ func vfunc(V, *V) string {\n \treturn \"vfunc\"\n }\n \n+func stringer(s fmt.Stringer) string {\n+\treturn s.String()\n+}\n+\n func testExecute(execTests []execTest, template *Template, t *testing.T) {\n \tb := new(bytes.Buffer)\n \tfuncs := FuncMap{\n@@ -516,6 +521,7 @@ func testExecute(execTests []execTest, template *Template, t *testing.T) {\n \t\t\"typeOf\":   typeOf,\n \t\t\"vfunc\":    vfunc,\n \t\t\"zeroArgs\": zeroArgs,\n+\t\t\"stringer\": stringer,\n \t}\n \tfor _, test := range execTests {\n \t\tvar tmpl *Template"}, {"sha": "caa9702c9fc74b2a48c39efce289581d73935d66", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -224,3 +224,25 @@ func TestTimerStopStress(t *testing.T) {\n \t}\n \tSleep(3 * Second)\n }\n+\n+func TestSleepZeroDeadlock(t *testing.T) {\n+\t// Sleep(0) used to hang, the sequence of events was as follows.\n+\t// Sleep(0) sets G's status to Gwaiting, but then immediately returns leaving the status.\n+\t// Then the goroutine calls e.g. new and falls down into the scheduler due to pending GC.\n+\t// After the GC nobody wakes up the goroutine from Gwaiting status.\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(4))\n+\tc := make(chan bool)\n+\tgo func() {\n+\t\tfor i := 0; i < 100; i++ {\n+\t\t\truntime.GC()\n+\t\t}\n+\t\tc <- true\n+\t}()\n+\tfor i := 0; i < 100; i++ {\n+\t\tSleep(0)\n+\t\ttmp := make(chan bool, 1)\n+\t\ttmp <- true\n+\t\t<-tmp\n+\t}\n+\t<-c\n+}"}, {"sha": "ebd169b0991dc4a7c0dd646e061ebf53bc1d854b", "filename": "libgo/go/unicode/tables.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Funicode%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fgo%2Funicode%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Ftables.go?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -2701,7 +2701,7 @@ var _Zs = &RangeTable{\n \t},\n }\n \n-// The following variables are of type *RangeTable:\n+// These variables have type *RangeTable.\n var (\n \tCc     = _Cc // Cc is the set of Unicode characters in category Cc.\n \tCf     = _Cf // Cf is the set of Unicode characters in category Cf.\n@@ -4054,7 +4054,7 @@ var _Yi = &RangeTable{\n \t},\n }\n \n-// The following variables are of type *RangeTable:\n+// These variables have type *RangeTable.\n var (\n \tArabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.\n \tArmenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.\n@@ -5116,7 +5116,7 @@ var _White_Space = &RangeTable{\n \t},\n }\n \n-// The following variables are of type *RangeTable:\n+// These variables have type *RangeTable.\n var (\n \tASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.\n \tBidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control."}, {"sha": "eb1634690762d0524b5ffe4a8e003adbba3a7ab3", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -168,6 +168,7 @@ __go_free(void *v)\n \t\tc->local_by_size[sizeclass].nfree++;\n \t\truntime_MCache_Free(c, v, sizeclass, size);\n \t}\n+\tc->local_nfree++;\n \tc->local_alloc -= size;\n \tif(prof)\n \t\truntime_MProf_Free(v, size);"}, {"sha": "e52ae3bce539a453b5a79d81e7d0122919acc4dd", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -150,8 +150,7 @@ runtime_addfinalizer(void *p, void (*f)(void*), const struct __go_func_type *ft)\n \ttab = TAB(p);\n \truntime_lock(tab);\n \tif(f == nil) {\n-\t\tif(lookfintab(tab, p, true, nil))\n-\t\t\truntime_setblockspecial(p, false);\n+\t\tlookfintab(tab, p, true, nil);\n \t\truntime_unlock(tab);\n \t\treturn true;\n \t}"}, {"sha": "d35cc0ffbdd64f987c727fdd9ce633f844341884", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -1132,7 +1132,6 @@ runfinq(void* dummy __attribute__ ((unused)))\n \n \t\t\t\tf = &fb->fin[i];\n \t\t\t\tparams[0] = &f->arg;\n-\t\t\t\truntime_setblockspecial(f->arg, false);\n \t\t\t\treflect_call(f->ft, (void*)f->fn, 0, 0, params, nil);\n \t\t\t\tf->fn = nil;\n \t\t\t\tf->arg = nil;"}, {"sha": "b3f0fb0278fd3dcd35a290c955477fe780bf3d08", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08a680a8879ce9da16d808644730f7cfacaf667f/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=08a680a8879ce9da16d808644730f7cfacaf667f", "patch": "@@ -61,15 +61,21 @@ ready(int64 now, Eface e)\n void\n runtime_tsleep(int64 ns)\n {\n+\tG* g;\n \tTimer t;\n \n-\tif(ns <= 0)\n+\tg = runtime_g();\n+\n+\tif(ns <= 0) {\n+\t\tg->status = Grunning;\n+\t\tg->waitreason = nil;\n \t\treturn;\n+\t}\n \n \tt.when = runtime_nanotime() + ns;\n \tt.period = 0;\n \tt.f = ready;\n-\tt.arg.__object = runtime_g();\n+\tt.arg.__object = g;\n \taddtimer(&t);\n \truntime_gosched();\n }"}]}