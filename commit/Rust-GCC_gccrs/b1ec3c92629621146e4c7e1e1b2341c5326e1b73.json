{"sha": "b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFlYzNjOTI2Mjk2MjExNDZlNGM3ZTFlMWIyMzQxYzUzMjZlMWI3Mw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:04:10Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:04:10Z"}, "message": "entered into RCS\n\nFrom-SVN: r1472", "tree": {"sha": "7559e271b9c71c3f6f837b0ccd4bc2815e9a4727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7559e271b9c71c3f6f837b0ccd4bc2815e9a4727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/comments", "author": null, "committer": null, "parents": [{"sha": "5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f4f0e229486bb7af5cfeaf7aae644702e0fc0c7"}], "stats": {"total": 475, "additions": 245, "deletions": 230}, "files": [{"sha": "d812003b27ab52f455ee440a3ba3bb1f9a8f6ba4", "filename": "gcc/explow.c", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "patch": "@@ -29,12 +29,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n \n-/* Return an rtx for the sum of X and the integer C.  */\n+/* Return an rtx for the sum of X and the integer C.\n+\n+   This fucntion should be used via the `plus_constant' macro.  */\n \n rtx\n-plus_constant (x, c)\n+plus_constant_wide (x, c)\n      register rtx x;\n-     register int c;\n+     register HOST_WIDE_INT c;\n {\n   register RTX_CODE code;\n   register enum machine_mode mode;\n@@ -51,15 +53,15 @@ plus_constant (x, c)\n   switch (code)\n     {\n     case CONST_INT:\n-      return gen_rtx (CONST_INT, VOIDmode, (INTVAL (x) + c));\n+      return GEN_INT (INTVAL (x) + c);\n \n     case CONST_DOUBLE:\n       {\n-\tint l1 = CONST_DOUBLE_LOW (x);\n-\tint h1 = CONST_DOUBLE_HIGH (x);\n-\tint l2 = c;\n-\tint h2 = c < 0 ? ~0 : 0;\n-\tint lv, hv;\n+\tHOST_WIDE_INT l1 = CONST_DOUBLE_LOW (x);\n+\tHOST_WIDE_INT h1 = CONST_DOUBLE_HIGH (x);\n+\tHOST_WIDE_INT l2 = c;\n+\tHOST_WIDE_INT h2 = c < 0 ? ~0 : 0;\n+\tHOST_WIDE_INT lv, hv;\n \n \tadd_double (l1, h1, l2, h2, &lv, &hv);\n \n@@ -117,7 +119,7 @@ plus_constant (x, c)\n     }\n \n   if (c != 0)\n-    x = gen_rtx (PLUS, mode, x, gen_rtx (CONST_INT, VOIDmode, c));\n+    x = gen_rtx (PLUS, mode, x, GEN_INT (c));\n \n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     return x;\n@@ -127,12 +129,14 @@ plus_constant (x, c)\n     return x;\n }\n \n-/* This is the same as `plus_constant', except that it handles LO_SUM.  */\n+/* This is the same as `plus_constant', except that it handles LO_SUM.\n+\n+   This function should be used via the `plus_constant_for_output' macro.  */\n \n rtx\n-plus_constant_for_output (x, c)\n+plus_constant_for_output_wide (x, c)\n      register rtx x;\n-     register int c;\n+     register HOST_WIDE_INT c;\n {\n   register RTX_CODE code = GET_CODE (x);\n   register enum machine_mode mode = GET_MODE (x);\n@@ -239,7 +243,7 @@ expr_size (exp)\n      tree exp;\n {\n   return expand_expr (size_in_bytes (TREE_TYPE (exp)),\n-\t\t      0, TYPE_MODE (sizetype), 0);\n+\t\t      NULL_RTX, TYPE_MODE (sizetype), 0);\n }\n \f\n /* Return a copy of X in which all memory references\n@@ -377,15 +381,15 @@ memory_address (mode, x)\n       rtx y = eliminate_constant_term (x, &constant_term);\n       if (constant_term == const0_rtx\n \t  || ! memory_address_p (mode, y))\n-\treturn force_operand (x, 0);\n+\treturn force_operand (x, NULL_RTX);\n \n       y = gen_rtx (PLUS, GET_MODE (x), copy_to_reg (y), constant_term);\n       if (! memory_address_p (mode, y))\n-\treturn force_operand (x, 0);\n+\treturn force_operand (x, NULL_RTX);\n       return y;\n     }\n   if (GET_CODE (x) == MULT || GET_CODE (x) == MINUS)\n-    return force_operand (x, 0);\n+    return force_operand (x, NULL_RTX);\n \n   /* If we have a register that's an invalid address,\n      it must be a hard reg of the wrong class.  Copy it to a pseudo.  */\n@@ -408,7 +412,7 @@ memory_address (mode, x)\n       if (general_operand (x, Pmode))\n \treturn force_reg (Pmode, x);\n       else\n-\treturn force_operand (x, 0);\n+\treturn force_operand (x, NULL_RTX);\n     }\n   return x;\n }\n@@ -550,7 +554,7 @@ force_reg (mode, x)\n      and that X can be substituted for it.  */\n   if (CONSTANT_P (x))\n     {\n-      rtx note = find_reg_note (insn, REG_EQUAL, 0);\n+      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n       if (note)\n \tXEXP (note, 0) = x;\n@@ -662,16 +666,13 @@ round_push (size)\n     {\n       int new = (INTVAL (size) + align - 1) / align * align;\n       if (INTVAL (size) != new)\n-\tsize = gen_rtx (CONST_INT, VOIDmode, new);\n+\tsize = GEN_INT (new);\n     }\n   else\n     {\n-      size = expand_divmod (0, CEIL_DIV_EXPR, Pmode, size,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, align),\n-\t\t\t    0, 1);\n-      size = expand_mult (Pmode, size,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, align),\n-\t\t\t  0, 1);\n+      size = expand_divmod (0, CEIL_DIV_EXPR, Pmode, size, GEN_INT (align),\n+\t\t\t    NULL_RTX, 1);\n+      size = expand_mult (Pmode, size, GEN_INT (align), NULL_RTX, 1);\n     }\n #endif /* STACK_BOUNDARY */\n   return size;\n@@ -867,14 +868,12 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (known_align % BIGGEST_ALIGNMENT != 0)\n     {\n       if (GET_CODE (size) == CONST_INT)\n-\tsize = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t(INTVAL (size)\n-\t\t\t + (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1)));\n+\tsize = GEN_INT (INTVAL (size)\n+\t\t\t+ (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1));\n       else\n \tsize = expand_binop (Pmode, add_optab, size,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n-\t\t\t     0, 1, OPTAB_LIB_WIDEN);\n+\t\t\t     GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n #endif\n \n@@ -887,9 +886,9 @@ allocate_dynamic_stack_space (size, target, known_align)\n   {\n     rtx dynamic_offset\n       = expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n-\t\t      stack_pointer_rtx, 0, 1, OPTAB_LIB_WIDEN);\n+\t\t      stack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n-\t\t\t 0, 1, OPTAB_LIB_WIDEN);\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n   }\n #endif /* SETJMP_VIA_SAVE_AREA */\n \n@@ -953,14 +952,12 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (known_align % BIGGEST_ALIGNMENT != 0)\n     {\n       target = expand_divmod (0, CEIL_DIV_EXPR, Pmode, target,\n-\t\t\t      gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t       BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n-\t\t\t      0, 1);\n+\t\t\t      GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t      NULL_RTX, 1);\n \n       target = expand_mult (Pmode, target,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t     BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n-\t\t\t    0, 1);\n+\t\t\t    GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t    NULL_RTX, 1);\n     }\n #endif\n   "}, {"sha": "88a1b7e9c28060937b33afb0e43db878541e3e94", "filename": "gcc/expmed.c", "status": "modified", "additions": 122, "deletions": 116, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "patch": "@@ -62,25 +62,24 @@ init_expmed ()\n   /* This is \"some random pseudo register\" for purposes of calling recog\n      to see what insns exist.  */\n   rtx reg = gen_rtx (REG, word_mode, FIRST_PSEUDO_REGISTER);\n-  rtx pow2 = gen_rtx (CONST_INT, VOIDmode, 32);\n+  rtx pow2 = GEN_INT (32);\n   rtx lea;\n-  int i, dummy;\n+  HOST_WIDE_INT i;\n+  int dummy;\n \n   add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n   shift_cost = rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n \t\t\t\t  /* Using a constant gives better\n \t\t\t\t     estimate of typical costs.\n \t\t\t\t     1 or 2 might have quirks.  */\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 3)), SET);\n+\t\t\t\t  GEN_INT (3)), SET);\n   mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n   negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n \n   /* 999999 is chosen to avoid any plausible faster special case.  */\n   mult_is_very_cheap\n-    = (rtx_cost (gen_rtx (MULT, word_mode, reg,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, 999999)), SET)\n-       < rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, 7)), SET));\n+    = (rtx_cost (gen_rtx (MULT, word_mode, reg, GEN_INT (999999)), SET)\n+       < rtx_cost (gen_rtx (LSHIFT, word_mode, reg, GEN_INT (7)), SET));\n \n   sdiv_pow2_cheap\n     = rtx_cost (gen_rtx (DIV, word_mode, reg, pow2), SET) <= 2 * add_cost;\n@@ -92,8 +91,7 @@ init_expmed ()\n     {\n       lea = gen_rtx (SET, VOIDmode, reg,\n \t\t     gen_rtx (PLUS, word_mode,\n-\t\t\t      gen_rtx (MULT, word_mode, reg,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, i)),\n+\t\t\t      gen_rtx (MULT, word_mode, reg, GEN_INT (i)),\n \t\t\t      reg));\n       /* Using 0 as second argument is not quite right,\n \t but what else is there to do?  */\n@@ -118,19 +116,19 @@ negate_rtx (mode, x)\n {\n   if (GET_CODE (x) == CONST_INT)\n     {\n-      int val = - INTVAL (x);\n-      if (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_INT)\n+      HOST_WIDE_INT val = - INTVAL (x);\n+      if (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  /* Sign extend the value from the bits that are significant.  */\n-\t  if (val & (1 << (GET_MODE_BITSIZE (mode) - 1)))\n-\t    val |= (-1) << GET_MODE_BITSIZE (mode);\n+\t  if (val & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n+\t    val |= (HOST_WIDE_INT) (-1) << GET_MODE_BITSIZE (mode);\n \t  else\n-\t    val &= (1 << GET_MODE_BITSIZE (mode)) - 1;\n+\t    val &= ((HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (mode)) - 1;\n \t}\n-      return gen_rtx (CONST_INT, VOIDmode, val);\n+      return GEN_INT (val);\n     }\n   else\n-    return expand_unop (GET_MODE (x), neg_optab, x, 0, 0);\n+    return expand_unop (GET_MODE (x), neg_optab, x, NULL_RTX, 0);\n }\n \f\n /* Generate code to store value from rtx VALUE\n@@ -425,10 +423,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t     (value1, maxmode)))\n \tvalue1 = force_reg (maxmode, value1);\n \n-      pat = gen_insv (xop0,\n-\t\t      gen_rtx (CONST_INT, VOIDmode, bitsize),\n-\t\t      gen_rtx (CONST_INT, VOIDmode, xbitpos),\n-\t\t      value1);\n+      pat = gen_insv (xop0, GEN_INT (bitsize), GEN_INT (xbitpos), value1);\n       if (pat)\n \temit_insn (pat);\n       else\n@@ -546,15 +541,16 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n \n   if (GET_CODE (value) == CONST_INT)\n     {\n-      register int v = INTVAL (value);\n+      register HOST_WIDE_INT v = INTVAL (value);\n \n-      if (bitsize < HOST_BITS_PER_INT)\n-\tv &= (1 << bitsize) - 1;\n+      if (bitsize < HOST_BITS_PER_WIDE_INT)\n+\tv &= ((HOST_WIDE_INT) 1 << bitsize) - 1;\n \n       if (v == 0)\n \tall_zero = 1;\n-      else if ((bitsize < HOST_BITS_PER_INT && v == (1 << bitsize) - 1)\n-\t       || (bitsize == HOST_BITS_PER_INT && v == -1))\n+      else if ((bitsize < HOST_BITS_PER_WIDE_INT\n+\t\t&& v == ((HOST_WIDE_INT) 1 << bitsize) - 1)\n+\t       || (bitsize == HOST_BITS_PER_WIDE_INT && v == -1))\n \tall_one = 1;\n \n       value = lshift_value (mode, value, bitpos, bitsize);\n@@ -587,10 +583,10 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n       if (must_and)\n \tvalue = expand_binop (mode, and_optab, value,\n \t\t\t      mask_rtx (mode, 0, bitsize, 0),\n-\t\t\t      0, 1, OPTAB_LIB_WIDEN);\n+\t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       if (bitpos > 0)\n \tvalue = expand_shift (LSHIFT_EXPR, mode, value,\n-\t\t\t      build_int_2 (bitpos, 0), 0, 1);\n+\t\t\t      build_int_2 (bitpos, 0), NULL_RTX, 1);\n     }\n \n   /* Now clear the chosen bits in OP0,\n@@ -655,35 +651,33 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n   /* PART1 gets the more significant part.  */\n   if (GET_CODE (value) == CONST_INT)\n     {\n-      part1 = gen_rtx (CONST_INT, VOIDmode,\n-\t\t       (unsigned) (INTVAL (value)) >> bitsize_2);\n-      part2 = gen_rtx (CONST_INT, VOIDmode,\n-\t\t       (unsigned) (INTVAL (value)) & ((1 << bitsize_2) - 1));\n+      part1 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsize_2);\n+      part2 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value))\n+\t\t       & (((HOST_WIDE_INT) 1 << bitsize_2) - 1));\n     }\n   else\n     {\n       part1 = extract_fixed_bit_field (word_mode, value, 0, bitsize_1,\n-\t\t\t\t       BITS_PER_WORD - bitsize, 0, 1,\n+\t\t\t\t       BITS_PER_WORD - bitsize, NULL_RTX, 1,\n \t\t\t\t       BITS_PER_WORD);\n       part2 = extract_fixed_bit_field (word_mode, value, 0, bitsize_2,\n-\t\t\t\t       BITS_PER_WORD - bitsize_2, 0, 1,\n+\t\t\t\t       BITS_PER_WORD - bitsize_2, NULL_RTX, 1,\n \t\t\t\t       BITS_PER_WORD);\n     }\n #else\n   /* PART1 gets the less significant part.  */\n   if (GET_CODE (value) == CONST_INT)\n     {\n-      part1 = gen_rtx (CONST_INT, VOIDmode,\n-\t\t       (unsigned) (INTVAL (value)) & ((1 << bitsize_1) - 1));\n-      part2 = gen_rtx (CONST_INT, VOIDmode,\n-\t\t       (unsigned) (INTVAL (value)) >> bitsize_1);\n+      part1 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value))\n+\t\t       & (((HOST_WIDE_INT) 1 << bitsize_1) - 1));\n+      part2 = GEN_INT ((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsize_1);\n     }\n   else\n     {\n       part1 = extract_fixed_bit_field (word_mode, value, 0, bitsize_1, 0,\n-\t\t\t\t       0, 1, BITS_PER_WORD);\n+\t\t\t\t       NULL_RTX, 1, BITS_PER_WORD);\n       part2 = extract_fixed_bit_field (word_mode, value, 0, bitsize_2,\n-\t\t\t\t       bitsize_1, 0, 1, BITS_PER_WORD);\n+\t\t\t\t       bitsize_1, NULL_RTX, 1, BITS_PER_WORD);\n     }\n #endif\n \n@@ -989,8 +983,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t (xtarget, maxmode)))\n \t    xtarget = gen_reg_rtx (maxmode);\n \n-\t  bitsize_rtx = gen_rtx (CONST_INT, VOIDmode, bitsize);\n-\t  bitpos_rtx = gen_rtx (CONST_INT, VOIDmode, xbitpos);\n+\t  bitsize_rtx = GEN_INT (bitsize);\n+\t  bitpos_rtx = GEN_INT (xbitpos);\n \n \t  pat = gen_extzv (protect_from_queue (xtarget, 1),\n \t\t\t   xop0, bitsize_rtx, bitpos_rtx);\n@@ -1121,8 +1115,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t (xtarget, maxmode)))\n \t    xtarget = gen_reg_rtx (maxmode);\n \n-\t  bitsize_rtx = gen_rtx (CONST_INT, VOIDmode, bitsize);\n-\t  bitpos_rtx = gen_rtx (CONST_INT, VOIDmode, xbitpos);\n+\t  bitsize_rtx = GEN_INT (bitsize);\n+\t  bitpos_rtx = GEN_INT (xbitpos);\n \n \t  pat = gen_extv (protect_from_queue (xtarget, 1),\n \t\t\t  xop0, bitsize_rtx, bitpos_rtx);\n@@ -1327,23 +1321,25 @@ mask_rtx (mode, bitpos, bitsize, complement)\n      enum machine_mode mode;\n      int bitpos, bitsize, complement;\n {\n-  int masklow, maskhigh;\n+  HOST_WIDE_INT masklow, maskhigh;\n \n-  if (bitpos < HOST_BITS_PER_INT)\n-    masklow = -1 << bitpos;\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+    masklow = (HOST_WIDE_INT) -1 << bitpos;\n   else\n     masklow = 0;\n \n-  if (bitpos + bitsize < HOST_BITS_PER_INT)\n-    masklow &= (unsigned) -1 >> (HOST_BITS_PER_INT - bitpos - bitsize);\n+  if (bitpos + bitsize < HOST_BITS_PER_WIDE_INT)\n+    masklow &= ((unsigned HOST_WIDE_INT) -1\n+\t\t>> (HOST_BITS_PER_WIDE_INT - bitpos - bitsize));\n   \n-  if (bitpos <= HOST_BITS_PER_INT)\n+  if (bitpos <= HOST_BITS_PER_WIDE_INT)\n     maskhigh = -1;\n   else\n-    maskhigh = -1 << (bitpos - HOST_BITS_PER_INT);\n+    maskhigh = (HOST_WIDE_INT) -1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n \n-  if (bitpos + bitsize > HOST_BITS_PER_INT)\n-    maskhigh &= (unsigned) -1 >> (2 * HOST_BITS_PER_INT - bitpos - bitsize);\n+  if (bitpos + bitsize > HOST_BITS_PER_WIDE_INT)\n+    maskhigh &= ((unsigned HOST_WIDE_INT) -1\n+\t\t >> (2 * HOST_BITS_PER_WIDE_INT - bitpos - bitsize));\n   else\n     maskhigh = 0;\n \n@@ -1365,21 +1361,21 @@ lshift_value (mode, value, bitpos, bitsize)\n      rtx value;\n      int bitpos, bitsize;\n {\n-  unsigned v = INTVAL (value);\n-  int low, high;\n+  unsigned HOST_WIDE_INT v = INTVAL (value);\n+  HOST_WIDE_INT low, high;\n \n-  if (bitsize < HOST_BITS_PER_INT)\n-    v &= ~(-1 << bitsize);\n+  if (bitsize < HOST_BITS_PER_WIDE_INT)\n+    v &= ~((HOST_WIDE_INT) -1 << bitsize);\n \n-  if (bitpos < HOST_BITS_PER_INT)\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n     {\n       low = v << bitpos;\n-      high = (bitpos > 0 ? (v >> (HOST_BITS_PER_INT - bitpos)) : 0);\n+      high = (bitpos > 0 ? (v >> (HOST_BITS_PER_WIDE_INT - bitpos)) : 0);\n     }\n   else\n     {\n       low = 0;\n-      high = v << (bitpos - HOST_BITS_PER_INT);\n+      high = v << (bitpos - HOST_BITS_PER_WIDE_INT);\n     }\n \n   return immed_double_const (low, high, mode);\n@@ -1417,7 +1413,8 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n \t  : operand_subword_force (op0, offset, GET_MODE (op0)));\n   part1 = extract_fixed_bit_field (word_mode, word,\n \t\t\t\t   GET_CODE (op0) == MEM ? offset : 0,\n-\t\t\t\t   bitsize_1, bitpos % unit, 0, 1, align);\n+\t\t\t\t   bitsize_1, bitpos % unit, NULL_RTX,\n+\t\t\t\t   1, align);\n \n   /* Offset op0 by 1 word to get to the following one.  */\n   if (GET_CODE (op0) == SUBREG)\n@@ -1433,7 +1430,7 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n \t\t\t\t   (GET_CODE (op0) == MEM\n \t\t\t\t    ? CEIL (offset + 1, UNITS_PER_WORD) * UNITS_PER_WORD\n \t\t\t\t    : 0),\n-\t\t\t\t   bitsize_2, 0, 0, 1, align);\n+\t\t\t\t   bitsize_2, 0, NULL_RTX, 1, align);\n \n   /* Shift the more significant part up to fit above the other part.  */\n #if BYTES_BIG_ENDIAN\n@@ -1446,17 +1443,18 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n \n   /* Combine the two parts with bitwise or.  This works\n      because we extracted both parts as unsigned bit fields.  */\n-  result = expand_binop (word_mode, ior_optab, part1, part2, 0, 1,\n+  result = expand_binop (word_mode, ior_optab, part1, part2, NULL_RTX, 1,\n \t\t\t OPTAB_LIB_WIDEN);\n \n   /* Unsigned bit field: we are done.  */\n   if (unsignedp)\n     return result;\n   /* Signed bit field: sign-extend with two arithmetic shifts.  */\n   result = expand_shift (LSHIFT_EXPR, word_mode, result,\n-\t\t\t build_int_2 (BITS_PER_WORD - bitsize, 0), 0, 0);\n+\t\t\t build_int_2 (BITS_PER_WORD - bitsize, 0),\n+\t\t\t NULL_RTX, 0);\n   return expand_shift (RSHIFT_EXPR, word_mode, result,\n-\t\t       build_int_2 (BITS_PER_WORD - bitsize, 0), 0, 0);\n+\t\t       build_int_2 (BITS_PER_WORD - bitsize, 0), NULL_RTX, 0);\n }\n \f\n /* Add INC into TARGET.  */\n@@ -1510,7 +1508,7 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n      and shifted in the other direction; but that does not work\n      on all machines.  */\n \n-  op1 = expand_expr (amount, 0, VOIDmode, 0);\n+  op1 = expand_expr (amount, NULL_RTX, VOIDmode, 0);\n \n   if (op1 == const0_rtx)\n     return shifted;\n@@ -1624,18 +1622,16 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \t      /* WIDTH gets the width of the bit field to extract:\n \t\t wordsize minus # bits to shift by.  */\n \t      if (GET_CODE (xop1) == CONST_INT)\n-\t\twidth = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t (GET_MODE_BITSIZE (mode) - INTVAL (op1)));\n+\t\twidth = GEN_INT (GET_MODE_BITSIZE (mode) - INTVAL (op1));\n \t      else\n \t\t{\n \t\t  /* Now get the width in the proper mode.  */\n \t\t  width = convert_to_mode (length_mode, op1,\n \t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (amount)));\n \n \t\t  width = expand_binop (length_mode, sub_optab,\n-\t\t\t\t\tgen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t GET_MODE_BITSIZE (mode)),\n-\t\t\t\t\twidth, 0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t\tGEN_INT (GET_MODE_BITSIZE (mode)),\n+\t\t\t\t\twidth, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t\t}\n \n \t      /* If this machine's extzv insists on a register for\n@@ -1700,13 +1696,15 @@ struct algorithm\n \n static struct algorithm\n synth_mult (t, add_cost, shift_cost, max_cost)\n-     unsigned int t;\n+     unsigned HOST_WIDE_INT t;\n      int add_cost, shift_cost;\n      int max_cost;\n {\n   int m, n;\n-  struct algorithm *best_alg = (struct algorithm *)alloca (sizeof (struct algorithm));\n-  struct algorithm *alg_in = (struct algorithm *)alloca (sizeof (struct algorithm));\n+  struct algorithm *best_alg\n+    = (struct algorithm *)alloca (sizeof (struct algorithm));\n+  struct algorithm *alg_in\n+    = (struct algorithm *)alloca (sizeof (struct algorithm));\n   unsigned int cost;\n \n   /* No matter what happens, we want to return a valid algorithm.  */\n@@ -1756,13 +1754,13 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n \n   for (m = floor_log2 (t) - 1; m >= 2; m--)\n     {\n-      int m_exp_2 = 1 << m;\n-      int d;\n+      HOST_WIDE_INT m_exp_2 = (HOST_WIDE_INT) 1 << m;\n+      HOST_WIDE_INT d;\n \n       d = m_exp_2 + 1;\n       if (t % d == 0)\n \t{\n-\t  int q = t / d;\n+\t  HOST_WIDE_INT q = t / d;\n \n \t  cost = add_cost + shift_cost * 2;\n \n@@ -1791,7 +1789,7 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n       d = m_exp_2 - 1;\n       if (t % d == 0)\n \t{\n-\t  int q = t / d;\n+\t  HOST_WIDE_INT q = t / d;\n \n \t  cost = add_cost + shift_cost * 2;\n \n@@ -1821,8 +1819,8 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n   /* Try load effective address instructions, i.e. do a*3, a*5, a*9.  */\n \n   {\n-    int q;\n-    int w;\n+    HOST_WIDE_INT q;\n+    HOST_WIDE_INT w;\n \n     q = t & -t;\t\t\t/* get out lsb */\n     w = (t - q) & -(t - q);\t/* get out next lsb */\n@@ -1861,8 +1859,8 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n      1-bit.  */\n \n   {\n-    int q;\n-    int w;\n+    HOST_WIDE_INT q;\n+    HOST_WIDE_INT w;\n \n     q = t & -t;\t\t\t/* get out lsb */\n     for (w = q; (w & t) != 0; w <<= 1)\n@@ -1958,7 +1956,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n     {\n       if ((CONST_DOUBLE_HIGH (op1) == 0 && CONST_DOUBLE_LOW (op1) >= 0)\n \t  || (CONST_DOUBLE_HIGH (op1) == -1 && CONST_DOUBLE_LOW (op1) < 0))\n-\tconst_op1 = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (op1));\n+\tconst_op1 = GEN_INT (CONST_DOUBLE_LOW (op1));\n     }\n \n   /* We used to test optimize here, on the grounds that it's better to\n@@ -1970,7 +1968,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n       struct algorithm alg;\n       struct algorithm neg_alg;\n       int negate = 0;\n-      int absval = INTVAL (op1);\n+      HOST_WIDE_INT absval = INTVAL (op1);\n       rtx last;\n \n       /* Try to do the computation two ways: multiply by the negative of OP1\n@@ -2015,8 +2013,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t      if (alg.op[0] != alg_add)\n \t\tabort ();\n \t      accum = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t    build_int_2 (log, 0),\n-\t\t\t\t    0, 0);\n+\t\t\t\t    build_int_2 (log, 0), NULL_RTX, 0);\n \t    }\n    \n \t  while (++opno < alg.ops)\n@@ -2035,7 +2032,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t  if (factors_seen)\n \t\t    {\n \t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), 0, 0);\n+\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n \t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n \t\t\t\t\t     accum);\n \t\t    }\n@@ -2054,7 +2051,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t  if (factors_seen)\n \t\t    {\n \t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), 0, 0);\n+\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n \t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n \t\t\t\t\t     accum);\n \t\t    }\n@@ -2073,11 +2070,11 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\tcase alg_compound:\n \t\t  factors_seen = 1;\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t      build_int_2 (log, 0), 0, 0);\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n \n \t\t  log = floor_log2 (alg.coeff[opno + 1]);\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\tbuild_int_2 (log, 0), 0, 0);\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n \t\t  opno++;\n \t\t  if (alg.op[opno] == alg_add)\n \t\t    accum = force_operand (gen_rtx (PLUS, mode, tem, accum),\n@@ -2105,9 +2102,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t      REG_NOTES (last)\n \t\t= gen_rtx (EXPR_LIST, REG_EQUAL,\n \t\t\t   gen_rtx (MULT, mode, op0, \n-\t\t\t\t    negate ? gen_rtx (CONST_INT,\n-\t\t\t\t\t\t      VOIDmode, absval)\n-\t\t\t\t    : op1),\n+\t\t\t\t    negate ? GEN_INT (absval) : op1),\n \t\t\t   REG_NOTES (last));\n \t    }\n \n@@ -2285,7 +2280,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t which will screw up mem refs for autoincrements.  */\n \t      op0 = force_reg (compute_mode, op0);\n \t    }\n-\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, 0, compute_mode, 0, 0);\n+\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n+\t\t\t NULL_RTX, compute_mode, 0, 0);\n \t  emit_jump_insn (gen_bge (label));\n \t  expand_inc (adjusted_op0, plus_constant (op1, -1));\n \t  emit_label (label);\n@@ -2306,7 +2302,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t which will screw up mem refs for autoincrements.  */\n \t      op0 = force_reg (compute_mode, op0);\n \t    }\n-\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, 0, compute_mode, 0, 0);\n+\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n+\t\t\t NULL_RTX, compute_mode, 0, 0);\n \t  emit_jump_insn (gen_bge (label));\n \t  expand_dec (adjusted_op0, op1);\n \t  expand_inc (adjusted_op0, const1_rtx);\n@@ -2331,7 +2328,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  if (! unsignedp)\n \t    {\n \t      label = gen_label_rtx ();\n-\t      emit_cmp_insn (adjusted_op0, const0_rtx, LE, 0, compute_mode, 0, 0);\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, LE, \n+\t\t\t     NULL_RTX, compute_mode, 0, 0);\n \t      emit_jump_insn (gen_ble (label));\n \t    }\n \t  expand_inc (adjusted_op0, op1);\n@@ -2343,7 +2341,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t{\n \t  adjusted_op0 = expand_binop (compute_mode, add_optab,\n \t\t\t\t       adjusted_op0, plus_constant (op1, -1),\n-\t\t\t\t       0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t}\n       mod_insn_no_good = 1;\n       break;\n@@ -2361,11 +2359,12 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       if (log < 0)\n \t{\n \t  op1 = expand_shift (RSHIFT_EXPR, compute_mode, op1,\n-\t\t\t      integer_one_node, 0, 0);\n+\t\t\t      integer_one_node, NULL_RTX, 0);\n \t  if (! unsignedp)\n \t    {\n \t      rtx label = gen_label_rtx ();\n-\t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, 0, compute_mode, 0, 0);\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, NULL_RTX,\n+\t\t\t     compute_mode, 0, 0);\n \t      emit_jump_insn (gen_bge (label));\n \t      expand_unop (compute_mode, neg_optab, op1, op1, 0);\n \t      emit_label (label);\n@@ -2374,7 +2373,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t}\n       else\n \t{\n-\t  op1 = gen_rtx (CONST_INT, VOIDmode, (1 << log) / 2);\n+\t  op1 = GEN_INT (((HOST_WIDE_INT) 1 << log) / 2);\n \t  expand_inc (adjusted_op0, op1);\n \t}\n       mod_insn_no_good = 1;\n@@ -2386,8 +2385,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       /* Try to produce the remainder directly */\n       if (log >= 0)\n \tresult = expand_binop (compute_mode, and_optab, adjusted_op0,\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t(1 << log) - 1),\n+\t\t\t       GEN_INT (((HOST_WIDE_INT) 1 << log) - 1),\n \t\t\t       target, 1, OPTAB_LIB_WIDEN);\n       else\n \t{\n@@ -2403,7 +2401,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t      if (! expand_twoval_binop (unsignedp\n \t\t\t\t\t ? udivmod_optab : sdivmod_optab,\n \t\t\t\t\t adjusted_op0, op1,\n-\t\t\t\t\t 0, result, unsignedp))\n+\t\t\t\t\t NULL_RTX, result, unsignedp))\n \t\tresult = 0;\n \t    }\n \t}\n@@ -2421,12 +2419,14 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n        and a remainder subroutine would be ok,\n        don't use a divide subroutine.  */\n     result = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\tadjusted_op0, op1, 0, unsignedp, OPTAB_WIDEN);\n+\t\t\t\tadjusted_op0, op1, NULL_RTX, unsignedp,\n+\t\t\t\tOPTAB_WIDEN);\n   else\n     {\n       /* Try a quotient insn, but not a library call.  */\n       result = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\t  adjusted_op0, op1, rem_flag ? 0 : target,\n+\t\t\t\t  adjusted_op0, op1,\n+\t\t\t\t  rem_flag ? NULL_RTX : target,\n \t\t\t\t  unsignedp, OPTAB_WIDEN);\n       if (result == 0)\n \t{\n@@ -2435,14 +2435,15 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  result = gen_reg_rtx (mode);\n \t  if (! expand_twoval_binop (unsignedp ? udivmod_optab : sdivmod_optab,\n \t\t\t\t     adjusted_op0, op1,\n-\t\t\t\t     result, 0, unsignedp))\n+\t\t\t\t     result, NULL_RTX, unsignedp))\n \t    result = 0;\n \t}\n \n       /* If still no luck, use a library call.  */\n       if (result == 0)\n \tresult = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\t    adjusted_op0, op1, rem_flag ? 0 : target,\n+\t\t\t\t    adjusted_op0, op1,\n+\t\t\t\t    rem_flag ? NULL_RTX : target,\n \t\t\t\t    unsignedp, OPTAB_LIB_WIDEN);\n     }\n \n@@ -2611,7 +2612,7 @@ expand_and (op0, op1, target)\n   if (mode != VOIDmode)\n     tem = expand_binop (mode, and_optab, op0, op1, target, 0, OPTAB_LIB_WIDEN);\n   else if (GET_CODE (op0) == CONST_INT && GET_CODE (op1) == CONST_INT)\n-    tem = gen_rtx (CONST_INT, VOIDmode, INTVAL (op0) & INTVAL (op1));\n+    tem = GEN_INT (INTVAL (op0) & INTVAL (op1));\n   else\n     abort ();\n \n@@ -2697,8 +2698,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n   if (op1 == const0_rtx && (code == LT || code == GE)\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && (normalizep || STORE_FLAG_VALUE == 1\n-\t  || (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n-\t      && STORE_FLAG_VALUE == 1 << (GET_MODE_BITSIZE (mode) - 1))))\n+\t  || (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && (STORE_FLAG_VALUE \n+\t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))))\n     {\n       rtx subtarget = target;\n \n@@ -2742,7 +2744,8 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n       emit_queue ();\n       last = get_last_insn ();\n \n-      comparison = compare_from_rtx (op0, op1, code, unsignedp, mode, 0, 0);\n+      comparison\n+\t= compare_from_rtx (op0, op1, code, unsignedp, mode, NULL_RTX, 0);\n       if (GET_CODE (comparison) == CONST_INT)\n \treturn (comparison == const0_rtx ? const0_rtx\n \t\t: normalizep == 1 ? const1_rtx\n@@ -2773,9 +2776,10 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \t    {\n \t      convert_move (target, subtarget,\n \t\t\t    (GET_MODE_BITSIZE (compare_mode)\n-\t\t\t     <= HOST_BITS_PER_INT)\n+\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n \t\t\t    && 0 == (STORE_FLAG_VALUE\n-\t\t\t\t     & (1 << (GET_MODE_BITSIZE (compare_mode) -1))));\n+\t\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t\t<< (GET_MODE_BITSIZE (compare_mode) -1))));\n \t      op0 = target;\n \t      compare_mode = target_mode;\n \t    }\n@@ -2798,9 +2802,10 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \t  /* We don't want to use STORE_FLAG_VALUE < 0 below since this\n \t     makes it hard to use a value of just the sign bit due to\n \t     ANSI integer constant typing rules.  */\n-\t  else if (GET_MODE_BITSIZE (compare_mode) <= HOST_BITS_PER_INT\n+\t  else if (GET_MODE_BITSIZE (compare_mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && (STORE_FLAG_VALUE\n-\t\t       & (1 << (GET_MODE_BITSIZE (compare_mode) - 1))))\n+\t\t       & ((HOST_WIDE_INT) 1\n+\t\t\t  << (GET_MODE_BITSIZE (compare_mode) - 1))))\n \t    op0 = expand_shift (RSHIFT_EXPR, compare_mode, op0,\n \t\t\t\tsize_int (GET_MODE_BITSIZE (compare_mode) - 1),\n \t\t\t\tsubtarget, normalizep == 1);\n@@ -2874,8 +2879,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n       if (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \tnormalizep = STORE_FLAG_VALUE;\n \n-      else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n-\t       && STORE_FLAG_VALUE == 1 << (GET_MODE_BITSIZE (mode) - 1))\n+      else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t       && (STORE_FLAG_VALUE\n+\t\t   == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n \t;\n       else\n \treturn 0;"}, {"sha": "a96d3efd593fa45cb3ba91cea4670e8edb635a90", "filename": "gcc/global.c", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "patch": "@@ -96,14 +96,21 @@ static int *allocno_size;\n \n static int *reg_may_share;\n \n+/* Define the number of bits in each element of `conflicts' and what\n+   type that element has.  We use the largest integer format on the\n+   host machine.  */\n+\n+#define INT_BITS HOST_BITS_PER_WIDE_INT\n+#define INT_TYPE HOST_WIDE_INT\n+\n /* max_allocno by max_allocno array of bits,\n    recording whether two allocno's conflict (can't go in the same\n    hardware register).\n \n    `conflicts' is not symmetric; a conflict between allocno's i and j\n    is recorded either in element i,j or in element j,i.  */\n \n-static int *conflicts;\n+static INT_TYPE *conflicts;\n \n /* Number of ints require to hold max_allocno bits.\n    This is the length of a row in `conflicts'.  */\n@@ -114,11 +121,11 @@ static int allocno_row_words;\n \n #define CONFLICTP(I, J) \\\n  (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n-  & (1 << ((J) % INT_BITS)))\n+  & ((INT_TYPE) 1 << ((J) % INT_BITS)))\n \n #define SET_CONFLICT(I, J) \\\n  (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n-  |= (1 << ((J) % INT_BITS)))\n+  |= ((INT_TYPE) 1 << ((J) % INT_BITS)))\n \n /* Set of hard regs currently live (during scan of all insns).  */\n \n@@ -194,21 +201,19 @@ static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n \n /* Bit mask for allocnos live at current point in the scan.  */\n \n-static int *allocnos_live;\n-\n-#define INT_BITS HOST_BITS_PER_INT\n+static INT_TYPE *allocnos_live;\n \n /* Test, set or clear bit number I in allocnos_live,\n    a bit vector indexed by allocno.  */\n \n #define ALLOCNO_LIVE_P(I) \\\n-  (allocnos_live[(I) / INT_BITS] & (1 << ((I) % INT_BITS)))\n+  (allocnos_live[(I) / INT_BITS] & ((INT_TYPE) 1 << ((I) % INT_BITS)))\n \n #define SET_ALLOCNO_LIVE(I) \\\n-  (allocnos_live[(I) / INT_BITS] |= (1 << ((I) % INT_BITS)))\n+  (allocnos_live[(I) / INT_BITS] |= ((INT_TYPE) 1 << ((I) % INT_BITS)))\n \n #define CLEAR_ALLOCNO_LIVE(I) \\\n-  (allocnos_live[(I) / INT_BITS] &= ~(1 << ((I) % INT_BITS)))\n+  (allocnos_live[(I) / INT_BITS] &= ~((INT_TYPE) 1 << ((I) % INT_BITS)))\n \n /* This is turned off because it doesn't work right for DImode.\n    (And it is only used for DImode, so the other cases are worthless.)\n@@ -457,10 +462,12 @@ global_alloc (file)\n \n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n-  conflicts = (int *) alloca (max_allocno * allocno_row_words * sizeof (int));\n-  bzero (conflicts, max_allocno * allocno_row_words * sizeof (int));\n+  conflicts = (INT_TYPE *) alloca (max_allocno * allocno_row_words\n+\t\t\t\t   * sizeof (INT_TYPE));\n+  bzero (conflicts, max_allocno * allocno_row_words\n+\t * sizeof (INT_TYPE));\n \n-  allocnos_live = (int *) alloca (allocno_row_words * sizeof (int));\n+  allocnos_live = (INT_TYPE *) alloca (allocno_row_words * sizeof (INT_TYPE));\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n@@ -534,7 +541,7 @@ global_alloc (file)\n \t\tif (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n \t\t  continue;\n \t      }\n-\t    if (!reg_preferred_or_nothing (allocno_reg[allocno_order[i]]))\n+\t    if (reg_alternate_class (allocno_reg[allocno_order[i]]) != NO_REGS)\n \t      find_reg (allocno_order[i], HARD_CONST (0), 1, 0, 0);\n \t  }\n     }\n@@ -593,7 +600,7 @@ global_conflicts ()\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n-      bzero (allocnos_live, allocno_row_words * sizeof (int));\n+      bzero (allocnos_live, allocno_row_words * sizeof (INT_TYPE));\n \n       /* Initialize table of registers currently live\n \t to the state at the beginning of this basic block.\n@@ -609,7 +616,8 @@ global_conflicts ()\n \t are explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregister int offset, bit;\n+\tregister int offset;\n+\tREGSET_ELT_TYPE bit;\n \tregister regset old = basic_block_live_at_start[b];\n \tint ax = 0;\n \n@@ -620,7 +628,7 @@ global_conflicts ()\n #endif\n \tfor (offset = 0, i = 0; offset < regset_size; offset++)\n \t  if (old[offset] == 0)\n-\t    i += HOST_BITS_PER_INT;\n+\t    i += REGSET_ELT_BITS;\n \t  else\n \t    for (bit = 1; bit; bit <<= 1, i++)\n \t      {\n@@ -699,7 +707,7 @@ global_conflicts ()\n #ifdef AUTO_INC_DEC\n \t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_INC)\n-\t\t  mark_reg_store (XEXP (link, 0), 0);\n+\t\t  mark_reg_store (XEXP (link, 0), NULL_RTX);\n #endif\n \n \t      /* If INSN has multiple outputs, then any reg that dies here\n@@ -857,8 +865,8 @@ prune_preferences ()\n    LOSERS, if non-zero, is a HARD_REG_SET indicating registers that cannot\n    be used for this allocation.\n \n-   If ALL_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.\n-   Otherwise ignore that preferred class.\n+   If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.\n+   Otherwise ignore that preferred class and use the alternate class.\n \n    If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that\n    will have to be saved and restored at calls.\n@@ -869,10 +877,10 @@ prune_preferences ()\n    If not, do nothing.  */\n \n static void\n-find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n+find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n      int allocno;\n      HARD_REG_SET losers;\n-     int all_regs_p;\n+     int alt_regs_p;\n      int accept_call_clobbered;\n      int retrying;\n {\n@@ -882,8 +890,9 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n #endif\n     HARD_REG_SET used, used1, used2;\n \n-  enum reg_class class \n-    = all_regs_p ? ALL_REGS : reg_preferred_class (allocno_reg[allocno]);\n+  enum reg_class class = (alt_regs_p\n+\t\t\t  ? reg_alternate_class (allocno_reg[allocno])\n+\t\t\t  : reg_preferred_class (allocno_reg[allocno]));\n   enum machine_mode mode = PSEUDO_REGNO_MODE (allocno_reg[allocno]);\n \n   if (accept_call_clobbered)\n@@ -1042,7 +1051,7 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n \t  && CALLER_SAVE_PROFITABLE (allocno_n_refs[allocno],\n \t\t\t\t     allocno_calls_crossed[allocno]))\n \t{\n-\t  find_reg (allocno, losers, all_regs_p, 1, retrying);\n+\t  find_reg (allocno, losers, alt_regs_p, 1, retrying);\n \t  if (reg_renumber[allocno_reg[allocno]] >= 0)\n \t    {\n \t      caller_save_needed = 1;\n@@ -1146,7 +1155,7 @@ retry_global_alloc (regno, forbidden_regs)\n       if (N_REG_CLASSES > 1)\n \tfind_reg (allocno, forbidden_regs, 0, 0, 1);\n       if (reg_renumber[regno] < 0\n-\t  && !reg_preferred_or_nothing (regno))\n+\t  && reg_alternate_class (regno) != NO_REGS)\n \tfind_reg (allocno, forbidden_regs, 1, 0, 1);\n \n       /* If we found a register, modify the RTL for the register to\n@@ -1563,13 +1572,13 @@ mark_elimination (from, to)\n   int i;\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    if ((basic_block_live_at_start[i][from / HOST_BITS_PER_INT]\n-\t & (1 << (from % HOST_BITS_PER_INT))) != 0)\n+    if ((basic_block_live_at_start[i][from / REGSET_ELT_BITS]\n+\t & ((REGSET_ELT_TYPE) 1 << (from % REGSET_ELT_BITS))) != 0)\n       {\n-\tbasic_block_live_at_start[i][from / HOST_BITS_PER_INT]\n-\t  &= ~ (1 << (from % HOST_BITS_PER_INT));\n-\tbasic_block_live_at_start[i][to / HOST_BITS_PER_INT]\n-\t  |= (1 << (to % HOST_BITS_PER_INT));\n+\tbasic_block_live_at_start[i][from / REGSET_ELT_BITS]\n+\t  &= ~ ((REGSET_ELT_TYPE) 1 << (from % REGSET_ELT_BITS));\n+\tbasic_block_live_at_start[i][to / REGSET_ELT_BITS]\n+\t  |= ((REGSET_ELT_TYPE) 1 << (to % REGSET_ELT_BITS));\n       }\n }\n \f"}, {"sha": "effde39d03a25c5a7d254179f4acad68e330ca59", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "patch": "@@ -922,7 +922,7 @@ update_equiv_regs ()\n \t  || reg_n_sets[regno] != 1)\n \tcontinue;\n \n-      note = find_reg_note (insn, REG_EQUAL, 0);\n+      note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n       /* Record this insn as initializing this register.  */\n       reg_equiv_init_insn[regno] = insn;\n@@ -947,7 +947,7 @@ update_equiv_regs ()\n \t MEM remains unchanged for the life of the register, add a REG_EQUIV\n \t note.  */\n \t \n-      note = find_reg_note (insn, REG_EQUIV, 0);\n+      note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \n       if (note == 0 && reg_basic_block[regno] >= 0\n \t  && GET_CODE (SET_SRC (set)) == MEM\n@@ -1155,11 +1155,12 @@ block_alloc (b)\n \t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n \t      && (r0 = XEXP (PATTERN (insn), 0),\n \t\t  GET_CODE (r0) == REG)\n-\t      && (link = find_reg_note (insn, REG_LIBCALL, 0)) != 0\n+\t      && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n \t      && GET_CODE (XEXP (link, 0)) == INSN\n \t      && (set = single_set (XEXP (link, 0))) != 0\n \t      && SET_DEST (set) == r0 && SET_SRC (set) == r0\n-\t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL, 0)) != 0)\n+\t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL,\n+\t\t\t\t\tNULL_RTX)) != 0)\n \t    {\n \t      if (r1 = XEXP (note, 0), GET_CODE (r1) == REG\n \t\t  /* Check that we have such a sequence.  */\n@@ -1245,7 +1246,7 @@ block_alloc (b)\n \t  /* If this is an insn that has a REG_RETVAL note pointing at a \n \t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n \t     block, so clear any register number that combined within it.  */\n-\t  if ((note = find_reg_note (insn, REG_RETVAL, 0)) != 0\n+\t  if ((note = find_reg_note (insn, REG_RETVAL, NULL_RTX)) != 0\n \t      && GET_CODE (XEXP (note, 0)) == INSN\n \t      && GET_CODE (PATTERN (XEXP (note, 0))) == CLOBBER)\n \t    no_conflict_combined_regno = -1;\n@@ -1988,7 +1989,7 @@ no_conflict_p (insn, r0, r1)\n      rtx insn, r0, r1;\n {\n   int ok = 0;\n-  rtx note = find_reg_note (insn, REG_LIBCALL, 0);\n+  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n   rtx p, last;\n \n   /* If R1 is a hard register, return 0 since we handle this case"}, {"sha": "65c95d48da4f8518749bca49f1637148ec3dad2f", "filename": "gcc/optabs.c", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ec3c92629621146e4c7e1e1b2341c5326e1b73/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "patch": "@@ -402,8 +402,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      && ! add_equal_note (pat, temp, binoptab->code, xop0, xop1))\n \t    {\n \t      delete_insns_since (last);\n-\t      return expand_binop (mode, binoptab, op0, op1, 0, unsignedp,\n-\t\t\t\t   methods);\n+\t      return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n+\t\t\t\t   unsignedp, methods);\n \t    }\n \n \t  emit_insn (pat);\n@@ -454,7 +454,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    else\n \t      xop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n \n-\t    temp = expand_binop (wider_mode, binoptab, xop0, xop1, 0,\n+\t    temp = expand_binop (wider_mode, binoptab, xop0, xop1, NULL_RTX,\n \t\t\t\t unsignedp, OPTAB_DIRECT);\n \t    if (temp)\n \t      {\n@@ -711,33 +711,33 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  && smul_widen_optab->handlers[(int) mode].insn_code\n \t       != CODE_FOR_nothing)\n \t{\n-\t  rtx wordm1 = gen_rtx (CONST_INT, VOIDmode, BITS_PER_WORD - 1);\n+\t  rtx wordm1 = GEN_INT (BITS_PER_WORD - 1);\n \t  product = expand_binop (mode, smul_widen_optab, op0_low, op1_low,\n \t\t\t\t  target, 1, OPTAB_DIRECT);\n \t  op0_xhigh = expand_binop (word_mode, lshr_optab, op0_low, wordm1,\n-\t\t\t\t    0, 1, OPTAB_DIRECT);\n+\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n \t  if (op0_xhigh)\n \t    op0_xhigh = expand_binop (word_mode, add_optab, op0_high,\n \t\t\t\t      op0_xhigh, op0_xhigh, 0, OPTAB_DIRECT);\n \t  else\n \t    {\n \t      op0_xhigh = expand_binop (word_mode, ashr_optab, op0_low, wordm1,\n-\t\t\t\t\t0, 0, OPTAB_DIRECT);\n+\t\t\t\t\tNULL_RTX, 0, OPTAB_DIRECT);\n \t      if (op0_xhigh)\n \t\top0_xhigh = expand_binop (word_mode, sub_optab, op0_high,\n \t\t\t\t\t  op0_xhigh, op0_xhigh, 0,\n \t\t\t\t\t  OPTAB_DIRECT);\n \t    }\n \n \t  op1_xhigh = expand_binop (word_mode, lshr_optab, op1_low, wordm1,\n-\t\t\t\t    0, 1, OPTAB_DIRECT);\n+\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n \t  if (op1_xhigh)\n \t    op1_xhigh = expand_binop (word_mode, add_optab, op1_high,\n \t\t\t\t      op1_xhigh, op1_xhigh, 0, OPTAB_DIRECT);\n \t  else\n \t    {\n \t      op1_xhigh = expand_binop (word_mode, ashr_optab, op1_low, wordm1,\n-\t\t\t\t\t0, 0, OPTAB_DIRECT);\n+\t\t\t\t\tNULL_RTX, 0, OPTAB_DIRECT);\n \t      if (op1_xhigh)\n \t\top1_xhigh = expand_binop (word_mode, sub_optab, op1_high,\n \t\t\t\t\t  op1_xhigh, op1_xhigh, 0,\n@@ -759,8 +759,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t{\n \t  rtx product_piece;\n \t  rtx product_high = operand_subword (product, high, 1, mode);\n-\t  rtx temp = expand_binop (word_mode, binoptab, op0_low, op1_xhigh, 0,\n-\t\t\t\t   0, OPTAB_DIRECT);\n+\t  rtx temp = expand_binop (word_mode, binoptab, op0_low, op1_xhigh,\n+\t\t\t\t   NULL_RTX, 0, OPTAB_DIRECT);\n \n \t  if (temp)\n \t    {\n@@ -770,8 +770,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      if (product_piece != product_high)\n \t\temit_move_insn (product_high, product_piece);\n \n-\t      temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, 0,\n-\t\t\t\t   0, OPTAB_DIRECT);\n+\t      temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, \n+\t\t\t\t   NULL_RTX, 0, OPTAB_DIRECT);\n \n \t      product_piece = expand_binop (word_mode, add_optab, temp,\n \t\t\t\t\t    product_high, product_high,\n@@ -879,7 +879,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      else\n \t\txop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n \n-\t      temp = expand_binop (wider_mode, binoptab, xop0, xop1, 0,\n+\t      temp = expand_binop (wider_mode, binoptab, xop0, xop1, NULL_RTX,\n \t\t\t\t   unsignedp, methods);\n \t      if (temp)\n \t\t{\n@@ -1152,10 +1152,10 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       if (pat)\n \t{\n \t  if (GET_CODE (pat) == SEQUENCE\n-\t      && ! add_equal_note (pat, temp, unoptab->code, xop0, 0))\n+\t      && ! add_equal_note (pat, temp, unoptab->code, xop0, NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n-\t      return expand_unop (mode, unoptab, op0, 0, unsignedp);\n+\t      return expand_unop (mode, unoptab, op0, NULL_RTX, unsignedp);\n \t    }\n \n \t  emit_insn (pat);\n@@ -1186,7 +1186,8 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t    else\n \t      xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n \t      \n-\t    temp = expand_unop (wider_mode, unoptab, xop0, 0, unsignedp);\n+\t    temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n+\t\t\t\tunsignedp);\n \n \t    if (temp)\n \t      {\n@@ -1233,7 +1234,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, target, op0, 0,\n+      emit_no_conflict_block (insns, target, op0, NULL_RTX,\n \t\t\t      gen_rtx (unoptab->code, mode, op0));\n       return target;\n     }\n@@ -1282,7 +1283,8 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t      else\n \t\txop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n \t      \n-\t      temp = expand_unop (wider_mode, unoptab, xop0, 0, unsignedp);\n+\t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n+\t\t\t\t  unsignedp);\n \n \t      if (temp)\n \t\t{\n@@ -1341,7 +1343,7 @@ emit_unop_insn (icode, target, op0, code)\n   pat = GEN_FCN (icode) (temp, op0);\n \n   if (GET_CODE (pat) == SEQUENCE && code != UNKNOWN)\n-    add_equal_note (pat, temp, code, op0, 0);\n+    add_equal_note (pat, temp, code, op0, NULL_RTX);\n   \n   emit_insn (pat);\n \n@@ -1645,9 +1647,9 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t  enum machine_mode result_mode\n \t    = insn_operand_mode[(int) CODE_FOR_cmpstrqi][0];\n \t  rtx result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpstrqi (result, x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, 0, result_mode, 0, 0);\n+\t  emit_insn (gen_cmpstrqi (result, x, y, size, GEN_INT (align)));\n+\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n+\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n@@ -1659,9 +1661,9 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t  enum machine_mode result_mode\n \t    = insn_operand_mode[(int) CODE_FOR_cmpstrhi][0];\n \t  rtx result = gen_reg_rtx (result_mode);\n-\t  emit_insn (gen_cmpstrhi (result, x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, 0, result_mode, 0, 0);\n+\t  emit_insn (gen_cmpstrhi (result, x, y, size, GEN_INT (align)));\n+\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n+\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n@@ -1673,8 +1675,9 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t  rtx result = gen_reg_rtx (result_mode);\n \t  emit_insn (gen_cmpstrsi (result, x, y,\n \t\t\t\t   convert_to_mode (SImode, size, 1),\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align)));\n-\t  emit_cmp_insn (result, const0_rtx, comparison, 0, result_mode, 0, 0);\n+\t\t\t\t   GEN_INT (align)));\n+\t  emit_cmp_insn (result, const0_rtx, comparison, NULL_RTX,\n+\t\t\t result_mode, 0, 0);\n \t}\n       else\n #endif\n@@ -1691,7 +1694,7 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t\t\t     size, Pmode);\n #endif\n \t  emit_cmp_insn (hard_libcall_value (TYPE_MODE (integer_type_node)),\n-\t\t\t const0_rtx, comparison, 0,\n+\t\t\t const0_rtx, comparison, NULL_RTX,\n \t\t\t TYPE_MODE (integer_type_node), 0, 0);\n \t}\n       return;\n@@ -1752,7 +1755,7 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t    {\n \t      x = convert_to_mode (wider_mode, x, unsignedp);\n \t      y = convert_to_mode (wider_mode, y, unsignedp);\n-\t      emit_cmp_insn (x, y, comparison, 0,\n+\t      emit_cmp_insn (x, y, comparison, NULL_RTX,\n \t\t\t     wider_mode, unsignedp, align);\n \t      return;\n \t    }\n@@ -1778,7 +1781,7 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \t there is still a value that can represent the result \"less than\".  */\n \n       emit_cmp_insn (hard_libcall_value (SImode), const1_rtx,\n-\t\t     comparison, 0, SImode, unsignedp, 0);\n+\t\t     comparison, NULL_RTX, SImode, unsignedp, 0);\n       return;\n     }\n \n@@ -1949,7 +1952,7 @@ emit_float_lib_cmp (x, y, comparison)\n \t\t     SImode, 2, x, mode, y, mode);\n \n   emit_cmp_insn (hard_libcall_value (SImode), const0_rtx, comparison,\n-\t\t 0, SImode, 0, 0);\n+\t\t NULL_RTX, SImode, 0, 0);\n }\n \f\n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n@@ -2866,7 +2869,7 @@ expand_float (to, from, unsignedp)\n \t correct its value by 2**bitwidth.  */\n \n       do_pending_stack_adjust ();\n-      emit_cmp_insn (from, const0_rtx, GE, 0, GET_MODE (from), 0, 0);\n+      emit_cmp_insn (from, const0_rtx, GE, NULL_RTX, GET_MODE (from), 0, 0);\n       emit_jump_insn (gen_bge (label));\n       /* On SCO 3.2.1, ldexp rejects values outside [0.5, 1).\n \t Rather than setting up a dconst_dot_5, let's hope SCO\n@@ -3039,7 +3042,7 @@ expand_fix (to, from, unsignedp)\n      We only need to check all real modes, since we know we didn't find\n      anything with a wider integer mode.  */\n \n-  if (unsignedp && GET_MODE_BITSIZE (GET_MODE (to)) <= HOST_BITS_PER_INT)\n+  if (unsignedp && GET_MODE_BITSIZE (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n     for (fmode = GET_MODE (from); fmode != VOIDmode;\n \t fmode = GET_MODE_WIDER_MODE (fmode))\n       /* Make sure we won't lose significant bits doing this.  */\n@@ -3066,7 +3069,7 @@ expand_fix (to, from, unsignedp)\n \n \t  /* See if we need to do the subtraction.  */\n \t  do_pending_stack_adjust ();\n-\t  emit_cmp_insn (from, limit, GE, 0, GET_MODE (from), 0, 0);\n+\t  emit_cmp_insn (from, limit, GE, NULL_RTX, GET_MODE (from), 0, 0);\n \t  emit_jump_insn (gen_bge (lab1));\n \n \t  /* If not, do the signed \"fix\" and branch around fixup code.  */\n@@ -3079,11 +3082,10 @@ expand_fix (to, from, unsignedp)\n \t     will often generate better code.  */\n \t  emit_label (lab1);\n \t  target = expand_binop (GET_MODE (from), sub_optab, from, limit,\n-\t\t\t\t 0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  expand_fix (to, target, 0);\n \t  target = expand_binop (GET_MODE (to), xor_optab, to,\n-\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t1 << (bitsize - 1)),\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1 << (bitsize - 1)),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n \n \t  if (target != to)"}]}