{"sha": "5f446d2172c1ca3e776b91a40127de9efa2f62d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY0NDZkMjE3MmMxY2EzZTc3NmI5MWE0MDEyN2RlOWVmYTJmNjJkOQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2000-12-21T18:20:39Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2000-12-21T18:20:39Z"}, "message": "dwarf2out.c (simple_decl_align_in_bits): new\n\n* dwarf2out.c (simple_decl_align_in_bits): new\n(field_byte_offset): Try both the type align and the\ndecl align, use whichever works, preferring the type align.\n\nFrom-SVN: r38418", "tree": {"sha": "a1dbf48a966f8cd302df3cefa573d9905b403e4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1dbf48a966f8cd302df3cefa573d9905b403e4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f446d2172c1ca3e776b91a40127de9efa2f62d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f446d2172c1ca3e776b91a40127de9efa2f62d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f446d2172c1ca3e776b91a40127de9efa2f62d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f446d2172c1ca3e776b91a40127de9efa2f62d9/comments", "author": null, "committer": null, "parents": [{"sha": "477f6664a4b1316583e5a71f0edd30faefeeaab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477f6664a4b1316583e5a71f0edd30faefeeaab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477f6664a4b1316583e5a71f0edd30faefeeaab5"}], "stats": {"total": 49, "additions": 36, "deletions": 13}, "files": [{"sha": "4ebc22007f00e5e6d9d767cc11ebdee8269af957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f446d2172c1ca3e776b91a40127de9efa2f62d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f446d2172c1ca3e776b91a40127de9efa2f62d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f446d2172c1ca3e776b91a40127de9efa2f62d9", "patch": "@@ -1,3 +1,9 @@\n+2000-12-21  DJ Delorie  <dj@redhat.com>\n+\n+\t* dwarf2out.c (simple_decl_align_in_bits): new\n+\t(field_byte_offset): Try both the type align and the\n+\tdecl align, use whichever works, preferring the type align.\n+\n 2000-12-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gccbug.in: Fix typo."}, {"sha": "39d76b246182268de1810fc42bb6214ee36579c5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f446d2172c1ca3e776b91a40127de9efa2f62d9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f446d2172c1ca3e776b91a40127de9efa2f62d9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5f446d2172c1ca3e776b91a40127de9efa2f62d9", "patch": "@@ -3460,6 +3460,7 @@ static dw_loc_descr_ref loc_descriptor_from_tree PARAMS ((tree, int));\n static HOST_WIDE_INT ceiling\t\tPARAMS ((HOST_WIDE_INT, unsigned int));\n static tree field_type\t\t\tPARAMS ((tree));\n static unsigned int simple_type_align_in_bits PARAMS ((tree));\n+static unsigned int simple_decl_align_in_bits PARAMS ((tree));\n static unsigned HOST_WIDE_INT simple_type_size_in_bits PARAMS ((tree));\n static HOST_WIDE_INT field_byte_offset\tPARAMS ((tree));\n static void add_AT_location_description\tPARAMS ((dw_die_ref,\n@@ -8050,10 +8051,9 @@ field_type (decl)\n   return type;\n }\n \n-/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE\n-   node, return the alignment in bits for the type, or else return\n-   BITS_PER_WORD if the node actually turns out to be an\n-   ERROR_MARK node.  */\n+/* Given a pointer to a tree node, return the alignment in bits for\n+   it, or else return BITS_PER_WORD if the node actually turns out to\n+   be an ERROR_MARK node.  */\n \n static inline unsigned\n simple_type_align_in_bits (type)\n@@ -8062,6 +8062,13 @@ simple_type_align_in_bits (type)\n   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n }\n \n+static inline unsigned\n+simple_decl_align_in_bits (decl)\n+     register tree decl;\n+{\n+  return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;\n+}\n+\n /* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE\n    node, return the size in bits for the type if it is a constant, or else\n    return the alignment for the type if the type's size is not constant, or\n@@ -8096,10 +8103,9 @@ static HOST_WIDE_INT\n field_byte_offset (decl)\n      register tree decl;\n {\n-  unsigned int type_align_in_bytes;\n   unsigned int type_align_in_bits;\n+  unsigned int decl_align_in_bits;\n   unsigned HOST_WIDE_INT type_size_in_bits;\n-  HOST_WIDE_INT object_offset_in_align_units;\n   HOST_WIDE_INT object_offset_in_bits;\n   HOST_WIDE_INT object_offset_in_bytes;\n   tree type;\n@@ -8138,7 +8144,7 @@ field_byte_offset (decl)\n \n   type_size_in_bits = simple_type_size_in_bits (type);\n   type_align_in_bits = simple_type_align_in_bits (type);\n-  type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n+  decl_align_in_bits = simple_decl_align_in_bits (decl);\n \n   /* Note that the GCC front-end doesn't make any attempt to keep track of\n      the starting bit offset (relative to the start of the containing\n@@ -8185,14 +8191,25 @@ field_byte_offset (decl)\n \n   /* This is the tricky part.  Use some fancy footwork to deduce where the\n      lowest addressed bit of the containing object must be.  */\n-  object_offset_in_bits\n-    = ceiling (deepest_bitpos, type_align_in_bits) - type_size_in_bits;\n+  object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n+\n+  /* Round up to type_align by default.  This works best for bitfields.  */\n+  object_offset_in_bits += type_align_in_bits - 1;\n+  object_offset_in_bits /= type_align_in_bits;\n+  object_offset_in_bits *= type_align_in_bits;\n \n-  /* Compute the offset of the containing object in \"alignment units\".  */\n-  object_offset_in_align_units = object_offset_in_bits / type_align_in_bits;\n+  if (object_offset_in_bits > bitpos_int)\n+    {\n+      /* Sigh, the decl must be packed.  */\n+      object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n+\n+      /* Round up to decl_align instead.  */\n+      object_offset_in_bits += decl_align_in_bits - 1;\n+      object_offset_in_bits /= decl_align_in_bits;\n+      object_offset_in_bits *= decl_align_in_bits;\n+    }\n \n-  /* Compute the offset of the containing object in bytes.  */\n-  object_offset_in_bytes = object_offset_in_align_units * type_align_in_bytes;\n+  object_offset_in_bytes = object_offset_in_bits / BITS_PER_UNIT;\n \n   return object_offset_in_bytes;\n }"}]}