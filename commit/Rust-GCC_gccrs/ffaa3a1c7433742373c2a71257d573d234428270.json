{"sha": "ffaa3a1c7433742373c2a71257d573d234428270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhYTNhMWM3NDMzNzQyMzczYzJhNzEyNTdkNTczZDIzNDQyODI3MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-07T00:07:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-07T00:07:50Z"}, "message": "go/internal/gccgoimporter: ignore unexported and imported names\n    \n    Due to inlining, we can now see unexported functions and variables,\n    and functions and variables imported from different packages.\n    Ignore them rather than reporting them from this package.\n    \n    Handle $hash and $equal functions consistently, so that we discard the\n    inline body if there is one.\n    \n    Ignore names created for result parameters for inlining purposes.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/180758\n\nFrom-SVN: r272023", "tree": {"sha": "b7dc46662e228320e2254df24d28d28ce6fd2f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7dc46662e228320e2254df24d28d28ce6fd2f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffaa3a1c7433742373c2a71257d573d234428270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaa3a1c7433742373c2a71257d573d234428270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffaa3a1c7433742373c2a71257d573d234428270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaa3a1c7433742373c2a71257d573d234428270/comments", "author": null, "committer": null, "parents": [{"sha": "93cbebde76ac7de2d69b223d99acb39e0370687f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cbebde76ac7de2d69b223d99acb39e0370687f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cbebde76ac7de2d69b223d99acb39e0370687f"}], "stats": {"total": 55, "additions": 28, "deletions": 27}, "files": [{"sha": "7f687c8cc00c9cafa45be5b845289656f90cb59b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaa3a1c7433742373c2a71257d573d234428270/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaa3a1c7433742373c2a71257d573d234428270/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ffaa3a1c7433742373c2a71257d573d234428270", "patch": "@@ -1,4 +1,4 @@\n-015785baa74629baafe520367b9c71707366c6eb\n+e76c26059585433ce44e50cd7f8f504c6676f453\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5881d9c79cb7363373c6854a0507d053aeee7bec", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaa3a1c7433742373c2a71257d573d234428270/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaa3a1c7433742373c2a71257d573d234428270/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=ffaa3a1c7433742373c2a71257d573d234428270", "patch": "@@ -261,6 +261,10 @@ func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string) {\n // Param = Name [\"...\"] Type .\n func (p *parser) parseParam(pkg *types.Package) (param *types.Var, isVariadic bool) {\n \tname := p.parseName()\n+\t// Ignore names invented for inlinable functions.\n+\tif strings.HasPrefix(name, \"p.\") || strings.HasPrefix(name, \"r.\") || strings.HasPrefix(name, \"$ret\") {\n+\t\tname = \"\"\n+\t}\n \tif p.tok == '<' && p.scanner.Peek() == 'e' {\n \t\t// EscInfo = \"<esc:\" int \">\" . (optional and ignored)\n \t\tp.next()\n@@ -286,7 +290,14 @@ func (p *parser) parseParam(pkg *types.Package) (param *types.Var, isVariadic bo\n // Var = Name Type .\n func (p *parser) parseVar(pkg *types.Package) *types.Var {\n \tname := p.parseName()\n-\treturn types.NewVar(token.NoPos, pkg, name, p.parseType(pkg))\n+\tv := types.NewVar(token.NoPos, pkg, name, p.parseType(pkg))\n+\tif name[0] == '.' || name[0] == '<' {\n+\t\t// This is an unexported variable,\n+\t\t// or a variable defined in a different package.\n+\t\t// We only want to record exported variables.\n+\t\treturn nil\n+\t}\n+\treturn v\n }\n \n // Conversion = \"convert\" \"(\" Type \",\" ConstValue \")\" .\n@@ -741,14 +752,17 @@ func (p *parser) parseFunc(pkg *types.Package) *types.Func {\n \t}\n \n \tname := p.parseName()\n-\tif strings.ContainsRune(name, '$') {\n-\t\t// This is a Type$equal or Type$hash function, which we don't want to parse,\n-\t\t// except for the types.\n-\t\tp.discardDirectiveWhileParsingTypes(pkg)\n-\t\treturn nil\n-\t}\n \tf := types.NewFunc(token.NoPos, pkg, name, p.parseFunctionType(pkg, nil))\n \tp.skipInlineBody()\n+\n+\tif name[0] == '.' || name[0] == '<' || strings.ContainsRune(name, '$') {\n+\t\t// This is an unexported function,\n+\t\t// or a function defined in a different package,\n+\t\t// or a type$equal or type$hash function.\n+\t\t// We only want to record exported functions.\n+\t\treturn nil\n+\t}\n+\n \treturn f\n }\n \n@@ -769,7 +783,9 @@ func (p *parser) parseInterfaceType(pkg *types.Package, nlist []int) types.Type\n \t\t\tembeddeds = append(embeddeds, p.parseType(pkg))\n \t\t} else {\n \t\t\tmethod := p.parseFunc(pkg)\n-\t\t\tmethods = append(methods, method)\n+\t\t\tif method != nil {\n+\t\t\t\tmethods = append(methods, method)\n+\t\t\t}\n \t\t}\n \t\tp.expect(';')\n \t}\n@@ -1050,23 +1066,6 @@ func (p *parser) parsePackageInit() PackageInit {\n \treturn PackageInit{Name: name, InitFunc: initfunc, Priority: priority}\n }\n \n-// Throw away tokens until we see a newline or ';'.\n-// If we see a '<', attempt to parse as a type.\n-func (p *parser) discardDirectiveWhileParsingTypes(pkg *types.Package) {\n-\tfor {\n-\t\tswitch p.tok {\n-\t\tcase '\\n', ';':\n-\t\t\treturn\n-\t\tcase '<':\n-\t\t\tp.parseType(pkg)\n-\t\tcase scanner.EOF:\n-\t\t\tp.error(\"unexpected EOF\")\n-\t\tdefault:\n-\t\t\tp.next()\n-\t\t}\n-\t}\n-}\n-\n // Create the package if we have parsed both the package path and package name.\n func (p *parser) maybeCreatePackage() {\n \tif p.pkgname != \"\" && p.pkgpath != \"\" {\n@@ -1204,7 +1203,9 @@ func (p *parser) parseDirective() {\n \tcase \"var\":\n \t\tp.next()\n \t\tv := p.parseVar(p.pkg)\n-\t\tp.pkg.Scope().Insert(v)\n+\t\tif v != nil {\n+\t\t\tp.pkg.Scope().Insert(v)\n+\t\t}\n \t\tp.expectEOL()\n \n \tcase \"const\":"}]}