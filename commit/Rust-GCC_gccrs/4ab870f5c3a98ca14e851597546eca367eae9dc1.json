{"sha": "4ab870f5c3a98ca14e851597546eca367eae9dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFiODcwZjVjM2E5OGNhMTRlODUxNTk3NTQ2ZWNhMzY3ZWFlOWRjMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-03-06T09:04:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-06T09:04:47Z"}, "message": "m68k.h (PIC_OFFSET_TABLE_REGNUM): Use the REGNO of pic_offset_table_rtx if reload_completed.\n\ngcc/\n\t* config/m68k/m68k.h (PIC_OFFSET_TABLE_REGNUM): Use the REGNO\n\tof pic_offset_table_rtx if reload_completed.\n\t(CONDITIONAL_REGISTER_USAGE): Use PIC_REG instead of\n\tPIC_OFFSET_TABLE_REGNUM.\n\t* config/m68k/m68k.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Always\n\treturn true.\n\t(m68k_save_reg): Use PIC_REG instead of PIC_OFFSET_TABLE_REGNO.\n\t(m68k_output_mi_thunk): Rewrite to use RTL.  Honor vcall_offset.\n\nFrom-SVN: r122612", "tree": {"sha": "f685b1b0da87e29fdfb4fe60a1b35e32cfe75fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f685b1b0da87e29fdfb4fe60a1b35e32cfe75fea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ab870f5c3a98ca14e851597546eca367eae9dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab870f5c3a98ca14e851597546eca367eae9dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab870f5c3a98ca14e851597546eca367eae9dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab870f5c3a98ca14e851597546eca367eae9dc1/comments", "author": null, "committer": null, "parents": [{"sha": "afcb440c3f7605745e5bdca07927be75250f1d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcb440c3f7605745e5bdca07927be75250f1d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afcb440c3f7605745e5bdca07927be75250f1d34"}], "stats": {"total": 149, "additions": 98, "deletions": 51}, "files": [{"sha": "7cac0a259776188cf496f95125bb63e1a31b24c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ab870f5c3a98ca14e851597546eca367eae9dc1", "patch": "@@ -1,3 +1,14 @@\n+2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/m68k/m68k.h (PIC_OFFSET_TABLE_REGNUM): Use the REGNO\n+\tof pic_offset_table_rtx if reload_completed.\n+\t(CONDITIONAL_REGISTER_USAGE): Use PIC_REG instead of\n+\tPIC_OFFSET_TABLE_REGNUM.\n+\t* config/m68k/m68k.c (TARGET_ASM_CAN_OUTPUT_MI_THUNK): Always\n+\treturn true.\n+\t(m68k_save_reg): Use PIC_REG instead of PIC_OFFSET_TABLE_REGNO.\n+\t(m68k_output_mi_thunk): Rewrite to use RTL.  Honor vcall_offset.\n+\n 2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/m68k/m68k.c (m68k_save_reg): Save the PIC register in"}, {"sha": "99dedb847b9ac0841f83d008371a33560f424dea", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 81, "deletions": 47, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=4ab870f5c3a98ca14e851597546eca367eae9dc1", "patch": "@@ -191,7 +191,7 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK m68k_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n \n #undef TARGET_ASM_FILE_START_APP_OFF\n #define TARGET_ASM_FILE_START_APP_OFF true\n@@ -745,7 +745,7 @@ m68k_initial_elimination_offset (int from, int to)\n static bool\n m68k_save_reg (unsigned int regno, bool interrupt_handler)\n {\n-  if (flag_pic && regno == PIC_OFFSET_TABLE_REGNUM)\n+  if (flag_pic && regno == PIC_REG)\n     {\n       /* A function that receives a nonlocal goto must save all call-saved\n \t registers.  */\n@@ -4083,59 +4083,93 @@ m68k_coff_asm_named_section (const char *name, unsigned int flags,\n \n static void\n m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n-\t\t      HOST_WIDE_INT delta,\n-\t\t      HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t      tree function)\n {\n-  rtx xops[1];\n-  const char *fmt;\n-\n-  if (delta > 0 && delta <= 8)\n-    asm_fprintf (file, (MOTOROLA\n-\t\t\t? \"\\taddq.l %I%d,4(%Rsp)\\n\"\n-\t\t\t: \"\\taddql %I%d,%Rsp@(4)\\n\"),\n-\t\t (int) delta);\n-  else if (delta < 0 && delta >= -8)\n-    asm_fprintf (file, (MOTOROLA\n-\t\t\t? \"\\tsubq.l %I%d,4(%Rsp)\\n\"\n-\t\t\t: \"\\tsubql %I%d,%Rsp@(4)\\n\"),\n-\t\t (int) -delta);\n-  else if (TARGET_COLDFIRE)\n+  rtx this_slot, offset, addr, mem, insn;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  no_new_pseudos = 1;\n+  reload_completed = 1;\n+  reset_block_changes ();\n+  allocate_reg_info (FIRST_PSEUDO_REGISTER, true, true);\n+\n+  /* The \"this\" pointer is stored at 4(%sp).  */\n+  this_slot = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 4));\n+\n+  /* Add DELTA to THIS.  */\n+  if (delta != 0)\n     {\n-      /* ColdFire can't add/sub a constant to memory unless it is in\n-\t the range of addq/subq.  So load the value into %d0 and\n-\t then add it to 4(%sp). */\n-      if (delta >= -128 && delta <= 127)\n-\tasm_fprintf (file, (MOTOROLA\n-\t\t\t    ? \"\\tmoveq.l %I%wd,%Rd0\\n\"\n-\t\t\t    : \"\\tmoveql %I%wd,%Rd0\\n\"),\n-\t\t     delta);\n-      else\n-\tasm_fprintf (file, (MOTOROLA\n-\t\t\t    ? \"\\tmove.l %I%wd,%Rd0\\n\"\n-\t\t\t    : \"\\tmovel %I%wd,%Rd0\\n\"),\n-\t\t     delta);\n-      asm_fprintf (file, (MOTOROLA\n-\t\t\t  ? \"\\tadd.l %Rd0,4(%Rsp)\\n\"\n-\t\t\t  : \"\\taddl %Rd0,%Rsp@(4)\\n\"));\n+      /* Make the offset a legitimate operand for memory addition.  */\n+      offset = GEN_INT (delta);\n+      if ((delta < -8 || delta > 8)\n+\t  && (TARGET_COLDFIRE || USE_MOVQ (delta)))\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (Pmode, D0_REG), offset);\n+\t  offset = gen_rtx_REG (Pmode, D0_REG);\n+\t}\n+      emit_insn (gen_add3_insn (copy_rtx (this_slot),\n+\t\t\t\tcopy_rtx (this_slot), offset));\n     }\n-  else\n-    asm_fprintf (file, (MOTOROLA\n-\t\t\t? \"\\tadd.l %I%wd,4(%Rsp)\\n\"\n-\t\t\t: \"\\taddl %I%wd,%Rsp@(4)\\n\"),\n-\t\t delta);\n \n-  xops[0] = DECL_RTL (function);\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      /* Set the static chain register to *THIS.  */\n+      emit_move_insn (static_chain_rtx, this_slot);\n+      emit_move_insn (static_chain_rtx, gen_rtx_MEM (Pmode, static_chain_rtx));\n+\n+      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      addr = plus_constant (static_chain_rtx, vcall_offset);\n+      if (!m68k_legitimate_address_p (Pmode, addr, true))\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, static_chain_rtx, addr));\n+\t  addr = static_chain_rtx;\n+\t}\n \n-  gcc_assert (MEM_P (xops[0])\n-\t      && symbolic_operand (XEXP (xops[0], 0), VOIDmode));\n-  xops[0] = XEXP (xops[0], 0);\n+      /* Load the offset into %d0 and add it to THIS.  */\n+      emit_move_insn (gen_rtx_REG (Pmode, D0_REG),\n+\t\t      gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (copy_rtx (this_slot),\n+\t\t\t\tcopy_rtx (this_slot),\n+\t\t\t\tgen_rtx_REG (Pmode, D0_REG)));\n+    }\n \n-  fmt = m68k_symbolic_jump;\n-  if (m68k_symbolic_jump == NULL)\n-    fmt = \"move.l %%a1@GOT(%%a5), %%a1\\n\\tjmp (%%a1)\";\n+  /* Jump to the target function.  Use a sibcall if direct jumps are\n+     allowed, otherwise load the address into a register first.  */\n+  mem = DECL_RTL (function);\n+  if (!sibcall_operand (XEXP (mem, 0), VOIDmode))\n+    {\n+      gcc_assert (flag_pic);\n \n-  output_asm_insn (fmt, xops);\n+      if (!TARGET_SEP_DATA)\n+\t{\n+\t  /* Use the static chain register as a temporary (call-clobbered)\n+\t     GOT pointer for this function.  We can use the static chain\n+\t     register because it isn't live on entry to the thunk.  */\n+\t  REGNO (pic_offset_table_rtx) = STATIC_CHAIN_REGNUM;\n+\t  emit_insn (gen_load_got (pic_offset_table_rtx));\n+\t}\n+      legitimize_pic_address (XEXP (mem, 0), Pmode, static_chain_rtx);\n+      mem = replace_equiv_address (mem, static_chain_rtx);\n+    }\n+  insn = emit_call_insn (gen_sibcall (mem, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation.  */\n+  insn = get_insns ();\n+  split_all_insns_noflow ();\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  */\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n+\n+  /* Restore the original PIC register.  */\n+  if (flag_pic)\n+    REGNO (pic_offset_table_rtx) = PIC_REG;\n }\n \n /* Worker function for TARGET_STRUCT_VALUE_RTX.  */"}, {"sha": "5c5d59ebfb799d9d2f7696c33856e393010e4adc", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab870f5c3a98ca14e851597546eca367eae9dc1/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=4ab870f5c3a98ca14e851597546eca367eae9dc1", "patch": "@@ -316,7 +316,10 @@ Boston, MA 02110-1301, USA.  */\n #define FIRST_PSEUDO_REGISTER 25\n \n /* All m68k targets (except AmigaOS) use %a5 as the PIC register  */\n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 13 : INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\\\n+  (!flag_pic ? INVALID_REGNUM\t\t\t\t\\\n+   : reload_completed ? REGNO (pic_offset_table_rtx)\t\\\n+   : PIC_REG)\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -383,9 +386,8 @@ Boston, MA 02110-1301, USA.  */\n         if (TEST_HARD_REG_BIT (x, i))\t\t\t\t\\\n \t  fixed_regs[i] = call_used_regs[i] = 1;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n-      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\\\n+    fixed_regs[PIC_REG] = call_used_regs[PIC_REG] = 1;\t\t\\\n }\n \n /* On the m68k, ordinary registers hold 32 bits worth;"}]}