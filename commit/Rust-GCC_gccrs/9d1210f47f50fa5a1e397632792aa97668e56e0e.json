{"sha": "9d1210f47f50fa5a1e397632792aa97668e56e0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQxMjEwZjQ3ZjUwZmE1YTFlMzk3NjMyNzkyYWE5NzY2OGU1NmUwZQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-25T17:58:53Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-25T17:58:53Z"}, "message": "gfortran.h (gfc_find_component): Add new arguments.\n\n2008-08-25  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (gfc_find_component): Add new arguments.\n\t* parse.c (parse_derived_contains): Check if the derived-type containing\n\tthe CONTAINS section is SEQUENCE/BIND(C).\n\t* resolve.c (resolve_typebound_procedure): Check for name collision with\n\tcomponents.\n\t(resolve_fl_derived): Check for name collision with inherited\n\ttype-bound procedures.\n\t* symbol.c (gfc_find_component): New arguments `noaccess' and `silent'.\n\t(gfc_add_component): Adapt for new arguments.\n\t* primary.c (match_varspec), (gfc_match_structure_constructor): Ditto.\n\n2008-08-25  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/extends_7.f03: New test.\n\t* gfortran.dg/typebound_proc_7.f03: New test.\n\t* gfortran.dg/typebound_proc_8.f03: New test.\n\nFrom-SVN: r139566", "tree": {"sha": "48f2f28391f6447501ac0481370dfd5b4e376e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48f2f28391f6447501ac0481370dfd5b4e376e7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d1210f47f50fa5a1e397632792aa97668e56e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1210f47f50fa5a1e397632792aa97668e56e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1210f47f50fa5a1e397632792aa97668e56e0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1210f47f50fa5a1e397632792aa97668e56e0e/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e02aa5ec860b71931d3223505e0337ffb5d1a7a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02aa5ec860b71931d3223505e0337ffb5d1a7a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02aa5ec860b71931d3223505e0337ffb5d1a7a4"}], "stats": {"total": 204, "additions": 186, "deletions": 18}, "files": [{"sha": "b606361af403c3b48c933c473565969aa0643453", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -1,3 +1,16 @@\n+2008-08-25  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (gfc_find_component): Add new arguments.\n+\t* parse.c (parse_derived_contains): Check if the derived-type containing\n+\tthe CONTAINS section is SEQUENCE/BIND(C).\n+\t* resolve.c (resolve_typebound_procedure): Check for name collision with\n+\tcomponents.\n+\t(resolve_fl_derived): Check for name collision with inherited\n+\ttype-bound procedures.\n+\t* symbol.c (gfc_find_component): New arguments `noaccess' and `silent'.\n+\t(gfc_add_component): Adapt for new arguments.\n+\t* primary.c (match_varspec), (gfc_match_structure_constructor): Ditto.\n+\n 2008-08-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37201"}, {"sha": "b063474bf14c85dc1924e6b01aab95161770ac0b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -2208,7 +2208,7 @@ gfc_try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n gfc_try gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n gfc_symbol *gfc_use_derived (gfc_symbol *);\n gfc_symtree *gfc_use_derived_tree (gfc_symtree *);\n-gfc_component *gfc_find_component (gfc_symbol *, const char *);\n+gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);\n \n gfc_st_label *gfc_get_st_label (int);\n void gfc_free_st_label (gfc_st_label *);"}, {"sha": "f12afd5f2fbcbf03fd912b0cfeb9ecddd2753fcd", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -1715,8 +1715,19 @@ parse_derived_contains (void)\n   bool error_flag = false;\n   bool to_finish;\n \n-  accept_statement (ST_CONTAINS);\n   gcc_assert (gfc_current_state () == COMP_DERIVED);\n+  gcc_assert (gfc_current_block ());\n+\n+  /* Derived-types with SEQUENCE and/or BIND(C) must not have a CONTAINS\n+     section.  */\n+  if (gfc_current_block ()->attr.sequence)\n+    gfc_error (\"Derived-type '%s' with SEQUENCE must not have a CONTAINS\"\n+\t       \" section at %C\", gfc_current_block ()->name);\n+  if (gfc_current_block ()->attr.is_bind_c)\n+    gfc_error (\"Derived-type '%s' with BIND(C) must not have a CONTAINS\"\n+\t       \" section at %C\", gfc_current_block ()->name);\n+\n+  accept_statement (ST_CONTAINS);\n   push_state (&s, COMP_DERIVED_CONTAINS, NULL);\n \n   to_finish = false;"}, {"sha": "5d734079d7ad4c38a730bd96438c99464e19e648", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -1757,7 +1757,7 @@ match_varspec (gfc_expr *primary, int equiv_flag)\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n-      component = gfc_find_component (sym, name);\n+      component = gfc_find_component (sym, name, false, false);\n       if (component == NULL)\n \treturn MATCH_ERROR;\n \n@@ -2096,7 +2096,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent\n \n   where = gfc_current_locus;\n \n-  gfc_find_component (sym, NULL);\n+  gfc_find_component (sym, NULL, false, true);\n \n   /* Match the component list and store it in a list together with the\n      corresponding component names.  Check for empty argument list first.  */\n@@ -2149,13 +2149,15 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent\n \t      strncpy (comp_tail->name, comp->name, GFC_MAX_SYMBOL_LEN + 1);\n \t    }\n \n-\t  /* Find the current component in the structure definition and check its\n-\t     access is not private.  */\n+\t  /* Find the current component in the structure definition and check\n+\t     its access is not private.  */\n \t  if (comp)\n-\t    this_comp = gfc_find_component (sym, comp->name);\n+\t    this_comp = gfc_find_component (sym, comp->name, false, false);\n \t  else\n \t    {\n-\t      this_comp = gfc_find_component (sym, (const char *)comp_tail->name);\n+\t      this_comp = gfc_find_component (sym,\n+\t\t\t\t\t      (const char *)comp_tail->name,\n+\t\t\t\t\t      false, false);\n \t      comp = NULL; /* Reset needed!  */\n \t    }\n "}, {"sha": "6bf538096ffde999d30c6edbe0ca6097499a4031", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -7800,6 +7800,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   locus where;\n   gfc_symbol* me_arg;\n   gfc_symbol* super_type;\n+  gfc_component* comp;\n \n   /* If this is no type-bound procedure, just return.  */\n   if (!stree->typebound)\n@@ -7898,6 +7899,25 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \tgoto error;\n     }\n \n+  /* See if there's a name collision with a component directly in this type.  */\n+  for (comp = resolve_bindings_derived->components; comp; comp = comp->next)\n+    if (!strcmp (comp->name, stree->name))\n+      {\n+\tgfc_error (\"Procedure '%s' at %L has the same name as a component of\"\n+\t\t   \" '%s'\",\n+\t\t   stree->name, &where, resolve_bindings_derived->name);\n+\tgoto error;\n+      }\n+\n+  /* Try to find a name collision with an inherited component.  */\n+  if (super_type && gfc_find_component (super_type, stree->name, true, true))\n+    {\n+      gfc_error (\"Procedure '%s' at %L has the same name as an inherited\"\n+\t\t \" component of '%s'\",\n+\t\t stree->name, &where, resolve_bindings_derived->name);\n+      goto error;\n+    }\n+\n   /* FIXME: Remove once typebound-procedures are fully implemented.  */\n   {\n     /* Output the error only once so we can do reasonable testing.  */\n@@ -7954,11 +7974,24 @@ add_dt_to_dt_list (gfc_symbol *derived)\n static gfc_try\n resolve_fl_derived (gfc_symbol *sym)\n {\n+  gfc_symbol* super_type;\n   gfc_component *c;\n   int i;\n \n+  super_type = gfc_get_derived_super_type (sym);\n+\n   for (c = sym->components; c != NULL; c = c->next)\n     {\n+      /* If this type is an extension, see if this component has the same name\n+\t as an inherited type-bound procedure.  */\n+      if (super_type && gfc_find_typebound_proc (super_type, c->name))\n+\t{\n+\t  gfc_error (\"Component '%s' of '%s' at %L has the same name as an\"\n+\t\t     \" inherited type-bound procedure\",\n+\t\t     c->name, sym->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n       if (c->ts.type == BT_CHARACTER)\n \t{\n \t if (c->ts.cl->length == NULL"}, {"sha": "2eed9fefb0ee10c7de5efc34a4dc75ae3f7f1ee1", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -1722,7 +1722,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     }\n \n   if (sym->attr.extension\n-\t&& gfc_find_component (sym->components->ts.derived, name))\n+\t&& gfc_find_component (sym->components->ts.derived, name, true, true))\n     {\n       gfc_error (\"Component '%s' at %C already in the parent type \"\n \t\t \"at %L\", name, &sym->components->ts.derived->declared_at);\n@@ -1839,10 +1839,12 @@ gfc_use_derived (gfc_symbol *sym)\n \n /* Given a derived type node and a component name, try to locate the\n    component structure.  Returns the NULL pointer if the component is\n-   not found or the components are private.  */\n+   not found or the components are private.  If noaccess is set, no access\n+   checks are done.  */\n \n gfc_component *\n-gfc_find_component (gfc_symbol *sym, const char *name)\n+gfc_find_component (gfc_symbol *sym, const char *name,\n+\t\t    bool noaccess, bool silent)\n {\n   gfc_component *p;\n \n@@ -1862,31 +1864,34 @@ gfc_find_component (gfc_symbol *sym, const char *name)\n \t&& sym->attr.extension\n \t&& sym->components->ts.type == BT_DERIVED)\n     {\n-      p = gfc_find_component (sym->components->ts.derived, name);\n+      p = gfc_find_component (sym->components->ts.derived, name,\n+\t\t\t      noaccess, silent);\n       /* Do not overwrite the error.  */\n       if (p == NULL)\n \treturn p;\n     }\n \n-  if (p == NULL)\n+  if (p == NULL && !silent)\n     gfc_error (\"'%s' at %C is not a member of the '%s' structure\",\n \t       name, sym->name);\n \n-  else if (sym->attr.use_assoc)\n+  else if (sym->attr.use_assoc && !noaccess)\n     {\n       if (p->attr.access == ACCESS_PRIVATE)\n \t{\n-\t  gfc_error (\"Component '%s' at %C is a PRIVATE component of '%s'\",\n-\t\t     name, sym->name);\n+\t  if (!silent)\n+\t    gfc_error (\"Component '%s' at %C is a PRIVATE component of '%s'\",\n+\t\t       name, sym->name);\n \t  return NULL;\n \t}\n \t\n       /* If there were components given and all components are private, error\n \t out at this place.  */\n       if (p->attr.access != ACCESS_PUBLIC && sym->component_access == ACCESS_PRIVATE)\n \t{\n-\t  gfc_error (\"All components of '%s' are PRIVATE in structure\"\n-\t\t     \" constructor at %C\", sym->name);\n+\t  if (!silent)\n+\t    gfc_error (\"All components of '%s' are PRIVATE in structure\"\n+\t\t       \" constructor at %C\", sym->name);\n \t  return NULL;\n \t}\n     }"}, {"sha": "4406270be782d8a96b2e006269fdb9cf78015c82", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -1,3 +1,9 @@\n+2008-08-25  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/extends_7.f03: New test.\n+\t* gfortran.dg/typebound_proc_7.f03: New test.\n+\t* gfortran.dg/typebound_proc_8.f03: New test.\n+\n 2008-08-24  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/octeon-pop-1.c: New test."}, {"sha": "ebb2fcc3efb73cab530556a61f848e6d02a87470", "filename": "gcc/testsuite/gfortran.dg/extends_7.f03", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_7.f03?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! Check for re-definition of inherited components in the sub-type.\n+\n+MODULE m1\n+  IMPLICIT NONE\n+\n+  TYPE supert\n+    INTEGER :: c1\n+    INTEGER, PRIVATE :: c2\n+  END TYPE supert\n+\n+END MODULE m1\n+\n+MODULE m2\n+  USE m1 ! { dg-error \"already in the parent type\" }\n+  IMPLICIT NONE\n+\n+  TYPE, EXTENDS(supert) :: subt\n+    INTEGER :: c1 ! { dg-error \"already in the parent type\" }\n+    INTEGER :: c2 ! { dg-error \"already in the parent type\" }\n+  END TYPE subt\n+\n+END MODULE m2\n+\n+! { dg-final { cleanup-modules \"m1 m2\" } }"}, {"sha": "a12b1d25e34be0241ed4085bc058fc882f9fa992", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_7.f03", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Tests that SEQUENCE and BIND(C) types do not allow a type-bound procedure\n+! section.\n+\n+MODULE testmod\n+  USE ISO_C_BINDING\n+  IMPLICIT NONE\n+\n+  TYPE sequencet\n+    SEQUENCE\n+    INTEGER :: a, b\n+  CONTAINS ! { dg-error \"SEQUENCE\" }\n+    PROCEDURE, NOPASS :: proc_noarg\n+  END TYPE sequencet\n+\n+  TYPE, BIND(C) :: bindct\n+    INTEGER(c_int) :: a\n+    REAL(c_float) :: b\n+  CONTAINS ! { dg-error \"BIND\" }\n+    PROCEDURE, NOPASS :: proc_noarg\n+  END TYPE bindct\n+\n+CONTAINS\n+\n+  SUBROUTINE proc_noarg ()\n+  END SUBROUTINE proc_noarg\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }\n+! FIXME: Remove not-yet-implemented error when implemented.\n+! { dg-excess-errors \"not yet implemented\" }"}, {"sha": "087b11f685510362377a7aa26dff5b9a81a7e6f7", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_8.f03", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1210f47f50fa5a1e397632792aa97668e56e0e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03?ref=9d1210f47f50fa5a1e397632792aa97668e56e0e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Test for name collision between type-bound procedures and components.\n+\n+MODULE testmod\n+  IMPLICIT NONE\n+\n+  TYPE t\n+    REAL :: comp\n+  CONTAINS\n+    PROCEDURE, NOPASS :: comp => proc ! { dg-error \"same name as a component\" }\n+  END TYPE t\n+\n+  TYPE supert\n+    INTEGER :: comp1\n+  CONTAINS\n+    PROCEDURE, NOPASS :: comp2 => proc\n+  END TYPE supert\n+\n+  TYPE, EXTENDS(supert) :: subt1\n+    INTEGER :: comp2 ! { dg-error \"same name\" }\n+  END TYPE subt1\n+\n+  TYPE, EXTENDS(supert) :: subt2\n+  CONTAINS\n+    PROCEDURE, NOPASS :: comp1 => proc ! { dg-error \"same name as an inherited component\" }\n+  END TYPE subt2\n+\n+CONTAINS\n+\n+  SUBROUTINE proc ()\n+  END SUBROUTINE proc\n+\n+END MODULE testmod\n+\n+! { dg-final { cleanup-modules \"testmod\" } }\n+! FIXME: Remove not-yet-implemented error when implemented.\n+! { dg-excess-errors \"not yet implemented\" }"}]}