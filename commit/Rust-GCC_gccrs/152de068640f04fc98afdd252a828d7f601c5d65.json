{"sha": "152de068640f04fc98afdd252a828d7f601c5d65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyZGUwNjg2NDBmMDRmYzk4YWZkZDI1MmE4MjhkN2Y2MDFjNWQ2NQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-06-01T07:44:58Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-06-01T07:44:58Z"}, "message": "class.c (common_enclosing_context_p): New function.\n\n2000-04-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (common_enclosing_context_p): New function.\n\t* java-tree.h (common_enclosing_context_p): Added prototype.\n\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): Relaxed test to allow\n\tclasses sharing an outer context with the current instance.\n\t* parse.y (build_access_to_thisn): Fixed leading comment.\n\t(verify_constructor_super): New local `supper_inner'. Skip\n\tenclosing context argument in the case of inner class constructors.\n\t(patch_method_invocation): Insert proper context as second\n\tparameter to pure inner class constructor super invocations.\n\nThis fixes the Java PR #177.\n\nFrom-SVN: r34332", "tree": {"sha": "586253d11f233cbb77aa2d57a0c67ea6ec106370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/586253d11f233cbb77aa2d57a0c67ea6ec106370"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152de068640f04fc98afdd252a828d7f601c5d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152de068640f04fc98afdd252a828d7f601c5d65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152de068640f04fc98afdd252a828d7f601c5d65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152de068640f04fc98afdd252a828d7f601c5d65/comments", "author": null, "committer": null, "parents": [{"sha": "3aac3c2fd48d6b18b196acb1b9ad5cf9a0cd85ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aac3c2fd48d6b18b196acb1b9ad5cf9a0cd85ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aac3c2fd48d6b18b196acb1b9ad5cf9a0cd85ac"}], "stats": {"total": 143, "additions": 118, "deletions": 25}, "files": [{"sha": "7bd5521fa85c9871961792653f94781dd267e8ad", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -200,6 +200,18 @@ Wed Apr 26 14:29:33 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (register_incomplete_type): Handle JDEP_ANONYMOUS.\n \n+2000-04-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (common_enclosing_context_p): New function.\n+\t* java-tree.h (common_enclosing_context_p): Added prototype.\n+\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): Relaxed test to allow\n+\tclasses sharing an outer context with the current instance.\n+\t* parse.y (build_access_to_thisn): Fixed leading comment.\n+\t(verify_constructor_super): New local `supper_inner'. Skip\n+\tenclosing context argument in the case of inner class constructors.\n+\t(patch_method_invocation): Insert proper context as second\n+\tparameter to pure inner class constructor super invocations.\n+\n Mon Apr 24 14:59:36 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (end_class_declaration): Reset the interface number"}, {"sha": "dcc544846d1ddb552c3333d6469f43957dd5ee2c", "filename": "gcc/java/class.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -486,6 +486,30 @@ enclosing_context_p (type1, type2)\n   return 0;\n }\n \n+/* Return 1 iff there exists a common enclosing context between TYPE1\n+   and TYPE2.  */\n+\n+int common_enclosing_context_p (type1, type2)\n+     tree type1, type2;\n+{\n+  if (!PURE_INNER_CLASS_TYPE_P (type1) && !PURE_INNER_CLASS_TYPE_P (type2))\n+    return 0;\n+  \n+  for (type1 = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type1))); type1; \n+       type1 = (PURE_INNER_CLASS_TYPE_P (type1) ?\n+\t\tTREE_TYPE (DECL_CONTEXT (TYPE_NAME (type1))) : NULL_TREE))\n+    {\n+      tree current;\n+      for (current = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type2))); current;\n+\t   current = (PURE_INNER_CLASS_TYPE_P (current) ?\n+\t\t      TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current))) : \n+\t\t      NULL_TREE))\n+\tif (type1 == current)\n+\t  return 1;\n+    }\n+  return 0;\n+}\n+\n static void\n add_interface_do (basetype_vec, interface_class, i)\n      tree basetype_vec, interface_class;"}, {"sha": "8f2b2c825031deb3f85e0e17b7ad379317860ebe", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -696,6 +696,7 @@ extern void set_super_info PARAMS ((int, tree, tree, int));\n extern int get_access_flags_from_decl PARAMS ((tree));\n extern int interface_of_p PARAMS ((tree, tree));\n extern int inherits_from_p PARAMS ((tree, tree));\n+extern int common_enclosing_context_p PARAMS ((tree, tree));\n extern int enclosing_context_p PARAMS ((tree, tree));\n extern void complete_start_java_method PARAMS ((tree));\n extern tree build_result_decl PARAMS ((tree));"}, {"sha": "2f77d7497dbacfe05fe3e1a414d42f56457f2eb2", "filename": "gcc/java/parse.c", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -10642,7 +10642,7 @@ build_access_to_thisn (from, to, lc)\n \n /* Build an access function to the this$<n> local to TYPE. NULL_TREE\n    is returned if nothing needs to be generated. Otherwise, the method\n-   generated, fully walked and a method decl is returned.  \n+   generated and a method decl is returned.  \n \n    NOTE: These generated methods should be declared in a class file\n    attribute so that they can't be referred to directly.  */\n@@ -10985,6 +10985,7 @@ verify_constructor_super (mdecl)\n      tree mdecl;\n {\n   tree class = CLASSTYPE_SUPER (current_class);\n+  int super_inner = PURE_INNER_CLASS_TYPE_P (class);\n   tree sdecl;\n \n   if (!class)\n@@ -10997,10 +10998,11 @@ verify_constructor_super (mdecl)\n       for (sdecl = TYPE_METHODS (class); sdecl; sdecl = TREE_CHAIN (sdecl))\n \tif (DECL_CONSTRUCTOR_P (sdecl))\n \t  {\n-\t    tree arg_type;\n-\t    for (arg_type = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n-\t\t arg_type != end_params_node && \n-\t\t   mdecl_arg_type != end_params_node;\n+\t    tree arg_type = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n+\t    if (super_inner)\n+\t      arg_type = TREE_CHAIN (arg_type);\n+\t    for (; (arg_type != end_params_node \n+\t\t    && mdecl_arg_type != end_params_node);\n \t\t arg_type = TREE_CHAIN (arg_type), \n \t\t mdecl_arg_type = TREE_CHAIN (mdecl_arg_type))\n \t      if (TREE_VALUE (arg_type) != TREE_VALUE (mdecl_arg_type))\n@@ -11015,9 +11017,10 @@ verify_constructor_super (mdecl)\n     {\n       for (sdecl = TYPE_METHODS (class); sdecl; sdecl = TREE_CHAIN (sdecl))\n \t{\n-\t  if (DECL_CONSTRUCTOR_P (sdecl)\n-\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl))) \n-\t         == end_params_node)\n+\t  tree arg = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n+\t  if (super_inner)\n+\t    arg = TREE_CHAIN (arg);\n+\t  if (DECL_CONSTRUCTOR_P (sdecl) && arg == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -12286,6 +12289,30 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \targs = tree_cons (NULL_TREE, integer_zero_node, args);\n     }\n \n+  /* This handles the situation where a constructor invocation needs\n+     to have an enclosing context passed as a second parameter (the\n+     constructor is one of an inner class. We extract it from the\n+     current function.  */\n+  if (is_super_init && PURE_INNER_CLASS_TYPE_P (DECL_CONTEXT (list)))\n+    {\n+      tree enclosing_decl = DECL_CONTEXT (TYPE_NAME (current_class));\n+      tree extra_arg;\n+\n+      if (ANONYMOUS_CLASS_P (current_class) || !DECL_CONTEXT (enclosing_decl))\n+\t{\n+\t  extra_arg = DECL_FUNCTION_BODY (current_function_decl);\n+\t  extra_arg = TREE_CHAIN (BLOCK_EXPR_DECLS (extra_arg));\n+\t}\n+      else\n+\t{\n+\t  tree dest = TREE_TYPE (DECL_CONTEXT (enclosing_decl));\n+\t  extra_arg = \n+\t    build_access_to_thisn (TREE_TYPE (enclosing_decl), dest, 0);\n+\t  extra_arg = java_complete_tree (extra_arg);\n+\t}\n+      args = tree_cons (NULL_TREE, extra_arg, args);\n+    }\n+\n   is_static_flag = METHOD_STATIC (list);\n   if (! METHOD_STATIC (list) && this_arg != NULL_TREE)\n     args = tree_cons (NULL_TREE, this_arg, args);"}, {"sha": "24b0b9b82804d26e5036621497d86afb2b4923da", "filename": "gcc/java/parse.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -822,15 +822,17 @@ struct parser_ctxt {\n \n /* Make sure that innerclass T sits in an appropriate enclosing\n    context.  */\n-#define INNER_ENCLOSING_SCOPE_CHECK(T)\t\t\t\t\t\\\n-  (INNER_CLASS_TYPE_P ((T)) && !ANONYMOUS_CLASS_P ((T))\t\t\t\\\n-   && ((current_this\t\t\t\t\t\t\t\\\n-\t/* We have a this and it's not the right one */\t\t\t\\\n-\t&& (DECL_CONTEXT (TYPE_NAME ((T)))\t\t\t\t\\\n-\t    != TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this))))\t\\\n-\t&& !inherits_from_p (TREE_TYPE (TREE_TYPE (current_this)),\t\\\n-\t\t\t     TREE_TYPE (DECL_CONTEXT (TYPE_NAME (T)))))\t\\\n-       /* We don't have a this. */\t\t\t\t\t\\\n+#define INNER_ENCLOSING_SCOPE_CHECK(T)\t\t\t\t\t      \\\n+  (INNER_CLASS_TYPE_P ((T)) && !ANONYMOUS_CLASS_P ((T))\t\t\t      \\\n+   && ((current_this\t\t\t\t\t\t\t      \\\n+\t/* We have a this and it's not the right one */\t\t\t      \\\n+\t&& (DECL_CONTEXT (TYPE_NAME ((T)))\t\t\t\t      \\\n+\t    != TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this))))\t      \\\n+\t&& !inherits_from_p (TREE_TYPE (TREE_TYPE (current_this)),\t      \\\n+\t\t\t     TREE_TYPE (DECL_CONTEXT (TYPE_NAME (T))))\t      \\\n+        && !common_enclosing_context_p (TREE_TYPE (TREE_TYPE (current_this)), \\\n+\t\t\t\t\t(T)))\t\t\t\t      \\\n+       /* We don't have a this. */\t\t\t\t\t      \\\n        || !current_this))\n \n /* Push macro. First argument to PUSH_CPC is a DECL_TYPE, second"}, {"sha": "83cd49edfd6ef616a14f40843ca0edccb9a37866", "filename": "gcc/java/parse.y", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152de068640f04fc98afdd252a828d7f601c5d65/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=152de068640f04fc98afdd252a828d7f601c5d65", "patch": "@@ -7944,7 +7944,7 @@ build_access_to_thisn (from, to, lc)\n \n /* Build an access function to the this$<n> local to TYPE. NULL_TREE\n    is returned if nothing needs to be generated. Otherwise, the method\n-   generated, fully walked and a method decl is returned.  \n+   generated and a method decl is returned.  \n \n    NOTE: These generated methods should be declared in a class file\n    attribute so that they can't be referred to directly.  */\n@@ -8287,6 +8287,7 @@ verify_constructor_super (mdecl)\n      tree mdecl;\n {\n   tree class = CLASSTYPE_SUPER (current_class);\n+  int super_inner = PURE_INNER_CLASS_TYPE_P (class);\n   tree sdecl;\n \n   if (!class)\n@@ -8299,10 +8300,11 @@ verify_constructor_super (mdecl)\n       for (sdecl = TYPE_METHODS (class); sdecl; sdecl = TREE_CHAIN (sdecl))\n \tif (DECL_CONSTRUCTOR_P (sdecl))\n \t  {\n-\t    tree arg_type;\n-\t    for (arg_type = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n-\t\t arg_type != end_params_node && \n-\t\t   mdecl_arg_type != end_params_node;\n+\t    tree arg_type = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n+\t    if (super_inner)\n+\t      arg_type = TREE_CHAIN (arg_type);\n+\t    for (; (arg_type != end_params_node \n+\t\t    && mdecl_arg_type != end_params_node);\n \t\t arg_type = TREE_CHAIN (arg_type), \n \t\t mdecl_arg_type = TREE_CHAIN (mdecl_arg_type))\n \t      if (TREE_VALUE (arg_type) != TREE_VALUE (mdecl_arg_type))\n@@ -8317,9 +8319,10 @@ verify_constructor_super (mdecl)\n     {\n       for (sdecl = TYPE_METHODS (class); sdecl; sdecl = TREE_CHAIN (sdecl))\n \t{\n-\t  if (DECL_CONSTRUCTOR_P (sdecl)\n-\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl))) \n-\t         == end_params_node)\n+\t  tree arg = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (sdecl)));\n+\t  if (super_inner)\n+\t    arg = TREE_CHAIN (arg);\n+\t  if (DECL_CONSTRUCTOR_P (sdecl) && arg == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -9588,6 +9591,30 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \targs = tree_cons (NULL_TREE, integer_zero_node, args);\n     }\n \n+  /* This handles the situation where a constructor invocation needs\n+     to have an enclosing context passed as a second parameter (the\n+     constructor is one of an inner class. We extract it from the\n+     current function.  */\n+  if (is_super_init && PURE_INNER_CLASS_TYPE_P (DECL_CONTEXT (list)))\n+    {\n+      tree enclosing_decl = DECL_CONTEXT (TYPE_NAME (current_class));\n+      tree extra_arg;\n+\n+      if (ANONYMOUS_CLASS_P (current_class) || !DECL_CONTEXT (enclosing_decl))\n+\t{\n+\t  extra_arg = DECL_FUNCTION_BODY (current_function_decl);\n+\t  extra_arg = TREE_CHAIN (BLOCK_EXPR_DECLS (extra_arg));\n+\t}\n+      else\n+\t{\n+\t  tree dest = TREE_TYPE (DECL_CONTEXT (enclosing_decl));\n+\t  extra_arg = \n+\t    build_access_to_thisn (TREE_TYPE (enclosing_decl), dest, 0);\n+\t  extra_arg = java_complete_tree (extra_arg);\n+\t}\n+      args = tree_cons (NULL_TREE, extra_arg, args);\n+    }\n+\n   is_static_flag = METHOD_STATIC (list);\n   if (! METHOD_STATIC (list) && this_arg != NULL_TREE)\n     args = tree_cons (NULL_TREE, this_arg, args);"}]}