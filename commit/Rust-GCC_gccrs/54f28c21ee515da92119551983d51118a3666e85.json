{"sha": "54f28c21ee515da92119551983d51118a3666e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRmMjhjMjFlZTUxNWRhOTIxMTk1NTE5ODNkNTExMThhMzY2NmU4NQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2006-01-25T03:03:14Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2006-01-25T03:03:14Z"}, "message": "Import Boehm GC version 6.6.\n\nFrom-SVN: r110204", "tree": {"sha": "575ef0143266ff2f57b09fe0143e9a412b1fb27f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/575ef0143266ff2f57b09fe0143e9a412b1fb27f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54f28c21ee515da92119551983d51118a3666e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54f28c21ee515da92119551983d51118a3666e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54f28c21ee515da92119551983d51118a3666e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54f28c21ee515da92119551983d51118a3666e85/comments", "author": null, "committer": null, "parents": [{"sha": "ac42ec79e00a729e9d92fc1d254862936ee68bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac42ec79e00a729e9d92fc1d254862936ee68bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac42ec79e00a729e9d92fc1d254862936ee68bbe"}], "stats": {"total": 1945, "additions": 847, "deletions": 1098}, "files": [{"sha": "082cbfc000dc363c3633038aafe6032e76f7f1fb", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1,3 +1,7 @@\n+2006-01-24  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tImport Boehm GC version 6.6.\n+\n 2006-01-24  David Ayers  <d.ayers@inode.at>\n \n \tPR libobjc/13946"}, {"sha": "d25c052865eb447672f6941e11b2e759b0ec5028", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -17,28 +17,27 @@ else\n asm_libgc_sources = \n endif\n \n-GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \\\n+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n backgraph.c win32_threads.c \\\n pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n-$(asm_libgc_sources)\n+$(asm_libgcjgc_sources)\n+\n+libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)\n \n EXTRA_DIST = alpha_mach_dep.S \\\n mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n-libgcjgc_la_SOURCES = $(GC_SOURCES)\n-libgcjgc_convenience_la_SOURCES = $(GC_SOURCES)\n-\n # Include THREADLIBS here to ensure that the correct versions of\n # linuxthread semaphore functions get linked:\n-libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n+libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS) $(UNWINDLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n-libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n+libgcjgc_la_LDFLAGS = -version-info 1:2:0 -rpath $(toolexeclibdir)\n \n libgcjgc_convenience_la_LIBADD = @addobjs@\n libgcjgc_convenience_la_DEPENDENCIES = @addobjs@\n@@ -48,7 +47,7 @@ AM_CFLAGS = @GC_CFLAGS@\n \n check_PROGRAMS = gctest\n gctest_SOURCES = tests/test.c\n-gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)\n+gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc\n TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc\n TESTS = gctest"}, {"sha": "1f03b511c3b298c6fc71abcdbfc3bc2d090d944e", "filename": "boehm-gc/Makefile.direct", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -36,7 +36,7 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_\n # -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n # To build the parallel collector in a static library on HP/UX,\n # add to the above:\n-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L\n+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L -mt\n # To build the thread-safe collector on Tru64, add to the above:\n # -pthread -DGC_OSF1_THREADS\n \n@@ -70,10 +70,11 @@ HOSTCFLAGS=$(CFLAGS)\n #   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n # -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n #   see README.linux.  -D_REENTRANT may also be required.\n-# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.\n-# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.\n+# -DGC_OSF1_THREADS enables support for Tru64 pthreads.\n+# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.\n #   Appeared to run into some underlying thread problems.\n-# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.  Untested.\n+# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.\n+# -DGC_AIX_THREADS enables support for IBM AIX threads.\n # -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.\n #   See README.DGUX386.\n # -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense\n@@ -233,8 +234,8 @@ HOSTCFLAGS=$(CFLAGS)\n # -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()\n #   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate\n #   in a way that usually does not involve acquisition of a global lock.\n-#   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n-#   other pthreads environments.  Recommended for multiprocessors.\n+#   Currently works only on platforms such as Linux which use pthread_support.c.\n+#   Recommended for multiprocessors.\n # -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported\n #   \"__thread\" thread-local variables.  This is the default in HP/UX.  It\n #   may help performance on recent Linux installations.  (It failed for\n@@ -276,16 +277,20 @@ HOSTCFLAGS=$(CFLAGS)\n # -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers\n #   by the indicated amount before trying to interpret them.  Applied\n #   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.\n+# -DDARWIN_DONT_PARSE_STACK Causes the Darwin port to discover thread\n+#   stack bounds in the same way as other pthread ports, without trying to\n+#   walk the frames onthe stack.  This is recommended only as a fallback\n+#   for applications that don't support proper stack unwinding.\n #\n \n CXXFLAGS= $(CFLAGS) \n AR= ar\n RANLIB= ranlib\n \n \n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o aix_irix_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c aix_irix_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n \n CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n "}, {"sha": "9580d7637fd1c8d6aca478eefab646fbeaed980d", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -65,12 +65,13 @@ DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \\\n-\t$(srcdir)/../config.sub\n+\t$(srcdir)/../compile $(srcdir)/../ltmain.sh \\\n+\t$(srcdir)/../config.guess $(srcdir)/../config.sub\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n \t$(top_srcdir)/../config/no-executables.m4 \\\n \t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n@@ -82,34 +83,36 @@ CONFIG_HEADER = $(top_builddir)/include/gc_config.h \\\n CONFIG_CLEAN_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-@POWERPC_DARWIN_TRUE@am__objects_1 = powerpc_darwin_mach_dep.lo\n-am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n+am_libgcjgc_la_OBJECTS = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n \tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n-\theaders.lo aix_irix_threads.lo malloc.lo mallocx.lo mark.lo \\\n-\tmark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo \\\n-\tpcr_interface.lo ptr_chck.lo real_malloc.lo reclaim.lo \\\n-\tsolaris_pthreads.lo solaris_threads.lo specific.lo stubborn.lo \\\n-\ttypd_mlc.lo backgraph.lo win32_threads.lo pthread_support.lo \\\n-\tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n-am_libgcjgc_la_OBJECTS = $(am__objects_2)\n+\theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n+\tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n+\treal_malloc.lo reclaim.lo solaris_pthreads.lo \\\n+\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n+\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n+\tpthread_stop_world.lo darwin_stop_world.lo\n libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)\n-am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)\n+am__objects_1 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n+\tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n+\theaders.lo malloc.lo mallocx.lo mark.lo mark_rts.lo misc.lo \\\n+\tnew_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo ptr_chck.lo \\\n+\treal_malloc.lo reclaim.lo solaris_pthreads.lo \\\n+\tsolaris_threads.lo specific.lo stubborn.lo typd_mlc.lo \\\n+\tbackgraph.lo win32_threads.lo pthread_support.lo \\\n+\tpthread_stop_world.lo darwin_stop_world.lo\n+am_libgcjgc_convenience_la_OBJECTS = $(am__objects_1)\n libgcjgc_convenience_la_OBJECTS =  \\\n \t$(am_libgcjgc_convenience_la_OBJECTS)\n am__dirstamp = $(am__leading_dot)dirstamp\n am_gctest_OBJECTS = tests/test.$(OBJEXT)\n gctest_OBJECTS = $(am_gctest_OBJECTS)\n-gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1) \\\n-\t$(am__DEPENDENCIES_1)\n+gctest_DEPENDENCIES = ./libgcjgc.la $(am__DEPENDENCIES_1)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_builddir)/include\n depcomp =\n am__depfiles_maybe =\n COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n \t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CCLD = $(CC)\n-CCASCOMPILE = $(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)\n-LTCCASCOMPILE = $(LIBTOOL) --mode=compile $(CCAS) $(AM_CCASFLAGS) \\\n-\t$(CCASFLAGS)\n SOURCES = $(libgcjgc_la_SOURCES) $(libgcjgc_convenience_la_SOURCES) \\\n \t$(gctest_SOURCES)\n MULTISRCTOP = \n@@ -254,34 +257,33 @@ SUBDIRS = include\n noinst_LTLIBRARIES = libgcjgc.la libgcjgc_convenience.la\n @POWERPC_DARWIN_FALSE@asm_libgc_sources = \n @POWERPC_DARWIN_TRUE@asm_libgc_sources = powerpc_darwin_mach_dep.s\n-GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n-dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \\\n+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c \\\n malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \\\n backgraph.c win32_threads.c \\\n pthread_support.c pthread_stop_world.c darwin_stop_world.c \\\n-$(asm_libgc_sources)\n+$(asm_libgcjgc_sources)\n \n+libgcjgc_convenience_la_SOURCES = $(libgcjgc_la_SOURCES)\n EXTRA_DIST = alpha_mach_dep.S \\\n mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_darwin_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.S sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s ia64_save_regs_in_stack.s\n \n-libgcjgc_la_SOURCES = $(GC_SOURCES)\n-libgcjgc_convenience_la_SOURCES = $(GC_SOURCES)\n \n # Include THREADLIBS here to ensure that the correct versions of\n # linuxthread semaphore functions get linked:\n-libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n+libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS) $(UNWINDLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n-libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n+libgcjgc_la_LDFLAGS = -version-info 1:2:0 -rpath $(toolexeclibdir)\n libgcjgc_convenience_la_LIBADD = @addobjs@\n libgcjgc_convenience_la_DEPENDENCIES = @addobjs@\n AM_CXXFLAGS = @GC_CFLAGS@\n AM_CFLAGS = @GC_CFLAGS@\n gctest_SOURCES = tests/test.c\n-gctest_LDADD = ./libgcjgc.la $(THREADLIBS) $(EXTRA_TEST_LIBS)\n+gctest_LDADD = ./libgcjgc.la $(THREADDLLIBS) $(UNWINDLIBS) $(EXTRA_TEST_LIBS)\n gctest_LDFLAGS = -shared-libgcc\n TESTS_ENVIRONMENT = LD_LIBRARY_PATH=../../$(MULTIBUILDTOP)gcc\n TESTS = gctest\n@@ -414,12 +416,6 @@ distclean-compile:\n .c.lo:\n \t$(LTCOMPILE) -c -o $@ $<\n \n-.s.o:\n-\t$(CCASCOMPILE) -c $<\n-\n-.s.obj:\n-\t$(CCASCOMPILE) -c `$(CYGPATH_W) '$<'`\n-\n mostlyclean-libtool:\n \t-rm -f *.lo\n "}, {"sha": "462791461f1f8369a71024bdd7300ae164041e80", "filename": "boehm-gc/aclocal.m4", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -547,39 +547,6 @@ AC_DEFUN([AM_PROG_INSTALL_SH],\n install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n AC_SUBST(install_sh)])\n \n-#                                                          -*- Autoconf -*-\n-# Copyright (C) 2003  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 1\n-\n-# Check whether the underlying file-system supports filenames\n-# with a leading dot.  For instance MS-DOS doesn't.\n-AC_DEFUN([AM_SET_LEADING_DOT],\n-[rm -rf .tst 2>/dev/null\n-mkdir .tst 2>/dev/null\n-if test -d .tst; then\n-  am__leading_dot=.\n-else\n-  am__leading_dot=_\n-fi\n-rmdir .tst 2>/dev/null\n-AC_SUBST([am__leading_dot])])\n-\n # Add --enable-maintainer-mode option to configure.\n # From Jim Meyering\n \n@@ -1168,5 +1135,7 @@ AC_SUBST([am__untar])\n ]) # _AM_PROG_TAR\n \n m4_include([../config/acx.m4])\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n m4_include([../config/no-executables.m4])\n m4_include([../libtool.m4])"}, {"sha": "5d27afd145ed2c711fc8e9321a9063a259fdab2f", "filename": "boehm-gc/aix_irix_threads.c", "status": "removed", "additions": 0, "deletions": 689, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac42ec79e00a729e9d92fc1d254862936ee68bbe/boehm-gc%2Faix_irix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac42ec79e00a729e9d92fc1d254862936ee68bbe/boehm-gc%2Faix_irix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faix_irix_threads.c?ref=ac42ec79e00a729e9d92fc1d254862936ee68bbe", "patch": "@@ -1,689 +0,0 @@\n-/* \n- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999-2003 by Hewlett-Packard Company. All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Support code for Irix (>=6.2) Pthreads and for AIX pthreads.\n- * This relies on properties\n- * not guaranteed by the Pthread standard.  It may or may not be portable\n- * to other implementations.\n- *\n- * Note that there is a lot of code duplication between this file and\n- * (pthread_support.c, pthread_stop_world.c).  They should be merged.\n- * Pthread_support.c should be directly usable.\n- *\n- * Please avoid adding new ports here; use the generic pthread support\n- * as a base instead.\n- */\n-\n-# include \"private/gc_priv.h\"\n-\n-# if defined(GC_IRIX_THREADS) || defined(GC_AIX_THREADS)\n-\n-# include <pthread.h>\n-# include <assert.h>\n-# include <semaphore.h>\n-# include <time.h>\n-# include <errno.h>\n-# include <unistd.h>\n-# include <sys/mman.h>\n-# include <sys/time.h>\n-\n-#undef pthread_create\n-#undef pthread_sigmask\n-#undef pthread_join\n-\n-#if defined(GC_IRIX_THREADS) && !defined(MUTEX_RECURSIVE_NP)\n-#define MUTEX_RECURSIVE_NP PTHREAD_MUTEX_RECURSIVE\n-#endif\n-\n-void GC_thr_init();\n-\n-#if 0\n-void GC_print_sig_mask()\n-{\n-    sigset_t blocked;\n-    int i;\n-\n-    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)\n-    \tABORT(\"pthread_sigmask\");\n-    GC_printf0(\"Blocked: \");\n-    for (i = 1; i <= MAXSIG; i++) {\n-        if (sigismember(&blocked, i)) { GC_printf1(\"%ld \",(long) i); }\n-    }\n-    GC_printf0(\"\\n\");\n-}\n-#endif\n-\n-/* We use the allocation lock to protect thread-related data structures. */\n-\n-/* The set of all known threads.  We intercept thread creation and \t*/\n-/* joins.  We never actually create detached threads.  We allocate all \t*/\n-/* new thread stacks ourselves.  These allow us to maintain this\t*/\n-/* data structure.\t\t\t\t\t\t\t*/\n-/* Protected by GC_thr_lock.\t\t\t\t\t\t*/\n-/* Some of this should be declared volatile, but that's incosnsistent\t*/\n-/* with some library routine declarations.  \t\t \t\t*/\n-typedef struct GC_Thread_Rep {\n-    struct GC_Thread_Rep * next;  /* More recently allocated threads\t*/\n-\t\t\t\t  /* with a given pthread id come \t*/\n-\t\t\t\t  /* first.  (All but the first are\t*/\n-\t\t\t\t  /* guaranteed to be dead, but we may  */\n-\t\t\t\t  /* not yet have registered the join.) */\n-    pthread_t id;\n-    word stop;\n-#\tdefine NOT_STOPPED 0\n-#\tdefine PLEASE_STOP 1\n-#\tdefine STOPPED 2\n-    word flags;\n-#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n-#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n-    ptr_t stack_cold;\t\t/* cold end of the stack\t\t*/\n-    ptr_t stack_hot;  \t\t/* Valid only when stopped. */\n-\t\t\t\t/* But must be within stack region at\t*/\n-\t\t\t\t/* all times.\t\t\t\t*/\n-    void * status;\t\t/* Used only to avoid premature \t*/\n-\t\t\t\t/* reclamation of any data it might \t*/\n-\t\t\t\t/* reference.\t\t\t\t*/\n-} * GC_thread;\n-\n-GC_thread GC_lookup_thread(pthread_t id);\n-\n-/*\n- * The only way to suspend threads given the pthread interface is to send\n- * signals.  Unfortunately, this means we have to reserve\n- * a signal, and intercept client calls to change the signal mask.\n- */\n-#if 0 /* DOB: 6.1 */\n-# if defined(GC_AIX_THREADS)\n-#   define SIG_SUSPEND SIGUSR1\n-# else\n-#   define SIG_SUSPEND (SIGRTMIN + 6)\n-# endif\n-#endif\n-\n-pthread_mutex_t GC_suspend_lock = PTHREAD_MUTEX_INITIALIZER;\n-\t\t\t\t/* Number of threads stopped so far\t*/\n-pthread_cond_t GC_suspend_ack_cv = PTHREAD_COND_INITIALIZER;\n-pthread_cond_t GC_continue_cv = PTHREAD_COND_INITIALIZER;\n-\n-void GC_suspend_handler(int sig)\n-{\n-    int dummy;\n-    GC_thread me;\n-    sigset_t all_sigs;\n-    sigset_t old_sigs;\n-    int i;\n-\n-    if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n-    me = GC_lookup_thread(pthread_self());\n-    /* The lookup here is safe, since I'm doing this on behalf  */\n-    /* of a thread which holds the allocation lock in order\t*/\n-    /* to stop the world.  Thus concurrent modification of the\t*/\n-    /* data structure is impossible.\t\t\t\t*/\n-    if (PLEASE_STOP != me -> stop) {\n-\t/* Misdirected signal.\t*/\n-\tpthread_mutex_unlock(&GC_suspend_lock);\n-\treturn;\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    me -> stack_hot = (ptr_t)(&dummy);\n-    me -> stop = STOPPED;\n-    pthread_cond_signal(&GC_suspend_ack_cv);\n-    pthread_cond_wait(&GC_continue_cv, &GC_suspend_lock);\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    /* GC_printf1(\"Continuing 0x%x\\n\", pthread_self()); */\n-}\n-\n-\n-GC_bool GC_thr_initialized = FALSE;\n-\n-\n-# define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n-volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n-\n-void GC_push_thread_structures GC_PROTO((void))\n-{\n-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n-}\n-\n-/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n-/* Caller holds allocation lock.\t\t\t\t\t*/\n-GC_thread GC_new_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    GC_thread result;\n-    static struct GC_Thread_Rep first_thread;\n-    static GC_bool first_thread_used = FALSE;\n-    \n-    GC_ASSERT(I_HOLD_LOCK());\n-    if (!first_thread_used) {\n-    \tresult = &first_thread;\n-    \tfirst_thread_used = TRUE;\n-    \t/* Dont acquire allocation lock, since we may already hold it. */\n-    } else {\n-        result = (struct GC_Thread_Rep *)\n-        \t GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep), NORMAL);\n-    }\n-    if (result == 0) return(0);\n-    result -> id = id;\n-    result -> next = GC_threads[hv];\n-    GC_threads[hv] = result;\n-    /* result -> flags = 0;     */\n-    /* result -> stop = 0;\t*/\n-    return(result);\n-}\n-\n-/* Delete a thread from GC_threads.  We assume it is there.\t*/\n-/* (The code intentionally traps if it wasn't.)\t\t\t*/\n-/* Caller holds allocation lock.\t\t\t\t*/\n-/* We explicitly pass in the GC_thread we're looking for, since */\n-/* if a thread has been joined, but we have not yet\t\t*/\n-/* been notified, then there may be more than one thread \t*/\n-/* in the table with the same pthread id.\t\t\t*/\n-/* This is OK, but we need a way to delete a specific one.\t*/\n-void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    register GC_thread prev = 0;\n-\n-    GC_ASSERT(I_HOLD_LOCK());\n-    while (p != gc_id) {\n-        prev = p;\n-        p = p -> next;\n-    }\n-    if (prev == 0) {\n-        GC_threads[hv] = p -> next;\n-    } else {\n-        prev -> next = p -> next;\n-    }\n-}\n-\n-/* Return a GC_thread corresponding to a given thread_t.\t*/\n-/* Returns 0 if it's not there.\t\t\t\t\t*/\n-/* Caller holds  allocation lock or otherwise inhibits \t\t*/\n-/* updates.\t\t\t\t\t\t\t*/\n-/* If there is more than one thread with the given id we \t*/\n-/* return the most recent one.\t\t\t\t\t*/\n-GC_thread GC_lookup_thread(pthread_t id)\n-{\n-    int hv = ((word)id) % THREAD_TABLE_SZ;\n-    register GC_thread p = GC_threads[hv];\n-    \n-    /* I either hold the lock, or i'm being called from the stop-the-world\n-     * handler. */\n-#if defined(GC_AIX_THREADS)\n-    GC_ASSERT(I_HOLD_LOCK()); /* no stop-the-world handler needed on AIX */\n-#endif\n-    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;\n-    return(p);\n-}\n-\n-#if defined(GC_AIX_THREADS)\n-void GC_stop_world()\n-{\n-    pthread_t my_thread = pthread_self();\n-    register int i;\n-    register GC_thread p;\n-    register int result;\n-    struct timespec timeout;\n-\n-    GC_ASSERT(I_HOLD_LOCK());\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-          pthread_suspend_np(p->id);\n-        }\n-      }\n-    }\n-    /* GC_printf1(\"World stopped 0x%x\\n\", pthread_self()); */\n-}\n-\n-void GC_start_world()\n-{\n-    GC_thread p;\n-    unsigned i;\n-    pthread_t my_thread = pthread_self();\n-\n-    /* GC_printf0(\"World starting\\n\"); */\n-    GC_ASSERT(I_HOLD_LOCK());\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-          pthread_continue_np(p->id);\n-        }\n-      }\n-    }\n-}\n-\n-#else /* GC_AIX_THREADS */\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_stop_world()\n-{\n-    pthread_t my_thread = pthread_self();\n-    register int i;\n-    register GC_thread p;\n-    register int result;\n-    struct timespec timeout;\n-    \n-    GC_ASSERT(I_HOLD_LOCK());\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> id != my_thread) {\n-            if (p -> flags & FINISHED) {\n-\t\tp -> stop = STOPPED;\n-\t\tcontinue;\n-\t    }\n-\t    p -> stop = PLEASE_STOP;\n-            result = pthread_kill(p -> id, SIG_SUSPEND);\n-\t    /* GC_printf1(\"Sent signal to 0x%x\\n\", p -> id); */\n-\t    switch(result) {\n-                case ESRCH:\n-                    /* Not really there anymore.  Possible? */\n-                    p -> stop = STOPPED;\n-                    break;\n-                case 0:\n-                    break;\n-                default:\n-                    ABORT(\"pthread_kill failed\");\n-            }\n-        }\n-      }\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        while (p -> id != my_thread && p -> stop != STOPPED) {\n-\t    clock_gettime(CLOCK_REALTIME, &timeout);\n-            timeout.tv_nsec += 50000000; /* 50 msecs */\n-            if (timeout.tv_nsec >= 1000000000) {\n-                timeout.tv_nsec -= 1000000000;\n-                ++timeout.tv_sec;\n-            }\n-            result = pthread_cond_timedwait(&GC_suspend_ack_cv,\n-\t\t\t\t\t    &GC_suspend_lock,\n-                                            &timeout);\n-            if (result == ETIMEDOUT) {\n-                /* Signal was lost or misdirected.  Try again.      */\n-                /* Duplicate signals should be benign.              */\n-                result = pthread_kill(p -> id, SIG_SUSPEND);\n-\t    }\n-\t}\n-      }\n-    }\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    /* GC_printf1(\"World stopped 0x%x\\n\", pthread_self()); */\n-}\n-\n-/* Caller holds allocation lock.\t*/\n-void GC_start_world()\n-{\n-    GC_thread p;\n-    unsigned i;\n-\n-    /* GC_printf0(\"World starting\\n\"); */\n-    GC_ASSERT(I_HOLD_LOCK());\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-\tp -> stop = NOT_STOPPED;\n-      }\n-    }\n-    pthread_mutex_lock(&GC_suspend_lock);\n-    /* All other threads are at pthread_cond_wait in signal handler.\t*/\n-    /* Otherwise we couldn't have acquired the lock.\t\t\t*/\n-    pthread_mutex_unlock(&GC_suspend_lock);\n-    pthread_cond_broadcast(&GC_continue_cv);\n-}\n-\n-#endif /* GC_AIX_THREADS */\n-\n-\n-/* We hold allocation lock.  Should do exactly the right thing if the\t*/\n-/* world is stopped.  Should not fail if it isn't.\t\t\t*/\n-void GC_push_all_stacks()\n-{\n-    register int i;\n-    register GC_thread p;\n-    register ptr_t hot, cold;\n-    pthread_t me = pthread_self();\n-    \n-    /* GC_init() should have been called before GC_push_all_stacks is\n-     * invoked, and GC_init calls GC_thr_init(), which sets\n-     * GC_thr_initialized. */\n-    GC_ASSERT(GC_thr_initialized);\n-\n-    /* GC_printf1(\"Pushing stacks from thread 0x%x\\n\", me); */\n-    GC_ASSERT(I_HOLD_LOCK());\n-    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n-      for (p = GC_threads[i]; p != 0; p = p -> next) {\n-        if (p -> flags & FINISHED) continue;\n-\tcold = p->stack_cold;\n-\tif (!cold) cold=GC_stackbottom; /* 0 indicates 'original stack' */\n-        if (pthread_equal(p -> id, me)) {\n-\t    hot = GC_approx_sp();\n-\t} else {\n-#        ifdef GC_AIX_THREADS\n-          /* AIX doesn't use signals to suspend, so we need to get an */\n-\t  /* accurate hot stack pointer.\t\t\t      */\n-\t  /* See http://publib16.boulder.ibm.com/pseries/en_US/libs/basetrf1/pthread_getthrds_np.htm */\n-          pthread_t id = p -> id;\n-          struct __pthrdsinfo pinfo;\n-          int regbuf[64];\n-          int val = sizeof(regbuf);\n-          int retval = pthread_getthrds_np(&id, PTHRDSINFO_QUERY_ALL, &pinfo,\n-\t\t\t  \t\t   sizeof(pinfo), regbuf, &val);\n-          if (retval != 0) {\n-\t    printf(\"ERROR: pthread_getthrds_np() failed in GC\\n\");\n-\t    abort();\n-\t  }\n-\t  /* according to the AIX ABI, \n-\t     \"the lowest possible valid stack address is 288 bytes (144 + 144)\n-\t     less than the current value of the stack pointer.  Functions may\n-\t     use this stack space as volatile storage which is not preserved\n-\t     across function calls.\"\n-\t     ftp://ftp.penguinppc64.org/pub/people/amodra/PPC-elf64abi.txt.gz\n-\t  */\n-          hot = (ptr_t)(unsigned long)pinfo.__pi_ustk-288;\n-\t  cold = (ptr_t)pinfo.__pi_stackend; /* more precise */\n-          /* push the registers too, because they won't be on stack */\n-          GC_push_all_eager((ptr_t)&pinfo.__pi_context,\n-\t\t\t    (ptr_t)((&pinfo.__pi_context)+1));\n-          GC_push_all_eager((ptr_t)regbuf, ((ptr_t)regbuf)+val);\n-#\t else\n-              hot = p -> stack_hot;\n-#\t endif\n-\t}\n-#\tifdef STACK_GROWS_UP\n-          GC_push_all_stack(cold, hot);\n-#\telse\n- /* printf(\"thread 0x%x: hot=0x%08x cold=0x%08x\\n\", p -> id, hot, cold); */\n-          GC_push_all_stack(hot, cold);\n-#\tendif\n-      }\n-    }\n-}\n-\n-\n-/* We hold the allocation lock.\t*/\n-void GC_thr_init()\n-{\n-    GC_thread t;\n-    struct sigaction act;\n-\n-    if (GC_thr_initialized) return;\n-    GC_ASSERT(I_HOLD_LOCK());\n-    GC_thr_initialized = TRUE;\n-#ifndef GC_AIX_THREADS\n-    (void) sigaction(SIG_SUSPEND, 0, &act);\n-    if (act.sa_handler != SIG_DFL)\n-    \tABORT(\"Previously installed SIG_SUSPEND handler\");\n-    /* Install handler.\t*/\n-\tact.sa_handler = GC_suspend_handler;\n-\tact.sa_flags = SA_RESTART;\n-\t(void) sigemptyset(&act.sa_mask);\n-        if (0 != sigaction(SIG_SUSPEND, &act, 0))\n-\t    ABORT(\"Failed to install SIG_SUSPEND handler\");\n-#endif\n-    /* Add the initial thread, so we can stop it.\t*/\n-      t = GC_new_thread(pthread_self());\n-      /* use '0' to indicate GC_stackbottom, since GC_init() has not\n-       * completed by the time we are called (from GC_init_inner()) */\n-      t -> stack_cold = 0; /* the original stack. */\n-      t -> stack_hot = (ptr_t)(&t);\n-      t -> flags = DETACHED;\n-}\n-\n-int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n-{\n-    sigset_t fudged_set;\n-    \n-#ifdef GC_AIX_THREADS\n-    return(pthread_sigmask(how, set, oset));\n-#endif\n-\n-    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {\n-        fudged_set = *set;\n-        sigdelset(&fudged_set, SIG_SUSPEND);\n-        set = &fudged_set;\n-    }\n-    return(pthread_sigmask(how, set, oset));\n-}\n-\n-struct start_info {\n-    void *(*start_routine)(void *);\n-    void *arg;\n-    word flags;\n-    pthread_mutex_t registeredlock;\n-    pthread_cond_t registered;     \n-    int volatile registereddone;\n-};\n-\n-void GC_thread_exit_proc(void *arg)\n-{\n-    GC_thread me;\n-\n-    LOCK();\n-    me = GC_lookup_thread(pthread_self());\n-    me -> flags |= FINISHED;\n-    /* reclaim DETACHED thread right away; otherwise wait until join() */\n-    if (me -> flags & DETACHED) {\n-\tGC_delete_gc_thread(pthread_self(), me);\n-    }\n-    UNLOCK();\n-}\n-\n-int GC_pthread_join(pthread_t thread, void **retval)\n-{\n-    int result;\n-    GC_thread thread_gc_id;\n-    \n-    LOCK();\n-    thread_gc_id = GC_lookup_thread(thread);\n-    /* This is guaranteed to be the intended one, since the thread id\t*/\n-    /* cant have been recycled by pthreads.\t\t\t\t*/\n-    UNLOCK();\n-    GC_ASSERT(!(thread_gc_id->flags & DETACHED));\n-    result = pthread_join(thread, retval);\n-    /* Some versions of the Irix pthreads library can erroneously \t*/\n-    /* return EINTR when the call succeeds.\t\t\t\t*/\n-\tif (EINTR == result) result = 0;\n-    GC_ASSERT(thread_gc_id->flags & FINISHED);\n-    LOCK();\n-    /* Here the pthread thread id may have been recycled. */\n-    GC_delete_gc_thread(thread, thread_gc_id);\n-    UNLOCK();\n-    return result;\n-}\n-\n-void * GC_start_routine(void * arg)\n-{\n-    int dummy;\n-    struct start_info * si = arg;\n-    void * result;\n-    GC_thread me;\n-    pthread_t my_pthread;\n-    void *(*start)(void *);\n-    void *start_arg;\n-\n-    my_pthread = pthread_self();\n-    /* If a GC occurs before the thread is registered, that GC will\t*/\n-    /* ignore this thread.  That's fine, since it will block trying to  */\n-    /* acquire the allocation lock, and won't yet hold interesting \t*/\n-    /* pointers.\t\t\t\t\t\t\t*/\n-    LOCK();\n-    /* We register the thread here instead of in the parent, so that\t*/\n-    /* we don't need to hold the allocation lock during pthread_create. */\n-    /* Holding the allocation lock there would make REDIRECT_MALLOC\t*/\n-    /* impossible.  It probably still doesn't work, but we're a little  */\n-    /* closer ...\t\t\t\t\t\t\t*/\n-    /* This unfortunately means that we have to be careful the parent\t*/\n-    /* doesn't try to do a pthread_join before we're registered.\t*/\n-    me = GC_new_thread(my_pthread);\n-    me -> flags = si -> flags;\n-    me -> stack_cold = (ptr_t) &dummy; /* this now the 'start of stack' */\n-    me -> stack_hot = me->stack_cold;/* this field should always be sensible */\n-    UNLOCK();\n-    start = si -> start_routine;\n-    start_arg = si -> arg;\n-\n-    pthread_mutex_lock(&(si->registeredlock));\n-    si->registereddone = 1;\n-    pthread_cond_signal(&(si->registered));\n-    pthread_mutex_unlock(&(si->registeredlock));\n-    /* si went away as soon as we did this unlock */\n-\n-    pthread_cleanup_push(GC_thread_exit_proc, 0);\n-    result = (*start)(start_arg);\n-    me -> status = result;\n-    pthread_cleanup_pop(1);\n-\t/* This involves acquiring the lock, ensuring that we can't exit */\n-\t/* while a collection that thinks we're alive is trying to stop  */\n-\t/* us.\t\t\t\t\t\t\t\t */\n-    return(result);\n-}\n-\n-int\n-GC_pthread_create(pthread_t *new_thread,\n-\t\t  const pthread_attr_t *attr,\n-                  void *(*start_routine)(void *), void *arg)\n-{\n-    int result;\n-    GC_thread t;\n-    int detachstate;\n-    word my_flags = 0;\n-    struct start_info * si;\n-    \t/* This is otherwise saved only in an area mmapped by the thread */\n-    \t/* library, which isn't visible to the collector.\t\t */\n-\n-    LOCK();\n-    /* GC_INTERNAL_MALLOC implicitly calls GC_init() if required */\n-    si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info),\n-\t\t\t\t\t\t NORMAL);\n-    GC_ASSERT(GC_thr_initialized); /* initialized by GC_init() */\n-    UNLOCK();\n-    if (0 == si) return(ENOMEM);\n-    pthread_mutex_init(&(si->registeredlock), NULL);\n-    pthread_cond_init(&(si->registered),NULL);\n-    pthread_mutex_lock(&(si->registeredlock));\n-    si -> start_routine = start_routine;\n-    si -> arg = arg;\n-\n-    pthread_attr_getdetachstate(attr, &detachstate);\n-    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n-    si -> flags = my_flags;\n-    result = pthread_create(new_thread, attr, GC_start_routine, si); \n-\n-    /* Wait until child has been added to the thread table.\t\t*/\n-    /* This also ensures that we hold onto si until the child is done\t*/\n-    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n-    /* visible to the collector.\t\t\t\t\t*/\n-\n-    if (0 == result) {\n-      si->registereddone = 0;\n-      while (!si->registereddone) \n-        pthread_cond_wait(&(si->registered), &(si->registeredlock));\n-    }\n-    pthread_mutex_unlock(&(si->registeredlock));\n-\n-    pthread_cond_destroy(&(si->registered));\n-    pthread_mutex_destroy(&(si->registeredlock));\n-    LOCK();\n-    GC_INTERNAL_FREE(si);\n-    UNLOCK();\n-\n-    return(result);\n-}\n-\n-/* For now we use the pthreads locking primitives on HP/UX */\n-\n-VOLATILE GC_bool GC_collecting = 0; /* A hint that we're in the collector and       */\n-                        /* holding the allocation lock for an           */\n-                        /* extended period.                             */\n-\n-/* Reasonably fast spin locks.  Basically the same implementation */\n-/* as STL alloc.h.\t\t\t\t\t\t  */\n-\n-#define SLEEP_THRESHOLD 3\n-\n-volatile unsigned int GC_allocate_lock = 0;\n-#define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock)\n-#define GC_LOCK_TAKEN GC_allocate_lock\n-\n-void GC_lock()\n-{\n-#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n-#   define high_spin_max 1000 /* spin cycles for multiprocessor */\n-    static unsigned spin_max = low_spin_max;\n-    unsigned my_spin_max;\n-    static unsigned last_spins = 0;\n-    unsigned my_last_spins;\n-    volatile unsigned junk;\n-#   define PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n-    int i;\n-\n-    if (GC_TRY_LOCK()) {\n-        return;\n-    }\n-    junk = 0;\n-    my_spin_max = spin_max;\n-    my_last_spins = last_spins;\n-    for (i = 0; i < my_spin_max; i++) {\n-        if (GC_collecting) goto yield;\n-        if (i < my_last_spins/2 || GC_LOCK_TAKEN) {\n-            PAUSE; \n-            continue;\n-        }\n-        if (GC_TRY_LOCK()) {\n-\t    /*\n-             * got it!\n-             * Spinning worked.  Thus we're probably not being scheduled\n-             * against the other process with which we were contending.\n-             * Thus it makes sense to spin longer the next time.\n-\t     */\n-            last_spins = i;\n-            spin_max = high_spin_max;\n-            return;\n-        }\n-    }\n-    /* We are probably being scheduled against the other process.  Sleep. */\n-    spin_max = low_spin_max;\n-yield:\n-    for (i = 0;; ++i) {\n-        if (GC_TRY_LOCK()) {\n-            return;\n-        }\n-        if (i < SLEEP_THRESHOLD) {\n-            sched_yield();\n-\t} else {\n-\t    struct timespec ts;\n-\t\n-\t    if (i > 26) i = 26;\n-\t\t\t/* Don't wait for more than about 60msecs, even\t*/\n-\t\t\t/* under extreme contention.\t\t\t*/\n-\t    ts.tv_sec = 0;\n-\t    ts.tv_nsec = 1 << i;\n-\t    nanosleep(&ts, 0);\n-\t}\n-    }\n-}\n-\n-# else  /* !GC_IRIX_THREADS && !GC_AIX_THREADS */\n-\n-#ifndef LINT\n-  int GC_no_Irix_threads;\n-#endif\n-\n-# endif /* IRIX_THREADS */\n-"}, {"sha": "1a1efc6b91b920dcdacdf1582394eb63ee461443", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -285,8 +285,8 @@ int n;\n \tGET_HDR(hhdr -> hb_prev, phdr);\n \tphdr -> hb_next = hhdr -> hb_next;\n     }\n+    FREE_ASSERT(GC_free_bytes[index] >= hhdr -> hb_sz);\n     INCR_FREE_BYTES(index, - (signed_word)(hhdr -> hb_sz));\n-    FREE_ASSERT(GC_free_bytes[index] >= 0);\n     if (0 != hhdr -> hb_next) {\n \thdr * nhdr;\n \tGC_ASSERT(!IS_FORWARDING_ADDR_OR_NIL(NHDR(hhdr)));"}, {"sha": "9b4869f91b28066cbe3dc933adf7f9e97941c6ab", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -92,6 +92,16 @@ char * GC_copyright[] =\n \n # include \"version.h\"\n \n+#if defined(SAVE_CALL_CHAIN) && \\\n+\t!(defined(REDIRECT_MALLOC) && defined(GC_HAVE_BUILTIN_BACKTRACE))\n+#   define SAVE_CALL_CHAIN_IN_GC\n+    /* This is only safe if the call chain save mechanism won't end up\t*/\n+    /* calling GC_malloc.  The GNU C library documentation suggests \t*/\n+    /* that backtrace doesn't use malloc, but at least the initial\t*/\n+    /* call in some versions does seem to invoke the dynamic linker,\t*/\n+    /* which uses malloc.\t\t\t\t\t\t*/\n+#endif\n+\n /* some more variables */\n \n extern signed_word GC_mem_found;  /* Number of reclaimed longwords\t*/\n@@ -196,7 +206,8 @@ word GC_adj_words_allocd()\n     \t/* had been reallocated this round. Finalization is user\t*/\n     \t/* visible progress.  And if we don't count this, we have\t*/\n     \t/* stability problems for programs that finalize all objects.\t*/\n-    result += GC_words_wasted;\n+    if ((GC_words_wasted >> 3) < result)\n+        result += GC_words_wasted;\n      \t/* This doesn't reflect useful work.  But if there is lots of\t*/\n      \t/* new fragmentation, the same is probably true of the heap,\t*/\n      \t/* and the collection will be correspondingly cheaper.\t\t*/\n@@ -221,6 +232,8 @@ void GC_clear_a_few_frames()\n {\n #   define NWORDS 64\n     word frames[NWORDS];\n+    /* Some compilers will warn that frames was set but never used.\t*/\n+    /* That's the whole idea ...\t\t\t\t\t*/\n     register int i;\n     \n     for (i = 0; i < NWORDS; i++) frames[i] = 0;\n@@ -293,7 +306,7 @@ void GC_maybe_gc()\n #\tendif\n         if (GC_stopped_mark(GC_time_limit == GC_TIME_UNLIMITED? \n \t\t\t    GC_never_stop_func : GC_timeout_stop_func)) {\n-#           ifdef SAVE_CALL_CHAIN\n+#           ifdef SAVE_CALL_CHAIN_IN_GC\n                 GC_save_callers(GC_last_stack);\n #           endif\n             GC_finish_collection();\n@@ -358,7 +371,7 @@ GC_stop_func stop_func;\n \t}\n     GC_invalidate_mark_state();  /* Flush mark stack.\t*/\n     GC_clear_marks();\n-#   ifdef SAVE_CALL_CHAIN\n+#   ifdef SAVE_CALL_CHAIN_IN_GC\n         GC_save_callers(GC_last_stack);\n #   endif\n     GC_is_full_gc = TRUE;\n@@ -413,7 +426,7 @@ int n;\n     \tfor (i = GC_deficit; i < GC_RATE*n; i++) {\n     \t    if (GC_mark_some((ptr_t)0)) {\n     \t        /* Need to finish a collection */\n-#     \t\tifdef SAVE_CALL_CHAIN\n+#     \t\tifdef SAVE_CALL_CHAIN_IN_GC\n         \t    GC_save_callers(GC_last_stack);\n #     \t\tendif\n #\t\tifdef PARALLEL_MARK\n@@ -929,7 +942,7 @@ word n;\n #   endif\n     expansion_slop = WORDS_TO_BYTES(min_words_allocd()) + 4*MAXHINCR*HBLKSIZE;\n     if (GC_last_heap_addr == 0 && !((word)space & SIGNB)\n-        || GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space) {\n+        || (GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space)) {\n         /* Assume the heap is growing up */\n         GC_greatest_plausible_heap_addr =\n             (GC_PTR)GC_max((ptr_t)GC_greatest_plausible_heap_addr,\n@@ -992,7 +1005,7 @@ word needed_blocks;\n GC_bool ignore_off_page;\n {\n     if (!GC_incremental && !GC_dont_gc &&\n-\t(GC_dont_expand && GC_words_allocd > 0 || GC_should_collect())) {\n+\t((GC_dont_expand && GC_words_allocd > 0) || GC_should_collect())) {\n       GC_gcollect_inner();\n     } else {\n       word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)\n@@ -1001,6 +1014,9 @@ GC_bool ignore_off_page;\n       if (blocks_to_get > MAXHINCR) {\n           word slop;\n           \n+\t  /* Get the minimum required to make it likely that we\t\t*/\n+\t  /* can satisfy the current request in the presence of black-\t*/\n+\t  /* listing.  This will probably be more than MAXHINCR.\t*/\n           if (ignore_off_page) {\n               slop = 4;\n           } else {"}, {"sha": "d4def2405f9edf6cde19cfdc0a4d7d642d7e5738", "filename": "boehm-gc/alpha_mach_dep.S", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Falpha_mach_dep.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Falpha_mach_dep.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falpha_mach_dep.S?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1,4 +1,3 @@\n- # $Id: alpha_mach_dep.s,v 1.2 1993/01/18 22:54:51 dosser Exp $\n \t.arch ev6\n \n         .text\n@@ -12,13 +11,13 @@ GC_push_regs:\n         .mask   0x04000000, 0\n         .frame  $sp, 16, $26, 0\n \n- # $0\t\tinteger result\n- # $1-$8\ttemp regs - not preserved cross calls\n- # $9-$15\tcall saved regs\n- # $16-$21\targument regs - not preserved cross calls\n- # $22-$28\ttemp regs - not preserved cross calls\n- # $29\t\tglobal pointer - not preserved cross calls\n- # $30\t\tstack pointer\n+/* $0\t\tinteger result                                                */\n+/* $1-$8\ttemp regs - not preserved cross calls                         */\n+/* $9-$15\tcall saved regs                                               */\n+/* $16-$21\targument regs - not preserved cross calls                     */\n+/* $22-$28\ttemp regs - not preserved cross calls                         */\n+/* $29\t\tglobal pointer - not preserved cross calls                    */\n+/* $30\t\tstack pointer                                                 */\n \n # define call_push(x)\t\t\t\\\n \tmov   x, $16;\t\t\t\\\n@@ -33,12 +32,12 @@ GC_push_regs:\n         call_push($14)\n         call_push($15)\n \n- # $f0-$f1\tfloating point results\n- # $f2-$f9\tcall saved regs\n- # $f10-$f30\ttemp regs - not preserved cross calls\n+/* $f0-$f1\tfloating point results                                        */\n+/* $f2-$f9\tcall saved regs                                               */\n+/* $f10-$f30\ttemp regs - not preserved cross calls                         */\n \n-\t# Use the most efficient transfer method for this hardware.\n-\t# Bit 1 detects the FIX extension, which includes ftoit.\n+\t/* Use the most efficient transfer method for this hardware. */\n+\t/* Bit 1 detects the FIX extension, which includes ftoit. */\n \tamask\t2, $0\n \tbne\t$0, $use_stack\n "}, {"sha": "a4aeaa8f43d500a8ecb704e156af87badd225fd7", "filename": "boehm-gc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1767,7 +1767,7 @@ fi\n \n # Define the identity of the package.\n  PACKAGE=gc\n- VERSION=6.3\n+ VERSION=6.6\n \n \n # Some tools Automake needs."}, {"sha": "f33135f1dea9c53d38ddc62d671b48ce1f95144d", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -36,7 +36,7 @@ ACX_NONCANONICAL_TARGET\n mkinstalldirs=\"`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs\"\n AC_SUBST(mkinstalldirs)\n \n-AM_INIT_AUTOMAKE(gc, 6.3, no-define)\n+AM_INIT_AUTOMAKE(gc, 6.6, no-define)\n \n # The autoconf 2.5x version of the no-executables hack.\n GCC_NO_EXECUTABLES"}, {"sha": "6d278feda65b55dbfee6217c21588903aa6ef2ae", "filename": "boehm-gc/cord/cordprnt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -59,7 +59,7 @@ static int extract_conv_spec(CORD_pos source, char *buf,\n     register int result = 0;\n     register int current_number = 0;\n     register int saw_period = 0;\n-    register int saw_number;\n+    register int saw_number = 0;\n     register int chars_so_far = 0;\n     register char current;\n     \n@@ -243,7 +243,7 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n \t\t\t    char * str = va_arg(args, char *);\n \t\t\t    register char c;\n \n-\t\t\t    while (c = *str++) {\n+\t\t\t    while ((c = *str++)) {\n \t\t\t        CORD_ec_append(result, c);\n \t\t\t    }\n \t\t\t    goto done;\n@@ -320,7 +320,7 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n             \t    if (buf != result[0].ec_bufptr) {\n             \t        register char c;\n \n-\t\t\twhile (c = *buf++) {\n+\t\t\twhile ((c = *buf++)) {\n \t\t\t    CORD_ec_append(result, c);\n \t\t        }\n \t\t    } else {"}, {"sha": "08333ca043406ac596f636f06af7ff6fc68fa499", "filename": "boehm-gc/cord/cordtest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fcordtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fcordtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordtest.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -221,7 +221,7 @@ void test_printf()\n     if (CORD_cmp(result, result2) != 0)ABORT(\"CORD_sprintf goofed 5\");\n }\n \n-main()\n+int main()\n {\n #   ifdef THINK_C\n         printf(\"cordtest:\\n\");"}, {"sha": null, "filename": "boehm-gc/cord/de_win.ICO", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fde_win.ICO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fcord%2Fde_win.ICO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.ICO?ref=54f28c21ee515da92119551983d51118a3666e85"}, {"sha": "22c76a857332f2ea0c3596d7a08d061221afc66a", "filename": "boehm-gc/darwin_stop_world.c", "status": "modified", "additions": 104, "deletions": 9, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdarwin_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdarwin_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdarwin_stop_world.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -14,7 +14,13 @@\n    Page 50: \"If a leaf procedure's red zone usage would exceed 224 bytes, then\n    it must set up a stack frame just like routines that call other routines.\"\n */\n-#define PPC_RED_ZONE_SIZE 224\n+#ifdef POWERPC\n+# if CPP_WORDSZ == 32\n+#   define PPC_RED_ZONE_SIZE 224\n+# elif CPP_WORDSZ == 64\n+#   define PPC_RED_ZONE_SIZE 320\n+# endif\n+#endif\n \n typedef struct StackFrame {\n   unsigned long\tsavedSP;\n@@ -24,12 +30,17 @@ typedef struct StackFrame {\n   unsigned long\tsavedRTOC;\n } StackFrame;\n \n-\n-unsigned int FindTopOfStack(unsigned int stack_start) {\n+unsigned long FindTopOfStack(unsigned int stack_start) {\n   StackFrame\t*frame;\n   \n   if (stack_start == 0) {\n-    __asm__ volatile(\"lwz\t%0,0(r1)\" : \"=r\" (frame));\n+# ifdef POWERPC\n+#   if CPP_WORDSZ == 32\n+      __asm__ volatile(\"lwz\t%0,0(r1)\" : \"=r\" (frame));\n+#   else\n+      __asm__ volatile(\"ldz\t%0,0(r1)\" : \"=r\" (frame));\n+#   endif\n+# endif\n   } else {\n     frame = (StackFrame *)stack_start;\n   }\n@@ -38,7 +49,7 @@ unsigned int FindTopOfStack(unsigned int stack_start) {\n     /* GC_printf1(\"FindTopOfStack start at sp = %p\\n\", frame); */\n # endif\n   do {\n-    if (frame->savedSP == NULL) break;\n+    if (frame->savedSP == 0) break;\n     \t\t/* if there are no more stack frames, stop */\n \n     frame = (StackFrame*)frame->savedSP;\n@@ -54,9 +65,88 @@ unsigned int FindTopOfStack(unsigned int stack_start) {\n     /* GC_printf1(\"FindTopOfStack finish at sp = %p\\n\", frame); */\n # endif\n \n-  return (unsigned int)frame;\n+  return (unsigned long)frame;\n }\t\n \n+#ifdef DARWIN_DONT_PARSE_STACK\n+void GC_push_all_stacks() {\n+  int i;\n+  kern_return_t r;\n+  GC_thread p;\n+  pthread_t me;\n+  ptr_t lo, hi;\n+  ppc_thread_state_t state;\n+  mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;\n+  \n+  me = pthread_self();\n+  if (!GC_thr_initialized) GC_thr_init();\n+  \n+  for(i=0;i<THREAD_TABLE_SZ;i++) {\n+    for(p=GC_threads[i];p!=0;p=p->next) {\n+      if(p -> flags & FINISHED) continue;\n+      if(pthread_equal(p->id,me)) {\n+\tlo = GC_approx_sp();\n+      } else {\n+\t/* Get the thread state (registers, etc) */\n+\tr = thread_get_state(\n+\t\t\t     p->stop_info.mach_thread,\n+\t\t\t     MACHINE_THREAD_STATE,\n+\t\t\t     (natural_t*)&state,\n+\t\t\t     &thread_state_count);\n+\tif(r != KERN_SUCCESS) ABORT(\"thread_get_state failed\");\n+\t\n+\tlo = (void*)(state.r1 - PPC_RED_ZONE_SIZE);\n+        \n+\tGC_push_one(state.r0); \n+\tGC_push_one(state.r2); \n+\tGC_push_one(state.r3); \n+\tGC_push_one(state.r4); \n+\tGC_push_one(state.r5); \n+\tGC_push_one(state.r6); \n+\tGC_push_one(state.r7); \n+\tGC_push_one(state.r8); \n+\tGC_push_one(state.r9); \n+\tGC_push_one(state.r10); \n+\tGC_push_one(state.r11); \n+\tGC_push_one(state.r12); \n+\tGC_push_one(state.r13); \n+\tGC_push_one(state.r14); \n+\tGC_push_one(state.r15); \n+\tGC_push_one(state.r16); \n+\tGC_push_one(state.r17); \n+\tGC_push_one(state.r18); \n+\tGC_push_one(state.r19); \n+\tGC_push_one(state.r20); \n+\tGC_push_one(state.r21); \n+\tGC_push_one(state.r22); \n+\tGC_push_one(state.r23); \n+\tGC_push_one(state.r24); \n+\tGC_push_one(state.r25); \n+\tGC_push_one(state.r26); \n+\tGC_push_one(state.r27); \n+\tGC_push_one(state.r28); \n+\tGC_push_one(state.r29); \n+\tGC_push_one(state.r30); \n+\tGC_push_one(state.r31);\n+      } /* p != me */\n+      if(p->flags & MAIN_THREAD)\n+\thi = GC_stackbottom;\n+      else\n+\thi = p->stack_end;\n+#if DEBUG_THREADS\n+      GC_printf3(\"Darwin: Stack for thread 0x%lx = [%lx,%lx)\\n\",\n+\t\t (unsigned long) p -> id,\n+\t\t (unsigned long) lo,\n+\t\t (unsigned long) hi\n+\t\t );\n+#endif\n+      GC_push_all_stack(lo,hi);\n+    } /* for(p=GC_threads[i]...) */\n+  } /* for(i=0;i<THREAD_TABLE_SZ...) */\n+}\n+\n+#else /* !DARWIN_DONT_PARSE_STACK; Use FindTopOfStack() */\n+\n void GC_push_all_stacks() {\n     int i;\n     kern_return_t r;\n@@ -76,8 +166,12 @@ void GC_push_all_stacks() {\n \tlo = GC_approx_sp();\n \thi = (ptr_t)FindTopOfStack(0);\n       } else {\n-#      ifdef POWERPC\n+#     if defined(POWERPC)\n+#      if CPP_WORDSZ == 32\n \tppc_thread_state_t info;\n+#      else\n+\tppc_thread_state64_t info;\n+#      endif\n \tmach_msg_type_number_t outCount = THREAD_STATE_MAX;\n \tr = thread_get_state(thread, MACHINE_THREAD_STATE,\n \t\t\t     (natural_t *)&info, &outCount);\n@@ -156,6 +250,7 @@ void GC_push_all_stacks() {\n       GC_push_all_stack(lo, hi); \n     } /* for(p=GC_threads[i]...) */\n }\n+#endif /* !DARWIN_DONT_PARSE_STACK */\n \n static mach_port_t GC_mach_handler_thread;\n static int GC_use_mach_handler_thread = 0;\n@@ -325,6 +420,8 @@ void GC_start_world()\n   kern_return_t kern_result;\n   thread_act_array_t act_list;\n   mach_msg_type_number_t listcount;\n+  struct thread_basic_info info;\n+  mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n   \n #   if DEBUG_THREADS\n       GC_printf0(\"World starting\\n\");\n@@ -351,8 +448,6 @@ void GC_start_world()\n #             endif\n \t      continue;\n \t    }\n-\t    struct thread_basic_info info;\n-\t    mach_msg_type_number_t outCount = THREAD_INFO_MAX;\n \t    kern_result = thread_info(thread, THREAD_BASIC_INFO,\n \t\t\t\t      (thread_info_t)&info, &outCount);\n \t    if(kern_result != KERN_SUCCESS) ABORT(\"thread_info failed\");"}, {"sha": "a19cb3021b0aa9568f3ec265e4aca5a2961606ce", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -28,7 +28,7 @@ are GPL'ed, but with an exception that should cover all uses in the\n collector.  (If you are concerned about such things, I recommend you look\n at the notice in config.guess or ltmain.sh.)\n \n-This is version 6.3 of a conservative garbage collector for C and C++.\n+This is version 6.6 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n "}, {"sha": "97b0b684dde5b556750993056e3240d3bee1c2f5", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -2100,7 +2100,151 @@ Since gc6.3alpha6:\n    to Andrew Begel.)\n  - Fix GC_task_self declaration in os_dep.c.  (Thanks to Andrew Pinski.)\n  - Increase INITIAL_BUF_SZ in os_dep.c for Solaris /proc reads.\n+\n+Since 6.3:\n+ - Merge gcconfig.h changes from gcc tree.\n+ - Unconditionally include gc_priv.h in solaris_pthreads.c, win32_threads.h,\n+   aix_irix_threads.c, and solaris_threads.c to get thread definitions.\n+ - Start marker threads in GC_thr_init, so that they get started even\n+   if no other threads are ever started.  (Oddly enough, the parallel\n+   collector worked correctly, though not well, with no helper threads.)\n+ - Go ahead and split large blocks in GC_allochblk_nth if GC_dont_gc\n+   is set.  (Thanks to Alexander Petrossian.)\n+ - GC_PRINT_BACK_HEIGHT would deadlock with thread support.\n+ - Let in_progress_space in backgraph.s grow dynamically.\n+ - Fix README.solaris2.  The GC_thr_init() hack doesn't work anymore.\n+ - Convert GC_finalizer_mem_freed to bytes in allchblk.c.\n+ - Add missing declaration for GC_generic_malloc_words_small_inner.\n+   Without it, s390x breaks.  (Thanks to Ulrich Weigand.)\n+ - Applied several MacOSX patches to support older tool chains.\n+   (Thanks to Stefan Ring.)\n+ - Bug fix for NetBSD/amd64.  (Thanks to Marc Recht.)  Add NetBSD/sh3\n+   support.  (Thanks to Uchiyama Yasushi.)\n+ - Fixed an uninitialized variable in cordprnt.c.  (Thanks to gcc for\n+   providing the warning.)\n+ - Eliminated some, but not all, gcc -Wall warnings.\n+ - Changed some old style casts to reinterpret_cast in new_gc_alloc.h.\n+   (Thanks to Dan Grayson.)\n+ - GC_extend_size_map shouldn't adjust for GC_all_interior_pointers if\n+   GC_DONT_ADD_BYTE_AT_END is set.\n+ - Changed some (long) casts to (word) in preparation for win64.\n+   (Thanks to Peter Colson.)\n+ - Changed \"int stack_size\" declaration in pthread_support.c to use\n+   size_t.  (Only mattered with GC_ASSERTIONS enabled.)\n+ - Added CRIS (etrax) support.  (Thanks to Simon Posnjak and\n+   Hans-Peter Nilsson.)\n+ - Removed GC_IGNORE_FB frame buffer recognition, and replaced\n+   it with a check that the mapping type is MEM_IMAGE.\n+   In theory, this should work much better, but it is a high\n+   risk change for win32.  (Thanks to Ashley Bone for the crucial\n+   experimental data behind this, and to Rutger Ovidus for\n+   some further experiments.)\n+ - Fixed print_block_list to print the correct kind number for\n+   STUBBORN.  (Thanks to Rutger Ovidus.)\n+ - GC_allochblk_nth incremented GC_words_wasted by bytes rather than\n+   words.\n+ - Consider GC_words_wasted in GC_adj_words_allocd only if it is within\n+   reason.  (A hack to avoid some extremely unlikely scenarios in which\n+   we manage to allocate only \"wasted\" space.  7.0 has a better fix.)\n+ - Changed PowerPC GC_clear implementation to use lwsync instead of\n+   eieio, since the documentation recommends against eieio, and\n+   it seems to be incorrect if the preceding memory op is a load.\n+ - Fixed print_block_list to print the correct kind number for\n+   STUBBORN.  (Thanks to Rutger Ovidus.)\n+ - Have configure.in generate an error if it is asked to support\n+   pthreads, but doesn't know how to.\n+ - Added Kazuhiro Inaoka's patch for Renesas M32R support.\n+ - Have the GNU build mechanism link with -ldl.  Rename THREADLIBS\n+   to THREADDLLIBS to reflect this.  (Thanks to Sven Verdoolaege.)\n+ - Added Hannes Mehnert's patch for FreeBSD/SPARC support.\n+ - Merged some FreeBSD specific patches to threadlibs.c and dyn_load.c.\n+   (Thanks tp John Merryweather Cooper.)\n+ - Define MPROTECT_VDB on MACOSX only if threads are being used, since the\n+   dirty page tracking mechanism uses threads.  (This avoids an undefined\n+   reference to _GC_darwin_register_mach_handler_thread.)\n+ - By popular demand, use __libc symbols only if we are built with\n+   USE_LIBC_PRIVATES, which is off by default, and not otherwise documented.\n+ - Ignore GC_enable_incremental() requests when KEEP_BACK_PTRS is set.\n+   The GC itself will dirty lots of pages in this cases, probably making\n+   it counterproductive on all platforms.  And the DARWIN port crashes.\n+\n+Since GC6.4:\n+ - Integrated Paolo Molaro's patch to deal with EINTR in sem_wait.\n+ - Make GC_approx_sp() write to dummy location to ensure that stack\n+   is grown here, when sp looks reasonable, rather than later, when\n+   it might look like a bad memory reference.  (Problem was never\n+   observed that I know of.  But on rereading the code it seemed\n+   dubious.)\n+ - Separate out GC_with_callee_saves_pushed and sometimes call\n+   it from GC_suspend_handler in pthread_stop_world.c.  Callee-save\n+   register values sometimes failed to get traced under HP/UX on\n+   PA-RISC.  Linux/IA64 had the same problem, though non-stacked\n+   callee-save registers seem to be so rarely used there that nobody\n+   ever noticed.\n+ - Integrated an ancient Darwin powerpc_darwin_machine_dep.s patch\n+   from Andreas Tobler, which I had lost.\n+ - Fix compare_and_exchange implementation for gcc/IA64 to deal with\n+   pickier compiler versions.\n+ - Fixed Itanium 32-bit ABI support (HP/UX).  In particular, the\n+   compare_and_exchange implementation didn't consider that possibility.\n+ - Undefine GC_pthread_detach in win32_threads.c.  (Thanks to\n+   Tagliapietra Tommaso.)\n+ - Fixed inclusion of frame.h for NETBSD in os_dep.c.\n+ - Applied Dan Bonachea's patch to use mmap on AIX.\n+ - Several fixes to resurrect the Irix port on recent OS versions.\n+ - Change ALPHA to use LINUX_STACKBOTTOM.\n+ - Change SPARC64/LINUX to also use LINUX_STACKBOTTOM.  Deal with potential\n+   bad values of __libc_stack_end on that platform.  (Thanks to David Miller.)\n+ - Relax gctest to allow larger heap if ALIGN_DOUBLE isn't set.\n+   (Unnecessary in 7.0)\n+ - Force a define of __STDC__=0 for the IBM compiler on AIX, so that\n+   we get prototypes.  (Unnecessary in 7.0)\n+ - GC_INIT definition for AIX and CYGWIN referred to DATASTART and DATAEND\n+   which are only defined in private include files.\n+ - Integrated some small gcconfig.h patches from Dan Bonachea.  Also\n+   relaxed assertion about FreeBSD stack size in pthread_support.c.\n+ - Integrated Andrew Begel's darwin_stop_world.c patch for 64-bit\n+   support.  This may need additional work.\n+ - Avoided potentially infinite recursion in GC_save_callers if\n+   the system backtrace calls malloc.  The workaround currently requires\n+   __thread support if this code is used with threads.\n+ - Avoided another similar infinite recursion by conditionally\n+   invoking GC_save_callers in alloc.c.  (Thanks to Matthias Andree\n+   for helping to track down both of these.)\n+ - Removed all traces of aix_irix_threads.c.  AIX and Irix now use\n+   pthread_support.c and pthread_stop_world.c.  The old code appeared\n+   to be unreliable for AIX, and was not regularly maintained.\n+ - On Irix, ignore segments with MA_FETCHOP or MA_NOTCACHED attributed;\n+   they're not always safe to read.\n+ - Fixed a previously vacuous assertion (diagnosed by the SGI compiler)\n+   in GC_remove_from_fl.\n+ - Fix stack_size assertion in GC_pthread_create.\n+ - Fix assertion in GC_steal_mark_stack.\n   \n+Since 6.5\n+ - Fix CPU count detection for Irix and FreeBSD. (Thanks to Dan Bonachea.)\n+ - Integrate Dan Bonachea's patch for the IBM XLC compiler on Darwin.\n+ - Integrated Andreas Tobler's FreeBSD/PowerPC patch.\n+ - Don't access the GC thread structure from the restart handler.  It's\n+   unsafe, since the handler may run too late.  (Thanks to Ben Maurer for\n+   tracking this down.)\n+ - Applied Christian Thalinger's patch to change comment syntax in\n+   alpha_mach_dep.S.\n+ - Added test for GC_no_dls in GC_dyld_image_add for DARWIN. (Thanks to\n+   Juan Jose Garcia Ripoli).\n+ - Use LINUX_STACKBOTTOM for Linux/SH and LINUX/ARM. (Thanks to Sugioka\n+   Toshinobu and Christian Thalinger.)\n+ - Rewrote GC_parse_map_entry.  This assumed a fixed column layout of\n+   /proc/self/maps on Linux.  This ceased to be true about 2 years ago.\n+   The old code is probably quite problemetic with -DREDIRECT_MALLOC.  It\n+   is also used by default for IA64, though I haven't seen actual failures\n+   there.\n+ - More consistently define HBLKSIZE to 4096 on 64 bit architectures with\n+   4K pages.  (Thanks to Andrew Haley.)\n+ - With win32 threads, GC_stop_world needs to acquire GC_write_cs.  (Thanks\n+   to Ben Hutchings for the observation and patch.)\n+ - Move up struct callinfo declaration to make gcc 4.0.2. happy.\n+\n To do:\n  - The USE_MUNMAP code should really use a separate data structure\n    indexed by physical page to keep track of time since last use of"}, {"sha": "70954971fc05abc9f234ca1af16bc344609516b6", "filename": "boehm-gc/doc/README.darwin", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.darwin?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1,3 +1,16 @@\n+6.5 update:\n+I disabled incremental GC on Darwin in this version, since I couldn't\n+get gctest to pass when the GC was built as a dynamic library.  Building\n+with -DMPROTECT_VDB (and threads) on the command line should get you\n+back to the old state.\t\t\t- HB\n+\n+./configure --enable-cplusplus results in a \"make check\" failure, probably\n+because the ::delete override ends up in a separate dl, and Darwin dynamic\n+loader semantics appear to be such that this is not really visible to the\n+main program, unlike on ELF systems.  Someone who understands dynamic\n+loading needs to lookat this.  For now, gc_cpp.o needs to be linked\n+statically, if needed.\t\t\t- HB\n+\n Darwin/MacOSX Support - December 16, 2003\n =========================================\n "}, {"sha": "686e948250b6332c89b452ee703d86e19b5d50f2", "filename": "boehm-gc/doc/README.environment", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -115,6 +115,7 @@ GC_IGNORE_FB[=<n>] -  (Win32 only.) Try to avoid treating a mapped\n \t\tare never honored, eliminating this risk for most,\n \t\tbut not all, applications.  This feature is likely to disappear\n \t\tif/when we find a less disgusting \"solution\".\n+\t\tIN VERSION 6.4 AND LATER, THIS SHOULD BE UNNECESSARY.\n \n The following turn on runtime flags that are also program settable.  Checked\n only during initialization.  We expect that they will usually be set through"}, {"sha": "ec4e7e641a067bfa6e46a6b2475ddf4fff57060c", "filename": "boehm-gc/doc/README.linux", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.linux?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -19,10 +19,10 @@ Linux threads.  These should not be touched by the client program.\n \n To use threads, you need to abide by the following requirements:\n \n-1) You need to use LinuxThreads (which are included in libc6).\n+1) You need to use LinuxThreads or NPTL (which are included in libc6).\n \n    The collector relies on some implementation details of the LinuxThreads\n-   package.  It is unlikely that this code will work on other\n+   package.  This code may not work on other\n    pthread implementations (in particular it will *not* work with\n    MIT pthreads).\n "}, {"sha": "31e7500382dd6984fea151583664902d20abcf52", "filename": "boehm-gc/doc/README.solaris2", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdoc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.solaris2?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -43,9 +43,7 @@ can result in unpleasant heap growth.  But it seems better than the\n race/deadlock issues we had before.\n \n If solaris_threads are used on an X86 processor with malloc redirected to\n-GC_malloc, it is necessary to call GC_thr_init explicitly before forking the\n-first thread.  (This avoids a deadlock arising from calling GC_thr_init\n-with the allocation lock held.)\n+GC_malloc a deadlock is likely to result.\n \n It appears that there is a problem in using gc_cpp.h in conjunction with\n Solaris threads and Sun's C++ runtime.  Apparently the overloaded new operator"}, {"sha": "749bf824681a7d14831a8cb5a9b44c226614b158", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -96,17 +96,25 @@\n /* Newer versions of GNU/Linux define this macro.  We\n  * define it similarly for any ELF systems that don't.  */\n #  ifndef ElfW\n-#    ifdef __NetBSD__\n-#      if ELFSIZE == 32\n+#    if defined(FREEBSD)\n+#      if __ELF_WORD_SIZE == 32\n #        define ElfW(type) Elf32_##type\n #      else\n #        define ElfW(type) Elf64_##type\n #      endif\n #    else\n-#      if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n-#        define ElfW(type) Elf32_##type\n+#      ifdef NETBSD\n+#        if ELFSIZE == 32\n+#          define ElfW(type) Elf32_##type\n+#        else\n+#          define ElfW(type) Elf64_##type\n+#        endif\n #      else\n-#        define ElfW(type) Elf64_##type\n+#        if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n+#          define ElfW(type) Elf32_##type\n+#        else\n+#          define ElfW(type) Elf64_##type\n+#\t endif\n #      endif\n #    endif\n #  endif\n@@ -485,7 +493,6 @@ static struct link_map *\n GC_FirstDLOpenedLinkMap()\n {\n     ElfW(Dyn) *dp;\n-    struct r_debug *r;\n     static struct link_map *cachedResult = 0;\n \n     if( _DYNAMIC == 0) {\n@@ -494,6 +501,12 @@ GC_FirstDLOpenedLinkMap()\n     if( cachedResult == 0 ) {\n         int tag;\n         for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {\n+\t    /* FIXME: The DT_DEBUG header is not mandated by the\t*/\n+\t    /* ELF spec.  This code appears to be dependent on\t\t*/\n+\t    /* idiosynchracies of older GNU tool chains.  If this code\t*/\n+\t    /* fails for you, the real problem is probably that it is\t*/\n+\t    /* being used at all.  You should be getting the \t\t*/\n+\t    /* dl_iterate_phdr version.\t\t\t\t\t*/\n             if( tag == DT_DEBUG ) {\n                 struct link_map *lm\n                         = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n@@ -618,7 +631,8 @@ void GC_register_dynamic_libraries()\n     }\n     for (i = 0; i < needed_sz; i++) {\n         flags = addr_map[i].pr_mflags;\n-        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS)) != 0) goto irrelevant;\n+        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS\n+\t\t      | MA_FETCHOP | MA_NOTCACHED)) != 0) goto irrelevant;\n         if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))\n             goto irrelevant;\n           /* The latter test is empirically useless in very old Irix\t*/\n@@ -758,25 +772,27 @@ void GC_register_dynamic_libraries()\n  \n   /* Should [start, start+len) be treated as a frame buffer\t*/\n   /* and ignored?\t\t\t\t\t\t*/\n-  /* Unfortunately, we currently have no real way to tell\t*/\n-  /* automatically, and rely largely on user input.\t\t*/\n-  /* FIXME: If we had more data on this phenomenon (e.g.\t*/\n-  /* is start aligned to a MB multiple?) we should be able to\t*/\n-  /* do better.\t\t\t\t\t\t\t*/\n+  /* Unfortunately, we currently are not quite sure how to tell\t*/\n+  /* this automatically, and rely largely on user input.\t*/\n+  /* We expect that any mapping with type MEM_MAPPED (which \t*/\n+  /* apparently excludes library data sections) can be safely\t*/\n+  /* ignored.  But we're too chicken to do that in this \t*/\n+  /* version.\t\t\t\t\t\t\t*/\n   /* Based on a very limited sample, it appears that:\t\t*/\n-  /* \t- Frame buffer mappings appear as mappings of length\t*/\n-  /* \t  2**n MB - 192K.  (We guess the 192K can vary a bit.)\t*/\n-  /*\t- Have a stating address at best 64K aligned.\t\t*/\n-  /* I'd love more information about the mapping, since I\t*/\n-  /* can't reproduce the problem.\t\t\t\t*/\n-  static GC_bool is_frame_buffer(ptr_t start, size_t len)\n+  /* \t- Frame buffer mappings appear as mappings of large\t*/\n+  /*\t  length, usually a bit less than a power of two.\t*/\n+  /*\t- The definition of \"a bit less\" in the above cannot\t*/\n+  /*\t  be made more precise.\t\t\t\t\t*/\n+  /*\t- Have a starting address at best 64K aligned.\t\t*/\n+  /*\t- Have type == MEM_MAPPED.\t\t\t\t*/\n+  static GC_bool is_frame_buffer(ptr_t start, size_t len, DWORD tp)\n   {\n     static GC_bool initialized = FALSE;\n #   define MB (1024*1024)\n #   define DEFAULT_FB_MB 15\n #   define MIN_FB_MB 3\n \n-    if (GC_disallow_ignore_fb) return FALSE;\n+    if (GC_disallow_ignore_fb || tp != MEM_MAPPED) return FALSE;\n     if (!initialized) {\n       char * ignore_fb_string =  GETENV(\"GC_IGNORE_FB\");\n \n@@ -869,7 +885,7 @@ void GC_register_dynamic_libraries()\n \t\t * !is_frame_buffer(p, buf.RegionSize, buf.Type)\n \t\t * instead of just checking for MEM_IMAGE.\n \t\t * If something breaks, change it back. */\n-\t\t&& buf.Type == MEM_IMAGE) {\n+\t\t&& buf.Type == MEM_IMAGE) {  \n #\t        ifdef DEBUG_VIRTUALQUERY\n \t          GC_dump_meminfo(&buf);\n #\t        endif\n@@ -1125,21 +1141,22 @@ static const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n static void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n     unsigned long start,end,i;\n     const struct section *sec;\n+    if (GC_no_dls) return;\n     for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n         sec = getsectbynamefromheader(\n             hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n-            if(sec == NULL || sec->size == 0) continue;\n-            start = slide + sec->addr;\n-            end = start + sec->size;\n-#\t\tifdef DARWIN_DEBUG\n-                GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n+        if(sec == NULL || sec->size == 0) continue;\n+        start = slide + sec->addr;\n+        end = start + sec->size;\n+#\tifdef DARWIN_DEBUG\n+            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n                 start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n-#\t\t\tendif\n+#       endif\n         GC_add_roots((char*)start,(char*)end);\n-        }\n-#\tifdef DARWIN_DEBUG\n-    GC_print_static_roots();\n-#\tendif\n+    }\n+#   ifdef DARWIN_DEBUG\n+        GC_print_static_roots();\n+#   endif\n }\n \n /* This should never be called by a thread holding the lock */\n@@ -1152,15 +1169,15 @@ static void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide) {\n         if(sec == NULL || sec->size == 0) continue;\n         start = slide + sec->addr;\n         end = start + sec->size;\n-#\t\tifdef DARWIN_DEBUG\n+#\tifdef DARWIN_DEBUG\n             GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n                 start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n #\t\tendif\n         GC_remove_roots((char*)start,(char*)end);\n     }\n-#\tifdef DARWIN_DEBUG\n-    GC_print_static_roots();\n-#\tendif\n+#   ifdef DARWIN_DEBUG\n+        GC_print_static_roots();\n+#   endif\n }\n \n void GC_register_dynamic_libraries() {"}, {"sha": "cccac11bbbdf93f0af461076bdb5569e0d3e8d5e", "filename": "boehm-gc/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -43,6 +43,8 @@ DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \\\n \t$(srcdir)/gc_ext_config.h.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n \t$(top_srcdir)/../config/no-executables.m4 \\\n \t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\"}, {"sha": "cfc8658ac39962962f2b5b13717ec57cad9a0607", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -55,7 +55,7 @@\n # include <gc_config.h>\n # include \"gc_config_macros.h\"\n \n-# if defined(__STDC__) || defined(__cplusplus)\n+# if defined(__STDC__) || defined(__cplusplus) || defined(_AIX)\n #   define GC_PROTO(args) args\n     typedef void * GC_PTR;\n #   define GC_CONST const\n@@ -214,7 +214,7 @@ GC_API GC_word GC_free_space_divisor;\n \t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n \t\t\t/* collections, where N is the heap size plus\t*/\n \t\t\t/* a rough estimate of the root set size.\t*/\n-\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n+\t\t\t/* Initially, GC_free_space_divisor = 3.\t*/\n \t\t\t/* Increasing its value will use less space\t*/\n \t\t\t/* but more collection time.  Decreasing it\t*/\n \t\t\t/* will appreciably decrease collection time\t*/\n@@ -340,6 +340,9 @@ GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n /* the base of the user object.\t\t\t\t\t\t*/\n /* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n /* object.\t\t\t\t\t\t\t\t*/\n+/* Note that a deallocated object in the garbage collected heap\t\t*/\n+/* may be considered valid, even if it has been deallocated with\t*/\n+/* GC_free.  \t\t\t\t\t\t\t\t*/\n GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n \n /* Given a pointer to the base of an object, return its size in bytes.\t*/\n@@ -877,7 +880,7 @@ GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n \n /* Safer assignment of a pointer to a nonstack location.\t*/\n #ifdef GC_DEBUG\n-# ifdef __STDC__\n+# if defined(__STDC__) || defined(_AIX)\n #   define GC_PTR_STORE(p, q) \\\n \t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n # else\n@@ -972,12 +975,32 @@ extern void GC_thr_init GC_PROTO((void));/* Needed for Solaris/X86\t*/\n #   define GC_INIT() { extern end, etext; \\\n \t\t       GC_noop(&end, &etext); }\n #else\n-# if defined(__CYGWIN32__) && defined(GC_DLL) || defined (_AIX)\n+# if defined(__CYGWIN32__) || defined (_AIX)\n     /*\n      * Similarly gnu-win32 DLLs need explicit initialization from\n      * the main program, as does AIX.\n      */\n-#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n+#   ifdef __CYGWIN32__\n+      extern int _data_start__[];\n+      extern int _data_end__[];\n+      extern int _bss_start__[];\n+      extern int _bss_end__[];\n+#     define GC_MAX(x,y) ((x) > (y) ? (x) : (y))\n+#     define GC_MIN(x,y) ((x) < (y) ? (x) : (y))\n+#     define GC_DATASTART ((GC_PTR) GC_MIN(_data_start__, _bss_start__))\n+#     define GC_DATAEND\t ((GC_PTR) GC_MAX(_data_end__, _bss_end__))\n+#     ifdef GC_DLL\n+#       define GC_INIT() { GC_add_roots(GC_DATASTART, GC_DATAEND); }\n+#     else\n+#       define GC_INIT()\n+#     endif\n+#   endif\n+#   if defined(_AIX)\n+      extern int _data[], _end[];\n+#     define GC_DATASTART ((GC_PTR)((ulong)_data))\n+#     define GC_DATAEND ((GC_PTR)((ulong)_end))\n+#     define GC_INIT() { GC_add_roots(GC_DATASTART, GC_DATAEND); }\n+#   endif\n # else\n #  if defined(__APPLE__) && defined(__MACH__) || defined(GC_WIN32_THREADS)\n #   define GC_INIT() { GC_init(); }"}, {"sha": "5bb720ca34489895742992bf54e3c83a64ff04c7", "filename": "boehm-gc/include/gc_config_macros.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc_config_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc_config_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config_macros.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -59,6 +59,10 @@\n #   define GC_DGUX386_THREADS\n #   define GC_PTHREADS\n # endif\n+# if defined(_AIX)\n+#   define GC_AIX_THREADS\n+#   define GC_PTHREADS\n+# endif\n #endif /* GC_THREADS */\n \n #if defined(GC_THREADS) && !defined(GC_PTHREADS) && \\"}, {"sha": "4f56f0d965fcf360112686fb0cdfb86fe315a468", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -74,7 +74,7 @@ cycle, then that's considered a storage leak, and neither will be\n collectable.  See the interface gc.h for low-level facilities for\n handling such cycles of objects with clean-up.\n \n-The collector cannot guarrantee that it will find all inaccessible\n+The collector cannot guarantee that it will find all inaccessible\n objects.  In practice, it finds almost all of them.\n \n "}, {"sha": "7546638c981a5060523cd6bafc5a52cc956aaf96", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -109,7 +109,7 @@ enum { GC_byte_alignment = 8 };\n enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };\n \n inline void * &GC_obj_link(void * p)\n-{   return *(void **)p;  }\n+{   return *reinterpret_cast<void **>(p);  }\n \n // Compute a number of words >= n+1 bytes.\n // The +1 allows for pointers one past the end.\n@@ -228,7 +228,7 @@ class single_client_gc_alloc_template {\n \t    } else {\n \t        flh = GC_objfreelist_ptr + nwords;\n \t        GC_obj_link(p) = *flh;\n-\t\tmemset((char *)p + GC_bytes_per_word, 0,\n+\t\tmemset(reinterpret_cast<char *>(p) + GC_bytes_per_word, 0,\n \t\t       GC_bytes_per_word * (nwords - 1));\n \t        *flh = p;\n \t        GC_aux::GC_mem_recently_freed += nwords;\n@@ -352,9 +352,9 @@ class simple_alloc<T, alloc> { \\\n public: \\\n     static T *allocate(size_t n) \\\n \t{ return 0 == n? 0 : \\\n-\t\t\t (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \\\n+\t\t\t reinterpret_cast<T*>(alloc::ptr_free_allocate(n * sizeof (T))); } \\\n     static T *allocate(void) \\\n-\t{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \\\n+\t{ return reinterpret_cast<T*>(alloc::ptr_free_allocate(sizeof (T))); } \\\n     static void deallocate(T *p, size_t n) \\\n \t{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \\\n     static void deallocate(T *p) \\"}, {"sha": "70dfefe8fa7dc2725d2b14a409abe2fd7447a507", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -108,7 +108,7 @@ extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n \n /* Analogous to GET_HDR, except that in the case of large objects, it\t*/\n /* Returns the header for the object beginning, and updates p.\t\t*/\n-/* Returns &GC_bad_header instead of 0.  All of this saves a branch\t*/\n+/* Returns GC_invalid_header instead of 0.  All of this saves a branch\t*/\n /* in the fast path.\t\t\t\t\t\t\t*/\n # define HC_GET_HDR(p, hhdr, source) \\\n \t{ \\"}, {"sha": "1faf2d3d2091fdff2f3e48d82509ac16ef6e3791", "filename": "boehm-gc/include/private/gc_locks.h", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -139,6 +139,25 @@\n #      define GC_TEST_AND_SET_DEFINED\n #    endif\n #    if defined(POWERPC)\n+#     if CPP_WORDSZ == 64\n+        inline static int GC_test_and_set(volatile unsigned int *addr) {\n+          unsigned long oldval;\n+          unsigned long temp = 1; /* locked value */\n+\n+          __asm__ __volatile__(\n+               \"1:\\tldarx %0,0,%3\\n\"   /* load and reserve               */\n+               \"\\tcmpdi %0, 0\\n\"       /* if load is                     */\n+               \"\\tbne 2f\\n\"            /*   non-zero, return already set */\n+               \"\\tstdcx. %2,0,%1\\n\"    /* else store conditional         */\n+               \"\\tbne- 1b\\n\"           /* retry if lost reservation      */\n+               \"\\tsync\\n\"              /* import barrier                 */\n+               \"2:\\t\\n\"                /* oldval is zero if we set       */\n+              : \"=&r\"(oldval), \"=p\"(addr)\n+              : \"r\"(temp), \"1\"(addr)\n+              : \"cr0\",\"memory\");\n+          return (int)oldval;\n+        }\n+#     else\n         inline static int GC_test_and_set(volatile unsigned int *addr) {\n           int oldval;\n           int temp = 1; /* locked value */\n@@ -156,12 +175,13 @@\n               : \"cr0\",\"memory\");\n           return oldval;\n         }\n-#       define GC_TEST_AND_SET_DEFINED\n-        inline static void GC_clear(volatile unsigned int *addr) {\n-\t  __asm__ __volatile__(\"eieio\" : : : \"memory\");\n-          *(addr) = 0;\n-        }\n-#       define GC_CLEAR_DEFINED\n+#     endif\n+#     define GC_TEST_AND_SET_DEFINED\n+      inline static void GC_clear(volatile unsigned int *addr) {\n+\t__asm__ __volatile__(\"lwsync\" : : : \"memory\");\n+        *(addr) = 0;\n+      }\n+#     define GC_CLEAR_DEFINED\n #    endif\n #    if defined(ALPHA) \n         inline static int GC_test_and_set(volatile unsigned int * addr)\n@@ -282,6 +302,8 @@\n #          define GC_test_and_set(addr) test_and_set((void *)addr,1)\n #\t endif\n #    else\n+#\t include <sgidefs.h>\n+#\t include <mutex.h>\n #\t define GC_test_and_set(addr) __test_and_set32((void *)addr,1)\n #\t define GC_clear(addr) __lock_release(addr);\n #\t define GC_CLEAR_DEFINED\n@@ -354,7 +376,7 @@\n #  endif\n \n #  if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-      && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS)\n+      && !defined(GC_WIN32_THREADS)\n #    define NO_THREAD (pthread_t)(-1)\n #    include <pthread.h>\n #    if defined(PARALLEL_MARK) \n@@ -401,6 +423,29 @@\n \n #     if defined(POWERPC)\n #      if !defined(GENERIC_COMPARE_AND_SWAP)\n+#       if CPP_WORDSZ == 64\n+        /* Returns TRUE if the comparison succeeded. */\n+        inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+            GC_word old, GC_word new_val) \n+        {\n+            unsigned long result, dummy;\n+            __asm__ __volatile__(\n+                \"1:\\tldarx %0,0,%5\\n\"\n+                  \"\\tcmpd %0,%4\\n\"\n+                  \"\\tbne  2f\\n\"\n+                  \"\\tstdcx. %3,0,%2\\n\"\n+                  \"\\tbne- 1b\\n\"\n+                  \"\\tsync\\n\"\n+                  \"\\tli %1, 1\\n\"\n+                  \"\\tb 3f\\n\"\n+                \"2:\\tli %1, 0\\n\"\n+                \"3:\\t\\n\"\n+                :  \"=&r\" (dummy), \"=r\" (result), \"=p\" (addr)\n+                :  \"r\" (new_val), \"r\" (old), \"2\"(addr)\n+                : \"cr0\",\"memory\");\n+            return (GC_bool) result;\n+        }\n+#       else\n         /* Returns TRUE if the comparison succeeded. */\n         inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n             GC_word old, GC_word new_val) \n@@ -422,6 +467,7 @@\n                 : \"cr0\",\"memory\");\n             return (GC_bool) result;\n         }\n+#       endif\n #      endif /* !GENERIC_COMPARE_AND_SWAP */\n         inline static void GC_memory_barrier()\n         {\n@@ -598,33 +644,6 @@\n       extern pthread_t GC_mark_lock_holder;\n #   endif\n #  endif /* GC_PTHREADS with linux_threads.c implementation */\n-#  if defined(GC_IRIX_THREADS)\n-#    include <pthread.h>\n-     /* This probably should never be included, but I can't test\t*/\n-     /* on Irix anymore.\t\t\t\t\t\t*/\n-#    include <mutex.h>\n-\n-     extern volatile unsigned int GC_allocate_lock;\n-\t/* This is not a mutex because mutexes that obey the (optional) \t*/\n-\t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n-\t/* applications.  This is basically a spin lock.\t\t\t*/\n-     extern pthread_t GC_lock_holder;\n-     extern void GC_lock(void);\n-\t/* Allocation lock holder.  Only set if acquired by client through */\n-\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n-#    define NO_THREAD (pthread_t)(-1)\n-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    define LOCK() { if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n-#    define UNLOCK() GC_clear(&GC_allocate_lock);\n-     extern VOLATILE GC_bool GC_collecting;\n-#    define ENTER_GC() \\\n-\t\t{ \\\n-\t\t    GC_collecting = 1; \\\n-\t\t}\n-#    define EXIT_GC() GC_collecting = 0;\n-#  endif /* GC_IRIX_THREADS */\n #  if defined(GC_WIN32_THREADS)\n #    if defined(GC_PTHREADS)\n #      include <pthread.h>"}, {"sha": "38685bcd1264ca4530b65ebd5ea8995491aad8b9", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -262,17 +262,6 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n /*                               */\n /*********************************/\n \n-#ifdef SAVE_CALL_CHAIN\n-\n-/* Fill in the pc and argument information for up to NFRAMES of my\t*/\n-/* callers.  Ignore my frame and my callers frame.\t\t\t*/\n-struct callinfo;\n-void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));\n-  \n-void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n-\n-#endif\n-\n #ifdef NEED_CALLINFO\n     struct callinfo {\n \tword ci_pc;  \t/* Caller, not callee, pc\t*/\n@@ -286,6 +275,16 @@ void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n     };\n #endif\n \n+#ifdef SAVE_CALL_CHAIN\n+\n+/* Fill in the pc and argument information for up to NFRAMES of my\t*/\n+/* callers.  Ignore my frame and my callers frame.\t\t\t*/\n+void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));\n+  \n+void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));\n+\n+#endif\n+\n \n /*********************************/\n /*                               */"}, {"sha": "044fcf81c00cf2b5bdd9109b7f6de50b7ac15a05", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 84, "deletions": 48, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -55,7 +55,7 @@\n # endif\n \n /* And one for FreeBSD: */\n-# if defined(__FreeBSD__)\n+# if defined(__FreeBSD__) && !defined(FREEBSD)\n #    define FREEBSD\n # endif\n \n@@ -97,6 +97,10 @@\n #    define ARM32\n #    define mach_type_known\n # endif\n+# if defined(NETBSD) && defined(__sh__)\n+#    define SH\n+#    define mach_type_known\n+# endif\n # if defined(vax)\n #    define VAX\n #    ifdef ultrix\n@@ -167,7 +171,7 @@\n #   define mach_type_known\n # endif\n # if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \\\n-     && !defined(__OpenBSD__) && !(__NetBSD__)\n+     && !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__)\n #   define SPARC\n #   define DRSNX\n #   define mach_type_known\n@@ -198,14 +202,16 @@\n # if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \\\n      || defined(hppa) || defined(__hppa__)\n #   define HP_PA\n-#   ifndef LINUX\n+#   if !defined(LINUX) && !defined(HPUX)\n #     define HPUX\n #   endif\n #   define mach_type_known\n # endif\n # if defined(__ia64) && defined(_HPUX_SOURCE)\n #   define IA64\n-#   define HPUX\n+#   ifndef HPUX\n+#     define HPUX\n+#   endif\n #   define mach_type_known\n # endif\n # if defined(__BEOS__) && defined(_X86_)\n@@ -235,7 +241,8 @@\n #    endif\n #    define mach_type_known\n # endif\n-# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || defined(powerpc64) || defined(__powerpc64__))\n+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__) || \\\n+\t\t        defined(powerpc64) || defined(__powerpc64__))\n #    define POWERPC\n #    define mach_type_known\n # endif\n@@ -293,11 +300,11 @@\n #    define DARWIN\n #    define POWERPC\n #    define mach_type_known\n-# endif\n-# if defined(__APPLE__) && defined(__MACH__) && defined(__i386__)\n-#    define DARWIN\n-#    define I386\n+# else\n+#    if defined(__i386__)\n+#      define I386\n      --> Not really supported, but at least we recognize it.\n+#    endif\n # endif\n # if defined(NeXT) && defined(mc68000)\n #   define M68K\n@@ -326,6 +333,10 @@\n #    define X86_64\n #    define mach_type_known\n # endif\n+# if defined(FREEBSD) && defined(__sparc__)\n+#    define SPARC\n+#    define mach_type_known\n+#endif\n # if defined(bsdi) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define BSDI\n@@ -486,19 +497,22 @@\n \t\t    /*\t\t   POWERPC    ==> IBM/Apple PowerPC\t*/\n \t\t    /*\t\t\t(MACOS(<=9),DARWIN(incl.MACOSX),*/\n \t\t    /*\t\t\t LINUX, NETBSD, NOSYS variants)\t*/\n+\t\t    /*\t\t\tHandles 32 and 64-bit variants.\t*/\n+\t\t    /* \t\t\tAIX should be handled here, but\t*/\n+\t\t    /*\t\t\tthat's called an RS6000.\t*/\n \t\t    /*\t\t   CRIS       ==> Axis Etrax\t\t*/\n \t\t    /*\t\t   M32R\t      ==> Renesas M32R\t\t*/\n \n \n /*\n  * For each architecture and OS, the following need to be defined:\n  *\n- * CPP_WORD_SZ is a simple integer constant representing the word size.\n+ * CPP_WORDSZ is a simple integer constant representing the word size.\n  * in bits.  We assume byte addressibility, where a byte has 8 bits.\n- * We also assume CPP_WORD_SZ is either 32 or 64.\n+ * We also assume CPP_WORDSZ is either 32 or 64.\n  * (We care about the length of pointers, not hardware\n  * bus widths.  Thus a 64 bit processor with a C compiler that uses\n- * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n+ * 32 bit pointers should use CPP_WORDSZ of 32, not 64. Default is 32.)\n  *\n  * MACH_TYPE is a string representation of the machine type.\n  * OS_TYPE is analogous for the OS.\n@@ -615,7 +629,8 @@\n  */\n # if defined(__GNUC__) && ((__GNUC__ >= 3) || \\\n \t\t\t   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)) \\\n-\t\t       && !defined(__INTEL_COMPILER)\n+\t\t       && !defined(__INTEL_COMPILER) \\\n+ \t\t       && !defined(__PATHCC__)\n #   define HAVE_BUILTIN_UNWIND_INIT\n # endif\n \n@@ -740,7 +755,7 @@\n #   endif\n # endif\n \n-# ifdef POWERPC\n+# if defined(POWERPC)\n #   define MACH_TYPE \"POWERPC\"\n #   ifdef MACOS\n #     define ALIGNMENT 2  /* Still necessary?  Could it be 4?\t*/\n@@ -753,10 +768,12 @@\n #     define DATAEND  /* not needed */\n #   endif\n #   ifdef LINUX\n-#     if (defined (powerpc64) || defined(__powerpc64__))\n+#     if defined(__powerpc64__)\n #       define ALIGNMENT 8\n #       define CPP_WORDSZ 64\n-#       define HBLKSIZE 4096\n+#       ifndef HBLKSIZE\n+#         define HBLKSIZE 4096\n+#       endif\n #     else\n #       define ALIGNMENT 4\n #     endif\n@@ -770,7 +787,7 @@\n #     define DATAEND (_end)\n #   endif\n #   ifdef DARWIN\n-#     if (defined (__ppc64__))\n+#     ifdef __ppc64__\n #       define ALIGNMENT 8\n #       define CPP_WORDSZ 64\n #     else\n@@ -787,8 +804,10 @@\n #     define USE_MMAP_ANON\n #     define USE_ASM_PUSH_REGS\n       /* This is potentially buggy. It needs more testing. See the comments in\n-         os_dep.c */\n-#     define MPROTECT_VDB\n+         os_dep.c.  It relies on threads to track writes. */\n+#     ifdef GC_DARWIN_THREADS\n+/* #       define MPROTECT_VDB -- diabled for now.  May work for some apps. */\n+#     endif\n #     include <unistd.h>\n #     define GETPAGESIZE() getpagesize()\n #     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)\n@@ -975,6 +994,23 @@\n #\tdefine DATASTART ((ptr_t)(etext))\n #     endif\n #   endif\n+#   ifdef FREEBSD\n+#\tdefine OS_TYPE \"FREEBSD\"\n+#\tdefine SIG_SUSPEND SIGUSR1\n+#\tdefine SIG_THR_RESTART SIGUSR2\n+#\tdefine FREEBSD_STACKBOTTOM\n+#\tifdef __ELF__\n+#\t    define DYNAMIC_LOADING\n+#\tendif\n+\textern char etext[];\n+\textern char edata[];\n+\textern char end[];\n+#\tdefine NEED_FIND_LIMIT\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#\tdefine DATAEND (GC_find_limit (DATASTART, TRUE))\n+#\tdefine DATASTART2 ((ptr_t)(&edata))\n+#\tdefine DATAEND2 ((ptr_t)(&end))\n+#   endif\n # endif\n \n # ifdef I386\n@@ -1158,26 +1194,8 @@\n #   endif\n #   ifdef CYGWIN32\n #       define OS_TYPE \"CYGWIN32\"\n-          extern int _data_start__[];\n-          extern int _data_end__[];\n-          extern int _bss_start__[];\n-          extern int _bss_end__[];\n-  \t/* For binutils 2.9.1, we have\t\t\t*/\n-  \t/*\tDATASTART   = _data_start__\t\t*/\n-  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n-  \t/* whereas for some earlier versions it was\t*/\n-  \t/*\tDATASTART   = _bss_start__\t\t*/\n-  \t/*\tDATAEND\t    = _data_end__\t\t*/\n-  \t/* To get it right for both, we take the\t*/\n-  \t/* minumum/maximum of the two.\t\t\t*/\n-#     ifndef MAX\n-#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n-#     endif\n-#     ifndef MIN\n-#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n-#     endif\n-#       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))\n-#       define DATAEND\t ((ptr_t) MAX(_data_end__, _bss_end__))\n+#       define DATASTART ((ptr_t)GC_DATASTART)  /* From gc.h */\n+#       define DATAEND\t ((ptr_t)GC_DATAEND)\n #\tundef STACK_GRAN\n #       define STACK_GRAN 0x10000\n #       define HEURISTIC1\n@@ -1421,6 +1439,8 @@\n #     define CPP_WORDSZ 32\n #     define STACKBOTTOM ((ptr_t)((ulong)&errno))\n #   endif\n+#   define USE_MMAP\n+#   define USE_MMAP_ANON\n  /* From AIX linker man page:\n  _text Specifies the first location of the program.\n  _etext Specifies the first location after the program.\n@@ -1728,7 +1748,7 @@\n #   define USE_GENERIC_PUSH_REGS\n #   ifdef UTS4\n #       define OS_TYPE \"UTS4\"\n-       extern int etext[];\n+\textern int etext[];\n \textern int _etext[];\n \textern int _end[];\n \textern ptr_t GC_SysVGetDataStart();\n@@ -1742,18 +1762,20 @@\n #   define MACH_TYPE \"S390\"\n #   define USE_GENERIC_PUSH_REGS\n #   ifndef __s390x__\n-#   define ALIGNMENT 4\n-#   define CPP_WORDSZ 32\n+#     define ALIGNMENT 4\n+#     define CPP_WORDSZ 32\n #   else\n-#   define ALIGNMENT 8\n-#   define CPP_WORDSZ 64\n-#   define HBLKSIZE 4096\n+#     define ALIGNMENT 8\n+#     define CPP_WORDSZ 64\n+#   endif\n+#   ifndef HBLKSIZE\n+#     define HBLKSIZE 4096\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n #       define LINUX_STACKBOTTOM\n #       define DYNAMIC_LOADING\n-       extern int __data_start[];\n+\textern int __data_start[];\n #       define DATASTART ((ptr_t)(__data_start))\n     extern int _end[];\n #   define DATAEND (_end)\n@@ -1859,6 +1881,13 @@\n       extern int _end[];\n #     define DATAEND (_end)\n #   endif\n+#   ifdef NETBSD\n+#      define OS_TYPE \"NETBSD\"\n+#      define HEURISTIC2\n+#      define DATASTART GC_data_start\n+#       define USE_GENERIC_PUSH_REGS\n+#      define DYNAMIC_LOADING\n+#   endif\n # endif\n  \n # ifdef SH4\n@@ -2107,7 +2136,8 @@\n #   define THREADS\n # endif\n \n-# if defined(HP_PA) || defined(M88K) || defined(POWERPC) && !defined(DARWIN) \\\n+# if defined(HP_PA) || defined(M88K) \\\n+             || defined(POWERPC) && !defined(DARWIN) \\\n \t     || defined(LINT) || defined(MSWINCE) || defined(ARM32) || defined(CRIS) \\\n \t     || (defined(I386) && defined(__LCC__))\n \t/* Use setjmp based hack to mark from callee-save registers.    */\n@@ -2249,7 +2279,7 @@\n #\t    else\n #\t      if defined(AMIGA) && defined(GC_AMIGA_FASTALLOC)\n \t\t\textern void *GC_amiga_get_mem(size_t size);\n-#\t\t\tdefine GET_MEM(bytes) HBLKPTR((size_t) \\\n+#\t\tdefine GET_MEM(bytes) HBLKPTR((size_t) \\\n \t\t\t  GC_amiga_get_mem((size_t)bytes + GC_page_size) \\\n \t\t\t  + GC_page_size-1)\n #\t      else\n@@ -2265,4 +2295,10 @@\n \n #endif /* GC_PRIVATE_H */\n \n+#if defined(_AIX) && !defined(__GNUC__) && !defined(__STDC__)\n+  /* IBMs xlc compiler doesn't appear to follow the convention of\t*/\n+  /* defining  __STDC__ to be zero in extended mode.\t\t\t*/\n+#   define __STDC__ 0\n+#endif\n+\n # endif /* GCCONFIG_H */"}, {"sha": "6f9197a1f6f103615d59040c0b0a728726b95da3", "filename": "boehm-gc/include/private/pthread_stop_world.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_stop_world.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -2,7 +2,6 @@\n #define GC_PTHREAD_STOP_WORLD_H\n \n struct thread_stop_info {\n-    int\tsignal;\n     word last_stop_count;\t/* GC_last_stop_count value when thread\t*/\n     \t\t\t\t/* last successfully handled a suspend\t*/\n     \t\t\t\t/* signal.\t\t\t\t*/"}, {"sha": "469021b407105e9805a5527f3b860926f5cec362", "filename": "boehm-gc/include/private/pthread_support.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -4,7 +4,7 @@\n # include \"private/gc_priv.h\"\n \n # if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS)\n+     && !defined(GC_WIN32_THREADS)\n      \n #if defined(GC_DARWIN_THREADS)\n # include \"private/darwin_stop_world.h\""}, {"sha": "ba1e0b6fe506d35692c0de98f1bfaa2eff9917fc", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -27,6 +27,10 @@\n #   endif\n # endif\n \n+#if defined(RS6000) || defined(POWERPC)\n+# include <ucontext.h>\n+#endif\n+\n #if defined(__MWERKS__) && !defined(POWERPC)\n \n asm static void PushMacRegisters()\n@@ -413,6 +417,13 @@ ptr_t arg;\n         /* the stack.\t\t\t\t\t\t*/\n         __builtin_unwind_init();\n #     else /* !HAVE_BUILTIN_UNWIND_INIT */\n+#      if defined(RS6000) || defined(POWERPC)\n+\t/* FIXME: RS6000 means AIX.\t\t\t\t*/\n+        /* This should probably be used in all Posix/non-gcc\t*/\n+        /* settings.  We defer that change to minimize risk.\t*/\n+        ucontext_t ctxt;\n+        getcontext(&ctxt);\n+#      else\n         /* Generic code                          */\n         /* The idea is due to Parag Patel at HP. */\n         /* We're not sure whether he would like  */\n@@ -426,7 +437,7 @@ ptr_t arg;\n   \tfor (; (char *)i < lim; i++) {\n   \t    *i = 0;\n   \t}\n-#       if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n+#       if defined(MSWIN32) || defined(MSWINCE) \\\n                   || defined(UTS4) || defined(LINUX) || defined(EWS4800)\n   \t  (void) setjmp(regs);\n #       else\n@@ -435,15 +446,16 @@ ptr_t arg;\n   \t  /* SUSV3, setjmp() may or may not save signal mask.\t*/\n   \t  /* _setjmp won't, but is less portable.\t\t*/\n #       endif\n+#      endif /* !AIX ... */\n #     endif /* !HAVE_BUILTIN_UNWIND_INIT */\n-#   elif defined(PTHREADS) && !defined(MSWIN32) /* !USE_GENERIC_PUSH_REGS */\n-      /* We may still need this to save thread contexts.\t*/\n-      /* This should probably be used in all Posix/non-gcc\t*/\n-      /* settings.  We defer that change to minimize risk.\t*/\n-      ucontext_t ctxt;\n-      getcontext(&ctxt);\n-#   else  /* Shouldn't be needed */\n-      ABORT(\"Unexpected call to GC_with_callee_saves_pushed\");\n+#   else\n+#     if defined(PTHREADS) && !defined(MSWIN32) /* !USE_GENERIC_PUSH_REGS */\n+        /* We may still need this to save thread contexts.\t*/\n+        ucontext_t ctxt;\n+        getcontext(&ctxt);\n+#     else  /* Shouldn't be needed */\n+        ABORT(\"Unexpected call to GC_with_callee_saves_pushed\");\n+#     endif\n #   endif\n #   if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \\\n \t|| defined(IA64)\n@@ -480,7 +492,7 @@ ptr_t cold_gc_frame;\n /* the stack.\tReturn sp.\t\t\t\t\t\t*/\n # ifdef SPARC\n     asm(\"\t.seg \t\\\"text\\\"\");\n-#   if defined(SVR4) || defined(NETBSD)\n+#   if defined(SVR4) || defined(NETBSD) || defined(FREEBSD)\n       asm(\"\t.globl\tGC_save_regs_in_stack\");\n       asm(\"GC_save_regs_in_stack:\");\n       asm(\"\t.type GC_save_regs_in_stack,#function\");"}, {"sha": "5ad593dabb9961d1a1792428744f214ac61132e2", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -172,7 +172,8 @@ int obj_kind;\n # endif /* REDIRECT_REALLOC */\n \n \n-/* The same thing, except caller does not hold allocation lock.\t*/\n+/* Allocate memory such that only pointers to near the \t\t*/\n+/* beginning of the object are considered.\t\t\t*/\n /* We avoid holding allocation lock while we clear memory.\t*/\n ptr_t GC_generic_malloc_ignore_off_page(lb, k)\n register size_t lb;"}, {"sha": "09dfe92af3152d01289982c667a6ee6d14ed5759", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -858,9 +858,9 @@ mse * GC_steal_mark_stack(mse * low, mse * high, mse * local,\n \t    ++top;\n \t    top -> mse_descr = descr;\n \t    top -> mse_start = p -> mse_start;\n-\t    GC_ASSERT(  top -> mse_descr & GC_DS_TAGS != GC_DS_LENGTH || \n-\t\t\ttop -> mse_descr < GC_greatest_plausible_heap_addr\n-\t\t\t                   - GC_least_plausible_heap_addr);\n+\t    GC_ASSERT(  (top -> mse_descr & GC_DS_TAGS) != GC_DS_LENGTH || \n+\t\t\ttop -> mse_descr < (ptr_t)GC_greatest_plausible_heap_addr\n+\t\t\t                   - (ptr_t)GC_least_plausible_heap_addr);\n \t    /* If this is a big object, count it as\t\t\t*/\n \t    /* size/256 + 1 objects.\t\t\t\t\t*/\n \t    ++i;\n@@ -1450,8 +1450,8 @@ void GC_push_all_eager(bottom, top)\n ptr_t bottom;\n ptr_t top;\n {\n-    word * b = (word *)(((long) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));\n-    word * t = (word *)(((long) top) & ~(ALIGNMENT-1));\n+    word * b = (word *)(((word) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));\n+    word * t = (word *)(((word) top) & ~(ALIGNMENT-1));\n     register word *p;\n     register word q;\n     register word *lim;"}, {"sha": "89f05ba1dc93444b3ceb47eb6381e83b88ee2150", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -246,7 +246,7 @@ void *arg2;\n     \tbyte_sz = WORDS_TO_BYTES(word_sz);\n \tif (GC_all_interior_pointers) {\n \t    /* We need one extra byte; don't fill in GC_size_map[byte_sz] */\n-\t    byte_sz--;\n+\t    byte_sz -= EXTRA_BYTES;\n \t}\n \n     \tfor (j = low_limit; j <= byte_sz; j++) GC_size_map[j] = word_sz;  \n@@ -805,7 +805,10 @@ void GC_init_inner()\n \n void GC_enable_incremental GC_PROTO(())\n {\n-# if !defined(SMALL_CONFIG)\n+# if !defined(SMALL_CONFIG) && !defined(KEEP_BACK_PTRS)\n+  /* If we are keeping back pointers, the GC itself dirties all\t*/\n+  /* pages on which objects have been marked, making \t\t*/\n+  /* incremental GC pointless.\t\t\t\t\t*/\n   if (!GC_find_leak) {\n     DCL_LOCK_STATE;\n     "}, {"sha": "fb50a4554b778e9168e3a8fd6ee54da81e88229e", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 107, "deletions": 74, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -60,6 +60,10 @@\n #   include <signal.h>\n # endif\n \n+#if defined(LINUX) || defined(LINUX_STACKBOTTOM)\n+# include <ctype.h>\n+#endif\n+\n /* Blatantly OS dependent routines, except for those that are related \t*/\n /* to dynamic loading.\t\t\t\t\t\t\t*/\n \n@@ -245,30 +249,11 @@ word GC_apply_to_maps(word (*fn)(char *))\n //  XXXXXXXX-XXXXXXXX r-xp 00000000 30:05 260537     name of mapping...\\n\n //  ^^^^^^^^ ^^^^^^^^ ^^^^          ^^\n //  start    end      prot          maj_dev\n-//  0        9        18            32\n-//  \n-//  For 64 bit ABIs:\n-//  0\t     17\t      34\t    56\n //\n-//  The parser is called with a pointer to the entry and the return value\n-//  is either NULL or is advanced to the next entry(the byte after the\n-//  trailing '\\n'.)\n+//  Note that since about auguat 2003 kernels, the columns no longer have\n+//  fixed offsets on 64-bit kernels.  Hence we no longer rely on fixed offsets\n+//  anywhere, which is safer anyway.\n //\n-#if CPP_WORDSZ == 32\n-# define OFFSET_MAP_START   0\n-# define OFFSET_MAP_END     9\n-# define OFFSET_MAP_PROT   18\n-# define OFFSET_MAP_MAJDEV 32\n-# define ADDR_WIDTH \t    8\n-#endif\n-\n-#if CPP_WORDSZ == 64\n-# define OFFSET_MAP_START   0\n-# define OFFSET_MAP_END    17\n-# define OFFSET_MAP_PROT   34\n-# define OFFSET_MAP_MAJDEV 56\n-# define ADDR_WIDTH \t   16\n-#endif\n \n /*\n  * Assign various fields of the first line in buf_ptr to *start, *end,\n@@ -277,37 +262,46 @@ word GC_apply_to_maps(word (*fn)(char *))\n char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n                                 char *prot_buf, unsigned int *maj_dev)\n {\n-    int i;\n-    char *tok;\n+    char *start_start, *end_start, *prot_start, *maj_dev_start;\n+    char *p;\n+    char *endp;\n \n     if (buf_ptr == NULL || *buf_ptr == '\\0') {\n         return NULL;\n     }\n \n-    memcpy(prot_buf, buf_ptr+OFFSET_MAP_PROT, 4);\n-    \t\t\t\t/* do the protections first. */\n+    p = buf_ptr;\n+    while (isspace(*p)) ++p;\n+    start_start = p;\n+    GC_ASSERT(isxdigit(*start_start));\n+    *start = strtoul(start_start, &endp, 16); p = endp;\n+    GC_ASSERT(*p=='-');\n+\n+    ++p;\n+    end_start = p;\n+    GC_ASSERT(isxdigit(*end_start));\n+    *end = strtoul(end_start, &endp, 16); p = endp;\n+    GC_ASSERT(isspace(*p));\n+\n+    while (isspace(*p)) ++p;\n+    prot_start = p;\n+    GC_ASSERT(*prot_start == 'r' || *prot_start == '-');\n+    memcpy(prot_buf, prot_start, 4);\n     prot_buf[4] = '\\0';\n-\n-    if (prot_buf[1] == 'w') {/* we can skip all of this if it's not writable. */\n-\n-        tok = buf_ptr;\n-        buf_ptr[OFFSET_MAP_START+ADDR_WIDTH] = '\\0';\n-        *start = strtoul(tok, NULL, 16);\n-\n-        tok = buf_ptr+OFFSET_MAP_END;\n-        buf_ptr[OFFSET_MAP_END+ADDR_WIDTH] = '\\0';\n-        *end = strtoul(tok, NULL, 16);\n-\n-        buf_ptr += OFFSET_MAP_MAJDEV;\n-        tok = buf_ptr;\n-        while (*buf_ptr != ':') buf_ptr++;\n-        *buf_ptr++ = '\\0';\n-        *maj_dev = strtoul(tok, NULL, 16);\n+    if (prot_buf[1] == 'w') {/* we can skip the rest if it's not writable. */\n+\t/* Skip past protection field to offset field */\n+          while (!isspace(*p)) ++p; while (isspace(*p)) ++p;\n+          GC_ASSERT(isxdigit(*p));\n+\t/* Skip past offset field, which we ignore */\n+          while (!isspace(*p)) ++p; while (isspace(*p)) ++p;\n+\tmaj_dev_start = p;\n+        GC_ASSERT(isxdigit(*maj_dev_start));\n+        *maj_dev = strtoul(maj_dev_start, NULL, 16);\n     }\n \n-    while (*buf_ptr && *buf_ptr++ != '\\n');\n+    while (*p && *p++ != '\\n');\n \n-    return buf_ptr;\n+    return p;\n }\n \n #endif /* Need to parse /proc/self/maps. */\t\n@@ -699,7 +693,7 @@ ptr_t GC_get_stack_base()\n #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) \\\n     || defined(HURD) || defined(NETBSD)\n \tstatic struct sigaction old_segv_act;\n-#\tif defined(_sigargs) /* !Irix6.x */ || defined(HPUX) \\\n+#\tif defined(IRIX5) || defined(HPUX) \\\n \t|| defined(HURD) || defined(NETBSD)\n \t    static struct sigaction old_bus_act;\n #\tendif\n@@ -732,9 +726,11 @@ ptr_t GC_get_stack_base()\n \t\t/* and setting a handler at the same time.\t\t*/\n \t        (void) sigaction(SIGSEGV, 0, &old_segv_act);\n \t        (void) sigaction(SIGSEGV, &act, 0);\n+\t        (void) sigaction(SIGBUS, 0, &old_bus_act);\n+\t        (void) sigaction(SIGBUS, &act, 0);\n #\t  else\n \t        (void) sigaction(SIGSEGV, &act, &old_segv_act);\n-#\t\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+#\t\tif defined(IRIX5) \\\n \t\t   || defined(HPUX) || defined(HURD) || defined(NETBSD)\n \t\t    /* Under Irix 5.x or HP/UX, we may get SIGBUS.\t*/\n \t\t    /* Pthreads doesn't exist under Irix 5.x, so we\t*/\n@@ -773,7 +769,7 @@ ptr_t GC_get_stack_base()\n #       if defined(SUNOS5SIGS) || defined(IRIX5) \\\n \t   || defined(OSF1) || defined(HURD) || defined(NETBSD)\n \t  (void) sigaction(SIGSEGV, &old_segv_act, 0);\n-#\t  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+#\t  if defined(IRIX5) \\\n \t     || defined(HPUX) || defined(HURD) || defined(NETBSD)\n \t      (void) sigaction(SIGBUS, &old_bus_act, 0);\n #\t  endif\n@@ -854,13 +850,14 @@ ptr_t GC_get_stack_base()\n \n #include <sys/types.h>\n #include <sys/stat.h>\n-#include <ctype.h>\n \n # define STAT_SKIP 27   /* Number of fields preceding startstack\t*/\n \t\t\t/* field in /proc/self/stat\t\t\t*/\n \n+#ifdef USE_LIBC_PRIVATES\n # pragma weak __libc_stack_end\n   extern ptr_t __libc_stack_end;\n+#endif\n \n # ifdef IA64\n     /* Try to read the backing store base from /proc/self/maps.\t*/\n@@ -890,30 +887,33 @@ ptr_t GC_get_stack_base()\n         return GC_apply_to_maps(backing_store_base_from_maps);\n     }\n \n-#   pragma weak __libc_ia64_register_backing_store_base\n-    extern ptr_t __libc_ia64_register_backing_store_base;\n+#   ifdef USE_LIBC_PRIVATES\n+#     pragma weak __libc_ia64_register_backing_store_base\n+      extern ptr_t __libc_ia64_register_backing_store_base;\n+#   endif\n \n     ptr_t GC_get_register_stack_base(void)\n     {\n-      if (0 != &__libc_ia64_register_backing_store_base\n-\t  && 0 != __libc_ia64_register_backing_store_base) {\n-\t/* Glibc 2.2.4 has a bug such that for dynamically linked\t*/\n-\t/* executables __libc_ia64_register_backing_store_base is \t*/\n-\t/* defined but uninitialized during constructor calls.  \t*/\n-\t/* Hence we check for both nonzero address and value.\t\t*/\n-\treturn __libc_ia64_register_backing_store_base;\n-      } else {\n-\tword result = backing_store_base_from_proc();\n-\tif (0 == result) {\n+#     ifdef USE_LIBC_PRIVATES\n+        if (0 != &__libc_ia64_register_backing_store_base\n+\t    && 0 != __libc_ia64_register_backing_store_base) {\n+\t  /* Glibc 2.2.4 has a bug such that for dynamically linked\t*/\n+\t  /* executables __libc_ia64_register_backing_store_base is \t*/\n+\t  /* defined but uninitialized during constructor calls.  \t*/\n+\t  /* Hence we check for both nonzero address and value.\t\t*/\n+\t  return __libc_ia64_register_backing_store_base;\n+        }\n+#     endif\n+      word result = backing_store_base_from_proc();\n+      if (0 == result) {\n \t  /* Use dumb heuristics.  Works only for default configuration. */\n \t  result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;\n \t  result += BACKING_STORE_ALIGNMENT - 1;\n \t  result &= ~(BACKING_STORE_ALIGNMENT - 1);\n \t  /* Verify that it's at least readable.  If not, we goofed. */\n \t  GC_noop1(*(word *)result); \n-\t}\n-\treturn (ptr_t)result;\n       }\n+      return (ptr_t)result;\n     }\n # endif\n \n@@ -936,6 +936,7 @@ ptr_t GC_get_stack_base()\n     /* since the correct value of __libc_stack_end never\t*/\n     /* becomes visible to us.  The second test works around \t*/\n     /* this.\t\t\t\t\t\t\t*/  \n+#   ifdef USE_LIBC_PRIVATES\n       if (0 != &__libc_stack_end && 0 != __libc_stack_end ) {\n #       ifdef IA64\n \t  /* Some versions of glibc set the address 16 bytes too\t*/\n@@ -957,6 +958,7 @@ ptr_t GC_get_stack_base()\n #\tendif\n #\tendif\n       }\n+#   endif\n     f = open(\"/proc/self/stat\", O_RDONLY);\n     if (f < 0 || STAT_READ(f, stat_buf, STAT_BUF_SIZE) < 2 * STAT_SKIP) {\n \tABORT(\"Couldn't read /proc/self/stat\");\n@@ -1508,7 +1510,7 @@ void GC_register_data_segments()\n # endif\n \n \n-# ifdef RS6000\n+# if 0 && defined(RS6000)  /* We now use mmap */\n /* The compiler seems to generate speculative reads one past the end of\t*/\n /* an allocated object.  Hence we need to make sure that the page \t*/\n /* following the last heap page is also mapped.\t\t\t\t*/\n@@ -2381,7 +2383,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #   endif\n #   ifdef FREEBSD\n #     define SIG_OK (sig == SIGBUS)\n-#     define CODE_OK (code == BUS_PAGE_FAULT)\n+#     define CODE_OK TRUE\n #   endif\n # endif /* SUNOS4 || (FREEBSD && !SUNOS5SIGS) */\n \n@@ -3726,7 +3728,7 @@ static kern_return_t GC_forward_exception(\n     exception_behavior_t behavior;\n     thread_state_flavor_t flavor;\n     \n-    thread_state_data_t thread_state;\n+    thread_state_t thread_state;\n     mach_msg_type_number_t thread_state_count = THREAD_STATE_MAX;\n         \n     for(i=0;i<GC_old_exc_ports.count;i++)\n@@ -3787,13 +3789,19 @@ catch_exception_raise(\n     char *addr;\n     struct hblk *h;\n     int i;\n-#ifdef POWERPC\n-    thread_state_flavor_t flavor = PPC_EXCEPTION_STATE;\n-    mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE_COUNT;\n-    ppc_exception_state_t exc_state;\n-#else\n+#   if defined(POWERPC)\n+#     if CPP_WORDSZ == 32\n+        thread_state_flavor_t flavor = PPC_EXCEPTION_STATE;\n+        mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE_COUNT;\n+        ppc_exception_state_t exc_state;\n+#     else\n+        thread_state_flavor_t flavor = PPC_EXCEPTION_STATE64;\n+        mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE64_COUNT;\n+        ppc_exception_state64_t exc_state;\n+#     endif\n+#   else\n #\terror FIXME for non-ppc darwin\n-#endif\n+#   endif\n \n     \n     if(exception != EXC_BAD_ACCESS || code[0] != KERN_PROTECTION_FAILURE) {\n@@ -3953,10 +3961,14 @@ kern_return_t catch_exception_raise_state_identity(\n #      if defined (DRSNX)\n #\t include <sys/sparc/frame.h>\n #      else\n-#\t if defined(OPENBSD) || defined(NETBSD)\n+#\t if defined(OPENBSD)\n #\t   include <frame.h>\n #\t else\n-#\t   include <sys/frame.h>\n+#\t   if defined(FREEBSD) || defined(NETBSD)\n+#\t     include <machine/frame.h>\n+#\t   else\n+#\t     include <sys/frame.h>\n+#\t   endif\n #\t endif\n #      endif\n #    endif\n@@ -3985,6 +3997,16 @@ kern_return_t catch_exception_raise_state_identity(\n #if NARGS == 0 && NFRAMES % 2 == 0 /* No padding */ \\\n     && defined(GC_HAVE_BUILTIN_BACKTRACE)\n \n+#ifdef REDIRECT_MALLOC\n+  /* Deal with possible malloc calls in backtrace by omitting\t*/\n+  /* the infinitely recursing backtrace.\t\t\t*/\n+# ifdef THREADS\n+    __thread \t/* If your compiler doesn't understand this */\n+    \t\t/* you could use something like pthread_getspecific.\t*/\n+# endif\n+  GC_in_save_callers = FALSE;\n+#endif\n+\n void GC_save_callers (info) \n struct callinfo info[NFRAMES];\n {\n@@ -3994,15 +4016,26 @@ struct callinfo info[NFRAMES];\n   \n   /* We retrieve NFRAMES+1 pc values, but discard the first, since it\t*/\n   /* points to our own frame.\t\t\t\t\t\t*/\n+# ifdef REDIRECT_MALLOC\n+    if (GC_in_save_callers) {\n+      info[0].ci_pc = (word)(&GC_save_callers);\n+      for (i = 1; i < NFRAMES; ++i) info[i].ci_pc = 0;\n+      return;\n+    }\n+    GC_in_save_callers = TRUE;\n+# endif\n   GC_ASSERT(sizeof(struct callinfo) == sizeof(void *));\n   npcs = backtrace((void **)tmp_info, NFRAMES + IGNORE_FRAMES);\n   BCOPY(tmp_info+IGNORE_FRAMES, info, (npcs - IGNORE_FRAMES) * sizeof(void *));\n   for (i = npcs - IGNORE_FRAMES; i < NFRAMES; ++i) info[i].ci_pc = 0;\n+# ifdef REDIRECT_MALLOC\n+    GC_in_save_callers = FALSE;\n+# endif\n }\n \n #else /* No builtin backtrace; do it ourselves */\n \n-#if (defined(OPENBSD) || defined(NETBSD)) && defined(SPARC)\n+#if (defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD)) && defined(SPARC)\n #  define FR_SAVFP fr_fp\n #  define FR_SAVPC fr_pc\n #else"}, {"sha": "1121ee89c6e4661853a500fd1484f2684f594059", "filename": "boehm-gc/powerpc_darwin_mach_dep.s", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpowerpc_darwin_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpowerpc_darwin_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpowerpc_darwin_mach_dep.s?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -12,7 +12,7 @@\n \n ; GC_push_regs function. Under some optimization levels GCC will clobber\n ; some of the non-volatile registers before we get a chance to save them\n-; therefore, this can't be inline asm.\n+; therefore, this cannot be inline asm.\n \n .text\n \t.align LOG2_GPR_BYTES"}, {"sha": "b9034dc7f5bfb0c5ff626f4cf65f160c74129c0d", "filename": "boehm-gc/pthread_stop_world.c", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpthread_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpthread_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_stop_world.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1,13 +1,17 @@\n #include \"private/pthread_support.h\"\n \n #if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS) \\\n-     && !defined(GC_DARWIN_THREADS) && !defined(GC_AIX_THREADS)\n+     && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)\n \n #include <signal.h>\n #include <semaphore.h>\n #include <errno.h>\n #include <unistd.h>\n+#include <sys/time.h>\n+#ifndef HPUX\n+# include <sys/select.h>\n+  /* Doesn't exist on HP/UX 11.11. */\n+#endif\n \n #if DEBUG_THREADS\n \n@@ -67,7 +71,22 @@ void GC_remove_allowed_signals(sigset_t *set)\n \n static sigset_t suspend_handler_mask;\n \n-word GC_stop_count;\t/* Incremented at the beginning of GC_stop_world. */\n+volatile sig_atomic_t GC_stop_count;\n+\t\t\t/* Incremented at the beginning of GC_stop_world. */\n+\n+volatile sig_atomic_t GC_world_is_stopped = FALSE;\n+\t\t\t/* FALSE ==> it is safe for threads to restart, i.e. */\n+\t\t\t/* they will see another suspend signal before they  */\n+\t\t\t/* are expected to stop (unless they have voluntarily */\n+\t\t\t/* stopped).\t\t\t\t\t     */\n+\n+void GC_brief_async_signal_safe_sleep()\n+{\n+    struct timeval tv;\n+    tv.tv_sec = 0;\n+    tv.tv_usec = 1000 * TIME_LIMIT / 2;\n+    select(0, 0, 0, 0, &tv);\n+}\n \n #ifdef GC_OSF1_THREADS\n   GC_bool GC_retry_signals = TRUE;\n@@ -108,15 +127,19 @@ extern void GC_with_callee_saves_pushed();\n \n void GC_suspend_handler(int sig)\n {\n+  int old_errno = errno;\n   GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);\n+  errno = old_errno;\n }\n \n #else\n /* We believe that in all other cases the full context is already\t*/\n /* in the signal handler frame.\t\t\t\t\t\t*/\n void GC_suspend_handler(int sig)\n {\n+  int old_errno = errno;\n   GC_suspend_handler_inner((ptr_t)(word)sig);\n+  errno = old_errno;\n }\n #endif\n \n@@ -172,16 +195,26 @@ void GC_suspend_handler_inner(ptr_t sig_arg)\n     /* this thread a SIG_THR_RESTART signal.\t\t\t*/\n     /* SIG_THR_RESTART should be masked at this point.  Thus there\t*/\n     /* is no race.\t\t\t\t\t\t*/\n-    do {\n-\t    me->stop_info.signal = 0;\n-\t    sigsuspend(&suspend_handler_mask);        /* Wait for signal */\n-    } while (me->stop_info.signal != SIG_THR_RESTART);\n+    /* We do not continue until we receive a SIG_THR_RESTART,\t*/\n+    /* but we do not take that as authoritative.  (We may be\t*/\n+    /* accidentally restarted by one of the user signals we \t*/\n+    /* don't block.)  After we receive the signal, we use a \t*/\n+    /* primitive and expensive mechanism to wait until it's\t*/\n+    /* really safe to proceed.  Under normal circumstances,\t*/\n+    /* this code should not be executed.\t\t\t*/\n+    sigsuspend(&suspend_handler_mask);        /* Wait for signal */\n+    while (GC_world_is_stopped && GC_stop_count == my_stop_count) {\n+        GC_brief_async_signal_safe_sleep();\n+#       if DEBUG_THREADS\n+\t  GC_err_printf0(\"Sleeping in signal handler\");\n+#       endif\n+    }\n     /* If the RESTART signal gets lost, we can still lose.  That should be  */\n     /* less likely than losing the SUSPEND signal, since we don't do much   */\n     /* between the sem_post and sigsuspend.\t   \t\t\t    */\n-    /* We'd need more handshaking to work around that, since we don't want  */\n-    /* to accidentally leave a RESTART signal pending, thus causing us to   */\n-    /* continue prematurely in a future round.\t\t\t\t    */ \n+    /* We'd need more handshaking to work around that.\t\t\t    */\n+    /* Simply dropping the sigsuspend call should be safe, but is unlikely  */\n+    /* to be efficient.\t\t\t\t\t\t\t    */\n \n #if DEBUG_THREADS\n     GC_printf1(\"Continuing 0x%lx\\n\", my_thread);\n@@ -191,20 +224,11 @@ void GC_suspend_handler_inner(ptr_t sig_arg)\n void GC_restart_handler(int sig)\n {\n     pthread_t my_thread = pthread_self();\n-    GC_thread me;\n \n     if (sig != SIG_THR_RESTART) ABORT(\"Bad signal in suspend_handler\");\n \n-    /* Let the GC_suspend_handler() know that we got a SIG_THR_RESTART. */\n-    /* The lookup here is safe, since I'm doing this on behalf  */\n-    /* of a thread which holds the allocation lock in order\t*/\n-    /* to stop the world.  Thus concurrent modification of the\t*/\n-    /* data structure is impossible.\t\t\t\t*/\n-    me = GC_lookup_thread(my_thread);\n-    me->stop_info.signal = SIG_THR_RESTART;\n-\n     /*\n-    ** Note: even if we didn't do anything useful here,\n+    ** Note: even if we don't do anything useful here,\n     ** it would still be necessary to have a signal handler,\n     ** rather than ignoring the signals, otherwise\n     ** the signals will not be delivered at all, and\n@@ -357,6 +381,7 @@ void GC_stop_world()\n       /* We should have previously waited for it to become zero. */\n #   endif /* PARALLEL_MARK */\n     ++GC_stop_count;\n+    GC_world_is_stopped = TRUE;\n     n_live_threads = GC_suspend_all();\n \n       if (GC_retry_signals) {\n@@ -390,10 +415,10 @@ void GC_stop_world()\n       }\n     for (i = 0; i < n_live_threads; i++) {\n \t  while (0 != (code = sem_wait(&GC_suspend_ack_sem))) {\n-\t    if (errno != EINTR) {\n-\t      GC_err_printf1(\"Sem_wait returned %ld\\n\", (unsigned long)code);\n-\t      ABORT(\"sem_wait for handler failed\");\n-\t    }\n+\t      if (errno != EINTR) {\n+\t         GC_err_printf1(\"Sem_wait returned %ld\\n\", (unsigned long)code);\n+\t         ABORT(\"sem_wait for handler failed\");\n+\t      }\n \t  }\n     }\n #   ifdef PARALLEL_MARK\n@@ -419,6 +444,7 @@ void GC_start_world()\n       GC_printf0(\"World starting\\n\");\n #   endif\n \n+    GC_world_is_stopped = FALSE;\n     for (i = 0; i < THREAD_TABLE_SZ; i++) {\n       for (p = GC_threads[i]; p != 0; p = p -> next) {\n         if (p -> id != my_thread) {\n@@ -428,8 +454,7 @@ void GC_start_world()\n \t    #if DEBUG_THREADS\n \t      GC_printf1(\"Sending restart signal to 0x%lx\\n\", p -> id);\n \t    #endif\n-        \n-        result = pthread_kill(p -> id, SIG_THR_RESTART);\n+            result = pthread_kill(p -> id, SIG_THR_RESTART);\n \t    switch(result) {\n                 case ESRCH:\n                     /* Not really there anymore.  Possible? */"}, {"sha": "4271803c7c2a2f8443b1663ab0953ed6e810d14f", "filename": "boehm-gc/pthread_support.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -2,7 +2,7 @@\n  * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n  * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n- * Copyright (c) 2000-2001 by Hewlett-Packard Company.  All rights reserved.\n+ * Copyright (c) 2000-2004 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -51,8 +51,7 @@\n # include \"private/pthread_support.h\"\n \n # if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n-     && !defined(GC_IRIX_THREADS) && !defined(GC_WIN32_THREADS) \\\n-     && !defined(GC_AIX_THREADS)\n+     && !defined(GC_WIN32_THREADS)\n \n # if defined(GC_HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n      && !defined(USE_COMPILER_TLS)\n@@ -69,7 +68,8 @@\n # endif\n \n # if (defined(GC_DGUX386_THREADS) || defined(GC_OSF1_THREADS) || \\\n-      defined(GC_DARWIN_THREADS)) && !defined(USE_PTHREAD_SPECIFIC)\n+      defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)) \\\n+      && !defined(USE_PTHREAD_SPECIFIC)\n #   define USE_PTHREAD_SPECIFIC\n # endif\n \n@@ -117,7 +117,7 @@\n # include <semaphore.h>\n #endif /* !GC_DARWIN_THREADS */\n \n-#if defined(GC_DARWIN_THREADS)\n+#if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS)\n # include <sys/sysctl.h>\n #endif /* GC_DARWIN_THREADS */\n \n@@ -840,9 +840,9 @@ int GC_get_nprocs()\n /* We hold the allocation lock.\t*/\n void GC_thr_init()\n {\n-#\tifndef GC_DARWIN_THREADS\n-        int dummy;\n-#\tendif\n+#   ifndef GC_DARWIN_THREADS\n+      int dummy;\n+#   endif\n     GC_thread t;\n \n     if (GC_thr_initialized) return;\n@@ -874,14 +874,15 @@ void GC_thr_init()\n #       if defined(GC_HPUX_THREADS)\n \t  GC_nprocs = pthread_num_processors_np();\n #       endif\n-#\tif defined(GC_OSF1_THREADS)\n+#\tif defined(GC_OSF1_THREADS) || defined(GC_AIX_THREADS)\n \t  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);\n \t  if (GC_nprocs <= 0) GC_nprocs = 1;\n #\tendif\n-#       if defined(GC_FREEBSD_THREADS)\n-          GC_nprocs = 1;\n+#       if defined(GC_IRIX_THREADS)\n+\t  GC_nprocs = sysconf(_SC_NPROC_ONLN);\n+\t  if (GC_nprocs <= 0) GC_nprocs = 1;\n #       endif\n-#       if defined(GC_DARWIN_THREADS)\n+#       if defined(GC_DARWIN_THREADS) || defined(GC_FREEBSD_THREADS)\n \t  int ncpus = 1;\n \t  size_t len = sizeof(ncpus);\n \t  sysctl((int[2]) {CTL_HW, HW_NCPU}, 2, &ncpus, &len, NULL, 0);\n@@ -928,6 +929,8 @@ void GC_thr_init()\n \t/* Disable true incremental collection, but generational is OK.\t*/\n \tGC_time_limit = GC_TIME_UNLIMITED;\n       }\n+      /* If we are using a parallel marker, actually start helper threads.  */\n+        if (GC_parallel) start_mark_threads();\n #   endif\n }\n \n@@ -944,10 +947,6 @@ void GC_init_parallel()\n \n     /* GC_init() calls us back, so set flag first.\t*/\n     if (!GC_is_initialized) GC_init();\n-    /* If we are using a parallel marker, start the helper threads.  */\n-#     ifdef PARALLEL_MARK\n-        if (GC_parallel) start_mark_threads();\n-#     endif\n     /* Initialize thread local free lists if used.\t*/\n #   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n       LOCK();\n@@ -1223,15 +1222,21 @@ WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n     if (!GC_thr_initialized) GC_thr_init();\n #   ifdef GC_ASSERTIONS\n       {\n-\tint stack_size;\n+\tsize_t stack_size;\n \tif (NULL == attr) {\n \t   pthread_attr_t my_attr;\n \t   pthread_attr_init(&my_attr);\n \t   pthread_attr_getstacksize(&my_attr, &stack_size);\n \t} else {\n \t   pthread_attr_getstacksize(attr, &stack_size);\n \t}\n-\tGC_ASSERT(stack_size >= (8*HBLKSIZE*sizeof(word)));\n+#       ifdef PARALLEL_MARK\n+\t  GC_ASSERT(stack_size >= (8*HBLKSIZE*sizeof(word)));\n+#       else\n+          /* FreeBSD-5.3/Alpha: default pthread stack is 64K, \t*/\n+\t  /* HBLKSIZE=8192, sizeof(word)=8\t\t\t*/\n+\t  GC_ASSERT(stack_size >= 65536);\n+#       endif\n \t/* Our threads may need to do some work for the GC.\t*/\n \t/* Ridiculously small threads won't work, and they\t*/\n \t/* probably wouldn't work anyway.\t\t\t*/"}, {"sha": "864c0cad8afa40c5cf61cb1b47fff170036316dd", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -888,7 +888,7 @@ void GC_print_block_list()\n {\n     struct Print_stats pstats;\n \n-    GC_printf0(\"(kind(0=ptrfree,1=normal,2=unc.,3=stubborn):size_in_bytes, #_marks_set)\\n\");\n+    GC_printf1(\"(kind(0=ptrfree,1=normal,2=unc.,%lu=stubborn):size_in_bytes, #_marks_set)\\n\", STUBBORN);\n     pstats.number_of_blocks = 0;\n     pstats.total_bytes = 0;\n     GC_apply_to_all_blocks(GC_print_block_descr, (word)&pstats);"}, {"sha": "d604b6ec51a4673108a236422187ea4aa32c9498", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -16,7 +16,7 @@\n  * Modified by Peter C. for Solaris Posix Threads.\n  */\n \n-#include \"private/gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n # if defined(GC_SOLARIS_PTHREADS)\n # include <pthread.h>"}, {"sha": "386736d923b4c4cb13ad1289015432382b8ddc55", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -16,7 +16,7 @@\n  */\n /* Boehm, September 14, 1994 4:44 pm PDT */\n \n-#include \"private/gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n # if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)\n # include \"private/solaris_threads.h\"\n@@ -248,8 +248,8 @@ static void stop_all_lwps()\n     for (i = 0; i < max_lwps; i++)\n \tlast_ids[i] = 0;\n     for (;;) {\n-    if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)\n-    \tABORT(\"Main PIOCSTATUS failed\");\n+        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)\n+    \t    ABORT(\"Main PIOCSTATUS failed\");\n     \tif (status.pr_nlwp < 1)\n     \t\tABORT(\"Invalid number of lwps returned by PIOCSTATUS\");\n     \tif (status.pr_nlwp >= max_lwps) {\n@@ -262,7 +262,7 @@ static void stop_all_lwps()\n         \tfor (i = 0; i < max_lwps; i++)\n \t\t\tlast_ids[i] = 0;\n \t\tcontinue;\n-    }\n+    \t}\n         if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCLWPIDS, GC_current_ids) < 0)\n             ABORT(\"PIOCLWPIDS failed\");\n         changed = FALSE;"}, {"sha": "f44317393827c2be0851fc8f4ee0d8234751d255", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -1367,6 +1367,10 @@ void check_heap_stats()\n     \tmax_heap_sz = 11000000;\n     }\n #   endif\n+#   ifndef ALIGN_DOUBLE\n+        /* We end up needing more small object pages. */\n+        max_heap_sz += 2000000;\n+#   endif\n #   ifdef GC_DEBUG\n \tmax_heap_sz *= 2;\n #       ifdef SAVE_CALL_CHAIN"}, {"sha": "9078c8d8cd99f4e7bcf71a3d4990375a9ab9e9fd", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -11,10 +11,17 @@ int main()\n \t       \"-Wl,--wrap -Wl,pthread_sigmask -Wl,--wrap -Wl,sleep\\n\");\n #   endif\n #   if defined(GC_LINUX_THREADS) || defined(GC_IRIX_THREADS) \\\n-\t|| defined(GC_FREEBSD_THREADS) || defined(GC_SOLARIS_PTHREADS) \\\n+\t|| defined(GC_SOLARIS_PTHREADS) \\\n \t|| defined(GC_DARWIN_THREADS) || defined(GC_AIX_THREADS)\n         printf(\"-lpthread\\n\");\n #   endif\n+#   if defined(GC_FREEBSD_THREADS)\n+#       if (__FREEBSD_version >= 500000)\n+          printf(\"-lpthread\\n\");\n+#       else\n+          printf(\"-pthread\\n\");\n+#       endif\n+#   endif\n #   if defined(GC_HPUX_THREADS) || defined(GC_OSF1_THREADS)\n \tprintf(\"-lpthread -lrt\\n\");\n #   endif"}, {"sha": "e1fe24bd0abe84e8b3f15b950721c724ec612f20", "filename": "boehm-gc/version.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -2,7 +2,7 @@\n /* Eventually this one may become unnecessary.  For now we need\t*/\n /* it to keep the old-style build process working.\t\t*/\n #define GC_TMP_VERSION_MAJOR 6\n-#define GC_TMP_VERSION_MINOR 3\n+#define GC_TMP_VERSION_MINOR 6\n #define GC_TMP_ALPHA_VERSION GC_NOT_ALPHA\n \n #ifndef GC_NOT_ALPHA"}, {"sha": "ba53d86fbd100c09784e38c3e31d551e46b0da4d", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54f28c21ee515da92119551983d51118a3666e85/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=54f28c21ee515da92119551983d51118a3666e85", "patch": "@@ -11,6 +11,7 @@\n # undef pthread_create \n # undef pthread_sigmask \n # undef pthread_join \n+# undef pthread_detach\n # undef dlopen \n \n # define DEBUG_CYGWIN_THREADS 0\n@@ -185,7 +186,7 @@ static void GC_delete_thread(DWORD thread_id) {\n        /* Must still be in_use, since nobody else can store our thread_id. */\n        i++) {}\n   if (i > my_max) {\n-    WARN(\"Removing nonexisiting thread %ld\\n\", (GC_word)thread_id);\n+    WARN(\"Removing nonexistent thread %ld\\n\", (GC_word)thread_id);\n   } else {\n     GC_delete_gc_thread(thread_table+i);\n   }\n@@ -232,6 +233,9 @@ void GC_push_thread_structures GC_PROTO((void))\n # endif\n }\n \n+/* Defined in misc.c */\n+extern CRITICAL_SECTION GC_write_cs;\n+\n void GC_stop_world()\n {\n   DWORD thread_id = GetCurrentThreadId();\n@@ -240,6 +244,9 @@ void GC_stop_world()\n   if (!GC_thr_initialized) ABORT(\"GC_stop_world() called before GC_thr_init()\");\n \n   GC_please_stop = TRUE;\n+# ifndef CYGWIN32\n+    EnterCriticalSection(&GC_write_cs);\n+# endif /* !CYGWIN32 */\n   for (i = 0; i <= GC_get_max_thread_index(); i++)\n     if (thread_table[i].stack_base != 0\n \t&& thread_table[i].id != thread_id) {\n@@ -270,6 +277,9 @@ void GC_stop_world()\n #     endif\n       thread_table[i].suspended = TRUE;\n     }\n+# ifndef CYGWIN32\n+    LeaveCriticalSection(&GC_write_cs);\n+# endif /* !CYGWIN32 */\n }\n \n void GC_start_world()"}]}