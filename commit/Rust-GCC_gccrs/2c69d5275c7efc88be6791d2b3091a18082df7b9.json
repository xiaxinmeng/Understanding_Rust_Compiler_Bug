{"sha": "2c69d5275c7efc88be6791d2b3091a18082df7b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2OWQ1Mjc1YzdlZmM4OGJlNjc5MWQyYjMwOTFhMTgwODJkZjdiOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-11-24T06:34:16Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-11-24T06:34:16Z"}, "message": "re PR fortran/34820 (internal compiler error: in gfc_conv_descriptor_data_get, at fortran/trans-array.c:147)\n\n2008-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34820\n\t* trans-expr.c (gfc_conv_function_call): Remove all code to\n\tdeallocate intent out derived types with allocatable\n\tcomponents.\n\t(gfc_trans_assignment_1): An assignment from a scalar to an\n\tarray of derived types with allocatable components, requires\n\ta deep copy to each array element and deallocation of the\n\tconverted rhs expression afterwards.\n\t* trans-array.c : Minor whitespace.\n\t* trans-decl.c (init_intent_out_dt): Add code to deallocate\n\tallocatable components of derived types with intent out.\n\t(generate_local_decl): If these types are unused, set them\n\treferenced anyway but allow the uninitialized warning.\n\n\tPR fortran/34143\n\t* trans-expr.c (gfc_trans_subcomponent_assign): If a conversion\n\texpression has a null data pointer argument, nullify the\n\tallocatable component.\n\n\tPR fortran/32795\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Only nullify\n\tthe data pointer if the source is not a variable.\n\n2008-11-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34820\n\t* gfortran.dg/alloc_comp_constructor_6.f90 : New test.\n\t* gfortran.dg/alloc_comp_basics_1.f90 : Reduce expected refs to\n\t'builtin_free' from 24 to 18.\n\n\tPR fortran/34143\n\t* gfortran.dg/alloc_comp_constructor_5.f90 : New test.\n\n\tPR fortran/32795\n\t* gfortran.dg/alloc_comp_constructor_4.f90 : New test.\n\nFrom-SVN: r142148", "tree": {"sha": "997d7059d19cf99dc2c6500197c911b74e98bef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/997d7059d19cf99dc2c6500197c911b74e98bef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c69d5275c7efc88be6791d2b3091a18082df7b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c69d5275c7efc88be6791d2b3091a18082df7b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c69d5275c7efc88be6791d2b3091a18082df7b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c69d5275c7efc88be6791d2b3091a18082df7b9/comments", "author": null, "committer": null, "parents": [{"sha": "e4b9521065765f5ec954d0772a877bd9957478e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b9521065765f5ec954d0772a877bd9957478e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b9521065765f5ec954d0772a877bd9957478e3"}], "stats": {"total": 293, "additions": 255, "deletions": 38}, "files": [{"sha": "5f55609e6caadc4f1db73a2b11a04671b9fd17c5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -1,3 +1,28 @@\n+2008-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34820\n+\t* trans-expr.c (gfc_conv_function_call): Remove all code to\n+\tdeallocate intent out derived types with allocatable\n+\tcomponents.\n+\t(gfc_trans_assignment_1): An assignment from a scalar to an\n+\tarray of derived types with allocatable components, requires\n+\ta deep copy to each array element and deallocation of the\n+\tconverted rhs expression afterwards.\n+\t* trans-array.c : Minor whitespace.\n+\t* trans-decl.c (init_intent_out_dt): Add code to deallocate\n+\tallocatable components of derived types with intent out.\n+\t(generate_local_decl): If these types are unused, set them\n+\treferenced anyway but allow the uninitialized warning.\n+\n+\tPR fortran/34143\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): If a conversion\n+\texpression has a null data pointer argument, nullify the\n+\tallocatable component.\n+\n+\tPR fortran/32795\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Only nullify\n+\tthe data pointer if the source is not a variable.\n+\n 2008-11-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/37735"}, {"sha": "06d2e3d0ca571ef7da5642c855a464723be2eac5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -5276,7 +5276,6 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n       gfc_conv_expr_descriptor (se, expr, ss);\n     }\n \n-\n   /* Deallocate the allocatable components of structures that are\n      not variable.  */\n   if (expr->ts.type == BT_DERIVED"}, {"sha": "91db5df5840b506fafa29c2ca2b4abf7911b0c65", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -2781,20 +2781,34 @@ gfc_init_default_dt (gfc_symbol * sym, tree body)\n }\n \n \n-/* Initialize INTENT(OUT) derived type dummies.  */\n+/* Initialize INTENT(OUT) derived type dummies.  As well as giving\n+   them their default initializer, if they do not have allocatable\n+   components, they have their allocatable components deallocated. */\n+\n static tree\n init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n {\n   stmtblock_t fnblock;\n   gfc_formal_arglist *f;\n+  tree tmp;\n \n   gfc_init_block (&fnblock);\n   for (f = proc_sym->formal; f; f = f->next)\n     if (f->sym && f->sym->attr.intent == INTENT_OUT\n-\t  && f->sym->ts.type == BT_DERIVED\n-\t  && !f->sym->ts.derived->attr.alloc_comp\n-\t  && f->sym->value)\n-      body = gfc_init_default_dt (f->sym, body);\n+\t  && f->sym->ts.type == BT_DERIVED)\n+      {\n+\tif (f->sym->ts.derived->attr.alloc_comp)\n+\t  {\n+\t    tmp = gfc_deallocate_alloc_comp (f->sym->ts.derived,\n+\t\t\t\t\t     f->sym->backend_decl,\n+\t\t\t\t\t     f->sym->as ? f->sym->as->rank : 0);\n+\t    gfc_add_expr_to_block (&fnblock, tmp);\n+\t  }\n+\n+\tif (!f->sym->ts.derived->attr.alloc_comp\n+\t      && f->sym->value)\n+\t  body = gfc_init_default_dt (f->sym, body);\n+      }\n \n   gfc_add_expr_to_block (&fnblock, body);\n   return gfc_finish_block (&fnblock);\n@@ -3482,10 +3496,10 @@ generate_local_decl (gfc_symbol * sym)\n   if (sym->attr.flavor == FL_VARIABLE)\n     {\n       if (!sym->attr.dummy && !sym->ns->proc_name->attr.entry_master)\n-        generate_dependency_declarations (sym);\n+\tgenerate_dependency_declarations (sym);\n \n       if (sym->attr.referenced)\n-        gfc_get_symbol_decl (sym);\n+\tgfc_get_symbol_decl (sym);\n       /* INTENT(out) dummy arguments are likely meant to be set.  */\n       else if (warn_unused_variable\n \t       && sym->attr.dummy\n@@ -3502,20 +3516,34 @@ generate_local_decl (gfc_symbol * sym)\n \t       && !(sym->attr.in_common || sym->attr.use_assoc || sym->mark))\n \tgfc_warning (\"Unused variable '%s' declared at %L\", sym->name,\n \t\t     &sym->declared_at);\n+\n       /* For variable length CHARACTER parameters, the PARM_DECL already\n \t references the length variable, so force gfc_get_symbol_decl\n \t even when not referenced.  If optimize > 0, it will be optimized\n \t away anyway.  But do this only after emitting -Wunused-parameter\n \t warning if requested.  */\n-      if (sym->attr.dummy && ! sym->attr.referenced\n-\t  && sym->ts.type == BT_CHARACTER\n-\t  && sym->ts.cl->backend_decl != NULL\n-\t  && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n+      if (sym->attr.dummy && !sym->attr.referenced\n+\t    && sym->ts.type == BT_CHARACTER\n+\t    && sym->ts.cl->backend_decl != NULL\n+\t    && TREE_CODE (sym->ts.cl->backend_decl) == VAR_DECL)\n \t{\n \t  sym->attr.referenced = 1;\n \t  gfc_get_symbol_decl (sym);\n \t}\n \n+      /* INTENT(out) dummy arguments with allocatable components are reset\n+\t by default and need to be set referenced to generate the code for\n+\t automatic lengths.  */\n+      if (sym->attr.dummy && !sym->attr.referenced\n+\t    && sym->ts.type == BT_DERIVED\n+\t    && sym->ts.derived->attr.alloc_comp\n+\t    && sym->attr.intent == INTENT_OUT)\n+\t{\n+\t  sym->attr.referenced = 1;\n+\t  gfc_get_symbol_decl (sym);\n+\t}\n+\n+\n       /* Check for dependencies in the array specification and string\n \tlength, adding the necessary declarations to the function.  We\n \tmark the symbol now, as well as in traverse_ns, to prevent"}, {"sha": "5d3894c825d748904ebeef6780d48f6b59b71766", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -2742,14 +2742,11 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n       gfc_add_block_to_block (&post, &parmse.post);\n \n       /* Allocated allocatable components of derived types must be\n-\t deallocated for INTENT(OUT) dummy arguments and non-variable\n-         scalars.  Non-variable arrays are dealt with in trans-array.c\n-         (gfc_conv_array_parameter).  */\n+\t deallocated for non-variable scalars.  Non-variable arrays are\n+\t dealt with in trans-array.c(gfc_conv_array_parameter).  */\n       if (e && e->ts.type == BT_DERIVED\n \t    && e->ts.derived->attr.alloc_comp\n-\t    && ((formal && formal->sym->attr.intent == INTENT_OUT)\n-\t\t   ||\n-\t\t(e->expr_type != EXPR_VARIABLE && !e->rank)))\n+\t    && (e->expr_type != EXPR_VARIABLE && !e->rank))\n         {\n \t  int parm_rank;\n \t  tmp = build_fold_indirect_ref (parmse.expr);\n@@ -2764,24 +2761,10 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    case (SCALAR_POINTER):\n               tmp = build_fold_indirect_ref (tmp);\n \t      break;\n-\t    case (ARRAY):\n-              tmp = parmse.expr;\n-\t      break;\n \t    }\n \n-          tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);\n-\t  if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n-\t    tmp = build3_v (COND_EXPR, gfc_conv_expr_present (e->symtree->n.sym),\n-\t\t\t    tmp, build_empty_stmt ());\n-\n-\t  if (e->expr_type != EXPR_VARIABLE)\n-\t    /* Don't deallocate non-variables until they have been used.  */\n-\t    gfc_add_expr_to_block (&se->post, tmp);\n-\t  else \n-\t    {\n-\t      gcc_assert (formal && formal->sym->attr.intent == INTENT_OUT);\n-\t      gfc_add_expr_to_block (&se->pre, tmp);\n-\t    }\n+\t  tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);\n+\t  gfc_add_expr_to_block (&se->post, tmp);\n         }\n \n       /* Character strings are passed as two parameters, a length and a\n@@ -3610,9 +3593,10 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t\t\t\t\t     cm->as->rank);\n \n \t  gfc_add_expr_to_block (&block, tmp);\n-\n \t  gfc_add_block_to_block (&block, &se.post);\n-\t  gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n+\n+\t  if (expr->expr_type != EXPR_VARIABLE)\n+\t    gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n \n \t  /* Shift the lbound and ubound of temporaries to being unity, rather\n \t     than zero, based.  Calculate the offset for all cases.  */\n@@ -3644,6 +3628,35 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n \t      gfc_add_modify (&block, offset, tmp);\n \t    }\n+\n+\t  if (expr->expr_type == EXPR_FUNCTION\n+\t\t&& expr->value.function.isym\n+\t\t&& expr->value.function.isym->conversion\n+\t\t&& expr->value.function.actual->expr\n+\t\t&& expr->value.function.actual->expr->expr_type\n+\t\t\t\t\t\t== EXPR_VARIABLE)\n+\t    {\n+\t      /* If a conversion expression has a null data pointer\n+\t\t argument, nullify the allocatable component.  */\n+\t      gfc_symbol *s;\n+\t      tree non_null_expr;\n+\t      tree null_expr;\n+\t      s = expr->value.function.actual->expr->symtree->n.sym;\n+\t      if (s->attr.allocatable || s->attr.pointer)\n+\t\t{\n+\t\t  non_null_expr = gfc_finish_block (&block);\n+\t\t  gfc_start_block (&block);\n+\t\t  gfc_conv_descriptor_data_set (&block, dest,\n+\t\t\t\t\t\tnull_pointer_node);\n+\t\t  null_expr = gfc_finish_block (&block);\n+\t\t  tmp = gfc_conv_descriptor_data_get (s->backend_decl);\n+\t\t  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,\n+\t\t\t        fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t      null_pointer_node));\n+\t\t  return build3_v (COND_EXPR, tmp, null_expr,\n+\t\t\t\t   non_null_expr);\n+\t\t}\n+\t    }\n \t}\n       else\n \t{\n@@ -4533,6 +4546,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n   stmtblock_t block;\n   stmtblock_t body;\n   bool l_is_temp;\n+  bool scalar_to_array;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -4616,9 +4630,24 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n   else\n     gfc_conv_expr (&lse, expr1);\n \n+  /* Assignments of scalar derived types with allocatable components\n+     to arrays must be done with a deep copy and the rhs temporary\n+     must have its components deallocated afterwards.  */\n+  scalar_to_array = (expr2->ts.type == BT_DERIVED\n+\t\t       && expr2->ts.derived->attr.alloc_comp\n+\t\t       && expr2->expr_type != EXPR_VARIABLE\n+\t\t       && !gfc_is_constant_expr (expr2)\n+\t\t       && expr1->rank && !expr2->rank);\n+  if (scalar_to_array)\n+    {\n+      tmp = gfc_deallocate_alloc_comp (expr2->ts.derived, rse.expr, 0);\n+      gfc_add_expr_to_block (&loop.post, tmp);\n+    }\n+\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n \t\t\t\t l_is_temp || init_flag,\n-\t\t\t\t expr2->expr_type == EXPR_VARIABLE);\n+\t\t\t\t (expr2->expr_type == EXPR_VARIABLE)\n+\t\t\t\t    || scalar_to_array);\n   gfc_add_expr_to_block (&body, tmp);\n \n   if (lss == gfc_ss_terminator)"}, {"sha": "1ccc57336a76ebb4bd6bb90d9ce208e5f308a348", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -1,3 +1,16 @@\n+2008-11-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34820\n+\t* gfortran.dg/alloc_comp_constructor_6.f90 : New test.\n+\t* gfortran.dg/alloc_comp_basics_1.f90 : Reduce expected refs to\n+\t'builtin_free' from 24 to 18.\n+\n+\tPR fortran/34143\n+\t* gfortran.dg/alloc_comp_constructor_5.f90 : New test.\n+\n+\tPR fortran/32795\n+\t* gfortran.dg/alloc_comp_constructor_4.f90 : New test.\n+\n 2008-11-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/37735"}, {"sha": "c4c4ae21e01c01bc7281fb9b0df22853525dba6d", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_auto_array_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_2.f90?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! Tests the fix for PR34820, in which the nullification of the\n+! automatic array iregion occurred in the caller, rather than the\n+! callee.  Since 'nproc' was not available, an ICE ensued. During\n+! the bug fix, it was found that the scalar to array assignment\n+! of derived types with allocatable components did not work and\n+! the fix of this is tested too.\n+!\n+! Contributed by Toon Moene <toon@moene.indiv.nluug.nl>\n+!\n+module grid_io\n+  type grid_index_region\n+    integer, allocatable::lons(:)\n+  end type grid_index_region\n+contains\n+  subroutine read_grid_header()\n+    integer :: npiece = 1\n+    type(grid_index_region),allocatable :: iregion(:)\n+    allocate (iregion(npiece + 1))\n+    call read_iregion(npiece,iregion)\n+    if (size(iregion) .ne. npiece + 1) call abort\n+    if (.not.allocated (iregion(npiece)%lons)) call abort\n+    if (allocated (iregion(npiece+1)%lons)) call abort\n+    if (any (iregion(npiece)%lons .ne. [(i, i = 1, npiece)])) call abort\n+    deallocate (iregion)\n+  end subroutine read_grid_header\n+\n+  subroutine read_iregion (nproc,iregion)\n+    integer,intent(in)::nproc\n+    type(grid_index_region), intent(OUT)::iregion(1:nproc)\n+    integer :: iarg(nproc)\n+    iarg = [(i, i = 1, nproc)]\n+    iregion = grid_index_region (iarg) !\n+  end subroutine read_iregion\n+end module grid_io\n+\n+  use grid_io\n+  call read_grid_header\n+end\n+! { dg-final { cleanup-tree-dump \"grid_io\" } }"}, {"sha": "e024d8b790df74f61b841f9f8af6b1271a3af66f", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -139,6 +139,6 @@ subroutine check_alloc2(b)\n     end subroutine check_alloc2\n \n end program alloc\n-! { dg-final { scan-tree-dump-times \"builtin_free\" 27 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 21 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-modules \"alloc_m\" } }"}, {"sha": "4b047daf3490ac6a9b37e24edd5bb998646a7d2b", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_4.f90?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! Tests the fix for PR32795, which was primarily about memory leakage is\n+! certain combinations of alloctable components and constructors. This test\n+! which appears in comment #2 of the PR has the advantage of a wrong\n+! numeric result which is symptomatic.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+  type :: a\n+    integer, allocatable :: i(:)\n+  end type a\n+  type(a) :: x, y\n+  x = a ([1, 2, 3])\n+  y = a (x%i(:))  ! used to cause a memory leak and wrong result\n+  if (any (x%i .ne. [1, 2, 3])) call abort\n+end"}, {"sha": "9526112c995bf8bec361be2927f255913d2254d9", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_5.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_5.f90?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-fdefault-integer-8\" }\n+! Tests the fix for PR34143, in which the implicit conversion of yy, with\n+! fdefault-integer-8, would cause a segfault at runtime.\n+!\n+! Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+!\n+Program test_constructor\n+    implicit none\n+    type :: thytype\n+        integer(4) :: a(2,2)\n+    end type thytype\n+    type :: mytype\n+        integer(4), allocatable :: a(:, :)\n+        type(thytype), allocatable :: q(:)\n+    end type mytype\n+    integer, allocatable :: yy(:,:)\n+    type (thytype), allocatable :: bar(:)\n+    type (mytype) :: x, y\n+    x = mytype(yy, bar)\n+    if (allocated (x%a) .or. allocated (x%q)) call abort\n+    allocate (yy(2,2))\n+    allocate (bar(2))\n+    yy = reshape ([10,20,30,40],[2,2])\n+    bar = thytype (reshape ([1,2,3,4],[2,2]))\n+    ! Check that unallocated allocatables work\n+    y = mytype(yy, bar)\n+    if (.not.allocated (y%a) .or. .not.allocated (y%q)) call abort\n+end program test_constructor"}, {"sha": "b2ac4f723be1667518a7651e356e3b3c7f1a4766", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_6.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69d5275c7efc88be6791d2b3091a18082df7b9/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_6.f90?ref=2c69d5275c7efc88be6791d2b3091a18082df7b9", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-fdefault-integer-8 -O2\" }\n+! Tests the fix for PR34143, where the implicit type\n+! conversion in the derived type constructor would fail,\n+! when 'yy' was not allocated.  The testscase is an\n+! extract from alloc_comp_constructor.f90.\n+!\n+! Reported by Thomas Koenig <tkoenig@gcc.gnu.org>\n+!\n+Program test_constructor\n+    implicit none\n+    type :: thytype\n+        integer(4) :: a(2,2)\n+    end type thytype\n+    type :: mytype\n+        integer(4), allocatable :: a(:, :)\n+        type(thytype), allocatable :: q(:)\n+    end type mytype\n+    integer, allocatable :: yy(:,:)\n+    type (thytype), allocatable :: bar(:)\n+    call non_alloc\n+    call alloc\n+contains\n+    subroutine non_alloc\n+      type (mytype) :: x\n+      x = mytype(yy, bar)\n+      if (allocated (x%a) .or. allocated (x%q)) call abort\n+    end subroutine non_alloc\n+    subroutine alloc\n+      type (mytype) :: x\n+      allocate (yy(2,2))\n+      allocate (bar(2))\n+      yy = reshape ([10,20,30,40],[2,2])\n+      bar = thytype (reshape ([1,2,3,4],[2,2]))\n+      x = mytype(yy, bar)\n+      if (.not.allocated (x%a) .or. .not.allocated (x%q)) call abort\n+    end subroutine alloc\n+end program test_constructor"}]}