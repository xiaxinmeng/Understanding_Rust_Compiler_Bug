{"sha": "2f6f8285368749fd716178f92e3131d003b6a18c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2ZjgyODUzNjg3NDlmZDcxNjE3OGY5MmUzMTMxZDAwM2I2YTE4Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:29:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:29:48Z"}, "message": "[multiple changes]\n\n2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.ads Aspects Async_Readers, Async_Writers,\n\tEffective_Reads and Effective_Writes do not need to be delayed.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Propagate the\n\toptional Boolean expression when generating the corresponding\n\tpragma for an external property aspect.\n\t* sem_prag.adb (Analyze_External_Property_In_Decl_Part): Remove\n\tlocal constant Obj. Add local constant Obj_Id. Reimplement the\n\tcheck which ensures that the related variable is in fact volatile.\n\t(Analyze_Pragma): Reimplement the analysis of external property pragmas.\n\t* sem_util.adb (Is_Enabled): New routine.\n\t(Variable_Has_Enabled_Property): Reimplement the detection of\n\tan enabled external property.\n\n2014-07-30  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi, vms_data.ads: gnatstub: describe generating subunits\n\tfor body stubs.\n\n2014-07-30  Pascal Obry  <obry@adacore.com>\n\n\t* g-forstr.adb, g-forstr.ads: New.\n\t* gnat_rm.texi, impunit.adb Makefile.rtl: Add new unit\n\tGNAT.Formatted_String.\n\nFrom-SVN: r213241", "tree": {"sha": "62bf2a238524092997d4163a063e79d7d18c3ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62bf2a238524092997d4163a063e79d7d18c3ce7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f6f8285368749fd716178f92e3131d003b6a18c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6f8285368749fd716178f92e3131d003b6a18c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6f8285368749fd716178f92e3131d003b6a18c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6f8285368749fd716178f92e3131d003b6a18c/comments", "author": null, "committer": null, "parents": [{"sha": "ac43e11e234201441e84b5bc015587ecfff6c797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac43e11e234201441e84b5bc015587ecfff6c797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac43e11e234201441e84b5bc015587ecfff6c797"}], "stats": {"total": 1552, "additions": 1467, "deletions": 85}, "files": [{"sha": "18caba492741446dd17b1150680fc90df6ed63f1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -1,3 +1,29 @@\n+2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.ads Aspects Async_Readers, Async_Writers,\n+\tEffective_Reads and Effective_Writes do not need to be delayed.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Propagate the\n+\toptional Boolean expression when generating the corresponding\n+\tpragma for an external property aspect.\n+\t* sem_prag.adb (Analyze_External_Property_In_Decl_Part): Remove\n+\tlocal constant Obj. Add local constant Obj_Id. Reimplement the\n+\tcheck which ensures that the related variable is in fact volatile.\n+\t(Analyze_Pragma): Reimplement the analysis of external property pragmas.\n+\t* sem_util.adb (Is_Enabled): New routine.\n+\t(Variable_Has_Enabled_Property): Reimplement the detection of\n+\tan enabled external property.\n+\n+2014-07-30  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi, vms_data.ads: gnatstub: describe generating subunits\n+\tfor body stubs.\n+\n+2014-07-30  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-forstr.adb, g-forstr.ads: New.\n+\t* gnat_rm.texi, impunit.adb Makefile.rtl: Add new unit\n+\tGNAT.Formatted_String.\n+\n 2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): New predicate."}, {"sha": "fdac70c2297ed93be58956117f670a16177fcfea", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -411,6 +411,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-expect$(objext) \\\n   g-exptty$(objext) \\\n   g-flocon$(objext) \\\n+  g-forstr$(objext) \\\n   g-heasor$(objext) \\\n   g-hesora$(objext) \\\n   g-hesorg$(objext) \\"}, {"sha": "8ddd10bc8b8a4f182266ccabe4199d1e6fce2a84", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -590,8 +590,6 @@ package Aspects is\n      (No_Aspect                           => Always_Delay,\n       Aspect_Address                      => Always_Delay,\n       Aspect_All_Calls_Remote             => Always_Delay,\n-      Aspect_Async_Readers                => Always_Delay,\n-      Aspect_Async_Writers                => Always_Delay,\n       Aspect_Asynchronous                 => Always_Delay,\n       Aspect_Attach_Handler               => Always_Delay,\n       Aspect_Constant_Indexing            => Always_Delay,\n@@ -604,8 +602,6 @@ package Aspects is\n       Aspect_Discard_Names                => Always_Delay,\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n-      Aspect_Effective_Reads              => Always_Delay,\n-      Aspect_Effective_Writes             => Always_Delay,\n       Aspect_Elaborate_Body               => Always_Delay,\n       Aspect_External_Name                => Always_Delay,\n       Aspect_External_Tag                 => Always_Delay,\n@@ -673,9 +669,13 @@ package Aspects is\n \n       Aspect_Abstract_State               => Never_Delay,\n       Aspect_Annotate                     => Never_Delay,\n+      Aspect_Async_Readers                => Never_Delay,\n+      Aspect_Async_Writers                => Never_Delay,\n       Aspect_Convention                   => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,\n+      Aspect_Effective_Reads              => Never_Delay,\n+      Aspect_Effective_Writes             => Never_Delay,\n       Aspect_Part_Of                      => Never_Delay,\n       Aspect_Refined_Post                 => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,"}, {"sha": "bcb0fffc634349a6028d2873eed1102a27df6243", "filename": "gcc/ada/g-forstr.adb", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fg-forstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fg-forstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-forstr.adb?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -0,0 +1,951 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . F O R M A T T E D _ S T R I N G                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling;\n+with Ada.Float_Text_IO;\n+with Ada.Integer_Text_IO;\n+with Ada.Long_Float_Text_IO;\n+with Ada.Long_Integer_Text_IO;\n+with Ada.Strings.Fixed;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.Address_Image;\n+\n+package body GNAT.Formatted_String is\n+\n+   type F_Kind is (Decimal_Int,                 -- %d %i\n+                   Unsigned_Decimal_Int,        -- %u\n+                   Unsigned_Octal,              -- %o\n+                   Unsigned_Hexadecimal_Int,    -- %x\n+                   Unsigned_Hexadecimal_Int_Up, -- %X\n+                   Decimal_Float,               -- %f %F\n+                   Decimal_Scientific_Float,    -- %e\n+                   Decimal_Scientific_Float_Up, -- %E\n+                   Shortest_Decimal_Float,      -- %g\n+                   Shortest_Decimal_Float_Up,   -- %G\n+                   Char,                        -- %c\n+                   Str,                         -- %s\n+                   Pointer                      -- %p\n+                  );\n+\n+   type Sign_Kind is (Neg, Zero, Pos);\n+\n+   subtype Is_Number is F_Kind range Decimal_Int .. Decimal_Float;\n+\n+   type F_Sign is (If_Neg, Forced, Space) with Default_Value => If_Neg;\n+\n+   type F_Base is (None, C_Style, Ada_Style) with Default_Value => None;\n+\n+   Unset    : constant Integer := -1;\n+\n+   type F_Data is record\n+      Kind         : F_Kind;\n+      Width        : Natural := 0;\n+      Precision    : Integer := Unset;\n+      Left_Justify : Boolean := False;\n+      Sign         : F_Sign;\n+      Base         : F_Base;\n+      Zero_Pad     : Boolean := False;\n+      Value_Needed : Natural range 0 .. 2 := 0;\n+   end record;\n+\n+   procedure Next_Format\n+     (Format : Formatted_String; F_Spec : out F_Data; Start : out Positive);\n+   --  Parse the next format specifier, a format specifier has the following\n+   --  syntax: %[flags][width][.precision][length]specifier\n+\n+   function Get_Formatted\n+     (F_Spec : F_Data; Value : String; Len : Positive) return String;\n+   --  Returns Value formatted given the information in F_Spec\n+\n+   procedure Raise_Wrong_Format (Format : Formatted_String) with No_Return;\n+   --  Raise the Format_Error exception which information about the context\n+\n+   generic\n+      type Flt is private;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Flt;\n+         Aft  : Text_IO.Field;\n+         Exp  : Text_IO.Field);\n+   function P_Flt_Format\n+     (Format : Formatted_String; Var : Flt) return Formatted_String;\n+   --  Generic routine which handles all floating point numbers\n+\n+   generic\n+      type Int is private;\n+\n+      with function To_Integer (Item : Int) return Integer;\n+\n+      with function Sign (Item : Int) return Sign_Kind;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Int;\n+         Base : Text_IO.Number_Base);\n+   function P_Int_Format\n+     (Format : Formatted_String; Var : Int) return Formatted_String;\n+   --  Generic routine which handles all the integer numbers\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Format : String) return Formatted_String is\n+   begin\n+      return Formatted_String'\n+        (Finalization.Controlled with\n+           D => new Data'(Format'Length, 1, Format, 1,\n+             Null_Unbounded_String, 0, 0, (0, 0)));\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Format : Formatted_String) return String is\n+      F : String renames Format.D.Format;\n+      I : Natural renames Format.D.Index;\n+      R : Unbounded_String := Format.D.Result;\n+   begin\n+      --  Make sure we get the remaining character up to the next unhandled\n+      --  format specifier.\n+\n+      while (I <= F'Length and then F (I) /= '%')\n+        or else (I < F'Length - 1 and then F (I + 1) = '%')\n+      loop\n+         Append (R, F (I));\n+\n+         --  If we have two consecutive %, skip the second one\n+\n+         if F (I) = '%' and then I < F'Length - 1 and then F (I + 1) = '%' then\n+            I := I + 1;\n+         end if;\n+\n+         I := I + 1;\n+      end loop;\n+\n+      return To_String (R);\n+   end \"-\";\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Character) return Formatted_String\n+   is\n+      F     : F_Data;\n+      Start : Positive;\n+   begin\n+      Next_Format (Format, F, Start);\n+\n+      if F.Value_Needed > 0 then\n+         Raise_Wrong_Format (Format);\n+      end if;\n+\n+      case F.Kind is\n+         when Char =>\n+            Append (Format.D.Result, Get_Formatted (F, String'(1 => Var), 1));\n+         when others =>\n+            Raise_Wrong_Format (Format);\n+      end case;\n+\n+      return Format;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : String) return Formatted_String\n+   is\n+      F     : F_Data;\n+      Start : Positive;\n+   begin\n+      Next_Format (Format, F, Start);\n+\n+      if F.Value_Needed > 0 then\n+         Raise_Wrong_Format (Format);\n+      end if;\n+\n+      case F.Kind is\n+         when Str =>\n+            declare\n+               S : constant String := Get_Formatted (F, Var, Var'Length);\n+            begin\n+               if F.Precision = Unset then\n+                  Append (Format.D.Result, S);\n+               else\n+                  Append\n+                    (Format.D.Result,\n+                     S (S'First .. S'First + F.Precision - 1));\n+               end if;\n+            end;\n+\n+         when others =>\n+            Raise_Wrong_Format (Format);\n+      end case;\n+\n+      return Format;\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Boolean) return Formatted_String is\n+   begin\n+      return Format & Boolean'Image (Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Float) return Formatted_String\n+   is\n+      function Float_Format is new Flt_Format (Float, Float_Text_IO.Put);\n+   begin\n+      return Float_Format (Format, Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Long_Float) return Formatted_String\n+   is\n+      function Float_Format is\n+        new Flt_Format (Long_Float, Long_Float_Text_IO.Put);\n+   begin\n+      return Float_Format (Format, Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Duration) return Formatted_String\n+   is\n+      package Duration_Text_IO is new Text_IO.Fixed_IO (Duration);\n+      function Duration_Format is\n+        new P_Flt_Format (Duration, Duration_Text_IO.Put);\n+   begin\n+      return Duration_Format (Format, Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Integer) return Formatted_String\n+   is\n+      function Integer_Format is\n+        new Int_Format (Integer, Integer_Text_IO.Put);\n+   begin\n+      return Integer_Format (Format, Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Long_Integer) return Formatted_String\n+   is\n+      function Integer_Format is\n+        new Int_Format (Long_Integer, Long_Integer_Text_IO.Put);\n+   begin\n+      return Integer_Format (Format, Var);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : System.Address) return Formatted_String\n+   is\n+      A_Img : constant String := System.Address_Image (Var);\n+      F     : F_Data;\n+      Start : Positive;\n+   begin\n+      Next_Format (Format, F, Start);\n+\n+      if F.Value_Needed > 0 then\n+         Raise_Wrong_Format (Format);\n+      end if;\n+\n+      case F.Kind is\n+         when Pointer =>\n+            Append (Format.D.Result, Get_Formatted (F, A_Img, A_Img'Length));\n+         when others =>\n+            Raise_Wrong_Format (Format);\n+      end case;\n+\n+      return Format;\n+   end \"&\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   overriding procedure Adjust (F : in out Formatted_String) is\n+   begin\n+      F.D.Ref_Count := F.D.Ref_Count + 1;\n+   end Adjust;\n+\n+   --------------------\n+   -- Decimal_Format --\n+   --------------------\n+\n+   function Decimal_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String\n+   is\n+      function Flt_Format is new P_Flt_Format (Flt, Put);\n+   begin\n+      return Flt_Format (Format, Var);\n+   end Decimal_Format;\n+\n+   -----------------\n+   -- Enum_Format --\n+   -----------------\n+\n+   function Enum_Format\n+     (Format : Formatted_String;\n+      Var    : Enum) return Formatted_String is\n+   begin\n+      return Format & Enum'Image (Var);\n+   end Enum_Format;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   overriding procedure Finalize (F : in out Formatted_String) is\n+\n+      procedure Unchecked_Free is\n+        new Unchecked_Deallocation (Data, Data_Access);\n+\n+      D : Data_Access := F.D;\n+   begin\n+      F.D := null;\n+\n+      D.Ref_Count := D.Ref_Count - 1;\n+\n+      if D.Ref_Count = 0 then\n+         Unchecked_Free (D);\n+      end if;\n+   end Finalize;\n+\n+   ------------------\n+   -- Fixed_Format --\n+   ------------------\n+\n+   function Fixed_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String\n+   is\n+      function Flt_Format is new P_Flt_Format (Flt, Put);\n+   begin\n+      return Flt_Format (Format, Var);\n+   end Fixed_Format;\n+\n+   ----------------\n+   -- Flt_Format --\n+   ----------------\n+\n+   function Flt_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String\n+   is\n+      function Flt_Format is new P_Flt_Format (Flt, Put);\n+   begin\n+      return Flt_Format (Format, Var);\n+   end Flt_Format;\n+\n+   -------------------\n+   -- Get_Formatted --\n+   -------------------\n+\n+   function Get_Formatted\n+     (F_Spec : F_Data;\n+      Value  : String;\n+      Len    : Positive) return String\n+   is\n+      use Ada.Strings.Fixed;\n+\n+      Res : Unbounded_String;\n+      S   : Positive := Value'First;\n+   begin\n+      --  Let's hanfles the flags\n+\n+      if F_Spec.Kind in Is_Number then\n+         if F_Spec.Sign = Forced and then Value (Value'First) /= '-' then\n+            Append (Res, \"+\");\n+         elsif F_Spec.Sign = Space and then Value (Value'First) /= '-' then\n+            Append (Res, \" \");\n+         end if;\n+\n+         if Value (Value'First) = '-' then\n+            Append (Res, \"-\");\n+            S := S + 1;\n+         end if;\n+      end if;\n+\n+      --  Zero padding if required and possible\n+\n+      if F_Spec.Left_Justify = False\n+        and then F_Spec.Zero_Pad\n+        and then F_Spec.Width > Len + Value'First - S\n+      then\n+         Append (Res, String'((F_Spec.Width - Len + Value'First - S) * '0'));\n+      end if;\n+\n+      --  Add the value now\n+\n+      Append (Res, Value (S .. Value'Last));\n+\n+      declare\n+         R : String (1 .. Natural'Max (Natural'Max (F_Spec.Width, Len),\n+                                       Length (Res))) := (others => ' ');\n+      begin\n+         if F_Spec.Left_Justify then\n+            R (1 .. Length (Res)) := To_String (Res);\n+         else\n+            R (R'Last - Length (Res) + 1 .. R'Last) := To_String (Res);\n+         end if;\n+\n+         return R;\n+      end;\n+   end Get_Formatted;\n+\n+   ----------------\n+   -- Int_Format --\n+   ----------------\n+\n+   function Int_Format\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String\n+   is\n+      function Sign (Var : Int) return Sign_Kind\n+      is (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n+      function To_Integer (Var : Int) return Integer is (Integer (Var));\n+      function Int_Format is new P_Int_Format (Int, To_Integer, Sign, Put);\n+   begin\n+      return Int_Format (Format, Var);\n+   end Int_Format;\n+\n+   ----------------\n+   -- Mod_Format --\n+   ----------------\n+\n+   function Mod_Format\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String\n+   is\n+      function Sign (Var : Int) return Sign_Kind\n+        is (if Var < 0 then Neg elsif Var = 0 then Zero else Pos);\n+      function To_Integer (Var : Int) return Integer is (Integer (Var));\n+      function Int_Format is new P_Int_Format (Int, To_Integer, Sign, Put);\n+   begin\n+      return Int_Format (Format, Var);\n+   end Mod_Format;\n+\n+   -----------------\n+   -- Next_Format --\n+   -----------------\n+\n+   procedure Next_Format\n+     (Format : Formatted_String;\n+      F_Spec : out F_Data;\n+      Start  : out Positive)\n+   is\n+      F              : String renames Format.D.Format;\n+      I              : Natural renames Format.D.Index;\n+      S              : Natural;\n+      Width_From_Var : Boolean := False;\n+   begin\n+      Format.D.Current := Format.D.Current + 1;\n+      F_Spec.Value_Needed := 0;\n+\n+      --  Got to next %\n+\n+      while (I <= F'Last and then F (I) /= '%')\n+        or else (I < F'Last - 1 and then F (I + 1) = '%')\n+      loop\n+         Append (Format.D.Result, F (I));\n+\n+         --  If we have two consecutive %, skip the second one\n+\n+         if F (I) = '%' and then I < F'Last - 1 and then F (I + 1) = '%' then\n+            I := I + 1;\n+         end if;\n+\n+         I := I + 1;\n+      end loop;\n+\n+      if F (I) /= '%' or else I = F'Last then\n+         raise Format_Error with \"no format specifier found for parameter\"\n+           & Positive'Image (Format.D.Current);\n+      end if;\n+\n+      Start := I;\n+\n+      I := I + 1;\n+\n+      --  Check for any flags\n+\n+      Flags_Check : while I < F'Last loop\n+         if F (I) = '-' then\n+            F_Spec.Left_Justify := True;\n+         elsif F (I) = '+' then\n+            F_Spec.Sign := Forced;\n+         elsif F (I) = ' ' then\n+            F_Spec.Sign := Space;\n+         elsif F (I) = '#' then\n+            F_Spec.Base := C_Style;\n+         elsif F (I) = '~' then\n+            F_Spec.Base := Ada_Style;\n+         elsif F (I) = '0' then\n+            F_Spec.Zero_Pad := True;\n+         else\n+            exit Flags_Check;\n+         end if;\n+\n+         I := I + 1;\n+      end loop Flags_Check;\n+\n+      --  Check width if any\n+\n+      if F (I) in '0' .. '9' then\n+         --  We have a width parameter\n+\n+         S := I;\n+\n+         while I < F'Last and then F (I + 1) in '0' .. '9' loop\n+            I := I + 1;\n+         end loop;\n+\n+         F_Spec.Width := Natural'Value (F (S .. I));\n+\n+         I := I + 1;\n+\n+      elsif F (I) = '*' then\n+         --  The width will be taken from the integer parameter\n+\n+         F_Spec.Value_Needed := 1;\n+         Width_From_Var := True;\n+\n+         I := I + 1;\n+      end if;\n+\n+      if F (I) = '.' then\n+         --  We have a precision parameter\n+\n+         I := I + 1;\n+\n+         if F (I) in '0' .. '9' then\n+            S := I;\n+\n+            while I < F'Length and then F (I + 1) in '0' .. '9' loop\n+               I := I + 1;\n+            end loop;\n+\n+            if F (I) = '.' then\n+               --  No precision, 0 is assumed\n+               F_Spec.Precision := 0;\n+            else\n+               F_Spec.Precision := Natural'Value (F (S .. I));\n+            end if;\n+\n+            I := I + 1;\n+\n+         elsif F (I) = '*' then\n+            --  The prevision will be taken from the integer parameter\n+\n+            F_Spec.Value_Needed := F_Spec.Value_Needed + 1;\n+            I := I + 1;\n+         end if;\n+      end if;\n+\n+      --  Skip the length specifier, this is not needed for this implementation\n+      --  but yet for compatibility reason it is handled.\n+\n+      Length_Check :\n+      while I <= F'Last\n+        and then F (I) in 'h' | 'l' | 'j' | 'z' | 't' | 'L'\n+      loop\n+         I := I + 1;\n+      end loop Length_Check;\n+\n+      if I > F'Last then\n+         Raise_Wrong_Format (Format);\n+      end if;\n+\n+      --  Read next character which should be the expected type\n+\n+      case F (I) is\n+         when 'c'       => F_Spec.Kind := Char;\n+         when 's'       => F_Spec.Kind := Str;\n+         when 'd' | 'i' => F_Spec.Kind := Decimal_Int;\n+         when 'u'       => F_Spec.Kind := Unsigned_Decimal_Int;\n+         when 'f' | 'F' => F_Spec.Kind := Decimal_Float;\n+         when 'e'       => F_Spec.Kind := Decimal_Scientific_Float;\n+         when 'E'       => F_Spec.Kind := Decimal_Scientific_Float_Up;\n+         when 'g'       => F_Spec.Kind := Shortest_Decimal_Float;\n+         when 'G'       => F_Spec.Kind := Shortest_Decimal_Float_Up;\n+         when 'o'       => F_Spec.Kind := Unsigned_Octal;\n+         when 'x'       => F_Spec.Kind := Unsigned_Hexadecimal_Int;\n+         when 'X'       => F_Spec.Kind := Unsigned_Hexadecimal_Int_Up;\n+\n+         when others =>\n+            raise Format_Error with \"unknown format specified for parameter\"\n+              & Positive'Image (Format.D.Current);\n+      end case;\n+\n+      I := I + 1;\n+\n+      if F_Spec.Value_Needed > 0\n+        and then F_Spec.Value_Needed = Format.D.Stored_Value\n+      then\n+         if F_Spec.Value_Needed = 1 then\n+            if Width_From_Var then\n+               F_Spec.Width := Format.D.Stack (1);\n+            else\n+               F_Spec.Precision := Format.D.Stack (1);\n+            end if;\n+\n+         else\n+            F_Spec.Width := Format.D.Stack (1);\n+            F_Spec.Precision := Format.D.Stack (2);\n+         end if;\n+      end if;\n+   end Next_Format;\n+\n+   ------------------\n+   -- P_Flt_Format --\n+   ------------------\n+\n+   function P_Flt_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String\n+   is\n+      F      : F_Data;\n+      Buffer : String (1 .. 50);\n+      S, E   : Positive := 1;\n+      Start  : Positive;\n+      Aft    : Text_IO.Field;\n+   begin\n+      Next_Format (Format, F, Start);\n+\n+      if F.Value_Needed > 0 then\n+         Raise_Wrong_Format (Format);\n+      end if;\n+\n+      if F.Precision = Unset then\n+         Aft := 6;\n+      else\n+         Aft := F.Precision;\n+      end if;\n+\n+      case F.Kind is\n+         when Decimal_Float =>\n+\n+            Put (Buffer, Var, Aft, Exp => 0);\n+            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            E := Buffer'Last;\n+\n+         when Decimal_Scientific_Float | Decimal_Scientific_Float_Up =>\n+\n+            Put (Buffer, Var, Aft, Exp => 3);\n+            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            E := Buffer'Last;\n+\n+            if F.Kind = Decimal_Scientific_Float then\n+               Buffer (S .. E) :=\n+                 Characters.Handling.To_Lower (Buffer (S .. E));\n+            end if;\n+\n+         when Shortest_Decimal_Float | Shortest_Decimal_Float_Up =>\n+            --  Without exponent\n+\n+            Put (Buffer, Var, Aft, Exp => 0);\n+            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            E := Buffer'Last;\n+\n+            --  Check with exponent\n+\n+            declare\n+               Buffer2 : String (1 .. 50);\n+               S2, E2  : Positive;\n+            begin\n+               Put (Buffer2, Var, Aft, Exp => 3);\n+               S2 := Strings.Fixed.Index_Non_Blank (Buffer2);\n+               E2 := Buffer2'Last;\n+\n+               --  If with exponent it is shorter, use it\n+\n+               if (E2 - S2) < (E - S) then\n+                  Buffer := Buffer2;\n+                  S := S2;\n+                  E := E2;\n+               end if;\n+            end;\n+\n+            if F.Kind = Shortest_Decimal_Float then\n+               Buffer (S .. E) :=\n+                 Characters.Handling.To_Lower (Buffer (S .. E));\n+            end if;\n+\n+         when others =>\n+            Raise_Wrong_Format (Format);\n+      end case;\n+\n+      Append (Format.D.Result,\n+              Get_Formatted (F, Buffer (S .. E), Buffer (S .. E)'Length));\n+\n+      return Format;\n+   end P_Flt_Format;\n+\n+   ------------------\n+   -- P_Int_Format --\n+   ------------------\n+\n+   function P_Int_Format\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String\n+   is\n+\n+      function Handle_Precision return Boolean;\n+      --  Return True if nothing else to do\n+\n+      F      : F_Data;\n+      Buffer : String (1 .. 50);\n+      S, E   : Positive := 1;\n+      Len    : Natural := 0;\n+      Start  : Positive;\n+\n+      ----------------------\n+      -- Handle_Precision --\n+      ----------------------\n+\n+      function Handle_Precision return Boolean is\n+      begin\n+         if F.Precision = 0 and then Sign (Var) = Zero then\n+            return True;\n+\n+         elsif F.Precision = Natural'Last then\n+            null;\n+\n+         elsif F.Precision > E - S + 1 then\n+            Len := F.Precision - (E - S + 1);\n+            Buffer (S - Len .. S - 1) := (others => '0');\n+            S := S - Len;\n+         end if;\n+\n+         return False;\n+      end Handle_Precision;\n+\n+   begin\n+      Next_Format (Format, F, Start);\n+\n+      if Format.D.Stored_Value < F.Value_Needed then\n+         Format.D.Stored_Value := Format.D.Stored_Value + 1;\n+         Format.D.Stack (Format.D.Stored_Value) := To_Integer (Var);\n+         Format.D.Index := Start;\n+         return Format;\n+      end if;\n+\n+      case F.Kind is\n+         when Unsigned_Octal =>\n+            if Sign (Var) = Neg then\n+               Raise_Wrong_Format (Format);\n+            end if;\n+\n+            Put (Buffer, Var, Base => 8);\n+            S := Strings.Fixed.Index (Buffer, \"8#\") + 2;\n+            E := Strings.Fixed.Index (Buffer (S .. Buffer'Last), \"#\") - 1;\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+            case F.Base is\n+               when None      => null;\n+               when C_Style   => Len := 1;\n+               when Ada_Style => Len := 3;\n+            end case;\n+\n+         when Unsigned_Hexadecimal_Int =>\n+            if Sign (Var) = Neg then\n+               Raise_Wrong_Format (Format);\n+            end if;\n+\n+            Put (Buffer, Var, Base => 16);\n+            S := Strings.Fixed.Index (Buffer, \"16#\") + 3;\n+            E := Strings.Fixed.Index (Buffer (S .. Buffer'Last), \"#\") - 1;\n+            Buffer (S .. E) := Characters.Handling.To_Lower (Buffer (S .. E));\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+            case F.Base is\n+               when None      => null;\n+               when C_Style   => Len := 2;\n+               when Ada_Style => Len := 4;\n+            end case;\n+\n+         when Unsigned_Hexadecimal_Int_Up =>\n+            if Sign (Var) = Neg then\n+               Raise_Wrong_Format (Format);\n+            end if;\n+\n+            Put (Buffer, Var, Base => 16);\n+            S := Strings.Fixed.Index (Buffer, \"16#\") + 3;\n+            E := Strings.Fixed.Index (Buffer (S .. Buffer'Last), \"#\") - 1;\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+            case F.Base is\n+               when None      => null;\n+               when C_Style   => Len := 2;\n+               when Ada_Style => Len := 4;\n+            end case;\n+\n+         when Unsigned_Decimal_Int =>\n+            if Sign (Var) = Neg then\n+               Raise_Wrong_Format (Format);\n+            end if;\n+\n+            Put (Buffer, Var, Base => 10);\n+            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            E := Buffer'Last;\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+         when Decimal_Int =>\n+            Put (Buffer, Var, Base => 10);\n+            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            E := Buffer'Last;\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+         when Char =>\n+            S := Buffer'First;\n+            E := Buffer'First;\n+            Buffer (S) := Character'Val (To_Integer (Var));\n+\n+            if Handle_Precision then\n+               return Format;\n+            end if;\n+\n+         when others =>\n+            Raise_Wrong_Format (Format);\n+      end case;\n+\n+      --  Then add base if needed\n+\n+      declare\n+         N : String :=\n+               Get_Formatted (F, Buffer (S .. E), E - S + 1 + Len);\n+         P : constant Positive :=\n+               (if F.Left_Justify\n+                then N'First\n+                else Natural'Max (Strings.Fixed.Index_Non_Blank (N) - 1,\n+                                  N'First));\n+      begin\n+         case F.Base is\n+            when None   =>\n+               null;\n+\n+            when C_Style   =>\n+               case F.Kind is\n+                  when Unsigned_Octal =>\n+                     N (P) := 'O';\n+\n+                  when Unsigned_Hexadecimal_Int =>\n+                     if F.Left_Justify then\n+                        N (P .. P + 1) := \"Ox\";\n+                     else\n+                        N (P - 1 .. P) := \"0x\";\n+                     end if;\n+\n+                  when Unsigned_Hexadecimal_Int_Up =>\n+                     if F.Left_Justify then\n+                        N (P .. P + 1) := \"OX\";\n+                     else\n+                        N (P - 1 .. P) := \"0X\";\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+            when Ada_Style   =>\n+               case F.Kind is\n+                  when Unsigned_Octal =>\n+                     if F.Left_Justify then\n+                        N (N'First + 2 .. N'Last) := N (N'First .. N'Last - 2);\n+                     else\n+                        N (P .. N'Last - 1) := N (P + 1 .. N'Last);\n+                     end if;\n+\n+                     N (N'First .. N'First + 1) := \"8#\";\n+                     N (N'Last) := '#';\n+\n+                  when Unsigned_Hexadecimal_Int\n+                    | Unsigned_Hexadecimal_Int_Up\n+                    =>\n+                     if F.Left_Justify then\n+                        N (N'First + 3 .. N'Last) := N (N'First .. N'Last - 3);\n+                     else\n+                        N (P .. N'Last - 1) := N (P + 1 .. N'Last);\n+                     end if;\n+\n+                     N (N'First .. N'First + 2) := \"16#\";\n+                     N (N'Last) := '#';\n+\n+                  when others =>\n+                     null;\n+               end case;\n+         end case;\n+\n+         Append (Format.D.Result, N);\n+      end;\n+\n+      return Format;\n+   end P_Int_Format;\n+\n+   ------------------------\n+   -- Raise_Wrong_Format --\n+   ------------------------\n+\n+   procedure Raise_Wrong_Format (Format : Formatted_String) is\n+   begin\n+      raise Format_Error with \"wrong format specified for parameter\"\n+        & Positive'Image (Format.D.Current);\n+   end Raise_Wrong_Format;\n+\n+end GNAT.Formatted_String;"}, {"sha": "c0e0049c2e80c62445069738ca9d4a66977ab616", "filename": "gcc/ada/g-forstr.ads", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fg-forstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fg-forstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-forstr.ads?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -0,0 +1,285 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . F O R M A T T E D _ S T R I N G                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package add support for formatted string as supported by C printf().\n+--\n+--  A simple usage is:\n+--\n+--     declare\n+--        F : Formatted_String := +\"['%c' ; %10d]\";\n+--        C : Character := 'v';\n+--        I : Integer := 98;\n+--     begin\n+--        F := F & C & I;\n+--        Put_Line (-F);\n+--\n+--     end;\n+--\n+--  Which will display:\n+--\n+--     ['v' ;         98]\n+--\n+--\n+--  Each format specifier is: %[flags][width][.precision][length]specifier\n+--\n+--  Specifiers:\n+--    d or i    Signed decimal integer\n+--    u         Unsigned decimal integer\n+--    o         Unsigned octal\n+--    x         Unsigned hexadecimal integer\n+--    X         Unsigned hexadecimal integer (uppercase)\n+--    f         Decimal floating point, lowercase\n+--    F         Decimal floating point, uppercase\n+--    e         Scientific notation (mantissa/exponent), lowercase\n+--    E         Scientific notation (mantissa/exponent), uppercase\n+--    g         Use the shortest representation: %e or %f\n+--    G         Use the shortest representation: %E or %F\n+--    c         Character\n+--    s         String of characters\n+--    p         Pointer address\n+--    %         A % followed by another % character will write a single %\n+--\n+--  Flags:\n+--    -         Left-justify within the given field width;\n+--              Right justification is the default\n+--    +         Forces to preceed the result with a plus or minus sign (+ or -)\n+--              even for positive numbers. By default, only negative numbers\n+--              are preceded with a - sign.\n+--    (space)   If no sign is going to be written, a blank space is inserted\n+--              before the value.\n+--    #         Used with o, x or X specifiers the value is preceeded with\n+--              0, 0x or 0X respectively for values different than zero.\n+--              Used with a, A, e, E, f, F, g or G it forces the written\n+--              output to contain a decimal point even if no more digits\n+--              follow. By default, if no digits follow, no decimal point is\n+--              written.\n+--    ~         As above, but using Ada style based <base>#<number>#\n+--    0         Left-pads the number with zeroes (0) instead of spaces when\n+--              padding is specified.\n+--  Width:\n+--    number    Minimum number of characters to be printed. If the value to\n+--              be printed is shorter than this number, the result is padded\n+--              with blank spaces. The value is not truncated even if the\n+--              result is larger.\n+--    *         The width is not specified in the format string, but as an\n+--              additional integer value argument preceding the argument that\n+--              has to be formatted.\n+--  Precision:\n+--    number    For integer specifiers (d, i, o, u, x, X): precision specifies\n+--              the minimum number of digits to be written. If the value to be\n+--              written is shorter than this number, the result is padded with\n+--              leading zeros. The value is not truncated even if the result\n+--              is longer. A precision of 0 means that no character is written\n+--              for the value 0.\n+--              For e, E, f and F specifiers: this is the number of digits to\n+--              be printed after the decimal point (by default, this is 6).\n+--              For g and G specifiers: This is the maximum number of\n+--              significant digits to be printed.\n+--              For s: this is the maximum number of characters to be printed.\n+--              By default all characters are printed until the ending null\n+--              character is encountered.\n+--              If the period is specified without an explicit value for\n+--              precision, 0 is assumed.\n+--    .*        The precision is not specified in the format string, but as an\n+--              additional integer value argument preceding the argument that\n+--              has to be formatted.\n+\n+with Ada.Text_IO;\n+with System;\n+\n+private with Ada.Finalization;\n+private with Ada.Strings.Unbounded;\n+\n+package GNAT.Formatted_String is\n+\n+   use Ada;\n+\n+   type Formatted_String (<>) is private;\n+   --  A format string as defined for printf routine\n+\n+   Format_Error : exception;\n+   --  Raised for every mismatch between the parameter and the expected format\n+   --  and for malformed format.\n+\n+   function \"+\" (Format : String) return Formatted_String;\n+   --  Create the format string\n+\n+   function \"-\" (Format : Formatted_String) return String;\n+   --  Get the result of the formatted string corresponding to the current\n+   --  rendering (up to the last parameter formated).\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Character) return Formatted_String;\n+   --  A character, expect a %c\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : String) return Formatted_String;\n+   --  A string, expect a %s\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Boolean) return Formatted_String;\n+   --  A boolean image, expect a %s\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Integer) return Formatted_String;\n+   --  An integer, expect a %d, %o, %x, %X\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Long_Integer) return Formatted_String;\n+   --  As above\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : System.Address) return Formatted_String;\n+   --  An address, expect a %p\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Float) return Formatted_String;\n+   --  A float, expect %f, %e, %F, %E, %g, %G\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Long_Float) return Formatted_String;\n+   --  As above\n+\n+   function \"&\"\n+     (Format : Formatted_String;\n+      Var    : Duration) return Formatted_String;\n+   --  As above\n+\n+   --  Some generics\n+\n+   generic\n+      type Int is range <>;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Int;\n+         Base : Text_IO.Number_Base);\n+   function Int_Format\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String;\n+   --  As for Integer above\n+\n+   generic\n+      type Int is mod <>;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Int;\n+         Base : Text_IO.Number_Base);\n+   function Mod_Format\n+     (Format : Formatted_String;\n+      Var    : Int) return Formatted_String;\n+   --  As for Integer above\n+\n+   generic\n+      type Flt is digits <>;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Flt;\n+         Aft  : Text_IO.Field;\n+         Exp  : Text_IO.Field);\n+   function Flt_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String;\n+   --  As for Float above\n+\n+   generic\n+      type Flt is delta <>;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Flt;\n+         Aft  : Text_IO.Field;\n+         Exp  : Text_IO.Field);\n+   function Fixed_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String;\n+   --  As for Float above\n+\n+   generic\n+      type Flt is delta <> digits <>;\n+\n+      with procedure Put\n+        (To   : out String;\n+         Item : Flt;\n+         Aft  : Text_IO.Field;\n+         Exp  : Text_IO.Field);\n+   function Decimal_Format\n+     (Format : Formatted_String;\n+      Var    : Flt) return Formatted_String;\n+   --  As for Float above\n+\n+   generic\n+      type Enum is (<>);\n+   function Enum_Format\n+     (Format : Formatted_String; Var : Enum) return Formatted_String;\n+   --  As for String above, output the string representation of the enumeration\n+\n+private\n+\n+   use Ada.Strings.Unbounded;\n+\n+   type I_Vars is array (Positive range 1 .. 2) of Integer;\n+   --  Used to keep 2 numbers for the possible * for the width and precision\n+\n+   type Data (Size : Natural) is record\n+      Ref_Count    : Natural := 1;\n+      Format       : String (1 .. Size); -- the format string\n+      Index        : Positive := 1;      -- format index for next value\n+      Result       : Unbounded_String;   -- current value\n+      Current      : Natural;            -- the current format number\n+      Stored_Value : Natural := 0;       -- number of stored values in Stack\n+      Stack        : I_Vars;\n+   end record;\n+\n+   type Data_Access is access Data;\n+\n+   --  The formatted string record is controlled and do not need an initialize\n+   --  as it requires an explit initial value. This is given with \"+\" and\n+   --  properly initialize the record at this point.\n+\n+   type Formatted_String is new Finalization.Controlled with record\n+      D : Data_Access;\n+   end record;\n+\n+   overriding procedure Adjust   (F : in out Formatted_String);\n+   overriding procedure Finalize (F : in out Formatted_String);\n+\n+end GNAT.Formatted_String;"}, {"sha": "fa18f8ab2ffaecf9959ed72caa362422be434550", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -594,6 +594,7 @@ The GNAT Library\n * GNAT.Expect (g-expect.ads)::\n * GNAT.Expect.TTY (g-exptty.ads)::\n * GNAT.Float_Control (g-flocon.ads)::\n+* GNAT.Formatted_String (g-forstr.ads)::\n * GNAT.Heap_Sort (g-heasor.ads)::\n * GNAT.Heap_Sort_A (g-hesora.ads)::\n * GNAT.Heap_Sort_G (g-hesorg.ads)::\n@@ -18934,6 +18935,7 @@ of GNAT, and will generate a warning message.\n * GNAT.Expect (g-expect.ads)::\n * GNAT.Expect.TTY (g-exptty.ads)::\n * GNAT.Float_Control (g-flocon.ads)::\n+* GNAT.Formatted_String (g-forstr.ads)::\n * GNAT.Heap_Sort (g-heasor.ads)::\n * GNAT.Heap_Sort_A (g-hesora.ads)::\n * GNAT.Heap_Sort_G (g-hesorg.ads)::\n@@ -19860,6 +19862,18 @@ mode required for correct semantic operation in Ada.  Some third party\n library calls may cause this mode to be modified, and the Reset procedure\n in this package can be used to reestablish the required mode.\n \n+@node GNAT.Formatted_String (g-forstr.ads)\n+@section @code{GNAT.Formatted_String} (@file{g-forstr.ads})\n+@cindex @code{GNAT.Formatted_String} (@file{g-forstr.ads})\n+@cindex Formatted String\n+\n+@noindent\n+Provides support for C/C++ printf() formatted string. The format is\n+copied from the printf() routine and should therefore gives identical\n+output. Some generic routines are provided to be able to use types\n+derived from Integer, Float or enumerations as values for the\n+formatted string.\n+\n @node GNAT.Heap_Sort (g-heasor.ads)\n @section @code{GNAT.Heap_Sort} (@file{g-heasor.ads})\n @cindex @code{GNAT.Heap_Sort} (@file{g-heasor.ads})"}, {"sha": "af2c27565101248633d97c84cbf50207b01abe3a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -19436,10 +19436,11 @@ For full details, refer to @cite{GNATcheck Reference Manual} document.\n @findex gnatstub\n \n @noindent\n-@command{gnatstub} creates body stubs, that is, empty but compilable bodies\n-for library unit declarations.\n+@command{gnatstub} creates empty but compilable bodies\n+for library unit declarations and empty but compilable\n+subunit for body stubs.\n \n-To create a body stub, @command{gnatstub} invokes the Ada\n+To create a body or a subunit, @command{gnatstub} invokes the Ada\n compiler and generates and uses the ASIS tree for the input source;\n thus the input must be legal Ada code, and the tool should have all the\n information needed to compile the input source. To provide this information,\n@@ -19455,7 +19456,7 @@ then the needed options should be provided to run preprocessor as a part of\n the @command{gnatstub} call, and the generated body stub will correspond to\n the preprocessed source.\n \n-By default, all the program unit body stubs generated by @code{gnatstub}\n+By default, all the program unit bodies generated by @code{gnatstub}\n raise the predefined @code{Program_Error} exception, which will catch\n accidental calls of generated stubs. This behavior can be changed with\n option @option{^--no-exception^/NO_EXCEPTION^} (see below).\n@@ -19472,35 +19473,31 @@ option @option{^--no-exception^/NO_EXCEPTION^} (see below).\n @command{gnatstub} has a command-line interface of the form:\n \n @smallexample\n-@c $ gnatstub @ovar{switches} @var{filename} @ovar{directory}\n+@c $ gnatstub @ovar{switches} @var{filename}\n @c Expanding @ovar macro inline (explanation in macro def comments)\n-$ gnatstub @r{[}@var{switches}@r{]} @var{filename} @r{[}@var{directory}@r{]} @r{[}-cargs @var{gcc_switches}@r{]}\n+$ gnatstub @r{[}@var{switches}@r{]} @var{filename} @r{[}-cargs @var{gcc_switches}@r{]}\n @end smallexample\n \n @noindent\n where\n @table @var\n @item filename\n is the name of the source file that contains a library unit declaration\n-for which a body must be created. The file name may contain the path\n-information.\n-The file name does not have to follow the GNAT file name conventions. If the\n-name\n-does not follow GNAT file naming conventions, the name of the body file must\n+for which a body must be created or a library unit body for which subunits\n+must be created for the body stubs declared in this body.\n+The file name may contain the path information.\n+If the name does not follow GNAT file naming conventions and a set\n+of seitches does not contain a project file that defines naming\n+conventions, the name of the body file must\n be provided\n explicitly as the value of the @option{^-o^/BODY=^@var{body-name}} option.\n If the file name follows the GNAT file naming\n conventions and the name of the body file is not provided,\n @command{gnatstub}\n-creates the name\n-of the body file from the argument file name by replacing the @file{.ads}\n-suffix\n-with the @file{.adb} suffix.\n-\n-@item directory\n-indicates the directory in which the body stub is to be placed (the default\n-is the\n-current directory)\n+takes the naming conventions for the generated source from the\n+project file provided as a parameter of @option{-P} switch if any,\n+or creates the name file to generate using the standard GNAT\n+naming conventions.\n \n @item @samp{@var{gcc_switches}} is a list of switches for\n @command{gcc}. They will be passed on to all compiler invocations made by\n@@ -19539,11 +19536,20 @@ Indicates that external variable @var{name} in the argument project\n has the value @var{value}. Has no effect if no project is specified as\n tool argument.\n \n+@item ^--subunits^/SUBUNITS^\n+@cindex @option{^--subunits^/SUBUNITS^} (@command{gnatstub})\n+Generate subunits for body stubs. If this switch is specified,\n+@command{gnatstub} expects a library unit body as an agrument file,\n+otherwise a library unit declaration is expected. If a body stub\n+already has a corresponding subunit, @command{gnatstub} does not\n+generate anything for it.\n+\n @item ^-f^/FULL^\n @cindex @option{^-f^/FULL^} (@command{gnatstub})\n If the destination directory already contains a file with the name of the\n body file\n for the argument spec file, replace it with the generated body stub.\n+This switch cannot be used together with @option{^--subunits^/SUBUNITS^}.\n \n @item ^-hs^/HEADER=SPEC^\n @cindex @option{^-hs^/HEADER=SPEC^} (@command{gnatstub})\n@@ -19633,6 +19639,13 @@ conventions. If this switch is omitted the default name for the body will be\n obtained\n from the argument file name according to the GNAT file naming conventions.\n \n+@item ^--dir=^/DIR=^@var{dir-name}\n+@cindex @option{^--dir^/DIR^} (@command{gnatstub})\n+The path to the directory to place the generated files into.\n+If this switch is not set, the generated library unit body is\n+placed in the current directory, and generated sununits -\n+in the directory where the argument body is located.\n+\n @item ^-W^/RESULT_ENCODING=^@var{e}\n @cindex @option{^-W^/RESULT_ENCODING=^} (@command{gnatstub})\n Specify the wide character encoding method for the output body file."}, {"sha": "7b5c0fbaf518fee5dc64f057b9b677b8d61f615e", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -273,6 +273,7 @@ package body Impunit is\n     (\"g-expect\", F),  -- GNAT.Expect\n     (\"g-exptty\", F),  -- GNAT.Expect.TTY\n     (\"g-flocon\", F),  -- GNAT.Float_Control\n+    (\"g-forstr\", F),  -- GNAT.Formatted_String\n     (\"g-heasor\", F),  -- GNAT.Heap_Sort\n     (\"g-hesora\", F),  -- GNAT.Heap_Sort_A\n     (\"g-hesorg\", F),  -- GNAT.Heap_Sort_G"}, {"sha": "6a8f33640da7b305de4d8162d7be28cbfa9f3d4d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -2905,10 +2905,46 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n+                  --  External property aspects are Boolean by nature, but\n+                  --  their pragmas must contain two arguments, the second\n+                  --  being the optional Boolean expression.\n+\n+                  if A_Id = Aspect_Async_Readers\n+                    or else A_Id = Aspect_Async_Writers\n+                    or else A_Id = Aspect_Effective_Reads\n+                    or else A_Id = Aspect_Effective_Writes\n+                  then\n+                     declare\n+                        Args : List_Id;\n+\n+                     begin\n+                        --  The first argument of the external property pragma\n+                        --  is the related object.\n+\n+                        Args := New_List (\n+                          Make_Pragma_Argument_Association (Sloc (Ent),\n+                            Expression => Ent));\n+\n+                        --  The second argument is the optional Boolean\n+                        --  expression which must be propagated even if it\n+                        --  evaluates to False as this has special semantic\n+                        --  meaning.\n+\n+                        if Present (Expr) then\n+                           Append_To (Args,\n+                             Make_Pragma_Argument_Association (Loc,\n+                               Expression => Relocate_Node (Expr)));\n+                        end if;\n+\n+                        Make_Aitem_Pragma\n+                          (Pragma_Argument_Associations => Args,\n+                           Pragma_Name                  => Nam);\n+                     end;\n+\n                   --  Cases where we do not delay, includes all cases where\n                   --  the expression is missing other than the above cases.\n \n-                  if not Delay_Required or else No (Expr) then\n+                  elsif not Delay_Required or else No (Expr) then\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Sloc (Ent),\n@@ -2918,7 +2954,7 @@ package body Sem_Ch13 is\n \n                   --  In general cases, the corresponding pragma/attribute\n                   --  definition clause will be inserted later at the freezing\n-                  --  point, and we do not need to build it now\n+                  --  point, and we do not need to build it now.\n \n                   else\n                      Aitem := Empty;"}, {"sha": "158304d4ece09681d5fe3105cfae19002894cd8b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -1834,29 +1834,28 @@ package body Sem_Prag is\n      (N        : Node_Id;\n       Expr_Val : out Boolean)\n    is\n-      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n-      Obj  : constant Node_Id := Get_Pragma_Arg (Arg1);\n-      Expr : constant Node_Id := Get_Pragma_Arg (Next (Arg1));\n+      Arg1   : constant Node_Id   := First (Pragma_Argument_Associations (N));\n+      Obj_Id : constant Entity_Id := Entity (Get_Pragma_Arg (Arg1));\n+      Expr   : constant Node_Id   := Get_Pragma_Arg (Next (Arg1));\n \n    begin\n       Error_Msg_Name_1 := Pragma_Name (N);\n \n-      --  The Async / Effective pragmas must apply to a volatile object other\n-      --  than a formal subprogram parameter (SPARK RM 7.1.3(2)).\n+      --  An external property pragma must apply to a volatile object other\n+      --  than a formal subprogram parameter (SPARK RM 7.1.3(2)). The check\n+      --  is performed at the end of the declarative region due to a possible\n+      --  out-of-order arrangement of pragmas:\n+      --\n+      --    Obj : ...;\n+      --    pragma Async_Readers (Obj);\n+      --    pragma Volatile (Obj);\n \n-      if Is_SPARK_Volatile_Object (Obj) then\n-         if Is_Entity_Name (Obj)\n-           and then Present (Entity (Obj))\n-           and then Is_Formal (Entity (Obj))\n-         then\n-            SPARK_Msg_N (\"external property % cannot apply to parameter\", N);\n-         end if;\n-      else\n+      if not Is_SPARK_Volatile (Obj_Id) then\n          SPARK_Msg_N\n            (\"external property % must apply to a volatile object\", N);\n       end if;\n \n-      --  Ensure that the expression (if present) is static Boolean. A missing\n+      --  Ensure that the Boolean expression (if present) is static. A missing\n       --  argument defaults the value to True (SPARK RM 7.1.2(5)).\n \n       Expr_Val := True;\n@@ -1867,7 +1866,6 @@ package body Sem_Prag is\n          if Is_OK_Static_Expression (Expr) then\n             Expr_Val := Is_True (Expr_Value (Expr));\n          else\n-            Error_Msg_Name_1 := Pragma_Name (N);\n             SPARK_Msg_N (\"expression of % must be static\", Expr);\n          end if;\n       end if;\n@@ -11581,6 +11579,8 @@ package body Sem_Prag is\n               Pragma_Effective_Writes =>\n          Async_Effective : declare\n             Duplic : Node_Id;\n+            Expr   : Node_Id;\n+            Obj    : Node_Id;\n             Obj_Id : Entity_Id;\n \n          begin\n@@ -11589,48 +11589,47 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (1);\n             Check_At_Most_N_Arguments  (2);\n             Check_Arg_Is_Local_Name (Arg1);\n+            Error_Msg_Name_1 := Pname;\n \n-            Arg1 := Get_Pragma_Arg (Arg1);\n+            Obj  := Get_Pragma_Arg (Arg1);\n+            Expr := Get_Pragma_Arg (Arg2);\n \n             --  Perform minimal verification to ensure that the argument is at\n             --  least a variable. Subsequent finer grained checks will be done\n             --  at the end of the declarative region the contains the pragma.\n \n-            if Is_Entity_Name (Arg1) and then Present (Entity (Arg1)) then\n-               Obj_Id := Entity (Get_Pragma_Arg (Arg1));\n+            if Is_Entity_Name (Obj)\n+              and then Present (Entity (Obj))\n+              and then Ekind (Entity (Obj)) = E_Variable\n+            then\n+               Obj_Id := Entity (Obj);\n \n-               --  It is not efficient to examine preceding statements in order\n-               --  to detect duplicate pragmas as Boolean aspects may appear\n+               --  Detect a duplicate pragma. Note that it is not efficient to\n+               --  examine preceding statements as Boolean aspects may appear\n                --  anywhere between the related object declaration and its\n                --  freeze point. As an alternative, inspect the contents of the\n                --  variable contract.\n \n-               if Ekind (Obj_Id) = E_Variable then\n-                  Duplic := Get_Pragma (Obj_Id, Prag_Id);\n+               Duplic := Get_Pragma (Obj_Id, Prag_Id);\n \n-                  if Present (Duplic) then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc   := Sloc (Duplic);\n-                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+               if Present (Duplic) then\n+                  Error_Msg_Sloc := Sloc (Duplic);\n+                  Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n \n-                  --  Chain the pragma on the contract for further processing.\n-                  --  This also aids in detecting duplicates.\n+               --  No duplicate detected\n \n-                  else\n-                     Add_Contract_Item (N, Obj_Id);\n+               else\n+                  if Present (Expr) then\n+                     Preanalyze_And_Resolve (Expr, Standard_Boolean);\n                   end if;\n \n-                  --  The minimum legality requirements have been met, do not\n-                  --  fall through to the error message.\n+                  --  Chain the pragma on the contract for further processing\n \n-                  return;\n+                  Add_Contract_Item (N, Obj_Id);\n                end if;\n+            else\n+               Error_Pragma (\"pragma % must apply to a volatile object\");\n             end if;\n-\n-            --  If we get here, then the pragma applies to a non-object\n-            --  construct, issue a generic error (SPARK RM 7.1.3(2)).\n-\n-            Error_Pragma (\"pragma % must apply to a volatile object\");\n          end Async_Effective;\n \n          ------------------"}, {"sha": "9395c7bc3aca5186bc9f02deeef9d58a5f6182b3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -7423,10 +7423,11 @@ package body Sem_Util is\n       Property : Name_Id) return Boolean\n    is\n       function State_Has_Enabled_Property return Boolean;\n-      --  Determine whether a state denoted by Item_Id has the property\n+      --  Determine whether a state denoted by Item_Id has the property enabled\n \n       function Variable_Has_Enabled_Property return Boolean;\n       --  Determine whether a variable denoted by Item_Id has the property\n+      --  enabled.\n \n       --------------------------------\n       -- State_Has_Enabled_Property --\n@@ -7528,6 +7529,44 @@ package body Sem_Util is\n       -----------------------------------\n \n       function Variable_Has_Enabled_Property return Boolean is\n+         function Is_Enabled (Prag : Node_Id) return Boolean;\n+         --  Determine whether property pragma Prag (if present) denotes an\n+         --  enabled property.\n+\n+         ----------------\n+         -- Is_Enabled --\n+         ----------------\n+\n+         function Is_Enabled (Prag : Node_Id) return Boolean is\n+            Arg2 : Node_Id;\n+\n+         begin\n+            if Present (Prag) then\n+               Arg2 := Next (First (Pragma_Argument_Associations (Prag)));\n+\n+               --  The pragma has an optional Boolean expression, the related\n+               --  property is enabled only when the expression evaluates to\n+               --  True.\n+\n+               if Present (Arg2) then\n+                  return Is_True (Expr_Value (Get_Pragma_Arg (Arg2)));\n+\n+               --  Otherwise the lack of expression enables the property by\n+               --  default.\n+\n+               else\n+                  return True;\n+               end if;\n+\n+            --  The property was never set in the first place\n+\n+            else\n+               return False;\n+            end if;\n+         end Is_Enabled;\n+\n+         --  Local variables\n+\n          AR : constant Node_Id :=\n                 Get_Pragma (Item_Id, Pragma_Async_Readers);\n          AW : constant Node_Id :=\n@@ -7536,6 +7575,9 @@ package body Sem_Util is\n                 Get_Pragma (Item_Id, Pragma_Effective_Reads);\n          EW : constant Node_Id :=\n                 Get_Pragma (Item_Id, Pragma_Effective_Writes);\n+\n+      --  Start of processing for Variable_Has_Enabled_Property\n+\n       begin\n          --  A non-volatile object can never possess external properties\n \n@@ -7544,33 +7586,25 @@ package body Sem_Util is\n \n          --  External properties related to variables come in two flavors -\n          --  explicit and implicit. The explicit case is characterized by the\n-         --  presence of a property pragma while the implicit case lacks all\n-         --  such pragmas.\n+         --  presence of a property pragma with an optional Boolean flag. The\n+         --  property is enabled when the flag evaluates to True or the flag is\n+         --  missing altogether.\n \n-         elsif Property = Name_Async_Readers\n-           and then\n-             (Present (AR)\n-                or else\n-             (No (AW) and then No (ER) and then No (EW)))\n-         then\n+         elsif Property = Name_Async_Readers and then Is_Enabled (AR) then\n             return True;\n \n-         elsif Property = Name_Async_Writers\n-           and then (Present (AW)\n-                      or else (No (AR) and then No (ER) and then No (EW)))\n-         then\n+         elsif Property = Name_Async_Writers and then Is_Enabled (AW) then\n             return True;\n \n-         elsif Property = Name_Effective_Reads\n-           and then (Present (ER)\n-                      or else (No (AR) and then No (AW) and then No (EW)))\n-         then\n+         elsif Property = Name_Effective_Reads and then Is_Enabled (ER) then\n             return True;\n \n-         elsif Property = Name_Effective_Writes\n-           and then (Present (EW)\n-                      or else (No (AR) and then No (AW) and then No (ER)))\n-         then\n+         elsif Property = Name_Effective_Writes and then Is_Enabled (EW) then\n+            return True;\n+\n+         --  The implicit case lacks all property pragmas\n+\n+         elsif No (AR) and then No (AW) and then No (ER) and then No (EW) then\n             return True;\n \n          else"}, {"sha": "b4a19d8a9c43ef890edef61ba9776eaee52fbe2d", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6f8285368749fd716178f92e3131d003b6a18c/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=2f6f8285368749fd716178f92e3131d003b6a18c", "patch": "@@ -7167,6 +7167,16 @@ package VMS_Data is\n    --\n    --   Look for source, library or object files in the default directory.\n \n+   S_Stub_Dir      : aliased constant S := \"/DIR=@\"                        &\n+                                            \"--dir=@\";\n+\n+   --        /DIR=dirname\n+   --\n+   --   The directory to place the generated source(s) into. If this switch is\n+   --   omitted, the generated library unit body is placed in the current\n+   --   directory, and the generated subunit(s) - in the directory where the\n+   --   argument body file is located.\n+\n    S_Stub_Encoding : aliased constant S := \"/RESULT_ENCODING=\"             &\n                                             \"BRACKETS \"                    &\n                                                \"-Wb \"                      &\n@@ -7352,6 +7362,16 @@ package VMS_Data is\n    --   of the directory specified in the project file. If the subdirectory\n    --   does not exist, it is created automatically.\n \n+   S_Stub_Subunits : aliased constant S := \"/SUBUNITS \"                    &\n+                                           \"--subunits\";\n+\n+   --        /NOSUBUNITS (D)\n+   --        /SUBUNITS\n+   --\n+   --   Generate subunits for body stubs. If this switch is set, a library\n+   --   unit body is expected as a tool argument, otherwise a library unit\n+   --   declaration is expected to generate a body for.\n+\n    S_Stub_Tree    : aliased constant S := \"/TREE_FILE=\"                    &\n                                             \"OVERWRITE \"                   &\n                                                \"-t \"                       &\n@@ -7395,6 +7415,7 @@ package VMS_Data is\n                      (S_Stub_Add        'Access,\n                       S_Stub_Config     'Access,\n                       S_Stub_Current    'Access,\n+                      S_Stub_Dir        'Access,\n                       S_Stub_Encoding   'Access,\n                       S_Stub_Ext        'Access,\n                       S_Stub_Follow     'Access,\n@@ -7412,6 +7433,7 @@ package VMS_Data is\n                       S_Stub_Quiet      'Access,\n                       S_Stub_Search     'Access,\n                       S_Stub_Subdirs    'Access,\n+                      S_Stub_Subunits   'Access,\n                       S_Stub_Tree       'Access,\n                       S_Stub_Verbose    'Access);\n "}]}