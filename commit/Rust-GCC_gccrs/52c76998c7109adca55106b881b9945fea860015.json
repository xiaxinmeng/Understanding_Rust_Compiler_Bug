{"sha": "52c76998c7109adca55106b881b9945fea860015", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjNzY5OThjNzEwOWFkY2E1NTEwNmI4ODFiOTk0NWZlYTg2MDAxNQ==", "commit": {"author": {"name": "Paul Yuan", "email": "yingbo.com@gmail.com", "date": "2008-08-18T19:02:44Z"}, "committer": {"name": "Seongbae Park", "email": "spark@gcc.gnu.org", "date": "2008-08-18T19:02:44Z"}, "message": "cgraph.c (cgraph_edge): Handle inconsistent counts when setting count_scale.\n\n2008-08-18  Paul Yuan  <yingbo.com@gmail.com>\n\t    Vinodha Ramasamy  <vinodha@google.com>\n\n\t* cgraph.c (cgraph_edge): Handle inconsistent counts when setting\n\tcount_scale.\n\t* value-prof.c (check_counter): Fix the counter if\n\tflag_profile_correction is true.\n\t(tree_divmod_fixed_value_transform, tree_mod_pow2_value_transform,\n\ttree_mod_subtract_transform):\n\tFollow check_counter parameter change.\n\t* common.opt (fprofile-correction): New option.\n\t* mcf.c: New file.\n\t* profile.c (edge_info, EDGE_INFO): Moved to new file profile.h.\n\t(sum_edge_counts, is_edge_inconsistent, correct_negative_edge_counts,\n\tis_inconsistent, set_bb_counts, read_profile_edge_counts): New\n\tfunctions.\n\t(compute_branch_probabilities): Refactored. Invokes mcf_smooth_cfg if\n\tflag_profile_correction is set.\n\n\nCo-Authored-By: Vinodha Ramasamy <vinodha@google.com>\n\nFrom-SVN: r139208", "tree": {"sha": "60eb8bcbffe0c58454ecbc0a68eeff80b6a19db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60eb8bcbffe0c58454ecbc0a68eeff80b6a19db3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52c76998c7109adca55106b881b9945fea860015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c76998c7109adca55106b881b9945fea860015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c76998c7109adca55106b881b9945fea860015", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c76998c7109adca55106b881b9945fea860015/comments", "author": {"login": "pthread", "id": 1884629, "node_id": "MDQ6VXNlcjE4ODQ2Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1884629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pthread", "html_url": "https://github.com/pthread", "followers_url": "https://api.github.com/users/pthread/followers", "following_url": "https://api.github.com/users/pthread/following{/other_user}", "gists_url": "https://api.github.com/users/pthread/gists{/gist_id}", "starred_url": "https://api.github.com/users/pthread/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pthread/subscriptions", "organizations_url": "https://api.github.com/users/pthread/orgs", "repos_url": "https://api.github.com/users/pthread/repos", "events_url": "https://api.github.com/users/pthread/events{/privacy}", "received_events_url": "https://api.github.com/users/pthread/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "808cc41726a4f1b3ab1b87521e086baf3de66432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808cc41726a4f1b3ab1b87521e086baf3de66432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808cc41726a4f1b3ab1b87521e086baf3de66432"}], "stats": {"total": 302, "additions": 229, "deletions": 73}, "files": [{"sha": "e6f8549fd32ca4746debf94bd9b2ae9f5527aabf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -1,3 +1,22 @@\n+2008-08-18  Paul Yuan  <yingbo.com@gmail.com>\n+\t    Vinodha Ramasamy  <vinodha@google.com>\n+\n+\t* cgraph.c (cgraph_edge): Handle inconsistent counts when setting\n+\tcount_scale.\n+\t* value-prof.c (check_counter): Fix the counter if\n+\tflag_profile_correction is true.\n+\t(tree_divmod_fixed_value_transform, tree_mod_pow2_value_transform,\n+\ttree_mod_subtract_transform):\n+\tFollow check_counter parameter change.\n+\t* common.opt (fprofile-correction): New option.\n+\t* mcf.c: New file.\n+\t* profile.c (edge_info, EDGE_INFO): Moved to new file profile.h.\n+\t(sum_edge_counts, is_edge_inconsistent, correct_negative_edge_counts,\n+\tis_inconsistent, set_bb_counts, read_profile_edge_counts): New\n+\tfunctions.\n+\t(compute_branch_probabilities): Refactored. Invokes mcf_smooth_cfg if\n+\tflag_profile_correction is set.\n+\n 2008-08-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* rtlanal.c (subreg_offset_representable_p): Check HARD_REGNO_MODE_OK."}, {"sha": "e50c2d5600daf9def51d35a0ef9af4194be30279", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -1112,6 +1112,7 @@ OBJS-common = \\\n \tloop-unroll.o \\\n \tloop-unswitch.o \\\n \tlower-subreg.o \\\n+\tmcf.o \\\n \tmode-switching.o \\\n \tmodulo-sched.o \\\n \tomega.o \\\n@@ -2717,7 +2718,9 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\\n-   $(CFGLOOP_H) $(TIMEVAR_H) tree-pass.h\n+   $(CFGLOOP_H) $(TIMEVAR_H) tree-pass.h profile.h\n+mcf.o : mcf.c profile.h $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h \\\n+   $(BASIC_BLOCK_H) output.h langhooks.h $(GCOV_IO_H) $(TREE_H) \n tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    $(FUNCTION_H) $(TOPLEV_H) $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \\\n@@ -3213,7 +3216,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/function.c $(srcdir)/except.h \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n-  $(srcdir)/profile.c $(srcdir)/regclass.c \\\n+  $(srcdir)/profile.c $(srcdir)/regclass.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\"}, {"sha": "a8463d403689a5155315b7ac483206f14f9bc538", "filename": "gcc/cgraph.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -516,7 +516,7 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n   if (node->call_site_hash)\n     return (struct cgraph_edge *)\n       htab_find_with_hash (node->call_site_hash, call_stmt,\n-\t\t\t   htab_hash_pointer (call_stmt));\n+      \t                   htab_hash_pointer (call_stmt));\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best\n@@ -1208,7 +1208,12 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   new_node->master_clone = n->master_clone;\n   new_node->count = count;\n   if (n->count)\n-    count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n+    {\n+      if (new_node->count > n->count)\n+        count_scale = REG_BR_PROB_BASE;\n+      else\n+        count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n+    }\n   else\n     count_scale = 0;\n   if (update_original)"}, {"sha": "9fc5db3e158305c3e9a1c9b4e7fbd9fadf2ea554", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -821,6 +821,10 @@ Common Joined RejectNegative\n Set the top-level directory for storing the profile data.\n The default is 'pwd'.\n \n+fprofile-correction\n+Common Report Var(flag_profile_correction)\n+Enable correction of flow inconsistent profile data input\n+\n fprofile-generate\n Common\n Enable common options for generating profile info for profile feedback directed optimizations"}, {"sha": "1280e4928b1f4525f4d50f203ad4b171b66360a8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -342,7 +342,8 @@ Objective-C and Objective-C++ Dialects}.\n -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol\n -fpeel-loops -fpredictive-commoning -fprefetch-loop-arrays @gol\n--fprofile-dir=@var{path} -fprofile-generate -fprofile-generate=@var{path} @gol\n+-fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n+-fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n -freciprocal-math -fregmove -frename-registers -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n@@ -6369,6 +6370,13 @@ and occasionally eliminate the copy.\n \n Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -fprofile-correction\n+@opindex fprofile-correction\n+Profiles collected using an instrumented binary for multi-threaded programs may\n+be inconsistent due to missed counter updates. When this option is specified,\n+GCC will use heuristics to correct or smooth out such inconsistencies. By\n+default, GCC will emit an error message when an inconsistent profile is detected.\n+\n @item -fprofile-dir=@var{path}\n @opindex fprofile-dir\n "}, {"sha": "761c8ad4b07a3429e14c055f53d1bd0bedf7169c", "filename": "gcc/profile.c", "status": "modified", "additions": 145, "deletions": 55, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -69,21 +69,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n \n+#include \"profile.h\"\n+\n /* Hooks for profiling.  */\n static struct profile_hooks* profile_hooks;\n \n-/* Additional information about the edges we need.  */\n-struct edge_info {\n-  unsigned int count_valid : 1;\n-\n-  /* Is on the spanning tree.  */\n-  unsigned int on_tree : 1;\n-\n-  /* Pretend this edge does not exist (it is abnormal and we've\n-     inserted a fake to compensate).  */\n-  unsigned int ignore : 1;\n-};\n-\n struct bb_info {\n   unsigned int count_valid : 1;\n \n@@ -92,7 +82,6 @@ struct bb_info {\n   gcov_type pred_count;\n };\n \n-#define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n #define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n \n \n@@ -124,7 +113,6 @@ static gcov_type * get_exec_counts (void);\n static basic_block find_group (basic_block);\n static void union_groups (basic_block, basic_block);\n \n-\f\n /* Add edge instrumentation code to the entire insn chain.\n \n    F is the first insn of the chain.\n@@ -278,64 +266,84 @@ get_exec_counts (void)\n \n   return counts;\n }\n-\f\n \n-/* Compute the branch probabilities for the various branches.\n-   Annotate them accordingly.  */\n+\n+static bool\n+is_edge_inconsistent (VEC(edge,gc) *edges)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, edges)\n+    {\n+      if (!EDGE_INFO (e)->ignore)\n+        {\n+          if (e->count < 0)\n+            return true;\n+        }\n+    }\n+  return false;\n+}\n \n static void\n-compute_branch_probabilities (void)\n+correct_negative_edge_counts (void)\n {\n   basic_block bb;\n-  int i;\n-  int num_edges = 0;\n-  int changes;\n-  int passes;\n-  int hist_br_prob[20];\n-  int num_never_executed;\n-  int num_branches;\n-  gcov_type *exec_counts = get_exec_counts ();\n-  int exec_counts_pos = 0;\n+  edge e;\n+  edge_iterator ei;\n \n-  /* Very simple sanity checks so we catch bugs in our profiling code.  */\n-  if (profile_info)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      if (profile_info->run_max * profile_info->runs < profile_info->sum_max)\n-\t{\n-\t  error (\"corrupted profile info: run_max * runs < sum_max\");\n-\t  exec_counts = NULL;\n-\t}\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        {\n+           if (e->count < 0)\n+             e->count = 0;\n+        }\n+    }\n+}\n \n-      if (profile_info->sum_all < profile_info->sum_max)\n-\t{\n-\t  error (\"corrupted profile info: sum_all is smaller than sum_max\");\n-\t  exec_counts = NULL;\n-\t}\n+/* Check consistency.\n+   Return true if inconsistency is found.  */\n+static bool\n+is_inconsistent (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    {\n+      if (is_edge_inconsistent (bb->preds))\n+        return true;\n+      if (is_edge_inconsistent (bb->succs))\n+        return true;\n+      if ( bb->count != sum_edge_counts (bb->preds)\n+         || (bb->count != sum_edge_counts (bb->succs) &&\n+             !(find_edge (bb, EXIT_BLOCK_PTR) != NULL &&\n+               block_ends_with_call_p (bb))))\n+        return true;\n     }\n \n-  /* Attach extra info block to each bb.  */\n+  return false;\n+}\n \n-  alloc_aux_for_blocks (sizeof (struct bb_info));\n+/* Set each basic block count to the sum of its outgoing edge counts */\n+static void\n+set_bb_counts (void)\n+{\n+  basic_block bb;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (!EDGE_INFO (e)->ignore)\n-\t  BB_INFO (bb)->succ_count++;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!EDGE_INFO (e)->ignore)\n-\t  BB_INFO (bb)->pred_count++;\n+      bb->count = sum_edge_counts (bb->succs);\n+      gcc_assert (bb->count >= 0);\n     }\n+}\n \n-  /* Avoid predicting entry on exit nodes.  */\n-  BB_INFO (EXIT_BLOCK_PTR)->succ_count = 2;\n-  BB_INFO (ENTRY_BLOCK_PTR)->pred_count = 2;\n-\n+/* Reads profile data and returns total number of edge counts read */\n+static int\n+read_profile_edge_counts (gcov_type *exec_counts)\n+{\n+  basic_block bb;\n+  int num_edges = 0;\n+  int exec_counts_pos = 0;\n   /* For each edge not on the spanning tree, set its execution count from\n      the .da file.  */\n-\n   /* The first count in the .da file is the number of times that the function\n      was entered.  This is the exec_count for block zero.  */\n \n@@ -373,6 +381,63 @@ compute_branch_probabilities (void)\n \t  }\n     }\n \n+    return num_edges;\n+}\n+\n+/* Compute the branch probabilities for the various branches.\n+   Annotate them accordingly.  */\n+\n+static void\n+compute_branch_probabilities (void)\n+{\n+  basic_block bb;\n+  int i;\n+  int num_edges = 0;\n+  int changes;\n+  int passes;\n+  int hist_br_prob[20];\n+  int num_never_executed;\n+  int num_branches;\n+  gcov_type *exec_counts = get_exec_counts ();\n+  int inconsistent = 0;\n+\n+  /* Very simple sanity checks so we catch bugs in our profiling code.  */\n+  if (profile_info)\n+    {\n+      if (profile_info->run_max * profile_info->runs < profile_info->sum_max)\n+        {\n+          error (\"corrupted profile info: run_max * runs < sum_max\");\n+          exec_counts = NULL;\n+        }\n+\n+      if (profile_info->sum_all < profile_info->sum_max)\n+        {\n+          error (\"corrupted profile info: sum_all is smaller than sum_max\");\n+          exec_counts = NULL;\n+        }\n+    }\n+\n+  /* Attach extra info block to each bb.  */\n+  alloc_aux_for_blocks (sizeof (struct bb_info));\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (!EDGE_INFO (e)->ignore)\n+\t  BB_INFO (bb)->succ_count++;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!EDGE_INFO (e)->ignore)\n+\t  BB_INFO (bb)->pred_count++;\n+    }\n+\n+  /* Avoid predicting entry on exit nodes.  */\n+  BB_INFO (EXIT_BLOCK_PTR)->succ_count = 2;\n+  BB_INFO (ENTRY_BLOCK_PTR)->pred_count = 2;\n+\n+  num_edges = read_profile_edge_counts (exec_counts);\n+\n   if (dump_file)\n     fprintf (dump_file, \"\\n%d edge counts read\\n\", num_edges);\n \n@@ -502,6 +567,31 @@ compute_branch_probabilities (void)\n       gcc_assert (!BB_INFO (bb)->succ_count && !BB_INFO (bb)->pred_count);\n     }\n \n+  /* Check for inconsistent basic block counts */\n+  inconsistent = is_inconsistent ();\n+\n+  if (inconsistent)\n+   {\n+     if (flag_profile_correction)\n+       {\n+         /* Inconsistency detected. Make it flow-consistent. */\n+         static int informed = 0;\n+         if (informed == 0)\n+           {\n+             informed = 1;\n+             inform (\"correcting inconsistent profile data\");\n+           }\n+         correct_negative_edge_counts ();\n+         /* Set bb counts to the sum of the outgoing edge counts */\n+         set_bb_counts ();\n+         if (dump_file)\n+           fprintf (dump_file, \"\\nCalling mcf_smooth_cfg\\n\");\n+         mcf_smooth_cfg ();\n+       }\n+     else\n+       error (\"corrupted profile info: profile data is not flow-consistent\");\n+   }\n+\n   /* For every edge, calculate its branch probability and add a reg_note\n      to the branch insn to indicate this.  */\n "}, {"sha": "f3522f6dcb5036a9009ca266109dab505f2cb480", "filename": "gcc/value-prof.c", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c76998c7109adca55106b881b9945fea860015/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c76998c7109adca55106b881b9945fea860015/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=52c76998c7109adca55106b881b9945fea860015", "patch": "@@ -453,18 +453,32 @@ free_histograms (void)\n    somehow.  */\n \n static bool\n-check_counter (gimple stmt, const char *name, gcov_type all, gcov_type bb_count)\n+check_counter (gimple stmt, const char * name,\n+\t       gcov_type *count, gcov_type *all, gcov_type bb_count)\n {\n-  if (all != bb_count)\n+  if (*all != bb_count || *count > *all)\n     {\n       location_t locus;\n       locus = (stmt != NULL)\n-\t       ? gimple_location (stmt)\n-\t       : DECL_SOURCE_LOCATION (current_function_decl);\n-      error (\"%HCorrupted value profile: %s profiler overall count (%d) \"\n-\t     \"does not match BB count (%d)\", &locus, name, (int)all,\n-\t     (int)bb_count);\n-      return true;\n+              ? gimple_location (stmt)\n+              : DECL_SOURCE_LOCATION (current_function_decl);\n+      if (flag_profile_correction)\n+        {\n+\t  inform (\"%HCorrecting inconsistent value profile: \"\n+\t\t  \"%s profiler overall count (%d) does not match BB count \"\n+                  \"(%d)\", &locus, name, (int)all, (int)bb_count);\n+\t  *all = bb_count;\n+\t  if (*count > *all)\n+            *count = *all;\n+\t  return false;\n+\t}\n+      else\n+\t{\n+\t  error (\"%HCorrupted value profile: %s profiler overall count (%d) \"\n+                 \"does not match BB count (%d)\", &locus, name, (int)all,\n+                 (int)bb_count);\n+\t  return true;\n+\t}\n     }\n \n   return false;\n@@ -658,7 +672,7 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n       || !maybe_hot_bb_p (gimple_bb (stmt)))\n     return false;\n \n-  if (check_counter (stmt, \"value\", all, gimple_bb (stmt)->count))\n+  if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n \n   /* Compute probability of taking the optimal path.  */\n@@ -818,7 +832,7 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n   /* Compute probability of taking the optimal path.  */\n   all = count + wrong_values;\n \n-  if (check_counter (stmt, \"pow2\", all, gimple_bb (stmt)->count))\n+  if (check_counter (stmt, \"pow2\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n \n   if (all > 0)\n@@ -982,12 +996,17 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   count2 = histogram->hvalue.counters[1];\n \n   /* Compute probability of taking the optimal path.  */\n-  if (check_counter (stmt, \"interval\", all, gimple_bb (stmt)->count))\n+  if (check_counter (stmt, \"interval\", &count1, &all, gimple_bb (stmt)->count))\n     {\n       gimple_remove_histogram_value (cfun, stmt, histogram);\n       return false;\n     }\n \n+  if (flag_profile_correction && count1 + count2 > all)\n+      all = count1 + count2;\n+\n+  gcc_assert (count1 + count2 <= all);\n+\n   /* We require that we use just subtractions in at least 50% of all\n      evaluations.  */\n   count = 0;\n@@ -1160,7 +1179,7 @@ static bool\n gimple_ic_transform (gimple stmt)\n {\n   histogram_value histogram;\n-  gcov_type val, count, all;\n+  gcov_type val, count, all, bb_all;\n   gcov_type prob;\n   tree callee;\n   gimple modify;\n@@ -1186,6 +1205,14 @@ gimple_ic_transform (gimple stmt)\n   if (4 * count <= 3 * all)\n     return false;\n \n+  bb_all = gimple_bb (stmt)->count;\n+  /* The order of CHECK_COUNTER calls is important - \n+     since check_counter can correct the third parameter\n+     and we want to make count <= all <= bb_all. */\n+  if ( check_counter (stmt, \"ic\", &all, &bb_all, bb_all)\n+      || check_counter (stmt, \"ic\", &count, &all, all))\n+    return false;\n+\n   if (all > 0)\n     prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n   else\n@@ -1372,7 +1399,7 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n      at least 80% of time.  */\n   if ((6 * count / 5) < all || !maybe_hot_bb_p (gimple_bb (stmt)))\n     return false;\n-  if (check_counter (stmt, \"value\", all, gimple_bb (stmt)->count))\n+  if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n   if (all > 0)\n     prob = (count * REG_BR_PROB_BASE + all / 2) / all;"}]}