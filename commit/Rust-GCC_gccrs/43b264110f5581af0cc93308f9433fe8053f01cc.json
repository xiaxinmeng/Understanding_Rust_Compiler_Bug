{"sha": "43b264110f5581af0cc93308f9433fe8053f01cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNiMjY0MTEwZjU1ODFhZjBjYzkzMzA4Zjk0MzNmZTgwNTNmMDFjYw==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2019-09-18T08:33:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-18T08:33:07Z"}, "message": "[Ada] Spurious run time error on anonymous access formals\n\nThis patch fixes an issue whereby subprograms with anonymous access\nformals may trigger spurious runtime accessibility errors when such\nformals are used as actuals in calls to nested subprograms.\n\nRunning these commands:\n\n  gnatmake -q pass.adb\n  gnatmake -q fail.adb\n  gnatmake -q test_main.adb\n  gnatmake -q indirect_call_test.adb\n  pass\n  fail\n  test_main\n  indirect_call_test\n\nOn the following sources:\n\n--  pass.adb\n\nprocedure Pass is\n\n  function A (Param : access Integer) return Boolean is\n    type Typ is access all Integer;\n    function A_Inner (Param : access Integer) return Typ is\n      begin\n        return Typ (Param); --  OK\n      end;\n    begin\n      return A_Inner (Param) = Typ (Param);\n    end;\n\n  function B (Param : access Integer) return Boolean;\n  function B (Param : access Integer) return Boolean is\n    type Typ is access all Integer;\n    function B_Inner (Param : access Integer) return Typ is\n      begin\n        return Typ (Param); --  OK\n      end;\n    begin\n      return B_Inner (Param) = Typ (Param);\n    end;\n\n  procedure C (Param : access Integer) is\n    type Typ is access all Integer;\n    Var : Typ;\n    procedure C_Inner (Param : access Integer) is\n      begin\n        Var := Typ (Param); --  OK\n      end;\n    begin\n      C_Inner (Param);\n    end;\n\n  procedure D (Param : access Integer);\n  procedure D (Param : access Integer) is\n    type Typ is access all Integer;\n    Var : Typ;\n    procedure D_Inner (Param : access Integer) is\n      begin\n        Var := Typ (Param); --  OK\n      end;\n    begin\n      D_Inner (Param);\n    end;\n\n  protected type E is\n    function G (Param : access Integer) return Boolean;\n    procedure I (Param : access Integer);\n  end;\n\n  protected body E is\n    function F (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n      function F_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  OK\n        end;\n      begin\n        return F_Inner (Param) = Typ (Param);\n      end;\n\n    function G (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n      function G_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  OK\n        end;\n      B : Boolean := F (Param); --  OK\n      begin\n        return G_Inner (Param) = Typ (Param);\n      end;\n\n    procedure H (Param : access Integer) is\n      type Typ is access all Integer;\n      Var : Typ;\n      procedure H_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  OK\n        end;\n      begin\n        H_Inner (Param);\n      end;\n\n    procedure I (Param : access Integer) is\n      type Typ is access all Integer;\n      Var : Typ;\n      procedure I_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  OK\n        end;\n      begin\n        H (Param); --  OK\n        I_Inner (Param);\n      end;\n  end;\n\n  task type J is end;\n\n  task body J is\n    function K (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n      function K_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  OK\n        end;\n      begin\n        return K_Inner (Param) = Typ (Param);\n      end;\n\n    function L (Param : access Integer) return Boolean;\n    function L (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n      function L_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  OK\n        end;\n      begin\n        return L_Inner (Param) = Typ (Param);\n      end;\n\n    procedure M (Param : access Integer) is\n      type Typ is access all Integer;\n      Var : Typ;\n      procedure M_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  OK\n        end;\n      begin\n        M_Inner (Param);\n      end;\n\n    procedure N (Param : access Integer);\n    procedure N (Param : access Integer) is\n      type Typ is access all Integer;\n      Var : Typ;\n      procedure N_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  OK\n        end;\n      begin\n        N_Inner (Param);\n      end;\n    Var : aliased Integer := 666;\n    begin\n      if K (Var'Access) then null; end if; --  OK\n      if L (Var'Access) then null; end if; --  OK\n      M (Var'Access);                      --  OK\n      N (Var'Access);                      --  OK\n    end;\n\nbegin\n  begin\n    begin\n      declare\n      Var  : aliased Integer := 666;\n      T    : J;\n      Prot : E;\n      begin\n        if A (Var'Access) then null; end if;      --  OK\n        if B (Var'Access) then null; end if;      --  OK\n        C (Var'Access);                           --  OK\n        D (Var'Access);                           --  OK\n        if Prot.G (Var'Access) then null; end if; --  OK\n        Prot.I (Var'Access);                      --  OK\n      end;\n    end;\n  end;\nend;\n\n--  fail.adb\n\nprocedure Fail is\n  Failures : Integer := 0;\n\n  type Base_Typ is access all Integer;\n\n  function A (Param : access Integer) return Boolean is\n    subtype Typ is Base_Typ;\n    function A_Inner (Param : access Integer) return Typ is\n      begin\n        return Typ (Param); --  ERROR\n      end;\n    begin\n      return A_Inner (Param) = Typ (Param);\n    exception\n      when others => Failures := Failures + 1;\n      return False;\n    end;\n\n  function B (Param : access Integer) return Boolean;\n  function B (Param : access Integer) return Boolean is\n    subtype Typ is Base_Typ;\n    function B_Inner (Param : access Integer) return Typ is\n      begin\n        return Typ (Param); --  ERROR\n      end;\n    begin\n      return B_Inner (Param) = Typ (Param);\n    exception\n      when others => Failures := Failures + 1;\n      return False;\n    end;\n\n  procedure C (Param : access Integer) is\n    subtype Typ is Base_Typ;\n    Var : Typ;\n    procedure C_Inner (Param : access Integer) is\n      begin\n        Var := Typ (Param); --  ERROR\n      end;\n    begin\n      C_Inner (Param);\n    exception\n      when others => Failures := Failures + 1;\n    end;\n\n  procedure D (Param : access Integer);\n  procedure D (Param : access Integer) is\n    subtype Typ is Base_Typ;\n    Var : Typ;\n    procedure D_Inner (Param : access Integer) is\n      begin\n        Var := Typ (Param); --  ERROR\n      end;\n    begin\n      D_Inner (Param);\n    exception\n      when others => Failures := Failures + 1;\n    end;\n\n  protected type E is\n    function G (Param : access Integer) return Boolean;\n    procedure I (Param : access Integer);\n  end;\n\n  protected body E is\n    function F (Param : access Integer) return Boolean is\n      subtype Typ is Base_Typ;\n      function F_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  ERROR\n        end;\n      begin\n        return F_Inner (Param) = Typ (Param);\n      exception\n        when others => Failures := Failures + 1;\n        return False;\n      end;\n\n    function G (Param : access Integer) return Boolean is\n      subtype Typ is Base_Typ;\n      function G_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  ERROR\n        end;\n      B : Boolean := F (Param); --  ERROR\n      begin\n        return G_Inner (Param) = Typ (Param);\n      exception\n        when others => Failures := Failures + 1;\n        return False;\n      end;\n\n    procedure H (Param : access Integer) is\n      subtype Typ is Base_Typ;\n      Var : Typ;\n      procedure H_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  ERROR\n        end;\n      begin\n        H_Inner (Param);\n      exception\n        when others => Failures := Failures + 1;\n      end;\n\n    procedure I (Param : access Integer) is\n      subtype Typ is Base_Typ;\n      Var : Typ;\n      procedure I_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  ERROR\n        end;\n      begin\n        H (Param); --  ERROR\n        I_Inner (Param);\n      exception\n        when others => Failures := Failures + 1;\n      end;\n  end;\n\n  task type J is end;\n\n  task body J is\n    function K (Param : access Integer) return Boolean is\n      subtype Typ is Base_Typ;\n      function K_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  ERROR\n        end;\n      begin\n        return K_Inner (Param) = Typ (Param);\n      exception\n        when others => Failures := Failures + 1;\n        return False;\n      end;\n\n    function L (Param : access Integer) return Boolean;\n    function L (Param : access Integer) return Boolean is\n      subtype Typ is Base_Typ;\n      function L_Inner (Param : access Integer) return Typ is\n        begin\n          return Typ (Param); --  ERROR\n        end;\n      begin\n        return L_Inner (Param) = Typ (Param);\n      exception\n        when others => Failures := Failures + 1;\n        return False;\n      end;\n\n    procedure M (Param : access Integer) is\n      subtype Typ is Base_Typ;\n      Var : Typ;\n      procedure M_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  ERROR\n        end;\n      begin\n        M_Inner (Param);\n      exception\n        when others => Failures := Failures + 1;\n      end;\n\n    procedure N (Param : access Integer);\n    procedure N (Param : access Integer) is\n      subtype Typ is Base_Typ;\n      Var : Typ;\n      procedure N_Inner (Param : access Integer) is\n        begin\n          Var := Typ (Param); --  ERROR\n        end;\n      begin\n        N_Inner (Param);\n      exception\n        when others => Failures := Failures + 1;\n      end;\n    Var : aliased Integer := 666;\n    begin\n      if K (Var'Access) then null; end if; --  ERROR\n      if L (Var'Access) then null; end if; --  ERROR\n      M (Var'Access);                      --  ERROR\n      N (Var'Access);                      --  ERROR\n    end;\n\nbegin\n  begin\n    begin\n      declare\n      Var  : aliased Integer := 666;\n      T    : J;\n      Prot : E;\n      begin\n        if A (Var'Access) then null; end if;      --  ERROR\n        if B (Var'Access) then null; end if;      --  ERROR\n        C (Var'Access);                           --  ERROR\n        D (Var'Access);                           --  ERROR\n        if Prot.G (Var'Access) then null; end if; --  ERROR\n        Prot.I (Var'Access);                      --  ERROR\n        if Failures /= 12 then\n          raise Program_Error;\n        end if;\n      end;\n    end;\n  end;\nend;\n\n--  indirect_call_test.adb\n\nwith Text_IO;\n\nprocedure Indirect_Call_Test is\n\n   Tracing_Enabled : constant Boolean := False;\n   procedure Trace (S : String) is\n   begin\n      if Tracing_Enabled then\n        Text_IO.Put_Line (S);\n      end if;\n   end;\n\n   package Pkg is\n      type Root is abstract tagged null record;\n      function F (X : Root; Param : access Integer)\n        return Boolean is abstract;\n   end Pkg;\n\n   function F_Wrapper\n     (X : Pkg.Root; Param : access Integer)\n     return Boolean\n     is (Pkg.F (Pkg.Root'Class (X), Param));\n     -- dispatching call\n\n   function A (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n\n      package Nested is\n         type Ext is new Pkg.Root with null record;\n         overriding function F\n           (X : Ext; Param : access Integer)\n           return Boolean;\n      end Nested;\n\n      function A_Inner\n        (Param : access Integer) return Typ is\n      begin\n         return Typ (Param);  -- OK\n      end A_Inner;\n\n      package body Nested is\n         function F (X : Ext; Param : access Integer)\n          return Boolean is\n         begin\n            return A_Inner (Param) = null;\n         end;\n      end;\n\n       Ext_Obj : Nested.Ext;\n   begin\n       Trace (\"In subtest A\");\n       return F_Wrapper (Pkg.Root (Ext_Obj), Param);\n   exception\n      when Program_Error =>\n          Trace (\"Failed\");\n          return True;\n   end A;\n\n   function B (Param : access Integer) return Boolean is\n      type Typ is access all Integer;\n\n      function B_Inner\n        (Param : access Integer) return Typ is\n      begin\n         return Typ (Param); -- OK\n      end B_Inner;\n\n      type Ref is access function\n         (Param : access Integer) return Typ;\n      Ptr : Ref := B_Inner'Access;\n\n      function Ptr_Caller return Typ is\n        (Ptr.all (Param)); -- access-to-subp value\n   begin\n      Trace (\"In subtest B\");\n      return Ptr_Caller = null;\n   exception\n      when Program_Error =>\n          Trace (\"*** failed\");\n          return True;\n   end B;\n\nbegin\n   begin\n      begin\n         declare\n            Var : aliased Integer := 666;\n         begin\n            if A (Var'Access) then\n               null;\n            end if;\n            Trace (\"Subtest A done\");\n            if B (Var'Access) then\n               null;\n            end if;\n            Trace (\"Subtest B done\");\n         end;\n      end;\n   end;\nend Indirect_Call_Test;\n\nShould produce the following output:\n\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n  Failure\n\n2019-09-18  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* einfo.adb, einfo.ads (Minimum_Accessibility): Added new field.\n\t(Set_Minimum_Accessibility): Added to set new field.\n\t(Minimum_Accessibility): Added to fetch new field.\n\t* exp_ch6.adb (Expand_Subprogram_Call): Modify calls to fetch\n\taccessibility levels to the new subprogram Get_Accessibility\n\twhich handles cases where minimum accessibility might be needed.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Add section to\n\tgenerate a Minimum_Accessibility object within relevant\n\tsubprograms.\n\t* sem_util.adb, sem_util.ads (Dynamic_Accessibility_Level):\n\tAdditional documentation added and modify section to use new\n\tfunction Get_Accessibility.\n\t(Get_Accessibility): Added to centralize processing of\n\taccessibility levels.\n\nFrom-SVN: r275858", "tree": {"sha": "bf5040d78121224b3f819b3ec3708201aabd818a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf5040d78121224b3f819b3ec3708201aabd818a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43b264110f5581af0cc93308f9433fe8053f01cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b264110f5581af0cc93308f9433fe8053f01cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b264110f5581af0cc93308f9433fe8053f01cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b264110f5581af0cc93308f9433fe8053f01cc/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8324fe7b12851c16c867f16ce248c95d2dbae7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8324fe7b12851c16c867f16ce248c95d2dbae7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8324fe7b12851c16c867f16ce248c95d2dbae7d"}], "stats": {"total": 237, "additions": 216, "deletions": 21}, "files": [{"sha": "384f98205420d8d25ae45d97dbdb0bba3c9524d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -1,3 +1,20 @@\n+2019-09-18  Justin Squirek  <squirek@adacore.com>\n+\n+\t* einfo.adb, einfo.ads (Minimum_Accessibility): Added new field.\n+\t(Set_Minimum_Accessibility): Added to set new field.\n+\t(Minimum_Accessibility): Added to fetch new field.\n+\t* exp_ch6.adb (Expand_Subprogram_Call): Modify calls to fetch\n+\taccessibility levels to the new subprogram Get_Accessibility\n+\twhich handles cases where minimum accessibility might be needed.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Add section to\n+\tgenerate a Minimum_Accessibility object within relevant\n+\tsubprograms.\n+\t* sem_util.adb, sem_util.ads (Dynamic_Accessibility_Level):\n+\tAdditional documentation added and modify section to use new\n+\tfunction Get_Accessibility.\n+\t(Get_Accessibility): Added to centralize processing of\n+\taccessibility levels.\n+\n 2019-09-18  Steve Baird  <baird@adacore.com>\n \n \t* sem_util.ads (Interval_Lists): A new visible package. This"}, {"sha": "dcbeac5780ca5b0201c387eef4a97a9b33d17a52", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -215,6 +215,7 @@ package body Einfo is\n    --    Stored_Constraint               Elist23\n \n    --    Incomplete_Actuals              Elist24\n+   --    Minimum_Accessibility           Node24\n    --    Related_Expression              Node24\n    --    Subps_Index                     Uint24\n \n@@ -2847,6 +2848,12 @@ package body Einfo is\n       return UI_To_Int (Uint8 (Id));\n    end Mechanism;\n \n+   function Minimum_Accessibility (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) in Formal_Kind);\n+      return Node24 (Id);\n+   end Minimum_Accessibility;\n+\n    function Modulus (Id : E) return Uint is\n    begin\n       pragma Assert (Is_Modular_Integer_Type (Id));\n@@ -6076,6 +6083,12 @@ package body Einfo is\n       Set_Uint8 (Id, UI_From_Int (V));\n    end Set_Mechanism;\n \n+   procedure Set_Minimum_Accessibility (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) in Formal_Kind);\n+      Set_Node24 (Id, V);\n+   end Set_Minimum_Accessibility;\n+\n    procedure Set_Modulus (Id : E; V : U) is\n    begin\n       pragma Assert (Ekind (Id) = E_Modular_Integer_Type);\n@@ -10913,6 +10926,9 @@ package body Einfo is\n          =>\n             Write_Str (\"Related_Expression\");\n \n+         when Formal_Kind =>\n+            Write_Str (\"Minimum_Accessibility\");\n+\n          when E_Function\n             | E_Operator\n             | E_Procedure"}, {"sha": "3e968a29bd844326a451b0374a31f8b100594c0c", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -3516,6 +3516,14 @@ package Einfo is\n --       is also set (to the default value of zero = Default_Mechanism) in a\n --       subprogram body entity but not used in this context.\n \n+--    Minimum_Accessibility (Node24)\n+--       Defined in formal parameters in the non-generic case. Normally Empty,\n+--       but if expansion is active, and a parameter exists for which a\n+--       dynamic accessibility check is required, then an object is generated\n+--       within such a subprogram representing the accessibility level of the\n+--       subprogram or the formal's Extra_Accessibility - whichever one is\n+--       lesser. The Minimum_Accessibility field then points to this object.\n+\n --    Modulus (Uint17) [base type only]\n --       Defined in modular types. Contains the modulus. For the binary case,\n --       this will be a power of 2, but if Non_Binary_Modulus is set, then it\n@@ -6273,6 +6281,7 @@ package Einfo is\n    --    Default_Expr_Function               (Node21)\n    --    Protected_Formal                    (Node22)\n    --    Extra_Constrained                   (Node23)\n+   --    Minimum_Accessibility               (Node24)\n    --    Last_Assignment                     (Node26)   (OUT, IN-OUT only)\n    --    Activation_Record_Component         (Node31)\n    --    Has_Initial_Value                   (Flag219)\n@@ -7398,6 +7407,7 @@ package Einfo is\n    function Materialize_Entity                  (Id : E) return B;\n    function May_Inherit_Delayed_Rep_Aspects     (Id : E) return B;\n    function Mechanism                           (Id : E) return M;\n+   function Minimum_Accessibility               (Id : E) return E;\n    function Modulus                             (Id : E) return U;\n    function Must_Be_On_Byte_Boundary            (Id : E) return B;\n    function Must_Have_Preelab_Init              (Id : E) return B;\n@@ -8103,6 +8113,7 @@ package Einfo is\n    procedure Set_Materialize_Entity              (Id : E; V : B := True);\n    procedure Set_May_Inherit_Delayed_Rep_Aspects (Id : E; V : B := True);\n    procedure Set_Mechanism                       (Id : E; V : M);\n+   procedure Set_Minimum_Accessibility           (Id : E; V : E);\n    procedure Set_Modulus                         (Id : E; V : U);\n    procedure Set_Must_Be_On_Byte_Boundary        (Id : E; V : B := True);\n    procedure Set_Must_Have_Preelab_Init          (Id : E; V : B := True);\n@@ -8973,6 +8984,7 @@ package Einfo is\n    pragma Inline (Materialize_Entity);\n    pragma Inline (May_Inherit_Delayed_Rep_Aspects);\n    pragma Inline (Mechanism);\n+   pragma Inline (Minimum_Accessibility);\n    pragma Inline (Modulus);\n    pragma Inline (Must_Be_On_Byte_Boundary);\n    pragma Inline (Must_Have_Preelab_Init);\n@@ -9466,6 +9478,7 @@ package Einfo is\n    pragma Inline (Set_Materialize_Entity);\n    pragma Inline (Set_May_Inherit_Delayed_Rep_Aspects);\n    pragma Inline (Set_Mechanism);\n+   pragma Inline (Set_Minimum_Accessibility);\n    pragma Inline (Set_Modulus);\n    pragma Inline (Set_Must_Be_On_Byte_Boundary);\n    pragma Inline (Set_Must_Have_Preelab_Init);"}, {"sha": "78a1496d011c57a1c4a09608b17b6cc678e74811", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -3221,7 +3221,7 @@ package body Exp_Ch6 is\n \n          --  Create possible extra actual for accessibility level\n \n-         if Present (Extra_Accessibility (Formal)) then\n+         if Present (Get_Accessibility (Formal)) then\n \n             --  Ada 2005 (AI-252): If the actual was rewritten as an Access\n             --  attribute, then the original actual may be an aliased object\n@@ -3297,8 +3297,8 @@ package body Exp_Ch6 is\n \n                   Add_Extra_Actual\n                     (Expr =>\n-                       New_Occurrence_Of (Extra_Accessibility (Parm_Ent), Loc),\n-                     EF   => Extra_Accessibility (Formal));\n+                       New_Occurrence_Of (Get_Accessibility (Parm_Ent), Loc),\n+                     EF   => Get_Accessibility (Formal));\n                end;\n \n             elsif Is_Entity_Name (Prev_Orig) then\n@@ -3327,12 +3327,12 @@ package body Exp_Ch6 is\n                   begin\n                      pragma Assert (Present (Parm_Ent));\n \n-                     if Present (Extra_Accessibility (Parm_Ent)) then\n+                     if Present (Get_Accessibility (Parm_Ent)) then\n                         Add_Extra_Actual\n                           (Expr =>\n                              New_Occurrence_Of\n-                               (Extra_Accessibility (Parm_Ent), Loc),\n-                           EF   => Extra_Accessibility (Formal));\n+                               (Get_Accessibility (Parm_Ent), Loc),\n+                           EF   => Get_Accessibility (Formal));\n \n                      --  If the actual access parameter does not have an\n                      --  associated extra formal providing its scope level,\n@@ -3344,7 +3344,7 @@ package body Exp_Ch6 is\n                           (Expr =>\n                              Make_Integer_Literal (Loc,\n                                Intval => Scope_Depth (Standard_Standard)),\n-                           EF   => Extra_Accessibility (Formal));\n+                           EF   => Get_Accessibility (Formal));\n                      end if;\n                   end;\n \n@@ -3354,7 +3354,7 @@ package body Exp_Ch6 is\n                else\n                   Add_Extra_Actual\n                     (Expr => Dynamic_Accessibility_Level (Prev_Orig),\n-                     EF   => Extra_Accessibility (Formal));\n+                     EF   => Get_Accessibility (Formal));\n                end if;\n \n             --  If the actual is an access discriminant, then pass the level\n@@ -3370,7 +3370,7 @@ package body Exp_Ch6 is\n                  (Expr =>\n                     Make_Integer_Literal (Loc,\n                       Intval => Object_Access_Level (Prefix (Prev_Orig))),\n-                  EF   => Extra_Accessibility (Formal));\n+                  EF   => Get_Accessibility (Formal));\n \n             --  All other cases\n \n@@ -3440,27 +3440,27 @@ package body Exp_Ch6 is\n                                    Make_Integer_Literal (Loc,\n                                      Intval =>\n                                        Type_Access_Level (Pref_Entity)),\n-                                 EF   => Extra_Accessibility (Formal));\n+                                 EF   => Get_Accessibility (Formal));\n \n                            elsif Nkind (Prev_Orig) = N_Explicit_Dereference\n                              and then Present (Pref_Entity)\n                              and then Is_Formal (Pref_Entity)\n                              and then Present\n-                                        (Extra_Accessibility (Pref_Entity))\n+                                        (Get_Accessibility (Pref_Entity))\n                            then\n                               Add_Extra_Actual\n                                 (Expr =>\n                                    New_Occurrence_Of\n-                                     (Extra_Accessibility (Pref_Entity), Loc),\n-                                 EF   => Extra_Accessibility (Formal));\n+                                     (Get_Accessibility (Pref_Entity), Loc),\n+                                 EF   => Get_Accessibility (Formal));\n \n                            else\n                               Add_Extra_Actual\n                                 (Expr =>\n                                    Make_Integer_Literal (Loc,\n                                      Intval =>\n                                        Object_Access_Level (Prev_Orig)),\n-                                 EF   => Extra_Accessibility (Formal));\n+                                 EF   => Get_Accessibility (Formal));\n                            end if;\n \n                         --  Treat the unchecked attributes as library-level\n@@ -3472,7 +3472,7 @@ package body Exp_Ch6 is\n                              (Expr =>\n                                 Make_Integer_Literal (Loc,\n                                   Intval => Scope_Depth (Standard_Standard)),\n-                              EF   => Extra_Accessibility (Formal));\n+                              EF   => Get_Accessibility (Formal));\n \n                         --  No other cases of attributes returning access\n                         --  values that can be passed to access parameters.\n@@ -3494,7 +3494,7 @@ package body Exp_Ch6 is\n                        (Expr =>\n                           Make_Integer_Literal (Loc,\n                             Intval => Scope_Depth (Current_Scope) + 1),\n-                        EF   => Extra_Accessibility (Formal));\n+                        EF   => Get_Accessibility (Formal));\n \n                   --  For most other cases we simply pass the level of the\n                   --  actual's access type. The type is retrieved from\n@@ -3505,7 +3505,7 @@ package body Exp_Ch6 is\n                   when others =>\n                      Add_Extra_Actual\n                        (Expr => Dynamic_Accessibility_Level (Prev),\n-                        EF   => Extra_Accessibility (Formal));\n+                        EF   => Get_Accessibility (Formal));\n                end case;\n             end if;\n          end if;"}, {"sha": "eb6768d3ae2ce0e28dc5f714f83f01d8c769816f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -3376,6 +3376,9 @@ package body Sem_Ch6 is\n \n       --  Local variables\n \n+      Body_Nod         : Node_Id := Empty;\n+      Minimum_Acc_Objs : List_Id := No_List;\n+\n       Saved_GM   : constant Ghost_Mode_Type := Ghost_Mode;\n       Saved_IGR  : constant Node_Id         := Ignored_Ghost_Region;\n       Saved_EA   : constant Boolean         := Expander_Active;\n@@ -4254,6 +4257,110 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n+      --  Generate minimum accessibility local objects to correspond with\n+      --  any extra formal added for anonymous access types. This new local\n+      --  object can then be used instead of the formal in case it is used\n+      --  in an actual to a call to a nested subprogram.\n+\n+      --  This method is used to suppliment our \"small integer model\" for\n+      --  accessibility check generation (for more information see\n+      --  Dynamic_Accessibility_Level).\n+\n+      --  Because we allow accesibility values greater than our expected value\n+      --  passing along the same extra accessibility formal as an actual\n+      --  to a nested subprogram becomes a problem because high values mean\n+      --  different things to the callee even though they are the same to the\n+      --  caller. So, as described in the first section, we create a local\n+      --  object representing the minimum of the accessibility level value that\n+      --  is passed in and the accessibility level of the callee's parameter\n+      --  and locals and use it in the case of a call to a nested subprogram.\n+      --  This generated object is refered to as a \"minimum accessiblity\n+      --  level.\"\n+\n+      if Present (Spec_Id) or else Present (Body_Id) then\n+         Body_Nod := Unit_Declaration_Node (Body_Id);\n+\n+         declare\n+            Form : Entity_Id;\n+         begin\n+            --  Grab the appropriate formal depending on whether there exists\n+            --  an actual spec for the subprogram or whether we are dealing\n+            --  with a protected subprogram.\n+\n+            if Present (Spec_Id) then\n+               if Present (Protected_Body_Subprogram (Spec_Id)) then\n+                  Form := First_Formal (Protected_Body_Subprogram (Spec_Id));\n+               else\n+                  Form := First_Formal (Spec_Id);\n+               end if;\n+            else\n+               Form := First_Formal (Body_Id);\n+            end if;\n+\n+            --  Loop through formals if the subprogram is capable of accepting\n+            --  a generated local object. If it is not then it is also not\n+            --  capable of having local subprograms meaning it would not need\n+            --  a minimum accessibility level object anyway.\n+\n+            if Present (Body_Nod)\n+              and then Has_Declarations (Body_Nod)\n+              and then Nkind (Body_Nod) /= N_Package_Specification\n+            then\n+               while Present (Form) loop\n+\n+                  if Present (Extra_Accessibility (Form))\n+                    and then No (Minimum_Accessibility (Form))\n+                  then\n+                     --  Generate the minimum accessibility level object\n+\n+                     --    A60b : integer := integer'min(2, paramL);\n+\n+                     declare\n+                        Loc      : constant Source_Ptr := Sloc (Body_Nod);\n+                        Obj_Node : constant Node_Id :=\n+                           Make_Object_Declaration (Loc,\n+                            Defining_Identifier =>\n+                              Make_Temporary\n+                                (Loc, 'A', Extra_Accessibility (Form)),\n+                            Object_Definition   => New_Occurrence_Of\n+                                                     (Standard_Integer, Loc),\n+                            Expression          =>\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix         => New_Occurrence_Of\n+                                                    (Standard_Integer, Loc),\n+                                Attribute_Name => Name_Min,\n+                                Expressions    => New_List (\n+                                  Make_Integer_Literal (Loc,\n+                                    Object_Access_Level (Form)),\n+                                  New_Occurrence_Of\n+                                    (Extra_Accessibility (Form), Loc))));\n+                     begin\n+                        --  Add the new local object to the Minimum_Acc_Obj to\n+                        --  be later prepended to the subprogram's list of\n+                        --  declarations after we are sure all expansion is\n+                        --  done.\n+\n+                        if Present (Minimum_Acc_Objs) then\n+                           Prepend (Obj_Node, Minimum_Acc_Objs);\n+                        else\n+                           Minimum_Acc_Objs := New_List (Obj_Node);\n+                        end if;\n+\n+                        --  Register the object and analyze it\n+\n+                        Set_Minimum_Accessibility\n+                          (Form, Defining_Identifier (Obj_Node));\n+\n+                        Analyze (Obj_Node);\n+                     end;\n+                  end if;\n+\n+                  Next_Formal (Form);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Now we can go on to analyze the body\n \n       HSS := Handled_Statement_Sequence (N);\n@@ -4358,6 +4465,19 @@ package body Sem_Ch6 is\n       Inspect_Deferred_Constant_Completion (Declarations (N));\n       Analyze (HSS);\n \n+      --  Add the generated minimum accessibility objects to the subprogram\n+      --  body's list of declarations after analysis of the statements and\n+      --  contracts.\n+\n+      while Is_Non_Empty_List (Minimum_Acc_Objs) loop\n+         if Present (Declarations (Body_Nod)) then\n+            Prepend (Remove_Head (Minimum_Acc_Objs), Declarations (Body_Nod));\n+         else\n+            Set_Declarations\n+              (Body_Nod, New_List (Remove_Head (Minimum_Acc_Objs)));\n+         end if;\n+      end loop;\n+\n       --  Deal with end of scope processing for the body\n \n       Process_End_Label (HSS, 't', Current_Scope);"}, {"sha": "1bcda5fa172676893e6899e8bd9e7524d5ffa6fb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -6531,10 +6531,11 @@ package body Sem_Util is\n             return Dynamic_Accessibility_Level (Renamed_Object (E));\n          end if;\n \n-         if Is_Formal (E) or else Ekind_In (E, E_Variable, E_Constant) then\n-            if Present (Extra_Accessibility (E)) then\n-               return New_Occurrence_Of (Extra_Accessibility (E), Loc);\n-            end if;\n+         if (Is_Formal (E)\n+              or else Ekind_In (E, E_Variable, E_Constant))\n+           and then Present (Get_Accessibility (E))\n+         then\n+            return New_Occurrence_Of (Get_Accessibility (E), Loc);\n          end if;\n       end if;\n \n@@ -9212,6 +9213,30 @@ package body Sem_Util is\n       end if;\n    end Gather_Components;\n \n+   -----------------------\n+   -- Get_Accessibility --\n+   -----------------------\n+\n+   function Get_Accessibility (E : Entity_Id) return Node_Id is\n+   begin\n+      --  When minimum accessibility is set for E then we utilize it - except\n+      --  in a few edge cases like the expansion of select statements where\n+      --  generated subprogram may attempt to unnecessarily use a minimum\n+      --  accessibility object declared outside of scope.\n+\n+      --  To avoid these situations where expansion may get complex we verify\n+      --  that the minimum accessibility object is within scope.\n+\n+      if Ekind (E) in Formal_Kind\n+        and then Present (Minimum_Accessibility (E))\n+        and then In_Open_Scopes (Scope (Minimum_Accessibility (E)))\n+      then\n+         return Minimum_Accessibility (E);\n+      end if;\n+\n+      return Extra_Accessibility (E);\n+   end Get_Accessibility;\n+\n    ------------------------\n    -- Get_Actual_Subtype --\n    ------------------------"}, {"sha": "b41b8750fd25bcdcb4bcf48effc7a7d68bc3f2f9", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b264110f5581af0cc93308f9433fe8053f01cc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=43b264110f5581af0cc93308f9433fe8053f01cc", "patch": "@@ -983,6 +983,10 @@ package Sem_Util is\n    --  discriminants. Otherwise all components of the parent must be included\n    --  in the subtype for semantic analysis.\n \n+   function Get_Accessibility (E : Entity_Id) return Node_Id;\n+   --  Obtain the accessibility level for a given entity formal taking into\n+   --  account both extra and minimum accessibility.\n+\n    function Get_Actual_Subtype (N : Node_Id) return Entity_Id;\n    --  Given a node for an expression, obtain the actual subtype of the\n    --  expression. In the case of a parameter where the formal is an"}]}