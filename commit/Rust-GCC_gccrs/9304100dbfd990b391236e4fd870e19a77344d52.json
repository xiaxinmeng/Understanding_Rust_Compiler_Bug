{"sha": "9304100dbfd990b391236e4fd870e19a77344d52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMwNDEwMGRiZmQ5OTBiMzkxMjM2ZTRmZDg3MGUxOWE3NzM0NGQ1Mg==", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "rafael.espindola@gmail.com", "date": "2005-09-23T14:45:21Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-09-23T14:45:21Z"}, "message": "parse.y: Changed pointer declaration from \"type* var\" to \"type *var\" Removed trailing space.\n\n2005-09-23  Rafael \ufffd\ufffdvila de Esp\ufffd\ufffdndola  <rafael.espindola@gmail.com>\n\n        * parse.y : Changed pointer declaration from \"type* var\" to \"type *var\"\n        Removed trailing space.  Wrap long lines.\n\n2005-09-23  Rafael \ufffd\ufffdvila de Esp\ufffd\ufffdndola  <rafael.espindola@gmail.com>\n\n        * parse.y :  Fixed two compile warnings in \"error\" and \"warning\"\n        invocations.  Removed trailing periods in messages.  Decapitalized the\n        first word of each.\n\nFrom-SVN: r104569", "tree": {"sha": "0e46b6dcf5a261d368604577f4140439da0e388d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e46b6dcf5a261d368604577f4140439da0e388d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9304100dbfd990b391236e4fd870e19a77344d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9304100dbfd990b391236e4fd870e19a77344d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9304100dbfd990b391236e4fd870e19a77344d52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9304100dbfd990b391236e4fd870e19a77344d52/comments", "author": {"login": "espindola", "id": 42633, "node_id": "MDQ6VXNlcjQyNjMz", "avatar_url": "https://avatars.githubusercontent.com/u/42633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/espindola", "html_url": "https://github.com/espindola", "followers_url": "https://api.github.com/users/espindola/followers", "following_url": "https://api.github.com/users/espindola/following{/other_user}", "gists_url": "https://api.github.com/users/espindola/gists{/gist_id}", "starred_url": "https://api.github.com/users/espindola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/espindola/subscriptions", "organizations_url": "https://api.github.com/users/espindola/orgs", "repos_url": "https://api.github.com/users/espindola/repos", "events_url": "https://api.github.com/users/espindola/events{/privacy}", "received_events_url": "https://api.github.com/users/espindola/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c6fdb4671edffacf155232f55f38cc0e47b2e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c6fdb4671edffacf155232f55f38cc0e47b2e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c6fdb4671edffacf155232f55f38cc0e47b2e95"}], "stats": {"total": 176, "additions": 94, "deletions": 82}, "files": [{"sha": "4505683807451340a93742c1bb71cdbf5dca9f05", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9304100dbfd990b391236e4fd870e19a77344d52/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9304100dbfd990b391236e4fd870e19a77344d52/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=9304100dbfd990b391236e4fd870e19a77344d52", "patch": "@@ -1,3 +1,14 @@\n+2005-09-23  Rafael \u00c1vila de Esp\u00edndola  <rafael.espindola@gmail.com>\n+\n+\t* parse.y : Changed pointer declaration from \"type* var\" to \"type *var\"\n+\tRemoved trailing space.  Wrap long lines.\n+\n+2005-09-23  Rafael \u00c1vila de Esp\u00edndola  <rafael.espindola@gmail.com>\n+\n+\t* parse.y :  Fixed two compile warnings in \"error\" and \"warning\"\n+\tinvocations.  Removed trailing periods in messages.  Decapitalized the\n+\tfirst word of each.\n+\n 2005-08-07  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* tree-convert.c (convert): Use fold_build1 instead of"}, {"sha": "740237c8b98d83995b412c94606fc39ae452c8b2", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 83, "deletions": 82, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9304100dbfd990b391236e4fd870e19a77344d52/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9304100dbfd990b391236e4fd870e19a77344d52/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=9304100dbfd990b391236e4fd870e19a77344d52", "patch": "@@ -1,5 +1,5 @@\n /* -*- c -*- emacs mode c */\n-/* TREELANG Compiler parser.  \n+/* TREELANG Compiler parser.\n \n ---------------------------------------------------------------------\n \n@@ -23,7 +23,7 @@ Boston, MA 02110-1301, USA.\n \n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n-what you give them.   Help stamp out software-hoarding!  \n+what you give them.   Help stamp out software-hoarding!\n \n ---------------------------------------------------------------------\n \n@@ -34,7 +34,7 @@ the GCC compiler.  */\n    *****************\n    There are no conflicts in this grammar.  Please keep it that way.  */\n \n-%{ \n+%{\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -47,15 +47,15 @@ the GCC compiler.  */\n #include \"toplev.h\"\n \n #define YYDEBUG 1\n-#define YYPRINT(file, type, value) print_token (file, type, value) \n+#define YYPRINT(file, type, value) print_token (file, type, value)\n #define YYERROR_VERBOSE YES\n \n   /* My yylex routine used to intercept calls to flex generated code, to\n      record lex time.  */\n   int yylex (void);\n   static inline int my_yylex (void);\n \n-  /* Call lex, but ensure time is charged to TV_LEX.  */ \n+  /* Call lex, but ensure time is charged to TV_LEX.  */\n   static inline int\n     my_yylex (void)\n     {\n@@ -72,20 +72,20 @@ the GCC compiler.  */\n   /* Local prototypes.  */\n   static void yyerror (const char *error_message);\n   int yyparse (void);\n-  void print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED,\n+  void print_token (FILE *file, unsigned int type ATTRIBUTE_UNUSED,\n \t\t    YYSTYPE value);\n   static struct prod_token_parm_item *reverse_prod_list\n     (struct prod_token_parm_item *old_first);\n   static void ensure_not_void (unsigned int type,\n-\t\t\t       struct prod_token_parm_item* name);\n+\t\t\t       struct prod_token_parm_item *name);\n   static int check_type_match (int type_num, struct prod_token_parm_item *exp);\n   static int get_common_type (struct prod_token_parm_item *type1,\n \t\t\t      struct prod_token_parm_item *type2);\n   static struct prod_token_parm_item *make_integer_constant\n-    (struct prod_token_parm_item* value);\n+    (struct prod_token_parm_item *value);\n   static struct prod_token_parm_item *make_plus_expression\n-    (struct prod_token_parm_item* tok, struct prod_token_parm_item* op1,\n-     struct prod_token_parm_item* op2, int type_code, int prod_code);\n+    (struct prod_token_parm_item *tok, struct prod_token_parm_item *op1,\n+     struct prod_token_parm_item *op2, int type_code, int prod_code);\n   static void set_storage (struct prod_token_parm_item *prod);\n \n   /* File global variables.  */\n@@ -143,8 +143,8 @@ the GCC compiler.  */\n %token PROD_VARIABLE_REFERENCE_EXPRESSION\n %token PROD_PARAMETER\n %token PROD_FUNCTION_INVOCATION\n-%expect 0 \n-%% \n+%expect 0\n+%%\n \n file:\n /* Nil.  */ {\n@@ -179,15 +179,15 @@ variable_def {\n \n variable_def:\n storage typename NAME init_opt SEMICOLON {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $3;\n   prod = make_production (PROD_VARIABLE_NAME, tok);\n   SYMBOL_TABLE_NAME (prod) = tok;\n   EXPRESSION_TYPE (prod) = $2;\n   VAR_INIT (prod) = $4;\n-  NUMERIC_TYPE (prod) = \n-    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) =\n+    NUMERIC_TYPE (( (struct prod_token_parm_item *)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -198,10 +198,11 @@ storage typename NAME init_opt SEMICOLON {\n \n   if (VAR_INIT (prod))\n     {\n-      gcc_assert (((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code);\n+      gcc_assert (((struct prod_token_parm_item *)\n+\t\t   VAR_INIT (prod))->tp.pro.code);\n       if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n \t{\n-\t  error(\"%HExternal reference variable %q.*s has an initial value.\",\n+\t  error(\"%Hexternal reference variable %q.*s has an initial value\",\n \t\t&tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n \t  YYERROR;\n \t  VAR_INIT (prod) = NULL;\n@@ -210,12 +211,12 @@ storage typename NAME init_opt SEMICOLON {\n     }\n \n   prod->tp.pro.code = tree_code_create_variable\n-    (STORAGE_CLASS (prod), \n-     ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.chars,\n-     ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.length,\n+    (STORAGE_CLASS (prod),\n+     ((struct prod_token_parm_item *)SYMBOL_TABLE_NAME (prod))->tp.tok.chars,\n+     ((struct prod_token_parm_item *)SYMBOL_TABLE_NAME (prod))->tp.tok.length,\n      NUMERIC_TYPE (prod),\n      VAR_INIT (prod) ?\n-     ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code : NULL,\n+     ((struct prod_token_parm_item *)VAR_INIT (prod))->tp.pro.code : NULL,\n      tok->tp.tok.location);\n   gcc_assert (prod->tp.pro.code);\n }\n@@ -230,15 +231,15 @@ STATIC\n \n parameter:\n typename NAME {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   struct prod_token_parm_item *prod2;\n   tok = $2;\n   prod = make_production (PROD_VARIABLE_NAME, tok);\n   SYMBOL_TABLE_NAME (prod) = $2;\n   EXPRESSION_TYPE (prod) = $1;\n   NUMERIC_TYPE (prod) =\n-    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n+    NUMERIC_TYPE (( (struct prod_token_parm_item *)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -252,33 +253,33 @@ typename NAME {\n \n function_prototype:\n storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLON {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   struct prod_token_parm_item *type;\n-  struct prod_token_parm_item* first_parms;\n-  struct prod_token_parm_item* last_parms;\n-  struct prod_token_parm_item* this_parms;\n+  struct prod_token_parm_item *first_parms;\n+  struct prod_token_parm_item *last_parms;\n+  struct prod_token_parm_item *this_parms;\n   struct prod_token_parm_item *this_parm;\n   struct prod_token_parm_item *this_parm_var;\n   tok = $3;\n   prod = make_production (PROD_FUNCTION_NAME, $3);\n   SYMBOL_TABLE_NAME (prod) = $3;\n   EXPRESSION_TYPE (prod) = $2;\n   NUMERIC_TYPE (prod) =\n-    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n-  PARAMETERS (prod) = reverse_prod_list ($5); \n+    NUMERIC_TYPE (( (struct prod_token_parm_item *)EXPRESSION_TYPE (prod)));\n+  PARAMETERS (prod) = reverse_prod_list ($5);\n   insert_tree_name (prod);\n   STORAGE_CLASS_TOKEN (prod) = $1;\n   set_storage (prod);\n   switch (STORAGE_CLASS (prod))\n-    { \n+    {\n     case STATIC_STORAGE:\n     case EXTERNAL_DEFINITION_STORAGE:\n     case EXTERNAL_REFERENCE_STORAGE:\n       break;\n-      \n+\n     case AUTOMATIC_STORAGE:\n-      error (\"%HFunction %q.*s cannot be automatic.\",\n+      error (\"%Hfunction %q.*s cannot be automatic\",\n \t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n       break;\n@@ -304,8 +305,8 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n       this_parms->tp.par.variable_name =\n \tthis_parm_var->tp.pro.main_token->tp.tok.chars;\n       this_parms->category = parameter_category;\n-      this_parms->type = NUMERIC_TYPE \n-        (( (struct prod_token_parm_item*)EXPRESSION_TYPE (this_parm_var)));\n+      this_parms->type = NUMERIC_TYPE\n+        (( (struct prod_token_parm_item *)EXPRESSION_TYPE (this_parm_var)));\n       if (last_parms)\n         {\n           last_parms->tp.par.next = this_parms;\n@@ -316,8 +317,8 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n           first_parms = this_parms;\n           last_parms = this_parms;\n         }\n-      this_parms->tp.par.where_to_put_var_tree = \n-        & (( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code);\n+      this_parms->tp.par.where_to_put_var_tree =\n+        & (((struct prod_token_parm_item *)VARIABLE (this_parm))->tp.pro.code);\n     }\n   FIRST_PARMS (prod) = first_parms;\n \n@@ -333,8 +334,9 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n        this_parm;\n        this_parm = this_parm->tp.pro.next)\n     {\n-      gcc_assert ((struct prod_token_parm_item*)VARIABLE (this_parm));\n-      gcc_assert (((struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code);\n+      gcc_assert ((struct prod_token_parm_item *)VARIABLE (this_parm));\n+      gcc_assert (((struct prod_token_parm_item *)\n+\t\t   VARIABLE (this_parm))->tp.pro.code);\n     }\n #endif\n }\n@@ -344,14 +346,14 @@ function:\n NAME LEFT_BRACE {\n   struct prod_token_parm_item *proto;\n   struct prod_token_parm_item search_prod;\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   tok = $1;\n   SYMBOL_TABLE_NAME ((&search_prod)) = tok;\n   search_prod.category = token_category;\n   current_function = proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      error (\"%HNo prototype found for %q.*s\", &tok->tp.tok.location,\n+      error (\"%Hno prototype found for %q.*s\", &tok->tp.tok.location,\n \t     tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n@@ -362,7 +364,7 @@ NAME LEFT_BRACE {\n }\n \n variable_defs_opt statements_opt RIGHT_BRACE {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   tok = $1;\n   tree_code_create_function_wrapup (tok->tp.tok.location);\n   current_function = NULL;\n@@ -398,7 +400,7 @@ variable_def {\n \n typename:\n INT {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n@@ -407,7 +409,7 @@ INT {\n   $$ = prod;\n }\n |UNSIGNED INT {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n@@ -416,7 +418,7 @@ INT {\n   $$ = prod;\n }\n |CHAR {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n@@ -425,7 +427,7 @@ INT {\n   $$ = prod;\n }\n |UNSIGNED CHAR {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n@@ -434,7 +436,7 @@ INT {\n   $$ = prod;\n }\n |VOID {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n@@ -492,7 +494,7 @@ expression SEMICOLON {\n \n if_statement:\n IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *exp;\n   tok = $1;\n   exp = $3;\n@@ -503,12 +505,12 @@ LEFT_BRACE variable_defs_opt statements_opt RIGHT_BRACE {\n   /* Just let the statements flow.  */\n }\n ELSE {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   tok = $1;\n   tree_code_if_else (tok->tp.tok.location);\n }\n LEFT_BRACE variable_defs_opt statements_opt RIGHT_BRACE {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   tok = $1;\n   tree_code_if_end (tok->tp.tok.location);\n }\n@@ -527,14 +529,13 @@ tl_RETURN expression_opt {\n       tree_code_generate_return (type_prod->tp.pro.code, NULL);\n     else\n       {\n-\twarning (0, \"%HRedundant expression in return.\",\n-\t\t &ret_tok->tp.tok.location, ret_tok->tp.tok.length,\n-\t\t ret_tok->tp.tok.chars);\n+\twarning (0, \"%Hredundant expression in return\",\n+\t\t &ret_tok->tp.tok.location);\n         tree_code_generate_return (type_prod->tp.pro.code, NULL);\n        }\n   else\n     if (exp == NULL)\n-\terror (\"%HExpression missing in return.\", &ret_tok->tp.tok.location);\n+\terror (\"%Hexpression missing in return\", &ret_tok->tp.tok.location);\n     else\n       {\n         /* Check same type.  */\n@@ -559,7 +560,7 @@ expression_opt:\n   struct prod_token_parm_item *exp;\n   exp = $1;\n   gcc_assert (exp->tp.pro.code);\n-  \n+\n   $$ = $1;\n }\n ;\n@@ -617,7 +618,7 @@ INTEGER {\n function_invocation:\n NAME LEFT_PARENTHESIS expressions_with_commas_opt RIGHT_PARENTHESIS {\n   struct prod_token_parm_item *prod;\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item search_prod;\n   struct prod_token_parm_item *proto;\n   struct prod_token_parm_item *exp;\n@@ -627,7 +628,7 @@ NAME LEFT_PARENTHESIS expressions_with_commas_opt RIGHT_PARENTHESIS {\n   int exp_count;\n   tree parms;\n   tree type;\n-  \n+\n   tok = $1;\n   prod = make_production (PROD_FUNCTION_INVOCATION, tok);\n   SYMBOL_TABLE_NAME (prod) = tok;\n@@ -637,14 +638,14 @@ NAME LEFT_PARENTHESIS expressions_with_commas_opt RIGHT_PARENTHESIS {\n   proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      error (\"%HFunction prototype not found for %q.*%s.\",\n+      error (\"%Hfunction prototype not found for %q.*s\",\n \t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n   EXPRESSION_TYPE (prod) = EXPRESSION_TYPE (proto);\n   NUMERIC_TYPE (prod) = NUMERIC_TYPE (proto);\n   /* Count the expressions and ensure they match the prototype.  */\n-  for (exp_proto_count = 0, exp_proto = PARAMETERS (proto); \n+  for (exp_proto_count = 0, exp_proto = PARAMETERS (proto);\n        exp_proto; exp_proto = exp_proto->tp.pro.next)\n     exp_proto_count++;\n \n@@ -653,7 +654,7 @@ NAME LEFT_PARENTHESIS expressions_with_commas_opt RIGHT_PARENTHESIS {\n \n   if (exp_count !=  exp_proto_count)\n     {\n-      error (\"%HExpression count mismatch %q.*s with prototype.\",\n+      error (\"%Hexpression count mismatch %q.*s with prototype\",\n \t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n@@ -683,7 +684,7 @@ NAME LEFT_PARENTHESIS expressions_with_commas_opt RIGHT_PARENTHESIS {\n }\n ;\n \n-expressions_with_commas_opt: \n+expressions_with_commas_opt:\n /* Nil.  */ {\n $$ = 0\n }\n@@ -711,7 +712,7 @@ NAME {\n   struct prod_token_parm_item search_prod;\n   struct prod_token_parm_item *prod;\n   struct prod_token_parm_item *symbol_table_entry;\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   tree type;\n \n   tok = $1;\n@@ -720,7 +721,7 @@ NAME {\n   symbol_table_entry = lookup_tree_name (&search_prod);\n   if (!symbol_table_entry)\n     {\n-      error (\"%HVariable %q.*s not defined.\",\n+      error (\"%Hvariable %q.*s not defined\",\n \t     &tok->tp.tok.location, tok->tp.tok.length, tok->tp.tok.chars);\n       YYERROR;\n     }\n@@ -731,7 +732,7 @@ NAME {\n   if (!NUMERIC_TYPE (prod))\n     YYERROR;\n   OP1 (prod) = $1;\n-  \n+\n   prod->tp.pro.code =\n     tree_code_get_expression (EXP_REFERENCE, type,\n \t\t\t      symbol_table_entry->tp.pro.code, NULL, NULL,\n@@ -767,7 +768,7 @@ INTEGER {\n    type. */\n \n void\n-print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value) \n+print_token (FILE *file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value)\n {\n   struct prod_token_parm_item *tok;\n   unsigned int  ix;\n@@ -802,18 +803,18 @@ reverse_prod_list (struct prod_token_parm_item *old_first)\n   struct prod_token_parm_item *current;\n   struct prod_token_parm_item *next;\n   struct prod_token_parm_item *prev = NULL;\n-  \n+\n   current = old_first;\n   prev = NULL;\n \n-  while (current) \n+  while (current)\n     {\n       gcc_assert (current->category == production_category);\n \n       next = current->tp.pro.next;\n       current->tp.pro.next = prev;\n       prev = current;\n-      current = next; \n+      current = next;\n     }\n   return prev;\n }\n@@ -824,14 +825,14 @@ static void\n ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n {\n   if (type == VOID_TYPE)\n-    error (\"%HType must not be void in this context.\",\n+    error (\"%Htype must not be void in this context\",\n \t   &name->tp.tok.location);\n }\n \n /* Check TYPE1 and TYPE2 which are integral types.  Return the lowest\n    common type (min is signed int).  */\n \n-static int \n+static int\n get_common_type (struct prod_token_parm_item *type1,\n \t\t struct prod_token_parm_item *type2)\n {\n@@ -847,7 +848,7 @@ get_common_type (struct prod_token_parm_item *type1,\n    OK else 0.  Must be exact match - same name unless it is an\n    integral type.  */\n \n-static int \n+static int\n check_type_match (int type_num, struct prod_token_parm_item *exp)\n {\n   switch (type_num)\n@@ -863,17 +864,17 @@ check_type_match (int type_num, struct prod_token_parm_item *exp)\n         case SIGNED_CHAR:\n         case UNSIGNED_CHAR:\n           return 1;\n-          \n+\n         case VOID_TYPE:\n-        default: \n+        default:\n           gcc_unreachable ();\n         }\n       break;\n-      \n+\n     case VOID_TYPE:\n     default:\n       gcc_unreachable ();\n-      \n+\n     }\n }\n \n@@ -882,7 +883,7 @@ check_type_match (int type_num, struct prod_token_parm_item *exp)\n static struct prod_token_parm_item *\n make_integer_constant (struct prod_token_parm_item* value)\n {\n-  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *tok;\n   struct prod_token_parm_item *prod;\n   tok = value;\n   prod = make_production (PROD_INTEGER_CONSTANT, tok);\n@@ -901,9 +902,9 @@ make_integer_constant (struct prod_token_parm_item* value)\n    and EQUALS expressions.  */\n \n static struct prod_token_parm_item *\n-make_plus_expression (struct prod_token_parm_item* tok,\n-\t\t      struct prod_token_parm_item* op1,\n-\t\t      struct prod_token_parm_item* op2,\n+make_plus_expression (struct prod_token_parm_item *tok,\n+\t\t      struct prod_token_parm_item *op1,\n+\t\t      struct prod_token_parm_item *op2,\n \t\t      int type_code, int prod_code)\n {\n   struct prod_token_parm_item *prod;\n@@ -921,7 +922,7 @@ make_plus_expression (struct prod_token_parm_item* tok,\n \n   OP1 (prod) = op1;\n   OP2 (prod) = op2;\n-      \n+\n   prod->tp.pro.code = tree_code_get_expression (prod_code, type,\n \t\t\t\t\t\top1->tp.pro.code,\n \t\t\t\t\t\top2->tp.pro.code, NULL,\n@@ -936,18 +937,18 @@ make_plus_expression (struct prod_token_parm_item* tok,\n static void\n set_storage (struct prod_token_parm_item *prod)\n {\n-  struct prod_token_parm_item* stg_class;\n+  struct prod_token_parm_item *stg_class;\n   stg_class = STORAGE_CLASS_TOKEN (prod);\n   switch (stg_class->type)\n     {\n     case STATIC:\n       STORAGE_CLASS (prod) = STATIC_STORAGE;\n       break;\n-      \n+\n     case AUTOMATIC:\n       STORAGE_CLASS (prod) = AUTOMATIC_STORAGE;\n       break;\n-      \n+\n     case EXTERNAL_DEFINITION:\n       STORAGE_CLASS (prod) = EXTERNAL_DEFINITION_STORAGE;\n       break;"}]}