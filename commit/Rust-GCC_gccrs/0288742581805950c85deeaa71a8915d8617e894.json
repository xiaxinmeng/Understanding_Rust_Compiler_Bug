{"sha": "0288742581805950c85deeaa71a8915d8617e894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4ODc0MjU4MTgwNTk1MGM4NWRlZWFhNzFhODkxNWQ4NjE3ZTg5NA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-11-09T15:47:48Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-11-09T15:47:48Z"}, "message": "s390.c (s390_canonicalize_comparison): Reverse condition when eliminating an UNSPEC_CMPINT.\n\n\t* config/s390/s390.c (s390_canonicalize_comparison): Reverse condition\n\twhen eliminating an UNSPEC_CMPINT.\n\t(s390_secondary_input_reload_class): Fix test for CC register reload.\n\t(s390_secondary_output_reload_class): Likewise.\n\t(s390_expand_cmpmem): Swap operands.  Use gen_cmpint.\n\t* config/s390/s390.md (\"*cmpint_si\", \"*cmpint_di\"): Remove.\n\t(\"cmpint\", \"*cmpint_cc\", \"*cmpint_sign\", \"*cmpint_sign_cc\"): New\n\tinsn patterns with splitters.\n\nFrom-SVN: r90346", "tree": {"sha": "3462315bc1cb2785c1537fafcdb1081f6a6be655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3462315bc1cb2785c1537fafcdb1081f6a6be655"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0288742581805950c85deeaa71a8915d8617e894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0288742581805950c85deeaa71a8915d8617e894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0288742581805950c85deeaa71a8915d8617e894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0288742581805950c85deeaa71a8915d8617e894/comments", "author": null, "committer": null, "parents": [{"sha": "c0600ecd541e2e57c72bb7e478b0eb72fe5a1a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0600ecd541e2e57c72bb7e478b0eb72fe5a1a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0600ecd541e2e57c72bb7e478b0eb72fe5a1a27"}], "stats": {"total": 118, "additions": 88, "deletions": 30}, "files": [{"sha": "c5737d5f79275f4e76c9b9854ee118db9e7a7190", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0288742581805950c85deeaa71a8915d8617e894/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0288742581805950c85deeaa71a8915d8617e894/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0288742581805950c85deeaa71a8915d8617e894", "patch": "@@ -1,3 +1,14 @@\n+2004-11-09  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_canonicalize_comparison): Reverse condition\n+\twhen eliminating an UNSPEC_CMPINT.\n+\t(s390_secondary_input_reload_class): Fix test for CC register reload.\n+\t(s390_secondary_output_reload_class): Likewise.\n+\t(s390_expand_cmpmem): Swap operands.  Use gen_cmpint. \n+\t* config/s390/s390.md (\"*cmpint_si\", \"*cmpint_di\"): Remove.\n+\t(\"cmpint\", \"*cmpint_cc\", \"*cmpint_sign\", \"*cmpint_sign_cc\"): New\n+\tinsn patterns with splitters.\n+\n 2004-11-09  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_rtx_costs): Add EQ, GTU, and LTU."}, {"sha": "16018c6643765e215416d09a5a0f173392935021", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0288742581805950c85deeaa71a8915d8617e894/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0288742581805950c85deeaa71a8915d8617e894/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0288742581805950c85deeaa71a8915d8617e894", "patch": "@@ -624,10 +624,10 @@ s390_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1)\n \t{\n \t  case EQ: new_code = EQ;  break;\n \t  case NE: new_code = NE;  break;\n-\t  case LT: new_code = LTU; break;\n-\t  case GT: new_code = GTU; break;\n-\t  case LE: new_code = LEU; break;\n-\t  case GE: new_code = GEU; break;\n+\t  case LT: new_code = GTU; break;\n+\t  case GT: new_code = LTU; break;\n+\t  case LE: new_code = GEU; break;\n+\t  case GE: new_code = LEU; break;\n \t  default: break;\n \t}\n \n@@ -2291,13 +2291,13 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n    is not a legitimate operand of the LOAD ADDRESS instruction.  */\n \n enum reg_class\n-s390_secondary_input_reload_class (enum reg_class class ATTRIBUTE_UNUSED,\n+s390_secondary_input_reload_class (enum reg_class class,\n \t\t\t\t   enum machine_mode mode, rtx in)\n {\n   if (s390_plus_operand (in, mode))\n     return ADDR_REGS;\n \n-  if (GET_MODE_CLASS (mode) == MODE_CC)\n+  if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n   return NO_REGS;\n@@ -2321,7 +2321,7 @@ s390_secondary_output_reload_class (enum reg_class class,\n       && !s_operand (out, VOIDmode))\n     return ADDR_REGS;\n \n-  if (GET_MODE_CLASS (mode) == MODE_CC)\n+  if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n   return NO_REGS;\n@@ -3593,22 +3593,26 @@ void\n s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n {\n   rtx ccreg = gen_rtx_REG (CCUmode, CC_REGNUM);\n-  rtx result = gen_rtx_UNSPEC (SImode, gen_rtvec (1, ccreg), UNSPEC_CMPINT);\n+  rtx tmp;\n+\n+  /* As the result of CMPINT is inverted compared to what we need,\n+     we have to swap the operands.  */\n+  tmp = op0; op0 = op1; op1 = tmp;\n \n   if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n     {\n       if (INTVAL (len) > 0)\n         {\n           emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (INTVAL (len) - 1)));\n-          emit_move_insn (target, result);\n+          emit_insn (gen_cmpint (target, ccreg));\n         }\n       else\n         emit_move_insn (target, const0_rtx);\n     }\n   else if (TARGET_MVCLE)\n     {\n       emit_insn (gen_cmpmem_long (op0, op1, convert_to_mode (Pmode, len, 1)));\n-      emit_move_insn (target, result);\n+      emit_insn (gen_cmpint (target, ccreg));\n     }\n   else\n     {\n@@ -3675,7 +3679,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n \n-      emit_move_insn (target, result);\n+      emit_insn (gen_cmpint (target, ccreg));\n     }\n }\n "}, {"sha": "3f3f28ac015398f365d4e6763de15687ba53e343", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0288742581805950c85deeaa71a8915d8617e894/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0288742581805950c85deeaa71a8915d8617e894/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=0288742581805950c85deeaa71a8915d8617e894", "patch": "@@ -2276,33 +2276,76 @@\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vs\")])\n \n-; Convert condition code to integer in range (-1, 0, 1)\n+; Convert CCUmode condition code to integer.\n+; Result is zero if EQ, positive if LTU, negative if GTU.\n \n-(define_insn \"*cmpint_si\"\n+(define_insn_and_split \"cmpint\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(reg:CCU 33)] UNSPEC_CMPINT))]\n+        (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n+                   UNSPEC_CMPINT))\n+   (clobber (reg:CC 33))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 0) (const_int 2)))\n+   (parallel\n+    [(set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 30)))\n+     (clobber (reg:CC 33))])])\n+\n+(define_insn_and_split \"*cmpint_cc\"\n+  [(set (reg 33)\n+        (compare (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n+                            UNSPEC_CMPINT)\n+                 (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (unspec:SI [(match_dup 1)] UNSPEC_CMPINT))]\n+  \"s390_match_ccmode (insn, CCSmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 0) (const_int 2)))\n+   (parallel\n+    [(set (match_dup 2) (match_dup 3))\n+     (set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 30)))])]\n {\n-   output_asm_insn (\"lhi\\t%0,1\", operands);\n-   output_asm_insn (\"jh\\t.+12\", operands);\n-   output_asm_insn (\"jl\\t.+6\", operands);\n-   output_asm_insn (\"sr\\t%0,%0\", operands);\n-   return \"lcr\\t%0,%0\";\n-}\n-  [(set_attr \"length\" \"16\")])\n+  rtx result = gen_rtx_ASHIFTRT (SImode, operands[0], GEN_INT (30));\n+  operands[2] = SET_DEST (XVECEXP (PATTERN (curr_insn), 0, 0));\n+  operands[3] = gen_rtx_COMPARE (GET_MODE (operands[2]), result, const0_rtx);\n+})\n \n-(define_insn \"*cmpint_di\"\n+(define_insn_and_split \"*cmpint_sign\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (unspec:SI [(reg:CCU 33)] UNSPEC_CMPINT)))]\n+        (sign_extend:DI (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n+                                   UNSPEC_CMPINT)))\n+   (clobber (reg:CC 33))]\n   \"TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (ashift:DI (match_dup 0) (const_int 34)))\n+   (parallel\n+    [(set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 62)))\n+     (clobber (reg:CC 33))])])\n+\n+(define_insn_and_split \"*cmpint_sign_cc\"\n+  [(set (reg 33)\n+        (compare (ashiftrt:DI (ashift:DI (subreg:DI \n+                   (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n+                              UNSPEC_CMPINT) 0)\n+                   (const_int 32)) (const_int 32))\n+                 (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (sign_extend:DI (unspec:SI [(match_dup 1)] UNSPEC_CMPINT)))]\n+  \"s390_match_ccmode (insn, CCSmode) && TARGET_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (ashift:DI (match_dup 0) (const_int 34)))\n+   (parallel\n+    [(set (match_dup 2) (match_dup 3))\n+     (set (match_dup 0) (ashiftrt:DI (match_dup 0) (const_int 62)))])]\n {\n-   output_asm_insn (\"lghi\\t%0,1\", operands);\n-   output_asm_insn (\"jh\\t.+16\", operands);\n-   output_asm_insn (\"jl\\t.+8\", operands);\n-   output_asm_insn (\"sgr\\t%0,%0\", operands);\n-   return \"lcgr\\t%0,%0\";\n-}\n-  [(set_attr \"length\" \"20\")])\n+  rtx result = gen_rtx_ASHIFTRT (DImode, operands[0], GEN_INT (62));\n+  operands[2] = SET_DEST (XVECEXP (PATTERN (curr_insn), 0, 0));\n+  operands[3] = gen_rtx_COMPARE (GET_MODE (operands[2]), result, const0_rtx);\n+})\n \n \n ;;"}]}