{"sha": "e5207f1a6528877713109dc59b8db6c62a6eca28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyMDdmMWE2NTI4ODc3NzEzMTA5ZGM1OWI4ZGI2YzYyYTZlY2EyOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-11T11:53:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-11T11:53:40Z"}, "message": "ggc-page.c (release_pages): Output statistics when !quiet_flag.\n\n\t* ggc-page.c (release_pages): Output statistics when !quiet_flag.\n\t(ggc_collect): Dump later to not interfere with release_page dump.\n\t(ggc_trim): New function.\n\t* ggc-none.c (ggc_trim): New.\n\t* ggc.h (ggc_trim): Declare.\n\n\t* lto.c (lto_wpa_write_files): Call ggc_trim.\n\nFrom-SVN: r276878", "tree": {"sha": "34f4f7fba3ec2a97f492c3aa15d13541aa5a3843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f4f7fba3ec2a97f492c3aa15d13541aa5a3843"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5207f1a6528877713109dc59b8db6c62a6eca28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5207f1a6528877713109dc59b8db6c62a6eca28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5207f1a6528877713109dc59b8db6c62a6eca28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5207f1a6528877713109dc59b8db6c62a6eca28/comments", "author": null, "committer": null, "parents": [{"sha": "9d99596e3289766c392466eebb8b2f2d2f4f1bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d99596e3289766c392466eebb8b2f2d2f4f1bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d99596e3289766c392466eebb8b2f2d2f4f1bc1"}], "stats": {"total": 66, "additions": 60, "deletions": 6}, "files": [{"sha": "a73fe2074ed071c1d2a847acc27efc012057fe2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -1,3 +1,11 @@\n+2019-10-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ggc-page.c (release_pages): Output statistics when !quiet_flag.\n+\t(ggc_collect): Dump later to not interfere with release_page dump.\n+\t(ggc_trim): New function.\n+\t* ggc-none.c (ggc_trim): New.\n+\t* ggc.h (ggc_trim): Declare.\n+\n 2019-10-11  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92066"}, {"sha": "737429f9e49a76a7c7e43cee479b36a9d2c4c48f", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -72,3 +72,8 @@ void\n ggc_grow (void)\n {\n }\n+\n+void\n+ggc_trim (void)\n+{\n+}"}, {"sha": "4560206ac2ef2f10ca0229fba1ba47021f4b21e5", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -529,7 +529,6 @@ static void clear_page_group_in_use (page_group *, char *);\n #endif\n static struct page_entry * alloc_page (unsigned);\n static void free_page (struct page_entry *);\n-static void release_pages (void);\n static void clear_marks (void);\n static void sweep_pages (void);\n static void ggc_recalculate_in_use_p (page_entry *);\n@@ -1016,6 +1015,8 @@ free_page (page_entry *entry)\n static void\n release_pages (void)\n {\n+  size_t n1 = 0;\n+  size_t n2 = 0;\n #ifdef USING_MADVISE\n   page_entry *p, *start_p;\n   char *start;\n@@ -1061,6 +1062,7 @@ release_pages (void)\n           else\n             G.free_pages = p;\n           G.bytes_mapped -= mapped_len;\n+\t  n1 += len;\n \t  continue;\n         }\n       prev = newprev;\n@@ -1092,6 +1094,7 @@ release_pages (void)\n       /* Don't count those pages as mapped to not touch the garbage collector\n          unnecessarily. */\n       G.bytes_mapped -= len;\n+      n2 += len;\n       while (start_p != p)\n         {\n           start_p->discarded = true;\n@@ -1124,6 +1127,7 @@ release_pages (void)\n \t}\n \n       munmap (start, len);\n+      n1 += len;\n       G.bytes_mapped -= len;\n     }\n \n@@ -1152,10 +1156,20 @@ release_pages (void)\n \t*gp = g->next;\n \tG.bytes_mapped -= g->alloc_size;\n \tfree (g->allocation);\n+\tn1 += g->alloc_size;\n       }\n     else\n       gp = &g->next;\n #endif\n+  if (!quiet_flag && (n1 || n2))\n+    {\n+      fprintf (stderr, \" {GC\");\n+      if (n1)\n+\tfprintf (stderr, \" released %luk\", (unsigned long)(n1 / 1024));\n+      if (n2)\n+\tfprintf (stderr, \" madv_dontneed %luk\", (unsigned long)(n2 / 1024));\n+      fprintf (stderr, \"}\");\n+    }\n }\n \n /* This table provides a fast way to determine ceil(log_2(size)) for\n@@ -2178,19 +2192,22 @@ ggc_collect (void)\n     return;\n \n   timevar_push (TV_GC);\n-  if (!quiet_flag)\n-    fprintf (stderr, \" {GC %luk -> \", (unsigned long) G.allocated / 1024);\n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file, \"BEGIN COLLECTING\\n\");\n \n   /* Zero the total allocated bytes.  This will be recalculated in the\n      sweep phase.  */\n+  size_t allocated = G.allocated;\n   G.allocated = 0;\n \n   /* Release the pages we freed the last time we collected, but didn't\n      reuse in the interim.  */\n   release_pages ();\n \n+  /* Output this later so we do not interfere with release_pages.  */\n+  if (!quiet_flag)\n+    fprintf (stderr, \" {GC %luk -> \", (unsigned long) allocated / 1024);\n+\n   /* Indicate that we've seen collections at this context depth.  */\n   G.context_depth_collections = ((unsigned long)1 << (G.context_depth + 1)) - 1;\n \n@@ -2221,9 +2238,25 @@ ggc_collect (void)\n     fprintf (G.debug_file, \"END COLLECTING\\n\");\n }\n \n-/* Assume that all GGC memory is reachable and grow the limits for next collection.\n-   With checking, trigger GGC so -Q compilation outputs how much of memory really is\n-   reachable.  */\n+/* Return free pages to the system.  */\n+\n+void\n+ggc_trim ()\n+{\n+  timevar_push (TV_GC);\n+  G.allocated = 0;\n+  sweep_pages ();\n+  release_pages ();\n+  if (!quiet_flag)\n+    fprintf (stderr, \" {GC trimmed to %luk, %luk mapped}\",\n+\t     (unsigned long) G.allocated / 1024,\n+\t     (unsigned long) G.bytes_mapped / 1024);\n+  timevar_pop (TV_GC);\n+}\n+\n+/* Assume that all GGC memory is reachable and grow the limits for next\n+   collection.  With checking, trigger GGC so -Q compilation outputs how much\n+   of memory really is reachable.  */\n \n void\n ggc_grow (void)"}, {"sha": "31606dc843fb72186b5f13231ab6b101906efe84", "filename": "gcc/ggc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -243,6 +243,9 @@ extern const char *ggc_alloc_string (const char *contents, int length\n    function is called, not during allocations.  */\n extern void ggc_collect\t(void);\n \n+/* Return unused memory pages to the system.  */\n+extern void ggc_trim (void);\n+\n /* Assume that all GGC memory is reachable and grow the limits for next collection. */\n extern void ggc_grow (void);\n "}, {"sha": "5ad79e821adff6c38a36275a245910f8c792ba89", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -1,3 +1,7 @@\n+2019-10-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_wpa_write_files): Call ggc_trim.\n+\n 2019-10-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_wpa_write_files): Prepare all bodies for streaming."}, {"sha": "5aa143859d5991ae2d679d78bc8f4a8baa3e8fb7", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5207f1a6528877713109dc59b8db6c62a6eca28/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=e5207f1a6528877713109dc59b8db6c62a6eca28", "patch": "@@ -311,6 +311,7 @@ lto_wpa_write_files (void)\n     if (gimple_has_body_p (node->decl))\n       lto_prepare_function_for_streaming (node);\n \n+  ggc_trim ();\n   /* Generate a prefix for the LTRANS unit files.  */\n   blen = strlen (ltrans_output_list);\n   temp_filename = (char *) xmalloc (blen + sizeof (\"2147483648.o\"));"}]}