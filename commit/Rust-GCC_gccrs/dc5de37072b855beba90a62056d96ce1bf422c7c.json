{"sha": "dc5de37072b855beba90a62056d96ce1bf422c7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM1ZGUzNzA3MmI4NTViZWJhOTBhNjIwNTZkOTZjZTFiZjQyMmM3Yw==", "commit": {"author": {"name": "Hans Boehm", "email": "boehm@acm.org", "date": "2000-02-25T19:13:44Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-25T19:13:44Z"}, "message": "ffi.c, [...]: New files.\n\n2000-02-25  Hans Boehm <boehm@acm.org>\n\n\t* src/ia64/ffi.c, src/ia64/ia64_flags.h, src/ia64/unix.S: New\n\tfiles.\n\t* src/raw_api.c (ffi_translate_args): Fixed typo in argument\n\tlist.\n\t(ffi_prep_raw_closure): Use ffi_translate_args, not\n\tffi_closure_translate.\n\t* src/java_raw_api.c: New file.\n\t* src/ffitest.c (closure_test_fn): New function.\n\t(main): Define `rint' as long long on IA64.  Added new test when\n\tFFI_CLOSURES is defined.\n\t* include/ffi.h.in (ALIGN): Use size_t, not unsigned.\n\t(ffi_abi): Recognize IA64.\n\t(ffi_raw): Added `flt' field.\n\tAdded \"Java raw API\" code.\n\t* configure.in: Recognize ia64.\n\t* Makefile.am (TARGET_SRC_IA64): New macro.\n\t(libffi_la_common_SOURCES): Added java_raw_api.c.\n\t(libffi_la_SOURCES): Define in IA64 case.\n\nFrom-SVN: r32151", "tree": {"sha": "3d1ddd9e5907df213130f3823dd250c92c37a1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d1ddd9e5907df213130f3823dd250c92c37a1c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc5de37072b855beba90a62056d96ce1bf422c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5de37072b855beba90a62056d96ce1bf422c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc5de37072b855beba90a62056d96ce1bf422c7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5de37072b855beba90a62056d96ce1bf422c7c/comments", "author": {"login": "hboehm", "id": 1000362, "node_id": "MDQ6VXNlcjEwMDAzNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1000362?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hboehm", "html_url": "https://github.com/hboehm", "followers_url": "https://api.github.com/users/hboehm/followers", "following_url": "https://api.github.com/users/hboehm/following{/other_user}", "gists_url": "https://api.github.com/users/hboehm/gists{/gist_id}", "starred_url": "https://api.github.com/users/hboehm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hboehm/subscriptions", "organizations_url": "https://api.github.com/users/hboehm/orgs", "repos_url": "https://api.github.com/users/hboehm/repos", "events_url": "https://api.github.com/users/hboehm/events{/privacy}", "received_events_url": "https://api.github.com/users/hboehm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e2eaba46d7ef44ca821d3afaf385809db84fb1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2eaba46d7ef44ca821d3afaf385809db84fb1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e2eaba46d7ef44ca821d3afaf385809db84fb1f"}], "stats": {"total": 2033, "additions": 1681, "deletions": 352}, "files": [{"sha": "49a78bda796b476227399c0636dafa84e124ffc3", "filename": "libffi/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -1,3 +1,24 @@\n+2000-02-25  Hans Boehm <boehm@acm.org>\n+\n+\t* src/ia64/ffi.c, src/ia64/ia64_flags.h, src/ia64/unix.S: New\n+\tfiles.\n+\t* src/raw_api.c (ffi_translate_args): Fixed typo in argument\n+\tlist.\n+\t(ffi_prep_raw_closure): Use ffi_translate_args, not\n+\tffi_closure_translate.\n+\t* src/java_raw_api.c: New file.\n+\t* src/ffitest.c (closure_test_fn): New function.\n+\t(main): Define `rint' as long long on IA64.  Added new test when\n+\tFFI_CLOSURES is defined.\n+\t* include/ffi.h.in (ALIGN): Use size_t, not unsigned.\n+\t(ffi_abi): Recognize IA64.\n+\t(ffi_raw): Added `flt' field.\n+\tAdded \"Java raw API\" code.\n+\t* configure.in: Recognize ia64.\n+\t* Makefile.am (TARGET_SRC_IA64): New macro.\n+\t(libffi_la_common_SOURCES): Added java_raw_api.c.\n+\t(libffi_la_SOURCES): Define in IA64 case.\n+\n 2000-01-04  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt with newer automake."}, {"sha": "28369e78917701f5d5044305aa3a72c27a9ee249", "filename": "libffi/Makefile.am", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -42,13 +42,15 @@ TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s\n TARGET_SRC_X86 = src/x86/ffi.c src/x86/sysv.S\n TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n+TARGET_SRC_IA64 = src/alpha/ffi.c src/alpha/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c\n \n ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)\n ## Work around automake deficiency\n-libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c src/raw_api.c \n+libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n+\t\tsrc/raw_api.c src/java_raw_api.c\n if MIPS_GCC\n libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)\n endif\n@@ -64,6 +66,9 @@ endif\n if ALPHA\n libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_ALPHA)\n endif\n+if IA64\n+libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_IA64)\n+endif\n if M68K\n libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_M68K)\n endif"}, {"sha": "cd171a6bba317ec7e9173596547865ab7dbb9d69", "filename": "libffi/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -117,16 +117,18 @@ TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s\n TARGET_SRC_X86 = src/x86/ffi.c src/x86/sysv.S\n TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n+TARGET_SRC_IA64 = src/alpha/ffi.c src/alpha/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n \n-libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c src/raw_api.c \n+libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c src/raw_api.c src/java_raw_api.c\n @MIPS_GCC_TRUE@libffi_la_SOURCES = @MIPS_GCC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)\n @MIPS_SGI_TRUE@libffi_la_SOURCES = @MIPS_SGI_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_SGI)\n @X86_TRUE@libffi_la_SOURCES = @X86_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86)\n @SPARC_TRUE@libffi_la_SOURCES = @SPARC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_SPARC)\n @ALPHA_TRUE@libffi_la_SOURCES = @ALPHA_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ALPHA)\n+@IA64_TRUE@libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_IA64)\n @M68K_TRUE@libffi_la_SOURCES = @M68K_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_M68K)\n @POWERPC_TRUE@libffi_la_SOURCES = @POWERPC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC)\n @ARM_TRUE@libffi_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)\n@@ -290,6 +292,7 @@ debug.lo: src/debug.c\n prep_cif.lo: src/prep_cif.c\n types.lo: src/types.c\n raw_api.lo: src/raw_api.c\n+java_raw_api.lo: src/java_raw_api.c\n ffi.lo: src/alpha/ffi.c\n osf.lo: src/alpha/osf.S\n sysv.lo: src/arm/sysv.S"}, {"sha": "5bcef980326ca69a3098c2cea4326a7571c81820", "filename": "libffi/aclocal.m4", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Faclocal.m4?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -1,4 +1,4 @@\n-dnl aclocal.m4 generated automatically by aclocal 1.4a\n+dnl aclocal.m4 generated automatically by aclocal 1.4\n \n dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n dnl This file is free software; the Free Software Foundation\n@@ -44,8 +44,6 @@ dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n \n AC_DEFUN(AM_INIT_AUTOMAKE,\n [AC_REQUIRE([AC_PROG_INSTALL])\n-dnl We require 2.13 because we rely on SHELL being computed by configure.\n-AC_PREREQ([2.13])\n PACKAGE=[$1]\n AC_SUBST(PACKAGE)\n VERSION=[$2]\n@@ -66,23 +64,6 @@ AM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)\n AM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)\n AM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)\n AM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)\n-dnl Set install_sh for make dist\n-install_sh=\"$missing_dir/install-sh\"\n-test -f \"$install_sh\" || install_sh=\"$missing_dir/install.sh\"\n-AC_SUBST(install_sh)\n-dnl We check for tar when the user configures the end package.\n-dnl This is sad, since we only need this for \"dist\".  However,\n-dnl there's no other good way to do it.  We prefer GNU tar if\n-dnl we can find it.  If we can't find a tar, it doesn't really matter.\n-AC_CHECK_PROGS(AMTAR, gnutar gtar tar)\n-AMTARFLAGS=\n-if test -n \"$AMTAR\"; then\n-  if $SHELL -c \"$AMTAR --version\" > /dev/null 2>&1; then\n-    dnl We have GNU tar.\n-    AMTARFLAGS=o\n-  fi\n-fi\n-AC_SUBST(AMTARFLAGS)\n AC_REQUIRE([AC_PROG_MAKE_SET])])\n \n #\n@@ -191,7 +172,7 @@ LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n-$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \\\n+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $lt_target \\\n || AC_MSG_ERROR([libtool configure failed])\n \n # Reload cache, that may have been modified by ltconfig\n@@ -223,6 +204,11 @@ AC_REQUIRE([AC_PROG_NM])dnl\n AC_REQUIRE([AC_PROG_LN_S])dnl\n dnl\n \n+case \"$target\" in\n+NONE) lt_target=\"$host\" ;;\n+*) lt_target=\"$target\" ;;\n+esac\n+\n # Check for any special flags to pass to ltconfig.\n libtool_flags=\"--cache-file=$cache_file\"\n test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n@@ -241,7 +227,7 @@ test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n \n # Some flags need to be propagated to the compiler or linker for good\n # libtool support.\n-case \"$host\" in\n+case \"$lt_target\" in\n *-*-irix6*)\n   # Find out which ABI we are using.\n   echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n@@ -457,7 +443,6 @@ else\n   AC_MSG_RESULT(no)\n fi\n test -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n-AC_SUBST(LD)\n AC_PROG_LD_GNU\n ])\n \n@@ -503,14 +488,13 @@ else\n fi])\n NM=\"$ac_cv_path_NM\"\n AC_MSG_RESULT([$NM])\n-AC_SUBST(NM)\n ])\n \n # AC_CHECK_LIBM - check for math library\n AC_DEFUN(AC_CHECK_LIBM,\n [AC_REQUIRE([AC_CANONICAL_HOST])dnl\n LIBM=\n-case \"$host\" in\n+case \"$lt_target\" in\n *-*-beos* | *-*-cygwin*)\n   # These system don't have libm\n   ;;"}, {"sha": "f8259483b5c207c2db67f1a5663ad452f4f73e74", "filename": "libffi/configure", "status": "modified", "additions": 225, "deletions": 318, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -1,7 +1,7 @@\n #! /bin/sh\n \n # Guess values for system-dependent variables and create Makefiles.\n-# Generated automatically using autoconf version 2.13.1 \n+# Generated automatically using autoconf version 2.13 \n # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.\n #\n # This configure script is free software; the Free Software Foundation\n@@ -49,6 +49,7 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n+sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -163,6 +164,7 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n+  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -333,6 +335,11 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n+  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n+    ac_prev=sitefile ;;\n+  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n+    sitefile=\"$ac_optarg\" ;;\n+\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -354,7 +361,7 @@ EOF\n     verbose=yes ;;\n \n   -version | --version | --versio | --versi | --vers)\n-    echo \"configure generated by autoconf version 2.13.1\"\n+    echo \"configure generated by autoconf version 2.13\"\n     exit 0 ;;\n \n   -with-* | --with-*)\n@@ -498,12 +505,16 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$CONFIG_SITE\"; then\n-  if test \"x$prefix\" != xNONE; then\n-    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-  else\n-    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n+if test -z \"$sitefile\"; then\n+  if test -z \"$CONFIG_SITE\"; then\n+    if test \"x$prefix\" != xNONE; then\n+      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+    else\n+      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n+    fi\n   fi\n+else\n+  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -514,7 +525,7 @@ done\n \n if test -r \"$cache_file\"; then\n   echo \"loading cache $cache_file\"\n-      test -f \"$cache_file\" && . $cache_file\n+  . $cache_file\n else\n   echo \"creating cache $cache_file\"\n   > $cache_file\n@@ -568,50 +579,36 @@ done\n if test -z \"$ac_aux_dir\"; then\n   { echo \"configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../..\" 1>&2; exit 1; }\n fi\n-ac_config_guess=\"$SHELL $ac_aux_dir/config.guess\"\n-ac_config_sub=\"$SHELL $ac_aux_dir/config.sub\"\n-ac_configure=\"$SHELL $ac_aux_dir/configure\" # This should be Cygnus configure.\n-\n+ac_config_guess=$ac_aux_dir/config.guess\n+ac_config_sub=$ac_aux_dir/config.sub\n+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.\n \n-echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:578: checking host system type\" >&5\n-if test \"x$ac_cv_host\" = \"x\" || (test \"x$host\" != \"xNONE\" && test \"x$host\" != \"x$ac_cv_host_alias\"); then\n \n # Make sure we can run config.sub.\n-  if $ac_config_sub sun4 >/dev/null 2>&1; then :\n-    else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n-  fi\n-\n-  ac_cv_host_alias=$host\n-  case \"$ac_cv_host_alias\" in\n-  NONE)\n-    case $nonopt in\n-    NONE)\n-      if ac_cv_host_alias=`$ac_config_guess`; then :\n-      else { echo \"configure: error: can not guess host type; you must specify one\" 1>&2; exit 1; }\n-      fi ;;\n-    *) ac_cv_host_alias=$nonopt ;;\n-    esac ;;\n-  esac\n-\n-  ac_cv_host=`$ac_config_sub $ac_cv_host_alias`\n-  ac_cv_host_cpu=`echo $ac_cv_host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\1/'`\n-  ac_cv_host_vendor=`echo $ac_cv_host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\2/'`\n-  ac_cv_host_os=`echo $ac_cv_host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n-else\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n+if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :\n+else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n-echo \"$ac_t\"\"$ac_cv_host\" 1>&6\n-\n-host=$ac_cv_host\n-host_alias=$ac_cv_host_alias\n-host_cpu=$ac_cv_host_cpu\n-host_vendor=$ac_cv_host_vendor\n-host_os=$ac_cv_host_os\n-\n+echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n+echo \"configure:594: checking host system type\" >&5\n \n+host_alias=$host\n+case \"$host_alias\" in\n+NONE)\n+  case $nonopt in\n+  NONE)\n+    if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :\n+    else { echo \"configure: error: can not guess host type; you must specify one\" 1>&2; exit 1; }\n+    fi ;;\n+  *) host_alias=$nonopt ;;\n+  esac ;;\n+esac\n \n+host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`\n+host_cpu=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\1/'`\n+host_vendor=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\2/'`\n+host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n+echo \"$ac_t\"\"$host\" 1>&6\n \n \n # Find a good install program.  We prefer a C program (faster),\n@@ -626,9 +623,9 @@ host_os=$ac_cv_host_os\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:630: checking for a BSD compatible install\" >&5\n+echo \"configure:627: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n-if eval \"test \\\"\\${ac_cv_path_install+set}\\\" = set\"; then\n+if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n     IFS=\"${IFS= \t}\"; ac_save_IFS=\"$IFS\"; IFS=\":\"\n@@ -646,10 +643,6 @@ else\n             grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then\n \t    # AIX install.  It has an incompatible calling convention.\n \t    :\n-\t  elif test $ac_prog = install &&\n-\t    grep pwplus $ac_dir/$ac_prog >/dev/null 2>&1; then\n-\t    # program-specific install script used by HP pwplus--don't use.\n-\t    :\n \t  else\n \t    ac_cv_path_install=\"$ac_dir/$ac_prog -c\"\n \t    break 2\n@@ -678,12 +671,12 @@ echo \"$ac_t\"\"$INSTALL\" 1>&6\n # It thinks the first close brace ends the variable substitution.\n test -z \"$INSTALL_PROGRAM\" && INSTALL_PROGRAM='${INSTALL}'\n \n-test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL}'\n+test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n \n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:687: checking whether build environment is sane\" >&5\n+echo \"configure:680: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -731,18 +724,18 @@ EOF_SED\n   rm -f conftestsed\n fi\n test \"$program_prefix\" != NONE &&\n-  program_transform_name=\"s,^,${program_prefix},;$program_transform_name\"\n+  program_transform_name=\"s,^,${program_prefix},; $program_transform_name\"\n # Use a double $ so make ignores it.\n test \"$program_suffix\" != NONE &&\n-  program_transform_name=\"s,\\$\\$,${program_suffix},;$program_transform_name\"\n+  program_transform_name=\"s,\\$\\$,${program_suffix},; $program_transform_name\"\n \n # sed with no file args requires a program.\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:744: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:737: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n-if eval \"test \\\"\\${ac_cv_prog_make_${ac_make}_set+set}\\\" = set\"; then\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftestmake <<\\EOF\n@@ -767,7 +760,6 @@ else\n fi\n \n \n-\n PACKAGE=libffi\n \n VERSION=2.00-beta\n@@ -780,7 +772,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:784: checking for working aclocal\" >&5\n+echo \"configure:776: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -793,7 +785,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:797: checking for working autoconf\" >&5\n+echo \"configure:789: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -806,7 +798,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:810: checking for working automake\" >&5\n+echo \"configure:802: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -819,7 +811,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:823: checking for working autoheader\" >&5\n+echo \"configure:815: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -832,7 +824,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:836: checking for working makeinfo\" >&5\n+echo \"configure:828: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -844,59 +836,15 @@ else\n    echo \"$ac_t\"\"missing\" 1>&6\n fi\n \n-install_sh=\"$missing_dir/install-sh\"\n-test -f \"$install_sh\" || install_sh=\"$missing_dir/install.sh\"\n-\n-for ac_prog in gnutar gtar tar\n-do\n-# Extract the first word of \"$ac_prog\", so it can be a program name with args.\n-set dummy $ac_prog; ac_word=$2\n-echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:856: checking for $ac_word\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_AMTAR+set}\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  if test -n \"$AMTAR\"; then\n-  ac_cv_prog_AMTAR=\"$AMTAR\" # Let the user override the test.\n-else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n-  ac_dummy=\"$PATH\"\n-  for ac_dir in $ac_dummy; do\n-    test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/$ac_word; then\n-      ac_cv_prog_AMTAR=\"$ac_prog\"\n-      break\n-    fi\n-  done\n-  IFS=\"$ac_save_ifs\"\n-fi\n-fi\n-AMTAR=\"$ac_cv_prog_AMTAR\"\n-if test -n \"$AMTAR\"; then\n-  echo \"$ac_t\"\"$AMTAR\" 1>&6\n-else\n-  echo \"$ac_t\"\"no\" 1>&6\n-fi\n-\n-test -n \"$AMTAR\" && break\n-done\n-\n-AMTARFLAGS=\n-if test -n \"$AMTAR\"; then\n-  if $SHELL -c \"$AMTAR --version\" > /dev/null 2>&1; then\n-        AMTARFLAGS=o\n-  fi\n-fi\n-\n \n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:895: checking for Cygwin environment\" >&5\n-if eval \"test \\\"\\${ac_cv_cygwin+set}\\\" = set\"; then\n+echo \"configure:843: checking for Cygwin environment\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 900 \"configure\"\n+#line 848 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -907,7 +855,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:911: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:859: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -917,25 +865,26 @@ else\n   ac_cv_cygwin=no\n fi\n rm -f conftest*\n+rm -f conftest*\n fi\n \n echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:927: checking for mingw32 environment\" >&5\n-if eval \"test \\\"\\${ac_cv_mingw32+set}\\\" = set\"; then\n+echo \"configure:876: checking for mingw32 environment\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 932 \"configure\"\n+#line 881 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:939: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:888: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -945,57 +894,29 @@ else\n   ac_cv_mingw32=no\n fi\n rm -f conftest*\n+rm -f conftest*\n fi\n \n echo \"$ac_t\"\"$ac_cv_mingw32\" 1>&6\n MINGW32=\n test \"$ac_cv_mingw32\" = yes && MINGW32=yes\n-echo $ac_n \"checking for EMX OS/2 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:955: checking for EMX OS/2 environment\" >&5\n-if eval \"test \\\"\\${ac_cv_emxos2+set}\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  cat > conftest.$ac_ext <<EOF\n-#line 960 \"configure\"\n-#include \"confdefs.h\"\n-\n-int main() {\n-return __EMX__;\n-; return 0; }\n-EOF\n-if { (eval echo configure:967: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n-  rm -rf conftest*\n-  ac_cv_emxos2=yes\n-else\n-  echo \"configure: failed program was:\" >&5\n-  cat conftest.$ac_ext >&5\n-  rm -rf conftest*\n-  ac_cv_emxos2=no\n-fi\n-rm -f conftest*\n-fi\n-\n-echo \"$ac_t\"\"$ac_cv_emxos2\" 1>&6\n-EMXOS2=\n-test \"$ac_cv_emxos2\" = yes && EMXOS2=yes\n-\n \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:986: checking for executable suffix\" >&5\n-if eval \"test \\\"\\${ac_cv_exeext+set}\\\" = set\"; then\n+echo \"configure:907: checking for executable suffix\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n-  if test \"$CYGWIN\" = yes || test \"$MINGW32\" = yes || test \"$EMXOS2\" = yes; then\n+  if test \"$CYGWIN\" = yes || test \"$MINGW32\" = yes; then\n   ac_cv_exeext=.exe\n else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:996: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:917: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.C | *.o | *.obj | *.xcoff) ;;\n+      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -1013,7 +934,7 @@ echo \"$ac_t\"\"${ac_cv_exeext}\" 1>&6\n ac_exeext=$EXEEXT\n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1017: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:938: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1039,8 +960,8 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1043: checking for $ac_word\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_CC+set}\\\" = set\"; then\n+echo \"configure:964: checking for $ac_word\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$CC\"; then\n@@ -1069,8 +990,8 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1073: checking for $ac_word\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_CC+set}\\\" = set\"; then\n+echo \"configure:994: checking for $ac_word\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$CC\"; then\n@@ -1116,12 +1037,12 @@ fi\n \n   if test -z \"$CC\"; then\n     case \"`uname -s`\" in\n-    *win32* | *WIN32* | *CYGWIN*)\n+    *win32* | *WIN32*)\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1124: checking for $ac_word\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_CC+set}\\\" = set\"; then\n+echo \"configure:1045: checking for $ac_word\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$CC\"; then\n@@ -1151,8 +1072,8 @@ fi\n   test -z \"$CC\" && { echo \"configure: error: no acceptable cc found in \\$PATH\" 1>&2; exit 1; }\n fi\n \n-echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $CPPFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:1156: checking whether the C compiler ($CC $CFLAGS $CPPFLAGS $LDFLAGS) works\" >&5\n+echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n+echo \"configure:1077: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -1163,12 +1084,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 1167 \"configure\"\n+#line 1088 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:1172: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1093: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -1193,22 +1114,22 @@ echo \"$ac_t\"\"$ac_cv_prog_cc_works\" 1>&6\n if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n-echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $CPPFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:1198: checking whether the C compiler ($CC $CFLAGS $CPPFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n+echo \"configure:1119: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1203: checking whether we are using GNU C\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_gcc+set}\\\" = set\"; then\n+echo \"configure:1124: checking whether we are using GNU C\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.c <<EOF\n #ifdef __GNUC__\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1212: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1133: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1227,8 +1148,8 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1231: checking whether ${CC-cc} accepts -g\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_cc_g+set}\\\" = set\"; then\n+echo \"configure:1152: checking whether ${CC-cc} accepts -g\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   echo 'void f(){}' > conftest.c\n@@ -1327,51 +1248,29 @@ else\n   enable_fast_install=yes\n fi\n \n-\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1333: checking build system type\" >&5\n-if test \"x$ac_cv_build\" = \"x\" || (test \"x$build\" != \"xNONE\" && test \"x$build\" != \"x$ac_cv_build_alias\"); then\n-\n-# Make sure we can run config.sub.\n-  if $ac_config_sub sun4 >/dev/null 2>&1; then :\n-    else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n-  fi\n-\n-  ac_cv_build_alias=$build\n-  case \"$ac_cv_build_alias\" in\n-  NONE)\n-    case $nonopt in\n-    NONE)\n-      ac_cv_build_alias=$host_alias ;;\n-\n-    *) ac_cv_build_alias=$nonopt ;;\n-    esac ;;\n-  esac\n-\n-  ac_cv_build=`$ac_config_sub $ac_cv_build_alias`\n-  ac_cv_build_cpu=`echo $ac_cv_build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\1/'`\n-  ac_cv_build_vendor=`echo $ac_cv_build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\2/'`\n-  ac_cv_build_os=`echo $ac_cv_build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n-else\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-fi\n-\n-echo \"$ac_t\"\"$ac_cv_build\" 1>&6\n-\n-build=$ac_cv_build\n-build_alias=$ac_cv_build_alias\n-build_cpu=$ac_cv_build_cpu\n-build_vendor=$ac_cv_build_vendor\n-build_os=$ac_cv_build_os\n-\n-\n+echo \"configure:1253: checking build system type\" >&5\n+\n+build_alias=$build\n+case \"$build_alias\" in\n+NONE)\n+  case $nonopt in\n+  NONE) build_alias=$host_alias ;;\n+  *) build_alias=$nonopt ;;\n+  esac ;;\n+esac\n \n+build=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $build_alias`\n+build_cpu=`echo $build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\1/'`\n+build_vendor=`echo $build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\2/'`\n+build_os=`echo $build | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n+echo \"$ac_t\"\"$build\" 1>&6\n \n # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1374: checking for $ac_word\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_RANLIB+set}\\\" = set\"; then\n+echo \"configure:1273: checking for $ac_word\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$RANLIB\"; then\n@@ -1409,7 +1308,7 @@ ac_prog=ld\n if test \"$ac_cv_prog_gcc\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1413: checking for ld used by GCC\" >&5\n+echo \"configure:1312: checking for ld used by GCC\" >&5\n   ac_prog=`($CC -print-prog-name=ld) 2>&5`\n   case \"$ac_prog\" in\n     # Accept absolute paths.\n@@ -1433,12 +1332,12 @@ echo \"configure:1413: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1437: checking for GNU ld\" >&5\n+echo \"configure:1336: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1440: checking for non-GNU ld\" >&5\n+echo \"configure:1339: checking for non-GNU ld\" >&5\n fi\n-if eval \"test \\\"\\${ac_cv_path_LD+set}\\\" = set\"; then\n+if eval \"test \\\"`echo '$''{'ac_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -z \"$LD\"; then\n@@ -1470,10 +1369,9 @@ else\n   echo \"$ac_t\"\"no\" 1>&6\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n-\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1476: checking if the linker ($LD) is GNU ld\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_gnu_ld+set}\\\" = set\"; then\n+echo \"configure:1374: checking if the linker ($LD) is GNU ld\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   # I'd rather use --version here, but apparently some GNU ld's only accept -v.\n@@ -1488,8 +1386,8 @@ echo \"$ac_t\"\"$ac_cv_prog_gnu_ld\" 1>&6\n \n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1492: checking for BSD-compatible nm\" >&5\n-if eval \"test \\\"\\${ac_cv_path_NM+set}\\\" = set\"; then\n+echo \"configure:1390: checking for BSD-compatible nm\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$NM\"; then\n@@ -1523,10 +1421,9 @@ fi\n NM=\"$ac_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n-\n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1529: checking whether ln -s works\" >&5\n-if eval \"test \\\"\\${ac_cv_prog_LN_S+set}\\\" = set\"; then\n+echo \"configure:1426: checking whether ln -s works\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftestdata\n@@ -1546,6 +1443,11 @@ else\n fi\n \n \n+case \"$target\" in\n+NONE) lt_target=\"$host\" ;;\n+*) lt_target=\"$target\" ;;\n+esac\n+\n # Check for any special flags to pass to ltconfig.\n libtool_flags=\"--cache-file=$cache_file\"\n test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n@@ -1566,11 +1468,11 @@ test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n \n # Some flags need to be propagated to the compiler or linker for good\n # libtool support.\n-case \"$host\" in\n+case \"$lt_target\" in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 1573 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:1574: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 1475 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:1476: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -1591,19 +1493,19 @@ case \"$host\" in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:1595: checking whether the C compiler needs -belf\" >&5\n-if eval \"test \\\"\\${lt_cv_cc_needs_belf+set}\\\" = set\"; then\n+echo \"configure:1497: checking whether the C compiler needs -belf\" >&5\n+if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1600 \"configure\"\n+#line 1502 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:1607: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1509: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -1681,13 +1583,13 @@ LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n-$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \\\n+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $lt_target \\\n || { echo \"configure: error: libtool configure failed\" 1>&2; exit 1; }\n \n # Reload cache, that may have been modified by ltconfig\n if test -r \"$cache_file\"; then\n   echo \"loading cache $cache_file\"\n-      test -f \"$cache_file\" && . $cache_file\n+  . $cache_file\n else\n   echo \"creating cache $cache_file\"\n   > $cache_file\n@@ -1713,6 +1615,7 @@ i*86-*-beos*) TARGET=X86; TARGETDIR=x86;;\n sparc-sun-4*) TARGET=SPARC; TARGETDIR=sparc;;\n sparc-sun-*) TARGET=SPARC; TARGETDIR=sparc;;\n alpha*-*-linux* | alpha*-*-osf*) TARGET=ALPHA; TARGETDIR=alpha;;\n+ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;\n powerpc-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-beos*) TARGET=POWERPC; TARGETDIR=powerpc;;\n@@ -1770,6 +1673,15 @@ else\n fi\n \n \n+if test x$TARGET = xIA64; then\n+  IA64_TRUE=\n+  IA64_FALSE='#'\n+else\n+  IA64_TRUE='#'\n+  IA64_FALSE=\n+fi\n+\n+\n if test x$TARGET = xM68K; then\n   M68K_TRUE=\n   M68K_FALSE='#'\n@@ -1797,13 +1709,13 @@ else\n fi\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:1801: checking how to run the C preprocessor\" >&5\n+echo \"configure:1713: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n fi\n if test -z \"$CPP\"; then\n-if eval \"test \\\"\\${ac_cv_prog_CPP+set}\\\" = set\"; then\n+if eval \"test \\\"`echo '$''{'ac_cv_prog_CPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n     # This must be in double quotes, not single quotes, because CPP may get\n@@ -1812,13 +1724,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 1816 \"configure\"\n+#line 1728 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1822: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1734: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -1829,13 +1741,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 1833 \"configure\"\n+#line 1745 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1839: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1751: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -1846,13 +1758,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 1850 \"configure\"\n+#line 1762 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1856: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1768: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -1877,20 +1789,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:1881: checking for ANSI C header files\" >&5\n-if eval \"test \\\"\\${ac_cv_header_stdc+set}\\\" = set\"; then\n+echo \"configure:1793: checking for ANSI C header files\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1886 \"configure\"\n+#line 1798 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1894: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1806: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -1907,7 +1819,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 1911 \"configure\"\n+#line 1823 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -1925,7 +1837,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 1929 \"configure\"\n+#line 1841 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -1946,7 +1858,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1950 \"configure\"\n+#line 1862 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -1957,7 +1869,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:1961: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:1873: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -1983,12 +1895,12 @@ fi\n for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:1987: checking for $ac_func\" >&5\n-if eval \"test \\\"\\${ac_cv_func_$ac_func+set}\\\" = set\"; then\n+echo \"configure:1899: checking for $ac_func\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1992 \"configure\"\n+#line 1904 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -1997,7 +1909,6 @@ else\n /* We use char because int might match the return type of a gcc2\n     builtin and then its argument prototype would still apply.  */\n char $ac_func();\n-char (*f)();\n \n int main() {\n \n@@ -2007,12 +1918,12 @@ int main() {\n #if defined (__stub_$ac_func) || defined (__stub___$ac_func)\n choke me\n #else\n-f = $ac_func;\n+$ac_func();\n #endif\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2016: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1927: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2039,19 +1950,19 @@ done\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2043: checking for working alloca.h\" >&5\n-if eval \"test \\\"\\${ac_cv_header_alloca_h+set}\\\" = set\"; then\n+echo \"configure:1954: checking for working alloca.h\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2048 \"configure\"\n+#line 1959 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:2055: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1966: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -2072,12 +1983,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2076: checking for alloca\" >&5\n-if eval \"test \\\"\\${ac_cv_func_alloca_works+set}\\\" = set\"; then\n+echo \"configure:1987: checking for alloca\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2081 \"configure\"\n+#line 1992 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -2105,7 +2016,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2109: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2020: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -2137,12 +2048,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:2141: checking whether alloca needs Cray hooks\" >&5\n-if eval \"test \\\"\\${ac_cv_os_cray+set}\\\" = set\"; then\n+echo \"configure:2052: checking whether alloca needs Cray hooks\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2146 \"configure\"\n+#line 2057 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -2167,12 +2078,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2171: checking for $ac_func\" >&5\n-if eval \"test \\\"\\${ac_cv_func_$ac_func+set}\\\" = set\"; then\n+echo \"configure:2082: checking for $ac_func\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2176 \"configure\"\n+#line 2087 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2181,7 +2092,6 @@ else\n /* We use char because int might match the return type of a gcc2\n     builtin and then its argument prototype would still apply.  */\n char $ac_func();\n-char (*f)();\n \n int main() {\n \n@@ -2191,12 +2101,12 @@ int main() {\n #if defined (__stub_$ac_func) || defined (__stub___$ac_func)\n choke me\n #else\n-f = $ac_func;\n+$ac_func();\n #endif\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2200: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2110: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2223,15 +2133,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2227: checking stack direction for C alloca\" >&5\n-if eval \"test \\\"\\${ac_cv_c_stack_direction+set}\\\" = set\"; then\n+echo \"configure:2137: checking stack direction for C alloca\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2235 \"configure\"\n+#line 2145 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -2250,7 +2160,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:2254: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2164: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -2273,15 +2183,15 @@ fi\n \n \n echo $ac_n \"checking size of short\"\"... $ac_c\" 1>&6\n-echo \"configure:2277: checking size of short\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_short+set}\\\" = set\"; then\n+echo \"configure:2187: checking size of short\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_short'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2285 \"configure\"\n+#line 2195 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2292,7 +2202,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2296: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2206: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_short=`cat conftestval`\n else\n@@ -2312,15 +2222,15 @@ EOF\n \n \n echo $ac_n \"checking size of int\"\"... $ac_c\" 1>&6\n-echo \"configure:2316: checking size of int\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_int+set}\\\" = set\"; then\n+echo \"configure:2226: checking size of int\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_int'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2324 \"configure\"\n+#line 2234 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2331,7 +2241,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2335: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2245: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_int=`cat conftestval`\n else\n@@ -2351,15 +2261,15 @@ EOF\n \n \n echo $ac_n \"checking size of long\"\"... $ac_c\" 1>&6\n-echo \"configure:2355: checking size of long\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_long+set}\\\" = set\"; then\n+echo \"configure:2265: checking size of long\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2363 \"configure\"\n+#line 2273 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2370,7 +2280,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2374: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2284: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_long=`cat conftestval`\n else\n@@ -2390,15 +2300,15 @@ EOF\n \n \n echo $ac_n \"checking size of long long\"\"... $ac_c\" 1>&6\n-echo \"configure:2394: checking size of long long\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_long_long+set}\\\" = set\"; then\n+echo \"configure:2304: checking size of long long\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2402 \"configure\"\n+#line 2312 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2409,7 +2319,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2413: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2323: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_long_long=`cat conftestval`\n else\n@@ -2429,15 +2339,15 @@ EOF\n \n \n echo $ac_n \"checking size of float\"\"... $ac_c\" 1>&6\n-echo \"configure:2433: checking size of float\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_float+set}\\\" = set\"; then\n+echo \"configure:2343: checking size of float\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_float'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2441 \"configure\"\n+#line 2351 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2448,7 +2358,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2452: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2362: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_float=`cat conftestval`\n else\n@@ -2468,15 +2378,15 @@ EOF\n \n \n echo $ac_n \"checking size of double\"\"... $ac_c\" 1>&6\n-echo \"configure:2472: checking size of double\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_double+set}\\\" = set\"; then\n+echo \"configure:2382: checking size of double\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2480 \"configure\"\n+#line 2390 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2487,7 +2397,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2491: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2401: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_double=`cat conftestval`\n else\n@@ -2507,15 +2417,15 @@ EOF\n \n \n echo $ac_n \"checking size of long double\"\"... $ac_c\" 1>&6\n-echo \"configure:2511: checking size of long double\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_long_double+set}\\\" = set\"; then\n+echo \"configure:2421: checking size of long double\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2519 \"configure\"\n+#line 2429 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2526,7 +2436,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2530: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2440: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_long_double=`cat conftestval`\n else\n@@ -2547,15 +2457,15 @@ EOF\n \n \n echo $ac_n \"checking size of void *\"\"... $ac_c\" 1>&6\n-echo \"configure:2551: checking size of void *\" >&5\n-if eval \"test \\\"\\${ac_cv_sizeof_void_p+set}\\\" = set\"; then\n+echo \"configure:2461: checking size of void *\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2559 \"configure\"\n+#line 2469 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -2566,7 +2476,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:2570: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2480: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_void_p=`cat conftestval`\n else\n@@ -2586,14 +2496,14 @@ EOF\n \n \n echo $ac_n \"checking whether byte ordering is bigendian\"\"... $ac_c\" 1>&6\n-echo \"configure:2590: checking whether byte ordering is bigendian\" >&5\n-if eval \"test \\\"\\${ac_cv_c_bigendian+set}\\\" = set\"; then\n+echo \"configure:2500: checking whether byte ordering is bigendian\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_c_bigendian'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_bigendian=unknown\n # See if sys/param.h defines the BYTE_ORDER macro.\n cat > conftest.$ac_ext <<EOF\n-#line 2597 \"configure\"\n+#line 2507 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -2604,11 +2514,11 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:2608: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2518: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   # It does; now see whether it defined to BIG_ENDIAN or not.\n cat > conftest.$ac_ext <<EOF\n-#line 2612 \"configure\"\n+#line 2522 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -2619,7 +2529,7 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:2623: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2533: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_bigendian=yes\n else\n@@ -2639,7 +2549,7 @@ if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2643 \"configure\"\n+#line 2553 \"configure\"\n #include \"confdefs.h\"\n main () {\n   /* Are we little or big endian?  From Harbison&Steele.  */\n@@ -2652,7 +2562,7 @@ main () {\n   exit (u.c[sizeof (long) - 1] == 1);\n }\n EOF\n-if { (eval echo configure:2656: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2566: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_bigendian=no\n else\n@@ -2821,7 +2731,7 @@ do\n     echo \"running \\${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion\"\n     exec \\${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;\n   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)\n-    echo \"$CONFIG_STATUS generated by autoconf version 2.13.1\"\n+    echo \"$CONFIG_STATUS generated by autoconf version 2.13\"\n     exit 0 ;;\n   -help | --help | --hel | --he | --h)\n     echo \"\\$ac_cs_usage\"; exit 0 ;;\n@@ -2879,9 +2789,6 @@ s%@AUTOCONF@%$AUTOCONF%g\n s%@AUTOMAKE@%$AUTOMAKE%g\n s%@AUTOHEADER@%$AUTOHEADER%g\n s%@MAKEINFO@%$MAKEINFO%g\n-s%@install_sh@%$install_sh%g\n-s%@AMTAR@%$AMTAR%g\n-s%@AMTARFLAGS@%$AMTARFLAGS%g\n s%@SET_MAKE@%$SET_MAKE%g\n s%@EXEEXT@%$EXEEXT%g\n s%@MAINTAINER_MODE_TRUE@%$MAINTAINER_MODE_TRUE%g\n@@ -2894,8 +2801,6 @@ s%@build_cpu@%$build_cpu%g\n s%@build_vendor@%$build_vendor%g\n s%@build_os@%$build_os%g\n s%@RANLIB@%$RANLIB%g\n-s%@LD@%$LD%g\n-s%@NM@%$NM%g\n s%@LN_S@%$LN_S%g\n s%@LIBTOOL@%$LIBTOOL%g\n s%@MIPS_GCC_TRUE@%$MIPS_GCC_TRUE%g\n@@ -2908,6 +2813,8 @@ s%@X86_TRUE@%$X86_TRUE%g\n s%@X86_FALSE@%$X86_FALSE%g\n s%@ALPHA_TRUE@%$ALPHA_TRUE%g\n s%@ALPHA_FALSE@%$ALPHA_FALSE%g\n+s%@IA64_TRUE@%$IA64_TRUE%g\n+s%@IA64_FALSE@%$IA64_FALSE%g\n s%@M68K_TRUE@%$M68K_TRUE%g\n s%@M68K_FALSE@%$M68K_FALSE%g\n s%@POWERPC_TRUE@%$POWERPC_TRUE%g\n@@ -3147,5 +3054,5 @@ exit 0\n EOF\n chmod +x $CONFIG_STATUS\n rm -fr confdefs* $ac_clean_files\n-test \"$no_create\" = yes || $SHELL $CONFIG_STATUS || exit 1\n+test \"$no_create\" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1\n "}, {"sha": "dbbd1434af2177f64c686d813b05ea1cea5a6fb0", "filename": "libffi/configure.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -27,6 +27,7 @@ i*86-*-beos*) TARGET=X86; TARGETDIR=x86;;\n sparc-sun-4*) TARGET=SPARC; TARGETDIR=sparc;;\n sparc-sun-*) TARGET=SPARC; TARGETDIR=sparc;;\n alpha*-*-linux* | alpha*-*-osf*) TARGET=ALPHA; TARGETDIR=alpha;;\n+ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;\n powerpc-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-beos*) TARGET=POWERPC; TARGETDIR=powerpc;;\n@@ -42,6 +43,7 @@ AM_CONDITIONAL(MIPS_SGI, test ${TARGET}${ac_cv_prog_gcc} = MIPSno)\n AM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\n AM_CONDITIONAL(X86, test x$TARGET = xX86)\n AM_CONDITIONAL(ALPHA, test x$TARGET = xALPHA)\n+AM_CONDITIONAL(IA64, test x$TARGET = xIA64)\n AM_CONDITIONAL(M68K, test x$TARGET = xM68K)\n AM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\n AM_CONDITIONAL(ARM, test x$TARGET = xARM)"}, {"sha": "655cc1c6cbf86a6d95f53e66b0181c2c4ad0fb4c", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n    libffi @VERSION@ - Copyright (c) 1996-1999  Cygnus Solutions\n \n-   $Id: ffi.h.in,v 1.2 1999/08/09 02:52:58 green Exp $\n+   $Id: ffi.h.in,v 1.3 1999/09/01 23:16:34 tromey Exp $\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -24,6 +24,32 @@\n \n    ----------------------------------------------------------------------- */\n \n+/* -------------------------------------------------------------------\n+   The basic API is described in the README file.\n+\n+   The raw API is designed to bypass some of the argument packing\n+   and unpacking on architectures for which it can be avoided.\n+\n+   The closure API allows interpreted functions to be packaged up\n+   inside a C function pointer, so that they can be called as C functions,\n+   with no understanding on the client side that they are interpreted.\n+   It can also be used in other cases in which it is necessary to package\n+   up a user specified parameter and a function pointer as a single\n+   function pointer.\n+\n+   The closure API must be implemented in order to get its functionality,\n+   e.g. for use by gij.  Routines are provided to emulate the raw API\n+   if the underlying platform doesn't allow faster implementation.\n+\n+   More details on the raw and cloure API can be found in:\n+\n+   http://sourceware.cygnus.com/ml/java-discuss/1999-q3/msg00138.html\n+\n+   and\n+\n+   http://sourceware.cygnus.com/ml/java-discuss/1999-q3/msg00174.html\n+   -------------------------------------------------------------------- */\n+\n #ifndef LIBFFI_H\n #define LIBFFI_H\n \n@@ -138,7 +164,9 @@ extern \"C\" {\n \n /* ---- Generic type definitions ----------------------------------------- */\n \n-#define ALIGN(v, a)  (((((unsigned) (v))-1) | ((a)-1))+1)\n+#define ALIGN(v, a)  (((((size_t) (v))-1) | ((a)-1))+1)\n+/* The closure code assumes that this works on pointers, i.e. a size_t\t*/\n+/* can hold a pointer.\t\t\t\t\t\t\t*/\n \n typedef enum ffi_abi {\n \n@@ -159,6 +187,12 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif\n \n+  /* ---- Intel ia64 ---------------- */\n+#ifdef IA64\n+  FFI_UNIX,   \t/* Linux and all Unix variants use the same conventions\t*/\n+  FFI_DEFAULT_ABI = FFI_UNIX,\n+#endif\n+\n   /* ---- Mips --------------------- */\n #ifdef MIPS\n   FFI_O32,\n@@ -268,6 +302,7 @@ typedef struct {\n typedef union {\n   SINT_ARG sint;\n   UINT_ARG uint;\n+  float\t   flt;\n   char     data[SIZEOF_ARG];\n   void*    ptr;\n } ffi_raw;\n@@ -281,8 +316,22 @@ void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);\n void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);\n size_t ffi_raw_size (ffi_cif *cif);\n \n+#if !NO_JAVA_RAW_API\n \n+/* This is analogous to the raw API, except it uses Java parameter\t*/\n+/* packing, even on 64-bit machines.  I.e. on 64-bit machines\t\t*/\n+/* longs and doubles are followed by an empty 64-bit word.\t\t*/\n \n+void ffi_java_raw_call (/*@dependent@*/ ffi_cif *cif, \n+\t\t        void (*fn)(), \n+\t\t        /*@out@*/ void *rvalue, \n+\t\t        /*@dependent@*/ ffi_raw *avalue);\n+\n+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);\n+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);\n+size_t ffi_java_raw_size (ffi_cif *cif);\n+\n+#endif /* !NO_JAVA_RAW_API */\n \n #endif /* !FFI_NO_RAW_API */\n \n@@ -294,6 +343,21 @@ size_t ffi_raw_size (ffi_cif *cif);\n #define FFI_TRAMPOLINE_SIZE 10\n #define FFI_NATIVE_RAW_API 1\t/* and has native raw api support */\n \n+#elif defined(IA64)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24  /* Really the following struct, which \t*/\n+\t\t\t\t/* can be interpreted as a C function\t*/\n+\t\t\t\t/* decriptor:\t\t\t\t*/\n+\n+struct ffi_ia64_trampoline_struct {\n+    void * code_pointer;\t/* Pointer to ffi_closure_UNIX\t*/\n+    void * fake_gp;\t\t/* Pointer to closure, installed as gp\t*/\n+    void * real_gp;\t\t/* Real gp value, reinstalled by \t*/\n+\t\t\t\t/* ffi_closure_UNIX.\t\t\t*/\n+};\n+#define FFI_NATIVE_RAW_API 0\n+\n #else \n \n #define FFI_CLOSURES 0\n@@ -347,6 +411,14 @@ ffi_prep_raw_closure (ffi_raw_closure*,\n \t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n \t\t      void *user_data);\n \n+#ifndef NO_JAVA_RAW_API\n+ffi_status\n+ffi_prep_java_raw_closure (ffi_raw_closure*,\n+\t\t           ffi_cif *cif,\n+\t\t           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t           void *user_data);\n+#endif\n+\n #endif /* !FFI_NO_RAW_API */\n #endif /* FFI_CLOSURES */\n "}, {"sha": "3dd0989783c330105c4f3df65fd1f32dbce45fa8", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -196,6 +196,16 @@ static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)\n   return ts1;\n }\n \n+/* Take an int and a float argument, together with int userdata, and \t*/\n+/* return the sum.\t\t\t\t\t\t\t*/\n+static void closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n+{\n+    *(int*)resp =\n+\t *(int *)args[0] + (int)(*(float *)args[1]) + (int)(long)userdata;\n+}\n+\n+typedef int (*closure_test_type)(int, float);\n+\n int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n {\n   ffi_cif cif;\n@@ -214,7 +224,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   signed int si1;\n   signed int si2;\n \n-#if defined(ALPHA) || (defined(MIPS) && (_MIPS_SIM == _ABIN32))\n+#if defined(ALPHA) || defined(IA64) || (defined(MIPS) && (_MIPS_SIM == _ABIN32))\n   long long rint;\n #else\n   int rint;\n@@ -691,6 +701,27 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     free (ts5_result);\n   }\n \n+# if FFI_CLOSURES\n+  /* A simple closure test */\n+    {\n+      ffi_closure cl;\n+      ffi_type * cl_arg_types[3];\n+\n+      cl_arg_types[0] = &ffi_type_sint;\n+      cl_arg_types[1] = &ffi_type_float;\n+      cl_arg_types[2] = NULL;\n+      \n+      /* Initialize the cif */\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, \n+\t    \t         &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n+\t\t\t     (void *) 3 /* userdata */)\n+\t    == FFI_OK);\n+      CHECK((*((closure_test_type)(&cl)))(1, 2.0) == 6);\n+    }\n+# endif\n+\n   /* If we arrived here, all is good */\n   (void) puts(\"\\nLooks good. No surprises.\\n\");\n "}, {"sha": "bb4fbb73a728ed810d649f780d752e42f05ba4e6", "filename": "libffi/src/ia64/ffi.c", "status": "added", "additions": 670, "deletions": 0, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -0,0 +1,670 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 1998 Cygnus Solutions\n+\t   Copyright (c) 2000 Hewlett Packard Company\n+   \n+   IA64 Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+#include \"ia64_flags.h\"\n+\n+/* Memory image of fp register contents.  Should eventually be an fp \t*/\n+/* type long enough to hold an entire register.  For now we use double.\t*/\n+typedef double float80;\n+\n+/* The stack layout at call to ffi_prep_regs.  Other_args will remain\t*/\n+/* on the stack for the actual call.  Everything else we be transferred\t*/\n+/* to registers and popped by the assembly code.\t\t\t*/\n+\n+struct ia64_args {\n+    long scratch[2];\t/* Two scratch words at top of stack.\t\t*/\n+\t\t\t/* Allows sp to passed as arg pointer.\t\t*/\n+    void * r8_contents;\t/* Value to be passed in r8\t\t\t*/\n+    long spare;\t\t/* Not used.\t\t\t\t\t*/\n+    float80 fp_regs[8]; /* Contents of 8 floating point argument \t*/\n+\t\t\t/* registers.\t\t\t\t\t*/\n+    long out_regs[8];\t/* Contents of the 8 out registers used \t*/\n+\t\t\t/* for integer parameters.\t\t\t*/\n+    long other_args[0]; /* Arguments passed on stack, variable size\t*/\n+\t\t\t/* Treated as continuation of out_regs.\t\t*/\n+};\n+\n+static size_t float_type_size(unsigned short tp)\n+{\n+  switch(tp) {\n+    case FFI_TYPE_FLOAT:\n+      return sizeof(float);\n+    case FFI_TYPE_DOUBLE:\n+      return sizeof(double);\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+      return sizeof(long double);\n+#endif\n+    default:\n+      FFI_ASSERT(0);\n+  }\n+}\n+\n+/*\n+ * Is type a struct containing at most n floats, doubles, or extended\n+ * doubles, all of the same fp type?\n+ * If so, set *element_type to the fp type.\n+ */\n+static bool is_homogeneous_fp_aggregate(ffi_type * type, int n,\n+\t\t\t\t        unsigned short * element_type)\n+{\n+  ffi_type **ptr; \n+  unsigned short element, struct_element;\n+\n+  int type_set = 0;\n+\n+  FFI_ASSERT(type != NULL);\n+\n+  FFI_ASSERT(type->elements != NULL);\n+\n+  ptr = &(type->elements[0]);\n+\n+  while ((*ptr) != NULL)\n+    {\n+      switch((*ptr) -> type) {\n+\tcase FFI_TYPE_FLOAT:\n+\t  if (type_set && element != FFI_TYPE_FLOAT) return 0;\n+\t  if (--n < 0) return FALSE;\n+\t  type_set = 1;\n+\t  element = FFI_TYPE_FLOAT;\n+\t  break;\n+\tcase FFI_TYPE_DOUBLE:\n+\t  if (type_set && element != FFI_TYPE_DOUBLE) return 0;\n+\t  if (--n < 0) return FALSE;\n+\t  type_set = 1;\n+\t  element = FFI_TYPE_DOUBLE;\n+\t  break;\n+\tcase FFI_TYPE_STRUCT:\n+\t  if (!is_homogeneous_fp_aggregate(type, n, &struct_element))\n+\t      return FALSE;\n+\t  if (type_set && struct_element != element) return FALSE;\n+\t  n -= (type -> size)/float_type_size(element);\n+\t  element = struct_element;\n+\t  if (n < 0) return FALSE;\n+\t  break;\n+\t/* case FFI_TYPE_LONGDOUBLE:\n+\t  Not yet implemented.\t*/\n+\tdefault:\n+\t  return FALSE;\n+      }\n+      ptr++;\n+    }\n+  *element_type = element;\n+  return TRUE;\n+   \n+} \n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments.  Returns nonzero\n+   if fp registers are used for arguments. */\n+\n+static bool\n+ffi_prep_args(struct ia64_args *stack, extended_cif *ecif, int bytes)\n+{\n+  register long i, avn;\n+  register void **p_argv;\n+  register long *argp = stack -> out_regs;\n+  register float80 *fp_argp = stack -> fp_regs;\n+  register ffi_type **p_arg;\n+\n+  /* For big return structs, r8 needs to contain the target address.\t*/\n+  /* Since r8 is otherwise dead, we set it unconditionally.\t\t*/\n+  stack -> r8_contents = ecif -> rvalue;\n+  i = 0;\n+  avn = ecif->cif->nargs;\n+  p_arg = ecif->cif->arg_types;\n+  p_argv = ecif->avalue;\n+  while (i < avn)\n+    {\n+      size_t z; /* z is in units of arg slots or words, not bytes.\t*/\n+\n+      switch ((*p_arg)->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\t  z = 1;\n+\t  *(SINT64 *) argp = *(SINT8 *)(* p_argv);\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_UINT8:\n+\t  z = 1;\n+\t  *(UINT64 *) argp = *(UINT8 *)(* p_argv);\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_SINT16:\n+\t  z = 1;\n+\t  *(SINT64 *) argp = *(SINT16 *)(* p_argv);\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_UINT16:\n+\t  z = 1;\n+\t  *(UINT64 *) argp = *(UINT16 *)(* p_argv);\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_SINT32:\n+\t  z = 1;\n+\t  *(SINT64 *) argp = *(SINT32 *)(* p_argv);\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_UINT32:\n+\t  z = 1;\n+\t  *(UINT64 *) argp = *(UINT32 *)(* p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  z = 1;\n+\t  *(UINT64 *) argp = *(UINT64 *)(* p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  z = 1;\n+\t  if (fp_argp - stack->fp_regs < 8)\n+\t    {\n+\t      /* Note the conversion -- all the fp regs are loaded as\n+\t\t doubles.  */\n+\t      *fp_argp++ = *(float *)(* p_argv);\n+\t    }\n+\t  /* Also put it into the integer registers or memory: */\n+\t    *(UINT64 *) argp = *(UINT32 *)(* p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  z = 1;\n+\t  if (fp_argp - stack->fp_regs < 8)\n+\t    *fp_argp++ = *(double *)(* p_argv);\n+\t  /* Also put it into the integer registers or memory: */\n+\t    *(double *) argp = *(double *)(* p_argv);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  {\n+\t      size_t sz = (*p_arg)->size;\n+\t      unsigned short element_type;\n+              z = ((*p_arg)->size + SIZEOF_ARG - 1)/SIZEOF_ARG;\n+\t      if (is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {\n+\t\tint i;\n+\t\tint nelements = sz/float_type_size(element_type);\n+\t\tfor (i = 0; i < nelements; ++i) {\n+\t\t  switch (element_type) {\n+\t\t    case FFI_TYPE_FLOAT:\n+\t\t      if (fp_argp - stack->fp_regs < 8)\n+\t\t\t*fp_argp++ = ((float *)(* p_argv))[i];\n+\t\t      break;\n+\t\t    case FFI_TYPE_DOUBLE:\n+\t\t      if (fp_argp - stack->fp_regs < 8)\n+\t\t\t*fp_argp++ = ((double *)(* p_argv))[i];\n+\t\t      break;\n+\t\t    default:\n+\t\t\t/* Extended precision not yet implemented. */\n+\t\t\tabort();\n+\t\t  }\n+\t\t}\n+\t      }\n+\t      /* And pass it in integer registers as a struct, with\t*/\n+\t      /* its actual field sizes packed into registers.\t\t*/\n+\t      memcpy(argp, *p_argv, (*p_arg)->size);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      argp += z;\n+      i++, p_arg++, p_argv++;\n+    }\n+  return (fp_argp != stack -> fp_regs);\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  long i, avn;\n+  bool is_simple = TRUE;\n+  long simple_flag = FFI_SIMPLE_V;\n+  /* Adjust cif->bytes to include space for the 2 scratch words,\n+     r8 register contents, spare word,\n+     the 8 fp register contents, and all 8 integer register contents.\n+     This will be removed before the call, though 2 scratch words must\n+     remain.  */\n+\n+  cif->bytes += 4*sizeof(long) + 8 *sizeof(float80);\n+  if (cif->bytes < sizeof(struct ia64_args))\n+    cif->bytes = sizeof(struct ia64_args);\n+\n+  /* The stack must be double word aligned, so round bytes up\n+     appropriately. */\n+\n+  cif->bytes = ALIGN(cif->bytes, 2*sizeof(void*));\n+\n+  avn = cif->nargs;\n+  if (avn <= 2) {\n+    for (i = 0; i < avn; ++i) {\n+      switch(cif -> arg_types[i] -> type) {\n+\tcase FFI_TYPE_SINT32:\n+\t  simple_flag = FFI_ADD_INT_ARG(simple_flag);\n+\t  break;\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  simple_flag = FFI_ADD_LONG_ARG(simple_flag);\n+\t  break;\n+\tdefault:\n+\t  is_simple = FALSE;\n+      }\n+    }\n+  } else {\n+    is_simple = FALSE;\n+  }\n+\n+  /* Set the return type flag */\n+  switch (cif->rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+      cif->flags = FFI_TYPE_VOID;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      {\n+        size_t sz = cif -> rtype -> size;\n+  \tunsigned short element_type;\n+\n+\tis_simple = FALSE;\n+  \tif (is_homogeneous_fp_aggregate(cif -> rtype, 8, &element_type)) {\n+\t  int nelements = sz/float_type_size(element_type);\n+\t  if (nelements <= 1) {\n+\t    if (0 == nelements) {\n+\t      cif -> flags = FFI_TYPE_VOID;\n+\t    } else {\n+\t      cif -> flags = element_type;\n+\t    }\n+\t  } else {\n+\t    switch(element_type) {\n+\t      case FFI_TYPE_FLOAT:\n+\t        cif -> flags = FFI_IS_FLOAT_FP_AGGREGATE | nelements;\n+\t\tbreak;\n+\t      case FFI_TYPE_DOUBLE:\n+\t        cif -> flags = FFI_IS_DOUBLE_FP_AGGREGATE | nelements;\n+\t\tbreak;\n+\t      default:\n+\t\t/* long double NYI */\n+\t\tabort();\n+\t    }\n+\t  }\n+\t  break;\n+        }\n+        if (sz <= 32) {\n+\t  if (sz <= 8) {\n+              cif->flags = FFI_TYPE_INT;\n+  \t  } else if (sz <= 16) {\n+              cif->flags = FFI_IS_SMALL_STRUCT2;\n+  \t  } else if (sz <= 24) {\n+              cif->flags = FFI_IS_SMALL_STRUCT3;\n+\t  } else {\n+              cif->flags = FFI_IS_SMALL_STRUCT4;\n+\t  }\n+        } else {\n+          cif->flags = FFI_TYPE_STRUCT;\n+\t}\n+      }\n+      break;\n+\n+    case FFI_TYPE_FLOAT:\n+      is_simple = FALSE;\n+      cif->flags = FFI_TYPE_FLOAT;\n+      break;\n+\n+    case FFI_TYPE_DOUBLE:\n+      is_simple = FALSE;\n+      cif->flags = FFI_TYPE_DOUBLE;\n+      break;\n+\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      /* This seems to depend on little endian mode, and the fact that\t*/\n+      /* the return pointer always points to at least 8 bytes.  But \t*/\n+      /* that also seems to be true for other platforms.\t\t*/\n+      break;\n+    }\n+  \n+  if (is_simple) cif -> flags |= simple_flag;\n+  return FFI_OK;\n+}\n+\n+extern int ffi_call_unix(bool (*)(struct ia64_args *, extended_cif *, int), \n+\t\t\t extended_cif *, unsigned, \n+\t\t\t unsigned, unsigned *, void (*)());\n+\n+void\n+ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n+{\n+  extended_cif ecif;\n+  long simple = cif -> flags & FFI_SIMPLE;\n+\n+  /* Should this also check for Unix ABI? */\n+  /* This is almost, but not quite, machine independent.  Note that\t*/\n+  /* we can get away with not caring about length of the result because\t*/\n+  /* we assume we are little endian, and the result buffer is large \t*/\n+  /* enough.\t\t\t\t\t\t\t\t*/\n+  /* This needs work for HP/UX.\t\t\t\t\t\t*/\n+  if (simple) {\n+    long (*lfn)() = (long (*)())fn;\n+    long result;\n+    switch(simple) {\n+      case FFI_SIMPLE_V:\n+\tresult = lfn();\n+\tbreak;\n+      case FFI_SIMPLE_I:\n+\tresult = lfn(*(int *)avalue[0]);\n+\tbreak;\n+      case FFI_SIMPLE_L:\n+\tresult = lfn(*(long *)avalue[0]);\n+\tbreak;\n+      case FFI_SIMPLE_II:\n+\tresult = lfn(*(int *)avalue[0], *(int *)avalue[1]);\n+\tbreak;\n+      case FFI_SIMPLE_IL:\n+\tresult = lfn(*(int *)avalue[0], *(long *)avalue[1]);\n+\tbreak;\n+      case FFI_SIMPLE_LI:\n+\tresult = lfn(*(long *)avalue[0], *(int *)avalue[1]);\n+\tbreak;\n+      case FFI_SIMPLE_LL:\n+\tresult = lfn(*(long *)avalue[0], *(long *)avalue[1]);\n+\tbreak;\n+    }\n+    if ((cif->flags & ~FFI_SIMPLE) != FFI_TYPE_VOID && 0 != rvalue) {\n+      * (long *)rvalue = result;\n+    }\n+    return;\n+  }\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  \n+  /* If the return value is a struct and we don't have a return\n+     value address then we need to make one.  */\n+  \n+  if (rvalue == NULL && cif->rtype->type == FFI_TYPE_STRUCT)\n+    ecif.rvalue = alloca(cif->rtype->size);\n+  else\n+    ecif.rvalue = rvalue;\n+    \n+  switch (cif->abi) \n+    {\n+    case FFI_UNIX:\n+      ffi_call_unix(ffi_prep_args, &ecif, cif->bytes,\n+\t\t    cif->flags, rvalue, fn);\n+      break;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+\n+/*\n+ * Closures represent a pair consisting of a function pointer, and\n+ * some user data.  A closure is invoked by reinterpreting the closure\n+ * as a function pointer, and branching to it.  Thus we can make an\n+ * interpreted function callable as a C function:  We turn the interpreter\n+ * itself, together with a pointer specifying the interpreted procedure,\n+ * into a closure.\n+ * On X86, the first few words of the closure structure actually contain code,\n+ * which will do the right thing.  On most other architectures, this\n+ * would raise some Icache/Dcache coherence issues (which can be solved, but\n+ * often not cheaply).\n+ * For IA64, function pointer are already pairs consisting of a code\n+ * pointer, and a gp pointer.  The latter is needed to access global variables.\n+ * Here we set up such a pair as the first two words of the closure (in\n+ * the \"trampoline\" area), but we replace the gp pointer with a pointer\n+ * to the closure itself.  We also add the real gp pointer to the\n+ * closure.  This allows the function entry code to both retrieve the\n+ * user data, and to restire the correct gp pointer.\n+ */\n+\n+static void \n+ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,\n+\t\t\t    void **avalue, ffi_cif *cif);\n+\n+/* This function is entered with the doctored gp (r1) value.\n+ * This code is extremely gcc specific.  There is some argument that\n+ * it should really be written in assembly code, since it depends on\n+ * gcc properties that might change over time.\n+ */\n+\n+/* ffi_closure_UNIX is an assembly routine, which copies the register \t*/\n+/* state into s struct ia64_args, and the invokes\t\t\t*/\n+/* ffi_closure_UNIX_inner.  It also recovers the closure pointer\t*/\n+/* from its fake gp pointer.\t\t\t\t\t\t*/\n+void ffi_closure_UNIX();\n+\n+#ifndef __GNUC__\n+#   error This requires gcc\n+#endif\n+void\n+ffi_closure_UNIX_inner (ffi_closure *closure, struct ia64_args * args)\n+/* Hopefully declarint this as a varargs function will force all args\t*/\n+/* to memory.\t\t\t\t\t\t\t\t*/\n+{\n+  // this is our return value storage\n+  long double    res;\n+\n+  // our various things...\n+  ffi_cif       *cif;\n+  unsigned short rtype;\n+  void          *resp;\n+  void\t\t**arg_area;\n+\n+  resp = (void*)&res;\n+  cif         = closure->cif;\n+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  \n+\n+  /* this call will initialize ARG_AREA, such that each\n+   * element in that array points to the corresponding \n+   * value on the stack; and if the function returns\n+   * a structure, it will re-set RESP to point to the\n+   * structure return address.  */\n+\n+  ffi_prep_incoming_args_UNIX(args, (void**)&resp, arg_area, cif);\n+  \n+  (closure->fun) (cif, resp, arg_area, closure->user_data);\n+\n+  rtype = cif->flags;\n+\n+  /* now, do a generic return based on the value of rtype */\n+  if (rtype == FFI_TYPE_INT)\n+    {\n+      asm volatile (\"ld8 r8=[%0]\" : : \"r\" (resp) : \"r8\");\n+    }\n+  else if (rtype == FFI_TYPE_FLOAT)\n+    {\n+      asm volatile (\"ldfs f8=[%0]\" : : \"r\" (resp) : \"f8\");\n+    }\n+  else if (rtype == FFI_TYPE_DOUBLE)\n+    {\n+      asm volatile (\"ldfd f8=[%0]\" : : \"r\" (resp) : \"f8\");\n+    }\n+  else if (rtype == FFI_IS_SMALL_STRUCT2)\n+    {\n+      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]\"\n+\t\t    : : \"r\" (resp), \"r\" (resp+8) : \"r8\",\"r9\");\n+    }\n+  else if (rtype == FFI_IS_SMALL_STRUCT3)\n+    {\n+      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]; ld8 r10=[%2]\"\n+\t\t    : : \"r\" (resp), \"r\" (resp+8), \"r\" (resp+16)\n+\t\t    : \"r8\",\"r9\",\"r10\");\n+    }\n+  else if (rtype == FFI_IS_SMALL_STRUCT4)\n+    {\n+      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]; ld8 r10=[%2]; ld8 r11=[%3]\"\n+\t\t    : : \"r\" (resp), \"r\" (resp+8), \"r\" (resp+16), \"r\" (resp+24)\n+\t\t    : \"r8\",\"r9\",\"r10\",\"r11\");\n+    }\n+  else if (rtype != FFI_TYPE_VOID && rtype != FFI_TYPE_STRUCT)\n+    {\n+      /* Can only happen for homogeneous FP aggregates?\t*/\n+      abort();\n+    }\n+}\n+\n+static void \n+ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,\n+\t\t\t    void **avalue, ffi_cif *cif)\n+{\n+  register unsigned int i;\n+  register unsigned int avn;\n+  register void **p_argv;\n+  register unsigned long *argp = args -> out_regs;\n+  unsigned fp_reg_num = 0;\n+  register ffi_type **p_arg;\n+\n+  avn = cif->nargs;\n+  p_argv = avalue;\n+\n+  for (i = cif->nargs, p_arg = cif->arg_types; i != 0; i--, p_arg++)\n+    {\n+      size_t z; /* In units of words or argument slots.\t*/\n+\n+      switch ((*p_arg)->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  z = 1;\n+\t  *p_argv = (void *)argp;\n+\t  break;\n+\t\t  \n+\tcase FFI_TYPE_FLOAT:\n+\t  z = 1;\n+\t  /* Convert argument back to float in place from the saved value */\n+\t  if (fp_reg_num < 8) {\n+\t      *(float *)argp = args -> fp_regs[fp_reg_num++];\n+\t  } else {\n+\t      *(float *)argp = *(double *)argp;\n+\t  }\n+\t  *p_argv = (void *)argp;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  z = 1;\n+\t  if (fp_reg_num < 8) {\n+\t      *p_argv = args -> fp_regs + fp_reg_num++;\n+\t  } else {\n+\t      *p_argv = (void *)argp;\n+\t  }\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  {\n+\t      size_t sz = (*p_arg)->size;\n+\t      unsigned short element_type;\n+              z = ((*p_arg)->size + SIZEOF_ARG - 1)/SIZEOF_ARG;\n+\t      if (is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {\n+\t\tint nelements = sz/float_type_size(element_type);\n+\t\tif (nelements + fp_reg_num >= 8) {\n+\t\t  /* hard case NYI.\t*/\n+\t\t  abort();\n+\t\t}\n+\t\tif (element_type == FFI_TYPE_DOUBLE) {\n+\t          *p_argv = args -> fp_regs + fp_reg_num;\n+\t\t  fp_reg_num += nelements;\n+\t\t  break;\n+\t\t}\n+\t\tif (element_type == FFI_TYPE_FLOAT) {\n+\t\t  int j;\n+\t\t  for (j = 0; j < nelements; ++ j) {\n+\t\t     ((float *)argp)[j] = args -> fp_regs[fp_reg_num + j];\n+\t\t  }\n+\t          *p_argv = (void *)argp;\n+\t\t  fp_reg_num += nelements;\n+\t\t  break;\n+\t\t}\n+\t\tabort();  /* Other fp types NYI */\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      argp += z;\n+      p_argv++;\n+\n+    }\n+  \n+  return;\n+}\n+\n+\n+/* Fill in a closure to refer to the specified fun and user_data.\t*/\n+/* cif specifies the argument and result types for fun.\t\t\t*/\n+/* the cif must already be prep'ed */\n+\n+/* The layout of a function descriptor.  A C function pointer really \t*/\n+/* points to one of these.\t\t\t\t\t\t*/\n+typedef struct ia64_fd_struct {\n+    void *code_pointer;\n+    void *gp;\n+} ia64_fd;\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t  void *user_data)\n+{\n+  struct ffi_ia64_trampoline_struct *tramp =\n+    (struct ffi_ia64_trampoline_struct *) (closure -> tramp);\n+  ia64_fd *fd = (ia64_fd *)(void *)ffi_closure_UNIX;\n+\n+  FFI_ASSERT (cif->abi == FFI_UNIX);\n+\n+  tramp -> code_pointer = fd -> code_pointer;\n+  tramp -> real_gp = fd -> gp;\n+  tramp -> fake_gp = closure;\n+  closure->cif  = cif;\n+  closure->user_data = user_data;\n+  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}\n+\n+"}, {"sha": "23dbd3e0237d5f1e705415b53938539c59a4a969", "filename": "libffi/src/ia64/ia64_flags.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Fia64_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Fia64_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fia64_flags.h?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -0,0 +1,62 @@\n+/* -----------------------------------------------------------------------\n+   ia64_flags.h - Copyright (c) 2000 Hewlett Packard Company\n+   \n+   IA64/unix Foreign Function Interface \n+\n+   Original author: Hans Boehm, HP Labs\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+\n+/* Homogeneous Floating Point Aggregates (HFAs) which are returned\t*/\n+/* in FP registers.  The least significant bits specify the size in \t*/\n+/* words.\t\t\t\t\t\t\t\t*/\n+#define FFI_IS_FLOAT_FP_AGGREGATE 0x1000\n+#define FFI_IS_DOUBLE_FP_AGGREGATE 0x0800\n+#define FLOAT_FP_AGGREGATE_BIT 12\n+#define DOUBLE_FP_AGGREGATE_BIT 11\n+\n+/* Small structures containing N words.  If N=1, they are returned\t*/\n+/* as though they were integers.\t\t\t\t\t*/\n+#define FFI_IS_SMALL_STRUCT2\t0x40 /* Struct > 8, <=16 bytes\t*/\n+#define FFI_IS_SMALL_STRUCT3\t0x41 /* Struct > 16 <= 24 bytes\t*/\n+#define FFI_IS_SMALL_STRUCT4\t0x42 /* Struct > 24, <=32 bytes\t*/\n+\n+/* Flag values identifying particularly simple cases, which are \t*/\n+/* handled specially.  We treat functions as simple if they take all\t*/\n+/* arguments can be passed as 32 or 64 bit integer quantities, there is\t*/\n+/* either no return value or it can be treated as a 64bit integer, and\t*/\n+/* if there are at most 2 arguments.\t\t\t\t\t*/\n+/* This is OR'ed with the normal flag values.\t\t\t\t*/\n+#define FFI_SIMPLE_V 0x10000\t/* () -> X\t*/\n+#define FFI_SIMPLE_I 0x20000\t/* (int) -> X\t*/\n+#define FFI_SIMPLE_L 0x30000\t/* (long) -> X\t*/\n+#define FFI_SIMPLE_II 0x40000\t/* (int,int) -> X\t*/\n+#define FFI_SIMPLE_IL 0x50000\t/* (int,long) -> X\t*/\n+#define FFI_SIMPLE_LI 0x60000\t/* (long,int) -> X\t*/\n+#define FFI_SIMPLE_LL 0x70000\t/* (long,long) -> X\t*/\n+\n+/* Mask for all of the FFI_SIMPLE bits:\t*/\n+#define FFI_SIMPLE 0xf0000\n+\n+/* An easy way to build FFI_SIMPLE flags from FFI_SIMPLE_V:\t*/\n+#define FFI_ADD_LONG_ARG(flag) (((flag) << 1) | 0x10000)\n+#define FFI_ADD_INT_ARG(flag) ((flag) << 1)"}, {"sha": "fdaf8be28ad59481c1e8f51a42007bcc6db56b83", "filename": "libffi/src/ia64/unix.S", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Funix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fia64%2Funix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Funix.S?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -0,0 +1,301 @@\n+/* -----------------------------------------------------------------------\n+   unix.S - Copyright (c) 1998 Cygnus Solutions\n+            Copyright (c) 2000 Hewlett Packard Company\n+   \n+   IA64/unix Foreign Function Interface \n+\n+   Primary author: Hans Boehm, HP Labs\n+\n+   Loosely modeled on Cygnus code for other platforms.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\t\n+#include <ffi.h>\n+#include \"ia64_flags.h\"\n+\n+/* parameters:\t*/\n+#define callback\tin0\n+#define ecifp\t\tin1\n+#define bytes\t\tin2\n+#define flags\t\tin3\n+#define raddr\t\tin4\n+#define fn\t\tin5\n+\n+#define FLOAT_SZ\t8 /* in-memory size of fp operands\t*/\n+\n+.text\n+        .align 16\n+        .global ffi_call_unix#\n+        .proc ffi_call_unix#\n+ffi_call_unix:\n+\talloc   loc0=ar.pfs,6,5,8,0\n+\tmov \tloc1=b0;\n+\tsub\tsp=sp,bytes\n+\tmov\tloc4=r1\t\t/* Save gp \t*/\n+\tld8\tr8=[callback],8\t/* code address of callback\t*/\n+\t;;\n+\tmov \tout0=sp\n+\tmov\tout1=ecifp\n+\tmov\tout2=bytes\n+\tld8\tr1=[callback]\t/* Set up gp for callback.  Unnecessary? */\n+\tmov\tb6=r8\n+\t;;\n+\tbr.call.sptk.many b0 = b6\t/* call ffi_prep_args\t\t*/\n+\tcmp.eq\tp6,p0=0,r8\t\t/* r8 nonzero ==> need fp regs\t*/\n+ \t;;\n+(p6)\tadd\tloc2=32+8*FLOAT_SZ,sp\n+(p6)\tbr.cond.dptk.many\tfp_done\n+\t;;\t/* Quiets warning; needed?\t*/\n+\tadd\tloc2=32,sp\n+\tadd\tloc3=32+FLOAT_SZ,sp\n+\t;;\n+\tldfd\tf8=[loc2],2*FLOAT_SZ\n+\tldfd\tf9=[loc3],2*FLOAT_SZ\n+\t;;\n+\tldfd\tf10=[loc2],2*FLOAT_SZ\n+\tldfd\tf11=[loc3],2*FLOAT_SZ\n+\t;;\n+\tldfd\tf12=[loc2],2*FLOAT_SZ\n+\tldfd\tf13=[loc3],2*FLOAT_SZ\n+\t;;\n+\tldfd\tf14=[loc2],2*FLOAT_SZ\n+\tldfd\tf15=[loc3]\n+fp_done:\n+\tadd\tr9=16,sp\t/* Pointer to r8_contents\t*/\n+\t/* loc2 points at first integer register value.  */\n+\tadd\tloc3=8,loc2\n+\t;;\n+\tld8\tr8=[r9]\t\t/* Just in case we return large struct */\n+\tld8\tout0=[loc2],16\n+\tld8\tout1=[loc3],16\n+\t;;\n+\tld8\tout2=[loc2],16\n+\tld8\tout3=[loc3],16\n+\t;;\n+\tld8\tout4=[loc2],16\n+\tld8\tout5=[loc3],16\n+\t;;\n+\tld8\tout6=[loc2],16\n+\tld8\tout7=[loc3]\n+\t/* loc2 points at first stack parameter.  Set sp to 16 bytes\t*/\n+\t/* below that.\t\t\t\t\t\t\t*/\n+\tadd\tsp=-16,loc2\n+\t\n+\tld8 \tr8=[fn],8\n+\t;;\n+\tld8\tr1=[fn]\t\t/* Set up gp */\n+\tmov\tb6=r8;;\n+\tbr.call.sptk.many b0 = b6\t/* call ffi_prep_args\t*/\n+\t\n+\t/* Handle return value. */\n+\tcmp.eq\tp6,p0=0,raddr\n+\tcmp.eq\tp7,p0=FFI_TYPE_INT,flags\n+\tcmp.eq\tp10,p0=FFI_IS_SMALL_STRUCT2,flags\n+\tcmp.eq\tp11,p0=FFI_IS_SMALL_STRUCT3,flags\n+\tcmp.eq\tp12,p0=FFI_IS_SMALL_STRUCT4,flags\n+\t;;\n+(p6) \tbr.cond.dpnt.few done\t\t/* Dont copy ret values if raddr = 0 */\n+(p7)\tbr.cond.dptk.few copy1\n+(p10)\tbr.cond.dpnt.few copy2\n+(p11)\tbr.cond.dpnt.few copy3\n+(p12)\tbr.cond.dpnt.few copy4\n+\tcmp.eq\tp8,p0=FFI_TYPE_FLOAT,flags\n+\tcmp.eq\tp9,p0=FFI_TYPE_DOUBLE,flags\n+\ttbit.nz\tp6,p0=flags,FLOAT_FP_AGGREGATE_BIT\n+\ttbit.nz\tp7,p0=flags,DOUBLE_FP_AGGREGATE_BIT\n+\t;;\n+(p8)\tstfs\t[raddr]=f8\n+(p9)\tstfd\t[raddr]=f8\n+\t;;\n+(p6)\tbr.cond.dpnt.few handle_float_hfa\n+(p7)\tbr.cond.dpnt.few handle_double_hfa\n+\tbr done\n+\n+copy4:\n+\tadd\tloc3=24,raddr\n+\t;;\n+\tst8\t[loc3]=r11\n+copy3:\n+\tadd\tloc3=16,raddr\n+\t;;\n+\tst8\t[loc3]=r10\n+copy2:\n+\tadd\tloc3=8,raddr\n+\t;;\n+\tst8\t[loc3]=r9\n+copy1:\n+\tst8\t[raddr]=r8\n+\t/* In the big struct case, raddr was passed as an argument.\t*/\n+\t/* In the void case there was nothing to do.\t\t\t*/\n+\n+done:\n+\tmov\tr1=loc4\t\t/* Restore gp\t*/\n+\tmov\tar.pfs = loc0\n+\tmov\tb0 = loc1\n+\tbr.ret.sptk.many b0\n+\n+handle_double_hfa:\n+\t/* Homogeneous floating point array of doubles is returned in\t*/\n+\t/* registers f8-f15.  Save one at a time to return area.\t*/\n+\tand\tflags=0xf,flags\t/* Retrieve size\t*/\n+\t;;\n+\tcmp.eq\tp6,p0=2,flags\n+\tcmp.eq\tp7,p0=3,flags\n+\tcmp.eq\tp8,p0=4,flags\n+\tcmp.eq\tp9,p0=5,flags\n+\tcmp.eq\tp10,p0=6,flags\n+\tcmp.eq\tp11,p0=7,flags\n+\tcmp.eq\tp12,p0=8,flags\n+\t;;\n+(p6)\tbr.cond.dptk.few\tdhfa2\n+(p7)\tbr.cond.dptk.few\tdhfa3\n+(p8)\tbr.cond.dptk.few\tdhfa4\n+(p9)\tbr.cond.dptk.few\tdhfa5\n+(p10)\tbr.cond.dptk.few\tdhfa6\n+(p11)\tbr.cond.dptk.few\tdhfa7\n+dhfa8:\tadd \tloc3=7*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f15\n+dhfa7:\tadd \tloc3=6*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f14\n+dhfa6:\tadd \tloc3=5*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f13\n+dhfa5:\tadd \tloc3=4*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f12\n+dhfa4:\tadd \tloc3=3*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f11\n+dhfa3:\tadd \tloc3=2*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f10\n+dhfa2:\tadd \tloc3=1*8,raddr\n+\t;;\n+\tstfd\t[loc3]=f9\n+\tstfd\t[raddr]=f8\n+\tbr\tdone\n+\n+handle_float_hfa:\n+\t/* Homogeneous floating point array of floats is returned in\t*/\n+\t/* registers f8-f15.  Save one at a time to return area.\t*/\n+\tand\tflags=0xf,flags\t/* Retrieve size\t*/\n+\t;;\n+\tcmp.eq\tp6,p0=2,flags\n+\tcmp.eq\tp7,p0=3,flags\n+\tcmp.eq\tp8,p0=4,flags\n+\tcmp.eq\tp9,p0=5,flags\n+\tcmp.eq\tp10,p0=6,flags\n+\tcmp.eq\tp11,p0=7,flags\n+\tcmp.eq\tp12,p0=8,flags\n+\t;;\n+(p6)\tbr.cond.dptk.few\tshfa2\n+(p7)\tbr.cond.dptk.few\tshfa3\n+(p8)\tbr.cond.dptk.few\tshfa4\n+(p9)\tbr.cond.dptk.few\tshfa5\n+(p10)\tbr.cond.dptk.few\tshfa6\n+(p11)\tbr.cond.dptk.few\tshfa7\n+shfa8:\tadd \tloc3=7*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f15\n+shfa7:\tadd \tloc3=6*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f14\n+shfa6:\tadd \tloc3=5*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f13\n+shfa5:\tadd \tloc3=4*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f12\n+shfa4:\tadd \tloc3=3*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f11\n+shfa3:\tadd \tloc3=2*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f10\n+shfa2:\tadd \tloc3=1*4,raddr\n+\t;;\n+\tstfd\t[loc3]=f9\n+\tstfd\t[raddr]=f8\n+\tbr\tdone\n+\n+        .endp ffi_call_unix\n+\n+\n+.text\n+        .align 16\n+        .global ffi_closure_UNIX\n+        .proc ffi_closure_UNIX\n+ffi_closure_UNIX:\n+\talloc   loc0=ar.pfs,8,2,2,0\n+\tmov\tloc1=b0\n+\t/* Retrieve closure pointer and real gp.\t*/\n+\tmov\tout0=gp\n+\tadd\tgp=16,gp\n+\t;;\n+\tld8\tgp=[gp]\n+\t/* Reserve a structia64_args on the stack such that arguments\t*/\n+\t/* past the first 8 are automatically placed in the right\t*/\n+\t/* slot.  Note that when we start the sp points at 2 8-byte\t*/\n+\t/* scratch words, followed by the extra arguments.\t\t*/\n+#\tdefine BASIC_ARGS_SZ (8*FLOAT_SZ+8*8+2*8)\n+#\tdefine FIRST_FP_OFFSET (4*8)\n+\tadd\tr14=-(BASIC_ARGS_SZ-FIRST_FP_OFFSET),sp\n+\tadd\tr15=-(BASIC_ARGS_SZ-FIRST_FP_OFFSET-FLOAT_SZ),sp\n+\tadd\tsp=-BASIC_ARGS_SZ,sp\n+\t/* r14 points to fp_regs[0], r15 points to fp_regs[1]\t*/\n+\t;;\n+\tstfd\t[r14]=f8,2*FLOAT_SZ\n+\tstfd\t[r15]=f9,2*FLOAT_SZ\n+\t;;\n+\tstfd\t[r14]=f10,2*FLOAT_SZ\n+\tstfd\t[r15]=f11,2*FLOAT_SZ\n+\t;;\n+\tstfd\t[r14]=f12,2*FLOAT_SZ\n+\tstfd\t[r15]=f13,2*FLOAT_SZ\n+\t;;\n+\tstfd\t[r14]=f14,FLOAT_SZ+8\n+\tstfd\t[r15]=f15,2*8\n+\t;;\n+\t/* r14 points to first parameter register area, r15 to second. */\n+\tst8\t[r14]=in0,2*8\n+\tst8\t[r15]=in1,2*8\n+\t;;\n+\tst8\t[r14]=in2,2*8\n+\tst8\t[r15]=in3,2*8\n+\t;;\n+\tst8\t[r14]=in4,2*8\n+\tst8\t[r15]=in5,2*8\n+\t;;\n+\tst8\t[r14]=in6,2*8\n+\tst8\t[r15]=in7,2*8\n+\t/* Call ffi_closure_UNIX_inner */\n+\tmov\tout1=sp\n+\tbr.call.sptk.many b0=ffi_closure_UNIX_inner\n+\t;;\n+\tmov\tb0=loc1\n+\tmov \tar.pfs=loc0\n+\tbr.ret.sptk.many b0\n+\t.endp ffi_closure_UNIX\n+\t\n+"}, {"sha": "5f85582cfde4b3700800839eb2e299503f239d2c", "filename": "libffi/src/java_raw_api.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -0,0 +1,271 @@\n+/* -----------------------------------------------------------------------\n+   java_raw_api.c - Copyright (c) 1999  Cygnus Solutions\n+\n+   Cloned from raw_api.c\n+\n+   Raw_api.c author: Kresten Krab Thorup <krab@gnu.org>\n+   Java_raw_api.c author: Hans-J. Boehm <hboehm@hpl.hp.com>\n+\n+   $Id $\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+/* This defines a Java- and 64-bit specific variant of the raw API.\t*/\n+/* It assumes that \"raw\" argument blocks look like Java stacks on a \t*/\n+/* 64-bit machine.  Arguments that can be stored in a single stack\t*/\n+/* stack slots (longs, doubles) occupy 128 bits, but only the first\t*/\n+/* 64 bits are actually used.  \t\t\t\t\t\t*/\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#if !defined(NO_JAVA_RAW_API) && !defined(FFI_NO_RAW_API)\n+\n+size_t\n+ffi_java_raw_size (ffi_cif *cif)\n+{\n+  size_t result = 0;\n+  int i;\n+\n+  ffi_type **at = cif->arg_types;\n+\n+  for (i = cif->nargs-1; i >= 0; i--, at++)\n+    {\n+      switch((*at) -> type) {\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  result += 2 * SIZEOF_ARG;\n+\t  break;\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* No structure parameters in Java.\t*/\n+\t  abort();\n+\tdefault:\n+\t  result += SIZEOF_ARG;\n+      }\n+    }\n+\n+  return result;\n+}\n+\n+\n+void\n+ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n+{\n+  unsigned i;\n+  ffi_type **tp = cif->arg_types;\n+\n+#if WORDS_BIGENDIAN\n+\n+  for (i = 0; i < cif->nargs; i++, tp++, args++)\n+    {\t  \n+      switch ((*tp)->type)\n+\t{\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT8:\n+\t  *args = (void*) ((char*)(raw++) + SIZEOF_ARG - 1);\n+\t  break;\n+\t  \n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT16:\n+\t  *args = (void*) ((char*)(raw++) + SIZEOF_ARG - 2);\n+\t  break;\n+\n+#if SIZEOF_ARG >= 4\t  \n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\t  *args = (void*) ((char*)(raw++) + SIZEOF_ARG - 4);\n+\t  break;\n+#endif\n+\t\n+#if SIZEOF_ARG == 8\t  \n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_DOUBLE:\n+\t  *args = (void *)raw;\n+\t  raw += 2;\n+\t  break;\n+#endif\n+\n+\tcase FFI_TYPE_POINTER:\n+\t  *args = (void*) &(raw++)->ptr;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  *args = raw;\n+\t  raw += ALIGN ((*tp)->size, SIZEOF_ARG) / SIZEOF_ARG;\n+\t}\n+    }\n+\n+#else /* WORDS_BIGENDIAN */\n+\n+#if !PDP\n+\n+  /* then assume little endian */\n+  for (i = 0; i < cif->nargs; i++, tp++, args++)\n+    {\n+#if SIZEOF_ARG == 8\n+      switch((*tp)->type) {\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_DOUBLE:\n+\t  *args = (void*) raw;\n+\t  raw += 2;\n+\t  break;\n+\tdefault:\n+\t  *args = (void*) raw++;\n+      }\n+#else /* SIZEOF_ARG != 8 */\n+\t*args = (void*) raw;\n+\traw += ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);\n+#endif /* SIZEOF_ARG == 8 */\n+    }\n+\n+#else\n+#error \"pdp endian not supported\"\n+#endif /* ! PDP */\n+\n+#endif /* WORDS_BIGENDIAN */\n+}\n+\n+void\n+ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n+{\n+  unsigned i;\n+  ffi_type **tp = cif->arg_types;\n+\n+  for (i = 0; i < cif->nargs; i++, tp++, args++)\n+    {\t  \n+      switch ((*tp)->type)\n+\t{\n+\tcase FFI_TYPE_UINT8:\n+\t  (raw++)->uint = *(UINT8*) (*args);\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT8:\n+\t  (raw++)->sint = *(SINT8*) (*args);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT16:\n+\t  (raw++)->uint = *(UINT16*) (*args);\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT16:\n+\t  (raw++)->sint = *(SINT16*) (*args);\n+\t  break;\n+\n+#if SIZEOF_ARG >= 4\n+\tcase FFI_TYPE_UINT32:\n+\t  (raw++)->uint = *(UINT32*) (*args);\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT32:\n+\t  (raw++)->sint = *(SINT32*) (*args);\n+\t  break;\n+#endif\n+        case FFI_TYPE_FLOAT:\n+\t  (raw++)->flt = *(FLOAT32*) (*args);\n+\t  break;\n+\n+#if SIZEOF_ARG == 8\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_DOUBLE:\n+\t  raw->uint = *(UINT64*) (*args);\n+\t  raw += 2;\n+\t  break;\n+#endif\n+\n+\tcase FFI_TYPE_POINTER:\n+\t  (raw++)->ptr = **(void***) args;\n+\t  break;\n+\n+\tdefault:\n+#if SIZEOF_ARG == 8\n+\t  FFI_ASSERT(FALSE);\t/* Should have covered all cases */\n+#else\t\n+\t  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);\n+\t  raw += ALIGN ((*tp)->size, SIZEOF_ARG) / SIZEOF_ARG;\n+#endif\n+\t}\n+    }\n+}\n+\n+#if !FFI_NATIVE_RAW_API\n+\n+\n+/* This is a generic definition of ffi_raw_call, to be used if the\n+ * native system does not provide a machine-specific implementation.\n+ * Having this, allows code to be written for the raw API, without\n+ * the need for system-specific code to handle input in that format;\n+ * these following couple of functions will handle the translation forth\n+ * and back automatically. */\n+\n+void ffi_java_raw_call (/*@dependent@*/ ffi_cif *cif, \n+\t\t   void (*fn)(), \n+\t\t   /*@out@*/ void *rvalue, \n+\t\t   /*@dependent@*/ ffi_raw *raw)\n+{\n+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n+  ffi_java_raw_to_ptrarray (cif, raw, avalue);\n+  ffi_call (cif, fn, rvalue, avalue);\n+}\n+\n+#if FFI_CLOSURES\t\t/* base system provides closures */\n+\n+static void \n+ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n+\t\t    void **avalue, void *user_data)\n+{\n+  ffi_raw *raw = (ffi_raw*)alloca (ffi_java_raw_size (cif));\n+  ffi_raw_closure *cl = (ffi_raw_closure*)user_data;\n+\n+  ffi_java_ptrarray_to_raw (cif, avalue, raw);\n+  (*cl->fun) (cif, rvalue, raw, cl->user_data);\n+}\n+\n+/* Again, here is the generic version of ffi_prep_raw_closure, which\n+ * will install an intermediate \"hub\" for translation of arguments from\n+ * the pointer-array format, to the raw format */\n+\n+ffi_status\n+ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t      void *user_data)\n+{\n+  ffi_status status;\n+\n+  status = ffi_prep_closure ((ffi_closure*) cl, \n+\t\t\t     cif,\n+\t\t\t     &ffi_java_translate_args,\n+\t\t\t     (void*)cl);\n+  if (status == FFI_OK)\n+    {\n+      cl->fun       = fun;\n+      cl->user_data = user_data;\n+    }\n+\n+  return status;\n+}\n+\n+#endif /* FFI_CLOSURES */\n+#endif /* !FFI_NATIVE_RAW_API */\n+#endif /* !FFI_NO_RAW_API */"}, {"sha": "45cb0043c4d1da360c339456449e80e7b0ac1970", "filename": "libffi/src/raw_api.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fraw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5de37072b855beba90a62056d96ce1bf422c7c/libffi%2Fsrc%2Fraw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fraw_api.c?ref=dc5de37072b855beba90a62056d96ce1bf422c7c", "patch": "@@ -202,13 +202,13 @@ void ffi_raw_call (/*@dependent@*/ ffi_cif *cif,\n #if FFI_CLOSURES\t\t/* base system provides closures */\n \n static void \n-ffi_translate_args (ffi_cif *cif, void *ravlue,\n+ffi_translate_args (ffi_cif *cif, void *rvalue,\n \t\t    void **avalue, void *user_data)\n {\n   ffi_raw *raw = (ffi_raw*)alloca (ffi_raw_size (cif));\n-  ffi_ptrarray_to_raw (cif, avalue, raw);\n-\n   ffi_raw_closure *cl = (ffi_raw_closure*)user_data;\n+\n+  ffi_ptrarray_to_raw (cif, avalue, raw);\n   (*cl->fun) (cif, rvalue, raw, cl->user_data);\n }\n \n@@ -226,7 +226,7 @@ ffi_prep_raw_closure (ffi_raw_closure* cl,\n \n   status = ffi_prep_closure ((ffi_closure*) cl, \n \t\t\t     cif,\n-\t\t\t     &ffi_closure_translate,\n+\t\t\t     &ffi_translate_args,\n \t\t\t     (void*)cl);\n   if (status == FFI_OK)\n     {"}]}