{"sha": "30fdaead5b7880c4e9f140618e26ad1c545642d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmZGFlYWQ1Yjc4ODBjNGU5ZjE0MDYxOGUyNmFkMWM1NDU2NDJkNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-08T11:50:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-08T15:15:36Z"}, "message": "compute and check alignment info during analysis\n\nThis moves querying the alignment support scheme from load/store\ntransform time to get_load_store_type where we should know best\nwhat alignment constraints we actually need.  This should make\nverify_data_ref_alignment obsolete which prematurely disqualifies\nall vectorization IMHO.\n\n2020-07-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-stmts.c (get_group_load_store_type): Pass\n\tin the SLP node and the alignment support scheme output.\n\tSet that.\n\t(get_load_store_type): Likewise.\n\t(vectorizable_store): Adjust.\n\t(vectorizable_load): Likewise.", "tree": {"sha": "5580076a4b94e73d1e1900c57832d976f8200e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5580076a4b94e73d1e1900c57832d976f8200e25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30fdaead5b7880c4e9f140618e26ad1c545642d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30fdaead5b7880c4e9f140618e26ad1c545642d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30fdaead5b7880c4e9f140618e26ad1c545642d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30fdaead5b7880c4e9f140618e26ad1c545642d5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cb1b7276d0dad50678ac80a416e748e3d0a6ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb1b7276d0dad50678ac80a416e748e3d0a6ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb1b7276d0dad50678ac80a416e748e3d0a6ff2"}], "stats": {"total": 72, "additions": 50, "deletions": 22}, "files": [{"sha": "cec5c6012688226c8345c6ec2885c78e57d1fbe0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30fdaead5b7880c4e9f140618e26ad1c545642d5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30fdaead5b7880c4e9f140618e26ad1c545642d5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=30fdaead5b7880c4e9f140618e26ad1c545642d5", "patch": "@@ -2058,9 +2058,10 @@ vector_vector_composition_type (tree vtype, poly_uint64 nelts, tree *ptype)\n \n static bool\n get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n-\t\t\t   tree vectype, bool slp,\n+\t\t\t   tree vectype, slp_tree slp_node,\n \t\t\t   bool masked_p, vec_load_store_type vls_type,\n \t\t\t   vect_memory_access_type *memory_access_type,\n+\t\t\t   dr_alignment_support *alignment_support_scheme,\n \t\t\t   gather_scatter_info *gs_info)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n@@ -2089,10 +2090,15 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n   gcc_assert (!STMT_VINFO_STRIDED_P (first_stmt_info) || gap == 0);\n \n   /* Stores can't yet have gaps.  */\n-  gcc_assert (slp || vls_type == VLS_LOAD || gap == 0);\n+  gcc_assert (slp_node || vls_type == VLS_LOAD || gap == 0);\n \n-  if (slp)\n+  if (slp_node)\n     {\n+      /* For SLP vectorization we directly vectorize a subchain\n+\t without permutation.  */\n+      if (! SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n+\tfirst_dr_info\n+\t  = STMT_VINFO_DR_INFO (SLP_TREE_SCALAR_STMTS (slp_node)[0]);\n       if (STMT_VINFO_STRIDED_P (first_stmt_info))\n \t{\n \t  /* Try to use consecutive accesses of DR_GROUP_SIZE elements,\n@@ -2232,6 +2238,13 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t*memory_access_type = VMAT_GATHER_SCATTER;\n     }\n \n+  if (*memory_access_type == VMAT_GATHER_SCATTER\n+      || *memory_access_type == VMAT_ELEMENTWISE)\n+    *alignment_support_scheme = dr_unaligned_supported;\n+  else\n+    *alignment_support_scheme\n+      = vect_supportable_dr_alignment (vinfo, first_dr_info, false);\n+\n   if (vls_type != VLS_LOAD && first_stmt_info == stmt_info)\n     {\n       /* STMT is the leader of the group. Check the operands of all the\n@@ -2268,7 +2281,9 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n /* Analyze load or store statement STMT_INFO of type VLS_TYPE.  Return true\n    if there is a memory access type that the vectorized form can use,\n    storing it in *MEMORY_ACCESS_TYPE if so.  If we decide to use gathers\n-   or scatters, fill in GS_INFO accordingly.\n+   or scatters, fill in GS_INFO accordingly.  In addition\n+   *ALIGNMENT_SUPPORT_SCHEME is filled out and false is returned if\n+   the target does not support the alignment scheme.\n \n    SLP says whether we're performing SLP rather than loop vectorization.\n    MASKED_P is true if the statement is conditional on a vectorized mask.\n@@ -2277,10 +2292,11 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \n static bool\n get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n-\t\t     tree vectype, bool slp,\n+\t\t     tree vectype, slp_tree slp_node,\n \t\t     bool masked_p, vec_load_store_type vls_type,\n \t\t     unsigned int ncopies,\n \t\t     vect_memory_access_type *memory_access_type,\n+\t\t     dr_alignment_support *alignment_support_scheme,\n \t\t     gather_scatter_info *gs_info)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n@@ -2300,22 +2316,29 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t\t\t     vls_type == VLS_LOAD ? \"gather\" : \"scatter\");\n \t  return false;\n \t}\n+      /* Gather-scatter accesses perform only component accesses, alignment\n+\t is irrelevant for them.  */\n+      *alignment_support_scheme = dr_unaligned_supported;\n     }\n   else if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n-      if (!get_group_load_store_type (vinfo, stmt_info, vectype, slp, masked_p,\n-\t\t\t\t      vls_type, memory_access_type, gs_info))\n+      if (!get_group_load_store_type (vinfo, stmt_info, vectype, slp_node,\n+\t\t\t\t      masked_p,\n+\t\t\t\t      vls_type, memory_access_type,\n+\t\t\t\t      alignment_support_scheme, gs_info))\n \treturn false;\n     }\n   else if (STMT_VINFO_STRIDED_P (stmt_info))\n     {\n-      gcc_assert (!slp);\n+      gcc_assert (!slp_node);\n       if (loop_vinfo\n \t  && vect_use_strided_gather_scatters_p (stmt_info, loop_vinfo,\n \t\t\t\t\t\t masked_p, gs_info))\n \t*memory_access_type = VMAT_GATHER_SCATTER;\n       else\n \t*memory_access_type = VMAT_ELEMENTWISE;\n+      /* Alignment is irrelevant here.  */\n+      *alignment_support_scheme = dr_unaligned_supported;\n     }\n   else\n     {\n@@ -2330,6 +2353,9 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t}\n       else\n \t*memory_access_type = VMAT_CONTIGUOUS;\n+      *alignment_support_scheme\n+\t= vect_supportable_dr_alignment (vinfo,\n+\t\t\t\t\t STMT_VINFO_DR_INFO (stmt_info), false);\n     }\n \n   if ((*memory_access_type == VMAT_ELEMENTWISE\n@@ -2343,6 +2369,14 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n       return false;\n     }\n \n+  if (*alignment_support_scheme == dr_unaligned_unsupported)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"unsupported unaligned access\\n\");\n+      return false;\n+    }\n+\n   /* FIXME: At the moment the cost model seems to underestimate the\n      cost of using elementwise accesses.  This check preserves the\n      traditional behavior until that can be fixed.  */\n@@ -6956,7 +6990,6 @@ vectorizable_store (vec_info *vinfo,\n   class loop *loop = NULL;\n   machine_mode vec_mode;\n   tree dummy;\n-  enum dr_alignment_support alignment_support_scheme;\n   enum vect_def_type rhs_dt = vect_unknown_def_type;\n   enum vect_def_type mask_dt = vect_unknown_def_type;\n   tree dataref_ptr = NULL_TREE;\n@@ -7080,8 +7113,10 @@ vectorizable_store (vec_info *vinfo,\n     return false;\n \n   vect_memory_access_type memory_access_type;\n-  if (!get_load_store_type (vinfo, stmt_info, vectype, slp, mask, vls_type,\n-\t\t\t    ncopies, &memory_access_type, &gs_info))\n+  enum dr_alignment_support alignment_support_scheme;\n+  if (!get_load_store_type (vinfo, stmt_info, vectype, slp_node, mask, vls_type,\n+\t\t\t    ncopies, &memory_access_type,\n+\t\t\t    &alignment_support_scheme, &gs_info))\n     return false;\n \n   if (mask)\n@@ -8176,7 +8211,6 @@ vectorizable_load (vec_info *vinfo,\n   tree new_temp;\n   machine_mode mode;\n   tree dummy;\n-  enum dr_alignment_support alignment_support_scheme;\n   tree dataref_ptr = NULL_TREE;\n   tree dataref_offset = NULL_TREE;\n   gimple *ptr_incr = NULL;\n@@ -8404,8 +8438,10 @@ vectorizable_load (vec_info *vinfo,\n     group_size = 1;\n \n   vect_memory_access_type memory_access_type;\n-  if (!get_load_store_type (vinfo, stmt_info, vectype, slp, mask, VLS_LOAD,\n-\t\t\t    ncopies, &memory_access_type, &gs_info))\n+  enum dr_alignment_support alignment_support_scheme;\n+  if (!get_load_store_type (vinfo, stmt_info, vectype, slp_node, mask, VLS_LOAD,\n+\t\t\t    ncopies, &memory_access_type,\n+\t\t\t    &alignment_support_scheme, &gs_info))\n     return false;\n \n   if (mask)\n@@ -8804,14 +8840,6 @@ vectorizable_load (vec_info *vinfo,\n       ref_type = reference_alias_ptr_type (DR_REF (first_dr_info->dr));\n     }\n \n-  /* Gather-scatter accesses perform only component accesses, alignment\n-     is irrelevant for them.  */\n-  if (memory_access_type == VMAT_GATHER_SCATTER)\n-    alignment_support_scheme = dr_unaligned_supported;\n-  else\n-    alignment_support_scheme\n-      = vect_supportable_dr_alignment (vinfo, first_dr_info, false);\n-\n   gcc_assert (alignment_support_scheme);\n   vec_loop_masks *loop_masks\n     = (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)"}]}