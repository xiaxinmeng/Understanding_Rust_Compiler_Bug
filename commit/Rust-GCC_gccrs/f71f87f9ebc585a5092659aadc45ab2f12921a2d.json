{"sha": "f71f87f9ebc585a5092659aadc45ab2f12921a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxZjg3ZjllYmM1ODVhNTA5MjY1OWFhZGM0NWFiMmYxMjkyMWEyZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-03T01:37:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-03T01:37:47Z"}, "message": "invoke.texi (-fdump-translation-unit): New option.\n\n\t* invoke.texi (-fdump-translation-unit): New option.\n\t* Make-lang.in (CXX_SRCS): Add dump.c.\n\t* Makefile.in (CXX_OBJS): Add dump.o.\n\t(dump.o): New target.\n\t* cp-tree.h (DECL_CONV_FN_P): Document.\n\t(DECL_OVERLOADED_OPERATOR_P): New function.\n\t(TYPE_PTRMEM_CLASS_TYPE): New macro.\n\t(TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n\t(PTRMEM_CST_CLASS): Use TYPE_PTRMEM_CLASS_TYPE.\n\t(ASM_VOLATILE_P): New macro.\n\t(STMT_LINENO): Likewise.\n\t(cp_namespace_decls): New function.\n\t(dump_node_to_file): New function.\n\t* decl.c (cp_namespace_decls): New function.\n\t(walk_namespaces_r): Use it.\n\t(wrapup_globals_for_namespace): Likewise.\n\t* decl2.c (flag_dump_translation_unit): New variable.\n\t(lang_decode_option): Handle -fdump-translation-unit.\n\t(finish_file): If flag_dump_translation_unit is set, dump the\n\ttranslation unit.\n\t* dump.c: New file.\n\t* lang-options.h: Add -fdump-translation-unit.\n\t* pt.c (tsubst_template_parms): Robustify.\n\t(tsubst_decl): Use DECL_OVERLOADED_OPERATOR_P.\n\t(tsubst_expr): Use STMT_LINENO.\n\t* semantics.c (finish_asm_stmt): Eliminate duplicate code.  Check\n\tfor invalid cv-qualifiers even while building templates.\n\nFrom-SVN: r28434", "tree": {"sha": "e60e4eb12e074384984174f31e71d89fb02af12b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e60e4eb12e074384984174f31e71d89fb02af12b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f71f87f9ebc585a5092659aadc45ab2f12921a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71f87f9ebc585a5092659aadc45ab2f12921a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71f87f9ebc585a5092659aadc45ab2f12921a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71f87f9ebc585a5092659aadc45ab2f12921a2d/comments", "author": null, "committer": null, "parents": [{"sha": "246833ac171aa132fee598a93a86a819c6eaf4f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246833ac171aa132fee598a93a86a819c6eaf4f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246833ac171aa132fee598a93a86a819c6eaf4f4"}], "stats": {"total": 1041, "additions": 995, "deletions": 46}, "files": [{"sha": "6baa3338a6653ba0ee0c179f4c2e8d883f5f4801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -1,3 +1,7 @@\n+Mon Aug  2 18:29:32 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* invoke.texi (-fdump-translation-unit): New option.\n+\n Mon Aug  2 17:10:24 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* toplev.h (errorcount): Declare."}, {"sha": "886401a2807150b16340426f48c8af415eb94fce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -1,3 +1,32 @@\n+1999-08-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (CXX_SRCS): Add dump.c.\n+\t* Makefile.in (CXX_OBJS): Add dump.o.\n+\t(dump.o): New target.\n+\t* cp-tree.h (DECL_CONV_FN_P): Document.\n+\t(DECL_OVERLOADED_OPERATOR_P): New function.\n+\t(TYPE_PTRMEM_CLASS_TYPE): New macro.\n+\t(TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n+\t(PTRMEM_CST_CLASS): Use TYPE_PTRMEM_CLASS_TYPE.\n+\t(ASM_VOLATILE_P): New macro.\n+\t(STMT_LINENO): Likewise.\n+\t(cp_namespace_decls): New function.\n+\t(dump_node_to_file): New function.\n+\t* decl.c (cp_namespace_decls): New function.\n+\t(walk_namespaces_r): Use it.\n+\t(wrapup_globals_for_namespace): Likewise.\n+\t* decl2.c (flag_dump_translation_unit): New variable.\n+\t(lang_decode_option): Handle -fdump-translation-unit.\n+\t(finish_file): If flag_dump_translation_unit is set, dump the\n+\ttranslation unit.\n+\t* dump.c: New file.\n+\t* lang-options.h: Add -fdump-translation-unit.\n+\t* pt.c (tsubst_template_parms): Robustify.\n+\t(tsubst_decl): Use DECL_OVERLOADED_OPERATOR_P.\n+\t(tsubst_expr): Use STMT_LINENO.\n+\t* semantics.c (finish_asm_stmt): Eliminate duplicate code.  Check\n+\tfor invalid cv-qualifiers even while building templates.\n+\t\n 1999-08-02  Richard Henderson  <rth@cygnus.com>\n \n \t* call.c: Include defaults.h instead of expr.h."}, {"sha": "2e681b8194aea5dd019c06a4b74894146df78a55", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -117,7 +117,8 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n  $(srcdir)/cp/parse.y $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c \\\n- $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c\n+ $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c \\\n+ $(srcdir)/cp/dump.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n \t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def $(srcdir)/cp/gxx.gperf hash.o"}, {"sha": "63f858093805cbe203dae6a662e6a8440e3656a7", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -188,7 +188,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n  except.o friend.o init.o method.o search.o semantics.o tree.o xref.o \\\n- repo.o @extra_cxx_objs@\n+ repo.o dump.o @extra_cxx_objs@\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -306,7 +306,7 @@ repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n semantics.o: semantics.c $(CONFIG_H) $(CXX_TREE_H) lex.h \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-  \n+dump.o: dump.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n \n #\f\n # These exist for maintenance purposes."}, {"sha": "c5af6fdc736118f039c0e4cf93f7a86ddb699515", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -315,7 +315,8 @@ struct tree_srcloc\n \n #define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1(NODE)\n \n-/* Nonzero if this identifier is the prefix for a mangled C++ operator name.  */\n+/* Nonzero if this identifier is the prefix for a mangled C++ operator\n+   name.  */\n #define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2(NODE)\n \n /* Nonzero if this identifier is the name of a type-conversion\n@@ -1296,9 +1297,14 @@ struct lang_decl\n   (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (NODE))\t\\\n    && DECL_LANGUAGE (NODE) == lang_cplusplus)\n \n+/* Non-zero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE)\t\t\t\t\t\t     \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)) && TREE_TYPE (DECL_NAME (NODE)))\n \n+/* Non-zero if NODE is an overloaded operator.  */\n+#define DECL_OVERLOADED_OPERATOR_P(NODE)\t\\\n+  (IDENTIFIER_OPNAME_P (DECL_NAME ((NODE))))\n+\n /* For FUNCTION_DECLs: nonzero means that this function is a constructor\n    for an object with virtual baseclasses.  */\n #define DECL_CONSTRUCTOR_FOR_VBASE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_for_vbase_attr)\n@@ -1857,12 +1863,22 @@ extern int flag_new_for_scope;\n #define DELTA2_FROM_PTRMEMFUNC(NODE) delta2_from_ptrmemfunc ((NODE))\n #define PFN_FROM_PTRMEMFUNC(NODE) pfn_from_ptrmemfunc ((NODE))\n \n+/* For a pointer-to-member type of the form `T X::*', this is `X'.  */\n+#define TYPE_PTRMEM_CLASS_TYPE(NODE)\t\t\t\\\n+  (TYPE_PTRMEM_P ((NODE))\t\t\t\t\\\n+   ? TYPE_OFFSET_BASETYPE (TREE_TYPE ((NODE)))\t\t\\\n+   : TYPE_PTRMEMFUNC_OBJECT_TYPE ((NODE)))\n+\n+/* For a pointer-to-member type of the form `T X::*', this is `T'.  */\n+#define TYPE_PTRMEM_POINTED_TO_TYPE(NODE)\t\t\\\n+   (TYPE_PTRMEM_P ((NODE))\t\t\t\t\\\n+    ? TREE_TYPE (TREE_TYPE (NODE))\t\t\t\\\n+    : TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE ((NODE))))\n+\n /* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n    `X'.  */\n-#define PTRMEM_CST_CLASS(NODE)\t\t\t\t  \\\n-   (TYPE_PTRMEM_P (TREE_TYPE (NODE)) \t\t\t  \\\n-    ? TYPE_OFFSET_BASETYPE (TREE_TYPE (TREE_TYPE (NODE))) \\\n-    : TYPE_PTRMEMFUNC_OBJECT_TYPE (TREE_TYPE (NODE)))\n+#define PTRMEM_CST_CLASS(NODE) \\\n+  TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (NODE))\n \n /* For a pointer-to-member constant `X::Y' this is the _DECL for \n    `Y'.  */\n@@ -2172,6 +2188,14 @@ extern int flag_new_for_scope;\n #define ASM_INPUTS(NODE)        TREE_OPERAND (NODE, 3)\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n \n+/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n+#define ASM_VOLATILE_P(NODE)\t\t\t\\\n+  (ASM_CV_QUAL ((NODE)) != NULL_TREE)\n+\n+/* The line-number at which a statement began.  */\n+#define STMT_LINENO(NODE)\t\t\t\\\n+  (TREE_COMPLEXITY ((NODE)))\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { record_type, class_type, union_type, enum_type,\n \t\t   signature_type };\n@@ -2990,6 +3014,7 @@ typedef int (*walk_namespaces_fn)               PROTO((tree, void *));\n extern int walk_namespaces                      PROTO((walk_namespaces_fn,\n \t\t\t\t\t\t       void *));\n extern int wrapup_globals_for_namespace         PROTO((tree, void *));\n+extern tree cp_namespace_decls                  PROTO((tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));\n@@ -3604,6 +3629,9 @@ extern void GNU_xref_assign\t\t\tPROTO((tree));\n extern void GNU_xref_hier\t\t\tPROTO((tree, tree, int, int, int));\n extern void GNU_xref_member\t\t\tPROTO((tree, tree));\n \n+/* in dump.c */\n+extern void dump_node_to_file                   PROTO ((tree, char *));\n+\n /* -- end of C++ */\n \n #endif /* not _CP_TREE_H */"}, {"sha": "46708ac1782b1632bdf5293bf97c5d29326e8b08", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -1808,6 +1808,15 @@ sigtable_decl_p (t, data)\n \t  && IS_SIGNATURE (TREE_TYPE (t)));\n }\n \n+/* Return the declarations that are members of the namespace NS.  */\n+\n+tree\n+cp_namespace_decls (ns)\n+     tree ns;\n+{\n+  return NAMESPACE_LEVEL (ns)->names;\n+}\n+\n /* Walk all the namespaces contained NAMESPACE, including NAMESPACE\n    itself, calling F for each.  The DATA is passed to F as well.  */\n \n@@ -1822,7 +1831,7 @@ walk_namespaces_r (namespace, f, data)\n \n   result |= (*f) (namespace, data);\n \n-  for (current = NAMESPACE_LEVEL (namespace)->names;\n+  for (current = cp_namespace_decls (namespace);\n        current;\n        current = TREE_CHAIN (current))\n     {\n@@ -1921,7 +1930,7 @@ wrapup_globals_for_namespace (namespace, data)\n      tree namespace;\n      void *data;\n {\n-  tree globals = NAMESPACE_LEVEL (namespace)->names;\n+  tree globals = cp_namespace_decls (namespace);\n   int len = list_length (globals);\n   tree *vec = (tree *) alloca (sizeof (tree) * len);\n   int i;"}, {"sha": "cbc6c23eb9d498eaecaf488c3b1380c8a94931fd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -246,6 +246,11 @@ int flag_optional_diags = 1;\n \n int flag_const_strings = 1;\n \n+/* If non-NULL, dump the tree structure for the entire translation\n+   unit to this file.  */\n+\n+char *flag_dump_translation_unit = 0;\n+\n /* Nonzero means warn about deprecated conversion from string constant to\n    `char *'.  */\n \n@@ -649,6 +654,13 @@ lang_decode_option (argc, argv)\n \t  name_mangling_version =\n \t  \tread_integral_parameter (p + 22, p - 2, name_mangling_version);\n \t}\n+      else if (!strncmp (p, \"dump-translation-unit-\", 22))\n+\t{\n+\t  if (p[22] == '\\0')\n+\t    error (\"no file specified with -fdump-translation-unit\");\n+\t  else\n+\t    flag_dump_translation_unit = p + 22;\n+\t}\n       else for (j = 0;\n \t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n \t\tj++)\n@@ -3721,6 +3733,11 @@ finish_file ()\n \n   finish_repo ();\n \n+  /* The entire file is now complete.  If requested, dump everything\n+     file.   */\n+  if (flag_dump_translation_unit)\n+    dump_node_to_file (global_namespace, flag_dump_translation_unit);\n+\n   this_time = get_run_time ();\n   parse_time -= this_time - start_time;\n   varconst_time += this_time - start_time;"}, {"sha": "b22565cc7ba4a0ce6e75ea131850f0a505016cc3", "filename": "gcc/cp/dump.c", "status": "added", "additions": 861, "deletions": 0, "changes": 861, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -0,0 +1,861 @@\n+/* Tree-dumping functionality for intermediate representation.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Written by Mark Mitchell <mark@codesourcery.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* TODO: Class types.\n+         Binfos.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"splay-tree.h\"\n+\n+/* Flags used with queue functions.  */\n+#define DUMP_NONE     0\n+#define DUMP_CHILDREN 1\n+#define DUMP_BINFO    2\n+\n+/* Information about a node to be dumped.  */\n+\n+typedef struct dump_node_info\n+{\n+  /* The index for the node.  */\n+  unsigned int index;\n+  /* Nonzero if we should dump the children of the node.  */\n+  unsigned int dump_children_p : 1;\n+  /* Nonzero if the node is a binfo.  */\n+  unsigned int binfo_p : 1;\n+} *dump_node_info_p;\n+\n+/* A dump_queue is a link in the queue of things to be dumped.  */\n+\n+typedef struct dump_queue\n+{\n+  /* The queued tree node.  */\n+  splay_tree_node node;\n+  /* The next node in the queue.  */\n+  struct dump_queue *next;\n+} *dump_queue_p;\n+\n+/* A dump_info gives information about how we should perform the dump \n+   and about the current state of the dump.  */\n+\n+typedef struct dump_info\n+{\n+  /* The stream on which to dump the information.  */\n+  FILE *stream;\n+  /* The next unused node index.  */\n+  unsigned int index;\n+  /* The next column.  */\n+  unsigned int column;\n+  /* The first node in the queue of nodes to be written out.  */\n+  dump_queue_p queue;\n+  /* The last node in the queue.  */\n+  dump_queue_p queue_end;\n+  /* Free queue nodes.  */\n+  dump_queue_p free_list;\n+  /* The tree nodes which we have already written out.  The \n+     keys are the addresses of the nodes; the values are the integer\n+     indices we assigned them.  */\n+  splay_tree nodes;\n+} *dump_info_p;\n+\n+static unsigned int queue PROTO ((dump_info_p, tree, int));\n+static void dump_index PROTO ((dump_info_p, unsigned int));\n+static void queue_and_dump_index PROTO ((dump_info_p, char *, tree, int));\n+static void queue_and_dump_type PROTO ((dump_info_p, tree, int));\n+static void dequeue_and_dump PROTO ((dump_info_p));\n+static void dump_new_line PROTO ((dump_info_p));\n+static void dump_maybe_newline PROTO ((dump_info_p));\n+static void dump_int PROTO ((dump_info_p, char *, int));\n+static void dump_string PROTO ((dump_info_p, char *));\n+static void dump_string_field PROTO ((dump_info_p, char *, char *));\n+static void dump_node PROTO ((tree, FILE *));\n+\n+/* Add T to the end of the queue of nodes to dump.  If DUMP_CHILDREN_P\n+   is non-zero, then its children should be dumped as well.  Returns\n+   the index assigned to T.  */\n+\n+static unsigned int\n+queue (di, t, flags)\n+     dump_info_p di;\n+     tree t;\n+     int flags;\n+{\n+  dump_queue_p dq;\n+  dump_node_info_p dni;\n+  unsigned int index;\n+\n+  /* Assign the next available index to T.  */\n+  index = ++di->index;\n+\n+  /* Obtain a new queue node.  */\n+  if (di->free_list)\n+    {\n+      dq = di->free_list;\n+      di->free_list = dq->next;\n+    }\n+  else\n+    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n+\n+  /* Create a new entry in the splay-tree.  */\n+  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n+  dni->index = index;\n+  dni->dump_children_p = flags & DUMP_CHILDREN;\n+  dni->binfo_p = flags & DUMP_BINFO;\n+  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n+\t\t\t\t(splay_tree_value) dni);\n+\n+  /* Add it to the end of the queue.  */\n+  dq->next = 0;\n+  if (!di->queue_end)\n+    di->queue = dq;\n+  else\n+    di->queue_end->next = dq;\n+  di->queue_end = dq;\n+\n+  /* Return the index.  */\n+  return index;\n+}\n+\n+static void\n+dump_index (di, index)\n+     dump_info_p di;\n+     unsigned int index;\n+{\n+  fprintf (di->stream, \"@%-6u \", index);\n+  di->column += 8;\n+}\n+\n+/* If T has not already been output, queue it for subsequent output.\n+   FIELD is a string to print before printing the index.  Then, the\n+   index of T is printed.  */\n+\n+static void\n+queue_and_dump_index (di, field, t, flags)\n+     dump_info_p di;\n+     char *field;\n+     tree t;\n+     int flags;\n+{\n+  unsigned int index;\n+  splay_tree_node n;\n+\n+  /* If there's no node, just return.  This makes for fewer checks in\n+     our callers.  */\n+  if (!t)\n+    return;\n+\n+  /* See if we've already queued or dumped this node.  */\n+  n = splay_tree_lookup (di->nodes, (splay_tree_key) t);\n+  if (n)\n+    index = ((dump_node_info_p) n->value)->index;\n+  else\n+    /* If we haven't, add it to the queue.  */\n+    index = queue (di, t, flags);\n+\n+  /* Print the index of the node.  */\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: \", field);\n+  di->column += 6;\n+  dump_index (di, index);\n+}\n+\n+/* Dump the type of T.  */\n+\n+static void\n+queue_and_dump_type (di, t, dump_children_p)\n+     dump_info_p di;\n+     tree t;\n+     int dump_children_p;\n+{\n+  queue_and_dump_index (di, \"type\", TREE_TYPE (t), dump_children_p);\n+}\n+\n+/* Insert a new line in the dump output, and indent to an appropriate\n+   place to start printing more fields.  */\n+\n+static void\n+dump_new_line (di)\n+     dump_info_p di;\n+{\n+  fprintf (di->stream, \"\\n%25s\", \"\");\n+  di->column = 25;\n+}\n+\n+/* If necessary, insert a new line.  */\n+\n+static void\n+dump_maybe_newline (di)\n+     dump_info_p di;\n+{\n+  /* See if we need a new line.  */\n+  if (di->column > 53)\n+    dump_new_line (di);\n+  /* See if we need any padding.  */\n+  else if ((di->column - 25) % 14 != 0)\n+    {\n+      fprintf (di->stream, \"%*s\", 14 - ((di->column - 25) % 14), \"\");\n+      di->column += 14 - (di->column - 25) % 14;\n+    }\n+}\n+\n+/* Dump I using FIELD to identity it.  */\n+\n+static void\n+dump_int (di, field, i)\n+     dump_info_p di;\n+     char *field;\n+     int i;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7d \", field, i);\n+  di->column += 14;\n+}\n+\n+/* Dump the string S.  */\n+\n+static void\n+dump_string (di, string)\n+     dump_info_p di;\n+     char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-13s \", string);\n+  if (strlen (string) > 13)\n+    di->column += strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump the string field S.  */\n+\n+static void\n+dump_string_field (di, field, string)\n+     dump_info_p di;\n+     char *field;\n+     char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7s \", field, string);\n+  if (strlen (string) > 7)\n+    di->column += 6 + strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump information common to statements from STMT.  */\n+\n+static void\n+dump_stmt (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  dump_int (di, \"line\", STMT_LINENO (t));\n+}\n+\n+/* Dump the CHILD and its children.  */\n+#define dump_child(field, child) \\\n+  queue_and_dump_index (di, field, child, DUMP_CHILDREN)\n+\n+/* Dump the next node in the queue.  */\n+\n+static void \n+dequeue_and_dump (di)\n+     dump_info_p di;\n+{\n+  dump_queue_p dq;\n+  splay_tree_node stn;\n+  dump_node_info_p dni;\n+  tree t;\n+  unsigned int index;\n+  int dump_children_p;\n+  enum tree_code code;\n+  char code_class;\n+\n+  /* Get the next node from the queue.  */\n+  dq = di->queue;\n+  stn = dq->node;\n+  t = (tree) stn->key;\n+  dni = (dump_node_info_p) stn->value;\n+  index = dni->index;\n+  dump_children_p = dni->dump_children_p;\n+\n+  /* Remove the node from the queue, and put it on the free list.  */\n+  di->queue = dq->next;\n+  if (!di->queue)\n+    di->queue_end = 0;\n+  dq->next = di->free_list;\n+  di->free_list = dq;\n+\n+  /* Print the node index.  */\n+  dump_index (di, index);\n+  /* And the type of node this is.  */\n+  fprintf (di->stream, \"%-16s \", tree_code_name[(int) TREE_CODE (t)]);\n+  di->column = 25;\n+\n+  /* Figure out what kind of node this is.  */\n+  code = TREE_CODE (t);\n+  code_class = TREE_CODE_CLASS (code);\n+\n+  /* Although BINFOs are TREE_VECs, we dump them specially so as to be\n+     more informative.  */\n+  if (dni->binfo_p)\n+    {\n+      if (TREE_VIA_PUBLIC (t))\n+\tdump_string (di, \"pub\");\n+      else if (TREE_VIA_PROTECTED (t))\n+\tdump_string (di, \"prot\");\n+      else if (TREE_VIA_PRIVATE (t))\n+\tdump_string (di, \"priv\");\n+      if (TREE_VIA_VIRTUAL (t))\n+\tdump_string (di, \"virt\");\n+\t    \n+      if (dump_children_p) \n+\t{\n+\t  dump_child (\"type\", BINFO_TYPE (t));\n+\t  dump_child (\"base\", BINFO_BASETYPES (t));\n+\t}\n+\n+      goto done;\n+    }\n+\n+  /* We can knock off a bunch of expression nodes in exactly the same\n+     way.  */\n+  if (IS_EXPR_CODE_CLASS (code_class))\n+    {\n+      /* If we're dumping children, dump them now.  */\n+      if (dump_children_p)\n+\t{\n+\t  queue_and_dump_type (di, t, 1);\n+\n+\t  switch (code_class)\n+\t    {\n+\t    case '1':\n+\t      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t      break;\n+\t      \n+\t    case '2':\n+\t    case '<':\n+\t      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+\t      break;\n+\t      \n+\t    case 'e':\n+\t      /* These nodes are handled explicitly below.  */\n+\t      break;\n+\t      \n+\t    default:\n+\t      my_friendly_abort (19990726);\n+\t    }\n+\t}\n+    }\n+  else if (code_class == 'd')\n+    {\n+      /* All declarations have names.  */\n+      if (DECL_NAME (t))\n+\tdump_child (\"name\", DECL_NAME (t));\n+      /* And types.  */\n+      if (dump_children_p)\n+\t{\n+\t  queue_and_dump_type (di, t, 1);\n+\t  queue_and_dump_index (di, \"scpe\", DECL_CONTEXT (t), 0);\n+\t}\n+      /* And a source position.  */\n+      if (DECL_SOURCE_FILE (t))\n+\t{\n+\t  char *filename = rindex (DECL_SOURCE_FILE (t), '/');\n+\t  if (!filename)\n+\t    filename = DECL_SOURCE_FILE (t);\n+\t  else\n+\t    /* Skip the slash.  */\n+\t    ++filename;\n+\n+\t  dump_maybe_newline (di);\n+\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n+\t\t   DECL_SOURCE_LINE (t));\n+\t  di->column += 6 + strlen (filename) + 8;\n+\t}\n+      /* And any declaration can be compiler-generated.  */\n+      if (DECL_ARTIFICIAL (t))\n+\tdump_string (di, \"artificial\");\n+      if (TREE_CHAIN (t))\n+\tdump_child (\"chan\", TREE_CHAIN (t));\n+    }\n+  else if (code_class == 't')\n+    {\n+      /* All types have qualifiers.  */\n+      int quals = CP_TYPE_QUALS (t);\n+      if (quals != TYPE_UNQUALIFIED)\n+\t{\n+\t  fprintf (di->stream, \"qual: %c%c%c     \",\n+\t\t   (quals & TYPE_QUAL_CONST) ? 'c' : ' ',\n+\t\t   (quals & TYPE_QUAL_VOLATILE) ? 'v' : ' ',\n+\t\t   (quals & TYPE_QUAL_RESTRICT) ? 'r' : ' ');\n+\t  di->column += 14;\n+\t}\n+\n+      /* All types have associated declarations.  */\n+      dump_child (\"name\", TYPE_NAME (t));\n+\n+      if (dump_children_p)\n+\t{\n+\t  /* All types have a main variant.  */\n+\t  if (TYPE_MAIN_VARIANT (t) != t)\n+\t    dump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n+      \n+\t  /* And sizes.  */\n+\t  dump_child (\"size\", TYPE_SIZE (t));\n+\t}\n+\n+      /* All types have alignments.  */\n+      dump_int (di, \"algn\", TYPE_ALIGN (t));\n+    }\n+\n+  /* Now handle the various kinds of nodes.  */\n+  switch (code)\n+    {\n+      int i;\n+\n+    case IDENTIFIER_NODE:\n+      if (IDENTIFIER_OPNAME_P (t))\n+\tdump_string (di, \"operator\");\n+      else if (IDENTIFIER_TYPENAME_P (t))\n+\tqueue_and_dump_index (di, \"tynm\", TREE_TYPE (t), 0);\n+      else if (t == anonymous_namespace_name)\n+\tdump_string (di, \"unnamed\");\n+      else\n+\t{\n+\t  dump_string_field (di, \"strg\", IDENTIFIER_POINTER (t));\n+\t  dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+\t}\n+      break;\n+\n+    case TREE_LIST:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"purp\", TREE_PURPOSE (t));\n+\t  dump_child (\"valu\", TREE_VALUE (t));\n+\t  dump_child (\"chan\", TREE_CHAIN (t));\n+\t}\n+      break;\n+\n+    case TREE_VEC:\n+      dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+      if (dump_children_p)\n+\tfor (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+\t  {\n+\t    char buffer[32];\n+\t    sprintf (buffer, \"%u\", i);\n+\t    queue_and_dump_index (di, buffer, TREE_VEC_ELT (t, i), 1);\n+\t  }\n+      break;\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      if (TREE_UNSIGNED (t))\n+\tdump_string (di, \"unsigned\");\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"min\", TYPE_MIN_VALUE (t));\n+\t  dump_child (\"max\", TYPE_MAX_VALUE (t));\n+\t}\n+\n+      if (code == ENUMERAL_TYPE && dump_children_p)\n+\tdump_child (\"csts\", TYPE_VALUES (t));\n+      break;\n+\n+    case REAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      break;\n+\n+    case POINTER_TYPE:\n+      if (dump_children_p)\n+\t{\n+\t  if (TYPE_PTRMEM_P (t))\n+\t    {\n+\t      dump_string (di, \"ptrmem\");\n+\t      queue_and_dump_index (di, \"ptd\", \n+\t\t\t\t    TYPE_PTRMEM_POINTED_TO_TYPE (t), 1);\n+\t      queue_and_dump_index (di, \"cls\", \n+\t\t\t\t    TYPE_PTRMEM_CLASS_TYPE (t), 1);\n+\t    }\n+\t  else\n+\t    dump_child (\"ptd\", TREE_TYPE (t));\n+\t}\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      if (dump_children_p)\n+\tdump_child (\"refd\", TREE_TYPE (t));\n+      break;\n+\n+    case METHOD_TYPE:\n+      if (dump_children_p)\n+\tdump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n+      /* Fall through.  */\n+\n+    case FUNCTION_TYPE:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"retn\", TREE_TYPE (t));\n+\t  dump_child (\"prms\", TYPE_ARG_TYPES (t));\n+\t}\n+      break;\n+\n+    case ARRAY_TYPE:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"elts\", TREE_TYPE (t));\n+\t  dump_child (\"domn\", TYPE_DOMAIN (t));\n+\t}\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\t{\n+\t  dump_string (di, \"ptrmem\");\n+\t  queue_and_dump_index (di, \"ptd\", \n+\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (t), 1);\n+\t  queue_and_dump_index (di, \"cls\", \n+\t\t\t\tTYPE_PTRMEM_CLASS_TYPE (t), 1);\n+\t}\n+      else\n+\t{\n+\t  if (CLASSTYPE_DECLARED_CLASS (t))\n+\t    dump_string (di, \"class\");\n+\t  else if (TREE_CODE (t) == RECORD_TYPE)\n+\t    dump_string (di, \"struct\");\n+\t  else\n+\t    dump_string (di, \"union\");\n+\n+\t  if (dump_children_p)\n+\t    {\n+\t      dump_child (\"flds\", TYPE_FIELDS (t));\n+\t      dump_child (\"fncs\", TYPE_METHODS (t));\n+\t      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n+\t\t\t\t    DUMP_CHILDREN | DUMP_BINFO);\n+\t    }\n+\t}\n+      break;\n+\n+    case CONST_DECL:\n+      if (dump_children_p)\n+\tdump_child (\"cnst\", DECL_INITIAL (t));\n+      break;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"init\", DECL_INITIAL (t));\n+\t  dump_child (\"size\", DECL_SIZE (t));\n+\t}\n+      dump_int (di, \"algn\", DECL_ALIGN (t));\n+\n+      if (TREE_CODE (t) == FIELD_DECL && dump_children_p)\n+\tdump_child (\"bpos\", DECL_FIELD_BITPOS (t));\n+      break;\n+\n+    case FUNCTION_DECL:\n+      if (dump_children_p)\n+\t{\n+\t  queue_and_dump_index (di, \"scpe\", DECL_REAL_CONTEXT (t), 0);\n+\t  dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n+\t  dump_child (\"args\", DECL_ARGUMENTS (t));\n+\t}\n+      if (TREE_PUBLIC (t))\n+\tdump_string(di, \"extern\");\n+      else\n+\tdump_string (di, \"static\");\n+      if (DECL_FUNCTION_MEMBER_P (t))\n+\tdump_string (di, \"member\");\n+      if (DECL_CONSTRUCTOR_P (t))\n+\tdump_string (di, \"constructor\");\n+      if (DECL_DESTRUCTOR_P (t))\n+\tdump_string (di, \"destructor\");\n+      if (DECL_OVERLOADED_OPERATOR_P (t))\n+\tdump_string (di, \"operator\");\n+      if (DECL_CONV_FN_P (t))\n+\tdump_string (di, \"conversion\");\n+      if (dump_children_p)\n+\tdump_child (\"body\", DECL_INITIAL (t));\n+      break;\n+\n+    case NAMESPACE_DECL:\n+      /* The fake `::std' namespace does not have DECL_LANG_SPECIFIC,\n+\t and therefore many other macros do not work on it.  */\n+      if (t == std_node)\n+\tbreak;\n+      if (dump_children_p)\n+\tdump_child (\"dcls\", cp_namespace_decls (t));\n+      break;\n+\n+    case OVERLOAD:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"crnt\", OVL_CURRENT (t));\n+\t  dump_child (\"chan\", OVL_CHAIN (t));\n+\t}\n+      break;\n+\n+    case ASM_STMT:\n+      dump_stmt (di, t);\n+      if (ASM_VOLATILE_P (t))\n+\tdump_string (di, \"volatile\");\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"strg\", ASM_STRING (t));\n+\t  dump_child (\"outs\", ASM_OUTPUTS (t));\n+\t  dump_child (\"ins\", ASM_INPUTS (t));\n+\t  dump_child (\"clbr\", ASM_CLOBBERS (t));\n+\t}\n+      break;\n+\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      dump_stmt (di, t);\n+      break;\n+\n+    case CASE_LABEL:\n+      /* Note that a case label is not like other statments; there is\n+\t no way to get the line-number of a case label.  */\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"low\", CASE_LOW (t));\n+\t  dump_child (\"high\", CASE_HIGH (t));\n+\t}\n+      break;\n+\n+    case COMPOUND_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"body\", COMPOUND_BODY (t));\n+      break;\n+\n+    case DECL_STMT:\n+      dump_stmt (di, t);\n+#if 0\n+      /* We do not yet have DECL_STMT_DECL; there are declarators and\n+\t such hanging about in DECL_STMTs.  */\n+      if (dump_children_p)\n+\tdump_child (\"decl\", DECL_STMT_DECL (t));\n+#endif\n+      break;\n+      \n+    case DO_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"body\", DO_BODY (t));\n+\t  dump_child (\"cond\", DO_COND (t));\n+\t}\n+      break;\n+\n+    case EXPR_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"expr\", EXPR_STMT_EXPR (t));\n+      break;\n+\n+    case FOR_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"init\", FOR_INIT_STMT (t));\n+\t  dump_child (\"cond\", FOR_COND (t));\n+\t  dump_child (\"expr\", FOR_EXPR (t));\n+\t  dump_child (\"body\", FOR_BODY (t));\n+\t}\n+      break;\n+\n+    case GOTO_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"dest\", GOTO_DESTINATION (t));\n+      break;\n+\n+    case IF_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"cond\", IF_COND (t));\n+\t  dump_child (\"then\", THEN_CLAUSE (t));\n+\t  dump_child (\"else\", ELSE_CLAUSE (t));\n+\t}\n+      break;\n+\n+    case RETURN_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"expr\", RETURN_EXPR (t));\n+      break;\n+\n+    case SWITCH_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"cond\", SWITCH_COND (t));\n+\t  dump_child (\"body\", SWITCH_BODY (t));\n+\t}\n+      break;\n+\n+    case TRY_BLOCK:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"body\", TRY_STMTS (t));\n+\t  dump_child (\"hdlr\", TRY_HANDLERS (t));\n+\t}\n+      break;\n+\n+    case WHILE_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"cond\", WHILE_COND (t));\n+\t  dump_child (\"body\", WHILE_BODY (t));\n+\t}\n+      break;\n+\n+    case INTEGER_CST:\n+      if (TREE_INT_CST_HIGH (t))\n+\tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n+      dump_int (di, \"low\", TREE_INT_CST_LOW (t));\n+      break;\n+\n+    case STRING_CST:\n+      fprintf (di->stream, \"strg: %-7s \", TREE_STRING_POINTER (t));\n+      dump_int (di, \"lngt\", TREE_STRING_LENGTH (t));\n+      break;\n+\n+    case PTRMEM_CST:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n+\t  dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n+\t}\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case THROW_EXPR:\n+      /* These nodes are unary, but do not have code class `1'.  */\n+      if (dump_children_p)\n+\tdump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case MODIFY_EXPR:\n+    case COMPONENT_REF:\n+    case COMPOUND_EXPR:\n+    case COND_EXPR:\n+      /* These nodes are binary, but do not have code class `2'.  */\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+\t}\n+      break;\n+\n+    case CALL_EXPR:\n+      if (dump_children_p)\n+\t{\n+\t  dump_child (\"fn\", TREE_OPERAND (t, 0));\n+\t  dump_child (\"args\", TREE_OPERAND (t, 1));\n+\t}\n+      break;\n+\n+    case CONSTRUCTOR:\n+      if (dump_children_p)\n+\tdump_child (\"elts\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    default:\n+      /* There are no additional fields to print.  */\n+      break;\n+    }\n+\n+ done:\n+  /* Terminate the line.  */\n+  fprintf (di->stream, \"\\n\");\n+}\n+\n+/* Dump T, and all its children, on STREAM.  */\n+\n+static void\n+dump_node (t, stream)\n+     tree t;\n+     FILE *stream;\n+{\n+  struct dump_info di;\n+  dump_queue_p dq;\n+  dump_queue_p next_dq;\n+\n+  /* Initialize the dump-information structure.  */\n+  di.stream = stream;\n+  di.index = 0;\n+  di.column = 0;\n+  di.queue = 0;\n+  di.queue_end = 0;\n+  di.free_list = 0;\n+  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n+\t\t\t     (splay_tree_delete_value_fn) &free);\n+\n+  /* Queue up the first node.  */\n+  queue (&di, t, DUMP_CHILDREN);\n+\n+  /* Until the queue is empty, keep dumping nodes.  */\n+  while (di.queue)\n+    dequeue_and_dump (&di);\n+\n+  /* Now, clean up.  */\n+  for (dq = di.free_list; dq; dq = next_dq)\n+    {\n+      next_dq = dq->next;\n+      free (dq);\n+    }\n+  splay_tree_delete (di.nodes);\n+}\n+\n+/* Dump T, and all its children, to FILE.  */\n+\n+void\n+dump_node_to_file (t, file)\n+     tree t;\n+     char *file;\n+{\n+  FILE *f;\n+\n+  f = fopen (file, \"w\");\n+  if (!f)\n+    cp_error (\"could not open `%s'\", file);\n+  else\n+    {\n+      dump_node (t, f);\n+      fclose (f);\n+    }\n+}"}, {"sha": "e9199656667312cbb3aaf85207f36540b8f9b068", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -38,6 +38,7 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fconst-strings\", \"\" },\n   { \"-fno-const-strings\", \"Make string literals `char[]' instead of `const char[]'\" },\n   { \"-fdefault-inline\", \"\" },\n+  { \"-fdump-translation-unit-\", \"Dump the entire translation unit to a file\"},\n   { \"-fno-default-inline\", \"Do not inline member functions by default\"},\n   { \"-frtti\", \"\" },\n   { \"-fno-rtti\", \"Do not generate run time type descriptor information\" },"}, {"sha": "4e9b4120040e31cd2db9149cde6dbc7230e59a57", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -5307,8 +5307,8 @@ tsubst_template_parms (parms, args, complain)\n      tree args;\n      int complain;\n {\n-  tree r;\n-  tree* new_parms = &r;\n+  tree r = NULL_TREE;\n+  tree* new_parms;\n \n   for (new_parms = &r;\n        TMPL_PARMS_DEPTH (parms) > TMPL_ARGS_DEPTH (args);\n@@ -5822,7 +5822,7 @@ tsubst_decl (t, args, type, in_decl)\n \t    maybe_retrofit_in_chrg (r);\n \t    grok_ctor_properties (ctx, r);\n \t  }\n-\tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n+\telse if (DECL_OVERLOADED_OPERATOR_P (r))\n \t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n       }\n       break;\n@@ -7077,13 +7077,13 @@ tsubst_expr (t, args, complain, in_decl)\n   switch (TREE_CODE (t))\n     {\n     case RETURN_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       finish_return_stmt (tsubst_expr (RETURN_EXPR (t),\n \t\t\t\t       args, complain, in_decl));\n       break;\n \n     case EXPR_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       finish_expr_stmt (tsubst_expr (EXPR_STMT_EXPR (t),\n \t\t\t\t     args, complain, in_decl));\n       break;\n@@ -7093,7 +7093,7 @@ tsubst_expr (t, args, complain, in_decl)\n \tint i = suspend_momentary ();\n \ttree dcl, init;\n \n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \temit_line_note (input_filename, lineno);\n \tdcl = start_decl\n \t  (tsubst (TREE_OPERAND (t, 0), args, complain, in_decl),\n@@ -7109,7 +7109,7 @@ tsubst_expr (t, args, complain, in_decl)\n     case FOR_STMT:\n       {\n \ttree tmp;\n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \n \tbegin_for_stmt ();\n \tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n@@ -7127,7 +7127,7 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case WHILE_STMT:\n       {\n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \tbegin_while_stmt ();\n \tfinish_while_stmt_cond (tsubst_expr (WHILE_COND (t),\n \t\t\t\t\t     args, complain, in_decl),\n@@ -7139,7 +7139,7 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case DO_STMT:\n       {\n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \tbegin_do_stmt ();\n \ttsubst_expr (DO_BODY (t), args, complain, in_decl);\n \tfinish_do_body (NULL_TREE);\n@@ -7153,7 +7153,7 @@ tsubst_expr (t, args, complain, in_decl)\n       {\n \ttree tmp;\n \n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \tbegin_if_stmt ();\n \tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n \t\t\t\t\t  args, complain, in_decl),\n@@ -7180,7 +7180,7 @@ tsubst_expr (t, args, complain, in_decl)\n       {\n \ttree substmt;\n \n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \tbegin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n \tfor (substmt = COMPOUND_BODY (t); \n \t     substmt != NULL_TREE;\n@@ -7192,20 +7192,20 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case BREAK_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       finish_break_stmt ();\n       break;\n \n     case CONTINUE_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       finish_continue_stmt ();\n       break;\n \n     case SWITCH_STMT:\n       {\n \ttree val, tmp;\n \n-\tlineno = TREE_COMPLEXITY (t);\n+\tlineno = STMT_LINENO (t);\n \tbegin_switch_stmt ();\n \tval = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n \tfinish_switch_cond (val);\n@@ -7230,7 +7230,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case GOTO_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       t = GOTO_DESTINATION (t);\n       if (TREE_CODE (t) != IDENTIFIER_NODE)\n \t/* Computed goto's must be tsubst'd into.  On the other hand,\n@@ -7241,7 +7241,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case ASM_STMT:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       finish_asm_stmt (ASM_CV_QUAL (t),\n \t\t       tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n \t\t       tsubst_expr (ASM_OUTPUTS (t), args, complain, in_decl),\n@@ -7251,7 +7251,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case TRY_BLOCK:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       begin_try_block ();\n       tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n       finish_try_block (NULL_TREE);\n@@ -7264,7 +7264,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case HANDLER:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       begin_handler ();\n       if (HANDLER_PARMS (t))\n \t{\n@@ -7281,7 +7281,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case TAG_DEFN:\n-      lineno = TREE_COMPLEXITY (t);\n+      lineno = STMT_LINENO (t);\n       t = TREE_TYPE (t);\n       if (TREE_CODE (t) == ENUMERAL_TYPE)\n \ttsubst (t, args, complain, NULL_TREE);"}, {"sha": "18575ee1d475f5d78c1577220be4f810accf9ea3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -741,6 +741,14 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \tpop_obstacks ();\n     }\n \n+  if (cv_qualifier != NULL_TREE\n+      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n+    {\n+      cp_warning (\"%s qualifier ignored on asm\",\n+\t\t  IDENTIFIER_POINTER (cv_qualifier));\n+      cv_qualifier = NULL_TREE;\n+    }\n+\n   if (processing_template_decl)\n     {\n       tree r = build_min_nt (ASM_STMT, cv_qualifier, string,\n@@ -756,30 +764,17 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \t{\n \t  tree t;\n \n-\t  if (cv_qualifier != NULL_TREE\n-\t      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n-\t    cp_warning (\"%s qualifier ignored on asm\",\n-\t\t\tIDENTIFIER_POINTER (cv_qualifier));\n-\n \t  for (t = input_operands; t; t = TREE_CHAIN (t))\n \t    TREE_VALUE (t) = decay_conversion (TREE_VALUE (t));\n \n \t  c_expand_asm_operands (string, output_operands,\n \t\t\t\t input_operands, \n \t\t\t\t clobbers,\n-\t\t\t\t cv_qualifier \n-\t\t\t\t == ridpointers[(int) RID_VOLATILE],\n+\t\t\t\t cv_qualifier != NULL_TREE,\n \t\t\t\t input_filename, lineno);\n \t}\n       else\n-\t{\n-\t  /* Don't warn about redundant specification of 'volatile' here.  */\n-\t  if (cv_qualifier != NULL_TREE\n-\t      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n-\t    cp_warning (\"%s qualifier ignored on asm\",\n-\t\t\tIDENTIFIER_POINTER (cv_qualifier));\n-\t  expand_asm (string);\n-\t}\n+\texpand_asm (string);\n       \n       finish_stmt ();\n     }"}, {"sha": "69be85b7837dc526b41aa5270426af935a0bb100", "filename": "gcc/invoke.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f71f87f9ebc585a5092659aadc45ab2f12921a2d/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=f71f87f9ebc585a5092659aadc45ab2f12921a2d", "patch": "@@ -139,8 +139,8 @@ in the following sections.\n @item Debugging Options\n @xref{Debugging Options,,Options for Debugging Your Program or GCC}.\n @smallexample\n--a  -ax  -d@var{letters}  -fdump-unnumbered -fpretend-float\n--fprofile-arcs  -ftest-coverage\n+-a  -ax  -d@var{letters}  -fdump-unnumbered -fdump-translation-unit-@var{file}\n+-fpretend-float -fprofile-arcs  -ftest-coverage\n -g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-1  -gdwarf-1+  -gdwarf-2\n -ggdb  -gstabs  -gstabs+  -gxcoff  -gxcoff+\n -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name\n@@ -2120,6 +2120,10 @@ numbers and line number note output.  This makes it more feasible to\n use diff on debugging dumps for compiler invokations with different\n options, in particular with and without -g.\n \n+@item -fdump-translation-unit-@var{file} (C++ only)\n+Dump a representation of the tree structure for the entire translation\n+unit to @var{file}.\n+\n @item -fpretend-float\n When running a cross-compiler, pretend that the target machine uses the\n same floating point format as the host machine.  This causes incorrect"}]}