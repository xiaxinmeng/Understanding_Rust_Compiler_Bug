{"sha": "6adb4e3a29c612cc99a26a54364917e3a1709e8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkYjRlM2EyOWM2MTJjYzk5YTI2YTU0MzY0OTE3ZTNhMTcwOWU4Yw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-23T20:03:47Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-07-23T20:03:47Z"}, "message": "install EH code\n\nFrom-SVN: r12549", "tree": {"sha": "d1acdc1258bb390e198f2a31596603f8e267eacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1acdc1258bb390e198f2a31596603f8e267eacf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6adb4e3a29c612cc99a26a54364917e3a1709e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adb4e3a29c612cc99a26a54364917e3a1709e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6adb4e3a29c612cc99a26a54364917e3a1709e8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adb4e3a29c612cc99a26a54364917e3a1709e8c/comments", "author": null, "committer": null, "parents": [{"sha": "3d1953912dca5809d9e37fccd9ee606d5b637dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d1953912dca5809d9e37fccd9ee606d5b637dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d1953912dca5809d9e37fccd9ee606d5b637dc4"}], "stats": {"total": 219, "additions": 179, "deletions": 40}, "files": [{"sha": "47bee4943db2a8ded5bf5390e89eb0c6fd89e9ca", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -127,6 +127,14 @@ struct function\n   int emit_lineno;\n   struct goto_fixup *goto_fixup_chain;\n \n+  /* For exception handling information.  */\n+  struct eh_stack ehstack;\n+  struct eh_queue ehqueue;\n+  rtx catch_clauses;\n+  struct label_node *false_label_stack;\n+  struct label_node *caught_return_label_stack;\n+  tree protect_list;\n+\n   /* For expr.c.  */\n   int pending_stack_adjust;\n   int inhibit_defer_pop;"}, {"sha": "f1e778a81d8033dab86ef37ee181c10be4d8b2a7", "filename": "gcc/integrate.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"integrate.h\"\n #include \"real.h\"\n+#include \"except.h\"\n #include \"function.h\"\n #include \"bytecode.h\"\n \n@@ -170,6 +171,19 @@ function_cannot_inline_p (fndecl)\n   if (current_function_has_nonlocal_goto)\n     return \"function with nonlocal goto cannot be inline\";\n \n+  /* This is a hack, until the inliner is taught about eh regions at\n+     the start of the function.  */\n+  for (insn = get_insns ();\n+       insn &&\n+         ! (GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG);\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (insn && GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\treturn \"function with complex parameters cannot be inline\";\n+    }\n+\n   return 0;\n }\n \f\n@@ -309,6 +323,7 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n      the size of the incoming stack area for parameters,\n      the number of bytes popped on return,\n      the stack slot list,\n+     the labels that are forced to exist,\n      some flags that are used to restore compiler globals,\n      the value of current_function_outgoing_args_size,\n      the original argument vector,\n@@ -335,7 +350,7 @@ finish_inline (fndecl, head)\n      tree fndecl;\n      rtx head;\n {\n-  NEXT_INSN (head) = get_first_nonparm_insn ();\n+  FIRST_FUNCTION_INSN (head) = get_first_nonparm_insn ();\n   FIRST_PARM_INSN (head) = get_insns ();\n   DECL_SAVED_INSNS (fndecl) = head;\n   DECL_FRAME_SIZE (fndecl) = get_frame_size ();\n@@ -565,6 +580,15 @@ save_for_inline_copying (fndecl)\n \t      NOTE_SOURCE_FILE (insn) = (char *) copy;\n \t      NOTE_SOURCE_FILE (copy) = 0;\n \t    }\n+\t  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n+\t      || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END)\n+\t    {\n+\t      /* We have to forward these both to match the new exception\n+\t\t region.  */\n+\t      NOTE_BLOCK_NUMBER (copy)\n+\t\t= CODE_LABEL_NUMBER (label_map[NOTE_BLOCK_NUMBER (copy)]);\n+\t      \n+\t    }\n \t  RTX_INTEGRATED_P (copy) = RTX_INTEGRATED_P (insn);\n \t  break;\n \n@@ -1872,7 +1896,18 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_BEG\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED)\n-\t    copy = emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n+\t    {\n+\t      copy = emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n+\t      if (copy && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n+\t\t\t   || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END))\n+\t\t{\n+\t\t  rtx label = map->label_map[NOTE_BLOCK_NUMBER (copy)];\n+\n+\t\t  /* We have to forward these both to match the new exception\n+\t\t     region.  */\n+\t\t  NOTE_BLOCK_NUMBER (copy) = CODE_LABEL_NUMBER (label);\n+\t\t}\n+\t    }\n \t  else\n \t    copy = 0;\n \t  break;"}, {"sha": "61d712c6929223a7aa03baeb90ac2c3e483753bc", "filename": "gcc/jump.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -60,6 +60,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"expr.h\"\n #include \"real.h\"\n+#include \"except.h\"\n \n /* ??? Eventually must record somehow the labels used by jumps\n    from nested functions.  */\n@@ -234,6 +235,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n   for (insn = forced_labels; insn; insn = XEXP (insn, 1))\n     LABEL_NUSES (XEXP (insn, 0))++;\n \n+  check_exception_handler_labels ();\n+\n+  /* Keep track of labels used for marking handlers for exception\n+     regions; they cannot usually be deleted.  */\n+\n+  for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))\n+    LABEL_NUSES (XEXP (insn, 0))++;\n+\n+  exception_optimize ();\n+\n   /* Delete all labels already not referenced.\n      Also find the last insn.  */\n "}, {"sha": "41801fa73b0619273ca0f0ee8a2685047b35d70f", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -2989,6 +2989,13 @@ int _exit_dummy_decl = 0;\t/* prevent compiler & linker warnings */\n #endif /* L_exit */\n \f\n #ifdef L_eh\n+\n+#ifdef EH_TABLE_LOOKUP\n+\n+EH_TABLE_LOOKUP\n+\n+#else\n+\n typedef struct {\n   void *start;\n   void *end;\n@@ -3095,21 +3102,9 @@ void *pc;\n #endif\n \n #if 0\n-  printf(\"find_first_eh_table_match(): else: returning NULL!\\n\");\n-#endif\n-  return (void*)0;\n-}\n-\n-void *\n-__throw_type_match (void *catch_type, void *throw_type, void* obj)\n-{\n-#if 0\n- printf(\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n-\tcatch_type, throw_type);\n+  printf (\"find_first_eh_table_match(): else: returning NULL!\\n\");\n #endif\n- if (strcmp ((const char *)catch_type, (const char *)throw_type) == 0)\n-   return obj;\n- return 0;\n+  return (void *) 0;\n }\n \n void\n@@ -3140,6 +3135,19 @@ __register_exceptions (exception_table *table)\n   node->next = exception_table_list;\n   exception_table_list = node;\n }\n+#endif\n+\n+void *\n+__throw_type_match (void *catch_type, void *throw_type, void *obj)\n+{\n+#if 0\n+ printf (\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n+\t catch_type, throw_type);\n+#endif\n+ if (strcmp ((const char *)catch_type, (const char *)throw_type) == 0)\n+   return obj;\n+ return 0;\n+}\n \n void\n __empty ()"}, {"sha": "f4670fd073561a66760caecde8dc5d6651be8827", "filename": "gcc/loop.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"real.h\"\n #include \"loop.h\"\n+#include \"except.h\"\n \n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n@@ -2290,6 +2291,19 @@ find_and_verify_loops (f)\n \tloop_invalid[loop_num] = 1;\n     }\n \n+  /* Any loop containing a label used for an exception handler must be\n+     invalidated, because it can be jumped into from anywhere.  */\n+\n+  for (label = exception_handler_labels; label; label = XEXP (label, 1))\n+    {\n+      int loop_num;\n+\n+      for (loop_num = uid_loop_num[INSN_UID (XEXP (label, 0))];\n+\t   loop_num != -1;\n+\t   loop_num = loop_outer_loop[loop_num])\n+\tloop_invalid[loop_num] = 1;\n+    }\n+\n   /* Now scan all insn's in the function.  If any JUMP_INSN branches into a\n      loop that it is not contained within, that loop is marked invalid.\n      If any INSN or CALL_INSN uses a label's address, then the loop containing"}, {"sha": "ba4b72f147d303940c3339829c94526971ea7d2d", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -118,6 +118,8 @@ rtx bcmp_libfunc;\n rtx memset_libfunc;\n rtx bzero_libfunc;\n \n+rtx throw_libfunc;\n+\n rtx eqhf2_libfunc;\n rtx nehf2_libfunc;\n rtx gthf2_libfunc;\n@@ -4247,6 +4249,8 @@ init_optabs ()\n   memset_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memset\");\n   bzero_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bzero\");\n \n+  throw_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__throw\");\n+\n   eqhf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqhf2\");\n   nehf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nehf2\");\n   gthf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gthf2\");"}, {"sha": "8722b64759027bc6dab9436e9d82bf1989b15104", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -140,6 +140,9 @@ extern void named_section\t\tPROTO((tree, char *));\n /* Tell assembler to switch to the section for function DECL.  */\n extern void function_section\t\tPROTO((tree));\n \n+/* Tell assembler to switch to the section for the exception table.  */\n+extern void exception_section\t\tPROTO((void));\n+\n /* Create the rtl to represent a function, for a function definition.\n    DECL is a FUNCTION_DECL node which describes which function.\n    The rtl is stored into DECL.  */"}, {"sha": "93153d4b967cbd387c1f7aada0ed5d29076a4e68", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -108,6 +108,14 @@ print_rtx (in_rtx)\n       {\n       case 'S':\n       case 's':\n+\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n+\t    && (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_BEG\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END))\n+\t  {\n+\t    fprintf (outfile, \" %d\", NOTE_BLOCK_NUMBER (in_rtx));\n+\t    sawclose = 1;\n+\t    break;\n+\t  }\n \tif (XSTR (in_rtx, i) == 0)\n \t  fprintf (outfile, \" \\\"\\\"\");\n \telse"}, {"sha": "c186cfc06994cf0a73aac3793ce46951876a8e17", "filename": "gcc/sched.c", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -111,9 +111,11 @@ Boston, MA 02111-1307, USA.  */\n    reg_n_calls_crossed, and reg_live_length.  Also, basic_block_head,\n    basic_block_end.\n \n-   The information in the line number notes is carefully retained by this\n-   pass.  All other NOTE insns are grouped in their same relative order at\n-   the beginning of basic blocks that have been scheduled.  */\n+   The information in the line number notes is carefully retained by\n+   this pass.  Notes that refer to the starting and ending of\n+   exception regions are also carefully retained by this pass.  All\n+   other NOTE insns are grouped in their same relative order at the\n+   beginning of basic blocks that have been scheduled.  */\n \f\n #include <stdio.h>\n #include \"config.h\"\n@@ -2078,7 +2080,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \t  sched_analyze_2 (XEXP (link, 0), insn);\n       }\n \n-  /* If there is a LOOP_{BEG,END} note in the middle of a basic block, then\n+  /* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic block, then\n      we must be sure that no instructions are scheduled across it.\n      Otherwise, the reg_n_refs info (which depends on loop_depth) would\n      become incorrect.  */\n@@ -2240,8 +2242,13 @@ sched_analyze (head, tail)\n \t\t}\n \t      reg_pending_sets_all = 1;\n \n-\t      /* Add a fake REG_NOTE which we will later convert\n-\t\t back into a NOTE_INSN_SETJMP note.  */\n+\t      /* Add a pair of fake REG_NOTEs which we will later\n+\t\t convert back into a NOTE_INSN_SETJMP note.  See\n+\t\t reemit_notes for why we use a pair of of NOTEs.  */\n+\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t\t  GEN_INT (0),\n+\t\t\t\t\t  REG_NOTES (insn));\n \t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n \t\t\t\t\t  REG_NOTES (insn));\n@@ -2285,12 +2292,18 @@ sched_analyze (head, tail)\n \t  last_function_call = insn;\n \t  n_insns += 1;\n \t}\n+\n+      /* See comments on reemit_notes as to why we do this.  */\n       else if (GET_CODE (insn) == NOTE\n \t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n+\t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\tGEN_INT (NOTE_BLOCK_NUMBER (insn)), loop_notes);\n \t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)), loop_notes);\n \t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n@@ -3077,10 +3090,12 @@ unlink_notes (insn, tail)\n       /* Don't save away NOTE_INSN_SETJMPs, because they must remain\n \t immediately after the call they follow.  We use a fake\n \t (REG_DEAD (const_int -1)) note to remember them.\n-\t Likewise with NOTE_INSN_LOOP_BEG and NOTE_INSN_LOOP_END.  */\n+\t Likewise with NOTE_INSN_{LOOP,EHREGION}_{BEG, END}.  */\n       else if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n \t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n-\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END)\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n+\t       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END)\n \t{\n \t  /* Insert the note at the end of the notes list.  */\n \t  PREV_INSN (insn) = note_list;\n@@ -3143,10 +3158,12 @@ finish_sometimes_live (regs_sometimes_live, sometimes_max)\n     }\n }\n \n-/* Search INSN for fake REG_DEAD notes for NOTE_INSN_SETJMP,\n-   NOTE_INSN_LOOP_BEG, and NOTE_INSN_LOOP_END; and convert them back\n-   into NOTEs.  LAST is the last instruction output by the instruction\n-   scheduler.  Return the new value of LAST.  */\n+/* Search INSN for fake REG_DEAD note pairs for NOTE_INSN_SETJMP,\n+   NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into\n+   NOTEs.  The REG_DEAD note following first one is contains the saved\n+   value for NOTE_BLOCK_NUMBER which is useful for\n+   NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction\n+   output by the instruction scheduler.  Return the new value of LAST.  */\n \n static rtx\n reemit_notes (insn, last)\n@@ -3161,10 +3178,19 @@ reemit_notes (insn, last)\n \t  && GET_CODE (XEXP (note, 0)) == CONST_INT)\n \t{\n \t  if (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)\n-\t    CONST_CALL_P (emit_note_after (INTVAL (XEXP (note, 0)), insn))\n-\t      = CONST_CALL_P (note);\n+\t    {\n+\t      CONST_CALL_P (emit_note_after (INTVAL (XEXP (note, 0)), insn))\n+\t\t= CONST_CALL_P (note);\n+\t      remove_note (insn, note);\n+\t      note = XEXP (note, 1);\n+\t    }\n \t  else\n-\t    last = emit_note_before (INTVAL (XEXP (note, 0)), last);\n+\t    {\n+\t      last = emit_note_before (INTVAL (XEXP (note, 0)), last);\n+\t      remove_note (insn, note);\n+\t      note = XEXP (note, 1);\n+\t      NOTE_BLOCK_NUMBER (last) = INTVAL (XEXP (note, 0));\n+\t    }\n \t  remove_note (insn, note);\n \t}\n     }\n@@ -3961,8 +3987,8 @@ schedule_block (b, file)\n \t    }\n \t}\n \n-      /* Put back NOTE_INSN_SETJMP, NOTE_INSN_LOOP_BEGIN, and\n-\t NOTE_INSN_LOOP_END notes.  */\n+      /* Put back NOTE_INSN_SETJMP,\n+         NOTE_INSN_{LOOP,EHREGION}_{BEGIN,END} notes.  */\n \n       /* To prime the loop.  We need to handle INSN and all the insns in the\n          sched group.  */"}, {"sha": "b443fc428f345e9b016a9196c0e6c3460e497a73", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"except.h\"\n #include \"function.h\"\n #include \"insn-flags.h\"\n #include \"insn-config.h\"\n@@ -134,8 +135,6 @@ extern tree rtl_expr_chain;\n    cleanup list whenever an empty list is required.  */\n static tree empty_cleanup_list;\n #endif\n-\n-extern void (*interim_eh_hook)\tPROTO((tree));\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -473,9 +472,7 @@ void\n init_stmt ()\n {\n   gcc_obstack_init (&stmt_obstack);\n-#if 0\n-  empty_cleanup_list = build_tree_list (NULL_TREE, NULL_TREE);\n-#endif\n+  init_eh ();\n }\n \n void\n@@ -498,6 +495,8 @@ init_stmt_for_function ()\n   /* We are not processing a ({...}) grouping.  */\n   expr_stmts_for_value = 0;\n   last_expr_type = 0;\n+\n+  init_eh_for_function ();\n }\n \n void\n@@ -518,6 +517,7 @@ save_stmt_status (p)\n   p->emit_filename = emit_filename;\n   p->emit_lineno = emit_lineno;\n   p->goto_fixup_chain = goto_fixup_chain;\n+  save_eh_status (p);\n }\n \n void\n@@ -538,6 +538,7 @@ restore_stmt_status (p)\n   emit_filename = p->emit_filename;\n   emit_lineno = p->emit_lineno;\n   goto_fixup_chain = p->goto_fixup_chain;\n+  restore_eh_status (p);\n }\n \f\n /* Emit a no-op instruction.  */\n@@ -3730,7 +3731,7 @@ expand_decl_cleanup (decl, cleanup)\n \t= temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n       /* If this block has a cleanup, it belongs in stack_block_stack.  */\n       stack_block_stack = thisblock;\n-      (*interim_eh_hook) (NULL_TREE);\n+      expand_eh_region_start ();\n     }\n   return 1;\n }\n@@ -3831,7 +3832,7 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \telse\n \t  {\n \t    if (! in_fixup)\n-\t      (*interim_eh_hook) (TREE_VALUE (tail));\n+\t      expand_eh_region_end (TREE_VALUE (tail));\n \n \t    if (reachable)\n \t      {"}, {"sha": "67a31ca998cf13b032684cdc0255cd886a48edca", "filename": "gcc/varasm.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6adb4e3a29c612cc99a26a54364917e3a1709e8c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6adb4e3a29c612cc99a26a54364917e3a1709e8c", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"except.h\"\n #include \"function.h\"\n #include \"expr.h\"\n #include \"output.h\"\n@@ -414,6 +415,26 @@ variable_section (decl, reloc)\n #endif\n     }\n }\n+\n+/* Tell assembler to switch to the section for the exception handling\n+   table.  */\n+\n+void\n+exception_section ()\n+{\n+#ifdef ASM_OUTPUT_SECTION_NAME\n+  named_section (NULL_TREE, \".gcc_except_table\");\n+#else\n+  if (flag_pic)\n+    data_section ();\n+  else\n+#if defined (EXCEPTION_SECTION)\n+    EXCEPTION_SECTION ();\n+#else\n+    readonly_data_section ();\n+#endif\n+#endif\n+}\n \f\n /* Create the rtl to represent a function, for a function definition.\n    DECL is a FUNCTION_DECL node which describes which function."}]}