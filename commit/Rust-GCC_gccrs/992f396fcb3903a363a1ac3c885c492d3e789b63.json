{"sha": "992f396fcb3903a363a1ac3c885c492d3e789b63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyZjM5NmZjYjM5MDNhMzYzYTFhYzNjODg1YzQ5MmQzZTc4OWI2Mw==", "commit": {"author": {"name": "Grigory Zagorodnev", "email": "grigory.zagorodnev@intel.com", "date": "2005-05-10T16:10:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-10T16:10:54Z"}, "message": "libgcov.c (create_file_directory): New function.\n\n\t* libgcov.c (create_file_directory): New function. Create\n\tdirectory for the given file name.\n\t(gcov_max_filename): New static var. Keeps size of the longest\n\tfile name.\n\t(gcov_exit): Always try to create directory for output\n\tfile. Relocate each filename basing on environment vars.\n\t(__gcov_init): Remember the longest file name.\n\t* tsystem.h: include filenames.h to get IS_DIR_SEPARATOR\n\t* doc/gcov.texi (Cross-profiling): New node documenting\n\tcross-profiling management.\n\t* doc/invoke.texi (-fprofile-arcs): Add xref to cross-profiling.\n\nFrom-SVN: r99523", "tree": {"sha": "88434cdc971ae92b6f0f0bfa67f792324670c31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88434cdc971ae92b6f0f0bfa67f792324670c31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/992f396fcb3903a363a1ac3c885c492d3e789b63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992f396fcb3903a363a1ac3c885c492d3e789b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992f396fcb3903a363a1ac3c885c492d3e789b63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992f396fcb3903a363a1ac3c885c492d3e789b63/comments", "author": null, "committer": null, "parents": [{"sha": "0f95e9143a13dfd136675c080fba4038e4b5721c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f95e9143a13dfd136675c080fba4038e4b5721c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f95e9143a13dfd136675c080fba4038e4b5721c"}], "stats": {"total": 194, "additions": 181, "deletions": 13}, "files": [{"sha": "5152682171788d37f48aa8af49233aad58dd20be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=992f396fcb3903a363a1ac3c885c492d3e789b63", "patch": "@@ -1,3 +1,18 @@\n+2005-05-11  Grigory Zagorodnev  <grigory.zagorodnev@intel.com>\n+            H.J. Lu  <hongjiu.lu@intel.com   \n+\n+\t* libgcov.c (create_file_directory): New function. Create\n+\tdirectory for the given file name.\n+\t(gcov_max_filename): New static var. Keeps size of the longest\n+\tfile name.\n+\t(gcov_exit): Always try to create directory for output\n+\tfile. Relocate each filename basing on environment vars.\n+\t(__gcov_init): Remember the longest file name.\n+\t* tsystem.h: include filenames.h to get IS_DIR_SEPARATOR\n+\t* doc/gcov.texi (Cross-profiling): New node documenting\n+\tcross-profiling management.\n+\t* doc/invoke.texi (-fprofile-arcs): Add xref to cross-profiling.\n+\n 2005-05-10  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.c (mem_min_alignment): Do not rely"}, {"sha": "d932ab94ae8efbccd11ff8007dd37b4080cbb5b8", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=992f396fcb3903a363a1ac3c885c492d3e789b63", "patch": "@@ -42,6 +42,7 @@ test code coverage in your programs.\n * Invoking Gcov::       \tHow to use gcov.\n * Gcov and Optimization::       Using gcov with GCC optimization.\n * Gcov Data Files::             The files used by gcov.\n+* Cross-profiling::             Data file relocation.\n @end menu\n \n @node Gcov Intro\n@@ -531,3 +532,42 @@ information.\n The full details of the file format is specified in @file{gcov-io.h},\n and functions provided in that header file should be used to access the\n coverage files.\n+\n+@node Cross-profiling\n+@section Data file relocation to support cross-profiling\n+\n+Running the program will cause profile output to be generated.  For each \n+source file compiled with @option{-fprofile-arcs}, an accompanying @file{.gcda} \n+file will be placed in the object file directory. That implicitly requires \n+running the program on the same system as it was built or having the same \n+absolute directory structure on the target system. The program will try\n+to create the needed directory structure, if it is not already present.\n+\n+To support cross-profiling, a program compiled with @option{-fprofile-arcs}\n+can relocate the data files based on two environment variables: \n+\n+@itemize @bullet\n+@item\n+GCOV_PREFIX contains the prefix to add to the absolute paths \n+in the object file. Prefix must be absolute as well, otherwise its \n+value is ignored. The default is no prefix.\n+\n+@item\n+GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off\n+the hardwired absolute paths. Default value is 0.\n+\n+@emph{Note:} GCOV_PREFIX_STRIP has no effect if GCOV_PREFIX is undefined, empty\n+or non-absolute.\n+@end itemize\n+\n+For example, if the object file @file{/user/build/foo.o} was built with\n+@option{-fprofile-arcs}, the final executable will try to create the data file\n+@file{/user/build/foo.gcda} when running on the target system.  This will\n+fail if the corresponding directory does not exist and it is unable to create\n+it.  This can be overcome by, for example, setting the environment as\n+@samp{GCOV_PREFIX=/target/run} and @samp{GCOV_PREFIX_STRIP=1}.  Such a\n+setting will name the data file @file{/target/run/build/foo.gcda}.\n+\n+You must move the data files to the expected directory tree in order to\n+use them for profile directed optimizations (@option{--use-profile}), or to\n+use the the @command{gcov} tool."}, {"sha": "d95b35472f19aea5dc2bb149f4309495ae2a1a92", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=992f396fcb3903a363a1ac3c885c492d3e789b63", "patch": "@@ -3427,6 +3427,7 @@ explicitly specified and it is not the final executable, otherwise it is\n the basename of the source file.  In both cases any suffix is removed\n (e.g.@: @file{foo.gcda} for input file @file{dir/foo.c}, or\n @file{dir/foo.gcda} for output file specified as @option{-o dir/foo.o}).\n+@xref{Cross-profiling}.\n \n @cindex @command{gcov}\n @item --coverage"}, {"sha": "8b478a7707c4fa6431874093e6a2bfee22a1f064", "filename": "gcc/libgcov.c", "status": "modified", "additions": 122, "deletions": 13, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=992f396fcb3903a363a1ac3c885c492d3e789b63", "patch": "@@ -88,8 +88,49 @@ static struct gcov_info *gcov_list;\n    object file included in multiple programs.  */\n static gcov_unsigned_t gcov_crc32;\n \n+/* Size of the longest file name. */\n+static size_t gcov_max_filename = 0;\n+\n+/* Make sure path compenent of the given FILENAME exists, create \n+   missing directories. FILENAME must be writable. \n+   Returns zero on success, or -1 if an error occurred.  */\n+\n+static int\n+create_file_directory (char *filename)\n+{\n+  char *s;\n+\n+  for (s = filename + 1; *s != '\\0'; s++)\n+    if (IS_DIR_SEPARATOR(*s))\n+      {\n+        char sep = *s;\n+\t*s  = '\\0';\n+\n+        /* Try to make directory if it doesn't already exist.  */\n+        if (access (filename, F_OK) == -1\n+            && mkdir (filename, 0755) == -1\n+            /* The directory might have been made by another process.  */\n+\t    && errno != EEXIST)\n+\t  {\n+            fprintf (stderr, \"profiling:%s:Cannot create directory\\n\",\n+\t\t     filename);\n+            *s = sep;\n+\t    return -1;\n+\t  };\n+        \n+\t*s = sep;\n+      };\n+  return 0;\n+}\n+\n+/* Check if VERSION of the info block PTR matches libgcov one.\n+   Return 1 on success, or zero in case of versions mismatch.\n+   If FILENAME is not NULL, its value used for reporting purposes \n+   instead of value from the info block.  */\n+   \n static int\n-gcov_version (struct gcov_info *ptr, gcov_unsigned_t version)\n+gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,\n+\t      const char *filename)\n {\n   if (version != GCOV_VERSION)\n     {\n@@ -100,7 +141,7 @@ gcov_version (struct gcov_info *ptr, gcov_unsigned_t version)\n       \n       fprintf (stderr,\n \t       \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n-\t       ptr->filename, e, v);\n+\t       filename? filename : ptr->filename, e, v);\n       return 0;\n     }\n   return 1;\n@@ -123,6 +164,10 @@ gcov_exit (void)\n   const struct gcov_ctr_info *ci_ptr;\n   unsigned t_ix;\n   gcov_unsigned_t c_num;\n+  const char *gcov_prefix;\n+  int gcov_prefix_strip = 0;\n+  size_t prefix_length;\n+  char *gi_filename, *gi_filename_up;\n \n   memset (&all, 0, sizeof (all));\n   /* Find the totals for this execution.  */\n@@ -147,6 +192,33 @@ gcov_exit (void)\n \t}\n     }\n \n+  /* Get file name relocation prefix.  Non-absolute values are ignored. */\n+  gcov_prefix = getenv(\"GCOV_PREFIX\");\n+  if (gcov_prefix && IS_ABSOLUTE_PATH (gcov_prefix))\n+    {\n+      /* Check if the level of dirs to strip off specified. */\n+      char *tmp = getenv(\"GCOV_PREFIX_STRIP\");\n+      if (tmp)\n+        {\n+          gcov_prefix_strip = atoi (tmp);\n+          /* Do not consider negative values. */\n+          if (gcov_prefix_strip < 0)\n+            gcov_prefix_strip = 0;\n+        }\n+      \n+      prefix_length = strlen(gcov_prefix);\n+\n+      /* Remove an unneccesary trailing '/' */\n+      if (IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))\n+\tprefix_length--;\n+    }\n+  \n+  /* Allocate and initialize the filename scratch space.  */\n+  gi_filename = alloca (prefix_length + gcov_max_filename + 1);\n+  if (prefix_length)\n+    memcpy (gi_filename, gcov_prefix, prefix_length);\n+  gi_filename_up = gi_filename + prefix_length;\n+  \n   /* Now merge each file.  */\n   for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n@@ -165,6 +237,28 @@ gcov_exit (void)\n       memset (&this_object, 0, sizeof (this_object));\n       memset (&object, 0, sizeof (object));\n       \n+      /* Build relocated filename, stripping off leading \n+         directories from the initial filename if requested. */\n+      if (gcov_prefix_strip > 0)\n+        {\n+          int level = 0;\n+          const char *fname = gi_ptr->filename;\n+          const char *s;\n+\n+          /* Skip selected directory levels. */\n+\t  for (s = fname + 1; (*s != '\\0') && (level < gcov_prefix_strip); s++)\n+\t    if (IS_DIR_SEPARATOR(*s))\n+\t      {\n+\t\tfname = s;\n+\t\tlevel++;\n+\t      };\n+\n+          /* Update complete filename with stripped original. */\n+          strcpy (gi_filename_up, fname);\n+        }\n+      else\n+        strcpy (gi_filename_up, gi_ptr->filename);\n+\n       /* Totals for this object file.  */\n       ci_ptr = gi_ptr->counts;\n       for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n@@ -201,10 +295,20 @@ gcov_exit (void)\n \t  fi_stride &= ~(__alignof__ (struct gcov_fn_info) - 1);\n \t}\n       \n-      if (!gcov_open (gi_ptr->filename))\n+      if (!gcov_open (gi_filename))\n \t{\n-\t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_ptr->filename);\n-\t  continue;\n+\t  /* Open failed likely due to missed directory.\n+\t     Create directory and retry to open file. */\n+          if (create_file_directory (gi_filename))\n+\t    {\n+\t      fprintf (stderr, \"profiling:%s:Skip\\n\", gi_filename);\n+\t      continue;\n+\t    }\n+\t  if (!gcov_open (gi_filename))\n+\t    {\n+              fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_filename);\n+\t      continue;\n+\t    }\n \t}\n \n       tag = gcov_read_unsigned ();\n@@ -214,11 +318,11 @@ gcov_exit (void)\n \t  if (tag != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n-\t\t       gi_ptr->filename);\n+\t\t       gi_filename);\n \t      goto read_fatal;\n \t    }\n \t  length = gcov_read_unsigned ();\n-\t  if (!gcov_version (gi_ptr, length))\n+\t  if (!gcov_version (gi_ptr, length, gi_filename))\n \t    goto read_fatal;\n \n \t  length = gcov_read_unsigned ();\n@@ -242,7 +346,7 @@ gcov_exit (void)\n \t\t{\n \t\tread_mismatch:;\n \t\t  fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n-\t\t\t   gi_ptr->filename,\n+\t\t\t   gi_filename,\n \t\t\t   f_ix + 1 ? \"function\" : \"summaries\");\n \t\t  goto read_fatal;\n \t\t}\n@@ -301,7 +405,7 @@ gcov_exit (void)\n       \n     read_error:;\n       fprintf (stderr, error < 0 ? \"profiling:%s:Overflow merging\\n\"\n-\t       : \"profiling:%s:Error merging\\n\", gi_ptr->filename);\n+\t       : \"profiling:%s:Error merging\\n\", gi_filename);\n \t      \n     read_fatal:;\n       gcov_close ();\n@@ -352,7 +456,7 @@ gcov_exit (void)\n \t\t   && memcmp (cs_all, cs_prg, sizeof (*cs_all)))\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Invocation mismatch - some data files may have been removed%s\",\n-\t\t       gi_ptr->filename, GCOV_LOCKED\n+\t\t       gi_filename, GCOV_LOCKED\n \t\t       ? \"\" : \" or concurrent update without locking support\");\n \t      all.checksum = ~0u;\n \t    }\n@@ -417,7 +521,7 @@ gcov_exit (void)\n \t  fprintf (stderr, error  < 0 ?\n \t\t   \"profiling:%s:Overflow writing\\n\" :\n \t\t   \"profiling:%s:Error writing\\n\",\n-\t\t   gi_ptr->filename);\n+\t\t   gi_filename);\n     }\n }\n \n@@ -429,11 +533,16 @@ __gcov_init (struct gcov_info *info)\n {\n   if (!info->version)\n     return;\n-  if (gcov_version (info, info->version))\n+  if (gcov_version (info, info->version, 0))\n     {\n       const char *ptr = info->filename;\n       gcov_unsigned_t crc32 = gcov_crc32;\n-  \n+      size_t filename_length =  strlen(info->filename);\n+\n+      /* Refresh the longest file name information */\n+      if (filename_length > gcov_max_filename)\n+        gcov_max_filename = filename_length;\n+      \n       do\n \t{\n \t  unsigned ix;"}, {"sha": "bc8384e1739477cb041775f64f7ee7b6dccc1830", "filename": "gcc/tsystem.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Ftsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992f396fcb3903a363a1ac3c885c492d3e789b63/gcc%2Ftsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsystem.h?ref=992f396fcb3903a363a1ac3c885c492d3e789b63", "patch": "@@ -131,4 +131,7 @@ extern int errno;\n    unreachable default case of a switch.  Do not use gcc_assert(0).  */\n #define gcc_unreachable() (abort ())\n \n+/* Filename handling macros.  */\n+#include \"filenames.h\"\n+\n #endif /* ! GCC_TSYSTEM_H */"}]}