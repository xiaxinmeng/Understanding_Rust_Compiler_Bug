{"sha": "766b19fbaf036bf39cdab2f966737bcbdffd0d12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2YjE5ZmJhZjAzNmJmMzljZGFiMmY5NjY3MzdiY2JkZmZkMGQxMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-29T05:44:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-29T05:44:06Z"}, "message": "calls.c (expand_call): Handle returning BLKmode values in registers.\n\n\t* calls.c (expand_call): Handle returning BLKmode values in\n\tregisters.  Do not try to promote BLKmode.\n\nFrom-SVN: r8574", "tree": {"sha": "95395fbfcdc979f10fea6136f98a49cad45addba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95395fbfcdc979f10fea6136f98a49cad45addba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/766b19fbaf036bf39cdab2f966737bcbdffd0d12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766b19fbaf036bf39cdab2f966737bcbdffd0d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766b19fbaf036bf39cdab2f966737bcbdffd0d12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766b19fbaf036bf39cdab2f966737bcbdffd0d12/comments", "author": null, "committer": null, "parents": [{"sha": "451d86c2931fd9529ae0274937aeb5c75dfb4498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/451d86c2931fd9529ae0274937aeb5c75dfb4498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/451d86c2931fd9529ae0274937aeb5c75dfb4498"}], "stats": {"total": 51, "additions": 51, "deletions": 0}, "files": [{"sha": "c383248389c50014073eee49fc950c0155aae7e4", "filename": "gcc/calls.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766b19fbaf036bf39cdab2f966737bcbdffd0d12/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766b19fbaf036bf39cdab2f966737bcbdffd0d12/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=766b19fbaf036bf39cdab2f966737bcbdffd0d12", "patch": "@@ -2005,13 +2005,64 @@ expand_call (exp, target, ignore)\n        If they refer to the same register, this move will be a no-op, except\n        when function inlining is being done.  */\n     emit_move_insn (target, valreg);\n+  else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n+    {\n+      /* Some machines (the PA for example) want to return all small\n+\t structures in registers regardless of the structure's alignment.\n+\t \n+\t Deal with them explicitly by copying from the return registers\n+\t into the target MEM locations.  */\n+      int bytes = int_size_in_bytes (TREE_TYPE (exp));\n+      int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      int i;\n+      enum machine_mode tmpmode;\n+      \n+      if (target == 0)\n+\ttarget = assign_stack_temp (BLKmode, bytes, 0);\n+      MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+\n+      /* We could probably emit more efficient code for machines\n+\t which do not use strict alignment, but it doesn't seem\n+\t worth the effort at the current time.  */\n+      for (i = 0; i < n_regs; i++)\n+\t{\n+\t  rtx src = operand_subword_force (valreg, i, BLKmode);\n+\t  rtx dst = operand_subword (target, i, 1, BLKmode);\n+\t  int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (exp)), BITS_PER_WORD);\n+\t  int bitpos, big_endian_correction = 0;\n+\t  \n+\t  /* Should never happen.  */\n+\t  if (src == NULL || dst == NULL)\n+\t    abort ();\n+\t  \n+\t  if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\t    big_endian_correction\n+\t      = (BITS_PER_WORD - (bytes * BITS_PER_UNIT));\n+\t  \n+\t  for (bitpos = 0;\n+\t       bitpos < BITS_PER_WORD && bytes > 0;\n+\t       bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n+\t    {\n+\t      int xbitpos = bitpos + big_endian_correction;\n+\t      \n+\t      store_bit_field (dst, bitsize, xbitpos, word_mode,\n+\t\t\t       extract_bit_field (src, bitsize, bitpos, 1,\n+\t\t\t\t\t\t  NULL_RTX, word_mode,\n+\t\t\t\t\t\t  word_mode,\n+\t\t\t\t\t\t  bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t\t  BITS_PER_WORD),\n+\t\t\t       bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t    }\n+\t}\n+    }\n   else\n     target = copy_to_reg (valreg);\n \n #ifdef PROMOTE_FUNCTION_RETURN\n   /* If we promoted this return value, make the proper SUBREG.  TARGET\n      might be const0_rtx here, so be careful.  */\n   if (GET_CODE (target) == REG\n+      && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n       && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n     {\n       tree type = TREE_TYPE (exp);"}]}