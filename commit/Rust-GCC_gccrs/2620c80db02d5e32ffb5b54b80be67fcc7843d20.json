{"sha": "2620c80db02d5e32ffb5b54b80be67fcc7843d20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyMGM4MGRiMDJkNWUzMmZmYjViNTRiODBiZTY3ZmNjNzg0M2QyMA==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2016-03-30T15:08:47Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2016-03-30T15:08:47Z"}, "message": "Update OpenACC test cases\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/combined-directives.c: Clean up dg-*\n\tdirectives.\n\t* c-c++-common/goacc/loop-clauses.c: Likewise.\n\t* g++.dg/goacc/template.C: Likewise.\n\t* gfortran.dg/goacc/combined-directives.f90: Likewise.\n\t* gfortran.dg/goacc/loop-1.f95: Likewise.\n\t* gfortran.dg/goacc/loop-5.f95: Likewise.\n\t* gfortran.dg/goacc/loop-6.f95: Likewise.\n\t* gfortran.dg/goacc/loop-tree-1.f90: Likewise.\n\t* c-c++-common/goacc-gomp/nesting-1.c: Update.\n\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Likewise.\n\t* c-c++-common/goacc/clauses-fail.c: Likewise.\n\t* c-c++-common/goacc/parallel-1.c: Likewise.\n\t* c-c++-common/goacc/reduction-1.c: Likewise.\n\t* c-c++-common/goacc/reduction-2.c: Likewise.\n\t* c-c++-common/goacc/reduction-3.c: Likewise.\n\t* c-c++-common/goacc/reduction-4.c: Likewise.\n\t* c-c++-common/goacc/routine-3.c: Likewise.\n\t* c-c++-common/goacc/routine-4.c: Likewise.\n\t* c-c++-common/goacc/routine-5.c: Likewise.\n\t* c-c++-common/goacc/tile.c: Likewise.\n\t* g++.dg/goacc/template.C: Likewise.\n\t* gfortran.dg/goacc/combined-directives.f90: Likewise.\n\t* c-c++-common/goacc/nesting-1.c: Move dg-error test cases into...\n\t* c-c++-common/goacc/nesting-fail-1.c: ... this file.  Update.\n\t* c-c++-common/goacc/kernels-1.c: Update.  Incorporate...\n\t* c-c++-common/goacc/kernels-empty.c: ... this file, and...\n\t* c-c++-common/goacc/kernels-eternal.c: ... this file, and...\n\t* c-c++-common/goacc/kernels-noreturn.c: ... this file.\n\t* c-c++-common/goacc/host_data-1.c: New file.  Incorporate...\n\t* c-c++-common/goacc/use_device-1.c: ... this file.\n\t* c-c++-common/goacc/host_data-2.c: New file.  Incorporate...\n\t* c-c++-common/goacc/host_data-5.c: ... this file, and...\n\t* c-c++-common/goacc/host_data-6.c: ... this file.\n\t* c-c++-common/goacc/loop-2-kernels.c: New file.\n\t* c-c++-common/goacc/loop-2-parallel.c: Likewise.\n\t* c-c++-common/goacc/loop-3.c: Likewise.\n\t* g++.dg/goacc/reference.C: Likewise.\n\t* g++.dg/goacc/routine-1.C: Likewise.\n\t* g++.dg/goacc/routine-2.C: Likewise.\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Update.\n\t* testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/if-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/vector-loop.c: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/declare-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c: Likewise.\n\tXFAIL.\n\t* testsuite/libgomp.oacc-c-c++-common/firstprivate-1.c: Update.\n\tIncorporate...\n\t* testsuite/libgomp.oacc-c-c++-common/firstprivate-2.c: ... this\n\tfile.\n\t* testsuite/libgomp.oacc-c++/template-reduction.C: New file.\n\t* testsuite/libgomp.oacc-c-c++-common/gang-static-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/gang-static-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-loop-clauses.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/private-variables.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-7.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/routine-wv-2.c: Likewise.\n\t* testsuite/libgomp.oacc-fortran/clauses-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/default-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/firstprivate-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/gang-static-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/if-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/implicit-firstprivate-ref.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/pr68813.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/private-variables.f90: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-1.c: Merge this\n\tfile...\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-1.c: ..., and this\n\tfile into...\n\t* testsuite/libgomp.oacc-c-c++-common/data-clauses.h: ... this new\n\tfile.  Update.\n\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels.c: New\n\tfile.\n\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-2.c: Rename to...\n\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels-ipa-pta.c:\n\t... this new file.  Update.\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-2.c: Rename to...\n\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel-ipa-pta.c:\n\t... this new file.  Update.\n\t* testsuite/libgomp.oacc-c-c++-common/mode-transitions.c: New\n\tfile.  Incorporate...\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c: ... this\n\tfile, and...\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-4.c: ... this\n\tfile, and...\n\t* testsuite/libgomp.oacc-c-c++-common/worker-single-6.c: ... this\n\tfile.\n\t* testsuite/libgomp.oacc-c-c++-common/update-1-2.c: Remove file.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\nCo-Authored-By: James Norris <jnorris@codesourcery.com>\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r234575", "tree": {"sha": "644cb73427c8a0d16b846a71d030b324e252a3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644cb73427c8a0d16b846a71d030b324e252a3af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2620c80db02d5e32ffb5b54b80be67fcc7843d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2620c80db02d5e32ffb5b54b80be67fcc7843d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2620c80db02d5e32ffb5b54b80be67fcc7843d20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2620c80db02d5e32ffb5b54b80be67fcc7843d20/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba9c755f257ad36eaa7335c48008c76c27c0b30c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9c755f257ad36eaa7335c48008c76c27c0b30c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9c755f257ad36eaa7335c48008c76c27c0b30c"}], "stats": {"total": 8246, "additions": 7134, "deletions": 1112}, "files": [{"sha": "f4a73a72b6d361074af647f28bbdd9b3de65fb63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,3 +1,52 @@\n+2016-03-30  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-c++-common/goacc/combined-directives.c: Clean up dg-*\n+\tdirectives.\n+\t* c-c++-common/goacc/loop-clauses.c: Likewise.\n+\t* g++.dg/goacc/template.C: Likewise.\n+\t* gfortran.dg/goacc/combined-directives.f90: Likewise.\n+\t* gfortran.dg/goacc/loop-1.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-5.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-6.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-tree-1.f90: Likewise.\n+\t* c-c++-common/goacc-gomp/nesting-1.c: Update.\n+\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Likewise.\n+\t* c-c++-common/goacc/clauses-fail.c: Likewise.\n+\t* c-c++-common/goacc/parallel-1.c: Likewise.\n+\t* c-c++-common/goacc/reduction-1.c: Likewise.\n+\t* c-c++-common/goacc/reduction-2.c: Likewise.\n+\t* c-c++-common/goacc/reduction-3.c: Likewise.\n+\t* c-c++-common/goacc/reduction-4.c: Likewise.\n+\t* c-c++-common/goacc/routine-3.c: Likewise.\n+\t* c-c++-common/goacc/routine-4.c: Likewise.\n+\t* c-c++-common/goacc/routine-5.c: Likewise.\n+\t* c-c++-common/goacc/tile.c: Likewise.\n+\t* g++.dg/goacc/template.C: Likewise.\n+\t* gfortran.dg/goacc/combined-directives.f90: Likewise.\n+\t* c-c++-common/goacc/nesting-1.c: Move dg-error test cases into...\n+\t* c-c++-common/goacc/nesting-fail-1.c: ... this file.  Update.\n+\t* c-c++-common/goacc/kernels-1.c: Update.  Incorporate...\n+\t* c-c++-common/goacc/kernels-empty.c: ... this file, and...\n+\t* c-c++-common/goacc/kernels-eternal.c: ... this file, and...\n+\t* c-c++-common/goacc/kernels-noreturn.c: ... this file.\n+\t* c-c++-common/goacc/host_data-1.c: New file.  Incorporate...\n+\t* c-c++-common/goacc/use_device-1.c: ... this file.\n+\t* c-c++-common/goacc/host_data-2.c: New file.  Incorporate...\n+\t* c-c++-common/goacc/host_data-5.c: ... this file, and...\n+\t* c-c++-common/goacc/host_data-6.c: ... this file.\n+\t* c-c++-common/goacc/loop-2-kernels.c: New file.\n+\t* c-c++-common/goacc/loop-2-parallel.c: Likewise.\n+\t* c-c++-common/goacc/loop-3.c: Likewise.\n+\t* g++.dg/goacc/reference.C: Likewise.\n+\t* g++.dg/goacc/routine-1.C: Likewise.\n+\t* g++.dg/goacc/routine-2.C: Likewise.\n+\n 2016-03-30  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/70450"}, {"sha": "aaf0e7a4ee6238fa80414411fcae0ad55e018c42", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -20,12 +20,12 @@ f_acc_kernels (void)\n   }\n }\n \n+#pragma acc routine vector\n void\n f_acc_loop (void)\n {\n   int i;\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {"}, {"sha": "1a3324200e2c4989d5189cafc35df7bf38d8aa0b", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,4 +1,5 @@\n extern int i;\n+#pragma acc declare create(i)\n \n void\n f_omp (void)\n@@ -14,6 +15,9 @@ f_omp (void)\n #pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n #pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n #pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n   }\n \n #pragma omp for\n@@ -358,85 +362,77 @@ f_acc_data (void)\n   }\n }\n \n+#pragma acc routine\n void\n f_acc_loop (void)\n {\n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       for (i = 0; i < 3; i++)\n \t;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       {\n \t;\n       }\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n     }\n \n-#pragma acc parallel\n #pragma acc loop\n   for (i = 0; i < 2; ++i)\n     {\n-#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n-#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target data map(i) /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n       ;\n-#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC routine\" } */\n     }\n }\n "}, {"sha": "853d010d038912fa28e29bb3d26e4cf9200accbc", "filename": "gcc/testsuite/c-c++-common/goacc/clauses-fail.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,3 +1,5 @@\n+/* Miscellaneous tests where clause parsing is expected to fail.  */\n+\n void\n f (void)\n {\n@@ -17,3 +19,13 @@ f (void)\n   for (i = 0; i < 2; ++i)\n     ;\n }\n+\n+\n+void\n+f2 (void)\n+{\n+  int a, b[100];\n+\n+#pragma acc parallel firstprivate (b[10:20]) /* { dg-error \"expected ... before ... token\" } */\n+  ;\n+}"}, {"sha": "c2a3c57b48b83432c1bf000d279a2d09a8f2f57a", "filename": "gcc/testsuite/c-c++-common/goacc/combined-directives.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcombined-directives.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,10 +1,7 @@\n-// { dg-do compile }\n-// { dg-options \"-fopenacc -fdump-tree-gimple\" }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n \n-// This error is temporary.  Remove when support is added for these clauses\n-// in the middle end.  Also remove the comments from the reduction test\n+// Remove the comments from the reduction test\n // after the FE learns that reduction variables may appear in data clauses too.\n-// { dg-prune-output \"sorry, unimplemented\" }\n \n void\n test ()"}, {"sha": "0c7a857d0bf355cd988010357d9cedc17d2c1291", "filename": "gcc/testsuite/c-c++-common/goacc/host_data-1.c", "status": "renamed", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,4 +1,14 @@\n-/* { dg-do compile } */\n+/* Test valid use of host_data directive.  */\n+\n+int v1[3][3];\n+\n+void\n+f (void)\n+{\n+#pragma acc host_data use_device(v1)\n+  ;\n+}\n+\n \n void bar (float *, float *);\n ", "previous_filename": "gcc/testsuite/c-c++-common/goacc/use_device-1.c"}, {"sha": "bdce42472b9d5b64f91e8b969bb8ffce3820dada", "filename": "gcc/testsuite/c-c++-common/goacc/host_data-2.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-2.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,78 @@\n+/* Test invalid use of host_data directive.  */\n+\n+int v0;\n+#pragma acc host_data use_device(v0) /* { dg-error \"expected declaration specifiers before\" } */\n+\n+\n+void\n+f (void)\n+{\n+  int v2 = 3;\n+#pragma acc host_data copy(v2) /* { dg-error \".copy. is not valid for ..pragma acc host_data.\" } */\n+  ;\n+\n+#pragma acc host_data use_device(v2)\n+  ;\n+  /* { dg-error \".use_device_ptr. variable is neither a pointer nor an array\" \"\" { target c } 14 } */\n+  /* { dg-error \".use_device_ptr. variable is neither a pointer, nor an arraynor reference to pointer or array\" \"\" { target c++ } 14 } */\n+  \n+#pragma acc host_data use_device(v0)\n+  ;\n+  /* { dg-error \".use_device_ptr. variable is neither a pointer nor an array\" \"\" { target c } 19 } */\n+  /* { dg-error \".use_device_ptr. variable is neither a pointer, nor an arraynor reference to pointer or array\" \"\" { target c++ } 19 } */\n+}\n+\n+\n+void\n+f2 (void)\n+{\n+  int x[100];\n+\n+#pragma acc enter data copyin (x)\n+  /* Specifying an array index is not valid for host_data/use_device.  */\n+#pragma acc host_data use_device (x[4]) /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" } */\n+  ;\n+#pragma acc exit data delete (x)\n+}\n+\n+\n+void\n+f3 (void)\n+{\n+  int x[100];\n+\n+#pragma acc data copyin (x[25:50])\n+  {\n+    int *xp;\n+#pragma acc host_data use_device (x)\n+    {\n+      /* This use of the present clause is undefined behavior for OpenACC.  */\n+#pragma acc parallel present (x) copyout (xp) /* { dg-error \"variable .x. declared in enclosing .host_data. region\" } */\n+      {\n+        xp = x;\n+      }\n+    }\n+  }\n+}\n+\n+\n+void\n+f4 (void)\n+{\n+  int x[50];\n+\n+#pragma acc data copyin (x[10:30])\n+  {\n+    int *xp;\n+#pragma acc host_data use_device (x)\n+    {\n+      /* Here 'x' being implicitly firstprivate for the parallel region\n+\t conflicts with it being declared as use_device in the enclosing\n+\t host_data region.  */\n+#pragma acc parallel copyout (xp)\n+      {\n+        xp = x; /* { dg-error \"variable .x. declared in enclosing .host_data. region\" } */\n+      }\n+    }\n+  }\n+}"}, {"sha": "a4206c8b93095e7b1caa3e685d742049c279cf92", "filename": "gcc/testsuite/c-c++-common/goacc/host_data-5.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-5.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,23 +0,0 @@\n-/* { dg-do compile } */\n-\n-#define N 1024\n-\n-int main (int argc, char* argv[])\n-{\n-  int x[N];\n-\n-#pragma acc data copyin (x[0:N])\n-  {\n-    int *xp;\n-#pragma acc host_data use_device (x)\n-    {\n-      /* This use of the present clause is undefined behavior for OpenACC.  */\n-#pragma acc parallel present (x) copyout (xp) /* { dg-error \"variable 'x' declared in enclosing 'host_data' region\" } */\n-      {\n-        xp = x;\n-      }\n-    }\n-  }\n-\n-  return 0;\n-}"}, {"sha": "8be7912e28012a0f9b80f54474d9c776eed76075", "filename": "gcc/testsuite/c-c++-common/goacc/host_data-6.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fhost_data-6.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,25 +0,0 @@\n-/* { dg-do compile } */\n-\n-#define N 1024\n-\n-int main (int argc, char* argv[])\n-{\n-  int x[N];\n-\n-#pragma acc data copyin (x[0:N])\n-  {\n-    int *xp;\n-#pragma acc host_data use_device (x)\n-    {\n-      /* Here 'x' being implicitly firstprivate for the parallel region\n-\t conflicts with it being declared as use_device in the enclosing\n-\t host_data region.  */\n-#pragma acc parallel copyout (xp)\n-      {\n-        xp = x; /* { dg-error \"variable 'x' declared in enclosing 'host_data' region\" } */\n-      }\n-    }\n-  }\n-\n-  return 0;\n-}"}, {"sha": "4fcf86eca698ed813323c7dc6eceb25bad2c0eea", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-1.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,6 +1,45 @@\n-void\n-foo (void)\n+int\n+kernels_empty (void)\n {\n #pragma acc kernels\n   ;\n+\n+  return 0;\n+}\n+\n+int\n+kernels_eternal (void)\n+{\n+#pragma acc kernels\n+  {\n+    while (1)\n+      ;\n+  }\n+\n+  return 0;\n+}\n+\n+int\n+kernels_noreturn (void)\n+{\n+#pragma acc kernels\n+  __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+\n+float b[10][15][10];\n+\n+void\n+kernels_loop_ptr_it (void)\n+{\n+  float *i;\n+\n+#pragma acc kernels\n+  {\n+#pragma acc loop\n+    for (i = &b[0][0][0]; i < &b[0][0][10]; i++)\n+      ;\n+  }\n }"}, {"sha": "e91b81c8d04aada8e9a115affdb2adfa53c9c586", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-empty.c", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-empty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-empty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-empty.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,6 +0,0 @@\n-void\n-foo (void)\n-{\n-#pragma acc kernels\n-  ;\n-}"}, {"sha": "edc17d2960c9e42e803110d7f4a8a6af0e1cb593", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-eternal.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-eternal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-eternal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-eternal.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,11 +0,0 @@\n-int\n-main (void)\n-{\n-#pragma acc kernels\n-  {\n-    while (1)\n-      ;\n-  }\n-\n-  return 0;\n-}"}, {"sha": "1a8cc6778e83c949da57473fd9e35f92e2eedffc", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-noreturn.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-noreturn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-noreturn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-noreturn.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,12 +0,0 @@\n-int\n-main (void)\n-{\n-\n-#pragma acc kernels\n-  {\n-    __builtin_abort ();\n-  }\n-\n-  return 0;\n-}\n-"}, {"sha": "01ad32d6eac67eeecdae5bb10924d949390b7568", "filename": "gcc/testsuite/c-c++-common/goacc/loop-2-kernels.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-kernels.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-kernels.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-kernels.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,189 @@\n+void K(void)\n+{\n+  int i, j;\n+\n+#pragma acc kernels\n+  {\n+#pragma acc loop auto\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(num:5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(static:5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(static:*)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector \n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker \n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang // { dg-error \"inner loop uses same\" }\n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq gang // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop worker\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker(5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker(num:5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector \n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker // { dg-error \"inner loop uses same\" }\n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang\n+\tfor (j = 0; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq worker // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang worker\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector(5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector(length:5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector // { dg-error \"inner loop uses same\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq vector // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop auto\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop seq auto // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+  }\n+\n+#pragma acc kernels loop auto\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang(5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang(num:5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang(static:5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang(static:*)\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc kernels loop worker\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop worker(5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop worker(num:5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop seq worker // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc kernels loop gang worker\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc kernels loop vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop vector(5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop vector(length:5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop seq vector // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc kernels loop gang vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop worker vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc kernels loop auto\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop seq auto // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc kernels loop gang auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+#pragma acc kernels loop worker auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+#pragma acc kernels loop vector auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+}"}, {"sha": "0ef5741ca4bb2c0459a2ee7274eef2e0f17798e5", "filename": "gcc/testsuite/c-c++-common/goacc/loop-2-parallel.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-2-parallel.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,162 @@\n+void P(void)\n+{\n+  int i, j;\n+\n+#pragma acc parallel\n+  {\n+#pragma acc loop auto\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(static:5)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang(static:*)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang // { dg-message \"containing loop\" }\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker \n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang // { dg-error \"inner loop uses same\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq gang // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop worker\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker // { dg-message \"containing loop\" 2 }\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector \n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker // { dg-error \"inner loop uses same\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang // { dg-error \"incorrectly nested\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq worker // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang worker\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector // { dg-message \"containing loop\" 3 }\n+    for (i = 0; i < 10; i++)\n+      {\n+#pragma acc loop vector // { dg-error \"inner loop uses same\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop worker // { dg-error \"incorrectly nested\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+#pragma acc loop gang // { dg-error \"incorrectly nested\" }\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop seq vector // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker vector\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop auto\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop seq auto // { dg-error \"'seq' overrides\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector auto // { dg-error \"'auto' conflicts\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+  }\n+\n+#pragma acc parallel loop auto\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop gang\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop gang(static:5)\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop gang(static:*)\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc parallel loop seq gang // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+\n+#pragma acc parallel loop worker\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc parallel loop seq worker // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop gang worker\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc parallel loop vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc parallel loop seq vector // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop gang vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop worker vector\n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+#pragma acc parallel loop auto\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop seq auto // { dg-error \"'seq' overrides\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'seq' overrides\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop gang auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop worker auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop vector auto // { dg-error \"'auto' conflicts\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"'auto' conflicts\" \"\" { target c++ } }\n+    { }\n+}"}, {"sha": "44b65a8bf574aa8a7d8aa102bb58bbdb9ad2e738", "filename": "gcc/testsuite/c-c++-common/goacc/loop-3.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-3.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,58 @@\n+void par1 (void)\n+{\n+  int i, j;\n+\n+#pragma acc parallel\n+  {\n+#pragma acc loop gang(5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop gang(num:5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop worker(5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop worker(num:5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop vector(5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+#pragma acc loop vector(length:5) // { dg-error \"argument not permitted\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+\n+   }\n+}\n+\n+void p2 (void)\n+{\n+  int i, j;\n+\n+#pragma acc parallel loop gang(5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop gang(num:5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+\n+#pragma acc parallel loop worker(5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop worker(num:5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+\n+#pragma acc parallel loop vector(5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+#pragma acc parallel loop vector(length:5) // { dg-error \"argument not permitted\" \"\" { target c } }\n+  for (i = 0; i < 10; i++) // { dg-error \"argument not permitted\" \"\" { target c++ } }\n+    { }\n+}"}, {"sha": "f3c720730ead7725f8ca9183468d36715ad75b6d", "filename": "gcc/testsuite/c-c++-common/goacc/loop-clauses.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-clauses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-clauses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-clauses.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,7 +1,3 @@\n-/* { dg-do compile } */\n-\n-/* { dg-prune-output \"sorry, unimplemented\" } */\n-\n int\n main ()\n {"}, {"sha": "cab4f98950dec9b92712e30562ac9c03c3c5f497", "filename": "gcc/testsuite/c-c++-common/goacc/nesting-1.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -58,10 +58,6 @@ f_acc_data (void)\n \n #pragma acc exit data delete(i)\n \n-#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n-    for (i = 0; i < 2; ++i)\n-      ;\n-\n #pragma acc data\n     {\n #pragma acc parallel\n@@ -92,10 +88,6 @@ f_acc_data (void)\n #pragma acc enter data copyin(i)\n \n #pragma acc exit data delete(i)\n-\n-#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n-      for (i = 0; i < 2; ++i)\n-\t;\n     }\n   }\n }"}, {"sha": "93a911120d486dd94e1ba1fd96e208a17a6960a7", "filename": "gcc/testsuite/c-c++-common/goacc/nesting-fail-1.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -38,10 +38,39 @@ f_acc_kernels (void)\n   }\n }\n \n+void\n+f_acc_data (void)\n+{\n+  unsigned int i;\n+#pragma acc data\n+  {\n+#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+\n+#pragma acc data\n+    {\n+#pragma acc loop /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+  }\n+}\n+\n #pragma acc routine\n void\n f_acc_routine (void)\n {\n #pragma acc parallel /* { dg-error \"OpenACC region inside of OpenACC routine, nested parallelism not supported yet\" } */\n   ;\n }\n+\n+void\n+f (void)\n+{\n+  int i, v = 0;\n+\n+#pragma acc loop gang reduction (+:v) /* { dg-error \"loop directive must be associated with an OpenACC compute region\" } */\n+  for (i = 0; i < 10; i++)\n+    v++;\n+}"}, {"sha": "6c6cc88ecad0ab220acdbc8378294e610f2c9805", "filename": "gcc/testsuite/c-c++-common/goacc/parallel-1.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,6 +1,38 @@\n-void\n-foo (void)\n+int\n+parallel_empty (void)\n {\n #pragma acc parallel\n   ;\n+\n+  return 0;\n+}\n+\n+int\n+parallel_eternal (void)\n+{\n+#pragma acc parallel\n+  {\n+    while (1)\n+      ;\n+  }\n+\n+  return 0;\n+}\n+\n+int\n+parallel_noreturn (void)\n+{\n+#pragma acc parallel\n+  __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+int\n+parallel_clauses (void)\n+{\n+  int a, b[100];\n+\n+#pragma acc parallel firstprivate (a, b)\n+  ;\n }"}, {"sha": "3c1c2dda6cf0ac23e11578413b9644e0f5c5ada2", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-1.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,70 +1,65 @@\n-/* { dg-require-effective-target alloca } */\n /* Integer reductions.  */\n \n-#define vl 32\n+#define n 1000\n \n int\n main(void)\n {\n-  const int n = 1000;\n   int i;\n   int result, array[n];\n   int lresult;\n \n   /* '+' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (+:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (+:result)\n   for (i = 0; i < n; i++)\n     result += array[i];\n \n   /* '*' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (*:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (*:result)\n   for (i = 0; i < n; i++)\n     result *= array[i];\n \n-//   result = 0;\n-//   vresult = 0;\n-// \n-//   /* 'max' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result > array[i] ? result : array[i];\n-//\n-//   /* 'min' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result < array[i] ? result : array[i];\n+  /* 'max' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (max:result)\n+  for (i = 0; i < n; i++)\n+    result = result > array[i] ? result : array[i];\n+\n+  /* 'min' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (min:result)\n+  for (i = 0; i < n; i++)\n+    result = result < array[i] ? result : array[i];\n \n   /* '&' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (&:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (&:result)\n   for (i = 0; i < n; i++)\n     result &= array[i];\n \n   /* '|' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (|:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (|:result)\n   for (i = 0; i < n; i++)\n     result |= array[i];\n \n   /* '^' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (^:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (^:result)\n   for (i = 0; i < n; i++)\n     result ^= array[i];\n \n   /* '&&' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (&&:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (&&:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult && (result > array[i]);\n \n   /* '||' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (||:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (||:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult || (result > array[i]);\n "}, {"sha": "c3105a2073ce98209886e01b4b8fb5c067b07784", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-2.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,49 +1,47 @@\n-/* { dg-require-effective-target alloca } */\n /* float reductions.  */\n \n-#define vl 32\n+#define n 1000\n \n int\n main(void)\n {\n-  const int n = 1000;\n   int i;\n   float result, array[n];\n   int lresult;\n \n   /* '+' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (+:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (+:result)\n   for (i = 0; i < n; i++)\n     result += array[i];\n \n   /* '*' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (*:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (*:result)\n   for (i = 0; i < n; i++)\n     result *= array[i];\n \n-//   /* 'max' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result > array[i] ? result : array[i];\n-// \n-//   /* 'min' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result < array[i] ? result : array[i];\n+  /* 'max' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (max:result)\n+  for (i = 0; i < n; i++)\n+    result = result > array[i] ? result : array[i];\n+\n+  /* 'min' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (min:result)\n+  for (i = 0; i < n; i++)\n+    result = result < array[i] ? result : array[i];\n \n   /* '&&' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (&&:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (&&:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult && (result > array[i]);\n \n   /* '||' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (||:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (||:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult || (result > array[i]);\n "}, {"sha": "4dbde04bc3be9b9eff49126f93f30d0ed5ae65ca", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-3.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,49 +1,47 @@\n-/* { dg-require-effective-target alloca } */\n /* double reductions.  */\n \n-#define vl 32\n+#define n 1000\n \n int\n main(void)\n {\n-  const int n = 1000;\n   int i;\n   double result, array[n];\n   int lresult;\n \n   /* '+' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (+:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (+:result)\n   for (i = 0; i < n; i++)\n     result += array[i];\n \n   /* '*' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (*:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (*:result)\n   for (i = 0; i < n; i++)\n     result *= array[i];\n \n-//   /* 'max' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result > array[i] ? result : array[i];\n-// \n-//   /* 'min' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result < array[i] ? result : array[i];\n+  /* 'max' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (max:result)\n+  for (i = 0; i < n; i++)\n+    result = result > array[i] ? result : array[i];\n+\n+  /* 'min' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (min:result)\n+  for (i = 0; i < n; i++)\n+    result = result < array[i] ? result : array[i];\n \n   /* '&&' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (&&:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (&&:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult && (result > array[i]);\n \n   /* '||' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (||:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (||:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult || (result > array[i]);\n "}, {"sha": "c4572b97bb1cf3e7e3942a396b1a2eaca41e837f", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-4.c", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,51 +1,35 @@\n-/* { dg-require-effective-target alloca } */\n /* complex reductions.  */\n \n-#define vl 32\n+#define n 1000\n \n int\n main(void)\n {\n-  const int n = 1000;\n   int i;\n   __complex__ double result, array[n];\n   int lresult;\n \n   /* '+' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (+:result)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (+:result)\n   for (i = 0; i < n; i++)\n     result += array[i];\n \n-  /* Needs support for complex multiplication.  */\n-\n-//   /* '*' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (*:result)\n-//   for (i = 0; i < n; i++)\n-//     result *= array[i];\n-//\n-//   /* 'max' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result > array[i] ? result : array[i];\n-// \n-//   /* 'min' reductions.  */\n-// #pragma acc parallel vector_length (vl)\n-// #pragma acc loop reduction (+:result)\n-//   for (i = 0; i < n; i++)\n-//       result = result < array[i] ? result : array[i];\n+  /* '*' reductions.  */\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (*:result)\n+  for (i = 0; i < n; i++)\n+    result *= array[i];\n \n   /* '&&' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (&&:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (&&:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult && (__real__(result) > __real__(array[i]));\n \n   /* '||' reductions.  */\n-#pragma acc parallel vector_length (vl)\n-#pragma acc loop reduction (||:lresult)\n+#pragma acc parallel\n+#pragma acc loop gang worker vector reduction (||:lresult)\n   for (i = 0; i < n; i++)\n     lresult = lresult || (__real__(result) > __real__(array[i]));\n "}, {"sha": "b322d2677690b241585ea33ceff7e59848cc2423", "filename": "gcc/testsuite/c-c++-common/goacc/routine-3.c", "status": "modified", "additions": 97, "deletions": 31, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-3.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,52 +1,118 @@\n+/* Test invalid calls to routines.  */\n+\n #pragma acc routine gang\n-void gang (void) /* { dg-message \"declared here\" 3 } */\n+int\n+gang () /* { dg-message \"declared here\" 3 } */\n {\n+  #pragma acc loop gang worker vector\n+  for (int i = 0; i < 10; i++)\n+    {\n+    }\n+\n+  return 1;\n }\n \n #pragma acc routine worker\n-void worker (void) /* { dg-message \"declared here\" 2 } */\n+int\n+worker () /* { dg-message \"declared here\" 2 } */\n {\n+  #pragma acc loop worker vector\n+  for (int i = 0; i < 10; i++)\n+    {\n+    }\n+\n+  return 1;\n }\n \n #pragma acc routine vector\n-void vector (void) /* { dg-message \"declared here\" 1 } */\n+int\n+vector () /* { dg-message \"declared here\" } */\n {\n+  #pragma acc loop vector\n+  for (int i = 0; i < 10; i++)\n+    {\n+    }\n+\n+  return 1;\n }\n \n #pragma acc routine seq\n-void seq (void)\n+int\n+seq ()\n {\n+  return 1;\n }\n \n-int main ()\n+int\n+main ()\n {\n-\n-#pragma acc parallel num_gangs (32) num_workers (32) vector_length (32)\n+  int red = 0;\n+#pragma acc parallel copy (red)\n   {\n-    #pragma acc loop gang /* { dg-message \"loop here\" 1 } */\n-    for (int i = 0; i < 10; i++)\n-      {\n-\tgang (); /*  { dg-error \"routine call uses same\" } */\n-\tworker ();\n-\tvector ();\n-\tseq ();\n-      }\n-    #pragma acc loop worker /* { dg-message \"loop here\" 2 } */\n-    for (int i = 0; i < 10; i++)\n-      {\n-\tgang (); /*  { dg-error \"routine call uses same\" } */\n-\tworker (); /*  { dg-error \"routine call uses same\" } */\n-\tvector ();\n-\tseq ();\n-      }\n-    #pragma acc loop vector /* { dg-message \"loop here\" 3 } */\n-    for (int i = 0; i < 10; i++)\n-      {\n-\tgang (); /*  { dg-error \"routine call uses same\" } */\n-\tworker (); /*  { dg-error \"routine call uses same\" } */\n-\tvector (); /*  { dg-error \"routine call uses same\" } */\n-\tseq ();\n-      }\n+    /* Independent/seq loop tests.  */\n+#pragma acc loop reduction (+:red) // { dg-warning \"insufficient partitioning\" }\n+    for (int i = 0; i < 10; i++)\n+      red += gang ();\n+\n+#pragma acc loop reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += worker ();\n+\n+#pragma acc loop reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += vector ();\n+\n+    /* Gang routine tests.  */\n+#pragma acc loop gang reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += gang (); // { dg-error \"routine call uses same\" }\n+\n+#pragma acc loop worker reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += gang (); // { dg-error \"routine call uses same\" }\n+\n+#pragma acc loop vector reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += gang (); // { dg-error \"routine call uses same\" }\n+\n+    /* Worker routine tests.  */\n+#pragma acc loop gang reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += worker ();\n+\n+#pragma acc loop worker reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += worker (); // { dg-error \"routine call uses same\" }\n+\n+#pragma acc loop vector reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += worker (); // { dg-error \"routine call uses same\" }\n+\n+    /* Vector routine tests.  */\n+#pragma acc loop gang reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += vector ();\n+\n+#pragma acc loop worker reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += vector ();\n+\n+#pragma acc loop vector reduction (+:red)  /* { dg-message \"containing loop\" } */\n+    for (int i = 0; i < 10; i++)\n+      red += vector (); // { dg-error \"routine call uses same\" }\n+\n+    /* Seq routine tests.  */\n+#pragma acc loop gang reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += seq ();\n+\n+#pragma acc loop worker reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += seq ();\n+\n+#pragma acc loop vector reduction (+:red)\n+    for (int i = 0; i < 10; i++)\n+      red += seq ();\n   }\n \n   return 0;"}, {"sha": "3e5fc4f5d77c0c2666d764553a6c62ed8e2120ef", "filename": "gcc/testsuite/c-c++-common/goacc/routine-4.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-4.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,3 +1,4 @@\n+/* Test invalid intra-routine parallelism.  */\n \n void gang (void);\n void worker (void);\n@@ -14,6 +15,24 @@ void seq (void)\n   worker ();  /* { dg-error \"routine call uses\" } */\n   vector ();  /* { dg-error \"routine call uses\" } */\n   seq ();\n+\n+  int red;\n+\n+#pragma acc loop reduction (+:red) // { dg-warning \"insufficient partitioning\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop gang reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop worker reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop vector reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n }\n \n void vector (void) /* { dg-message \"declared here\" 1 } */\n@@ -22,6 +41,24 @@ void vector (void) /* { dg-message \"declared here\" 1 } */\n   worker ();  /* { dg-error \"routine call uses\" } */\n   vector ();\n   seq ();\n+\n+  int red;\n+\n+#pragma acc loop reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop gang reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop worker reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop vector reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n }\n \n void worker (void) /* { dg-message \"declared here\" 2 } */\n@@ -30,6 +67,24 @@ void worker (void) /* { dg-message \"declared here\" 2 } */\n   worker ();\n   vector ();\n   seq ();\n+\n+  int red;\n+\n+#pragma acc loop reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop gang reduction (+:red) // { dg-error \"disallowed by containing routine\" }\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop worker reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop vector reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n }\n \n void gang (void) /* { dg-message \"declared here\" 3 } */\n@@ -38,4 +93,22 @@ void gang (void) /* { dg-message \"declared here\" 3 } */\n   worker ();\n   vector ();\n   seq ();\n+\n+  int red;\n+\n+#pragma acc loop reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop gang reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop worker reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n+\n+#pragma acc loop vector reduction (+:red)\n+  for (int i = 0; i < 10; i++)\n+    red ++;\n }"}, {"sha": "2a9db90dcb97d9ee78091353d8d4723e37c13ca0", "filename": "gcc/testsuite/c-c++-common/goacc/routine-5.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -46,6 +46,21 @@ using namespace g;\n   \n #pragma acc routine (c) /* { dg-error \"does not refer to\" } */\n \n+\n+void Bar ();\n+\n+void Foo ()\n+{\n+  Bar ();\n+}\n+\n+#pragma acc routine (Bar) // { dg-error \"must be applied before use\" }\n+\n+#pragma acc routine (Foo) gang // { dg-error \"must be applied before definition\" }\n+\n+#pragma acc routine (Baz) // { dg-error \"not been declared\" }\n+\n+\n int vb1;\t\t/* { dg-error \"directive for use\" } */\n extern int vb2;\t\t/* { dg-error \"directive for use\" } */\n static int vb3;\t\t/* { dg-error \"directive for use\" } */"}, {"sha": "8e70e718e1f860260505e45a556139ea13bab821", "filename": "gcc/testsuite/c-c++-common/goacc/tile.c", "status": "modified", "additions": 256, "deletions": 2, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Ftile.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-do compile } */\n-\n int\n main ()\n {\n@@ -71,3 +69,259 @@ main ()\n \n   return 0;\n }\n+\n+\n+void par (void)\n+{\n+  int i, j;\n+\n+#pragma acc parallel\n+  {\n+#pragma acc loop tile // { dg-error \"expected\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile() // { dg-error \"expected\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(1) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(2) \n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 1; j < 10; j++)\n+\t  { }\n+      }\n+#pragma acc loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+    for (i = 1; i < 10; i++)\n+      { }\n+#pragma acc loop tile(i)\n+    for (i = 1; i < 10; i++)\n+      { }\n+#pragma acc loop tile(2, 2, 1)\n+    for (i = 1; i < 3; i++)\n+      {\n+\tfor (j = 4; j < 6; j++)\n+\t  { }\n+      } \n+#pragma acc loop tile(2, 2)\n+    for (i = 1; i < 5; i+=2)\n+      {\n+\tfor (j = i + 1; j < 7; j+=i)\n+\t  { }\n+      }\n+#pragma acc loop vector tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector gang tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+  }\n+}\n+void p3 (void)\n+{\n+  int i, j;\n+\n+  \n+#pragma acc parallel loop tile // { dg-error \"expected\" }\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile() // { dg-error \"expected\" }\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile(1) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile(*, 1) \n+  for (i = 0; i < 10; i++)\n+    {\n+      for (j = 1; j < 10; j++)\n+\t{ }\n+    }\n+#pragma acc parallel loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+  for (i = 1; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile(i)\n+  for (i = 1; i < 10; i++)\n+    { }\n+#pragma acc parallel loop tile(2, 2, 1)\n+  for (i = 1; i < 3; i++)\n+    {\n+      for (j = 4; j < 6; j++)\n+        { }\n+    }    \n+#pragma acc parallel loop tile(2, 2)\n+  for (i = 1; i < 5; i+=2)\n+    {\n+      for (j = i + 1; j < 7; j++)\n+        { }\n+    }\n+#pragma acc parallel loop vector tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop gang tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop vector gang tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop vector worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc parallel loop gang worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+\n+}\n+\n+\n+void\n+kern (void)\n+{\n+  int i, j;\n+\n+#pragma acc kernels\n+  {\n+#pragma acc loop tile // { dg-error \"expected\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile() // { dg-error \"expected\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(1)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(2)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(6-2) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(6+2) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(*, 1) \n+    for (i = 0; i < 10; i++)\n+      {\n+\tfor (j = 0; j < 10; i++)\n+\t  { }\n+      }\n+#pragma acc loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(i)\n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop tile(2, 2, 1)\n+    for (i = 2; i < 4; i++)\n+      for (i = 4; i < 6; i++)\n+\t{ }\n+#pragma acc loop tile(2, 2)\n+    for (i = 1; i < 5; i+=2)\n+      for (j = i+1; j < 7; i++)\n+\t{ }\n+#pragma acc loop vector tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector gang tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop vector worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+#pragma acc loop gang worker tile(*) \n+    for (i = 0; i < 10; i++)\n+      { }\n+   }\n+}\n+\n+\n+void k3 (void)\n+{\n+  int i, j;\n+\n+#pragma acc kernels loop tile // { dg-error \"expected\" }\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile() // { dg-error \"expected\" }\n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile(1) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile(*, 1) \n+  for (i = 0; i < 10; i++)\n+    {\n+      for (j = 1; j < 10; j++)\n+\t{ }\n+    }\n+#pragma acc kernels loop tile(-2) // { dg-warning \"'tile' value must be positive\" }\n+  for (i = 1; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile(i)\n+  for (i = 1; i < 10; i++)\n+    { }\n+#pragma acc kernels loop tile(2, 2, 1)\n+  for (i = 1; i < 3; i++)\n+    {\n+      for (j = 4; j < 6; j++)\n+\t{ }\n+    }    \n+#pragma acc kernels loop tile(2, 2)\n+  for (i = 1; i < 5; i++)\n+    {\n+      for (j = i + 1; j < 7; j += i)\n+\t{ }\n+    }\n+#pragma acc kernels loop vector tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop vector gang tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop vector worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+#pragma acc kernels loop gang worker tile(*) \n+  for (i = 0; i < 10; i++)\n+    { }\n+}"}, {"sha": "b000668b1aa78b4fc43c55130f0dfe0766c95f58", "filename": "gcc/testsuite/g++.dg/goacc/reference.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Freference.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Freference.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Freference.C?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,39 @@\n+int\n+test1 (int &ref)\n+{\n+#pragma acc kernels copy (ref)\n+  {\n+    ref = 10;\n+  }\n+}\n+\n+int\n+test2 (int &ref)\n+{\n+  int b;\n+#pragma acc kernels copyout (b)\n+  {\n+    b = ref + 10;\n+  }\n+\n+#pragma acc parallel copyout (b)\n+  {\n+    b = ref + 10;\n+  }\n+\n+  ref = b;\n+}\n+\n+int\n+main()\n+{\n+  int a = 0;\n+  int &ref_a = a;\n+\n+  #pragma acc parallel copy (a, ref_a)\n+  {\n+    ref_a = 5;\n+  }\n+\n+  return a;\n+}"}, {"sha": "a73a73d5fc1b1081585e9afbd486db105cd9f245", "filename": "gcc/testsuite/g++.dg/goacc/routine-1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-1.C?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,13 @@\n+/* Test valid use of the routine directive.  */\n+\n+namespace N\n+{\n+  extern void foo1();\n+  extern void foo2();\n+#pragma acc routine (foo1)\n+#pragma acc routine\n+  void foo3()\n+  {\n+  }\n+}\n+#pragma acc routine (N::foo2)"}, {"sha": "2d1646647af1dba369f76b329d3f860be629d45d", "filename": "gcc/testsuite/g++.dg/goacc/routine-2.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Froutine-2.C?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,42 @@\n+/* Test invalid use of the routine directive.  */\n+\n+template <typename T>\n+extern T one_d();\n+#pragma acc routine (one_d) /* { dg-error \"names a set of overloads\" } */\n+\n+template <typename T>\n+T\n+one()\n+{\n+  return 1;\n+}\n+#pragma acc routine (one) /* { dg-error \"names a set of overloads\" } */\n+\n+int incr (int);\n+float incr (float);\n+int inc;\n+\n+#pragma acc routine (incr) /* { dg-error \"names a set of overloads\" } */\n+\n+#pragma acc routine (increment) /* { dg-error \"has not been declared\" } */\n+\n+#pragma acc routine (inc) /* { dg-error \"does not refer to a function\" } */\n+\n+#pragma acc routine (+) /* { dg-error \"expected unqualified-id before '.' token\" } */\n+\n+int sum (int, int);\n+\n+namespace foo {\n+#pragma acc routine (sum)\n+  int sub (int, int);\n+}\n+\n+#pragma acc routine (foo::sub)\n+\n+/* It's strange to apply a routine directive to subset of overloaded\n+   functions, but that is permissible in OpenACC 2.x.  */\n+\n+int decr (int a);\n+\n+#pragma acc routine\n+float decr (float a);"}, {"sha": "f139dc25b58b1051688b14fc9b74ad498392b254", "filename": "gcc/testsuite/g++.dg/goacc/template.C", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Ftemplate.C?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,8 +1,3 @@\n-// This error is temporary.  Remove when support is added for these clauses\n-// in the middle end.  Also remove the comments from the reduction test\n-// after the FE learns that reduction variables may appear in data clauses too.\n-// { dg-prune-output \"sorry, unimplemented\" }\n-\n #pragma acc routine\n template <typename T> T\n accDouble(int val)\n@@ -20,65 +15,72 @@ oacc_parallel_copy (T a)\n   double z = 4;\n \n #pragma acc parallel num_gangs (a) num_workers (a) vector_length (a) default (none) copyout (b) copyin (a)\n-  {\n+#pragma acc loop gang worker vector\n+  for (int i = 0; i < 1; i++)\n     b = a;\n-  }\n \n #pragma acc parallel num_gangs (a) copy (w, x, y, z)\n-  {\n-    w = accDouble<char>(w);\n-    x = accDouble<int>(x);\n-    y = accDouble<float>(y);\n-    z = accDouble<double>(z);\n-  }\n+#pragma acc loop\n+  for (int i = 0; i < 1; i++)\n+    {\n+      w = accDouble<char>(w);\n+      x = accDouble<int>(x);\n+      y = accDouble<float>(y);\n+      z = accDouble<double>(z);\n+    }\n \n #pragma acc parallel num_gangs (a) if (1)\n   {\n+#pragma acc loop independent collapse (2) gang\n+    for (int i = 0; i < a; i++)\n+      for (int j = 0; j < 5; j++)\n+\tb = a;\n+\n #pragma acc loop auto tile (a, 3)\n-  for (int i = 0; i < a; i++)\n-    for (int j = 0; j < 5; j++)\n-      b = a;\n+    for (int i = 0; i < a; i++)\n+      for (int j = 0; j < 5; j++)\n+\tb = a;\n \n #pragma acc loop seq\n-  for (int i = 0; i < a; i++)\n-    b = a;\n+    for (int i = 0; i < a; i++)\n+      b = a;\n   }\n \n   T c;\n \n #pragma acc parallel num_workers (10)\n-  {\n+#pragma acc loop worker\n+  for (int i = 0; i < 1; i++)\n+    {\n #pragma acc atomic capture\n-    c = b++;\n+      c = b++;\n \n #pragma atomic update\n-    c++;\n+      c++;\n \n #pragma acc atomic read\n-    b = a;\n+      b = a;\n \n #pragma acc atomic write\n-    b = a;\n-  }\n+      b = a;\n+    }\n \n-//#pragma acc parallel reduction (+:c)\n-//  {\n-//    c = 1;\n-//  }\n+#pragma acc parallel reduction (+:c)\n+  c = 1;\n \n #pragma acc data if (1) copy (b)\n   {\n-    #pragma acc parallel\n+#pragma acc parallel\n     {\n       b = a;\n     }\n   }\n \n #pragma acc enter data copyin (b)\n #pragma acc parallel present (b)\n-    {\n-      b = a;\n-    }\n+  {\n+    b = a;\n+  }\n \n #pragma acc update host (b)\n #pragma acc update self (b)\n@@ -109,11 +111,9 @@ oacc_kernels_copy (T a)\n #pragma acc kernels copyout (b) copyin (a)\n   b = a;\n \n-//#pragma acc kernels loop reduction (+:c)\n-//  for (int i = 0; i < 10; i++)\n-//    {\n-//      c = 1;\n-//    }\n+#pragma acc kernels loop reduction (+:c)\n+  for (int i = 0; i < 10; i++)\n+    c = 1;\n \n #pragma acc data if (1) copy (b)\n   {\n@@ -125,9 +125,10 @@ oacc_kernels_copy (T a)\n \n #pragma acc enter data copyin (b)\n #pragma acc kernels present (b)\n-    {\n-      b = a;\n-    }\n+  {\n+    b = a;\n+  }\n+\n   return b;\n }\n "}, {"sha": "42a447ad06bff8238048deb124cc020ff13c8447", "filename": "gcc/testsuite/gfortran.dg/goacc/combined-directives.f90", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcombined-directives.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,17 +1,10 @@\n ! Exercise combined OpenACC directives.\n \n-! { dg-do compile }\n-! { dg-options \"-fopenacc -fdump-tree-gimple\" }\n-\n-! This error is temporary.  Remove when support is added for these clauses\n-! in the middle end.\n-! { dg-prune-output \"sorry, unimplemented\" }\n-\n-! Update the reduction tests.\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n \n subroutine test\n   implicit none\n-  integer a(100), i, j, z\n+  integer a(100), i, j, y, z\n \n   ! PARALLEL\n   \n@@ -73,10 +66,10 @@ subroutine test\n   end do\n   !$acc end parallel loop\n \n-!  !$acc parallel loop reduction (+:z) copy (z)\n-!  do i = 1, 100\n-!  end do\n-!  !$acc end parallel loop\n+  !$acc parallel loop reduction (+:y) copy (y)\n+  do i = 1, 100\n+  end do\n+  !$acc end parallel loop\n \n   ! KERNELS\n \n@@ -138,10 +131,10 @@ subroutine test\n   end do\n   !$acc end kernels loop\n \n-!  !$acc kernels loop reduction (+:z) copy (z)\n-!  do i = 1, 100\n-!  end do\n-!  !$acc end kernels loop\n+  !$acc kernels loop reduction (+:y) copy (y)\n+  do i = 1, 100\n+  end do\n+  !$acc end kernels loop\n end subroutine test\n \n ! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. collapse.2.\" 2 \"gimple\" } }\n@@ -153,3 +146,5 @@ end subroutine test\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. private.j. tile.2, 3\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"acc loop private.i. independent\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"private.z\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"omp target oacc_\\[^ \\]+ map.force_tofrom:y\" 2 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"acc loop private.i. reduction..:y.\" 2 \"gimple\" } }"}, {"sha": "b5f9e038145ae585df9b3532e0b5d1a9b4f2230f", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-1.f95", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,5 +1,3 @@\n-! { dg-do compile } \n-! { dg-additional-options \"-fmax-errors=100\" } \n module test\n   implicit none\n contains\n@@ -29,14 +27,18 @@ subroutine test1\n        i = i + 1\n   end do\n   !$acc loop\n-  do 300 d = 1, 30, 6 ! { dg-error \"integer\" }\n+  do 300 d = 1, 30, 6\n       i = d\n   300 a(i) = 1\n+  ! { dg-warning \"Deleted feature: Loop variable at .1. must be integer\" \"\" { target *-*-* } 30 }\n+  ! { dg-error \"ACC LOOP iteration variable must be of type integer\" \"\" { target *-*-* } 30 }\n   !$acc loop\n-  do d = 1, 30, 5 ! { dg-error \"integer\" }\n+  do d = 1, 30, 5\n        i = d\n       a(i) = 2\n   end do\n+  ! { dg-warning \"Deleted feature: Loop variable at .1. must be integer\" \"\" { target *-*-* } 36 }\n+  ! { dg-error \"ACC LOOP iteration variable must be of type integer\" \"\" { target *-*-* } 36 }\n   !$acc loop\n   do i = 1, 30\n       if (i .eq. 16) exit ! { dg-error \"EXIT statement\" }\n@@ -144,8 +146,10 @@ subroutine test1\n     end do\n     !$acc parallel loop collapse(2)\n     do i = 1, 3\n-        do r = 4, 6    ! { dg-error \"integer\" }\n+        do r = 4, 6\n         end do\n+        ! { dg-warning \"Deleted feature: Loop variable at .1. must be integer\" \"\" { target *-*-* } 149 }\n+        ! { dg-error \"ACC LOOP iteration variable must be of type integer\" \"\" { target *-*-* } 149 }\n     end do\n \n     ! Both seq and independent are not allowed\n@@ -167,4 +171,3 @@ subroutine test1\n \n end subroutine test1\n end module test\n-! { dg-prune-output \"Deleted\" }"}, {"sha": "d059cf7f3777294559c7420dcfb5929a8b9ac1f2", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-5.f95", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-5.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-5.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-5.f95?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,9 +1,3 @@\n-! { dg-do compile }\n-! { dg-additional-options \"-fmax-errors=100\" }\n-\n-! { dg-prune-output \"sorry, unimplemented\" }\n-! { dg-prune-output \"Error: work-sharing region\" }\n-\n program test\n   implicit none\n   integer :: i, j"}, {"sha": "d0855b4fa958bde4df3923d6cb9ac32ca6e4ed4a", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-6.f95", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-6.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-6.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-6.f95?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,11 +1,3 @@\n-! { dg-do compile }\n-! { dg-additional-options \"-fmax-errors=100\" }\n-\n-! This error is temporary.  Remove when support is added for these clauses\n-! in the middle end.\n-! { dg-prune-output \"sorry, unimplemented\" }\n-! { dg-prune-output \"Error: work-sharing region\" }\n-\n program test\n   implicit none\n   integer :: i, j"}, {"sha": "81bdc23e46c0df6133198aeecf1018cd26e20ef9", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-tree-1.f90", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,13 +1,7 @@\n-! { dg-do compile } \n ! { dg-additional-options \"-fdump-tree-original -std=f2008\" } \n \n ! test for tree-dump-original and spaces-commas\n \n-! This error is temporary.  Remove when support is added for these clauses\n-! in the middle end.\n-! { dg-prune-output \"sorry, unimplemented\" }\n-! { dg-prune-output \"Error: work-sharing region\" }\n-\n program test\n   implicit none\n   integer :: i, j, k, m, sum"}, {"sha": "a1763b68c9e6a6bd0bbeacc87f284d0f59949f9f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,3 +1,71 @@\n+2016-03-30  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Update.\n+\t* testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/if-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/vector-loop.c: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/declare-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c: Likewise.\n+\tXFAIL.\n+\t* testsuite/libgomp.oacc-c-c++-common/firstprivate-1.c: Update.\n+\tIncorporate...\n+\t* testsuite/libgomp.oacc-c-c++-common/firstprivate-2.c: ... this\n+\tfile.\n+\t* testsuite/libgomp.oacc-c++/template-reduction.C: New file.\n+\t* testsuite/libgomp.oacc-c-c++-common/gang-static-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/gang-static-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/kernels-loop-clauses.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/private-variables.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-7.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/routine-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/routine-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/routine-wv-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/clauses-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/default-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/firstprivate-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/gang-static-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/if-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/implicit-firstprivate-ref.f90:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-fortran/pr68813.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/private-variables.f90: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/kernels-1.c: Merge this\n+\tfile...\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-1.c: ..., and this\n+\tfile into...\n+\t* testsuite/libgomp.oacc-c-c++-common/data-clauses.h: ... this new\n+\tfile.  Update.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels.c: New\n+\tfile.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/kernels-2.c: Rename to...\n+\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels-ipa-pta.c:\n+\t... this new file.  Update.\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-2.c: Rename to...\n+\t* testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel-ipa-pta.c:\n+\t... this new file.  Update.\n+\t* testsuite/libgomp.oacc-c-c++-common/mode-transitions.c: New\n+\tfile.  Incorporate...\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c: ... this\n+\tfile, and...\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-4.c: ... this\n+\tfile, and...\n+\t* testsuite/libgomp.oacc-c-c++-common/worker-single-6.c: ... this\n+\tfile.\n+\t* testsuite/libgomp.oacc-c-c++-common/update-1-2.c: Remove file.\n+\n 2016-03-29  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-c++/c++.exp [!lang_test_file_found]: Call"}, {"sha": "fb5924c9b5196c999bb40b11af551dd754f2a1da", "filename": "libgomp/testsuite/libgomp.oacc-c++/template-reduction.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Ftemplate-reduction.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Ftemplate-reduction.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Ftemplate-reduction.C?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,98 @@\n+const int n = 100;\n+\n+// Check explicit template copy map\n+\n+template<typename T> T\n+sum (T array[])\n+{\n+   T s = 0;\n+\n+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy (s, array[0:n])\n+  for (int i = 0; i < n; i++)\n+    s += array[i];\n+\n+  return s;\n+}\n+\n+// Check implicit template copy map\n+\n+template<typename T> T\n+sum ()\n+{\n+  T s = 0;\n+  T array[n];\n+\n+  for (int i = 0; i < n; i++)\n+    array[i] = i+1;\n+\n+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy (s)\n+  for (int i = 0; i < n; i++)\n+    s += array[i];\n+\n+  return s;\n+}\n+\n+// Check present and async\n+\n+template<typename T> T\n+async_sum (T array[])\n+{\n+   T s = 0;\n+\n+#pragma acc parallel loop num_gangs (10) gang async (1) present (array[0:n])\n+   for (int i = 0; i < n; i++)\n+     array[i] = i+1;\n+\n+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) present (array[0:n]) copy (s) async wait (1)\n+  for (int i = 0; i < n; i++)\n+    s += array[i];\n+\n+#pragma acc wait\n+\n+  return s;\n+}\n+\n+// Check present and async and an explicit firstprivate\n+\n+template<typename T> T\n+async_sum (int c)\n+{\n+   T s = 0;\n+\n+#pragma acc parallel loop num_gangs (10) gang reduction (+:s) copy(s) firstprivate (c) async wait (1)\n+  for (int i = 0; i < n; i++)\n+    s += i+c;\n+\n+#pragma acc wait\n+\n+  return s;\n+}\n+\n+int\n+main()\n+{\n+  int a[n];\n+  int result = 0;\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      a[i] = i+1;\n+      result += i+1;\n+    }\n+\n+  if (sum (a) != result)\n+    __builtin_abort ();\n+\n+  if (sum<int> () != result)\n+    __builtin_abort ();\n+\n+#pragma acc enter data copyin (a)\n+  if (async_sum (a) != result)\n+    __builtin_abort ();\n+\n+  if (async_sum<int> (1) != result)\n+    __builtin_abort ();\n+#pragma acc exit data delete (a)\n+\n+  return 0;\n+}"}, {"sha": "f3b490a9508a3924474e7a7917a8d02577c4a705", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c", "status": "modified", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,4 +1,6 @@\n /* { dg-do run { target openacc_nvidia_accel_selected } } */\n+/* <http://news.gmane.org/find-root.php?message_id=%3C87pp0aaksc.fsf%40kepler.schwinge.homeip.net%3E>.\n+   { dg-xfail-run-if \"TODO\" { *-*-* } } */\n /* { dg-additional-options \"-lcuda\" } */\n \n #include <openacc.h>\n@@ -444,6 +446,438 @@ main (int argc, char **argv)\n \n #pragma acc update host (a[0:N], b[0:N], c[0:N]) async (1)\n \n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 5.0)\n+            abort ();\n+\n+        if (b[i] != 25.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 3.0;\n+        b[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N]) copy (b[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc wait\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 3.0)\n+            abort ();\n+\n+        if (b[i] != 3.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 2.0;\n+        b[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N]) copy (b[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 2.0)\n+            abort ();\n+\n+        if (b[i] != 2.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 3.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N]) copy (b[0:N]) copy (c[0:N]) copy (d[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            d[ii] = ((a[ii] * a[ii] + a[ii]) / a[ii]) - a[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 3.0)\n+            abort ();\n+\n+        if (b[i] != 9.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+\n+        if (d[i] != 1.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 2.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+        e[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N], b[0:N], c[0:N], d[0:N], e[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            d[ii] = ((a[ii] * a[ii] + a[ii]) / a[ii]) - a[ii];\n+    }\n+\n+#pragma acc kernels wait (1) async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            e[ii] = a[ii] + b[ii] + c[ii] + d[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 2.0)\n+            abort ();\n+\n+        if (b[i] != 4.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+\n+        if (d[i] != 1.0)\n+            abort ();\n+\n+        if (e[i] != 11.0)\n+            abort ();\n+    }\n+\n+\n+    r = cuStreamCreate (&stream1, CU_STREAM_NON_BLOCKING);\n+    if (r != CUDA_SUCCESS)\n+    {\n+        fprintf (stderr, \"cuStreamCreate failed: %d\\n\", r);\n+        abort ();\n+    }\n+\n+    acc_set_cuda_stream (1, stream1);\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 5.0;\n+        b[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N], b[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 5.0)\n+            abort ();\n+\n+        if (b[i] != 5.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 7.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N]) copy (b[0:N]) copy (c[0:N]) copy (d[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            d[ii] = ((a[ii] * a[ii] + a[ii]) / a[ii]) - a[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 7.0)\n+            abort ();\n+\n+        if (b[i] != 49.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+\n+        if (d[i] != 1.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 3.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+        e[i] = 0.0;\n+    }\n+\n+#pragma acc data copy (a[0:N], b[0:N], c[0:N], d[0:N], e[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            d[ii] = ((a[ii] * a[ii] + a[ii]) / a[ii]) - a[ii];\n+    }\n+\n+#pragma acc kernels wait (1) async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            e[ii] = a[ii] + b[ii] + c[ii] + d[ii];\n+    }\n+\n+#pragma acc wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 3.0)\n+            abort ();\n+\n+        if (b[i] != 9.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+\n+        if (d[i] != 1.0)\n+            abort ();\n+\n+        if (e[i] != 17.0)\n+            abort ();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 4.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+        e[i] = 0.0;\n+    }\n+\n+#pragma acc data copyin (a[0:N], b[0:N], c[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+#pragma acc update host (a[0:N], b[0:N], c[0:N]) wait (1)\n+\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != 4.0)\n+            abort ();\n+\n+        if (b[i] != 16.0)\n+            abort ();\n+\n+        if (c[i] != 4.0)\n+            abort ();\n+    }\n+\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 5.0;\n+        b[i] = 0.0;\n+        c[i] = 0.0;\n+        d[i] = 0.0;\n+        e[i] = 0.0;\n+    }\n+\n+#pragma acc data copyin (a[0:N], b[0:N], c[0:N]) copyin (N)\n+    {\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = (a[ii] * a[ii] * a[ii]) / a[ii];\n+    }\n+\n+#pragma acc kernels async (1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            c[ii] = (a[ii] + a[ii] + a[ii] + a[ii]) / a[ii];\n+    }\n+\n+#pragma acc update host (a[0:N], b[0:N], c[0:N]) async (1)\n+\n #pragma acc wait (1)\n \n     }"}, {"sha": "410c46cc651ed9022ffa1afe133356e19eb9f31c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -578,6 +578,32 @@ main (int argc, char **argv)\n             abort ();\n     }\n \n+    if (acc_is_present (&a[0], (N * sizeof (float))))\n+      abort ();\n+\n+    if (acc_is_present (&b[0], (N * sizeof (float))))\n+      abort ();\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 6.0;\n+        b[i] = 0.0;\n+    }\n+\n+#pragma acc parallel pcopy (a[0:N], b[0:N])\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 6.0)\n+            abort ();\n+    }\n+\n     if (acc_is_present (&a[0], (N * sizeof (float))))\n       abort ();\n "}, {"sha": "2cd98bd9d78696d94413fa6b1fd880a24bacfadd", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels-ipa-pta.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels-ipa-pta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels-ipa-pta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels-ipa-pta.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do run { target lto } } */\n /* { dg-additional-options \"-fipa-pta -flto -flto-partition=max\" } */\n \n-#include \"parallel-1.c\"\n+#include \"data-clauses-kernels.c\"", "previous_filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-2.c"}, {"sha": "f7f2d1c861cdfca1acb9dab3fd60ffea3137d093", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-clauses-kernels.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-kernels.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,2 @@\n+#define CONSTRUCT kernels\n+#include \"data-clauses.h\""}, {"sha": "ddcf4e389cb311eb143d9beebd68a8171768046c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel-ipa-pta.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel-ipa-pta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel-ipa-pta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel-ipa-pta.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do run { target lto } } */\n /* { dg-additional-options \"-fipa-pta -flto -flto-partition=max\" } */\n \n-#include \"kernels-1.c\"\n+#include \"data-clauses-parallel.c\"", "previous_filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-2.c"}, {"sha": "e734b2f3afd08215b9c9c64367d714150ce0a128", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-clauses-parallel.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses-parallel.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,2 @@\n+#define CONSTRUCT parallel\n+#include \"data-clauses.h\""}, {"sha": "d557befba354d05fc71bc3aeb371e2bd3d17b1d0", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-clauses.h", "status": "renamed", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-clauses.h?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,7 +1,3 @@\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n int i;\n \n int main(void)\n@@ -11,145 +7,145 @@ int main(void)\n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) copyin (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) copyin (i, j)\n   {\n     if (i != -1 || j != -2)\n-      abort ();\n+      __builtin_abort ();\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) copyout (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) copyout (i, j)\n   {\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) copy (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) copy (i, j)\n   {\n     if (i != -1 || j != -2)\n-      abort ();\n+      __builtin_abort ();\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) create (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) create (i, j)\n   {\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) present_or_copyin (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) present_or_copyin (i, j)\n   {\n     if (i != -1 || j != -2)\n-      abort ();\n+      __builtin_abort ();\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1)\n-    abort ();\n+    __builtin_abort ();\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) present_or_copyout (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) present_or_copyout (i, j)\n   {\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) present_or_copy (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) present_or_copy (i, j)\n   {\n     if (i != -1 || j != -2)\n-      abort ();\n+      __builtin_abort ();\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n \n   i = -1;\n   j = -2;\n   v = 0;\n-#pragma acc parallel /* copyout */ present_or_copyout (v) present_or_create (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) present_or_create (i, j)\n   {\n     i = 2;\n     j = 1;\n     if (i != 2 || j != 1)\n-      abort ();\n+      __builtin_abort ();\n     v = 1;\n   }\n   if (v != 1)\n-    abort ();\n+    __builtin_abort ();\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   i = -1;\n@@ -158,23 +154,23 @@ int main(void)\n \n #pragma acc data copyin (i, j)\n   {\n-#pragma acc parallel /* copyout */ present_or_copyout (v) present (i, j)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v) present (i, j)\n     {\n       if (i != -1 || j != -2)\n-        abort ();\n+\t__builtin_abort ();\n       i = 2;\n       j = 1;\n       if (i != 2 || j != 1)\n-        abort ();\n+\t__builtin_abort ();\n       v = 1;\n     }\n   }\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   i = -1;\n@@ -183,23 +179,23 @@ int main(void)\n \n #pragma acc data copyin(i, j)\n   {\n-#pragma acc parallel /* copyout */ present_or_copyout (v)\n+#pragma acc CONSTRUCT /* copyout */ present_or_copyout (v)\n     {\n       if (i != -1 || j != -2)\n-        abort ();\n+\t__builtin_abort ();\n       i = 2;\n       j = 1;\n       if (i != 2 || j != 1)\n-        abort ();\n+\t__builtin_abort ();\n       v = 1;\n     }\n   }\n #if ACC_MEM_SHARED\n   if (v != 1 || i != 2 || j != 1)\n-    abort ();\n+    __builtin_abort ();\n #else\n   if (v != 1 || i != -1 || j != -2)\n-    abort ();\n+    __builtin_abort ();\n #endif\n \n   return 0;", "previous_filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-1.c"}, {"sha": "8247e7b6bdd06edef5a119f7f9514481bbe0b7d4", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-do run } */\n-\n #include <stdlib.h>\n \n int main (void)\n@@ -16,6 +14,27 @@ int main (void)\n     a_2 = &a;\n   }\n \n+  if (a != A)\n+    abort ();\n+  if (a_1 != a)\n+    abort ();\n+#if ACC_MEM_SHARED\n+  if (a_2 != &a)\n+    abort ();\n+#else\n+  if (a_2 == &a)\n+    abort ();\n+#endif\n+\n+  a_1 = a_2 = 0;\n+\n+#pragma acc data deviceptr (a)\n+#pragma acc parallel copyout (a_1, a_2)\n+  {\n+    a_1 = a;\n+    a_2 = &a;\n+  }\n+\n   if (a != A)\n     abort ();\n   if (a_1 != a)"}, {"sha": "689a443ca43b573439a20406f4db71cd2f645d5c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/firstprivate-1.c", "status": "modified", "additions": 107, "deletions": 7, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,8 +1,7 @@\n-/* { dg-do run } */\n-\n #include  <openacc.h>\n \n-int main ()\n+\n+void t1 ()\n {\n   int ok = 1;\n   int val = 2;\n@@ -28,14 +27,115 @@ int main ()\n   if (ondev)\n     {\n       if (!ok)\n-\treturn 1;\n+\t__builtin_abort ();\n       if (val != 2)\n-\treturn 1;\n+\t__builtin_abort ();\n \n       for (int i = 0; i < 32; i++)\n \tif (ary[i] != 2 + i)\n-\t  return 1;\n+\t  __builtin_abort ();\n     }\n-  \n+}\n+\n+\n+void t2 ()\n+{\n+  int ok = 1;\n+  int val = 2;\n+\n+#pragma acc data copy(val)\n+  {\n+#pragma acc parallel present (val)\n+    {\n+      val = 7;\n+    }\n+\n+#pragma acc parallel firstprivate (val) copy(ok)\n+    {\n+      ok  = val == 7;\n+      val = 9;\n+    }\n+  }\n+\n+  if (!ok)\n+    __builtin_abort ();\n+  if (val != 7)\n+    __builtin_abort ();\n+}\n+\n+\n+#define N 100\n+void t3 ()\n+{\n+  int a, b[N], c, d, i;\n+  int n = acc_get_device_type () == acc_device_nvidia ? N : 1;\n+\n+  a = 5;\n+  for (i = 0; i < n; i++)\n+    b[i] = -1;\n+\n+  #pragma acc parallel num_gangs (n) firstprivate (a)\n+  #pragma acc loop gang\n+  for (i = 0; i < n; i++)\n+    {\n+      a = a + i;\n+      b[i] = a;\n+    }\n+\n+  for (i = 0; i < n; i++)\n+    if (a + i != b[i])\n+      __builtin_abort ();\n+\n+  #pragma acc data copy (a)\n+  {\n+    #pragma acc parallel firstprivate (a) copyout (c)\n+    {\n+      a = 10;\n+      c = a;\n+    }\n+\n+    /* This version of 'a' should still be 5.  */\n+    #pragma acc parallel copyout (d) present (a)\n+    {\n+      d = a;\n+    }\n+  }\n+\n+  if (c != 10)\n+    __builtin_abort ();\n+  if (d != 5)\n+    __builtin_abort ();\n+}\n+#undef N\n+\n+\n+void t4 ()\n+{\n+  int x = 5, i, arr[32];\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 3;\n+\n+#pragma acc parallel firstprivate(x) copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+#pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      arr[i] += x;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    if (arr[i] != 8)\n+      __builtin_abort ();\n+}\n+\n+\n+int\n+main()\n+{\n+  t1 ();\n+  t2 ();\n+  t3 ();\n+  t4 ();\n+\n   return 0;\n }"}, {"sha": "9666542fd8243dc45b698d20192bf7ba3636dd15", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/firstprivate-2.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Ffirstprivate-2.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,31 +0,0 @@\n-/* { dg-do run } */\n-\n-#include  <openacc.h>\n-\n-int main ()\n-{\n-  int ok = 1;\n-  int val = 2;\n-\n-#pragma acc data copy(val)\n-  {\n-#pragma acc parallel present (val)\n-    {\n-      val = 7;\n-    }\n-\n-#pragma acc parallel firstprivate (val) copy(ok)\n-    {\n-      ok  = val == 7;\n-      val = 9;\n-    }\n-\n-  }\n-\n-  if (!ok)\n-    return 1;\n-  if(val != 7)\n-    return 1;\n-\n-  return 0;\n-}"}, {"sha": "d8ab958f334ed2c0d41f8ca30d6b10a7ef763735", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/gang-static-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,48 @@\n+#include <assert.h>\n+\n+#define N 100\n+\n+void\n+test (int *a, int *b, int sarg)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    assert (a[i] == b[i] + sarg);\n+}\n+\n+int\n+main ()\n+{\n+  int a[N], b[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    b[i] = i+1;\n+\n+#pragma acc parallel loop gang (static:*) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = b[i] + 0;\n+\n+  test (a, b, 0);\n+\n+#pragma acc parallel loop gang (static:1) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = b[i] + 1;\n+\n+  test (a, b, 1);\n+\n+#pragma acc parallel loop gang (static:5) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = b[i] + 5;\n+\n+  test (a, b, 5);\n+\n+#pragma acc parallel loop gang (static:20) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = b[i] + 20;\n+\n+  test (a, b, 20);\n+\n+  return 0;\n+}"}, {"sha": "ce9632cf1c0fd954db3fe784157226eec9010870", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/gang-static-2.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fgang-static-2.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do run { target openacc_nvidia_accel_selected } } */\n+/* This code uses nvptx inline assembly guarded with acc_on_device, which is\n+   not optimized away at -O0, and then confuses the target assembler.\n+   { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+#include <assert.h>\n+#include <openacc.h>\n+\n+#define N 100\n+\n+#define GANG_ID(I)\t\t\t\t\t\t\\\n+  (acc_on_device (acc_device_nvidia)\t\t\t\t\\\n+   ? ({unsigned __r;\t\t\t\t\t\t\\\n+       __asm__ volatile (\"mov.u32 %0,%%ctaid.x;\" : \"=r\" (__r));\t\\\n+       __r; }) : (I))\n+\n+int\n+test_static(int *a, int num_gangs, int sarg)\n+{\n+  int i, j;\n+\n+  if (sarg == 0)\n+    sarg = 1;\n+\n+  for (i = 0; i < N / sarg; i++)\n+    for (j = 0; j < sarg; j++)\n+      assert (a[i*sarg+j] == i % num_gangs);\n+}\n+\n+int\n+test_nonstatic(int *a, int gangs)\n+{\n+  int i, j;\n+\n+  for (i = 0; i < N; i+=gangs)\n+    for (j = 0; j < gangs; j++)\n+      assert (a[i+j] == i/gangs);\n+}\n+\n+int\n+main ()\n+{\n+  int a[N];\n+  int i, x;\n+\n+#pragma acc parallel loop gang (static:*) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_nonstatic (a, 10);\n+\n+#pragma acc parallel loop gang (static:1) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 1);\n+\n+#pragma acc parallel loop gang (static:2) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 2);\n+\n+#pragma acc parallel loop gang (static:5) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 5);\n+\n+#pragma acc parallel loop gang (static:20) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 20);\n+\n+  /* Non-static gang.  */\n+#pragma acc parallel loop gang num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_nonstatic (a, 10);\n+\n+  /* Static arguments with a variable expression.  */\n+\n+  x = 20;\n+#pragma acc parallel loop gang (static:0+x) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 20);\n+\n+  x = 20;\n+#pragma acc parallel loop gang (static:x) num_gangs (10)\n+  for (i = 0; i < 100; i++)\n+    a[i] = GANG_ID (i);\n+\n+  test_static (a, 10, 20);\n+\n+  return 0;\n+}"}, {"sha": "5398905f4113bf7c9a72a53d89542ddfd08c0591", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/if-1.c", "status": "modified", "additions": 352, "deletions": 2, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-do run } */\n-\n #include <openacc.h>\n #include <stdlib.h>\n #include <stdbool.h>\n@@ -608,5 +606,357 @@ main(int argc, char **argv)\n \tabort ();\n #endif\n \n+    for (i = 0; i < N; i++)\n+        a[i] = 4.0;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 5.0;\n+#else\n+    exp = 4.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 16.0;\n+\n+#pragma acc kernels if(0)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 17.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 8.0;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(one)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 9.0;\n+#else\n+    exp = 8.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 22.0;\n+\n+#pragma acc kernels if(zero)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 23.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 16.0;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(true)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 17.0;\n+#else\n+    exp = 16.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 76.0;\n+\n+#pragma acc kernels if(false)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 77.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 22.0;\n+\n+    n = 1;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(n)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 23.0;\n+#else\n+    exp = 22.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 18.0;\n+\n+    n = 0;\n+\n+#pragma acc kernels if(n)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 19.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 49.0;\n+\n+    n = 1;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(n + n)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 50.0;\n+#else\n+    exp = 49.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 38.0;\n+\n+    n = 0;\n+\n+#pragma acc kernels if(n + n)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 39.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 91.0;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(-2)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 92.0;\n+#else\n+    exp = 91.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 43.0;\n+\n+#pragma acc kernels copyin(a[0:N]) copyout(b[0:N]) if(one == 1)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 44.0;\n+#else\n+    exp = 43.0;\n+#endif\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != exp)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+        a[i] = 87.0;\n+\n+#pragma acc kernels if(one == 0)\n+    {\n+        int ii;\n+\n+        for (ii = 0; ii < N; ii++)\n+        {\n+            if (acc_on_device (acc_device_host))\n+                b[ii] = a[ii] + 1;\n+            else\n+                b[ii] = a[ii];\n+        }\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (b[i] != 88.0)\n+            abort();\n+    }\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 3.0;\n+        b[i] = 9.0;\n+    }\n+\n+#if ACC_MEM_SHARED\n+    exp = 0.0;\n+    exp2 = 0.0;\n+#else\n+    acc_map_data (a, d_a, N * sizeof (float));\n+    acc_map_data (b, d_b, N * sizeof (float));\n+    exp = 3.0;\n+    exp2 = 9.0;\n+#endif\n+\n     return 0;\n }"}, {"sha": "3acfdf55ef6f92019f6b5e1ca7caa97487afbdc6", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-1.c", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,184 +0,0 @@\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-int i;\n-\n-int main (void)\n-{\n-  int j, v;\n-\n-#if 0\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) copyin (i, j)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != -1 || j != -2)\n-    abort ();\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) copyout (i, j)\n-  {\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) copy (i, j)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) create (i, j)\n-  {\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != -1 || j != -2)\n-    abort ();\n-#endif\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) present_or_copyin (i, j)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1)\n-    abort ();\n-#if ACC_MEM_SHARED\n-  if (i != 2 || j != 1)\n-    abort ();\n-#else\n-  if (i != -1 || j != -2)\n-    abort ();\n-#endif\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) present_or_copyout (i, j)\n-  {\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) present_or_copy (i, j)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) present_or_create (i, j)\n-  {\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1)\n-    abort ();\n-#if ACC_MEM_SHARED\n-  if (i != 2 || j != 1)\n-    abort ();\n-#else\n-  if (i != -1 || j != -2)\n-    abort ();\n-#endif\n-\n-#if 0\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v) present (i, j)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-#endif\n-\n-#if 0\n-  i = -1;\n-  j = -2;\n-  v = 0;\n-#pragma acc kernels /* copyout */ present_or_copyout (v)\n-  {\n-    if (i != -1 || j != -2)\n-      abort ();\n-    i = 2;\n-    j = 1;\n-    if (i != 2 || j != 1)\n-      abort ();\n-    v = 1;\n-  }\n-  if (v != 1 || i != 2 || j != 1)\n-    abort ();\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "2c424973eb1716cfea17ccd141694dfbf0dbe329", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-loop-clauses.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-loop-clauses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-loop-clauses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-loop-clauses.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,62 @@\n+/* Exercise the auto, independent, seq and tile loop clauses inside\n+   kernels regions.  */\n+\n+#include <assert.h>\n+\n+#define N 100\n+\n+void\n+check (int *a, int *b)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    assert (a[i] == b[i]);\n+}\n+\n+int\n+main ()\n+{\n+  int i, a[N], b[N];\n+\n+#pragma acc kernels copy(a)\n+  {\n+#pragma acc loop auto\n+    for (i = 0; i < N; i++)\n+      a[i] = i;\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    b[i] = i;\n+\n+  check (a, b);\n+\n+#pragma acc kernels copyout(a)\n+  {\n+#pragma acc loop independent\n+    for (i = 0; i < N; i++)\n+      a[i] = i;\n+  }\n+\n+  check (a, b);\n+\n+#pragma acc kernels present_or_copy(a)\n+  {\n+#pragma acc loop seq\n+    for (i = 0; i < N; i++)\n+      a[i] = i;\n+  }\n+\n+  check (a, b);\n+\n+#pragma acc kernels pcopyout(a) present_or_copyin(b)\n+  {\n+#pragma acc loop seq\n+    for (i = 0; i < N; i++)\n+      a[i] = b[i];\n+  }\n+\n+  check (a, b);\n+\n+  return 0;\n+}"}, {"sha": "2394ac8cbd60076814222b8fb3e6c4cb99fb8ee1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/mode-transitions.c", "status": "added", "additions": 895, "deletions": 0, "changes": 895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmode-transitions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmode-transitions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmode-transitions.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,895 @@\n+/* Miscellaneous test cases for gang/worker/vector mode transitions.  */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <math.h>\n+#include <openacc.h>\n+\n+\n+/* Test basic vector-partitioned mode transitions.  */\n+\n+void t1()\n+{\n+  int n = 0, arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  #pragma acc parallel copy(n, arr) \\\n+\t\t       num_gangs(1) num_workers(1) vector_length(32)\n+  {\n+    int j;\n+    n++;\n+    #pragma acc loop vector\n+    for (j = 0; j < 32; j++)\n+      arr[j]++;\n+    n++;\n+  }\n+\n+  assert (n == 2);\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 1);\n+}\n+\n+\n+/* Test vector-partitioned, gang-partitioned mode.  */\n+\n+void t2()\n+{\n+  int n[32], arr[1024], i;\n+  \n+  for (i = 0; i < 1024; i++)\n+    arr[i] = 0;\n+\n+  for (i = 0; i < 32; i++)\n+    n[i] = 0;\n+\n+  #pragma acc parallel copy(n, arr) \\\n+\t\t       num_gangs(32) num_workers(1) vector_length(32)\n+  {\n+    int j, k;\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      #pragma acc loop vector\n+      for (k = 0; k < 32; k++)\n+\tarr[j * 32 + k]++;\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (n[i] == 2);\n+\n+  for (i = 0; i < 1024; i++)\n+    assert (arr[i] == 1);\n+}\n+\n+\n+/* Test conditions inside vector-partitioned loops.  */\n+\n+void t4()\n+{\n+  int n[32], arr[1024], i;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  for (i = 0; i < 32; i++)\n+    n[i] = 0;\n+\n+  #pragma acc parallel copy(n, arr) \\\n+\t\t       num_gangs(32) num_workers(1) vector_length(32)\n+  {\n+    int j, k;\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\t#pragma acc loop vector\n+\tfor (k = 0; k < 32; k++)\n+\t  if ((arr[j * 32 + k] % 2) != 0)\n+\t    arr[j * 32 + k] *= 2;\n+      }\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (n[i] == 2);\n+\n+  for (i = 0; i < 1024; i++)\n+    assert (arr[i] == ((i % 2) == 0 ? i : i * 2));\n+}\n+\n+\n+/* Test conditions inside gang-partitioned/vector-partitioned loops.  */\n+\n+void t5()\n+{\n+  int n[32], arr[1024], i;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  for (i = 0; i < 32; i++)\n+    n[i] = 0;\n+\n+  #pragma acc parallel copy(n, arr) \\\n+\t\t       num_gangs(32) num_workers(1) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+\n+    #pragma acc loop gang vector\n+    for (j = 0; j < 1024; j++)\n+      if ((arr[j] % 2) != 0)\n+\tarr[j] *= 2;\n+\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 32; j++)\n+      n[j]++;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (n[i] == 2);\n+\n+  for (i = 0; i < 1024; i++)\n+    assert (arr[i] == ((i % 2) == 0 ? i : i * 2));\n+}\n+\n+\n+/* Test trivial operation of vector-single mode.  */\n+\n+void t7()\n+{\n+  int n = 0;\n+  #pragma acc parallel copy(n) \\\n+\t\t       num_gangs(1) num_workers(1) vector_length(32)\n+  {\n+    n++;\n+  }\n+  assert (n == 1);\n+}\n+\n+\n+/* Test vector-single, gang-partitioned mode.  */\n+\n+void t8()\n+{\n+  int arr[1024];\n+  int gangs;\n+\n+  for (gangs = 1; gangs <= 1024; gangs <<= 1)\n+    {\n+      int i;\n+\n+      for (i = 0; i < 1024; i++)\n+\tarr[i] = 0;\n+\n+      #pragma acc parallel copy(arr) \\\n+\t\t\t   num_gangs(gangs) num_workers(1) vector_length(32)\n+      {\n+\tint j;\n+\t#pragma acc loop gang\n+\tfor (j = 0; j < 1024; j++)\n+\t  arr[j]++;\n+      }\n+\n+      for (i = 0; i < 1024; i++)\n+\tassert (arr[i] == 1);\n+    }\n+}\n+\n+\n+/* Test conditions in vector-single mode.  */\n+\n+void t9()\n+{\n+  int arr[1024];\n+  int gangs;\n+\n+  for (gangs = 1; gangs <= 1024; gangs <<= 1)\n+    {\n+      int i;\n+\n+      for (i = 0; i < 1024; i++)\n+\tarr[i] = 0;\n+\n+      #pragma acc parallel copy(arr) \\\n+\t\t\t   num_gangs(gangs) num_workers(1) vector_length(32)\n+      {\n+\tint j;\n+\t#pragma acc loop gang\n+\tfor (j = 0; j < 1024; j++)\n+\t  if ((j % 3) == 0)\n+\t    arr[j]++;\n+\t  else\n+\t    arr[j] += 2;\n+      }\n+\n+      for (i = 0; i < 1024; i++)\n+\tassert (arr[i] == ((i % 3) == 0) ? 1 : 2);\n+    }\n+}\n+\n+\n+/* Test switch in vector-single mode.  */\n+\n+void t10()\n+{\n+  int arr[1024];\n+  int gangs;\n+\n+  for (gangs = 1; gangs <= 1024; gangs <<= 1)\n+    {\n+      int i;\n+\n+      for (i = 0; i < 1024; i++)\n+\tarr[i] = 0;\n+\n+      #pragma acc parallel copy(arr) \\\n+\t\t\t   num_gangs(gangs) num_workers(1) vector_length(32)\n+      {\n+\tint j;\n+\t#pragma acc loop gang\n+\tfor (j = 0; j < 1024; j++)\n+\t  switch (j % 5)\n+\t    {\n+\t    case 0: arr[j] += 1; break;\n+\t    case 1: arr[j] += 2; break;\n+\t    case 2: arr[j] += 3; break;\n+\t    case 3: arr[j] += 4; break;\n+\t    case 4: arr[j] += 5; break;\n+\t    default: arr[j] += 99;\n+\t    }\n+      }\n+\n+      for (i = 0; i < 1024; i++)\n+\tassert (arr[i] == (i % 5) + 1);\n+    }\n+}\n+\n+\n+/* Test switch in vector-single mode, initialise array on device.  */\n+\n+void t11()\n+{\n+  int arr[1024];\n+  int i;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = 99;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(1024) num_workers(1) vector_length(32)\n+  {\n+    int j;\n+\n+    /* This loop and the one following must be distributed to available gangs\n+       in the same way to ensure data dependencies are not violated (hence the\n+       \"static\" clauses).  */\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 1024; j++)\n+      arr[j] = 0;\n+    \n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < 1024; j++)\n+      switch (j % 5)\n+\t{\n+\tcase 0: arr[j] += 1; break;\n+\tcase 1: arr[j] += 2; break;\n+\tcase 2: arr[j] += 3; break;\n+\tcase 3: arr[j] += 4; break;\n+\tcase 4: arr[j] += 5; break;\n+\tdefault: arr[j] += 99;\n+\t}\n+  }\n+\n+  for (i = 0; i < 1024; i++)\n+    assert (arr[i] == (i % 5) + 1);\n+}\n+\n+\n+/* Test multiple conditions in vector-single mode.  */\n+\n+#define NUM_GANGS 4096\n+void t12()\n+{\n+  bool fizz[NUM_GANGS], buzz[NUM_GANGS], fizzbuzz[NUM_GANGS];\n+  int i;\n+\n+  #pragma acc parallel copyout(fizz, buzz, fizzbuzz) \\\n+\t\t       num_gangs(NUM_GANGS) num_workers(1) vector_length(32)\n+  {\n+    int j;\n+    \n+    /* This loop and the one following must be distributed to available gangs\n+       in the same way to ensure data dependencies are not violated (hence the\n+       \"static\" clauses).  */\n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < NUM_GANGS; j++)\n+      fizz[j] = buzz[j] = fizzbuzz[j] = 0;\n+    \n+    #pragma acc loop gang(static:*)\n+    for (j = 0; j < NUM_GANGS; j++)\n+      {\n+\tif ((j % 3) == 0 && (j % 5) == 0)\n+\t  fizzbuzz[j] = 1;\n+\telse\n+\t  {\n+\t    if ((j % 3) == 0)\n+\t      fizz[j] = 1;\n+\t    else if ((j % 5) == 0)\n+\t      buzz[j] = 1;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < NUM_GANGS; i++)\n+    {\n+      assert (fizzbuzz[i] == ((i % 3) == 0 && (i % 5) == 0));\n+      assert (fizz[i] == ((i % 3) == 0 && (i % 5) != 0));\n+      assert (buzz[i] == ((i % 3) != 0 && (i % 5) == 0));\n+    }\n+}\n+#undef NUM_GANGS\n+\n+\n+/* Test worker-partitioned/vector-single mode.  */\n+\n+void t13()\n+{\n+  int arr[32 * 8], i;\n+\n+  for (i = 0; i < 32 * 8; i++)\n+    arr[i] = 0;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\tint k;\n+\t#pragma acc loop worker\n+\tfor (k = 0; k < 8; k++)\n+          arr[j * 8 + k] += j * 8 + k;\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 8; i++)\n+    assert (arr[i] == i);\n+}\n+\n+\n+/* Test worker-single/worker-partitioned transitions.  */\n+\n+void t16()\n+{\n+  int n[32], arr[32 * 32], i;\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = 0;\n+\n+  for (i = 0; i < 32; i++)\n+    n[i] = 0;\n+\n+  #pragma acc parallel copy(n, arr) \\\n+\t\t       num_gangs(8) num_workers(16) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\tint k;\n+\n+\tn[j]++;\n+\n+\t#pragma acc loop worker\n+\tfor (k = 0; k < 32; k++)\n+          arr[j * 32 + k]++;\n+\n+\tn[j]++;\n+\n+\t#pragma acc loop worker\n+\tfor (k = 0; k < 32; k++)\n+          arr[j * 32 + k]++;\n+\n+\tn[j]++;\n+\n+\t#pragma acc loop worker\n+\tfor (k = 0; k < 32; k++)\n+          arr[j * 32 + k]++;\n+\n+\tn[j]++;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (n[i] == 4);\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == 3);\n+}\n+\n+\n+/* Test correct synchronisation between worker-partitioned loops.  */\n+\n+void t17()\n+{\n+  int arr_a[32 * 32], arr_b[32 * 32], i;\n+  int num_workers, num_gangs;\n+\n+  for (num_workers = 1; num_workers <= 32; num_workers <<= 1)\n+    for (num_gangs = 1; num_gangs <= 32; num_gangs <<= 1)\n+      {\n+\tfor (i = 0; i < 32 * 32; i++)\n+\t  arr_a[i] = i;\n+\n+\t#pragma acc parallel copyin(arr_a) copyout(arr_b) \\\n+\t\t\t     num_gangs(num_gangs) num_workers(num_workers) vector_length(32)\n+\t{\n+\t  int j;\n+\t  #pragma acc loop gang\n+\t  for (j = 0; j < 32; j++)\n+\t    {\n+\t      int k;\n+\n+\t      #pragma acc loop worker\n+\t      for (k = 0; k < 32; k++)\n+        \tarr_b[j * 32 + (31 - k)] = arr_a[j * 32 + k] * 2;\n+\n+\t      #pragma acc loop worker\n+\t      for (k = 0; k < 32; k++)\n+        \tarr_a[j * 32 + (31 - k)] = arr_b[j * 32 + k] * 2;\n+\n+\t      #pragma acc loop worker\n+\t      for (k = 0; k < 32; k++)\n+        \tarr_b[j * 32 + (31 - k)] = arr_a[j * 32 + k] * 2;\n+\t    }\n+\t}\n+\n+\tfor (i = 0; i < 32 * 32; i++)\n+\t  assert (arr_b[i] == (i ^ 31) * 8);\n+      }\n+}\n+\n+\n+/* Test correct synchronisation between worker+vector-partitioned loops.  */\n+\n+void t18()\n+{\n+  int arr_a[32 * 32 * 32], arr_b[32 * 32 * 32], i;\n+  int num_workers, num_gangs;\n+\n+  for (num_workers = 1; num_workers <= 32; num_workers <<= 1)\n+    for (num_gangs = 1; num_gangs <= 32; num_gangs <<= 1)\n+      {\n+\tfor (i = 0; i < 32 * 32 * 32; i++)\n+\t  arr_a[i] = i;\n+\n+\t#pragma acc parallel copyin(arr_a) copyout(arr_b) \\\n+\t\t\t     num_gangs(num_gangs) num_workers(num_workers) vector_length(32)\n+\t{\n+\t  int j;\n+\t  #pragma acc loop gang\n+\t  for (j = 0; j < 32; j++)\n+\t    {\n+\t      int k;\n+\n+\t      #pragma acc loop worker vector\n+\t      for (k = 0; k < 32 * 32; k++)\n+        \tarr_b[j * 32 * 32 + (1023 - k)] = arr_a[j * 32 * 32 + k] * 2;\n+\n+\t      #pragma acc loop worker vector\n+\t      for (k = 0; k < 32 * 32; k++)\n+        \tarr_a[j * 32 * 32 + (1023 - k)] = arr_b[j * 32 * 32 + k] * 2;\n+\n+\t      #pragma acc loop worker vector\n+\t      for (k = 0; k < 32 * 32; k++)\n+        \tarr_b[j * 32 * 32 + (1023 - k)] = arr_a[j * 32 * 32 + k] * 2;\n+\t    }\n+\t}\n+\n+\tfor (i = 0; i < 32 * 32 * 32; i++)\n+\t  assert (arr_b[i] == (i ^ 1023) * 8);\n+      }\n+}\n+\n+\n+/* Test correct synchronisation between vector-partitioned loops in\n+   worker-partitioned mode.  */\n+\n+void t19()\n+{\n+  int n[32 * 32], arr_a[32 * 32 * 32], arr_b[32 * 32 * 32], i;\n+  int num_workers, num_gangs;\n+\n+  for (num_workers = 1; num_workers <= 32; num_workers <<= 1)\n+    for (num_gangs = 1; num_gangs <= 32; num_gangs <<= 1)\n+      {\n+\tfor (i = 0; i < 32 * 32 * 32; i++)\n+\t  arr_a[i] = i;\n+\n+\tfor (i = 0; i < 32 * 32; i++)\n+          n[i] = 0;\n+\n+\t#pragma acc parallel copy (n) copyin(arr_a) copyout(arr_b) \\\n+\t\t\t     num_gangs(num_gangs) num_workers(num_workers) vector_length(32)\n+\t{\n+\t  int j;\n+\t  #pragma acc loop gang\n+\t  for (j = 0; j < 32; j++)\n+\t    {\n+\t      int k;\n+\n+\t      #pragma acc loop worker\n+\t      for (k = 0; k < 32; k++)\n+\t\t{\n+\t\t  int m;\n+\n+\t\t  n[j * 32 + k]++;\n+\n+\t\t  #pragma acc loop vector\n+\t\t  for (m = 0; m < 32; m++)\n+\t\t    {\n+\t              if (((j * 1024 + k * 32 + m) % 2) == 0)\n+\t\t\tarr_b[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_a[j * 1024 + k * 32 + m] * 2;\n+\t\t      else\n+\t\t\tarr_b[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_a[j * 1024 + k * 32 + m] * 3;\n+\t\t    }\n+\n+\t\t  /* Test returning to vector-single mode...  */\n+\t\t  n[j * 32 + k]++;\n+\n+\t\t  #pragma acc loop vector\n+\t\t  for (m = 0; m < 32; m++)\n+\t\t    {\n+\t              if (((j * 1024 + k * 32 + m) % 3) == 0)\n+\t\t\tarr_a[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_b[j * 1024 + k * 32 + m] * 5;\n+\t\t      else\n+\t\t\tarr_a[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_b[j * 1024 + k * 32 + m] * 7;\n+\t\t    }\n+\n+\t\t  /* ...and back-to-back vector loops.  */\n+\n+\t\t  #pragma acc loop vector\n+\t\t  for (m = 0; m < 32; m++)\n+\t\t    {\n+\t              if (((j * 1024 + k * 32 + m) % 2) == 0)\n+\t\t\tarr_b[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_a[j * 1024 + k * 32 + m] * 3;\n+\t\t      else\n+\t\t\tarr_b[j * 1024 + k * 32 + (31 - m)]\n+\t\t\t  = arr_a[j * 1024 + k * 32 + m] * 2;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+\tfor (i = 0; i < 32 * 32; i++)\n+          assert (n[i] == 2);\n+\n+\tfor (i = 0; i < 32 * 32 * 32; i++)\n+          {\n+\t    int m = 6 * ((i % 3) == 0 ? 5 : 7);\n+\t    assert (arr_b[i] == (i ^ 31) * m);\n+\t  }\n+      }\n+}\n+\n+\n+/* With -O0, variables are on the stack, not in registers.  Check that worker\n+   state propagation handles the stack frame.  */\n+\n+void t20()\n+{\n+  int w0 = 0;\n+  int w1 = 0;\n+  int w2 = 0;\n+  int w3 = 0;\n+  int w4 = 0;\n+  int w5 = 0;\n+  int w6 = 0;\n+  int w7 = 0;\n+\n+  int i;\n+\n+#pragma acc parallel copy (w0, w1, w2, w3, w4, w5, w6, w7) \\\n+\t\t     num_gangs (1) num_workers (8)\n+  {\n+    int internal = 100;\n+\n+#pragma acc loop worker\n+    for (i = 0; i < 8; i++)\n+      {\n+\tswitch (i)\n+\t  {\n+\t  case 0: w0 = internal; break;\n+\t  case 1: w1 = internal; break;\n+\t  case 2: w2 = internal; break;\n+\t  case 3: w3 = internal; break;\n+\t  case 4: w4 = internal; break;\n+\t  case 5: w5 = internal; break;\n+\t  case 6: w6 = internal; break;\n+\t  case 7: w7 = internal; break;\n+\t  default: break;\n+\t  }\n+      }\n+  }\n+\n+  if (w0 != 100\n+      || w1 != 100\n+      || w2 != 100\n+      || w3 != 100\n+      || w4 != 100\n+      || w5 != 100\n+      || w6 != 100\n+      || w7 != 100)\n+    __builtin_abort ();\n+}\n+\n+\n+/* Test worker-single/vector-single mode.  */\n+\n+void t21()\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      arr[j]++;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 1);\n+}\n+\n+\n+/* Test worker-single/vector-single mode.  */\n+\n+void t22()\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\t#pragma acc atomic\n+\tarr[j]++;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 1);\n+}\n+\n+\n+/* Test condition in worker-single/vector-single mode.  */\n+\n+void t23()\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      if ((arr[j] % 2) != 0)\n+\tarr[j]++;\n+      else\n+\tarr[j] += 2;\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == ((i % 2) != 0) ? i + 1 : i + 2);\n+}\n+\n+\n+/* Test switch in worker-single/vector-single mode.  */\n+\n+void t24()\n+{\n+  int arr[32], i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      switch (arr[j] % 5)\n+\t{\n+\tcase 0: arr[j] += 1; break;\n+\tcase 1: arr[j] += 2; break;\n+\tcase 2: arr[j] += 3; break;\n+\tcase 3: arr[j] += 4; break;\n+\tcase 4: arr[j] += 5; break;\n+\tdefault: arr[j] += 99;\n+\t}\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == i + (i % 5) + 1);\n+}\n+\n+\n+/* Test worker-single/vector-partitioned mode.  */\n+\n+void t25()\n+{\n+  int arr[32 * 32], i;\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) \\\n+\t\t       num_gangs(8) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+    #pragma acc loop gang\n+    for (j = 0; j < 32; j++)\n+      {\n+\tint k;\n+\t#pragma acc loop vector\n+\tfor (k = 0; k < 32; k++)\n+\t  {\n+\t    #pragma acc atomic\n+\t    arr[j * 32 + k]++;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + 1);\n+}\n+\n+\n+/* Test worker-single, vector-partitioned, gang-redundant mode.  */\n+\n+#define ACTUAL_GANGS 8\n+void t27()\n+{\n+  int n, arr[32], i;\n+  int ondev;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 0;\n+\n+  n = 0;\n+\n+  #pragma acc parallel copy(n, arr) copyout(ondev) \\\n+\t  num_gangs(ACTUAL_GANGS) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+\n+    ondev = acc_on_device (acc_device_not_host);\n+\n+    #pragma acc atomic\n+    n++;\n+\n+    #pragma acc loop vector\n+    for (j = 0; j < 32; j++)\n+      {\n+\t#pragma acc atomic\n+\tarr[j] += 1;\n+      }\n+\n+    #pragma acc atomic\n+    n++;\n+  }\n+\n+  int m = ondev ? ACTUAL_GANGS : 1;\n+  \n+  assert (n == m * 2);\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == m);\n+}\n+#undef ACTUAL_GANGS\n+\n+\n+/* Check if worker-single variables get broadcastd to vectors.  */\n+\n+#pragma acc routine\n+float t28_routine ()\n+{\n+  return 2.71;\n+}\n+\n+#define N 32\n+void t28()\n+{\n+  float threads[N], v1 = 3.14;\n+\n+  for (int i = 0; i < N; i++)\n+    threads[i] = -1;\n+\n+#pragma acc parallel num_gangs (1) vector_length (32) copy (v1)\n+  {\n+    float val = t28_routine ();\n+\n+#pragma acc loop vector\n+    for (int i = 0; i < N; i++)\n+      threads[i] = val + v1*i;\n+  }\n+\n+  for (int i = 0; i < N; i++)\n+    assert (fabs (threads[i] - (t28_routine () + v1*i)) < 0.0001);\n+}\n+#undef N\n+\n+\n+int main()\n+{\n+  t1();\n+  t2();\n+  t4();\n+  t5();\n+  t7();\n+  t8();\n+  t9();\n+  t10();\n+  t11();\n+  t12();\n+  t13();\n+  t16();\n+  t17();\n+  t18();\n+  t19();\n+  t20();\n+  t21();\n+  t22();\n+  t23();\n+  t24();\n+  t25();\n+  t27();\n+  t28();\n+\n+  return 0;\n+}"}, {"sha": "53f03d17bb2f96b98b7ed385cb1d146d8b390762", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/private-variables.c", "status": "added", "additions": 953, "deletions": 0, "changes": 953, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-variables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-variables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-variables.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,953 @@\n+#include <assert.h>\n+#include <openacc.h>\n+\n+typedef struct {\n+  int x, y;\n+} vec2;\n+\n+typedef struct {\n+  int x, y, z;\n+  int attr[13];\n+} vec3_attr;\n+\n+\n+/* Test of gang-private variables declared in local scope with parallel\n+   directive.  */\n+\n+void local_g_1()\n+{\n+  int i, arr[32];\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 3;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    int x;\n+\n+    #pragma acc loop gang(static:1)\n+    for (i = 0; i < 32; i++)\n+      x = i * 2;\n+\n+    #pragma acc loop gang(static:1)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tif (acc_on_device (acc_device_host))\n+\t  x = i * 2;\n+\tarr[i] += x;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 3 + i * 2);\n+}\n+\n+\n+/* Test of worker-private variables declared in a local scope, broadcasting\n+   to vector-partitioned mode.  Back-to-back worker loops.  */\n+\n+void local_w_1()\n+{\n+  int i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    int x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+\n+\t#pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    int x = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared in a local scope, broadcasting\n+   to vector-partitioned mode.  Successive vector loops.  */\n+\n+void local_w_2()\n+{\n+  int i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    int x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t    \n+\t    x = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared in a local scope, broadcasting\n+   to vector-partitioned mode.  Aggregate worker variable.  */\n+\n+void local_w_3()\n+{\n+  int i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    vec2 pt;\n+\t    \n+\t    pt.x = i ^ j * 3;\n+\t    pt.y = i | j * 5;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt.x * k;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared in a local scope, broadcasting\n+   to vector-partitioned mode.  Addressable worker variable.  */\n+\n+void local_w_4()\n+{\n+  int i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    vec2 pt, *ptp;\n+\t    \n+\t    ptp = &pt;\n+\t    \n+\t    pt.x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += ptp->x * k;\n+\n+\t    ptp->y = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared in a local scope, broadcasting\n+   to vector-partitioned mode.  Array worker variable.  */\n+\n+void local_w_5()\n+{\n+  int i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    int pt[2];\n+\t    \n+\t    pt[0] = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt[0] * k;\n+\n+\t    pt[1] = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of gang-private variables declared on loop directive.  */\n+\n+void loop_g_1()\n+{\n+  int x = 5, i, arr[32];\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(x)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tx = i * 2;\n+\tarr[i] += x;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == i * 3);\n+}\n+\n+\n+/* Test of gang-private variables declared on loop directive, with broadcasting\n+   to partitioned workers.  */\n+\n+void loop_g_2()\n+{\n+  int x = 5, i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(x)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tx = i * 2;\n+\n+\t#pragma acc loop worker\n+\tfor (int j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += x;\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (i / 32) * 2);\n+}\n+\n+\n+/* Test of gang-private variables declared on loop directive, with broadcasting\n+   to partitioned vectors.  */\n+\n+void loop_g_3()\n+{\n+  int x = 5, i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(x)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tx = i * 2;\n+\n+\t#pragma acc loop vector\n+\tfor (int j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += x;\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (i / 32) * 2);\n+}\n+\n+\n+/* Test of gang-private addressable variable declared on loop directive, with\n+   broadcasting to partitioned workers.  */\n+\n+void loop_g_4()\n+{\n+  int x = 5, i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(x)\n+    for (i = 0; i < 32; i++)\n+      {\n+        int *p = &x;\n+\n+\tx = i * 2;\n+\n+\t#pragma acc loop worker\n+\tfor (int j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += x;\n+\n+\t(*p)--;\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (i / 32) * 2);\n+}\n+\n+\n+/* Test of gang-private array variable declared on loop directive, with\n+   broadcasting to partitioned workers.  */\n+\n+void loop_g_5()\n+{\n+  int x[8], i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(x)\n+    for (i = 0; i < 32; i++)\n+      {\n+        for (int j = 0; j < 8; j++)\n+\t  x[j] = j * 2;\n+\n+\t#pragma acc loop worker\n+\tfor (int j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += x[j % 8];\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (i % 8) * 2);\n+}\n+\n+\n+/* Test of gang-private aggregate variable declared on loop directive, with\n+   broadcasting to partitioned workers.  */\n+\n+void loop_g_6()\n+{\n+  int i, arr[32 * 32];\n+  vec3_attr pt;\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang private(pt)\n+    for (i = 0; i < 32; i++)\n+      {\n+        pt.x = i;\n+\tpt.y = i * 2;\n+\tpt.z = i * 4;\n+\tpt.attr[5] = i * 6;\n+\n+\t#pragma acc loop worker\n+\tfor (int j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += pt.x + pt.y + pt.z + pt.attr[5];\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (i / 32) * 13);\n+}\n+\n+\n+/* Test of vector-private variables declared on loop directive.  */\n+\n+void loop_v_1()\n+{\n+  int x, i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\n+\t    #pragma acc loop vector private(x)\n+\t    for (k = 0; k < 32; k++)\n+\t      {\n+\t\tx = i ^ j * 3;\n+\t\tarr[i * 1024 + j * 32 + k] += x * k;\n+\t      }\n+\n+\t    #pragma acc loop vector private(x)\n+\t    for (k = 0; k < 32; k++)\n+\t      {\n+\t\tx = i | j * 5;\n+\t\tarr[i * 1024 + j * 32 + k] += x * k;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of vector-private variables declared on loop directive. Array type.  */\n+\n+void loop_v_2()\n+{\n+  int pt[2], i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\n+\t    #pragma acc loop vector private(pt)\n+\t    for (k = 0; k < 32; k++)\n+\t      {\n+\t        pt[0] = i ^ j * 3;\n+\t\tpt[1] = i | j * 5;\n+\t\tarr[i * 1024 + j * 32 + k] += pt[0] * k;\n+\t\tarr[i * 1024 + j * 32 + k] += pt[1] * k;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive.  */\n+\n+void loop_w_1()\n+{\n+  int x = 5, i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    x = i ^ j * 3;\n+\t    /* Try to ensure 'x' accesses doesn't get optimized into a\n+\t       temporary.  */\n+\t    __asm__ __volatile__ (\"\");\n+\t    arr[i * 32 + j] += x;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + ((i / 32) ^ (i % 32) * 3));\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive, broadcasting\n+   to vector-partitioned mode.  */\n+\n+void loop_w_2()\n+{\n+  int x = 5, i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive, broadcasting\n+   to vector-partitioned mode.  Back-to-back worker loops.  */\n+\n+void loop_w_3()\n+{\n+  int x = 5, i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+\n+\t#pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    x = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive, broadcasting\n+   to vector-partitioned mode.  Successive vector loops.  */\n+\n+void loop_w_4()\n+{\n+  int x = 5, i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t    \n+\t    x = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive, broadcasting\n+   to vector-partitioned mode.  Addressable worker variable.  */\n+\n+void loop_w_5()\n+{\n+  int x = 5, i, arr[32 * 32 * 32];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(x)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    int *p = &x;\n+\t    \n+\t    x = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t    \n+\t    *p = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += x * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on a loop directive, broadcasting\n+   to vector-partitioned mode.  Aggregate worker variable.  */\n+\n+void loop_w_6()\n+{\n+  int i, arr[32 * 32 * 32];\n+  vec2 pt;\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        #pragma acc loop worker private(pt)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    \n+\t    pt.x = i ^ j * 3;\n+\t    pt.y = i | j * 5;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt.x * k;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of worker-private variables declared on loop directive, broadcasting\n+   to vector-partitioned mode.  Array worker variable.  */\n+\n+void loop_w_7()\n+{\n+  int i, arr[32 * 32 * 32];\n+  int pt[2];\n+\n+  for (i = 0; i < 32 * 32 * 32; i++)\n+    arr[i] = i;\n+\n+  /* \"pt\" is treated as \"present_or_copy\" on the parallel directive because it\n+     is an array variable.  */\n+  #pragma acc parallel copy(arr) num_gangs(32) num_workers(32) vector_length(32)\n+  {\n+    int j;\n+\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        /* But here, it is made private per-worker.  */\n+        #pragma acc loop worker private(pt)\n+\tfor (j = 0; j < 32; j++)\n+\t  {\n+\t    int k;\n+\t    \n+\t    pt[0] = i ^ j * 3;\n+\n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt[0] * k;\n+\n+\t    pt[1] = i | j * 5;\n+\t    \n+\t    #pragma acc loop vector\n+\t    for (k = 0; k < 32; k++)\n+\t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    for (int j = 0; j < 32; j++)\n+      for (int k = 0; k < 32; k++)\n+        {\n+\t  int idx = i * 1024 + j * 32 + k;\n+          assert (arr[idx] == idx + (i ^ j * 3) * k + (i | j * 5) * k);\n+\t}\n+}\n+\n+\n+/* Test of gang-private variables declared on the parallel directive.  */\n+\n+void parallel_g_1()\n+{\n+  int x = 5, i, arr[32];\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = 3;\n+\n+  #pragma acc parallel private(x) copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  {\n+    #pragma acc loop gang(static:1)\n+    for (i = 0; i < 32; i++)\n+      x = i * 2;\n+\n+    #pragma acc loop gang(static:1)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tif (acc_on_device (acc_device_host))\n+\t  x = i * 2;\n+\tarr[i] += x;\n+      }\n+  }\n+\n+  for (i = 0; i < 32; i++)\n+    assert (arr[i] == 3 + i * 2);\n+}\n+\n+\n+/* Test of gang-private array variable declared on the parallel directive.  */\n+\n+void parallel_g_2()\n+{\n+  int x[32], i, arr[32 * 32];\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel private(x) copy(arr) num_gangs(32) num_workers(2) vector_length(32)\n+  {\n+    #pragma acc loop gang\n+    for (i = 0; i < 32; i++)\n+      {\n+        int j;\n+\tfor (j = 0; j < 32; j++)\n+\t  x[j] = j * 2;\n+\t\n+\t#pragma acc loop worker\n+\tfor (j = 0; j < 32; j++)\n+\t  arr[i * 32 + j] += x[31 - j];\n+      }\n+  }\n+\n+  for (i = 0; i < 32 * 32; i++)\n+    assert (arr[i] == i + (31 - (i % 32)) * 2);\n+}\n+\n+\n+int main ()\n+{\n+  local_g_1();\n+  local_w_1();\n+  local_w_2();\n+  local_w_3();\n+  local_w_4();\n+  local_w_5();\n+  loop_g_1();\n+  loop_g_2();\n+  loop_g_3();\n+  loop_g_4();\n+  loop_g_5();\n+  loop_g_6();\n+  loop_v_1();\n+  loop_v_2();\n+  loop_w_1();\n+  loop_w_2();\n+  loop_w_3();\n+  loop_w_4();\n+  loop_w_5();\n+  loop_w_6();\n+  loop_w_7();\n+  parallel_g_1();\n+  parallel_g_2();\n+\n+  return 0;\n+}"}, {"sha": "b23c75877f89f026a72388572bd3946485a20e46", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/reduction-7.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-7.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,129 @@\n+/* Tests of reduction on loop directive.  */\n+\n+#include <assert.h>\n+\n+\n+/* Test of reduction on loop directive (gangs, non-private reduction\n+   variable).  */\n+\n+void g_np_1()\n+{\n+  int i, arr[1024], res = 0, hres = 0;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n+\t\t       copy(res)\n+  {\n+    #pragma acc loop gang reduction(+:res)\n+    for (i = 0; i < 1024; i++)\n+      res += arr[i];\n+  }\n+\n+  for (i = 0; i < 1024; i++)\n+    hres += arr[i];\n+\n+  assert (res == hres);\n+\n+  res = hres = 1;\n+\n+  #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n+\t\t       copy(res)\n+  {\n+    #pragma acc loop gang reduction(*:res)\n+    for (i = 0; i < 12; i++)\n+      res *= arr[i];\n+  }\n+\n+  for (i = 0; i < 12; i++)\n+    hres *= arr[i];\n+\n+  assert (res == hres);\n+}\n+\n+\n+/* Test of reduction on loop directive (gangs and vectors, non-private\n+   reduction variable).  */\n+\n+void gv_np_1()\n+{\n+  int i, arr[1024], res = 0, hres = 0;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n+\t\t       copy(res)\n+  {\n+    #pragma acc loop gang vector reduction(+:res)\n+    for (i = 0; i < 1024; i++)\n+      res += arr[i];\n+  }\n+\n+  for (i = 0; i < 1024; i++)\n+    hres += arr[i];\n+\n+  assert (res == hres);\n+}\n+\n+\n+/* Test of reduction on loop directive (gangs and workers, non-private\n+   reduction variable).  */\n+\n+void gw_np_1()\n+{\n+  int i, arr[1024], res = 0, hres = 0;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n+\t\t       copy(res)\n+  {\n+    #pragma acc loop gang worker reduction(+:res)\n+    for (i = 0; i < 1024; i++)\n+      res += arr[i];\n+  }\n+\n+  for (i = 0; i < 1024; i++)\n+    hres += arr[i];\n+\n+  assert (res == hres);\n+}\n+\n+\n+/* Test of reduction on loop directive (gangs, workers and vectors, non-private\n+   reduction variable).  */\n+\n+void gwv_np_1()\n+{\n+  int i, arr[1024], res = 0, hres = 0;\n+\n+  for (i = 0; i < 1024; i++)\n+    arr[i] = i;\n+\n+  #pragma acc parallel num_gangs(32) num_workers(32) vector_length(32) \\\n+\t\t       copy(res)\n+  {\n+    #pragma acc loop gang worker vector reduction(+:res)\n+    for (i = 0; i < 1024; i++)\n+      res += arr[i];\n+  }\n+\n+  for (i = 0; i < 1024; i++)\n+    hres += arr[i];\n+\n+  assert (res == hres);\n+}\n+\n+\n+int main()\n+{\n+  g_np_1();\n+  gv_np_1();\n+  gw_np_1();\n+  gwv_np_1();\n+\n+  return 0;\n+}"}, {"sha": "f112457c168ec72f494879ae4df095da534c8b0a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-1.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,88 @@\n+// { dg-additional-options \"-fno-exceptions\" }\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#pragma acc routine\n+int fact(int n)\n+{\n+  if (n == 0 || n == 1)\n+    return 1;\n+  else\n+    return n * fact (n - 1);\n+}\n+\n+int main()\n+{\n+  int *s, *g, *w, *v, *gw, *gv, *wv, *gwv, i, n = 10;\n+\n+  s = (int *) malloc (sizeof (int) * n);\n+  g = (int *) malloc (sizeof (int) * n);\n+  w = (int *) malloc (sizeof (int) * n);\n+  v = (int *) malloc (sizeof (int) * n);\n+  gw = (int *) malloc (sizeof (int) * n);\n+  gv = (int *) malloc (sizeof (int) * n);\n+  wv = (int *) malloc (sizeof (int) * n);\n+  gwv = (int *) malloc (sizeof (int) * n);\n+\n+#pragma acc parallel loop async copyout(s[0:n]) seq\n+  for (i = 0; i < n; i++)\n+    s[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(g[0:n]) gang\n+  for (i = 0; i < n; i++)\n+    g[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(w[0:n]) worker\n+  for (i = 0; i < n; i++)\n+    w[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(v[0:n]) vector\n+  for (i = 0; i < n; i++)\n+    v[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(gw[0:n]) gang worker\n+  for (i = 0; i < n; i++)\n+    gw[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(gv[0:n]) gang vector\n+  for (i = 0; i < n; i++)\n+    gv[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(wv[0:n]) worker vector\n+  for (i = 0; i < n; i++)\n+    wv[i] = fact (i);\n+\n+#pragma acc parallel loop async copyout(gwv[0:n]) gang worker vector\n+  for (i = 0; i < n; i++)\n+    gwv[i] = fact (i);\n+\n+#pragma acc wait\n+\n+  for (i = 0; i < n; i++)\n+    if (s[i] != fact (i))\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (g[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (w[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (v[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (gw[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (gv[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (wv[i] != s[i])\n+      abort ();\n+  for (i = 0; i < n; i++)\n+    if (gwv[i] != s[i])\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "d6ff44df5a1107b8ded158b2f98db08f7ab23810", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-4.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-4.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,123 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#define M 8\n+#define N 32\n+\n+#pragma acc routine vector\n+void\n+vector (int *a)\n+{\n+  int i;\n+\n+#pragma acc loop vector\n+  for (i = 0; i < N; i++)\n+    a[i] -= a[i]; \n+}\n+\n+#pragma acc routine worker\n+void\n+worker (int *b)\n+{\n+  int i, j;\n+\n+#pragma acc loop worker\n+  for (i = 0; i < N; i++)\n+    {\n+#pragma acc loop vector\n+      for (j = 0; j < M; j++)\n+        b[i * M + j] += b[i  * M + j]; \n+    }\n+}\n+\n+#pragma acc routine gang\n+void\n+gang (int *a)\n+{\n+  int i;\n+\n+#pragma acc loop gang worker vector\n+  for (i = 0; i < N; i++)\n+    a[i] -= i; \n+}\n+\n+#pragma acc routine seq\n+void\n+seq (int *a)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    a[i] += 1;\n+}\n+\n+int\n+main(int argc, char **argv)\n+{\n+  int i;\n+  int a[N];\n+  int b[M * N];\n+\n+  i = 0;\n+\n+  for (i = 0; i < N; i++)\n+    a[i] = 0;\n+\n+#pragma acc parallel copy (a[0:N])\n+  {\n+#pragma acc loop seq\n+    for (i = 0; i < N; i++)\n+      seq (&a[0]);\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != N)\n+\tabort ();\n+    }\n+\n+#pragma acc parallel copy (a[0:N])\n+  {\n+#pragma acc loop seq\n+    for (i = 0; i < N; i++)\n+      gang (&a[0]);\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != N + (N * (-1 * i)))\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    a[i] = i;\n+\n+#pragma acc parallel copy (b[0:M*N])\n+  {\n+    worker (&b[0]);\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != i)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    a[i] = i;\n+\n+#pragma acc parallel copy (a[0:N])\n+  {\n+#pragma acc loop\n+    for (i = 0; i < N; i++)\n+      vector (&a[0]);\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != 0)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "b5cbc9014d6567ba5e0ab2a8e2b48b3722f857d1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/routine-wv-2.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Froutine-wv-2.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,76 @@\n+/* This code uses nvptx inline assembly guarded with acc_on_device, which is\n+   not optimized away at -O0, and then confuses the target assembler.\n+   { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+#include <stdio.h>\n+#include <openacc.h>\n+\n+#define NUM_WORKERS 16\n+#define NUM_VECTORS 32\n+#define WIDTH 64\n+#define HEIGHT 32\n+\n+#define WORK_ID(I,N)\t\t\t\t\t\t\\\n+  (acc_on_device (acc_device_nvidia)\t\t\t\t\\\n+   ? ({unsigned __r;\t\t\t\t\t\t\\\n+       __asm__ volatile (\"mov.u32 %0,%%tid.y;\" : \"=r\" (__r));\t\\\n+       __r; }) : (I % N))\n+#define VEC_ID(I,N)\t\t\t\t\t\t\\\n+  (acc_on_device (acc_device_nvidia)\t\t\t\t\\\n+   ? ({unsigned __r;\t\t\t\t\t\t\\\n+       __asm__ volatile (\"mov.u32 %0,%%tid.x;\" : \"=r\" (__r));\t\\\n+       __r; }) : (I % N))\n+\n+#pragma acc routine worker\n+void __attribute__ ((noinline))\n+  WorkVec (int *ptr, int w, int h, int nw, int nv)\n+{\n+#pragma acc loop worker\n+  for (int i = 0; i < h; i++)\n+#pragma acc loop vector\n+    for (int j = 0; j < w; j++)\n+      ptr[i*w + j] = (WORK_ID (i, nw) << 8) | VEC_ID(j, nv);\n+}\n+\n+int DoWorkVec (int nw)\n+{\n+  int ary[HEIGHT][WIDTH];\n+  int err = 0;\n+\n+  for (int ix = 0; ix != HEIGHT; ix++)\n+    for (int jx = 0; jx != WIDTH; jx++)\n+      ary[ix][jx] = 0xdeadbeef;\n+\n+  printf (\"spawning %d ...\", nw); fflush (stdout);\n+  \n+#pragma acc parallel num_workers(nw) vector_length (NUM_VECTORS) copy (ary)\n+  {\n+    WorkVec ((int *)ary, WIDTH, HEIGHT, nw, NUM_VECTORS);\n+  }\n+\n+  for (int ix = 0; ix != HEIGHT; ix++)\n+    for (int jx = 0; jx != WIDTH; jx++)\n+      {\n+\tint exp = ((ix % nw) << 8) | (jx % NUM_VECTORS);\n+\t\n+\tif (ary[ix][jx] != exp)\n+\t  {\n+\t    printf (\"\\nary[%d][%d] = %#x expected %#x\", ix, jx,\n+\t\t    ary[ix][jx], exp);\n+\t    err = 1;\n+\t  }\n+      }\n+  printf (err ? \" failed\\n\" : \" ok\\n\");\n+  \n+  return err;\n+}\n+\n+int main ()\n+{\n+  int err = 0;\n+\n+  for (int W = 1; W <= NUM_WORKERS; W <<= 1)\n+    err |= DoWorkVec (W);\n+\n+  return err;\n+}"}, {"sha": "82c319250637415b5f0c1e3ae15053452ced853e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/update-1-2.c", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fupdate-1-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fupdate-1-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fupdate-1-2.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,361 +0,0 @@\n-/* Copy of update-1.c with self exchanged with host for #pragma acc update.  */\n-\n-/* { dg-do run } */\n-/* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } } */\n-\n-#include <openacc.h>\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <stdbool.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-    int N = 8;\n-    int NDIV2 = N / 2;\n-    float *a, *b, *c;\n-    float *d_a, *d_b, *d_c;\n-    int i;\n-\n-    a = (float *) malloc (N * sizeof (float));\n-    b = (float *) malloc (N * sizeof (float));\n-    c = (float *) malloc (N * sizeof (float));\n-\n-    d_a = (float *) acc_malloc (N * sizeof (float));\n-    d_b = (float *) acc_malloc (N * sizeof (float));\n-    d_c = (float *) acc_malloc (N * sizeof (float));\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 3.0;\n-        b[i] = 0.0;\n-    }\n-\n-    acc_map_data (a, d_a, N * sizeof (float));\n-    acc_map_data (b, d_b, N * sizeof (float));\n-    acc_map_data (c, d_c, N * sizeof (float));\n-\n-#pragma acc update device (a[0:N], b[0:N])\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 3.0)\n-            abort ();\n-\n-        if (b[i] != 3.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 5.0;\n-        b[i] = 1.0;\n-    }\n-\n-#pragma acc update device (a[0:N], b[0:N])\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 5.0)\n-            abort ();\n-\n-        if (b[i] != 5.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 5.0;\n-        b[i] = 1.0;\n-    }\n-\n-#pragma acc update device (a[0:N], b[0:N])\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update host (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 5.0)\n-            abort ();\n-\n-        if (b[i] != 5.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 6.0;\n-        b[i] = 0.0;\n-    }\n-\n-#pragma acc update device (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 9.0;\n-    }\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 6.0)\n-            abort ();\n-\n-        if (b[i] != 6.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 7.0;\n-        b[i] = 2.0;\n-    }\n-\n-#pragma acc update device (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 9.0;\n-    }\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 7.0)\n-            abort ();\n-\n-        if (b[i] != 7.0)\n-            abort ();\n-    }\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 9.0;\n-    }\n-\n-#pragma acc update device (a[0:N])\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        if (a[i] != 9.0)\n-            abort ();\n-\n-        if (b[i] != 9.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 5.0;\n-    }\n-\n-#pragma acc update device (a[0:N])\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 6.0;\n-    }\n-\n-#pragma acc update device (a[0:NDIV2])\n-\n-#pragma acc parallel present (a[0:N], b[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            b[ii] = a[ii];\n-    }\n-\n-#pragma acc update self (a[0:N], b[0:N])\n-\n-    for (i = 0; i < NDIV2; i++)\n-    {\n-        if (a[i] != 6.0)\n-            abort ();\n-\n-        if (b[i] != 6.0)\n-            abort ();\n-    }\n-\n-    for (i = NDIV2; i < N; i++)\n-    {\n-        if (a[i] != 5.0)\n-            abort ();\n-\n-        if (b[i] != 5.0)\n-            abort ();\n-    }\n-\n-    if (!acc_is_present (&a[0], (N * sizeof (float))))\n-      abort ();\n-\n-    if (!acc_is_present (&b[0], (N * sizeof (float))))\n-      abort ();\n-\n-    for (i = 0; i < N; i++)\n-    {\n-        a[i] = 0.0;\n-    }\n-\n-#pragma acc update device (a[0:4])\n-\n-#pragma acc parallel present (a[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            a[ii] = a[ii] + 1.0;\n-    }\n-\n-#pragma acc update self (a[4:4])\n-\n-    for (i = 0; i < NDIV2; i++)\n-    {\n-        if (a[i] != 0.0)\n-            abort ();\n-    }\n-\n-    for (i = NDIV2; i < N; i++)\n-    {\n-        if (a[i] != 6.0)\n-            abort ();\n-    }\n-\n-#pragma acc update self (a[0:4])\n-\n-    for (i = 0; i < NDIV2; i++)\n-    {\n-        if (a[i] != 1.0)\n-            abort ();\n-    }\n-\n-    for (i = NDIV2; i < N; i++)\n-    {\n-        if (a[i] != 6.0)\n-            abort ();\n-    }\n-\n-    a[2] = 9;\n-    a[3] = 9;\n-    a[4] = 9;\n-    a[5] = 9;\n-\n-#pragma acc update device (a[2:4])\n-\n-#pragma acc parallel present (a[0:N])\n-    {\n-        int ii;\n-\n-        for (ii = 0; ii < N; ii++)\n-            a[ii] = a[ii] + 1.0;\n-    }\n-\n-#pragma acc update self (a[2:4])\n-\n-    for (i = 0; i < 2; i++)\n-    {\n-      if (a[i] != 1.0)\n-\tabort ();\n-    }\n-\n-    for (i = 2; i < 6; i++)\n-    {\n-      if (a[i] != 10.0)\n-\tabort ();\n-    }\n-\n-    for (i = 6; i < N; i++)\n-    {\n-        if (a[i] != 6.0)\n-            abort ();\n-    }\n-\n-    return 0;\n-}"}, {"sha": "807347f68884d4916bef4eee4339b3b078d25c2a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/vector-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvector-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvector-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fvector-loop.c?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -20,7 +20,7 @@ main (void)\n \n #pragma acc parallel vector_length (32) copyin (a,b) copyout (c)\n   {\n-#pragma acc loop /* vector clause is missing, since it's not yet supported.  */\n+#pragma acc loop vector\n     for (unsigned int i = 0; i < n; i++)\n       c[i] = a[i] + b[i];\n   }"}, {"sha": "99c6dfbf8a3ccd5ddc0a8c01389dc1dfe7ae0b44", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-1a.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-1a.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,28 +0,0 @@\n-#include <assert.h>\n-\n-/* Test worker-single/vector-single mode.  */\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  int arr[32], i;\n-\n-  for (i = 0; i < 32; i++)\n-    arr[i] = 0;\n-\n-  #pragma acc parallel copy(arr) num_gangs(8) num_workers(8) vector_length(32)\n-  {\n-    int j;\n-    #pragma acc loop gang\n-    for (j = 0; j < 32; j++)\n-      {\n-\t#pragma acc atomic\n-\tarr[j]++;\n-      }\n-  }\n-\n-  for (i = 0; i < 32; i++)\n-    assert (arr[i] == 1);\n-\n-  return 0;\n-}"}, {"sha": "84080d0a8e5fe654bfe819f0a95e8902b469a26e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-4.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-4.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,28 +0,0 @@\n-#include <assert.h>\n-\n-/* Test worker-single/vector-partitioned mode.  */\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  int arr[32], i;\n-\n-  for (i = 0; i < 32; i++)\n-    arr[i] = i;\n-\n-  #pragma acc parallel copy(arr) num_gangs(1) num_workers(8) vector_length(32)\n-      {\n-\tint k;\n-\t#pragma acc loop vector\n-\tfor (k = 0; k < 32; k++)\n-\t  {\n-\t    #pragma acc atomic\n-\t    arr[k]++;\n-\t  }\n-      }\n-\n-  for (i = 0; i < 32; i++)\n-    assert (arr[i] == i + 1);\n-\n-  return 0;\n-}"}, {"sha": "cbc3e37a3a0166fd6d2f2d07a0552cfabae0980e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/worker-single-6.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9c755f257ad36eaa7335c48008c76c27c0b30c/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fworker-single-6.c?ref=ba9c755f257ad36eaa7335c48008c76c27c0b30c", "patch": "@@ -1,46 +0,0 @@\n-#include <assert.h>\n-\n-#if defined(ACC_DEVICE_TYPE_host)\n-#define ACTUAL_GANGS 1\n-#else\n-#define ACTUAL_GANGS 8\n-#endif\n-\n-/* Test worker-single, vector-partitioned, gang-redundant mode.  */\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  int n, arr[32], i;\n-\n-  for (i = 0; i < 32; i++)\n-    arr[i] = 0;\n-\n-  n = 0;\n-\n-  #pragma acc parallel copy(n, arr) num_gangs(ACTUAL_GANGS) num_workers(8) \\\n-\t  vector_length(32)\n-  {\n-    int j;\n-\n-    #pragma acc atomic\n-    n++;\n-\n-    #pragma acc loop vector\n-    for (j = 0; j < 32; j++)\n-      {\n-\t#pragma acc atomic\n-\tarr[j] += 1;\n-      }\n-\n-    #pragma acc atomic\n-    n++;\n-  }\n-\n-  assert (n == ACTUAL_GANGS * 2);\n-\n-  for (i = 0; i < 32; i++)\n-    assert (arr[i] == ACTUAL_GANGS);\n-\n-  return 0;\n-}"}, {"sha": "01728bd3f6c8d89d22cbc084881235ffea52b2cc", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-1.f90", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -132,4 +132,126 @@ program asyncwait\n      if (d(i) .ne. 1.0) call abort\n      if (e(i) .ne. 11.0) call abort\n   end do\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc data copy (a(1:N)) copy (b(1:N))\n+\n+  !$acc kernels async\n+  !$acc loop\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc wait\n+  !$acc end data\n+\n+  do i = 1, N\n+     if (a(i) .ne. 3.0) call abort\n+     if (b(i) .ne. 3.0) call abort\n+  end do\n+\n+  a(:) = 2.0\n+  b(:) = 0.0\n+\n+  !$acc data copy (a(1:N)) copy (b(1:N))\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc wait (1)\n+  !$acc end data\n+\n+  do i = 1, N\n+     if (a(i) .ne. 2.0) call abort\n+     if (b(i) .ne. 2.0) call abort\n+  end do\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+  c(:) = 0.0\n+  d(:) = 0.0\n+\n+  !$acc data copy (a(1:N)) copy (b(1:N)) copy (c(1:N)) copy (d(1:N))\n+\n+  !$acc kernels async (1)\n+  do i = 1, N\n+     b(i) = (a(i) * a(i) * a(i)) / a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  do i = 1, N\n+     c(i) = (a(i) * 4) / a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+     d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc wait (1)\n+  !$acc end data\n+\n+  do i = 1, N\n+     if (a(i) .ne. 3.0) call abort\n+     if (b(i) .ne. 9.0) call abort\n+     if (c(i) .ne. 4.0) call abort\n+     if (d(i) .ne. 1.0) call abort\n+  end do\n+\n+  a(:) = 2.0\n+  b(:) = 0.0\n+  c(:) = 0.0\n+  d(:) = 0.0\n+  e(:) = 0.0\n+\n+  !$acc data copy (a(1:N), b(1:N), c(1:N), d(1:N), e(1:N))\n+\n+  !$acc kernels async (1)\n+  do i = 1, N\n+     b(i) = (a(i) * a(i) * a(i)) / a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+     c(i) = (a(i) * 4) / a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+     d(i) = ((a(i) * a(i) + a(i)) / a(i)) - a(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels wait (1) async (1)\n+  !$acc loop\n+  do i = 1, N\n+     e(i) = a(i) + b(i) + c(i) + d(i)\n+  end do\n+  !$acc end kernels\n+\n+  !$acc wait (1)\n+  !$acc end data\n+\n+  do i = 1, N\n+     if (a(i) .ne. 2.0) call abort\n+     if (b(i) .ne. 4.0) call abort\n+     if (c(i) .ne. 4.0) call abort\n+     if (d(i) .ne. 1.0) call abort\n+     if (e(i) .ne. 11.0) call abort\n+  end do\n end program asyncwait"}, {"sha": "fe131b62716d1d34988cbe9b947e2a945d08146c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-2.f90", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-2.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n \n-program parallel_wait\n+program asyncwait\n   integer, parameter :: N = 64\n   real, allocatable :: a(:), b(:), c(:)\n   integer i\n@@ -30,11 +30,36 @@ program parallel_wait\n   end do\n   !$acc end parallel\n \n+  do i = 1, N\n+    if (c(i) .ne. 2.0) call abort\n+  end do\n+\n+  !$acc kernels async (0)\n+  !$acc loop\n+  do i = 1, N\n+    a(i) = 1\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+    b(i) = 1\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels wait (0, 1)\n+  !$acc loop\n+  do i = 1, N\n+    c(i) = a(i) + b(i)\n+  end do\n+  !$acc end kernels\n+\n   do i = 1, N\n     if (c(i) .ne. 2.0) call abort\n   end do\n   \n   deallocate (a)\n   deallocate (b)\n   deallocate (c)\n-end program parallel_wait\n+end program asyncwait"}, {"sha": "fa96a015ce163c3c7a830f0de38359ba5bb5dfec", "filename": "libgomp/testsuite/libgomp.oacc-fortran/asyncwait-3.f90", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fasyncwait-3.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do run }\n \n-program parallel_wait\n+program asyncwait\n   integer, parameter :: N = 64\n   real, allocatable :: a(:), b(:), c(:)\n   integer i\n@@ -32,11 +32,38 @@ program parallel_wait\n   end do\n   !$acc end parallel\n \n+  do i = 1, N\n+    if (c(i) .ne. 2.0) call abort\n+  end do\n+\n+  !$acc kernels async (0)\n+  !$acc loop\n+  do i = 1, N\n+    a(i) = 1\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels async (1)\n+  !$acc loop\n+  do i = 1, N\n+    b(i) = 1\n+  end do\n+  !$acc end kernels\n+\n+  !$acc wait (0, 1)\n+\n+  !$acc kernels\n+  !$acc loop\n+  do i = 1, N\n+    c(i) = a(i) + b(i)\n+  end do\n+  !$acc end kernels\n+\n   do i = 1, N\n     if (c(i) .ne. 2.0) call abort\n   end do\n   \n   deallocate (a)\n   deallocate (b)\n   deallocate (c)\n-end program parallel_wait\n+end program asyncwait"}, {"sha": "e6ab78dc047eb5b09e542db5bf22da013a78818a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/clauses-1.f90", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fclauses-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fclauses-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fclauses-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,290 @@\n+! { dg-do run }\n+! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n+\n+program main\n+  use openacc\n+  implicit none\n+\n+  integer, parameter :: N = 32\n+  real, allocatable :: a(:), b(:), c(:)\n+  integer i\n+\n+  i = 0\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+  allocate (c(N))\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      b(i) = a(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 3.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 5.0\n+  b(:) = 1.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      b(i) = a(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 5.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 6.0\n+  b(:) = 0.0\n+\n+  call acc_copyin (a, sizeof (a))\n+\n+  a(:) = 9.0\n+\n+  !$acc parallel present_or_copyin (a(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      b(i) = a(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 6.0) call abort\n+  end do\n+\n+  call acc_copyout (a, sizeof (a))\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 6.0\n+  b(:) = 0.0\n+\n+  !$acc parallel copyin (a(1:N)) present_or_copyout (b(1:N))\n+     do i = 1, N\n+       b(i) = a(i)\n+     end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+     if (b(i) .ne. 6.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 5.0\n+  b(:) = 2.0\n+\n+  call acc_copyin (b, sizeof (b))\n+\n+  !$acc parallel copyin (a(1:N)) present_or_copyout (b(1:N))\n+     do i = 1, N\n+       b(i) = a(i)\n+     end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 5.0) call abort\n+    if (b(i) .ne. 2.0) call abort\n+  end do\n+\n+  call acc_copyout (b, sizeof (b))\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 3.0;\n+  b(:) = 4.0;\n+\n+  !$acc parallel copy (a(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      a(i) = a(i) + 1\n+      b(i) = a(i) + 2\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 4.0) call abort\n+    if (b(i) .ne. 6.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 4.0\n+  b(:) = 7.0\n+\n+  !$acc parallel present_or_copy (a(1:N)) present_or_copy (b(1:N))\n+    do i = 1, N\n+      a(i) = a(i) + 1\n+      b(i) = b(i) + 2\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 5.0) call abort\n+    if (b(i) .ne. 9.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 3.0\n+  b(:) = 7.0\n+\n+  call acc_copyin (a, sizeof (a))\n+  call acc_copyin (b, sizeof (b))\n+\n+  !$acc parallel present_or_copy (a(1:N)) present_or_copy (b(1:N))\n+    do i = 1, N\n+      a(i) = a(i) + 1\n+      b(i) = b(i) + 2\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 3.0) call abort\n+    if (b(i) .ne. 7.0) call abort\n+  end do\n+\n+  call acc_copyout (a, sizeof (a))\n+  call acc_copyout (b, sizeof (b))\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 3.0\n+  b(:) = 7.0\n+\n+  !$acc parallel copyin (a(1:N)) create (c(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      c(i) = a(i)\n+      b(i) = c(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 3.0) call abort\n+    if (b(i) .ne. 3.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+  if (acc_is_present (c) .eqv. .TRUE.) call abort\n+\n+  a(:) = 4.0\n+  b(:) = 8.0\n+\n+  !$acc parallel copyin (a(1:N)) present_or_create (c(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      c(i) = a(i)\n+      b(i) = c(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 4.0) call abort\n+    if (b(i) .ne. 4.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+  if (acc_is_present (c) .eqv. .TRUE.) call abort\n+\n+  a(:) = 4.0\n+\n+  call acc_copyin (a, sizeof (a))\n+  call acc_copyin (b, sizeof (b))\n+  call acc_copyin (c, sizeof (c))\n+\n+  !$acc parallel present (a(1:N)) present (c(1:N)) present (b(1:N))\n+    do i = 1, N\n+      c(i) = a(i)\n+      b(i) = c(i)\n+    end do\n+  !$acc end parallel\n+\n+  call acc_copyout (a, sizeof (a))\n+  call acc_copyout (b, sizeof (b))\n+  call acc_copyout (c, sizeof (c))\n+  \n+  do i = 1, N\n+    if (a(i) .ne. 4.0) call abort\n+    if (b(i) .ne. 4.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+  if (acc_is_present (c) .eqv. .TRUE.) call abort\n+\n+  a(:) = 6.0\n+  b(:) = 0.0\n+\n+  call acc_copyin (a, sizeof (a))\n+\n+  a(:) = 9.0\n+\n+  !$acc parallel pcopyin (a(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      b(i) = a(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 6.0) call abort\n+  end do\n+  \n+  call acc_copyout (a, sizeof (a))\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 6.0\n+  b(:) = 0.0\n+\n+  !$acc parallel copyin (a(1:N)) pcopyout (b(1:N))\n+   do i = 1, N\n+     b(i) = a(i)\n+   end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 6.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+\n+  a(:) = 5.0\n+  b(:) = 7.0\n+\n+  !$acc parallel copyin (a(1:N)) pcreate (c(1:N)) copyout (b(1:N))\n+    do i = 1, N\n+      c(i) = a(i)\n+      b(i) = c(i)\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (a(i) .ne. 5.0) call abort\n+    if (b(i) .ne. 5.0) call abort\n+  end do\n+\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+  if (acc_is_present (c) .eqv. .TRUE.) call abort\n+\n+end program main"}, {"sha": "2d4b70720e3d5d0f77bf7ec2121112d7d6d29224", "filename": "libgomp/testsuite/libgomp.oacc-fortran/declare-1.f90", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -1,29 +1,22 @@\n ! { dg-do run  { target openacc_nvidia_accel_selected } }\n \n+! Tests to exercise the declare directive along with\n+! the clauses: copy\n+!              copyin\n+!              copyout\n+!              create\n+!              present\n+!              present_or_copy\n+!              present_or_copyin\n+!              present_or_copyout\n+!              present_or_create\n+\n module vars\n   implicit none\n   integer z\n   !$acc declare create (z)\n end module vars\n \n-subroutine subr6 (a, d)\n-  implicit none\n-  integer, parameter :: N = 8\n-  integer :: i\n-  integer :: a(N)\n-  !$acc declare deviceptr (a)\n-  integer :: d(N)\n-\n-  i = 0\n-\n-  !$acc parallel copy (d)\n-    do i = 1, N\n-      d(i) = a(i) + a(i)\n-    end do\n-  !$acc end parallel\n-\n-end subroutine\n-\n subroutine subr5 (a, b, c, d)\n   implicit none\n   integer, parameter :: N = 8\n@@ -201,15 +194,6 @@ subroutine subr0 (a, b, c, d)\n     if (d(i) .ne. 13) call abort\n   end do\n \n-  call subr6 (a, d)\n-\n-  call test (a, .true.)\n-  call test (d, .false.)\n-\n-  do i = 1, N\n-    if (d(i) .ne. 16) call abort\n-  end do\n-\n end subroutine\n \n program main\n@@ -241,8 +225,7 @@ program main\n     if (a(i) .ne. 8) call abort\n     if (b(i) .ne. 8) call abort\n     if (c(i) .ne. 8) call abort\n-    if (d(i) .ne. 16) call abort\n+    if (d(i) .ne. 13) call abort\n   end do\n \n-\n end program"}, {"sha": "10590892458bc22f5349340f83f5ef6e5ee8866b", "filename": "libgomp/testsuite/libgomp.oacc-fortran/default-1.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdefault-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdefault-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdefault-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+\n+program main\n+  implicit none\n+  real a, b\n+  real c\n+  !$acc declare create (c)\n+\n+  a = 2.0\n+  b = 0.0\n+\n+  !$acc parallel copy (a) create (b) default (none)\n+    b = a\n+    a = 1.0\n+    a = a + b\n+  !$acc end parallel\n+\n+  if (a .ne. 3.0) call abort\n+\n+  !$acc kernels copy (a) create (b) default (none)\n+    b = a\n+    a = 1.0\n+    a = a + b\n+  !$acc end kernels\n+\n+  if (a .ne. 4.0) call abort\n+\n+  !$acc parallel default (none) copy (a) create (b)\n+    b = a\n+    a = 1.0\n+    a = a + b\n+  !$acc end parallel\n+\n+  if (a .ne. 5.0) call abort\n+\n+  !$acc parallel default (none) copy (a)\n+    c = a\n+    a = 1.0\n+    a = a + c\n+  !$acc end parallel\n+\n+  if (a .ne. 6.0) call abort\n+\n+  !$acc data copy (a)\n+  !$acc parallel default (none)\n+    c = a\n+    a = 1.0\n+    a = a + c\n+  !$acc end parallel\n+  !$acc end data\n+\n+  if (a .ne. 7.0) call abort\n+\n+end program main"}, {"sha": "d3f909361fb54e8e8cb64327ec68caab62867e89", "filename": "libgomp/testsuite/libgomp.oacc-fortran/firstprivate-1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffirstprivate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffirstprivate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffirstprivate-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+\n+program firstprivate\n+  integer, parameter :: Nupper=100\n+  integer :: a, b(Nupper), c, d, n\n+  include \"openacc_lib.h\"\n+\n+  if (acc_get_device_type () .eq. acc_device_nvidia) then\n+     n = Nupper\n+  else\n+     n = 1\n+  end if\n+\n+  b(:) = -1\n+  a = 5\n+\n+  !$acc parallel firstprivate (a) num_gangs (n)\n+  !$acc loop gang\n+  do i = 1, n\n+     a = a + i\n+     b(i) = a\n+  end do\n+  !$acc end parallel\n+\n+  do i = 1, n\n+     if (b(i) .ne. i + a) call abort ()\n+  end do\n+\n+  !$acc data copy (a)\n+  !$acc parallel firstprivate (a) copyout (c)\n+  a = 10\n+  c = a\n+  !$acc end parallel\n+\n+  !$acc parallel copyout (d) present (a)\n+  d = a\n+  !$acc end parallel\n+  !$acc end data\n+\n+  if (c .ne. 10) call abort ()\n+  if (d .ne. 5) call abort ()\n+end program firstprivate"}, {"sha": "7d56060ad496009add463e4d3e8d84b084836433", "filename": "libgomp/testsuite/libgomp.oacc-fortran/gang-static-1.f90", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fgang-static-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fgang-static-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fgang-static-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,79 @@\n+! { dg-do run }\n+\n+program main\n+  integer, parameter :: n = 100\n+  integer i, a(n), b(n)\n+  integer x\n+\n+  do i = 1, n\n+     b(i) = i\n+  end do\n+\n+  !$acc parallel loop gang (static:*) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 0\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 0, n)\n+\n+  !$acc parallel loop gang (static:1) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 1\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 1, n)\n+\n+  !$acc parallel loop gang (static:2) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 2\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 2, n)\n+\n+  !$acc parallel loop gang (static:5) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 5\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 5, n)\n+\n+  !$acc parallel loop gang (static:20) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 20\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 20, n)\n+\n+  x = 5\n+  !$acc parallel loop gang (static:0+x) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 5\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 5, n)\n+\n+  x = 10\n+  !$acc parallel loop gang (static:x) num_gangs (10)\n+  do i = 1, n\n+     a(i) = b(i) + 10\n+  end do\n+  !$acc end parallel loop\n+\n+  call test (a, b, 10, n)\n+end program main\n+\n+subroutine test (a, b, sarg, n)\n+  integer n\n+  integer a (n), b(n), sarg\n+  integer i\n+\n+  do i = 1, n\n+     if (a(i) .ne. b(i) + sarg) call abort ()\n+  end do\n+end subroutine test"}, {"sha": "44055e177f8ed1e17c0fa1a72fb7ffe739901b73", "filename": "libgomp/testsuite/libgomp.oacc-fortran/if-1.f90", "status": "added", "additions": 886, "deletions": 0, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fif-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fif-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fif-1.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,886 @@\n+! { dg-do run }\n+! { dg-additional-options \"-cpp\" }\n+\n+program main\n+  use openacc\n+  implicit none\n+\n+  integer, parameter :: N = 8\n+  integer, parameter :: one = 1\n+  integer, parameter :: zero = 0\n+  integer i, nn\n+  real, allocatable :: a(:), b(:)\n+  real exp, exp2\n+\n+  i = 0\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+\n+  a(:) = 4.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (1 == 1)\n+     do i = 1, N\n+        if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+          b(i) = a(i) + 1\n+        else\n+          b(i) = a(i)\n+        end if\n+     end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 5.0\n+#else\n+  exp = 4.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 16.0\n+\n+  !$acc parallel if (0 == 1)\n+     do i = 1, N\n+       if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+         b(i) = a(i) + 1\n+       else\n+         b(i) = a(i)\n+       end if\n+     end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 17.0) call abort\n+  end do\n+\n+  a(:) = 8.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (one == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 9.0\n+#else\n+  exp = 8.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 22.0\n+\n+  !$acc parallel if (zero == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 23.0) call abort\n+  end do\n+\n+  a(:) = 16.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (.TRUE.)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 17.0;\n+#else\n+  exp = 16.0;\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 76.0\n+\n+  !$acc parallel if (.FALSE.)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 77.0) call abort\n+  end do\n+\n+  a(:) = 22.0\n+\n+  nn = 1\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (nn == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 23.0;\n+#else\n+  exp = 22.0;\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 18.0\n+\n+  nn = 0\n+\n+  !$acc parallel if (nn == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 19.0) call abort\n+  end do\n+\n+  a(:) = 49.0\n+\n+  nn = 1\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if ((nn + nn) > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 50.0\n+#else\n+  exp = 49.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 38.0\n+\n+  nn = 0;\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if ((nn + nn) > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 39.0) call abort\n+  end do\n+\n+  a(:) = 91.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (-2 > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 92.0) call abort\n+  end do\n+\n+  a(:) = 43.0\n+\n+  !$acc parallel copyin (a(1:N)) copyout (b(1:N)) if (one == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+#if ACC_MEM_SHARED\n+  exp = 44.0\n+#else\n+  exp = 43.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 87.0\n+\n+  !$acc parallel if (one == 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, N\n+    if (b(i) .ne. 88.0) call abort\n+  end do\n+\n+  a(:) = 3.0\n+  b(:) = 9.0\n+\n+#if ACC_MEM_SHARED\n+  exp = 0.0\n+  exp2 = 0.0\n+#else\n+  call acc_copyin (a, sizeof (a))\n+  call acc_copyin (b, sizeof (b))\n+  exp = 3.0;\n+  exp2 = 9.0;\n+#endif\n+\n+  !$acc update device (a(1:N), b(1:N)) if (1 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (1 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. exp) call abort\n+    if (b(i) .ne. exp2) call abort\n+  end do\n+\n+  a(:) = 6.0\n+  b(:) = 12.0\n+\n+  !$acc update device (a(1:N), b(1:N)) if (0 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (1 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. exp) call abort\n+    if (b(i) .ne. exp2) call abort\n+  end do\n+\n+  a(:) = 26.0\n+  b(:) = 21.0\n+\n+  !$acc update device (a(1:N), b(1:N)) if (1 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (0 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. 0.0) call abort\n+    if (b(i) .ne. 0.0) call abort\n+  end do\n+\n+#if !ACC_MEM_SHARED\n+  call acc_copyout (a, sizeof (a))\n+  call acc_copyout (b, sizeof (b))\n+#endif\n+\n+  a(:) = 4.0\n+  b(:) = 0.0\n+\n+  !$acc data copyin (a(1:N)) copyout (b(1:N)) if (1 == 1)\n+\n+    !$acc parallel present (a(1:N))\n+       do i = 1, N\n+           b(i) = a(i)\n+       end do\n+    !$acc end parallel\n+  !$acc end data\n+\n+  do i = 1, N\n+    if (b(i) .ne. 4.0) call abort\n+  end do\n+\n+  a(:) = 8.0\n+  b(:) = 1.0\n+\n+  !$acc data copyin (a(1:N)) copyout (b(1:N)) if (0 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc end data\n+\n+  a(:) = 18.0\n+  b(:) = 21.0\n+\n+  !$acc data copyin (a(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (a) .eqv. .FALSE.) call abort\n+#endif\n+\n+    !$acc data copyout (b(1:N)) if (0 == 1)\n+#if !ACC_MEM_SHARED\n+      if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+        !$acc data copyout (b(1:N)) if (1 == 1)\n+\n+        !$acc parallel present (a(1:N)) present (b(1:N))\n+          do i = 1, N\n+            b(i) = a(i)\n+          end do\n+      !$acc end parallel\n+\n+    !$acc end data\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+    !$acc end data\n+  !$acc end data\n+\n+  do i = 1, N\n+   if (b(1) .ne. 18.0) call abort\n+  end do\n+\n+  !$acc enter data copyin (b(1:N)) if (0 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (0 == 1)\n+\n+  !$acc enter data copyin (b(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc enter data copyin (b(1:N)) if (zero == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (zero == 1)\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 0)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 0)\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  a(:) = 4.0\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (1 == 1)\n+     do i = 1, N\n+        if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+          b(i) = a(i) + 1\n+        else\n+          b(i) = a(i)\n+        end if\n+     end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 5.0\n+#else\n+  exp = 4.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 16.0\n+\n+  !$acc kernels if (0 == 1)\n+     do i = 1, N\n+       if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+         b(i) = a(i) + 1\n+       else\n+         b(i) = a(i)\n+       end if\n+     end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 17.0) call abort\n+  end do\n+\n+  a(:) = 8.0\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (one == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 9.0\n+#else\n+  exp = 8.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 22.0\n+\n+  !$acc kernels if (zero == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 23.0) call abort\n+  end do\n+\n+  a(:) = 16.0\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (.TRUE.)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 17.0;\n+#else\n+  exp = 16.0;\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 76.0\n+\n+  !$acc kernels if (.FALSE.)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 77.0) call abort\n+  end do\n+\n+  a(:) = 22.0\n+\n+  nn = 1\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (nn == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 23.0;\n+#else\n+  exp = 22.0;\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 18.0\n+\n+  nn = 0\n+\n+  !$acc kernels if (nn == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 19.0) call abort\n+  end do\n+\n+  a(:) = 49.0\n+\n+  nn = 1\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if ((nn + nn) > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 50.0\n+#else\n+  exp = 49.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 38.0\n+\n+  nn = 0;\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if ((nn + nn) > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 39.0) call abort\n+  end do\n+\n+  a(:) = 91.0\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (-2 > 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 92.0) call abort\n+  end do\n+\n+  a(:) = 43.0\n+\n+  !$acc kernels copyin (a(1:N)) copyout (b(1:N)) if (one == 1)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+#if ACC_MEM_SHARED\n+  exp = 44.0\n+#else\n+  exp = 43.0\n+#endif\n+\n+  do i = 1, N\n+    if (b(i) .ne. exp) call abort\n+  end do\n+\n+  a(:) = 87.0\n+\n+  !$acc kernels if (one == 0)\n+    do i = 1, N\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) then\n+        b(i) = a(i) + 1\n+      else\n+        b(i) = a(i)\n+      end if\n+    end do\n+  !$acc end kernels\n+\n+  do i = 1, N\n+    if (b(i) .ne. 88.0) call abort\n+  end do\n+\n+  a(:) = 3.0\n+  b(:) = 9.0\n+\n+#if ACC_MEM_SHARED\n+  exp = 0.0\n+  exp2 = 0.0\n+#else\n+  call acc_copyin (a, sizeof (a))\n+  call acc_copyin (b, sizeof (b))\n+  exp = 3.0;\n+  exp2 = 9.0;\n+#endif\n+\n+  !$acc update device (a(1:N), b(1:N)) if (1 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (1 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. exp) call abort\n+    if (b(i) .ne. exp2) call abort\n+  end do\n+\n+  a(:) = 6.0\n+  b(:) = 12.0\n+\n+  !$acc update device (a(1:N), b(1:N)) if (0 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (1 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. exp) call abort\n+    if (b(i) .ne. exp2) call abort\n+  end do\n+\n+  a(:) = 26.0\n+  b(:) = 21.0\n+\n+  !$acc update device (a(1:N), b(1:N)) if (1 == 1)\n+\n+  a(:) = 0.0\n+  b(:) = 0.0\n+\n+  !$acc update host (a(1:N), b(1:N)) if (0 == 1)\n+\n+  do i = 1, N\n+    if (a(i) .ne. 0.0) call abort\n+    if (b(i) .ne. 0.0) call abort\n+  end do\n+\n+#if !ACC_MEM_SHARED\n+  call acc_copyout (a, sizeof (a))\n+  call acc_copyout (b, sizeof (b))\n+#endif\n+\n+  a(:) = 4.0\n+  b(:) = 0.0\n+\n+  !$acc data copyin (a(1:N)) copyout (b(1:N)) if (1 == 1)\n+\n+    !$acc kernels present (a(1:N))\n+       do i = 1, N\n+           b(i) = a(i)\n+       end do\n+    !$acc end kernels\n+  !$acc end data\n+\n+  do i = 1, N\n+    if (b(i) .ne. 4.0) call abort\n+  end do\n+\n+  a(:) = 8.0\n+  b(:) = 1.0\n+\n+  !$acc data copyin (a(1:N)) copyout (b(1:N)) if (0 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (a) .eqv. .TRUE.) call abort\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc end data\n+\n+  a(:) = 18.0\n+  b(:) = 21.0\n+\n+  !$acc data copyin (a(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (a) .eqv. .FALSE.) call abort\n+#endif\n+\n+    !$acc data copyout (b(1:N)) if (0 == 1)\n+#if !ACC_MEM_SHARED\n+      if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+        !$acc data copyout (b(1:N)) if (1 == 1)\n+\n+        !$acc kernels present (a(1:N)) present (b(1:N))\n+          do i = 1, N\n+            b(i) = a(i)\n+          end do\n+      !$acc end kernels\n+\n+    !$acc end data\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+    !$acc end data\n+  !$acc end data\n+\n+  do i = 1, N\n+   if (b(1) .ne. 18.0) call abort\n+  end do\n+\n+  !$acc enter data copyin (b(1:N)) if (0 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (0 == 1)\n+\n+  !$acc enter data copyin (b(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (1 == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc enter data copyin (b(1:N)) if (zero == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (zero == 1)\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 0)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 0)\n+\n+  !$acc enter data copyin (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+    if (acc_is_present (b) .eqv. .FALSE.) call abort\n+#endif\n+\n+  !$acc exit data delete (b(1:N)) if (one == 1)\n+\n+#if !ACC_MEM_SHARED\n+  if (acc_is_present (b) .eqv. .TRUE.) call abort\n+#endif\n+\n+end program main"}, {"sha": "a5f3840f63c4c36af90a4cd4f8b5adcec95b2524", "filename": "libgomp/testsuite/libgomp.oacc-fortran/implicit-firstprivate-ref.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fimplicit-firstprivate-ref.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fimplicit-firstprivate-ref.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fimplicit-firstprivate-ref.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,42 @@\n+! This test checks if the runtime can properly handle implicit\n+! firstprivate varaibles inside subroutines in modules.\n+\n+! { dg-do run }\n+\n+module test_mod\n+  contains\n+    subroutine test(x)\n+\n+      IMPLICIT NONE\n+\n+      INTEGER      :: x, y, j\n+\n+      x = 5\n+\n+      !$ACC PARALLEL LOOP copyout (y)\n+      DO j=1,10\n+         y=x\n+      ENDDO\n+      !$ACC END PARALLEL LOOP\n+\n+      y = -1;\n+\n+      !$ACC PARALLEL LOOP firstprivate (y) copyout (x)\n+      DO j=1,10\n+         x=y\n+      ENDDO\n+      !$ACC END PARALLEL LOOP\n+    end subroutine test\n+end module test_mod\n+\n+program t\n+  use test_mod\n+\n+  INTEGER      :: x_min\n+\n+  x_min = 8\n+\n+  CALL test(x_min)\n+\n+  if (x_min .ne. -1) call abort\n+end program t"}, {"sha": "735350f6aac30bfde378be628549f72f6d782dcd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/pr68813.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr68813.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr68813.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr68813.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,19 @@\n+program foo\n+  implicit none\n+  integer, parameter :: n = 100\n+  integer, dimension(n,n) :: a\n+  integer :: i, j, sum = 0\n+\n+  a = 1\n+\n+  !$acc parallel copyin(a(1:n,1:n)) firstprivate (sum)\n+  !$acc loop gang reduction(+:sum)\n+  do i=1, n\n+     !$acc loop vector reduction(+:sum)\n+     do j=1, n\n+        sum = sum + a(i, j)\n+     enddo\n+  enddo\n+  !$acc end parallel\n+\n+end program foo"}, {"sha": "3c1940b5d8515d1377aa4837422ab1239a3836d5", "filename": "libgomp/testsuite/libgomp.oacc-fortran/private-variables.f90", "status": "added", "additions": 544, "deletions": 0, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-variables.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2620c80db02d5e32ffb5b54b80be67fcc7843d20/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-variables.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-variables.f90?ref=2620c80db02d5e32ffb5b54b80be67fcc7843d20", "patch": "@@ -0,0 +1,544 @@\n+! Miscellaneous tests for private variables.\n+\n+! { dg-do run }\n+\n+\n+! Test of gang-private variables declared on loop directive.\n+\n+subroutine t1()\n+  integer :: x, i, arr(32)\n+\n+  do i = 1, 32\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang private(x)\n+  do i = 1, 32\n+     x = i * 2;\n+     arr(i) = arr(i) + x\n+  end do\n+  !$acc end parallel\n+\n+  do i = 1, 32\n+     if (arr(i) .ne. i * 3) call abort\n+  end do\n+end subroutine t1\n+\n+\n+! Test of gang-private variables declared on loop directive, with broadcasting\n+! to partitioned workers.\n+\n+subroutine t2()\n+  integer :: x, i, j, arr(0:32*32)\n+\n+  do i = 0, 32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang private(x)\n+  do i = 0, 31\n+     x = i * 2;\n+\n+     !$acc loop worker\n+     do j = 0, 31\n+        arr(i * 32 + j) = arr(i * 32 + j) + x\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 * 32 - 1\n+     if (arr(i) .ne. i + (i / 32) * 2) call abort\n+  end do\n+end subroutine t2\n+\n+\n+! Test of gang-private variables declared on loop directive, with broadcasting\n+! to partitioned vectors.\n+\n+subroutine t3()\n+  integer :: x, i, j, arr(0:32*32)\n+\n+  do i = 0, 32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang private(x)\n+  do i = 0, 31\n+     x = i * 2;\n+\n+     !$acc loop vector\n+     do j = 0, 31\n+        arr(i * 32 + j) = arr(i * 32 + j) + x\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 * 32 - 1\n+     if (arr(i) .ne. i + (i / 32) * 2) call abort\n+  end do\n+end subroutine t3\n+\n+\n+! Test of gang-private addressable variable declared on loop directive, with\n+! broadcasting to partitioned workers.\n+\n+subroutine t4()\n+  type vec3\n+     integer x, y, z, attr(13)\n+  end type vec3\n+\n+  integer i, j, arr(0:32*32)\n+  type(vec3) pt\n+  \n+  do i = 0, 32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang private(pt)\n+  do i = 0, 31\n+     pt%x = i\n+     pt%y = i * 2\n+     pt%z = i * 4\n+     pt%attr(5) = i * 6\n+\n+     !$acc loop vector\n+     do j = 0, 31\n+        arr(i * 32 + j) = arr(i * 32 + j) + pt%x + pt%y + pt%z + pt%attr(5);\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 * 32 - 1\n+     if (arr(i) .ne. i + (i / 32) * 13) call abort\n+  end do\n+end subroutine t4\n+\n+\n+! Test of vector-private variables declared on loop directive.\n+\n+subroutine t5()\n+  integer :: x, i, j, k, idx, arr(0:32*32*32)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker\n+     do j = 0, 31\n+        !$acc loop vector private(x)\n+        do k = 0, 31\n+           x = ieor(i, j * 3)\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+        !$acc loop vector private(x)\n+        do k = 0, 31\n+           x = ior(i, j * 5)\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t5\n+\n+\n+! Test of vector-private variables declared on loop directive. Array type.\n+\n+subroutine t6()\n+  integer :: i, j, k, idx, arr(0:32*32*32), pt(2)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker\n+     do j = 0, 31\n+        !$acc loop vector private(x, pt)\n+        do k = 0, 31\n+           pt(1) = ieor(i, j * 3)\n+           pt(2) = ior(i, j * 5)\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(1) * k\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(2) * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t6\n+\n+\n+! Test of worker-private variables declared on a loop directive.\n+\n+subroutine t7()\n+  integer :: x, i, j, arr(0:32*32)\n+  common x\n+\n+  do i = 0, 32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang private(x)\n+  do i = 0, 31\n+     !$acc loop worker private(x)\n+     do j = 0, 31\n+        x = ieor(i, j * 3)\n+        arr(i * 32 + j) = arr(i * 32 + j) + x\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 * 32 - 1\n+     if (arr(i) .ne. i + ieor(i / 32, mod(i, 32) * 3)) call abort\n+  end do\n+end subroutine t7\n+\n+\n+! Test of worker-private variables declared on a loop directive, broadcasting\n+! to vector-partitioned mode.\n+\n+subroutine t8()\n+  integer :: x, i, j, k, idx, arr(0:32*32*32)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(x)\n+     do j = 0, 31\n+        x = ieor(i, j * 3)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k) call abort\n+        end do\n+     end do\n+  end do\n+end subroutine t8\n+\n+\n+! Test of worker-private variables declared on a loop directive, broadcasting\n+! to vector-partitioned mode.  Back-to-back worker loops.\n+\n+subroutine t9()\n+  integer :: x, i, j, k, idx, arr(0:32*32*32)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(x)\n+     do j = 0, 31\n+        x = ieor(i, j * 3)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+\n+     !$acc loop worker private(x)\n+     do j = 0, 31\n+        x = ior(i, j * 5)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t9\n+\n+\n+! Test of worker-private variables declared on a loop directive, broadcasting\n+! to vector-partitioned mode.  Successive vector loops.  */\n+\n+subroutine t10()\n+  integer :: x, i, j, k, idx, arr(0:32*32*32)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(x)\n+     do j = 0, 31\n+        x = ieor(i, j * 3)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+\n+        x = ior(i, j * 5)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t10\n+\n+\n+! Test of worker-private variables declared on a loop directive, broadcasting\n+! to vector-partitioned mode.  Addressable worker variable.\n+\n+subroutine t11()\n+  integer :: i, j, k, idx, arr(0:32*32*32)\n+  integer, target :: x\n+  integer, pointer :: p\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(x, p)\n+     do j = 0, 31\n+        p => x\n+        x = ieor(i, j * 3)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+\n+        p = ior(i, j * 5)\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + x * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t11\n+\n+\n+! Test of worker-private variables declared on a loop directive, broadcasting\n+! to vector-partitioned mode.  Aggregate worker variable.\n+\n+subroutine t12()\n+  type vec2\n+     integer x, y\n+  end type vec2\n+  \n+  integer :: i, j, k, idx, arr(0:32*32*32)\n+  type(vec2) :: pt\n+  \n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(pt)\n+     do j = 0, 31\n+        pt%x = ieor(i, j * 3)\n+        pt%y = ior(i, j * 5)\n+        \n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt%x * k\n+        end do\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt%y * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t12\n+\n+\n+! Test of worker-private variables declared on loop directive, broadcasting\n+! to vector-partitioned mode.  Array worker variable.\n+\n+subroutine t13()\n+  integer :: i, j, k, idx, arr(0:32*32*32), pt(2)\n+\n+  do i = 0, 32*32*32-1\n+     arr(i) = i\n+  end do\n+\n+  !$acc parallel copy(arr) num_gangs(32) num_workers(8) vector_length(32)\n+  !$acc loop gang\n+  do i = 0, 31\n+     !$acc loop worker private(pt)\n+     do j = 0, 31\n+        pt(1) = ieor(i, j * 3)\n+        pt(2) = ior(i, j * 5)\n+        \n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(1) * k\n+        end do\n+\n+        !$acc loop vector\n+        do k = 0, 31\n+           arr(i * 1024 + j * 32 + k) = arr(i * 1024 + j * 32 + k) + pt(2) * k\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  do i = 0, 32 - 1\n+     do j = 0, 32 -1\n+        do k = 0, 32 - 1\n+           idx = i * 1024 + j * 32 + k\n+           if (arr(idx) .ne. idx + ieor(i, j * 3) * k + ior(i, j * 5) * k) then\n+              call abort\n+           end if\n+        end do\n+     end do\n+  end do\n+end subroutine t13\n+\n+\n+! Test of gang-private variables declared on the parallel directive.\n+\n+subroutine t14()\n+  use openacc\n+  integer :: x = 5\n+  integer, parameter :: n = 32\n+  integer :: arr(n)\n+\n+  do i = 1, n\n+    arr(i) = 3\n+  end do\n+\n+  !$acc parallel private(x) copy(arr) num_gangs(n) num_workers(8) vector_length(32)\n+    !$acc loop gang(static:1)\n+    do i = 1, n\n+      x = i * 2;\n+    end do\n+\n+   !$acc loop gang(static:1)\n+    do i = 1, n\n+      if (acc_on_device (acc_device_host) .eqv. .TRUE.) x = i * 2\n+      arr(i) = arr(i) + x\n+    end do\n+  !$acc end parallel\n+\n+  do i = 1, n\n+    if (arr(i) .ne. (3 + i * 2)) call abort\n+  end do\n+\n+end subroutine t14\n+\n+\n+program main\n+  call t1()\n+  call t2()\n+  call t3()\n+  call t4()\n+  call t5()\n+  call t6()\n+  call t7()\n+  call t8()\n+  call t9()\n+  call t10()\n+  call t11()\n+  call t12()\n+  call t13()\n+  call t14()\n+end program main"}]}