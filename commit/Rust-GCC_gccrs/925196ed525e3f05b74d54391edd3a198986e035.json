{"sha": "925196ed525e3f05b74d54391edd3a198986e035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI1MTk2ZWQ1MjVlM2YwNWI3NGQ1NDM5MWVkZDNhMTk4OTg2ZTAzNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-11-18T10:27:50Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-11-18T10:27:50Z"}, "message": "tree-scalar-evolution.c (expression_expensive_p): New function.\n\n\t* tree-scalar-evolution.c (expression_expensive_p): New function.\n\t(scev_const_prop): Use compute_overall_effect_of_inner_loop.\n\n\t* gcc.dg/tree-ssa/loop-14.c: New test.\n\nFrom-SVN: r107170", "tree": {"sha": "feca6fb50fea0f4ac734005b28fa6601460c13b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feca6fb50fea0f4ac734005b28fa6601460c13b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/925196ed525e3f05b74d54391edd3a198986e035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925196ed525e3f05b74d54391edd3a198986e035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/925196ed525e3f05b74d54391edd3a198986e035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925196ed525e3f05b74d54391edd3a198986e035/comments", "author": null, "committer": null, "parents": [{"sha": "d087f5fe3148044f40866d6f0d307db52c3d64ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d087f5fe3148044f40866d6f0d307db52c3d64ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d087f5fe3148044f40866d6f0d307db52c3d64ec"}], "stats": {"total": 91, "additions": 66, "deletions": 25}, "files": [{"sha": "7774bdaeaa83ce3584d81485a06aac0866d70da6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/925196ed525e3f05b74d54391edd3a198986e035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/925196ed525e3f05b74d54391edd3a198986e035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=925196ed525e3f05b74d54391edd3a198986e035", "patch": "@@ -1,3 +1,8 @@\n+2005-11-18  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-scalar-evolution.c (expression_expensive_p): New function.\n+\t(scev_const_prop): Use compute_overall_effect_of_inner_loop.\n+\n 2005-11-18  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/crtlibid.s: New file."}, {"sha": "dc1c727a80cf00513303df7af5400978edc3dec4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=925196ed525e3f05b74d54391edd3a198986e035", "patch": "@@ -1,3 +1,7 @@\n+2005-11-18  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-14.c: New test.\n+\n 2005-11-17  James A. Morrison  <phython@gcc.gnu.org>\n             Michael Chamberlain <michael@chamberlain.net.au>\n "}, {"sha": "ff96e128bebe2b4800be882df7f077e8c789e569", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-14.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-14.c?ref=925196ed525e3f05b74d54391edd3a198986e035", "patch": "@@ -0,0 +1,19 @@\n+/* A test for final value replacement.  */\n+\n+/* { dg-options \"-O2 -fdump-tree-vars\" } */\n+\n+int foo(void);\n+\n+int bla(void)\n+{\n+  int i, j = foo ();\n+\n+  for (i = 0; i < 100; i++, j++)\n+    foo ();\n+\n+  /* Should be replaced with return j0 + 100;  */\n+  return j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\+ 100\" 1 \"vars\" } } */\n+/* { dg-final { cleanup-tree-dump \"vars\" } } */"}, {"sha": "c35298e9d09bb088404c04335a9882fc2d97bc02", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/925196ed525e3f05b74d54391edd3a198986e035/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=925196ed525e3f05b74d54391edd3a198986e035", "patch": "@@ -2700,6 +2700,14 @@ scev_finalize (void)\n   BITMAP_FREE (already_instantiated);\n }\n \n+/* Returns true if EXPR looks expensive.  */\n+\n+static bool\n+expression_expensive_p (tree expr)\n+{\n+  return force_expr_to_var_cost (expr) >= target_spill_cost;\n+}\n+\n /* Replace ssa names for that scev can prove they are constant by the\n    appropriate constants.  Also perform final value replacement in loops,\n    in case the replacement expressions are cheap.\n@@ -2775,7 +2783,8 @@ scev_const_prop (void)\n   for (i = current_loops->num - 1; i > 0; i--)\n     {\n       edge exit;\n-      tree def, stmts;\n+      tree def, rslt, ass;\n+      block_stmt_iterator bsi;\n \n       loop = current_loops->parray[i];\n       if (!loop)\n@@ -2787,46 +2796,50 @@ scev_const_prop (void)\n       if (!exit\n \t  || number_of_iterations_in_loop (loop) == chrec_dont_know)\n \tcontinue;\n-      ex_loop = exit->dest->loop_father;\n+\n+      /* Ensure that it is possible to insert new statements somewhere.  */\n+      if (!single_pred_p (exit->dest))\n+\tsplit_loop_exit_edge (exit);\n+      tree_block_label (exit->dest);\n+      bsi = bsi_after_labels (exit->dest);\n+\n+      ex_loop = superloop_at_depth (loop, exit->dest->loop_father->depth + 1);\n \n       for (phi = phi_nodes (exit->dest); phi; phi = next_phi)\n \t{\n \t  next_phi = PHI_CHAIN (phi);\n+\t  rslt = PHI_RESULT (phi);\n \t  def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-\t  if (!is_gimple_reg (def)\n-\t      || expr_invariant_in_loop_p (loop, def))\n+\t  if (!is_gimple_reg (def))\n \t    continue;\n \n \t  if (!POINTER_TYPE_P (TREE_TYPE (def))\n \t      && !INTEGRAL_TYPE_P (TREE_TYPE (def)))\n \t    continue;\n \n-\t  def = analyze_scalar_evolution_in_loop (ex_loop, ex_loop, def);\n+\t  def = analyze_scalar_evolution_in_loop (ex_loop, loop, def);\n+\t  def = compute_overall_effect_of_inner_loop (ex_loop, def);\n \t  if (!tree_does_not_contain_chrecs (def)\n-\t      || chrec_contains_symbols_defined_in_loop (def, loop->num)\n-\t      || def == PHI_RESULT (phi)\n-\t      || (TREE_CODE (def) == SSA_NAME\n-\t\t  && loop_containing_stmt (SSA_NAME_DEF_STMT (def))\n-\t\t  && loop_containing_stmt (phi)\n-\t\t  && loop_containing_stmt (SSA_NAME_DEF_STMT (def))\n-\t\t  == loop_containing_stmt (phi)))\n+\t      || chrec_contains_symbols_defined_in_loop (def, ex_loop->num))\n \t    continue;\n \n-\t  /* If computing the expression is expensive, let it remain in\n-\t     loop.  TODO -- we should take the cost of computing the expression\n-\t     in loop into account.  */\n-\t  if (force_expr_to_var_cost (def) >= target_spill_cost)\n+\t  /* If computing the expression is expensive, let it remain in the\n+\t     loop.  */\n+\t  if (expression_expensive_p (def))\n \t    continue;\n-\t  def = unshare_expr (def);\n \n-\t  if (is_gimple_val (def))\n-\t    stmts = NULL_TREE;\n-\t  else\n-\t    def = force_gimple_operand (def, &stmts, true,\n-\t\t\t\t\tSSA_NAME_VAR (PHI_RESULT (phi)));\n-\t  SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, exit), def);\n-\t  if (stmts)\n-\t    compute_phi_arg_on_exit (exit, stmts, def);\n+\t  /* Eliminate the phi node and replace it by a computation outside\n+\t     the loop.  */\n+\t  def = unshare_expr (def);\n+\t  SET_PHI_RESULT (phi, NULL_TREE);\n+\t  remove_phi_node (phi, NULL_TREE);\n+\n+\t  ass = build2 (MODIFY_EXPR, void_type_node, rslt, NULL_TREE);\n+\t  SSA_NAME_DEF_STMT (rslt) = ass;\n+\t  bsi_insert_after (&bsi, ass, BSI_NEW_STMT);\n+\t  def = force_gimple_operand_bsi (&bsi, def, false, NULL_TREE);\n+\t  TREE_OPERAND (ass, 1) = def;\n+\t  update_stmt (ass);\n \t}\n     }\n }"}]}