{"sha": "c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNjNDQ1ZTFjZmU0MTg0YzBkMzUzN2Y4N2U4ZTViZDNmOTk3NDY0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-12T17:55:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-12T17:55:13Z"}, "message": "common.opt (flto-partition): Add \"max\".\n\n\t* common.opt (flto-partition): Add \"max\".\n\t* invoke.texi (flto-partition): Document \"max\"\n\n\t* lto.c (do_whole_program_analysis): Care timevars, statistics and\n\tAUX pointer cleaning. Add max partitioning.\n\t* lto-partition.c (enum symbol_class): New.\n\t(get_symbol_class): New function.\n\t(symbol_partitioned_p): New function.\n\t(add_references_to_partition): Remove.\n\t(add_aliases_to_partition): Remove.\n\t(add_cgraph_node_to_partition_1): Remove.\n\t(add_cgraph_node_to_partition): Remove.\n\t(add_symbol_to_partition): New function.\n\t(add_symbol_to_partition_1): New function.\n\t(contained_in_symbol): New function.\n\t(partition_cgraph_node_p): Remove.\n\t(partition_varpool_node_p): Remove.\n\t(partition_symbol_p): Remove.\n\t(lto_1_to_1_map): Cleanup.\n\t(lto_max_map): New.\n\t(lto_balanced_map): Update.\n\t(lto_promote_cross_file_statics): Update.\n\t* lto-partition.h (lto_max_map): Declare.\n\t* timevar.def (TV_WHOPR_PARTITIONING): New timevar.\n\nFrom-SVN: r191229", "tree": {"sha": "4b0831fe3e4311ccc76b7a244999bd8e3c36b484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b0831fe3e4311ccc76b7a244999bd8e3c36b484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/comments", "author": null, "committer": null, "parents": [{"sha": "b5c7cdfb0a1331bbed96c6e1c4f7e832fe070100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c7cdfb0a1331bbed96c6e1c4f7e832fe070100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c7cdfb0a1331bbed96c6e1c4f7e832fe070100"}], "stats": {"total": 546, "additions": 316, "deletions": 230}, "files": [{"sha": "3fb65fe1adc310295a0363d5de1e002e28afc29f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -1,3 +1,8 @@\n+2012-09-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* common.opt (flto-partition): Add \"max\".\n+\t* invoke.texi (flto-partition): Document \"max\"\n+\n 2012-09-12  Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n \n \t* config/i386/i386.md : Comments on fma4 instruction"}, {"sha": "aa893acb20e5c331d8b2fa59133d3f23e59f2a88", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -1439,12 +1439,16 @@ Link-time optimization with number of parallel jobs or jobserver.\n \n flto-partition=1to1\n Common Var(flag_lto_partition_1to1)\n-Partition functions and vars at linktime based on object files they originate from\n+Partition symbols and vars at linktime based on object files they originate from\n \n flto-partition=balanced\n Common Var(flag_lto_partition_balanced)\n Partition functions and vars at linktime into approximately same sized buckets\n \n+flto-partition=max\n+Common Var(flag_lto_partition_max)\n+Put every symbol into separate partition\n+\n flto-partition=none\n Common Var(flag_lto_partition_none)\n Disable partioning and streaming"}, {"sha": "0a9226a313bdc9d42dbdf9f10b08ce9811909972", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -8093,9 +8093,12 @@ This option is disabled by default.\n Specify the partitioning algorithm used by the link-time optimizer.\n The value is either @code{1to1} to specify a partitioning mirroring\n the original source files or @code{balanced} to specify partitioning\n-into equally sized chunks (whenever possible).  Specifying @code{none}\n-as an algorithm disables partitioning and streaming completely. The\n-default value is @code{balanced}.\n+into equally sized chunks (whenever possible) or @code{max} to create\n+new partition for every symbol where possible.  Specifying @code{none}\n+as an algorithm disables partitioning and streaming completely. \n+The default value is @code{balanced}. While @code{1to1} can be used\n+as an workaround for various code ordering issues, the @code{max}\n+partitioning is intended for internal testing only.\n \n @item -flto-compression-level=@var{n}\n This option specifies the level of compression used for intermediate"}, {"sha": "8b2a469d8647bda6bd235141f26611608bbcd989", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -1,3 +1,27 @@\n+2012-09-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (do_whole_program_analysis): Care timevars, statistics and\n+\tAUX pointer cleaning. Add max partitioning.\n+\t* lto-partition.c (enum symbol_class): New.\n+\t(get_symbol_class): New function.\n+\t(symbol_partitioned_p): New function.\n+\t(add_references_to_partition): Remove.\n+\t(add_aliases_to_partition): Remove.\n+\t(add_cgraph_node_to_partition_1): Remove.\n+\t(add_cgraph_node_to_partition): Remove.\n+\t(add_symbol_to_partition): New function.\n+\t(add_symbol_to_partition_1): New function.\n+\t(contained_in_symbol): New function.\n+\t(partition_cgraph_node_p): Remove.\n+\t(partition_varpool_node_p): Remove.\n+\t(partition_symbol_p): Remove.\n+\t(lto_1_to_1_map): Cleanup.\n+\t(lto_max_map): New.\n+\t(lto_balanced_map): Update.\n+\t(lto_promote_cross_file_statics): Update.\n+\t* lto-partition.h (lto_max_map): Declare.\n+\t* timevar.def (TV_WHOPR_PARTITIONING): New timevar.\n+\n 2012-09-11  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/54312"}, {"sha": "b1310335a4a141cbd9dc2182f992f66391686ea6", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 239, "deletions": 225, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -31,13 +31,70 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"lto-partition.h\"\n \n+/* Classifcation of symbols into classes WRT partitioning.  */\n+enum symbol_class\n+{\n+   /* External declarations are ignored by partitioning algorithms and they are\n+      added into the boundary later via compute_ltrans_boundary.  */\n+   SYMBOL_EXTERNAL,\n+   /* Partitioned symbols are pur into one of partitions.  */\n+   SYMBOL_PARTITION,\n+   /* Duplicated symbols (such as comdat or constant pool references) are\n+      copied into every node needing them via add_symbol_to_partition.  */\n+   SYMBOL_DUPLICATE\n+};\n+\n VEC(ltrans_partition, heap) *ltrans_partitions;\n \n-static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n-static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n-static bool partition_symbol_p (symtab_node node);\n+static void add_symbol_to_partition (ltrans_partition part, symtab_node node);\n+\n+/* Classify symbol NODE.  */\n+\n+enum symbol_class\n+get_symbol_class (symtab_node node)\n+{\n+  /* Inline clones are always duplicated.\n+     This include external delcarations.   */\n+  if (symtab_function_p (node)\n+      && cgraph (node)->global.inlined_to)\n+    return SYMBOL_DUPLICATE;\n+\n+  /* External declarations are external.  */\n+  if (DECL_EXTERNAL (node->symbol.decl))\n+    return SYMBOL_EXTERNAL;\n+\n+  if (symtab_variable_p (node))\n+    {\n+      /* Constant pool references use local symbol names that can not\n+         be promoted global.  We should never put into a constant pool\n+         objects that can not be duplicated across partitions.  */\n+      if (DECL_IN_CONSTANT_POOL (node->symbol.decl))\n+\treturn SYMBOL_DUPLICATE;\n+      gcc_checking_assert (varpool (node)->analyzed);\n+    }\n+  /* Functions that are cloned may stay in callgraph even if they are unused.\n+     Handle them as external; compute_ltrans_boundary take care to make\n+     proper things to happen (i.e. to make them appear in the boundary but\n+     with body streamed, so clone can me materialized).  */\n+  else if (!cgraph (node)->analyzed)\n+    return SYMBOL_EXTERNAL;\n+\n+  /* Weakref aliases are always duplicated.  */\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+    return SYMBOL_DUPLICATE;\n+\n+  /* Comdats are duplicated to every use unless they are keyed.\n+     Those do not need duplication.  */\n+  if (DECL_COMDAT (node->symbol.decl)\n+      && !node->symbol.force_output\n+      && !symtab_used_from_object_file_p ((symtab_node) node))\n+    return SYMBOL_DUPLICATE;\n+\n+  return SYMBOL_PARTITION;\n+}\n \n /* Create new partition with name NAME.  */\n+\n static ltrans_partition\n new_partition (const char *name)\n {\n@@ -50,167 +107,183 @@ new_partition (const char *name)\n }\n \n /* Free memory used by ltrans datastructures.  */\n+\n void\n free_ltrans_partitions (void)\n {\n   unsigned int idx;\n   ltrans_partition part;\n   for (idx = 0; VEC_iterate (ltrans_partition, ltrans_partitions, idx, part); idx++)\n     {\n+      if (part->initializers_visited)\n+\tpointer_set_destroy (part->initializers_visited);\n       /* Symtab encoder is freed after streaming.  */\n       free (part);\n     }\n   VEC_free (ltrans_partition, heap, ltrans_partitions);\n }\n \n-/* Add all referenced symbols referenced by REFS that are not external and not\n-   partitioned into PART.  */\n-static void\n-add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n+/* Return true if symbol is already in some partition.  */\n+\n+static inline bool\n+symbol_partitioned_p (symtab_node node)\n {\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n-    {\n-      if (DECL_EXTERNAL (ref->referred->symbol.decl)\n-\t  || partition_symbol_p (ref->referred)\n-\t  || lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n-\tcontinue;\n-      if (symtab_function_p (ref->referred))\n-\tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n-      else\n-\tadd_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n-    }\n+  return node->symbol.aux;\n }\n \n-/* Look for all (nonweakref) aliases in REFS and add them into PART. */\n+/* Add references into the partition.  */\n static void\n-add_aliases_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n+add_references_to_partition (ltrans_partition part, symtab_node node)\n {\n   int i;\n   struct ipa_ref *ref;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (refs, i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS\n-\t&& !lto_symtab_encoder_in_partition_p (part->encoder,\n-\t\t\t\t\t       ref->referring)\n-\t&& !lookup_attribute (\"weakref\",\n-\t\t\t      DECL_ATTRIBUTES\n-\t\t\t\t(ref->referring->symbol.decl)))\n+  /* Add all duplicated references to the partition.  */\n+  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+    if (get_symbol_class (ref->referred) == SYMBOL_DUPLICATE)\n+      add_symbol_to_partition (part, ref->referred);\n+    /* References to a readonly variable may be constant foled into its value.\n+       Recursively look into the initializers of the constant variable and add\n+       references, too.  */\n+    else if (symtab_variable_p (ref->referred)\n+\t     && const_value_known_p (ref->referred->symbol.decl)\n+\t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n-\tif (symtab_function_p (ref->referring))\n-\t  add_cgraph_node_to_partition (part, ipa_ref_referring_node (ref));\n-\telse\n-\t  add_varpool_node_to_partition (part,\n-\t\t\t\t\t ipa_ref_referring_varpool_node (ref));\n+\tif (!part->initializers_visited)\n+\t  part->initializers_visited = pointer_set_create ();\n+\tif (!pointer_set_insert (part->initializers_visited, ref->referred))\n+\t  add_references_to_partition (part, ref->referred);\n       }\n }\n \n-/* Worker for add_cgraph_node_to_partition.  */\n+/* Helper function for add_symbol_to_partition doing the actual dirty work\n+   of adding NODE to PART.  */\n \n static bool\n-add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n+add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n {\n-  ltrans_partition part = (ltrans_partition) data;\n+  enum symbol_class c = get_symbol_class (node);\n+  int i;\n+  struct ipa_ref *ref;\n+  symtab_node node1;\n \n+  /* If NODE is already there, we have nothing to do.  */\n   if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) node))\n+    return true;\n+\n+  /* non-duplicated aliases or tunks of a duplicated symbol needs to be output\n+     just once.\n+\n+     Be lax about comdats; they may or may not be duplicated and we may\n+     end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n+  if (c == SYMBOL_PARTITION && !DECL_COMDAT (node->symbol.decl)\n+      && symbol_partitioned_p (node))\n     return false;\n \n-  /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n-  if (!DECL_COMDAT (node->symbol.decl)\n-      && !node->global.inlined_to\n-      && node->symbol.aux)\n-    {\n-      gcc_assert (node->thunk.thunk_p || node->alias);\n-      return false;\n-    }\n+  /* Be sure that we never try to duplicate partitioned symbol\n+     or add external symbol.  */\n+  gcc_assert (c != SYMBOL_EXTERNAL\n+\t      && (c == SYMBOL_DUPLICATE || !symbol_partitioned_p (node)));\n+\n+  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) node);\n \n-  if (node->symbol.aux)\n+  if (symbol_partitioned_p (node))\n     {\n       node->symbol.in_other_partition = 1;\n       if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n-\t\t cgraph_node_name (node), node->uid);\n+        fprintf (cgraph_dump_file, \"Symbol node %s now used in multiple partitions\\n\",\n+\t\t symtab_node_name (node));\n     }\n   node->symbol.aux = (void *)((size_t)node->symbol.aux + 1);\n-  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node)node);\n-  return false;\n-}\n-\n-/* Add NODE to partition as well as the inline callees and referred comdats into partition PART. */\n-\n-static void\n-add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n-{\n-  struct cgraph_edge *e;\n-  struct cgraph_node *n;\n-\n-  /* If NODE is already there, we have nothing to do.  */\n-  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) node))\n-    return;\n-\n-  cgraph_for_node_thunks_and_aliases (node, add_cgraph_node_to_partition_1, part, true);\n \n-  part->insns += inline_summary (node)->self_size;\n+  if (symtab_function_p (node))\n+    {\n+      struct cgraph_node *cnode = cgraph (node);\n+      struct cgraph_edge *e;\n+      part->insns += inline_summary (cnode)->self_size;\n+\n+      /* Add all inline clones and callees that are duplicated.  */\n+      for (e = cnode->callees; e; e = e->next_callee)\n+\tif (!e->inline_failed)\n+\t  add_symbol_to_partition_1 (part, (symtab_node) e->callee);\n+\telse if (get_symbol_class ((symtab_node) e->callee) == SYMBOL_DUPLICATE)\n+\t  add_symbol_to_partition (part, (symtab_node) e->callee);\n+\n+      /* Add all thunks associated with the function.  */\n+      for (e = cnode->callers; e; e = e->next_caller)\n+\tif (e->caller->thunk.thunk_p)\n+\t  add_symbol_to_partition_1 (part, (symtab_node) e->caller);\n+    }\n \n-  for (e = node->callees; e; e = e->next_callee)\n-    if ((!e->inline_failed\n-         || (!DECL_EXTERNAL (e->callee->symbol.decl)\n-\t     && !partition_symbol_p ((symtab_node) e->callee))))\n-      add_cgraph_node_to_partition (part, e->callee);\n+  add_references_to_partition (part, node);\n \n-  /* The only way to assemble non-weakref alias is to add the aliased object into\n-     the unit.  */\n-  add_references_to_partition (part, &node->symbol.ref_list);\n-  n = cgraph_function_node (node, NULL);\n-  if (n != node\n-      && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (node->symbol.decl)))\n-    add_cgraph_node_to_partition (part, n);\n+  /* Add all aliases associated with the symbol.  */\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS\n+\t&& !lookup_attribute (\"weakref\",\n+\t\t\t      DECL_ATTRIBUTES\n+\t\t\t\t(ref->referring->symbol.decl)))\n+      add_symbol_to_partition_1 (part, ref->referring);\n \n+  /* Ensure that SAME_COMDAT_GROUP lists all allways added in a group.  */\n   if (node->symbol.same_comdat_group)\n-    for (n = cgraph (node->symbol.same_comdat_group);\n-\t n != node; n = cgraph (n->symbol.same_comdat_group))\n-      add_cgraph_node_to_partition (part, n);\n+    for (node1 = node->symbol.same_comdat_group;\n+\t node1 != node; node1 = node1->symbol.same_comdat_group)\n+      {\n+\tbool added = add_symbol_to_partition_1 (part, node1);\n+\tgcc_assert (added);\n+      }\n+  return true;\n }\n \n-/* Add VNODE to partition as well as comdat references partition PART. */\n+/* If symbol NODE is really part of other symbol's definition (i.e. it is\n+   internal label, thunk, alias or so), return the outer symbol. \n+   When add_symbol_to_partition_1 is called on the outer symbol it must\n+   eventually add NODE, too.  */\n+static symtab_node\n+contained_in_symbol (symtab_node node)\n+{\n+  /* Weakrefs are never contained in anything.  */\n+  if (lookup_attribute (\"weakref\",\n+\t\t\tDECL_ATTRIBUTES (node->symbol.decl)))\n+    return node;\n+  if (symtab_function_p (node))\n+    {\n+      struct cgraph_node *cnode = cgraph_function_node (cgraph (node), NULL);\n+      if (cnode->global.inlined_to)\n+\tcnode = cnode->global.inlined_to;\n+      return (symtab_node) cnode;\n+    }\n+  else if (symtab_variable_p (node))\n+    return (symtab_node) varpool_variable_node (varpool (node), NULL);\n+  return node;\n+}\n+\n+/* Add symbol NODE to partition.  When definition of NODE is part\n+   of other symbol definition, add the other symbol, too.  */\n \n static void\n-add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n+add_symbol_to_partition (ltrans_partition part, symtab_node node)\n {\n-  struct varpool_node *v;\n+  symtab_node node1;\n \n-  /* If NODE is already there, we have nothing to do.  */\n-  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) vnode))\n-    return;\n+  /* Verify that we do not try to duplicate something that can not be.  */\n+  gcc_checking_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n+\t\t       || !symbol_partitioned_p (node));\n \n-  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) vnode);\n+  while ((node1 = contained_in_symbol (node)) != node)\n+    node = node1;\n \n-  if (vnode->symbol.aux)\n-    {\n-      vnode->symbol.in_other_partition = 1;\n-      if (cgraph_dump_file)\n-        fprintf (cgraph_dump_file, \"Varpool node %s now used in multiple partitions\\n\",\n-\t\t varpool_node_name (vnode));\n-    }\n-  vnode->symbol.aux = (void *)((size_t)vnode->symbol.aux + 1);\n-\n-  /* The only way to assemble non-weakref alias is to add the aliased object into\n-     the unit.  */\n-  v = varpool_variable_node (vnode, NULL);\n-  if (v != vnode\n-      && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (vnode->symbol.decl)))\n-    add_varpool_node_to_partition (part, v);\n-\n-  add_references_to_partition (part, &vnode->symbol.ref_list);\n-  add_aliases_to_partition (part, &vnode->symbol.ref_list);\n-\n-  if (vnode->symbol.same_comdat_group\n-      && !lto_symtab_encoder_in_partition_p (part->encoder,\n-\t\t\t\t\t     vnode->symbol.same_comdat_group))\n-    add_varpool_node_to_partition (part, varpool (vnode->symbol.same_comdat_group));\n+  /* If we have duplicated symbol contained in something we can not duplicate,\n+     we are very badly screwed.  The other way is possible, so we do not\n+     assert this in add_symbol_to_partition_1. \n+\n+     Be lax about comdats; they may or may not be duplicated and we may\n+     end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n+  gcc_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n+\t      || DECL_COMDAT (node->symbol.decl)\n+\t      || !symbol_partitioned_p (node));\n+  add_symbol_to_partition_1 (part, node);\n }\n \n /* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n@@ -223,92 +296,38 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n     {\n       symtab_node node = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t   n_nodes);\n+\n+      /* After UNDO we no longer know what was visited.  */\n+      if (partition->initializers_visited)\n+\tpointer_set_destroy (partition->initializers_visited);\n+      partition->initializers_visited = NULL;\n+\n       if (symtab_function_p (node))\n         partition->insns -= inline_summary (cgraph (node))->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n     }\n }\n \n-/* Return true if NODE should be partitioned.\n-   This means that partitioning algorithm should put NODE into one of partitions.\n-   This apply to most functions with bodies.  Functions that are not partitions\n-   are put into every unit needing them.  This is the case of i.e. COMDATs.  */\n-\n-static bool\n-partition_cgraph_node_p (struct cgraph_node *node)\n-{\n-  /* We will get proper partition based on function they are inlined to.  */\n-  if (node->global.inlined_to)\n-    return false;\n-  /* Nodes without a body do not need partitioning.  */\n-  if (!node->analyzed)\n-    return false;\n-  /* Extern inlines and comdat are always only in partitions they are needed.  */\n-  if (DECL_EXTERNAL (node->symbol.decl)\n-      || (DECL_COMDAT (node->symbol.decl)\n-\t  && !node->symbol.force_output\n-\t  && !symtab_used_from_object_file_p ((symtab_node) node)))\n-    return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n-    return false;\n-  return true;\n-}\n-\n-/* Return true if VNODE should be partitioned. \n-   This means that partitioning algorithm should put VNODE into one of partitions. */\n-\n-static bool\n-partition_varpool_node_p (struct varpool_node *vnode)\n-{\n-  if (!vnode->analyzed)\n-    return false;\n-  /* Constant pool and comdat are always only in partitions they are needed.  */\n-  if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n-      || DECL_EXTERNAL (vnode->symbol.decl)\n-      || (DECL_COMDAT (vnode->symbol.decl)\n-\t  && !vnode->symbol.force_output\n-\t  && !symtab_used_from_object_file_p ((symtab_node) vnode)))\n-    return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n-    return false;\n-  return true;\n-}\n-\n-/* Return true if NODE should be partitioned. \n-   This means that partitioning algorithm should put NODE into one of partitions. */\n-\n-static bool\n-partition_symbol_p (symtab_node node)\n-{\n-  if (symtab_function_p (node))\n-    return partition_cgraph_node_p (cgraph (node));\n-  else\n-    return partition_varpool_node_p (varpool (node));\n-}\n-\n /* Group cgrah nodes by input files.  This is used mainly for testing\n    right now.  */\n \n void\n lto_1_to_1_map (void)\n {\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n+  symtab_node node;\n   struct lto_file_decl_data *file_data;\n   struct pointer_map_t *pmap;\n   ltrans_partition partition;\n   void **slot;\n   int npartitions = 0;\n \n-  timevar_push (TV_WHOPR_WPA);\n-\n   pmap = pointer_map_create ();\n \n-  FOR_EACH_DEFINED_FUNCTION (node)\n+  FOR_EACH_SYMBOL (node)\n     {\n-      if (!partition_cgraph_node_p (node)\n-\t  || node->symbol.aux)\n+      if (get_symbol_class (node) != SYMBOL_PARTITION\n+\t  || symbol_partitioned_p (node))\n \tcontinue;\n \n       file_data = node->symbol.lto_file_data;\n@@ -337,32 +356,8 @@ lto_1_to_1_map (void)\n \t  npartitions++;\n \t}\n \n-      add_cgraph_node_to_partition (partition, node);\n-    }\n-\n-  FOR_EACH_VARIABLE (vnode)\n-    {\n-      if (!partition_varpool_node_p (vnode)\n-\t  || vnode->symbol.aux)\n-\tcontinue;\n-      file_data = vnode->symbol.lto_file_data;\n-      slot = pointer_map_contains (pmap, file_data);\n-      if (slot)\n-\tpartition = (ltrans_partition) *slot;\n-      else\n-\t{\n-\t  partition = new_partition (file_data->file_name);\n-\t  slot = pointer_map_insert (pmap, file_data);\n-\t  *slot = partition;\n-\t  npartitions++;\n-\t}\n-\n-      add_varpool_node_to_partition (partition, vnode);\n+      add_symbol_to_partition (partition, (symtab_node) node);\n     }\n-  FOR_EACH_FUNCTION (node)\n-    node->symbol.aux = NULL;\n-  FOR_EACH_VARIABLE (vnode)\n-    vnode->symbol.aux = NULL;\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n      an output file for any variables that need to be exported in a DSO.  */\n@@ -371,10 +366,28 @@ lto_1_to_1_map (void)\n \n   pointer_map_destroy (pmap);\n \n-  timevar_pop (TV_WHOPR_WPA);\n+}\n+\n+/* Maximal partitioning.  Put every new symbol into new partition if possible.  */\n \n-  lto_stats.num_cgraph_partitions += VEC_length (ltrans_partition, \n-\t\t\t\t\t\t ltrans_partitions);\n+void\n+lto_max_map (void)\n+{\n+  symtab_node node;\n+  ltrans_partition partition;\n+  int npartitions = 0;\n+\n+  FOR_EACH_SYMBOL (node)\n+    {\n+      if (get_symbol_class (node) != SYMBOL_PARTITION\n+\t  || symbol_partitioned_p (node))\n+\tcontinue;\n+      partition = new_partition (symtab_node_asm_name (node));\n+      add_symbol_to_partition (partition, (symtab_node) node);\n+      npartitions++;\n+    }\n+  if (!npartitions)\n+    new_partition (\"empty\");\n }\n \n /* Helper function for qsort; sort nodes by order.  */\n@@ -467,7 +480,7 @@ lto_balanced_map (void)\n   for (i = 0; i < postorder_len; i++)\n     {\n       node = postorder[i];\n-      if (partition_cgraph_node_p (node))\n+      if (get_symbol_class ((symtab_node) node) == SYMBOL_PARTITION)\n \t{\n \t  order[n_nodes++] = node;\n           total_size += inline_summary (node)->size;\n@@ -480,13 +493,13 @@ lto_balanced_map (void)\n       qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n \n       FOR_EACH_VARIABLE (vnode)\n-\tif (partition_varpool_node_p (vnode))\n+\tif (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n       varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n       FOR_EACH_VARIABLE (vnode)\n-\tif (partition_varpool_node_p (vnode))\n+\tif (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n \t  varpool_order[n_varpool_nodes++] = vnode;\n       qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n \t     varpool_node_cmp);\n@@ -504,7 +517,7 @@ lto_balanced_map (void)\n \n   for (i = 0; i < n_nodes; i++)\n     {\n-      if (order[i]->symbol.aux)\n+      if (symbol_partitioned_p ((symtab_node) order[i]))\n \tcontinue;\n \n       current_order = order[i]->symbol.order;\n@@ -513,19 +526,19 @@ lto_balanced_map (void)\n \twhile (varpool_pos < n_varpool_nodes\n \t       && varpool_order[varpool_pos]->symbol.order < current_order)\n \t  {\n-\t    if (!varpool_order[varpool_pos]->symbol.aux)\n-\t      add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t    if (!symbol_partitioned_p ((symtab_node) varpool_order[varpool_pos]))\n+\t      add_symbol_to_partition (partition, (symtab_node) varpool_order[varpool_pos]);\n \t    varpool_pos++;\n \t  }\n \n-      add_cgraph_node_to_partition (partition, order[i]);\n+      add_symbol_to_partition (partition, (symtab_node) order[i]);\n       total_size -= inline_summary (order[i])->size;\n \t  \n \n       /* Once we added a new node to the partition, we also want to add\n          all referenced variables unless they was already added into some\n          earlier partition.\n-\t add_cgraph_node_to_partition adds possibly multiple nodes and\n+\t add_symbol_to_partition adds possibly multiple nodes and\n \t variables that are needed to satisfy needs of ORDER[i].\n          We remember last visited cgraph and varpool node from last iteration\n          of outer loop that allows us to process every new addition. \n@@ -605,9 +618,9 @@ lto_balanced_map (void)\n \t\tvnode = ipa_ref_varpool_node (ref);\n \t\tif (!vnode->finalized)\n \t\t  continue;\n-\t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n-\t\t    && partition_varpool_node_p (vnode))\n-\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n+\t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n+\t\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   (symtab_node)vnode);\n \t\tif (index != LCC_NOT_FOUND\n@@ -638,9 +651,9 @@ lto_balanced_map (void)\n \n \t\tvnode = ipa_ref_referring_varpool_node (ref);\n \t\tgcc_assert (vnode->finalized);\n-\t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n-\t\t    && partition_varpool_node_p (vnode))\n-\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n+\t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n+\t\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   (symtab_node)vnode);\n \t\tif (index != LCC_NOT_FOUND\n@@ -696,7 +709,7 @@ lto_balanced_map (void)\n \t    }\n \t  i = best_i;\n  \t  /* When we are finished, avoid creating empty partition.  */\n-\t  while (i < n_nodes - 1 && order[i + 1]->symbol.aux)\n+\t  while (i < n_nodes - 1 && symbol_partitioned_p ((symtab_node) order[i + 1]))\n \t    i++;\n \t  if (i == n_nodes - 1)\n \t    break;\n@@ -728,15 +741,16 @@ lto_balanced_map (void)\n   if (flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-        if (partition_varpool_node_p (vnode) && !vnode->symbol.aux)\n-\t  add_varpool_node_to_partition (partition, vnode);\n+        if (get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION\n+\t    && !symbol_partitioned_p ((symtab_node) vnode))\n+\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n     }\n   else\n     {\n       while (varpool_pos < n_varpool_nodes)\n \t{\n-\t  if (!varpool_order[varpool_pos]->symbol.aux)\n-\t    add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t  if (!symbol_partitioned_p ((symtab_node) varpool_order[varpool_pos]))\n+\t    add_symbol_to_partition (partition, (symtab_node) varpool_order[varpool_pos]);\n \t  varpool_pos++;\n \t}\n       free (varpool_order);\n@@ -806,7 +820,7 @@ lto_promote_cross_file_statics (void)\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)\n \t      /* ... or if we do not partition it. This mean that it will\n \t\t appear in every partition refernecing it.  */\n-\t      || !partition_symbol_p (node))\n+\t      || get_symbol_class ((symtab_node) node) != SYMBOL_PARTITION)\n \t    continue;\n \n           promote_symbol (node);"}, {"sha": "5bf4055269f208ecc242ad6d37a4e10ee85b1b0d", "filename": "gcc/lto/lto-partition.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto-partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto-partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.h?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -25,6 +25,7 @@ struct ltrans_partition_def\n   lto_symtab_encoder_t encoder;\n   const char * name;\n   int insns;\n+  pointer_set_t *initializers_visited;\n };\n \n typedef struct ltrans_partition_def *ltrans_partition;\n@@ -34,6 +35,7 @@ DEF_VEC_ALLOC_P(ltrans_partition,heap);\n extern VEC(ltrans_partition, heap) *ltrans_partitions;\n \n void lto_1_to_1_map (void);\n+void lto_max_map (void);\n void lto_balanced_map (void);\n void lto_promote_cross_file_statics (void);\n void free_ltrans_partitions (void);"}, {"sha": "c15f9cff5a793e41408bc53bdeb6b9f4cc3e9625", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -2604,11 +2604,28 @@ lto_wpa_write_files (void)\n \t  \n \t  fprintf (cgraph_dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n \t\t   part->name, temp_filename, part->insns);\n+\t  fprintf (cgraph_dump_file, \"  Symbols in partition: \");\n \t  for (lsei = lsei_start_in_partition (part->encoder); !lsei_end_p (lsei);\n \t       lsei_next_in_partition (&lsei))\n \t    {\n \t      symtab_node node = lsei_node (lsei);\n-\t      fprintf (cgraph_dump_file, \"%s \", symtab_node_name (node));\n+\t      fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n+\t    }\n+\t  fprintf (cgraph_dump_file, \"\\n  Symbols in boundary: \");\n+\t  for (lsei = lsei_start (part->encoder); !lsei_end_p (lsei);\n+\t       lsei_next (&lsei))\n+\t    {\n+\t      symtab_node node = lsei_node (lsei);\n+\t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n+\t\t{\n+\t          fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n+\t\t  if (symtab_function_p (node)\n+\t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cgraph (node)))\n+\t\t    fprintf (cgraph_dump_file, \"(body included)\");\n+\t\t  else if (symtab_variable_p (node)\n+\t\t           && lto_symtab_encoder_encode_initializer_p (part->encoder, varpool (node)))\n+\t\t    fprintf (cgraph_dump_file, \"(initializer included)\");\n+\t\t}\n \t    }\n \t  fprintf (cgraph_dump_file, \"\\n\");\n \t}\n@@ -3093,6 +3110,8 @@ print_lto_report_1 (void)\n static void\n do_whole_program_analysis (void)\n {\n+  symtab_node node;\n+\n   timevar_start (TV_PHASE_OPT_GEN);\n \n   /* Note that since we are in WPA mode, materialize_cgraph will not\n@@ -3127,17 +3146,31 @@ do_whole_program_analysis (void)\n       dump_cgraph (cgraph_dump_file);\n       dump_varpool (cgraph_dump_file);\n     }\n+#ifdef ENABLE_CHECKING\n   verify_cgraph ();\n+#endif\n   bitmap_obstack_release (NULL);\n \n   /* We are about to launch the final LTRANS phase, stop the WPA timer.  */\n   timevar_pop (TV_WHOPR_WPA);\n \n+  timevar_push (TV_WHOPR_PARTITIONING);\n   if (flag_lto_partition_1to1)\n     lto_1_to_1_map ();\n+  else if (flag_lto_partition_max)\n+    lto_max_map ();\n   else\n     lto_balanced_map ();\n \n+  /* AUX pointers are used by partitioning code to bookkeep number of\n+     partitions symbol is in.  This is no longer needed.  */\n+  FOR_EACH_SYMBOL (node)\n+    node->symbol.aux = NULL;\n+\n+  lto_stats.num_cgraph_partitions += VEC_length (ltrans_partition, \n+\t\t\t\t\t\t ltrans_partitions);\n+  timevar_pop (TV_WHOPR_PARTITIONING);\n+\n   timevar_stop (TV_PHASE_OPT_GEN);\n   timevar_start (TV_PHASE_STREAM_OUT);\n "}, {"sha": "8f99b5095586ebbed293f655bd17c6073cf9fdfa", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c445e1cfe4184c0d3537f87e8e5bd3f9974646/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c3c445e1cfe4184c0d3537f87e8e5bd3f9974646", "patch": "@@ -81,6 +81,7 @@ DEFTIMEVAR (TV_IPA_LTO_CGRAPH_MERGE  , \"ipa lto cgraph merge\")\n DEFTIMEVAR (TV_LTO                   , \"lto\")\n DEFTIMEVAR (TV_WHOPR_WPA             , \"whopr wpa\")\n DEFTIMEVAR (TV_WHOPR_WPA_IO          , \"whopr wpa I/O\")\n+DEFTIMEVAR (TV_WHOPR_PARTITIONING    , \"whopr partitioning\")\n DEFTIMEVAR (TV_WHOPR_LTRANS          , \"whopr ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PROFILE           , \"ipa profile\")"}]}