{"sha": "6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMyODMzZTc0ZTRlNjRhNzFiYWZhZjZlMjBlNjU1MDZiYmNlNWE1Yw==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-07-15T05:12:05Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-07-15T05:12:05Z"}, "message": "re PR tree-optimization/88497 (Improve Accumulation in Auto-Vectorized Code)\n\ngcc/ChangeLog\n\n2019-07-15  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR tree-optimization/88497\n    * tree-ssa-reassoc.c (reassociate_bb): Swap the positions of\n    GIMPLE_BINARY_RHS check and gimple_visited_p check, call new\n    function undistribute_bitref_for_vector.\n    (undistribute_bitref_for_vector): New function.\n    (cleanup_vinfo_map): Likewise.\n    (sort_by_mach_mode): Likewise.\n\ngcc/testsuite/ChangeLog\n\n2019-07-15  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR tree-optimization/88497\n    * gcc.dg/tree-ssa/pr88497-1.c: New test.\n    * gcc.dg/tree-ssa/pr88497-2.c: Likewise.\n    * gcc.dg/tree-ssa/pr88497-3.c: Likewise.\n    * gcc.dg/tree-ssa/pr88497-4.c: Likewise.\n    * gcc.dg/tree-ssa/pr88497-5.c: Likewise.\n    * gcc.dg/tree-ssa/pr88497-6.c: Likewise.\n    * gcc.dg/tree-ssa/pr88497-7.c: Likewise.\n\nFrom-SVN: r273490", "tree": {"sha": "72bf6558a965e41b38734da8eeb6753c2f53c690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72bf6558a965e41b38734da8eeb6753c2f53c690"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3126c241afaa38bc9002b3c15e244070b80af09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3126c241afaa38bc9002b3c15e244070b80af09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3126c241afaa38bc9002b3c15e244070b80af09d"}], "stats": {"total": 656, "additions": 650, "deletions": 6}, "files": [{"sha": "1ff1c4c7fcdd73980b047029770613d68a01456c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -1,3 +1,13 @@\n+2019-07-15  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/88497\n+\t* tree-ssa-reassoc.c (reassociate_bb): Swap the positions of\n+\tGIMPLE_BINARY_RHS check and gimple_visited_p check, call new\n+\tfunction undistribute_bitref_for_vector.\n+\t(undistribute_bitref_for_vector): New function.\n+\t(cleanup_vinfo_map): Likewise.\n+\t(sort_by_mach_mode): Likewise.\n+\n 2019-07-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (nonmemory_szext_operand): New mode attribute."}, {"sha": "57d11413f5adb4804eecebec1980de0151d72c67", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -1,3 +1,14 @@\n+2019-07-15  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/88497\n+\t* gcc.dg/tree-ssa/pr88497-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr88497-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr88497-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr88497-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr88497-5.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr88497-6.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr88497-7.c: Likewise.\n+\n 2019-07-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/87233"}, {"sha": "b6dd7ba94fffab44d8a621a44c956c26ce520e07", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-1.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vsx_hw { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target sse2_runtime { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+/* { dg-additional-options \"-mvsx\" { target { powerpc*-*-* } } } */\n+/* { dg-additional-options \"-msse2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref summation.\n+\n+   arg1 and arg2 are two arrays whose elements of type vector double.\n+   Assuming:\n+     A0 = arg1[0], A1 = arg1[1], A2 = arg1[2], A3 = arg1[3],\n+     B0 = arg2[0], B1 = arg2[1], B2 = arg2[2], B3 = arg2[3],\n+\n+   Then:\n+     V0 = A0 * B0, V1 = A1 * B1, V2 = A2 * B2, V3 = A3 * B3,\n+\n+   reassoc transforms\n+\n+     accumulator += V0[0] + V0[1] + V1[0] + V1[1] + V2[0] + V2[1]\n+          + V3[0] + V3[1];\n+\n+   into:\n+\n+     T = V0 + V1 + V2 + V3\n+     accumulator += T[0] + T[1];\n+\n+   Fewer bit_field_refs, only two for 128 or more bits vector.  */\n+\n+typedef double v2df __attribute__ ((vector_size (16)));\n+__attribute__ ((noinline)) double\n+test (double accumulator, v2df arg1[], v2df arg2[])\n+{\n+  v2df temp;\n+  temp = arg1[0] * arg2[0];\n+  accumulator += temp[0] + temp[1];\n+  temp = arg1[1] * arg2[1];\n+  accumulator += temp[0] + temp[1];\n+  temp = arg1[2] * arg2[2];\n+  accumulator += temp[0] + temp[1];\n+  temp = arg1[3] * arg2[3];\n+  accumulator += temp[0] + temp[1];\n+  return accumulator;\n+}\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  v2df v2[4] = {{1.0, 2.0}, {4.0, 8.0}, {1.0, 3.0}, {9.0, 27.0}};\n+  v2df v3[4] = {{1.0, 4.0}, {16.0, 64.0}, {1.0, 2.0}, {3.0, 4.0}};\n+  double acc = 100.0;\n+  double res = test (acc, v2, v3);\n+  if (res != 827.0)\n+    abort ();\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 2 \"reassoc1\" { target { powerpc*-*-* i?86-*-* x86_64-*-* } } } } */"}, {"sha": "8da5920903c5adb47e449cbbf78c22bfed309cf8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-2.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_float } */\n+/* { dg-require-effective-target powerpc_altivec_ok { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target sse2 { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+/* { dg-additional-options \"-maltivec\" { target { powerpc*-*-* } } } */\n+/* { dg-additional-options \"-msse2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on multiplication.\n+\n+   v1, v2, v3, v4 of type vector float.\n+\n+   reassoc transforms\n+\n+     accumulator *= v1[0] * v1[1] * v1[2] * v1[3] *\n+                    v2[0] * v2[1] * v2[2] * v2[3] *\n+                    v3[0] * v3[1] * v3[2] * v3[3] *\n+                    v4[0] * v4[1] * v4[2] * v4[3] ;\n+\n+   into:\n+\n+     T = v1 * v2 * v3 * v4;\n+     accumulator *= T[0] * T[1] * T[2] * T[3];\n+\n+   Fewer bit_field_refs, only four for 128 or more bits vector.  */\n+\n+typedef float v4sf __attribute__ ((vector_size (16)));\n+float\n+test (float accumulator, v4sf v1, v4sf v2, v4sf v3, v4sf v4)\n+{\n+  accumulator *= v1[0] * v1[1] * v1[2] * v1[3];\n+  accumulator *= v2[0] * v2[1] * v2[2] * v2[3];\n+  accumulator *= v3[0] * v3[1] * v3[2] * v3[3];\n+  accumulator *= v4[0] * v4[1] * v4[2] * v4[3];\n+  return accumulator;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"reassoc1\" { target { powerpc*-*-* i?86-*-* x86_64-*-* } } } } */"}, {"sha": "449f282e85cdf6d7139c9ee4b796c552380c653c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-3.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target powerpc_altivec_ok { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target sse2 { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+/* { dg-additional-options \"-maltivec\" { target { powerpc*-*-* } } } */\n+/* { dg-additional-options \"-msse2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on bitwise AND.\n+\n+   v1, v2, v3, v4 of type vector int.\n+\n+   reassoc transforms\n+\n+     accumulator &= v1[0] & v1[1] & v1[2] & v1[3] &\n+                    v2[0] & v2[1] & v2[2] & v2[3] &\n+                    v3[0] & v3[1] & v3[2] & v3[3] &\n+                    v4[0] & v4[1] & v4[2] & v4[3] ;\n+\n+   into:\n+\n+     T = v1 & v2 & v3 & v4;\n+     accumulator &= T[0] & T[1] & T[2] & T[3];\n+\n+   Fewer bit_field_refs, only four for 128 or more bits vector.  */\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+int\n+test (int accumulator, v4si v1, v4si v2, v4si v3, v4si v4)\n+{\n+  accumulator &= v1[0] & v1[1] & v1[2] & v1[3];\n+  accumulator &= v2[0] & v2[1] & v2[2] & v2[3];\n+  accumulator &= v3[0] & v3[1] & v3[2] & v3[3];\n+  accumulator &= v4[0] & v4[1] & v4[2] & v4[3];\n+  return accumulator;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"reassoc1\" { target { powerpc*-*-* i?86-*-* x86_64-*-* } } } } */"}, {"sha": "f7b6c91c911d00d712f161a217c04ba8eebb4822", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-4.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target powerpc_altivec_ok { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target sse2 { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+/* { dg-additional-options \"-maltivec\" { target { powerpc*-*-* } } } */\n+/* { dg-additional-options \"-msse2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on bitwise IOR.\n+\n+   v1, v2, v3, v4 of type vector int.\n+\n+   reassoc transforms\n+\n+     accumulator |= v1[0] | v1[1] | v1[2] | v1[3] |\n+                    v2[0] | v2[1] | v2[2] | v2[3] |\n+                    v3[0] | v3[1] | v3[2] | v3[3] |\n+                    v4[0] | v4[1] | v4[2] | v4[3] ;\n+\n+   into:\n+\n+     T = v1 | v2 | v3 | v4;\n+     accumulator |= T[0] | T[1] | T[2] | T[3];\n+\n+   Fewer bit_field_refs, only four for 128 or more bits vector.  */\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+int\n+test (int accumulator, v4si v1, v4si v2, v4si v3, v4si v4)\n+{\n+  accumulator |= v1[0] | v1[1] | v1[2] | v1[3];\n+  accumulator |= v2[0] | v2[1] | v2[2] | v2[3];\n+  accumulator |= v3[0] | v3[1] | v3[2] | v3[3];\n+  accumulator |= v4[0] | v4[1] | v4[2] | v4[3];\n+  return accumulator;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"reassoc1\" { target { powerpc*-*-* i?86-*-* x86_64-*-* } } } } */"}, {"sha": "cbd12241c7600c03685ce4c1c4ae7192f8047690", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-5.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target powerpc_altivec_ok { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target sse2 { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+/* { dg-additional-options \"-maltivec\" { target { powerpc*-*-* } } } */\n+/* { dg-additional-options \"-msse2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on bitwise XOR.\n+\n+   v1, v2, v3, v4 of type vector int.\n+\n+   reassoc transforms\n+\n+     accumulator ^= v1[0] ^ v1[1] ^ v1[2] ^ v1[3] ^\n+                    v2[0] ^ v2[1] ^ v2[2] ^ v2[3] ^\n+                    v3[0] ^ v3[1] ^ v3[2] ^ v3[3] ^\n+                    v4[0] ^ v4[1] ^ v4[2] ^ v4[3] ;\n+\n+   into:\n+\n+     T = v1 ^ v2 ^ v3 ^ v4;\n+     accumulator ^= T[0] ^ T[1] ^ T[2] ^ T[3];\n+\n+   Fewer bit_field_refs, only four for 128 or more bits vector.  */\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+int\n+test (int accumulator, v4si v1, v4si v2, v4si v3, v4si v4)\n+{\n+  accumulator ^= v1[0] ^ v1[1] ^ v1[2] ^ v1[3];\n+  accumulator ^= v2[0] ^ v2[1] ^ v2[2] ^ v2[3];\n+  accumulator ^= v3[0] ^ v3[1] ^ v3[2] ^ v3[3];\n+  accumulator ^= v4[0] ^ v4[1] ^ v4[2] ^ v4[3];\n+  return accumulator;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"reassoc1\" { target { powerpc*-*-* i?86-*-* x86_64-*-* } } } } */"}, {"sha": "0146518a98e7cc71a5882a287506bc3b887e99c1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-6.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-6.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-options \"-O2 -mavx512f -ffast-math -fdump-tree-reassoc1\" } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on multiple\n+   vector machine modes.\n+\n+   v1, v2 of type vector 4 x float\n+   v3, v4 of type vector 8 x float\n+   v5, v6 of type vector 16 x float\n+\n+   reassoc transforms\n+\n+     accumulator  +=  v1[0]  + v1[1]  + v1[2]  + v1[3]  +\n+                      v2[0]  + v2[1]  + v2[2]  + v2[3]  +\n+                      v3[0]  + v3[1]  + v3[2]  + v3[3]  +\n+                      v3[4]  + v3[5]  + v3[6]  + v3[7]  +\n+                      v4[0]  + v4[1]  + v4[2]  + v4[3]  +\n+                      v4[4]  + v4[5]  + v4[6]  + v4[7]  +\n+                      v5[0]  + v5[1]  + v5[2]  + v5[3]  +\n+                      v5[4]  + v5[5]  + v5[6]  + v5[7]  +\n+                      v5[8]  + v5[9]  + v5[10] + v5[11] +\n+                      v5[12] + v5[13] + v5[14] + v5[15] +\n+                      v6[0]  + v6[1]  + v6[2]  + v6[3]  +\n+                      v6[4]  + v6[5]  + v6[6]  + v6[7]  +\n+                      v6[8]  + v6[9]  + v6[10] + v6[11] +\n+                      v6[12] + v6[13] + v6[14] + v6[15] ;\n+\n+   into:\n+\n+     T12 = v1 + v2;\n+     T34 = v3 + v4;\n+     T56 = v5 + v6;\n+     accumulator += T12[0]  + T12[1]  + T12[2]  + T12[3]  +\n+     accumulator += T34[0]  + T34[1]  + T34[2]  + T34[3]  +\n+     accumulator += T34[4]  + T34[5]  + T34[6]  + T34[7]  +\n+     accumulator += T56[0]  + T56[1]  + T56[2]  + T56[3]  +\n+     accumulator += T56[4]  + T56[5]  + T56[6]  + T56[7]  +\n+     accumulator += T56[8]  + T56[9]  + T56[10] + T56[11] +\n+     accumulator += T56[12] + T56[13] + T56[14] + T56[15] ;  */\n+\n+typedef float v4sf __attribute__((vector_size(16)));\n+typedef float v8sf __attribute__((vector_size(32)));\n+typedef float v16sf __attribute__((vector_size(64)));\n+\n+float\n+test (float accumulator, v4sf v1, v4sf v2, v8sf v3, v8sf v4, v16sf v5, v16sf v6)\n+{\n+  accumulator += v1[0] + v1[1] + v1[2] + v1[3];\n+  accumulator += v2[0] + v2[1] + v2[2] + v2[3];\n+  accumulator += v3[0] + v3[1] + v3[2] + v3[3];\n+  accumulator += v3[4] + v3[5] + v3[6] + v3[7];\n+  accumulator += v4[0] + v4[1] + v4[2] + v4[3];\n+  accumulator += v4[4] + v4[5] + v4[6] + v4[7];\n+  accumulator += v5[0] + v5[1] + v5[2] + v5[3];\n+  accumulator += v5[4] + v5[5] + v5[6] + v5[7];\n+  accumulator += v5[8] + v5[9] + v5[10] + v5[11];\n+  accumulator += v5[12] + v5[13] + v5[14] + v5[15];\n+  accumulator += v6[0] + v6[1] + v6[2] + v6[3];\n+  accumulator += v6[4] + v6[5] + v6[6] + v6[7];\n+  accumulator += v6[8] + v6[9] + v6[10] + v6[11];\n+  accumulator += v6[12] + v6[13] + v6[14] + v6[15];\n+  return accumulator;\n+}\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 28 \"reassoc1\" } } */"}, {"sha": "0445878d94bf2ae59e27460702e9f6131d1a721f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88497-7.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88497-7.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx512f_runtime } */\n+/* { dg-options \"-O2 -mavx512f -ffast-math -fdump-tree-reassoc1\" } */\n+\n+/* To test reassoc can undistribute vector bit_field_ref on multiple\n+   vector machine modes, bypass those modes with only one candidate.\n+\n+   v1, v2 of type vector 4 x float\n+   v3     of type vector 8 x float\n+   v5, v6 of type vector 16 x float\n+\n+   reassoc transforms\n+\n+     accumulator  +=  v1[0]  + v1[1]  + v1[2]  + v1[3]  +\n+                      v2[0]  + v2[1]  + v2[2]  + v2[3]  +\n+                      v3[0]  + v3[1]  + v3[2]  + v3[3]  +\n+                      v3[4]  + v3[5]  + v3[6]  + v3[7]  +\n+                      v5[0]  + v5[1]  + v5[2]  + v5[3]  +\n+                      v5[4]  + v5[5]  + v5[6]  + v5[7]  +\n+                      v5[8]  + v5[9]  + v5[10] + v5[11] +\n+                      v5[12] + v5[13] + v5[14] + v5[15] +\n+                      v6[0]  + v6[1]  + v6[2]  + v6[3]  +\n+                      v6[4]  + v6[5]  + v6[6]  + v6[7]  +\n+                      v6[8]  + v6[9]  + v6[10] + v6[11] +\n+                      v6[12] + v6[13] + v6[14] + v6[15] ;\n+\n+   into:\n+\n+     T12 = v1 + v2;\n+     T56 = v5 + v6;\n+     accumulator += T12[0]  + T12[1]  + T12[2]  + T12[3]  +\n+     accumulator += v3[0]   + v3[1]   + v3[2]   + v3[3]   +\n+     accumulator += v3[4]   + v3[5]   + v3[6]   + v3[7]   +\n+     accumulator += T56[0]  + T56[1]  + T56[2]  + T56[3]  +\n+     accumulator += T56[4]  + T56[5]  + T56[6]  + T56[7]  +\n+     accumulator += T56[8]  + T56[9]  + T56[10] + T56[11] +\n+     accumulator += T56[12] + T56[13] + T56[14] + T56[15] ;  */\n+\n+typedef float v4sf __attribute__((vector_size(16)));\n+typedef float v8sf __attribute__((vector_size(32)));\n+typedef float v16sf __attribute__((vector_size(64)));\n+\n+__attribute__ ((noinline))\n+float test(float accumulator, v4sf v1, v4sf v2, v8sf v3, v16sf v5, v16sf v6) {\n+  accumulator += v1[0] + v1[1] + v1[2] + v1[3];\n+  accumulator += v2[0] + v2[1] + v2[2] + v2[3];\n+  accumulator += v3[0] + v3[1] + v3[2] + v3[3];\n+  accumulator += v3[4] + v3[5] + v3[6] + v3[7];\n+  accumulator += v5[0] + v5[1] + v5[2] + v5[3];\n+  accumulator += v5[4] + v5[5] + v5[6] + v5[7];\n+  accumulator += v5[8] + v5[9] + v5[10] + v5[11];\n+  accumulator += v5[12] + v5[13] + v5[14] + v5[15];\n+  accumulator += v6[0] + v6[1] + v6[2] + v6[3];\n+  accumulator += v6[4] + v6[5] + v6[6] + v6[7];\n+  accumulator += v6[8] + v6[9] + v6[10] + v6[11];\n+  accumulator += v6[12] + v6[13] + v6[14] + v6[15];\n+  return accumulator;\n+}\n+\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  v4sf v1 = {1.0, 2.0, 3.0, 4.0 };\n+  v4sf v2 = {5.0, 6.0, 7.0, 8.0 };\n+  v8sf v3 = {9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0 };\n+  v16sf v5 = {17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0};\n+  v16sf v6 = {33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0};\n+  float acc = 24.0;\n+  double res = test (acc, v1, v2, v3, v5, v6);\n+  if (res != 1200.0)\n+    abort();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 28 \"reassoc1\" } } */"}, {"sha": "df76e66bccfe4c9255b814b99f3bab2bb4daf9d6", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 279, "deletions": 6, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2833e74e4e64a71bafaf6e20e65506bbce5a5c/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=6c2833e74e4e64a71bafaf6e20e65506bbce5a5c", "patch": "@@ -1772,6 +1772,274 @@ undistribute_ops_list (enum tree_code opcode,\n   return changed;\n }\n \n+/* Pair to hold the information of one specific VECTOR_TYPE SSA_NAME:\n+   first: element index for each relevant BIT_FIELD_REF.\n+   second: the index of vec ops* for each relevant BIT_FIELD_REF.  */\n+typedef std::pair<unsigned, unsigned> v_info_elem;\n+typedef auto_vec<v_info_elem, 32> v_info;\n+typedef v_info *v_info_ptr;\n+\n+/* Comparison function for qsort on VECTOR SSA_NAME trees by machine mode.  */\n+static int\n+sort_by_mach_mode (const void *p_i, const void *p_j)\n+{\n+  const tree tr1 = *((const tree *) p_i);\n+  const tree tr2 = *((const tree *) p_j);\n+  unsigned int mode1 = TYPE_MODE (TREE_TYPE (tr1));\n+  unsigned int mode2 = TYPE_MODE (TREE_TYPE (tr2));\n+  if (mode1 > mode2)\n+    return 1;\n+  else if (mode1 < mode2)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Cleanup hash map for VECTOR information.  */\n+static void\n+cleanup_vinfo_map (hash_map<tree, v_info_ptr> &info_map)\n+{\n+  for (hash_map<tree, v_info_ptr>::iterator it = info_map.begin ();\n+       it != info_map.end (); ++it)\n+    {\n+      v_info_ptr info = (*it).second;\n+      delete info;\n+      (*it).second = NULL;\n+    }\n+}\n+\n+/* Perform un-distribution of BIT_FIELD_REF on VECTOR_TYPE.\n+     V1[0] + V1[1] + ... + V1[k] + V2[0] + V2[1] + ... + V2[k] + ... Vn[k]\n+   is transformed to\n+     Vs = (V1 + V2 + ... + Vn)\n+     Vs[0] + Vs[1] + ... + Vs[k]\n+\n+   The basic steps are listed below:\n+\n+    1) Check the addition chain *OPS by looking those summands coming from\n+       VECTOR bit_field_ref on VECTOR type.  Put the information into\n+       v_info_map for each satisfied summand, using VECTOR SSA_NAME as key.\n+\n+    2) For each key (VECTOR SSA_NAME), validate all its BIT_FIELD_REFs are\n+       continuous, they can cover the whole VECTOR perfectly without any holes.\n+       Obtain one VECTOR list which contain candidates to be transformed.\n+\n+    3) Sort the VECTOR list by machine mode of VECTOR type, for each group of\n+       candidates with same mode, build the addition statements for them and\n+       generate BIT_FIELD_REFs accordingly.\n+\n+   TODO:\n+       The current implementation requires the whole VECTORs should be fully\n+       covered, but it can be extended to support partial, checking adjacent\n+       but not fill the whole, it may need some cost model to define the\n+       boundary to do or not.\n+*/\n+static bool\n+undistribute_bitref_for_vector (enum tree_code opcode,\n+\t\t\t\tvec<operand_entry *> *ops, struct loop *loop)\n+{\n+  if (ops->length () <= 1)\n+    return false;\n+\n+  if (opcode != PLUS_EXPR && opcode != MULT_EXPR && opcode != BIT_XOR_EXPR\n+      && opcode != BIT_IOR_EXPR && opcode != BIT_AND_EXPR)\n+    return false;\n+\n+  hash_map<tree, v_info_ptr> v_info_map;\n+  operand_entry *oe1;\n+  unsigned i;\n+\n+  /* Find those summands from VECTOR BIT_FIELD_REF in addition chain, put the\n+     information into map.  */\n+  FOR_EACH_VEC_ELT (*ops, i, oe1)\n+    {\n+      enum tree_code dcode;\n+      gimple *oe1def;\n+\n+      if (TREE_CODE (oe1->op) != SSA_NAME)\n+\tcontinue;\n+      oe1def = SSA_NAME_DEF_STMT (oe1->op);\n+      if (!is_gimple_assign (oe1def))\n+\tcontinue;\n+      dcode = gimple_assign_rhs_code (oe1def);\n+      if (dcode != BIT_FIELD_REF || !is_reassociable_op (oe1def, dcode, loop))\n+\tcontinue;\n+\n+      tree rhs = gimple_assign_rhs1 (oe1def);\n+      tree vec = TREE_OPERAND (rhs, 0);\n+      tree vec_type = TREE_TYPE (vec);\n+\n+      if (TREE_CODE (vec) != SSA_NAME || !VECTOR_TYPE_P (vec_type))\n+\tcontinue;\n+\n+      /* Ignore it if target machine can't support this VECTOR type.  */\n+      if (!VECTOR_MODE_P (TYPE_MODE (vec_type)))\n+\tcontinue;\n+\n+      /* Check const vector type, constrain BIT_FIELD_REF offset and size.  */\n+      if (!TYPE_VECTOR_SUBPARTS (vec_type).is_constant ())\n+\tcontinue;\n+\n+      tree elem_type = TREE_TYPE (vec_type);\n+      unsigned HOST_WIDE_INT elem_size\n+\t= TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n+      if (maybe_ne (bit_field_size (rhs), elem_size))\n+\tcontinue;\n+\n+      unsigned idx;\n+      if (!constant_multiple_p (bit_field_offset (rhs), elem_size, &idx))\n+\tcontinue;\n+\n+      /* Ignore it if target machine can't support this type of VECTOR\n+         operation.  */\n+      optab op_tab = optab_for_tree_code (opcode, vec_type, optab_vector);\n+      if (optab_handler (op_tab, TYPE_MODE (vec_type)) == CODE_FOR_nothing)\n+\tcontinue;\n+\n+      bool existed;\n+      v_info_ptr &info = v_info_map.get_or_insert (vec, &existed);\n+      if (!existed)\n+\tinfo = new v_info;\n+      info->safe_push (std::make_pair (idx, i));\n+    }\n+\n+  /* At least two VECTOR to combine.  */\n+  if (v_info_map.elements () <= 1)\n+    {\n+      cleanup_vinfo_map (v_info_map);\n+      return false;\n+    }\n+\n+  /* Verify all VECTOR candidates by checking two conditions:\n+       1) sorted offsets are adjacent, no holes.\n+       2) can fill the whole VECTOR perfectly.\n+     And add the valid candidates to a vector for further handling.  */\n+  auto_vec<tree> valid_vecs (v_info_map.elements ());\n+  for (hash_map<tree, v_info_ptr>::iterator it = v_info_map.begin ();\n+       it != v_info_map.end (); ++it)\n+    {\n+      tree cand_vec = (*it).first;\n+      v_info_ptr cand_info = (*it).second;\n+      unsigned int num_elems = VECTOR_CST_NELTS (cand_vec).to_constant ();\n+      if (cand_info->length () != num_elems)\n+\tcontinue;\n+      sbitmap holes = sbitmap_alloc (num_elems);\n+      bitmap_ones (holes);\n+      bool valid = true;\n+      v_info_elem *curr;\n+      FOR_EACH_VEC_ELT (*cand_info, i, curr)\n+\t{\n+\t  if (!bitmap_bit_p (holes, curr->first))\n+\t    {\n+\t      valid = false;\n+\t      break;\n+\t    }\n+\t  else\n+\t    bitmap_clear_bit (holes, curr->first);\n+\t}\n+      if (valid && bitmap_empty_p (holes))\n+\tvalid_vecs.quick_push (cand_vec);\n+      sbitmap_free (holes);\n+    }\n+\n+  /* At least two VECTOR to combine.  */\n+  if (valid_vecs.length () <= 1)\n+    {\n+      cleanup_vinfo_map (v_info_map);\n+      return false;\n+    }\n+\n+  valid_vecs.qsort (sort_by_mach_mode);\n+  /* Go through all candidates by machine mode order, query the mode_to_total\n+     to get the total number for each mode and skip the single one.  */\n+  for (unsigned i = 0; i < valid_vecs.length () - 1; ++i)\n+    {\n+      tree tvec = valid_vecs[i];\n+      enum machine_mode mode = TYPE_MODE (TREE_TYPE (tvec));\n+\n+      /* Skip modes with only a single candidate.  */\n+      if (TYPE_MODE (TREE_TYPE (valid_vecs[i + 1])) != mode)\n+\tcontinue;\n+\n+      unsigned int idx, j;\n+      gimple *sum = NULL;\n+      v_info_ptr info_ptr;\n+      tree sum_vec = tvec;\n+      v_info_elem *elem;\n+\n+      /* Build the sum for all candidates with same mode.  */\n+      do\n+\t{\n+\t  sum = build_and_add_sum (TREE_TYPE (sum_vec), sum_vec,\n+\t\t\t\t   valid_vecs[i + 1], opcode);\n+\t  sum_vec = gimple_get_lhs (sum);\n+\t  info_ptr = *(v_info_map.get (valid_vecs[i + 1]));\n+\t  /* Update those related ops of current candidate VECTOR.  */\n+\t  FOR_EACH_VEC_ELT (*info_ptr, j, elem)\n+\t    {\n+\t      idx = elem->second;\n+\t      gimple *def = SSA_NAME_DEF_STMT ((*ops)[idx]->op);\n+\t      /* Set this then op definition will get DCEd later.  */\n+\t      gimple_set_visited (def, true);\n+\t      if (opcode == PLUS_EXPR || opcode == BIT_XOR_EXPR\n+\t\t  || opcode == BIT_IOR_EXPR)\n+\t\t(*ops)[idx]->op = build_zero_cst (TREE_TYPE ((*ops)[idx]->op));\n+\t      else if (opcode == MULT_EXPR)\n+\t\t(*ops)[idx]->op = build_one_cst (TREE_TYPE ((*ops)[idx]->op));\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (opcode == BIT_AND_EXPR);\n+\t\t  (*ops)[idx]->op\n+\t\t    = build_all_ones_cst (TREE_TYPE ((*ops)[idx]->op));\n+\t\t}\n+\t      (*ops)[idx]->rank = 0;\n+\t    }\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Generating addition -> \");\n+\t      print_gimple_stmt (dump_file, sum, 0);\n+\t    }\n+\t  i++;\n+\t}\n+      while ((i < valid_vecs.length () - 1)\n+\t     && TYPE_MODE (TREE_TYPE (valid_vecs[i + 1])) == mode);\n+\n+      /* Referring to first valid VECTOR with this mode, generate the\n+         BIT_FIELD_REF statements accordingly.  */\n+      info_ptr = *(v_info_map.get (tvec));\n+      gcc_assert (sum);\n+      tree elem_type = TREE_TYPE (TREE_TYPE (tvec));\n+      FOR_EACH_VEC_ELT (*info_ptr, j, elem)\n+\t{\n+\t  idx = elem->second;\n+\t  tree dst = make_ssa_name (elem_type);\n+\t  gimple *gs = gimple_build_assign (\n+\t    dst, BIT_FIELD_REF,\n+\t    build3 (BIT_FIELD_REF, elem_type, sum_vec, TYPE_SIZE (elem_type),\n+\t\t    bitsize_int (elem->first\n+\t\t\t\t * tree_to_uhwi (TYPE_SIZE (elem_type)))));\n+\t  insert_stmt_after (gs, sum);\n+\t  gimple *def = SSA_NAME_DEF_STMT ((*ops)[idx]->op);\n+\t  /* Set this then op definition will get DCEd later.  */\n+\t  gimple_set_visited (def, true);\n+\t  (*ops)[idx]->op = gimple_assign_lhs (gs);\n+\t  (*ops)[idx]->rank = get_rank ((*ops)[idx]->op);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Generating bit_field_ref -> \");\n+\t      print_gimple_stmt (dump_file, gs, 0);\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"undistributiong bit_field_ref for vector done.\\n\");\n+\n+  cleanup_vinfo_map (v_info_map);\n+\n+  return true;\n+}\n+\n /* If OPCODE is BIT_IOR_EXPR or BIT_AND_EXPR and CURR is a comparison\n    expression, examine the other OPS to see if any of them are comparisons\n    of the same values, which we may be able to combine or eliminate.\n@@ -5879,11 +6147,6 @@ reassociate_bb (basic_block bb)\n \t  tree lhs, rhs1, rhs2;\n \t  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n \n-\t  /* If this is not a gimple binary expression, there is\n-\t     nothing for us to do with it.  */\n-\t  if (get_gimple_rhs_class (rhs_code) != GIMPLE_BINARY_RHS)\n-\t    continue;\n-\n \t  /* If this was part of an already processed statement,\n \t     we don't need to touch it again. */\n \t  if (gimple_visited_p (stmt))\n@@ -5910,6 +6173,11 @@ reassociate_bb (basic_block bb)\n \t      continue;\n \t    }\n \n+\t  /* If this is not a gimple binary expression, there is\n+\t     nothing for us to do with it.  */\n+\t  if (get_gimple_rhs_class (rhs_code) != GIMPLE_BINARY_RHS)\n+\t    continue;\n+\n \t  lhs = gimple_assign_lhs (stmt);\n \t  rhs1 = gimple_assign_rhs1 (stmt);\n \t  rhs2 = gimple_assign_rhs2 (stmt);\n@@ -5948,7 +6216,12 @@ reassociate_bb (basic_block bb)\n \t\t  ops.qsort (sort_by_operand_rank);\n \t\t  optimize_ops_list (rhs_code, &ops);\n \t\t}\n-\n+\t      if (undistribute_bitref_for_vector (rhs_code, &ops,\n+\t\t\t\t\t\t  loop_containing_stmt (stmt)))\n+\t\t{\n+\t\t  ops.qsort (sort_by_operand_rank);\n+\t\t  optimize_ops_list (rhs_code, &ops);\n+\t\t}\n \t      if (rhs_code == PLUS_EXPR\n \t\t  && transform_add_to_multiply (&ops))\n \t\tops.qsort (sort_by_operand_rank);"}]}