{"sha": "e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1ZTliZTNhODlmZjZjYTFlZmJhNjEyZjk3MzJkNTY4ZTFlZjNmYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-04-03T04:20:57Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-04-03T04:20:57Z"}, "message": "re PR testsuite/26981 (g++.old-deja/g++.other/init18.C fails)\n\n2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26981\n\t* trans.h : Prototype for gfc_conv_missing_dummy.\n\t* trans-expr (gfc_conv_missing_dummy): New function\n\t(gfc_conv_function_call): Call it and tidy up some of the code.\n\t* trans-intrinsic (gfc_conv_intrinsic_function_args): The same.\n\n\tPR fortran/26976\n\t* array.c (gfc_array_dimen_size): If available, return shape[dimen].\n\t* resolve.c (resolve_function): If available, use the argument shape for the\n\tfunction expression.\n\t* iresolve.c (gfc_resolve_transfer): Set shape[0] = size.\n\n2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/26981\n\t* gfortran.dg/missing_optional_dummy_1.f90: New test.\n\n\tPR fortran/26976\n\t* gfortran.dg/compliant_elemental_intrinsics_1.f90: New test.\n\t* gfortran.dg/initialization_1.f90: Make assignment compliant.\n\t* gfortran.dg/transfer_array_intrinsic_1.f90: Simplify.\n\t* gfortran.dg/transfer_array_intrinsic_2.f90: Make assignments compliant and detect\n\tbigendian-ness.\n\nFrom-SVN: r112634", "tree": {"sha": "2c807f9c4b8161c106bc907ae90fd1bf5e28296d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c807f9c4b8161c106bc907ae90fd1bf5e28296d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/comments", "author": null, "committer": null, "parents": [{"sha": "b6f65e3c5dd79817b4255d4780fa2ca4e1274f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f65e3c5dd79817b4255d4780fa2ca4e1274f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f65e3c5dd79817b4255d4780fa2ca4e1274f95"}], "stats": {"total": 459, "additions": 316, "deletions": 143}, "files": [{"sha": "fe9ad51929ccd3b90de374642abad7e6953ec1dc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1,3 +1,17 @@\n+2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26981\n+\t* trans.h : Prototype for gfc_conv_missing_dummy.\n+\t* trans-expr (gfc_conv_missing_dummy): New function\n+\t(gfc_conv_function_call): Call it and tidy up some of the code.\n+\t* trans-intrinsic (gfc_conv_intrinsic_function_args): The same.\n+\n+\tPR fortran/26976\n+\t* array.c (gfc_array_dimen_size): If available, return shape[dimen].\n+\t* resolve.c (resolve_function): If available, use the argument shape for the\n+\tfunction expression.\n+\t* iresolve.c (gfc_resolve_transfer): Set shape[0] = size.\n+\n 2006-04-02  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \t* trans-array.c (gfc_trans_dealloc_allocated): Take a"}, {"sha": "2cb349945624b7decacf7786398776c08b367702", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1872,6 +1872,12 @@ gfc_array_dimen_size (gfc_expr * array, int dimen, mpz_t * result)\n \t    }\n \t}\n \n+      if (array->shape && array->shape[dimen])\n+\t{\n+\t  mpz_init_set (*result, array->shape[dimen]);\n+\t  return SUCCESS;\n+\t}\n+\n       if (spec_dimen_size (array->symtree->n.sym->as, dimen, result) == FAILURE)\n \treturn FAILURE;\n "}, {"sha": "d07864ee36ee6f81edc4726a03153c2b1565a295", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1955,6 +1955,11 @@ gfc_resolve_transfer (gfc_expr * f, gfc_expr * source ATTRIBUTE_UNUSED,\n     {\n       f->rank = 1;\n       f->value.function.name = transfer1;\n+      if (size && gfc_is_constant_expr (size))\n+\t{\n+\t  f->shape = gfc_get_shape (1);\n+\t  mpz_init_set (f->shape[0], size->value.integer);\n+\t}\n     }\n }\n "}, {"sha": "4831d799d709a214b1290cfc0660f7fb1f539e27", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1205,6 +1205,7 @@ resolve_function (gfc_expr * expr)\n   const char *name;\n   try t;\n   int temp;\n+  int i;\n \n   sym = NULL;\n   if (expr->symtree)\n@@ -1304,6 +1305,12 @@ resolve_function (gfc_expr * expr)\n \t  if (arg->expr != NULL && arg->expr->rank > 0)\n \t    {\n \t      expr->rank = arg->expr->rank;\n+\t      if (!expr->shape && arg->expr->shape)\n+\t\t{\n+\t\t  expr->shape = gfc_get_shape (expr->rank);\n+\t\t  for (i = 0; i < expr->rank; i++)\n+\t\t    mpz_init_set (expr->shape[i], arg->expr->shape[i]);\n+\t        }\n \t      break;\n \t    }\n \t}"}, {"sha": "1e1802ed205ab1441c898c674b240d5bdd18ca20", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -142,6 +142,31 @@ gfc_conv_expr_present (gfc_symbol * sym)\n }\n \n \n+/* Converts a missing, dummy argument into a null or zero.  */\n+\n+void\n+gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts)\n+{\n+  tree present;\n+  tree tmp;\n+\n+  present = gfc_conv_expr_present (arg->symtree->n.sym);\n+  tmp = build3 (COND_EXPR, TREE_TYPE (se->expr), present, se->expr,\n+\t\tconvert (TREE_TYPE (se->expr), integer_zero_node));\n+  tmp = gfc_evaluate_now (tmp, &se->pre);\n+  se->expr = tmp;\n+  if (ts.type == BT_CHARACTER)\n+    {\n+      tmp = convert (gfc_charlen_type_node, integer_zero_node);\n+      tmp = build3 (COND_EXPR, gfc_charlen_type_node, present,\n+\t\t    se->string_length, tmp);\n+      tmp = gfc_evaluate_now (tmp, &se->pre);\n+      se->string_length = tmp;\n+    }\n+  return;\n+}\n+\n+\n /* Get the character length of an expression, looking through gfc_refs\n    if necessary.  */\n \n@@ -1805,6 +1830,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   bool callee_alloc;\n   gfc_typespec ts;\n   gfc_charlen cl;\n+  gfc_expr *e;\n+  gfc_symbol *fsym;\n \n   arglist = NULL_TREE;\n   retargs = NULL_TREE;\n@@ -1844,7 +1871,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   /* Evaluate the arguments.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n     {\n-      if (arg->expr == NULL)\n+      e = arg->expr;\n+      fsym = formal ? formal->sym : NULL;\n+      if (e == NULL)\n \t{\n \n \t  if (se->ignore_optional)\n@@ -1872,19 +1901,19 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  /* An elemental function inside a scalarized loop.  */\n           gfc_init_se (&parmse, se);\n-          gfc_conv_expr_reference (&parmse, arg->expr);\n+          gfc_conv_expr_reference (&parmse, e);\n \t}\n       else\n \t{\n \t  /* A scalar or transformational function.  */\n \t  gfc_init_se (&parmse, NULL);\n-\t  argss = gfc_walk_expr (arg->expr);\n+\t  argss = gfc_walk_expr (e);\n \n \t  if (argss == gfc_ss_terminator)\n             {\n-\t      gfc_conv_expr_reference (&parmse, arg->expr);\n-              if (formal && formal->sym->attr.pointer\n-\t\t  && arg->expr->expr_type != EXPR_NULL)\n+\t      gfc_conv_expr_reference (&parmse, e);\n+              if (fsym && fsym->attr.pointer\n+\t\t  && e->expr_type != EXPR_NULL)\n                 {\n                   /* Scalar pointer dummy args require an extra level of\n \t\t  indirection. The null pointer already contains\n@@ -1901,27 +1930,27 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n                  convention, and pass the address of the array descriptor\n                  instead. Otherwise we use g77's calling convention.  */\n \t      int f;\n-\t      f = (formal != NULL)\n-\t\t  && !(formal->sym->attr.pointer || formal->sym->attr.allocatable)\n-\t\t  && formal->sym->as->type != AS_ASSUMED_SHAPE;\n+\t      f = (fsym != NULL)\n+\t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n+\t\t  && fsym->as->type != AS_ASSUMED_SHAPE;\n \t      f = f || !sym->attr.always_explicit;\n-\t      if (arg->expr->expr_type == EXPR_VARIABLE\n-\t\t    && is_aliased_array (arg->expr))\n+\t      if (e->expr_type == EXPR_VARIABLE\n+\t\t    && is_aliased_array (e))\n \t\t/* The actual argument is a component reference to an\n \t\t   array of derived types.  In this case, the argument\n \t\t   is converted to a temporary, which is passed and then\n \t\t   written back after the procedure call.  */\n-\t\tgfc_conv_aliased_arg (&parmse, arg->expr, f);\n+\t\tgfc_conv_aliased_arg (&parmse, e, f);\n \t      else\n-\t        gfc_conv_array_parameter (&parmse, arg->expr, argss, f);\n+\t        gfc_conv_array_parameter (&parmse, e, argss, f);\n \n               /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n                  allocated on entry, it must be deallocated.  */\n-              if (formal && formal->sym->attr.allocatable\n-                  && formal->sym->attr.intent == INTENT_OUT)\n+              if (fsym && fsym->attr.allocatable\n+                  && fsym->attr.intent == INTENT_OUT)\n                 {\n-\t\t  tmp = arg->expr->symtree->n.sym->backend_decl;\n-\t\t  if (arg->expr->symtree->n.sym->attr.dummy)\n+\t\t  tmp = e->symtree->n.sym->backend_decl;\n+\t\t  if (e->symtree->n.sym->attr.dummy)\n                     tmp = build_fold_indirect_ref (tmp);\n                   tmp = gfc_trans_dealloc_allocated (tmp);\n                   gfc_add_expr_to_block (&se->pre, tmp);\n@@ -1930,8 +1959,15 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    } \n \t}\n \n-      if (formal && need_interface_mapping)\n-\tgfc_add_interface_mapping (&mapping, formal->sym, &parmse);\n+      /* If an optional argument is itself an optional dummy argument,\n+\t check its presence and substitute a null if absent.  */\n+      if (e && e->expr_type == EXPR_VARIABLE\n+\t    && e->symtree->n.sym->attr.optional\n+\t    && fsym && fsym->attr.optional)\n+\tgfc_conv_missing_dummy (&parmse, e, fsym->ts);\n+\n+      if (fsym && need_interface_mapping)\n+\tgfc_add_interface_mapping (&mapping, fsym, &parmse);\n \n       gfc_add_block_to_block (&se->pre, &parmse.pre);\n       gfc_add_block_to_block (&se->post, &parmse.post);"}, {"sha": "b69ffefc8a0ec6be405def715b6c390d51ff161f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -165,28 +165,42 @@ static tree\n gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n {\n   gfc_actual_arglist *actual;\n-  tree args;\n+  gfc_expr *e;\n+  gfc_intrinsic_arg  *formal;\n   gfc_se argse;\n+  tree args;\n \n   args = NULL_TREE;\n-  for (actual = expr->value.function.actual; actual; actual = actual->next)\n+  formal = expr->value.function.isym->formal;\n+\n+  for (actual = expr->value.function.actual; actual; actual = actual->next,\n+       formal = formal ? formal->next : NULL)\n     {\n+      e = actual->expr;\n       /* Skip omitted optional arguments.  */\n-      if (!actual->expr)\n+      if (!e)\n \tcontinue;\n \n       /* Evaluate the parameter.  This will substitute scalarized\n          references automatically.  */\n       gfc_init_se (&argse, se);\n \n-      if (actual->expr->ts.type == BT_CHARACTER)\n+      if (e->ts.type == BT_CHARACTER)\n \t{\n-\t  gfc_conv_expr (&argse, actual->expr);\n+\t  gfc_conv_expr (&argse, e);\n \t  gfc_conv_string_parameter (&argse);\n \t  args = gfc_chainon_list (args, argse.string_length);\n \t}\n       else\n-        gfc_conv_expr_val (&argse, actual->expr);\n+        gfc_conv_expr_val (&argse, e);\n+\n+      /* If an optional argument is itself an optional dummy argument,\n+\t check its presence and substitute a null if absent.  */\n+      if (e->expr_type ==EXPR_VARIABLE\n+\t    && e->symtree->n.sym->attr.optional\n+\t    && formal\n+\t    && formal->optional)\n+\tgfc_conv_missing_dummy (&argse, e, formal->ts);\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);"}, {"sha": "0b1514e94d6492632073d7c9abc9646b289e8ebd", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -317,6 +317,8 @@ void gfc_conv_structure (gfc_se *, gfc_expr *, int);\n \n /* Return an expression which determines if a dummy parameter is present.  */\n tree gfc_conv_expr_present (gfc_symbol *);\n+/* Convert a missing, dummy argument into a null or zero.  */\n+void gfc_conv_missing_dummy (gfc_se *, gfc_expr *, gfc_typespec);\n \n /* Generate code to allocate a string temporary.  */\n tree gfc_conv_string_tmp (gfc_se *, tree, tree);"}, {"sha": "6ae43d57e00c35f9af3061768b8747e023ac9033", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1,3 +1,15 @@\n+2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/26981\n+\t* gfortran.dg/missing_optional_dummy_1.f90: New test.\n+\n+\tPR fortran/26976\n+\t* gfortran.dg/compliant_elemental_intrinsics_1.f90: New test.\n+\t* gfortran.dg/initialization_1.f90: Make assignment compliant.\n+\t* gfortran.dg/transfer_array_intrinsic_1.f90: Simplify.\n+\t* gfortran.dg/transfer_array_intrinsic_2.f90: Make assignments compliant and detect\n+\tbigendian-ness.\n+\n 2006-04-02  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \t* gfortran.dg/allocatable_dummy_1.f90: Also check that allocatable"}, {"sha": "7829d977eb2bc23db372f7acd0403517774903a5", "filename": "gcc/testsuite/gfortran.dg/compliant_elemental_intrinsics_1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompliant_elemental_intrinsics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompliant_elemental_intrinsics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcompliant_elemental_intrinsics_1.f90?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+! Tests the fix for PR26976, in which non-compliant elemental\n+! intrinsic function results were not detected.  At the same\n+! time, the means to tests the compliance of TRANSFER with the\n+! optional SIZE parameter was added.\n+!\n+! Contributed by Dominique Dhumieres  <dominiq@lps.ens.fr>\n+!\n+real(4) :: pi, a(2), b(3)\n+character(26) :: ch\n+\n+pi = acos(-1.0)\n+b = pi\n+\n+a = cos(b) ! { dg-error \"different shape for Array assignment\" }\n+\n+a = -pi\n+b = cos(a) ! { dg-error \"different shape for Array assignment\" }\n+\n+ch = \"abcdefghijklmnopqrstuvwxyz\"\n+a = transfer (ch, pi, 3) ! { dg-error \"different shape for Array assignment\" }\n+\n+! This already generated an error\n+b = reshape ((/1.0/),(/1/)) ! { dg-error \"different shape for Array assignment\" }\n+\n+end"}, {"sha": "af7ccb0f78268fe1b5d34262dd2f72d2994550aa", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -21,6 +21,7 @@ subroutine foo(ch1, x, y)\n     real(8) :: x (1:2, *)\n     real(8) :: y (0:,:)\n     integer :: i\n+    real :: z(2, 2)\n \n ! However, this gives a warning because it is an initialization expression.\n     integer :: l1 = len (ch1)     ! { dg-warning \"assumed character length variable\" }"}, {"sha": "29f08f9e0e820ce89fd7fc01dca4ff7e6c727bfb", "filename": "gcc/testsuite/gfortran.dg/missing_optional_dummy_1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmissing_optional_dummy_1.f90?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! Test the fix for PR26891, in which an optional argument, whose actual\n+! is a missing dummy argument would cause a segfault.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  logical :: back =.false.\n+\n+! This was the case that would fail - PR case was an intrinsic call.\n+  if (scan (\"A quick brown fox jumps over the lazy dog\", \"lazy\", back) &\n+      .ne. myscan (\"A quick brown fox jumps over the lazy dog\", \"lazy\")) &\n+    call abort ()\n+\n+! Check that the patch works with non-intrinsic functions.\n+  if (myscan (\"A quick brown fox jumps over the lazy dog\", \"fox\", back) &\n+      .ne. thyscan (\"A quick brown fox jumps over the lazy dog\", \"fox\")) &\n+    call abort ()\n+\n+! Check that missing, optional character actual arguments are OK.\n+  if (scan (\"A quick brown fox jumps over the lazy dog\", \"over\", back) &\n+      .ne. thyscan (\"A quick brown fox jumps over the lazy dog\")) &\n+    call abort ()\n+\n+contains\n+  integer function myscan (str, substr, back)\n+    character(*), intent(in) :: str, substr\n+    logical, optional, intent(in) :: back\n+    myscan = scan (str, substr, back)\n+  end function myscan\n+\n+  integer function thyscan (str, substr, back)\n+    character(*), intent(in) :: str\n+    character(*), optional, intent(in) :: substr\n+    logical, optional, intent(in) :: back\n+    thyscan = isscan (str, substr, back)\n+  end function thyscan\n+\n+  integer function isscan (str, substr, back)\n+    character(*), intent(in) :: str\n+    character(*), optional :: substr\n+    logical, optional, intent(in) :: back\n+    if (.not.present(substr)) then\n+      isscan = myscan (str, \"over\", back)\n+    else\n+      isscan = myscan (str, substr, back)\n+    end if\n+  end function isscan\n+\n+end"}, {"sha": "0d828efa66b9db7a7a66a0fa11a19a29efaff2b1", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_1.f90", "status": "modified", "additions": 2, "deletions": 97, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1,22 +1,11 @@\n-! { dg-do run { target i?86-*-* x86_64-*-* } }\n+! { dg-do run }\n ! Tests the patch to implement the array version of the TRANSFER\n ! intrinsic (PR17298).\n-! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n \n-   character(8) :: ch(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n-\n-! tests numeric transfers(including PR testcase).\n+! test the PR is fixed.\n \n    call test1 ()\n \n-! tests numeric/character transfers.\n-\n-   call test2 ()\n-\n-! Test dummies, automatic objects and assumed character length.\n-\n-   call test3 (ch, ch, ch, 8)\n-\n contains\n \n    subroutine test1 ()\n@@ -29,90 +18,6 @@ subroutine test1 ()\n      cmp = transfer (z, cmp) * 2.0\n      if (any (cmp .ne. (/2.0, 4.0/))) call abort ()\n \n-! Check that size smaller than the source word length is OK.\n-\n-     z = (-1.0, -2.0)\n-     cmp = transfer (z, cmp, 1) * 8.0\n-     if (any (cmp .ne. (/-8.0, 4.0/))) call abort ()\n-\n-! Check multi-dimensional sources and that transfer works as an actual\n-! argument of reshape.\n-\n-     a = reshape ((/(rand (), i = 1, 16)/), (/4,4/))\n-     jt = transfer (a, it)\n-     it = reshape (jt, (/4, 2, 4/))\n-     if (any (reshape (transfer (it, a), (/4,4/)) .ne. a)) call abort ()\n-\n    end subroutine test1\n \n-   subroutine test2 ()\n-     integer(4) :: y(4), z(2)\n-     character(4) :: ch(4)\n-     y = (/(i + ishft (i + 1, 8) + ishft (i + 2, 16) &\n-              + ishft (i + 3, 24), i = 65, 80 , 4)/)\n-\n-! Check source array sections in both directions.\n-\n-     ch = \"wxyz\"\n-     ch = transfer (y(2:4:2), ch)\n-     if (any (ch .ne. (/\"EFGH\",\"MNOP\",\"wxyz\",\"wxyz\"/))) call abort ()\n-     ch = \"wxyz\"\n-     ch = transfer (y(4:2:-2), ch)\n-     if (any (ch .ne. (/\"MNOP\",\"EFGH\",\"wxyz\",\"wxyz\"/))) call abort ()\n-\n-! Check that a complete array transfers with size absent.\n-\n-     ch = transfer (y, ch)\n-     if (any (ch .ne. (/\"ABCD\",\"EFGH\",\"IJKL\",\"MNOP\"/))) call abort ()\n-\n-! Check that a character array section is OK\n-\n-     z = transfer (ch(2:3), y)\n-     if (any (z .ne. y(2:3))) call abort ()\n-\n-! Check dest array sections in both directions.\n-\n-     ch = \"wxyz\"\n-     ch(3:4) = transfer (y, ch, 2)\n-     if (any (ch .ne. (/\"wxyz\",\"wxyz\",\"ABCD\",\"EFGH\"/))) call abort ()\n-     ch = \"wxyz\"\n-     ch(3:2:-1) = transfer (y, ch, 3)\n-     if (any (ch .ne. (/\"wxyz\",\"EFGH\",\"ABCD\",\"wxyz\"/))) call abort ()\n-\n-! Check that too large a value of size is cut off.\n-\n-     ch = \"wxyz\"\n-     ch(1:2) = transfer (y, ch, 3)\n-     if (any (ch .ne. (/\"ABCD\",\"EFGH\",\"wxyz\",\"wxyz\"/))) call abort ()\n-\n-! Make sure that character to numeric is OK.\n-\n-     z = transfer (ch, y)\n-     if (any (y(1:2) .ne. z)) call abort ()\n-\n-   end subroutine test2\n-\n-   subroutine test3 (ch1, ch2, ch3, clen)\n-     integer clen\n-     character(8) :: ch1(:)\n-     character(*) :: ch2(2)\n-     character(clen) :: ch3(2)\n-     character(8) :: cntrl(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n-     integer(8) :: ic(2)\n-     ic = transfer (cntrl, ic)\n-\n-! Check assumed shape.\n-\n-     if (any (ic .ne. transfer (ch1, ic))) call abort ()\n-\n-! Check assumed character length.\n-\n-     if (any (ic .ne. transfer (ch2, ic))) call abort ()\n-\n-! Check automatic character length.\n-\n-     if (any (ic .ne. transfer (ch3, ic))) call abort ()\n-\n-  end subroutine test3\n-\n end"}, {"sha": "aaa10f8a4f5227a913edd782014a039dd7ad7145", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_2.f90", "status": "modified", "additions": 117, "deletions": 21, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15e9be3a89ff6ca1efba612f9732d568e1ef3fc/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90?ref=e15e9be3a89ff6ca1efba612f9732d568e1ef3fc", "patch": "@@ -1,23 +1,119 @@\n-! { dg-do run { target i?86-*-* x86_64-*-* } }\n-! { dg-options \"-fpack-derived\" }\n-   call test3()\n+! { dg-do run }\n+! Tests the patch to implement the array version of the TRANSFER\n+! intrinsic (PR17298).\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+\n+! Bigendian test posted by Perseus in comp.lang.fortran on 4 July 2005.\n+! Original had parameter but this fails, at present, if is_gimple_var with -Ox, x>0\n+\n+   LOGICAL :: bigend\n+   integer :: icheck = 1\n+\n+   character(8) :: ch(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n+\n+   bigend = IACHAR(TRANSFER(icheck,\"a\")) == 0\n+\n+! tests numeric transfers other than original testscase.\n+\n+   call test1 ()\n+\n+! tests numeric/character transfers.\n+\n+   call test2 ()\n+\n+! Test dummies, automatic objects and assumed character length.\n+\n+   call test3 (ch, ch, ch, 8)\n+\n contains\n-   subroutine test3 ()\n-     type mytype\n-       sequence\n-       real(8) :: x = 3.14159\n-       character(4) :: ch = \"wxyz\"\n-       integer(2) :: i = 77\n-     end type mytype\n-     type(mytype) :: z(2)\n-     character(1) :: c(32)\n-     character(4) :: chr\n-     real(8) :: a\n-     integer(2) :: l\n-     equivalence (a, c(15)), (chr, c(23)), (l, c(27))\n-     c = transfer(z, c)\n-     if (a .ne. z(1)%x) call abort ()\n-     if (chr .ne. z(1)%ch) call abort ()\n-     if (l .ne. z(1)%i) call abort ()\n-   end subroutine test3\n+\n+   subroutine test1 ()\n+     real(4) :: a(4, 4)\n+     integer(2) :: it(4, 2, 4), jt(32)\n+\n+! Check multi-dimensional sources and that transfer works as an actual\n+! argument of reshape.\n+\n+     a = reshape ((/(rand (), i = 1, 16)/), (/4,4/))\n+     jt = transfer (a, it)\n+     it = reshape (jt, (/4, 2, 4/))\n+     if (any (reshape (transfer (it, a), (/4,4/)) .ne. a)) call abort ()\n+\n+   end subroutine test1\n+\n+   subroutine test2 ()\n+     integer(4) :: y(4), z(2)\n+     character(4) :: ch(4)\n+\n+! Allow for endian-ness\n+     if (bigend) then\n+       y = (/(i + 3 + ishft (i + 2, 8) + ishft (i + 1, 16) &\n+                + ishft (i, 24), i = 65, 80 , 4)/)\n+     else \n+       y = (/(i + ishft (i + 1, 8) + ishft (i + 2, 16) &\n+                + ishft (i + 3, 24), i = 65, 80 , 4)/)\n+     end if\n+\n+! Check source array sections in both directions.\n+\n+     ch = \"wxyz\"\n+     ch(1:2) = transfer (y(2:4:2), ch)\n+     if (any (ch(1:2) .ne. (/\"EFGH\",\"MNOP\"/))) call abort ()\n+     ch = \"wxyz\"\n+     ch(1:2) = transfer (y(4:2:-2), ch)\n+     if (any (ch(1:2) .ne. (/\"MNOP\",\"EFGH\"/))) call abort ()\n+\n+! Check that a complete array transfers with size absent.\n+\n+     ch = transfer (y, ch)\n+     if (any (ch .ne. (/\"ABCD\",\"EFGH\",\"IJKL\",\"MNOP\"/))) call abort ()\n+\n+! Check that a character array section is OK\n+\n+     z = transfer (ch(2:3), y)\n+     if (any (z .ne. y(2:3))) call abort ()\n+\n+! Check dest array sections in both directions.\n+\n+     ch = \"wxyz\"\n+     ch(3:4) = transfer (y, ch, 2)\n+     if (any (ch(3:4) .ne. (/\"ABCD\",\"EFGH\"/))) call abort ()\n+     ch = \"wxyz\"\n+     ch(3:2:-1) = transfer (y, ch, 2)\n+     if (any (ch(2:3) .ne. (/\"EFGH\",\"ABCD\"/))) call abort ()\n+\n+! Make sure that character to numeric is OK.\n+\n+     ch = \"wxyz\"\n+     ch(1:2) = transfer (y, ch, 2)\n+     if (any (ch(1:2) .ne. (/\"ABCD\",\"EFGH\"/))) call abort ()\n+\n+     z = transfer (ch, y)\n+     if (any (y(1:2) .ne. z)) call abort ()\n+\n+   end subroutine test2\n+\n+   subroutine test3 (ch1, ch2, ch3, clen)\n+     integer clen\n+     character(8) :: ch1(:)\n+     character(*) :: ch2(2)\n+     character(clen) :: ch3(2)\n+     character(8) :: cntrl(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n+     integer(8) :: ic(2)\n+     ic = transfer (cntrl, ic)\n+\n+! Check assumed shape.\n+\n+     if (any (ic .ne. transfer (ch1, ic))) call abort ()\n+\n+! Check assumed character length.\n+\n+     if (any (ic .ne. transfer (ch2, ic))) call abort ()\n+\n+! Check automatic character length.\n+\n+     if (any (ic .ne. transfer (ch3, ic))) call abort ()\n+\n+  end subroutine test3\n+\n end"}]}