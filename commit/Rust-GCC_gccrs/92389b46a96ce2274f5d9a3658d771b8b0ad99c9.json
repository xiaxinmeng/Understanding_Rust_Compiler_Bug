{"sha": "92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "node_id": "C_kwDOANBUbNoAKDkyMzg5YjQ2YTk2Y2UyMjc0ZjVkOWEzNjU4ZDc3MWI4YjBhZDk5Yzk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T14:43:54Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-21T11:36:52Z"}, "message": "gccrs: Add initial support for argument capture of closures\n\nWhen we have a closure expression that captures a parent function's\nvariable we must setup the closure data to contain this. Ignoring\nmoveability and mutability requires for now, this patch creates the closure\nstructure with fields for each of the captured variables. When it comes to\ncompilation of the closure expression in order to support nested closures\nwe must setup a context of implicit mappings so that for all path\nresolution we hit this implicit closure mappings lookups code before any\nlookup_var_decl as this decl will not exist so the order here is important\nduring path resolution which is a similar problem to match expression\ndestructuring.\n\nFixes #195\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-context.cc (Context::push_closure_context): New function.\n\t(Context::pop_closure_context): Likewise.\n\t(Context::insert_closure_binding): Likewise.\n\t(Context::lookup_closure_binding): Likewise.\n\t* backend/rust-compile-context.h: Declare new functions and closure mappings.\n\t* backend/rust-compile-expr.cc (CompileExpr::visit): Visit captures properly.\n\t(CompileExpr::generate_closure_function): Compile captures properly.\n\t* backend/rust-compile-resolve-path.cc (ResolvePathRef::resolve): Check for\n\tclosure bindings.\n\t* backend/rust-compile-type.cc (TyTyResolveCompile::visit): Compile capture list's\n\ttypes as well.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/execute/torture/closure3.rs: New test.", "tree": {"sha": "10ad93f9c578725e9249f1303f096da0b0c5c016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10ad93f9c578725e9249f1303f096da0b0c5c016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb1202224f8e9be687589d66011485b5fc582eb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1202224f8e9be687589d66011485b5fc582eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1202224f8e9be687589d66011485b5fc582eb5"}], "stats": {"total": 178, "additions": 172, "deletions": 6}, "files": [{"sha": "018897e39b2dd098b8afd18b89a6aab576b00e22", "filename": "gcc/rust/backend/rust-compile-context.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.cc?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -142,5 +142,52 @@ Context::type_hasher (tree type)\n   return hstate.end ();\n }\n \n+void\n+Context::push_closure_context (HirId id)\n+{\n+  auto it = closure_bindings.find (id);\n+  rust_assert (it == closure_bindings.end ());\n+\n+  closure_bindings.insert ({id, {}});\n+  closure_scope_bindings.push_back (id);\n+}\n+\n+void\n+Context::pop_closure_context ()\n+{\n+  rust_assert (!closure_scope_bindings.empty ());\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  closure_scope_bindings.pop_back ();\n+  closure_bindings.erase (ref);\n+}\n+\n+void\n+Context::insert_closure_binding (HirId id, tree expr)\n+{\n+  rust_assert (!closure_scope_bindings.empty ());\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  closure_bindings[ref].insert ({id, expr});\n+}\n+\n+bool\n+Context::lookup_closure_binding (HirId id, tree *expr)\n+{\n+  if (closure_scope_bindings.empty ())\n+    return false;\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  auto it = closure_bindings.find (ref);\n+  rust_assert (it != closure_bindings.end ());\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  *expr = iy->second;\n+  return true;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "8e8fac80d5938740f39759fe863113579a6dbc5c", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -345,6 +345,11 @@ class Context\n     return mangler.mangle_item (ty, path);\n   }\n \n+  void push_closure_context (HirId id);\n+  void pop_closure_context ();\n+  void insert_closure_binding (HirId id, tree expr);\n+  bool lookup_closure_binding (HirId id, tree *expr);\n+\n   std::vector<tree> &get_type_decls () { return type_decls; }\n   std::vector<::Bvariable *> &get_var_decls () { return var_decls; }\n   std::vector<tree> &get_const_decls () { return const_decls; }\n@@ -377,6 +382,10 @@ class Context\n   std::map<HirId, tree> implicit_pattern_bindings;\n   std::map<hashval_t, tree> main_variants;\n \n+  // closure bindings\n+  std::vector<HirId> closure_scope_bindings;\n+  std::map<HirId, std::map<HirId, tree>> closure_bindings;\n+\n   // To GCC middle-end\n   std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;"}, {"sha": "436fc924a1376c5a096b27b07c553de94c906304", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -2829,10 +2829,25 @@ CompileExpr::visit (HIR::ClosureExpr &expr)\n \n   // lets ignore state capture for now we need to instantiate the struct anyway\n   // then generate the function\n-\n   std::vector<tree> vals;\n-  // TODO\n-  // setup argument captures based on the mode?\n+  for (const auto &capture : closure_tyty->get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = ctx->get_mappings ()->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // lookup the var decl\n+      Bvariable *var = nullptr;\n+      bool found = ctx->lookup_var_decl (ref, &var);\n+      rust_assert (found);\n+\n+      // FIXME\n+      // this should bes based on the closure move-ability\n+      tree var_expr = var->get_tree (expr.get_locus ());\n+      tree val = address_expression (var_expr, expr.get_locus ());\n+      vals.push_back (val);\n+    }\n \n   translated\n     = ctx->get_backend ()->constructor_expression (compiled_closure_tyty, false,\n@@ -2879,8 +2894,29 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n   DECL_ARTIFICIAL (self_param->get_decl ()) = 1;\n   param_vars.push_back (self_param);\n \n+  // push a new context\n+  ctx->push_closure_context (expr.get_mappings ().get_hirid ());\n+\n   // setup the implicit argument captures\n-  // TODO\n+  size_t idx = 0;\n+  for (const auto &capture : closure_tyty.get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = ctx->get_mappings ()->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // get the assessor\n+      tree binding = ctx->get_backend ()->struct_field_expression (\n+\tself_param->get_tree (expr.get_locus ()), idx, expr.get_locus ());\n+      tree indirection = indirect_expression (binding, expr.get_locus ());\n+\n+      // insert bindings\n+      ctx->insert_closure_binding (ref, indirection);\n+\n+      // continue\n+      idx++;\n+    }\n \n   // args tuple\n   tree args_type\n@@ -2910,7 +2946,10 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n     }\n \n   if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-    return error_mark_node;\n+    {\n+      ctx->pop_closure_context ();\n+      return error_mark_node;\n+    }\n \n   // lookup locals\n   HIR::Expr *function_body = expr.get_expr ().get ();\n@@ -2977,6 +3016,7 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n   DECL_SAVED_TREE (fndecl) = bind_tree;\n \n+  ctx->pop_closure_context ();\n   ctx->pop_fn ();\n   ctx->push_function (fndecl);\n "}, {"sha": "8857df2f3a54d950666c02c4490387cb1aa85b0f", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -121,6 +121,14 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       return constant_expr;\n     }\n \n+  // maybe closure binding\n+  tree closure_binding = error_mark_node;\n+  if (ctx->lookup_closure_binding (ref, &closure_binding))\n+    {\n+      TREE_USED (closure_binding) = 1;\n+      return closure_binding;\n+    }\n+\n   // this might be a variable reference or a function reference\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))"}, {"sha": "c8e1d3b40361df98ff4eb31d2aa608c37e3a7097", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -19,6 +19,7 @@\n #include \"rust-compile-type.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-gcc.h\"\n \n #include \"tree.h\"\n \n@@ -99,11 +100,39 @@ TyTyResolveCompile::visit (const TyTy::InferType &)\n void\n TyTyResolveCompile::visit (const TyTy::ClosureType &type)\n {\n+  auto mappings = ctx->get_mappings ();\n+\n   std::vector<Backend::typed_identifier> fields;\n+\n+  size_t i = 0;\n+  for (const auto &capture : type.get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = mappings->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // lookup the var decl type\n+      TyTy::BaseType *lookup = nullptr;\n+      bool found = ctx->get_tyctx ()->lookup_type (ref, &lookup);\n+      rust_assert (found);\n+\n+      // FIXME get the var pattern name\n+      std::string mappings_name = \"capture_\" + std::to_string (i);\n+\n+      // FIXME\n+      // this should be based on the closure move-ability\n+      tree decl_type = TyTyResolveCompile::compile (ctx, lookup);\n+      tree capture_type = build_reference_type (decl_type);\n+      fields.push_back (Backend::typed_identifier (mappings_name, capture_type,\n+\t\t\t\t\t\t   type.get_ident ().locus));\n+    }\n+\n   tree type_record = ctx->get_backend ()->struct_type (fields);\n   RS_CLOSURE_FLAG (type_record) = 1;\n \n-  std::string named_struct_str = type.get_ident ().path.get () + \"{{closure}}\";\n+  std::string named_struct_str\n+    = type.get_ident ().path.get () + \"::{{closure}}\";\n   translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n \t\t\t\t\t\ttype.get_ident ().locus);\n }"}, {"sha": "62cf3a082cff181339e6e5f3d0bdff371e89a728", "filename": "gcc/testsuite/rust/execute/torture/closure3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92389b46a96ce2274f5d9a3658d771b8b0ad99c9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs?ref=92389b46a96ce2274f5d9a3658d771b8b0ad99c9", "patch": "@@ -0,0 +1,33 @@\n+// { dg-output \"3\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn f<F: FnOnce(i32) -> i32>(g: F) {\n+    let call = g(1);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, call);\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let capture = 2;\n+    let a = |i: i32| {\n+        let b = i + capture;\n+        b\n+    };\n+    f(a);\n+    0\n+}"}]}