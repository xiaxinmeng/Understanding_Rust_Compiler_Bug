{"sha": "9c5a221c37501117aeebe06ee4c986b38a968024", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM1YTIyMWMzNzUwMTExN2FlZWJlMDZlZTRjOTg2YjM4YTk2ODAyNA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-11-22T01:46:54Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-11-22T01:46:54Z"}, "message": "tree-dump.{c,h} renamed from c-dump.{c,h}.\n\nFrom-SVN: r47255", "tree": {"sha": "c6975e61c2d5131174bfa6aa6e6982f37daabcb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6975e61c2d5131174bfa6aa6e6982f37daabcb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c5a221c37501117aeebe06ee4c986b38a968024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5a221c37501117aeebe06ee4c986b38a968024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c5a221c37501117aeebe06ee4c986b38a968024", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5a221c37501117aeebe06ee4c986b38a968024/comments", "author": null, "committer": null, "parents": [{"sha": "13422e9d3b90cdedf32f7e1dc610e35735a330e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13422e9d3b90cdedf32f7e1dc610e35735a330e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13422e9d3b90cdedf32f7e1dc610e35735a330e1"}], "stats": {"total": 1024, "additions": 1024, "deletions": 0}, "files": [{"sha": "28e7248a051b03dde81231c709b4c2341e0fc3ae", "filename": "gcc/tree-dump.c", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5a221c37501117aeebe06ee4c986b38a968024/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5a221c37501117aeebe06ee4c986b38a968024/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=9c5a221c37501117aeebe06ee4c986b38a968024", "patch": "@@ -0,0 +1,929 @@\n+/* Tree-dumping functionality for intermediate representation.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Written by Mark Mitchell <mark@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"splay-tree.h\"\n+#include \"diagnostic.h\"\n+#include \"toplev.h\"\n+#include \"c-dump.h\"\n+#include \"langhooks.h\"\n+\n+static unsigned int queue PARAMS ((dump_info_p, tree, int));\n+static void dump_index PARAMS ((dump_info_p, unsigned int));\n+static void dequeue_and_dump PARAMS ((dump_info_p));\n+static void dump_new_line PARAMS ((dump_info_p));\n+static void dump_maybe_newline PARAMS ((dump_info_p));\n+static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n+\n+/* Add T to the end of the queue of nodes to dump.  Returns the index\n+   assigned to T.  */\n+\n+static unsigned int\n+queue (di, t, flags)\n+     dump_info_p di;\n+     tree t;\n+     int flags;\n+{\n+  dump_queue_p dq;\n+  dump_node_info_p dni;\n+  unsigned int index;\n+\n+  /* Assign the next available index to T.  */\n+  index = ++di->index;\n+\n+  /* Obtain a new queue node.  */\n+  if (di->free_list)\n+    {\n+      dq = di->free_list;\n+      di->free_list = dq->next;\n+    }\n+  else\n+    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n+\n+  /* Create a new entry in the splay-tree.  */\n+  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n+  dni->index = index;\n+  dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n+  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n+\t\t\t\t(splay_tree_value) dni);\n+\n+  /* Add it to the end of the queue.  */\n+  dq->next = 0;\n+  if (!di->queue_end)\n+    di->queue = dq;\n+  else\n+    di->queue_end->next = dq;\n+  di->queue_end = dq;\n+\n+  /* Return the index.  */\n+  return index;\n+}\n+\n+static void\n+dump_index (di, index)\n+     dump_info_p di;\n+     unsigned int index;\n+{\n+  fprintf (di->stream, \"@%-6u \", index);\n+  di->column += 8;\n+}\n+\n+/* If T has not already been output, queue it for subsequent output.\n+   FIELD is a string to print before printing the index.  Then, the\n+   index of T is printed.  */\n+\n+void\n+queue_and_dump_index (di, field, t, flags)\n+     dump_info_p di;\n+     const char *field;\n+     tree t;\n+     int flags;\n+{\n+  unsigned int index;\n+  splay_tree_node n;\n+\n+  /* If there's no node, just return.  This makes for fewer checks in\n+     our callers.  */\n+  if (!t)\n+    return;\n+\n+  /* See if we've already queued or dumped this node.  */\n+  n = splay_tree_lookup (di->nodes, (splay_tree_key) t);\n+  if (n)\n+    index = ((dump_node_info_p) n->value)->index;\n+  else\n+    /* If we haven't, add it to the queue.  */\n+    index = queue (di, t, flags);\n+\n+  /* Print the index of the node.  */\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: \", field);\n+  di->column += 6;\n+  dump_index (di, index);\n+}\n+\n+/* Dump the type of T.  */\n+\n+void\n+queue_and_dump_type (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n+}\n+\n+/* Dump column control */\n+#define SOL_COLUMN 25\t\t/* Start of line column.  */\n+#define EOL_COLUMN 55\t\t/* End of line column.  */\n+#define COLUMN_ALIGNMENT 15\t/* Alignment.  */\n+\n+/* Insert a new line in the dump output, and indent to an appropriate\n+   place to start printing more fields.  */\n+\n+static void\n+dump_new_line (di)\n+     dump_info_p di;\n+{\n+  fprintf (di->stream, \"\\n%*s\", SOL_COLUMN, \"\");\n+  di->column = SOL_COLUMN;\n+}\n+\n+/* If necessary, insert a new line.  */\n+\n+static void\n+dump_maybe_newline (di)\n+     dump_info_p di;\n+{\n+  int extra;\n+  \n+  /* See if we need a new line.  */\n+  if (di->column > EOL_COLUMN)\n+    dump_new_line (di);\n+  /* See if we need any padding.  */\n+  else if ((extra = (di->column - SOL_COLUMN) % COLUMN_ALIGNMENT) != 0)\n+    {\n+      fprintf (di->stream, \"%*s\", COLUMN_ALIGNMENT - extra, \"\");\n+      di->column += COLUMN_ALIGNMENT - extra;\n+    }\n+}\n+\n+/* Dump pointer PTR using FIELD to identify it.  */\n+\n+void\n+dump_pointer (di, field, ptr)\n+     dump_info_p di;\n+     const char *field;\n+     void *ptr;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-8lx \", field, (long) ptr);\n+  di->column += 15;\n+}\n+\n+/* Dump integer I using FIELD to identify it.  */\n+\n+void\n+dump_int (di, field, i)\n+     dump_info_p di;\n+     const char *field;\n+     int i;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7d \", field, i);\n+  di->column += 14;\n+}\n+\n+/* Dump the string S.  */\n+\n+void\n+dump_string (di, string)\n+     dump_info_p di;\n+     const char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-13s \", string);\n+  if (strlen (string) > 13)\n+    di->column += strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump the string field S.  */\n+\n+static void\n+dump_string_field (di, field, string)\n+     dump_info_p di;\n+     const char *field;\n+     const char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7s \", field, string);\n+  if (strlen (string) > 7)\n+    di->column += 6 + strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump information common to statements from STMT.  */\n+\n+void\n+dump_stmt (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  dump_int (di, \"line\", STMT_LINENO (t));\n+}\n+\n+/* Dump the next statement after STMT.  */\n+\n+void\n+dump_next_stmt (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  dump_child (\"next\", TREE_CHAIN (t));\n+}\n+\n+/* Dump the next node in the queue.  */\n+\n+static void \n+dequeue_and_dump (di)\n+     dump_info_p di;\n+{\n+  dump_queue_p dq;\n+  splay_tree_node stn;\n+  dump_node_info_p dni;\n+  tree t;\n+  unsigned int index;\n+  enum tree_code code;\n+  char code_class;\n+  const char* code_name;\n+\n+  /* Get the next node from the queue.  */\n+  dq = di->queue;\n+  stn = dq->node;\n+  t = (tree) stn->key;\n+  dni = (dump_node_info_p) stn->value;\n+  index = dni->index;\n+\n+  /* Remove the node from the queue, and put it on the free list.  */\n+  di->queue = dq->next;\n+  if (!di->queue)\n+    di->queue_end = 0;\n+  dq->next = di->free_list;\n+  di->free_list = dq;\n+\n+  /* Print the node index.  */\n+  dump_index (di, index);\n+  /* And the type of node this is.  */\n+  if (dni->binfo_p)\n+    code_name = \"binfo\";\n+  else\n+    code_name = tree_code_name[(int) TREE_CODE (t)];\n+  fprintf (di->stream, \"%-16s \", code_name);\n+  di->column = 25;\n+\n+  /* Figure out what kind of node this is.  */\n+  code = TREE_CODE (t);\n+  code_class = TREE_CODE_CLASS (code);\n+\n+  /* Although BINFOs are TREE_VECs, we dump them specially so as to be\n+     more informative.  */\n+  if (dni->binfo_p)\n+    {\n+      if (TREE_VIA_PUBLIC (t))\n+\tdump_string (di, \"pub\");\n+      else if (TREE_VIA_PROTECTED (t))\n+\tdump_string (di, \"prot\");\n+      else if (TREE_VIA_PRIVATE (t))\n+\tdump_string (di, \"priv\");\n+      if (TREE_VIA_VIRTUAL (t))\n+\tdump_string (di, \"virt\");\n+\t    \n+      dump_child (\"type\", BINFO_TYPE (t));\n+      dump_child (\"base\", BINFO_BASETYPES (t));\n+\n+      goto done;\n+    }\n+\n+  /* We can knock off a bunch of expression nodes in exactly the same\n+     way.  */\n+  if (IS_EXPR_CODE_CLASS (code_class))\n+    {\n+      /* If we're dumping children, dump them now.  */\n+      queue_and_dump_type (di, t);\n+\n+      switch (code_class)\n+\t{\n+\tcase '1':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  break;\n+\t      \n+\tcase '2':\n+\tcase '<':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+\t  break;\n+\t      \n+\tcase 'e':\n+\t  /* These nodes are handled explicitly below.  */\n+\t  break;\n+\t      \n+\tdefault:\n+\t  abort();\n+\t}\n+    }\n+  else if (DECL_P (t))\n+    {\n+      /* All declarations have names.  */\n+      if (DECL_NAME (t))\n+\tdump_child (\"name\", DECL_NAME (t));\n+      if (DECL_ASSEMBLER_NAME_SET_P (t) \n+\t  && DECL_ASSEMBLER_NAME (t) != DECL_NAME (t))\n+\tdump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n+      /* And types.  */\n+      queue_and_dump_type (di, t);\n+      dump_child (\"scpe\", DECL_CONTEXT (t));\n+      /* And a source position.  */\n+      if (DECL_SOURCE_FILE (t))\n+\t{\n+\t  const char *filename = strrchr (DECL_SOURCE_FILE (t), '/');\n+\t  if (!filename)\n+\t    filename = DECL_SOURCE_FILE (t);\n+\t  else\n+\t    /* Skip the slash.  */\n+\t    ++filename;\n+\n+\t  dump_maybe_newline (di);\n+\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n+\t\t   DECL_SOURCE_LINE (t));\n+\t  di->column += 6 + strlen (filename) + 8;\n+\t}\n+      /* And any declaration can be compiler-generated.  */\n+      if (DECL_ARTIFICIAL (t))\n+\tdump_string (di, \"artificial\");\n+      if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n+\tdump_child (\"chan\", TREE_CHAIN (t));\n+    }\n+  else if (code_class == 't')\n+    {\n+      /* All types have qualifiers.  */\n+      int quals = (*lang_hooks.tree_dump.type_quals) (t);\n+      \n+      if (quals != TYPE_UNQUALIFIED)\n+\t{\n+\t  fprintf (di->stream, \"qual: %c%c%c     \",\n+\t\t   (quals & TYPE_QUAL_CONST) ? 'c' : ' ',\n+\t\t   (quals & TYPE_QUAL_VOLATILE) ? 'v' : ' ',\n+\t\t   (quals & TYPE_QUAL_RESTRICT) ? 'r' : ' ');\n+\t  di->column += 14;\n+\t}\n+\n+      /* All types have associated declarations.  */\n+      dump_child (\"name\", TYPE_NAME (t));\n+\n+      /* All types have a main variant.  */\n+      if (TYPE_MAIN_VARIANT (t) != t)\n+\tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n+      \n+      /* And sizes.  */\n+      dump_child (\"size\", TYPE_SIZE (t));\n+\n+      /* All types have alignments.  */\n+      dump_int (di, \"algn\", TYPE_ALIGN (t));\n+    }\n+  else if (code_class == 'c')\n+    /* All constants can have types.  */\n+    queue_and_dump_type (di, t);\n+\n+  /* Give the language-specific code a chance to print something.  If\n+     it's completely taken care of things, don't bother printing\n+     anything more ourselves.  */\n+  if ((*lang_hooks.tree_dump.dump_tree) (di, t))\n+    goto done;\n+\n+  /* Now handle the various kinds of nodes.  */\n+  switch (code)\n+    {\n+      int i;\n+\n+    case IDENTIFIER_NODE:\n+      dump_string_field (di, \"strg\", IDENTIFIER_POINTER (t));\n+      dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+      break;\n+\n+    case TREE_LIST:\n+      dump_child (\"purp\", TREE_PURPOSE (t));\n+      dump_child (\"valu\", TREE_VALUE (t));\n+      dump_child (\"chan\", TREE_CHAIN (t));\n+      break;\n+\n+    case TREE_VEC:\n+      dump_int (di, \"lngt\", TREE_VEC_LENGTH (t));\n+      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+\t{\n+\t  char buffer[32];\n+\t  sprintf (buffer, \"%u\", i);\n+\t  dump_child (buffer, TREE_VEC_ELT (t, i));\n+\t}\n+      break;\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      if (TREE_UNSIGNED (t))\n+\tdump_string (di, \"unsigned\");\n+      dump_child (\"min\", TYPE_MIN_VALUE (t));\n+      dump_child (\"max\", TYPE_MAX_VALUE (t));\n+\n+      if (code == ENUMERAL_TYPE)\n+\tdump_child (\"csts\", TYPE_VALUES (t));\n+      break;\n+\n+    case REAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      break;\n+\n+    case POINTER_TYPE:\n+      dump_child (\"ptd\", TREE_TYPE (t));\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      dump_child (\"refd\", TREE_TYPE (t));\n+      break;\n+\n+    case METHOD_TYPE:\n+      dump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n+      /* Fall through.  */\n+\n+    case FUNCTION_TYPE:\n+      dump_child (\"retn\", TREE_TYPE (t));\n+      dump_child (\"prms\", TYPE_ARG_TYPES (t));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      dump_child (\"elts\", TREE_TYPE (t));\n+      dump_child (\"domn\", TYPE_DOMAIN (t));\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (TREE_CODE (t) == RECORD_TYPE)\n+\tdump_string (di, \"struct\");\n+      else\n+\tdump_string (di, \"union\");\n+      \n+      dump_child (\"flds\", TYPE_FIELDS (t));\n+      dump_child (\"fncs\", TYPE_METHODS (t));\n+      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n+\t\t\t    DUMP_BINFO);\n+      break;\n+\n+    case CONST_DECL:\n+      dump_child (\"cnst\", DECL_INITIAL (t));\n+      break;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+      if (TREE_CODE (t) == PARM_DECL)\n+\tdump_child (\"argt\", DECL_ARG_TYPE (t));\n+      else\n+\tdump_child (\"init\", DECL_INITIAL (t));\n+      dump_child (\"size\", DECL_SIZE (t));\n+      dump_int (di, \"algn\", DECL_ALIGN (t));\n+\n+      if (TREE_CODE (t) == FIELD_DECL)\n+\t{\n+\t  if (DECL_C_BIT_FIELD (t))\n+\t    dump_string (di, \"bitfield\");\n+\t  if (DECL_FIELD_OFFSET (t))\n+\t    dump_child (\"bpos\", bit_position (t));\n+\t}\n+      else if (TREE_CODE (t) == VAR_DECL \n+\t       || TREE_CODE (t) == PARM_DECL)\n+\t{\n+\t  dump_int (di, \"used\", TREE_USED (t));\n+\t  if (DECL_REGISTER (t))\n+\t    dump_string (di, \"register\");\n+\t}\n+      break;\n+\n+    case FUNCTION_DECL:\n+      dump_child (\"args\", DECL_ARGUMENTS (t));\n+      if (DECL_EXTERNAL (t))\n+\tdump_string (di, \"undefined\");\n+      if (TREE_PUBLIC (t))\n+\tdump_string (di, \"extern\");\n+      else\n+\tdump_string (di, \"static\");\n+      if (DECL_LANG_SPECIFIC (t) && !dump_flag (di, TDF_SLIM, t))\n+\tdump_child (\"body\", DECL_SAVED_TREE (t));\n+      break;\n+\n+    case ASM_STMT:\n+      dump_stmt (di, t);\n+      if (ASM_VOLATILE_P (t))\n+\tdump_string (di, \"volatile\");\n+      dump_child (\"strg\", ASM_STRING (t));\n+      dump_child (\"outs\", ASM_OUTPUTS (t));\n+      dump_child (\"ins\", ASM_INPUTS (t));\n+      dump_child (\"clbr\", ASM_CLOBBERS (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      dump_stmt (di, t);\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case CASE_LABEL:\n+      /* Note that a case label is not like other statements; there is\n+\t no way to get the line-number of a case label.  */\n+      dump_child (\"low\", CASE_LOW (t));\n+      dump_child (\"high\", CASE_HIGH (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case COMPOUND_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", COMPOUND_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case DECL_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"decl\", DECL_STMT_DECL (t));\n+      dump_next_stmt (di, t);\n+      break;\n+      \n+    case DO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", DO_BODY (t));\n+      dump_child (\"cond\", DO_COND (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case EXPR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"expr\", EXPR_STMT_EXPR (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case FOR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"init\", FOR_INIT_STMT (t));\n+      dump_child (\"cond\", FOR_COND (t));\n+      dump_child (\"expr\", FOR_EXPR (t));\n+      dump_child (\"body\", FOR_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case GOTO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"dest\", GOTO_DESTINATION (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case IF_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", IF_COND (t));\n+      dump_child (\"then\", THEN_CLAUSE (t));\n+      dump_child (\"else\", ELSE_CLAUSE (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case LABEL_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"labl\", LABEL_STMT_LABEL (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case RETURN_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"expr\", RETURN_EXPR (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case SWITCH_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", SWITCH_COND (t));\n+      dump_child (\"body\", SWITCH_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case WHILE_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", WHILE_COND (t));\n+      dump_child (\"body\", WHILE_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case SCOPE_STMT:\n+      dump_stmt (di, t);\n+      if (SCOPE_BEGIN_P (t))\n+\tdump_string (di, \"begn\");\n+      else\n+\tdump_string (di, \"end\");\n+      if (SCOPE_NULLIFIED_P (t))\n+\tdump_string (di, \"null\");\n+      if (!SCOPE_NO_CLEANUPS_P (t))\n+\tdump_string (di, \"clnp\");\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case INTEGER_CST:\n+      if (TREE_INT_CST_HIGH (t))\n+\tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n+      dump_int (di, \"low\", TREE_INT_CST_LOW (t));\n+      break;\n+\n+    case STRING_CST:\n+      fprintf (di->stream, \"strg: %-7s \", TREE_STRING_POINTER (t));\n+      dump_int (di, \"lngt\", TREE_STRING_LENGTH (t));\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case CLEANUP_POINT_EXPR:\n+    case SAVE_EXPR:\n+      /* These nodes are unary, but do not have code class `1'.  */\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case INIT_EXPR:\n+    case MODIFY_EXPR:\n+    case COMPONENT_REF:\n+    case COMPOUND_EXPR:\n+    case ARRAY_REF:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      /* These nodes are binary, but do not have code class `2'.  */\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case COND_EXPR:\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n+      break;\n+\n+    case CALL_EXPR:\n+      dump_child (\"fn\", TREE_OPERAND (t, 0));\n+      dump_child (\"args\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      dump_child (\"elts\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case STMT_EXPR:\n+      dump_child (\"stmt\", STMT_EXPR_STMT (t));\n+      break;\n+\n+    case BIND_EXPR:\n+      dump_child (\"vars\", TREE_OPERAND (t, 0));\n+      dump_child (\"body\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case LOOP_EXPR:\n+      dump_child (\"body\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case EXIT_EXPR:\n+      dump_child (\"cond\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case TARGET_EXPR:\n+      dump_child (\"decl\", TREE_OPERAND (t, 0));\n+      dump_child (\"init\", TREE_OPERAND (t, 1));\n+      dump_child (\"clnp\", TREE_OPERAND (t, 2));\n+      /* There really are two possible places the initializer can be.\n+\t After RTL expansion, the second operand is moved to the\n+\t position of the fourth operand, and the second operand\n+\t becomes NULL.  */\n+      dump_child (\"init\", TREE_OPERAND (t, 3));\n+      break;\n+      \n+    case EXPR_WITH_FILE_LOCATION:\n+      dump_child (\"expr\", EXPR_WFL_NODE (t));\n+      break;\n+\n+    default:\n+      /* There are no additional fields to print.  */\n+      break;\n+    }\n+\n+ done:\n+  if (dump_flag (di, TDF_ADDRESS, NULL))\n+    dump_pointer (di, \"addr\", (void *)t);\n+  \n+  /* Terminate the line.  */\n+  fprintf (di->stream, \"\\n\");\n+}\n+\n+/* Return non-zero if FLAG has been specified for the dump, and NODE\n+   is not the root node of the dump.  */\n+\n+int dump_flag (di, flag, node)\n+     dump_info_p di;\n+     int flag;\n+     tree node;\n+{\n+  return (di->flags & flag) && (node != di->node);\n+}\n+\n+/* Dump T, and all its children, on STREAM.  */\n+\n+void\n+dump_node (t, flags, stream)\n+     tree t;\n+     int flags;\n+     FILE *stream;\n+{\n+  struct dump_info di;\n+  dump_queue_p dq;\n+  dump_queue_p next_dq;\n+\n+  /* Initialize the dump-information structure.  */\n+  di.stream = stream;\n+  di.index = 0;\n+  di.column = 0;\n+  di.queue = 0;\n+  di.queue_end = 0;\n+  di.free_list = 0;\n+  di.flags = flags;\n+  di.node = t;\n+  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n+\t\t\t     (splay_tree_delete_value_fn) &free);\n+\n+  /* Queue up the first node.  */\n+  queue (&di, t, DUMP_NONE);\n+\n+  /* Until the queue is empty, keep dumping nodes.  */\n+  while (di.queue)\n+    dequeue_and_dump (&di);\n+\n+  /* Now, clean up.  */\n+  for (dq = di.free_list; dq; dq = next_dq)\n+    {\n+      next_dq = dq->next;\n+      free (dq);\n+    }\n+  splay_tree_delete (di.nodes);\n+}\n+\n+/* Define a tree dump switch.  */\n+struct dump_file_info\n+{\n+  const char *suffix;\t\t/* suffix to give output file.  */\n+  const char *swtch;\t\t/* command line switch */\n+  int flags;\t\t\t/* user flags */\n+  int state;\t\t\t/* state of play */\n+};\n+\n+/* Table of tree dump switches. This must be consistent with the\n+   TREE_DUMP_INDEX enumeration in tree.h */\n+static struct dump_file_info dump_files[TDI_end] =\n+{\n+  {\".tu\", \"dump-translation-unit\", 0, 0},\n+  {\".class\", \"dump-class-hierarchy\", 0, 0},\n+  {\".original\", \"dump-tree-original\", 0, 0},\n+  {\".optimized\", \"dump-tree-optimized\", 0, 0},\n+  {\".inlined\", \"dump-tree-inlined\", 0, 0},\n+};\n+\n+/* Define a name->number mapping for a dump flag value.  */\n+struct dump_option_value_info\n+{\n+  const char *const name;\t/* the name of the value */\n+  const int value;\t\t/* the value of the name */\n+};\n+\n+/* Table of dump options. This must be consistent with the TDF_* flags\n+   in tree.h */\n+static const struct dump_option_value_info dump_options[] =\n+{\n+  {\"address\", TDF_ADDRESS},\n+  {\"slim\", TDF_SLIM},\n+  {\"all\", ~0},\n+  {NULL, 0}\n+};\n+\n+/* Begin a tree dump for PHASE. Stores any user supplied flag in\n+   *FLAG_PTR and returns a stream to write to. If the dump is not\n+   enabled, returns NULL.\n+   Multiple calls will reopen and append to the dump file.  */\n+\n+FILE *\n+dump_begin (phase, flag_ptr)\n+     enum tree_dump_index phase;\n+     int *flag_ptr;\n+{\n+  FILE *stream;\n+  char *name;\n+  \n+  if (!dump_files[phase].state)\n+    return NULL;\n+  \n+  name = concat (dump_base_name, dump_files[phase].suffix, NULL);\n+  stream = fopen (name, dump_files[phase].state < 0 ? \"w\" : \"a\");\n+  if (!stream)\n+    error (\"could not open dump file `%s'\", name);\n+  else\n+    dump_files[phase].state = 1;\n+  free (name);\n+  if (flag_ptr)\n+    *flag_ptr = dump_files[phase].flags;\n+  \n+  return stream;\n+}\n+\n+/* Returns non-zero if tree dump PHASE is enabled.  */\n+\n+int\n+dump_enabled_p (phase)\n+     enum tree_dump_index phase;\n+{\n+  return dump_files[phase].state;\n+}\n+\n+/* Returns the switch name of PHASE.  */\n+\n+const char *\n+dump_flag_name (phase)\n+     enum tree_dump_index phase;\n+{\n+  return dump_files[phase].swtch;\n+}\n+\n+/* Finish a tree dump for PHASE. STREAM is the stream created by\n+   dump_begin.  */\n+\n+void\n+dump_end (phase, stream)\n+     enum tree_dump_index phase ATTRIBUTE_UNUSED;\n+     FILE *stream;\n+{\n+  fclose (stream);\n+}\n+\n+/* Parse ARG as a dump switch. Return non-zero if it is, and store the\n+   relevant details in the dump_files array.  */\n+\n+int\n+dump_switch_p (arg)\n+     const char *arg;\n+{\n+  unsigned ix;\n+  const char *option_value;\n+  \n+  for (ix = 0; ix != TDI_end; ix++)\n+    if ((option_value = skip_leading_substring (arg, dump_files[ix].swtch)))\n+      {\n+\tconst char *ptr = option_value;\n+\tint flags = 0;\n+\t\n+\twhile (*ptr)\n+\t  {\n+\t    const struct dump_option_value_info *option_ptr;\n+\t    const char *end_ptr;\n+\t    unsigned length;\n+\t    \n+\t    while (*ptr == '-')\n+\t      ptr++;\n+\t    end_ptr = strchr (ptr, '-');\n+\t    if (!end_ptr)\n+\t      end_ptr = ptr + strlen (ptr);\n+\t    length = end_ptr - ptr;\n+\t    \n+\t    for (option_ptr = dump_options; option_ptr->name;\n+\t\t option_ptr++)\n+\t      if (strlen (option_ptr->name) == length\n+\t\t  && !memcmp (option_ptr->name, ptr, length))\n+\t\t{\n+\t\t  flags |= option_ptr->value;\n+\t\t  goto found;\n+\t\t}\n+\t    warning (\"ignoring unknown option `%.*s' in `-f%s'\",\n+\t\t     length, ptr, dump_files[ix].swtch);\n+\t  found:;\n+\t    ptr = end_ptr;\n+\t  }\n+\t\n+\tdump_files[ix].state = -1;\n+\tdump_files[ix].flags = flags;\n+\t\n+\treturn 1;\n+      }\n+  return 0;\n+}"}, {"sha": "4c4962c9a5c7237257702cf239d0dc2db09f3d95", "filename": "gcc/tree-dump.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c5a221c37501117aeebe06ee4c986b38a968024/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c5a221c37501117aeebe06ee4c986b38a968024/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=9c5a221c37501117aeebe06ee4c986b38a968024", "patch": "@@ -0,0 +1,95 @@\n+/* Tree-dumping functionality for intermediate representation.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Written by Mark Mitchell <mark@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_C_DUMP_H\n+#define GCC_C_DUMP_H\n+\n+/* Flags used with queue functions.  */\n+#define DUMP_NONE     0\n+#define DUMP_BINFO    1\n+\n+/* Information about a node to be dumped.  */\n+\n+typedef struct dump_node_info\n+{\n+  /* The index for the node.  */\n+  unsigned int index;\n+  /* Nonzero if the node is a binfo.  */\n+  unsigned int binfo_p : 1;\n+} *dump_node_info_p;\n+\n+/* A dump_queue is a link in the queue of things to be dumped.  */\n+\n+typedef struct dump_queue\n+{\n+  /* The queued tree node.  */\n+  splay_tree_node node;\n+  /* The next node in the queue.  */\n+  struct dump_queue *next;\n+} *dump_queue_p;\n+\n+/* A dump_info gives information about how we should perform the dump \n+   and about the current state of the dump.  */\n+\n+struct dump_info\n+{\n+  /* The stream on which to dump the information.  */\n+  FILE *stream;\n+  /* The original node.  */\n+  tree node;\n+  /* User flags.  */\n+  int flags;\n+  /* The next unused node index.  */\n+  unsigned int index;\n+  /* The next column.  */\n+  unsigned int column;\n+  /* The first node in the queue of nodes to be written out.  */\n+  dump_queue_p queue;\n+  /* The last node in the queue.  */\n+  dump_queue_p queue_end;\n+  /* Free queue nodes.  */\n+  dump_queue_p free_list;\n+  /* The tree nodes which we have already written out.  The \n+     keys are the addresses of the nodes; the values are the integer\n+     indices we assigned them.  */\n+  splay_tree nodes;\n+};\n+\n+/* Dump the CHILD and its children.  */\n+#define dump_child(field, child) \\\n+  queue_and_dump_index (di, field, child, DUMP_NONE)\n+\n+extern void dump_pointer\n+  PARAMS ((dump_info_p, const char *, void *));\n+extern void dump_int \n+  PARAMS ((dump_info_p, const char *, int));\n+extern void dump_string \n+  PARAMS ((dump_info_p, const char *));\n+extern void dump_stmt \n+  PARAMS ((dump_info_p, tree));\n+extern void dump_next_stmt \n+  PARAMS ((dump_info_p, tree));\n+extern void queue_and_dump_index \n+  PARAMS ((dump_info_p, const char *, tree, int));\n+extern void queue_and_dump_type \n+  PARAMS ((dump_info_p, tree));\n+\n+#endif /* ! GCC_C_DUMP_H */"}]}