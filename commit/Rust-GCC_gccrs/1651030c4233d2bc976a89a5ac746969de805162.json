{"sha": "1651030c4233d2bc976a89a5ac746969de805162", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1MTAzMGM0MjMzZDJiYzk3NmE4OWE1YWM3NDY5NjlkZTgwNTE2Mg==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2007-08-24T07:40:35Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2007-08-24T07:40:35Z"}, "message": "[patch]: libiberty pex for _WIN64.\n\nFrom-SVN: r127761", "tree": {"sha": "0404b66ffe5fcadd6ec7dc74194dfdaa583c6a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0404b66ffe5fcadd6ec7dc74194dfdaa583c6a0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1651030c4233d2bc976a89a5ac746969de805162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1651030c4233d2bc976a89a5ac746969de805162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1651030c4233d2bc976a89a5ac746969de805162", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1651030c4233d2bc976a89a5ac746969de805162/comments", "author": null, "committer": null, "parents": [{"sha": "affb3cb2002b1e238f0ae6188742c543934ea270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affb3cb2002b1e238f0ae6188742c543934ea270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affb3cb2002b1e238f0ae6188742c543934ea270"}], "stats": {"total": 124, "additions": 69, "deletions": 55}, "files": [{"sha": "8e3444820c1274121c1f9d6c414d1caca4ec15a6", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -1,3 +1,11 @@\n+2007-08-24  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* pex-common.h: (pex_funcs): Retyped wait and exec_child to pid_t.\n+\t* pex-djgpp.c: Likewise.\n+\t* pex-msdos.c: Likewise.\n+\t* pex-unix.c: Likewise.\n+\t* pex-win32.c: Likewise.\n+\n 2007-08-17  Michael Snyder  <msnyder@access-company.com>\n \n \t* make-relative-prefix.c (make_relative_prefix_1): Resource leaks."}, {"sha": "5b7bfcc03ee3bc23fde19f2ad984269c35bc4a04", "filename": "libiberty/pex-common.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.h?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -26,6 +26,12 @@ Boston, MA 02110-1301, USA.  */\n #include \"libiberty.h\"\n #include <stdio.h>\n \n+/* pid_t is may defined by config.h or sys/types.h needs to be\n+   included.  */\n+#if !defined(pid_t) && defined(HAVE_SYS_TYPES_H)\n+#include <sys/types.h>\n+#endif\n+\n #define install_error_msg \"installation problem, cannot exec `%s'\"\n \n /* stdin file number.  */\n@@ -108,7 +114,7 @@ struct pex_funcs\n      closed in the child process.  The function should handle the\n      PEX_STDERR_TO_STDOUT flag.  Return >= 0 on success, or -1 on\n      error and set *ERRMSG and *ERR.  */\n-  long (*exec_child) (struct pex_obj *, int /* flags */,\n+  pid_t (*exec_child) (struct pex_obj *, int /* flags */,\n                       const char */* executable */, char * const * /* argv */,\n                       char * const * /* env */,\n                       int /* in */, int /* out */, int /* errdes */,\n@@ -120,7 +126,7 @@ struct pex_funcs\n      and time in *TIME (if it is not null).  CHILD is from fork.  DONE\n      is 1 if this is called via pex_free.  ERRMSG and ERR are as in\n      fork.  Return 0 on success, -1 on error.  */\n-  int (*wait) (struct pex_obj *, long /* child */, int * /* status */,\n+  int (*wait) (struct pex_obj *, pid_t /* child */, int * /* status */,\n                struct pex_time * /* time */, int /* done */,\n                const char ** /* errmsg */, int * /* err */);\n   /* Create a pipe (only called if PEX_USE_PIPES is set) storing two"}, {"sha": "bd279380daec881e2355a8dc337d3e08bf963923", "filename": "libiberty/pex-djgpp.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -44,12 +44,12 @@ extern int errno;\n \n static int pex_djgpp_open_read (struct pex_obj *, const char *, int);\n static int pex_djgpp_open_write (struct pex_obj *, const char *, int);\n-static long pex_djgpp_exec_child (struct pex_obj *, int, const char *,\n+static pid_t pex_djgpp_exec_child (struct pex_obj *, int, const char *,\n \t\t\t\t  char * const *, char * const *,\n \t\t\t\t  int, int, int, int,\n \t\t\t\t  const char **, int *);\n static int pex_djgpp_close (struct pex_obj *, int);\n-static int pex_djgpp_wait (struct pex_obj *, long, int *, struct pex_time *,\n+static int pex_djgpp_wait (struct pex_obj *, pid_t, int *, struct pex_time *,\n \t\t\t   int, const char **, int *);\n \n /* The list of functions we pass to the common routines.  */\n@@ -110,7 +110,7 @@ pex_djgpp_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n \n /* Execute a child.  */\n \n-static long\n+static pid_t\n pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t\t      char * const * argv, char * const * env,\n                       int in, int out, int errdes,\n@@ -132,19 +132,19 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (dup2 (in, STDIN_FILE_NO) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (close (in) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"close\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n     }\n \n@@ -155,19 +155,19 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (dup2 (out, STDOUT_FILE_NO) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (close (out) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"close\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n     }\n \n@@ -179,22 +179,22 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,\n \t\t STDERR_FILE_NO) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (errdes != STDERR_FILE_NO)\n \t{\n \t  if (close (errdes) < 0)\n \t    {\n \t      *err = errno;\n \t      *errmsg = \"close\";\n-\t      return -1;\n+\t      return (pid_t) -1;\n \t    }\n \t}\n     }\n@@ -218,13 +218,13 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (close (org_in) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"close\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n     }\n \n@@ -234,13 +234,13 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (close (org_out) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"close\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n     }\n \n@@ -251,13 +251,13 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t{\n \t  *err = errno;\n \t  *errmsg = \"dup2\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n       if (close (org_errdes) < 0)\n \t{\n \t  *err = errno;\n \t  *errmsg = \"close\";\n-\t  return -1;\n+\t  return (pid_t) -1;\n \t}\n     }\n \n@@ -269,15 +269,15 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n   statuses[obj->count] = status;\n   obj->sysdep = (void *) statuses;\n \n-  return obj->count;\n+  return (pid_t) obj->count;\n }\n \n /* Wait for a child process to complete.  Actually the child process\n    has already completed, and we just need to return the exit\n    status.  */\n \n static int\n-pex_djgpp_wait (struct pex_obj *obj, long pid, int *status,\n+pex_djgpp_wait (struct pex_obj *obj, pid_t pid, int *status,\n \t\tstruct pex_time *time, int done ATTRIBUTE_UNUSED,\n \t\tconst char **errmsg ATTRIBUTE_UNUSED,\n \t\tint *err ATTRIBUTE_UNUSED)"}, {"sha": "ab4d736429e801bbb956fc06b315039a0a084121", "filename": "libiberty/pex-msdos.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -54,12 +54,12 @@ struct pex_msdos\n static int pex_msdos_open (struct pex_obj *, const char *, int);\n static int pex_msdos_open (struct pex_obj *, const char *, int);\n static int pex_msdos_fdindex (struct pex_msdos *, int);\n-static long pex_msdos_exec_child (struct pex_obj *, int, const char *,\n+static pid_t pex_msdos_exec_child (struct pex_obj *, int, const char *,\n \t\t\t\t  char * const *, char * const *,\n \t\t\t\t  int, int, int, int,\n \t\t\t\t  int, const char **, int *);\n static int pex_msdos_close (struct pex_obj *, int);\n-static int pex_msdos_wait (struct pex_obj *, long, int *, struct pex_time *,\n+static int pex_msdos_wait (struct pex_obj *, pid_t, int *, struct pex_time *,\n \t\t\t   int, const char **, int *);\n static void pex_msdos_cleanup (struct pex_obj *);\n \n@@ -152,7 +152,7 @@ pex_msdos_close (struct pex_obj *obj, int fd)\n \n /* Execute a child.  */\n \n-static long\n+static pid_t\n pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t\t      char * const * argv, char * const * env, int in, int out,\n \t\t      int toclose ATTRIBUTE_UNUSED,\n@@ -235,7 +235,7 @@ pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n       free (scmd);\n       free (rf);\n       *errmsg = \"cannot open temporary command file\";\n-      return -1;\n+      return (pid_t) -1;\n     }\n \n   for (i = 1; argv[i] != NULL; ++i)\n@@ -262,7 +262,7 @@ pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n       free (scmd);\n       free (rf);\n       *errmsg = \"system\";\n-      return -1;\n+      return (pid_t) -1;\n     }\n \n   remove (rf);\n@@ -275,15 +275,15 @@ pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n   ms->statuses = XRESIZEVEC(int, ms->statuses, obj->count + 1);\n   ms->statuses[obj->count] = status;\n \n-  return obj->count;\n+  return (pid_t) obj->count;\n }\n \n /* Wait for a child process to complete.  Actually the child process\n    has already completed, and we just need to return the exit\n    status.  */\n \n static int\n-pex_msdos_wait (struct pex_obj *obj, long pid, int *status,\n+pex_msdos_wait (struct pex_obj *obj, pid_t pid, int *status,\n \t\tstruct pex_time *time, int done ATTRIBUTE_UNUSED,\n \t\tconst char **errmsg ATTRIBUTE_UNUSED,\n \t\tint *err ATTRIBUTE_UNUSED)"}, {"sha": "366e96ef8d23243234f0b47793642b45d2850c11", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -269,12 +269,12 @@ static void pex_child_error (struct pex_obj *, const char *, const char *, int)\n      ATTRIBUTE_NORETURN;\n static int pex_unix_open_read (struct pex_obj *, const char *, int);\n static int pex_unix_open_write (struct pex_obj *, const char *, int);\n-static long pex_unix_exec_child (struct pex_obj *, int, const char *,\n+static pid_t pex_unix_exec_child (struct pex_obj *, int, const char *,\n \t\t\t\t char * const *, char * const *,\n \t\t\t\t int, int, int, int,\n \t\t\t\t const char **, int *);\n static int pex_unix_close (struct pex_obj *, int);\n-static int pex_unix_wait (struct pex_obj *, long, int *, struct pex_time *,\n+static int pex_unix_wait (struct pex_obj *, pid_t, int *, struct pex_time *,\n \t\t\t  int, const char **, int *);\n static int pex_unix_pipe (struct pex_obj *, int *, int);\n static FILE *pex_unix_fdopenr (struct pex_obj *, int, int);\n@@ -355,7 +355,7 @@ pex_child_error (struct pex_obj *obj, const char *executable,\n \n extern char **environ;\n \n-static long\n+static pid_t\n pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t\t     char * const * argv, char * const * env,\n                      int in, int out, int errdes,\n@@ -384,7 +384,7 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n     case -1:\n       *err = errno;\n       *errmsg = VFORK_STRING;\n-      return -1;\n+      return (pid_t) -1;\n \n     case 0:\n       /* Child process.  */\n@@ -435,7 +435,7 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t}\n \n       /* NOTREACHED */\n-      return -1;\n+      return (pid_t) -1;\n \n     default:\n       /* Parent process.  */\n@@ -445,7 +445,7 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t    {\n \t      *err = errno;\n \t      *errmsg = \"close\";\n-\t      return -1;\n+\t      return (pid_t) -1;\n \t    }\n \t}\n       if (out != STDOUT_FILE_NO)\n@@ -454,7 +454,7 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t    {\n \t      *err = errno;\n \t      *errmsg = \"close\";\n-\t      return -1;\n+\t      return (pid_t) -1;\n \t    }\n \t}\n       if (errdes != STDERR_FILE_NO)\n@@ -463,18 +463,18 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t    {\n \t      *err = errno;\n \t      *errmsg = \"close\";\n-\t      return -1;\n+\t      return (pid_t) -1;\n \t    }\n \t}\n \n-      return (long) pid;\n+      return pid;\n     }\n }\n \n /* Wait for a child process to complete.  */\n \n static int\n-pex_unix_wait (struct pex_obj *obj, long pid, int *status,\n+pex_unix_wait (struct pex_obj *obj, pid_t pid, int *status,\n \t       struct pex_time *time, int done, const char **errmsg,\n \t       int *err)\n {"}, {"sha": "05d44e9d183a6c9e14cd59afe0c26c6cb8920aa9", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1651030c4233d2bc976a89a5ac746969de805162/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=1651030c4233d2bc976a89a5ac746969de805162", "patch": "@@ -79,12 +79,12 @@ backslashify (char *s)\n \n static int pex_win32_open_read (struct pex_obj *, const char *, int);\n static int pex_win32_open_write (struct pex_obj *, const char *, int);\n-static long pex_win32_exec_child (struct pex_obj *, int, const char *,\n+static pid_t pex_win32_exec_child (struct pex_obj *, int, const char *,\n \t\t\t\t  char * const *, char * const *,\n                                   int, int, int, int,\n \t\t\t\t  const char **, int *);\n static int pex_win32_close (struct pex_obj *, int);\n-static int pex_win32_wait (struct pex_obj *, long, int *,\n+static int pex_win32_wait (struct pex_obj *, pid_t, int *,\n \t\t\t   struct pex_time *, int, const char **, int *);\n static int pex_win32_pipe (struct pex_obj *, int *, int);\n static FILE *pex_win32_fdopenr (struct pex_obj *, int, int);\n@@ -522,7 +522,7 @@ env_compare (const void *a_ptr, const void *b_ptr)\n   return c1 - c2;\n }\n \n-static long\n+static pid_t\n win32_spawn (const char *executable,\n \t     BOOL search,\n \t     char *const *argv,\n@@ -597,7 +597,7 @@ win32_spawn (const char *executable,\n \n       free (full_executable);\n \n-      return -1;\n+      return (pid_t) -1;\n     }\n \n   /* Clean up.  */\n@@ -606,7 +606,7 @@ win32_spawn (const char *executable,\n   if (env_block)\n     free (env_block);\n \n-  return (long) pi->hProcess;\n+  return (pid_t) pi->hProcess;\n \n  error:\n   if (env_block)\n@@ -616,17 +616,17 @@ win32_spawn (const char *executable,\n   if (full_executable)\n     free (full_executable);\n \n-  return -1;\n+  return (pid_t) -1;\n }\n \n-static long\n+static pid_t\n spawn_script (const char *executable, char *const *argv,\n               char* const *env,\n \t      DWORD dwCreationFlags,\n \t      LPSTARTUPINFO si,\n \t      LPPROCESS_INFORMATION pi)\n {\n-  int pid = -1;\n+  pid_t pid = (pid_t) -1;\n   int save_errno = errno;\n   int fd = _open (executable, _O_RDONLY);\n \n@@ -673,7 +673,7 @@ spawn_script (const char *executable, char *const *argv,\n \t\t\t\t     dwCreationFlags, si, pi);\n \t\t  if (executable1 != newex)\n \t\t    free ((char *) newex);\n-\t\t  if (pid < 0)\n+\t\t  if ((long) pid < 0)\n \t\t    {\n \t\t      newex = msys_rootify (executable1);\n \t\t      if (newex != executable1)\n@@ -689,14 +689,14 @@ spawn_script (const char *executable, char *const *argv,\n \t    }\n \t}\n     }\n-  if (pid < 0)\n+  if ((long) pid < 0)\n     errno = save_errno;\n   return pid;\n }\n \n /* Execute a child.  */\n \n-static long\n+static pid_t\n pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n \t\t      const char *executable, char * const * argv,\n                       char* const* env,\n@@ -705,7 +705,7 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n \t\t      const char **errmsg,\n \t\t      int *err)\n {\n-  long pid;\n+  pid_t pid;\n   HANDLE stdin_handle;\n   HANDLE stdout_handle;\n   HANDLE stderr_handle;\n@@ -780,10 +780,10 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n   /* Create the child process.  */  \n   pid = win32_spawn (executable, (flags & PEX_SEARCH) != 0,\n \t\t     argv, env, dwCreationFlags, &si, &pi);\n-  if (pid == -1)\n+  if (pid == (pid_t) -1)\n     pid = spawn_script (executable, argv, env, dwCreationFlags,\n                         &si, &pi);\n-  if (pid == -1)\n+  if (pid == (pid_t) -1)\n     {\n       *err = ENOENT;\n       *errmsg = \"CreateProcess\";\n@@ -808,7 +808,7 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n    macros.  Note that WIFSIGNALED will never be true under CRTDLL. */\n \n static int\n-pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, long pid,\n+pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid,\n \t\tint *status, struct pex_time *time, int done ATTRIBUTE_UNUSED,\n \t\tconst char **errmsg, int *err)\n {\n@@ -883,7 +883,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n   char const *errmsg;\n   int err;\n   argv++;\n-  printf (\"%ld\\n\", pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));\n+  printf (\"%ld\\n\", (long) pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));\n   exit (0);\n }\n #endif"}]}