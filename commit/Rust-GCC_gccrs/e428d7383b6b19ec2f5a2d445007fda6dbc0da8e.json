{"sha": "e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQyOGQ3MzgzYjZiMTllYzJmNWEyZDQ0NTAwN2ZkYTZkYmMwZGE4ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-11-12T11:39:08Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-11-12T11:39:08Z"}, "message": "Remove useless code\n\nFrom-SVN: r30499", "tree": {"sha": "f65bcc5130952905834c894c9e94a13f9140e1fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f65bcc5130952905834c894c9e94a13f9140e1fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e/comments", "author": null, "committer": null, "parents": [{"sha": "68ed151f7e718e3ea8023776362b079e2bac1cd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ed151f7e718e3ea8023776362b079e2bac1cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ed151f7e718e3ea8023776362b079e2bac1cd5"}], "stats": {"total": 63, "additions": 14, "deletions": 49}, "files": [{"sha": "3cb4bb79ef91e7f37b204e532b8c0aef14eac827", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "patch": "@@ -1,3 +1,16 @@\n+Fri Nov 12 12:36:04 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cse.c (hash_arg_in_struct): Delete.\n+\t(struct table_elt): Delete elt in_struct.\n+\t(struct set): Delete elt src_in_struct.\n+\t(merge_equiv_classes): Don't set either hash_arg_in_struct or\n+\tthe corresponding in_struct elts.\n+\t(canon_hash): Likewise.\n+\t(safe_hash): Likewise.\n+\t(find_best_addr): Likewise.\n+\t(record_jump_cond): Likewise.\n+\t(cse_insn): Likewise.\n+\n Thu Nov 11 19:45:24 1999  Jim Wilson  <wilson@cygnus.com>\n \n \t* loop.c (invariant_p, case MEM): Put MEM_VOLATILE_P check back."}, {"sha": "caee712a251bd264fc22ca102fd800207b132168", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e428d7383b6b19ec2f5a2d445007fda6dbc0da8e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e428d7383b6b19ec2f5a2d445007fda6dbc0da8e", "patch": "@@ -388,11 +388,6 @@ static rtx memory_extend_rtx;\n \n static int hash_arg_in_memory;\n \n-/* canon_hash stores 1 in hash_arg_in_struct\n-   if it notices a reference to memory that's part of a structure.  */\n-\n-static int hash_arg_in_struct;\n-\n /* The hash table contains buckets which are chains of `struct table_elt's,\n    each recording one expression's information.\n    That expression is in the `exp' field.\n@@ -414,9 +409,6 @@ static int hash_arg_in_struct;\n    the address is either a symbol constant or a constant plus\n    the frame pointer or argument pointer.\n \n-   The `in_struct' field is nonzero for elements that\n-   involve any reference to memory inside a structure or array.\n-\n    The `related_value' field is used to connect related expressions\n    (that differ by adding an integer).\n    The related expressions are chained in a circular fashion.\n@@ -448,7 +440,6 @@ struct table_elt\n   int cost;\n   enum machine_mode mode;\n   char in_memory;\n-  char in_struct;\n   char is_const;\n   char flag;\n };\n@@ -1683,7 +1674,6 @@ merge_equiv_classes (class1, class2)\n       if (GET_CODE (exp) == REG || exp_equiv_p (exp, exp, 1, 0))\n \t{\n \t  hash_arg_in_memory = 0;\n-\t  hash_arg_in_struct = 0;\n \t  hash = HASH (exp, mode);\n \t      \n \t  if (GET_CODE (exp) == REG)\n@@ -1698,7 +1688,6 @@ merge_equiv_classes (class1, class2)\n \t    }\n \t  new = insert (exp, class1, hash, mode);\n \t  new->in_memory = hash_arg_in_memory;\n-\t  new->in_struct = hash_arg_in_struct;\n \t}\n     }\n }\n@@ -2099,8 +2088,6 @@ use_related_value (x, elt)\n \n    Store 1 in hash_arg_in_memory if X contains a MEM rtx\n    which does not have the RTX_UNCHANGING_P bit set.\n-   In this case, also store 1 in hash_arg_in_struct\n-   if there is a MEM rtx which has the MEM_IN_STRUCT_P bit set.\n \n    Note that cse_insn knows that the hash code of a MEM expression\n    is just (int) MEM plus the hash code of the address.  */\n@@ -2212,7 +2199,6 @@ canon_hash (x, mode)\n       if (! RTX_UNCHANGING_P (x) || FIXED_BASE_PLUS_P (XEXP (x, 0)))\n \t{\n \t  hash_arg_in_memory = 1;\n-\t  if (MEM_IN_STRUCT_P (x)) hash_arg_in_struct = 1;\n \t}\n       /* Now that we have already found this special case,\n \t might as well speed it up as much as possible.  */\n@@ -2294,10 +2280,8 @@ safe_hash (x, mode)\n {\n   int save_do_not_record = do_not_record;\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n-  int save_hash_arg_in_struct = hash_arg_in_struct;\n   unsigned hash = canon_hash (x, mode);\n   hash_arg_in_memory = save_hash_arg_in_memory;\n-  hash_arg_in_struct = save_hash_arg_in_struct;\n   do_not_record = save_do_not_record;\n   return hash;\n }\n@@ -2842,7 +2826,6 @@ find_best_addr (insn, loc)\n #endif\n   int save_do_not_record = do_not_record;\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n-  int save_hash_arg_in_struct = hash_arg_in_struct;\n   int addr_volatile;\n   int regno;\n   unsigned hash;\n@@ -2898,7 +2881,6 @@ find_best_addr (insn, loc)\n   addr_volatile = do_not_record;\n   do_not_record = save_do_not_record;\n   hash_arg_in_memory = save_hash_arg_in_memory;\n-  hash_arg_in_struct = save_hash_arg_in_struct;\n \n   if (addr_volatile)\n     return;\n@@ -2987,7 +2969,6 @@ find_best_addr (insn, loc)\n       hash = HASH (XEXP (*loc, 0), Pmode);\n       do_not_record = save_do_not_record;\n       hash_arg_in_memory = save_hash_arg_in_memory;\n-      hash_arg_in_struct = save_hash_arg_in_struct;\n \n       elt = lookup (XEXP (*loc, 0), hash, Pmode);\n       if (elt == 0)\n@@ -4355,7 +4336,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n      int reversed_nonequality;\n {\n   unsigned op0_hash, op1_hash;\n-  int op0_in_memory, op0_in_struct, op1_in_memory, op1_in_struct;\n+  int op0_in_memory, op1_in_memory;\n   struct table_elt *op0_elt, *op1_elt;\n \n   /* If OP0 and OP1 are known equal, and either is a paradoxical SUBREG,\n@@ -4425,20 +4406,16 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n   do_not_record = 0;\n   hash_arg_in_memory = 0;\n-  hash_arg_in_struct = 0;\n   op0_hash = HASH (op0, mode);\n   op0_in_memory = hash_arg_in_memory;\n-  op0_in_struct = hash_arg_in_struct;\n \n   if (do_not_record)\n     return;\n \n   do_not_record = 0;\n   hash_arg_in_memory = 0;\n-  hash_arg_in_struct = 0;\n   op1_hash = HASH (op1, mode);\n   op1_in_memory = hash_arg_in_memory;\n-  op1_in_struct = hash_arg_in_struct;\n   \n   if (do_not_record)\n     return;\n@@ -4491,7 +4468,6 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n \t  op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n \t  op0_elt->in_memory = op0_in_memory;\n-\t  op0_elt->in_struct = op0_in_struct;\n \t}\n \n       qty_comparison_code[REG_QTY (REGNO (op0))] = code;\n@@ -4511,7 +4487,6 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n \t      op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n \t      op1_elt->in_memory = op1_in_memory;\n-\t      op1_elt->in_struct = op1_in_struct;\n \t    }\n \n \t  qty_comparison_qty[REG_QTY (REGNO (op0))] = REG_QTY (REGNO (op1));\n@@ -4539,7 +4514,6 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n       op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n       op0_elt->in_memory = op0_in_memory;\n-      op0_elt->in_struct = op0_in_struct;\n     }\n \n   if (op1_elt == 0)\n@@ -4552,7 +4526,6 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n       op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n       op1_elt->in_memory = op1_in_memory;\n-      op1_elt->in_struct = op1_in_struct;\n     }\n \n   merge_equiv_classes (op0_elt, op1_elt);\n@@ -4587,8 +4560,6 @@ struct set\n   rtx inner_dest;\n   /* Nonzero if the SET_SRC is in memory.  */ \n   char src_in_memory;\n-  /* Nonzero if the SET_SRC is in a structure.  */ \n-  char src_in_struct;\n   /* Nonzero if the SET_SRC contains something\n      whose value cannot be predicted and understood.  */\n   char src_volatile;\n@@ -4622,7 +4593,6 @@ cse_insn (insn, libcall_insn)\n   struct table_elt *src_eqv_elt = 0;\n   int src_eqv_volatile = 0;\n   int src_eqv_in_memory = 0;\n-  int src_eqv_in_struct = 0;\n   unsigned src_eqv_hash = 0;\n \n   struct set *sets = NULL_PTR;\n@@ -4871,7 +4841,6 @@ cse_insn (insn, libcall_insn)\n \t    eqvmode = GET_MODE (SUBREG_REG (XEXP (dest, 0)));\n \t  do_not_record = 0;\n \t  hash_arg_in_memory = 0;\n-\t  hash_arg_in_struct = 0;\n \t  src_eqv = fold_rtx (src_eqv, insn);\n \t  src_eqv_hash = HASH (src_eqv, eqvmode);\n \n@@ -4882,7 +4851,6 @@ cse_insn (insn, libcall_insn)\n \n \t  src_eqv_volatile = do_not_record;\n \t  src_eqv_in_memory = hash_arg_in_memory;\n-\t  src_eqv_in_struct = hash_arg_in_struct;\n \t}\n \n       /* If this is a STRICT_LOW_PART assignment, src_eqv corresponds to the\n@@ -4926,13 +4894,11 @@ cse_insn (insn, libcall_insn)\n \t prevent any further processing of this assignment.  */\n       do_not_record = 0;\n       hash_arg_in_memory = 0;\n-      hash_arg_in_struct = 0;\n \n       sets[i].src = src;\n       sets[i].src_hash = HASH (src, mode);\n       sets[i].src_volatile = do_not_record;\n       sets[i].src_in_memory = hash_arg_in_memory;\n-      sets[i].src_in_struct = hash_arg_in_struct;\n \n       /* If SRC is a MEM, there is a REG_EQUIV note for SRC, and DEST is\n \t a pseudo that is set more than once, do not record SRC.  Using\n@@ -5480,12 +5446,10 @@ cse_insn (insn, libcall_insn)\n         {\n           do_not_record = 0;\n           hash_arg_in_memory = 0;\n-          hash_arg_in_struct = 0;\n \t  sets[i].src = src;\n           sets[i].src_hash = HASH (src, mode);\n           sets[i].src_volatile = do_not_record;\n           sets[i].src_in_memory = hash_arg_in_memory;\n-          sets[i].src_in_struct = hash_arg_in_struct;\n           sets[i].src_elt = lookup (src, sets[i].src_hash, mode);\n         }\n \n@@ -5723,7 +5687,6 @@ cse_insn (insn, libcall_insn)\n \t}\n       elt = insert (src_eqv, classp, src_eqv_hash, eqvmode);\n       elt->in_memory = src_eqv_in_memory;\n-      elt->in_struct = src_eqv_in_struct;\n       src_eqv_elt = elt;\n \n       /* Check to see if src_eqv_elt is the same as a set source which\n@@ -5780,7 +5743,6 @@ cse_insn (insn, libcall_insn)\n \t\t      }\n \t\t    elt = insert (src, classp, sets[i].src_hash, mode);\n \t\t    elt->in_memory = sets[i].src_in_memory;\n-\t\t    elt->in_struct = sets[i].src_in_struct;\n \t\t    sets[i].src_elt = classp = elt;\n \t\t  }\n \t\telse\n@@ -5982,15 +5944,6 @@ cse_insn (insn, libcall_insn)\n \t\t\t      || FIXED_BASE_PLUS_P (XEXP (sets[i].inner_dest,\n \t\t\t\t\t\t\t  0))));\n \n-\tif (elt->in_memory)\n-\t  {\n-\t    /* This implicitly assumes a whole struct\n-\t       need not have MEM_IN_STRUCT_P.\n-\t       But a whole struct is *supposed* to have MEM_IN_STRUCT_P.  */\n-\t    elt->in_struct = (MEM_IN_STRUCT_P (sets[i].inner_dest)\n-\t\t\t      || sets[i].inner_dest != SET_DEST (sets[i].rtl));\n-\t  }\n-\n \t/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is no\n \t   narrower than M2, and both M1 and M2 are the same number of words,\n \t   we are also doing (set (reg:m2 foo) (subreg:m2 (bar:m1) 0)) so\n@@ -6047,7 +6000,6 @@ cse_insn (insn, libcall_insn)\n \t\t      }\n \t\t    src_elt = insert (new_src, classp, src_hash, new_mode);\n \t\t    src_elt->in_memory = elt->in_memory;\n-\t\t    src_elt->in_struct = elt->in_struct;\n \t\t  }\n \t\telse if (classp && classp != src_elt->first_same_value)\n \t\t  /* Show that two things that we've seen before are "}]}