{"sha": "fc378698688e76cd83c0171c493703858b822bac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzNzg2OTg2ODhlNzZjZDgzYzAxNzFjNDkzNzAzODU4YjgyMmJhYw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-21T19:46:11Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-21T19:46:11Z"}, "message": "85th Cygnus<->FSF quick merge\n\nFrom-SVN: r11587", "tree": {"sha": "71acc1f1dfc74c8765bd1a8cb6d4812f1fc07115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71acc1f1dfc74c8765bd1a8cb6d4812f1fc07115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc378698688e76cd83c0171c493703858b822bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc378698688e76cd83c0171c493703858b822bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc378698688e76cd83c0171c493703858b822bac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc378698688e76cd83c0171c493703858b822bac/comments", "author": null, "committer": null, "parents": [{"sha": "2a27574812f7aaf0b0bfbf8d197448a22ae2c289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a27574812f7aaf0b0bfbf8d197448a22ae2c289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a27574812f7aaf0b0bfbf8d197448a22ae2c289"}], "stats": {"total": 1629, "additions": 893, "deletions": 736}, "files": [{"sha": "3434665100c7b060bbc6659bbc2c2d8980bb76bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1,3 +1,233 @@\n+Wed Mar 20 14:51:55 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (named_complex_class_head_sans_basetype): Don't crash on\n+ \tdefinition of nonexistent nested type.\n+\n+\t* error.c (dump_decl, case TYPE_DECL): Fix decision for whether or\n+ \tnot to say 'typedef'.\n+\n+Wed Mar 20 00:11:47 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.h (struct lang_type): Make search_slot a tree, not a char*.\n+\t* search.c (dfs_walk, dfs_init_vbase_pointers,\n+\texpand_upcast_fixups): Remove cast of CLASSTYPE_SEARCH_SLOT.\n+\t(dfs_find_vbases): Remove cast for CLASSTYPE_SEARCH_SLOT init.\n+\n+Tue Mar 19 17:56:03 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (build_throw): Support minimal parse.\n+\t* pt.c (tsubst_copy): Support THROW_EXPR.\n+\t* decl2.c (build_expr_from_tree): Ditto.\n+\n+\t* pt.c (mangle_class_name_for_template): Always allocate\n+ \tscratch_firstobj.\n+\n+Tue Mar 19 16:34:31 1996  Bob Manson  <manson@beauty.cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Give an appropriate error\n+\twhen trying to cast from an incomplete type.\n+\n+Tue Mar 19 16:00:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Don't bother setting up\n+ \tCLASSTYPE_TAGS explicitly, as the nested types will add\n+ \tthemselves.\n+\n+Tue Mar 19 15:48:43 1996  Bob Manson  <manson@beauty.cygnus.com>\n+\n+\t* decl.c (shadow_tag): Remove old error check for usage of\n+\tan enum without a previous declaration.\n+\t(xref_tag): Add error message about usage of enums without a\n+\tprevious declaration.\n+\n+Tue Mar 19 09:21:35 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (do_identifier): Only do name consistency check if we're\n+ \tparsing.\n+\n+\t* pt.c (push_template_decl): Don't crash if we get a member defn\n+\tthat doesn't match.\n+\n+\t* decl.c (xref_tag_from_type): New function to do an xref without\n+ \talways having to figure out code_type_node.\n+\t* cp-tree.h: Declare it.\n+\t* pt.c (instantiate_class_template): Use it for friend classes.\n+  \t(lookup_template_class): Use it.\n+\n+\t* typeck2.c (build_functional_cast): Pull out a single parm before\n+ \tpassing it to build_c_cast.\n+\n+Tue Mar 19 09:07:15 1996  Bob Manson  <manson@beauty.cygnus.com>\n+\n+\t* expr.c (do_case): Give an error message if a pointer is\n+\tgiven as a case value.\n+\n+Mon Mar 18 21:57:54 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_c_cast): Don't pull single TEMPLATE_DECL out of\n+ \tan overload list.\n+\n+\t* lex.c (cons_up_default_function): Really, now, interface hackery\n+ \tdoes not apply to synthesized methods.\n+\n+Mon Mar 18 18:20:57 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_method_call): Ctors and dtors now have special names\n+\twith respect to lookups.\n+\t* class.c (add_method): Ditto.\n+\t(grow_method): Ditto.\n+\t(finish_struct_methods): Ditto.\n+\t(warn_hidden): Ditto.\n+\t(finish_struct_1): Ditto.\n+\t* cvt.c (convert_to_reference): Ditto.\n+\t(convert_to_aggr): Ditto.\n+\t(cp_convert): Ditto.\n+\t* decl2.c (check_classfn): Ditto.\n+\t* init.c (expand_member_init): Ditto.\n+\t(expand_default_init): Ditto.\n+\t(expand_aggr_init_1): Ditto.\n+\t(build_offset_ref): Ditto.\n+\t(build_new): Ditto.\n+\t(build_delete): Ditto.\n+\t* lex.c (do_inline_function_hair): Ditto.\n+\t* search.c (lookup_field_1): Ditto.\n+\t(lookup_fnfields_here): Ditto.\n+\t(lookup_field): Ditto.\n+\t(lookup_fnfields): Ditto.\n+\t(get_virtual_destructor): Ditto.\n+\t(dfs_debug_mark): Ditto.\n+\t(dfs_pushdecls): Ditto.\n+\t(dfs_compress_decls): Ditto.\n+\t* tree.c (layout_basetypes): Ditto.\n+\t* typeck.c (build_component_ref): Ditto.\n+\t(build_x_function_call): Ditto.\n+\t(build_modify_expr): Ditto.\n+\t(convert_for_initialization): Ditto.\n+\t(build_functional_cast): Ditto.\n+\t* cp-tree.h (CLASSTYPE_FIRST_CONVERSION): Ditto.\n+\t(CTOR_NAME): New.\n+\t(DTOR_NAME): New.\n+\t* decl.c (ctor_identifier): New.\n+\t(dtor_identifier): New.\n+\t(init_decl_processing): Set them.\n+\n+Mon Mar 18 18:00:51 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Don't get confused by fields whose\n+\tcontext has no type name, like pointer to member functions.\n+\n+Mon Mar 18 13:19:03 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Handle typedef without declarator.\n+\n+\t* pt.c (tsubst): Handle SCOPE_REF in declarator.\n+\n+\t* parse.y (bad_parm): Catch another case of missing `typename'.\n+\n+\t* lex.c (yyprint): Handle TYPE_DECLs.\n+\n+\t* decl.c (start_function): Don't try to be clever.\n+\n+\t* lex.c: Lose compiler_error_with_decl.\n+\t* typeck2.c: Lose error_with_aggr_type.\n+\t(incomplete_type_error): Use cp_* instead of old functions.\n+\t(readonly_error): Ditto.\n+\t* typeck.c (convert_arguments): Ditto.\n+\t* search.c (lookup_nested_field): Ditto.\n+\t* method.c (make_thunk): Ditto.\n+\t* decl.c (grokparms): Ditto.\n+\t* cp-tree.h: Update.\n+\n+\t* tree.c (min_tree_cons): Call copy_to_permanent for the purpose\n+ \tand value.\n+\n+Mon Mar 18 11:25:52 1996  Bob Manson  <manson@beauty.cygnus.com>\n+\n+\t* method.c (build_opfncall): When deleting a pointer to an\n+\tarray, build a new pointer to the tree past any ARRAY_TYPE\n+\tnodes.\n+\n+Mon Mar 18 10:11:46 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Initialize local var TYPE to NULL_TREE.\n+\n+Fri Mar 15 11:03:57 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_decl): Only call import_export_decl if at_eof\n+ \tand ! DECL_INLINE.\n+\n+\t* decl.c (finish_function): Don't set nested based on\n+ \thack_decl_function_context.\n+\t* parse.y (function_try_block): Check for nested function.\n+\t(pending_inlines): Ditto.\n+\n+\t* decl2.c (build_expr_from_tree): If a unary op already has a\n+ \ttype, just return it.\n+\n+\t* decl2.c (finish_prevtable_vardecl): Use ADJUST_VTABLE_LINKAGE.\n+\n+\t* decl2.c (walk_vtables): vardecl_fn returns int; return 1 if it does.\n+\t(finish_file): Check the return value of walk_vtables.\n+\t(finish_prevtable_vardecl): Return int.\n+\t(finish_vtable_vardecl): Ditto.\n+\t(prune_vtable_vardecl): Ditto.\n+\t* lex.c (set_vardecl_interface_info): Ditto.\n+\t* cp-tree.h: Adjust return types.\n+\n+\t* class.c (delete_duplicate_fields_1): Don't complain about\n+ \tduplicate nested types if they're the same type.\n+\t(finish_struct): Remove check for duplicate.\n+\t* decl2.c (grokfield): Don't check for typedef of anonymous type.\n+\n+Thu Mar 14 10:00:19 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h: Lose SIGNATURE_GROKKING_TYPEDEF.\n+\n+\t* decl.c (grokdeclarator): Lose special handling of class-level\n+ \ttypedef.  Lose SIGNATURE_GROKKING_TYPEDEF.  Set\n+ \tSIGNATURE_HAS_OPAQUE_TYPEDECLS later.\n+\n+\t* cvt.c (convert_pointer_to_real): Retain cv-quals in conversion.\n+\n+\t* pt.c (tsubst_copy): Strip cv-quals from destructor name types.\n+\n+\t* search.c (compute_access): Fix handling of anonymous union\n+ \tmembers.\n+\t* class.c (finish_struct_anon): Propagate TREE_{PRIVATE,PROTECTED}\n+ \tfrom anonymous unions to their members.\n+\n+\t* typeck.c (build_x_function_call): For static member functions,\n+ \thand off to build_member_call.\n+\n+Wed Mar 13 14:03:34 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Handle OFFSET_REFs.\n+\n+\t* init.c (expand_vec_init): Fix init == 0 case.\n+\n+Tue Mar 12 14:36:02 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_new): Pedwarn about init and array new.\n+\t(expand_vec_init): Handle lists, use convert_for_initialization\n+\n+\t* typeck.c (convert_for_initialization): Pass LOOKUP_NO_CONVERSION\n+ \twhen converting to an aggregate type.\n+\t* cvt.c (cp_convert): Pass it through.\n+\n+\t* typeck.c (build_conditional_expr): Handle user-defined\n+ \tconversions to slightly different types.\n+\n+\t* decl.c (grokdeclarator): Force an array type in a parm to be\n+ \tpermanent.\n+\n+\t* decl2.c (do_using_directive): Sorry.\n+\t(do_namespace_alias): Ditto.\n+\t* lex.c (real_yylex): Warn about using the `namespace' keyword.\n+\n+Sun Mar 10 22:26:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (datadef): Move call to note_list_got_semicolon up.\n+\n Fri Mar  8 11:47:26 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* tree.c (unsave_expr): Don't unsave, UNSAVE_EXPRs."}, {"sha": "5f0560f39916972e9566b60c4ec1996bcc9cbbb7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 54, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1745,11 +1745,15 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t;\n       /* call to a constructor... */\n       else if (basetype_path)\n-\tbasetype = BINFO_TYPE (basetype_path);\n+\t{\n+\t  basetype = BINFO_TYPE (basetype_path);\n+\t  if (name == DECL_NAME (TYPE_NAME (basetype)))\n+\t    name = ctor_identifier;\n+\t}\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n \t{\n \t  basetype = IDENTIFIER_TYPE_VALUE (name);\n-\t  name = constructor_name (basetype);\n+\t  name = ctor_identifier;\n \t}\n       else\n \t{\n@@ -1758,7 +1762,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    {\n \t      /* Canonicalize the typedef name.  */\n \t      basetype = TREE_TYPE (typedef_name);\n-\t      name = TYPE_IDENTIFIER (basetype);\n+\t      name = ctor_identifier;\n \t    }\n \t  else\n \t    {\n@@ -2046,14 +2050,17 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   /* Look up function name in the structure type definition.  */\n \n+  /* FIXME Axe most of this now?  */\n   if ((IDENTIFIER_HAS_TYPE_VALUE (name)\n        && ! IDENTIFIER_OPNAME_P (name)\n        && IS_AGGR_TYPE (IDENTIFIER_TYPE_VALUE (name)))\n-      || name == constructor_name (basetype))\n+      || name == constructor_name (basetype)\n+      || name == ctor_identifier)\n     {\n       tree tmp = NULL_TREE;\n       if (IDENTIFIER_TYPE_VALUE (name) == basetype\n-\t  || name == constructor_name (basetype))\n+\t  || name == constructor_name (basetype)\n+\t  || name == ctor_identifier)\n \ttmp = TYPE_BINFO (basetype);\n       else\n \ttmp = get_binfo (IDENTIFIER_TYPE_VALUE (name), basetype, 0);\n@@ -2092,30 +2099,13 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (result == error_mark_node)\n     return error_mark_node;\n \n-\n-#if 0\n-  /* Now, go look for this method name.  We do not find destructors here.\n-\n-     Putting `void_list_node' on the end of the parmtypes\n-     fakes out `build_decl_overload' into doing the right thing.  */\n-  TREE_CHAIN (last) = void_list_node;\n-  method_name = build_decl_overload (name, parmtypes,\n-\t\t\t\t     1 + (name == constructor_name (save_basetype)\n-\t\t\t\t\t  || name == constructor_name_full (save_basetype)));\n-  TREE_CHAIN (last) = NULL_TREE;\n-#endif\n-\n   for (pass = 0; pass < 2; pass++)\n     {\n       struct candidate *candidates;\n       struct candidate *cp;\n       int len;\n       unsigned best = 1;\n \n-      /* This increments every time we go up the type hierarchy.\n-\t The idea is to prefer a function of the derived class if possible. */\n-      int b_or_d = 0;\n-\n       baselink = result;\n \n       if (pass > 0)\n@@ -2167,7 +2157,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    }\n \t}\n \n-      while (baselink)\n+      if (baselink)\n \t{\n \t  /* We have a hit (of sorts). If the parameter list is\n \t     \"error_mark_node\", or some variant thereof, it won't\n@@ -2183,30 +2173,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype_path = TREE_VALUE (basetype_path);\n \t  basetype = BINFO_TYPE (basetype_path);\n \n-#if 0\n-\t  /* Cast the instance variable if necessary.  */\n-\t  if (basetype != TYPE_MAIN_VARIANT\n-\t      (TREE_TYPE (TREE_TYPE (TREE_VALUE (parms)))))\n-\t    {\n-\t      if (basetype == save_basetype)\n-\t\tTREE_VALUE (parms) = instance_ptr;\n-\t      else\n-\t\t{\n-\t\t  tree type = build_pointer_type\n-\t\t    (build_type_variant (basetype, constp, volatilep));\n-\t\t  TREE_VALUE (parms) = convert_force (type, instance_ptr, 0);\n-\t\t}\n-\t    }\n-\n-\t  /* FIXME: this is the wrong place to get an error.  Hopefully\n-\t     the access-control rewrite will make this change more cleanly.  */\n-\t  if (TREE_VALUE (parms) == error_mark_node)\n-\t    return error_mark_node;\n-#endif\n-\n-\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function)))\n-\t    function = DECL_CHAIN (function);\n-\n \t  for (; function; function = DECL_CHAIN (function))\n \t    {\n #ifdef GATHER_STATISTICS\n@@ -2263,14 +2229,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t    }\n \t\t}\n \t    }\n-\t  /* Now we have run through one link's member functions.\n-\t     arrange to head-insert this link's links.  */\n-\t  baselink = next_baselink (baselink);\n-\t  b_or_d += 1;\n-\t  /* Don't grab functions from base classes.  lookup_fnfield will\n-\t     do the work to get us down into the right place.  */\n-\t  baselink = NULL_TREE;\n \t}\n+\n       if (pass == 0)\n \t{\n \t  tree igv = lookup_name_nonclass (name);"}, {"sha": "ffe0104656e082eb971025890b90faf889785943", "filename": "gcc/cp/class.c", "status": "modified", "additions": 95, "deletions": 134, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -932,18 +932,26 @@ add_method (type, fields, method)\n       tree method_vec = make_node (TREE_VEC);\n       if (TYPE_IDENTIFIER (type) == DECL_NAME (decl))\n \t{\n-\t  TREE_VEC_ELT (method_vec, 0) = decl;\n-\t  TREE_VEC_LENGTH (method_vec) = 1;\n+\t  /* ??? Is it possible for there to have been enough room in the\n+\t     current chunk for the tree_vec structure but not a tree_vec\n+\t     plus a tree*?  Will this work in that case?  */\n+\t  obstack_free (current_obstack, method_vec);\n+\t  obstack_blank (current_obstack, sizeof (struct tree_vec) + sizeof (tree *));\n+\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))\n+\t    TREE_VEC_ELT (method_vec, 1) = decl;\n+\t  else\n+\t    TREE_VEC_ELT (method_vec, 0) = decl;\n+\t  TREE_VEC_LENGTH (method_vec) = 2;\n \t}\n       else\n \t{\n \t  /* ??? Is it possible for there to have been enough room in the\n \t     current chunk for the tree_vec structure but not a tree_vec\n \t     plus a tree*?  Will this work in that case?  */\n \t  obstack_free (current_obstack, method_vec);\n-\t  obstack_blank (current_obstack, sizeof (struct tree_vec) + sizeof (tree *));\n-\t  TREE_VEC_ELT (method_vec, 1) = decl;\n-\t  TREE_VEC_LENGTH (method_vec) = 2;\n+\t  obstack_blank (current_obstack, sizeof (struct tree_vec) + 2*sizeof (tree *));\n+\t  TREE_VEC_ELT (method_vec, 2) = decl;\n+\t  TREE_VEC_LENGTH (method_vec) = 3;\n \t  obstack_finish (current_obstack);\n \t}\n       CLASSTYPE_METHOD_VEC (type) = method_vec;\n@@ -957,11 +965,12 @@ add_method (type, fields, method)\n          METHOD_VEC always has a slot for such entries.  */\n       if (TYPE_IDENTIFIER (type) == DECL_NAME (decl))\n \t{\n-\t  /* TREE_VEC_ELT (method_vec, 0) = decl; */\n-\t  if (decl != TREE_VEC_ELT (method_vec, 0))\n+\t  int index = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl));\n+\t  /* TREE_VEC_ELT (method_vec, index) = decl; */\n+\t  if (decl != TREE_VEC_ELT (method_vec, index))\n \t    {\n-\t      DECL_CHAIN (decl) = TREE_VEC_ELT (method_vec, 0);\n-\t      TREE_VEC_ELT (method_vec, 0) = decl;\n+\t      DECL_CHAIN (decl) = TREE_VEC_ELT (method_vec, index);\n+\t      TREE_VEC_ELT (method_vec, index) = decl;\n \t    }\n \t}\n       else\n@@ -1085,7 +1094,11 @@ delete_duplicate_fields_1 (field, fields)\n \t\t\t\tx);\n \t\t  else if (TREE_CODE (field) == TYPE_DECL\n \t\t\t   && TREE_CODE (x) == TYPE_DECL)\n-\t\t    cp_error_at (\"duplicate nested type `%D'\", x);\n+\t\t    {\n+\t\t      if (TREE_TYPE (field) == TREE_TYPE (x))\n+\t\t\tcontinue;\n+\t\t      cp_error_at (\"duplicate nested type `%D'\", x);\n+\t\t    }\n \t\t  else if (TREE_CODE (field) == TYPE_DECL\n \t\t\t   || TREE_CODE (x) == TYPE_DECL)\n \t\t    {\n@@ -1756,57 +1769,56 @@ finish_struct_bits (t, max_has_virtual)\n     }\n }\n \n-/* Add FN to the method_vec growing on the class_obstack.  Used by\n-   finish_struct_methods.  */\n+/* Add FNDECL to the method_vec growing on the class_obstack.  Used by\n+   finish_struct_methods.  Note, FNDECL cannot be a constructor or\n+   destructor, those cases are handled by the caller.  */\n static void\n-grow_method (fn, method_vec_ptr)\n-     tree fn;\n+grow_method (fndecl, method_vec_ptr)\n+     tree fndecl;\n      tree *method_vec_ptr;\n {\n   tree method_vec = (tree)obstack_base (&class_obstack);\n-  tree *testp = &TREE_VEC_ELT (method_vec, 0);\n-  if (*testp == NULL_TREE)\n-    testp++;\n-  while (((HOST_WIDE_INT) testp\n-\t  < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n-\t && DECL_NAME (*testp) != DECL_NAME (fn))\n+\n+  /* Start off past the constructors and destructor.  */\n+  tree *testp = &TREE_VEC_ELT (method_vec, 2);\n+\n+  while (testp < (tree *) obstack_next_free (&class_obstack)\n+\t && (*testp == NULL_TREE || DECL_NAME (*testp) != DECL_NAME (fndecl)))\n     testp++;\n-  if ((HOST_WIDE_INT) testp\n-      < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n+\n+  if (testp < (tree *) obstack_next_free (&class_obstack))\n     {\n       tree x, prev_x;\n \n       for (x = *testp; x; x = DECL_CHAIN (x))\n \t{\n-\t  if (DECL_NAME (fn) == ansi_opname[(int) DELETE_EXPR]\n-\t      || DECL_NAME (fn) == ansi_opname[(int) VEC_DELETE_EXPR])\n+\t  if (DECL_NAME (fndecl) == ansi_opname[(int) DELETE_EXPR]\n+\t      || DECL_NAME (fndecl) == ansi_opname[(int) VEC_DELETE_EXPR])\n \t    {\n \t      /* ANSI C++ June 5 1992 WP 12.5.5.1 */\n-\t      cp_error_at (\"`%D' overloaded\", fn);\n+\t      cp_error_at (\"`%D' overloaded\", fndecl);\n \t      cp_error_at (\"previous declaration as `%D' here\", x);\n \t    }\n-\t  if (DECL_ASSEMBLER_NAME (fn)==DECL_ASSEMBLER_NAME (x))\n+\t  if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (x))\n \t    {\n-\t      /* We complain about multiple destructors on sight,\n-\t\t so we do not repeat the warning here.  Friend-friend\n-\t\t ambiguities are warned about outside this loop.  */\n-\t      if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn)))\n-\t\tcp_error_at (\"ambiguous method `%#D' in structure\", fn);\n+\t      /* Friend-friend ambiguities are warned about outside\n+\t\t this loop.  */\n+\t      cp_error_at (\"ambiguous method `%#D' in structure\", fndecl);\n \t      break;\n \t    }\n \t  prev_x = x;\n \t}\n       if (x == 0)\n \t{\n \t  if (*testp)\n-\t    DECL_CHAIN (prev_x) = fn;\n+\t    DECL_CHAIN (prev_x) = fndecl;\n \t  else\n-\t    *testp = fn;\n+\t    *testp = fndecl;\n \t}\n     }\n   else\n     {\n-      obstack_ptr_grow (&class_obstack, fn);\n+      obstack_ptr_grow (&class_obstack, fndecl);\n       *method_vec_ptr = (tree)obstack_base (&class_obstack);\n     }\n }\n@@ -1842,27 +1854,27 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n {\n   tree method_vec;\n   tree save_fn_fields = fn_fields;\n-  tree name = constructor_name (t);\n+  tree ctor_name = constructor_name (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n   /* Now prepare to gather fn_fields into vector.  */\n   struct obstack *ambient_obstack = current_obstack;\n   current_obstack = &class_obstack;\n-  method_vec = make_node (TREE_VEC);\n-  /* Room has been saved for constructors and destructors.  */\n+  method_vec = make_tree_vec (2);\n   current_obstack = ambient_obstack;\n+\n   /* Now make this a live vector.  */\n   obstack_free (&class_obstack, method_vec);\n-  obstack_blank (&class_obstack, sizeof (struct tree_vec));\n \n-  /* First fill in entry 0 with the constructors, and the next few with\n-     type conversion operators (if any).  */\n+  /* Save room for constructors and destructors.  */\n+  obstack_blank (&class_obstack, sizeof (struct tree_vec) + sizeof (struct tree *));\n+\n+  /* First fill in entry 0 with the constructors, entry 1 with destructors,\n+     and the next few with type conversion operators (if any).  */\n \n   for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n     {\n       tree fn_name = DECL_NAME (fn_fields);\n-      if (fn_name == NULL_TREE)\n-\tfn_name = name;\n \n       /* Clear out this flag.\n \n@@ -1873,7 +1885,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n       /* Note here that a copy ctor is private, so we don't dare generate\n  \t a default copy constructor for a class that has a member\n  \t of this type without making sure they have access to it.  */\n-      if (fn_name == name)\n+      if (fn_name == ctor_name)\n  \t{\n  \t  tree parmtypes = FUNCTION_ARG_CHAIN (fn_fields);\n  \t  tree parmtype = parmtypes ? TREE_VALUE (parmtypes) : void_type_node;\n@@ -1891,9 +1903,18 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n  \t\t    TYPE_HAS_NONPUBLIC_CTOR (t) = 2;\n  \t\t}\n  \t    }\n-\t  /* Constructors are handled easily in search routines.  */\n-\t  DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n-\t  TREE_VEC_ELT (method_vec, 0) = fn_fields;\n+\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn_fields)))\n+\t    {\t    \n+\t      /* Destructors go in slot 1.  */\n+\t      DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 1);\n+\t      TREE_VEC_ELT (method_vec, 1) = fn_fields;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Constructors go in slot 0.  */\n+\t      DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n+\t      TREE_VEC_ELT (method_vec, 0) = fn_fields;\n+\t    }\n  \t}\n       else if (IDENTIFIER_TYPENAME_P (fn_name))\n \t{\n@@ -1914,10 +1935,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n     {\n       tree fn_name = DECL_NAME (fn_fields);\n-      if (fn_name == NULL_TREE)\n-\tfn_name = name;\n \n-      if (fn_name == name || IDENTIFIER_TYPENAME_P (fn_name))\n+      if (fn_name == ctor_name || IDENTIFIER_TYPENAME_P (fn_name))\n \tcontinue;\n \n       if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n@@ -1957,53 +1976,35 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tcp_warning (\"all member functions in class `%T' are private\", t);\n     }\n \n-  /* If there are constructors (and destructors), they are at the\n-     front.  Place destructors at very front.  Also warn if all\n-     constructors and/or destructors are private (in which case this\n-     class is effectively unusable.  */\n+  /* Warn if all destructors are private (in which case this class is\n+     effectively unusable.  */\n   if (TYPE_HAS_DESTRUCTOR (t))\n     {\n-      tree dtor, prev;\n-\n-      for (dtor = TREE_VEC_ELT (method_vec, 0);\n-\t   dtor;\n-\t   prev = dtor, dtor = DECL_CHAIN (dtor))\n-\t{\n-\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (dtor)))\n-\t    {\n-\t      if (TREE_PRIVATE (dtor)\n-\t\t  && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-\t\t  && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE\n-\t\t  && warn_ctor_dtor_privacy)\n-\t\tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n-\t\t\t    t);\n-\t      break;\n-\t    }\n-\t}\n+      tree dtor = TREE_VEC_ELT (method_vec, 1);\n \n       /* Wild parse errors can cause this to happen.  */\n       if (dtor == NULL_TREE)\n \tTYPE_HAS_DESTRUCTOR (t) = 0;\n-      else if (dtor != TREE_VEC_ELT (method_vec, 0))\n-\t{\n-\t  DECL_CHAIN (prev) = DECL_CHAIN (dtor);\n-\t  DECL_CHAIN (dtor) = TREE_VEC_ELT (method_vec, 0);\n-\t  TREE_VEC_ELT (method_vec, 0) = dtor;\n-\t}\n+      else if (TREE_PRIVATE (dtor)\n+\t       && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n+\t       && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE\n+\t       && warn_ctor_dtor_privacy)\n+\tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t\t    t);\n     }\n \n   /* Now for each member function (except for constructors and\n      destructors), compute where member functions of the same\n      name reside in base classes.  */\n   if (n_baseclasses != 0\n-      && TREE_VEC_LENGTH (method_vec) > 1)\n+      && TREE_VEC_LENGTH (method_vec) > 2)\n     {\n       int len = TREE_VEC_LENGTH (method_vec);\n       tree baselink_vec = make_tree_vec (len);\n       int any_links = 0;\n       tree baselink_binfo = build_tree_list (NULL_TREE, TYPE_BINFO (t));\n \n-      for (i = 1; i < len; i++)\n+      for (i = 2; i < len; i++)\n \t{\n \t  TREE_VEC_ELT (baselink_vec, i)\n \t    = get_baselinks (baselink_binfo, t, DECL_NAME (TREE_VEC_ELT (method_vec, i)));\n@@ -2016,44 +2017,6 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tobstack_free (current_obstack, baselink_vec);\n     }\n \n-#if 0\n-  /* Now add the methods to the TYPE_METHODS of T, arranged in a chain.  */\n-  {\n-    tree x, last_x = NULL_TREE;\n-    int limit = TREE_VEC_LENGTH (method_vec);\n-\n-    for (i = 1; i < limit; i++)\n-      {\n-\tfor (x = TREE_VEC_ELT (method_vec, i); x; x = DECL_CHAIN (x))\n-\t  {\n-\t    if (last_x != NULL_TREE)\n-\t      TREE_CHAIN (last_x) = x;\n-\t    last_x = x;\n-\t  }\n-      }\n-\n-    /* Put ctors and dtors at the front of the list.  */\n-    x = TREE_VEC_ELT (method_vec, 0);\n-    if (x)\n-      {\n-\twhile (DECL_CHAIN (x))\n-\t  {\n-\t    /* Let's avoid being circular about this.  */\n-\t    if (x == DECL_CHAIN (x))\n-\t      break;\n-\t    TREE_CHAIN (x) = DECL_CHAIN (x);\n-\t    x = DECL_CHAIN (x);\n-\t  }\n-\tif (TREE_VEC_LENGTH (method_vec) > 1)\n-\t  TREE_CHAIN (x) = TREE_VEC_ELT (method_vec, 1);\n-\telse\n-\t  TREE_CHAIN (x) = NULL_TREE;\n-      }\n-  }\n-\n-  TYPE_METHODS (t) = method_vec;\n-#endif\n-\n   return method_vec;\n }\n \n@@ -2077,17 +2040,17 @@ duplicate_tag_error (t)\n    * This used to be in finish_struct, but it turns out that the\n    * TREE_CHAIN is used by dbxout_type_methods and perhaps some other things...\n    */\n-  if (CLASSTYPE_METHOD_VEC(t)) \n+  if (CLASSTYPE_METHOD_VEC (t)) \n     {\n-      tree tv = CLASSTYPE_METHOD_VEC(t);\n-      int i, len  = TREE_VEC_LENGTH (tv);\n+      tree method_vec = CLASSTYPE_METHOD_VEC (t);\n+      int i, len  = TREE_VEC_LENGTH (method_vec);\n       for (i = 0; i < len; i++)\n \t{\n-\t  tree unchain = TREE_VEC_ELT (tv, i);\n+\t  tree unchain = TREE_VEC_ELT (method_vec, i);\n \t  while (unchain != NULL_TREE) \n \t    {\n \t      TREE_CHAIN (unchain) = NULL_TREE;\n-\t      unchain = DECL_CHAIN(unchain);\n+\t      unchain = DECL_CHAIN (unchain);\n \t    }\n \t}\n     }\n@@ -2829,7 +2792,8 @@ check_for_override (decl, ctype)\n     }\n }\n \n-/* Warn about hidden virtual functions that are not overridden in t.  */\n+/* Warn about hidden virtual functions that are not overridden in t.\n+   We know that constructors and destructors don't apply.  */\n void\n warn_hidden (t)\n      tree t;\n@@ -2839,7 +2803,7 @@ warn_hidden (t)\n   int i;\n \n   /* We go through each separately named virtual function.  */\n-  for (i = 1; i < n_methods; ++i)\n+  for (i = 2; i < n_methods; ++i)\n     {\n       tree fndecl = TREE_VEC_ELT (method_vec, i);\n \n@@ -2927,6 +2891,9 @@ finish_struct_anon (t)\n \t      else if (TREE_PROTECTED (*uelt))\n \t\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n \t\t\t       *uelt);\n+\n+\t      TREE_PRIVATE (*uelt) = TREE_PRIVATE (field);\n+\t      TREE_PROTECTED (*uelt) = TREE_PROTECTED (field);\n \t    }\n \t}\n     }\n@@ -3692,8 +3659,8 @@ finish_struct_1 (t, attributes, warn_anon)\n \ttree fdecl = TREE_VALUE (access_decls);\n \ttree flist = NULL_TREE;\n \ttree name;\n-\ttree access = TREE_PURPOSE(access_decls);\n-\tint i = TREE_VEC_ELT (method_vec, 0) ? 0 : 1;\n+\ttree access = TREE_PURPOSE (access_decls);\n+\tint i = 2;\n \ttree tmp;\n \n \tif (TREE_CODE (fdecl) == TREE_LIST)\n@@ -3811,9 +3778,11 @@ finish_struct_1 (t, attributes, warn_anon)\n       for (x = fields; x; x = TREE_CHAIN (x))\n \t{\n \t  tree name = DECL_NAME (x);\n-\t  int i = /*TREE_VEC_ELT (method_vec, 0) ? 0 : */ 1;\n+\t  int i = 2;\n+\n \t  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x))\n \t    continue;\n+\n \t  for (; i < n_methods; ++i)\n \t    if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n \t      {\n@@ -4368,14 +4337,6 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t{\n \t  tree tag = TYPE_NAME (TREE_VALUE (x));\n \n-\t  /* Check to see if it is already there.  This will be the case if\n-\t     was do enum { red; } color; */\n-\t  if (chain_member (tag, fields))\n-\t      {\n-\t\tx = TREE_CHAIN (x);\n-\t\tcontinue;\n-\t      }\n-\n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n \t    {"}, {"sha": "7d9f12cf96e4f2ed8ff7a94bdc14935af06b84fe", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -427,9 +427,9 @@ struct lang_type\n       unsigned marked4 : 1;\n       unsigned marked5 : 1;\n       unsigned marked6 : 1;\n+      unsigned debug_requested : 1;\n \n       unsigned use_template : 2;\n-      unsigned debug_requested : 1;\n       unsigned has_method_call_overloaded : 1;\n       unsigned private_attr : 1;\n       unsigned got_semicolon : 1;\n@@ -439,14 +439,13 @@ struct lang_type\n \n       unsigned is_signature_reference : 1;\n       unsigned has_default_implementation : 1;\n-      unsigned grokking_typedef : 1;\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n       unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n-\n       unsigned has_const_init_ref : 1;\n+\n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n@@ -455,7 +454,7 @@ struct lang_type\n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 19;\n+      unsigned dummy : 20;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -475,7 +474,7 @@ struct lang_type\n   union tree_node *tags;\n   char *memoized_table_entry;\n \n-  char *search_slot;\n+  union tree_node *search_slot;\n \n #ifdef ONLY_INT_FIELDS\n   unsigned int mode : 8;\n@@ -604,9 +603,6 @@ struct lang_type\n /* Nonzero means that this signature type has a default implementation.  */\n # define HAS_DEFAULT_IMPLEMENTATION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_implementation)\n \n-/* Nonzero means that grokdeclarator works on a signature-local typedef.  */\n-#define SIGNATURE_GROKKING_TYPEDEF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.grokking_typedef)\n-\n /* Nonzero means that this signature contains opaque type declarations.  */\n #define SIGNATURE_HAS_OPAQUE_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_opaque_typedecls)\n \n@@ -664,8 +660,8 @@ struct lang_type\n    searched with TREE_CHAIN), or the first non-constructor function if\n    there are no type conversion operators.  */\n #define CLASSTYPE_FIRST_CONVERSION(NODE) \\\n-  TREE_VEC_LENGTH (CLASSTYPE_METHOD_VEC (NODE)) > 1 \\\n-    ? TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 1) \\\n+  TREE_VEC_LENGTH (CLASSTYPE_METHOD_VEC (NODE)) > 2 \\\n+    ? TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 2) \\\n     : NULL_TREE;\n \n /* Pointer from any member function to the head of the list of\n@@ -1491,6 +1487,7 @@ extern tree __ptmf_desc_type_node, __ptmd_desc_type_node;\n extern tree type_info_type_node;\n extern tree class_star_type_node;\n extern tree this_identifier;\n+extern tree ctor_identifier, dtor_identifier;\n extern tree pfn_identifier;\n extern tree index_identifier;\n extern tree delta_identifier;\n@@ -1675,6 +1672,8 @@ extern int current_function_parms_stored;\n #define THIS_NAME \"this\"\n #define DESTRUCTOR_NAME_FORMAT \"~%s\"\n #define FILE_FUNCTION_PREFIX_LEN 9\n+#define CTOR_NAME \"__ct\"\n+#define DTOR_NAME \"__dt\"\n \n #define IN_CHARGE_NAME \"__in_chrg\"\n \n@@ -2047,6 +2046,7 @@ extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n /* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n+extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n@@ -2099,7 +2099,7 @@ extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void import_export_vtable\t\tPROTO((tree, tree, int));\n-extern void walk_vtables\t\t\tPROTO((void (*)(), void (*)()));\n+extern int walk_vtables\t\t\t\tPROTO((void (*)(), int (*)()));\n extern void walk_sigtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void finish_file\t\t\t\tPROTO((void));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n@@ -2203,7 +2203,7 @@ extern void reinit_parse_for_function\t\tPROTO((void));\n extern int *init_parse\t\t\t\tPROTO((void));\n extern void print_parse_statistics\t\tPROTO((void));\n extern void extract_interface_info\t\tPROTO((void));\n-extern void set_vardecl_interface_info\t\tPROTO((tree, tree));\n+extern int set_vardecl_interface_info\t\tPROTO((tree, tree));\n extern void do_pending_inlines\t\t\tPROTO((void));\n extern void process_next_inline\t\t\tPROTO((tree));\n /* skip restore_pending_input */\n@@ -2231,7 +2231,6 @@ extern tree make_lang_type\t\t\tPROTO((enum tree_code));\n extern void copy_decl_lang_specific\t\tPROTO((tree));\n extern void dump_time_statistics\t\tPROTO((void));\n /* extern void compiler_error\t\t\tPROTO((char *, HOST_WIDE_INT, HOST_WIDE_INT)); */\n-extern void compiler_error_with_decl\t\tPROTO((tree, char *));\n extern void yyerror\t\t\t\tPROTO((char *));\n \n /* in errfn.c */\n@@ -2472,7 +2471,6 @@ extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n-extern void error_with_aggr_type\t\t(); /* PROTO((tree, char *, HOST_WIDE_INT)); */\n extern void readonly_error\t\t\tPROTO((tree, char *, int));\n extern void abstract_virtuals_error\t\tPROTO((tree, tree));\n extern void signature_error\t\t\tPROTO((tree, tree));"}, {"sha": "f9f3dfc8e3b4511a26b33261b5a793bcdbf19561", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -201,6 +201,14 @@ cp_convert_to_pointer (type, expr)\n   if (IS_AGGR_TYPE (intype))\n     {\n       tree rval;\n+\n+      if (TYPE_SIZE (complete_type (intype)) == NULL_TREE)\n+\t{\n+\t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n+\t\t    intype, type);\n+\t  return error_mark_node;\n+\t}\n+\n       rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n       if (rval)\n \t{\n@@ -774,7 +782,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (TYPE_HAS_CONSTRUCTOR (type)\n \t  && ! CLASSTYPE_ABSTRACT_VIRTUALS (type)\n \t  && (rval = build_method_call\n-\t      (NULL_TREE, constructor_name_full (type),\n+\t      (NULL_TREE, ctor_identifier,\n \t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (type),\n \t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY\n \t       | LOOKUP_ONLYCONVERTING)))\n@@ -785,7 +793,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    {\n \t      extern tree static_aggregates;\n \t      tree t = get_temp_name (type, toplevel_bindings_p ());\n-\t      init = build_method_call (t, constructor_name_full (type),\n+\t      init = build_method_call (t, ctor_identifier,\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n@@ -800,7 +808,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    }\n \t  else\n \t    {\n-\t      init = build_method_call (NULL_TREE, constructor_name_full (type),\n+\t      init = build_method_call (NULL_TREE, ctor_identifier,\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n@@ -919,47 +927,9 @@ convert_to_aggr (type, expr, msgp, protect)\n   parmlist = tree_cons (NULL_TREE, integer_zero_node, parmlist);\n   parmtypes = tree_cons (NULL_TREE, build_pointer_type (basetype), parmtypes);\n \n-#if 0\n-  method_name = build_decl_overload (name, parmtypes, 1);\n-\n-  /* constructors are up front.  */\n-  fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n-  if (TYPE_HAS_DESTRUCTOR (basetype))\n-    fndecl = DECL_CHAIN (fndecl);\n-\n-  while (fndecl)\n-    {\n-      if (DECL_ASSEMBLER_NAME (fndecl) == method_name)\n-\t{\n-\t  function = fndecl;\n-\t  if (protect)\n-\t    {\n-\t      if (TREE_PRIVATE (fndecl))\n-\t\t{\n-\t\t  can_be_private =\n-\t\t    (basetype == current_class_type\n-\t\t     || is_friend (basetype, current_function_decl)\n-\t\t     || purpose_member (basetype, DECL_ACCESS (fndecl)));\n-\t\t  if (! can_be_private)\n-\t\t    goto found;\n-\t\t}\n-\t      else if (TREE_PROTECTED (fndecl))\n-\t\t{\n-\t\t  if (! can_be_protected)\n-\t\t    goto found;\n-\t\t}\n-\t    }\n-\t  goto found_and_ok;\n-\t}\n-      fndecl = DECL_CHAIN (fndecl);\n-    }\n-#endif\n-\n   /* No exact conversion was found.  See if an approximate\n      one will do.  */\n   fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n-  if (TYPE_HAS_DESTRUCTOR (basetype))\n-    fndecl = DECL_CHAIN (fndecl);\n \n   {\n     int saw_private = 0;\n@@ -1119,7 +1089,9 @@ convert_pointer_to_real (binfo, expr)\n       binfo = NULL_TREE;\n     }\n \n-  ptr_type = build_pointer_type (type);\n+  ptr_type = cp_build_type_variant (type, TYPE_READONLY (TREE_TYPE (intype)),\n+\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (intype)));\n+  ptr_type = build_pointer_type (ptr_type);\n   if (ptr_type == TYPE_MAIN_VARIANT (intype))\n     return expr;\n \n@@ -1338,11 +1310,12 @@ cp_convert (type, expr, convtype, flags)\n \t}\n \n       if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n-\tctor = build_method_call (NULL_TREE, constructor_name_full (type),\n+\tctor = build_method_call (NULL_TREE, ctor_identifier,\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n \t\t\t\t  (flags & LOOKUP_NORMAL) | LOOKUP_SPECULATIVELY\n-\t\t\t\t  | (convtype&CONV_NONCONVERTING ? 0 : LOOKUP_ONLYCONVERTING)\n+\t\t\t\t  | (convtype & CONV_NONCONVERTING ? 0 : LOOKUP_ONLYCONVERTING)\n+\t\t\t\t  | (flags & LOOKUP_NO_CONVERSION)\n \t\t\t\t  | (conversion ? LOOKUP_NO_CONVERSION : 0));\n \n       if (ctor == error_mark_node)"}, {"sha": "9855baca00562c9b1f9c494ee1b4c154987aecf7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 83, "deletions": 109, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -294,6 +294,7 @@ tree base_init_expr;\n    Identifiers for `this' in member functions and the auto-delete\n    parameter for destructors.  */\n tree this_identifier, in_charge_identifier;\n+tree ctor_identifier, dtor_identifier;\n /* Used in pointer to member functions, in vtables, and in sigtables. */\n tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n tree pfn_or_delta2_identifier, tag_identifier;\n@@ -1461,11 +1462,11 @@ print_binding_level (lvl)\n       /* We can probably fit 3 names to a line?  */\n       for (t = lvl->names; t; t = TREE_CHAIN (t))\n \t{\n-\t  if (no_print_functions && (TREE_CODE(t) == FUNCTION_DECL)) \n+\t  if (no_print_functions && (TREE_CODE (t) == FUNCTION_DECL)) \n \t    continue;\n \t  if (no_print_builtins\n-\t      && (TREE_CODE(t) == TYPE_DECL)\n-\t      && (!strcmp(DECL_SOURCE_FILE(t),\"<built-in>\")))\n+\t      && (TREE_CODE (t) == TYPE_DECL)\n+\t      && (!strcmp (DECL_SOURCE_FILE (t),\"<built-in>\")))\n \t    continue;\n \n \t  /* Function decls tend to have longer names.  */\n@@ -4298,16 +4299,25 @@ lookup_namespace_name (namespace, name)\n      tree namespace, name;\n {\n   struct binding_level *b = (struct binding_level *)NAMESPACE_LEVEL (namespace);\n-  tree x;\n+  tree x = NULL_TREE;\n \n-  for (x = NULL_TREE; b && !x; b = b->level_chain)\n+#if 1\n+  /* This searches just one level.  */\n+  if (b)\n     {\n       for (x = b->names; x; x = TREE_CHAIN (x))\n \tif (DECL_NAME (x) == name || DECL_ASSEMBLER_NAME (x) == name)\n \t  break;\n-      /* Must find directly in the namespace.  */\n-      break;\n     }\n+#else\n+  /* This searches all levels.  */\n+  for (; b && !x; b = b->level_chain)\n+    {\n+      for (x = b->names; x; x = TREE_CHAIN (x))\n+\tif (DECL_NAME (x) == name || DECL_ASSEMBLER_NAME (x) == name)\n+\t  break;\n+    }\n+#endif\n   return x;\n }\n \n@@ -4370,7 +4380,7 @@ lookup_name_real (name, prefer_type, nonclass)\n   if (prefer_type == -2)\n     {\n       extern int looking_for_typename;\n-      tree type;\n+      tree type = NULL_TREE;\n \n       yylex = 1;\n       prefer_type = looking_for_typename;\n@@ -4773,6 +4783,8 @@ init_decl_processing ()\n \n   this_identifier = get_identifier (THIS_NAME);\n   in_charge_identifier = get_identifier (IN_CHARGE_NAME);\n+  ctor_identifier = get_identifier (CTOR_NAME);\n+  dtor_identifier = get_identifier (DTOR_NAME);\n   pfn_identifier = get_identifier (VTABLE_PFN_NAME);\n   index_identifier = get_identifier (VTABLE_INDEX_NAME);\n   delta_identifier = get_identifier (VTABLE_DELTA_NAME);\n@@ -5525,7 +5537,7 @@ init_type_desc()\n   tdecl = lookup_name (get_identifier (\"type_info\"), 0);\n   if (tdecl == NULL_TREE)\n     return 0;\n-  __t_desc_type_node = TREE_TYPE(tdecl);\n+  __t_desc_type_node = TREE_TYPE (tdecl);\n #if 0\n   __tp_desc_type_node = build_pointer_type (__t_desc_type_node);\n #endif\n@@ -5651,10 +5663,7 @@ shadow_tag (declspecs)\n \t{\n \t  my_friendly_assert (TYPE_NAME (value) != NULL_TREE, 261);\n \n-\t  if (code == ENUMERAL_TYPE && TYPE_SIZE (value) == 0)\n-\t    cp_error (\"forward declaration of `%#T'\", value);\n-\n-\t  else if (IS_AGGR_TYPE (value) && CLASSTYPE_USE_TEMPLATE (value))\n+\t  if (IS_AGGR_TYPE (value) && CLASSTYPE_USE_TEMPLATE (value))\n \t    {\n \t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (value)\n \t\t  && TYPE_SIZE (value) == NULL_TREE)\n@@ -7916,8 +7925,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \ttype = ctor_return_type;\n       else if (current_class_type\n \t       && IS_SIGNATURE (current_class_type)\n-\t       && (RIDBIT_SETP (RID_TYPEDEF, specbits)\n-\t\t   || SIGNATURE_GROKKING_TYPEDEF (current_class_type))\n+\t       && RIDBIT_SETP (RID_TYPEDEF, specbits)\n \t       && (decl_context == FIELD || decl_context == NORMAL))\n \t{\n \t  explicit_int = 0;\n@@ -8147,8 +8155,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n      is used in a signature member function declaration.  */\n   if (decl_context == FIELD\n       && IS_SIGNATURE (current_class_type)\n-      && RIDBIT_NOTSETP(RID_TYPEDEF, specbits)\n-      && !SIGNATURE_GROKKING_TYPEDEF (current_class_type))\n+      && RIDBIT_NOTSETP (RID_TYPEDEF, specbits))\n     {\n       if (constp)\n \t{\n@@ -8192,82 +8199,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  && (RIDBIT_SETP (RID_REGISTER, specbits)\n \t      || RIDBIT_SETP (RID_AUTO, specbits)))\n \t;\n+      else if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n+\t;\n       else if (decl_context == FIELD\n-\t       && RIDBIT_SETP (RID_TYPEDEF, specbits))\n-\t{\n-\t  /* Processing a typedef declaration nested within a class type\n-\t     definition.  */\n-\t  register tree scanner;\n-\t  register tree previous_declspec;\n-  \t  tree loc_typedecl;\n-  \n-\t  if (initialized)\n-\t    error (\"typedef declaration includes an initializer\");\n-  \n-\t  /* To process a class-local typedef declaration, we descend down\n-\t     the chain of declspecs looking for the `typedef' spec.  When\n-\t     we find it, we replace it with `static', and then recursively\n-\t     call `grokdeclarator' with the original declarator and with\n-\t     the newly adjusted declspecs.  This call should return a\n-\t     FIELD_DECL node with the TREE_TYPE (and other parts) set\n-\t     appropriately.  We can then just change the TREE_CODE on that\n-\t     from FIELD_DECL to TYPE_DECL and we're done.  */\n-\n-\t  for (previous_declspec = NULL_TREE, scanner = declspecs;\n-\t       scanner;\n-\t       previous_declspec = scanner, scanner = TREE_CHAIN (scanner))\n-  \t    {\n-\t      if (TREE_VALUE (scanner) == ridpointers[(int) RID_TYPEDEF])\n-\t\tbreak;\n-  \t    }\n-\n-\t  if (previous_declspec)\n-\t    TREE_CHAIN (previous_declspec) = TREE_CHAIN (scanner);\n-\t  else\n-\t    declspecs = TREE_CHAIN (scanner);\n-\n-\t  declspecs = tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC],\n-\t\t\t\t declspecs);\n-\n-\t  /* In the recursive call to grokdeclarator we need to know\n-\t     whether we are working on a signature-local typedef.  */\n-\t  if (IS_SIGNATURE (current_class_type))\n-\t    SIGNATURE_GROKKING_TYPEDEF (current_class_type) = 1;\n-  \n-\t  loc_typedecl =\n-\t    grokdeclarator (declarator, declspecs, FIELD, 0, NULL_TREE, NULL_TREE);\n-\n-\t  if (previous_declspec)\n-\t    TREE_CHAIN (previous_declspec) = scanner;\n-  \n-\t  if (loc_typedecl != error_mark_node)\n-  \t    {\n-\t      register int i = sizeof (struct lang_decl_flags) / sizeof (int);\n-\t      register int *pi;\n-  \n-\t      TREE_SET_CODE (loc_typedecl, TYPE_DECL);\n-\t      /* This is the same field as DECL_ARGUMENTS, which is set for\n-\t\t function typedefs by the above grokdeclarator.  */\n-\t      DECL_NESTED_TYPENAME (loc_typedecl) = 0;\n-  \n-\t      pi = (int *) permalloc (sizeof (struct lang_decl_flags));\n-\t      while (i > 0)\n-\t        pi[--i] = 0;\n-\t      DECL_LANG_SPECIFIC (loc_typedecl) = (struct lang_decl *) pi;\n-\t    }\n-  \n-\t  if (IS_SIGNATURE (current_class_type))\n-\t    {\n-\t      SIGNATURE_GROKKING_TYPEDEF (current_class_type) = 0;\n-\t      if (loc_typedecl != error_mark_node && opaque_typedef)\n-\t\tSIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n-\t    }\n-\n-  \t  return loc_typedecl;\n-\t}\n-      else if (decl_context == FIELD\n-\t       && (! IS_SIGNATURE (current_class_type)\n-\t\t   || SIGNATURE_GROKKING_TYPEDEF (current_class_type))\n+\t       && ! IS_SIGNATURE (current_class_type)\n  \t       /* C++ allows static class elements  */\n  \t       && RIDBIT_SETP (RID_STATIC, specbits))\n  \t/* C++ also allows inlines and signed and unsigned elements,\n@@ -8511,7 +8446,21 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t\t\t\t\t  integer_one_node), 1));\n \t\tif (! TREE_CONSTANT (itype))\n \t\t  itype = variable_size (itype);\n-\t\titype = build_index_type (itype);\n+\n+\t\t/* If we're a parm, we need to have a permanent type so\n+                   mangling checks for re-use will work right.  If both the\n+                   element and index types are permanent, the array type\n+                   will be, too.  */\n+\t\tif (decl_context == PARM\n+\t\t    && allocation_temporary_p () && TREE_PERMANENT (type))\n+\t\t  {\n+\t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t\t    itype = build_index_type (itype);\n+\t\t    pop_obstacks ();\n+\t\t  }\n+\t\telse\n+\t\t  itype = build_index_type (itype);\n+\n \t      dont_grok_size:\n \t\tresume_momentary (yes);\n \t      }\n@@ -8636,7 +8585,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n  \t\t      }\n \t\t    {\n \t\t      RID_BIT_TYPE tmp_bits;\n-\t\t      bcopy ((void*)&specbits, (void*)&tmp_bits, sizeof(RID_BIT_TYPE));\n+\t\t      bcopy ((void*)&specbits, (void*)&tmp_bits, sizeof (RID_BIT_TYPE));\n \t\t      RIDBIT_RESET (RID_INLINE, tmp_bits);\n \t\t      RIDBIT_RESET (RID_STATIC, tmp_bits);\n \t\t      if (RIDBIT_ANY_SET (tmp_bits))\n@@ -9034,7 +8983,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t}\n     }\n \n-  if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n+  if (RIDBIT_SETP (RID_TYPEDEF, specbits) && decl_context != TYPENAME)\n     {\n       tree decl;\n \n@@ -9076,7 +9025,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  }\n \t}\n \n-      decl = build_decl (TYPE_DECL, declarator, type);\n+      if (decl_context == FIELD)\n+\t{\n+\t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n+\t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n+\t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n+\t}\n+      else\n+\tdecl = build_decl (TYPE_DECL, declarator, type);\n+\n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n \t{\n \t  cp_error_at (\"typedef name may not be class-qualified\", decl);\n@@ -9802,8 +9759,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t{\n \t\t  /* Give various messages as the need arises.  */\n \t\t  if (TREE_CODE (decl) == STRING_CST)\n-\t\t    error (\"invalid string constant `%s'\",\n-\t\t\t   TREE_STRING_POINTER (decl));\n+\t\t    cp_error (\"invalid string constant `%E'\", decl);\n \t\t  else if (TREE_CODE (decl) == INTEGER_CST)\n \t\t    error (\"invalid integer constant in parameter list, did you forget to give parameter name?\");\n \t\t  continue;\n@@ -9824,10 +9780,10 @@ grokparms (first_parm, funcdef_flag)\n \t\t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t\t    {\n \t\t      if (DECL_NAME (decl))\n-\t\t\t/* Cannot use `error_with_decl' here because\n+\t\t\t/* Cannot use the decl here because\n \t\t\t   we don't have DECL_CONTEXT set up yet.  */\n-\t\t\terror (\"parameter `%s' invalidly declared method type\",\n-\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t\t\tcp_error (\"parameter `%D' invalidly declared method type\",\n+\t\t\t\t  DECL_NAME (decl));\n \t\t      else\n \t\t\terror (\"parameter invalidly declared method type\");\n \t\t      type = build_pointer_type (type);\n@@ -9836,8 +9792,8 @@ grokparms (first_parm, funcdef_flag)\n \t\t  else if (TREE_CODE (type) == OFFSET_TYPE)\n \t\t    {\n \t\t      if (DECL_NAME (decl))\n-\t\t\terror (\"parameter `%s' invalidly declared offset type\",\n-\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t\t\tcp_error (\"parameter `%D' invalidly declared offset type\",\n+\t\t\t\t  DECL_NAME (decl));\n \t\t      else\n \t\t\terror (\"parameter invalidly declared offset type\");\n \t\t      type = build_pointer_type (type);\n@@ -10345,7 +10301,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t}\n       /* If we know we are defining this tag, only look it up in this scope\n        * and don't try to find it as a type. */\n-      if (t && TYPE_CONTEXT(t) && TREE_MANGLED (name))\n+      if (t && TYPE_CONTEXT (t) && TREE_MANGLED (name))\n \tref = t;\n       else\n       \tref = lookup_tag (code, name, b, 1);\n@@ -10387,6 +10343,8 @@ xref_tag (code_type_node, name, binfo, globalize)\n \n       if (code == ENUMERAL_TYPE)\n \t{\n+\t  cp_error (\"use of enum `%#D' without previous declaration\", name);\n+\n \t  ref = make_node (ENUMERAL_TYPE);\n \n \t  /* Give the type a default layout like unsigned int\n@@ -10462,6 +10420,25 @@ xref_tag (code_type_node, name, binfo, globalize)\n   return ref;\n }\n \n+tree\n+xref_tag_from_type (old, id, globalize)\n+     tree old, id;\n+     int globalize;\n+{\n+  tree code_type_node;\n+\n+  if (TREE_CODE (old) == RECORD_TYPE)\n+    code_type_node = (CLASSTYPE_DECLARED_CLASS (old)\n+\t\t      ? class_type_node : record_type_node);\n+  else\n+    code_type_node = union_type_node;\n+\n+  if (id == NULL_TREE)\n+    id = TYPE_IDENTIFIER (old);\n+\n+  return xref_tag (code_type_node, id, NULL_TREE, globalize);\n+}\n+\n void\n xref_basetypes (code_type_node, name, ref, binfo)\n      tree code_type_node;\n@@ -11048,7 +11025,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \n   announce_function (decl1);\n \n-  if (! current_template_parms || ! uses_template_parms (TREE_TYPE (fntype)))\n+  if (! current_template_parms)\n     {\n       if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n \t{\n@@ -11533,9 +11510,6 @@ finish_function (lineno, call_poplevel, nested)\n   if (fndecl == NULL_TREE)\n     return;\n \n-  if (! nested && hack_decl_function_context (fndecl) != NULL_TREE)\n-    nested = 1;\n-\n   fntype = TREE_TYPE (fndecl);\n \n /*  TREE_READONLY (fndecl) = 1;\n@@ -11715,7 +11689,7 @@ finish_function (lineno, call_poplevel, nested)\n \t    }\n \n \t  /* End of destructor.  */\n-\t  expand_end_bindings (NULL_TREE, getdecls() != NULL_TREE, 0);\n+\t  expand_end_bindings (NULL_TREE, getdecls () != NULL_TREE, 0);\n \t  poplevel (2, 0, 0);\t/* XXX change to 1 */\n \n \t  /* Back to the top of destructor.  */"}, {"sha": "a902a4f473f8e53f7d7dda3ca4686402dc45476c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -757,27 +757,27 @@ grok_x_components (specs, components)\n \t  /* This code may be needed for UNION_TYPEs as\n \t     well.  */\n \t  tcode = record_type_node;\n-\t  if (CLASSTYPE_DECLARED_CLASS(t))\n+\t  if (CLASSTYPE_DECLARED_CLASS (t))\n \t    tcode = class_type_node;\n-\t  else if (IS_SIGNATURE(t))\n+\t  else if (IS_SIGNATURE (t))\n \t    tcode = signature_type_node;\n \t  \n \t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n-\t  if (TYPE_CONTEXT(t))\n-\t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n+\t  if (TYPE_CONTEXT (t))\n+\t    CLASSTYPE_NO_GLOBALIZE (t) = 1;\n \t  return NULL_TREE;\n \t  break;\n \n \tcase UNION_TYPE:\n \tcase ENUMERAL_TYPE:\n-\t  if (TREE_CODE(t) == UNION_TYPE)\n+\t  if (TREE_CODE (t) == UNION_TYPE)\n \t    tcode = union_type_node;\n \t  else\n \t    tcode = enum_type_node;\n \n \t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n-\t  if (TREE_CODE(t) == UNION_TYPE && TYPE_CONTEXT(t))\n-\t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n+\t  if (TREE_CODE (t) == UNION_TYPE && TYPE_CONTEXT (t))\n+\t    CLASSTYPE_NO_GLOBALIZE (t) = 1;\n \t  if (TREE_CODE (t) == UNION_TYPE\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n \t    {\n@@ -1233,7 +1233,11 @@ check_classfn (ctype, function)\n       end = TREE_VEC_END (method_vec);\n \n       /* First suss out ctors and dtors.  */\n-      if (*methods && fn_name == DECL_NAME (*methods))\n+      if (*methods && fn_name == DECL_NAME (*methods)\n+\t  && DECL_CONSTRUCTOR_P (function))\n+\tgoto got_it;\n+      if (*++methods && fn_name == DECL_NAME (*methods)\n+\t  && DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function)))\n \tgoto got_it;\n \n       while (++methods != end)\n@@ -1295,8 +1299,8 @@ check_classfn (ctype, function)\n \t\tfunction, ctype);\n     }\n \n-  /* If we did not find the method in the class, add it to\n-     avoid spurious errors.  */\n+  /* If we did not find the method in the class, add it to avoid\n+     spurious errors.  */\n   add_method (ctype, methods, function);\n   return NULL_TREE;\n }\n@@ -1381,16 +1385,6 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n       DECL_CLASS_CONTEXT (value) = current_class_type;\n       CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n \n-      /* If we declare a typedef name for something that has no name,\n-\t the typedef name is used for linkage.  See 7.1.3 p4 94/0158. */\n-      if (TYPE_NAME (TREE_TYPE (value))\n-\t  && TREE_CODE (TYPE_NAME (TREE_TYPE (value))) == TYPE_DECL\n-\t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TREE_TYPE (value))))\n-\t{\n-\t  TYPE_NAME (TREE_TYPE (value)) = value;\n-\t  TYPE_STUB_DECL (TREE_TYPE (value)) = value;\n-\t}\n-\n       pushdecl_class_level (value);\n       return value;\n     }\n@@ -2094,6 +2088,7 @@ get_temp_name (type, staticp)\n     }\n   TREE_USED (decl) = 1;\n   TREE_STATIC (decl) = staticp;\n+  DECL_ARTIFICIAL (decl) = 1;\n \n   /* If this is a local variable, then lay out its rtl now.\n      Otherwise, callers of this function are responsible for dealing\n@@ -2529,7 +2524,7 @@ import_export_template (type)\n     }\n }\n     \n-static void\n+static int\n finish_prevtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n@@ -2550,6 +2545,9 @@ finish_prevtable_vardecl (prev, vars)\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n \t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n+#ifdef ADJUST_VTABLE_LINKAGE\n+\t      ADJUST_VTABLE_LINKAGE (vars, method);\n+#endif\n \t      break;\n \t    }\n \t}\n@@ -2570,14 +2568,17 @@ finish_prevtable_vardecl (prev, vars)\n \t at the top level.  */\n       build_t_desc (ctype, 1);\n     }\n+\n+  return 1;\n }\n     \n-static void\n+static int\n finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   if (write_virtuals >= 0\n-      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n+      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars))\n+      && ! TREE_ASM_WRITTEN (vars))\n     {\n #if 0\n       /* The long term plan it to make the TD entries statically initialized,\n@@ -2622,37 +2623,42 @@ finish_vtable_vardecl (prev, vars)\n #endif /* DWARF_DEBUGGING_INFO */\n \n       rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n+      return 1;\n     }\n   else if (! TREE_USED (vars))\n     /* We don't know what to do with this one yet.  */\n-    return;\n+    return 0;\n \n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+  return 0;\n }\n \n-static void\n+static int\n prune_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+  return 1;\n }\n \n-void\n+int\n walk_vtables (typedecl_fn, vardecl_fn)\n      register void (*typedecl_fn)();\n-     register void (*vardecl_fn)();\n+     register int (*vardecl_fn)();\n {\n   tree prev, vars;\n+  int flag = 0;\n \n   for (prev = 0, vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n     {\n       register tree type = TREE_TYPE (vars);\n \n       if (TREE_CODE (vars) == VAR_DECL && DECL_VIRTUAL_P (vars))\n \t{\n-\t  if (vardecl_fn) (*vardecl_fn) (prev, vars);\n+\t  if (vardecl_fn)\n+\t    flag |= (*vardecl_fn) (prev, vars);\n \n \t  if (prev && TREE_CHAIN (prev) != vars)\n \t    continue;\n@@ -2667,6 +2673,8 @@ walk_vtables (typedecl_fn, vardecl_fn)\n \n       prev = vars;\n     }\n+\n+  return flag;\n }\n \n static void\n@@ -2910,7 +2918,7 @@ finish_file ()\n     expand_expr_stmt (build_function_call (TREE_VALUE (static_dtors),\n \t\t\t\t\t   NULL_TREE));\n       \n-  expand_end_bindings (getdecls(), 1, 0);\n+  expand_end_bindings (getdecls (), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n \n@@ -3027,7 +3035,7 @@ finish_file ()\n \texpand_expr_stmt (build_function_call (TREE_VALUE (static_ctors),\n \t\t\t\t\t       NULL_TREE));\n       \n-      expand_end_bindings (getdecls(), 1, 0);\n+      expand_end_bindings (getdecls (), 1, 0);\n       poplevel (1, 0, 0);\n       pop_momentary ();\n \n@@ -3107,7 +3115,7 @@ finish_file ()\n \tSET_DECL_ARTIFICIAL (vars);\n \tpushdecl (vars);\n \n-\twalk_vtables ((void (*)())0, finish_vtable_vardecl);\n+\treconsider |= walk_vtables ((void (*)())0, finish_vtable_vardecl);\n \n \twhile (*p)\n \t  {\n@@ -3314,6 +3322,8 @@ build_expr_from_tree (t)\n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case CONVERT_EXPR:      /* Unary + */\n+      if (TREE_TYPE (t))\n+\treturn t;\n       return build_x_unary_op (TREE_CODE (t),\n \t\t\t       build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n@@ -3472,6 +3482,9 @@ build_expr_from_tree (t)\n \t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n \t TREE_OPERAND (t, 1), NULL_TREE, 1);\n \n+    case THROW_EXPR:\n+      return build_throw (build_expr_from_tree (TREE_OPERAND (t, 0)));\n+\n     default:\n       return t;\n     }\n@@ -3599,6 +3612,7 @@ void\n do_namespace_alias (alias, namespace)\n      tree alias, namespace;\n {\n+  sorry (\"namespace alias\");\n }\n \n tree\n@@ -3651,6 +3665,7 @@ void\n do_using_directive (namespace)\n      tree namespace;\n {\n+  sorry (\"using directive\");\n }\n \n void"}, {"sha": "bb93dd4a17c7d6ba510b4af0e3f553221e6b772a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -543,7 +543,7 @@ ident_fndecl (t)\n #endif\n \n #define GLOBAL_IORD_P(NODE) \\\n-  !strncmp(IDENTIFIER_POINTER(NODE),GLOBAL_THING,sizeof(GLOBAL_THING)-1)\n+  ! strncmp (IDENTIFIER_POINTER(NODE), GLOBAL_THING, sizeof (GLOBAL_THING) - 1)\n \n void\n dump_global_iord (t)\n@@ -581,12 +581,9 @@ dump_decl (t, v)\n     case TYPE_DECL:\n       {\n \t/* Don't say 'typedef class A' */\n-\ttree type = TREE_TYPE (t);\n-        if (((IS_AGGR_TYPE (type) && ! TYPE_PTRMEMFUNC_P (type))\n-\t     || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t    && type == TYPE_MAIN_VARIANT (type))\n+        if (DECL_ARTIFICIAL (t))\n \t  {\n-\t    dump_type (type, v);\n+\t    dump_type (TREE_TYPE (t), v);\n \t    break;\n \t  }\n       }\n@@ -1087,7 +1084,7 @@ dump_expr (t, nop)\n \t    args = TREE_CHAIN (args);\n \t  }\n \tdump_expr (fn, 0);\n-\tOB_PUTC('(');\n+\tOB_PUTC ('(');\n \tdump_expr_list (args);\n \tOB_PUTC (')');\n       }"}, {"sha": "41742a7325136c1fab4924246890b5b66901bc17", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1398,7 +1398,7 @@ expand_builtin_throw ()\n     /* Fall into epilogue to unwind prologue. */\n   }\n \n-  expand_end_bindings (getdecls(), 1, 0);\n+  expand_end_bindings (getdecls (), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n \n@@ -1626,7 +1626,7 @@ start_anon_func ()\n void\n end_anon_func ()\n {\n-  expand_end_bindings (getdecls(), 1, 0);\n+  expand_end_bindings (getdecls (), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n \n@@ -1809,6 +1809,8 @@ build_throw (e)\n {\n   if (e != error_mark_node)\n     {\n+      if (current_template_parms)\n+\treturn build_min (THROW_EXPR, void_type_node, e);\n       e = build1 (THROW_EXPR, void_type_node, e);\n       TREE_SIDE_EFFECTS (e) = 1;\n       TREE_USED (e) = 1;"}, {"sha": "9986698d20fcf4f4c9f35bbe10778ab0409153a0", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -366,6 +366,9 @@ do_case (start, end)\n {\n   tree value1 = NULL_TREE, value2 = NULL_TREE, label;\n \n+  if (start && POINTER_TYPE_P (TREE_TYPE (start)))\n+    error (\"pointers are not permitted as case values\");\n+\n   if (end && pedantic)\n     pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n "}, {"sha": "64d9776cac2311559b2363d7387152bd75451819", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1226,22 +1226,22 @@ stands.\n \n Only exact type matching or reference matching of throw types works when\n -fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm,\n-rs6000, PowerPC, Alpha, mips and VAX machines.  Partial support is in\n-for all other machines, but a stack unwinder called __unwind_function\n-has to be written, and added to libgcc2 for them.  The new EH code\n-doesn't rely upon the __unwind_function for C++ code, instead it creates\n-per function unwinders right inside the function, unfortunately, on many\n-platforms the definition of RETURN_ADDR_RTX in the tm.h file for the\n-machine port is wrong.  The HPPA has a brain dead abi that prevents\n-exception handling from just working.  See below for details on\n-__unwind_function.  Don't expect exception handling to work right if you\n-optimize, in fact the compiler will probably core dump.  RTL_EXPRs for\n-EH cond variables for && and || exprs should probably be wrapped in\n-UNSAVE_EXPRs, and RTL_EXPRs tweaked so that they can be unsaved, and the\n-UNSAVE_EXPR code should be in the backend, or alternatively, UNSAVE_EXPR\n-should be ripped out and exactly one finalization allowed to be expanded\n-by the backend.  I talked with kenner about this, and we have to allow\n-multiple expansions.\n+rs6000, PowerPC, Alpha, mips, VAX, and m68k machines.  Partial support\n+is in for all other machines, but a stack unwinder called\n+__unwind_function has to be written, and added to libgcc2 for them.  The\n+new EH code doesn't rely upon the __unwind_function for C++ code,\n+instead it creates per function unwinders right inside the function,\n+unfortunately, on many platforms the definition of RETURN_ADDR_RTX in\n+the tm.h file for the machine port is wrong.  The HPPA has a brain dead\n+abi that prevents exception handling from just working.  See below for\n+details on __unwind_function.  Don't expect exception handling to work\n+right if you optimize, in fact the compiler will probably core dump.\n+RTL_EXPRs for EH cond variables for && and || exprs should probably be\n+wrapped in UNSAVE_EXPRs, and RTL_EXPRs tweaked so that they can be\n+unsaved, and the UNSAVE_EXPR code should be in the backend, or\n+alternatively, UNSAVE_EXPR should be ripped out and exactly one\n+finalization allowed to be expanded by the backend.  I talked with\n+kenner about this, and we have to allow multiple expansions.\n \n We only do pointer conversions on exception matching a la 15.3 p2 case\n 3: `A handler with type T, const T, T&, or const T& is a match for a"}, {"sha": "289cef8e117ddac38e0d6646b7d0a69e45f23304", "filename": "gcc/cp/init.c", "status": "modified", "additions": 81, "deletions": 88, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -596,7 +596,7 @@ emit_base_init (t, immediately)\n \t  target_temp_slot_level = temp_slot_level;\n \n \t  member = convert_pointer_to_real (base_binfo, current_class_decl);\n-\t  expand_aggr_init_1 (base_binfo, 0,\n+\t  expand_aggr_init_1 (base_binfo, NULL_TREE,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      BINFO_OFFSET_ZEROP (base_binfo), LOOKUP_NORMAL);\n \t  expand_cleanups_to (old_cleanups);\n@@ -935,7 +935,6 @@ expand_member_init (exp, name, init)\n   tree basetype = NULL_TREE, field;\n   tree parm;\n   tree rval, type;\n-  tree actual_name;\n \n   if (exp == NULL_TREE)\n     return;\t\t\t/* complain about this later */\n@@ -1071,14 +1070,10 @@ expand_member_init (exp, name, init)\n \t  TREE_USED (exp) = 1;\n \t}\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (field));\n-      actual_name = TYPE_IDENTIFIER (type);\n       parm = build_component_ref (exp, name, 0, 0);\n \n-      /* Now get to the constructor.  */\n+      /* Now get to the constructors.  */\n       fndecl = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0);\n-      /* Get past destructor, if any.  */\n-      if (TYPE_HAS_DESTRUCTOR (type))\n-\tfndecl = DECL_CHAIN (fndecl);\n \n       if (fndecl)\n \tmy_friendly_assert (TREE_CODE (fndecl) == FUNCTION_DECL, 209);\n@@ -1102,7 +1097,8 @@ expand_member_init (exp, name, init)\n \n       init = convert_arguments (parm, parmtypes, NULL_TREE, fndecl, LOOKUP_NORMAL);\n       if (init == NULL_TREE || TREE_TYPE (init) != error_mark_node)\n-\trval = build_method_call (NULL_TREE, actual_name, init, NULL_TREE, LOOKUP_NORMAL);\n+\trval = build_method_call (NULL_TREE, ctor_identifier, init,\n+\t\t\t\t  TYPE_BINFO (type), LOOKUP_NORMAL);\n       else\n \treturn;\n \n@@ -1245,14 +1241,15 @@ expand_aggr_init (exp, init, alias_this, flags)\n }\n \n static void\n-expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n+expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n      tree binfo;\n      tree true_exp, exp;\n-     tree type;\n      tree init;\n      int alias_this;\n      int flags;\n {\n+  tree type = TREE_TYPE (exp);\n+\n   /* It fails because there may not be a constructor which takes\n      its own type as the first (or only parameter), but which does\n      take other types via a conversion.  So, if the thing initializing\n@@ -1301,7 +1298,7 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n     {\n       if (flags & LOOKUP_ONLYCONVERTING)\n \tflags |= LOOKUP_NO_CONVERSION;\n-      rval = build_method_call (exp, constructor_name_full (type),\n+      rval = build_method_call (exp, ctor_identifier,\n \t\t\t\tparms, binfo, flags);\n \n       /* Private, protected, or otherwise unavailable.  */\n@@ -1534,7 +1531,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t  tree parms = build_tree_list (NULL_TREE, init);\n \t\t  tree as_cons = NULL_TREE;\n \t\t  if (TYPE_HAS_CONSTRUCTOR (type))\n-\t\t    as_cons = build_method_call (exp, constructor_name_full (type),\n+\t\t    as_cons = build_method_call (exp, ctor_identifier,\n \t\t\t\t\t\t parms, binfo,\n \t\t\t\t\t\t LOOKUP_SPECULATIVELY|LOOKUP_NO_CONVERSION);\n \t\t  if (as_cons != NULL_TREE && as_cons != error_mark_node)\n@@ -1551,7 +1548,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \n   /* We know that expand_default_init can handle everything we want\n      at this point.  */\n-  expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags);\n+  expand_default_init (binfo, true_exp, exp, init, alias_this, flags);\n }\n \n /* Report an error if NAME is not the name of a user-defined,\n@@ -1781,7 +1778,7 @@ build_offset_ref (type, name)\n      tree type, name;\n {\n   tree decl, fnfields, fields, t = error_mark_node;\n-  tree basetypes = NULL_TREE;\n+  tree basebinfo = NULL_TREE;\n   int dtor = 0;\n \n   if (current_template_parms)\n@@ -1843,18 +1840,28 @@ build_offset_ref (type, name)\n     }\n \n   if (current_class_type == 0\n-      || get_base_distance (type, current_class_type, 0, &basetypes) == -1)\n+      || get_base_distance (type, current_class_type, 0, &basebinfo) == -1)\n     {\n-      basetypes = TYPE_BINFO (type);\n+      basebinfo = TYPE_BINFO (type);\n       decl = build1 (NOP_EXPR, type, error_mark_node);\n     }\n   else if (current_class_decl == 0)\n     decl = build1 (NOP_EXPR, type, error_mark_node);\n   else\n     decl = C_C_D;\n \n-  fnfields = lookup_fnfields (basetypes, name, 1);\n-  fields = lookup_field (basetypes, name, 0, 0);\n+  if (constructor_name (BINFO_TYPE (basebinfo)) == name)\n+    if (dtor)\n+      name = dtor_identifier;\n+    else\n+      name = ctor_identifier;\n+  else\n+    if (dtor)\n+      my_friendly_abort (999);\n+\n+    \n+  fnfields = lookup_fnfields (basebinfo, name, 1);\n+  fields = lookup_field (basebinfo, name, 0, 0);\n \n   if (fields == error_mark_node || fnfields == error_mark_node)\n     return error_mark_node;\n@@ -1863,91 +1870,58 @@ build_offset_ref (type, name)\n      lookup_fnfield. */\n   if (fnfields)\n     {\n-      basetypes = TREE_PURPOSE (fnfields);\n+      extern int flag_save_memoized_contexts;\n+      basebinfo = TREE_PURPOSE (fnfields);\n \n       /* Go from the TREE_BASELINK to the member function info.  */\n       t = TREE_VALUE (fnfields);\n \n-      if (fields)\n+      if (DECL_CHAIN (t) == NULL_TREE)\n \t{\n-\t  if (DECL_FIELD_CONTEXT (fields) == DECL_FIELD_CONTEXT (t))\n+\t  tree access;\n+\n+\t  /* unique functions are handled easily.  */\n+\tunique:\n+\t  access = compute_access (basebinfo, t);\n+\t  if (access == access_protected_node)\n \t    {\n-\t      error (\"ambiguous member reference: member `%s' defined as both field and function\",\n-\t\t     IDENTIFIER_POINTER (name));\n+\t      cp_error_at (\"member function `%#D' is protected\", t);\n+\t      error (\"in this context\");\n \t      return error_mark_node;\n \t    }\n-\t  if (UNIQUELY_DERIVED_FROM_P (DECL_FIELD_CONTEXT (fields), DECL_FIELD_CONTEXT (t)))\n-\t    ;\n-\t  else if (UNIQUELY_DERIVED_FROM_P (DECL_FIELD_CONTEXT (t), DECL_FIELD_CONTEXT (fields)))\n-\t    t = fields;\n-\t  else\n+\t  if (access == access_private_node)\n \t    {\n-\t      error (\"ambiguous member reference: member `%s' derives from distinct classes in multiple inheritance lattice\");\n+\t      cp_error_at (\"member function `%#D' is private\", t);\n+\t      error (\"in this context\");\n \t      return error_mark_node;\n \t    }\n+\t  mark_used (t);\n+\t  return build (OFFSET_REF, TREE_TYPE (t), decl, t);\n \t}\n \n-      if (t == TREE_VALUE (fnfields))\n-\t{\n-\t  extern int flag_save_memoized_contexts;\n+      /* FNFIELDS is most likely allocated on the search_obstack,\n+\t which will go away after this class scope.  If we need\n+\t to save this value for later (either for memoization\n+\t or for use as an initializer for a static variable), then\n+\t do so here.\n \n-\t  if (DECL_CHAIN (t) == NULL_TREE || dtor)\n-\t    {\n-\t      tree access;\n-\n-\t      /* unique functions are handled easily.  */\n-\t    unique:\n-\t      access = compute_access (basetypes, t);\n-\t      if (access == access_protected_node)\n-\t\t{\n-\t\t  cp_error_at (\"member function `%#D' is protected\", t);\n-\t\t  error (\"in this context\");\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      if (access == access_private_node)\n-\t\t{\n-\t\t  cp_error_at (\"member function `%#D' is private\", t);\n-\t\t  error (\"in this context\");\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      mark_used (t);\n-\t      return build (OFFSET_REF, TREE_TYPE (t), decl, t);\n-\t    }\n+\t ??? The smart thing to do for the case of saving initializers\n+\t is to resolve them before we're done with this scope.  */\n+      if (!TREE_PERMANENT (fnfields)\n+\t  && ((flag_save_memoized_contexts && global_bindings_p ())\n+\t      || ! allocation_temporary_p ()))\n+\tfnfields = copy_list (fnfields);\n \n-\t  /* overloaded functions may need more work.  */\n-\t  if (name == constructor_name (type))\n-\t    {\n-\t      if (TYPE_HAS_DESTRUCTOR (type)\n-\t\t  && DECL_CHAIN (DECL_CHAIN (t)) == NULL_TREE)\n-\t\t{\n-\t\t  t = DECL_CHAIN (t);\n-\t\t  goto unique;\n-\t\t}\n-\t    }\n-\t  /* FNFIELDS is most likely allocated on the search_obstack,\n-\t     which will go away after this class scope.  If we need\n-\t     to save this value for later (either for memoization\n-\t     or for use as an initializer for a static variable), then\n-\t     do so here.\n-\n-\t     ??? The smart thing to do for the case of saving initializers\n-\t     is to resolve them before we're done with this scope.  */\n-\t  if (!TREE_PERMANENT (fnfields)\n-\t      && ((flag_save_memoized_contexts && global_bindings_p ())\n-\t\t  || ! allocation_temporary_p ()))\n-\t    fnfields = copy_list (fnfields);\n-\n-\t  t = build_tree_list (error_mark_node, fnfields);\n-\t  TREE_TYPE (t) = build_offset_type (type, unknown_type_node);\n-\t  return t;\n-\t}\n+      t = build_tree_list (error_mark_node, fnfields);\n+      TREE_TYPE (t) = build_offset_type (type, unknown_type_node);\n+      return t;\n     }\n \n   /* Now that we know we are looking for a field, see if we\n      have access to that field.  Lookup_field will give us the\n      error message.  */\n \n-  t = lookup_field (basetypes, name, 1, 0);\n+  t = lookup_field (basebinfo, name, 1, 0);\n \n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -2802,7 +2776,12 @@ build_new (placement, decl, init, use_global_new)\n     }\n \n   if (has_array)\n-    code = VEC_NEW_EXPR;\n+    {\n+      code = VEC_NEW_EXPR;\n+\n+      if (init && pedantic)\n+\tcp_pedwarn (\"initialization in array new\");\n+    }\n \n   /* Allocate the object. */\n   if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n@@ -2930,8 +2909,8 @@ build_new (placement, decl, init, use_global_new)\n \t  if (newrval && TREE_CODE (TREE_TYPE (newrval)) == POINTER_TYPE)\n \t    newrval = build_indirect_ref (newrval, NULL_PTR);\n \n-\t  newrval = build_method_call (newrval, constructor_name_full (true_type),\n-\t\t\t\t       init, NULL_TREE, flags);\n+\t  newrval = build_method_call (newrval, ctor_identifier,\n+\t\t\t\t       init, TYPE_BINFO (true_type), flags);\n \n \t  if (newrval)\n \t    {\n@@ -3272,6 +3251,9 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n   expand_assignment (rval, base, 0, 0);\n   base = get_temp_regvar (build_pointer_type (type), base);\n \n+  if (init != NULL_TREE && TREE_CODE (init) == TREE_LIST)\n+    init = build_compound_expr (init);\n+\n   if (init != NULL_TREE\n       && TREE_CODE (init) == CONSTRUCTOR\n       && TREE_TYPE (init) == TREE_TYPE (decl))\n@@ -3387,7 +3369,18 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t\t\t   array_type_nelts (type), 0, 0);\n \t}\n       else\n-\texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0, 0);\n+\t{\n+\t  tree targ = build1 (INDIRECT_REF, type, base);\n+\t  tree rhs;\n+\n+\t  if (init)\n+\t    rhs = convert_for_initialization (targ, type, init, LOOKUP_NORMAL,\n+\t\t\t\t\t      \"initialization\", NULL_TREE, 0);\n+\t  else\n+\t    rhs = NULL_TREE;\n+\n+\t  expand_aggr_init (targ, rhs, 0, 0);\n+\t}\n \n       expand_assignment (base,\n \t\t\t build (PLUS_EXPR, build_pointer_type (type), base, size),\n@@ -3578,7 +3571,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n      of the base classes; otherwise, we must do that here.  */\n   if (TYPE_HAS_DESTRUCTOR (type))\n     {\n-      tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0));\n+      tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1));\n       tree basetypes = TYPE_BINFO (type);\n       tree passed_auto_delete;\n       tree do_delete = NULL_TREE;\n@@ -3631,7 +3624,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t     complete right way to do this. this offsets may not be right\n \t     in the below.  (mrs) */\n \t  /* This destructor must be called via virtual function table.  */\n-\t  dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (DECL_CONTEXT (dtor)), 0);\n+\t  dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (DECL_CONTEXT (dtor)), 1);\n \t  basetype = DECL_CLASS_CONTEXT (dtor);\n \t  binfo = get_binfo (basetype,\n \t\t\t     TREE_TYPE (TREE_TYPE (TREE_VALUE (parms))),"}, {"sha": "a1b841bf4672c58a530c449aad6bc044408c6ea5", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -837,6 +837,11 @@ yyprint (file, yychar, yylval)\n     case SCSPEC:\n     case PRE_PARSED_CLASS_DECL:\n       t = yylval.ttype;\n+      if (TREE_CODE (t) == TYPE_DECL)\n+\t{\n+\t  fprintf (file, \" `%s'\", DECL_NAME (t));\n+\t  break;\n+\t}\n       my_friendly_assert (TREE_CODE (t) == IDENTIFIER_NODE, 224);\n       if (IDENTIFIER_POINTER (t))\n \t  fprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n@@ -1076,7 +1081,7 @@ set_typedecl_interface_info (prev, vars)\n     = interface_strcmp (FILE_NAME_NONDIRECTORY (DECL_SOURCE_FILE (vars)));\n }\n \n-void\n+int\n set_vardecl_interface_info (prev, vars)\n      tree prev, vars;\n {\n@@ -1090,7 +1095,9 @@ set_vardecl_interface_info (prev, vars)\n \tCLASSTYPE_VTABLE_NEEDS_WRITING (type) = 1;\n       DECL_EXTERNAL (vars) = CLASSTYPE_INTERFACE_ONLY (type);\n       TREE_PUBLIC (vars) = 1;\n+      return 1;\n     }\n+  return 0;\n }\n \f\n /* Called from the top level: if there are any pending inlines to\n@@ -1683,13 +1690,15 @@ cons_up_default_function (type, full_name, kind)\n     }\n #endif\n \n+#if 0\n   if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n       DECL_INTERFACE_KNOWN (fn) = 1;\n       DECL_NOT_REALLY_EXTERN (fn) = (!CLASSTYPE_INTERFACE_ONLY (type)\n \t\t\t\t     && flag_implement_inlines);\n     }\n   else\n+#endif\n     DECL_NOT_REALLY_EXTERN (fn) = 1;\n \n   mark_inline_for_output (fn);\n@@ -1986,7 +1995,7 @@ check_newline ()\n \t\t\t      goto skipline;\n \t\t\t    }\n \t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t\t\t  c = getch();\n+\t\t\t  c = getch ();\n \t\t\t  put_back (c);\n \t\t\t}\n \n@@ -2063,7 +2072,7 @@ check_newline ()\n \t\t\t      goto skipline;\n \t\t\t    }\n \t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t\t\t  c = getch();\n+\t\t\t  c = getch ();\n \t\t\t  put_back (c);\n \t\t\t}\n \n@@ -2683,7 +2692,7 @@ see_typename ()\n {\n   looking_for_typename = 1;\n   if (yychar < 0)\n-    if ((yychar = yylex()) < 0) yychar = 0;\n+    if ((yychar = yylex ()) < 0) yychar = 0;\n   looking_for_typename = 0;\n   if (yychar == IDENTIFIER)\n     {\n@@ -2742,7 +2751,7 @@ do_identifier (token, parsing)\n \n   /* Remember that this name has been used in the class definition, as per\n      [class.scope0] */\n-  if (id && current_class_type\n+  if (id && current_class_type && parsing\n       && TYPE_BEING_DEFINED (current_class_type)\n       && ! IDENTIFIER_CLASS_VALUE (token))\n     pushdecl_class_level (id);\n@@ -3238,6 +3247,14 @@ real_yylex ()\n \t\t  token_buffer[0] = '^';\n \t\t  token_buffer[1] = 0;\n \t\t}\n+\t      else if (ptr->token == NAMESPACE)\n+\t\t{\n+\t\t  static int warned;\n+\t\t  if (! warned)\n+\t\t    warning (\"namespaces are mostly broken in this version of g++\");\n+\n+\t\t  warned = 1;\n+\t\t}\n \n \t      value = (int) ptr->token;\n \t    }\n@@ -4037,7 +4054,7 @@ real_yylex ()\n \t  skipnewline:\n \t    c = getch ();\n \t    if (c == EOF) {\n-\t\terror(\"Unterminated string\");\n+\t\terror (\"Unterminated string\");\n \t\tbreak;\n \t    }\n \t  }\n@@ -4383,7 +4400,7 @@ build_lang_decl (code, name, type)\n #endif\n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += sizeof(struct lang_decl);\n+  tree_node_sizes[(int)lang_decl] += sizeof (struct lang_decl);\n #endif\n \n   return t;\n@@ -4480,7 +4497,7 @@ make_lang_type (code)\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_type] += 1;\n-  tree_node_sizes[(int)lang_type] += sizeof(struct lang_type);\n+  tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n #endif\n \n   return t;\n@@ -4509,7 +4526,7 @@ copy_decl_lang_specific (decl)\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += sizeof(struct lang_decl);\n+  tree_node_sizes[(int)lang_decl] += sizeof (struct lang_decl);\n #endif\n }\n \n@@ -4549,32 +4566,6 @@ compiler_error (s, v, v2)\n   sprintf (buf, s, v, v2);\n   error_with_file_and_line (input_filename, lineno, \"%s (compiler error)\", buf);\n }\n-\n-void\n-compiler_error_with_decl (decl, s)\n-     tree decl;\n-     char *s;\n-{\n-  char *name;\n-  count_error (0);\n-\n-  report_error_function (0);\n-\n-  if (TREE_CODE (decl) == PARM_DECL)\n-    fprintf (stderr, \"%s:%d: \",\n-\t     DECL_SOURCE_FILE (DECL_CONTEXT (decl)),\n-\t     DECL_SOURCE_LINE (DECL_CONTEXT (decl)));\n-  else\n-    fprintf (stderr, \"%s:%d: \",\n-\t     DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n-\n-  name = lang_printable_name (decl);\n-  if (name)\n-    fprintf (stderr, s, name);\n-  else\n-    fprintf (stderr, s, \"((anonymous))\");\n-  fprintf (stderr, \" (compiler error)\\n\");\n-}\n \f\n void\n yyerror (string)"}, {"sha": "c8732072d0a1eac71905790251326d75dfbc4ecf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -91,10 +91,12 @@ do_inline_function_hair (type, friend_list)\n \n   if (method && TREE_CODE (method) == TREE_VEC)\n     {\n-      if (TREE_VEC_ELT (method, 0))\n+      if (TREE_VEC_ELT (method, 1))\n+\tmethod = TREE_VEC_ELT (method, 1);\n+      else if (TREE_VEC_ELT (method, 0))\n \tmethod = TREE_VEC_ELT (method, 0);\n       else\n-\tmethod = TREE_VEC_ELT (method, 1);\n+\tmethod = TREE_VEC_ELT (method, 2);\n     }\n \n   while (method)\n@@ -1277,9 +1279,26 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t\t\t\t      build_tree_list (NULL_TREE, xarg1),\n \t\t\t\t      flags & LOOKUP_COMPLAIN,\n \t\t\t\t      (struct candidate *)0);\n+\targ1 = TREE_TYPE (xarg1);\n+\n+\t/* This handles the case where we're trying to delete\n+\t   X (*a)[10];\n+\t   a=new X[5][10];\n+\t   delete[] a; */\n+\t   \n+\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n+\t  {\n+\t    /* Strip off the pointer and the array. */\n+\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n+\n+\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n+\t\targ1 = (TREE_TYPE (arg1));\n+\n+\t    arg1 = build_pointer_type (arg1);\n+\t  }\n \n \trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, TREE_TYPE (xarg1),\n+\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n \t\t\t\t       error_mark_node),\n \t\t\t       NULL_PTR),\n \t   fnname, tree_cons (NULL_TREE, xarg1,\n@@ -1826,7 +1845,7 @@ make_thunk (function, delta)\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && TREE_CODE (thunk) != THUNK_DECL)\n     {\n-      error_with_decl (\"implementation-reserved name `%s' used\");\n+      cp_error (\"implementation-reserved name `%D' used\", thunk_id);\n       IDENTIFIER_GLOBAL_VALUE (thunk_id) = thunk = NULL_TREE;\n     }\n   if (thunk == NULL_TREE)"}, {"sha": "d2b6f95e202e298051ae5b3bd2785bcfa2e6c9a6", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -499,10 +499,10 @@ datadef:\n \t| typed_declspecs declarator ';'\n \t\t{ tree d, specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  note_list_got_semicolon (specs);\n \t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n         | declmods ';'\n \t  { pedwarn (\"empty declaration\"); }\n@@ -1990,7 +1990,9 @@ pending_inlines:\n \t| pending_inlines fn.defpen maybe_return_init ctor_initializer_opt\n \t  compstmt_or_error\n \t\t{\n-\t\t  finish_function (lineno, (int)$4, 0);\n+\t\t  int nested = (hack_decl_function_context\n+\t\t\t\t(current_function_decl) != NULL_TREE);\n+\t\t  finish_function (lineno, (int)$4, nested);\n \t\t  process_next_inline ($2);\n \t\t}\n \t| pending_inlines fn.defpen maybe_return_init function_try_block\n@@ -2108,7 +2110,19 @@ named_class_head_sans_basetype_defn:\n \n named_complex_class_head_sans_basetype:\n \t  aggr nested_name_specifier identifier\n-\t\t{ current_aggr = $$; $$ = $3; }\n+\t\t{\n+\t\t  current_aggr = $1;\n+\t\t  if (TREE_CODE ($3) == TYPE_DECL)\n+\t\t    $$ = $3;\n+\t\t  else\n+\t\t    {\n+\t\t      cp_error (\"`%T' does not have a nested type named `%D'\",\n+\t\t\t\t$2, $3);\n+\t\t      $$ = xref_tag\n+\t\t\t(current_aggr, make_anon_name (), NULL_TREE, 1);\n+\t\t      $$ = TYPE_MAIN_DECL ($$);\n+\t\t    }\n+\t\t}\n \t| aggr template_type\n \t\t{ current_aggr = $$; $$ = $2; }\n \t| aggr nested_name_specifier template_type\n@@ -3519,8 +3533,10 @@ function_try_block:\n \t\t  expand_start_all_catch (); }\n \t  handler_seq\n \t\t{\n+\t\t  int nested = (hack_decl_function_context\n+\t\t\t\t(current_function_decl) != NULL_TREE);\n \t\t  expand_end_all_catch ();\n-\t\t  finish_function (lineno, (int)$3, 0);\n+\t\t  finish_function (lineno, (int)$3, nested);\n \t\t}\n \t;\n \n@@ -3820,6 +3836,9 @@ bad_parm:\n \t| notype_declarator\n \t\t{\n \t\t  error (\"type specifier omitted for parameter\");\n+\t\t  if (TREE_CODE ($$) == SCOPE_REF\n+\t\t      && TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM)\n+\t\t    cp_error (\"  perhaps you want `typename %E' to make it a type\", $$);\n \t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}\n \t;"}, {"sha": "0ecc40018b0c7f416c7acc546c13c8a43ec4814c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1,6 +1,7 @@\n /* Handle parameterized types (templates) for GNU C++.\n    Copyright (C) 1992, 93, 94, 95, 1996 Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n+   Rewritten by Jason Merrill (jason@cygnus.com).\n \n This file is part of GNU CC.\n \n@@ -233,6 +234,9 @@ push_template_decl (decl)\n     {\n       if (TREE_CODE (decl) == TYPE_DECL)\n \ttmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n+      else if (! DECL_TEMPLATE_INFO (decl))\n+\t/* A member definition that doesn't match anything in the class.  */\n+\treturn;\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n     }\n@@ -475,12 +479,10 @@ mangle_class_name_for_template (name, parms, arglist)\n   int i, nparms;\n \n   if (!scratch_firstobj)\n-    {\n-      gcc_obstack_init (&scratch_obstack);\n-      scratch_firstobj = obstack_alloc (&scratch_obstack, 1);\n-    }\n+    gcc_obstack_init (&scratch_obstack);\n   else\n     obstack_free (&scratch_obstack, scratch_firstobj);\n+  scratch_firstobj = obstack_alloc (&scratch_obstack, 1);\n \n #if 0\n #define buflen\tsizeof(buf)\n@@ -629,12 +631,6 @@ lookup_template_class (d1, arglist, in_decl)\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (TREE_TYPE (template)) == RECORD_TYPE)\n-    code_type_node = (CLASSTYPE_DECLARED_CLASS (TREE_TYPE (template))\n-\t\t      ? class_type_node : record_type_node);\n-  else\n-    code_type_node = union_type_node;\n-\n   if (PRIMARY_TEMPLATE_P (template))\n     {\n       parmlist = DECL_TEMPLATE_PARMS (template);\n@@ -675,7 +671,7 @@ lookup_template_class (d1, arglist, in_decl)\n       IDENTIFIER_TEMPLATE (id) = d1;\n \n       maybe_push_to_top_level (uses_template_parms (arglist));\n-      t = xref_tag (code_type_node, id, NULL_TREE, 1);\n+      t = xref_tag_from_type (TREE_TYPE (template), id, 1);\n       pop_from_top_level ();\n     }\n   else\n@@ -689,7 +685,7 @@ lookup_template_class (d1, arglist, in_decl)\n \t{\n \t  tree save_parms = current_template_parms;\n \t  current_template_parms = NULL_TREE;\n-\t  t = xref_tag (code_type_node, id, NULL_TREE, 0);\n+\t  t = xref_tag_from_type (TREE_TYPE (template), id, 0);\n \t  current_template_parms = save_parms;\n \t}\n       else\n@@ -978,7 +974,7 @@ tree\n instantiate_class_template (type)\n      tree type;\n {\n-  tree template, template_info, args, pattern, t, *field_chain, *tag_chain;\n+  tree template, template_info, args, pattern, t, *field_chain;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -1060,23 +1056,20 @@ instantiate_class_template (type)\n   CLASSTYPE_LOCAL_TYPEDECLS (type) = CLASSTYPE_LOCAL_TYPEDECLS (pattern);\n \n   field_chain = &TYPE_FIELDS (type);\n-  tag_chain = &CLASSTYPE_TAGS (type);\n \n   for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n     {\n       tree name = TREE_PURPOSE (t);\n       tree tag = TREE_VALUE (t);\n       tree newtag;\n \n+      /* These will add themselves to CLASSTYPE_TAGS for the new type.  */\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \tnewtag = start_enum (name);\n       else\n \tnewtag = tsubst (tag, &TREE_VEC_ELT (args, 0),\n \t\t\t TREE_VEC_LENGTH (args), NULL_TREE);\n \n-      *tag_chain = build_tree_list (name, newtag);\n-      tag_chain = &TREE_CHAIN (*tag_chain);\n-\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \t{\n \t  tree e, values = NULL_TREE, *last = &values;\n@@ -1124,16 +1117,30 @@ instantiate_class_template (type)\n   TYPE_METHODS (type) = tsubst_chain (TYPE_METHODS (pattern), args);\n \n   DECL_FRIENDLIST (TYPE_MAIN_DECL (type))\n-    = tsubst_chain (DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern)), args);\n-  CLASSTYPE_FRIEND_CLASSES (type)\n-    = tsubst_chain (CLASSTYPE_FRIEND_CLASSES (pattern), args);\n+    = tsubst (DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern)),\n+\t      &TREE_VEC_ELT (args, 0), TREE_VEC_LENGTH (args), NULL_TREE);\n \n   {\n-    tree d = tsubst (DECL_TEMPLATE_INJECT (template), &TREE_VEC_ELT (args, 0),\n+    tree d = CLASSTYPE_FRIEND_CLASSES (type) =\n+      tsubst (CLASSTYPE_FRIEND_CLASSES (pattern), &TREE_VEC_ELT (args, 0),\n+\t      TREE_VEC_LENGTH (args), NULL_TREE);\n+\n+    /* This does injection for friend classes.  */\n+    for (; d; d = TREE_CHAIN (d))\n+      TREE_VALUE (d) = xref_tag_from_type (TREE_VALUE (d), NULL_TREE, 1);\n+\n+    d = tsubst (DECL_TEMPLATE_INJECT (template), &TREE_VEC_ELT (args, 0),\n \t\t     TREE_VEC_LENGTH (args), NULL_TREE);\n \n     for (; d; d = TREE_CHAIN (d))\n-      pushdecl (TREE_VALUE (d));\n+      {\n+\ttree t = TREE_VALUE (d);\n+\n+\tif (TREE_CODE (t) == TYPE_DECL)\n+\t  /* Already injected.  */;\n+\telse\n+\t  pushdecl (t);\n+      }\n   }\n \n   TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n@@ -1781,6 +1788,11 @@ tsubst (t, args, nargs, in_decl)\n \t(CALL_EXPR, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n \t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl), 0);\n \n+    case SCOPE_REF:\n+      return build_parse_node\n+\t(TREE_CODE (t), tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n+\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\n     default:\n       sorry (\"use of `%s' in template\",\n \t     tree_code_name [(int) TREE_CODE (t)]);\n@@ -1866,6 +1878,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case CONVERT_EXPR:      /* Unary + */\n     case SIZEOF_EXPR:\n     case ARROW_EXPR:\n+    case THROW_EXPR:\n       return build1\n \t(code, NULL_TREE,\n \t tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl));\n@@ -1928,15 +1941,15 @@ tsubst_copy (t, args, nargs, in_decl)\n \tif (TREE_CODE (name) == BIT_NOT_EXPR)\n \t  {\n \t    name = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n-\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n+\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, TYPE_MAIN_VARIANT (name));\n \t  }\n \telse if (TREE_CODE (name) == SCOPE_REF\n \t\t && TREE_CODE (TREE_OPERAND (name, 1)) == BIT_NOT_EXPR)\n \t  {\n \t    tree base = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n \t    name = TREE_OPERAND (name, 1);\n \t    name = tsubst_copy (TREE_OPERAND (name, 0), args, nargs, in_decl);\n-\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n+\t    name = build1 (BIT_NOT_EXPR, NULL_TREE, TYPE_MAIN_VARIANT (name));\n \t    name = build_nt (SCOPE_REF, base, name);\n \t  }\n \telse\n@@ -2915,7 +2928,7 @@ instantiate_decl (d)\n \t    warn_if_unknown_interface (pattern);\n \t}\n \n-      if (at_eof)\n+      if (at_eof && ! DECL_INLINE (d))\n \timport_export_decl (d);\n     }\n "}, {"sha": "588d8231f0946108af70e3f359076594fa2ae4c1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 64, "deletions": 46, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -146,7 +146,7 @@ static int n_calls_lookup_fnfields, n_calls_lookup_fnfields_1;\n static int n_calls_get_base_type;\n static int n_outer_fields_searched;\n static int n_contexts_saved;\n-#endif\n+#endif /* GATHER_STATISTICS */\n \n /* Local variables to help save memoization contexts.  */\n static tree prev_type_memoized;\n@@ -323,7 +323,7 @@ push_memoized_context (type, use_old)\n \t{\n #ifdef GATHER_STATISTICS\n \t  n_contexts_saved++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n \t  type_stack = prev_type_stack;\n \t  prev_type_stack = 0;\n \n@@ -694,12 +694,12 @@ lookup_field_1 (type, name)\n \n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field_1++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n   while (field)\n     {\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n       if (DECL_NAME (field) == NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t{\n@@ -724,8 +724,6 @@ lookup_field_1 (type, name)\n       if (TYPE_VIRTUAL_P (type))\n \treturn CLASSTYPE_VFIELD (type);\n     }\n-  if (name == constructor_name (type))\n-    return TYPE_STUB_DECL (type);\n   return NULL_TREE;\n }\n \n@@ -845,10 +843,10 @@ compute_access (basetype_path, field)\n \n   /* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT\n      slot set to the union type rather than the record type containing\n-     the anonymous union.  In this case, DECL_FIELD_CONTEXT is correct.  */\n+     the anonymous union.  */\n   if (context && TREE_CODE (context) == UNION_TYPE\n       && ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n-    context = DECL_FIELD_CONTEXT (field);\n+    context = TYPE_CONTEXT (context);\n \n   /* Virtual function tables are never private.  But we should know that\n      we are looking for this, and not even try to hide it.  */\n@@ -1020,7 +1018,8 @@ lookup_fnfields_here (type, name)\n   int index = lookup_fnfields_1 (type, name);\n   tree fndecls;\n \n-  if (index <= 0)\n+  /* ctors and dtors are always only in the right class.  */\n+  if (index <= 1)\n     return index;\n   fndecls = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), index);\n   while (fndecls)\n@@ -1074,10 +1073,14 @@ lookup_field (xbasetype, name, protect, want_type)\n      accurate error messages for access control.  */\n   int index = MEMOIZED_HASH_FN (name);\n \n+#if 0\n+  /* We cannot search for constructor/destructor names like this.  */\n+  /* This can't go here, but where should it go?  */\n   /* If we are looking for a constructor in a templated type, use the\n      unspecialized name, as that is how we store it.  */\n   if (IDENTIFIER_TEMPLATE (name))\n     name = constructor_name (name);\n+#endif\n \n   if (TREE_CODE (xbasetype) == TREE_VEC)\n     {\n@@ -1121,7 +1124,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n   if (protect && flag_memoize_lookups && ! global_bindings_p ())\n     entry = make_memoized_table_entry (type, name, 0);\n   else\n@@ -1137,10 +1140,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    {\n \t      if (TREE_CODE (rval) != TYPE_DECL)\n \t\t{\n-\t\t  if (name == constructor_name (type))\n-\t\t    rval = type;\n-\t\t  else\n-\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t  rval = purpose_member (name, CLASSTYPE_TAGS (type));\n \t\t  if (rval)\n \t\t    rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n \t\t}\n@@ -1322,10 +1322,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      {\n \t\tif (TREE_CODE (rval) != TYPE_DECL)\n \t\t  {\n-\t\t    if (name == constructor_name (type))\n-\t\t      rval = type;\n-\t\t    else\n-\t\t      rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n \t\t    if (rval)\n \t\t      rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n \t\t  }\n@@ -1468,10 +1465,8 @@ lookup_nested_field (name, complain)\n \t\t\t enums in nested classes) when we do need to call\n \t\t\t this fn at parse time.  So, in those cases, we pass\n \t\t\t complain as a 0 and just return a NULL_TREE.  */\n-\t\t      error (\"assignment to non-static member `%s' of enclosing class `%s'\",\n-\t\t\t     lang_printable_name (id),\n-\t\t\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER\n-\t\t\t\t\t\t (DECL_CONTEXT (t))));\n+\t\t      cp_error (\"assignment to non-static member `%D' of enclosing class `%T'\",\n+\t\t\t\tid, DECL_CONTEXT (t));\n \t\t      /* Mark this for do_identifier().  It would otherwise\n \t\t\t claim that the variable was undeclared.  */\n \t\t      TREE_TYPE (id) = error_mark_node;\n@@ -1505,15 +1500,21 @@ lookup_fnfields_1 (type, name)\n \n #ifdef GATHER_STATISTICS\n       n_calls_lookup_fnfields_1++;\n-#endif\n-      if (*methods && name == constructor_name (type))\n+#endif /* GATHER_STATISTICS */\n+\n+      /* Constructors are first...  */\n+      if (*methods && name == ctor_identifier)\n \treturn 0;\n \n+      /* and destructors are second.  */\n+      if (*++methods && name == dtor_identifier)\n+\treturn 1;\n+\n       while (++methods != end)\n \t{\n #ifdef GATHER_STATISTICS\n \t  n_outer_fields_searched++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n \t  if (DECL_NAME (*methods) == name)\n \t    break;\n \t}\n@@ -1581,10 +1582,14 @@ lookup_fnfields (basetype_path, name, complain)\n       protect = complain = 0;\n     }\n \n+#if 0\n+  /* We cannot search for constructor/destructor names like this.  */\n+  /* This can't go here, but where should it go?  */\n   /* If we are looking for a constructor in a templated type, use the\n      unspecialized name, as that is how we store it.  */\n   if (IDENTIFIER_TEMPLATE (name))\n     name = constructor_name (name);\n+#endif\n \n   binfo = basetype_path;\n   binfo_h = binfo;\n@@ -1644,7 +1649,7 @@ lookup_fnfields (basetype_path, name, complain)\n \n #ifdef GATHER_STATISTICS\n   n_calls_lookup_fnfields++;\n-#endif\n+#endif /* GATHER_STATISTICS */\n   if (protect && flag_memoize_lookups && ! global_bindings_p ())\n     entry = make_memoized_table_entry (type, name, 1);\n   else\n@@ -1674,6 +1679,16 @@ lookup_fnfields (basetype_path, name, complain)\n     }\n   rval = NULL_TREE;\n \n+  if (name == ctor_identifier || name == dtor_identifier)\n+    {\n+      /* Don't allow lookups of constructors and destructors to go\n+ \t deeper than the first place we look.  */\n+      if (entry)\n+ \tTREE_TYPE (entry) = TREE_VALUE (entry) = NULL_TREE;\n+\n+      return NULL_TREE;\n+    }\n+\n   if (basetype_path == TYPE_BINFO (type))\n     {\n       basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n@@ -1930,16 +1945,17 @@ get_virtuals_named_this (binfo)\n   return NULL_TREE;\n }\n \n-static tree get_virtual_destructor (binfo, i)\n+static tree\n+get_virtual_destructor (binfo, i)\n      tree binfo;\n      int i;\n {\n   tree type = BINFO_TYPE (binfo);\n   if (i >= 0)\n     type = BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo), i));\n   if (TYPE_HAS_DESTRUCTOR (type)\n-      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0)))\n-    return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 0);\n+      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1)))\n+    return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1);\n   return 0;\n }\n \n@@ -2336,7 +2352,7 @@ dfs_walk (binfo, fn, qfn)\n \t\t  /* No need for the conversion here, as we know it is the\n \t\t     right type.  */\n \t\t  vbase_decl_ptr_intermediate\n-\t\t    = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo));\n+\t\t    = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo));\n \t\t}\n \t      else\n \t\t{\n@@ -2477,10 +2493,12 @@ dfs_debug_mark (binfo)\n   if (current_function_decl == NULL_TREE\n       || DECL_CLASS_CONTEXT (current_function_decl) != t)\n     {\n-      if (TREE_VEC_ELT (methods, 0))\n+      if (TREE_VEC_ELT (methods, 1))\n+\tmethods = TREE_VEC_ELT (methods, 1);\n+      else if (TREE_VEC_ELT (methods, 0))\n \tmethods = TREE_VEC_ELT (methods, 0);\n       else\n-\tmethods = TREE_VEC_ELT (methods, 1);\n+\tmethods = TREE_VEC_ELT (methods, 2);\n       while (methods)\n \t{\n \t  if (DECL_VINDEX (methods)\n@@ -2523,8 +2541,8 @@ dfs_find_vbases (binfo)\n \t  tree binfo = binfo_member (vbase, vbase_types);\n \n \t  CLASSTYPE_SEARCH_SLOT (vbase)\n-\t    = (char *) build (PLUS_EXPR, build_pointer_type (vbase),\n-\t\t\t      vbase_decl_ptr, BINFO_OFFSET (binfo));\n+\t    = build (PLUS_EXPR, build_pointer_type (vbase),\n+\t\t     vbase_decl_ptr, BINFO_OFFSET (binfo));\n \t}\n     }\n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n@@ -2563,7 +2581,7 @@ dfs_init_vbase_pointers (binfo)\n     {\n       tree ref = build (COMPONENT_REF, TREE_TYPE (fields),\n \t\t\tbuild_indirect_ref (this_vbase_ptr, NULL_PTR), fields);\n-      tree init = (tree)CLASSTYPE_SEARCH_SLOT (TREE_TYPE (TREE_TYPE (fields)));\n+      tree init = CLASSTYPE_SEARCH_SLOT (TREE_TYPE (TREE_TYPE (fields)));\n       vbase_init_result = tree_cons (binfo_member (TREE_TYPE (TREE_TYPE (fields)),\n \t\t\t\t\t\t   vbase_types),\n \t\t\t\t     build_modify_expr (ref, NOP_EXPR, init),\n@@ -2682,7 +2700,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   delta = purpose_member (vbase, *vbase_offsets);\n   if (! delta)\n     {\n-      delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbase));\n+      delta = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbase));\n       delta = build (MINUS_EXPR, ptrdiff_type_node, delta, vbase_addr);\n       delta = save_expr (delta);\n       delta = tree_cons (vbase, delta, *vbase_offsets);\n@@ -2751,7 +2769,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      if (! vc_delta)\n \t\t{\n \t\t  tree vc_addr = convert_pointer_to_real (vc, orig_addr);\n-\t\t  vc_delta = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vc));\n+\t\t  vc_delta = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vc));\n \t\t  vc_delta = build (MINUS_EXPR, ptrdiff_type_node,\n \t\t\t\t    vc_delta, vc_addr);\n \t\t  vc_delta = save_expr (vc_delta);\n@@ -3207,10 +3225,10 @@ dfs_pushdecls (binfo)\n     }\n \n   method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (method_vec != 0)\n+  if (method_vec)\n     {\n       /* Farm out constructors and destructors.  */\n-      methods = &TREE_VEC_ELT (method_vec, 1);\n+      methods = &TREE_VEC_ELT (method_vec, 2);\n       end = TREE_VEC_END (method_vec);\n \n       while (methods != end)\n@@ -3257,7 +3275,7 @@ dfs_compress_decls (binfo)\n   if (method_vec != 0)\n     {\n       /* Farm out constructors and destructors.  */\n-      tree *methods = &TREE_VEC_ELT (method_vec, 1);\n+      tree *methods = &TREE_VEC_ELT (method_vec, 2);\n       tree *end = TREE_VEC_END (method_vec);\n \n       for (; methods != end; methods++)\n@@ -3404,9 +3422,9 @@ print_search_statistics ()\n   fprintf (stderr, \"%d fnfields searched in %d calls to lookup_fnfields\\n\",\n \t   n_outer_fields_searched, n_calls_lookup_fnfields);\n   fprintf (stderr, \"%d calls to get_base_type\\n\", n_calls_get_base_type);\n-#else\n+#else /* GATHER_STATISTICS */\n   fprintf (stderr, \"no search statistics\\n\");\n-#endif\n+#endif /* GATHER_STATISTICS */\n }\n \n void\n@@ -3441,7 +3459,7 @@ reinit_search_statistics ()\n   n_calls_get_base_type = 0;\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n-#endif\n+#endif /* GATHER_STATISTICS */\n }\n \n static tree conversions;\n@@ -3450,11 +3468,11 @@ add_conversions (binfo)\n      tree binfo;\n {\n   int i;\n-  tree vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n \n-  for (i = 1; i < TREE_VEC_LENGTH (vec); ++i)\n+  for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n-      tree tmp = TREE_VEC_ELT (vec, i);\n+      tree tmp = TREE_VEC_ELT (method_vec, i);\n       if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n \tbreak;\n       conversions = tree_cons (DECL_NAME (tmp), TREE_TYPE (TREE_TYPE (tmp)),"}, {"sha": "ace8c8f56c4ddc6c5de29aa95c80be2a37d27b6b", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -71,7 +71,7 @@ static int debug_yychar ();\n void\n init_spew ()\n {\n-  gcc_obstack_init(&token_obstack);\n+  gcc_obstack_init (&token_obstack);\n }\n \n #ifdef SPEW_DEBUG\n@@ -81,7 +81,7 @@ init_spew ()\n static int\n num_tokens ()\n {\n-  return (obstack_object_size(&token_obstack)/sizeof(struct token))\n+  return (obstack_object_size (&token_obstack) / sizeof (struct token))\n     - first_token;\n }\n \n@@ -92,25 +92,25 @@ nth_token (n)\n {\n   /* could just have this do slurp_ implicitly, but this way is easier\n    * to debug... */\n-  my_friendly_assert (n < num_tokens(), 298);\n-  return ((struct token*)obstack_base(&token_obstack))+n+first_token;\n+  my_friendly_assert (n < num_tokens (), 298);\n+  return ((struct token*)obstack_base (&token_obstack)) + n + first_token;\n }\n \n /* Add a token to the token fifo. */\n static void\n add_token (t)\n      struct token* t;\n {\n-  obstack_grow(&token_obstack,t,sizeof (struct token));\n+  obstack_grow (&token_obstack, t, sizeof (struct token));\n }\n \n /* Consume the next token out of the fifo.  */\n static void\n-consume_token()\n+consume_token ()\n {\n-  if (num_tokens() == 1)\n+  if (num_tokens () == 1)\n     {\n-      obstack_free(&token_obstack, obstack_base (&token_obstack));\n+      obstack_free (&token_obstack, obstack_base (&token_obstack));\n       first_token = 0;\n     }\n   else\n@@ -121,15 +121,15 @@ consume_token()\n /* ...otherwise use macros.  */\n \n #define num_tokens() \\\n-  ((obstack_object_size(&token_obstack)/sizeof(struct token)) - first_token)\n+  ((obstack_object_size (&token_obstack) / sizeof (struct token)) - first_token)\n \n #define nth_token(N) \\\n-  (((struct token*)obstack_base(&token_obstack))+(N)+first_token)\n+  (((struct token*)obstack_base (&token_obstack))+(N)+first_token)\n \n-#define add_token(T) obstack_grow(&token_obstack, (T), sizeof (struct token))\n+#define add_token(T) obstack_grow (&token_obstack, (T), sizeof (struct token))\n \n #define consume_token() \\\n-  (num_tokens() == 1\t\t\t\t\t\t\t\\\n+  (num_tokens () == 1\t\t\t\t\t\t\t\\\n    ? (obstack_free (&token_obstack, obstack_base (&token_obstack)),\t\\\n       (first_token = 0))\t\t\t\t\t\t\\\n    : first_token++)\n@@ -158,11 +158,11 @@ scan_tokens (n)\n \tgoto pad_tokens;\n     }\n \n-  while (num_tokens() <= n)\n+  while (num_tokens () <= n)\n     {\n-      obstack_blank(&token_obstack,sizeof (struct token));\n+      obstack_blank (&token_obstack, sizeof (struct token));\n       tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n-      tmp->yychar = real_yylex();\n+      tmp->yychar = real_yylex ();\n       tmp->end_of_file = end_of_file;\n       tmp->yylval = yylval;\n       end_of_file = 0;\n@@ -173,7 +173,7 @@ scan_tokens (n)\n \tpad_tokens:\n \t  while (num_tokens () <= n)\n \t    {\n-\t      obstack_blank(&token_obstack,sizeof (struct token));\n+\t      obstack_blank (&token_obstack, sizeof (struct token));\n \t      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n \t      tmp->yychar = EMPTY;\n \t      tmp->end_of_file = 0;\n@@ -216,14 +216,14 @@ tree got_scope;\n tree got_object;\n \n int\n-peekyylex()\n+peekyylex ()\n {\n   scan_tokens (0);\n   return nth_token (0)->yychar;\n }\n \n int\n-yylex()\n+yylex ()\n {\n   struct token tmp_token;\n   tree trrr;\n@@ -233,14 +233,14 @@ yylex()\n   if (spew_debug)\n   {\n     yylex_ctr ++;\n-    fprintf(stderr, \"\\t\\t## %d ##\",yylex_ctr);\n+    fprintf (stderr, \"\\t\\t## %d ##\", yylex_ctr);\n   }\n #endif\n \n   /* if we've got tokens, send them */\n-  if (num_tokens())\n+  if (num_tokens ())\n     {\n-      tmp_token= *nth_token(0);\n+      tmp_token= *nth_token (0);\n \n       /* TMP_TOKEN.YYLVAL.TTYPE may have been allocated on the wrong obstack.\n \t If we don't find it in CURRENT_OBSTACK's current or immediately\n@@ -258,13 +258,13 @@ yylex()\n       tmp_token.yychar = real_yylex ();\n       tmp_token.yylval = yylval;\n       tmp_token.end_of_file = end_of_file;\n-      add_token(&tmp_token);\n+      add_token (&tmp_token);\n     }\n \n   /* many tokens just need to be returned. At first glance, all we\n    * have to do is send them back up, but some of them are needed to\n    * figure out local context. */\n-  switch(tmp_token.yychar)\n+  switch (tmp_token.yychar)\n     {\n     case EMPTY:\n       /* This is a lexical no-op.  */\n@@ -341,15 +341,15 @@ yylex()\n       break;\n \n     case AGGR:\n-      *nth_token(0) = tmp_token;\n+      *nth_token (0) = tmp_token;\n       do_aggr ();\n       /* fall through to output... */\n     case ENUM:\n       /* Set this again, in case we are rescanning.  */\n       looking_for_typename = 1;\n       /* fall through... */\n     default:\n-      consume_token();\n+      consume_token ();\n     }\n \n   got_object = NULL_TREE;\n@@ -358,7 +358,7 @@ yylex()\n   end_of_file = tmp_token.end_of_file;\n #ifdef SPEW_DEBUG    \n   if (spew_debug)\n-    debug_yychar(yychar);\n+    debug_yychar (yychar);\n #endif\n   return yychar;\n }\n@@ -423,7 +423,7 @@ debug_yychar (yy)\n   \n   int i;\n   \n-  if(yy<256) {\n+  if (yy<256) {\n     fprintf (stderr, \"<%d: %c >\\n\", yy, yy);\n     return 0;\n   }"}, {"sha": "5c8fc1ce36be820615ee18ca4f95d591a5a83dc6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -800,9 +800,9 @@ layout_basetypes (rec, binfos)\n \t  vbase_decls = decl;\n \n \t  if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (basetype)\n-\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0)) == NULL_TREE)\n+\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1)) == NULL_TREE)\n \t    {\n-\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0),\n+\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1),\n \t\t\t\t \"destructor `%s' non-virtual\");\n \t      warning (\"in inheritance relationship `%s: virtual %s'\",\n \t\t       TYPE_NAME_STRING (rec),\n@@ -827,9 +827,9 @@ layout_basetypes (rec, binfos)\n \t     claim it as theirs and explain exactly what circumstances\n \t     warrant the warning.  */ \n \t  if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (basetype)\n-\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0)) == NULL_TREE)\n+\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1)) == NULL_TREE)\n \t    {\n-\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0),\n+\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1),\n \t\t\t\t \"destructor `%s' non-virtual\");\n \t      warning (\"in inheritance relationship `%s:%s %s'\",\n \t\t       TYPE_NAME_STRING (rec),\n@@ -1950,7 +1950,8 @@ min_tree_cons (purpose, value, chain)\n   register struct obstack *ambient_obstack = current_obstack;\n   current_obstack = &permanent_obstack;\n \n-  node = tree_cons (purpose, value, chain);\n+  node = tree_cons (copy_to_permanent (purpose),\n+\t\t    copy_to_permanent (value), chain);\n   current_obstack = ambient_obstack;\n   return node;\n }"}, {"sha": "44e05b848b1a1ef6946391146f6cc0abf12b33f7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -1767,6 +1767,12 @@ build_component_ref (datum, component, basetype_path, protect)\n       basetype = TREE_TYPE (datum);\n       code = TREE_CODE (basetype);\n     }\n+  if (TREE_CODE (datum) == OFFSET_REF)\n+    {\n+      datum = resolve_offset_ref (datum);\n+      basetype = TREE_TYPE (datum);\n+      code = TREE_CODE (basetype);\n+    }\n \n   /* First, see if there is a field or component with name COMPONENT. */\n   if (TREE_CODE (component) == TREE_LIST)\n@@ -1803,7 +1809,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  cp_error (\"type `%T' has no destructor\", basetype);\n \t  return error_mark_node;\n \t}\n-      return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 0);\n+      return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1);\n     }\n \n   /* Look up component name in the structure type definition.  */\n@@ -1905,7 +1911,8 @@ build_component_ref (datum, component, basetype_path, protect)\n     {\n       tree context = DECL_FIELD_CONTEXT (field);\n       tree base = context;\n-      while (base != basetype && ANON_AGGRNAME_P (TYPE_IDENTIFIER (base)))\n+      while (base != basetype && TYPE_NAME (base)\n+\t     && ANON_AGGRNAME_P (TYPE_IDENTIFIER (base)))\n \t{\n \t  base = TYPE_CONTEXT (base);\n \t}\n@@ -1935,7 +1942,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       basetype = base;\n  \n       /* Handle things from anon unions here...  */\n-      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n+      if (TYPE_NAME (context) && ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n \t{\n \t  tree subfield = lookup_anon_field (basetype, context);\n \t  tree subdatum = build_component_ref (datum, subfield,\n@@ -2231,13 +2238,35 @@ build_x_function_call (function, params, decl)\n     return build_min_nt (CALL_EXPR, function, params, 0);\n \n   type = TREE_TYPE (function);\n+\n+  if (TREE_CODE (type) == OFFSET_TYPE\n+      && TREE_TYPE (type) == unknown_type_node\n+      && TREE_CODE (function) == TREE_LIST\n+      && TREE_CHAIN (function) == NULL_TREE)\n+    {\n+      /* Undo (Foo:bar)()... */\n+      type = TYPE_OFFSET_BASETYPE (type);\n+      function = TREE_VALUE (function);\n+      my_friendly_assert (TREE_CODE (function) == TREE_LIST, 999);\n+      my_friendly_assert (TREE_CHAIN (function) == NULL_TREE, 999);\n+      function = TREE_VALUE (function);\n+      my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 999);\n+      function = DECL_NAME (function);\n+      return build_method_call (decl, function, params, TYPE_BINFO (type), LOOKUP_NORMAL);\n+    }\n+    \n   is_method = ((TREE_CODE (function) == TREE_LIST\n \t\t&& current_class_type != NULL_TREE\n \t\t&& IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (function)) == function)\n \t       || TREE_CODE (function) == IDENTIFIER_NODE\n \t       || TREE_CODE (type) == METHOD_TYPE\n \t       || TYPE_PTRMEMFUNC_P (type));\n \n+  if (TREE_CODE (function) == FUNCTION_DECL\n+      && DECL_STATIC_FUNCTION_P (function))\n+    return build_member_call\n+      (DECL_CONTEXT (function), DECL_NAME (function), params);\n+\n   /* Handle methods, friends, and overloaded functions, respectively.  */\n   if (is_method)\n     {\n@@ -2712,9 +2741,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      char *buf = (char *)alloca (40 + strlen (called_thing));\n-\t      sprintf (buf, \"too many arguments to %s `%%s'\", called_thing);\n-\t      error_with_decl (fndecl, buf);\n+\t      cp_error_at (\"too many arguments to %s `%+D'\", called_thing,\n+\t\t\t   fndecl);\n \t      error (\"at this point in file\");\n \t    }\n \t  else\n@@ -4877,30 +4905,42 @@ build_conditional_expr (ifexp, op1, op2)\n \t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n \t  return error_mark_node;\n \t}\n+      /* Warning: this code assumes that conversion between cv-variants of\n+         a type is done using NOP_EXPRs.  */\n       if (code1 == RECORD_TYPE && TYPE_HAS_CONVERSION (type1))\n \t{\n-\t  tree tmp = build_type_conversion (CONVERT_EXPR, type2, op1, 0);\n+\t  tree tmp = build_pointer_type\n+\t    (build_type_variant (TREE_TYPE (type2), 1, 1));\n+\t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op1, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n-\t      cp_error (\"aggregate type `%T' could not convert on lhs of `:'\", type1);\n+\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n+\t\t\ttype1, type2);\n \t      return error_mark_node;\n \t    }\n \t  if (tmp == error_mark_node)\n \t    error (\"ambiguous pointer conversion\");\n-\t  result_type = type2;\n+\t  else\n+\t    STRIP_NOPS (tmp);\n+\t  result_type = common_type (type1, TREE_TYPE (tmp));\n \t  op1 = tmp;\n \t}\n       else if (code2 == RECORD_TYPE && TYPE_HAS_CONVERSION (type2))\n \t{\n-\t  tree tmp = build_type_conversion (CONVERT_EXPR, type1, op2, 0);\n+\t  tree tmp = build_pointer_type\n+\t    (build_type_variant (TREE_TYPE (type1), 1, 1));\n+\t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op2, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n-\t      cp_error (\"aggregate type `%T' could not convert on rhs of `:'\", type2);\n+\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n+\t\t\ttype1, type2);\n \t      return error_mark_node;\n \t    }\n \t  if (tmp == error_mark_node)\n \t    error (\"ambiguous pointer conversion\");\n-\t  result_type = type1;\n+\t  else\n+\t    STRIP_NOPS (tmp);\n+\t  result_type = common_type (type1, TREE_TYPE (tmp));\n \t  op2 = tmp;\n \t}\n       else if (flag_cond_mismatch)\n@@ -5183,12 +5223,6 @@ build_c_cast (type, expr, allow_nonconverting)\n       return error_mark_node;\n     }\n \n-  /* If there's only one function in the overloaded space,\n-     just take it.  */\n-  if (TREE_CODE (value) == TREE_LIST\n-      && TREE_CHAIN (value) == NULL_TREE)\n-    value = TREE_VALUE (value);\n-\n   if (current_template_parms)\n     {\n       tree t = build_min (CAST_EXPR, type,\n@@ -5471,9 +5505,9 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* Do the default thing */;\n       else\n \t{\n-\t  result = build_method_call (lhs, constructor_name_full (lhstype),\n+\t  result = build_method_call (lhs, ctor_identifier,\n \t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t      NULL_TREE, LOOKUP_NORMAL);\n+\t\t\t\t      TYPE_BINFO (lhstype), LOOKUP_NORMAL);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n \t  return result;\n@@ -6688,7 +6722,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t{\n \t  if (TYPE_HAS_INIT_REF (type))\n \t    {\n-\t      tree init = build_method_call (exp, constructor_name_full (type),\n+\t      tree init = build_method_call (exp, ctor_identifier,\n \t\t\t\t\t     build_tree_list (NULL_TREE, rhs),\n \t\t\t\t\t     TYPE_BINFO (type), LOOKUP_NORMAL);\n \n@@ -6721,7 +6755,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t  return rhs;\n \t}\n \n-      return cp_convert (type, rhs, CONV_OLD_CONVERT, flags);\n+      return cp_convert (type, rhs, CONV_OLD_CONVERT,\n+\t\t\t flags | LOOKUP_NO_CONVERSION);\n     }\n \n   if (type == TREE_TYPE (rhs))"}, {"sha": "76ac10402e3a9ff4f5d43efc5cc58f2a52908e8e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 24, "deletions": 69, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc378698688e76cd83c0171c493703858b822bac/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=fc378698688e76cd83c0171c493703858b822bac", "patch": "@@ -71,29 +71,6 @@ binfo_or_else (parent_or_type, type)\n   return NULL_TREE;\n }\n \n-/* Print an error message stemming from an invalid use of an\n-   aggregate type.\n-\n-   TYPE is the type or binfo which draws the error.\n-   MSG is the message to print.\n-   ARG is an optional argument which may provide more information.  */\n-void\n-error_with_aggr_type (type, msg, arg)\n-     tree type;\n-     char *msg;\n-     HOST_WIDE_INT arg;\n-{\n-  tree name;\n-\n-  if (TREE_CODE (type) == TREE_VEC)\n-    type = BINFO_TYPE (type);\n-\n-  name = TYPE_NAME (type);\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  error (msg, IDENTIFIER_POINTER (name), arg);\n-}\n-\n /* According to ARM $7.1.6, \"A `const' object may be initialized, but its\n    value may not be changed thereafter.  Thus, we emit hard errors for these,\n    rather than just pedwarns.  If `SOFT' is 1, then we just pedwarn.  (For\n@@ -108,40 +85,37 @@ readonly_error (arg, string, soft)\n   void (*fn)();\n \n   if (soft)\n-    fn = pedwarn;\n+    fn = cp_pedwarn;\n   else\n-    fn = error;\n+    fn = cp_error;\n \n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-        fmt = \"%s of member `%s' in read-only structure\";\n+        fmt = \"%s of member `%D' in read-only structure\";\n       else\n-        fmt = \"%s of read-only member `%s'\";\n-      (*fn) (fmt, string, lang_printable_name (TREE_OPERAND (arg, 1)));\n+        fmt = \"%s of read-only member `%D'\";\n+      (*fn) (fmt, string, TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n     {\n       if (DECL_LANG_SPECIFIC (arg)\n \t  && DECL_IN_AGGR_P (arg)\n \t  && !TREE_STATIC (arg))\n-\tfmt = \"%s of constant field `%s'\";\n+\tfmt = \"%s of constant field `%D'\";\n       else\n-\tfmt = \"%s of read-only variable `%s'\";\n-      (*fn) (fmt, string, lang_printable_name (arg));\n+\tfmt = \"%s of read-only variable `%D'\";\n+      (*fn) (fmt, string, arg);\n     }\n   else if (TREE_CODE (arg) == PARM_DECL)\n-    (*fn) (\"%s of read-only parameter `%s'\", string,\n-\t   lang_printable_name (arg));\n+    (*fn) (\"%s of read-only parameter `%D'\", string, arg);\n   else if (TREE_CODE (arg) == INDIRECT_REF\n            && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n            && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n                || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n-    (*fn) (\"%s of read-only reference `%s'\",\n-\t   string, lang_printable_name (TREE_OPERAND (arg, 0)));\n+    (*fn) (\"%s of read-only reference `%D'\", string, TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n-    (*fn) (\"%s of read-only named return value `%s'\",\n-\t   string, lang_printable_name (arg));\n+    (*fn) (\"%s of read-only named return value `%D'\", string, arg);\n   else\t       \n     (*fn) (\"%s of read-only location\", string);\n }\n@@ -239,8 +213,7 @@ incomplete_type_error (value, type)\n \n   if (value != 0 && (TREE_CODE (value) == VAR_DECL\n \t\t     || TREE_CODE (value) == PARM_DECL))\n-    error (\"`%s' has an incomplete type\",\n-\t   IDENTIFIER_POINTER (DECL_NAME (value)));\n+    cp_error (\"`%D' has incomplete type\", value);\n   else\n     {\n     retry:\n@@ -249,15 +222,9 @@ incomplete_type_error (value, type)\n       switch (TREE_CODE (type))\n \t{\n \tcase RECORD_TYPE:\n-\t  errmsg = \"invalid use of undefined type `struct %s'\";\n-\t  break;\n-\n \tcase UNION_TYPE:\n-\t  errmsg = \"invalid use of undefined type `union %s'\";\n-\t  break;\n-\n \tcase ENUMERAL_TYPE:\n-\t  errmsg = \"invalid use of undefined type `enum %s'\";\n+\t  errmsg = \"invalid use of undefined type `%#T'\";\n \t  break;\n \n \tcase VOID_TYPE:\n@@ -281,7 +248,7 @@ incomplete_type_error (value, type)\n \t  my_friendly_abort (108);\n \t}\n \n-      error_with_aggr_type (type, errmsg);\n+      cp_error (errmsg, type);\n     }\n }\n \n@@ -1410,28 +1377,23 @@ build_m_component_ref (datum, component)\n   return build (OFFSET_REF, rettype, datum, component);\n }\n \n-/* Return a tree node for the expression TYPENAME '(' PARMS ')'.\n-\n-   Because we cannot tell whether this construct is really a call to a\n-   constructor or a request for a type conversion, we try both, and\n-   report any ambiguities we find.  */\n+/* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */\n tree\n build_functional_cast (exp, parms)\n      tree exp;\n      tree parms;\n {\n+  tree binfo;\n+\n   /* This is either a call to a constructor,\n      or a C cast in C++'s `functional' notation.  */\n-  tree type, name = NULL_TREE;\n-  tree expr_as_ctor = NULL_TREE;\n+  tree type;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n     return error_mark_node;\n \n   if (TREE_CODE (exp) == IDENTIFIER_NODE)\n     {\n-      name = exp;\n-\n       if (IDENTIFIER_HAS_TYPE_VALUE (exp))\n \t/* Either an enum or an aggregate type.  */\n \ttype = IDENTIFIER_TYPE_VALUE (exp);\n@@ -1440,7 +1402,7 @@ build_functional_cast (exp, parms)\n \t  type = lookup_name (exp, 1);\n \t  if (!type || TREE_CODE (type) != TYPE_DECL)\n \t    {\n-\t      cp_error (\"`%T' fails to be a typedef or built-in type\", name);\n+\t      cp_error (\"`%T' fails to be a typedef or built-in type\", exp);\n \t      return error_mark_node;\n \t    }\n \t  type = TREE_TYPE (type);\n@@ -1482,29 +1444,22 @@ build_functional_cast (exp, parms)\n \t \n      then the slot being initialized will be filled in.  */\n \n-  if (name == NULL_TREE)\n-    {\n-      name = TYPE_NAME (type);\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NESTED_TYPENAME (name);\n-    }\n-\n   if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n     {\n       cp_error (\"type `%T' is not yet defined\", type);\n       return error_mark_node;\n     }\n \n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-    return build_c_cast (type, parms, 1);\n+    return build_c_cast (type, TREE_VALUE (parms), 1);\n \n-  expr_as_ctor = build_method_call (NULL_TREE, name, parms,\n-\t\t\t\t    NULL_TREE, LOOKUP_NORMAL);\n+  exp = build_method_call (NULL_TREE, ctor_identifier, parms,\n+\t\t\t   TYPE_BINFO (type), LOOKUP_NORMAL);\n \n-  if (expr_as_ctor == error_mark_node)\n+  if (exp == error_mark_node)\n     return error_mark_node;\n \n-  return build_cplus_new (type, expr_as_ctor);\n+  return build_cplus_new (type, exp);\n }\n \f\n /* Return the character string for the name that encodes the"}]}