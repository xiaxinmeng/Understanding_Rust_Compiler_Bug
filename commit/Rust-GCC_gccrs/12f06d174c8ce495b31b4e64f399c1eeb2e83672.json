{"sha": "12f06d174c8ce495b31b4e64f399c1eeb2e83672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmMDZkMTc0YzhjZTQ5NWIzMWI0ZTY0ZjM5OWMxZWViMmU4MzY3Mg==", "commit": {"author": {"name": "Charles M. Hannum", "email": "root@ihack.net", "date": "1999-01-06T01:28:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T01:28:56Z"}, "message": "expr.c (store_expr): If the lhs is a memory location pointed to be a postincremented (or...\n\n\ufffd\n        * expr.c (store_expr): If the lhs is a memory location pointed\n        to be a postincremented (or postdecremented) pointer, always\n        force the rhs to be evaluated into a pseudo.\n\nFrom-SVN: r24507", "tree": {"sha": "b7c9a0b5e5732c3e2352370cd06bdd08df1ce5df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7c9a0b5e5732c3e2352370cd06bdd08df1ce5df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f06d174c8ce495b31b4e64f399c1eeb2e83672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f06d174c8ce495b31b4e64f399c1eeb2e83672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f06d174c8ce495b31b4e64f399c1eeb2e83672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f06d174c8ce495b31b4e64f399c1eeb2e83672/comments", "author": {"login": "mycroftxxx", "id": 1772872, "node_id": "MDQ6VXNlcjE3NzI4NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1772872?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mycroftxxx", "html_url": "https://github.com/mycroftxxx", "followers_url": "https://api.github.com/users/mycroftxxx/followers", "following_url": "https://api.github.com/users/mycroftxxx/following{/other_user}", "gists_url": "https://api.github.com/users/mycroftxxx/gists{/gist_id}", "starred_url": "https://api.github.com/users/mycroftxxx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mycroftxxx/subscriptions", "organizations_url": "https://api.github.com/users/mycroftxxx/orgs", "repos_url": "https://api.github.com/users/mycroftxxx/repos", "events_url": "https://api.github.com/users/mycroftxxx/events{/privacy}", "received_events_url": "https://api.github.com/users/mycroftxxx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3fa7e9f2a52018d7d0a5b566d8fd1d11178e295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3fa7e9f2a52018d7d0a5b566d8fd1d11178e295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3fa7e9f2a52018d7d0a5b566d8fd1d11178e295"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "496764244ece9d60aa9e8947e65f90e51dd808bf", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f06d174c8ce495b31b4e64f399c1eeb2e83672/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f06d174c8ce495b31b4e64f399c1eeb2e83672/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=12f06d174c8ce495b31b4e64f399c1eeb2e83672", "patch": "@@ -3528,21 +3528,6 @@ store_expr (exp, target, want_value)\n \n       return want_value ? target : NULL_RTX;\n     }\n-  else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n-\t   && GET_MODE (target) != BLKmode)\n-    /* If target is in memory and caller wants value in a register instead,\n-       arrange that.  Pass TARGET as target for expand_expr so that,\n-       if EXP is another assignment, WANT_VALUE will be nonzero for it.\n-       We know expand_expr will not use the target in that case.\n-       Don't do this if TARGET is volatile because we are supposed\n-       to write it and then read it.  */\n-    {\n-      temp = expand_expr (exp, cse_not_expected ? NULL_RTX : target,\n-\t\t\t  GET_MODE (target), 0);\n-      if (GET_MODE (temp) != BLKmode && GET_MODE (temp) != VOIDmode)\n-\ttemp = copy_to_reg (temp);\n-      dont_return_target = 1;\n-    }\n   else if (queued_subexp_p (target))\n     /* If target contains a postincrement, let's not risk\n        using it as the place to generate the rhs.  */\n@@ -3562,6 +3547,21 @@ store_expr (exp, target, want_value)\n       if (! MEM_VOLATILE_P (target) && want_value)\n \tdont_return_target = 1;\n     }\n+  else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n+\t   && GET_MODE (target) != BLKmode)\n+    /* If target is in memory and caller wants value in a register instead,\n+       arrange that.  Pass TARGET as target for expand_expr so that,\n+       if EXP is another assignment, WANT_VALUE will be nonzero for it.\n+       We know expand_expr will not use the target in that case.\n+       Don't do this if TARGET is volatile because we are supposed\n+       to write it and then read it.  */\n+    {\n+      temp = expand_expr (exp, cse_not_expected ? NULL_RTX : target,\n+\t\t\t  GET_MODE (target), 0);\n+      if (GET_MODE (temp) != BLKmode && GET_MODE (temp) != VOIDmode)\n+\ttemp = copy_to_reg (temp);\n+      dont_return_target = 1;\n+    }\n   else if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n     /* If this is an scalar in a register that is stored in a wider mode\n        than the declared mode, compute the result into its declared mode"}]}