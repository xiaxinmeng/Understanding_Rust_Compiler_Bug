{"sha": "71595748a3b193518a6bfb3578e9ff1aa813620f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE1OTU3NDhhM2IxOTM1MThhNmJmYjM1NzhlOWZmMWFhODEzNjIwZg==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2017-05-30T10:56:15Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-05-30T10:56:15Z"}, "message": "Vector peeling cost model 2/6\n\ngcc/ChangeLog:\n\n2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Rename.\n\t(vect_get_peeling_costs_all_drs): Create function.\n\t(vect_peeling_hash_get_lowest_cost):\n\tUse vect_get_peeling_costs_all_drs.\n\t(vect_peeling_supportable): Create function.\n\t(vect_enhance_data_refs_alignment): Use vect_peeling_supportable.\n\nFrom-SVN: r248676", "tree": {"sha": "b19902ac7164e0c2ae16ff1268700700beff119a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b19902ac7164e0c2ae16ff1268700700beff119a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71595748a3b193518a6bfb3578e9ff1aa813620f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71595748a3b193518a6bfb3578e9ff1aa813620f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71595748a3b193518a6bfb3578e9ff1aa813620f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71595748a3b193518a6bfb3578e9ff1aa813620f/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d21ff9f66a20e551d52b0759c926660dccb49cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d21ff9f66a20e551d52b0759c926660dccb49cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d21ff9f66a20e551d52b0759c926660dccb49cd"}], "stats": {"total": 168, "additions": 112, "deletions": 56}, "files": [{"sha": "a90e028781878b565e31d53f7aca1a297c2c64d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71595748a3b193518a6bfb3578e9ff1aa813620f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71595748a3b193518a6bfb3578e9ff1aa813620f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71595748a3b193518a6bfb3578e9ff1aa813620f", "patch": "@@ -1,3 +1,12 @@\n+2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Rename.\n+\t(vect_get_peeling_costs_all_drs): Create function.\n+\t(vect_peeling_hash_get_lowest_cost):\n+\tUse vect_get_peeling_costs_all_drs.\n+\t(vect_peeling_supportable): Create function.\n+\t(vect_enhance_data_refs_alignment): Use vect_peeling_supportable.\n+\n 2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n \n \t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Create"}, {"sha": "1659443ee17461d1f60117a6b09a145fa758bd5c", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 103, "deletions": 56, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71595748a3b193518a6bfb3578e9ff1aa813620f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71595748a3b193518a6bfb3578e9ff1aa813620f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=71595748a3b193518a6bfb3578e9ff1aa813620f", "patch": "@@ -903,7 +903,11 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n }\n \n \n-/* Function vect_update_misalignment_for_peel\n+/* Function vect_update_misalignment_for_peel.\n+   Sets DR's misalignment\n+   - to 0 if it has the same alignment as DR_PEEL,\n+   - to the misalignment computed using NPEEL if DR's salignment is known,\n+   - to -1 (unknown) otherwise.\n \n    DR - the data reference whose misalignment is to be adjusted.\n    DR_PEEL - the data reference whose misalignment is being made\n@@ -916,7 +920,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n                                    struct data_reference *dr_peel, int npeel)\n {\n   unsigned int i;\n-  vec<dr_p> same_align_drs;\n+  vec<dr_p> same_aligned_drs;\n   struct data_reference *current_dr;\n   int dr_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n   int dr_peel_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr_peel))));\n@@ -932,9 +936,9 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n \n   /* It can be assumed that the data refs with the same alignment as dr_peel\n      are aligned in the vector loop.  */\n-  same_align_drs\n+  same_aligned_drs\n     = STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr_peel)));\n-  FOR_EACH_VEC_ELT (same_align_drs, i, current_dr)\n+  FOR_EACH_VEC_ELT (same_aligned_drs, i, current_dr)\n     {\n       if (current_dr != dr)\n         continue;\n@@ -1234,27 +1238,23 @@ vect_peeling_hash_get_most_frequent (_vect_peel_info **slot,\n   return 1;\n }\n \n+/* Get the costs of peeling NPEEL iterations checking data access costs\n+   for all data refs. */\n \n-/* Traverse peeling hash table and calculate cost for each peeling option.\n-   Find the one with the lowest cost.  */\n-\n-int\n-vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n-\t\t\t\t   _vect_peel_extended_info *min)\n+static void\n+vect_get_peeling_costs_all_drs (struct data_reference *dr0,\n+\t\t\t\tunsigned int *inside_cost,\n+\t\t\t\tunsigned int *outside_cost,\n+\t\t\t\tstmt_vector_for_cost *body_cost_vec,\n+\t\t\t\tunsigned int npeel, unsigned int vf)\n {\n-  vect_peel_info elem = *slot;\n-  int save_misalignment, dummy;\n-  unsigned int inside_cost = 0, outside_cost = 0, i;\n-  gimple *stmt = DR_STMT (elem->dr);\n+  gimple *stmt = DR_STMT (dr0);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  struct data_reference *dr;\n-  stmt_vector_for_cost prologue_cost_vec, body_cost_vec, epilogue_cost_vec;\n \n-  prologue_cost_vec.create (2);\n-  body_cost_vec.create (2);\n-  epilogue_cost_vec.create (2);\n+  unsigned i;\n+  data_reference *dr;\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n@@ -1272,12 +1272,40 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n+      int save_misalignment;\n       save_misalignment = DR_MISALIGNMENT (dr);\n-      vect_update_misalignment_for_peel (dr, elem->dr, elem->npeel);\n-      vect_get_data_access_cost (dr, &inside_cost, &outside_cost,\n-\t\t\t\t &body_cost_vec);\n+      if (dr == dr0 && npeel == vf / 2)\n+\tSET_DR_MISALIGNMENT (dr, 0);\n+      else\n+\tvect_update_misalignment_for_peel (dr, dr0, npeel);\n+      vect_get_data_access_cost (dr, inside_cost, outside_cost,\n+\t\t\t\t body_cost_vec);\n       SET_DR_MISALIGNMENT (dr, save_misalignment);\n     }\n+}\n+\n+/* Traverse peeling hash table and calculate cost for each peeling option.\n+   Find the one with the lowest cost.  */\n+\n+int\n+vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n+\t\t\t\t   _vect_peel_extended_info *min)\n+{\n+  vect_peel_info elem = *slot;\n+  int dummy;\n+  unsigned int inside_cost = 0, outside_cost = 0;\n+  gimple *stmt = DR_STMT (elem->dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  stmt_vector_for_cost prologue_cost_vec, body_cost_vec,\n+\t\t       epilogue_cost_vec;\n+\n+  prologue_cost_vec.create (2);\n+  body_cost_vec.create (2);\n+  epilogue_cost_vec.create (2);\n+\n+  vect_get_peeling_costs_all_drs (elem->dr, &inside_cost, &outside_cost,\n+\t\t\t\t  &body_cost_vec, elem->npeel, 0);\n \n   outside_cost += vect_get_known_peeling_cost\n     (loop_vinfo, elem->npeel, &dummy,\n@@ -1292,14 +1320,16 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n   epilogue_cost_vec.release ();\n \n   if (inside_cost < min->inside_cost\n-      || (inside_cost == min->inside_cost && outside_cost < min->outside_cost))\n+      || (inside_cost == min->inside_cost\n+\t  && outside_cost < min->outside_cost))\n     {\n       min->inside_cost = inside_cost;\n       min->outside_cost = outside_cost;\n       min->body_cost_vec.release ();\n       min->body_cost_vec = body_cost_vec;\n       min->peel_info.dr = elem->dr;\n       min->peel_info.npeel = elem->npeel;\n+      min->peel_info.count = elem->count;\n     }\n   else\n     body_cost_vec.release ();\n@@ -1342,6 +1372,52 @@ vect_peeling_hash_choose_best_peeling (hash_table<peel_info_hasher> *peeling_hta\n    return res.peel_info.dr;\n }\n \n+/* Return true if the new peeling NPEEL is supported.  */\n+\n+static bool\n+vect_peeling_supportable (loop_vec_info loop_vinfo, struct data_reference *dr0,\n+\t\t\t  unsigned npeel)\n+{\n+  unsigned i;\n+  struct data_reference *dr = NULL;\n+  vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  gimple *stmt;\n+  stmt_vec_info stmt_info;\n+  enum dr_alignment_support supportable_dr_alignment;\n+\n+  /* Ensure that all data refs can be vectorized after the peel.  */\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+    {\n+      int save_misalignment;\n+\n+      if (dr == dr0)\n+\tcontinue;\n+\n+      stmt = DR_STMT (dr);\n+      stmt_info = vinfo_for_stmt (stmt);\n+      /* For interleaving, only the alignment of the first access\n+\t matters.  */\n+      if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+\tcontinue;\n+\n+      /* Strided accesses perform only component accesses, alignment is\n+\t irrelevant for them.  */\n+      if (STMT_VINFO_STRIDED_P (stmt_info)\n+\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+\tcontinue;\n+\n+      save_misalignment = DR_MISALIGNMENT (dr);\n+      vect_update_misalignment_for_peel (dr, dr0, npeel);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n+      SET_DR_MISALIGNMENT (dr, save_misalignment);\n+\n+      if (!supportable_dr_alignment)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n \n /* Function vect_enhance_data_refs_alignment\n \n@@ -1780,40 +1856,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                              \"Try peeling by %d\\n\", npeel);\n         }\n \n-      /* Ensure that all data refs can be vectorized after the peel.  */\n-      FOR_EACH_VEC_ELT (datarefs, i, dr)\n-        {\n-          int save_misalignment;\n-\n-\t  if (dr == dr0)\n-\t    continue;\n-\n-\t  stmt = DR_STMT (dr);\n-\t  stmt_info = vinfo_for_stmt (stmt);\n-\t  /* For interleaving, only the alignment of the first access\n-            matters.  */\n-\t  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n-\t    continue;\n-\n-\t  /* Strided accesses perform only component accesses, alignment is\n-\t     irrelevant for them.  */\n-\t  if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t    continue;\n-\n-\t  save_misalignment = DR_MISALIGNMENT (dr);\n-\t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n-\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n-\t  SET_DR_MISALIGNMENT (dr, save_misalignment);\n-\n-\t  if (!supportable_dr_alignment)\n-\t    {\n-\t      do_peeling = false;\n-\t      break;\n-\t    }\n-\t}\n+      /* Ensure that all datarefs can be vectorized after the peel.  */\n+      if (!vect_peeling_supportable (loop_vinfo, dr0, npeel))\n+\tdo_peeling = false;\n \n+      /* Check if all datarefs are supportable and log.  */\n       if (do_peeling && known_alignment_for_access_p (dr0) && npeel == 0)\n         {\n           stat = vect_verify_datarefs_alignment (loop_vinfo);"}]}