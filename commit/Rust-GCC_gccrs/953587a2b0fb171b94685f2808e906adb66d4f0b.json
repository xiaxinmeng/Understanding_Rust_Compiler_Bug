{"sha": "953587a2b0fb171b94685f2808e906adb66d4f0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzNTg3YTJiMGZiMTcxYjk0Njg1ZjI4MDhlOTA2YWRiNjZkNGYwYg==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:35:33Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:36:29Z"}, "message": "MSP430: Implement TARGET_MEMORY_MOVE_COST\n\nThe cycle and size cost of a MOV instruction in different addressing\nmodes can be used to calculate the TARGET_MEMORY_MOVE_COST relative to\nTARGET_REGISTER_MOVE_COST.\n\ngcc/ChangeLog:\n\n\t* config/msp430/msp430.c (struct single_op_cost): New struct.\n\t(struct double_op_cost): Likewise.\n\t(TARGET_REGISTER_MOVE_COST): Don't define but add comment.\n\t(TARGET_MEMORY_MOVE_COST): Define to...\n\t(msp430_memory_move_cost): New function.\n\t(BRANCH_COST): Don't define but add comment.", "tree": {"sha": "8eae617ef8d39db229893352a655a29a53d4fc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eae617ef8d39db229893352a655a29a53d4fc68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/953587a2b0fb171b94685f2808e906adb66d4f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953587a2b0fb171b94685f2808e906adb66d4f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953587a2b0fb171b94685f2808e906adb66d4f0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953587a2b0fb171b94685f2808e906adb66d4f0b/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602c6cfc79ce4ae61e277107e0a60079c1a93a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602c6cfc79ce4ae61e277107e0a60079c1a93a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602c6cfc79ce4ae61e277107e0a60079c1a93a97"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "580e87f4b151bbd9aabf6e63599ba9cda4cd4cd2", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953587a2b0fb171b94685f2808e906adb66d4f0b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953587a2b0fb171b94685f2808e906adb66d4f0b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=953587a2b0fb171b94685f2808e906adb66d4f0b", "patch": "@@ -1031,6 +1031,135 @@ msp430_legitimate_constant (machine_mode mode, rtx x)\n }\n \n \f\n+/* Describing Relative Costs of Operations\n+   To model the cost of an instruction, use the number of cycles when\n+   optimizing for speed, and the number of words when optimizing for size.\n+   The cheapest instruction will execute in one cycle and cost one word.\n+   The cycle and size costs correspond to 430 ISA instructions, not 430X\n+   instructions or 430X \"address\" instructions.  The relative costs of 430X\n+   instructions is accurately modeled with the 430 costs.  The relative costs\n+   of some \"address\" instructions can differ, but these are not yet handled.\n+   Adding support for this could improve performance/code size.  */\n+\n+struct single_op_cost\n+{\n+  const int reg;\n+  /* Indirect register (@Rn) or indirect autoincrement (@Rn+).  */\n+  const int ind;\n+  const int mem;\n+};\n+\n+static const struct single_op_cost cycle_cost_single_op =\n+{\n+  1, 3, 4\n+};\n+\n+static const struct single_op_cost size_cost_single_op =\n+{\n+  1, 1, 2\n+};\n+\n+/* When the destination of an insn is memory, the cost is always the same\n+   regardless of whether that memory is accessed using indirect register,\n+   indexed or absolute addressing.\n+   When the source operand is memory, indirect register and post-increment have\n+   the same cost, which is lower than indexed and absolute, which also have\n+   the same cost.  */\n+struct double_op_cost\n+{\n+  /* Source operand is a register.  */\n+  const int r2r;\n+  const int r2pc;\n+  const int r2m;\n+\n+  /* Source operand is memory, using indirect register (@Rn) or indirect\n+     autoincrement (@Rn+) addressing modes.  */\n+  const int ind2r;\n+  const int ind2pc;\n+  const int ind2m;\n+\n+  /* Source operand is an immediate.  */\n+  const int imm2r;\n+  const int imm2pc;\n+  const int imm2m;\n+\n+  /* Source operand is memory, using indexed (x(Rn)) or absolute (&ADDR)\n+     addressing modes.  */\n+  const int mem2r;\n+  const int mem2pc;\n+  const int mem2m;\n+};\n+\n+/* These structures describe the cost of MOV, BIT and CMP instructions, in terms\n+   of clock cycles or words.  */\n+static const struct double_op_cost cycle_cost_double_op_mov =\n+{\n+  1, 3, 3,\n+  2, 4, 4,\n+  2, 3, 4,\n+  3, 5, 5\n+};\n+\n+/* Cycle count when memory is the destination operand is one larger than above\n+   for instructions that aren't MOV, BIT or CMP.  */\n+static const struct double_op_cost cycle_cost_double_op =\n+{\n+  1, 3, 4,\n+  2, 4, 5,\n+  2, 3, 5,\n+  3, 5, 6\n+};\n+\n+static const struct double_op_cost size_cost_double_op =\n+{\n+  1, 1, 2,\n+  1, 1, 2,\n+  2, 2, 3,\n+  2, 2, 3\n+};\n+\n+/* TARGET_REGISTER_MOVE_COST\n+   There is only one class of general-purpose, non-fixed registers, and the\n+   relative cost of moving data between them is always the same.\n+   Therefore, the default of 2 is optimal.  */\n+\n+#undef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST msp430_memory_move_cost\n+\n+/* Return the cost of moving data between registers and memory.\n+   The returned cost must be relative to the default TARGET_REGISTER_MOVE_COST\n+   of 2.\n+   IN is false if the value is to be written to memory.  */\n+static int\n+msp430_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t reg_class_t rclass ATTRIBUTE_UNUSED,\n+\t\t\t bool in)\n+{\n+  int cost;\n+  const struct double_op_cost *cost_p;\n+  /* Optimize with a code size focus by default, unless -O2 or above is\n+     specified.  */\n+  bool speed = (!optimize_size && optimize >= 2);\n+\n+  cost_p = (speed ? &cycle_cost_double_op_mov : &size_cost_double_op);\n+\n+  if (in)\n+    /* Reading from memory using indirect addressing is assumed to be the more\n+       common case.  */\n+    cost = cost_p->ind2r;\n+  else\n+    cost = cost_p->r2m;\n+\n+  /* All register to register moves cost 1 cycle or 1 word, so multiply by 2\n+     to get the costs relative to TARGET_REGISTER_MOVE_COST of 2.  */\n+  return 2 * cost;\n+}\n+\n+/* BRANCH_COST\n+   Changing from the default of 1 doesn't affect code generation, presumably\n+   because there are no conditional move insns - when a condition is involved,\n+   the only option is to use a cbranch.  */\n+\n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS msp430_rtx_costs\n "}]}