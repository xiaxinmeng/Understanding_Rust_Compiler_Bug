{"sha": "168cbdf99b562337e1970451c9194b4ef1a64a6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY4Y2JkZjk5YjU2MjMzN2UxOTcwNDUxYzkxOTRiNGVmMWE2NGE2ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-03-08T02:15:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-08T02:15:26Z"}, "message": "haifa-sched.c (is_cfg_nonregular): Change return type to an int.\n\n        * haifa-sched.c (is_cfg_nonregular): Change return type to\n        an int.  No longer compute \"estimated\" number of edges.  Use\n        computed_jump_p instead of duplicating the code.  Fixup/add\n        some comments.\n        (build_control_flow): Returns a value indicating an irregularity\n        in the cfg was detected.  Count the number of edges in the cfg.\n        allocate various edge tables.\n        (find_rgns): No longer look for unreachable blocks.\n        (schedule_insns): Do not allocate memory for edge tables here.\n        Free memory for edge tables before returning.  Do not perform\n        cross block scheduling if build_control_flow returns nonzero.\n        * flow.c (compute_preds_succs): More accurately determine when\n        a block drops in.\nFixes various compile hangs after haifa cleanup.\n\nFrom-SVN: r18439", "tree": {"sha": "56bb1b57f71a20e0b59f7213f7821d27d1f5b592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56bb1b57f71a20e0b59f7213f7821d27d1f5b592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/168cbdf99b562337e1970451c9194b4ef1a64a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168cbdf99b562337e1970451c9194b4ef1a64a6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/168cbdf99b562337e1970451c9194b4ef1a64a6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168cbdf99b562337e1970451c9194b4ef1a64a6d/comments", "author": null, "committer": null, "parents": [{"sha": "52becdc0352009f8240665bda5183b4c8ec3fe51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52becdc0352009f8240665bda5183b4c8ec3fe51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52becdc0352009f8240665bda5183b4c8ec3fe51"}], "stats": {"total": 311, "additions": 119, "deletions": 192}, "files": [{"sha": "3554885792b3b273480d51e7cac55bdfba3687e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=168cbdf99b562337e1970451c9194b4ef1a64a6d", "patch": "@@ -1,5 +1,19 @@\n Sat Mar  7 00:54:15 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* haifa-sched.c (is_cfg_nonregular): Change return type to\n+\tan int.  No longer compute \"estimated\" number of edges.  Use\n+\tcomputed_jump_p instead of duplicating the code.  Fixup/add\n+\tsome comments.\n+\t(build_control_flow): Returns a value indicating an irregularity\n+\tin the cfg was detected.  Count the number of edges in the cfg.\n+\tallocate various edge tables.\n+\t(find_rgns): No longer look for unreachable blocks.\n+\t(schedule_insns): Do not allocate memory for edge tables here.\n+\tFree memory for edge tables before returning.  Do not perform\n+\tcross block scheduling if build_control_flow returns nonzero.\n+\t* flow.c (compute_preds_succs): More accurately determine when\n+\ta block drops in.\n+\n \t* basic-block.h (free_basic_block_vargs): Provide prototype.\n \n \t* cccp.c (main): Fix dumb mistakes in last change."}, {"sha": "5daff7c3602380d1540594dae45098916aad0915", "filename": "gcc/flow.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=168cbdf99b562337e1970451c9194b4ef1a64a6d", "patch": "@@ -3269,13 +3269,29 @@ compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n \t uid_block_number as needed.  */\n       for (bb = 0; bb < n_basic_blocks; bb++)\n \t{\n-\t  rtx insn;\n+\t  rtx insn, stop_insn;\n \n+\t  if (bb == 0)\n+\t    stop_insn = NULL_RTX;\n+\t  else\n+\t    stop_insn = basic_block_end[bb-1];\n+\n+\t  /* Look backwards from the start of this block.  Stop if we\n+\t     hit the start of the function or the end of a previous\n+\t     block.  Don't walk backwards through blocks that are just\n+\t     deleted insns!  */\n \t  for (insn = PREV_INSN (basic_block_head[bb]);\n-\t       insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n+\t       insn && insn != stop_insn && GET_CODE (insn) == NOTE;\n+\t       insn = PREV_INSN (insn))\n \t    ;\n \n-\t  basic_block_drops_in[bb] = insn && GET_CODE (insn) != BARRIER;\n+\t  /* Never set basic_block_drops_in for the first block.  It is\n+\t     implicit.\n+\n+\t     If we stopped on anything other than a BARRIER, then this\n+\t     block drops in.  */\n+\t  if (bb != 0)\n+\t    basic_block_drops_in[bb] = (insn ? GET_CODE (insn) != BARRIER : 1);\n \n \t  insn = basic_block_head[bb];\n \t  while (insn)\n@@ -3286,9 +3302,8 @@ compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n \t      insn = NEXT_INSN (insn);\n \t    }\n \t}\n-      \n-      \n     }\n+      \n   for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n       rtx head;\n@@ -3300,8 +3315,14 @@ compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n \tfor (jump = LABEL_REFS (head);\n \t     jump != head;\n \t     jump = LABEL_NEXTREF (jump))\n-\t  add_pred_succ (BLOCK_NUM (CONTAINING_INSN (jump)), bb,\n-\t\t\t s_preds, s_succs, num_preds, num_succs);\n+\t  {\n+\t    if (! INSN_DELETED_P (CONTAINING_INSN (jump))\n+\t\t&& (GET_CODE (CONTAINING_INSN (jump)) != NOTE\n+\t\t    || (NOTE_LINE_NUMBER (CONTAINING_INSN (jump))\n+\t\t\t!= NOTE_INSN_DELETED)))\n+\t      add_pred_succ (BLOCK_NUM (CONTAINING_INSN (jump)), bb,\n+\t\t\t     s_preds, s_succs, num_preds, num_succs);\n+\t  }\n \n       jump = BLOCK_END (bb);\n       /* If this is a RETURN insn or a conditional jump in the last"}, {"sha": "264e4226fa02b9ff44edec5756dde5f53bcdb117", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 77, "deletions": 185, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168cbdf99b562337e1970451c9194b4ef1a64a6d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=168cbdf99b562337e1970451c9194b4ef1a64a6d", "patch": "@@ -517,10 +517,9 @@ static int *out_edges;\n extern rtx forced_labels;\n \n \n-static char is_cfg_nonregular PROTO ((void));\n-static int uses_reg_or_mem PROTO ((rtx));\n+static int is_cfg_nonregular PROTO ((void));\n void debug_control_flow PROTO ((void));\n-static void build_control_flow PROTO ((void));\n+static int build_control_flow PROTO ((void));\n static void new_edge PROTO ((int, int));\n \n \n@@ -1078,37 +1077,35 @@ static rtx *bb_sched_before_next_call;\n /* functions for construction of the control flow graph.  */\n \n /* Return 1 if control flow graph should not be constructed, 0 otherwise.\n-   Estimate in nr_edges the number of edges on the graph.\n+\n    We decide not to build the control flow graph if there is possibly more\n-   than one entry to the function, or if computed branches exist.  */\n+   than one entry to the function, if computed branches exist, of if we\n+   have nonlocal gotos.  */\n \n-static char\n+static int\n is_cfg_nonregular ()\n {\n   int b;\n   rtx insn;\n   RTX_CODE code;\n \n-  rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n-\n-  /* check for non local labels */\n-  if (nonlocal_label_list)\n-    {\n-      return 1;\n-    }\n+  /* If we have a label that could be the target of a nonlocal goto, then\n+     the cfg is not well structured.  */\n+  if (nonlocal_label_rtx_list () != NULL)\n+    return 1;\n \n-  /* check for labels which cannot be deleted */\n+  /* If we have any forced labels, then the cfg is not well structured.  */\n   if (forced_labels)\n-    {\n-      return 1;\n-    }\n+    return 1;\n \n-  /* check for labels which probably cannot be deleted */\n+  /* If we have exception handlers, then we consider the cfg not well\n+     structured.  ?!?  We should be able to handle this now that flow.c\n+     computes an accurate cfg for EH.  */\n   if (exception_handler_labels)\n-    {\n-      return 1;\n-    }\n+    return 1;\n \n+  /* If we have non-jumping insns which refer to labels, then we consider\n+     the cfg not well structured.  */\n   /* check for labels referred to other thn by jumps */\n   for (b = 0; b < n_basic_blocks; b++)\n     for (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n@@ -1120,150 +1117,31 @@ is_cfg_nonregular ()\n \n \t    for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t      if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t\t{\n-\t\t  return 1;\n-\t\t}\n+\t\treturn 1;\n \t  }\n \n \tif (insn == basic_block_end[b])\n \t  break;\n       }\n \n-  nr_edges = 0;\n-\n-  /* check for computed branches */\n+  /* If this function has a computed jump, then we consider the cfg\n+     not well structured.  */\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       for (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n \t{\n-\n-\t  if (GET_CODE (insn) == JUMP_INSN)\n-\t    {\n-\t      rtx pat = PATTERN (insn);\n-\t      int i;\n-\n-\t      if (GET_CODE (pat) == PARALLEL)\n-\t\t{\n-\t\t  int len = XVECLEN (pat, 0);\n-\t\t  int has_use_labelref = 0;\n-\n-\t\t  for (i = len - 1; i >= 0; i--)\n-\t\t    if (GET_CODE (XVECEXP (pat, 0, i)) == USE\n-\t\t\t&& (GET_CODE (XEXP (XVECEXP (pat, 0, i), 0))\n-\t\t\t    == LABEL_REF))\n-\t\t      {\n-\t\t\tnr_edges++;\n-\t\t\thas_use_labelref = 1;\n-\t\t      }\n-\n-\t\t  if (!has_use_labelref)\n-\t\t    for (i = len - 1; i >= 0; i--)\n-\t\t      if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n-\t\t\t  && SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx\n-\t\t\t  && uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))\n-\t\t\t{\n-\t\t\t  return 1;\n-\t\t\t}\n-\t\t}\n-\t      /* check for branch table */\n-\t      else if (GET_CODE (pat) == ADDR_VEC\n-\t\t       || GET_CODE (pat) == ADDR_DIFF_VEC)\n-\t\t{\n-\t\t  int diff_vec_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n-\t\t  int len = XVECLEN (pat, diff_vec_p);\n-\n-\t\t  nr_edges += len;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* check for computed branch */\n-\t\t  if (GET_CODE (pat) == SET\n-\t\t      && SET_DEST (pat) == pc_rtx\n-\t\t      && uses_reg_or_mem (SET_SRC (pat)))\n-\t\t    {\n-\t\t      return 1;\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  if (computed_jump_p (insn))\n+\t    return 1;\n \n \t  if (insn == basic_block_end[b])\n \t    break;\n \t}\n     }\n \n-  /* count for the fallthrough edges */\n-  for (b = 0; b < n_basic_blocks; b++)\n-    {\n-      for (insn = PREV_INSN (basic_block_head[b]);\n-\t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n-\t;\n-\n-      if (!insn && b != 0)\n-\tnr_edges++;\n-      else if (insn && GET_CODE (insn) != BARRIER)\n-\tnr_edges++;\n-    }\n-\n-  nr_edges++;\n-\n-  return 0;\n-}\n-\n-\n-/* Returns 1 if x uses a reg or a mem (function was taken from flow.c).\n-   x is a target of a jump. Used for the detection of computed\n-   branches. For each label seen, updates the edges estimation\n-   counter nr_edges.  */\n-\n-static int\n-uses_reg_or_mem (x)\n-     rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  int i, j;\n-  char *fmt;\n-\n-  if (code == REG)\n-    return 1;\n-\n-  if (code == MEM\n-      && !(GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n-\t   && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0))))\n-    return 1;\n-\n-  if (code == IF_THEN_ELSE)\n-    {\n-      if (uses_reg_or_mem (XEXP (x, 1))\n-\t  || uses_reg_or_mem (XEXP (x, 2)))\n-\treturn 1;\n-      else\n-\treturn 0;\n-    }\n-\n-  if (code == LABEL_REF)\n-    {\n-      nr_edges++;\n-\n-      return 0;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e'\n-\t  && uses_reg_or_mem (XEXP (x, i)))\n-\treturn 1;\n-\n-      if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (uses_reg_or_mem (XVECEXP (x, i, j)))\n-\t    return 1;\n-    }\n-\n+  /* All the tests passed.  Consider the cfg well structured.  */\n   return 0;\n }\n \n-\n /* Print the control flow graph, for debugging purposes.\n    Callable from the debugger.  */\n \n@@ -1312,9 +1190,12 @@ debug_control_flow ()\n /* Build the control flow graph and set nr_edges.\n \n    Instead of trying to build a cfg ourselves, we rely on flow to\n-   do it for us.  Stamp out useless code (and bug) duplication.  */\n+   do it for us.  Stamp out useless code (and bug) duplication.\n \n-static void\n+   Return nonzero if an irregularity in the cfg is found which would\n+   prevent cross block scheduling.  */\n+\n+static int\n build_control_flow ()\n {\n   int i, j;\n@@ -1323,6 +1204,7 @@ build_control_flow ()\n   int_list_ptr succ;\n   int *num_preds;\n   int *num_succs;\n+  int unreachable;\n \n   /* The scheduler runs after flow; therefore, we can't blindly call\n      back into find_basic_blocks since doing so could invalidate the\n@@ -1341,6 +1223,27 @@ build_control_flow ()\n   num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n   compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n \n+  /* Count the number of edges in the cfg.  */\n+  nr_edges = 0;\n+  unreachable = 0;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      nr_edges += num_succs[i];\n+      if (num_preds[i] == 0)\n+\tunreachable = 1;\n+    }\n+\n+  /* Account for entry/exit edges.  */\n+  nr_edges += 2;\n+\n+  in_edges = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  out_edges = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  bzero ((char *) in_edges, n_basic_blocks * sizeof (int));\n+  bzero ((char *) out_edges, n_basic_blocks * sizeof (int));\n+\n+  edge_table = (edge *) xmalloc ((nr_edges) * sizeof (edge));\n+  bzero ((char *) edge_table, ((nr_edges) * sizeof (edge)));\n+\n   nr_edges = 0;\n   for (i = 0; i < n_basic_blocks; i++)\n     for (succ = s_succs[i]; succ; succ = succ->next)\n@@ -1355,6 +1258,7 @@ build_control_flow ()\n   /* For now.  This will move as more and more of haifa is converted\n      to using the cfg code in flow.c  */\n   free_bb_mem ();\n+  return unreachable;\n }\n \n \n@@ -1627,7 +1531,6 @@ find_rgns ()\n   int count = 0, sp, idx = 0, current_edge = out_edges[0];\n   int num_bbs, num_insns;\n   int too_large_failure;\n-  char *reachable;\n \n   /*\n      The following data structures are computed by the first traversal and\n@@ -1664,8 +1567,6 @@ find_rgns ()\n   bzero ((char *) passed, nr_edges * sizeof (char));\n   in_stack = (char *) alloca (nr_edges * sizeof (char));\n   bzero ((char *) in_stack, nr_edges * sizeof (char));\n-  reachable = (char *) alloca (n_basic_blocks * sizeof (char));\n-  bzero ((char *) reachable, n_basic_blocks * sizeof (char));\n \n   in_queue = (char *) alloca (n_basic_blocks * sizeof (char));\n \n@@ -1677,7 +1578,6 @@ find_rgns ()\n \n   /* First traversal: DFS, finds inner loops in control flow graph */\n \n-  reachable[0] = 1;\n   sp = -1;\n   while (1)\n     {\n@@ -1711,7 +1611,6 @@ find_rgns ()\n       dfs_nr[node] = ++count;\n       in_stack[node] = 1;\n       child = TO_BLOCK (current_edge);\n-      reachable[child] = 1;\n \n       /* found a loop header */\n       if (in_stack[child])\n@@ -1742,19 +1641,6 @@ find_rgns ()\n       current_edge = OUT_EDGES (child);\n     }\t\t\t\t/* while (1); */\n \n-  /* if there are unreachable blocks, or more than one entry to\n-     the subroutine, give up on interblock scheduling */\n-  for (i = 1; i < n_basic_blocks; i++)\n-    {\n-      if (reachable[i] == 0)\n-\t{\n-\t  find_single_block_region ();\n-\t  if (sched_verbose >= 3)\n-\t    fprintf (stderr, \"sched: warning: found an unreachable block %d \\n\", i);\n-\t  return;\n-\t}\n-    }\n-\n   /* Second travsersal: find reducible inner loops, and sort\n      topologically the blocks of each region */\n   degree = dfs_nr;\t\t/* reuse dfs_nr array - it is not needed anymore */\n@@ -8547,31 +8433,20 @@ schedule_insns (dump_file)\n     }\n   else\n     {\n-      /* an estimation for nr_edges is computed in is_cfg_nonregular () */\n-      nr_edges = 0;\n-\n       /* verify that a 'good' control flow graph can be built */\n-      if (is_cfg_nonregular ()\n-\t  || nr_edges <= 1)\n+      if (is_cfg_nonregular ())\n \t{\n \t  find_single_block_region ();\n \t}\n       else\n \t{\n-\t  /* build control flow graph */\n-\t  in_edges = (int *) alloca (n_basic_blocks * sizeof (int));\n-\t  out_edges = (int *) alloca (n_basic_blocks * sizeof (int));\n-\t  bzero ((char *) in_edges, n_basic_blocks * sizeof (int));\n-\t  bzero ((char *) out_edges, n_basic_blocks * sizeof (int));\n-\n-\t  edge_table =\n-\t    (edge *) alloca ((nr_edges) * sizeof (edge));\n-\t  bzero ((char *) edge_table,\n-\t\t ((nr_edges) * sizeof (edge)));\n-\t  build_control_flow ();\n-\n-\t  /* identify reducible inner loops and compute regions */\n-\t  find_rgns ();\n+\t  /* build_control_flow will return nonzero if it detects unreachable\n+\t     blocks or any other irregularity with the cfg which prevents\n+\t     cross block scheduling.  */\n+\t  if (build_control_flow () != 0)\n+\t    find_single_block_region ();\n+\t  else\n+\t    find_rgns ();\n \n \t  if (sched_verbose >= 3)\n \t    {\n@@ -8711,5 +8586,22 @@ schedule_insns (dump_file)\n \n   if (bb_live_regs)\n     FREE_REG_SET (bb_live_regs);\n+\n+  if (edge_table)\n+    {\n+      free (edge_table);\n+      edge_table = NULL;\n+    }\n+\n+  if (in_edges)\n+    {\n+      free (in_edges);\n+      in_edges = NULL;\n+    }\n+  if (out_edges)\n+    {\n+      free (out_edges);\n+      out_edges = NULL;\n+    }\n }\n #endif /* INSN_SCHEDULING */"}]}