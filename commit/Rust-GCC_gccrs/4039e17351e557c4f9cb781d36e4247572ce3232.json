{"sha": "4039e17351e557c4f9cb781d36e4247572ce3232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzOWUxNzM1MWU1NTdjNGY5Y2I3ODFkMzZlNDI0NzU3MmNlMzIzMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T15:44:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T15:44:32Z"}, "message": "[multiple changes]\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Add_Item_To_Name_Buffer): Update the comment on usage.\n\tAdd an output string for loop parameters.\n\t(Analyze_Global_Items): Loop parameters are now a\n\tvalid global item. The share the legality checks of constants.\n\t(Analyze_Input_Output): Loop parameters are now a valid dependency item.\n\t(Find_Role): Loop parameters share the role of constants.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Generalized_Indexing): In ASIS mode,\n\tpreserve the Generalized_ indexing link if the context is not\n\ta spec expression that will be analyzed anew.\n\n2015-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.ads, exp_ch6.adb (Build_Procedure_Body_Form): Promote it to\n\tlibrary level (to invoke this routine from the semantic analyzer).\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): When generating\n\tC code, invoke Build_Procedure_Body_Form to transform a function\n\tthat returns a constrained array type into a procedure with an\n\tout parameter that carries the return value.\n\n2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-reatim.ads: Add \"Clock_Time with Synchronous\" contract in package\n\tAda.Real_Time.\n\t* a-taside.ads: Add \"Tasking_State with Synchronous\" contract in\n\tpackage Ada.Task_Identification.\n\t* sem_ch12.adb: minor typo in comment\n\nFrom-SVN: r229377", "tree": {"sha": "95c92efad99e3642a702ee71109a067a6077e478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c92efad99e3642a702ee71109a067a6077e478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4039e17351e557c4f9cb781d36e4247572ce3232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4039e17351e557c4f9cb781d36e4247572ce3232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4039e17351e557c4f9cb781d36e4247572ce3232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4039e17351e557c4f9cb781d36e4247572ce3232/comments", "author": null, "committer": null, "parents": [{"sha": "58996b09cafcb656b74a6df85b2c632f6500d2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58996b09cafcb656b74a6df85b2c632f6500d2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58996b09cafcb656b74a6df85b2c632f6500d2ab"}], "stats": {"total": 434, "additions": 264, "deletions": 170}, "files": [{"sha": "ce4195eac368672f4d0ceb1558ee00ba94a64cde", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -1,3 +1,35 @@\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Add_Item_To_Name_Buffer): Update the comment on usage.\n+\tAdd an output string for loop parameters.\n+\t(Analyze_Global_Items): Loop parameters are now a\n+\tvalid global item. The share the legality checks of constants.\n+\t(Analyze_Input_Output): Loop parameters are now a valid dependency item.\n+\t(Find_Role): Loop parameters share the role of constants.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Generalized_Indexing): In ASIS mode,\n+\tpreserve the Generalized_ indexing link if the context is not\n+\ta spec expression that will be analyzed anew.\n+\n+2015-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.ads, exp_ch6.adb (Build_Procedure_Body_Form): Promote it to\n+\tlibrary level (to invoke this routine from the semantic analyzer).\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): When generating\n+\tC code, invoke Build_Procedure_Body_Form to transform a function\n+\tthat returns a constrained array type into a procedure with an\n+\tout parameter that carries the return value.\n+\n+2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-reatim.ads: Add \"Clock_Time with Synchronous\" contract in package\n+\tAda.Real_Time.\n+\t* a-taside.ads: Add \"Tasking_State with Synchronous\" contract in\n+\tpackage Ada.Task_Identification.\n+\t* sem_ch12.adb: minor typo in comment\n+\n 2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* contracts.adb (Analyze_Object_Contract): Set and restore"}, {"sha": "8b341c0b58d26cfa9f48f794614d152df6ff4eca", "filename": "gcc/ada/a-reatim.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fa-reatim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fa-reatim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.ads?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -38,7 +38,8 @@ pragma Elaborate_All (System.Task_Primitives.Operations);\n \n package Ada.Real_Time with\n   SPARK_Mode,\n-  Abstract_State => (Clock_Time with External => (Async_Readers,\n+  Abstract_State => (Clock_Time with Synchronous,\n+                                     External => (Async_Readers,\n                                                   Async_Writers))\n is\n "}, {"sha": "ee39ec3e5a9d25a7cbd0a0f6911170524d3e1529", "filename": "gcc/ada/a-taside.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fa-taside.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fa-taside.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.ads?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -38,7 +38,8 @@ with System.Tasking;\n \n package Ada.Task_Identification with\n   SPARK_Mode,\n-  Abstract_State => (Tasking_State with External => (Async_Readers,\n+  Abstract_State => (Tasking_State with Synchronous,\n+                                        External => (Async_Readers,\n                                                      Async_Writers))\n is\n    pragma Preelaborate;"}, {"sha": "fb919248a8b7f2c281ac2eb969135fbfdbd69f5e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 126, "deletions": 135, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -674,6 +674,131 @@ package body Exp_Ch6 is\n       return Extra_Formal;\n    end Build_In_Place_Formal;\n \n+   -------------------------------\n+   -- Build_Procedure_Body_Form --\n+   -------------------------------\n+\n+   function Build_Procedure_Body_Form\n+     (Func_Id   : Entity_Id;\n+      Func_Body : Node_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Func_Body);\n+\n+      Proc_Decl : constant Node_Id   :=\n+                    Next (Unit_Declaration_Node (Func_Id));\n+      --  It is assumed that the next node following the declaration of the\n+      --  corresponding subprogram spec is the declaration of the procedure\n+      --  form.\n+\n+      Proc_Id : constant Entity_Id := Defining_Entity (Proc_Decl);\n+\n+      procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id);\n+      --  Replace each return statement found in the list Stmts with an\n+      --  assignment of the return expression to parameter Param_Id.\n+\n+      ---------------------\n+      -- Replace_Returns --\n+      ---------------------\n+\n+      procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id) is\n+         Stmt : Node_Id;\n+\n+      begin\n+         Stmt := First (Stmts);\n+         while Present (Stmt) loop\n+            if Nkind (Stmt) = N_Block_Statement then\n+               Replace_Returns (Param_Id, Statements (Stmt));\n+\n+            elsif Nkind (Stmt) = N_Case_Statement then\n+               declare\n+                  Alt : Node_Id;\n+               begin\n+                  Alt := First (Alternatives (Stmt));\n+                  while Present (Alt) loop\n+                     Replace_Returns (Param_Id, Statements (Alt));\n+                     Next (Alt);\n+                  end loop;\n+               end;\n+\n+            elsif Nkind (Stmt) = N_If_Statement then\n+               Replace_Returns (Param_Id, Then_Statements (Stmt));\n+               Replace_Returns (Param_Id, Else_Statements (Stmt));\n+\n+               declare\n+                  Part : Node_Id;\n+               begin\n+                  Part := First (Elsif_Parts (Stmt));\n+                  while Present (Part) loop\n+                     Replace_Returns (Part, Then_Statements (Part));\n+                     Next (Part);\n+                  end loop;\n+               end;\n+\n+            elsif Nkind (Stmt) = N_Loop_Statement then\n+               Replace_Returns (Param_Id, Statements (Stmt));\n+\n+            elsif Nkind (Stmt) = N_Simple_Return_Statement then\n+\n+               --  Generate:\n+               --    Param := Expr;\n+               --    return;\n+\n+               Rewrite (Stmt,\n+                 Make_Assignment_Statement (Sloc (Stmt),\n+                   Name       => New_Occurrence_Of (Param_Id, Loc),\n+                   Expression => Relocate_Node (Expression (Stmt))));\n+\n+               Insert_After (Stmt, Make_Simple_Return_Statement (Loc));\n+\n+               --  Skip the added return\n+\n+               Next (Stmt);\n+            end if;\n+\n+            Next (Stmt);\n+         end loop;\n+      end Replace_Returns;\n+\n+      --  Local variables\n+\n+      Stmts    : List_Id;\n+      New_Body : Node_Id;\n+\n+   --  Start of processing for Build_Procedure_Body_Form\n+\n+   begin\n+      --  This routine replaces the original function body:\n+\n+      --    function F (...) return Array_Typ is\n+      --    begin\n+      --       ...\n+      --       return Something;\n+      --    end F;\n+\n+      --    with the following:\n+\n+      --    procedure P (..., Result : out Array_Typ) is\n+      --    begin\n+      --       ...\n+      --       Result := Something;\n+      --    end P;\n+\n+      Stmts :=\n+        Statements (Handled_Statement_Sequence (Func_Body));\n+      Replace_Returns (Last_Entity (Proc_Id), Stmts);\n+\n+      New_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Subprogram_Spec (Specification (Proc_Decl)),\n+          Declarations               => Declarations (Func_Body),\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts));\n+\n+      return New_Body;\n+   end Build_Procedure_Body_Form;\n+\n    --------------------------------\n    -- Check_Overriding_Operation --\n    --------------------------------\n@@ -4959,11 +5084,6 @@ package body Exp_Ch6 is\n       --  returns, since they get eliminated anyway later on. Spec_Id denotes\n       --  the corresponding spec of the subprogram body.\n \n-      procedure Build_Procedure_Body_Form (Func_Id : Entity_Id);\n-      --  Create a procedure body which emulates the behavior of function\n-      --  Func_Id. This body replaces the original function body, which is\n-      --  not needed for the C program.\n-\n       ----------------\n       -- Add_Return --\n       ----------------\n@@ -5036,125 +5156,7 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Return;\n \n-      -------------------------------\n-      -- Build_Procedure_Body_Form --\n-      -------------------------------\n-\n-      procedure Build_Procedure_Body_Form (Func_Id : Entity_Id) is\n-         Proc_Decl : constant Node_Id   :=\n-                       Next (Unit_Declaration_Node (Func_Id));\n-         --  It is assumed that the next node following the declaration of the\n-         --  corresponding subprogram spec is the declaration of the procedure\n-         --  form.\n-\n-         Proc_Id : constant Entity_Id := Defining_Entity (Proc_Decl);\n-\n-         procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id);\n-         --  Replace each return statement found in the list Stmts with an\n-         --  assignment of the return expression to parameter Param_Id.\n-\n-         ---------------------\n-         -- Replace_Returns --\n-         ---------------------\n-\n-         procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id) is\n-            Stmt : Node_Id;\n-\n-         begin\n-            Stmt := First (Stmts);\n-            while Present (Stmt) loop\n-               if Nkind (Stmt) = N_Block_Statement then\n-                  Replace_Returns (Param_Id, Statements (Stmt));\n-\n-               elsif Nkind (Stmt) = N_Case_Statement then\n-                  declare\n-                     Alt : Node_Id;\n-                  begin\n-                     Alt := First (Alternatives (Stmt));\n-                     while Present (Alt) loop\n-                        Replace_Returns (Param_Id, Statements (Alt));\n-                        Next (Alt);\n-                     end loop;\n-                  end;\n-\n-               elsif Nkind (Stmt) = N_If_Statement then\n-                  Replace_Returns (Param_Id, Then_Statements (Stmt));\n-                  Replace_Returns (Param_Id, Else_Statements (Stmt));\n-\n-                  declare\n-                     Part : Node_Id;\n-                  begin\n-                     Part := First (Elsif_Parts (Stmt));\n-                     while Present (Part) loop\n-                        Replace_Returns (Part, Then_Statements (Part));\n-                        Next (Part);\n-                     end loop;\n-                  end;\n-\n-               elsif Nkind (Stmt) = N_Loop_Statement then\n-                  Replace_Returns (Param_Id, Statements (Stmt));\n-\n-               elsif Nkind (Stmt) = N_Simple_Return_Statement then\n-\n-                  --  Generate:\n-                  --    Param := Expr;\n-                  --    return;\n-\n-                  Rewrite (Stmt,\n-                    Make_Assignment_Statement (Sloc (Stmt),\n-                      Name       => New_Occurrence_Of (Param_Id, Loc),\n-                      Expression => Relocate_Node (Expression (Stmt))));\n-\n-                  Insert_After (Stmt, Make_Simple_Return_Statement (Loc));\n-\n-                  --  Skip the added return\n-\n-                  Next (Stmt);\n-               end if;\n-\n-               Next (Stmt);\n-            end loop;\n-         end Replace_Returns;\n-\n-         --  Local variables\n-\n-         Stmts : List_Id;\n-\n-      --  Start of processing for Build_Procedure_Body_Form\n-\n-      begin\n-         --  This routine replaces the original function body:\n-\n-         --    function F (...) return Array_Typ is\n-         --    begin\n-         --       ...\n-         --       return Something;\n-         --    end F;\n-\n-         --    with the following:\n-\n-         --    procedure P (..., Result : out Array_Typ) is\n-         --    begin\n-         --       ...\n-         --       Result := Something;\n-         --    end P;\n-\n-         Stmts := Statements (HSS);\n-         Replace_Returns (Last_Entity (Proc_Id), Stmts);\n-\n-         Replace (N,\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Copy_Subprogram_Spec (Specification (Proc_Decl)),\n-             Declarations               => Declarations (N),\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Stmts)));\n-\n-         Analyze (N);\n-      end Build_Procedure_Body_Form;\n-\n-      --  Local varaibles\n+      --  Local variables\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n@@ -5452,17 +5454,6 @@ package body Exp_Ch6 is\n          Unest_Bodies.Append ((Spec_Id, N));\n       end if;\n \n-      --  When generating C code, transform a function that returns a\n-      --  constrained array type into a procedure with an out parameter\n-      --  that carries the return value.\n-\n-      if Modify_Tree_For_C\n-        and then Ekind (Spec_Id) = E_Function\n-        and then Rewritten_For_C (Spec_Id)\n-      then\n-         Build_Procedure_Body_Form (Spec_Id);\n-      end if;\n-\n       Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Subprogram_Body;\n "}, {"sha": "7ae19de63777cf0ba8394bd74f2b0be9116c98a8", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -110,6 +110,13 @@ package Exp_Ch6 is\n    --  function Func, and returns its Entity_Id. It is a bug if not found; the\n    --  caller should ensure this is called only when the extra formal exists.\n \n+   function Build_Procedure_Body_Form\n+     (Func_Id : Entity_Id; Func_Body : Node_Id) return Node_Id;\n+   --  Create a procedure body which emulates the behavior of function Func_Id.\n+   --  Func_Body is the root of the body of the function before its analysis.\n+   --  The returned node is the root of the procedure body which will replace\n+   --  the original function body, which is not needed for the C program.\n+\n    procedure Initialize;\n    --  Initialize internal tables\n "}, {"sha": "eece74ff3d9f520e1bd8c1210a5d9b5c68d83323", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -3569,7 +3569,7 @@ package body Sem_Ch12 is\n    begin\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n-      --  Very first thing: check for Text_IO sp[ecial unit in case we are\n+      --  Very first thing: check for Text_IO special unit in case we are\n       --  instantiating one of the children of [[Wide_]Wide_]Text_IO.\n \n       Check_Text_IO_Special_Unit (Name (N));"}, {"sha": "519d7caffb25eb56ddda12de3af038ba8ad87ccb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -3003,7 +3003,8 @@ package body Sem_Ch6 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Save_Ghost_Mode   : constant Ghost_Mode_Type := Ghost_Mode;\n+      Cloned_Body_For_C : Node_Id := Empty;\n \n    --  Start of processing for Analyze_Subprogram_Body_Helper\n \n@@ -3584,6 +3585,21 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  If we are generating C and this is a function returning a constrained\n+      --  array type for which we must create a procedure with an extra out\n+      --  parameter then clone the body before it is analyzed. Needed to ensure\n+      --  that the body of the built procedure does not have any reference to\n+      --  the body of the function.\n+\n+      if Expander_Active\n+        and then Modify_Tree_For_C\n+        and then Present (Spec_Id)\n+        and then Ekind (Spec_Id) = E_Function\n+        and then Rewritten_For_C (Spec_Id)\n+      then\n+         Cloned_Body_For_C := Copy_Separate_Tree (N);\n+      end if;\n+\n       --  Handle frontend inlining\n \n       --  Note: Normally we don't do any inlining if expansion is off, since\n@@ -4041,6 +4057,16 @@ package body Sem_Ch6 is\n          end if;\n       end;\n \n+      --  When generating C code, transform a function that returns a\n+      --  constrained array type into a procedure with an out parameter\n+      --  that carries the return value.\n+\n+      if Present (Cloned_Body_For_C) then\n+         Replace (N,\n+           Build_Procedure_Body_Form (Spec_Id, Cloned_Body_For_C));\n+         Analyze (N);\n+      end if;\n+\n       Ghost_Mode := Save_Ghost_Mode;\n    end Analyze_Subprogram_Body_Helper;\n "}, {"sha": "96f508f641e1f1ac3db700ffb5cafbe57b476dcc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -530,6 +530,7 @@ package body Sem_Prag is\n       --    E_Generic_Out_Parameter    - \"generic parameter\"\n       --    E_In_Parameter             - \"parameter\"\n       --    E_In_Out_Parameter         - \"parameter\"\n+      --    E_Loop_Parameter           - \"loop parameter\"\n       --    E_Out_Parameter            - \"parameter\"\n       --    E_Protected_Type           - \"current instance of protected type\"\n       --    E_Task_Type                - \"current instance of task type\"\n@@ -590,6 +591,9 @@ package body Sem_Prag is\n          elsif Is_Formal (Item_Id) then\n             Add_Str_To_Name_Buffer (\"parameter\");\n \n+         elsif Ekind (Item_Id) = E_Loop_Parameter then\n+            Add_Str_To_Name_Buffer (\"loop parameter\");\n+\n          elsif Ekind (Item_Id) = E_Protected_Type then\n             Add_Str_To_Name_Buffer (\"current instance of protected type\");\n \n@@ -826,17 +830,31 @@ package body Sem_Prag is\n                Item_Id := Entity_Of (Item);\n \n                if Present (Item_Id) then\n-                  if Ekind_In (Item_Id, E_Abstract_State,\n-                                        E_Constant,\n+\n+                  --  Constants\n+\n+                  if Ekind_In (Item_Id, E_Constant,\n                                         E_Discriminant,\n-                                        E_Generic_In_Out_Parameter,\n-                                        E_Generic_In_Parameter,\n-                                        E_In_Parameter,\n-                                        E_In_Out_Parameter,\n-                                        E_Out_Parameter,\n-                                        E_Protected_Type,\n-                                        E_Task_Type,\n-                                        E_Variable)\n+                                        E_Loop_Parameter)\n+                      or else\n+\n+                    --  Current instances of concurrent types\n+\n+                    Ekind_In (Item_Id, E_Protected_Type, E_Task_Type)\n+                      or else\n+\n+                    --  Formal parameters\n+\n+                    Ekind_In (Item_Id, E_Generic_In_Out_Parameter,\n+                                       E_Generic_In_Parameter,\n+                                       E_In_Parameter,\n+                                       E_In_Out_Parameter,\n+                                       E_Out_Parameter)\n+                      or else\n+\n+                    --  States, variables\n+\n+                    Ekind_In (Item_Id, E_Abstract_State, E_Variable)\n                   then\n                      --  The item denotes a concurrent type, but it is not the\n                      --  current instance of an enclosing concurrent type.\n@@ -1063,7 +1081,7 @@ package body Sem_Prag is\n             Item_Is_Input  := False;\n             Item_Is_Output := False;\n \n-            --  Abstract state cases\n+            --  Abstract states\n \n             if Ekind (Item_Id) = E_Abstract_State then\n \n@@ -1086,29 +1104,24 @@ package body Sem_Prag is\n                   Item_Is_Output := True;\n                end if;\n \n-            --  Constant case\n-\n-            elsif Ekind (Item_Id) = E_Constant then\n-               Item_Is_Input := True;\n-\n-            elsif Ekind (Item_Id) = E_Discriminant then\n-               Item_Is_Input := True;\n-\n-            --  Generic parameter cases\n+            --  Constants\n \n-            elsif Ekind (Item_Id) = E_Generic_In_Parameter then\n+            elsif Ekind_In (Item_Id, E_Constant,\n+                                     E_Discriminant,\n+                                     E_Loop_Parameter)\n+            then\n                Item_Is_Input := True;\n \n-            elsif Ekind (Item_Id) = E_Generic_In_Out_Parameter then\n-               Item_Is_Input  := True;\n-               Item_Is_Output := True;\n-\n-            --  Parameter cases\n+            --  Parameters\n \n-            elsif Ekind (Item_Id) = E_In_Parameter then\n+            elsif Ekind_In (Item_Id, E_Generic_In_Parameter,\n+                                     E_In_Parameter)\n+            then\n                Item_Is_Input := True;\n \n-            elsif Ekind (Item_Id) = E_In_Out_Parameter then\n+            elsif Ekind_In (Item_Id, E_Generic_In_Out_Parameter,\n+                                     E_In_Out_Parameter)\n+            then\n                Item_Is_Input  := True;\n                Item_Is_Output := True;\n \n@@ -2021,11 +2034,12 @@ package body Sem_Prag is\n                   null;\n \n                --  The only legal references are those to abstract states,\n-               --  discriminants and objects (SPARK RM 6.1.4(4)).\n+               --  objects and various kinds of constants (SPARK RM 6.1.4(4)).\n \n                elsif not Ekind_In (Item_Id, E_Abstract_State,\n                                             E_Constant,\n                                             E_Discriminant,\n+                                            E_Loop_Parameter,\n                                             E_Variable)\n                then\n                   SPARK_Msg_N\n@@ -2108,6 +2122,20 @@ package body Sem_Prag is\n                      return;\n                   end if;\n \n+               --  Loop parameter related checks\n+\n+               elsif Ekind (Item_Id) = E_Loop_Parameter then\n+\n+                  --  A loop parameter is a read-only item, therefore it cannot\n+                  --  act as an output.\n+\n+                  if Nam_In (Global_Mode, Name_In_Out, Name_Output) then\n+                     SPARK_Msg_NE\n+                       (\"loop parameter & cannot act as output\",\n+                        Item, Item_Id);\n+                     return;\n+                  end if;\n+\n                --  Variable related checks. These are only relevant when\n                --  SPARK_Mode is on as they are not standard Ada legality\n                --  rules."}, {"sha": "689e1cbca169ece63b7473e7426f10131ec8cee8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4039e17351e557c4f9cb781d36e4247572ce3232/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4039e17351e557c4f9cb781d36e4247572ce3232", "patch": "@@ -8174,7 +8174,15 @@ package body Sem_Res is\n             Indexes := Parameter_Associations (Call);\n             Pref := Remove_Head (Indexes);\n             Set_Expressions (N, Indexes);\n-            Set_Generalized_Indexing (N, Empty);\n+\n+            --  If expression is to be reanalyzed, reset Generalized_Indexing\n+            --  to recreate call node, as is the case when the expression is\n+            --  part of an expression function.\n+\n+            if In_Spec_Expression then\n+               Set_Generalized_Indexing (N, Empty);\n+            end if;\n+\n             Set_Prefix (N, Pref);\n          end if;\n "}]}