{"sha": "4d281ff7ddd8f6365943c0a622107f92315bb8a6", "node_id": "C_kwDOANBUbNoAKDRkMjgxZmY3ZGRkOGY2MzY1OTQzYzBhNjIyMTA3ZjkyMzE1YmI4YTY", "commit": {"author": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2021-11-12T02:50:46Z"}, "committer": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2021-11-15T11:09:38Z"}, "message": "PR target/103069: Relax cmpxchg loop for x86 target\n\nFrom the CPU's point of view, getting a cache line for writing is more\nexpensive than reading.  See Appendix A.2 Spinlock in:\n\nhttps://www.intel.com/content/dam/www/public/us/en/documents/white-papers/\nxeon-lock-scaling-analysis-paper.pdf\n\nThe full compare and swap will grab the cache line exclusive and causes\nexcessive cache line bouncing.\n\nThe atomic_fetch_{or,xor,and,nand} builtins generates cmpxchg loop under\n-march=x86-64 like:\n\n\tmovl\tv(%rip), %eax\n.L2:\n\tmovl\t%eax, %ecx\n\tmovl\t%eax, %edx\n\torl\t$1, %ecx\n\tlock cmpxchgl\t%ecx, v(%rip)\n\tjne\t.L2\n\tmovl\t%edx, %eax\n\tandl\t$1, %eax\n\tret\n\nTo relax above loop, GCC should first emit a normal load, check and jump to\n.L2 if cmpxchgl may fail. Before jump to .L2, PAUSE should be inserted to\nyield the CPU to another hyperthread and to save power, so the code is\nlike\n\n.L84:\n        movl    (%rdi), %ecx\n        movl    %eax, %edx\n        orl     %esi, %edx\n        cmpl    %eax, %ecx\n        jne     .L82\n        lock cmpxchgl   %edx, (%rdi)\n        jne     .L84\n.L82:\n        rep nop\n        jmp     .L84\n\nThis patch adds corresponding atomic_fetch_op expanders to insert load/\ncompare and pause for all the atomic logic fetch builtins. Add flag\n-mrelax-cmpxchg-loop to control whether to generate relaxed loop.\n\ngcc/ChangeLog:\n\n\tPR target/103069\n\t* config/i386/i386-expand.c (ix86_expand_atomic_fetch_op_loop):\n\tNew expand function.\n\t* config/i386/i386-options.c (ix86_target_string): Add\n\t-mrelax-cmpxchg-loop flag.\n\t(ix86_valid_target_attribute_inner_p): Likewise.\n\t* config/i386/i386-protos.h (ix86_expand_atomic_fetch_op_loop):\n\tNew expand function prototype.\n\t* config/i386/i386.opt: Add -mrelax-cmpxchg-loop.\n\t* config/i386/sync.md (atomic_fetch_<logic><mode>): New expander\n\tfor SI,HI,QI modes.\n\t(atomic_<logic>_fetch<mode>): Likewise.\n\t(atomic_fetch_nand<mode>): Likewise.\n\t(atomic_nand_fetch<mode>): Likewise.\n\t(atomic_fetch_<logic><mode>): New expander for DI,TI modes.\n\t(atomic_<logic>_fetch<mode>): Likewise.\n\t(atomic_fetch_nand<mode>): Likewise.\n\t(atomic_nand_fetch<mode>): Likewise.\n\t* doc/invoke.texi: Document -mrelax-cmpxchg-loop.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/103069\n\t* gcc.target/i386/pr103069-1.c: New test.\n\t* gcc.target/i386/pr103069-2.c: Ditto.", "tree": {"sha": "e53e1de41e5ef5299c57ed2e5c6e4d6287e37f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e53e1de41e5ef5299c57ed2e5c6e4d6287e37f2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d281ff7ddd8f6365943c0a622107f92315bb8a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d281ff7ddd8f6365943c0a622107f92315bb8a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d281ff7ddd8f6365943c0a622107f92315bb8a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d281ff7ddd8f6365943c0a622107f92315bb8a6/comments", "author": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ca8aeaf34a717dffd8f4a1f0333d25c7d1c904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ca8aeaf34a717dffd8f4a1f0333d25c7d1c904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ca8aeaf34a717dffd8f4a1f0333d25c7d1c904"}], "stats": {"total": 320, "additions": 318, "deletions": 2}, "files": [{"sha": "3e4de64ec24365b8c7c6be2cb6e1fecd0c2cf638", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -23138,4 +23138,80 @@ ix86_expand_divmod_libfunc (rtx libfunc, machine_mode mode,\n   *rem_p = rem;\n }\n \n+void ix86_expand_atomic_fetch_op_loop (rtx target, rtx mem, rtx val,\n+\t\t\t\t       enum rtx_code code, bool after,\n+\t\t\t\t       bool doubleword)\n+{\n+  rtx old_reg, new_reg, old_mem, success, oldval, new_mem;\n+  rtx_code_label *loop_label, *pause_label;\n+  machine_mode mode = GET_MODE (target);\n+\n+  old_reg = gen_reg_rtx (mode);\n+  new_reg = old_reg;\n+  loop_label = gen_label_rtx ();\n+  pause_label = gen_label_rtx ();\n+  old_mem = copy_to_reg (mem);\n+  emit_label (loop_label);\n+  emit_move_insn (old_reg, old_mem);\n+\n+  /* return value for atomic_fetch_op.  */\n+  if (!after)\n+    emit_move_insn (target, old_reg);\n+\n+  if (code == NOT)\n+    {\n+      new_reg = expand_simple_binop (mode, AND, new_reg, val, NULL_RTX,\n+\t\t\t\t     true, OPTAB_LIB_WIDEN);\n+      new_reg = expand_simple_unop (mode, code, new_reg, NULL_RTX, true);\n+    }\n+  else\n+    new_reg = expand_simple_binop (mode, code, new_reg, val, NULL_RTX,\n+\t\t\t\t   true, OPTAB_LIB_WIDEN);\n+\n+  /* return value for atomic_op_fetch.  */\n+  if (after)\n+    emit_move_insn (target, new_reg);\n+\n+  /* Load memory again inside loop.  */\n+  new_mem = copy_to_reg (mem);\n+  /* Compare mem value with expected value.  */\n+\n+  if (doubleword)\n+    {\n+      machine_mode half_mode = (mode == DImode)? SImode : DImode;\n+      rtx low_new_mem = gen_lowpart (half_mode, new_mem);\n+      rtx low_old_mem = gen_lowpart (half_mode, old_mem);\n+      rtx high_new_mem = gen_highpart (half_mode, new_mem);\n+      rtx high_old_mem = gen_highpart (half_mode, old_mem);\n+      emit_cmp_and_jump_insns (low_new_mem, low_old_mem, NE, NULL_RTX,\n+\t\t\t       half_mode, 1, pause_label,\n+\t\t\t       profile_probability::guessed_never ());\n+      emit_cmp_and_jump_insns (high_new_mem, high_old_mem, NE, NULL_RTX,\n+\t\t\t       half_mode, 1, pause_label,\n+\t\t\t       profile_probability::guessed_never ());\n+    }\n+  else\n+    emit_cmp_and_jump_insns (new_mem, old_mem, NE, NULL_RTX,\n+\t\t\t     GET_MODE (old_mem), 1, pause_label,\n+\t\t\t     profile_probability::guessed_never ());\n+\n+  success = NULL_RTX;\n+  oldval = old_mem;\n+  expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n+\t\t\t\t  new_reg, false, MEMMODEL_SYNC_SEQ_CST,\n+\t\t\t\t  MEMMODEL_RELAXED);\n+  if (oldval != old_mem)\n+    emit_move_insn (old_mem, oldval);\n+\n+  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n+\t\t\t   GET_MODE (success), 1, loop_label,\n+\t\t\t   profile_probability::guessed_never ());\n+\n+  /* If mem is not expected, pause and loop back.  */\n+  emit_label (pause_label);\n+  emit_insn (gen_pause ());\n+  emit_jump_insn (gen_jump (loop_label));\n+  emit_barrier ();\n+}\n+\n #include \"gt-i386-expand.h\""}, {"sha": "feff2584f41a2c5b7e501d3e8415b8d29708e056", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -397,7 +397,8 @@ ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2,\n     { \"-mstv\",\t\t\t\tMASK_STV },\n     { \"-mavx256-split-unaligned-load\",\tMASK_AVX256_SPLIT_UNALIGNED_LOAD },\n     { \"-mavx256-split-unaligned-store\",\tMASK_AVX256_SPLIT_UNALIGNED_STORE },\n-    { \"-mcall-ms2sysv-xlogues\",\t\tMASK_CALL_MS2SYSV_XLOGUES }\n+    { \"-mcall-ms2sysv-xlogues\",\t\tMASK_CALL_MS2SYSV_XLOGUES },\n+    { \"-mrelax-cmpxchg-loop\",\t\tMASK_RELAX_CMPXCHG_LOOP }\n   };\n \n   /* Additional flag options.  */\n@@ -1092,6 +1093,10 @@ ix86_valid_target_attribute_inner_p (tree fndecl, tree args, char *p_strings[],\n     IX86_ATTR_IX86_YES (\"general-regs-only\",\n \t\t\tOPT_mgeneral_regs_only,\n \t\t\tOPTION_MASK_GENERAL_REGS_ONLY),\n+\n+    IX86_ATTR_YES (\"relax-cmpxchg-loop\",\n+\t\t   OPT_mrelax_cmpxchg_loop,\n+\t\t   MASK_RELAX_CMPXCHG_LOOP),\n   };\n \n   location_t loc"}, {"sha": "7e05510c679d054b08c5ddac6c85d532940b7ec2", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -217,6 +217,8 @@ extern void ix86_move_vector_high_sse_to_mmx (rtx);\n extern void ix86_split_mmx_pack (rtx[], enum rtx_code);\n extern void ix86_split_mmx_punpck (rtx[], bool);\n extern void ix86_expand_avx_vzeroupper (void);\n+extern void ix86_expand_atomic_fetch_op_loop (rtx, rtx, rtx, enum rtx_code,\n+\t\t\t\t\t      bool, bool);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);"}, {"sha": "46fad3cc03808b170514585ea17e152c3b3149d1", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -404,6 +404,10 @@ momit-leaf-frame-pointer\n Target Mask(OMIT_LEAF_FRAME_POINTER) Save\n Omit the frame pointer in leaf functions.\n \n+mrelax-cmpxchg-loop\n+Target Mask(RELAX_CMPXCHG_LOOP) Save\n+Relax cmpxchg loop for atomic_fetch_{or,xor,and,nand} by adding load and cmp before cmpxchg, execute pause and loop back to load and compare if load value is not expected.\n+\n mpc32\n Target RejectNegative\n Set 80387 floating-point precision to 32-bit."}, {"sha": "cc4fe727bd908379044d286a0bd425cdd1c5fbec", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -525,6 +525,123 @@\n \t      (set (reg:CCZ FLAGS_REG)\n \t\t   (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))])])\n \n+(define_expand \"atomic_fetch_<logic><mode>\"\n+  [(match_operand:SWI124 0 \"register_operand\")\n+   (any_logic:SWI124\n+    (match_operand:SWI124 1 \"memory_operand\")\n+    (match_operand:SWI124 2 \"register_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], <CODE>, false,\n+\t\t\t\t    false);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<logic>_fetch<mode>\"\n+  [(match_operand:SWI124 0 \"register_operand\")\n+   (any_logic:SWI124\n+    (match_operand:SWI124 1 \"memory_operand\")\n+    (match_operand:SWI124 2 \"register_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], <CODE>, true,\n+\t\t\t\t    false);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_nand<mode>\"\n+  [(match_operand:SWI124 0 \"register_operand\")\n+   (match_operand:SWI124 1 \"memory_operand\")\n+   (match_operand:SWI124 2 \"register_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], NOT, false,\n+\t\t\t\t    false);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_nand_fetch<mode>\"\n+  [(match_operand:SWI124 0 \"register_operand\")\n+   (match_operand:SWI124 1 \"memory_operand\")\n+   (match_operand:SWI124 2 \"register_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], NOT, true,\n+\t\t\t\t    false);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_<logic><mode>\"\n+  [(match_operand:CASMODE 0 \"register_operand\")\n+   (any_logic:CASMODE\n+    (match_operand:CASMODE 1 \"memory_operand\")\n+    (match_operand:CASMODE 2 \"register_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  bool doubleword = (<MODE>mode == DImode && !TARGET_64BIT)\n+\t\t    || (<MODE>mode == TImode);\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], <CODE>, false,\n+\t\t\t\t    doubleword);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<logic>_fetch<mode>\"\n+  [(match_operand:CASMODE 0 \"register_operand\")\n+   (any_logic:CASMODE\n+    (match_operand:CASMODE 1 \"memory_operand\")\n+    (match_operand:CASMODE 2 \"register_operand\"))\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  bool doubleword = (<MODE>mode == DImode && !TARGET_64BIT)\n+\t\t    || (<MODE>mode == TImode);\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], <CODE>, true,\n+\t\t\t\t    doubleword);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_nand<mode>\"\n+  [(match_operand:CASMODE 0 \"register_operand\")\n+   (match_operand:CASMODE 1 \"memory_operand\")\n+   (match_operand:CASMODE 2 \"register_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  bool doubleword = (<MODE>mode == DImode && !TARGET_64BIT)\n+\t\t    || (<MODE>mode == TImode);\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], NOT, false,\n+\t\t\t\t    doubleword);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_nand_fetch<mode>\"\n+  [(match_operand:CASMODE 0 \"register_operand\")\n+   (match_operand:CASMODE 1 \"memory_operand\")\n+   (match_operand:CASMODE 2 \"register_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"TARGET_CMPXCHG && TARGET_RELAX_CMPXCHG_LOOP\"\n+{\n+  bool doubleword = (<MODE>mode == DImode && !TARGET_64BIT)\n+\t\t    || (<MODE>mode == TImode);\n+  ix86_expand_atomic_fetch_op_loop (operands[0], operands[1],\n+\t\t\t\t    operands[2], NOT, true,\n+\t\t\t\t    doubleword);\n+  DONE;\n+})\n+\n+\n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic\n ;; additions of constants."}, {"sha": "6070288856c02bc6e76ad1496424332a58719e78", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -1423,7 +1423,7 @@ See RS/6000 and PowerPC Options.\n -mstack-protector-guard-reg=@var{reg} @gol\n -mstack-protector-guard-offset=@var{offset} @gol\n -mstack-protector-guard-symbol=@var{symbol} @gol\n--mgeneral-regs-only  -mcall-ms2sysv-xlogues @gol\n+-mgeneral-regs-only  -mcall-ms2sysv-xlogues -mrelax-cmpxchg-loop @gol\n -mindirect-branch=@var{choice}  -mfunction-return=@var{choice} @gol\n -mindirect-branch-register -mneeded}\n \n@@ -32330,6 +32330,13 @@ Generate code that uses only the general-purpose registers.  This\n prevents the compiler from using floating-point, vector, mask and bound\n registers.\n \n+@item -mrelax-cmpxchg-loop\n+@opindex mrelax-cmpxchg-loop\n+Relax cmpxchg loop by emitting an early load and compare before cmpxchg,\n+execute pause if load value is not expected. This reduces excessive\n+cachline bouncing when and works for all atomic logic fetch builtins\n+that generates compare and swap loop.\n+\n @item -mindirect-branch=@var{choice}\n @opindex mindirect-branch\n Convert indirect call and jump with @var{choice}.  The default is"}, {"sha": "f819af4409c5080fccfe9249c176913c306349e1", "filename": "gcc/testsuite/gcc.target/i386/pr103069-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-1.c?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -0,0 +1,35 @@\n+/* PR target/103068 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -march=x86-64 -mtune=generic -mrelax-cmpxchg-loop\" } */ \n+/* { dg-final { scan-assembler-times \"rep;?\\[ \\\\t\\]+nop\" 32 } } */\n+\n+#include <stdint.h>\n+\n+#define FUNC_ATOMIC(TYPE, OP) \\\n+__attribute__ ((noinline, noclone))\t\\\n+TYPE f_##TYPE##_##OP##_fetch (TYPE *a, TYPE b)\t\\\n+{ \\\n+  return __atomic_##OP##_fetch (a, b, __ATOMIC_RELAXED);  \\\n+} \\\n+__attribute__ ((noinline, noclone))\t\\\n+TYPE f_##TYPE##_fetch_##OP (TYPE *a, TYPE b)\t\\\n+{ \\\n+  return __atomic_fetch_##OP (a, b, __ATOMIC_RELAXED);  \\\n+}\n+\n+FUNC_ATOMIC (int64_t, and)\n+FUNC_ATOMIC (int64_t, nand)\n+FUNC_ATOMIC (int64_t, or)\n+FUNC_ATOMIC (int64_t, xor)\n+FUNC_ATOMIC (int, and)\n+FUNC_ATOMIC (int, nand)\n+FUNC_ATOMIC (int, or)\n+FUNC_ATOMIC (int, xor)\n+FUNC_ATOMIC (short, and)\n+FUNC_ATOMIC (short, nand)\n+FUNC_ATOMIC (short, or)\n+FUNC_ATOMIC (short, xor)\n+FUNC_ATOMIC (char, and)\n+FUNC_ATOMIC (char, nand)\n+FUNC_ATOMIC (char, or)\n+FUNC_ATOMIC (char, xor)"}, {"sha": "8ac824cc8e8f4e09d6a41f792cf1d82236bcd713", "filename": "gcc/testsuite/gcc.target/i386/pr103069-2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d281ff7ddd8f6365943c0a622107f92315bb8a6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c?ref=4d281ff7ddd8f6365943c0a622107f92315bb8a6", "patch": "@@ -0,0 +1,70 @@\n+/* PR target/103068 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -march=x86-64 -mtune=generic\" } */ \n+\n+#include <stdlib.h>\n+#include \"pr103069-1.c\"\n+\n+#define FUNC_ATOMIC_RELAX(TYPE, OP) \\\n+__attribute__ ((noinline, noclone, target (\"relax-cmpxchg-loop\")))\t\\\n+TYPE relax_##TYPE##_##OP##_fetch (TYPE *a, TYPE b)\t\\\n+{ \\\n+  return __atomic_##OP##_fetch (a, b, __ATOMIC_RELAXED);  \\\n+} \\\n+__attribute__ ((noinline, noclone, target (\"relax-cmpxchg-loop\")))\t\\\n+TYPE relax_##TYPE##_fetch_##OP (TYPE *a, TYPE b)\t\\\n+{ \\\n+  return __atomic_fetch_##OP (a, b, __ATOMIC_RELAXED);  \\\n+}\n+\n+FUNC_ATOMIC_RELAX (int64_t, and)\n+FUNC_ATOMIC_RELAX (int64_t, nand)\n+FUNC_ATOMIC_RELAX (int64_t, or)\n+FUNC_ATOMIC_RELAX (int64_t, xor)\n+FUNC_ATOMIC_RELAX (int, and)\n+FUNC_ATOMIC_RELAX (int, nand)\n+FUNC_ATOMIC_RELAX (int, or)\n+FUNC_ATOMIC_RELAX (int, xor)\n+FUNC_ATOMIC_RELAX (short, and)\n+FUNC_ATOMIC_RELAX (short, nand)\n+FUNC_ATOMIC_RELAX (short, or)\n+FUNC_ATOMIC_RELAX (short, xor)\n+FUNC_ATOMIC_RELAX (char, and)\n+FUNC_ATOMIC_RELAX (char, nand)\n+FUNC_ATOMIC_RELAX (char, or)\n+FUNC_ATOMIC_RELAX (char, xor)\n+\n+#define TEST_ATOMIC_FETCH_LOGIC(TYPE, OP) \\\n+{ \\\n+  TYPE a = 11, b = 101, res, exp; \\\n+  res = relax_##TYPE##_##OP##_fetch (&a, b); \\\n+  exp = f_##TYPE##_##OP##_fetch (&a, b);  \\\n+  if (res != exp) \\\n+    abort (); \\\n+  a = 21, b = 92; \\\n+  res = relax_##TYPE##_fetch_##OP (&a, b); \\\n+  exp = f_##TYPE##_fetch_##OP (&a, b);  \\\n+  if (res != exp) \\\n+    abort (); \\\n+}\n+\n+int main (void)\n+{\n+  TEST_ATOMIC_FETCH_LOGIC (int64_t, and)\n+  TEST_ATOMIC_FETCH_LOGIC (int64_t, nand)\n+  TEST_ATOMIC_FETCH_LOGIC (int64_t, or)\n+  TEST_ATOMIC_FETCH_LOGIC (int64_t, xor)\n+  TEST_ATOMIC_FETCH_LOGIC (int, and)\n+  TEST_ATOMIC_FETCH_LOGIC (int, nand)\n+  TEST_ATOMIC_FETCH_LOGIC (int, or)\n+  TEST_ATOMIC_FETCH_LOGIC (int, xor)\n+  TEST_ATOMIC_FETCH_LOGIC (short, and)\n+  TEST_ATOMIC_FETCH_LOGIC (short, nand)\n+  TEST_ATOMIC_FETCH_LOGIC (short, or)\n+  TEST_ATOMIC_FETCH_LOGIC (short, xor)\n+  TEST_ATOMIC_FETCH_LOGIC (char, and)\n+  TEST_ATOMIC_FETCH_LOGIC (char, nand)\n+  TEST_ATOMIC_FETCH_LOGIC (char, or)\n+  TEST_ATOMIC_FETCH_LOGIC (char, xor)\n+  return 0;\n+}"}]}