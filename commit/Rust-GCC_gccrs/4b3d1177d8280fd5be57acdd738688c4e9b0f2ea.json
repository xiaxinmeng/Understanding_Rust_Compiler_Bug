{"sha": "4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIzZDExNzdkODI4MGZkNWJlNTdhY2RkNzM4Njg4YzRlOWIwZjJlYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-10-10T11:58:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-10-10T11:58:22Z"}, "message": "revert: longlong.h (count_leading_zeros): Replace '{' and '}' with '%{' and '%}', respectively.\n\n\tRevert:\n\t2007-10-09  Kazu Hirata  <kazu@codesourcery.com>\n\t* longlong.h (count_leading_zeros): Replace '{' and '}' with '%{'\n\tand '%}', respectively.\n\n\tRevert:\n\t2007-10-09  Kazu Hirata  <kazu@codesourcery.com>\n\t* config/m68k/m68k.c (print_operand): Handle '{' and '}'.\n\t* config/m68k/m68k.h (PRINT_OPERAND_PUNCT_VALID_P): Accept '{'\n\tand '}'.\n\t* config/m68k/m68k.md: Replace '{' with '%{' where '{' is\n\tmeant to be output.\n\n\tRevert:\n\t2007-10-07  Kazu Hirata  <kazu@codesourcery.com>\n\t* config/m68k/m68k.c, config/m68k/m68k.md: Use the assembly\n\tsyntax for ASSEMBLER_DIALECT.\n\t* config/m68k/m68k.h (ASSEMBLER_DIALECT): New.\n\nFrom-SVN: r129202", "tree": {"sha": "60bebc454acb2a2d6dec2b0dca8d075d480c3da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60bebc454acb2a2d6dec2b0dca8d075d480c3da0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/comments", "author": null, "committer": null, "parents": [{"sha": "05223046d5ea16a6a21a0324fbd369a43db9ee8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05223046d5ea16a6a21a0324fbd369a43db9ee8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05223046d5ea16a6a21a0324fbd369a43db9ee8b"}], "stats": {"total": 181, "additions": 110, "deletions": 71}, "files": [{"sha": "c347d43fa745a51ceaea69dd344b152909a8893c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "patch": "@@ -1,3 +1,24 @@\n+2007-10-10  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tRevert:\n+\t2007-10-09  Kazu Hirata  <kazu@codesourcery.com>\n+\t* longlong.h (count_leading_zeros): Replace '{' and '}' with '%{'\n+\tand '%}', respectively.\n+\n+\tRevert:\n+\t2007-10-09  Kazu Hirata  <kazu@codesourcery.com>\n+\t* config/m68k/m68k.c (print_operand): Handle '{' and '}'.\n+\t* config/m68k/m68k.h (PRINT_OPERAND_PUNCT_VALID_P): Accept '{'\n+\tand '}'.\n+\t* config/m68k/m68k.md: Replace '{' with '%{' where '{' is\n+\tmeant to be output.\n+\n+\tRevert:\n+\t2007-10-07  Kazu Hirata  <kazu@codesourcery.com>\n+\t* config/m68k/m68k.c, config/m68k/m68k.md: Use the assembly\n+\tsyntax for ASSEMBLER_DIALECT.\n+\t* config/m68k/m68k.h (ASSEMBLER_DIALECT): New.\n+\n 2007-10-10  Revital Eres  <eres@il.ibm.com>\n \n \t* modulo-sched.c (check_nodes_order): Dump the final order of"}, {"sha": "952b94783d451bfd322ba9dee5a9692640ac8c38", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "patch": "@@ -3375,8 +3375,8 @@ output_addsi3 (rtx *operands)\n \t  && (INTVAL (operands[2]) < -32768 || INTVAL (operands[2]) > 32767))\n         return \"move%.l %2,%0\\n\\tadd%.l %1,%0\";\n       if (GET_CODE (operands[2]) == REG)\n-\treturn \"lea {(%1,%2.l)|%1@(0,%2:l)},%0\";\n-      return \"lea {(%c2,%1)|%1@(%c2)},%0\";\n+\treturn MOTOROLA ? \"lea (%1,%2.l),%0\" : \"lea %1@(0,%2:l),%0\";\n+      return MOTOROLA ? \"lea (%c2,%1),%0\" : \"lea %1@(%c2),%0\";\n     }\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -3414,7 +3414,7 @@ output_addsi3 (rtx *operands)\n \t  if (TUNE_68040)\n \t    return \"add%.w %2,%0\";\n \t  else\n-\t    return \"lea {(%c2,%0)|%0@(%c2)},%0\";\n+\t    return MOTOROLA ? \"lea (%c2,%0),%0\" : \"lea %0@(%c2),%0\";\n \t}\n     }\n   return \"add%.l %2,%0\";\n@@ -3710,8 +3710,6 @@ floating_exact_log2 (rtx x)\n    '&' for the letter `d' in an op code, but only on the 68040.\n    '/' for register prefix needed by longlong.h.\n    '?' for m68k_library_id_string\n-   '{' for '{'\n-   '}' for '}'\n \n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n@@ -3729,18 +3727,14 @@ print_operand (FILE *file, rtx op, int letter)\n       if (MOTOROLA)\n \tfprintf (file, \".\");\n     }\n-  else if (letter == '{')\n-    fprintf (file, \"{\");\n-  else if (letter == '}')\n-    fprintf (file, \"}\");\n   else if (letter == '#')\n     asm_fprintf (file, \"%I\");\n   else if (letter == '-')\n-    asm_fprintf (file, \"{-(%Rsp)|%Rsp@-}\");\n+    asm_fprintf (file, MOTOROLA ? \"-(%Rsp)\" : \"%Rsp@-\");\n   else if (letter == '+')\n-    asm_fprintf (file, \"{(%Rsp)+|%Rsp@+}\");\n+    asm_fprintf (file, MOTOROLA ? \"(%Rsp)+\" : \"%Rsp@+\");\n   else if (letter == '@')\n-    asm_fprintf (file, \"{(%Rsp)|%Rsp@}\");\n+    asm_fprintf (file, MOTOROLA ? \"(%Rsp)\" : \"%Rsp@\");\n   else if (letter == '!')\n     asm_fprintf (file, \"%Rfpcr\");\n   else if (letter == '$')\n@@ -3780,7 +3774,7 @@ print_operand (FILE *file, rtx op, int letter)\n \t  && !(GET_CODE (XEXP (op, 0)) == CONST_INT\n \t       && INTVAL (XEXP (op, 0)) < 0x8000\n \t       && INTVAL (XEXP (op, 0)) >= -0x8000))\n-\tasm_fprintf (file, \"{.|:}l\");\n+\tfprintf (file, MOTOROLA ? \".l\" : \":l\");\n     }\n   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == SFmode)\n     {\n@@ -3840,11 +3834,11 @@ print_operand_address (FILE *file, rtx addr)\n     gcc_unreachable ();\n \n   if (address.code == PRE_DEC)\n-    asm_fprintf (file, \"{-(%s)|%s@-}\",\n-\t\t M68K_REGNAME (REGNO (address.base)));\n+    fprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n+\t     M68K_REGNAME (REGNO (address.base)));\n   else if (address.code == POST_INC)\n-    asm_fprintf (file, \"{(%s)+|%s@+}\",\n-\t\t M68K_REGNAME (REGNO (address.base)));\n+    fprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n+\t     M68K_REGNAME (REGNO (address.base)));\n   else if (!address.base && !address.index)\n     {\n       /* A constant address.  */\n@@ -3853,7 +3847,7 @@ print_operand_address (FILE *file, rtx addr)\n \t{\n \t  /* (xxx).w or (xxx).l.  */\n \t  if (IN_RANGE (INTVAL (addr), -0x8000, 0x7fff))\n-\t    asm_fprintf (file, \"%d{.|:}w\", (int) INTVAL (addr));\n+\t    fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n \t  else\n \t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n \t}"}, {"sha": "93b962a9fef7db3a2a8359d262586cb7bcae5bae", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "patch": "@@ -29,10 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n # define TARGET_VERSION fprintf (stderr, \" (68k, MIT syntax)\")\n #endif\n \n-/* Options 0 and 1 are the Motorola and MIT syntaxes,\n-   respectively.  */\n-#define ASSEMBLER_DIALECT\t!MOTOROLA\n-\n /* Handle --with-cpu default option from configure script.  */\n #define OPTION_DEFAULT_SPECS\t\t\t\t\t\t\\\n   { \"cpu\",   \"%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:\\\n@@ -975,11 +971,17 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*%s%s%ld\", LOCAL_LABEL_PREFIX, PREFIX, (long)(NUM))\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t  \\\n-  asm_fprintf (FILE, \"\\tmove%.l %s,{-(%Rsp)|%Rsp@-}\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\\\n+  asm_fprintf (FILE, (MOTOROLA\t\t\t\t\\\n+\t\t      ? \"\\tmove.l %s,-(%Rsp)\\n\"\t\t\\\n+\t\t      : \"\\tmovel %s,%Rsp@-\\n\"),\t\t\\\n+\t       reg_names[REGNO])\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t     \\\n-  asm_fprintf (FILE, \"\\tmove%.l {(%Rsp)+|%Rsp@+},%s\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\\\n+  asm_fprintf (FILE, (MOTOROLA\t\t\t\t\\\n+\t\t      ? \"\\tmove.l (%Rsp)+,%s\\n\"\t\t\\\n+\t\t      : \"\\tmovel %Rsp@+,%s\\n\"),\t\t\\\n+\t       reg_names[REGNO])\n \n /* The m68k does not use absolute case-vectors, but we must define this macro\n    anyway.  */\n@@ -1057,8 +1059,6 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n    '&' for the letter `d' in an op code, but only on the 68040.\n    '/' for register prefix needed by longlong.h.\n    '?' for m68k_library_id_string\n-   '{' for '{'\n-   '}' for '}'\n \n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n@@ -1069,8 +1069,7 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n   ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n    || (CODE) == '+' || (CODE) == '@' || (CODE) == '!'\t\t\t\\\n-   || (CODE) == '$' || (CODE) == '&' || (CODE) == '/' || (CODE) == '?'\t\\\n-   || (CODE) == '{' || (CODE) == '}')\n+   || (CODE) == '$' || (CODE) == '&' || (CODE) == '/' || (CODE) == '?')\n \n \n /* See m68k.c for the m68k specific codes.  */"}, {"sha": "68053b33b707c3ac266ea06f282fe9a978ccba60", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "patch": "@@ -825,7 +825,7 @@\n   \"TUNE_68040_60\"\n {\n   if (which_alternative == 0)\n-    return \"lea 0{.|:}w,%0\";\n+    return MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n   else if (which_alternative == 1)\n     return \"clr%.l %0\";\n   else\n@@ -1140,7 +1140,7 @@\n \t{\n \t  /* On the '040, 'subl an,an' takes 2 clocks while lea takes only 1 */\n \t  if (TUNE_68040_60)\n-\t    return \"lea 0{.|:}w,%0\";\n+\t    return MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n \t  else\n \t    return \"sub%.l %0,%0\";\n \t}\n@@ -2444,13 +2444,13 @@\n       return \"#\";\n \n     case 5:\n-      return \"lea {(%1,%2.l)|%1@(0,%2:l)},%0\";\n+      return MOTOROLA ? \"lea (%1,%2.l),%0\" : \"lea %1@(0,%2:l),%0\";\n \n     case 6:\n-      return \"lea {(%2,%1.l)|%2@(0,%1:l)},%0\";\n+      return MOTOROLA ? \"lea (%2,%1.l),%0\" : \"lea %2@(0,%1:l),%0\";\n \n     case 7:\n-      return \"lea {(%c2,%1)|%1@(%c2)},%0\";\n+      return MOTOROLA ? \"lea (%c2,%1),%0\" : \"lea %1@(%c2),%0\";\n \n     default:\n       gcc_unreachable ();\n@@ -2521,7 +2521,7 @@\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n-\treturn \"lea {(%c2,%0)|%0@(%c2)},%0\";\n+\treturn MOTOROLA ? \"lea (%c2,%0),%0\" : \"lea %0@(%c2),%0\";\n     }\n   return \"add%.w %2,%0\";\n })\n@@ -2576,7 +2576,7 @@\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n-\treturn \"lea {(%c1,%0)|%0@(%c1)},%0\";\n+\treturn MOTOROLA ? \"lea (%c1,%0),%0\" : \"lea %0@(%c1),%0\";\n     }\n   return \"add%.w %1,%0\";\n })\n@@ -2625,7 +2625,7 @@\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TUNE_68040)\n-\treturn \"lea {(%c1,%0)|%0@(%c1)},%0\";\n+\treturn MOTOROLA ? \"lea (%c1,%0),%0\" : \"lea %0@(%c1),%0\";\n     }\n   return \"add%.w %1,%0\";\n })\n@@ -2971,7 +2971,9 @@\n \t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n \t\t (match_operand:HI 2 \"general_src_operand\" \"dmSn\")))]\n   \"\"\n-  \"muls{.w} %2,%0\"\n+{\n+  return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n+}\n   [(set_attr \"type\" \"muls_w\")\n    (set_attr \"opy\" \"2\")])\n \n@@ -2982,7 +2984,9 @@\n \t\t (sign_extend:SI\n \t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"dmS\"))))]\n   \"\"\n-  \"muls{.w} %2,%0\"\n+{\n+  return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n+}\n   [(set_attr \"type\" \"muls_w\")\n    (set_attr \"opy\" \"2\")])\n \n@@ -2992,7 +2996,9 @@\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"INTVAL (operands[2]) >= -0x8000 && INTVAL (operands[2]) <= 0x7fff\"\n-  \"muls{.w} %2,%0\"\n+{\n+  return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n+}\n   [(set_attr \"type\" \"muls_w\")\n    (set_attr \"opy\" \"2\")])\n \n@@ -3029,7 +3035,9 @@\n \t\t (zero_extend:SI\n \t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"dmS\"))))]\n   \"\"\n-  \"mulu{.w} %2,%0\"\n+{\n+  return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n+}\n   [(set_attr \"type\" \"mulu_w\")\n    (set_attr \"opy\" \"2\")])\n \n@@ -3039,7 +3047,9 @@\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) <= 0xffff\"\n-  \"mulu{.w} %2,%0\"\n+{\n+  return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n+}\n   [(set_attr \"type\" \"mulu_w\")\n    (set_attr \"opy\" \"2\")])\n \n@@ -3462,7 +3472,10 @@\n \t(mod:HI (match_dup 1) (match_dup 2)))]\n   \"!TARGET_COLDFIRE || TARGET_CF_HWDIV\"\n {\n-  output_asm_insn (\"ext%.l %0\\;divs{.w} %2,%0\", operands);\n+  output_asm_insn (MOTOROLA ?\n+    \"ext%.l %0\\;divs%.w %2,%0\" :\n+    \"extl %0\\;divs %2,%0\",\n+    operands);\n   if (!find_reg_note(insn, REG_UNUSED, operands[3]))\n     {\n       CC_STATUS_INIT;\n@@ -3481,9 +3494,15 @@\n   \"!TARGET_COLDFIRE || TARGET_CF_HWDIV\"\n {\n   if (ISA_HAS_MVS_MVZ)\n-    output_asm_insn (\"mvz%.w %0,%0\\;divu{.w} %2,%0\", operands);\n+    output_asm_insn (MOTOROLA ?\n+      \"mvz%.w %0,%0\\;divu%.w %2,%0\" :\n+      \"mvz%.w %0,%0\\;divu %2,%0\",\n+      operands);\n   else\n-    output_asm_insn (\"and%.l #0xFFFF,%0\\;divu{.w} %2,%0\", operands);\n+    output_asm_insn (MOTOROLA ?\n+      \"and%.l #0xFFFF,%0\\;divu%.w %2,%0\" :\n+      \"and%.l #0xFFFF,%0\\;divu %2,%0\",\n+      operands);\n \n   if (!find_reg_note(insn, REG_UNUSED, operands[3]))\n     {\n@@ -5487,7 +5506,7 @@\n   if (REG_P (operands[0]))\n     {\n       if (INTVAL (operands[1]) + INTVAL (operands[2]) != 32)\n-        return \"bfins %3,%0%{%b2:%b1%}\";\n+        return \"bfins %3,%0{%b2:%b1}\";\n     }\n   else\n     operands[0] = adjust_address (operands[0],\n@@ -5542,7 +5561,7 @@\n   if (REG_P (operands[1]))\n     {\n       if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \"bfextu %1%{%b3:%b2%},%0\";\n+\treturn \"bfextu %1{%b3:%b2},%0\";\n     }\n   else\n     operands[1]\n@@ -5595,7 +5614,7 @@\n   if (REG_P (operands[1]))\n     {\n       if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \"bfexts %1%{%b3:%b2%},%0\";\n+\treturn \"bfexts %1{%b3:%b2},%0\";\n     }\n   else\n     operands[1]\n@@ -5626,7 +5645,7 @@\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\")\n \t\t\t (match_operand:SI 3 \"nonmemory_operand\" \"dn\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfexts %1%{%b3:%b2%},%0\")\n+  \"bfexts %1{%b3:%b2},%0\")\n \n (define_expand \"extzv\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -5652,7 +5671,7 @@\n     {\n       CC_STATUS_INIT;\n     }\n-  return \"bfextu %1%{%b3:%b2%},%0\";\n+  return \"bfextu %1{%b3:%b2},%0\";\n })\n \n (define_insn \"\"\n@@ -5667,7 +5686,7 @@\n            && (~ INTVAL (operands[3]) & ((1 << INTVAL (operands[1]))- 1)) == 0))\"\n {\n   CC_STATUS_INIT;\n-  return \"bfchg %0%{%b2:%b1%}\";\n+  return \"bfchg %0{%b2:%b1}\";\n })\n \n (define_insn \"\"\n@@ -5678,7 +5697,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   CC_STATUS_INIT;\n-  return \"bfclr %0%{%b2:%b1%}\";\n+  return \"bfclr %0{%b2:%b1}\";\n })\n \n (define_insn \"\"\n@@ -5689,7 +5708,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   CC_STATUS_INIT;\n-  return \"bfset %0%{%b2:%b1%}\";\n+  return \"bfset %0{%b2:%b1}\";\n })\n \n (define_expand \"insv\"\n@@ -5706,7 +5725,7 @@\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\"))\n \t(match_operand:SI 3 \"register_operand\" \"d\"))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfins %3,%0%{%b2:%b1%}\")\n+  \"bfins %3,%0{%b2:%b1}\")\n \n ;; Now recognize bit-field insns that operate on registers\n ;; (or at least were intended to do so).\n@@ -5717,7 +5736,7 @@\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfexts %1%{%b3:%b2%},%0\")\n+  \"bfexts %1{%b3:%b2},%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n@@ -5735,7 +5754,7 @@\n     {\n       CC_STATUS_INIT;\n     }\n-  return \"bfextu %1%{%b3:%b2%},%0\";\n+  return \"bfextu %1{%b3:%b2},%0\";\n })\n \n (define_insn \"\"\n@@ -5746,7 +5765,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   CC_STATUS_INIT;\n-  return \"bfclr %0%{%b2:%b1%}\";\n+  return \"bfclr %0{%b2:%b1}\";\n })\n \n (define_insn \"\"\n@@ -5757,7 +5776,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n {\n   CC_STATUS_INIT;\n-  return \"bfset %0%{%b2:%b1%}\";\n+  return \"bfset %0{%b2:%b1}\";\n })\n \n (define_insn \"\"\n@@ -5776,7 +5795,7 @@\n       && INTVAL (operands[1]) == 24 && INTVAL (operands[2]) == 8)\n     return \"move%.b %3,%0\";\n #endif\n-  return \"bfins %3,%0%{%b2:%b1%}\";\n+  return \"bfins %3,%0{%b2:%b1}\";\n })\n \f\n ;; Special patterns for optimizing bit-field instructions.\n@@ -5801,7 +5820,7 @@\n     }\n   if (INTVAL (operands[1]) != 32)\n     cc_status.flags = CC_NOT_NEGATIVE;\n-  return \"bftst %0%{%b2:%b1%}\";\n+  return \"bftst %0{%b2:%b1}\";\n })\n \n \n@@ -5825,7 +5844,7 @@\n     }\n   if (INTVAL (operands[1]) != 32)\n     cc_status.flags = CC_NOT_NEGATIVE;\n-  return \"bftst %0%{%b2:%b1%}\";\n+  return \"bftst %0{%b2:%b1}\";\n })\n \f\n (define_insn \"scc0_di\"\n@@ -6813,7 +6832,9 @@\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"jmp {(%0)|%0@}\"\n+{\n+  return MOTOROLA ? \"jmp (%0)\" : \"jmp %0@\";\n+}\n   [(set_attr \"type\" \"bra\")])\n \n ;; Jump to variable address from dispatch table of relative addresses.\n@@ -6830,12 +6851,14 @@\n   if (TARGET_COLDFIRE)\n     {\n       if (ADDRESS_REG_P (operands[0]))\n-\treturn \"jmp {(2,pc,%0.l)|pc@(2,%0:l)}\";\n+\treturn MOTOROLA ? \"jmp (2,pc,%0.l)\" : \"jmp pc@(2,%0:l)\";\n+      else if (MOTOROLA)\n+\treturn \"ext%.l %0\\;jmp (2,pc,%0.l)\";\n       else\n-\treturn \"ext%.l %0\\;jmp {(2,pc,%0.l)|pc@(2,%0:l)}\";\n+\treturn \"extl %0\\;jmp pc@(2,%0:l)\";\n     }\n   else\n-    return \"jmp {(2,pc,%0.w)|pc@(2,%0:w)}\";\n+    return MOTOROLA ? \"jmp (2,pc,%0.w)\" : \"jmp pc@(2,%0:w)\";\n #endif\n })\n \n@@ -7202,10 +7225,12 @@\n   \"TARGET_68020 || INTVAL (operands[1]) >= -0x8004\"\n {\n   operands[1] = GEN_INT (INTVAL (operands[1]) + 4);\n-  if (INTVAL (operands[1]) >= -0x8000)\n-    return \"link{.w} %0,%1\";\n+  if (!MOTOROLA)\n+    return \"link %0,%1\";\n+  else if (INTVAL (operands[1]) >= -0x8000)\n+    return \"link.w %0,%1\";\n   else\n-    return \"link{.l} %0,%1\";\n+    return \"link.l %0,%1\";\n })\n \n (define_expand \"unlink\"\n@@ -7238,7 +7263,7 @@\n   if (TARGET_ID_SHARED_LIBRARY)\n     {\n       operands[1] = gen_rtx_REG (Pmode, PIC_REG);\n-      return \"move%.l {%?(%1)|%1@(%?)},%0\";\n+      return MOTOROLA ? \"move.l %?(%1),%0\" : \"movel %1@(%?), %0\";\n     }\n   else if (MOTOROLA)\n     {"}, {"sha": "8350fbc2b45cfbe03fbc2117ba755fee0829e523", "filename": "gcc/longlong.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3d1177d8280fd5be57acdd738688c4e9b0f2ea/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=4b3d1177d8280fd5be57acdd738688c4e9b0f2ea", "patch": "@@ -553,7 +553,7 @@ UDItype __umulsidi3 (USItype, USItype);\n    cpu32 disguises as a 68020, but lacks them.  */\n #if defined (__mc68020__) && !defined (__mcpu32__)\n #define count_leading_zeros(count, x) \\\n-  __asm__ (\"bfffo %1%{%b2:%b2%},%0\"\t\t\t\t\t\\\n+  __asm__ (\"bfffo %1{%b2:%b2},%0\"\t\t\t\t\t\\\n \t   : \"=d\" ((USItype) (count))\t\t\t\t\t\\\n \t   : \"od\" ((USItype) (x)), \"n\" (0))\n /* Some ColdFire architectures have a ff1 instruction supported via"}]}