{"sha": "d9a81cdb415ff070289eda51d122663c62219330", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlhODFjZGI0MTVmZjA3MDI4OWVkYTUxZDEyMjY2M2M2MjIxOTMzMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-20T19:56:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-20T19:56:21Z"}, "message": "compiler: do order_evaluations before remove_shortcuts\n    \n    In remove_shortcuts, the shortcut expressions (&&, ||) are\n    rewritten to if statements, which are lifted out before the\n    statement containing the shortcut expression. If the containing\n    statement has other (sub)expressions that should be evaluated\n    before the shortcut expression, which has not been lifted out,\n    this will result in wrong evaluation order.\n    \n    For example, F() + G(A() && B()), the evaluation order per spec\n    is F, A, B (if A returns true), G. If we lift A() and B() out\n    first, they will be called before F, which is wrong.\n    \n    To fix this, we split order_evaluations to two phases. The first\n    phase, which runs before remove_shortcuts, skips shortcut\n    expressions' components. So it won't lift out subexpressions that\n    are evaluated conditionally. The shortcut expression itself is\n    ordered, since it may have side effects. Then we run\n    remove_shortcuts. At this point the subexpressions that should be\n    evaluated before the shortcut expression are already lifted out.\n    remove_shortcuts also runs the second phase of order_evaluations\n    to order the components of shortcut expressions, which were\n    skipped during the first phase.\n    \n    Reorder the code blocks of remove_shortcuts and order_evaluations,\n    since remove_shortcuts now calls Order_eval.\n    \n    Fixes golang/go#26495.\n    \n    Reviewed-on: https://go-review.googlesource.com/125299\n\nFrom-SVN: r262908", "tree": {"sha": "090e83349d8f9d7e192730b2bcdbfe630a88edab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090e83349d8f9d7e192730b2bcdbfe630a88edab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9a81cdb415ff070289eda51d122663c62219330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a81cdb415ff070289eda51d122663c62219330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9a81cdb415ff070289eda51d122663c62219330", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a81cdb415ff070289eda51d122663c62219330/comments", "author": null, "committer": null, "parents": [{"sha": "523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8"}], "stats": {"total": 433, "additions": 225, "deletions": 208}, "files": [{"sha": "abd55923b092116de7650aef0e50865435172139", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d9a81cdb415ff070289eda51d122663c62219330", "patch": "@@ -1,4 +1,4 @@\n-38850073f25f9de4f3daa33d799def3a33c942ab\n+39d4d755db7d71b5e770ca435a8b1d1f08f53185\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d444e4aca564eb7a5795fce11073da2365561a51", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=d9a81cdb415ff070289eda51d122663c62219330", "patch": "@@ -143,12 +143,12 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   // Export global identifiers as appropriate.\n   ::gogo->do_exports();\n \n-  // Turn short-cut operators (&&, ||) into explicit if statements.\n-  ::gogo->remove_shortcuts();\n-\n   // Use temporary variables to force order of evaluation.\n   ::gogo->order_evaluations();\n \n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  ::gogo->remove_shortcuts();\n+\n   // Convert named types to backend representation.\n   ::gogo->convert_named_types();\n "}, {"sha": "c16b40e56fd8433bca4c65016ba7c486af118c93", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 221, "deletions": 204, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9a81cdb415ff070289eda51d122663c62219330/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=d9a81cdb415ff070289eda51d122663c62219330", "patch": "@@ -3432,210 +3432,6 @@ Gogo::check_types_in_block(Block* block)\n   block->traverse(&traverse);\n }\n \n-// A traversal class used to find a single shortcut operator within an\n-// expression.\n-\n-class Find_shortcut : public Traverse\n-{\n- public:\n-  Find_shortcut()\n-    : Traverse(traverse_blocks\n-\t       | traverse_statements\n-\t       | traverse_expressions),\n-      found_(NULL)\n-  { }\n-\n-  // A pointer to the expression which was found, or NULL if none was\n-  // found.\n-  Expression**\n-  found() const\n-  { return this->found_; }\n-\n- protected:\n-  int\n-  block(Block*)\n-  { return TRAVERSE_SKIP_COMPONENTS; }\n-\n-  int\n-  statement(Block*, size_t*, Statement*)\n-  { return TRAVERSE_SKIP_COMPONENTS; }\n-\n-  int\n-  expression(Expression**);\n-\n- private:\n-  Expression** found_;\n-};\n-\n-// Find a shortcut expression.\n-\n-int\n-Find_shortcut::expression(Expression** pexpr)\n-{\n-  Expression* expr = *pexpr;\n-  Binary_expression* be = expr->binary_expression();\n-  if (be == NULL)\n-    return TRAVERSE_CONTINUE;\n-  Operator op = be->op();\n-  if (op != OPERATOR_OROR && op != OPERATOR_ANDAND)\n-    return TRAVERSE_CONTINUE;\n-  go_assert(this->found_ == NULL);\n-  this->found_ = pexpr;\n-  return TRAVERSE_EXIT;\n-}\n-\n-// A traversal class used to turn shortcut operators into explicit if\n-// statements.\n-\n-class Shortcuts : public Traverse\n-{\n- public:\n-  Shortcuts(Gogo* gogo)\n-    : Traverse(traverse_variables\n-\t       | traverse_statements),\n-      gogo_(gogo)\n-  { }\n-\n- protected:\n-  int\n-  variable(Named_object*);\n-\n-  int\n-  statement(Block*, size_t*, Statement*);\n-\n- private:\n-  // Convert a shortcut operator.\n-  Statement*\n-  convert_shortcut(Block* enclosing, Expression** pshortcut);\n-\n-  // The IR.\n-  Gogo* gogo_;\n-};\n-\n-// Remove shortcut operators in a single statement.\n-\n-int\n-Shortcuts::statement(Block* block, size_t* pindex, Statement* s)\n-{\n-  // FIXME: This approach doesn't work for switch statements, because\n-  // we add the new statements before the whole switch when we need to\n-  // instead add them just before the switch expression.  The right\n-  // fix is probably to lower switch statements with nonconstant cases\n-  // to a series of conditionals.\n-  if (s->switch_statement() != NULL)\n-    return TRAVERSE_CONTINUE;\n-\n-  while (true)\n-    {\n-      Find_shortcut find_shortcut;\n-\n-      // If S is a variable declaration, then ordinary traversal won't\n-      // do anything.  We want to explicitly traverse the\n-      // initialization expression if there is one.\n-      Variable_declaration_statement* vds = s->variable_declaration_statement();\n-      Expression* init = NULL;\n-      if (vds == NULL)\n-\ts->traverse_contents(&find_shortcut);\n-      else\n-\t{\n-\t  init = vds->var()->var_value()->init();\n-\t  if (init == NULL)\n-\t    return TRAVERSE_CONTINUE;\n-\t  init->traverse(&init, &find_shortcut);\n-\t}\n-      Expression** pshortcut = find_shortcut.found();\n-      if (pshortcut == NULL)\n-\treturn TRAVERSE_CONTINUE;\n-\n-      Statement* snew = this->convert_shortcut(block, pshortcut);\n-      block->insert_statement_before(*pindex, snew);\n-      ++*pindex;\n-\n-      if (pshortcut == &init)\n-\tvds->var()->var_value()->set_init(init);\n-    }\n-}\n-\n-// Remove shortcut operators in the initializer of a global variable.\n-\n-int\n-Shortcuts::variable(Named_object* no)\n-{\n-  if (no->is_result_variable())\n-    return TRAVERSE_CONTINUE;\n-  Variable* var = no->var_value();\n-  Expression* init = var->init();\n-  if (!var->is_global() || init == NULL)\n-    return TRAVERSE_CONTINUE;\n-\n-  while (true)\n-    {\n-      Find_shortcut find_shortcut;\n-      init->traverse(&init, &find_shortcut);\n-      Expression** pshortcut = find_shortcut.found();\n-      if (pshortcut == NULL)\n-\treturn TRAVERSE_CONTINUE;\n-\n-      Statement* snew = this->convert_shortcut(NULL, pshortcut);\n-      var->add_preinit_statement(this->gogo_, snew);\n-      if (pshortcut == &init)\n-\tvar->set_init(init);\n-    }\n-}\n-\n-// Given an expression which uses a shortcut operator, return a\n-// statement which implements it, and update *PSHORTCUT accordingly.\n-\n-Statement*\n-Shortcuts::convert_shortcut(Block* enclosing, Expression** pshortcut)\n-{\n-  Binary_expression* shortcut = (*pshortcut)->binary_expression();\n-  Expression* left = shortcut->left();\n-  Expression* right = shortcut->right();\n-  Location loc = shortcut->location();\n-\n-  Block* retblock = new Block(enclosing, loc);\n-  retblock->set_end_location(loc);\n-\n-  Temporary_statement* ts = Statement::make_temporary(shortcut->type(),\n-\t\t\t\t\t\t      left, loc);\n-  retblock->add_statement(ts);\n-\n-  Block* block = new Block(retblock, loc);\n-  block->set_end_location(loc);\n-  Expression* tmpref = Expression::make_temporary_reference(ts, loc);\n-  Statement* assign = Statement::make_assignment(tmpref, right, loc);\n-  block->add_statement(assign);\n-\n-  Expression* cond = Expression::make_temporary_reference(ts, loc);\n-  if (shortcut->binary_expression()->op() == OPERATOR_OROR)\n-    cond = Expression::make_unary(OPERATOR_NOT, cond, loc);\n-\n-  Statement* if_statement = Statement::make_if_statement(cond, block, NULL,\n-\t\t\t\t\t\t\t loc);\n-  retblock->add_statement(if_statement);\n-\n-  *pshortcut = Expression::make_temporary_reference(ts, loc);\n-\n-  delete shortcut;\n-\n-  // Now convert any shortcut operators in LEFT and RIGHT.\n-  Shortcuts shortcuts(this->gogo_);\n-  retblock->traverse(&shortcuts);\n-\n-  return Statement::make_block_statement(retblock, loc);\n-}\n-\n-// Turn shortcut operators into explicit if statements.  Doing this\n-// considerably simplifies the order of evaluation rules.\n-\n-void\n-Gogo::remove_shortcuts()\n-{\n-  Shortcuts shortcuts(this);\n-  this->traverse(&shortcuts);\n-}\n-\n // A traversal class which finds all the expressions which must be\n // evaluated in order within a statement or larger expression.  This\n // is used to implement the rules about order of evaluation.\n@@ -3689,6 +3485,18 @@ class Find_eval_ordering : public Traverse\n int\n Find_eval_ordering::expression(Expression** expression_pointer)\n {\n+  Binary_expression* binexp = (*expression_pointer)->binary_expression();\n+  if (binexp != NULL\n+      && (binexp->op() == OPERATOR_ANDAND || binexp->op() == OPERATOR_OROR))\n+    {\n+      // Shortcut expressions may potentially have side effects which need\n+      // to be ordered, so add them to the list.\n+      // We don't order its subexpressions here since they may be evaluated\n+      // conditionally. This is handled in remove_shortcuts.\n+      this->exprs_.push_back(expression_pointer);\n+      return TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n   // We have to look at subexpressions before this one.\n   if ((*expression_pointer)->traverse_subexpressions(this) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n@@ -3925,6 +3733,215 @@ Gogo::order_evaluations()\n   this->traverse(&order_eval);\n }\n \n+// A traversal class used to find a single shortcut operator within an\n+// expression.\n+\n+class Find_shortcut : public Traverse\n+{\n+ public:\n+  Find_shortcut()\n+    : Traverse(traverse_blocks\n+\t       | traverse_statements\n+\t       | traverse_expressions),\n+      found_(NULL)\n+  { }\n+\n+  // A pointer to the expression which was found, or NULL if none was\n+  // found.\n+  Expression**\n+  found() const\n+  { return this->found_; }\n+\n+ protected:\n+  int\n+  block(Block*)\n+  { return TRAVERSE_SKIP_COMPONENTS; }\n+\n+  int\n+  statement(Block*, size_t*, Statement*)\n+  { return TRAVERSE_SKIP_COMPONENTS; }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  Expression** found_;\n+};\n+\n+// Find a shortcut expression.\n+\n+int\n+Find_shortcut::expression(Expression** pexpr)\n+{\n+  Expression* expr = *pexpr;\n+  Binary_expression* be = expr->binary_expression();\n+  if (be == NULL)\n+    return TRAVERSE_CONTINUE;\n+  Operator op = be->op();\n+  if (op != OPERATOR_OROR && op != OPERATOR_ANDAND)\n+    return TRAVERSE_CONTINUE;\n+  go_assert(this->found_ == NULL);\n+  this->found_ = pexpr;\n+  return TRAVERSE_EXIT;\n+}\n+\n+// A traversal class used to turn shortcut operators into explicit if\n+// statements.\n+\n+class Shortcuts : public Traverse\n+{\n+ public:\n+  Shortcuts(Gogo* gogo)\n+    : Traverse(traverse_variables\n+\t       | traverse_statements),\n+      gogo_(gogo)\n+  { }\n+\n+ protected:\n+  int\n+  variable(Named_object*);\n+\n+  int\n+  statement(Block*, size_t*, Statement*);\n+\n+ private:\n+  // Convert a shortcut operator.\n+  Statement*\n+  convert_shortcut(Block* enclosing, Expression** pshortcut);\n+\n+  // The IR.\n+  Gogo* gogo_;\n+};\n+\n+// Remove shortcut operators in a single statement.\n+\n+int\n+Shortcuts::statement(Block* block, size_t* pindex, Statement* s)\n+{\n+  // FIXME: This approach doesn't work for switch statements, because\n+  // we add the new statements before the whole switch when we need to\n+  // instead add them just before the switch expression.  The right\n+  // fix is probably to lower switch statements with nonconstant cases\n+  // to a series of conditionals.\n+  if (s->switch_statement() != NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  while (true)\n+    {\n+      Find_shortcut find_shortcut;\n+\n+      // If S is a variable declaration, then ordinary traversal won't\n+      // do anything.  We want to explicitly traverse the\n+      // initialization expression if there is one.\n+      Variable_declaration_statement* vds = s->variable_declaration_statement();\n+      Expression* init = NULL;\n+      if (vds == NULL)\n+\ts->traverse_contents(&find_shortcut);\n+      else\n+\t{\n+\t  init = vds->var()->var_value()->init();\n+\t  if (init == NULL)\n+\t    return TRAVERSE_CONTINUE;\n+\t  init->traverse(&init, &find_shortcut);\n+\t}\n+      Expression** pshortcut = find_shortcut.found();\n+      if (pshortcut == NULL)\n+\treturn TRAVERSE_CONTINUE;\n+\n+      Statement* snew = this->convert_shortcut(block, pshortcut);\n+      block->insert_statement_before(*pindex, snew);\n+      ++*pindex;\n+\n+      if (pshortcut == &init)\n+\tvds->var()->var_value()->set_init(init);\n+    }\n+}\n+\n+// Remove shortcut operators in the initializer of a global variable.\n+\n+int\n+Shortcuts::variable(Named_object* no)\n+{\n+  if (no->is_result_variable())\n+    return TRAVERSE_CONTINUE;\n+  Variable* var = no->var_value();\n+  Expression* init = var->init();\n+  if (!var->is_global() || init == NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  while (true)\n+    {\n+      Find_shortcut find_shortcut;\n+      init->traverse(&init, &find_shortcut);\n+      Expression** pshortcut = find_shortcut.found();\n+      if (pshortcut == NULL)\n+\treturn TRAVERSE_CONTINUE;\n+\n+      Statement* snew = this->convert_shortcut(NULL, pshortcut);\n+      var->add_preinit_statement(this->gogo_, snew);\n+      if (pshortcut == &init)\n+\tvar->set_init(init);\n+    }\n+}\n+\n+// Given an expression which uses a shortcut operator, return a\n+// statement which implements it, and update *PSHORTCUT accordingly.\n+\n+Statement*\n+Shortcuts::convert_shortcut(Block* enclosing, Expression** pshortcut)\n+{\n+  Binary_expression* shortcut = (*pshortcut)->binary_expression();\n+  Expression* left = shortcut->left();\n+  Expression* right = shortcut->right();\n+  Location loc = shortcut->location();\n+\n+  Block* retblock = new Block(enclosing, loc);\n+  retblock->set_end_location(loc);\n+\n+  Temporary_statement* ts = Statement::make_temporary(shortcut->type(),\n+\t\t\t\t\t\t      left, loc);\n+  retblock->add_statement(ts);\n+\n+  Block* block = new Block(retblock, loc);\n+  block->set_end_location(loc);\n+  Expression* tmpref = Expression::make_temporary_reference(ts, loc);\n+  Statement* assign = Statement::make_assignment(tmpref, right, loc);\n+  block->add_statement(assign);\n+\n+  Expression* cond = Expression::make_temporary_reference(ts, loc);\n+  if (shortcut->binary_expression()->op() == OPERATOR_OROR)\n+    cond = Expression::make_unary(OPERATOR_NOT, cond, loc);\n+\n+  Statement* if_statement = Statement::make_if_statement(cond, block, NULL,\n+\t\t\t\t\t\t\t loc);\n+  retblock->add_statement(if_statement);\n+\n+  *pshortcut = Expression::make_temporary_reference(ts, loc);\n+\n+  delete shortcut;\n+\n+  // Now convert any shortcut operators in LEFT and RIGHT.\n+  // LEFT and RIGHT were skipped in the top level\n+  // Gogo::order_evaluations. We need to order their\n+  // components first.\n+  Order_eval order_eval(this->gogo_);\n+  retblock->traverse(&order_eval);\n+  Shortcuts shortcuts(this->gogo_);\n+  retblock->traverse(&shortcuts);\n+\n+  return Statement::make_block_statement(retblock, loc);\n+}\n+\n+// Turn shortcut operators into explicit if statements.  Doing this\n+// considerably simplifies the order of evaluation rules.\n+\n+void\n+Gogo::remove_shortcuts()\n+{\n+  Shortcuts shortcuts(this);\n+  this->traverse(&shortcuts);\n+}\n+\n // Traversal to flatten parse tree after order of evaluation rules are applied.\n \n class Flatten : public Traverse"}]}