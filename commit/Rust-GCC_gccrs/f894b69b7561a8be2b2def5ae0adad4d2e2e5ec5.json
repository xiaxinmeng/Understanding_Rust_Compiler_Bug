{"sha": "f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5NGI2OWI3NTYxYThiZTJiMmRlZjVhZTBhZGFkNGQyZTJlNWVjNQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-03-05T10:32:54Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-03-05T10:32:54Z"}, "message": "rtlanal.c: Include target.h and output.h.\n\n2004-03-05  Paolo Bonzini  <bonzini@gnu.org>\n\n        * rtlanal.c: Include target.h and output.h.\n        (rtx_cost, address_cost, default_address_cost): Move from...\n        * cse.c (rtx_cost, address_cost, default_address_cost):\n        ... this file.\n        * rtl.h (rtx_cost, address_cost): Move under rtlanal.c.\n        * Makefile.in: Adjust dependencies.\n\nFrom-SVN: r78961", "tree": {"sha": "98c5020651c4a61ba9b85e846fb8559e5e983851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98c5020651c4a61ba9b85e846fb8559e5e983851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86caf04d48093177caa3904e186ef538e4094e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86caf04d48093177caa3904e186ef538e4094e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86caf04d48093177caa3904e186ef538e4094e9d"}], "stats": {"total": 249, "additions": 127, "deletions": 122}, "files": [{"sha": "00236182f83719fa08d69e66d80909fadb746f3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "patch": "@@ -1,3 +1,12 @@\n+2004-03-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* rtlanal.c: Include target.h and output.h\n+\t(rtx_cost, address_cost, default_address_cost): Move from...\n+\t* cse.c (rtx_cost, address_cost, default_address_cost):\n+\t... this file.\n+\t* rtl.h (rtx_cost, address_cost): Move under rtlanal.c.\n+\t* Makefile.in: Adjust dependencies.\n+\n 2004-03-05  Paolo Bonzini <bonzini@gnu.org>\n \n \t* cse.c (cse_end_of_basic_block): Make static."}, {"sha": "81c79e62476df0fb8a9919636744de83a90bf81d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "patch": "@@ -1568,7 +1568,7 @@ print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h $(TM_P_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h flags.h \\\n-   $(BASIC_BLOCK_H) $(REGS_H)\n+   $(BASIC_BLOCK_H) $(REGS_H) output.h target.h\n \n errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)"}, {"sha": "c84e761f2ba03b38162573c7fb58e8318b355c9c", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "patch": "@@ -812,109 +812,6 @@ notreg_cost (rtx x, enum rtx_code outer)\n \t  : rtx_cost (x, outer) * 2);\n }\n \n-/* Return an estimate of the cost of computing rtx X.\n-   One use is in cse, to decide which expression to keep in the hash table.\n-   Another is in rtl generation, to pick the cheapest way to multiply.\n-   Other uses like the latter are expected in the future.  */\n-\n-int\n-rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-  int total;\n-\n-  if (x == 0)\n-    return 0;\n-\n-  /* Compute the default costs of certain things.\n-     Note that targetm.rtx_costs can override the defaults.  */\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case MULT:\n-      total = COSTS_N_INSNS (5);\n-      break;\n-    case DIV:\n-    case UDIV:\n-    case MOD:\n-    case UMOD:\n-      total = COSTS_N_INSNS (7);\n-      break;\n-    case USE:\n-      /* Used in loop.c and combine.c as a marker.  */\n-      total = 0;\n-      break;\n-    default:\n-      total = COSTS_N_INSNS (1);\n-    }\n-\n-  switch (code)\n-    {\n-    case REG:\n-      return 0;\n-\n-    case SUBREG:\n-      /* If we can't tie these modes, make this expensive.  The larger\n-\t the mode, the more expensive it is.  */\n-      if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))\n-\treturn COSTS_N_INSNS (2\n-\t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n-      break;\n-\n-    default:\n-      if ((*targetm.rtx_costs) (x, code, outer_code, &total))\n-\treturn total;\n-      break;\n-    }\n-\n-  /* Sum the costs of the sub-rtx's, plus cost of this operation,\n-     which is already in total.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      total += rtx_cost (XEXP (x, i), code);\n-    else if (fmt[i] == 'E')\n-      for (j = 0; j < XVECLEN (x, i); j++)\n-\ttotal += rtx_cost (XVECEXP (x, i, j), code);\n-\n-  return total;\n-}\n-\f\n-/* Return cost of address expression X.\n-   Expect that X is properly formed address reference.  */\n-\n-int\n-address_cost (rtx x, enum machine_mode mode)\n-{\n-  /* The address_cost target hook does not deal with ADDRESSOF nodes.  But,\n-     during CSE, such nodes are present.  Using an ADDRESSOF node which\n-     refers to the address of a REG is a good thing because we can then\n-     turn (MEM (ADDRESSSOF (REG))) into just plain REG.  */\n-\n-  if (GET_CODE (x) == ADDRESSOF && REG_P (XEXP ((x), 0)))\n-    return -1;\n-\n-  /* We may be asked for cost of various unusual addresses, such as operands\n-     of push instruction.  It is not worthwhile to complicate writing\n-     of the target hook by such cases.  */\n-\n-  if (!memory_address_p (mode, x))\n-    return 1000;\n-\n-  return (*targetm.address_cost) (x);\n-}\n-\n-/* If the target doesn't override, compute the cost as with arithmetic.  */\n-\n-int\n-default_address_cost (rtx x)\n-{\n-  return rtx_cost (x, MEM);\n-}\n \f\n static struct cse_reg_info *\n get_cse_reg_info (unsigned int regno)"}, {"sha": "94dc136e53beb91863175e337f621b7cb4be3423", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "patch": "@@ -1168,6 +1168,17 @@ enum label_kind\n #define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n \n /* in rtlanal.c */\n+/* Return the right cost to give to an operation\n+   to make the cost of the corresponding register-to-register instruction\n+   N times that of a fast register-to-register instruction.  */\n+#define COSTS_N_INSNS(N) ((N) * 4)\n+\n+/* Maximum cost of an rtl expression.  This value has the special meaning\n+   not to use an rtx with this cost under any circumstances.  */\n+#define MAX_COST INT_MAX\n+\n+extern int rtx_cost (rtx, enum rtx_code);\n+extern int address_cost (rtx, enum machine_mode);\n extern unsigned int subreg_lsb (rtx);\n extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,\n \t\t\t\t  unsigned int);\n@@ -2099,25 +2110,10 @@ extern int no_new_pseudos;\n extern int rtx_to_tree_code (enum rtx_code);\n \n /* In cse.c */\n-struct cse_basic_block_data;\n-\n-/* Return the right cost to give to an operation\n-   to make the cost of the corresponding register-to-register instruction\n-   N times that of a fast register-to-register instruction.  */\n-#define COSTS_N_INSNS(N) ((N) * 4)\n-\n-/* Maximum cost of an rtl expression.  This value has the special meaning\n-   not to use an rtx with this cost under any circumstances.  */\n-#define MAX_COST INT_MAX\n-\n-extern int rtx_cost (rtx, enum rtx_code);\n-extern int address_cost (rtx, enum machine_mode);\n extern int delete_trivially_dead_insns (rtx, int);\n #ifdef BUFSIZ\n extern int cse_main (rtx, int, int, FILE *);\n #endif\n-extern void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n-\t\t\t\t    int, int, int);\n extern void cse_condition_code_reg (void);\n \n /* In jump.c */\n@@ -2238,12 +2234,10 @@ extern void print_inline_rtx (FILE *, rtx, int);\n \n /* In loop.c */\n extern void init_loop (void);\n-extern rtx libcall_other_reg (rtx, rtx);\n #ifdef BUFSIZ\n extern void loop_optimize (rtx, FILE *, int);\n #endif\n extern void branch_target_load_optimize (rtx, bool);\n-extern void record_excess_regs (rtx, rtx, rtx *);\n \n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (rtx);\n@@ -2343,7 +2337,6 @@ extern void dbr_schedule (rtx, FILE *);\n extern void dump_local_alloc (FILE *);\n #endif\n extern int local_alloc (void);\n-extern int function_invariant_p (rtx);\n \n /* In profile.c */\n extern void init_branch_prob (void);"}, {"sha": "15fc7ad2fbc015d04bbbad094cd2357dc311801e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f894b69b7561a8be2b2def5ae0adad4d2e2e5ec5", "patch": "@@ -29,6 +29,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"target.h\"\n+#include \"output.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"basic-block.h\"\n@@ -3785,3 +3787,107 @@ label_is_jump_target_p (rtx label, rtx jump_insn)\n   return false;\n }\n \n+\f\n+/* Return an estimate of the cost of computing rtx X.\n+   One use is in cse, to decide which expression to keep in the hash table.\n+   Another is in rtl generation, to pick the cheapest way to multiply.\n+   Other uses like the latter are expected in the future.  */\n+\n+int\n+rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  int total;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  /* Compute the default costs of certain things.\n+     Note that targetm.rtx_costs can override the defaults.  */\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case MULT:\n+      total = COSTS_N_INSNS (5);\n+      break;\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      total = COSTS_N_INSNS (7);\n+      break;\n+    case USE:\n+      /* Used in loop.c and combine.c as a marker.  */\n+      total = 0;\n+      break;\n+    default:\n+      total = COSTS_N_INSNS (1);\n+    }\n+\n+  switch (code)\n+    {\n+    case REG:\n+      return 0;\n+\n+    case SUBREG:\n+      /* If we can't tie these modes, make this expensive.  The larger\n+\t the mode, the more expensive it is.  */\n+      if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))\n+\treturn COSTS_N_INSNS (2\n+\t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n+      break;\n+\n+    default:\n+      if ((*targetm.rtx_costs) (x, code, outer_code, &total))\n+\treturn total;\n+      break;\n+    }\n+\n+  /* Sum the costs of the sub-rtx's, plus cost of this operation,\n+     which is already in total.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      total += rtx_cost (XEXP (x, i), code);\n+    else if (fmt[i] == 'E')\n+      for (j = 0; j < XVECLEN (x, i); j++)\n+\ttotal += rtx_cost (XVECEXP (x, i, j), code);\n+\n+  return total;\n+}\n+\f\n+/* Return cost of address expression X.\n+   Expect that X is properly formed address reference.  */\n+\n+int\n+address_cost (rtx x, enum machine_mode mode)\n+{\n+  /* The address_cost target hook does not deal with ADDRESSOF nodes.  But,\n+     during CSE, such nodes are present.  Using an ADDRESSOF node which\n+     refers to the address of a REG is a good thing because we can then\n+     turn (MEM (ADDRESSOF (REG))) into just plain REG.  */\n+\n+  if (GET_CODE (x) == ADDRESSOF && REG_P (XEXP ((x), 0)))\n+    return -1;\n+\n+  /* We may be asked for cost of various unusual addresses, such as operands\n+     of push instruction.  It is not worthwhile to complicate writing\n+     of the target hook by such cases.  */\n+\n+  if (!memory_address_p (mode, x))\n+    return 1000;\n+\n+  return (*targetm.address_cost) (x);\n+}\n+\n+/* If the target doesn't override, compute the cost as with arithmetic.  */\n+\n+int\n+default_address_cost (rtx x)\n+{\n+  return rtx_cost (x, MEM);\n+}"}]}