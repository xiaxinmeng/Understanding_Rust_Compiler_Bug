{"sha": "9bcb18f6f57b6601c83818975ac63855a3e25b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJjYjE4ZjZmNTdiNjYwMWM4MzgxODk3NWFjNjM4NTVhM2UyNWIyMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-02-26T04:27:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-02-26T04:27:51Z"}, "message": "re PR c++/56377 (<missing> template args in substitution-failure diagnostics)\n\n\tPR c++/56377\n\t* pt.c (fn_type_unification): Wait to call push_tinst_level until\n\twe know what args we're looking at.\n\nFrom-SVN: r196275", "tree": {"sha": "1fd770c7cff40ddfb0640de75e2749f98b8acb28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd770c7cff40ddfb0640de75e2749f98b8acb28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bcb18f6f57b6601c83818975ac63855a3e25b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcb18f6f57b6601c83818975ac63855a3e25b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcb18f6f57b6601c83818975ac63855a3e25b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcb18f6f57b6601c83818975ac63855a3e25b20/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70e9ab23f4ad839bd0979da933101a0da8fbefe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e9ab23f4ad839bd0979da933101a0da8fbefe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e9ab23f4ad839bd0979da933101a0da8fbefe9"}], "stats": {"total": 55, "additions": 30, "deletions": 25}, "files": [{"sha": "c2a2b3c223a695db254de05d211f28dc833a2e88", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb18f6f57b6601c83818975ac63855a3e25b20/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb18f6f57b6601c83818975ac63855a3e25b20/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9bcb18f6f57b6601c83818975ac63855a3e25b20", "patch": "@@ -1,5 +1,9 @@\n 2013-02-25  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/56377\n+\t* pt.c (fn_type_unification): Wait to call push_tinst_level until\n+\twe know what args we're looking at.\n+\n \tPR c++/56438\n \t* semantics.c (potential_constant_expression_1): In C++98, a cast\n \tto non-integral type can't be a constant expression."}, {"sha": "9b7fc3a5a4f075f8a3dd34008f9881feb88481d5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bcb18f6f57b6601c83818975ac63855a3e25b20/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bcb18f6f57b6601c83818975ac63855a3e25b20/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9bcb18f6f57b6601c83818975ac63855a3e25b20", "patch": "@@ -14900,19 +14900,6 @@ fn_type_unification (tree fn,\n   tree tinst;\n   tree r = error_mark_node;\n \n-  /* Adjust any explicit template arguments before entering the\n-     substitution context.  */\n-  if (explicit_targs)\n-    {\n-      explicit_targs\n-\t= (coerce_template_parms (tparms, explicit_targs, NULL_TREE,\n-\t\t\t\t  complain,\n-\t\t\t\t  /*require_all_args=*/false,\n-\t\t\t\t  /*use_default_args=*/false));\n-      if (explicit_targs == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n   /* In C++0x, it's possible to have a function template whose type depends\n      on itself recursively.  This is most obvious with decltype, but can also\n      occur with enumeration scope (c++/48969).  So we need to catch infinite\n@@ -14926,13 +14913,7 @@ fn_type_unification (tree fn,\n      This is, of course, not reentrant.  */\n   if (excessive_deduction_depth)\n     return error_mark_node;\n-  tinst = build_tree_list (fn, targs);\n-  if (!push_tinst_level (tinst))\n-    {\n-      excessive_deduction_depth = true;\n-      ggc_free (tinst);\n-      return error_mark_node;\n-    }\n+  tinst = build_tree_list (fn, NULL_TREE);\n   ++deduction_depth;\n   push_deferring_access_checks (dk_deferred);\n \n@@ -14962,6 +14943,16 @@ fn_type_unification (tree fn,\n       location_t loc = input_location;\n       bool incomplete = false;\n \n+      /* Adjust any explicit template arguments before entering the\n+\t substitution context.  */\n+      explicit_targs\n+\t= (coerce_template_parms (tparms, explicit_targs, NULL_TREE,\n+\t\t\t\t  complain,\n+\t\t\t\t  /*require_all_args=*/false,\n+\t\t\t\t  /*use_default_args=*/false));\n+      if (explicit_targs == error_mark_node)\n+\tgoto fail;\n+\n       /* Substitute the explicit args into the function type.  This is\n \t necessary so that, for instance, explicitly declared function\n \t arguments can match null pointed constants.  If we were given\n@@ -15008,14 +14999,19 @@ fn_type_unification (tree fn,\n             }\n         }\n \n+      TREE_VALUE (tinst) = explicit_targs;\n+      if (!push_tinst_level (tinst))\n+\t{\n+\t  excessive_deduction_depth = true;\n+\t  goto fail;\n+\t}\n       processing_template_decl += incomplete;\n       input_location = DECL_SOURCE_LOCATION (fn);\n-      TREE_VALUE (tinst) = explicit_targs;\n       fntype = tsubst (TREE_TYPE (fn), explicit_targs,\n \t\t       complain | tf_partial, NULL_TREE);\n-      TREE_VALUE (tinst) = targs;\n       input_location = loc;\n       processing_template_decl -= incomplete;\n+      pop_tinst_level ();\n \n       if (fntype == error_mark_node)\n \tgoto fail;\n@@ -15051,11 +15047,9 @@ fn_type_unification (tree fn,\n      callers must be ready to deal with unification failures in any\n      event.  */\n \n-  pop_tinst_level ();\n   ok = !type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n \t\t\t       targs, parms, args, nargs, /*subr=*/0,\n \t\t\t       strict, flags, explain_p);\n-  push_tinst_level (tinst);\n   if (!ok)\n     goto fail;\n \n@@ -15096,7 +15090,15 @@ fn_type_unification (tree fn,\n      the corresponding deduced argument values.  If the\n      substitution results in an invalid type, as described above,\n      type deduction fails.  */\n+  TREE_VALUE (tinst) = targs;\n+  if (!push_tinst_level (tinst))\n+    {\n+      excessive_deduction_depth = true;\n+      goto fail;\n+    }\n   decl = instantiate_template (fn, targs, complain);\n+  pop_tinst_level ();\n+\n   if (decl == error_mark_node)\n     goto fail;\n \n@@ -15141,7 +15143,6 @@ fn_type_unification (tree fn,\n \texcessive_deduction_depth = false;\n     }\n \n-  pop_tinst_level ();\n   /* We can't free this if a pending_template entry or last_error_tinst_level\n      is pointing at it.  */\n   if (last_pending_template == old_last_pend"}]}