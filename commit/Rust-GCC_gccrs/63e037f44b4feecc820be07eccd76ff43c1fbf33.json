{"sha": "63e037f44b4feecc820be07eccd76ff43c1fbf33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlMDM3ZjQ0YjRmZWVjYzgyMGJlMDdlY2NkNzZmZjQzYzFmYmYzMw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2014-09-30T18:19:59Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2014-09-30T18:19:59Z"}, "message": "Redesign jump threading profile updates to avoid introducing insanities.\n\ngcc:\n\n2014-09-30  Teresa Johnson  <tejohnson@google.com>\n\n\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): New\n\tduplicate_blocks bitmap.\n\t(remove_ctrl_stmt_and_useless_edges): Ditto.\n\t(create_block_for_threading): Ditto.\n\t(compute_path_counts): New function.\n\t(update_profile): Ditto.\n\t(recompute_probabilities): Ditto.\n\t(update_joiner_offpath_counts): Ditto.\n\t(freqs_to_counts_path): Ditto.\n\t(clear_counts_path): Ditto.\n\t(ssa_fix_duplicate_block_edges): Update profile info.\n\t(ssa_create_duplicates): Pass new parameter.\n\t(ssa_redirect_edges): Remove old profile update.\n\t(thread_block_1): New duplicate_blocks bitmap,\n\tremove old profile update.\n\t(thread_single_edge): Pass new parameter.\n\ngcc/testsuite:\n\n2014-09-30  Teresa Johnson  <tejohnson@google.com>\n\n\t* testsuite/gcc.dg/tree-prof/20050826-2.c: New test.\n\t* testsuite/gcc.dg/tree-prof/cmpsf-1.c: Ditto.\n\nFrom-SVN: r215739", "tree": {"sha": "be50f652bc5e038c0a3da95c9efb2964a3ed6c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be50f652bc5e038c0a3da95c9efb2964a3ed6c88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63e037f44b4feecc820be07eccd76ff43c1fbf33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e037f44b4feecc820be07eccd76ff43c1fbf33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e037f44b4feecc820be07eccd76ff43c1fbf33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e037f44b4feecc820be07eccd76ff43c1fbf33/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5d5481bebf401a855eb362fa5ffc2101ba06f2"}], "stats": {"total": 910, "additions": 881, "deletions": 29}, "files": [{"sha": "9374b611e35cacdd2c929668bf8180f1ca40c413", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63e037f44b4feecc820be07eccd76ff43c1fbf33", "patch": "@@ -1,3 +1,22 @@\n+2014-09-30  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): New\n+\tduplicate_blocks bitmap.\n+\t(remove_ctrl_stmt_and_useless_edges): Ditto.\n+\t(create_block_for_threading): Ditto.\n+\t(compute_path_counts): New function.\n+\t(update_profile): Ditto.\n+\t(recompute_probabilities): Ditto.\n+\t(update_joiner_offpath_counts): Ditto.\n+\t(freqs_to_counts_path): Ditto.\n+\t(clear_counts_path): Ditto.\n+\t(ssa_fix_duplicate_block_edges): Update profile info.\n+\t(ssa_create_duplicates): Pass new parameter.\n+\t(ssa_redirect_edges): Remove old profile update.\n+\t(thread_block_1): New duplicate_blocks bitmap,\n+\tremove old profile update.\n+\t(thread_single_edge): Pass new parameter.\n+\n 2014-09-30  Ilya Tocar  <ilya.tocar@intel.com>\n \n \tPR middle-end/62120"}, {"sha": "2ccb1d937bf6dc725a82b3e140cbf48e83cc5d6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63e037f44b4feecc820be07eccd76ff43c1fbf33", "patch": "@@ -1,3 +1,8 @@\n+2014-09-30  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* gcc.dg/tree-prof/20050826-2.c: New test.\n+\t* gcc.dg/tree-prof/cmpsf-1.c: Ditto.\n+\n 2014-09-30  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n        PR c++/16564"}, {"sha": "233c7ec70c0fa2f2ce13b9dbab90a77604768440", "filename": "gcc/testsuite/gcc.dg/tree-prof/20050826-2.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20050826-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20050826-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2F20050826-2.c?ref=63e037f44b4feecc820be07eccd76ff43c1fbf33", "patch": "@@ -0,0 +1,75 @@\n+/* Testcase derived from gcc.c-torture/execute 20050826-2.c\n+   which showed jump threading profile insanities.  */\n+/* { dg-options \"-Ofast -fdump-tree-dom1-all\" } */\n+\n+struct rtattr\n+{\n+  unsigned short rta_len;\n+  unsigned short rta_type;\n+};\n+\n+__attribute__ ((noinline))\n+int inet_check_attr (void *r, struct rtattr **rta)\n+{\n+  int i;\n+\n+  for (i = 1; i <= 14; i++)\n+    {\n+      struct rtattr *attr = rta[i - 1];\n+      if (attr)\n+\t{\n+\t  if (attr->rta_len - sizeof (struct rtattr) < 4)\n+\t    return -22;\n+\t  if (i != 9 && i != 8)\n+\t    rta[i - 1] = attr + 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+extern void abort (void);\n+\n+int\n+test (void)\n+{\n+  struct rtattr rt[2];\n+  struct rtattr *rta[14];\n+  int i;\n+\n+  rt[0].rta_len = sizeof (struct rtattr) + 8;\n+  rt[0].rta_type = 0;\n+  rt[1] = rt[0];\n+  for (i = 0; i < 14; i++)\n+    rta[i] = &rt[0];\n+  if (inet_check_attr (0, rta) != 0)\n+    abort ();\n+  for (i = 0; i < 14; i++)\n+    if (rta[i] != &rt[i != 7 && i != 8])\n+      abort ();\n+  for (i = 0; i < 14; i++)\n+    rta[i] = &rt[0];\n+  rta[1] = 0;\n+  rt[1].rta_len -= 8;\n+  rta[5] = &rt[1];\n+  if (inet_check_attr (0, rta) != -22)\n+    abort ();\n+  for (i = 0; i < 14; i++)\n+    if (i == 1 && rta[i] != 0)\n+      abort ();\n+    else if (i != 1 && i <= 5 && rta[i] != &rt[1])\n+      abort ();\n+    else if (i > 5 && rta[i] != &rt[0])\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  for (i=0; i<100; i++)\n+    test ();\n+  return 0;\n+}\n+\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"dom1\"} } */"}, {"sha": "02af8547da6e9f39e98e7bc4c86465ea6693502c", "filename": "gcc/testsuite/gcc.dg/tree-prof/cmpsf-1.c", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcmpsf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcmpsf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcmpsf-1.c?ref=63e037f44b4feecc820be07eccd76ff43c1fbf33", "patch": "@@ -0,0 +1,178 @@\n+/* Testcase derived from gcc.c-torture/execute cmpsf-1.c\n+   which showed jump threading profile insanities.  */\n+/* { dg-options \"-Ofast -fdump-tree-dom1-all\" } */\n+\n+#include <limits.h>\n+\n+void abort();\n+extern void exit (int);\n+\n+#define F 140\n+#define T 13\n+\n+feq (float x, float y)\n+{\n+  if (x == y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fne (float x, float y)\n+{\n+  if (x != y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+flt (float x, float y)\n+{\n+  if (x < y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fge (float x, float y)\n+{\n+  if (x >= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fgt (float x, float y)\n+{\n+  if (x > y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+fle (float x, float y)\n+{\n+  if (x <= y)\n+    return T;\n+  else\n+    return F;\n+}\n+\n+float args[] =\n+{\n+  0.0F,\n+  1.0F,\n+  -1.0F, \n+  __FLT_MAX__,\n+  __FLT_MIN__,\n+  0.0000000000001F,\n+  123456789.0F,\n+  -987654321.0F\n+};\n+\n+int correct_results[] =\n+{\n+ T, F, F, T, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, F, T, T, F,                                             \n+ T, F, F, T, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ T, F, F, T, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, T, F, F, T,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, F, T, T, F,                                             \n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ T, F, F, T, F, T,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ T, F, F, T, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ T, F, F, T, F, T,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ F, T, F, T, T, F,\n+ F, T, F, T, T, F,\n+ T, F, F, T, F, T,\n+ F, T, F, T, T, F,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ F, T, T, F, F, T,\n+ T, F, F, T, F, T,\n+};\n+\n+void\n+test (void)\n+{\n+  int i, j, *res = correct_results;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      float arg0 = args[i];\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  float arg1 = args[j];\n+\n+\t  if (feq (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fne (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (flt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fge (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fgt (arg0, arg1) != *res++)\n+\t    abort ();\n+\t  if (fle (arg0, arg1) != *res++)\n+\t    abort ();\n+\t}\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  for (i=0; i<100; i++)\n+    test ();\n+  exit (0);\n+}\n+\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"dom1\"} } */"}, {"sha": "2a8e005efd4f06b0738cd2560240746f67ee249a", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 604, "deletions": 29, "changes": 633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e037f44b4feecc820be07eccd76ff43c1fbf33/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=63e037f44b4feecc820be07eccd76ff43c1fbf33", "patch": "@@ -229,6 +229,9 @@ struct ssa_local_info_t\n \n   /* TRUE if we thread one or more jumps, FALSE otherwise.  */\n   bool jumps_threaded;\n+\n+  /* Blocks duplicated for the thread.  */\n+  bitmap duplicate_blocks;\n };\n \n /* Passes which use the jump threading code register jump threading\n@@ -292,7 +295,8 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n static void\n create_block_for_threading (basic_block bb,\n \t\t\t    struct redirection_data *rd,\n-\t\t\t    unsigned int count)\n+\t\t\t    unsigned int count,\n+\t\t\t    bitmap *duplicate_blocks)\n {\n   edge_iterator ei;\n   edge e;\n@@ -307,6 +311,8 @@ create_block_for_threading (basic_block bb,\n   /* Zero out the profile, since the block is unreachable for now.  */\n   rd->dup_blocks[count]->frequency = 0;\n   rd->dup_blocks[count]->count = 0;\n+  if (duplicate_blocks)\n+    bitmap_set_bit (*duplicate_blocks, rd->dup_blocks[count]->index);\n }\n \n /* Main data structure to hold information for duplicates of BB.  */\n@@ -555,18 +561,520 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n   return false;\n }\n \n+\n+/* Compute the amount of profile count/frequency coming into the jump threading\n+   path stored in RD that we are duplicating, returned in PATH_IN_COUNT_PTR and\n+   PATH_IN_FREQ_PTR, as well as the amount of counts flowing out of the\n+   duplicated path, returned in PATH_OUT_COUNT_PTR.  LOCAL_INFO is used to\n+   identify blocks duplicated for jump threading, which have duplicated\n+   edges that need to be ignored in the analysis.  Return true if path contains\n+   a joiner, false otherwise.\n+\n+   In the non-joiner case, this is straightforward - all the counts/frequency\n+   flowing into the jump threading path should flow through the duplicated\n+   block and out of the duplicated path.\n+\n+   In the joiner case, it is very tricky.  Some of the counts flowing into\n+   the original path go offpath at the joiner.  The problem is that while\n+   we know how much total count goes off-path in the original control flow,\n+   we don't know how many of the counts corresponding to just the jump\n+   threading path go offpath at the joiner.\n+\n+   For example, assume we have the following control flow and identified\n+   jump threading paths:\n+\n+                A     B     C\n+                 \\    |    /\n+               Ea \\   |Eb / Ec\n+                   \\  |  /\n+                    v v v\n+                      J       <-- Joiner\n+                     / \\\n+                Eoff/   \\Eon\n+                   /     \\\n+                  v       v\n+                Soff     Son  <--- Normal\n+                         /\\\n+                      Ed/  \\ Ee\n+                       /    \\\n+                      v     v\n+                      D      E\n+\n+            Jump threading paths: A -> J -> Son -> D (path 1)\n+                                  C -> J -> Son -> E (path 2)\n+\n+   Note that the control flow could be more complicated:\n+   - Each jump threading path may have more than one incoming edge.  I.e. A and\n+   Ea could represent multiple incoming blocks/edges that are included in\n+   path 1.\n+   - There could be EDGE_NO_COPY_SRC_BLOCK edges after the joiner (either\n+   before or after the \"normal\" copy block).  These are not duplicated onto\n+   the jump threading path, as they are single-successor.\n+   - Any of the blocks along the path may have other incoming edges that\n+   are not part of any jump threading path, but add profile counts along\n+   the path.\n+\n+   In the aboe example, after all jump threading is complete, we will\n+   end up with the following control flow:\n+\n+                A          B            C\n+                |          |            |\n+              Ea|          |Eb          |Ec\n+                |          |            |\n+                v          v            v\n+               Ja          J           Jc\n+               / \\        / \\Eon'     / \\\n+          Eona/   \\   ---/---\\--------   \\Eonc\n+             /     \\ /  /     \\           \\\n+            v       v  v       v          v\n+           Sona     Soff      Son        Sonc\n+             \\                 /\\         /\n+              \\___________    /  \\  _____/\n+                          \\  /    \\/\n+                           vv      v\n+                            D      E\n+\n+   The main issue to notice here is that when we are processing path 1\n+   (A->J->Son->D) we need to figure out the outgoing edge weights to\n+   the duplicated edges Ja->Sona and Ja->Soff, while ensuring that the\n+   sum of the incoming weights to D remain Ed.  The problem with simply\n+   assuming that Ja (and Jc when processing path 2) has the same outgoing\n+   probabilities to its successors as the original block J, is that after\n+   all paths are processed and other edges/counts removed (e.g. none\n+   of Ec will reach D after processing path 2), we may end up with not\n+   enough count flowing along duplicated edge Sona->D.\n+\n+   Therefore, in the case of a joiner, we keep track of all counts\n+   coming in along the current path, as well as from predecessors not\n+   on any jump threading path (Eb in the above example).  While we\n+   first assume that the duplicated Eona for Ja->Sona has the same\n+   probability as the original, we later compensate for other jump\n+   threading paths that may eliminate edges.  We do that by keep track\n+   of all counts coming into the original path that are not in a jump\n+   thread (Eb in the above example, but as noted earlier, there could\n+   be other predecessors incoming to the path at various points, such\n+   as at Son).  Call this cumulative non-path count coming into the path\n+   before D as Enonpath.  We then ensure that the count from Sona->D is as at\n+   least as big as (Ed - Enonpath), but no bigger than the minimum\n+   weight along the jump threading path.  The probabilities of both the\n+   original and duplicated joiner block J and Ja will be adjusted\n+   accordingly after the updates.  */\n+\n+static bool\n+compute_path_counts (struct redirection_data *rd,\n+                     ssa_local_info_t *local_info,\n+                     gcov_type *path_in_count_ptr,\n+                     gcov_type *path_out_count_ptr,\n+                     int *path_in_freq_ptr)\n+{\n+  edge e = rd->incoming_edges->e;\n+  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+  edge elast = path->last ()->e;\n+  gcov_type nonpath_count = 0;\n+  bool has_joiner = false;\n+  gcov_type path_in_count = 0;\n+  int path_in_freq = 0;\n+\n+  /* Start by accumulating incoming edge counts to the path's first bb\n+     into a couple buckets:\n+        path_in_count: total count of incoming edges that flow into the\n+                  current path.\n+        nonpath_count: total count of incoming edges that are not\n+                  flowing along *any* path.  These are the counts\n+                  that will still flow along the original path after\n+                  all path duplication is done by potentially multiple\n+                  calls to this routine.\n+     (any other incoming edge counts are for a different jump threading\n+     path that will be handled by a later call to this routine.)\n+     To make this easier, start by recording all incoming edges that flow into\n+     the current path in a bitmap.  We could add up the path's incoming edge\n+     counts here, but we still need to walk all the first bb's incoming edges\n+     below to add up the counts of the other edges not included in this jump\n+     threading path.  */\n+  struct el *next, *el;\n+  bitmap in_edge_srcs = BITMAP_ALLOC (NULL);\n+  for (el = rd->incoming_edges; el; el = next)\n+    {\n+      next = el->next;\n+      bitmap_set_bit (in_edge_srcs, el->e->src->index);\n+    }\n+  edge ein;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n+    {\n+      vec<jump_thread_edge *> *ein_path = THREAD_PATH (ein);\n+      /* Simply check the incoming edge src against the set captured above.  */\n+      if (ein_path\n+          && bitmap_bit_p (in_edge_srcs, (*ein_path)[0]->e->src->index))\n+        {\n+          /* It is necessary but not sufficient that the last path edges\n+             are identical.  There may be different paths that share the\n+             same last path edge in the case where the last edge has a nocopy\n+             source block.  */\n+          gcc_assert (ein_path->last ()->e == elast);\n+          path_in_count += ein->count;\n+          path_in_freq += EDGE_FREQUENCY (ein);\n+        }\n+      else if (!ein_path)\n+        {\n+          /* Keep track of the incoming edges that are not on any jump-threading\n+             path.  These counts will still flow out of original path after all\n+             jump threading is complete.  */\n+            nonpath_count += ein->count;\n+        }\n+    }\n+  BITMAP_FREE (in_edge_srcs);\n+\n+  /* Now compute the fraction of the total count coming into the first\n+     path bb that is from the current threading path.  */\n+  gcov_type total_count = e->dest->count;\n+  /* Handle incoming profile insanities.  */\n+  if (total_count < path_in_count)\n+    path_in_count = total_count;\n+  int onpath_scale = GCOV_COMPUTE_SCALE (path_in_count, total_count);\n+\n+  /* Walk the entire path to do some more computation in order to estimate\n+     how much of the path_in_count will flow out of the duplicated threading\n+     path.  In the non-joiner case this is straightforward (it should be\n+     the same as path_in_count, although we will handle incoming profile\n+     insanities by setting it equal to the minimum count along the path).\n+\n+     In the joiner case, we need to estimate how much of the path_in_count\n+     will stay on the threading path after the joiner's conditional branch.\n+     We don't really know for sure how much of the counts\n+     associated with this path go to each successor of the joiner, but we'll\n+     estimate based on the fraction of the total count coming into the path\n+     bb was from the threading paths (computed above in onpath_scale).\n+     Afterwards, we will need to do some fixup to account for other threading\n+     paths and possible profile insanities.\n+\n+     In order to estimate the joiner case's counts we also need to update\n+     nonpath_count with any additional counts coming into the path.  Other\n+     blocks along the path may have additional predecessors from outside\n+     the path.  */\n+  gcov_type path_out_count = path_in_count;\n+  gcov_type min_path_count = path_in_count;\n+  for (unsigned int i = 1; i < path->length (); i++)\n+    {\n+      edge epath = (*path)[i]->e;\n+      gcov_type cur_count = epath->count;\n+      if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+        {\n+          has_joiner = true;\n+          cur_count = apply_probability (cur_count, onpath_scale);\n+        }\n+      /* In the joiner case we need to update nonpath_count for any edges\n+         coming into the path that will contribute to the count flowing\n+         into the path successor.  */\n+      if (has_joiner && epath != elast)\n+      {\n+        /* Look for other incoming edges after joiner.  */\n+        FOR_EACH_EDGE (ein, ei, epath->dest->preds)\n+          {\n+            if (ein != epath\n+                /* Ignore in edges from blocks we have duplicated for a\n+                   threading path, which have duplicated edge counts until\n+                   they are redirected by an invocation of this routine.  */\n+                && !bitmap_bit_p (local_info->duplicate_blocks,\n+                                  ein->src->index))\n+              nonpath_count += ein->count;\n+          }\n+      }\n+      if (cur_count < path_out_count)\n+        path_out_count = cur_count;\n+      if (epath->count < min_path_count)\n+        min_path_count = epath->count;\n+    }\n+\n+  /* We computed path_out_count above assuming that this path targeted\n+     the joiner's on-path successor with the same likelihood as it\n+     reached the joiner.  However, other thread paths through the joiner\n+     may take a different path through the normal copy source block\n+     (i.e. they have a different elast), meaning that they do not\n+     contribute any counts to this path's elast.  As a result, it may\n+     turn out that this path must have more count flowing to the on-path\n+     successor of the joiner.  Essentially, all of this path's elast\n+     count must be contributed by this path and any nonpath counts\n+     (since any path through the joiner with a different elast will not\n+     include a copy of this elast in its duplicated path).\n+     So ensure that this path's path_out_count is at least the\n+     difference between elast->count and nonpath_count.  Otherwise the edge\n+     counts after threading will not be sane.  */\n+  if (has_joiner && path_out_count < elast->count - nonpath_count)\n+  {\n+    path_out_count = elast->count - nonpath_count;\n+    /* But neither can we go above the minimum count along the path\n+       we are duplicating.  This can be an issue due to profile\n+       insanities coming in to this pass.  */\n+    if (path_out_count > min_path_count)\n+      path_out_count = min_path_count;\n+  }\n+\n+  *path_in_count_ptr = path_in_count;\n+  *path_out_count_ptr = path_out_count;\n+  *path_in_freq_ptr = path_in_freq;\n+  return has_joiner;\n+}\n+\n+\n+/* Update the counts and frequencies for both an original path\n+   edge EPATH and its duplicate EDUP.  The duplicate source block\n+   will get a count/frequency of PATH_IN_COUNT and PATH_IN_FREQ,\n+   and the duplicate edge EDUP will have a count of PATH_OUT_COUNT.  */\n+static void\n+update_profile (edge epath, edge edup, gcov_type path_in_count,\n+                gcov_type path_out_count, int path_in_freq)\n+{\n+\n+  /* First update the duplicated block's count / frequency.  */\n+  if (edup)\n+    {\n+      basic_block dup_block = edup->src;\n+      gcc_assert (dup_block->count == 0);\n+      gcc_assert (dup_block->frequency == 0);\n+      dup_block->count = path_in_count;\n+      dup_block->frequency = path_in_freq;\n+    }\n+\n+  /* Now update the original block's count and frequency in the\n+     opposite manner - remove the counts/freq that will flow\n+     into the duplicated block.  Handle underflow due to precision/\n+     rounding issues.  */\n+  epath->src->count -= path_in_count;\n+  if (epath->src->count < 0)\n+    epath->src->count = 0;\n+  epath->src->frequency -= path_in_freq;\n+  if (epath->src->frequency < 0)\n+    epath->src->frequency = 0;\n+\n+  /* Next update this path edge's original and duplicated counts.  We know\n+     that the duplicated path will have path_out_count flowing\n+     out of it (in the joiner case this is the count along the duplicated path\n+     out of the duplicated joiner).  This count can then be removed from the\n+     original path edge.  */\n+  if (edup)\n+    edup->count = path_out_count;\n+  epath->count -= path_out_count;\n+  gcc_assert (epath->count >= 0);\n+}\n+\n+\n+/* The duplicate and original joiner blocks may end up with different\n+   probabilities (different from both the original and from each other).\n+   Recompute the probabilities here once we have updated the edge\n+   counts and frequencies.  */\n+\n+static void\n+recompute_probabilities (basic_block bb)\n+{\n+  edge esucc;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (esucc, ei, bb->succs)\n+    {\n+      if (bb->count)\n+        esucc->probability = GCOV_COMPUTE_SCALE (esucc->count,\n+                                                 bb->count);\n+      if (esucc->probability > REG_BR_PROB_BASE)\n+        {\n+\t  /* Can happen with missing/guessed probabilities, since we\n+\t     may determine that more is flowing along duplicated\n+\t     path than joiner succ probabilities allowed.\n+\t     Counts and freqs will be insane after jump threading,\n+\t     at least make sure probability is sane or we will\n+\t     get a flow verification error.\n+\t     Not much we can do to make counts/freqs sane without\n+\t     redoing the profile estimation.  */\n+\t  esucc->probability = REG_BR_PROB_BASE;\n+\t}\n+    }\n+}\n+\n+\n+/* Update the counts of the original and duplicated edges from a joiner\n+   that go off path, given that we have already determined that the\n+   duplicate joiner DUP_BB has incoming count PATH_IN_COUNT and\n+   outgoing count along the path PATH_OUT_COUNT.  The original (on-)path\n+   edge from joiner is EPATH.  */\n+\n+static void\n+update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n+                              gcov_type path_in_count,\n+                              gcov_type path_out_count)\n+{\n+  /* Compute the count that currently flows off path from the joiner.\n+     In other words, the total count of joiner's out edges other than\n+     epath.  Compute this by walking the successors instead of\n+     subtracting epath's count from the joiner bb count, since there\n+     are sometimes slight insanities where the total out edge count is\n+     larger than the bb count (possibly due to rounding/truncation\n+     errors).  */\n+  gcov_type total_orig_off_path_count = 0;\n+  edge enonpath;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n+    {\n+      if (enonpath == epath)\n+        continue;\n+      total_orig_off_path_count += enonpath->count;\n+    }\n+\n+  /* For the path that we are duplicating, the amount that will flow\n+     off path from the duplicated joiner is the delta between the\n+     path's cumulative in count and the portion of that count we\n+     estimated above as flowing from the joiner along the duplicated\n+     path.  */\n+  gcov_type total_dup_off_path_count = path_in_count - path_out_count;\n+\n+  /* Now do the actual updates of the off-path edges.  */\n+  FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n+    {\n+      /* Look for edges going off of the threading path.  */\n+      if (enonpath == epath)\n+        continue;\n+\n+      /* Find the corresponding edge out of the duplicated joiner.  */\n+      edge enonpathdup = find_edge (dup_bb, enonpath->dest);\n+      gcc_assert (enonpathdup);\n+\n+      /* We can't use the original probability of the joiner's out\n+         edges, since the probabilities of the original branch\n+         and the duplicated branches may vary after all threading is\n+         complete.  But apportion the duplicated joiner's off-path\n+         total edge count computed earlier (total_dup_off_path_count)\n+         among the duplicated off-path edges based on their original\n+         ratio to the full off-path count (total_orig_off_path_count).\n+         */\n+      int scale = GCOV_COMPUTE_SCALE (enonpath->count,\n+                                      total_orig_off_path_count);\n+      /* Give the duplicated offpath edge a portion of the duplicated\n+         total.  */\n+      enonpathdup->count = apply_scale (scale,\n+                                        total_dup_off_path_count);\n+      /* Now update the original offpath edge count, handling underflow\n+         due to rounding errors.  */\n+      enonpath->count -= enonpathdup->count;\n+      if (enonpath->count < 0)\n+        enonpath->count = 0;\n+    }\n+}\n+\n+\n+/* Invoked for routines that have guessed frequencies and no profile\n+   counts to record the block and edge frequencies for paths through RD\n+   in the profile count fields of those blocks and edges.  This is because\n+   ssa_fix_duplicate_block_edges incrementally updates the block and\n+   edge counts as edges are redirected, and it is difficult to do that\n+   for edge frequencies which are computed on the fly from the source\n+   block frequency and probability.  When a block frequency is updated\n+   its outgoing edge frequencies are affected and become difficult to\n+   adjust.  */\n+\n+static void\n+freqs_to_counts_path (struct redirection_data *rd)\n+{\n+  edge e = rd->incoming_edges->e;\n+  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+  edge ein;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n+    {\n+      gcc_assert (!ein->count);\n+      ein->count = EDGE_FREQUENCY (ein);\n+    }\n+\n+  for (unsigned int i = 1; i < path->length (); i++)\n+    {\n+      edge epath = (*path)[i]->e;\n+      gcc_assert (!epath->count);\n+      edge esucc;\n+      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+        {\n+          esucc->count = EDGE_FREQUENCY (esucc);\n+        }\n+      epath->src->count = epath->src->frequency;\n+    }\n+}\n+\n+\n+/* For routines that have guessed frequencies and no profile counts, where we\n+   used freqs_to_counts_path to record block and edge frequencies for paths\n+   through RD, we clear the counts after completing all updates for RD.\n+   The updates in ssa_fix_duplicate_block_edges are based off the count fields,\n+   but the block frequencies and edge probabilities were updated as well,\n+   so we can simply clear the count fields.  */\n+\n+static void\n+clear_counts_path (struct redirection_data *rd)\n+{\n+  edge e = rd->incoming_edges->e;\n+  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+  edge ein, esucc;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n+    ein->count = 0;\n+\n+  /* First clear counts along original path.  */\n+  for (unsigned int i = 1; i < path->length (); i++)\n+    {\n+      edge epath = (*path)[i]->e;\n+      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+        esucc->count = 0;\n+      epath->src->count = 0;\n+    }\n+  /* Also need to clear the counts along duplicated path.  */\n+  for (unsigned int i = 0; i < 2; i++)\n+    {\n+      basic_block dup = rd->dup_blocks[i];\n+      if (!dup)\n+        continue;\n+      FOR_EACH_EDGE (esucc, ei, dup->succs)\n+        esucc->count = 0;\n+      dup->count = 0;\n+    }\n+}\n+\n /* Wire up the outgoing edges from the duplicate blocks and\n-   update any PHIs as needed.  */\n+   update any PHIs as needed.  Also update the profile counts\n+   on the original and duplicate blocks and edges.  */\n void\n ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t\t       ssa_local_info_t *local_info)\n {\n   bool multi_incomings = (rd->incoming_edges->next != NULL);\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-\n+  edge elast = path->last ()->e;\n+  gcov_type path_in_count = 0;\n+  gcov_type path_out_count = 0;\n+  int path_in_freq = 0;\n+\n+  /* This routine updates profile counts, frequencies, and probabilities\n+     incrementally. Since it is difficult to do the incremental updates\n+     using frequencies/probabilities alone, for routines without profile\n+     data we first take a snapshot of the existing block and edge frequencies\n+     by copying them into the empty profile count fields.  These counts are\n+     then used to do the incremental updates, and cleared at the end of this\n+     routine.  */\n+  bool do_freqs_to_counts = (profile_status_for_fn (cfun) != PROFILE_READ\n+                             || !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n+  if (do_freqs_to_counts)\n+    freqs_to_counts_path (rd);\n+\n+  /* First determine how much profile count to move from original\n+     path to the duplicate path.  This is tricky in the presence of\n+     a joiner (see comments for compute_path_counts), where some portion\n+     of the path's counts will flow off-path from the joiner.  In the\n+     non-joiner case the path_in_count and path_out_count should be the\n+     same.  */\n+  bool has_joiner = compute_path_counts (rd, local_info,\n+                                         &path_in_count, &path_out_count,\n+                                         &path_in_freq);\n+\n+  int cur_path_freq = path_in_freq;\n   for (unsigned int count = 0, i = 1; i < path->length (); i++)\n     {\n+      edge epath = (*path)[i]->e;\n+\n       /* If we were threading through an joiner block, then we want\n \t to keep its control statement and redirect an outgoing edge.\n \t Else we want to remove the control statement & edges, then create\n@@ -576,6 +1084,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  edge victim;\n \t  edge e2;\n \n+          gcc_assert (has_joiner);\n+\n \t  /* This updates the PHIs at the destination of the duplicate\n \t     block.  Pass 0 instead of i if we are threading a path which\n \t     has multiple incoming edges.  */\n@@ -591,14 +1101,13 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t     threading path.  */\n \t  if (!any_remaining_duplicated_blocks (path, i))\n \t    {\n-\t      e2 = redirect_edge_and_branch (victim, path->last ()->e->dest);\n-\t      e2->count = path->last ()->e->count;\n+\t      e2 = redirect_edge_and_branch (victim, elast->dest);\n \t      /* If we redirected the edge, then we need to copy PHI arguments\n \t\t at the target.  If the edge already existed (e2 != victim\n \t\t case), then the PHIs in the target already have the correct\n \t\t arguments.  */\n \t      if (e2 == victim)\n-\t\tcopy_phi_args (e2->dest, path->last ()->e, e2,\n+\t\tcopy_phi_args (e2->dest, elast, e2,\n \t\t\t       path, multi_incomings ? 0 : i);\n \t    }\n \t  else\n@@ -626,7 +1135,31 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t    }\n \t\t}\n \t    }\n-\t  count++;\n+\n+\t  /* Update the counts and frequency of both the original block\n+\t     and path edge, and the duplicates.  The path duplicate's\n+\t     incoming count and frequency are the totals for all edges\n+\t     incoming to this jump threading path computed earlier.\n+\t     And we know that the duplicated path will have path_out_count\n+\t     flowing out of it (i.e. along the duplicated path out of the\n+\t     duplicated joiner).  */\n+\t  update_profile (epath, e2, path_in_count, path_out_count,\n+\t\t\t  path_in_freq);\n+\n+\t  /* Next we need to update the counts of the original and duplicated\n+\t     edges from the joiner that go off path.  */\n+\t  update_joiner_offpath_counts (epath, e2->src, path_in_count,\n+                                        path_out_count);\n+\n+\t  /* Finally, we need to set the probabilities on the duplicated\n+\t     edges out of the duplicated joiner (e2->src).  The probabilities\n+\t     along the original path will all be updated below after we finish\n+\t     processing the whole path.  */\n+\t  recompute_probabilities (e2->src);\n+\n+\t  /* Record the frequency flowing to the downstream duplicated\n+\t     path blocks.  */\n+\t  cur_path_freq = EDGE_FREQUENCY (e2);\n \t}\n       else if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n \t{\n@@ -635,9 +1168,60 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t\t\t\t\t   multi_incomings ? 0 : i);\n \t  if (count == 1)\n \t    single_succ_edge (rd->dup_blocks[1])->aux = NULL;\n-\t  count++;\n+\n+\t  /* Update the counts and frequency of both the original block\n+\t     and path edge, and the duplicates.  Since we are now after\n+\t     any joiner that may have existed on the path, the count\n+\t     flowing along the duplicated threaded path is path_out_count.\n+\t     If we didn't have a joiner, then cur_path_freq was the sum\n+\t     of the total frequencies along all incoming edges to the\n+\t     thread path (path_in_freq).  If we had a joiner, it would have\n+\t     been updated at the end of that handling to the edge frequency\n+\t     along the duplicated joiner path edge.  */\n+\t  update_profile (epath, EDGE_SUCC (rd->dup_blocks[count], 0),\n+\t\t\t  path_out_count, path_out_count,\n+\t\t\t  cur_path_freq);\n+\t}\n+      else\n+        {\n+\t  /* No copy case.  In this case we don't have an equivalent block\n+\t     on the duplicated thread path to update, but we do need\n+\t     to remove the portion of the counts/freqs that were moved\n+\t     to the duplicated path from the counts/freqs flowing through\n+\t     this block on the original path.  Since all the no-copy edges\n+\t     are after any joiner, the removed count is the same as\n+\t     path_out_count.\n+\n+\t     If we didn't have a joiner, then cur_path_freq was the sum\n+\t     of the total frequencies along all incoming edges to the\n+\t     thread path (path_in_freq).  If we had a joiner, it would have\n+\t     been updated at the end of that handling to the edge frequency\n+\t     along the duplicated joiner path edge.  */\n+\t     update_profile (epath, NULL, path_out_count, path_out_count,\n+\t\t\t     cur_path_freq);\n \t}\n+\n+      /* Increment the index into the duplicated path when we processed\n+         a duplicated block.  */\n+      if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK\n+          || (*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n+      {\n+\t  count++;\n+      }\n     }\n+\n+  /* Now walk orig blocks and update their probabilities, since the\n+     counts and freqs should be updated properly by above loop.  */\n+  for (unsigned int i = 1; i < path->length (); i++)\n+    {\n+      edge epath = (*path)[i]->e;\n+      recompute_probabilities (epath->src);\n+    }\n+\n+  /* Done with all profile and frequency updates, clear counts if they\n+     were copied.  */\n+  if (do_freqs_to_counts)\n+    clear_counts_path (rd);\n }\n \n /* Hash table traversal callback routine to create duplicate blocks.  */\n@@ -663,7 +1247,8 @@ ssa_create_duplicates (struct redirection_data **slot,\n       if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK\n \t  || (*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n-\t  create_block_for_threading ((*path)[i]->e->src, rd, 1);\n+\t  create_block_for_threading ((*path)[i]->e->src, rd, 1,\n+                                      &local_info->duplicate_blocks);\n \t  break;\n \t}\n     }\n@@ -672,7 +1257,8 @@ ssa_create_duplicates (struct redirection_data **slot,\n      use the template to create a new block.  */\n   if (local_info->template_block == NULL)\n     {\n-      create_block_for_threading ((*path)[1]->e->src, rd, 0);\n+      create_block_for_threading ((*path)[1]->e->src, rd, 0,\n+                                  &local_info->duplicate_blocks);\n       local_info->template_block = rd->dup_blocks[0];\n \n       /* We do not create any outgoing edges for the template.  We will\n@@ -681,7 +1267,8 @@ ssa_create_duplicates (struct redirection_data **slot,\n     }\n   else\n     {\n-      create_block_for_threading (local_info->template_block, rd, 0);\n+      create_block_for_threading (local_info->template_block, rd, 0,\n+                                  &local_info->duplicate_blocks);\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n \t block.   */\n@@ -751,19 +1338,6 @@ ssa_redirect_edges (struct redirection_data **slot,\n \t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n \t\t     e->src->index, e->dest->index, rd->dup_blocks[0]->index);\n \n-\t  rd->dup_blocks[0]->count += e->count;\n-\n-\t  /* Excessive jump threading may make frequencies large enough so\n-\t     the computation overflows.  */\n-\t  if (rd->dup_blocks[0]->frequency < BB_FREQ_MAX * 2)\n-\t    rd->dup_blocks[0]->frequency += EDGE_FREQUENCY (e);\n-\n-\t  /* In the case of threading through a joiner block, the outgoing\n-\t     edges from the duplicate block were updated when they were\n-\t     redirected during ssa_fix_duplicate_block_edges.  */\n-\t  if ((*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n-\t    EDGE_SUCC (rd->dup_blocks[0], 0)->count += e->count;\n-\n \t  /* If we redirect a loop latch edge cancel its loop.  */\n \t  if (e->src == e->src->loop_father->latch)\n \t    mark_loop_for_removal (e->src->loop_father);\n@@ -849,6 +1423,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n   edge_iterator ei;\n   ssa_local_info_t local_info;\n \n+  local_info.duplicate_blocks = BITMAP_ALLOC (NULL);\n+\n   /* To avoid scanning a linear array for the element we need we instead\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n@@ -908,10 +1484,6 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \t    continue;\n \t}\n \n-      if (e->dest == e2->src)\n-\tupdate_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t\t e->count, (*THREAD_PATH (e))[1]->e);\n-\n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n       lookup_redirection_data (e, INSERT);\n@@ -965,6 +1537,9 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n       && bb == bb->loop_father->header)\n     set_loop_copy (bb->loop_father, NULL);\n \n+  BITMAP_FREE (local_info.duplicate_blocks);\n+  local_info.duplicate_blocks = NULL;\n+\n   /* Indicate to our caller whether or not any jumps were threaded.  */\n   return local_info.jumps_threaded;\n }\n@@ -1031,7 +1606,7 @@ thread_single_edge (edge e)\n   npath->safe_push (x);\n   rd.path = npath;\n \n-  create_block_for_threading (bb, &rd, 0);\n+  create_block_for_threading (bb, &rd, 0, NULL);\n   remove_ctrl_stmt_and_useless_edges (rd.dup_blocks[0], NULL);\n   create_edge_and_update_destination_phis (&rd, rd.dup_blocks[0], 0);\n "}]}