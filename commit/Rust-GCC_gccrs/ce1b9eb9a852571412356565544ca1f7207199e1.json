{"sha": "ce1b9eb9a852571412356565544ca1f7207199e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxYjllYjlhODUyNTcxNDEyMzU2NTY1NTQ0Y2ExZjcyMDcxOTllMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-20T11:03:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-20T11:03:18Z"}, "message": "decl2.c (find_representative_member): New function.\n\n\t* decl2.c (find_representative_member): New function.\n\t(finish_anon_union): Use it.\n\nFrom-SVN: r19910", "tree": {"sha": "713826f356a31b538c52674679218fc84194dbe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/713826f356a31b538c52674679218fc84194dbe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1b9eb9a852571412356565544ca1f7207199e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1b9eb9a852571412356565544ca1f7207199e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1b9eb9a852571412356565544ca1f7207199e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1b9eb9a852571412356565544ca1f7207199e1/comments", "author": null, "committer": null, "parents": [{"sha": "f9c3933a4bc38832c1708b79a1e9c81feac2709e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c3933a4bc38832c1708b79a1e9c81feac2709e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9c3933a4bc38832c1708b79a1e9c81feac2709e"}], "stats": {"total": 77, "additions": 60, "deletions": 17}, "files": [{"sha": "ef645d15d18ca242f34fc977f30361845fa2939e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ce1b9eb9a852571412356565544ca1f7207199e1", "patch": "@@ -1,5 +1,8 @@\n 1998-05-20  Mark Mitchell  <mmitchell@usa.net>\n \n+\t* decl2.c (find_representative_member): New function.\n+\t(finish_anon_union): Use it.\n+\n \t* cp-tree.h (MAIN_NAME_P): New macro.\n \t(DECL_MAIN_P): Likwise.\n \t* decl.c (pushdecl): Avoid crashing on redefinitions of `main'."}, {"sha": "63b90d72c31d12d01e00c868e38f7110412b00ce", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ce1b9eb9a852571412356565544ca1f7207199e1", "patch": "@@ -52,6 +52,7 @@ static int is_namespace_ancestor PROTO((tree, tree));\n static tree namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree));\n+static tree find_representative_member PROTO((tree));\n \n extern int current_class_depth;\n \n@@ -2144,6 +2145,43 @@ get_temp_regvar (type, init)\n   return decl;\n }\n \n+/* Hunt through ANON_DECL, which declares an anonymous union, for a named\n+   member of the same size as ANON_DECL.  */\n+\n+tree\n+find_representative_member (anon_decl)\n+     tree anon_decl;\n+{\n+  tree field;\n+  tree main_decl = NULL_TREE;\n+\n+  for (field = TYPE_FIELDS (TREE_TYPE (anon_decl));\n+       field != NULL_TREE; \n+       field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* Only write out one anon union element--choose the one that\n+\t can hold them all.  */\n+      if (main_decl == NULL_TREE\n+\t  && 1 == simple_cst_equal (DECL_SIZE (field),\n+\t\t\t\t    DECL_SIZE (anon_decl)))\n+\t{\n+\t  if (DECL_NAME (field))\n+\t    main_decl = field;\n+\t  else if (TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t    main_decl = find_representative_member (field);\n+\t}\n+      else\n+\t/* ??? This causes there to be no debug info written out\n+\t   about this decl.  */\n+\tTREE_ASM_WRITTEN (field) = 1;\n+    }\n+\n+  return main_decl;\n+}\n+\n /* Finish off the processing of a UNION_TYPE structure.\n    If there are static members, then all members are\n    static, and must be laid out together.  If the\n@@ -2156,13 +2194,13 @@ finish_anon_union (anon_union_decl)\n      tree anon_union_decl;\n {\n   tree type = TREE_TYPE (anon_union_decl);\n-  tree field, main_decl = NULL_TREE;\n+  tree field = TYPE_FIELDS (type);\n   tree elems = NULL_TREE;\n   int public_p = TREE_PUBLIC (anon_union_decl);\n   int static_p = TREE_STATIC (anon_union_decl);\n   int external_p = DECL_EXTERNAL (anon_union_decl);\n \n-  if ((field = TYPE_FIELDS (type)) == NULL_TREE)\n+  if (field == NULL_TREE)\n     return;\n \n   if (public_p)\n@@ -2182,6 +2220,14 @@ finish_anon_union (anon_union_decl)\n       else if (TREE_PROTECTED (field))\n \tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n \n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n+\t  && find_representative_member (field) == NULL_TREE)\n+\t/* The member is an empty anonymous union.  Don't make a\n+\t   declaration for it, as finish_file will otherwise try to\n+\t   call make_decl_rtl for it, and crash.  */\n+\tcontinue;\n+\n       decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n       /* tell `pushdecl' that this is not tentative.  */\n       DECL_INITIAL (decl) = error_mark_node;\n@@ -2190,29 +2236,17 @@ finish_anon_union (anon_union_decl)\n       DECL_EXTERNAL (decl) = external_p;\n       decl = pushdecl (decl);\n \n-      /* Only write out one anon union element--choose the one that\n-\t can hold them all.  */\n-      if (main_decl == NULL_TREE\n-\t  && 1 == simple_cst_equal (DECL_SIZE (decl),\n-\t\t\t\t    DECL_SIZE (anon_union_decl)))\n-\t{\n-\t  main_decl = decl;\n-\t}\n-      else\n-\t{\n-\t  /* ??? This causes there to be no debug info written out\n-\t     about this decl.  */\n-\t  TREE_ASM_WRITTEN (decl) = 1;\n-\t}\n-\n       DECL_INITIAL (decl) = NULL_TREE;\n       /* If there's a cleanup to do, it belongs in the\n \t TREE_PURPOSE of the following TREE_LIST.  */\n       elems = scratch_tree_cons (NULL_TREE, decl, elems);\n       TREE_TYPE (elems) = type;\n     }\n+\n   if (static_p)\n     {\n+      tree main_decl = find_representative_member (anon_union_decl);\n+\n       if (main_decl)\n \t{\n \t  make_decl_rtl (main_decl, 0, toplevel_bindings_p ());"}, {"sha": "87948481d2b9574ce8660af0202d5234dc0c3234", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b9eb9a852571412356565544ca1f7207199e1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon1.C?ref=ce1b9eb9a852571412356565544ca1f7207199e1", "patch": "@@ -0,0 +1,6 @@\n+// Build don't link:\n+\n+static union {\n+  union {\n+  };\n+}; // ERROR - anonymous union with no members"}]}