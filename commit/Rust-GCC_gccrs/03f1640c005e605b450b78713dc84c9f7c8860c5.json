{"sha": "03f1640c005e605b450b78713dc84c9f7c8860c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmMTY0MGMwMDVlNjA1YjQ1MGI3ODcxM2RjODRjOWY3Yzg4NjBjNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-05-10T13:10:47Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-05-10T13:10:47Z"}, "message": "arm.md (DOM_CC_X_AND_Y, [...]): New constants.\n\n* arm.md (DOM_CC_X_AND_Y, DOM_CC_NX_OR_Y, DOM_CC_X_OR_Y): New\nconstants.\n(ior_scc_scc, and_scc_scc): New insn_and_split patterns.\n* arm.c (arm_select_dominance_cc_mode): Renamed from\nselect_dominance_cc_mode, no-longer static.  Use DOM_CC... constants.\nCallers updated.\n* arm-protos.h (arm_select_dominance_cc_mode): Add prototype.\n\nFrom-SVN: r66662", "tree": {"sha": "7aeb8d0b0c940516f2bf53921b2d2aa5e00060d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aeb8d0b0c940516f2bf53921b2d2aa5e00060d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03f1640c005e605b450b78713dc84c9f7c8860c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f1640c005e605b450b78713dc84c9f7c8860c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f1640c005e605b450b78713dc84c9f7c8860c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f1640c005e605b450b78713dc84c9f7c8860c5/comments", "author": null, "committer": null, "parents": [{"sha": "429d6300848372398c42e8c48aac076cef5405f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429d6300848372398c42e8c48aac076cef5405f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429d6300848372398c42e8c48aac076cef5405f3"}], "stats": {"total": 114, "additions": 94, "deletions": 20}, "files": [{"sha": "6a4c6d6188a6478b8b428d42f9f80bbaeb3af5d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03f1640c005e605b450b78713dc84c9f7c8860c5", "patch": "@@ -1,3 +1,13 @@\n+2003-05-10  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.md (DOM_CC_X_AND_Y, DOM_CC_NX_OR_Y, DOM_CC_X_OR_Y): New \n+\tconstants.\n+\t(ior_scc_scc, and_scc_scc): New insn_and_split patterns.\n+\t* arm.c (arm_select_dominance_cc_mode): Renamed from \n+\tselect_dominance_cc_mode, no-longer static.  Use DOM_CC... constants.\n+\tCallers updated.\n+\t* arm-protos.h (arm_select_dominance_cc_mode): Add prototype.\n+\n 2003-05-09  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/alpha/alpha.c (alpha_start_function): Declare frame_size"}, {"sha": "7f6610a8297b22451bcdec75bfa1e985f63ae861", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=03f1640c005e605b450b78713dc84c9f7c8860c5", "patch": "@@ -117,6 +117,8 @@ extern rtx    arm_gen_store_multiple\tPARAMS ((int, int, rtx, int, int, int,\n extern int    arm_gen_movstrqi\t\tPARAMS ((rtx *));\n extern rtx    arm_gen_rotated_half_load\tPARAMS ((rtx));\n extern enum machine_mode arm_select_cc_mode PARAMS ((RTX_CODE, rtx, rtx));\n+extern enum machine_mode arm_select_dominance_cc_mode PARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t       HOST_WIDE_INT));\n extern rtx    arm_gen_compare_reg\tPARAMS ((RTX_CODE, rtx, rtx));\n extern rtx    arm_gen_return_addr_mask\tPARAMS ((void));\n extern void   arm_reload_in_hi\t\tPARAMS ((rtx *));"}, {"sha": "41b49f8d871c8c2d0999f8a1b3bcad02ecc6e156", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=03f1640c005e605b450b78713dc84c9f7c8860c5", "patch": "@@ -92,7 +92,6 @@ static Hint      int_log2\t\t\tPARAMS ((Hint));\n static rtx       is_jump_table \t\t\tPARAMS ((rtx));\n static Ccstar    output_multi_immediate\t\tPARAMS ((rtx *, Ccstar, Ccstar, int, Hint));\n static void      print_multi_reg\t\tPARAMS ((FILE *, Ccstar, int, int));\n-static Mmode     select_dominance_cc_mode\tPARAMS ((rtx, rtx, Hint));\n static Ccstar    shift_op\t\t\tPARAMS ((rtx, Hint *));\n static struct machine_function * arm_init_machine_status PARAMS ((void));\n static int       number_of_first_bit_set        PARAMS ((int));\n@@ -5504,16 +5503,18 @@ arm_gen_rotated_half_load (memref)\n   return gen_rtx_ROTATE (SImode, base, GEN_INT (16));\n }\n \n-/* Select a dominance comparison mode if possible.  We support three forms.\n-   COND_OR == 0 => (X && Y) \n-   COND_OR == 1 => ((! X( || Y)\n-   COND_OR == 2 => (X || Y) \n-   If we are unable to support a dominance comparison we return CC mode.  \n-   This will then fail to match for the RTL expressions that generate this\n-   call.  */\n+/* Select a dominance comparison mode if possible for a test of the general\n+   form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.\n+   COND_OR == DOM_CC_X_AND_Y => (X && Y) \n+   COND_OR == DOM_CC_NX_OR_Y => ((! X) || Y)\n+   COND_OR == DOM_CC_X_OR_Y => (X || Y) \n+   In all cases OP will be either EQ or NE, but we don't need to know which\n+   here.  If we are unable to support a dominance comparison we return \n+   CC mode.  This will then fail to match for the RTL expressions that\n+   generate this call.  */\n \n-static enum machine_mode\n-select_dominance_cc_mode (x, y, cond_or)\n+enum machine_mode\n+arm_select_dominance_cc_mode (x, y, cond_or)\n      rtx x;\n      rtx y;\n      HOST_WIDE_INT cond_or;\n@@ -5533,7 +5534,7 @@ select_dominance_cc_mode (x, y, cond_or)\n   /* The if_then_else variant of this tests the second condition if the\n      first passes, but is true if the first fails.  Reverse the first\n      condition to get a true \"inclusive-or\" expression.  */\n-  if (cond_or == 1)\n+  if (cond_or == DOM_CC_NX_OR_Y)\n     cond1 = reverse_condition (cond1);\n \n   /* If the comparisons are not equal, and one doesn't dominate the other,\n@@ -5553,7 +5554,7 @@ select_dominance_cc_mode (x, y, cond_or)\n   switch (cond1)\n     {\n     case EQ:\n-      if (cond2 == EQ || !cond_or)\n+      if (cond2 == EQ || cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DEQmode;\n \n       switch (cond2)\n@@ -5568,7 +5569,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case LT:\n-      if (cond2 == LT || !cond_or)\n+      if (cond2 == LT || cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DLTmode;\n       if (cond2 == LE)\n \treturn CC_DLEmode;\n@@ -5577,7 +5578,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case GT:\n-      if (cond2 == GT || !cond_or)\n+      if (cond2 == GT || cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DGTmode;\n       if (cond2 == GE)\n \treturn CC_DGEmode;\n@@ -5586,7 +5587,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n       \n     case LTU:\n-      if (cond2 == LTU || !cond_or)\n+      if (cond2 == LTU || cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DLTUmode;\n       if (cond2 == LEU)\n \treturn CC_DLEUmode;\n@@ -5595,7 +5596,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case GTU:\n-      if (cond2 == GTU || !cond_or)\n+      if (cond2 == GTU || cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DGTUmode;\n       if (cond2 == GEU)\n \treturn CC_DGEUmode;\n@@ -5696,19 +5697,21 @@ arm_select_cc_mode (op, x, y)\n \t  || XEXP (x, 2) == const1_rtx)\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n-    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), \n-\t\t\t\t     INTVAL (XEXP (x, 2)));\n+    return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), \n+\t\t\t\t\t INTVAL (XEXP (x, 2)));\n \n   /* Alternate canonicalizations of the above.  These are somewhat cleaner.  */\n   if (GET_CODE (x) == AND\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n-    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), 0);\n+    return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1),\n+\t\t\t\t\t DOM_CC_X_AND_Y);\n \n   if (GET_CODE (x) == IOR\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n       && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n-    return select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), 2);\n+    return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1),\n+\t\t\t\t\t DOM_CC_X_OR_Y);\n \n   /* An operation that sets the condition codes as a side-effect, the\n      V flag is not set correctly, so we can only use comparisons where"}, {"sha": "85bd1462dd0bd3f2dc8acf255292240250fed9fd", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f1640c005e605b450b78713dc84c9f7c8860c5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=03f1640c005e605b450b78713dc84c9f7c8860c5", "patch": "@@ -38,6 +38,13 @@\n    (LAST_ARM_REGNUM 15)\n   ]\n )\n+;; 3rd operand to select_dominance_cc_mode\n+(define_constants\n+  [(DOM_CC_X_AND_Y  0)\n+   (DOM_CC_NX_OR_Y  1)\n+   (DOM_CC_X_OR_Y   2)\n+  ]\n+)\n \n ;; UNSPEC Usage:\n ;; Note: sin and cos are no-longer used.\n@@ -6745,6 +6752,58 @@\n    (set_attr \"length\" \"8\")]\n )\n \n+(define_insn_and_split \"*ior_scc_scc\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (match_operator:SI 3 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arm_add_operand\" \"rIL\")])\n+\t\t(match_operator:SI 6 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 4 \"s_register_operand\" \"r\")\n+\t\t  (match_operand:SI 5 \"arm_add_operand\" \"rIL\")])))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\n+   && (arm_select_dominance_cc_mode (operands[3], operands[6], DOM_CC_X_OR_Y)\n+       != CCmode)\"\n+  \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 7)\n+\t(compare\n+\t (ior:SI\n+\t  (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t  (match_op_dup 6 [(match_dup 4) (match_dup 5)]))\n+\t (const_int 0)))\n+   (set (match_dup 0) (ne:SI (match_dup 7) (const_int 0)))]\n+  \"operands[7]\n+     = gen_rtx_REG (arm_select_dominance_cc_mode (operands[3], operands[6],\n+\t\t\t\t\t\t  DOM_CC_X_OR_Y),\n+\t\t    CC_REGNUM);\")\n+\n+(define_insn_and_split \"*and_scc_scc\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(and:SI (match_operator:SI 3 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arm_add_operand\" \"rIL\")])\n+\t\t(match_operator:SI 6 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 4 \"s_register_operand\" \"r\")\n+\t\t  (match_operand:SI 5 \"arm_add_operand\" \"rIL\")])))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\n+   && (arm_select_dominance_cc_mode (operands[3], operands[6], DOM_CC_X_AND_Y)\n+       != CCmode)\"\n+  \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 7)\n+\t(compare\n+\t (and:SI\n+\t  (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t  (match_op_dup 6 [(match_dup 4) (match_dup 5)]))\n+\t (const_int 0)))\n+   (set (match_dup 0) (ne:SI (match_dup 7) (const_int 0)))]\n+  \"operands[7]\n+     = gen_rtx_REG (arm_select_dominance_cc_mode (operands[3], operands[6],\n+\t\t\t\t\t\t  DOM_CC_X_AND_Y),\n+\t\t    CC_REGNUM);\")\n+\n (define_insn \"*negscc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(neg:SI (match_operator 3 \"arm_comparison_operator\""}]}