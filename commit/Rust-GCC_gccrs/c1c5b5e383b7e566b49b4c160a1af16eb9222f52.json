{"sha": "c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFjNWI1ZTM4M2I3ZTU2NmI0OWI0YzE2MGExYWYxNmViOTIyMmY1Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-02-02T00:30:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-02-02T00:30:36Z"}, "message": "re PR rtl-optimization/19680 (sub-optimial register allocation with sse)\n\n        PR target/19680\n        * config/i386/i386.h (MODES_TIEABLE_P): Use ix86_modes_tieable_p.\n        * config/i386/i386.c (ix86_hard_regno_mode_ok): Change return\n        type to bool.\n        (ix86_tieable_integer_mode_p, ix86_modes_tieable_p): New.\n        * config/i386/i386-protos.h: Update.\n\nFrom-SVN: r94575", "tree": {"sha": "7ed9ac7a001a41282b1bc0a116f2ed9933e1a48a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ed9ac7a001a41282b1bc0a116f2ed9933e1a48a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/comments", "author": null, "committer": null, "parents": [{"sha": "fa4c37aab9ba18b8d345be30a4ebc463e7209b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4c37aab9ba18b8d345be30a4ebc463e7209b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4c37aab9ba18b8d345be30a4ebc463e7209b4c"}], "stats": {"total": 87, "additions": 75, "deletions": 12}, "files": [{"sha": "6390a0b301e21e65a077962554a9e82fe4b51795", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "patch": "@@ -1,3 +1,12 @@\n+2005-02-01  Richard Henderson  <rth@redhat.com\n+\n+\tPR target/19680\n+\t* config/i386/i386.h (MODES_TIEABLE_P): Use ix86_modes_tieable_p.\n+\t* config/i386/i386.c (ix86_hard_regno_mode_ok): Change return\n+\ttype to bool.\n+\t(ix86_tieable_integer_mode_p, ix86_modes_tieable_p): New.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2005-02-01  Steven Bosscher  <stevenb@suse.de>\n \n \tPR tree-optimization/19217"}, {"sha": "53edfd161045a62f63c610550369354ef1605a1c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "patch": "@@ -180,7 +180,8 @@ extern rtx ix86_force_to_memory (enum machine_mode, rtx);\n extern void ix86_free_from_memory (enum machine_mode);\n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx, rtx);\n-extern int ix86_hard_regno_mode_ok (int, enum machine_mode);\n+extern bool ix86_hard_regno_mode_ok (int, enum machine_mode);\n+extern bool ix86_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern int ix86_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);\n extern int ix86_secondary_memory_needed (enum reg_class, enum reg_class,"}, {"sha": "bc680c80df9c6bececa5e4ecfe82871015fef496", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "patch": "@@ -14997,7 +14997,8 @@ ix86_register_move_cost (enum machine_mode mode, enum reg_class class1,\n }\n \n /* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-int\n+\n+bool\n ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   /* Flags and only flags can only hold CCmode values.  */\n@@ -15038,6 +15039,67 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n }\n \n+/* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a \n+   tieable integer mode.  */\n+\n+static bool\n+ix86_tieable_integer_mode_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case HImode:\n+    case SImode:\n+      return true;\n+\n+    case QImode:\n+      return TARGET_64BIT || !TARGET_PARTIAL_REG_STALL;\n+\n+    case DImode:\n+      return TARGET_64BIT;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if MODE1 is accessible in a register that can hold MODE2\n+   without copying.  That is, all register classes that can hold MODE2\n+   can also hold MODE1.  */\n+\n+bool\n+ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+{\n+  if (mode1 == mode2)\n+    return true;\n+\n+  if (ix86_tieable_integer_mode_p (mode1)\n+      && ix86_tieable_integer_mode_p (mode2))\n+    return true;\n+\n+  /* MODE2 being XFmode implies fp stack or general regs, which means we\n+     can tie any smaller floating point modes to it.  Note that we do not\n+     tie this with TFmode.  */\n+  if (mode2 == XFmode)\n+    return mode1 == SFmode || mode1 == DFmode;\n+\n+  /* MODE2 being DFmode implies fp stack, general or sse regs, which means\n+     that we can tie it with SFmode.  */\n+  if (mode2 == DFmode)\n+    return mode1 == SFmode;\n+\n+  /* If MODE2 is only appropriate for an SSE register, then tie with \n+     any other mode acceptable to SSE registers.  */\n+  if (SSE_REG_MODE_P (mode2))\n+    return ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode1);\n+\n+  /* If MODE2 is appropriate for an MMX (or SSE) register, then tie\n+     with any other mode acceptable to MMX registers.  */\n+  if (MMX_REG_MODE_P (mode2))\n+    return ix86_hard_regno_mode_ok (FIRST_MMX_REG, mode1);\n+\n+  return false;\n+}\n+\n /* Return the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n    relative to those in `REGISTER_MOVE_COST'."}, {"sha": "5c2046a49d711a5b90f554127b83ba6234613801", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1c5b5e383b7e566b49b4c160a1af16eb9222f52/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c1c5b5e383b7e566b49b4c160a1af16eb9222f52", "patch": "@@ -1122,16 +1122,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n-  ((MODE1) == (MODE2)\t\t\t\t\t\t\\\n-   || (((MODE1) == HImode || (MODE1) == SImode\t\t\t\\\n-\t|| ((MODE1) == QImode\t\t\t\t\t\\\n-\t    && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))\t\\\n-        || ((MODE1) == DImode && TARGET_64BIT))\t\t\t\\\n-       && ((MODE2) == HImode || (MODE2) == SImode\t\t\\\n-\t   || ((MODE2) == QImode\t\t\t\t\\\n-\t       && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))\t\\\n-\t   || ((MODE2) == DImode && TARGET_64BIT))))\n+#define MODES_TIEABLE_P(MODE1, MODE2)  ix86_modes_tieable_p (MODE1, MODE2)\n \n /* It is possible to write patterns to move flags; but until someone\n    does it,  */"}]}