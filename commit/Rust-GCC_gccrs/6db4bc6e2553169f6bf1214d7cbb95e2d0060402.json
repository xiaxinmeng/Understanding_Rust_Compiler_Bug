{"sha": "6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRiNGJjNmUyNTUzMTY5ZjZiZjEyMTRkN2NiYjk1ZTJkMDA2MDQwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-12-19T20:27:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-12-19T20:27:53Z"}, "message": "hash-table.h (struct pointer_hash): Fix formating.\n\n\n\t* hash-table.h (struct pointer_hash): Fix formating.\n\t(hash_table_higher_prime_index): Declare pure.\n\t(hash_table_mod2, hash_table_mod1, mul_mod): Move inline;\n\tassume that uint64_t always exists.\n\t(hash_table<Descriptor, Allocator, false>): Use gcc_checking_assert.\n\t(hash_table<Descriptor, Allocator, false>::expand ()): Fix formating.\n\t(hash_table<Descriptor, Allocator, false>::clear_slot (value_type **slot)):\n\tUse checking assert.\n\t* hash-table.c: Remove #if 0 code.\n\t(hash_table_higher_prime_index): Use gcc_assert.\n\t(mul_mod, hash-table_mod1, hash_table_mod2): move to hash-table.h\n\nFrom-SVN: r218976", "tree": {"sha": "3079c37f4f6dcacc32eabe361d9f90849127fe5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3079c37f4f6dcacc32eabe361d9f90849127fe5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/comments", "author": null, "committer": null, "parents": [{"sha": "58c9330bc1f7d1235de3fa7f4684a75d9c3d9e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c9330bc1f7d1235de3fa7f4684a75d9c3d9e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c9330bc1f7d1235de3fa7f4684a75d9c3d9e0c"}], "stats": {"total": 191, "additions": 79, "deletions": 112}, "files": [{"sha": "9c5841f91c8a8611f0d54b71b3e765c9e23eee23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "patch": "@@ -1,3 +1,17 @@\n+2014-12-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* hash-table.h (struct pointer_hash): Fix formating.\n+\t(hash_table_higher_prime_index): Declare pure.\n+\t(hash_table_mod2, hash_table_mod1, mul_mod): Move inline;\n+\tassume that uint64_t always exists.\n+\t(hash_table<Descriptor, Allocator, false>): Use gcc_checking_assert.\n+\t(hash_table<Descriptor, Allocator, false>::expand ()): Fix formating.\n+\t(hash_table<Descriptor, Allocator, false>::clear_slot (value_type **slot)):\n+\tUse checking assert.\n+\t* hash-table.c: Remove #if 0 code.\n+\t(hash_table_higher_prime_index): Use gcc_assert.\n+\t(mul_mod, hash-table_mod1, hash_table_mod2): move to hash-table.h\n+\n 2014-12-19  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* config.gcc: Support mips*-img-linux* and mips*-img-elf*."}, {"sha": "4c9ef0abf7212a84613ba9f27cf138a713cb0299", "filename": "gcc/hash-table.c", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2Fhash-table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2Fhash-table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.c?ref=6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "patch": "@@ -41,39 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n    For the record, here's the function that computed the table; it's a \n    vastly simplified version of the function of the same name from gcc.  */\n \n-#if 0\n-unsigned int\n-ceil_log2 (unsigned int x)\n-{\n-  int i;\n-  for (i = 31; i >= 0 ; --i)\n-    if (x > (1u << i))\n-      return i+1;\n-  abort ();\n-}\n-\n-unsigned int\n-choose_multiplier (unsigned int d, unsigned int *mlp, unsigned char *shiftp)\n-{\n-  unsigned long long mhigh;\n-  double nx;\n-  int lgup, post_shift;\n-  int pow, pow2;\n-  int n = 32, precision = 32;\n-\n-  lgup = ceil_log2 (d);\n-  pow = n + lgup;\n-  pow2 = n + lgup - precision;\n-\n-  nx = ldexp (1.0, pow) + ldexp (1.0, pow2);\n-  mhigh = nx / d;\n-\n-  *shiftp = lgup - 1;\n-  *mlp = mhigh;\n-  return mhigh >> 32;\n-}\n-#endif\n-\n struct prime_ent const prime_tab[] = {\n   {          7, 0x24924925, 0x9999999b, 2 },\n   {         13, 0x3b13b13c, 0x745d1747, 3 },\n@@ -127,67 +94,8 @@ hash_table_higher_prime_index (unsigned long n)\n     }\n \n   /* If we've run out of primes, abort.  */\n-  if (n > prime_tab[low].prime)\n-    {\n-      fprintf (stderr, \"Cannot find prime bigger than %lu\\n\", n);\n-      abort ();\n-    }\n+  gcc_assert (n <= prime_tab[low].prime);\n \n   return low;\n }\n \n-/* Return X % Y using multiplicative inverse values INV and SHIFT.\n-\n-   The multiplicative inverses computed above are for 32-bit types,\n-   and requires that we be able to compute a highpart multiply.\n-\n-   FIX: I am not at all convinced that\n-     3 loads, 2 multiplications, 3 shifts, and 3 additions\n-   will be faster than\n-     1 load and 1 modulus\n-   on modern systems running a compiler.  */\n-\n-#ifdef UNSIGNED_64BIT_TYPE\n-static inline hashval_t\n-mul_mod (hashval_t x, hashval_t y, hashval_t inv, int shift)\n-{\n-  __extension__ typedef UNSIGNED_64BIT_TYPE ull;\n-   hashval_t t1, t2, t3, t4, q, r;\n-\n-   t1 = ((ull)x * inv) >> 32;\n-   t2 = x - t1;\n-   t3 = t2 >> 1;\n-   t4 = t1 + t3;\n-   q  = t4 >> shift;\n-   r  = x - (q * y);\n-\n-   return r;\n-}\n-#endif\n-\n-/* Compute the primary table index for HASH given current prime index.  */\n-\n-hashval_t\n-hash_table_mod1 (hashval_t hash, unsigned int index)\n-{\n-  const struct prime_ent *p = &prime_tab[index];\n-#ifdef UNSIGNED_64BIT_TYPE\n-  if (sizeof (hashval_t) * CHAR_BIT <= 32)\n-    return mul_mod (hash, p->prime, p->inv, p->shift);\n-#endif\n-  return hash % p->prime;\n-}\n-\n-\n-/* Compute the secondary table index for HASH given current prime index.  */\n-\n-hashval_t\n-hash_table_mod2 (hashval_t hash, unsigned int index)\n-{\n-  const struct prime_ent *p = &prime_tab[index];\n-#ifdef UNSIGNED_64BIT_TYPE\n-  if (sizeof (hashval_t) * CHAR_BIT <= 32)\n-    return 1 + mul_mod (hash, p->prime - 2, p->inv_m2, p->shift);\n-#endif\n-  return 1 + hash % (p->prime - 2);\n-}"}, {"sha": "bfbe36db7e561dcba84edd0709494d3bf685f8a0", "filename": "gcc/hash-table.h", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db4bc6e2553169f6bf1214d7cbb95e2d0060402/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=6db4bc6e2553169f6bf1214d7cbb95e2d0060402", "patch": "@@ -282,7 +282,8 @@ struct pointer_hash : typed_noop_remove <Type>\n \n   static inline hashval_t hash (const value_type &);\n \n-  static inline bool equal (const value_type &existing, const compare_type &candidate);\n+  static inline bool equal (const value_type &existing,\n+\t\t\t    const compare_type &candidate);\n };\n \n template <typename Type>\n@@ -388,9 +389,54 @@ extern struct prime_ent const prime_tab[];\n \n /* Functions for computing hash table indexes.  */\n \n-extern unsigned int hash_table_higher_prime_index (unsigned long n);\n-extern hashval_t hash_table_mod1 (hashval_t hash, unsigned int index);\n-extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n+extern unsigned int hash_table_higher_prime_index (unsigned long n)\n+   ATTRIBUTE_PURE;\n+\n+/* Return X % Y using multiplicative inverse values INV and SHIFT.\n+\n+   The multiplicative inverses computed above are for 32-bit types,\n+   and requires that we be able to compute a highpart multiply.\n+\n+   FIX: I am not at all convinced that\n+     3 loads, 2 multiplications, 3 shifts, and 3 additions\n+   will be faster than\n+     1 load and 1 modulus\n+   on modern systems running a compiler.  */\n+\n+inline hashval_t\n+mul_mod (hashval_t x, hashval_t y, hashval_t inv, int shift)\n+{\n+   hashval_t t1, t2, t3, t4, q, r;\n+\n+   t1 = ((uint64_t)x * inv) >> 32;\n+   t2 = x - t1;\n+   t3 = t2 >> 1;\n+   t4 = t1 + t3;\n+   q  = t4 >> shift;\n+   r  = x - (q * y);\n+\n+   return r;\n+}\n+\n+/* Compute the primary table index for HASH given current prime index.  */\n+\n+inline hashval_t\n+hash_table_mod1 (hashval_t hash, unsigned int index)\n+{\n+  const struct prime_ent *p = &prime_tab[index];\n+  gcc_checking_assert (sizeof (hashval_t) * CHAR_BIT <= 32);\n+    return mul_mod (hash, p->prime, p->inv, p->shift);\n+}\n+\n+/* Compute the secondary table index for HASH given current prime index.  */\n+\n+inline hashval_t\n+hash_table_mod2 (hashval_t hash, unsigned int index)\n+{\n+  const struct prime_ent *p = &prime_tab[index];\n+  gcc_checking_assert (sizeof (hashval_t) * CHAR_BIT <= 32);\n+  return 1 + mul_mod (hash, p->prime - 2, p->inv_m2, p->shift);\n+}\n \n /* The below is some template meta programming to decide if we should use the\n    hash table partial specialization that directly stores value_type instead of\n@@ -748,8 +794,7 @@ ::find_empty_slot_for_expand (hashval_t hash)\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n     return slot;\n-  else if (*slot == HTAB_DELETED_ENTRY)\n-    abort ();\n+  gcc_checking_assert (*slot != HTAB_DELETED_ENTRY);\n \n   hash2 = hash_table_mod2 (hash, m_size_prime_index);\n   for (;;)\n@@ -761,8 +806,7 @@ ::find_empty_slot_for_expand (hashval_t hash)\n       slot = m_entries + index;\n       if (*slot == HTAB_EMPTY_ENTRY)\n         return slot;\n-      else if (*slot == HTAB_DELETED_ENTRY)\n-        abort ();\n+      gcc_checking_assert (*slot != HTAB_DELETED_ENTRY);\n     }\n }\n \n@@ -773,7 +817,7 @@ ::find_empty_slot_for_expand (hashval_t hash)\n    table entries is changed.  If memory allocation fails, this function\n    will abort.  */\n \n-\t  template<typename Descriptor, template<typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n void\n hash_table<Descriptor, Allocator, false>::expand ()\n {\n@@ -862,9 +906,9 @@ template<typename Descriptor, template<typename Type> class Allocator>\n void\n hash_table<Descriptor, Allocator, false>::clear_slot (value_type **slot)\n {\n-  if (slot < m_entries || slot >= m_entries + size ()\n-      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n-    abort ();\n+  gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n+\t\t         || *slot == HTAB_EMPTY_ENTRY\n+\t\t\t || *slot == HTAB_DELETED_ENTRY));\n \n   Descriptor::remove (*slot);\n \n@@ -1317,8 +1361,9 @@ ::find_empty_slot_for_expand (hashval_t hash)\n \n   if (is_empty (*slot))\n     return slot;\n-  else if (is_deleted (*slot))\n-    abort ();\n+#ifdef ENABLE_CHECKING\n+  gcc_checking_assert (!is_deleted (*slot));\n+#endif\n \n   hash2 = hash_table_mod2 (hash, m_size_prime_index);\n   for (;;)\n@@ -1330,8 +1375,9 @@ ::find_empty_slot_for_expand (hashval_t hash)\n       slot = m_entries + index;\n       if (is_empty (*slot))\n         return slot;\n-      else if (is_deleted (*slot))\n-        abort ();\n+#ifdef ENABLE_CHECKING\n+      gcc_checking_assert (!is_deleted (*slot));\n+#endif\n     }\n }\n \n@@ -1437,9 +1483,8 @@ template<typename Descriptor, template<typename Type> class Allocator>\n void\n hash_table<Descriptor, Allocator, true>::clear_slot (value_type *slot)\n {\n-  if (slot < m_entries || slot >= m_entries + size ()\n-      || is_empty (*slot) || is_deleted (*slot))\n-    abort ();\n+  gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n+\t\t         || is_empty (*slot) || is_deleted (*slot)));\n \n   Descriptor::remove (*slot);\n "}]}