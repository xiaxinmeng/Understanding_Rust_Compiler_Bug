{"sha": "af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY3MjI2N2M3MjAxYWM3YjBjM2U0YTkwNzIxYmZjOWJhYzBlNDc4Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-25T20:47:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-25T20:47:45Z"}, "message": "gimplify.c (lookup_tmp_var): Set TREE_READONLY in is_formal case.\n\n\t* gimplify.c (lookup_tmp_var): Set TREE_READONLY in is_formal case.\n\t(build_addr_expr_with_type): Deleted.\n\t(build_addr_expr): Deleted; callers changed to build_fold_addr_expr.\n\t(gimplify_compound_lval): Make two passes over reference nest.\n\nFrom-SVN: r83678", "tree": {"sha": "ddf770748d0fb31735a7ad5f582dcef973bebf9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddf770748d0fb31735a7ad5f582dcef973bebf9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af72267c7201ac7b0c3e4a90721bfc9bac0e4787/comments", "author": null, "committer": null, "parents": [{"sha": "8f44bc38a5532e8d1ac357bf56aaef1fbd1899d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f44bc38a5532e8d1ac357bf56aaef1fbd1899d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f44bc38a5532e8d1ac357bf56aaef1fbd1899d3"}], "stats": {"total": 163, "additions": 73, "deletions": 90}, "files": [{"sha": "8062d5328ac5820480a85735628912a44e904fc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af72267c7201ac7b0c3e4a90721bfc9bac0e4787/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af72267c7201ac7b0c3e4a90721bfc9bac0e4787/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "patch": "@@ -1,5 +1,10 @@\n 2004-06-25  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* gimplify.c (lookup_tmp_var): Set TREE_READONLY in is_formal case.\n+\t(build_addr_expr_with_type): Deleted.\n+\t(build_addr_expr): Deleted; callers changed to build_fold_addr_expr.\n+\t(gimplify_compound_lval): Make two passes over reference nest.\n+\n \t* tree-nested.c (build_addr): Merge real/imagpart with\n \thandled_component_p.\n \t(convert_nonlocal_reference, convert_local_reference): Process extra"}, {"sha": "38bd2d7084438ab06a96cbfa78c105338226237a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 68, "deletions": 90, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af72267c7201ac7b0c3e4a90721bfc9bac0e4787/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af72267c7201ac7b0c3e4a90721bfc9bac0e4787/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=af72267c7201ac7b0c3e4a90721bfc9bac0e4787", "patch": "@@ -418,7 +418,8 @@ lookup_tmp_var (tree val, bool is_formal)\n \t  elt_p = xmalloc (sizeof (*elt_p));\n \t  elt_p->val = val;\n \t  elt_p->temp = create_tmp_from_val (val);\n-\t  *slot = (void *)elt_p;\n+\t  TREE_READONLY (elt_p->temp) = 1;\n+\t  *slot = (void *) elt_p;\n \t}\n       else\n \telt_p = (elt_t *) *slot;\n@@ -1749,44 +1750,6 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n   return GS_OK;\n }\n \n-/*  Build an expression for the address of T.  Folds away INDIRECT_REF to\n-    avoid confusing the gimplify process.  */\n-\n-static tree\n-build_addr_expr_with_type (tree t, tree ptrtype)\n-{\n-  if (TREE_CODE (t) == INDIRECT_REF)\n-    {\n-      t = TREE_OPERAND (t, 0);\n-      if (TREE_TYPE (t) != ptrtype)\n-\tt = build1 (NOP_EXPR, ptrtype, t);\n-    }\n-  else\n-    {\n-      tree base = t;\n-\n-      if (TREE_CODE (base) == REALPART_EXPR\n-\t  || TREE_CODE (base) == IMAGPART_EXPR)\n-\tbase = TREE_OPERAND (base, 0);\n-      else\n-\twhile (handled_component_p (base))\n-\t  base = TREE_OPERAND (base, 0);\n-\n-      if (DECL_P (base))\n-\tTREE_ADDRESSABLE (base) = 1;\n-\n-      t = build1 (ADDR_EXPR, ptrtype, t);\n-    }\n-\n-  return t;\n-}\n-\n-static tree\n-build_addr_expr (tree t)\n-{\n-  return build_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n-}\n-\n /* Gimplify the COMPONENT_REF, ARRAY_REF, REALPART_EXPR or IMAGPART_EXPR\n    node pointed by EXPR_P.\n \n@@ -1816,6 +1779,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   tree *p;\n   varray_type stack;\n   enum gimplify_status ret = GS_OK, tret;\n+  int i;\n \n #if defined ENABLE_CHECKING\n   if (TREE_CODE (*expr_p) != ARRAY_REF\n@@ -1831,43 +1795,32 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n      order from inner to outer.  */\n   VARRAY_TREE_INIT (stack, 10, \"stack\");\n \n-  /* We can either handle one REALPART_EXPR or IMAGEPART_EXPR or\n-     nest of handled components.  */\n-  if (TREE_CODE (*expr_p) == REALPART_EXPR\n-      || TREE_CODE (*expr_p) == IMAGPART_EXPR)\n-    p = &TREE_OPERAND (*expr_p, 0);\n-  else\n-    for (p = expr_p; handled_component_p (*p); p = &TREE_OPERAND (*p, 0))\n-      VARRAY_PUSH_TREE (stack, *p);\n+  /* We can either handle REALPART_EXPR, IMAGEPART_EXPR anything that\n+     handled_components can deal with.  */\n+  for (p = expr_p;\n+       (handled_component_p (*p)\n+\t|| TREE_CODE (*p) == REALPART_EXPR || TREE_CODE (*p) == IMAGPART_EXPR);\n+       p = &TREE_OPERAND (*p, 0))\n+    VARRAY_PUSH_TREE (stack, *p);\n \n   /* Now STACK is a stack of pointers to all the refs we've walked through\n      and P points to the innermost expression.\n \n-     Process each of the outer nodes from left to right, then gimplify the\n-     base.  We need to do it in this order so that PLACEHOLDER_EXPRs\n-     can be resolved.  */\n-  for (; VARRAY_ACTIVE_SIZE (stack) > 0; )\n+     Java requires that we elaborated nodes in source order.  That\n+     means we must gimplify the inner expression followed by each of\n+     the indices, in order.  But we can't gimplify the inner\n+     expression until we deal with any variable bounds, sizes, or\n+     positions in order to deal with PLACEHOLDER_EXPRs.\n+\n+     So we do this in three steps.  First we deal with the annotations\n+     for any variables in the components, then we gimplify the base,\n+     then we gimplify any indices, from left to right.  */\n+  for (i = VARRAY_ACTIVE_SIZE (stack) - 1; i >= 0; i--)\n     {\n-      tree t = VARRAY_TOP_TREE (stack);\n+      tree t = VARRAY_TREE (stack, i);\n \n       if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n-\t  /* Gimplify the dimension.\n-\t     Temporary fix for gcc.c-torture/execute/20040313-1.c.\n-\t     Gimplify non-constant array indices into a temporary\n-\t     variable.\n-\t     FIXME - The real fix is to gimplify post-modify\n-\t     expressions into a minimal gimple lvalue.  However, that\n-\t     exposes bugs in alias analysis.  The alias analyzer does\n-\t     not handle &PTR->FIELD very well.  Will fix after the\n-\t     branch is merged into mainline (dnovillo 2004-05-03).  */\n-\t  if (!is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n-\t    {\n-\t      tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n-\t\t\t\t    is_gimple_tmp_var, fb_rvalue);\n-\t      ret = MIN (ret, tret);\n-\t    }\n-\n \t  /* Gimplify the low bound and element type size and put them into\n \t     the ARRAY_REF.  If these values are set, they have already been\n \t     gimplified.  */\n@@ -1924,6 +1877,36 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t}\n \t    }\n \t}\n+    }\n+\n+  /* Step 2 is to gimplify the base expression.  */\n+  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n+\t\t\twant_lvalue ? fb_lvalue : fb_rvalue);\n+  ret = MIN (ret, tret);\n+\n+  /* And finally, the indices and operands to BIT_FIELD_REF.  */\n+  for (; VARRAY_ACTIVE_SIZE (stack) > 0; )\n+    {\n+      tree t = VARRAY_TOP_TREE (stack);\n+\n+      if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t{\n+\t  /* Gimplify the dimension.\n+\t     Temporary fix for gcc.c-torture/execute/20040313-1.c.\n+\t     Gimplify non-constant array indices into a temporary\n+\t     variable.\n+\t     FIXME - The real fix is to gimplify post-modify\n+\t     expressions into a minimal gimple lvalue.  However, that\n+\t     exposes bugs in alias analysis.  The alias analyzer does\n+\t     not handle &PTR->FIELD very well.  Will fix after the\n+\t     branch is merged into mainline (dnovillo 2004-05-03).  */\n+\t  if (!is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n+\t\t\t\t    is_gimple_tmp_var, fb_rvalue);\n+\t      ret = MIN (ret, tret);\n+\t    }\n+\t}\n       else if (TREE_CODE (t) == BIT_FIELD_REF)\n \t{\n \t  tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n@@ -1934,6 +1917,9 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t  ret = MIN (ret, tret);\n \t}\n \t  \n+      /* The innermost expression P may have originally had TREE_SIDE_EFFECTS\n+\t set which would have caused all the outer expressions in EXPR_P\n+\t leading to P to also have had TREE_SIDE_EFFECTS set.  */\n       recalculate_side_effects (t);\n       VARRAY_POP (stack);\n     }\n@@ -1942,22 +1928,6 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t\twant_lvalue ? fb_lvalue : fb_rvalue);\n   ret = MIN (ret, tret);\n \n-  /* The innermost expression P may have originally had TREE_SIDE_EFFECTS\n-     set which would have caused all the outer expressions in EXPR_P leading\n-     to P to also have had TREE_SIDE_EFFECTS set.\n- \n-     Gimplification of P may have cleared TREE_SIDE_EFFECTS on P, which should\n-     be propagated to P's parents, innermost to outermost.  */\n-  for (p = expr_p; handled_component_p (*p); p = &TREE_OPERAND (*p, 0))\n-    VARRAY_PUSH_TREE (stack, *p);\n-\n-  for (; VARRAY_ACTIVE_SIZE (stack) > 0; )\n-    {\n-      tree t = VARRAY_TOP_TREE (stack);\n-      recalculate_side_effects (t);\n-      VARRAY_POP (stack);\n-    }\n-\n   /* If the outermost expression is a COMPONENT_REF, canonicalize its type.  */\n   if (!want_lvalue && TREE_CODE (*expr_p) == COMPONENT_REF)\n     {\n@@ -2754,9 +2724,9 @@ gimplify_variable_sized_compare (tree *expr_p)\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);\n   t = unshare_expr (t);\n   args = tree_cons (NULL, t, NULL);\n-  t = build_addr_expr (op1);\n+  t = build_fold_addr_expr (op1);\n   args = tree_cons (NULL, t, args);\n-  dest = build_addr_expr (op0);\n+  dest = build_fold_addr_expr (op0);\n   args = tree_cons (NULL, dest, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n   t = build_function_call_expr (t, args);\n@@ -2944,9 +2914,12 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n     case VIEW_CONVERT_EXPR:\n       /* Take the address of our operand and then convert it to the type of\n-\t this ADDR_EXPR.  */\n+\t this ADDR_EXPR.\n+\n+\t ??? The interactions of VIEW_CONVERT_EXPR and aliasing is not at\n+\t all clear.  The impact of this transformation is even less clear.  */\n       *expr_p = fold_convert (TREE_TYPE (expr),\n-\t\t\t      build_addr_expr (TREE_OPERAND (op0, 0)));\n+\t\t\t      build_fold_addr_expr (TREE_OPERAND (op0, 0)));\n       ret = GS_OK;\n       break;\n \n@@ -3473,7 +3446,12 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \t  /* If both types are BLKmode or if one type is of variable size,\n \t     convert this into a pointer punning operation.  This avoids\n-\t     copies of large data or making a variable-size temporary.  */\n+\t     copies of large data or making a variable-size temporary.\n+\n+\t     ??? The interactions of VIEW_CONVERT_EXPR and aliasing is not at\n+\t     all clear.  The impact of this transformation is even less\n+\t     clear.  */\n+\n \t  if ((TYPE_MODE (TREE_TYPE (*expr_p)) == BLKmode\n \t       && TYPE_MODE (TREE_TYPE (TREE_OPERAND (*expr_p, 0))) == BLKmode)\n \t      || !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (*expr_p)))\n@@ -3483,7 +3461,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t      tree restype = TREE_TYPE (*expr_p);\n \t      *expr_p = build1 (INDIRECT_REF, TREE_TYPE (*expr_p),\n \t\t\t\tfold_convert (build_pointer_type (restype),\n-\t\t\t\t\t      build_addr_expr\n+\t\t\t\t\t      build_fold_addr_expr\n \t\t\t\t\t      (TREE_OPERAND (*expr_p, 0))));\n \t      break;\n \t    }"}]}