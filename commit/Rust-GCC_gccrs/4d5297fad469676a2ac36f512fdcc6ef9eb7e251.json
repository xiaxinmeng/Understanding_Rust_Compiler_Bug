{"sha": "4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1Mjk3ZmFkNDY5Njc2YTJhYzM2ZjUxMmZkY2M2ZWY5ZWI3ZTI1MQ==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2003-12-18T11:50:58Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2003-12-18T11:50:58Z"}, "message": "re PR c++/9154 (poor error message for \">>\" vs. \"> >\" for nested template args)\n\n\tPR c++/9154\n\t* parser.c (cp_parser_template_argument): A type-id followed by '>>'\n\tis just an user typo, and should be accepted as last resort if any\n\tother parsing fails.\n\t(cp_parser_enclosed_template_argument_list): If the argument list is\n\tparsed correctly, but the next token is '>>', emit a diagnostic.\n\t(cp_parser_next_token_ends_template_argument): Accept '>>' as\n\tdelimiter of template argument, it will be later detected as a typo.\n\nFrom-SVN: r74776", "tree": {"sha": "903a3d5514be16a67cf897721d58405cffb064fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/903a3d5514be16a67cf897721d58405cffb064fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5297fad469676a2ac36f512fdcc6ef9eb7e251/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a21f130e82ebee7ccdee1e89d45fbb1969555a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21f130e82ebee7ccdee1e89d45fbb1969555a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21f130e82ebee7ccdee1e89d45fbb1969555a81"}], "stats": {"total": 105, "additions": 90, "deletions": 15}, "files": [{"sha": "8d9d9a34e6b533c8cc8fc63a84ceeb183da99ba3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5297fad469676a2ac36f512fdcc6ef9eb7e251/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5297fad469676a2ac36f512fdcc6ef9eb7e251/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "patch": "@@ -1,3 +1,14 @@\n+2003-12-18  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/9154\n+\t* parser.c (cp_parser_template_argument): A type-id followed by '>>'\n+\tis just an user typo, and should be accepted as last resort if any\n+\tother parsing fails.\n+\t(cp_parser_enclosed_template_argument_list): If the argument list is\n+\tparsed correctly, but the next token is '>>', emit a diagnostic.\n+\t(cp_parser_next_token_ends_template_argument): Accept '>>' as \n+\tdelimiter of template argument, it will be later detected as a typo.\n+\n 2003-12-17  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Make-lang.in: Replace cp/g++.1 with $(docobjdir)/g++.1.\n@@ -44,7 +55,7 @@\n 2003-12-16  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/2294\n-\t* name-lookup.c (push_overloaded_decl): always construct an OVERLOAD\r\n+\t* name-lookup.c (push_overloaded_decl): always construct an OVERLOAD\n \tif the declaration comes from an using declaration.\n \n 2003-12-16  Giovanni Bajo  <giovannibajo@gcc.gnu.org>"}, {"sha": "81ad259c697f4c91adea26681ec24d63216715e1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 78, "deletions": 14, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5297fad469676a2ac36f512fdcc6ef9eb7e251/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5297fad469676a2ac36f512fdcc6ef9eb7e251/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4d5297fad469676a2ac36f512fdcc6ef9eb7e251", "patch": "@@ -8101,6 +8101,7 @@ cp_parser_template_argument (cp_parser* parser)\n   tree argument;\n   bool template_p;\n   bool address_p;\n+  bool maybe_type_id = false;\n   cp_token *token;\n   cp_id_kind idk;\n   tree qualifying_class;\n@@ -8117,13 +8118,35 @@ cp_parser_template_argument (cp_parser* parser)\n      Therefore, we try a type-id first.  */\n   cp_parser_parse_tentatively (parser);\n   argument = cp_parser_type_id (parser);\n-  /* If the next token isn't a `,' or a `>', then this argument wasn't\n-     really finished.  */\n-  if (!cp_parser_next_token_ends_template_argument_p (parser))\n-    cp_parser_error (parser, \"expected template-argument\");\n-  /* If that worked, we're done.  */\n-  if (cp_parser_parse_definitely (parser))\n-    return argument;\n+  /* If there was no error parsing the type-id but the next token is a '>>',\n+     we probably found a typo for '> >'. But there are type-id which are \n+     also valid expressions. For instance:\n+\n+     struct X { int operator >> (int); };\n+     template <int V> struct Foo {};\n+     Foo<X () >> 5> r;\n+\n+     Here 'X()' is a valid type-id of a function type, but the user just\n+     wanted to write the expression \"X() >> 5\". Thus, we remember that we\n+     found a valid type-id, but we still try to parse the argument as an\n+     expression to see what happens.  */\n+  if (!cp_parser_error_occurred (parser)\n+      && cp_lexer_next_token_is (parser->lexer, CPP_RSHIFT))\n+    {\n+      maybe_type_id = true;\n+      cp_parser_abort_tentative_parse (parser);\n+    }\n+  else\n+    {\n+      /* If the next token isn't a `,' or a `>', then this argument wasn't\n+      really finished. This means that the argument is not a valid\n+      type-id.  */\n+      if (!cp_parser_next_token_ends_template_argument_p (parser))\n+\tcp_parser_error (parser, \"expected template-argument\");\n+      /* If that worked, we're done.  */\n+      if (cp_parser_parse_definitely (parser))\n+\treturn argument;\n+    }\n   /* We're still not sure what the argument will be.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try a template.  */\n@@ -8238,12 +8261,27 @@ cp_parser_template_argument (cp_parser* parser)\n       cp_parser_error (parser, \"invalid non-type template argument\");\n       return error_mark_node;\n     }\n-  /* The argument must be a constant-expression.  */\n+  /* If the argument wasn't successfully parsed as a type-id followed\n+     by '>>', the argument can only be a constant expression now.  \n+     Otherwise, we try parsing the constant-expression tentatively,\n+     because the argument could really be a type-id.  */\n+  if (maybe_type_id)\n+    cp_parser_parse_tentatively (parser);\n   argument = cp_parser_constant_expression (parser, \n \t\t\t\t\t    /*allow_non_constant_p=*/false,\n \t\t\t\t\t    /*non_constant_p=*/NULL);\n-  /* If it's non-dependent, simplify it.  */\n-  return cp_parser_fold_non_dependent_expr (argument);\n+  argument = cp_parser_fold_non_dependent_expr (argument);\n+  if (!maybe_type_id)\n+    return argument;\n+  if (!cp_parser_next_token_ends_template_argument_p (parser))\n+    cp_parser_error (parser, \"expected template-argument\");\n+  if (cp_parser_parse_definitely (parser))\n+    return argument;\n+  /* We did our best to parse the argument as a non type-id, but that\n+     was the only alternative that matched (albeit with a '>' after\n+     it). We can assume it's just a typo from the user, and a \n+     diagnostic will then be issued.  */\n+  return cp_parser_type_id (parser);\n }\n \n /* Parse an explicit-instantiation.\n@@ -14177,8 +14215,31 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n     arguments = NULL_TREE;\n   else\n     arguments = cp_parser_template_argument_list (parser);\n-  /* Look for the `>' that ends the template-argument-list.  */\n-  cp_parser_require (parser, CPP_GREATER, \"`>'\");\n+  /* Look for the `>' that ends the template-argument-list. If we find\n+     a '>>' instead, it's probably just a typo.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_RSHIFT))\n+    {\n+      if (!saved_greater_than_is_operator_p)\n+\t{\n+\t  /* If we're in a nested template argument list, the '>>' has to be\n+\t    a typo for '> >'. We emit the error message, but we continue\n+\t    parsing and we push a '>' as next token, so that the argument\n+\t    list will be parsed correctly..  */\n+\t  cp_token* token;\n+\t  error (\"`>>' should be `> >' within a nested template argument list\");\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  token->type = CPP_GREATER;\n+\t}\n+      else\n+\t{\n+\t  /* If this is not a nested template argument list, the '>>' is\n+\t    a typo for '>'. Emit an error message and continue.  */\n+\t  error (\"spurious `>>', use `>' to terminate a template argument list\");\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+    }\n+  else\n+    cp_parser_require (parser, CPP_GREATER, \"`>'\");\n   /* The `>' token might be a greater-than operator again now.  */\n   parser->greater_than_is_operator_p \n     = saved_greater_than_is_operator_p;\n@@ -14618,15 +14679,18 @@ cp_parser_next_token_starts_class_definition_p (cp_parser *parser)\n }\n \n /* Returns TRUE iff the next token is the \",\" or \">\" ending a\n-   template-argument.  */\n+   template-argument. \">>\" is also accepted (after the full\n+   argument was parsed) because it's probably a typo for \"> >\",\n+   and there is a specific diagnostic for this.  */\n \n static bool\n cp_parser_next_token_ends_template_argument_p (cp_parser *parser)\n {\n   cp_token *token;\n \n   token = cp_lexer_peek_token (parser->lexer);\n-  return (token->type == CPP_COMMA || token->type == CPP_GREATER);\n+  return (token->type == CPP_COMMA || token->type == CPP_GREATER \n+\t  || token->type == CPP_RSHIFT);\n }\n  \n /* Returns the kind of tag indicated by TOKEN, if it is a class-key,"}]}