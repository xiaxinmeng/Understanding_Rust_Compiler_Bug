{"sha": "88228c4b75737ccd236ef68919d5596ca14badb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgyMjhjNGI3NTczN2NjZDIzNmVmNjg5MTlkNTU5NmNhMTRiYWRiOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-01-25T15:48:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-01-25T15:48:40Z"}, "message": "more small data support\n\nFrom-SVN: r11101", "tree": {"sha": "47f101117eaaa02f3151a29315a72fb84f2ae387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f101117eaaa02f3151a29315a72fb84f2ae387"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88228c4b75737ccd236ef68919d5596ca14badb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88228c4b75737ccd236ef68919d5596ca14badb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88228c4b75737ccd236ef68919d5596ca14badb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88228c4b75737ccd236ef68919d5596ca14badb8/comments", "author": null, "committer": null, "parents": [{"sha": "6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91"}], "stats": {"total": 108, "additions": 81, "deletions": 27}, "files": [{"sha": "24cbc8123c4f8b4a8291371ffca735145e112093", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=88228c4b75737ccd236ef68919d5596ca14badb8", "patch": "@@ -836,6 +836,13 @@ input_operand (op, mode)\n       && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF))\n     return 1;\n \n+  /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n+     to be valid.  */\n+  if (DEFAULT_ABI == ABI_V4\n+      && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST)\n+      && small_data_operand (op, Pmode))\n+    return 1;\n+\n   /* Otherwise, we will be doing this SET with an add, so anything valid\n      for an add will be valid.  */\n   return add_operand (op, mode);\n@@ -853,11 +860,19 @@ small_data_operand (op, mode)\n   if (DEFAULT_ABI != ABI_V4)\n     return 0;\n \n-  if (GET_CODE (op) != SYMBOL_REF && GET_CODE (op) != CONST)\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    sym_ref = op;\n+\n+  else if (GET_CODE (op) != CONST\n+\t   || GET_CODE (XEXP (op, 0)) != PLUS\n+\t   || GET_CODE (XEXP (XEXP (op, 0), 0)) != SYMBOL_REF\n+\t   || GET_CODE (XEXP (XEXP (op, 0), 1)) != CONST_INT)\n     return 0;\n \n-  sym_ref = eliminate_constant_term (op, &const_part);\n-  if (!sym_ref || GET_CODE (sym_ref) != SYMBOL_REF || *XSTR (sym_ref, 0) != '@')\n+  else\n+    sym_ref = XEXP (XEXP (op, 0), 0);\n+\n+  if (*XSTR (sym_ref, 0) != '@')\n     return 0;\n \n   return 1;\n@@ -2071,9 +2086,9 @@ print_operand (file, x, code)\n \t     we have already done it, we can just use an offset of four.  */\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t    print_operand_address (file, plus_constant (XEXP (XEXP (x, 0), 0), 4));\n \t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t    print_operand_address (file, plus_constant (XEXP (x, 0), 4));\n \t}\n       return;\n \t\t\t    \n@@ -2281,9 +2296,9 @@ print_operand (file, x, code)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t    print_operand_address (file, plus_constant (XEXP (XEXP (x, 0), 0), 8));\n \t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 8));\n+\t    print_operand_address (file, plus_constant (XEXP (x, 0), 8));\n \t}\n       return;\n \t\t\t    \n@@ -2327,9 +2342,9 @@ print_operand (file, x, code)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t    print_operand_address (file, plus_constant (XEXP (XEXP (x, 0), 0), 12));\n \t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 12));\n+\t    print_operand_address (file, plus_constant (XEXP (x, 0), 12));\n \t}\n       return;\n \t\t\t    \n@@ -2347,10 +2362,10 @@ print_operand (file, x, code)\n \t    fprintf (file, \"%d(%d)\", - GET_MODE_SIZE (GET_MODE (x)),\n \t\t     REGNO (XEXP (XEXP (x, 0), 0)));\n \t  else\n-\t    output_address (XEXP (x, 0));\n+\t    print_operand_address (file, XEXP (x, 0));\n \t}\n       else\n-\toutput_addr_const (file, x);\n+\tprint_operand_address (file, x);\n       return;\n \n     default:\n@@ -4152,8 +4167,6 @@ rs6000_select_rtx_section (mode, x)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x))\n     toc_section ();\n-  else if (TARGET_SDATA && GET_MODE_SIZE (mode) > 0 && GET_MODE_SIZE (mode) <= 8)\n-    sdata2_section ();\n   else\n     const_section ();\n }\n@@ -4172,12 +4185,8 @@ rs6000_select_section (decl, reloc)\n \n   if (TREE_CODE (decl) == STRING_CST)\n     {\n-      if ((! flag_writable_strings) && TARGET_SDATA && (size <= 8))\n-\tsdata2_section ();\n-      else if (! flag_writable_strings)\n+      if (! flag_writable_strings)\n \tconst_section ();\n-      else if (TARGET_SDATA && (size <= 8))\n-\tsdata_section ();\n       else\n \tdata_section ();\n     }\n@@ -4190,14 +4199,14 @@ rs6000_select_section (decl, reloc)\n \t  || (DECL_INITIAL (decl) != error_mark_node\n \t      && !TREE_CONSTANT (DECL_INITIAL (decl))))\n \t{\n-\t  if (TARGET_SDATA && (size <= 8) && (size > 0))\n+\t  if (TARGET_SDATA && (size > 0) && (size <= g_switch_value))\n \t    sdata_section ();\n \t  else\n \t    data_section ();\n \t}\n       else\n \t{\n-\t  if (TARGET_SDATA && (size <= 8) && (size > 0))\n+\t  if (TARGET_SDATA && (size > 0) && (size <= g_switch_value))\n \t    sdata2_section ();\n \t  else\n \t    const_section ();"}, {"sha": "6a5264bbceaa03e58f22908d9592a43b5469c628", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=88228c4b75737ccd236ef68919d5596ca14badb8", "patch": "@@ -1005,13 +1005,15 @@ enum reg_class\n    'Q' means that is a memory operand that is just an offset from a reg.\n    'R' is for AIX TOC entries.\n    'S' is for Windows NT SYMBOL_REFs\n-   'T' is for Windows NT LABEL_REFs.  */\n+   'T' is for Windows NT LABEL_REFs.\n+   'U' is for V.4 small data references.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n    : (C) == 'R' ? LEGITIMATE_CONSTANT_POOL_ADDRESS_P (OP)\t\t\\\n    : (C) == 'S' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == SYMBOL_REF)\\\n    : (C) == 'T' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == LABEL_REF) \\\n+   : (C) == 'U' ? (DEFAULT_ABI == ABI_V4 && small_data_operand (OP, GET_MODE (OP))) \\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -1687,7 +1689,9 @@ typedef struct rs6000_args\n        && LEGITIMATE_CONSTANT_POOL_BASE_P (XEXP (XEXP (X, 0), 0))))\n \n #define LEGITIMATE_SMALL_DATA_P(MODE, X)\t\t\t\t\\\n-  (DEFAULT_ABI == ABI_V4 && small_data_operand (X, MODE))\n+  (DEFAULT_ABI == ABI_V4\t\t\t\t\t\t\\\n+   && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST)\t\t\\\n+   && small_data_operand (X, MODE))\n \n #define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\"}, {"sha": "12d9a8518fb57d5a4cca2f50271c7fe4439ecf6c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=88228c4b75737ccd236ef68919d5596ca14badb8", "patch": "@@ -4731,6 +4731,16 @@\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \n+  /* Use default pattern for address of ELF small data */\n+  if (TARGET_ELF\n+      && TARGET_SDATA\n+      && (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+      && !small_data_operand (operands[1], SImode))\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+      DONE;\n+    }\n+\n   if (TARGET_ELF && TARGET_NO_TOC && !TARGET_64BIT\n       && CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != HIGH\n@@ -4826,14 +4836,15 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,S,T,m,r,I,J,n,R,*h,r,r,0\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,S,T,U,m,r,I,J,n,R,*h,r,r,0\"))]\n   \"gpc_reg_operand (operands[0], SImode)\n    || gpc_reg_operand (operands[1], SImode)\"\n   \"@\n    mr %0,%1\n    {l|lwz} %0,[toc]%1(2)\n    {l|lwz} %0,[toc]%l1(2)\n+   {cal|la} %0,%1\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n@@ -4844,8 +4855,8 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,load,load,*,*,*,*,*,*,*,mtjmpr,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,8,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,load,load,*,load,*,*,*,*,*,*,*,mtjmpr,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,8,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence."}, {"sha": "36d61eb05b69af8e2b571d0f7a83de7fb54022d5", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88228c4b75737ccd236ef68919d5596ca14badb8/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=88228c4b75737ccd236ef68919d5596ca14badb8", "patch": "@@ -99,6 +99,15 @@ Boston, MA 02111-1307, USA.  */\n   { \"mvme\",\t\t 0 },\t\t\t\t\t\t\\\n   { \"emb\",\t\t 0 },\t\t\t\t\t\t\\\n \n+/* Max # of bytes for variables to automatically be put into the .sdata\n+   or .sdata2 sections.  */\n+extern int g_switch_value;\t\t/* value of the -G xx switch */\n+extern int g_switch_set;\t\t/* whether -G xx was passed.  */\n+\n+#ifndef SDATA_DEFAULT_SIZE\n+#define SDATA_DEFAULT_SIZE 8\n+#endif\n+\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n@@ -110,11 +119,19 @@ Boston, MA 02111-1307, USA.  */\n \n #define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n+  if (!g_switch_set)\t\t\t\t\t\t\t\\\n+    g_switch_value = SDATA_DEFAULT_SIZE;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   rs6000_current_abi = ((TARGET_AIXDESC_CALLS) ? ABI_AIX :\t\t\\\n \t\t\t(TARGET_NT_CALLS)      ? ABI_NT :\t\t\\\n \t\t\t(TARGET_AIX_CALLS)     ? ABI_AIX_NODESC :\t\\\n \t\t\t\t\t\t ABI_V4);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  /* CYGNUS LOCAL -fcombine-statics vs. -msdata */\t\t\t\\\n+  if (TARGET_SDATA)\t\t\t\t\t\t\t\\\n+    flag_combine_statics = 0;\t\t\t\t\t\t\\\n+  /* END CYGNUS LOCAL -fcombine-statics vs. -msdata */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_RELOCATABLE && TARGET_SDATA)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       target_flags &= ~MASK_SDATA;\t\t\t\t\t\\\n@@ -499,6 +516,19 @@ extern int rs6000_pic_labelno;\n %{mrelocatable} %{mrelocatable-lib} %{memb} %{msdata: -memb} \\\n %{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian}\"\n \n+#undef CC1_SPEC\n+/* Pass -G xxx to the compiler */\n+#define CC1_SPEC \"%{G*}\"\n+\n+/* Switch  Recognition by gcc.c.  Add -G xx support */\n+\n+#undef SWITCH_TAKES_ARG\n+#define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n+  ((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o'\t\t\t\\\n+   || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u'\t\t\t\\\n+   || (CHAR) == 'I' || (CHAR) == 'm'\t\t\t\t\t\\\n+   || (CHAR) == 'L' || (CHAR) == 'A' || (CHAR) == 'G')\n+\n /* Output .file and comments listing what options there are */\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n@@ -664,7 +694,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef LINK_SPEC\n #define LINK_SPEC \"\\\n-%{h*} %{V} %{v:%{!V:-V}} \\\n+%{h*} %{V} %{v:%{!V:-V}} %{G*} \\\n %{b} %{Wl,*:%*} \\\n %{static:-dn -Bstatic} \\\n %{shared:-G -dy -z text %{!h*:%{o*:-h %*}}} \\"}]}