{"sha": "0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3ZTNmYzFhOTM5NDA0YWE2ZTA3ZDA0NjdkYzM2NDNlMzNiOWZkMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-15T23:31:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-15T23:31:15Z"}, "message": "(index0): New function.\n\n(trigraph_pcp): Use index0 instead of index, so that a null byte\ndoesn't suppress further trigraph preprocessing.\n\nFrom-SVN: r7934", "tree": {"sha": "acaf8dc69047b83f6f119f67cf134116a47f6ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acaf8dc69047b83f6f119f67cf134116a47f6ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2/comments", "author": null, "committer": null, "parents": [{"sha": "b415f25eef56f3f037a1cbdcfe5ceec98138f8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b415f25eef56f3f037a1cbdcfe5ceec98138f8a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b415f25eef56f3f037a1cbdcfe5ceec98138f8a6"}], "stats": {"total": 32, "additions": 30, "deletions": 2}, "files": [{"sha": "aa564fdfe909246f58f05ebcebb2cd29afb97b2e", "filename": "gcc/cccp.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=0e7e3fc1a939404aa6e07d0467dc3643e33b9fd2", "patch": "@@ -2195,6 +2195,33 @@ path_include (path)\n     }\n }\n \f\n+/* Return the address of the first character in S that equals C.\n+   S is an array of length N, possibly containing '\\0's, and followed by '\\0'.\n+   Return 0 if there is no such character.  Assume that C itself is not '\\0'.\n+   If we knew we could use memchr, we could just invoke memchr (S, C, N),\n+   but unfortunately memchr isn't autoconfigured yet.  */\n+\n+static U_CHAR *\n+index0 (s, c, n)\n+     U_CHAR *s;\n+     int c;\n+     int n;\n+{\n+  for (;;) {\n+    char *q = index (s, c);\n+    if (q)\n+      return (U_CHAR *) q;\n+    else {\n+      int l = strlen (s);\n+      if (l == n)\n+\treturn 0;\n+      l++;\n+      s += l;\n+      n -= l;\n+    }\n+  }\n+}\n+\f\n /* Pre-C-Preprocessor to translate ANSI trigraph idiocy in BUF\n    before main CCCP processing.  Name `pcp' is also in honor of the\n    drugs the trigraph designers must have been on.\n@@ -2208,11 +2235,12 @@ static void\n trigraph_pcp (buf)\n      FILE_BUF *buf;\n {\n-  register U_CHAR c, *fptr, *bptr, *sptr;\n+  register U_CHAR c, *fptr, *bptr, *sptr, *lptr;\n   int len;\n \n   fptr = bptr = sptr = buf->buf;\n-  while ((sptr = (U_CHAR *) index (sptr, '?')) != NULL) {\n+  lptr = fptr + buf->length;\n+  while ((sptr = (U_CHAR *) index0 (sptr, '?', lptr - sptr)) != NULL) {\n     if (*++sptr != '?')\n       continue;\n     switch (*++sptr) {"}]}