{"sha": "bd936951453c1105710649955568375e67c69d30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5MzY5NTE0NTNjMTEwNTcxMDY0OTk1NTU2ODM3NWU2N2M2OWQzMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-02-20T06:40:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-20T06:40:07Z"}, "message": "re PR middle-end/58555 (Floating point exception in want_inline_self_recursive_call_p)\n\n\n\tPR ipa/58555\n\t* ipa-inline-transform.c (clone_inlined_nodes): Add freq_scale parameter\n\tspecifying the scaling.\n\t(inline_call): Update.\n\t(want_inline_recursively): Guard division by zero.\n\t(recursive_inlining): Update.\n\t* ipa-inline.h (clone_inlined_nodes): Update.\n\t* testsuite/g++.dg/torture/pr58555.C: New testcase.\n\nFrom-SVN: r207934", "tree": {"sha": "aa5cb062d365b7b66d1c27c29cac928aaa4f40a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5cb062d365b7b66d1c27c29cac928aaa4f40a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd936951453c1105710649955568375e67c69d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd936951453c1105710649955568375e67c69d30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd936951453c1105710649955568375e67c69d30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd936951453c1105710649955568375e67c69d30/comments", "author": null, "committer": null, "parents": [{"sha": "3c898e1acb4f9c8d43c84d2138fa298de0205c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c898e1acb4f9c8d43c84d2138fa298de0205c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c898e1acb4f9c8d43c84d2138fa298de0205c46"}], "stats": {"total": 157, "additions": 150, "deletions": 7}, "files": [{"sha": "24d8e18084bd5c4fa478434f45dfd6c0922710a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -1,3 +1,13 @@\n+2014-02-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/58555\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Add freq_scale parameter\n+\tspecifying the scaling.\n+\t(inline_call): Update.\n+\t(want_inline_recursively): Guard division by zero.\n+\t(recursive_inlining): Update.\n+\t* ipa-inline.h (clone_inlined_nodes): Update.\n+\n 2014-02-20  Ilya Tocar  <ilya.tocar@intel.com>\n \n \tPR target/60204"}, {"sha": "b2e0285462c17a58eea7694a4d82f621ad57c216", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -127,11 +127,15 @@ can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n    the edge and redirect it to the new clone.\n    DUPLICATE is used for bookkeeping on whether we are actually creating new\n    clones or re-using node originally representing out-of-line function call.\n-   */\n+   By default the offline copy is removed, when it appears dead after inlining.\n+   UPDATE_ORIGINAL prevents this transformation.\n+   If OVERALL_SIZE is non-NULL, the size is updated to reflect the\n+   transformation.\n+   FREQ_SCALE specify the scaling of frequencies of call sites.  */\n \n void\n clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n-\t\t     bool update_original, int *overall_size)\n+\t\t     bool update_original, int *overall_size, int freq_scale)\n {\n   struct cgraph_node *inlining_into;\n   struct cgraph_edge *next;\n@@ -175,8 +179,11 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       else\n \t{\n \t  struct cgraph_node *n;\n+\n+\t  if (freq_scale == -1)\n+\t    freq_scale = e->frequency;\n \t  n = cgraph_clone_node (e->callee, e->callee->decl,\n-\t\t\t\t e->count, e->frequency, update_original,\n+\t\t\t\t e->count, freq_scale, update_original,\n \t\t\t\t vNULL, true, inlining_into);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n@@ -191,7 +198,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n     {\n       next = e->next_callee;\n       if (!e->inline_failed)\n-        clone_inlined_nodes (e, duplicate, update_original, overall_size);\n+        clone_inlined_nodes (e, duplicate, update_original, overall_size, freq_scale);\n       if (e->speculative && !speculation_useful_p (e, true))\n \t{\n \t  cgraph_resolve_speculation (e, NULL);\n@@ -260,7 +267,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \t}\n     }\n \n-  clone_inlined_nodes (e, true, update_original, overall_size);\n+  clone_inlined_nodes (e, true, update_original, overall_size, e->frequency);\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n "}, {"sha": "f6f97f87ebe417af459a45778bc65688926280d5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -708,6 +708,12 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   if (outer_node->global.inlined_to)\n     caller_freq = outer_node->callers->frequency;\n \n+  if (!caller_freq)\n+    {\n+      reason = \"function is inlined and unlikely\";\n+      want_inline = false;\n+    }\n+\n   if (!want_inline)\n     ;\n   /* Inlining of self recursive function into copy of itself within other function\n@@ -1385,7 +1391,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t\t\t\t\t    false, vNULL, true, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n-\t      clone_inlined_nodes (e, true, false, NULL);\n+\t      clone_inlined_nodes (e, true, false, NULL, CGRAPH_FREQ_BASE);\n           cgraph_redirect_edge_callee (curr, master_clone);\n           reset_edge_growth_cache (curr);\n \t}"}, {"sha": "0a5960899a3fb5a147dae8702dfddb9854ef305f", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -233,7 +233,8 @@ bool speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining);\n /* In ipa-inline-transform.c  */\n bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge_p> *, int *, bool);\n unsigned int inline_transform (struct cgraph_node *);\n-void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *);\n+void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *,\n+\t\t\t  int freq_scale);\n \n extern int ncalls_inlined;\n extern int nfunctions_inlined;"}, {"sha": "0b8de7804b7b680ffebee90fdae52de0098d8143", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -1,3 +1,8 @@\n+2014-02-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/58555\n+\t* testsuite/g++.dg/torture/pr58555.C: New testcase.\n+\n 2014-02-20  Ilya Tocar  <ilya.tocar@intel.com>\n \n \tPR target/60204"}, {"sha": "ac5009a7b262930bf6a11b1f422f82a89d7be437", "filename": "gcc/testsuite/g++.dg/torture/pr58555.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd936951453c1105710649955568375e67c69d30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58555.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd936951453c1105710649955568375e67c69d30/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58555.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58555.C?ref=bd936951453c1105710649955568375e67c69d30", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do compile } */\n+template <typename _Tp> _Tp *__addressof(_Tp &) {}\n+template <typename _Tp> class A {\n+public:\n+  typedef _Tp *pointer;\n+};\n+template <typename _Tp> class M : public A<_Tp> {\n+public:\n+  typedef M other;\n+  ~M();\n+};\n+class B {\n+public:\n+  B(int *);\n+};\n+class C {\n+public:\n+  void GetNext();\n+  C *GetChildren();\n+};\n+template <typename _Tp> void _Destroy(_Tp *p1) { p1->~_Tp(); }\n+struct D {\n+  template <typename _ForwardIterator>\n+  static void __destroy(_ForwardIterator p1, _ForwardIterator p2) {\n+    for (; p1 != p2; ++p1)\n+      _Destroy(__addressof(*p1));\n+  }\n+};\n+template <typename _ForwardIterator>\n+void _Destroy(_ForwardIterator p1, _ForwardIterator p2) {\n+  D::__destroy(p1, p2);\n+}\n+template <typename _ForwardIterator, typename _Tp>\n+void _Destroy(_ForwardIterator p1, _ForwardIterator p2, M<_Tp> &) {\n+  _Destroy(p1, p2);\n+}\n+template <typename _Alloc> struct F {\n+  typedef _Alloc _Tp_alloc_type;\n+  typedef typename _Tp_alloc_type::pointer pointer;\n+  struct N : _Tp_alloc_type {\n+    pointer _M_start;\n+    pointer _M_finish;\n+  };\n+  _Tp_alloc_type &_M_get_Tp_allocator();\n+  N _M_impl;\n+};\n+template <typename _Tp, typename _Alloc = M<_Tp> > class O : F<_Alloc> {\n+using  F<_Alloc>::_M_get_Tp_allocator;\n+public:\n+  ~O() {\n+    _Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+             _M_get_Tp_allocator());\n+  }\n+};\n+template <class T> void checked_delete(T *p1) { delete p1; }\n+template <class> class I;\n+template <class T> struct J {\n+  typedef T *type;\n+};\n+class K;\n+class L {\n+public:\n+  virtual ~L();\n+};\n+class P : L {\n+  O<I<int> > databasesM;\n+  O<I<K> > usersM;\n+public:\n+  I<int> addDatabase();\n+};\n+C a;\n+C *b;\n+int atomic_exchange_and_add();\n+class G {\n+public:\n+  virtual void dispose() = 0;\n+  void release() {\n+    if (atomic_exchange_and_add() == 1)\n+      dispose();\n+  }\n+};\n+class Q : G {\n+  P *px_;\n+  Q() {}\n+  void dispose() { checked_delete(px_); }\n+};\n+class H {\n+  G *pi_;\n+public:\n+  H();\n+  H(P *);\n+  ~H() {\n+    if (pi_)\n+      pi_->release();\n+  }\n+};\n+template <class T, class Y> void sp_pointer_construct(I<T> *, Y, H);\n+template <class T> class I {\n+public:\n+  typedef T element_type;\n+  template <class Y> I(Y *p1) { sp_pointer_construct(this, 0, 0); }\n+  typename J<T>::type operator->();\n+  H pn;\n+};\n+void getNodeContent(const B &) {\n+  for (C *n = a.GetChildren(); n; n->GetNext())\n+    ;\n+}\n+void parseDatabase(I<P> p1) {\n+  I<int> c = p1->addDatabase();\n+  for (; b;)\n+    getNodeContent(0);\n+}\n+void addServer() { I<int>(new P); }"}]}