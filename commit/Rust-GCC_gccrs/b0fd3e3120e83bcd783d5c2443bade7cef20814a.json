{"sha": "b0fd3e3120e83bcd783d5c2443bade7cef20814a", "node_id": "C_kwDOANBUbNoAKGIwZmQzZTMxMjBlODNiY2Q3ODNkNWMyNDQzYmFkZTdjZWYyMDgxNGE", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-02-01T11:33:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-11T08:53:22Z"}, "message": "[Ada] Proof of 'Image support for unsigned integers\n\nProve System.Image_U, making the connection with the space available in\nthe string as computed with System.Width_U and the functions that\nsupport the other direction of 'Value in System.Value_U.\n\nThe units that support 'Image cannot be marked Pure anymore, as they now\ndepend on non-pure units.\n\ngcc/ada/\n\n\t* libgnat/s-imaged.ads: Remove Pure.\n\t* libgnat/s-imagef.ads: Remove Pure.\n\t* libgnat/s-imager.ads: Remove Pure.\n\t* libgnat/s-imageu.adb: Add ghost code.\n\t* libgnat/s-imageu.ads: Add contracts.\n\t* libgnat/s-imde128.ads: Remove Pure.\n\t* libgnat/s-imde32.ads: Remove Pure.\n\t* libgnat/s-imde64.ads: Remove Pure.\n\t* libgnat/s-imfi128.ads: Remove Pure.\n\t* libgnat/s-imfi32.ads: Remove Pure.\n\t* libgnat/s-imfi64.ads: Remove Pure.\n\t* libgnat/s-imgflt.ads: Remove Pure.\n\t* libgnat/s-imglfl.ads: Remove Pure.\n\t* libgnat/s-imgllf.ads: Remove Pure.\n\t* libgnat/s-imglllu.ads: Instantiate with ghost subprograms.\n\t* libgnat/s-imgllu.ads: Instantiate with ghost subprograms.\n\t* libgnat/s-imgrea.ads: Remove Pure.\n\t* libgnat/s-imguns.ads: Instantiate with ghost subprograms.\n\t* libgnat/s-imguti.ads: Remove Pure.\n\t* libgnat/s-valueu.adb (Prove_Iter_Scan_Based_Number_Ghost,\n\tProve_Scan_Only_Decimal_Ghost): New lemmas.\n\t* libgnat/s-valueu.ads (Uns_Option): Do not make type ghost to\n\tbe able to use it as formal in instantiations.\n\t(Only_Decimal_Ghost): New ghost query.\n\t(Prove_Iter_Scan_Based_Number_Ghost,\n\tProve_Scan_Only_Decimal_Ghost): New lemmas.\n\t* libgnat/s-widlllu.ads: Adapt to changes in Width_U.\n\t* libgnat/s-widllu.ads: Adapt to changes in Width_U.\n\t* libgnat/s-widthu.adb: Change generic function in generic\n\tpackage in order to complete the postcondition. Tighten the\n\tupper bound on the result by 1.\n\t* libgnat/s-widthu.ads: Same.\n\t* libgnat/s-widuns.ads: Adapt to changes in Width_U.\n\t* gcc-interface/Make-lang.in: Add dependencies on a-nubinu,\n\ta-numeri.ads and a-widuns.ads.", "tree": {"sha": "df06a6aebedbae5b9613493b22eaa40f96d48d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df06a6aebedbae5b9613493b22eaa40f96d48d60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0fd3e3120e83bcd783d5c2443bade7cef20814a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fd3e3120e83bcd783d5c2443bade7cef20814a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0fd3e3120e83bcd783d5c2443bade7cef20814a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fd3e3120e83bcd783d5c2443bade7cef20814a/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48a2e84929bba9aa60497c39c18c332ebfbd256e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48a2e84929bba9aa60497c39c18c332ebfbd256e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48a2e84929bba9aa60497c39c18c332ebfbd256e"}], "stats": {"total": 979, "additions": 793, "deletions": 186}, "files": [{"sha": "1e245ed3b0f09181759e9e32613bfc0d17635ac7", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -486,6 +486,8 @@ GNAT_ADA_OBJS+= \\\n  ada/libgnat/a-except.o\t\\\n  ada/libgnat/a-exctra.o \\\n  ada/libgnat/a-ioexce.o\t\\\n+ ada/libgnat/a-nubinu.o\t\\\n+ ada/libgnat/a-numeri.o\t\\\n  ada/libgnat/ada.o\t\\\n  ada/libgnat/g-byorma.o\t\\\n  ada/libgnat/g-heasor.o\t\\\n@@ -542,7 +544,8 @@ GNAT_ADA_OBJS+= \\\n  ada/libgnat/s-wchcnv.o\t\\\n  ada/libgnat/s-wchcon.o\t\\\n  ada/libgnat/s-wchjis.o\t\\\n- ada/libgnat/s-wchstw.o\n+ ada/libgnat/s-wchstw.o\t\\\n+ ada/libgnat/s-widuns.o\n endif\n \n # Object files for gnat executables\n@@ -649,6 +652,8 @@ GNATBIND_OBJS +=  \\\n  ada/libgnat/a-assert.o   \\\n  ada/libgnat/a-elchha.o   \\\n  ada/libgnat/a-except.o   \\\n+ ada/libgnat/a-nubinu.o   \\\n+ ada/libgnat/a-numeri.o   \\\n  ada/libgnat/ada.o        \\\n  ada/libgnat/g-byorma.o   \\\n  ada/libgnat/g-hesora.o   \\\n@@ -693,6 +698,7 @@ GNATBIND_OBJS +=  \\\n  ada/libgnat/s-wchcon.o   \\\n  ada/libgnat/s-wchjis.o   \\\n  ada/libgnat/s-wchstw.o   \\\n+ ada/libgnat/s-widuns.o   \\\n  ada/adaint.o     \\\n  ada/argv.o       \\\n  ada/cio.o        \\"}, {"sha": "f23eac8130879e721c4a3840fcc2e301c060bea1", "filename": "gcc/ada/libgnat/s-imaged.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imaged.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imaged.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imaged.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -38,7 +38,6 @@ generic\n    type Int is range <>;\n \n package System.Image_D is\n-   pragma Pure;\n \n    procedure Image_Decimal\n      (V     : Int;"}, {"sha": "c16d2c58d41307dea5bfd184f1a03abbf4003ae3", "filename": "gcc/ada/libgnat/s-imagef.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -43,7 +43,6 @@ generic\n            Round : Boolean);\n \n package System.Image_F is\n-   pragma Pure;\n \n    procedure Image_Fixed\n      (V    : Int;"}, {"sha": "6828b6fbf00ec2ac2942ff50cc30d2ceb289131a", "filename": "gcc/ada/libgnat/s-imager.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imager.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imager.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imager.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -48,7 +48,6 @@ generic\n       P : in out Natural);\n \n package System.Image_R is\n-   pragma Pure;\n \n    procedure Image_Fixed_Point\n      (V   : Num;"}, {"sha": "87830dff74052825cd25a57e5db864cbce7242d3", "filename": "gcc/ada/libgnat/s-imageu.adb", "status": "modified", "additions": 309, "deletions": 1, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.adb?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -29,8 +29,106 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n package body System.Image_U is\n \n+   --  Ghost code, loop invariants and assertions in this unit are meant for\n+   --  analysis only, not for run-time checking, as it would be too costly\n+   --  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+   pragma Assertion_Policy (Ghost              => Ignore,\n+                            Loop_Invariant     => Ignore,\n+                            Assert             => Ignore,\n+                            Assert_And_Cut     => Ignore,\n+                            Subprogram_Variant => Ignore);\n+\n+   package Unsigned_Conversion is new Unsigned_Conversions (Int => Uns);\n+\n+   function Big (Arg : Uns) return Big_Integer renames\n+     Unsigned_Conversion.To_Big_Integer;\n+\n+   function From_Big (Arg : Big_Integer) return Uns renames\n+     Unsigned_Conversion.From_Big_Integer;\n+\n+   Big_10 : constant Big_Integer := Big (10) with Ghost;\n+\n+   --  Maximum value of exponent for 10 that fits in Uns'Base\n+   function Max_Log10 return Natural is\n+     (case Uns'Base'Size is\n+        when 8   => 2,\n+        when 16  => 4,\n+        when 32  => 9,\n+        when 64  => 19,\n+        when 128 => 38,\n+        when others => raise Program_Error)\n+   with Ghost;\n+\n+   ------------------\n+   -- Local Lemmas --\n+   ------------------\n+\n+   procedure Lemma_Non_Zero (X : Uns)\n+   with\n+     Ghost,\n+     Pre  => X /= 0,\n+     Post => Big (X) /= 0;\n+\n+   procedure Lemma_Div_Commutation (X, Y : Uns)\n+   with\n+     Ghost,\n+     Pre  => Y /= 0,\n+     Post => Big (X) / Big (Y) = Big (X / Y);\n+\n+   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive)\n+   with\n+     Ghost,\n+     Post => X / Y / Z = X / (Y * Z);\n+\n+   procedure Lemma_Unsigned_Width_Ghost\n+   with\n+     Ghost,\n+     Post => Unsigned_Width_Ghost = Max_Log10 + 2;\n+\n+   ---------------------------\n+   -- Lemma_Div_Commutation --\n+   ---------------------------\n+\n+   procedure Lemma_Non_Zero (X : Uns) is null;\n+   procedure Lemma_Div_Commutation (X, Y : Uns) is null;\n+\n+   ---------------------\n+   -- Lemma_Div_Twice --\n+   ---------------------\n+\n+   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive) is\n+      XY  : constant Big_Natural := X / Y;\n+      YZ  : constant Big_Natural := Y * Z;\n+      XYZ : constant Big_Natural := X / Y / Z;\n+      R   : constant Big_Natural := (XY rem Z) * Y + (X rem Y);\n+   begin\n+      pragma Assert (X = XY * Y + (X rem Y));\n+      pragma Assert (XY = XY / Z * Z + (XY rem Z));\n+      pragma Assert (X = XYZ * YZ + R);\n+      pragma Assert ((XY rem Z) * Y <= (Z - 1) * Y);\n+      pragma Assert (R <= YZ - 1);\n+      pragma Assert (X / YZ = (XYZ * YZ + R) / YZ);\n+      pragma Assert (X / YZ = XYZ + R / YZ);\n+   end Lemma_Div_Twice;\n+\n+   --------------------------------\n+   -- Lemma_Unsigned_Width_Ghost --\n+   --------------------------------\n+\n+   procedure Lemma_Unsigned_Width_Ghost is\n+   begin\n+      pragma Assert (Unsigned_Width_Ghost <= Max_Log10 + 2);\n+      pragma Assert (Big (Uns'Last) > Big_10 ** Max_Log10);\n+      pragma Assert (Big (Uns'Last) < Big_10 ** (Unsigned_Width_Ghost - 1));\n+      pragma Assert (Unsigned_Width_Ghost >= Max_Log10 + 2);\n+   end Lemma_Unsigned_Width_Ghost;\n+\n    --------------------\n    -- Image_Unsigned --\n    --------------------\n@@ -41,10 +139,45 @@ package body System.Image_U is\n       P : out Natural)\n    is\n       pragma Assert (S'First = 1);\n+\n+      procedure Prove_Value_Unsigned\n+      with\n+        Ghost,\n+        Pre => S'First = 1\n+          and then S'Last < Integer'Last\n+          and then P in 2 .. S'Last\n+          and then S (1) = ' '\n+          and then Only_Decimal_Ghost (S, From => 2, To => P)\n+          and then Scan_Based_Number_Ghost (S, From => 2, To => P)\n+            = Wrap_Option (V),\n+        Post => Is_Unsigned_Ghost (S (1 .. P))\n+          and then Value_Unsigned (S (1 .. P)) = V;\n+      --  Ghost lemma to prove the value of Value_Unsigned from the value of\n+      --  Scan_Based_Number_Ghost on a decimal string.\n+\n+      --------------------------\n+      -- Prove_Value_Unsigned --\n+      --------------------------\n+\n+      procedure Prove_Value_Unsigned is\n+         Str : constant String := S (1 .. P);\n+      begin\n+         pragma Assert (Str'First = 1);\n+         pragma Assert (Only_Decimal_Ghost (Str, From => 2, To => P));\n+         Prove_Iter_Scan_Based_Number_Ghost (S, Str, From => 2, To => P);\n+         pragma Assert (Scan_Based_Number_Ghost (Str, From => 2, To => P)\n+            = Wrap_Option (V));\n+         Prove_Scan_Only_Decimal_Ghost (Str, V);\n+      end Prove_Value_Unsigned;\n+\n+   --  Start of processing for Image_Unsigned\n+\n    begin\n       S (1) := ' ';\n       P := 1;\n       Set_Image_Unsigned (V, S, P);\n+\n+      Prove_Value_Unsigned;\n    end Image_Unsigned;\n \n    ------------------------\n@@ -58,28 +191,203 @@ package body System.Image_U is\n    is\n       Nb_Digits : Natural := 0;\n       Value     : Uns := V;\n+\n+      --  Local ghost variables\n+\n+      Pow        : Big_Positive := 1 with Ghost;\n+      S_Init     : constant String := S with Ghost;\n+      Prev, Cur  : Uns_Option with Ghost;\n+      Prev_Value : Uns with Ghost;\n+      Prev_S     : String := S with Ghost;\n+\n+      --  Local ghost lemmas\n+\n+      procedure Prove_Character_Val (R : Uns)\n+      with\n+        Ghost,\n+        Pre  => R in 0 .. 9,\n+        Post => Character'Val (48 + R) in '0' .. '9';\n+      --  Ghost lemma to prove the value of a character corresponding to the\n+      --  next figure.\n+\n+      procedure Prove_Hexa_To_Unsigned_Ghost (R : Uns)\n+      with\n+        Ghost,\n+        Pre  => R in 0 .. 9,\n+        Post => Hexa_To_Unsigned_Ghost (Character'Val (48 + R)) = R;\n+      --  Ghost lemma to prove that Hexa_To_Unsigned_Ghost returns the source\n+      --  figure when applied to the corresponding character.\n+\n+      procedure Prove_Unchanged\n+      with\n+        Ghost,\n+        Pre  => P <= S'Last\n+          and then S_Init'First = S'First\n+          and then S_Init'Last = S'Last\n+          and then (for all K in S'First .. P => S (K) = S_Init (K)),\n+        Post => S (S'First .. P) = S_Init (S'First .. P);\n+      --  Ghost lemma to prove that the part of string S before P has not been\n+      --  modified.\n+\n+      procedure Prove_Iter_Scan\n+        (Str1, Str2 : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+      with\n+        Ghost,\n+        Pre  => Str1'Last /= Positive'Last\n+          and then\n+            (From > To or else (From >= Str1'First and then To <= Str1'Last))\n+          and then Only_Decimal_Ghost (Str1, From, To)\n+          and then Str1'First = Str2'First\n+          and then Str1'Last = Str2'Last\n+          and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n+        Post =>\n+          Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n+            = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n+      --  Ghost lemma to prove that the result of Scan_Based_Number_Ghost only\n+      --  depends on the value of the argument string in the (From .. To) range\n+      --  of indexes. This is a wrapper on Prove_Iter_Scan_Based_Number_Ghost\n+      --  so that we can call it here on ghost arguments.\n+\n+      -----------------------------\n+      -- Local lemma null bodies --\n+      -----------------------------\n+\n+      procedure Prove_Character_Val (R : Uns) is null;\n+      procedure Prove_Hexa_To_Unsigned_Ghost (R : Uns) is null;\n+      procedure Prove_Unchanged is null;\n+\n+      ---------------------\n+      -- Prove_Iter_Scan --\n+      ---------------------\n+\n+      procedure Prove_Iter_Scan\n+        (Str1, Str2 : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+      is\n+      begin\n+         Prove_Iter_Scan_Based_Number_Ghost (Str1, Str2, From, To, Base, Acc);\n+      end Prove_Iter_Scan;\n+\n+   --  Start of processing for Set_Image_Unsigned\n+\n    begin\n       pragma Assert (P >= S'First - 1 and then P < S'Last and then\n                      P < Natural'Last);\n       --  No check is done since, as documented in the specification, the\n       --  caller guarantees that S is long enough to hold the result.\n \n+      Lemma_Unsigned_Width_Ghost;\n+\n       --  First we compute the number of characters needed for representing\n       --  the number.\n       loop\n+         Lemma_Div_Commutation (Value, 10);\n+         Lemma_Div_Twice (Big (V), Big_10 ** Nb_Digits, Big_10);\n+\n          Value := Value / 10;\n          Nb_Digits := Nb_Digits + 1;\n+         Pow := Pow * 10;\n+\n+         pragma Loop_Invariant (Nb_Digits in 1 .. Unsigned_Width_Ghost - 1);\n+         pragma Loop_Invariant (Pow = Big_10 ** Nb_Digits);\n+         pragma Loop_Invariant (Big (Value) = Big (V) / Pow);\n+         pragma Loop_Variant (Decreases => Value);\n+\n          exit when Value = 0;\n+\n+         Lemma_Non_Zero (Value);\n+         pragma Assert (Pow <= Big (Uns'Last));\n       end loop;\n \n       Value := V;\n+      Pow := 1;\n+\n+      pragma Assert (Value = From_Big (Big (V) / Big_10 ** 0));\n \n       --  We now populate digits from the end of the string to the beginning\n-      for J in reverse  1 .. Nb_Digits loop\n+      for J in reverse 1 .. Nb_Digits loop\n+         Lemma_Div_Commutation (Value, 10);\n+         Lemma_Div_Twice (Big (V), Big_10 ** (Nb_Digits - J), Big_10);\n+         Prove_Character_Val (Value rem 10);\n+         Prove_Hexa_To_Unsigned_Ghost (Value rem 10);\n+\n+         Prev_Value := Value;\n+         Prev_S := S;\n+         Pow := Pow * 10;\n+\n          S (P + J) := Character'Val (48 + (Value rem 10));\n          Value := Value / 10;\n+\n+         pragma Assert (S (P + J) in '0' .. '9');\n+         pragma Assert (Hexa_To_Unsigned_Ghost (S (P + J)) =\n+           From_Big (Big (V) / Big_10 ** (Nb_Digits - J)) rem 10);\n+         pragma Assert\n+           (for all K in P + J + 1 .. P + Nb_Digits => S (K) in '0' .. '9');\n+         pragma Assert\n+           (for all K in P + J + 1 .. P + Nb_Digits =>\n+              Hexa_To_Unsigned_Ghost (S (K)) =\n+                From_Big (Big (V) / Big_10 ** (Nb_Digits - (K - P))) rem 10);\n+\n+         Prev := Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + J + 1,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Prev_Value);\n+         Cur := Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + J,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Value);\n+\n+         if J /= Nb_Digits then\n+            pragma Assert\n+              (Prev_Value = 10 * Value + Hexa_To_Unsigned_Ghost (S (P + J)));\n+            Prove_Iter_Scan\n+              (Prev_S, S, P + J + 1, P + Nb_Digits, 10, Prev_Value);\n+         end if;\n+\n+         pragma Assert (Prev = Cur);\n+         pragma Assert (Prev = Wrap_Option (V));\n+\n+         pragma Loop_Invariant (Value <= Uns'Last / 10);\n+         pragma Loop_Invariant\n+           (for all K in S'First .. P => S (K) = S_Init (K));\n+         pragma Loop_Invariant (Only_Decimal_Ghost (S, P + J, P + Nb_Digits));\n+         pragma Loop_Invariant\n+           (for all K in P + J .. P + Nb_Digits => S (K) in '0' .. '9');\n+         pragma Loop_Invariant\n+           (for all K in P + J .. P + Nb_Digits =>\n+              Hexa_To_Unsigned_Ghost (S (K)) =\n+                From_Big (Big (V) / Big_10 ** (Nb_Digits - (K - P))) rem 10);\n+         pragma Loop_Invariant (Pow = Big_10 ** (Nb_Digits - J + 1));\n+         pragma Loop_Invariant (Big (Value) = Big (V) / Pow);\n+         pragma Loop_Invariant\n+           (Scan_Based_Number_Ghost\n+              (Str  => S,\n+               From => P + J,\n+               To   => P + Nb_Digits,\n+               Base => 10,\n+               Acc  => Value)\n+              = Wrap_Option (V));\n       end loop;\n \n+      Prove_Unchanged;\n+      pragma Assert\n+        (Scan_Based_Number_Ghost\n+           (Str  => S,\n+            From => P + 1,\n+            To   => P + Nb_Digits,\n+            Base => 10,\n+            Acc  => Value)\n+         = Wrap_Option (V));\n+\n       P := P + Nb_Digits;\n    end Set_Image_Unsigned;\n "}, {"sha": "d3f29819e0eb0497a79693cb33b6c9e93802a213", "filename": "gcc/ada/libgnat/s-imageu.ads", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -33,17 +33,61 @@\n --  modular integer types, and also for conversion operations required in\n --  Text_IO.Modular_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n generic\n \n    type Uns is mod <>;\n+   type Uns_Option is private;\n+\n+   --  Additional parameters for ghost subprograms used inside contracts\n+\n+   Unsigned_Width_Ghost : Natural;\n+\n+   with function Wrap_Option (Value : Uns) return Uns_Option;\n+   with function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean;\n+   with function Hexa_To_Unsigned_Ghost (X : Character) return Uns;\n+   with function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0) return Uns_Option;\n+   with function Is_Unsigned_Ghost (Str : String) return Boolean;\n+   with function Value_Unsigned (Str : String) return Uns;\n+   with procedure Prove_Iter_Scan_Based_Number_Ghost\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0);\n+   with procedure Prove_Scan_Only_Decimal_Ghost\n+     (Str : String;\n+      Val : Uns);\n \n package System.Image_U is\n-   pragma Pure;\n \n    procedure Image_Unsigned\n      (V : Uns;\n       S : in out String;\n-      P : out Natural);\n+      P : out Natural)\n+   with\n+     Pre  => S'First = 1\n+       and then S'Last < Integer'Last\n+       and then S'Last >= Unsigned_Width_Ghost,\n+     Post => P in S'Range\n+       and then Value_Unsigned (S (1 .. P)) = V;\n    pragma Inline (Image_Unsigned);\n    --  Computes Uns'Image (V) and stores the result in S (1 .. P) setting\n    --  the resulting value of P. The caller guarantees that S is long enough to\n@@ -52,7 +96,18 @@ package System.Image_U is\n    procedure Set_Image_Unsigned\n      (V : Uns;\n       S : in out String;\n-      P : in out Natural);\n+      P : in out Natural)\n+   with\n+     Pre  => P < Integer'Last\n+       and then S'Last < Integer'Last\n+       and then S'First <= P + 1\n+       and then S'First <= S'Last\n+       and then P <= S'Last - Unsigned_Width_Ghost + 1,\n+     Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n+       and then P in P'Old + 1 .. S'Last\n+       and then Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n+       and then Scan_Based_Number_Ghost (S, From => P'Old + 1, To => P)\n+         = Wrap_Option (V);\n    --  Stores the image of V in S starting at S (P + 1), P is updated to point\n    --  to the last character stored. The value stored is identical to the value\n    --  of Uns'Image (V) except that no leading space is stored. The caller"}, {"sha": "2bd339fef7022054b674cf319ee167ab62f3ebdb", "filename": "gcc/ada/libgnat/s-imde128.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde128.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with Interfaces;\n with System.Image_D;\n \n package System.Img_Decimal_128 is\n-   pragma Pure;\n \n    subtype Int128 is Interfaces.Integer_128;\n "}, {"sha": "47d7792b02f3faf66835045c27c57e507fda6a09", "filename": "gcc/ada/libgnat/s-imde32.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde32.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with Interfaces;\n with System.Image_D;\n \n package System.Img_Decimal_32 is\n-   pragma Pure;\n \n    subtype Int32 is Interfaces.Integer_32;\n "}, {"sha": "d84f5c9e3059cbd58301540c05691235f80fda28", "filename": "gcc/ada/libgnat/s-imde64.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imde64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde64.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with Interfaces;\n with System.Image_D;\n \n package System.Img_Decimal_64 is\n-   pragma Pure;\n \n    subtype Int64 is Interfaces.Integer_64;\n "}, {"sha": "4614455a4e968a09bb6b02baded8cfee8d57fbc0", "filename": "gcc/ada/libgnat/s-imfi128.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with System.Arith_128;\n with System.Image_F;\n \n package System.Img_Fixed_128 is\n-   pragma Pure;\n \n    subtype Int128 is Interfaces.Integer_128;\n "}, {"sha": "492cc92812013684307640ab0c948be46d294185", "filename": "gcc/ada/libgnat/s-imfi32.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with System.Arith_32;\n with System.Image_F;\n \n package System.Img_Fixed_32 is\n-   pragma Pure;\n \n    subtype Int32 is Interfaces.Integer_32;\n "}, {"sha": "d51634c9414f0dd6663e28fe221ba1ea22edeaff", "filename": "gcc/ada/libgnat/s-imfi64.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -37,7 +37,6 @@ with System.Arith_64;\n with System.Image_F;\n \n package System.Img_Fixed_64 is\n-   pragma Pure;\n \n    subtype Int64 is Interfaces.Integer_64;\n "}, {"sha": "cc7df511b060b0c154f2a2bb50e7a2412228f6d7", "filename": "gcc/ada/libgnat/s-imgflt.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgflt.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -38,7 +38,6 @@ with System.Powten_Flt;\n with System.Unsigned_Types;\n \n package System.Img_Flt is\n-   pragma Pure;\n \n    package Impl is new Image_R\n      (Float,"}, {"sha": "294990ab55c79aec8fcbaed9ba6e6be5b525263e", "filename": "gcc/ada/libgnat/s-imglfl.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglfl.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -38,7 +38,6 @@ with System.Powten_LFlt;\n with System.Unsigned_Types;\n \n package System.Img_LFlt is\n-   pragma Pure;\n \n    --  Note that the following instantiation is really for a 32-bit target,\n    --  where 128-bit integer types are not available. For a 64-bit targaet,"}, {"sha": "b10a029f663c556ead3465abfff92ed6184366fa", "filename": "gcc/ada/libgnat/s-imgllf.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllf.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -38,7 +38,6 @@ with System.Powten_LLF;\n with System.Unsigned_Types;\n \n package System.Img_LLF is\n-   pragma Pure;\n \n    --  Note that the following instantiation is really for a 32-bit target,\n    --  where 128-bit integer types are not available. For a 64-bit targaet,"}, {"sha": "0116aa83bc7474c081199cf7d9e2a73de220dfb3", "filename": "gcc/ada/libgnat/s-imglllu.ads", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -33,15 +33,46 @@\n --  modular integer types larger than Long_Long_Unsigned, and also for\n --  conversion operations required in Text_IO.Modular_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_U;\n with System.Unsigned_Types;\n+with System.Val_LLLU;\n+with System.Wid_LLLU;\n \n-package System.Img_LLLU is\n-   pragma Pure;\n-\n+package System.Img_LLLU\n+  with SPARK_Mode\n+is\n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n-   package Impl is new Image_U (Long_Long_Long_Unsigned);\n+   package Impl is new Image_U\n+     (Uns                                => Long_Long_Long_Unsigned,\n+      Uns_Option                         => Val_LLLU.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_LLLU.Width_Long_Long_Long_Unsigned\n+        (0, Long_Long_Long_Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_LLLU.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_LLLU.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_LLLU.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_LLLU.Impl.Scan_Based_Number_Ghost,\n+      Is_Unsigned_Ghost                  => Val_LLLU.Impl.Is_Unsigned_Ghost,\n+      Value_Unsigned                     => Val_LLLU.Impl.Value_Unsigned,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_LLLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_LLLU.Impl.Prove_Scan_Only_Decimal_Ghost);\n \n    procedure Image_Long_Long_Long_Unsigned\n      (V : Long_Long_Long_Unsigned;"}, {"sha": "67372d77227eb06d0e085100f1fd32d7fcf26287", "filename": "gcc/ada/libgnat/s-imgllu.ads", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -33,15 +33,45 @@\n --  modular integer types larger than Unsigned, and also for conversion\n --  operations required in Text_IO.Modular_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_U;\n with System.Unsigned_Types;\n+with System.Val_LLU;\n+with System.Wid_LLU;\n \n-package System.Img_LLU is\n-   pragma Pure;\n-\n+package System.Img_LLU\n+  with SPARK_Mode\n+is\n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n-   package Impl is new Image_U (Long_Long_Unsigned);\n+   package Impl is new Image_U\n+     (Uns                                => Long_Long_Unsigned,\n+      Uns_Option                         => Val_LLU.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_LLU.Width_Long_Long_Unsigned (0, Long_Long_Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_LLU.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_LLU.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_LLU.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_LLU.Impl.Scan_Based_Number_Ghost,\n+      Is_Unsigned_Ghost                  => Val_LLU.Impl.Is_Unsigned_Ghost,\n+      Value_Unsigned                     => Val_LLU.Impl.Value_Unsigned,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_LLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_LLU.Impl.Prove_Scan_Only_Decimal_Ghost);\n \n    procedure Image_Long_Long_Unsigned\n      (V : Long_Long_Unsigned;"}, {"sha": "8d663b7d6597401e1f3d7eae4f721526740d6001", "filename": "gcc/ada/libgnat/s-imgrea.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -34,7 +34,6 @@\n with System.Img_LLF;\n \n package System.Img_Real is\n-   pragma Pure;\n \n    procedure Set_Image_Real\n      (V    : Long_Long_Float;"}, {"sha": "fa903cece7a9cf4c0d4adefc146a8f1881b058c8", "filename": "gcc/ada/libgnat/s-imguns.ads", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -33,15 +33,45 @@\n --  modular integer types up to Unsigned, and also for conversion operations\n --  required in Text_IO.Modular_IO for such types.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n with System.Image_U;\n with System.Unsigned_Types;\n+with System.Val_Uns;\n+with System.Wid_Uns;\n \n-package System.Img_Uns is\n-   pragma Pure;\n-\n+package System.Img_Uns\n+  with SPARK_Mode\n+is\n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n-   package Impl is new Image_U (Unsigned);\n+   package Impl is new Image_U\n+     (Uns                                => Unsigned,\n+      Uns_Option                         => Val_Uns.Impl.Uns_Option,\n+      Unsigned_Width_Ghost               =>\n+         Wid_Uns.Width_Unsigned (0, Unsigned'Last),\n+      Only_Decimal_Ghost                 => Val_Uns.Impl.Only_Decimal_Ghost,\n+      Hexa_To_Unsigned_Ghost             =>\n+         Val_Uns.Impl.Hexa_To_Unsigned_Ghost,\n+      Wrap_Option                        => Val_Uns.Impl.Wrap_Option,\n+      Scan_Based_Number_Ghost            =>\n+         Val_Uns.Impl.Scan_Based_Number_Ghost,\n+      Is_Unsigned_Ghost                  => Val_Uns.Impl.Is_Unsigned_Ghost,\n+      Value_Unsigned                     => Val_Uns.Impl.Value_Unsigned,\n+      Prove_Iter_Scan_Based_Number_Ghost =>\n+         Val_Uns.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n+      Prove_Scan_Only_Decimal_Ghost      =>\n+         Val_Uns.Impl.Prove_Scan_Only_Decimal_Ghost);\n \n    procedure Image_Unsigned\n      (V : Unsigned;"}, {"sha": "37e592f50aeb997ba763b7bab74092f435961c17", "filename": "gcc/ada/libgnat/s-imguti.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -32,7 +32,6 @@\n --  This package provides some common utilities used by the s-imgxxx files\n \n package System.Img_Util is\n-   pragma Pure;\n \n    Max_Real_Image_Length : constant := 5200;\n    --  If Exp is set to zero and Aft is set to Text_IO.Field'Last (i.e., 255)"}, {"sha": "f1456a1a5ca42b550b2d107481410324c67b9303", "filename": "gcc/ada/libgnat/s-valueu.adb", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.adb?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -234,6 +234,77 @@ package body System.Value_U is\n       end if;\n    end Lemma_Scan_Digit;\n \n+   ----------------------------------------\n+   -- Prove_Iter_Scan_Based_Number_Ghost --\n+   ----------------------------------------\n+\n+   procedure Prove_Iter_Scan_Based_Number_Ghost\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is\n+   begin\n+      if From > To then\n+         null;\n+      elsif Str1 (From) = '_' then\n+         Prove_Iter_Scan_Based_Number_Ghost\n+           (Str1, Str2, From + 1, To, Base, Acc);\n+      elsif Scan_Overflows_Ghost\n+        (Hexa_To_Unsigned_Ghost (Str1 (From)), Base, Acc)\n+      then\n+         null;\n+      else\n+         Prove_Iter_Scan_Based_Number_Ghost\n+           (Str1, Str2, From + 1, To, Base,\n+            Base * Acc + Hexa_To_Unsigned_Ghost (Str1 (From)));\n+      end if;\n+   end Prove_Iter_Scan_Based_Number_Ghost;\n+\n+   -----------------------------------\n+   -- Prove_Scan_Only_Decimal_Ghost --\n+   -----------------------------------\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost\n+     (Str : String;\n+      Val : Uns)\n+   is\n+      Non_Blank : constant Positive := First_Non_Space_Ghost\n+        (Str, Str'First, Str'Last);\n+      pragma Assert (Non_Blank = Str'First + 1);\n+      Fst_Num   : constant Positive :=\n+        (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      pragma Assert (Fst_Num = Str'First + 1);\n+      Last_Num_Init   : constant Integer :=\n+        Last_Number_Ghost (Str (Str'First + 1 .. Str'Last));\n+      pragma Assert (Last_Num_Init = Str'Last);\n+      Starts_As_Based : constant Boolean :=\n+        Last_Num_Init < Str'Last - 1\n+        and then Str (Last_Num_Init + 1) in '#' | ':'\n+        and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+      pragma Assert (Starts_As_Based = False);\n+      Last_Num_Based  : constant Integer :=\n+        (if Starts_As_Based\n+         then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n+         else Last_Num_Init);\n+      pragma Assert (Last_Num_Based = Str'Last);\n+   begin\n+      pragma Assert\n+        (Is_Opt_Exponent_Format_Ghost (Str (Str'Last + 1 .. Str'Last)));\n+      pragma Assert\n+        (Is_Natural_Format_Ghost (Str (Str'First + 1 .. Str'Last)));\n+      pragma Assert\n+        (Is_Raw_Unsigned_Format_Ghost (Str (Str'First + 1 .. Str'Last)));\n+      pragma Assert\n+        (not Raw_Unsigned_Overflows_Ghost (Str, Str'First + 1, Str'Last));\n+      pragma Assert (Val = Exponent_Unsigned_Ghost (Val, 0, 10).Value);\n+      pragma Assert\n+        (Val = Scan_Raw_Unsigned_Ghost (Str, Str'First + 1, Str'Last));\n+      pragma Assert (Is_Unsigned_Ghost (Str));\n+      pragma Assert (Is_Value_Unsigned_Ghost (Str, Val));\n+   end Prove_Scan_Only_Decimal_Ghost;\n+\n    -----------------------\n    -- Scan_Raw_Unsigned --\n    -----------------------"}, {"sha": "6245c47a7916b465624cd1d1e22bd487080271dc", "filename": "gcc/ada/libgnat/s-valueu.ads", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -62,7 +62,24 @@ package System.Value_U is\n          when False =>\n             Value : Uns := 0;\n       end case;\n-   end record with Ghost;\n+   end record;\n+\n+   function Wrap_Option (Value : Uns) return Uns_Option is\n+     (Overflow => False, Value => Value)\n+   with\n+     Ghost;\n+\n+   function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+   is\n+      (for all J in From .. To => Str (J) in '0' .. '9')\n+   with\n+     Ghost,\n+     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n+   --  Ghost function that returns True if S has only decimal characters\n+   --  from index From to index To.\n \n    function Only_Hexa_Ghost (Str : String; From, To : Integer) return Boolean\n    is\n@@ -535,6 +552,46 @@ package System.Value_U is\n    --  is the string argument of the attribute. Constraint_Error is raised if\n    --  the string is malformed, or if the value is out of range.\n \n+   procedure Prove_Iter_Scan_Based_Number_Ghost\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Ghost,\n+     Subprogram_Variant => (Increases => From),\n+     Pre  => Str1'Last /= Positive'Last\n+       and then Str2'Last /= Positive'Last\n+       and then\n+         (From > To or else (From >= Str1'First and then To <= Str1'Last))\n+       and then\n+         (From > To or else (From >= Str2'First and then To <= Str2'Last))\n+       and then Only_Hexa_Ghost (Str1, From, To)\n+       and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n+     Post =>\n+       Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n+         = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n+   --  Ghost lemma used in the proof of 'Image implementation, to prove the\n+   --  preservation of Scan_Based_Number_Ghost across an update in the string\n+   --  in lower indexes.\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost\n+     (Str : String;\n+      Val : Uns)\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then Str'Length >= 2\n+       and then Str (Str'First) = ' '\n+       and then Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n+       and then Scan_Based_Number_Ghost (Str, Str'First + 1, Str'Last)\n+         = Wrap_Option (Val),\n+     Post => Is_Unsigned_Ghost (Slide_If_Necessary (Str))\n+       and then Value_Unsigned (Str) = Val;\n+   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n+   --  the result of Value_Unsigned on a decimal string is the same as the\n+   --  result of Scan_Based_Number_Ghost.\n+\n private\n \n    -----------------------------"}, {"sha": "e9b6f9bed9d0402274e73126c005240766831b8b", "filename": "gcc/ada/libgnat/s-widlllu.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widlllu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -50,8 +50,11 @@ package System.Wid_LLLU\n is\n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n-   function Width_Long_Long_Long_Unsigned is\n-     new Width_U (Long_Long_Long_Unsigned);\n-   pragma Pure_Function (Width_Long_Long_Long_Unsigned);\n+   package Width_Uns is new Width_U (Long_Long_Long_Unsigned);\n+\n+   function Width_Long_Long_Long_Unsigned\n+     (Lo, Hi : Long_Long_Long_Unsigned)\n+      return Natural\n+      renames Width_Uns.Width;\n \n end System.Wid_LLLU;"}, {"sha": "7276d02414420ebfdbfa947b499cc67fa111fb6f", "filename": "gcc/ada/libgnat/s-widllu.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widllu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -50,7 +50,11 @@ package System.Wid_LLU\n is\n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n-   function Width_Long_Long_Unsigned is new Width_U (Long_Long_Unsigned);\n-   pragma Pure_Function (Width_Long_Long_Unsigned);\n+   package Width_Uns is new Width_U (Long_Long_Unsigned);\n+\n+   function Width_Long_Long_Unsigned\n+     (Lo, Hi : Long_Long_Unsigned)\n+      return Natural\n+      renames Width_Uns.Width;\n \n end System.Wid_LLU;"}, {"sha": "390942c8f808c71ee3330ca8c12dded6a4250dcc", "filename": "gcc/ada/libgnat/s-widthu.adb", "status": "modified", "additions": 122, "deletions": 141, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.adb?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -29,157 +29,138 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n-use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n-\n-function System.Width_U (Lo, Hi : Uns) return Natural is\n+package body System.Width_U is\n \n    --  Ghost code, loop invariants and assertions in this unit are meant for\n    --  analysis only, not for run-time checking, as it would be too costly\n    --  otherwise. This is enforced by setting the assertion policy to Ignore.\n \n-   pragma Assertion_Policy (Ghost          => Ignore,\n-                            Loop_Invariant => Ignore,\n-                            Assert         => Ignore);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   package Unsigned_Conversion is new Unsigned_Conversions (Int => Uns);\n-\n-   function Big (Arg : Uns) return Big_Integer renames\n-     Unsigned_Conversion.To_Big_Integer;\n-\n-   --  Maximum value of exponent for 10 that fits in Uns'Base\n-   function Max_Log10 return Natural is\n-     (case Uns'Base'Size is\n-        when 8   => 2,\n-        when 16  => 4,\n-        when 32  => 9,\n-        when 64  => 19,\n-        when 128 => 38,\n-        when others => raise Program_Error)\n-   with Ghost;\n-\n-   ------------------\n-   -- Local Lemmas --\n-   ------------------\n-\n-   procedure Lemma_Lower_Mult (A, B, C : Big_Natural)\n-   with\n-     Ghost,\n-     Pre  => A <= B,\n-     Post => A * C <= B * C;\n-\n-   procedure Lemma_Div_Commutation (X, Y : Uns)\n-   with\n-     Ghost,\n-     Pre  => Y /= 0,\n-     Post => Big (X) / Big (Y) = Big (X / Y);\n-\n-   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive)\n-   with\n-     Ghost,\n-     Post => X / Y / Z = X / (Y * Z);\n-\n-   ----------------------\n-   -- Lemma_Lower_Mult --\n-   ----------------------\n-\n-   procedure Lemma_Lower_Mult (A, B, C : Big_Natural) is null;\n-\n-   ---------------------------\n-   -- Lemma_Div_Commutation --\n-   ---------------------------\n-\n-   procedure Lemma_Div_Commutation (X, Y : Uns) is null;\n-\n-   ---------------------\n-   -- Lemma_Div_Twice --\n-   ---------------------\n-\n-   procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive) is\n-      XY  : constant Big_Natural := X / Y;\n-      YZ  : constant Big_Natural := Y * Z;\n-      XYZ : constant Big_Natural := X / Y / Z;\n-      R   : constant Big_Natural := (XY rem Z) * Y + (X rem Y);\n-   begin\n-      pragma Assert (X = XY * Y + (X rem Y));\n-      pragma Assert (XY = XY / Z * Z + (XY rem Z));\n-      pragma Assert (X = XYZ * YZ + R);\n-      pragma Assert ((XY rem Z) * Y <= (Z - 1) * Y);\n-      pragma Assert (R <= YZ - 1);\n-      pragma Assert (X / YZ = (XYZ * YZ + R) / YZ);\n-      pragma Assert (X / YZ = XYZ + R / YZ);\n-   end Lemma_Div_Twice;\n-\n-   --  Local variables\n-\n-   W : Natural;\n-   T : Uns;\n-\n-   --  Local ghost variables\n-\n-   Max_W  : constant Natural := Max_Log10 with Ghost;\n-   Big_10 : constant Big_Integer := Big (10) with Ghost;\n-\n-   Pow    : Big_Integer := 1 with Ghost;\n-   T_Init : constant Uns := Uns'Max (Lo, Hi) with Ghost;\n-\n---  Start of processing for System.Width_U\n-\n-begin\n-   if Lo > Hi then\n-      return 0;\n-\n-   else\n-      --  Minimum value is 2, one for space, one for digit\n-\n-      W := 2;\n-\n-      --  Get max of absolute values\n+   pragma Assertion_Policy (Ghost              => Ignore,\n+                            Loop_Invariant     => Ignore,\n+                            Assert             => Ignore,\n+                            Assert_And_Cut     => Ignore,\n+                            Subprogram_Variant => Ignore);\n+\n+   function Width (Lo, Hi : Uns) return Natural is\n+\n+      --  Ghost code, loop invariants and assertions in this unit are meant for\n+      --  analysis only, not for run-time checking, as it would be too costly\n+      --  otherwise. This is enforced by setting the assertion policy to\n+      --  Ignore.\n+\n+      pragma Assertion_Policy (Ghost          => Ignore,\n+                               Loop_Invariant => Ignore,\n+                               Assert         => Ignore);\n+\n+      ------------------\n+      -- Local Lemmas --\n+      ------------------\n+\n+      procedure Lemma_Lower_Mult (A, B, C : Big_Natural)\n+      with\n+        Ghost,\n+        Pre  => A <= B,\n+        Post => A * C <= B * C;\n+\n+      procedure Lemma_Div_Commutation (X, Y : Uns)\n+      with\n+        Ghost,\n+        Pre  => Y /= 0,\n+        Post => Big (X) / Big (Y) = Big (X / Y);\n+\n+      procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive)\n+      with\n+        Ghost,\n+        Post => X / Y / Z = X / (Y * Z);\n+\n+      ----------------------\n+      -- Lemma_Lower_Mult --\n+      ----------------------\n+\n+      procedure Lemma_Lower_Mult (A, B, C : Big_Natural) is null;\n+\n+      ---------------------------\n+      -- Lemma_Div_Commutation --\n+      ---------------------------\n+\n+      procedure Lemma_Div_Commutation (X, Y : Uns) is null;\n+\n+      ---------------------\n+      -- Lemma_Div_Twice --\n+      ---------------------\n+\n+      procedure Lemma_Div_Twice (X : Big_Natural; Y, Z : Big_Positive) is\n+         XY  : constant Big_Natural := X / Y;\n+         YZ  : constant Big_Natural := Y * Z;\n+         XYZ : constant Big_Natural := X / Y / Z;\n+         R   : constant Big_Natural := (XY rem Z) * Y + (X rem Y);\n+      begin\n+         pragma Assert (X = XY * Y + (X rem Y));\n+         pragma Assert (XY = XY / Z * Z + (XY rem Z));\n+         pragma Assert (X = XYZ * YZ + R);\n+         pragma Assert ((XY rem Z) * Y <= (Z - 1) * Y);\n+         pragma Assert (R <= YZ - 1);\n+         pragma Assert (X / YZ = (XYZ * YZ + R) / YZ);\n+         pragma Assert (X / YZ = XYZ + R / YZ);\n+      end Lemma_Div_Twice;\n \n-      T := Uns'Max (Lo, Hi);\n+      --  Local variables\n \n-      --  Increase value if more digits required\n+      W : Natural;\n+      T : Uns;\n \n-      while T >= 10 loop\n-         Lemma_Div_Commutation (T, 10);\n-         Lemma_Div_Twice (Big (T_Init), Big_10 ** (W - 2), Big_10);\n+      --  Local ghost variables\n \n-         T := T / 10;\n-         W := W + 1;\n-         Pow := Pow * 10;\n+      Max_W  : constant Natural := Max_Log10 with Ghost;\n+      Pow    : Big_Integer := 1 with Ghost;\n+      T_Init : constant Uns := Uns'Max (Lo, Hi) with Ghost;\n \n-         pragma Loop_Invariant (W in 3 .. Max_W + 3);\n-         pragma Loop_Invariant (Pow = Big_10 ** (W - 2));\n-         pragma Loop_Invariant (Big (T) = Big (T_Init) / Pow);\n-         pragma Loop_Variant (Decreases => T);\n-      end loop;\n+   --  Start of processing for System.Width_U\n \n-      declare\n-         F : constant Big_Integer := Big_10 ** (W - 2) with Ghost;\n-         Q : constant Big_Integer := Big (T_Init) / F with Ghost;\n-         R : constant Big_Integer := Big (T_Init) rem F with Ghost;\n-      begin\n-         pragma Assert (Q < Big_10);\n-         pragma Assert (Big (T_Init) = Q * F + R);\n-         Lemma_Lower_Mult (Q, Big (9), F);\n-         pragma Assert (Big (T_Init) <= Big (9) * F + F - 1);\n-         pragma Assert (Big (T_Init) < Big_10 * F);\n-         pragma Assert (Big_10 * F = Big_10 ** (W - 1));\n-      end;\n-\n-      --  This is an expression of the functional postcondition for Width_U,\n-      --  which cannot be expressed readily as a postcondition as this would\n-      --  require making the instantiation Unsigned_Conversion and function\n-      --  Big available from the spec.\n-\n-      pragma Assert (Big (Lo) < Big_10 ** (W - 1));\n-      pragma Assert (Big (Hi) < Big_10 ** (W - 1));\n-\n-      return W;\n-   end if;\n+   begin\n+      if Lo > Hi then\n+         return 0;\n+\n+      else\n+         --  Minimum value is 2, one for space, one for digit\n+\n+         W := 2;\n+\n+         --  Get max of absolute values\n+\n+         T := Uns'Max (Lo, Hi);\n+\n+         --  Increase value if more digits required\n+\n+         while T >= 10 loop\n+            Lemma_Div_Commutation (T, 10);\n+            Lemma_Div_Twice (Big (T_Init), Big_10 ** (W - 2), Big_10);\n+\n+            T := T / 10;\n+            W := W + 1;\n+            Pow := Pow * 10;\n+\n+            pragma Loop_Invariant (W in 3 .. Max_W + 2);\n+            pragma Loop_Invariant (Pow = Big_10 ** (W - 2));\n+            pragma Loop_Invariant (Big (T) = Big (T_Init) / Pow);\n+            pragma Loop_Variant (Decreases => T);\n+         end loop;\n+\n+         declare\n+            F : constant Big_Integer := Big_10 ** (W - 2) with Ghost;\n+            Q : constant Big_Integer := Big (T_Init) / F with Ghost;\n+            R : constant Big_Integer := Big (T_Init) rem F with Ghost;\n+         begin\n+            pragma Assert (Q < Big_10);\n+            pragma Assert (Big (T_Init) = Q * F + R);\n+            Lemma_Lower_Mult (Q, Big (9), F);\n+            pragma Assert (Big (T_Init) <= Big (9) * F + F - 1);\n+            pragma Assert (Big (T_Init) < Big_10 * F);\n+            pragma Assert (Big_10 * F = Big_10 ** (W - 1));\n+         end;\n+\n+         return W;\n+      end if;\n+   end Width;\n \n end System.Width_U;"}, {"sha": "7bad3fd758e7822bfaed459deed1ecfd2d4e1e40", "filename": "gcc/ada/libgnat/s-widthu.ads", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widthu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -29,16 +29,59 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n --  Compute Width attribute for non-static type derived from a modular integer\n --  type. The arguments Lo, Hi are the bounds of the type.\n \n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n generic\n \n    type Uns is mod <>;\n \n-function System.Width_U (Lo, Hi : Uns) return Natural\n-with\n-  Post => (if Lo > Hi then\n-             System.Width_U'Result = 0\n-           else\n-             System.Width_U'Result > 0);\n+package System.Width_U\n+  with Pure\n+is\n+   package Unsigned_Conversion is new Unsigned_Conversions (Int => Uns);\n+\n+   function Big (Arg : Uns) return Big_Integer renames\n+     Unsigned_Conversion.To_Big_Integer;\n+\n+   Big_10 : constant Big_Integer := Big (10) with Ghost;\n+\n+   --  Maximum value of exponent for 10 that fits in Uns'Base\n+   function Max_Log10 return Natural is\n+     (case Uns'Base'Size is\n+        when 8   => 2,\n+        when 16  => 4,\n+        when 32  => 9,\n+        when 64  => 19,\n+        when 128 => 38,\n+        when others => raise Program_Error)\n+   with Ghost;\n+\n+   function Width (Lo, Hi : Uns) return Natural\n+   with\n+     Post =>\n+       (declare\n+          W : constant Natural := System.Width_U.Width'Result;\n+        begin\n+          (if Lo > Hi then W = 0\n+           else W > 0\n+             and then W <= Max_Log10 + 2\n+             and then Big (Lo) < Big_10 ** (W - 1)\n+             and then Big (Hi) < Big_10 ** (W - 1)));\n+\n+end System.Width_U;"}, {"sha": "137b8815d94822657b143170fd6d0e9916826fb3", "filename": "gcc/ada/libgnat/s-widuns.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widuns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fd3e3120e83bcd783d5c2443bade7cef20814a/gcc%2Fada%2Flibgnat%2Fs-widuns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widuns.ads?ref=b0fd3e3120e83bcd783d5c2443bade7cef20814a", "patch": "@@ -50,7 +50,9 @@ package System.Wid_Uns\n is\n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n-   function Width_Unsigned is new Width_U (Unsigned);\n-   pragma Pure_Function (Width_Unsigned);\n+   package Width_Uns is new Width_U (Unsigned);\n+\n+   function Width_Unsigned (Lo, Hi : Unsigned) return Natural\n+     renames Width_Uns.Width;\n \n end System.Wid_Uns;"}]}