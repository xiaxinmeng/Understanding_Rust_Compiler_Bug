{"sha": "b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg5ZmZiOTgxMWE3YjNkNDQyYWUxNDRmZjZmNGFiMjMzNjJmMDMxNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-07-20T07:18:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-07-20T07:18:35Z"}, "message": "tree-ssa-sccvn.h (struct vn_nary_op_s): Add next member.\n\n2018-07-20  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.h (struct vn_nary_op_s): Add next member.\n\t(struct vn_phi_s): Likewise.\n\t(struct vn_reference_s): Likewise.\n\t* tree-ssa-sccvn.c (vn_nary_op_hasher::equal): Add shortcut\n\tfor searching the slot of an entry known to be in the hash itself.\n\t(vn_phi_hasher::equal): Likewise.\n\t(vn_reference_hasher::equal): Likewise.\n\t(last_inserted_ref, last_inserted_phi, last_inserted_nary): New\n\tglobals.\n\t(optimistic_info, current_info): Remove, keeping only valid_info.\n\t(vn_reference_lookup_1): Remove fallback lookup.\n\t(vn_reference_lookup_2): Likewise.\n\t(vn_nary_op_lookup_1): Likewise.\n\t(vn_phi_lookup): Likewise.\n\t(vn_nary_build_or_lookup_1): Make sure to not chain the built\n\thash element.\n\t(vn_reference_insert): Adjust, chain the inserted hash element\n\tat last_inserted_ref.\n\t(vn_reference_insert_pieces): Likewise.\n\t(visit_reference_op_call): Likewise.\n\t(vn_nary_op_insert_into): Chain the inserted hash element at\n\tlast_inserted_nary.\n\t(vn_nary_op_insert_pieces): Adjust.\n\t(vn_nary_op_insert): Likewise.\n\t(vn_nary_op_insert_stmt): Likewise.\n\t(vn_phi_insert): Adjust, chain the inserted hash element at\n\tlast_inserted_phi.\n\t(process_scc): Remove clearing and copying the optimistic\n\ttable.  Instead remove elements inserted during an optimistic\n\titeration from the single table we maintain.\n\t(init_scc_vn): Adjust.\n\t(free_scc_vn): Likewise.\n\t(sccvn_dom_walker::record_cond): Likewise.\n\t(sccvn_dom_walker::after_dom_children): Likewise.\n\nFrom-SVN: r262899", "tree": {"sha": "36a2dc027309b10955e17089051504ce5b96f076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36a2dc027309b10955e17089051504ce5b96f076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b0df776fa87c7515710f11e76c5a63a60d2c88f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0df776fa87c7515710f11e76c5a63a60d2c88f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0df776fa87c7515710f11e76c5a63a60d2c88f"}], "stats": {"total": 200, "additions": 110, "deletions": 90}, "files": [{"sha": "8733357a9cdd1762d137fe81ab2526d36a0d99b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "patch": "@@ -1,3 +1,40 @@\n+2018-07-20  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.h (struct vn_nary_op_s): Add next member.\n+\t(struct vn_phi_s): Likewise.\n+\t(struct vn_reference_s): Likewise.\n+\t* tree-ssa-sccvn.c (vn_nary_op_hasher::equal): Add shortcut\n+\tfor searching the slot of an entry known to be in the hash itself.\n+\t(vn_phi_hasher::equal): Likewise.\n+\t(vn_reference_hasher::equal): Likewise.\n+\t(last_inserted_ref, last_inserted_phi, last_inserted_nary): New\n+\tglobals.\n+\t(optimistic_info, current_info): Remove, keeping only valid_info.\n+\t(vn_reference_lookup_1): Remove fallback lookup.\n+\t(vn_reference_lookup_2): Likewise.\n+\t(vn_nary_op_lookup_1): Likewise.\n+\t(vn_phi_lookup): Likewise.\n+\t(vn_nary_build_or_lookup_1): Make sure to not chain the built\n+\thash element.\n+\t(vn_reference_insert): Adjust, chain the inserted hash element\n+\tat last_inserted_ref.\n+\t(vn_reference_insert_pieces): Likewise.\n+\t(visit_reference_op_call): Likewise.\n+\t(vn_nary_op_insert_into): Chain the inserted hash element at\n+\tlast_inserted_nary.\n+\t(vn_nary_op_insert_pieces): Adjust.\n+\t(vn_nary_op_insert): Likewise.\n+\t(vn_nary_op_insert_stmt): Likewise.\n+\t(vn_phi_insert): Adjust, chain the inserted hash element at\n+\tlast_inserted_phi.\n+\t(process_scc): Remove clearing and copying the optimistic\n+\ttable.  Instead remove elements inserted during an optimistic\n+\titeration from the single table we maintain.\n+\t(init_scc_vn): Adjust.\n+\t(free_scc_vn): Likewise.\n+\t(sccvn_dom_walker::record_cond): Likewise.\n+\t(sccvn_dom_walker::after_dom_children): Likewise.\n+\n 2018-07-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/84047"}, {"sha": "833291a57a662730250b95d7e11384447380330c", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 70, "deletions": 90, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "patch": "@@ -156,7 +156,7 @@ vn_nary_op_hasher::hash (const vn_nary_op_s *vno1)\n inline bool\n vn_nary_op_hasher::equal (const vn_nary_op_s *vno1, const vn_nary_op_s *vno2)\n {\n-  return vn_nary_op_eq (vno1, vno2);\n+  return vno1 == vno2 || vn_nary_op_eq (vno1, vno2);\n }\n \n typedef hash_table<vn_nary_op_hasher> vn_nary_op_table_type;\n@@ -187,7 +187,7 @@ vn_phi_hasher::hash (const vn_phi_s *vp1)\n inline bool\n vn_phi_hasher::equal (const vn_phi_s *vp1, const vn_phi_s *vp2)\n {\n-  return vn_phi_eq (vp1, vp2);\n+  return vp1 == vp2 || vn_phi_eq (vp1, vp2);\n }\n \n typedef hash_table<vn_phi_hasher> vn_phi_table_type;\n@@ -242,7 +242,7 @@ vn_reference_hasher::hash (const vn_reference_s *vr1)\n inline bool\n vn_reference_hasher::equal (const vn_reference_s *v, const vn_reference_s *c)\n {\n-  return vn_reference_eq (v, c);\n+  return v == c || vn_reference_eq (v, c);\n }\n \n typedef hash_table<vn_reference_hasher> vn_reference_table_type;\n@@ -295,19 +295,14 @@ static obstack vn_tables_obstack;\n /* Special obstack we never unwind.  */\n static obstack vn_tables_insert_obstack;\n \n+static vn_reference_t last_inserted_ref;\n+static vn_phi_t last_inserted_phi;\n+static vn_nary_op_t last_inserted_nary;\n+\n /* Valid hashtables storing information we have proven to be\n    correct.  */\n static vn_tables_t valid_info;\n \n-/* Optimistic hashtables storing information we are making assumptions about\n-   during iterations.  */\n-static vn_tables_t optimistic_info;\n-\n-/* Pointer to the set of hashtables that is currently being used.\n-   Should always point to either the optimistic_info, or the\n-   valid_info.  */\n-static vn_tables_t current_info;\n-\n \n /* Reverse post order index for each basic block.  */\n static int *rpo_numbers;\n@@ -1548,9 +1543,7 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n   hashval_t hash;\n \n   hash = vr->hashcode;\n-  slot = current_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n+  slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     {\n       if (vnresult)\n@@ -1589,9 +1582,7 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,\n     vr->hashcode = vr->hashcode + SSA_NAME_VERSION (vr->vuse);\n \n   hash = vr->hashcode;\n-  slot = current_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n+  slot = valid_info->references->find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     return *slot;\n \n@@ -1735,7 +1726,7 @@ vn_nary_build_or_lookup_1 (gimple_match_op *res_op, bool insert)\n \t optimistic table gets cleared after each iteration).\n \t We do not need to insert into the optimistic table, as\n \t lookups there will fall back to the valid table.  */\n-      else if (current_info == optimistic_info)\n+      else\n \t{\n \t  unsigned int length = vn_nary_length_from_stmt (new_stmt);\n \t  vn_nary_op_t vno1\n@@ -1745,9 +1736,10 @@ vn_nary_build_or_lookup_1 (gimple_match_op *res_op, bool insert)\n \t  vno1->result = result;\n \t  init_vn_nary_op_from_stmt (vno1, new_stmt);\n \t  vn_nary_op_insert_into (vno1, valid_info->nary, true);\n+\t  /* Also do not link it into the undo chain.  */\n+\t  last_inserted_nary = vno1->next;\n+\t  vno1->next = (vn_nary_op_t)(void *)-1;\n \t}\n-      else\n-\tvn_nary_op_insert_stmt (new_stmt, result);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Inserting name \");\n@@ -2624,7 +2616,7 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n   vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n   vr1->result_vdef = vdef;\n \n-  slot = current_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n+  slot = valid_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n \t\t\t\t\t\t\tINSERT);\n \n   /* Because we lookup stores using vuses, and value number failures\n@@ -2640,6 +2632,8 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n     free_reference (*slot);\n \n   *slot = vr1;\n+  vr1->next = last_inserted_ref;\n+  last_inserted_ref = vr1;\n   return vr1;\n }\n \n@@ -2667,7 +2661,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n     result = SSA_VAL (result);\n   vr1->result = result;\n \n-  slot = current_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n+  slot = valid_info->references->find_slot_with_hash (vr1, vr1->hashcode,\n \t\t\t\t\t\t\tINSERT);\n \n   /* At this point we should have all the things inserted that we have\n@@ -2678,6 +2672,8 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n     free_reference (*slot);\n \n   *slot = vr1;\n+  vr1->next = last_inserted_ref;\n+  last_inserted_ref = vr1;\n   return vr1;\n }\n \n@@ -2849,10 +2845,7 @@ vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)\n     *vnresult = NULL;\n \n   vno->hashcode = vn_nary_op_compute_hash (vno);\n-  slot = current_info->nary->find_slot_with_hash (vno, vno->hashcode,\n-\t\t\t\t\t\t  NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = valid_info->nary->find_slot_with_hash (vno, vno->hashcode,\n+  slot = valid_info->nary->find_slot_with_hash (vno, vno->hashcode,\n \t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -2956,6 +2949,8 @@ vn_nary_op_insert_into (vn_nary_op_t vno, vn_nary_op_table_type *table,\n   gcc_assert (!*slot);\n \n   *slot = vno;\n+  vno->next = last_inserted_nary;\n+  last_inserted_nary = vno;\n   return vno;\n }\n \n@@ -2970,7 +2965,7 @@ vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,\n {\n   vn_nary_op_t vno1 = alloc_vn_nary_op (length, result, value_id);\n   init_vn_nary_op_from_pieces (vno1, length, code, type, ops);\n-  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n+  return vn_nary_op_insert_into (vno1, valid_info->nary, true);\n }\n \n /* Insert OP into the current hash table with a value number of\n@@ -2985,7 +2980,7 @@ vn_nary_op_insert (tree op, tree result)\n \n   vno1 = alloc_vn_nary_op (length, result, VN_INFO (result)->value_id);\n   init_vn_nary_op_from_op (vno1, op);\n-  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n+  return vn_nary_op_insert_into (vno1, valid_info->nary, true);\n }\n \n /* Insert the rhs of STMT into the current hash table with a value number of\n@@ -2998,7 +2993,7 @@ vn_nary_op_insert_stmt (gimple *stmt, tree result)\n     = alloc_vn_nary_op (vn_nary_length_from_stmt (stmt),\n \t\t\tresult, VN_INFO (result)->value_id);\n   init_vn_nary_op_from_stmt (vno1, stmt);\n-  return vn_nary_op_insert_into (vno1, current_info->nary, true);\n+  return vn_nary_op_insert_into (vno1, valid_info->nary, true);\n }\n \n /* Compute a hashcode for PHI operation VP1 and return it.  */\n@@ -3206,10 +3201,7 @@ vn_phi_lookup (gimple *phi)\n \tvp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n       }\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n-  slot = current_info->phis->find_slot_with_hash (vp1, vp1->hashcode,\n-\t\t\t\t\t\t  NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = valid_info->phis->find_slot_with_hash (vp1, vp1->hashcode,\n+  slot = valid_info->phis->find_slot_with_hash (vp1, vp1->hashcode,\n \t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -3253,11 +3245,13 @@ vn_phi_insert (gimple *phi, tree result)\n   vp1->result = result;\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n \n-  slot = current_info->phis->find_slot_with_hash (vp1, vp1->hashcode, INSERT);\n+  slot = valid_info->phis->find_slot_with_hash (vp1, vp1->hashcode, INSERT);\n \n   /* Because we iterate over phi operations more than once, it's\n      possible the slot might already exist here, hence no assert.*/\n   *slot = vp1;\n+  vp1->next = last_inserted_phi;\n+  last_inserted_phi = vp1;\n   return vp1;\n }\n \n@@ -3778,10 +3772,12 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       vr2->result_vdef = vdef_val;\n-      slot = current_info->references->find_slot_with_hash (vr2, vr2->hashcode,\n+      slot = valid_info->references->find_slot_with_hash (vr2, vr2->hashcode,\n \t\t\t\t\t\t\t    INSERT);\n       gcc_assert (!*slot);\n       *slot = vr2;\n+      vr2->next = last_inserted_ref;\n+      last_inserted_ref = vr2;\n     }\n \n   return changed;\n@@ -4312,12 +4308,6 @@ process_scc (vec<tree> scc)\n   unsigned int i;\n   unsigned int iterations = 0;\n   bool changed = true;\n-  vn_nary_op_iterator_type hin;\n-  vn_phi_iterator_type hip;\n-  vn_reference_iterator_type hir;\n-  vn_nary_op_t nary;\n-  vn_phi_t phi;\n-  vn_reference_t ref;\n \n   /* If the SCC has a single member, just visit it.  */\n   if (scc.length () == 1)\n@@ -4344,7 +4334,6 @@ process_scc (vec<tree> scc)\n \n   /* Iterate over the SCC with the optimistic table until it stops\n      changing.  */\n-  current_info = optimistic_info;\n   while (changed)\n     {\n       changed = false;\n@@ -4354,62 +4343,55 @@ process_scc (vec<tree> scc)\n       /* As we are value-numbering optimistically we have to\n \t clear the expression tables and the simplified expressions\n \t in each iteration until we converge.  */\n-      gcc_assert (optimistic_info->nary->elements () == 0\n-\t\t  && optimistic_info->phis->elements () == 0\n-\t\t  && optimistic_info->references->elements () == 0);\n       void *ob_top = obstack_alloc (&vn_tables_obstack, 0);\n+      vn_reference_t ref_top = last_inserted_ref;\n+      vn_phi_t phi_top = last_inserted_phi;\n+      vn_nary_op_t nary_top = last_inserted_nary;\n       FOR_EACH_VEC_ELT (scc, i, var)\n \tgcc_assert (!VN_INFO (var)->needs_insertion\n \t\t    && VN_INFO (var)->expr == NULL);\n       FOR_EACH_VEC_ELT (scc, i, var)\n \tchanged |= visit_use (var);\n       if (changed)\n \t{\n-\t  optimistic_info->nary->empty ();\n-\t  optimistic_info->phis->empty ();\n-\t  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->references,\n-\t\t\t\t       ref, vn_reference_t, hir)\n+\t  for (; last_inserted_nary != nary_top;\n+\t       last_inserted_nary = last_inserted_nary->next)\n+\t    {\n+\t      vn_nary_op_t *slot;\n+\t      slot = valid_info->nary->find_slot_with_hash (last_inserted_nary,\n+\t\t\t\t\t\t       last_inserted_nary->hashcode,\n+\t\t\t\t\t\t       NO_INSERT);\n+\t      gcc_assert (slot);\n+\t      valid_info->nary->clear_slot (slot);\n+\t    }\n+\t  for (; last_inserted_phi != phi_top;\n+\t       last_inserted_phi = last_inserted_phi->next)\n \t    {\n-\t      ref->operands.release ();\n-\t      optimistic_info->references->clear_slot (&*hir);\n+\t      vn_phi_t *slot;\n+\t      slot = valid_info->phis->find_slot_with_hash (last_inserted_phi,\n+\t\t\t\t\t\t       last_inserted_phi->hashcode,\n+\t\t\t\t\t\t       NO_INSERT);\n+\t      gcc_assert (slot);\n+\t      valid_info->phis->clear_slot (slot);\n+\t    }\n+\t  for (; last_inserted_ref != ref_top;\n+\t       last_inserted_ref = last_inserted_ref->next)\n+\t    {\n+\t      vn_reference_t *slot;\n+\t      slot = valid_info->references->find_slot_with_hash (last_inserted_ref,\n+\t\t\t\t\t\t       last_inserted_ref->hashcode,\n+\t\t\t\t\t\t       NO_INSERT);\n+\t      gcc_assert (slot);\n+\t      (*slot)->operands.release ();\n+\t      valid_info->references->clear_slot (slot);\n \t    }\n-\t  optimistic_info->references->empty ();\n \t  obstack_free (&vn_tables_obstack, ob_top);\n \t}\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Processing SCC needed %d iterations\\n\", iterations);\n   statistics_histogram_event (cfun, \"SCC iterations\", iterations);\n-\n-  /* Finally, move the contents of the no longer used optimistic\n-     table to the valid table and clear the optimistic table.  */\n-  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->nary, nary, vn_nary_op_t, hin)\n-    {\n-      optimistic_info->nary->clear_slot (&*hin);\n-      vn_nary_op_insert_into (nary, valid_info->nary, false);\n-    }\n-  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->phis, phi, vn_phi_t, hip)\n-    {\n-      optimistic_info->phis->clear_slot (&*hip);\n-      vn_phi_s **slot\n-\t= valid_info->phis->find_slot_with_hash (phi, phi->hashcode, INSERT);\n-      gcc_assert (!*slot);\n-      *slot = phi;\n-    }\n-  FOR_EACH_HASH_TABLE_ELEMENT (*optimistic_info->references,\n-\t\t\t       ref, vn_reference_t, hir)\n-    {\n-      optimistic_info->references->clear_slot (&*hir);\n-      vn_reference_s **slot\n-\t= valid_info->references->find_slot_with_hash (ref, ref->hashcode,\n-\t\t\t\t\t\t       INSERT);\n-      if (*slot)\n-\tfree_reference (*slot);\n-      *slot = ref;\n-    }\n-\n-  current_info = valid_info;\n }\n \n \n@@ -4634,9 +4616,9 @@ init_scc_vn (void)\n   gcc_obstack_init (&vn_tables_insert_obstack);\n   valid_info = XCNEW (struct vn_tables_s);\n   allocate_vn_table (valid_info);\n-  optimistic_info = XCNEW (struct vn_tables_s);\n-  allocate_vn_table (optimistic_info);\n-  current_info = valid_info;\n+  last_inserted_ref = NULL;\n+  last_inserted_phi = NULL;\n+  last_inserted_nary = NULL;\n \n   /* Create the VN_INFO structures, and initialize value numbers to\n      TOP or VARYING for parameters.  */\n@@ -4749,8 +4731,6 @@ free_scc_vn (void)\n   sccstack.release ();\n   free_vn_table (valid_info);\n   XDELETE (valid_info);\n-  free_vn_table (optimistic_info);\n-  XDELETE (optimistic_info);\n   obstack_free (&vn_tables_obstack, NULL);\n   obstack_free (&vn_tables_insert_obstack, NULL);\n \n@@ -4824,7 +4804,7 @@ sccvn_dom_walker::record_cond (basic_block bb,\n   tree ops[2] = { lhs, rhs };\n   vn_nary_op_t old = NULL;\n   if (vn_nary_op_lookup_pieces (2, code, boolean_type_node, ops, &old))\n-    current_info->nary->remove_elt_with_hash (old, old->hashcode);\n+    valid_info->nary->remove_elt_with_hash (old, old->hashcode);\n   vn_nary_op_t cond\n     = vn_nary_op_insert_pieces (2, code, boolean_type_node, ops,\n \t\t\t\tvalue\n@@ -4890,9 +4870,9 @@ sccvn_dom_walker::after_dom_children (basic_block bb)\n     {\n       vn_nary_op_t cond = cond_stack.last ().second.first;\n       vn_nary_op_t old = cond_stack.last ().second.second;\n-      current_info->nary->remove_elt_with_hash (cond, cond->hashcode);\n+      valid_info->nary->remove_elt_with_hash (cond, cond->hashcode);\n       if (old)\n-\tvn_nary_op_insert_into (old, current_info->nary, false);\n+\tvn_nary_op_insert_into (old, valid_info->nary, false);\n       cond_stack.pop ();\n     }\n }"}, {"sha": "323c85fde5509c95e92388acff8bbe91c04608cf", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b89ffb9811a7b3d442ae144ff6f4ab23362f0314/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=b89ffb9811a7b3d442ae144ff6f4ab23362f0314", "patch": "@@ -35,6 +35,7 @@ extern tree VN_TOP;\n \n typedef struct vn_nary_op_s\n {\n+  vn_nary_op_s *next;\n   /* Unique identify that all expressions with the same value have. */\n   unsigned int value_id;\n   ENUM_BITFIELD(tree_code) opcode : 16;\n@@ -62,6 +63,7 @@ sizeof_vn_nary_op (unsigned int length)\n \n typedef struct vn_phi_s\n {\n+  vn_phi_s *next;\n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n   hashval_t hashcode;\n@@ -116,6 +118,7 @@ vn_ref_op_align_unit (vn_reference_op_t op)\n \n typedef struct vn_reference_s\n {\n+  vn_reference_s *next;\n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n   hashval_t hashcode;"}]}