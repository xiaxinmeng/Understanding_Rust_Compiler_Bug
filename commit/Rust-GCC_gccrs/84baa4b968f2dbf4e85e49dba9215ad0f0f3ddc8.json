{"sha": "84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiYWE0Yjk2OGYyZGJmNGU4NWU0OWRiYTkyMTVhZDBmMGYzZGRjOA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-06-24T13:21:53Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-06-24T13:21:53Z"}, "message": "allow storing values directly in hash tables\n\ngcc/\n\n\t* hash-table.h: Add a template arg to choose between storing values\n\tand storing pointers to values, and then provide partial\n\tspecializations for both.\n\t* tree-browser.c (tree_upper_hasher): Provide the type the hash table\n\tshould store, not the type values should point to.\n\t* tree-into-ssa.c (var_info_hasher): Likewise.\n\t* tree-ssa-dom.c (expr_elt_hasher): Likewise.\n\t* tree-complex.c: Adjust.\n\t* tree-hasher.h (int_tree_hasher): store int_tree_map in the hash\n\ttable instead of int_tree_map *.\n\t* tree-parloops.c: Adjust.\n\t* tree-ssa-reassoc.c (ocount_hasher): Don't lie to hash_map about what\n\ttype is being stored.\n\t* tree-vectorizer.c: Adjust.\n\nFrom-SVN: r211937", "tree": {"sha": "8527b8e2f9f9bb9c3a525567a8e393965e2ad66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8527b8e2f9f9bb9c3a525567a8e393965e2ad66c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/comments", "author": null, "committer": null, "parents": [{"sha": "c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c203e8a73b2f12a1da52a16a0c4a50e62b42445b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c203e8a73b2f12a1da52a16a0c4a50e62b42445b"}], "stats": {"total": 921, "additions": 800, "deletions": 121}, "files": [{"sha": "bf1a716e751c1567837738bd1d1d77e78cb6cb49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -1,3 +1,20 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-table.h: Add a template arg to choose between storing values\n+\tand storing pointers to values, and then provide partial\n+\tspecializations for both.\n+\t* tree-browser.c (tree_upper_hasher): Provide the type the hash table\n+\tshould store, not the type values should point to.\n+\t* tree-into-ssa.c (var_info_hasher): Likewise.\n+\t* tree-ssa-dom.c (expr_elt_hasher): Likewise.\n+\t* tree-complex.c: Adjust.\n+\t* tree-hasher.h (int_tree_hasher): store int_tree_map in the hash\n+\ttable instead of int_tree_map *.\n+\t* tree-parloops.c: Adjust.\n+\t* tree-ssa-reassoc.c (ocount_hasher): Don't lie to hash_map about what\n+\ttype is being stored.\n+\t* tree-vectorizer.c: Adjust.\n+\n 2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* hash-table.h: Remove a layer of indirection from hash_table so that"}, {"sha": "22af12f996c146cf7b3e41b5037a052f7f9474fb", "filename": "gcc/hash-table.h", "status": "modified", "additions": 695, "deletions": 30, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -272,29 +272,28 @@ typed_noop_remove <Type>::remove (Type *p ATTRIBUTE_UNUSED)\n template <typename Type>\n struct pointer_hash : typed_noop_remove <Type>\n {\n-  typedef Type value_type;\n-  typedef Type compare_type;\n+  typedef Type *value_type;\n+  typedef Type *compare_type;\n+  typedef int store_values_directly;\n \n-  static inline hashval_t\n-  hash (const value_type *);\n+  static inline hashval_t hash (const value_type &);\n \n-  static inline int\n-  equal (const value_type *existing, const compare_type *candidate);\n+  static inline bool equal (const value_type &existing, const compare_type &candidate);\n };\n \n template <typename Type>\n inline hashval_t\n-pointer_hash <Type>::hash (const value_type *candidate)\n+pointer_hash <Type>::hash (const value_type &candidate)\n {\n   /* This is a really poor hash function, but it is what the current code uses,\n      so I am reusing it to avoid an additional axis in testing.  */\n   return (hashval_t) ((intptr_t)candidate >> 3);\n }\n \n template <typename Type>\n-inline int\n-pointer_hash <Type>::equal (const value_type *existing,\n-\t\t\t   const compare_type *candidate)\n+inline bool\n+pointer_hash <Type>::equal (const value_type &existing,\n+\t\t\t   const compare_type &candidate)\n {\n   return existing == candidate;\n }\n@@ -319,10 +318,147 @@ extern unsigned int hash_table_higher_prime_index (unsigned long n);\n extern hashval_t hash_table_mod1 (hashval_t hash, unsigned int index);\n extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n \n+/* The below is some template meta programming to decide if we should use the\n+   hash table partial specialization that directly stores value_type instead of\n+   pointers to value_type.  If the Descriptor type defines the type\n+   Descriptor::store_values_directly then values are stored directly otherwise\n+   pointers to them are stored.  */\n+template<typename T> struct notype { typedef void type; };\n+\n+template<typename T, typename = void>\n+struct storage_tester\n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct storage_tester<T, typename notype<typename\n+\t\t\t\t\t T::store_values_directly>::type>\n+{\n+  static const bool value = true;\n+};\n+\n+ template<typename Traits>\n+ struct has_is_deleted\n+{\n+  template<typename U, bool (*)(U &)> struct helper {};\n+  template<typename U> static char test (helper<U, U::is_deleted> *);\n+  template<typename U> static int test (...);\n+  static const bool value = sizeof (test<Traits> (0)) == sizeof (char);\n+};\n+\n+template<typename Type, typename Traits, bool = has_is_deleted<Traits>::value>\n+struct is_deleted_helper\n+{\n+  static inline bool\n+  call (Type &v)\n+  {\n+    return Traits::is_deleted (v);\n+  }\n+};\n+\n+template<typename Type, typename Traits>\n+struct is_deleted_helper<Type *, Traits, false>\n+{\n+  static inline bool\n+  call (Type *v)\n+  {\n+    return v == HTAB_DELETED_ENTRY;\n+  }\n+};\n+\n+ template<typename Traits>\n+ struct has_is_empty\n+{\n+  template<typename U, bool (*)(U &)> struct helper {};\n+  template<typename U> static char test (helper<U, U::is_empty> *);\n+  template<typename U> static int test (...);\n+  static const bool value = sizeof (test<Traits> (0)) == sizeof (char);\n+};\n+\n+template<typename Type, typename Traits, bool = has_is_deleted<Traits>::value>\n+struct is_empty_helper\n+{\n+  static inline bool\n+  call (Type &v)\n+  {\n+    return Traits::is_empty (v);\n+  }\n+};\n+\n+template<typename Type, typename Traits>\n+struct is_empty_helper<Type *, Traits, false>\n+{\n+  static inline bool\n+  call (Type *v)\n+  {\n+    return v == HTAB_EMPTY_ENTRY;\n+  }\n+};\n+\n+ template<typename Traits>\n+ struct has_mark_deleted\n+{\n+  template<typename U, void (*)(U &)> struct helper {};\n+  template<typename U> static char test (helper<U, U::mark_deleted> *);\n+  template<typename U> static int test (...);\n+  static const bool value = sizeof (test<Traits> (0)) == sizeof (char);\n+};\n+\n+template<typename Type, typename Traits, bool = has_is_deleted<Traits>::value>\n+struct mark_deleted_helper\n+{\n+  static inline void\n+  call (Type &v)\n+  {\n+    Traits::mark_deleted (v);\n+  }\n+};\n+\n+template<typename Type, typename Traits>\n+struct mark_deleted_helper<Type *, Traits, false>\n+{\n+  static inline void\n+  call (Type *&v)\n+  {\n+    v = static_cast<Type *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n+ template<typename Traits>\n+ struct has_mark_empty\n+{\n+  template<typename U, void (*)(U &)> struct helper {};\n+  template<typename U> static char test (helper<U, U::mark_empty> *);\n+  template<typename U> static int test (...);\n+  static const bool value = sizeof (test<Traits> (0)) == sizeof (char);\n+};\n+\n+template<typename Type, typename Traits, bool = has_is_deleted<Traits>::value>\n+struct mark_empty_helper\n+{\n+  static inline void\n+  call (Type &v)\n+  {\n+    Traits::mark_empty (v);\n+  }\n+};\n+\n+template<typename Type, typename Traits>\n+struct mark_empty_helper<Type *, Traits, false>\n+{\n+  static inline void\n+  call (Type *&v)\n+  {\n+    v = static_cast<Type *> (HTAB_EMPTY_ENTRY);\n+  }\n+};\n \n /* User-facing hash table type.\n \n-   The table stores elements of type Descriptor::value_type.\n+   The table stores elements of type Descriptor::value_type, or pointers to\n+   objects of type value_type if the descriptor does not define the type\n+   store_values_directly.\n \n    It hashes values with the hash member function.\n      The table currently works with relatively weak hash functions.\n@@ -340,10 +476,20 @@ extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n    Specify the template Allocator to allocate and free memory.\n      The default is xcallocator.\n \n+     Storage is an implementation detail and should not be used outside the\n+     hash table code.\n+\n */\n template <typename Descriptor,\n-\t template<typename Type> class Allocator= xcallocator>\n+\t template<typename Type> class Allocator= xcallocator,\n+\t bool Storage = storage_tester<Descriptor>::value>\n class hash_table\n+{\n+};\n+\n+template <typename Descriptor,\n+\t template<typename Type> class Allocator>\n+class hash_table<Descriptor, Allocator, false>\n {\n   typedef typename Descriptor::value_type value_type;\n   typedef typename Descriptor::compare_type compare_type;\n@@ -428,7 +574,7 @@ class hash_table\n     iterator (value_type **slot, value_type **limit) :\n       m_slot (slot), m_limit (limit) {}\n \n-    inline value_type &operator * () { return **m_slot; }\n+    inline value_type *operator * () { return *m_slot; }\n     void slide ();\n     inline iterator &operator ++ ();\n     bool operator != (const iterator &other) const\n@@ -485,7 +631,7 @@ class hash_table\n };\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::hash_table (size_t size) :\n+hash_table<Descriptor, Allocator, false>::hash_table (size_t size) :\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0)\n {\n   unsigned int size_prime_index;\n@@ -500,7 +646,7 @@ hash_table<Descriptor, Allocator>::hash_table (size_t size) :\n }\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::~hash_table ()\n+hash_table<Descriptor, Allocator, false>::~hash_table ()\n {\n   for (size_t i = m_size - 1; i < m_size; i--)\n     if (m_entries[i] != HTAB_EMPTY_ENTRY && m_entries[i] != HTAB_DELETED_ENTRY)\n@@ -518,7 +664,8 @@ hash_table<Descriptor, Allocator>::~hash_table ()\n \n template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type **\n-hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n+hash_table<Descriptor, Allocator, false>\n+::find_empty_slot_for_expand (hashval_t hash)\n {\n   hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n   size_t size = m_size;\n@@ -554,7 +701,7 @@ hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n \n \t  template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::expand ()\n+hash_table<Descriptor, Allocator, false>::expand ()\n {\n   value_type **oentries = m_entries;\n   unsigned int oindex = m_size_prime_index;\n@@ -606,7 +753,7 @@ hash_table<Descriptor, Allocator>::expand ()\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::empty ()\n+hash_table<Descriptor, Allocator, false>::empty ()\n {\n   size_t size = m_size;\n   value_type **entries = m_entries;\n@@ -639,7 +786,7 @@ hash_table<Descriptor, Allocator>::empty ()\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::clear_slot (value_type **slot)\n+hash_table<Descriptor, Allocator, false>::clear_slot (value_type **slot)\n {\n   if (slot < m_entries || slot >= m_entries + size ()\n       || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n@@ -657,7 +804,7 @@ hash_table<Descriptor, Allocator>::clear_slot (value_type **slot)\n \n template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type *\n-hash_table<Descriptor, Allocator>\n+hash_table<Descriptor, Allocator, false>\n ::find_with_hash (const compare_type *comparable, hashval_t hash)\n {\n   m_searches++;\n@@ -695,7 +842,7 @@ ::find_with_hash (const compare_type *comparable, hashval_t hash)\n \n template<typename Descriptor, template<typename Type> class Allocator>\n typename Descriptor::value_type **\n-hash_table<Descriptor, Allocator>\n+hash_table<Descriptor, Allocator, false>\n ::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n@@ -756,7 +903,7 @@ ::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>\n+hash_table<Descriptor, Allocator, false>\n ::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)\n {\n   value_type **slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n@@ -773,12 +920,11 @@ ::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)\n    each live entry.  If CALLBACK returns false, the iteration stops.\n    ARGUMENT is passed as CALLBACK's second argument. */\n \n-template<typename Descriptor,\n-\t  template<typename Type> class Allocator>\n+template<typename Descriptor, template<typename Type> class Allocator>\n template<typename Argument,\n \t  int (*Callback) (typename Descriptor::value_type **slot, Argument argument)>\n void\n-hash_table<Descriptor, Allocator>::traverse_noresize (Argument argument)\n+hash_table<Descriptor, Allocator, false>::traverse_noresize (Argument argument)\n {\n   value_type **slot = m_entries;\n   value_type **limit = slot + size ();\n@@ -803,7 +949,7 @@ template <typename Argument,\n \t  int (*Callback) (typename Descriptor::value_type **slot,\n \t\t\t   Argument argument)>\n void\n-hash_table<Descriptor, Allocator>::traverse (Argument argument)\n+hash_table<Descriptor, Allocator, false>::traverse (Argument argument)\n {\n   size_t size = m_size;\n   if (elements () * 8 < size && size > 32)\n@@ -816,7 +962,7 @@ hash_table<Descriptor, Allocator>::traverse (Argument argument)\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator>::iterator::slide ()\n+hash_table<Descriptor, Allocator, false>::iterator::slide ()\n {\n   for ( ; m_slot < m_limit; ++m_slot )\n     {\n@@ -831,8 +977,527 @@ hash_table<Descriptor, Allocator>::iterator::slide ()\n /* Bump the iterator.  */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator>::iterator &\n-hash_table<Descriptor, Allocator>::iterator::operator ++ ()\n+inline typename hash_table<Descriptor, Allocator, false>::iterator &\n+hash_table<Descriptor, Allocator, false>::iterator::operator ++ ()\n+{\n+  ++m_slot;\n+  slide ();\n+  return *this;\n+}\n+\n+/* A partial specialization used when values should be stored directly.  */\n+\n+template <typename Descriptor,\n+\t template<typename Type> class Allocator>\n+class hash_table<Descriptor, Allocator, true>\n+{\n+  typedef typename Descriptor::value_type value_type;\n+  typedef typename Descriptor::compare_type compare_type;\n+\n+public:\n+  hash_table (size_t);\n+  ~hash_table ();\n+\n+  /* Current size (in entries) of the hash table.  */\n+  size_t size () const { return m_size; }\n+\n+  /* Return the current number of elements in this hash table. */\n+  size_t elements () const { return m_n_elements - m_n_deleted; }\n+\n+  /* Return the current number of elements in this hash table. */\n+  size_t elements_with_deleted () const { return m_n_elements; }\n+\n+  /* This function clears all entries in the given hash table.  */\n+  void empty ();\n+\n+  /* This function clears a specified SLOT in a hash table.  It is\n+     useful when you've already done the lookup and don't want to do it\n+     again. */\n+\n+  void clear_slot (value_type *);\n+\n+  /* This function searches for a hash table entry equal to the given\n+     COMPARABLE element starting with the given HASH value.  It cannot\n+     be used to insert or delete an element. */\n+  value_type &find_with_hash (const compare_type &, hashval_t);\n+\n+/* Like find_slot_with_hash, but compute the hash value from the element.  */\n+  value_type &find (const value_type &value)\n+    {\n+      return find_with_hash (value, Descriptor::hash (value));\n+    }\n+\n+  value_type *find_slot (const value_type &value, insert_option insert)\n+    {\n+      return find_slot_with_hash (value, Descriptor::hash (value), insert);\n+    }\n+\n+  /* This function searches for a hash table slot containing an entry\n+     equal to the given COMPARABLE element and starting with the given\n+     HASH.  To delete an entry, call this with insert=NO_INSERT, then\n+     call clear_slot on the slot returned (possibly after doing some\n+     checks).  To insert an entry, call this with insert=INSERT, then\n+     write the value you want into the returned slot.  When inserting an\n+     entry, NULL may be returned if memory allocation fails. */\n+  value_type *find_slot_with_hash (const compare_type &comparable,\n+\t\t\t\t    hashval_t hash, enum insert_option insert);\n+\n+  /* This function deletes an element with the given COMPARABLE value\n+     from hash table starting with the given HASH.  If there is no\n+     matching element in the hash table, this function does nothing. */\n+  void remove_elt_with_hash (const compare_type &, hashval_t);\n+\n+/* Like remove_elt_with_hash, but compute the hash value from the element.  */\n+  void remove_elt (const value_type &value)\n+    {\n+      remove_elt_with_hash (value, Descriptor::hash (value));\n+    }\n+\n+  /* This function scans over the entire hash table calling CALLBACK for\n+     each live entry.  If CALLBACK returns false, the iteration stops.\n+     ARGUMENT is passed as CALLBACK's second argument. */\n+  template <typename Argument,\n+\t    int (*Callback) (value_type *slot, Argument argument)>\n+  void traverse_noresize (Argument argument);\n+\n+  /* Like traverse_noresize, but does resize the table when it is too empty\n+     to improve effectivity of subsequent calls.  */\n+  template <typename Argument,\n+\t    int (*Callback) (value_type *slot, Argument argument)>\n+  void traverse (Argument argument);\n+\n+  class iterator\n+  {\n+  public:\n+    iterator () : m_slot (NULL), m_limit (NULL) {}\n+\n+    iterator (value_type *slot, value_type *limit) :\n+      m_slot (slot), m_limit (limit) {}\n+\n+    inline value_type &operator * () { return *m_slot; }\n+    void slide ();\n+    inline iterator &operator ++ ();\n+    bool operator != (const iterator &other) const\n+      {\n+\treturn m_slot != other.m_slot || m_limit != other.m_limit;\n+      }\n+\n+  private:\n+    value_type *m_slot;\n+    value_type *m_limit;\n+  };\n+\n+  iterator begin () const\n+    {\n+      iterator iter (m_entries, m_entries + m_size);\n+      iter.slide ();\n+      return iter;\n+    }\n+\n+  iterator end () const { return iterator (); }\n+\n+  double collisions () const\n+    {\n+      return m_searches ? static_cast <double> (m_collisions) / m_searches : 0;\n+    }\n+\n+private:\n+\n+  value_type *find_empty_slot_for_expand (hashval_t);\n+  void expand ();\n+  static bool is_deleted (value_type &v)\n+    {\n+      return is_deleted_helper<value_type, Descriptor>::call (v);\n+    }\n+  static bool is_empty (value_type &v)\n+    {\n+      return is_empty_helper<value_type, Descriptor>::call (v);\n+    }\n+\n+  static void mark_deleted (value_type &v)\n+    {\n+      return mark_deleted_helper<value_type, Descriptor>::call (v);\n+    }\n+\n+  static void mark_empty (value_type &v)\n+    {\n+      return mark_empty_helper<value_type, Descriptor>::call (v);\n+    }\n+\n+  /* Table itself.  */\n+  typename Descriptor::value_type *m_entries;\n+\n+  size_t m_size;\n+\n+  /* Current number of elements including also deleted elements.  */\n+  size_t m_n_elements;\n+\n+  /* Current number of deleted elements in the table.  */\n+  size_t m_n_deleted;\n+\n+  /* The following member is used for debugging. Its value is number\n+     of all calls of `htab_find_slot' for the hash table. */\n+  unsigned int m_searches;\n+\n+  /* The following member is used for debugging.  Its value is number\n+     of collisions fixed for time of work with the hash table. */\n+  unsigned int m_collisions;\n+\n+  /* Current size (in entries) of the hash table, as an index into the\n+     table of primes.  */\n+  unsigned int m_size_prime_index;\n+};\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+hash_table<Descriptor, Allocator, true>::hash_table (size_t size) :\n+  m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0)\n+{\n+  unsigned int size_prime_index;\n+\n+  size_prime_index = hash_table_higher_prime_index (size);\n+  size = prime_tab[size_prime_index].prime;\n+\n+  m_entries = Allocator <value_type> ::data_alloc (size);\n+  gcc_assert (m_entries != NULL);\n+  m_size = size;\n+  m_size_prime_index = size_prime_index;\n+}\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+hash_table<Descriptor, Allocator, true>::~hash_table ()\n+{\n+  for (size_t i = m_size - 1; i < m_size; i--)\n+    if (!is_empty (m_entries[i]) && !is_deleted (m_entries[i]))\n+      Descriptor::remove (m_entries[i]);\n+\n+  Allocator <value_type> ::data_free (m_entries);\n+}\n+\n+/* Similar to find_slot, but without several unwanted side effects:\n+    - Does not call equal when it finds an existing entry.\n+    - Does not change the count of elements/searches/collisions in the\n+      hash table.\n+   This function also assumes there are no deleted entries in the table.\n+   HASH is the hash value for the element to be inserted.  */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+typename Descriptor::value_type *\n+hash_table<Descriptor, Allocator, true>\n+::find_empty_slot_for_expand (hashval_t hash)\n+{\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n+  size_t size = m_size;\n+  value_type *slot = m_entries + index;\n+  hashval_t hash2;\n+\n+  if (is_empty (*slot))\n+    return slot;\n+  else if (is_deleted (*slot))\n+    abort ();\n+\n+  hash2 = hash_table_mod2 (hash, m_size_prime_index);\n+  for (;;)\n+    {\n+      index += hash2;\n+      if (index >= size)\n+        index -= size;\n+\n+      slot = m_entries + index;\n+      if (is_empty (*slot))\n+        return slot;\n+      else if (is_deleted (*slot))\n+        abort ();\n+    }\n+}\n+\n+/* The following function changes size of memory allocated for the\n+   entries and repeatedly inserts the table elements.  The occupancy\n+   of the table after the call will be about 50%.  Naturally the hash\n+   table must already exist.  Remember also that the place of the\n+   table entries is changed.  If memory allocation fails, this function\n+   will abort.  */\n+\n+\t  template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator, true>::expand ()\n+{\n+  value_type *oentries = m_entries;\n+  unsigned int oindex = m_size_prime_index;\n+  size_t osize = size ();\n+  value_type *olimit = oentries + osize;\n+  size_t elts = elements ();\n+\n+  /* Resize only when table after removal of unused elements is either\n+     too full or too empty.  */\n+  unsigned int nindex;\n+  size_t nsize;\n+  if (elts * 2 > osize || (elts * 8 < osize && osize > 32))\n+    {\n+      nindex = hash_table_higher_prime_index (elts * 2);\n+      nsize = prime_tab[nindex].prime;\n+    }\n+  else\n+    {\n+      nindex = oindex;\n+      nsize = osize;\n+    }\n+\n+  value_type *nentries = Allocator <value_type> ::data_alloc (nsize);\n+  gcc_assert (nentries != NULL);\n+  m_entries = nentries;\n+  m_size = nsize;\n+  m_size_prime_index = nindex;\n+  m_n_elements -= m_n_deleted;\n+  m_n_deleted = 0;\n+\n+  value_type *p = oentries;\n+  do\n+    {\n+      value_type &x = *p;\n+\n+      if (!is_empty (x) && !is_deleted (x))\n+        {\n+          value_type *q = find_empty_slot_for_expand (Descriptor::hash (x));\n+\n+          *q = x;\n+        }\n+\n+      p++;\n+    }\n+  while (p < olimit);\n+\n+  Allocator <value_type> ::data_free (oentries);\n+}\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator, true>::empty ()\n+{\n+  size_t size = m_size;\n+  value_type *entries = m_entries;\n+  int i;\n+\n+  for (i = size - 1; i >= 0; i--)\n+    if (!is_empty (entries[i]) && !is_deleted (entries[i]))\n+      Descriptor::remove (entries[i]);\n+\n+  /* Instead of clearing megabyte, downsize the table.  */\n+  if (size > 1024*1024 / sizeof (PTR))\n+    {\n+      int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n+      int nsize = prime_tab[nindex].prime;\n+\n+      Allocator <value_type> ::data_free (m_entries);\n+      m_entries = Allocator <value_type> ::data_alloc (nsize);\n+      m_size = nsize;\n+      m_size_prime_index = nindex;\n+    }\n+  else\n+    memset (entries, 0, size * sizeof (value_type));\n+  m_n_deleted = 0;\n+  m_n_elements = 0;\n+}\n+\n+/* This function clears a specified SLOT in a hash table.  It is\n+   useful when you've already done the lookup and don't want to do it\n+   again. */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator, true>::clear_slot (value_type *slot)\n+{\n+  if (slot < m_entries || slot >= m_entries + size ()\n+      || is_empty (*slot) || is_deleted (*slot))\n+    abort ();\n+\n+  Descriptor::remove (*slot);\n+\n+  mark_deleted (*slot);\n+  m_n_deleted++;\n+}\n+\n+/* This function searches for a hash table entry equal to the given\n+   COMPARABLE element starting with the given HASH value.  It cannot\n+   be used to insert or delete an element. */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+typename Descriptor::value_type &\n+hash_table<Descriptor, Allocator, true>\n+::find_with_hash (const compare_type &comparable, hashval_t hash)\n+{\n+  m_searches++;\n+  size_t size = m_size;\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n+\n+  value_type *entry = &m_entries[index];\n+  if (is_empty (*entry)\n+      || (!is_deleted (*entry) && Descriptor::equal (*entry, comparable)))\n+    return *entry;\n+\n+  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n+  for (;;)\n+    {\n+      m_collisions++;\n+      index += hash2;\n+      if (index >= size)\n+        index -= size;\n+\n+      entry = &m_entries[index];\n+      if (is_empty (*entry)\n+          || (!is_deleted (*entry) && Descriptor::equal (*entry, comparable)))\n+        return *entry;\n+    }\n+}\n+\n+/* This function searches for a hash table slot containing an entry\n+   equal to the given COMPARABLE element and starting with the given\n+   HASH.  To delete an entry, call this with insert=NO_INSERT, then\n+   call clear_slot on the slot returned (possibly after doing some\n+   checks).  To insert an entry, call this with insert=INSERT, then\n+   write the value you want into the returned slot.  When inserting an\n+   entry, NULL may be returned if memory allocation fails. */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+typename Descriptor::value_type *\n+hash_table<Descriptor, Allocator, true>\n+::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n+\t\t       enum insert_option insert)\n+{\n+  if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n+    expand ();\n+\n+  m_searches++;\n+\n+  value_type *first_deleted_slot = NULL;\n+  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n+  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n+  value_type *entry = &m_entries[index];\n+  size_t size = m_size;\n+  if (is_empty (*entry))\n+    goto empty_entry;\n+  else if (is_deleted (*entry))\n+    first_deleted_slot = &m_entries[index];\n+  else if (Descriptor::equal (*entry, comparable))\n+    return &m_entries[index];\n+\n+  for (;;)\n+    {\n+      m_collisions++;\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+\n+      entry = &m_entries[index];\n+      if (is_empty (*entry))\n+\tgoto empty_entry;\n+      else if (is_deleted (*entry))\n+\t{\n+\t  if (!first_deleted_slot)\n+\t    first_deleted_slot = &m_entries[index];\n+\t}\n+      else if (Descriptor::equal (*entry, comparable))\n+\treturn &m_entries[index];\n+    }\n+\n+ empty_entry:\n+  if (insert == NO_INSERT)\n+    return NULL;\n+\n+  if (first_deleted_slot)\n+    {\n+      m_n_deleted--;\n+      mark_empty (*first_deleted_slot);\n+      return first_deleted_slot;\n+    }\n+\n+  m_n_elements++;\n+  return &m_entries[index];\n+}\n+\n+/* This function deletes an element with the given COMPARABLE value\n+   from hash table starting with the given HASH.  If there is no\n+   matching element in the hash table, this function does nothing. */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator, true>\n+::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n+{\n+  value_type *slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n+  if (is_empty (*slot))\n+    return;\n+\n+  Descriptor::remove (*slot);\n+\n+  mark_deleted (*slot);\n+  m_n_deleted++;\n+}\n+\n+/* This function scans over the entire hash table calling CALLBACK for\n+   each live entry.  If CALLBACK returns false, the iteration stops.\n+   ARGUMENT is passed as CALLBACK's second argument. */\n+\n+template<typename Descriptor,\n+\t  template<typename Type> class Allocator>\n+template<typename Argument,\n+\t  int (*Callback) (typename Descriptor::value_type *slot,\n+\t\t\t   Argument argument)>\n+void\n+hash_table<Descriptor, Allocator, true>::traverse_noresize (Argument argument)\n+{\n+  value_type *slot = m_entries;\n+  value_type *limit = slot + size ();\n+\n+  do\n+    {\n+      value_type &x = *slot;\n+\n+      if (!is_empty (x) && !is_deleted (x))\n+        if (! Callback (slot, argument))\n+          break;\n+    }\n+  while (++slot < limit);\n+}\n+\n+/* Like traverse_noresize, but does resize the table when it is too empty\n+   to improve effectivity of subsequent calls.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+template <typename Argument,\n+\t  int (*Callback) (typename Descriptor::value_type *slot,\n+\t\t\t   Argument argument)>\n+void\n+hash_table<Descriptor, Allocator, true>::traverse (Argument argument)\n+{\n+  size_t size = m_size;\n+  if (elements () * 8 < size && size > 32)\n+    expand ();\n+\n+  traverse_noresize <Argument, Callback> (argument);\n+}\n+\n+/* Slide down the iterator slots until an active entry is found.  */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+void\n+hash_table<Descriptor, Allocator, true>::iterator::slide ()\n+{\n+  for ( ; m_slot < m_limit; ++m_slot )\n+    {\n+      value_type &x = *m_slot;\n+      if (!is_empty (x) && !is_deleted (x))\n+        return;\n+    }\n+  m_slot = NULL;\n+  m_limit = NULL;\n+}\n+\n+/* Bump the iterator.  */\n+\n+template<typename Descriptor, template<typename Type> class Allocator>\n+inline typename hash_table<Descriptor, Allocator, true>::iterator &\n+hash_table<Descriptor, Allocator, true>::iterator::operator ++ ()\n {\n   ++m_slot;\n   slide ();\n@@ -846,7 +1511,7 @@ hash_table<Descriptor, Allocator>::iterator::operator ++ ()\n \n #define FOR_EACH_HASH_TABLE_ELEMENT(HTAB, RESULT, TYPE, ITER) \\\n   for ((ITER) = (HTAB).begin (); \\\n-       (ITER) != (HTAB).end () ? (RESULT = &*(ITER) , true) : false; \\\n+       (ITER) != (HTAB).end () ? (RESULT = *(ITER) , true) : false; \\\n        ++(ITER))\n \n #endif /* TYPED_HASHTAB_H */"}, {"sha": "2a4db1b309579c4737ee97047c76e42041ad9637", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -102,22 +102,13 @@ static tree TB_history_prev (void);\n void browse_tree (tree);\n \n /* Hashtable helpers.  */\n-struct tree_upper_hasher : typed_noop_remove <tree_node>\n+struct tree_upper_hasher : pointer_hash<tree_node>\n {\n-  typedef tree_node value_type;\n-  typedef tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline bool equal (const value_type &, const compare_type &);\n };\n \n-inline hashval_t\n-tree_upper_hasher::hash (const value_type *v)\n-{\n-  return pointer_hash <value_type>::hash (v);\n-}\n-\n inline bool\n-tree_upper_hasher::equal (const value_type *parent, const compare_type *node)\n+tree_upper_hasher::equal (const value_type &parent, const compare_type &node)\n {\n   if (parent == NULL || node == NULL)\n     return 0;"}, {"sha": "3ed403a1c85c9d2f401e6025f8d4a5f668c1b181", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -83,25 +83,23 @@ static vec<tree> complex_ssa_name_components;\n static tree\n cvc_lookup (unsigned int uid)\n {\n-  struct int_tree_map *h, in;\n+  struct int_tree_map in;\n   in.uid = uid;\n-  h = complex_variable_components->find_with_hash (&in, uid);\n-  return h ? h->to : NULL;\n+  return complex_variable_components->find_with_hash (in, uid).to;\n }\n \n /* Insert the pair UID, TO into the complex_variable_components hashtable.  */\n \n static void\n cvc_insert (unsigned int uid, tree to)\n {\n-  struct int_tree_map *h;\n-  int_tree_map **loc;\n+  int_tree_map h;\n+  int_tree_map *loc;\n \n-  h = XNEW (struct int_tree_map);\n-  h->uid = uid;\n-  h->to = to;\n+  h.uid = uid;\n   loc = complex_variable_components->find_slot_with_hash (h, uid, INSERT);\n-  *loc = h;\n+  loc->uid = uid;\n+  loc->to = to;\n }\n \n /* Return true if T is not a zero constant.  In the case of real values,"}, {"sha": "ae56a84d1ce2eacaa849825442071acb8f38d620", "filename": "gcc/tree-hasher.h", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-hasher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-hasher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-hasher.h?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -30,28 +30,37 @@ struct int_tree_map {\n \n /* Hashtable helpers.  */\n \n-struct int_tree_hasher : typed_free_remove <int_tree_map>\n+struct int_tree_hasher\n {\n   typedef int_tree_map value_type;\n   typedef int_tree_map compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef int store_values_directly;\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &, const compare_type &);\n+  static bool is_deleted (const value_type &v)\n+    {\n+      return v.to == reinterpret_cast<tree> (1);\n+    }\n+  static void mark_deleted (value_type &v) { v.to = reinterpret_cast<tree> (0x1); }\n+  static bool is_empty (const value_type &v) { return v.to == NULL; }\n+  static void mark_empty (value_type &v) { v.to = NULL; }\n+  static void remove (value_type &) {}\n };\n \n /* Hash a UID in a int_tree_map.  */\n \n inline hashval_t\n-int_tree_hasher::hash (const value_type *item)\n+int_tree_hasher::hash (const value_type &item)\n {\n-  return item->uid;\n+  return item.uid;\n }\n \n /* Return true if the uid in both int tree maps are equal.  */\n \n inline bool\n-int_tree_hasher::equal (const value_type *a, const compare_type *b)\n+int_tree_hasher::equal (const value_type &a, const compare_type &b)\n {\n-  return (a->uid == b->uid);\n+  return (a.uid == b.uid);\n }\n \n typedef hash_table <int_tree_hasher> int_tree_htab_type;"}, {"sha": "96255f9a5593ebb4dbba4ec78c140b8ac3ea30f4", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -203,20 +203,21 @@ typedef struct var_info_d *var_info_p;\n \n struct var_info_hasher : typed_free_remove <var_info_d>\n {\n-  typedef var_info_d value_type;\n-  typedef var_info_d compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef var_info_d *value_type;\n+  typedef var_info_d *compare_type;\n+  typedef int store_values_directly;\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &, const compare_type &);\n };\n \n inline hashval_t\n-var_info_hasher::hash (const value_type *p)\n+var_info_hasher::hash (const value_type &p)\n {\n   return DECL_UID (p->var);\n }\n \n inline bool\n-var_info_hasher::equal (const value_type *p1, const compare_type *p2)\n+var_info_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n   return p1->var == p2->var;\n }"}, {"sha": "0c486bbebc22a0096b96805582dcf20b512f59ac", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -489,8 +489,6 @@ take_address_of (tree obj, tree type, edge entry,\n \t\t int_tree_htab_type *decl_address, gimple_stmt_iterator *gsi)\n {\n   int uid;\n-  int_tree_map **dslot;\n-  struct int_tree_map ielt, *nielt;\n   tree *var_p, name, addr;\n   gimple stmt;\n   gimple_seq stmts;\n@@ -511,9 +509,10 @@ take_address_of (tree obj, tree type, edge entry,\n      in the address and share it for all accesses and addresses based\n      on it.  */\n   uid = DECL_UID (TREE_OPERAND (TREE_OPERAND (*var_p, 0), 0));\n-  ielt.uid = uid;\n-  dslot = decl_address->find_slot_with_hash (&ielt, uid, INSERT);\n-  if (!*dslot)\n+  int_tree_map elt;\n+  elt.uid = uid;\n+  int_tree_map *slot = decl_address->find_slot (elt, INSERT);\n+  if (!slot->to)\n     {\n       if (gsi == NULL)\n \treturn NULL;\n@@ -527,13 +526,11 @@ take_address_of (tree obj, tree type, edge entry,\n       stmt = gimple_build_assign (name, addr);\n       gsi_insert_on_edge_immediate (entry, stmt);\n \n-      nielt = XNEW (struct int_tree_map);\n-      nielt->uid = uid;\n-      nielt->to = name;\n-      *dslot = nielt;\n+      slot->uid = uid;\n+      slot->to = name;\n     }\n   else\n-    name = (*dslot)->to;\n+    name = slot->to;\n \n   /* Express the address in terms of the canonical SSA name.  */\n   TREE_OPERAND (*var_p, 0) = name;\n@@ -822,10 +819,10 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type *name_copies,\n {\n   tree copy, var, var_copy;\n   unsigned idx, uid, nuid;\n-  struct int_tree_map ielt, *nielt;\n+  struct int_tree_map ielt;\n   struct name_to_copy_elt elt, *nelt;\n   name_to_copy_elt **slot;\n-  int_tree_map **dslot;\n+  int_tree_map *dslot;\n \n   if (TREE_CODE (name) != SSA_NAME)\n     return name;\n@@ -858,29 +855,25 @@ separate_decls_in_region_name (tree name, name_to_copy_table_type *name_copies,\n \n   uid = DECL_UID (var);\n   ielt.uid = uid;\n-  dslot = decl_copies->find_slot_with_hash (&ielt, uid, INSERT);\n-  if (!*dslot)\n+  dslot = decl_copies->find_slot_with_hash (ielt, uid, INSERT);\n+  if (!dslot->to)\n     {\n       var_copy = create_tmp_var (TREE_TYPE (var), get_name (var));\n       DECL_GIMPLE_REG_P (var_copy) = DECL_GIMPLE_REG_P (var);\n-      nielt = XNEW (struct int_tree_map);\n-      nielt->uid = uid;\n-      nielt->to = var_copy;\n-      *dslot = nielt;\n+      dslot->uid = uid;\n+      dslot->to = var_copy;\n \n       /* Ensure that when we meet this decl next time, we won't duplicate\n          it again.  */\n       nuid = DECL_UID (var_copy);\n       ielt.uid = nuid;\n-      dslot = decl_copies->find_slot_with_hash (&ielt, nuid, INSERT);\n-      gcc_assert (!*dslot);\n-      nielt = XNEW (struct int_tree_map);\n-      nielt->uid = nuid;\n-      nielt->to = var_copy;\n-      *dslot = nielt;\n+      dslot = decl_copies->find_slot_with_hash (ielt, nuid, INSERT);\n+      gcc_assert (!dslot->to);\n+      dslot->uid = nuid;\n+      dslot->to = var_copy;\n     }\n   else\n-    var_copy = ((struct int_tree_map *) *dslot)->to;\n+    var_copy = dslot->to;\n \n   replace_ssa_name_symbol (copy, var_copy);\n   return copy;\n@@ -944,7 +937,7 @@ separate_decls_in_region_debug (gimple stmt,\n   struct int_tree_map ielt;\n   struct name_to_copy_elt elt;\n   name_to_copy_elt **slot;\n-  int_tree_map **dslot;\n+  int_tree_map *dslot;\n \n   if (gimple_debug_bind_p (stmt))\n     var = gimple_debug_bind_get_var (stmt);\n@@ -956,13 +949,13 @@ separate_decls_in_region_debug (gimple stmt,\n     return true;\n   gcc_assert (DECL_P (var) && SSA_VAR_P (var));\n   ielt.uid = DECL_UID (var);\n-  dslot = decl_copies->find_slot_with_hash (&ielt, ielt.uid, NO_INSERT);\n+  dslot = decl_copies->find_slot_with_hash (ielt, ielt.uid, NO_INSERT);\n   if (!dslot)\n     return true;\n   if (gimple_debug_bind_p (stmt))\n-    gimple_debug_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n+    gimple_debug_bind_set_var (stmt, dslot->to);\n   else if (gimple_debug_source_bind_p (stmt))\n-    gimple_debug_source_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n+    gimple_debug_source_bind_set_var (stmt, dslot->to);\n \n   FOR_EACH_PHI_OR_STMT_USE (use, stmt, oi, SSA_OP_USE)\n   {"}, {"sha": "61e75b6fb2032f1674511e9ac98540a7bc878d42", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -158,21 +158,22 @@ static void free_expr_hash_elt (void *);\n \n struct expr_elt_hasher\n {\n-  typedef expr_hash_elt value_type;\n-  typedef expr_hash_elt compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef expr_hash_elt *value_type;\n+  typedef expr_hash_elt *compare_type;\n+  typedef int store_values_directly;\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &, const compare_type &);\n+  static inline void remove (value_type &);\n };\n \n inline hashval_t\n-expr_elt_hasher::hash (const value_type *p)\n+expr_elt_hasher::hash (const value_type &p)\n {\n   return p->hash;\n }\n \n inline bool\n-expr_elt_hasher::equal (const value_type *p1, const compare_type *p2)\n+expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n   gimple stmt1 = p1->stmt;\n   const struct hashable_expr *expr1 = &p1->expr;\n@@ -211,7 +212,7 @@ expr_elt_hasher::equal (const value_type *p1, const compare_type *p2)\n /* Delete an expr_hash_elt and reclaim its storage.  */\n \n inline void\n-expr_elt_hasher::remove (value_type *element)\n+expr_elt_hasher::remove (value_type &element)\n {\n   free_expr_hash_elt (element);\n }"}, {"sha": "4903f4879fabf3bfc4d836cac40a44630ab039ec", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -1023,32 +1023,36 @@ static vec<oecount> cvec;\n \n /* Oecount hashtable helpers.  */\n \n-struct oecount_hasher : typed_noop_remove <void>\n+struct oecount_hasher\n {\n-  /* Note that this hash table stores integers, not pointers.\n-     So, observe the casting in the member functions.  */\n-  typedef void value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef int value_type;\n+  typedef int compare_type;\n+  typedef int store_values_directly;\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &, const compare_type &);\n+  static bool is_deleted (int &v) { return v == 1; }\n+  static void mark_deleted (int &e) { e = 1; }\n+  static bool is_empty (int &v) { return v == 0; }\n+  static void mark_empty (int &e) { e = 0; }\n+  static void remove (int &) {}\n };\n \n /* Hash function for oecount.  */\n \n inline hashval_t\n-oecount_hasher::hash (const value_type *p)\n+oecount_hasher::hash (const value_type &p)\n {\n-  const oecount *c = &cvec[(size_t)p - 42];\n+  const oecount *c = &cvec[p - 42];\n   return htab_hash_pointer (c->op) ^ (hashval_t)c->oecode;\n }\n \n /* Comparison function for oecount.  */\n \n inline bool\n-oecount_hasher::equal (const value_type *p1, const compare_type *p2)\n+oecount_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n-  const oecount *c1 = &cvec[(size_t)p1 - 42];\n-  const oecount *c2 = &cvec[(size_t)p2 - 42];\n+  const oecount *c1 = &cvec[p1 - 42];\n+  const oecount *c2 = &cvec[p2 - 42];\n   return (c1->oecode == c2->oecode\n \t  && c1->op == c2->op);\n }\n@@ -1473,23 +1477,23 @@ undistribute_ops_list (enum tree_code opcode,\n       FOR_EACH_VEC_ELT (subops[i], j, oe1)\n \t{\n \t  oecount c;\n-\t  void **slot;\n-\t  size_t idx;\n+\t  int *slot;\n+\t  int idx;\n \t  c.oecode = oecode;\n \t  c.cnt = 1;\n \t  c.id = next_oecount_id++;\n \t  c.op = oe1->op;\n \t  cvec.safe_push (c);\n \t  idx = cvec.length () + 41;\n-\t  slot = ctable.find_slot ((void *)idx, INSERT);\n+\t  slot = ctable.find_slot (idx, INSERT);\n \t  if (!*slot)\n \t    {\n-\t      *slot = (void *)idx;\n+\t      *slot = idx;\n \t    }\n \t  else\n \t    {\n \t      cvec.pop ();\n-\t      cvec[(size_t)*slot - 42].cnt++;\n+\t      cvec[*slot - 42].cnt++;\n \t    }\n \t}\n     }"}, {"sha": "60923557df794cd24dd2455a578c365e427e41a3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "patch": "@@ -550,14 +550,14 @@ vectorize_loops (void)\n       for (hash_table<simd_array_to_simduid>::iterator iter\n \t   = simd_array_to_simduid_htab->begin ();\n \t   iter != simd_array_to_simduid_htab->end (); ++iter)\n-\tif ((*iter).simduid != -1U)\n+\tif ((*iter)->simduid != -1U)\n \t  {\n-\t    tree decl = (*iter).decl;\n+\t    tree decl = (*iter)->decl;\n \t    int vf = 1;\n \t    if (simduid_to_vf_htab)\n \t      {\n \t\tsimduid_to_vf *p = NULL, data;\n-\t\tdata.simduid = (*iter).simduid;\n+\t\tdata.simduid = (*iter)->simduid;\n \t\tp = simduid_to_vf_htab->find (&data);\n \t\tif (p)\n \t\t  vf = p->vf;"}]}