{"sha": "83a1beee2766f01a1f46f81ed53f679419318942", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhMWJlZWUyNzY2ZjAxYTFmNDZmODFlZDUzZjY3OTQxOTMxODk0Mg==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2020-11-20T20:29:34Z"}, "committer": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2020-11-20T22:40:18Z"}, "message": "libstdc++: Add C++2a synchronization support\n\nAdd support for -\n  * atomic_flag::wait/notify_one/notify_all\n  * atomic::wait/notify_one/notify_all\n  * counting_semaphore\n  * binary_semaphore\n  * latch\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am (bits_headers): Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/atomic_base.h (__atomic_flag::wait): Define.\n\t(__atomic_flag::notify_one): Likewise.\n\t(__atomic_flag::notify_all): Likewise.\n\t(__atomic_base<_Itp>::wait): Likewise.\n\t(__atomic_base<_Itp>::notify_one): Likewise.\n\t(__atomic_base<_Itp>::notify_all): Likewise.\n\t(__atomic_base<_Ptp*>::wait): Likewise.\n\t(__atomic_base<_Ptp*>::notify_one): Likewise.\n\t(__atomic_base<_Ptp*>::notify_all): Likewise.\n\t(__atomic_impl::wait): Likewise.\n\t(__atomic_impl::notify_one): Likewise.\n\t(__atomic_impl::notify_all): Likewise.\n\t(__atomic_float<_Fp>::wait): Likewise.\n\t(__atomic_float<_Fp>::notify_one): Likewise.\n\t(__atomic_float<_Fp>::notify_all): Likewise.\n\t(__atomic_ref<_Tp>::wait): Likewise.\n\t(__atomic_ref<_Tp>::notify_one): Likewise.\n\t(__atomic_ref<_Tp>::notify_all): Likewise.\n\t(atomic_wait<_Tp>): Likewise.\n\t(atomic_wait_explicit<_Tp>): Likewise.\n\t(atomic_notify_one<_Tp>): Likewise.\n\t(atomic_notify_all<_Tp>): Likewise.\n\t* include/bits/atomic_wait.h: New file.\n\t* include/bits/atomic_timed_wait.h: New file.\n\t* include/bits/semaphore_base.h: New file.\n\t* include/std/atomic (atomic<bool>::wait): Define.\n\t(atomic<bool>::wait_one): Likewise.\n\t(atomic<bool>::wait_all): Likewise.\n\t(atomic<_Tp>::wait): Likewise.\n\t(atomic<_Tp>::wait_one): Likewise.\n\t(atomic<_Tp>::wait_all): Likewise.\n\t(atomic<_Tp*>::wait): Likewise.\n\t(atomic<_Tp*>::wait_one): Likewise.\n\t(atomic<_Tp*>::wait_all): Likewise.\n\t* include/std/latch: New file.\n\t* include/std/semaphore: New file.\n\t* include/std/version: Add __cpp_lib_semaphore and\n\t__cpp_lib_latch defines.\n\t* testsuite/29_atomics/atomic/wait_notify/bool.cc: New test.\n\t* testsuite/29_atomics/atomic/wait_notify/pointers.cc: Likewise.\n\t* testsuite/29_atomics/atomic/wait_notify/generic.cc: Liekwise.\n\t* testsuite/29_atomics/atomic_flag/wait_notify/1.cc: Likewise.\n\t* testsuite/29_atomics/atomic_float/wait_notify.cc: Likewise.\n\t* testsuite/29_atomics/atomic_integral/wait_notify.cc: Likewise.\n\t* testsuite/29_atomics/atomic_ref/wait_notify.cc: Likewise.\n\t* testsuite/30_threads/semaphore/1.cc: New test.\n\t* testsuite/30_threads/semaphore/2.cc: Likewise.\n\t* testsuite/30_threads/semaphore/least_max_value_neg.cc: Likewise.\n\t* testsuite/30_threads/semaphore/try_acquire.cc: Likewise.\n\t* testsuite/30_threads/semaphore/try_acquire_for.cc: Likewise.\n\t* testsuite/30_threads/semaphore/try_acquire_posix.cc: Likewise.\n\t* testsuite/30_threads/semaphore/try_acquire_until.cc: Likewise.\n\t* testsuite/30_threads/latch/1.cc: New test.\n\t* testsuite/30_threads/latch/2.cc: New test.\n\t* testsuite/30_threads/latch/3.cc: New test.\n\t* testsuite/util/atomic/wait_notify_util.h: New File.", "tree": {"sha": "91d590aea81ac38d24b814371ebe533d12d6cfa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91d590aea81ac38d24b814371ebe533d12d6cfa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83a1beee2766f01a1f46f81ed53f679419318942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a1beee2766f01a1f46f81ed53f679419318942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a1beee2766f01a1f46f81ed53f679419318942", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a1beee2766f01a1f46f81ed53f679419318942/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89d9c634dc5c10b499c23297ef70133066946790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d9c634dc5c10b499c23297ef70133066946790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d9c634dc5c10b499c23297ef70133066946790"}], "stats": {"total": 2507, "additions": 2506, "deletions": 1}, "files": [{"sha": "ca413b8fdfeb3cd679f13538c9ffeafcda5eb9b6", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -52,6 +52,7 @@ std_headers = \\\n \t${std_srcdir}/iostream \\\n \t${std_srcdir}/istream \\\n \t${std_srcdir}/iterator \\\n+\t${std_srcdir}/latch \\\n \t${std_srcdir}/limits \\\n \t${std_srcdir}/list \\\n \t${std_srcdir}/locale \\\n@@ -69,6 +70,7 @@ std_headers = \\\n \t${std_srcdir}/ratio \\\n \t${std_srcdir}/regex \\\n \t${std_srcdir}/scoped_allocator \\\n+\t${std_srcdir}/semaphore \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/shared_mutex \\\n \t${std_srcdir}/span \\\n@@ -103,6 +105,8 @@ bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n \t${bits_srcdir}/atomic_futex.h \\\n+\t${bits_srcdir}/atomic_timed_wait.h \\\n+\t${bits_srcdir}/atomic_wait.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -178,6 +182,7 @@ bits_headers = \\\n \t${bits_srcdir}/regex_compiler.tcc \\\n \t${bits_srcdir}/regex_executor.h \\\n \t${bits_srcdir}/regex_executor.tcc \\\n+\t${bits_srcdir}/semaphore_base.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\"}, {"sha": "ef2dc18965b92161e0598ca1a006d9320a4c1acf", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -398,6 +398,7 @@ std_headers = \\\n \t${std_srcdir}/iostream \\\n \t${std_srcdir}/istream \\\n \t${std_srcdir}/iterator \\\n+\t${std_srcdir}/latch \\\n \t${std_srcdir}/limits \\\n \t${std_srcdir}/list \\\n \t${std_srcdir}/locale \\\n@@ -415,6 +416,7 @@ std_headers = \\\n \t${std_srcdir}/ratio \\\n \t${std_srcdir}/regex \\\n \t${std_srcdir}/scoped_allocator \\\n+\t${std_srcdir}/semaphore \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/shared_mutex \\\n \t${std_srcdir}/span \\\n@@ -449,6 +451,8 @@ bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n \t${bits_srcdir}/atomic_base.h \\\n \t${bits_srcdir}/atomic_futex.h \\\n+\t${bits_srcdir}/atomic_timed_wait.h \\\n+\t${bits_srcdir}/atomic_wait.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -524,6 +528,7 @@ bits_headers = \\\n \t${bits_srcdir}/regex_compiler.tcc \\\n \t${bits_srcdir}/regex_executor.h \\\n \t${bits_srcdir}/regex_executor.tcc \\\n+\t${bits_srcdir}/semaphore_base.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\"}, {"sha": "dd4db926592ed9e2d304bb6d74696d65902351e1", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 194, "deletions": 1, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -37,6 +37,10 @@\n #include <bits/atomic_lockfree_defines.h>\n #include <bits/move.h>\n \n+#if __cplusplus > 201703L\n+#include <bits/atomic_wait.h>\n+#endif\n+\n #ifndef _GLIBCXX_ALWAYS_INLINE\n #define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))\n #endif\n@@ -134,7 +138,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __ret;\n     }\n \n-\n   // Base types for atomics.\n   template<typename _IntTp>\n     struct __atomic_base;\n@@ -226,6 +229,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __atomic_load(&_M_i, &__v, int(__m));\n       return __v == __GCC_ATOMIC_TEST_AND_SET_TRUEVAL;\n     }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    wait(bool __old,\n+\tmemory_order __m = memory_order_seq_cst) const noexcept\n+    {\n+      std::__atomic_wait(&_M_i, __old,\n+\t\t\t [__m, this, __old]()\n+\t\t\t { return this->test(__m) != __old; });\n+    }\n+\n+    // TODO add const volatile overload\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    notify_one() const noexcept\n+    { std::__atomic_notify(&_M_i, false); }\n+\n+    // TODO add const volatile overload\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    notify_all() const noexcept\n+    { std::__atomic_notify(&_M_i, true); }\n+\n+    // TODO add const volatile overload\n #endif // C++20\n \n     _GLIBCXX_ALWAYS_INLINE void\n@@ -576,6 +602,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__m));\n       }\n \n+#if __cplusplus > 201703L\n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(__int_type __old,\n+\t  memory_order __m = memory_order_seq_cst) const noexcept\n+      {\n+\tstd::__atomic_wait(&_M_i, __old,\n+\t\t\t   [__m, this, __old]\n+\t\t\t   { return this->load(__m) != __old; });\n+      }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { std::__atomic_notify(&_M_i, false); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { std::__atomic_notify(&_M_i, true); }\n+\n+      // TODO add const volatile overload\n+#endif // C++2a\n+\n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_add(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n@@ -845,6 +896,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n+#if __cplusplus > 201703L\n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(__pointer_type __old,\n+\t   memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\tstd::__atomic_wait(&_M_p, __old,\n+\t\t      [__m, this, __old]()\n+\t\t      { return this->load(__m) != __old; });\n+      }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { std::__atomic_notify(&_M_p, false); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { std::__atomic_notify(&_M_p, true); }\n+\n+      // TODO add const volatile overload\n+#endif // C++2a\n+\n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n@@ -933,6 +1009,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t int(__success), int(__failure));\n       }\n \n+#if __cplusplus > 201703L\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(const _Tp* __ptr, _Val<_Tp> __old,\n+\t   memory_order __m = memory_order_seq_cst) noexcept\n+      {\n+\tstd::__atomic_wait(__ptr, __old,\n+\t    [=]() { return load(__ptr, __m) == __old; });\n+      }\n+\n+      // TODO add const volatile overload\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one(const _Tp* __ptr) noexcept\n+      { std::__atomic_notify(__ptr, false); }\n+\n+      // TODO add const volatile overload\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all(const _Tp* __ptr) noexcept\n+      { std::__atomic_notify(__ptr, true); }\n+\n+      // TODO add const volatile overload\n+#endif // C++2a\n+\n     template<typename _Tp>\n       _GLIBCXX_ALWAYS_INLINE _Tp\n       fetch_add(_Tp* __ptr, _Diff<_Tp> __i, memory_order __m) noexcept\n@@ -1186,6 +1289,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__order));\n       }\n \n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(_Fp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::wait(&_M_fp, __old, __m); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { __atomic_impl::notify_one(&_M_fp); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { __atomic_impl::notify_all(&_M_fp); }\n+\n+      // TODO add const volatile overload\n+\n       value_type\n       fetch_add(value_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n@@ -1323,6 +1444,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__order));\n       }\n \n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::wait(_M_ptr, __old, __m); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { __atomic_impl::notify_one(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { __atomic_impl::notify_all(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n     private:\n       _Tp* _M_ptr;\n     };\n@@ -1418,6 +1557,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__order));\n       }\n \n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::wait(_M_ptr, __old, __m); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { __atomic_impl::notify_one(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { __atomic_impl::notify_all(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n       value_type\n       fetch_add(value_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) const noexcept\n@@ -1573,6 +1730,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__order));\n       }\n \n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(_Fp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::wait(_M_ptr, __old, __m); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { __atomic_impl::notify_one(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { __atomic_impl::notify_all(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n       value_type\n       fetch_add(value_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) const noexcept\n@@ -1682,6 +1857,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t       __cmpexch_failure_order(__order));\n       }\n \n+      _GLIBCXX_ALWAYS_INLINE void\n+      wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+      { __atomic_impl::wait(_M_ptr, __old, __m); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_one() const noexcept\n+      { __atomic_impl::notify_one(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      notify_all() const noexcept\n+      { __atomic_impl::notify_all(_M_ptr); }\n+\n+      // TODO add const volatile overload\n+\n       _GLIBCXX_ALWAYS_INLINE value_type\n       fetch_add(difference_type __d,\n \t\tmemory_order __m = memory_order_seq_cst) const noexcept"}, {"sha": "7712a6c591dcc9515aad4340755269d65a50fdb8", "filename": "libstdc++-v3/include/bits/atomic_timed_wait.h", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,287 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/atomic_timed_wait.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{atomic}\n+ */\n+\n+#ifndef _GLIBCXX_ATOMIC_TIMED_WAIT_H\n+#define _GLIBCXX_ATOMIC_TIMED_WAIT_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <bits/functional_hash.h>\n+#include <bits/atomic_wait.h>\n+\n+#include <chrono>\n+\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+#include <sys/time.h>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  enum class __atomic_wait_status { no_timeout, timeout };\n+\n+  namespace __detail\n+  {\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+    using __platform_wait_clock_t = chrono::steady_clock;\n+\n+    template<typename _Duration>\n+      __atomic_wait_status\n+      __platform_wait_until_impl(__platform_wait_t* __addr,\n+\t\t\t\t __platform_wait_t __val,\n+\t\t\t\t const chrono::time_point<\n+\t\t\t\t\t  __platform_wait_clock_t, _Duration>&\n+\t\t\t\t      __atime) noexcept\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\tstruct timespec __rt =\n+\t{\n+\t  static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t  static_cast<long>(__ns.count())\n+\t};\n+\n+\tauto __e = syscall (SYS_futex, __addr,\n+\t\t\t    static_cast<int>(__futex_wait_flags::\n+\t\t\t\t\t\t__wait_bitset_private),\n+\t\t\t    __val, &__rt, nullptr,\n+\t\t\t    static_cast<int>(__futex_wait_flags::\n+\t\t\t\t\t\t__bitset_match_any));\n+\tif (__e && !(errno == EINTR || errno == EAGAIN || errno == ETIMEDOUT))\n+\t    std::terminate();\n+\treturn (__platform_wait_clock_t::now() < __atime)\n+\t       ? __atomic_wait_status::no_timeout\n+\t       : __atomic_wait_status::timeout;\n+      }\n+\n+    template<typename _Clock, typename _Duration>\n+      __atomic_wait_status\n+      __platform_wait_until(__platform_wait_t* __addr, __platform_wait_t __val,\n+\t\t\t    const chrono::time_point<_Clock, _Duration>&\n+\t\t\t\t__atime)\n+      {\n+\tif constexpr (is_same_v<__platform_wait_clock_t, _Clock>)\n+\t  {\n+\t    return __detail::__platform_wait_until_impl(__addr, __val, __atime);\n+\t  }\n+\telse\n+\t  {\n+\t    const typename _Clock::time_point __c_entry = _Clock::now();\n+\t    const __platform_wait_clock_t::time_point __s_entry =\n+\t\t    __platform_wait_clock_t::now();\n+\t    const auto __delta = __atime - __c_entry;\n+\t    const auto __s_atime = __s_entry + __delta;\n+\t    if (__detail::__platform_wait_until_impl(__addr, __val, __s_atime)\n+\t\t  == __atomic_wait_status::no_timeout)\n+\t      return __atomic_wait_status::no_timeout;\n+\n+\t    // We got a timeout when measured against __clock_t but\n+\t    // we need to check against the caller-supplied clock\n+\t    // to tell whether we should return a timeout.\n+\t    if (_Clock::now() < __atime)\n+\t      return __atomic_wait_status::no_timeout;\n+\t    return __atomic_wait_status::timeout;\n+\t  }\n+      }\n+#endif\n+\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    template<typename _Duration>\n+      __atomic_wait_status\n+      __cond_wait_until_impl(__gthread_cond_t* __cv,\n+\t  unique_lock<mutex>& __lock,\n+\t  const chrono::time_point<chrono::steady_clock, _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tpthread_cond_clockwait(__cv, __lock.mutex()->native_handle(),\n+\t\t\t       CLOCK_MONOTONIC,\n+\t\t\t       &__ts);\n+\treturn (chrono::steady_clock::now() < __atime)\n+\t       ? __atomic_wait_status::no_timeout\n+\t       : __atomic_wait_status::timeout;\n+      }\n+#endif\n+\n+      template<typename _Duration>\n+\t__atomic_wait_status\n+\t__cond_wait_until_impl(__gthread_cond_t* __cv,\n+\t    unique_lock<std::mutex>& __lock,\n+\t    const chrono::time_point<chrono::system_clock, _Duration>& __atime)\n+\t{\n+\t  auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\t  auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t  __gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\t  __gthread_cond_timedwait(__cv, __lock.mutex()->native_handle(),\n+\t\t\t\t   &__ts);\n+\t  return (chrono::system_clock::now() < __atime)\n+\t\t ? __atomic_wait_status::no_timeout\n+\t\t : __atomic_wait_status::timeout;\n+\t}\n+\n+      // return true if timeout\n+      template<typename _Clock, typename _Duration>\n+\t__atomic_wait_status\n+\t__cond_wait_until(__gthread_cond_t* __cv,\n+\t    unique_lock<std::mutex>& __lock,\n+\t    const chrono::time_point<_Clock, _Duration>& __atime)\n+\t{\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+\t  using __clock_t = chrono::steady_clock;\n+#else\n+\t  using __clock_t = chrono::system_clock;\n+#endif\n+\t  const typename _Clock::time_point __c_entry = _Clock::now();\n+\t  const __clock_t::time_point __s_entry = __clock_t::now();\n+\t  const auto __delta = __atime - __c_entry;\n+\t  const auto __s_atime = __s_entry + __delta;\n+\t  if (std::__detail::__cond_wait_until_impl(__cv, __lock, __s_atime))\n+\t    return __atomic_wait_status::no_timeout;\n+\t  // We got a timeout when measured against __clock_t but\n+\t  // we need to check against the caller-supplied clock\n+\t  // to tell whether we should return a timeout.\n+\t  if (_Clock::now() < __atime)\n+\t    return __atomic_wait_status::no_timeout;\n+\t  return __atomic_wait_status::timeout;\n+\t}\n+\n+    struct __timed_waiters : __waiters\n+    {\n+      template<typename _Clock, typename _Duration>\n+\t__atomic_wait_status\n+\t_M_do_wait_until(__platform_wait_t __version,\n+\t\t\t const chrono::time_point<_Clock, _Duration>& __atime)\n+\t{\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+\t  return __detail::__platform_wait_until(&_M_ver, __version, __atime);\n+#else\n+\t  __platform_wait_t __cur = 0;\n+\t  __waiters::__lock_t __l(_M_mtx);\n+\t  while (__cur <= __version)\n+\t    {\n+\t      if (__detail::__cond_wait_until(&_M_cv, __l, __atime)\n+\t\t    == __atomic_wait_status::timeout)\n+\t\treturn __atomic_wait_status::timeout;\n+\n+\t      __platform_wait_t __last = __cur;\n+\t      __atomic_load(&_M_ver, &__cur, __ATOMIC_ACQUIRE);\n+\t      if (__cur < __last)\n+\t\tbreak; // break the loop if version overflows\n+\t    }\n+\t  return __atomic_wait_status::no_timeout;\n+#endif\n+\t}\n+\n+      static __timed_waiters&\n+      _S_timed_for(void* __t)\n+      {\n+\tstatic_assert(sizeof(__timed_waiters) == sizeof(__waiters));\n+\treturn static_cast<__timed_waiters&>(__waiters::_S_for(__t));\n+      }\n+    };\n+  } // namespace __detail\n+\n+  template<typename _Tp, typename _Pred,\n+\t   typename _Clock, typename _Duration>\n+    bool\n+    __atomic_wait_until(const _Tp* __addr, _Tp __old, _Pred __pred,\n+\t\t\tconst chrono::time_point<_Clock, _Duration>&\n+\t\t\t    __atime) noexcept\n+    {\n+      using namespace __detail;\n+\n+      if (std::__atomic_spin(__pred))\n+\treturn true;\n+\n+      auto& __w = __timed_waiters::_S_timed_for((void*)__addr);\n+      auto __version = __w._M_enter_wait();\n+      do\n+\t{\n+\t  __atomic_wait_status __res;\n+\t  if constexpr (__platform_wait_uses_type<_Tp>)\n+\t    {\n+\t      __res = __detail::__platform_wait_until((__platform_wait_t*)(void*) __addr,\n+\t\t\t\t\t\t      __old, __atime);\n+\t    }\n+\t  else\n+\t    {\n+\t      __res = __w._M_do_wait_until(__version, __atime);\n+\t    }\n+\t  if (__res == __atomic_wait_status::timeout)\n+\t    return false;\n+\t}\n+      while (!__pred() && __atime < _Clock::now());\n+      __w._M_leave_wait();\n+\n+      // if timed out, return false\n+      return (_Clock::now() < __atime);\n+    }\n+\n+  template<typename _Tp, typename _Pred,\n+\t   typename _Rep, typename _Period>\n+    bool\n+    __atomic_wait_for(const _Tp* __addr, _Tp __old, _Pred __pred,\n+\t\t      const chrono::duration<_Rep, _Period>& __rtime) noexcept\n+    {\n+      using namespace __detail;\n+\n+      if (std::__atomic_spin(__pred))\n+\treturn true;\n+\n+      if (!__rtime.count())\n+\treturn false; // no rtime supplied, and spin did not acquire\n+\n+      using __dur = chrono::steady_clock::duration;\n+      auto __reltime = chrono::duration_cast<__dur>(__rtime);\n+      if (__reltime < __rtime)\n+\t++__reltime;\n+\n+\n+      return __atomic_wait_until(__addr, __old, std::move(__pred),\n+\t\t\t\t chrono::steady_clock::now() + __reltime);\n+    }\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif"}, {"sha": "2d08e5325fb2edb1915cb7cc9d2a8b7809d9c0a2", "filename": "libstdc++-v3/include/bits/atomic_wait.h", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,306 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/atomic_wait.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{atomic}\n+ */\n+\n+#ifndef _GLIBCXX_ATOMIC_WAIT_H\n+#define _GLIBCXX_ATOMIC_WAIT_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <bits/functional_hash.h>\n+#include <bits/gthr.h>\n+#include <bits/std_mutex.h>\n+#include <bits/unique_lock.h>\n+#include <ext/numeric_traits.h>\n+\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+#include <climits>\n+#include <unistd.h>\n+#include <syscall.h>\n+#endif\n+\n+\n+// TODO get this from Autoconf\n+#define _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE 1\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  namespace __detail\n+  {\n+    using __platform_wait_t = int;\n+\n+    constexpr auto __atomic_spin_count_1 = 16;\n+    constexpr auto __atomic_spin_count_2 = 12;\n+\n+    inline constexpr\n+    auto __platform_wait_max_value =\n+\t\t__gnu_cxx::__int_traits<__platform_wait_t>::__max;\n+\n+    template<typename _Tp>\n+      inline constexpr bool __platform_wait_uses_type\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+\t= is_same_v<remove_cv_t<_Tp>, __platform_wait_t>;\n+#else\n+\t= false;\n+#endif\n+\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+    enum class __futex_wait_flags : int\n+    {\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE\n+      __private_flag = 128,\n+#else\n+      __private_flag = 0,\n+#endif\n+      __wait = 0,\n+      __wake = 1,\n+      __wait_bitset = 9,\n+      __wake_bitset = 10,\n+      __wait_private = __wait | __private_flag,\n+      __wake_private = __wake | __private_flag,\n+      __wait_bitset_private = __wait_bitset | __private_flag,\n+      __wake_bitset_private = __wake_bitset | __private_flag,\n+      __bitset_match_any = -1\n+    };\n+\n+    template<typename _Tp>\n+      void\n+      __platform_wait(const _Tp* __addr, __platform_wait_t __val) noexcept\n+      {\n+\tfor(;;)\n+\t  {\n+\t    auto __e = syscall (SYS_futex, static_cast<const void*>(__addr),\n+\t\t\t\t  static_cast<int>(__futex_wait_flags::__wait_private),\n+\t\t\t\t    __val, nullptr);\n+\t    if (!__e)\n+\t      break;\n+\t    else if (!(errno == EINTR || errno == EAGAIN))\n+\t      __throw_system_error(__e);\n+\t  }\n+      }\n+\n+      template<typename _Tp>\n+      void\n+      __platform_notify(const _Tp* __addr, bool __all) noexcept\n+      {\n+\tsyscall (SYS_futex, static_cast<const void*>(__addr),\n+\t\t  static_cast<int>(__futex_wait_flags::__wake_private),\n+\t\t    __all ? INT_MAX : 1);\n+      }\n+#endif\n+\n+    struct __waiters\n+    {\n+       alignas(64) __platform_wait_t _M_ver = 0;\n+       alignas(64) __platform_wait_t _M_wait = 0;\n+\n+#ifndef _GLIBCXX_HAVE_LINUX_FUTEX\n+      using __lock_t = std::unique_lock<std::mutex>;\n+      mutable __lock_t::mutex_type _M_mtx;\n+\n+#  ifdef __GTHREAD_COND_INIT\n+      mutable __gthread_cond_t _M_cv = __GTHREAD_COND_INIT;\n+      __waiters() noexcept = default;\n+#  else\n+      mutable __gthread_cond_t _M_cv;\n+      __waiters() noexcept\n+      {\n+\t__GTHREAD_COND_INIT_FUNCTION(&_M_cond);\n+      }\n+#  endif\n+#endif\n+\n+      __platform_wait_t\n+      _M_enter_wait() noexcept\n+      {\n+\t__platform_wait_t __res;\n+\t__atomic_load(&_M_ver, &__res, __ATOMIC_ACQUIRE);\n+\t__atomic_fetch_add(&_M_wait, 1, __ATOMIC_ACQ_REL);\n+\treturn __res;\n+      }\n+\n+      void\n+      _M_leave_wait() noexcept\n+      {\n+\t__atomic_fetch_sub(&_M_wait, 1, __ATOMIC_ACQ_REL);\n+      }\n+\n+      void\n+      _M_do_wait(__platform_wait_t __version) noexcept\n+      {\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+\t__platform_wait(&_M_ver, __version);\n+#else\n+\t__platform_wait_t __cur = 0;\n+\twhile (__cur <= __version)\n+\t  {\n+\t    __waiters::__lock_t __l(_M_mtx);\n+\t    auto __e = __gthread_cond_wait(&_M_cv, __l.mutex()->native_handle());\n+\t    if (__e)\n+\t      __throw_system_error(__e);\n+\t    __platform_wait_t __last = __cur;\n+\t    __atomic_load(&_M_ver, &__cur, __ATOMIC_ACQUIRE);\n+\t    if (__cur < __last)\n+\t      break; // break the loop if version overflows\n+\t  }\n+#endif\n+      }\n+\n+      bool\n+      _M_waiting() const noexcept\n+\t{\n+\t  __platform_wait_t __res;\n+\t  __atomic_load(&_M_wait, &__res, __ATOMIC_ACQUIRE);\n+\t  return __res;\n+\t}\n+\n+      void\n+      _M_notify(bool __all) noexcept\n+      {\n+\t__atomic_fetch_add(&_M_ver, 1, __ATOMIC_ACQ_REL);\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+\t__platform_notify(&_M_ver, __all);\n+#else\n+\tauto __e = __gthread_cond_broadcast(&_M_cv);\n+\tif (__e)\n+\t  __throw_system_error(__e);\n+#endif\n+      }\n+\n+      static __waiters&\n+      _S_for(const void* __t)\n+      {\n+\tconst unsigned char __mask = 0xf;\n+\tstatic __waiters __w[__mask + 1];\n+\n+\tauto __key = _Hash_impl::hash(__t) & __mask;\n+\treturn __w[__key];\n+      }\n+    };\n+\n+    struct __waiter\n+    {\n+      __waiters& _M_w;\n+      __platform_wait_t _M_version;\n+\n+      template<typename _Tp>\n+\t__waiter(const _Tp* __addr) noexcept\n+\t  : _M_w(__waiters::_S_for(static_cast<const void*>(__addr)))\n+\t  , _M_version(_M_w._M_enter_wait())\n+\t{ }\n+\n+      ~__waiter()\n+      { _M_w._M_leave_wait(); }\n+\n+      void _M_do_wait() noexcept\n+      { _M_w._M_do_wait(_M_version); }\n+    };\n+\n+    void\n+    __thread_relax() noexcept\n+    {\n+#if defined __i386__ || defined __x86_64__\n+      __builtin_ia32_pause();\n+#elif defined _GLIBCXX_USE_SCHED_YIELD\n+      __gthread_yield();\n+#endif\n+    }\n+\n+    void\n+    __thread_yield() noexcept\n+   {\n+#if defined _GLIBCXX_USE_SCHED_YIELD\n+     __gthread_yield();\n+#endif\n+    }\n+\n+  } // namespace __detail\n+\n+  template<typename _Pred>\n+    bool\n+    __atomic_spin(_Pred& __pred) noexcept\n+    {\n+      for (auto __i = 0; __i < __detail::__atomic_spin_count_1; ++__i)\n+\t{\n+\t  if (__pred())\n+\t    return true;\n+\n+\t  if (__i < __detail::__atomic_spin_count_2)\n+\t    __detail::__thread_relax();\n+\t  else\n+\t    __detail::__thread_yield();\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _Tp, typename _Pred>\n+    void\n+    __atomic_wait(const _Tp* __addr, _Tp __old, _Pred __pred) noexcept\n+    {\n+      using namespace __detail;\n+      if (std::__atomic_spin(__pred))\n+\treturn;\n+\n+      __waiter __w(__addr);\n+      while (!__pred())\n+\t{\n+\t  if constexpr (__platform_wait_uses_type<_Tp>)\n+\t    {\n+\t      __platform_wait(__addr, __old);\n+\t    }\n+\t  else\n+\t    {\n+\t      // TODO support timed backoff when this can be moved into the lib\n+\t      __w._M_do_wait();\n+\t    }\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    void\n+    __atomic_notify(const _Tp* __addr, bool __all) noexcept\n+    {\n+      using namespace __detail;\n+      auto& __w = __waiters::_S_for((void*)__addr);\n+      if (!__w._M_waiting())\n+\treturn;\n+\n+      if constexpr (__platform_wait_uses_type<_Tp>)\n+\t{\n+\t  __platform_notify((__platform_wait_t*)(void*) __addr, __all);\n+\t}\n+      else\n+\t{\n+\t  __w._M_notify(__all);\n+\t}\n+    }\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif"}, {"sha": "da6dc4b91858db9559cc6f3c8707cc722c28d298", "filename": "libstdc++-v3/include/bits/semaphore_base.h", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,296 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/semaphore_base.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{semaphore}\n+ */\n+\n+#ifndef _GLIBCXX_SEMAPHORE_BASE_H\n+#define _GLIBCXX_SEMAPHORE_BASE_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <bits/atomic_base.h>\n+#include <bits/atomic_timed_wait.h>\n+\n+#include <ext/numeric_traits.h>\n+\n+#if __has_include(<semaphore.h>)\n+#define _GLIBCXX_HAVE_POSIX_SEMAPHORE 1\n+#include <semaphore.h>\n+#endif\n+\n+#include <chrono>\n+#include <type_traits>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#ifdef _GLIBCXX_HAVE_POSIX_SEMAPHORE\n+  struct __platform_semaphore\n+  {\n+    using __clock_t = chrono::system_clock;\n+    static constexpr ptrdiff_t _S_max = SEM_VALUE_MAX;\n+\n+    explicit __platform_semaphore(ptrdiff_t __count) noexcept\n+    {\n+      sem_init(&_M_semaphore, 0, __count);\n+    }\n+\n+    __platform_semaphore(const __platform_semaphore&) = delete;\n+    __platform_semaphore& operator=(const __platform_semaphore&) = delete;\n+\n+    ~__platform_semaphore()\n+    { sem_destroy(&_M_semaphore); }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_acquire() noexcept\n+    {\n+      for (;;)\n+\t{\n+\t  auto __err = sem_wait(&_M_semaphore);\n+\t  if (__err && (errno == EINTR))\n+\t    continue;\n+\t  else if (__err)\n+\t    std::terminate();\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_release(std::ptrdiff_t __update) noexcept\n+    {\n+      for(; __update != 0; --__update)\n+\t{\n+\t   auto __err = sem_post(&_M_semaphore);\n+\t   if (__err)\n+\t     std::terminate();\n+\t}\n+    }\n+\n+    bool\n+    _M_try_acquire_until_impl(const chrono::time_point<__clock_t>& __atime)\n+      noexcept\n+    {\n+\n+      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+      struct timespec __ts =\n+      {\n+\tstatic_cast<std::time_t>(__s.time_since_epoch().count()),\n+\tstatic_cast<long>(__ns.count())\n+      };\n+\n+      for (;;)\n+\t{\n+\t  if (auto __err = sem_timedwait(&_M_semaphore, &__ts))\n+\t    {\n+\t      if (errno == EINTR)\n+\t\tcontinue;\n+\t      else if (errno == ETIMEDOUT || errno == EINVAL)\n+\t\treturn false;\n+\t      else\n+\t\tstd::terminate();\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+      return true;\n+    }\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      _M_try_acquire_until(const chrono::time_point<_Clock,\n+\t\t\t   _Duration>& __atime) noexcept\n+      {\n+\tif constexpr (std::is_same_v<__clock_t, _Clock>)\n+\t  {\n+\t    return _M_try_acquire_until_impl(__atime);\n+\t  }\n+\telse\n+\t  {\n+\t    const typename _Clock::time_point __c_entry = _Clock::now();\n+\t    const __clock_t __s_entry = __clock_t::now();\n+\t    const auto __delta = __atime - __c_entry;\n+\t    const auto __s_atime = __s_entry + __delta;\n+\t    if (_M_try_acquire_until_impl(__s_atime))\n+\t      return true;\n+\n+\t    // We got a timeout when measured against __clock_t but\n+\t    // we need to check against the caller-supplied clock\n+\t    // to tell whether we should return a timeout.\n+\t    return (_Clock::now() < __atime);\n+\t  }\n+      }\n+\n+    template<typename _Rep, typename _Period>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_try_acquire_for(const chrono::duration<_Rep, _Period>& __rtime)\n+\tnoexcept\n+      { return _M_try_acquire_until(__clock_t::now() + __rtime); }\n+\n+    private:\n+      sem_t _M_semaphore;\n+    };\n+#endif // _GLIBCXX_HAVE_POSIX_SEMAPHORE\n+\n+    template<typename _Tp>\n+      struct __atomic_semaphore\n+      {\n+\tstatic_assert(std::is_integral_v<_Tp>);\n+\tstatic_assert(__gnu_cxx::__int_traits<_Tp>::__max\n+\t\t\t<= __gnu_cxx::__int_traits<ptrdiff_t>::__max);\n+\tstatic constexpr ptrdiff_t _S_max = __gnu_cxx::__int_traits<_Tp>::__max;\n+\n+\texplicit __atomic_semaphore(_Tp __count) noexcept\n+\t  : _M_counter(__count)\n+\t{\n+\t  __glibcxx_assert(__count >= 0 && __count <= _S_max);\n+\t}\n+\n+\t__atomic_semaphore(const __atomic_semaphore&) = delete;\n+\t__atomic_semaphore& operator=(const __atomic_semaphore&) = delete;\n+\n+\t_GLIBCXX_ALWAYS_INLINE void\n+\t_M_acquire() noexcept\n+\t{\n+\t  auto const __pred = [this]\n+\t    {\n+\t      auto __old = __atomic_impl::load(&this->_M_counter,\n+\t\t\t      memory_order::acquire);\n+\t      if (__old == 0)\n+\t\treturn false;\n+\t      return __atomic_impl::compare_exchange_strong(&this->_M_counter,\n+\t\t\t__old, __old - 1,\n+\t\t\tmemory_order::acquire,\n+\t\t\tmemory_order::release);\n+\t    };\n+\t  auto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n+\t  std::__atomic_wait(&_M_counter, __old, __pred);\n+\t}\n+\n+\tbool\n+\t_M_try_acquire() noexcept\n+\t{\n+\t  auto __old = __atomic_impl::load(&_M_counter, memory_order::acquire);\n+\t  auto const __pred = [this, __old]\n+\t    {\n+\t      if (__old == 0)\n+\t\treturn false;\n+\n+\t      auto __prev = __old;\n+\t      return __atomic_impl::compare_exchange_weak(&this->_M_counter,\n+\t\t\t__prev, __prev - 1,\n+\t\t\tmemory_order::acquire,\n+\t\t\tmemory_order::release);\n+\t    };\n+\t  return std::__atomic_spin(__pred);\n+\t}\n+\n+\ttemplate<typename _Clock, typename _Duration>\n+\t  _GLIBCXX_ALWAYS_INLINE bool\n+\t  _M_try_acquire_until(const chrono::time_point<_Clock,\n+\t\t\t       _Duration>& __atime) noexcept\n+\t  {\n+\t    auto const __pred = [this]\n+\t      {\n+\t\tauto __old = __atomic_impl::load(&this->_M_counter,\n+\t\t\t\tmemory_order::acquire);\n+\t\tif (__old == 0)\n+\t\t  return false;\n+\t\treturn __atomic_impl::compare_exchange_strong(&this->_M_counter,\n+\t\t\t\t__old, __old - 1,\n+\t\t\t\tmemory_order::acquire,\n+\t\t\t\tmemory_order::release);\n+\t      };\n+\n+\t    auto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n+\t    return __atomic_wait_until(&_M_counter, __old, __pred, __atime);\n+\t}\n+\n+      template<typename _Rep, typename _Period>\n+\t_GLIBCXX_ALWAYS_INLINE bool\n+\t_M_try_acquire_for(const chrono::duration<_Rep, _Period>& __rtime)\n+\t  noexcept\n+\t{\n+\t  auto const __pred = [this]\n+\t    {\n+\t      auto __old = __atomic_impl::load(&this->_M_counter,\n+\t\t\t      memory_order::acquire);\n+\t      if (__old == 0)\n+\t\treturn false;\n+\t      return  __atomic_impl::compare_exchange_strong(&this->_M_counter,\n+\t\t\t      __old, __old - 1,\n+\t\t\t      memory_order::acquire,\n+\t\t\t      memory_order::release);\n+\t    };\n+\n+\t  auto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n+\t  return __atomic_wait_for(&_M_counter, __old, __pred, __rtime);\n+\t}\n+\n+      _GLIBCXX_ALWAYS_INLINE void\n+      _M_release(ptrdiff_t __update) noexcept\n+      {\n+\tif (0 < __atomic_impl::fetch_add(&_M_counter, __update, memory_order_release))\n+\t  return;\n+\tif (__update > 1)\n+\t  __atomic_impl::notify_all(&_M_counter);\n+\telse\n+\t  __atomic_impl::notify_one(&_M_counter);\n+      }\n+\n+    private:\n+      alignas(__alignof__(_Tp)) _Tp _M_counter;\n+    };\n+\n+// Note: the _GLIBCXX_REQUIRE_POSIX_SEMAPHORE macro can be used to force the\n+// use of Posix semaphores (sem_t). Doing so however, alters the ABI.\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX && !_GLIBCXX_REQUIRE_POSIX_SEMAPHORE\n+  // Use futex if available and didn't force use of POSIX\n+  using __fast_semaphore = __atomic_semaphore<__detail::__platform_wait_t>;\n+#elif _GLIBCXX_HAVE_POSIX_SEMAPHORE\n+  using __fast_semaphore = __platform_semaphore;\n+#else\n+  using __fast_semaphore = __atomic_semaphore<ptrdiff_t>;\n+#endif\n+\n+template<ptrdiff_t __least_max_value>\n+  using __semaphore_impl = conditional_t<\n+\t\t(__least_max_value > 1),\n+\t\tconditional_t<\n+\t\t    (__least_max_value <= __fast_semaphore::_S_max),\n+\t\t    __fast_semaphore,\n+\t\t    __atomic_semaphore<ptrdiff_t>>,\n+\t\t__fast_semaphore>;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif"}, {"sha": "5afe33b41d9b01b53f151f15a775c57ade51c796", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -163,6 +163,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     compare_exchange_strong(bool& __i1, bool __i2,\n \t\t    memory_order __m = memory_order_seq_cst) volatile noexcept\n     { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n+\n+#if __cplusplus > 201703L\n+    void wait(bool __old, memory_order __m = memory_order_seq_cst) const\n+      noexcept\n+    { _M_base.wait(__old, __m); }\n+\n+    // TODO add const volatile overload\n+\n+    void notify_one() const noexcept\n+    { _M_base.notify_one(); }\n+\n+    void notify_all() const noexcept\n+    { _M_base.notify_all(); }\n+#endif\n   };\n \n #if __cplusplus <= 201703L\n@@ -363,6 +377,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     memory_order __m = memory_order_seq_cst) volatile noexcept\n       { return compare_exchange_strong(__e, __i, __m,\n                                        __cmpexch_failure_order(__m)); }\n+\n+#if __cplusplus > 201703L\n+    void wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n+    {\n+      std::__atomic_wait(&_M_i, __old,\n+\t\t\t [__m, this, __old]\n+\t\t\t {\n+\t\t\t   const auto __v = this->load(__m);\n+\t\t\t   // TODO make this ignore padding bits when we\n+\t\t\t   // can do that\n+\t\t\t   return __builtin_memcmp(&__old, &__v,\n+\t\t\t\t\t\t    sizeof(_Tp)) != 0;\n+\t\t\t });\n+    }\n+\n+    // TODO add const volatile overload\n+\n+    void notify_one() const noexcept\n+    { std::__atomic_notify(&_M_i, false); }\n+\n+    void notify_all() const noexcept\n+    { std::__atomic_notify(&_M_i, true); }\n+#endif\n+\n     };\n #undef _GLIBCXX20_INIT\n \n@@ -601,6 +639,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t    __cmpexch_failure_order(__m));\n       }\n \n+#if __cplusplus > 201703L\n+    void wait(__pointer_type __old,\n+\t      memory_order __m = memory_order_seq_cst) noexcept\n+    { _M_b.wait(__old, __m); }\n+\n+    // TODO add const volatile overload\n+\n+    void notify_one() const noexcept\n+    { _M_b.notify_one(); }\n+\n+    void notify_all() const noexcept\n+    { _M_b.notify_all(); }\n+#endif\n       __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n@@ -1353,6 +1404,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t     memory_order_seq_cst);\n     }\n \n+\n+#if __cplusplus > 201703L\n+  template<typename _Tp>\n+    inline void\n+    atomic_wait(const atomic<_Tp>* __a,\n+\t        typename std::atomic<_Tp>::value_type __old) noexcept\n+    { __a->wait(__old); }\n+\n+  template<typename _Tp>\n+    inline void\n+    atomic_wait_explicit(const atomic<_Tp>* __a,\n+\t\t\t typename std::atomic<_Tp>::value_type __old,\n+\t\t\t std::memory_order __m) noexcept\n+    { __a->wait(__old, __m); }\n+\n+  template<typename _Tp>\n+    inline void\n+    atomic_notify_one(atomic<_Tp>* __a) noexcept\n+    { __a->notify_one(); }\n+\n+  template<typename _Tp>\n+    inline void\n+    atomic_notify_all(atomic<_Tp>* __a) noexcept\n+    { __a->notify_all(); }\n+\n+#endif // C++2a\n+\n   // Function templates for atomic_integral and atomic_pointer operations only.\n   // Some operations (and, or, xor) are only available for atomic integrals,\n   // which is implemented by taking a parameter of type __atomic_base<_ITp>*."}, {"sha": "9d9c880a88bd49516fb4b15e05ccaa698ca30e53", "filename": "libstdc++-v3/include/std/latch", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,91 @@\n+// <latch> -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.\tThis library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.\t If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/latch\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_LATCH\n+#define _GLIBCXX_LATCH\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L\n+#define __cpp_lib_latch 201907L\n+\n+#include <bits/atomic_base.h>\n+#include <ext/numeric_traits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  class latch\n+  {\n+  public:\n+    static constexpr ptrdiff_t\n+    max() noexcept\n+    { return __gnu_cxx::__int_traits<ptrdiff_t>::__max; }\n+\n+    constexpr explicit latch(ptrdiff_t __expected) noexcept\n+      : _M_a(__expected) { }\n+\n+    ~latch() = default;\n+    latch(const latch&) = delete;\n+    latch& operator=(const latch&) = delete;\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    count_down(ptrdiff_t __update = 1)\n+    {\n+      auto const __old = __atomic_impl::fetch_sub(&_M_a,\n+\t\t\t\t    __update, memory_order::release);\n+      if (__old == __update)\n+\t__atomic_impl::notify_all(&_M_a);\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    try_wait() const noexcept\n+    { return __atomic_impl::load(&_M_a, memory_order::acquire) == 0; }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    wait() const noexcept\n+    {\n+      auto const __old = __atomic_impl::load(&_M_a, memory_order::acquire);\n+      std::__atomic_wait(&_M_a, __old, [this] { return this->try_wait(); });\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    arrive_and_wait(ptrdiff_t __update = 1) noexcept\n+    {\n+      count_down(__update);\n+      wait();\n+    }\n+\n+  private:\n+    alignas(__alignof__(ptrdiff_t)) ptrdiff_t _M_a;\n+  };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // __cplusplus > 201703L\n+#endif // _GLIBCXX_LATCH"}, {"sha": "b4facde4ea1f4e752b5af00956c5cfd58007a234", "filename": "libstdc++-v3/include/std/semaphore", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,92 @@\n+// <semaphore> -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.\tThis library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.\t If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/semaphore\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_SEMAPHORE\n+#define _GLIBCXX_SEMAPHORE\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L\n+#define __cpp_lib_semaphore 201907L\n+#include <bits/semaphore_base.h>\n+#include <ext/numeric_traits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<ptrdiff_t __least_max_value =\n+\t\t\t__gnu_cxx::__int_traits<ptrdiff_t>::__max>\n+    class counting_semaphore\n+    {\n+      static_assert(__least_max_value >= 0);\n+\n+      __semaphore_impl<__least_max_value> _M_sem;\n+\n+    public:\n+      explicit counting_semaphore(ptrdiff_t __desired) noexcept\n+\t: _M_sem(__desired)\n+      { }\n+\n+      ~counting_semaphore() = default;\n+\n+      counting_semaphore(const counting_semaphore&) = delete;\n+      counting_semaphore& operator=(const counting_semaphore&) = delete;\n+\n+      static constexpr ptrdiff_t\n+      max() noexcept\n+      { return __least_max_value; }\n+\n+      void\n+      release(ptrdiff_t __update = 1) noexcept(noexcept(_M_sem._M_release(1)))\n+      { _M_sem._M_release(__update); }\n+\n+      void\n+      acquire() noexcept(noexcept(_M_sem._M_acquire()))\n+      { _M_sem._M_acquire(); }\n+\n+      bool\n+      try_acquire() noexcept(noexcept(_M_sem._M_try_acquire()))\n+      { return _M_sem._M_try_acquire(); }\n+\n+      template<typename _Rep, typename _Period>\n+\tbool\n+\ttry_acquire_for(const std::chrono::duration<_Rep, _Period>& __rtime)\n+\t{ return _M_sem._M_try_acquire_for(__rtime); }\n+\n+      template<typename _Clock, typename _Dur>\n+\tbool\n+\ttry_acquire_until(const std::chrono::time_point<_Clock, _Dur>& __atime)\n+\t{ return _M_sem._M_try_acquire_until(__atime); }\n+    };\n+\n+ using binary_semaphore = std::counting_semaphore<1>;\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // __cplusplus > 201703L\n+#endif // _GLIBCXX_SEMAPHORE"}, {"sha": "42ed7cb74d38ce02845afc134ac0c9efa9063a3d", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -216,6 +216,7 @@\n #ifdef _GLIBCXX_HAS_GTHREADS\n # define __cpp_lib_jthread 201911L\n #endif\n+#define __cpp_lib_latch 201907L\n #define __cpp_lib_list_remove_return_type 201806L\n #if __cpp_lib_concepts\n # define __cpp_lib_make_obj_using_allocator 201811L\n@@ -225,6 +226,7 @@\n #if __cpp_lib_concepts\n # define __cpp_lib_ranges 201911L\n #endif\n+#define __cpp_lib_semaphore 201907L\n #define __cpp_lib_shift 201806L\n #if __cpp_lib_concepts\n # define __cpp_lib_span 202002L"}, {"sha": "5f1e30a710fe732828a2e8fc7737092da43a7afb", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/bool.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#include <type_traits>\n+#include <chrono>\n+\n+#include <testsuite_hooks.h>\n+\n+int\n+main ()\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic<bool> a(false);\n+  std::atomic<bool> b(false);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(false);\n+\t\t  if (a.load())\n+\t\t    {\n+\t\t      b.store(true);\n+\t\t    }\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(true);\n+  a.notify_one();\n+  t.join();\n+  VERIFY( b.load() );\n+  return 0;\n+}"}, {"sha": "0249341055cc5aa8d9f4a30a073a2ac4cb2ae167", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/generic.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"atomic/wait_notify_util.h\"\n+\n+int\n+main ()\n+{\n+  struct S{ int i; };\n+  check<S> check_s{S{0},S{42}};\n+  return 0;\n+}"}, {"sha": "8531bb2e78802cb64ddad2c4ae0067bb8ee6adad", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/pointers.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#include <type_traits>\n+#include <chrono>\n+\n+#include <testsuite_hooks.h>\n+\n+int\n+main ()\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  long aa;\n+  long bb;\n+\n+  std::atomic<long*> a(nullptr);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(nullptr);\n+\t\t  if (a.load() == &aa)\n+\t\t    a.store(&bb);\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(&aa);\n+  a.notify_one();\n+  t.join();\n+  VERIFY( a.load() == &bb);\n+  return 0;\n+}"}, {"sha": "4f026e1dc9c1bbe50c00c772a93cf249ea46572f", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <chrono>\n+#include <condition_variable>\n+#include <concepts>\n+#include <mutex>\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n+\n+int\n+main()\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic_flag a;\n+  std::atomic_flag b;\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(false);\n+\t\t  b.test_and_set();\n+\t\t  b.notify_one();\n+\t\t});\n+\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.test_and_set();\n+  a.notify_one();\n+  b.wait(false);\n+  t.join();\n+\n+  VERIFY( a.test() );\n+  VERIFY( b.test() );\n+  return 0;\n+}"}, {"sha": "640a84e0342e061b9471763ffaeb9322b8efa7ff", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_float/wait_notify.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"atomic/wait_notify_util.h\"\n+\n+int\n+main ()\n+{\n+  check<float> f;\n+  check<double> d;\n+  return 0;\n+}"}, {"sha": "6e9ee7dbf93f1ac2f7a22f29b78d18ea04da870a", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/wait_notify.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"atomic/wait_notify_util.h\"\n+\n+void\n+test01()\n+{\n+  struct S{ int i; };\n+  std::atomic<S> s;\n+\n+  s.wait(S{42});\n+}\n+\n+int\n+main ()\n+{\n+  // check<bool> bb;\n+  check<char> ch;\n+  check<signed char> sch;\n+  check<unsigned char> uch;\n+  check<short> s;\n+  check<unsigned short> us;\n+  check<int> i;\n+  check<unsigned int> ui;\n+  check<long> l;\n+  check<unsigned long> ul;\n+  check<long long> ll;\n+  check<unsigned long long> ull;\n+\n+  check<wchar_t> wch;\n+  check<char8_t> ch8;\n+  check<char16_t> ch16;\n+  check<char32_t> ch32;\n+\n+  check<int8_t> i8;\n+  check<int16_t> i16;\n+  check<int32_t> i32;\n+  check<int64_t> i64;\n+\n+  check<uint8_t> u8;\n+  check<uint16_t> u16;\n+  check<uint32_t> u32;\n+  check<uint64_t> u64;\n+  return 0;\n+}"}, {"sha": "dc5ae7a21eac7cae2e55bff5c3575abc2ae8bf79", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/wait_notify.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#include <chrono>\n+#include <type_traits>\n+\n+#include <testsuite_hooks.h>\n+\n+template<typename Tp>\n+Tp check_wait_notify(Tp val1, Tp val2)\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  Tp aa = val1;\n+  std::atomic_ref<Tp> a(aa);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(val1);\n+\t\t  if (a.load() != val2)\n+\t\t    a = val1;\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(val2);\n+  a.notify_one();\n+  t.join();\n+  return a.load();\n+}\n+\n+template<typename Tp,\n+\t bool = std::is_integral_v<Tp>\n+\t || std::is_floating_point_v<Tp>>\n+struct check;\n+\n+template<typename Tp>\n+struct check<Tp, true>\n+{\n+  check()\n+  {\n+    Tp a = 0;\n+    Tp b = 42;\n+    VERIFY(check_wait_notify(a, b) == b);\n+  }\n+};\n+\n+template<typename Tp>\n+struct check<Tp, false>\n+{\n+  check(Tp b)\n+  {\n+    Tp a;\n+    VERIFY(check_wait_notify(a, b) == b);\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  check<long>();\n+  check<double>();\n+  return 0;\n+}"}, {"sha": "aa203cdf525248568c7dea8602870951be72d99a", "filename": "libstdc++-v3/testsuite/30_threads/latch/1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F1.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <latch>\n+\n+#ifndef __cpp_lib_latch\n+# error \"Feature-test macro for latch missing in <latch>\"\n+#elif __cpp_lib_latch!= 201907L\n+# error \"Feature-test macro for latch has wrong value in <latch>\"\n+#endif"}, {"sha": "318a859ee21b7f69bb3cc3bf1cb113bf24f0923c", "filename": "libstdc++-v3/testsuite/30_threads/latch/2.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F2.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_latch\n+# error \"Feature-test macro for latch missing in <version>\"\n+#elif __cpp_lib_latch != 201907L\n+# error \"Feature-test macro for latch has wrong value in <version>\"\n+#endif"}, {"sha": "5d08000f4302abd13ee06ebb19a3113aff08bf65", "filename": "libstdc++-v3/testsuite/30_threads/latch/3.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flatch%2F3.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+//\n+#include <latch>\n+#include <atomic>\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::latch l(3);\n+\n+  VERIFY( !l.try_wait() );\n+\n+  auto fn = [&]\n+  {\n+    l.count_down();\n+  };\n+\n+  std::thread t0(fn);\n+  std::thread t1(fn);\n+\n+  l.arrive_and_wait();\n+  t0.join();\n+  t1.join();\n+\n+  VERIFY( l.try_wait() );\n+}\n+\n+void\n+test02()\n+{\n+  std::latch l(3);\n+  std::thread t([&]\n+    {\n+      l.count_down();\n+    });\n+\n+  l.arrive_and_wait(2);\n+  t.join();\n+  VERIFY( l.try_wait() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1bbca687fc35948d84a8d164fb25d75a699e44e9", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F1.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <semaphore>\n+\n+#ifndef __cpp_lib_semaphore\n+# error \"Feature-test macro for semaphore missing in <semaphore>\"\n+#elif __cpp_lib_semaphore != 201907L\n+# error \"Feature-test macro for semaphore has wrong value in <semaphore>\"\n+#endif"}, {"sha": "98743f5e27c4539d1434cdc8a6d1240feaefef7b", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/2.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2F2.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_semaphore\n+# error \"Feature-test macro for semaphore missing in <version>\"\n+#elif __cpp_lib_semaphore != 201907L\n+# error \"Feature-test macro for semaphore has wrong value in <version>\"\n+#endif"}, {"sha": "d74cfad53e986950aee9244bafdb15d6dba7eae2", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/least_max_value_neg.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Fleast_max_value_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Fleast_max_value_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Fleast_max_value_neg.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <semaphore>\n+\n+int main()\n+{\n+  std::counting_semaphore<-1> sem(2);\n+  return 0;\n+}\n+// { dg-error \"static assertion failed\" \"\" {  target *-*-* } 0 }"}, {"sha": "25280441d078990b67002619e22710baba9536ae", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/try_acquire.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <semaphore>\n+#include <limits>\n+#include <cstddef>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::counting_semaphore<10> s(3);\n+\n+  s.acquire();\n+  VERIFY( s.try_acquire() );\n+  VERIFY( s.try_acquire() );\n+  VERIFY( !s.try_acquire() );\n+  s.release();\n+  VERIFY( s.try_acquire() );\n+}\n+\n+void test02()\n+{\n+  std::binary_semaphore s(1);\n+\n+  s.acquire();\n+  VERIFY( !s.try_acquire() );\n+  s.release();\n+  VERIFY( s.try_acquire() );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "3f450e7466182ee40090e357825891835ffa9a22", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/try_acquire_for.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_for.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_for.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_for.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <semaphore>\n+#include <chrono>\n+#include <thread>\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std::chrono_literals;\n+  std::counting_semaphore<10> s(2);\n+  s.acquire();\n+\n+  auto const dur = 250ms;\n+  {\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( s.try_acquire_for(dur) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff < dur );\n+  }\n+\n+  {\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( !s.try_acquire_for(dur) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff >= dur );\n+  }\n+}\n+\n+void test02()\n+{\n+  using namespace std::chrono_literals;\n+  std::binary_semaphore s(1);\n+  std::atomic<int> a(0), b(0);\n+  std::thread t([&] {\n+    a.wait(0);\n+    auto const dur = 250ms;\n+    VERIFY( !s.try_acquire_for(dur) );\n+    b++;\n+    b.notify_one();\n+\n+    a.wait(1);\n+    VERIFY( s.try_acquire_for(dur) );\n+    b++;\n+    b.notify_one();\n+  });\n+  t.detach();\n+\n+  s.acquire();\n+  a++;\n+  a.notify_one();\n+  b.wait(0);\n+  s.release();\n+  a++;\n+  a.notify_one();\n+\n+  b.wait(1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "13bd7487d563a970f098313b146f6937a177f1a9", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/try_acquire_posix.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_posix.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,153 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <semaphore>\n+#ifdef _GLIBCXX_HAVE_POSIX_SEMAPHORE\n+#include <chrono>\n+#include <thread>\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std::chrono_literals;\n+  std::__platform_semaphore s(2);\n+  s._M_acquire();\n+\n+  auto const dur = 250ms;\n+  {\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( s._M_try_acquire_for(dur) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff < dur );\n+  }\n+\n+  {\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( !s._M_try_acquire_for(dur) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff >= dur );\n+  }\n+}\n+\n+void test02()\n+{\n+  using namespace std::chrono_literals;\n+  std::__platform_semaphore s(1);\n+  std::atomic<int> a(0), b(0);\n+  std::thread t([&] {\n+    a.wait(0);\n+    auto const dur = 250ms;\n+    VERIFY( !s._M_try_acquire_for(dur) );\n+    b++;\n+    b.notify_one();\n+\n+    a.wait(1);\n+    VERIFY( s._M_try_acquire_for(dur) );\n+    b++;\n+    b.notify_one();\n+  });\n+  t.detach();\n+\n+  s._M_acquire();\n+  a++;\n+  a.notify_one();\n+  b.wait(0);\n+  s._M_release(1);\n+  a++;\n+  a.notify_one();\n+\n+  b.wait(1);\n+}\n+\n+void test03()\n+{\n+  using namespace std::chrono_literals;\n+  std::__platform_semaphore s(2);\n+  s._M_acquire();\n+\n+  auto const dur = 250ms;\n+  {\n+    auto const at = std::chrono::system_clock::now() + dur;\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( s._M_try_acquire_until(at) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff < dur );\n+  }\n+\n+  {\n+    auto const at = std::chrono::system_clock::now() + dur;\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( !s._M_try_acquire_until(at) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff >= dur );\n+  }\n+}\n+\n+void test04()\n+{\n+  using namespace std::chrono_literals;\n+  std::__platform_semaphore s(1);\n+  std::atomic<int> a(0), b(0);\n+  std::thread t([&] {\n+    a.wait(0);\n+    auto const dur = 250ms;\n+    {\n+      auto const at = std::chrono::system_clock::now() + dur;\n+      VERIFY( !s._M_try_acquire_until(at) );\n+\n+      b++;\n+      b.notify_one();\n+    }\n+\n+    a.wait(1);\n+    {\n+      auto const at = std::chrono::system_clock::now() + dur;\n+      VERIFY( s._M_try_acquire_until(at) );\n+    }\n+    b++;\n+    b.notify_one();\n+  });\n+  t.detach();\n+\n+  s._M_acquire();\n+  a++;\n+  a.notify_one();\n+  b.wait(0);\n+  s._M_release(1);\n+  a++;\n+  a.notify_one();\n+\n+  b.wait(1);\n+}\n+#endif\n+\n+int main()\n+{\n+#ifdef _GLIBCXX_HAVE_POSIX_SEMAPHORE\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+#endif\n+  return 0;\n+}"}, {"sha": "af7ab7bac39527abe11358aa858dfee5945b7e49", "filename": "libstdc++-v3/testsuite/30_threads/semaphore/try_acquire_until.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_until.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_until.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fsemaphore%2Ftry_acquire_until.cc?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,94 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <semaphore>\n+#include <chrono>\n+#include <thread>\n+#include <atomic>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std::chrono_literals;\n+  std::counting_semaphore<10> s(2);\n+  s.acquire();\n+\n+  auto const dur = 250ms;\n+  {\n+    auto const at = std::chrono::system_clock::now() + dur;\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( s.try_acquire_until(at) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff < dur );\n+  }\n+\n+  {\n+    auto const at = std::chrono::system_clock::now() + dur;\n+    auto const t0 = std::chrono::steady_clock::now();\n+    VERIFY( !s.try_acquire_until(at) );\n+    auto const diff = std::chrono::steady_clock::now() - t0;\n+    VERIFY( diff >= dur );\n+  }\n+}\n+\n+void test02()\n+{\n+  using namespace std::chrono_literals;\n+  std::binary_semaphore s(1);\n+  std::atomic<int> a(0), b(0);\n+  std::thread t([&] {\n+    a.wait(0);\n+    auto const dur = 250ms;\n+    {\n+      auto const at = std::chrono::system_clock::now() + dur;\n+      VERIFY( !s.try_acquire_until(at) );\n+\n+      b++;\n+      b.notify_one();\n+    }\n+\n+    a.wait(1);\n+    {\n+      auto const at = std::chrono::system_clock::now() + dur;\n+      VERIFY( s.try_acquire_until(at) );\n+    }\n+    b++;\n+    b.notify_one();\n+  });\n+  t.detach();\n+\n+  s.acquire();\n+  a++;\n+  a.notify_one();\n+  b.wait(0);\n+  s.release();\n+  a++;\n+  a.notify_one();\n+\n+  b.wait(1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "a319e8b60a696fa65a8eda6f6e30f7b683527a8e", "filename": "libstdc++-v3/testsuite/util/atomic/wait_notify_util.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fatomic%2Fwait_notify_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a1beee2766f01a1f46f81ed53f679419318942/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fatomic%2Fwait_notify_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fatomic%2Fwait_notify_util.h?ref=83a1beee2766f01a1f46f81ed53f679419318942", "patch": "@@ -0,0 +1,160 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+#include <chrono>\n+#include <condition_variable>\n+#include <concepts>\n+#include <mutex>\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n+\n+#include <iostream>\n+\n+template<typename Tp>\n+Tp check_wait_notify(Tp val1, Tp val2)\n+  requires std::equality_comparable<Tp>\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic<Tp> a(val1);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(val1);\n+\t\t  if (a.load() != val2)\n+\t\t    a = val1;\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(val2);\n+  a.notify_one();\n+  t.join();\n+  return a.load();\n+}\n+\n+template<typename Tp>\n+Tp check_wait_notify(Tp val1, Tp val2)\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic<Tp> a(val1);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  a.wait(val1);\n+\t\t  auto v = a.load();\n+\t\t  // TODO this needs to zero padding bits when we can do that\n+\t\t  if (__builtin_memcmp(&v, &val2, sizeof(Tp)) != 0)\n+\t\t    a = val1;\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(val2);\n+  a.notify_one();\n+  t.join();\n+  return a.load();\n+}\n+\n+template<typename Tp>\n+Tp check_atomic_wait_notify(Tp val1, Tp val2)\n+  requires std::equality_comparable<Tp>\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic<Tp> a(val1);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  std::atomic_wait(&a, val1);\n+\t\t  if (a.load() != val2)\n+\t\t    a = val1;\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(val2);\n+  std::atomic_notify_one(&a);\n+  t.join();\n+  return a.load();\n+}\n+\n+template<typename Tp>\n+Tp check_atomic_wait_notify(Tp val1, Tp val2)\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  std::mutex m;\n+  std::condition_variable cv;\n+\n+  std::atomic<Tp> a(val1);\n+  std::thread t([&]\n+\t\t{\n+\t\t  cv.notify_one();\n+\t\t  std::atomic_wait(&a, val1);\n+\t\t  auto v = a.load();\n+\t\t  // TODO this needs to zero padding bits when we can do that\n+\t\t  if (__builtin_memcmp(&v, &val2, sizeof(Tp)) != 0)\n+\t\t    a = val1;\n+\t\t});\n+  std::unique_lock<std::mutex> l(m);\n+  cv.wait(l);\n+  std::this_thread::sleep_for(100ms);\n+  a.store(val2);\n+  std::atomic_notify_one(&a);\n+  t.join();\n+  return a.load();\n+}\n+\n+template<typename Tp>\n+struct check\n+{\n+  check(Tp a = 0, Tp b = 42)\n+  {\n+    if constexpr (std::equality_comparable<Tp>)\n+    {\n+      VERIFY( check_wait_notify(a, b) == b);\n+      VERIFY( check_atomic_wait_notify(a, b) == b);\n+    }\n+    else\n+    {\n+      {\n+\t// TODO this needs to zero padding bits when we can do that\n+\tauto v = check_wait_notify(a, b);\n+\tVERIFY( __builtin_memcmp(&v, &b, sizeof(Tp)) == 0 );\n+      }\n+\n+      {\n+\t// TODO this needs to zero padding bits when we can do that\n+\tauto v = check_atomic_wait_notify(a, b);\n+\tVERIFY( __builtin_memcmp(&v, &b, sizeof(Tp)) == 0);\n+      }\n+    }\n+  }\n+};"}]}