{"sha": "78cc4167bcd0392c21b3db4682415245bfead558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjYzQxNjdiY2QwMzkyYzIxYjNkYjQ2ODI0MTUyNDViZmVhZDU1OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-01T22:26:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-01T22:26:12Z"}, "message": "tree-sra.c (sra_walk_expr): Don't maybe_lookup_element_for_expr in order to disable scalarization.\n\n        * tree-sra.c (sra_walk_expr): Don't maybe_lookup_element_for_expr\n        in order to disable scalarization.  Instead set a flag and wait\n        for a candidate decl.\n\nFrom-SVN: r84001", "tree": {"sha": "8642a57541f237700abdd68abbb181a33c0c08c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8642a57541f237700abdd68abbb181a33c0c08c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78cc4167bcd0392c21b3db4682415245bfead558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cc4167bcd0392c21b3db4682415245bfead558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78cc4167bcd0392c21b3db4682415245bfead558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cc4167bcd0392c21b3db4682415245bfead558/comments", "author": null, "committer": null, "parents": [{"sha": "2eac577f17210ba9b9e3780cee6c6dbefa0298e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eac577f17210ba9b9e3780cee6c6dbefa0298e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eac577f17210ba9b9e3780cee6c6dbefa0298e6"}], "stats": {"total": 22, "additions": 13, "deletions": 9}, "files": [{"sha": "c2512885a470383f596561d9849faa381f805fd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cc4167bcd0392c21b3db4682415245bfead558/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cc4167bcd0392c21b3db4682415245bfead558/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78cc4167bcd0392c21b3db4682415245bfead558", "patch": "@@ -1,3 +1,9 @@\n+2004-07-01  Richard Henderson  <rth@redhat.com>\n+\n+        * tree-sra.c (sra_walk_expr): Don't maybe_lookup_element_for_expr\n+        in order to disable scalarization.  Instead set a flag and wait\n+        for a candidate decl.\n+\n 2004-07-01  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/cppinternals.texi, doc/install.texi, doc/invoke.texi,"}, {"sha": "2642dfea7edf1cefeff07a5967ca48abe0d319f3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cc4167bcd0392c21b3db4682415245bfead558/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cc4167bcd0392c21b3db4682415245bfead558/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=78cc4167bcd0392c21b3db4682415245bfead558", "patch": "@@ -615,6 +615,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n {\n   tree expr = *expr_p;\n   tree inner = expr;\n+  bool disable_scalarization = false;\n \n   /* We're looking to collect a reference expression between EXPR and INNER,\n      such that INNER is a scalarizable decl and all other nodes through EXPR\n@@ -632,7 +633,10 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \tif (is_sra_candidate_decl (inner))\n \t  {\n \t    struct sra_elt *elt = maybe_lookup_element_for_expr (expr);\n-\t    fns->use (elt, expr_p, bsi, is_output);\n+\t    if (disable_scalarization)\n+\t      elt->cannot_scalarize = true;\n+\t    else\n+\t      fns->use (elt, expr_p, bsi, is_output);\n \t  }\n \treturn;\n \n@@ -649,14 +653,8 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \t   without duplicating too much code.  */\n \tif (!is_valid_const_index (inner))\n \t  {\n-\t    if (fns->initial_scan)\n-\t      {\n-\t\tstruct sra_elt *elt\n-\t\t  = maybe_lookup_element_for_expr (TREE_OPERAND (inner, 0));\n-\t\tif (elt)\n-\t\t  elt->cannot_scalarize = true;\n-\t      }\n-\t    return;\n+\t    disable_scalarization = true;\n+\t    goto use_all;\n \t  }\n \t/* ??? Are we assured that non-constant bounds and stride will have\n \t   the same value everywhere?  I don't think Fortran will...  */"}]}