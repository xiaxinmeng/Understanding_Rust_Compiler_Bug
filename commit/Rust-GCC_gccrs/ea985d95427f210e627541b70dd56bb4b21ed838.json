{"sha": "ea985d95427f210e627541b70dd56bb4b21ed838", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5ODVkOTU0MjdmMjEwZTYyNzU0MWI3MGRkNTZiYjRiMjFlZDgzOA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-12-09T17:19:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:19:33Z"}, "message": "exp_util.ads, [...] (Is_Ref_To_Bit_Packed_Slice): Handle case of type conversion.\n\n2005-12-05  Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.ads, exp_util.adb (Is_Ref_To_Bit_Packed_Slice): Handle case\n\tof type conversion.\n\t(Find_Interface): New subprogram that given a tagged type and one of its\n\tcomponent associated with the secondary table of an abstract interface\n\ttype, return the entity associated with such abstract interface type.\n\t(Make_Subtype_From_Expr): If type has unknown discriminants, always use\n\tbase type to create anonymous subtype, because entity may be a locally\n\tdeclared subtype or generic actual.\n\t(Find_Interface): New subprogram that given a tagged type and one of its\n\tcomponent associated with the secondary table of an abstract interface\n\ttype, return the entity associated with such abstract interface type.\n\n\t* sem_res.adb (Resolve_Type_Conversion): Handle the case in which the\n\tconversion cannot be handled at compile time. In this case we pass this\n\tinformation to the expander to generate the appropriate code.\n\nFrom-SVN: r108294", "tree": {"sha": "d80dcb32baa9ca80225cb974ec83c8600812eaf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d80dcb32baa9ca80225cb974ec83c8600812eaf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea985d95427f210e627541b70dd56bb4b21ed838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea985d95427f210e627541b70dd56bb4b21ed838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea985d95427f210e627541b70dd56bb4b21ed838", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea985d95427f210e627541b70dd56bb4b21ed838/comments", "author": null, "committer": null, "parents": [{"sha": "e6d9df3c650d24bcd50b5df61d4656dea3e974da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d9df3c650d24bcd50b5df61d4656dea3e974da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d9df3c650d24bcd50b5df61d4656dea3e974da"}], "stats": {"total": 217, "additions": 168, "deletions": 49}, "files": [{"sha": "997fc7b7b9012c7153ebed0296df0c8e29a73695", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 108, "deletions": 10, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ea985d95427f210e627541b70dd56bb4b21ed838", "patch": "@@ -1447,7 +1447,7 @@ package body Exp_Util is\n       Iface : Entity_Id) return Entity_Id\n    is\n       ADT   : Elmt_Id;\n-      Found : Boolean := False;\n+      Found : Boolean   := False;\n       Typ   : Entity_Id := T;\n \n       procedure Find_Secondary_Table (Typ : Entity_Id);\n@@ -1544,9 +1544,9 @@ package body Exp_Util is\n       procedure Find_Tag (Typ : in Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n-      -----------------\n-      -- Find_AI_Tag --\n-      -----------------\n+      --------------\n+      -- Find_Tag --\n+      --------------\n \n       procedure Find_Tag (Typ : in Entity_Id) is\n          AI_Elmt : Elmt_Id;\n@@ -1642,6 +1642,101 @@ package body Exp_Util is\n       return AI_Tag;\n    end Find_Interface_Tag;\n \n+   --------------------\n+   -- Find_Interface --\n+   --------------------\n+\n+   function Find_Interface\n+     (T      : Entity_Id;\n+      Comp   : Entity_Id) return Entity_Id\n+   is\n+      AI_Tag : Entity_Id;\n+      Found  : Boolean := False;\n+      Iface  : Entity_Id;\n+      Typ    : Entity_Id := T;\n+\n+      procedure Find_Iface (Typ : in Entity_Id);\n+      --  Internal subprogram used to recursively climb to the ancestors\n+\n+      ----------------\n+      -- Find_Iface --\n+      ----------------\n+\n+      procedure Find_Iface (Typ : in Entity_Id) is\n+         AI_Elmt : Elmt_Id;\n+\n+      begin\n+         --  Climb to the root type\n+\n+         if Etype (Typ) /= Typ then\n+            Find_Iface (Etype (Typ));\n+         end if;\n+\n+         --  Traverse the list of interfaces implemented by the type\n+\n+         if not Found\n+           and then Present (Abstract_Interfaces (Typ))\n+           and then not (Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n+         then\n+            --  Skip the tag associated with the primary table\n+\n+            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+            AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n+            pragma Assert (Present (AI_Tag));\n+\n+            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+            while Present (AI_Elmt) loop\n+               if AI_Tag = Comp then\n+                  Iface := Node (AI_Elmt);\n+                  Found := True;\n+                  return;\n+               end if;\n+\n+               AI_Tag := Next_Tag_Component (AI_Tag);\n+               Next_Elmt (AI_Elmt);\n+            end loop;\n+         end if;\n+      end Find_Iface;\n+\n+   --  Start of processing for Find_Interface\n+\n+   begin\n+      --  Handle private types\n+\n+      if Has_Private_Declaration (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n+\n+      --  Handle access types\n+\n+      if Is_Access_Type (Typ) then\n+         Typ := Directly_Designated_Type (Typ);\n+      end if;\n+\n+      --  Handle task and protected types implementing interfaces\n+\n+      if Is_Concurrent_Type (Typ) then\n+         Typ := Corresponding_Record_Type (Typ);\n+      end if;\n+\n+      if Is_Class_Wide_Type (Typ) then\n+         Typ := Etype (Typ);\n+      end if;\n+\n+      --  Handle entities from the limited view\n+\n+      if Ekind (Typ) = E_Incomplete_Type then\n+         pragma Assert (Present (Non_Limited_View (Typ)));\n+         Typ := Non_Limited_View (Typ);\n+      end if;\n+\n+      Find_Iface (Typ);\n+      pragma Assert (Found);\n+      return Iface;\n+   end Find_Interface;\n+\n    ------------------\n    -- Find_Prim_Op --\n    ------------------\n@@ -3050,14 +3145,16 @@ package body Exp_Util is\n \n    function Is_Ref_To_Bit_Packed_Slice (N : Node_Id) return Boolean is\n    begin\n-      if Is_Entity_Name (N)\n+      if Nkind (N) = N_Type_Conversion then\n+         return Is_Ref_To_Bit_Packed_Slice (Expression (N));\n+\n+      elsif Is_Entity_Name (N)\n         and then Is_Object (Entity (N))\n         and then Present (Renamed_Object (Entity (N)))\n       then\n          return Is_Ref_To_Bit_Packed_Slice (Renamed_Object (Entity (N)));\n-      end if;\n \n-      if Nkind (N) = N_Slice\n+      elsif Nkind (N) = N_Slice\n         and then Is_Bit_Packed_Array (Etype (Prefix (N)))\n       then\n          return True;\n@@ -3500,7 +3597,8 @@ package body Exp_Util is\n         and then Has_Unknown_Discriminants (Unc_Typ)\n       then\n          --  Prepare the subtype completion, Go to base type to\n-         --  find underlying type.\n+         --  find underlying type, because the type may be a generic\n+         --  actual or an explicit subtype.\n \n          Utyp        := Underlying_Type (Base_Type (Unc_Typ));\n          Full_Subtyp := Make_Defining_Identifier (Loc,\n@@ -3521,7 +3619,7 @@ package body Exp_Util is\n          --  Define the dummy private subtype\n \n          Set_Ekind          (Priv_Subtyp, Subtype_Kind (Ekind (Unc_Typ)));\n-         Set_Etype          (Priv_Subtyp, Unc_Typ);\n+         Set_Etype          (Priv_Subtyp, Base_Type (Unc_Typ));\n          Set_Scope          (Priv_Subtyp, Full_Subtyp);\n          Set_Is_Constrained (Priv_Subtyp);\n          Set_Is_Tagged_Type (Priv_Subtyp, Is_Tagged_Type (Unc_Typ));\n@@ -3585,7 +3683,7 @@ package body Exp_Util is\n             return New_Occurrence_Of (CW_Subtype, Loc);\n          end;\n \n-      --  Indefinite record type with discriminants.\n+      --  Indefinite record type with discriminants\n \n       else\n          D := First_Discriminant (Unc_Typ);"}, {"sha": "fad07ccafe5067fc45c3215153fe0e13da989df2", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=ea985d95427f210e627541b70dd56bb4b21ed838", "patch": "@@ -339,6 +339,13 @@ package Exp_Util is\n    --  declarations and/or allocations when the type is indefinite (including\n    --  class-wide).\n \n+   function Find_Interface\n+     (T    : Entity_Id;\n+      Comp : Entity_Id) return Entity_Id;\n+   --  Ada 2005 (AI-251): Given a tagged type and one of its components\n+   --  associated with the secondary dispatch table of an abstract interface\n+   --  type, return the associated abstract interface type.\n+\n    function Find_Interface_ADT\n      (T     : Entity_Id;\n       Iface : Entity_Id) return Entity_Id;"}, {"sha": "45e902bccff692438cd02c7caa29907b64003f4f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea985d95427f210e627541b70dd56bb4b21ed838/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=ea985d95427f210e627541b70dd56bb4b21ed838", "patch": "@@ -1559,8 +1559,8 @@ package body Sem_Res is\n \n       if Nkind (N) = N_Attribute_Reference\n         and then (Attribute_Name (N) = Name_Access\n-          or else Attribute_Name (N) = Name_Unrestricted_Access\n-          or else Attribute_Name (N) = Name_Unchecked_Access)\n+                    or else Attribute_Name (N) = Name_Unrestricted_Access\n+                    or else Attribute_Name (N) = Name_Unchecked_Access)\n         and then Comes_From_Source (N)\n         and then Is_Entity_Name (Prefix (N))\n         and then Is_Subprogram (Entity (Prefix (N)))\n@@ -2091,11 +2091,9 @@ package body Sem_Res is\n \n                         Get_First_Interp (Name (N), Index, It);\n                         while Present (It.Nam) loop\n-                              Error_Msg_Sloc := Sloc (It.Nam);\n-                              Error_Msg_Node_2 := It.Typ;\n-                              Error_Msg_NE (\"\\&  declared#, type&\",\n-                                N, It.Nam);\n-\n+                           Error_Msg_Sloc := Sloc (It.Nam);\n+                           Error_Msg_Node_2 := It.Typ;\n+                           Error_Msg_NE (\"\\&  declared#, type&\", N, It.Nam);\n                            Get_Next_Interp (Index, It);\n                         end loop;\n                      end;\n@@ -2591,15 +2589,15 @@ package body Sem_Res is\n             --  If the formal is Out or In_Out, do not resolve and expand the\n             --  conversion, because it is subsequently expanded into explicit\n             --  temporaries and assignments. However, the object of the\n-            --  conversion can be resolved. An exception is the case of a\n-            --  tagged type conversion with a class-wide actual. In that case\n-            --  we want the tag check to occur and no temporary will be needed\n-            --  (no representation change can occur) and the parameter is\n-            --  passed by reference, so we go ahead and resolve the type\n-            --  conversion. Another excpetion is the case of reference to a\n-            --  component or subcomponent of a bit-packed array, in which case\n-            --  we want to defer expansion to the point the in and out\n-            --  assignments are performed.\n+            --  conversion can be resolved. An exception is the case of tagged\n+            --  type conversion with a class-wide actual. In that case we want\n+            --  the tag check to occur and no temporary will be needed (no\n+            --  representation change can occur) and the parameter is passed by\n+            --  reference, so we go ahead and resolve the type conversion.\n+            --  Another excpetion is the case of reference to component or\n+            --  subcomponent of a bit-packed array, in which case we want to\n+            --  defer expansion to the point the in and out assignments are\n+            --  performed.\n \n             if Ekind (F) /= E_In_Parameter\n               and then Nkind (A) = N_Type_Conversion\n@@ -6660,34 +6658,50 @@ package body Sem_Res is\n                Opnd_Type := Directly_Designated_Type (Opnd_Type);\n             end if;\n \n-            if Is_Class_Wide_Type (Opnd_Type) then\n-               Opnd_Type := Etype (Opnd_Type);\n-            end if;\n+            declare\n+               Save_Typ : constant Entity_Id := Opnd_Type;\n \n-            if not Interface_Present_In_Ancestor\n-                     (Typ   => Opnd_Type,\n-                      Iface => Target_Type)\n-            then\n-               Error_Msg_NE\n-                 (\"(Ada 2005) does not implement interface }\",\n-                  Operand, Target_Type);\n+            begin\n+               if Is_Class_Wide_Type (Opnd_Type) then\n+                  Opnd_Type := Etype (Opnd_Type);\n+               end if;\n \n-            else\n-               --  If a conversion to an interface type appears as an actual in\n-               --  a source call, it will be expanded when the enclosing call\n-               --  itself is examined in Expand_Interface_Formals. Otherwise,\n-               --  generate the proper conversion code now, using the tag of\n-               --  the interface.\n-\n-               if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-                     or else Nkind (Parent (N)) = N_Function_Call)\n-                 and then Comes_From_Source (N)\n+               if not Interface_Present_In_Ancestor\n+                        (Typ   => Opnd_Type,\n+                         Iface => Target_Type)\n                then\n-                  null;\n+                  --  The static analysis is not enough to know if the\n+                  --  interface is implemented or not. Hence we must pass the\n+                  --  work to the expander to generate the required code to\n+                  --  evaluate the conversion at run-time.\n+\n+                  if Is_Class_Wide_Type (Save_Typ)\n+                    and then Is_Interface (Save_Typ)\n+                  then\n+                     Expand_Interface_Conversion (N, Is_Static => False);\n+                  else\n+                     Error_Msg_NE\n+                       (\"(Ada 2005) does not implement interface }\",\n+                        Operand, Target_Type);\n+                  end if;\n+\n                else\n-                  Expand_Interface_Conversion (N);\n+                  --  If a conversion to an interface type appears as an actual\n+                  --  in a source call, it will be expanded when the enclosing\n+                  --  call itself is examined in Expand_Interface_Formals.\n+                  --  Otherwise, generate the proper conversion code now, using\n+                  --  the tag of the interface.\n+\n+                  if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+                        or else Nkind (Parent (N)) = N_Function_Call)\n+                    and then Comes_From_Source (N)\n+                  then\n+                     null;\n+                  else\n+                     Expand_Interface_Conversion (N);\n+                  end if;\n                end if;\n-            end if;\n+            end;\n          end if;\n       end if;\n    end Resolve_Type_Conversion;"}]}