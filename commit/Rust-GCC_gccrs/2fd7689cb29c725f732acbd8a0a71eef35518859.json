{"sha": "2fd7689cb29c725f732acbd8a0a71eef35518859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkNzY4OWNiMjljNzI1ZjczMmFjYmQ4YTBhNzFlZWYzNTUxODg1OQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2021-01-24T18:57:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-06T07:51:45Z"}, "message": "[Ada] ACATS 4.1R-c611a04: Class-wide preconditions in dispatching calls\n\ngcc/ada/\n\n\t* exp_disp.adb (Build_Class_Wide_Check): Extending the\n\tfunctionality of this routine to climb to the ancestors\n\tsearching for the enclosing overridden dispatching primitive\n\tthat has a class-wide precondition to generate the check.", "tree": {"sha": "b194bd4eff26513a3c65e1916d31894dce827d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b194bd4eff26513a3c65e1916d31894dce827d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd7689cb29c725f732acbd8a0a71eef35518859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd7689cb29c725f732acbd8a0a71eef35518859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd7689cb29c725f732acbd8a0a71eef35518859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd7689cb29c725f732acbd8a0a71eef35518859/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60b803a7f19a5b4df6694f9a579050996b8dfba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b803a7f19a5b4df6694f9a579050996b8dfba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b803a7f19a5b4df6694f9a579050996b8dfba4"}], "stats": {"total": 106, "additions": 84, "deletions": 22}, "files": [{"sha": "18b691c5d7d627146764e0c6355217bd9a96454f", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 84, "deletions": 22, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd7689cb29c725f732acbd8a0a71eef35518859/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd7689cb29c725f732acbd8a0a71eef35518859/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=2fd7689cb29c725f732acbd8a0a71eef35518859", "patch": "@@ -709,10 +709,13 @@ package body Exp_Disp is\n       Eq_Prim_Op      : Entity_Id := Empty;\n       Controlling_Tag : Node_Id;\n \n-      procedure Build_Class_Wide_Check;\n+      procedure Build_Class_Wide_Check (E : Entity_Id);\n       --  If the denoted subprogram has a class-wide precondition, generate a\n       --  check using that precondition before the dispatching call, because\n-      --  this is the only class-wide precondition that applies to the call.\n+      --  this is the only class-wide precondition that applies to the call;\n+      --  otherwise climb to the ancestors searching for the enclosing\n+      --  overridden primitive of E that has a class-wide precondition (and\n+      --  use it to generate the check).\n \n       function New_Value (From : Node_Id) return Node_Id;\n       --  From is the original Expression. New_Value is equivalent to a call\n@@ -723,7 +726,14 @@ package body Exp_Disp is\n       -- Build_Class_Wide_Check --\n       ----------------------------\n \n-      procedure Build_Class_Wide_Check is\n+      procedure Build_Class_Wide_Check (E : Entity_Id) is\n+         Subp : Entity_Id := E;\n+\n+         function Has_Class_Wide_Precondition\n+           (Subp : Entity_Id) return Boolean;\n+         --  Evaluates if the dispatching subprogram Subp has a class-wide\n+         --  precondition.\n+\n          function Replace_Formals (N : Node_Id) return Traverse_Result;\n          --  Replace occurrences of the formals of the subprogram by the\n          --  corresponding actuals in the call, given that this check is\n@@ -735,6 +745,32 @@ package body Exp_Disp is\n          --  has not been analyzed yet, in which case we use the Chars\n          --  field to recognize intended occurrences of the formals.\n \n+         ---------------------------------\n+         -- Has_Class_Wide_Precondition --\n+         ---------------------------------\n+\n+         function Has_Class_Wide_Precondition\n+           (Subp : Entity_Id) return Boolean\n+         is\n+            Prec : Node_Id := Empty;\n+\n+         begin\n+            if Present (Contract (Subp))\n+              and then Present (Pre_Post_Conditions (Contract (Subp)))\n+            then\n+               Prec := Pre_Post_Conditions (Contract (Subp));\n+\n+               while Present (Prec) loop\n+                  exit when Pragma_Name (Prec) = Name_Precondition\n+                    and then Class_Present (Prec);\n+                  Prec := Next_Pragma (Prec);\n+               end loop;\n+            end if;\n+\n+            return Present (Prec)\n+              and then not Is_Ignored (Prec);\n+         end Has_Class_Wide_Precondition;\n+\n          ---------------------\n          -- Replace_Formals --\n          ---------------------\n@@ -750,27 +786,46 @@ package body Exp_Disp is\n                if Present (Entity (N)) and then Is_Formal (Entity (N)) then\n                   while Present (F) loop\n                      if F = Entity (N) then\n-                        Rewrite (N, New_Copy_Tree (A));\n-\n-                        --  If the formal is class-wide, and thus not a\n-                        --  controlling argument, preserve its type because\n-                        --  it may appear in a nested call with a class-wide\n-                        --  parameter.\n+                        if not Is_Controlling_Actual (N) then\n+                           Rewrite (N, New_Copy_Tree (A));\n+\n+                           --  If the formal is class-wide, and thus not a\n+                           --  controlling argument, preserve its type because\n+                           --  it may appear in a nested call with a class-wide\n+                           --  parameter.\n+\n+                           if Is_Class_Wide_Type (Etype (F)) then\n+                              Set_Etype (N, Etype (F));\n+\n+                           --  Conversely, if this is a controlling argument\n+                           --  (in a dispatching call in the condition) that\n+                           --  is a dereference, the source is an access-to-\n+                           --  -class-wide type, so preserve the dispatching\n+                           --  nature of the call in the rewritten condition.\n+\n+                           elsif Nkind (Parent (N)) = N_Explicit_Dereference\n+                             and then Is_Controlling_Actual (Parent (N))\n+                           then\n+                              Set_Controlling_Argument (Parent (Parent (N)),\n+                                 Parent (N));\n+                           end if;\n \n-                        if Is_Class_Wide_Type (Etype (F)) then\n-                           Set_Etype (N, Etype (F));\n+                        --  Ensure that the type of the controlling actual\n+                        --  matches the type of the controlling formal of the\n+                        --  parent primitive Subp defining the class-wide\n+                        --  precondition.\n \n-                        --  Conversely, if this is a controlling argument\n-                        --  (in a dispatching call in the condition) that is a\n-                        --  dereference, the source is an access-to-class-wide\n-                        --  type, so preserve the dispatching nature of the\n-                        --  call in the rewritten condition.\n+                        elsif Is_Class_Wide_Type (Etype (A)) then\n+                           Rewrite (N,\n+                             Convert_To\n+                               (Class_Wide_Type (Etype (F)),\n+                                New_Copy_Tree (A)));\n \n-                        elsif Nkind (Parent (N)) = N_Explicit_Dereference\n-                          and then Is_Controlling_Actual (Parent (N))\n-                        then\n-                           Set_Controlling_Argument (Parent (Parent (N)),\n-                              Parent (N));\n+                        else\n+                           Rewrite (N,\n+                             Convert_To\n+                               (Etype (F),\n+                                New_Copy_Tree (A)));\n                         end if;\n \n                         exit;\n@@ -816,6 +871,13 @@ package body Exp_Disp is\n       --  Start of processing for Build_Class_Wide_Check\n \n       begin\n+         --  Climb searching for the enclosing class-wide precondition\n+\n+         while not Has_Class_Wide_Precondition (Subp)\n+           and then Present (Overridden_Operation (Subp))\n+         loop\n+            Subp := Overridden_Operation (Subp);\n+         end loop;\n \n          --  Locate class-wide precondition, if any\n \n@@ -924,7 +986,7 @@ package body Exp_Disp is\n          Subp := Alias (Subp);\n       end if;\n \n-      Build_Class_Wide_Check;\n+      Build_Class_Wide_Check (Subp);\n \n       --  Definition of the class-wide type and the tagged type\n "}]}