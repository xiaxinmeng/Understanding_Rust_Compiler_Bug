{"sha": "fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ0MzgzNzNjZGQyYTViMTJkMmMxN2I3NzkyMmVlOGZiOGQ0Mzg0Nw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-11-19T17:27:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-11-19T17:27:18Z"}, "message": "Add PowerPC target attribute/pragma support\n\nFrom-SVN: r166947", "tree": {"sha": "331042dabc400c80ac08ddae1835f9a3e6300ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/331042dabc400c80ac08ddae1835f9a3e6300ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/comments", "author": null, "committer": null, "parents": [{"sha": "69ccdddbb807489bdc6f25871532b6f8e236f82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ccdddbb807489bdc6f25871532b6f8e236f82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ccdddbb807489bdc6f25871532b6f8e236f82f"}], "stats": {"total": 3074, "additions": 2376, "deletions": 698}, "files": [{"sha": "292fa371c9478620902a650ef7e8e6686f8d73b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -1,3 +1,230 @@\n+2010-11-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* doc/extend.texi (Function attributes): Document PowerPC target\n+\tattributes that are supported.\n+\t(Pragmas): Document that PowerPC now supports target pragmas.\n+\n+\t* doc/options.texi (TargetVariable): Document TargetVariable,\n+\tHeaderInclude, and SourceInclude.\n+\n+\t* doc/invoke.texi (-mfused-madd): Document that -mfused-madd is\n+\tmapped to -ffp-contract=fast, and -mno-fused-madd is mapped to\n+\t-ffp-contract=off.\n+\n+\t* optc-gen.awk: Add support for TargetVariable, HeaderInclude, and\n+\tSourceInclude directives.  Fix a cut+paste error with target save\n+\tenum variables.  Sort enums in the structures after ints and\n+\tbefore shorts.\n+\t* opth-gen.awk: Ditto.\n+\n+\t* configure.ac: Add support for HeaderInclude and SourceInclude\n+\toption directives to add the appropriate files to the dependency\n+\tlists.\n+\t* configure: Regenerate.\n+\t* Makefile.in (OPTIONS_H_EXTRA): New variable for HeaderInclude.\n+\t(OPTIONS_C_EXTRA): New variable for SourceInclude.\n+\t(OPTIONS_H): Add $(OPTIONS_H_EXTRA).\n+\t(options.o): Add $(OPTIONS_C_EXTRA) dependency.\n+\t(gcc-options.o): Ditto.\n+\t* opt-include.awk: New awk script to handle HeaderInclude and\n+\tTargetInclude.\n+\n+\t* config/rs6000/aix.opt (-mxl-compat): Mark option as Save so it\n+\tgets saved in the target options.\n+\t* config/rs6000/linux64.opt (-mprofile-kernel): Ditto.\n+\t* config/rs6000/sysv4.opt (-mbit-align): Ditto.\n+\t(-mprototype): Ditto.\n+\t(-mbit-word): ditto.\n+\t(-mregnames): Ditto.\n+\t(-msecure-plt): Ditto.\n+\t(-mbss-plt): Ditto.\n+\t* config/rs6000/rs6000.opt (-mpowerpc-gpopt): Ditto.\n+\t(-mpowerpc-gfxopt): Ditto.\n+\t(-mmfcrf): Ditto.\n+\t(-mpopcntb): Ditto.\n+\t(-mfprnd): Ditto.\n+\t(-mcmpb): Ditto.\n+\t(-mmmfpgpr): Ditto.\n+\t(-maltivec): Ditto.\n+\t(-mhard-dfp): Ditto.\n+\t(-mmulhw): Ditto.\n+\t(-mdlmzb): Ditto.\n+\t(-mmultiple): Ditto.\n+\t(-mstring): Ditto.\n+\t(-mpopcntd): Ditto.\n+\t(-mfriz): Ditto.\n+\t(-mvsx): Ditto.\n+\t(-mno-update): Ditto.\n+\t(-mavoid-indexed-addresses): Ditto.\n+\t(-mtls-markers): Ditto.\n+\t(-msched-epilog): Ditto.\n+\t(-msched-prolog): Ditto.\n+\t(-maix-struct-return): Ditto.\n+\t(-msvr4-struct-return): Ditto.\n+\t(-mxl-compat): Ditto.\n+\t(-mrecip-precision): Ditto.\n+\t(-mfp-in-toc): Ditto.\n+\t(-msum-in-toc): Ditto.\n+\t(-mvrsave): Ditto.\n+\t(-mblock-move-inline-limit=): Ditto.\n+\t(-misel): Ditto.\n+\t(-mpaired): Ditto.\n+\t(-mlongcall): Ditto.\n+\t(-mgen-cell-microcode): Ditto.\n+\t(-mwarn-cell-microcode): Ditto.\n+\t(-mwarn-altivec-long): Ditto.\n+\t(-mprioritize-restricted-insns=): Ditto.\n+\t(-msingle-float): Ditto.\n+\t(-mdouble-float): Ditto.\n+\t(-msimple-fpu): Ditto.\n+\t(-mxilinx-fpu): Ditto.\n+\t* config/rs6000/aix64.opt (-mpe): Ditto.\n+\n+\t* config/rs6000/rs6000.opt (HeaderInclude): Include rs6000-opts.h.\n+\t(rs6000_cpu): Move variable to be a target variable.  Rename\n+\tcmodel to rs6000_current_cmodel because of macro conflict.  Merge\n+\t-mdebug=<xxx> variables into a single int.\n+\t(rs6000_always_hint): Ditto.\n+\t(rs6000_sched_groups): Ditto.\n+\t(rs6000_align_branch_targets): Ditto.\n+\t(rs6000_sched_costly_dep): Ditto.\n+\t(rs6000_sched_insert_nops): Ditto.\n+\t(rs6000_long_double_type_size): Ditto.\n+\t(rs6000_ieeequad): Ditto.\n+\t(rs6000_altivec_abi): Ditto.\n+\t(rs6000_spe): Ditto.\n+\t(rs6000_spe_abi): Ditto.\n+\t(rs6000_float_gprs): Ditto.\n+\t(rs6000_darwin64_abi): Ditto.\n+\t(can_override_loop_align): Ditto.\n+\t(rs6000_sdata): Ditto.\n+\t(rs6000_tls_size): Ditto.\n+\t(rs6000_current_abi): Ditto.\n+\t(rs6000_traceback): Ditto.\n+\t(rs6000_alignment_flags): Ditto.\n+\t(rs6000_current_cmodel): Ditto.\n+\t(rs6000_recip_control): Ditto.\n+\t(rs6000_cpu_index): Ditto.\n+\t(rs6000_tune_index): Ditto.\n+\t(rs6000_debug): Ditto.\n+\t(rs6000_target_flags_explict): Ditto.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_pragma_target_parse): Add\n+\tdeclaration.\n+\n+\t* config/rs6000/linux64.h (rs6000_current_cmode): Rename from\n+\tcmodel.  Change all uses.\n+\n+\t* config/rs6000/rs6000.c (rs6000_always_hint): Move to\n+\trs6000.opt.  Combine -mdebug=<xxx> variables into a single int.\n+\tRename cmodel to rs6000_current_cmodel.\n+\t(rs6000_sched_groups): Ditto.\n+\t(rs6000_align_branch_targets): Ditto.\n+\t(rs6000_sched_costly_dep): Ditto.\n+\t(rs6000_sched_insert_nops): Ditto.\n+\t(rs6000_long_double_type_size): Ditto.\n+\t(rs6000_ieeequad): Ditto.\n+\t(rs6000_altivec_abi): Ditto.\n+\t(rs6000_spe): Ditto.\n+\t(rs6000_spe_abi): Ditto.\n+\t(rs6000_float_gprs): Ditto.\n+\t(rs6000_darwin64_abi): Ditto.\n+\t(can_override_loop_align): Ditto.\n+\t(rs6000_sdata): Ditto.\n+\t(rs6000_tls_size): Ditto.\n+\t(rs6000_current_abi): Ditto.\n+\t(rs6000_traceback): Ditto.\n+\t(rs6000_alignment_flags): Ditto.\n+\t(rs6000_current_cmodel): Ditto.\n+\t(rs6000_recip_control): Ditto.\n+\t(rs6000_cpu_index): Ditto.\n+\t(rs6000_tune_index): Ditto.\n+\t(rs6000_debug): Ditto.\n+\t(rs6000_target_flags_explict): Ditto.\n+\t(rs6000_sched_insert_nops_str): Make static.\n+\t(rs6000_sched_costly_dep_str): Ditto.\n+\t(rs6000_recip_name): Ditto.\n+\t(rs6000_abi_name): Ditto.\n+\t(rs6000_sdata_name): Ditto.\n+\t(enum rs6000_traceback_name): Move to rs6000-opts.h.\n+\t(rs6000_parse_tls_size_option): Delete.\n+\t(rs6000_valid_attribute_p): New function for target attributes and\n+\tpragmas.\n+\t(rs6000_function_specific_save): Ditto.\n+\t(rs6000_function_specific_restore): Ditto.\n+\t(rs6000_function_specific_print): Ditto.\n+\t(rs6000_can_inline_p): Ditto.\n+\t(rs6000_set_current_function): Ditto.\n+\t(rs6000_inner_target_options): Ditto.\n+\t(rs6000_debug_target_options): Ditto.\n+\t(rs6000_pragma_target_parse): Ditto.\n+\t(TARGET_OPTION_VALID_ATTRIBUTE_P): Define target hooks for target\n+\tattributes and pragmas.\n+\t(TARGET_OPTION_SAVE): Ditto.\n+\t(TARGET_OPTION_RESTORE): Ditto.\n+\t(TARGET_OPTION_PRINT): Ditto.\n+\t(TARGET_CAN_INLINE_P): Ditto.\n+\t(TARGET_SET_CURRENT_FUNCTION): Ditto.\n+\t(POWER_MASKS): Move to file level scope from the\n+\trs6000_option_override_internal function.\n+\t(POWERPC_MASKS): Ditto.\n+\t(ISA_*_MASKS): Ditto.\n+\t(struct rs6000_ptt): Ditto.\n+\t(processor_target_table): Ditto.\n+\t(rs6000_cpu_name_lookup): Map cpu name to an index in\n+\tprocessor_target_table.\n+\t(rs6000_debug_reg_global): Print more information on processor\n+\toptions for -mdebug=reg.\n+\t(rs6000_init_hard_regno_mode_ok): Add support for target\n+\tattributes and pragmas.  Merge all -mdebug=<xxx> fields into one.\n+\tAllow -mdebug=val1,val2.  Rename cmodel variable.\n+\t(rs6000_option_override_internal): Ditto.\n+\t(rs6000_option_override): Ditto.\n+\t(rs6000_handle_option): Ditto.\n+\t(rs6000_conditional_register_usage): Add debug trace message.\n+\t(struct rs6000_opt_mask): New for target attribute/pragma\n+\tsupport.\n+\t(rs6000_opt_masks): Ditto.\n+\t(struct rs6000_opt_var): Ditto.\n+\t(rs6000_opt_vars): Ditto.\n+\t(rs6000_previous_function): Ditto.\n+\n+\t* config/rs6000/rs6000.h (top level): Include rs6000-opts.h if it\n+\twasn't already included.\n+\t(enum rs6000_cmodel): Move to rs6000-opts.h or rs6000.opt.\n+\t(enum processor_type): Ditto.\n+\t(rs6000_cpu): Ditto.\n+\t(enum fpu_type_t): Ditto.\n+\t(fpu_type): Ditto.\n+\t(enum rs6000_dependence_cost): Ditto.\n+\t(enum rs6000_nop_insertion): Ditto.\n+\t(enum group_termination): Ditto.\n+\t(rs6000_long_double_type_size): Ditto.\n+\t(rs6000_ieeequad): Ditto.\n+\t(rs6000_altivec_abi): Ditto.\n+\t(rs6000_spe_abi): Ditto.\n+\t(rs6000_spe): Ditto.\n+\t(rs6000_float_gprs): Ditto.\n+\t(rs6000_alignment_flags): Ditto.\n+\t(rs6000_sched_insert_nops): Ditto.\n+\t(enum rs6000_vector): Ditto.\n+\t(enum rs6000_abi): Ditto.\n+\t(rs6000_current_opt): Ditto.\n+\t(rs6000_debug_*): Delete.\n+\t(MASK_DEBUG*): Combine -mdebug=xxxx into one int.\n+\t(TARGET_DEBUG*): Ditto.\n+\n+\t* config/rs6000/rs6000-opts.h: New header file to define the enums\n+\tthat are used in target variables that are now defined in\n+\trs6000.opt.\n+\n+\t* config/rs6000/sysv4.h (enum rs6000_sdata_type): Move to\n+\trs6000-opts.h.\n+\t(rs6000_sdata): Ditto.\n+\t(rs6000_abi_name): Delete.\n+\t(rs6000_sdata_name): Ditto.\n+\t(rs6000_tls_size_string): Ditto.\n+\n 2010-11-19  Joseph Myers  <joseph@codesourcery.com>\n \n \t* common.opt (debug_struct_ordinary, debug_struct_generic): New"}, {"sha": "5491aeaf4d057012e108a8ca137ffd77b556c4b1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -806,6 +806,16 @@ T_TARGET : $(T_TARGET)\n # at build time.\n SPECS = specs\n \n+# Extra include files that are defined by HeaderInclude directives in\n+# the .opt files\n+OPTIONS_H_EXTRA =\n+\n+# Extra include files that are defined by SourceInclude directives in\n+# the .opt files\n+OPTIONS_C_EXTRA =\n+\n+@option_includes@\n+\n # End of variables for you to override.\n \n # GTM_H lists the config files that the generator files depend on,\n@@ -893,7 +903,7 @@ RECOG_H = recog.h\n ALIAS_H = alias.h coretypes.h\n EMIT_RTL_H = emit-rtl.h\n FLAGS_H = flags.h coretypes.h flag-types.h $(OPTIONS_H)\n-OPTIONS_H = options.h flag-types.h\n+OPTIONS_H = options.h flag-types.h $(OPTIONS_H_EXTRA)\n FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) vecprim.h $(TM_H)\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n@@ -2234,9 +2244,10 @@ s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk\n \t$(STAMP) $@\n \n options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) $(FLAGS_H) \\\n-\t$(TM_H) $(OPTS_H) intl.h\n+\t$(TM_H) $(OPTS_H) intl.h $(OPTIONS_C_EXTRA)\n \n-gcc-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OPTS_H) intl.h\n+gcc-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OPTS_H) intl.h \\\n+\t$(OPTIONS_C_EXTRA)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(OUTPUT_OPTION) \\\n \t\t-DGCC_DRIVER options.c\n "}, {"sha": "ac2b6030c22ab9652869866a63216efc5cf761cd", "filename": "gcc/config/rs6000/aix.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Faix.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Faix.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.opt?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -20,5 +20,5 @@\n ; <http://www.gnu.org/licenses/>.\n \n mxl-compat\n-Target Var(has_xl_compat_option)\n+Target Var(has_xl_compat_option) Save\n Conform more closely to IBM XLC semantics"}, {"sha": "230bb99a7d683d604ef5743d207033ba69abaa2f", "filename": "gcc/config/rs6000/aix64.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Faix64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Faix64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix64.opt?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -28,5 +28,5 @@ Target Report RejectNegative Negative(maix64) InverseMask(64BIT)\n Compile for 32-bit pointers\n \n mpe\n-Target Report RejectNegative Var(internal_nothing_1)\n+Target Report RejectNegative Var(internal_nothing_1) Save\n Support message passing with the Parallel Environment"}, {"sha": "0bc774a1f0cdc2df5d5de36eff1f5d7511820492", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -65,10 +65,9 @@ extern int dot_symbols;\n \n #define TARGET_USES_LINUX64_OPT 1\n #ifdef HAVE_LD_LARGE_TOC\n-extern enum rs6000_cmodel cmodel;\n #undef TARGET_CMODEL\n-#define TARGET_CMODEL cmodel\n-#define SET_CMODEL(opt) cmodel = opt\n+#define TARGET_CMODEL rs6000_current_cmodel\n+#define SET_CMODEL(opt) rs6000_current_cmodel = opt\n #else\n #define SET_CMODEL(opt) do {} while (0)\n #endif\n@@ -127,15 +126,15 @@ extern enum rs6000_cmodel cmodel;\n \t  if ((target_flags_explicit & MASK_MINIMAL_TOC) != 0)\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      if (rs6000_explicit_options.cmodel\t\t\\\n-\t\t  && cmodel != CMODEL_SMALL)\t\t\t\\\n+\t\t  && rs6000_current_cmodel != CMODEL_SMALL)\t\\\n \t\terror (\"-mcmodel incompatible with other toc options\"); \\\n \t      SET_CMODEL (CMODEL_SMALL);\t\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      if (!rs6000_explicit_options.cmodel)\t\t\\\n \t\tSET_CMODEL (CMODEL_MEDIUM);\t\t\t\\\n-\t      if (cmodel != CMODEL_SMALL)\t\t\t\\\n+\t      if (rs6000_current_cmodel != CMODEL_SMALL)\t\\\n \t\t{\t\t\t\t\t\t\\\n \t\t  TARGET_NO_FP_IN_TOC = 0;\t\t\t\\\n \t\t  TARGET_NO_SUM_IN_TOC = 0;\t\t\t\\"}, {"sha": "28177f1edcab009ffc46c4262d294186c038c065", "filename": "gcc/config/rs6000/linux64.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.opt?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -20,7 +20,7 @@\n ; <http://www.gnu.org/licenses/>.\n \n mprofile-kernel\n-Target Report Var(profile_kernel)\n+Target Report Var(profile_kernel) Save\n Call mcount for profiling before a function prologue\n \n mcmodel="}, {"sha": "542fea7901326aeb1be0dfb23c2278244ca73848", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -0,0 +1,144 @@\n+/* Definitions of target machine needed for option handling for GNU compiler,\n+   for IBM RS/6000.\n+   Copyright (C) 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef RS6000_OPTS_H\n+#define RS6000_OPTS_H\n+\n+/* Processor type.  Order must match cpu attribute in MD file.  */\n+enum processor_type\n+ {\n+   PROCESSOR_RIOS1,\n+   PROCESSOR_RIOS2,\n+   PROCESSOR_RS64A,\n+   PROCESSOR_MPCCORE,\n+   PROCESSOR_PPC403,\n+   PROCESSOR_PPC405,\n+   PROCESSOR_PPC440,\n+   PROCESSOR_PPC476,\n+   PROCESSOR_PPC601,\n+   PROCESSOR_PPC603,\n+   PROCESSOR_PPC604,\n+   PROCESSOR_PPC604e,\n+   PROCESSOR_PPC620,\n+   PROCESSOR_PPC630,\n+   PROCESSOR_PPC750,\n+   PROCESSOR_PPC7400,\n+   PROCESSOR_PPC7450,\n+   PROCESSOR_PPC8540,\n+   PROCESSOR_PPCE300C2,\n+   PROCESSOR_PPCE300C3,\n+   PROCESSOR_PPCE500MC,\n+   PROCESSOR_PPCE500MC64,\n+   PROCESSOR_POWER4,\n+   PROCESSOR_POWER5,\n+   PROCESSOR_POWER6,\n+   PROCESSOR_POWER7,\n+   PROCESSOR_CELL,\n+   PROCESSOR_PPCA2,\n+   PROCESSOR_TITAN\n+};\n+\n+/* FP processor type.  */\n+enum fpu_type_t\n+{\n+  FPU_NONE,\t\t\t/* No FPU */\n+  FPU_SF_LITE,\t\t\t/* Limited Single Precision FPU */\n+  FPU_DF_LITE,\t\t\t/* Limited Double Precision FPU */\n+  FPU_SF_FULL,\t\t\t/* Full Single Precision FPU */\n+  FPU_DF_FULL\t\t\t/* Full Double Single Precision FPU */\n+};\n+\n+/* Types of costly dependences.  */\n+enum rs6000_dependence_cost\n+{\n+  max_dep_latency = 1000,\n+  no_dep_costly,\n+  all_deps_costly,\n+  true_store_to_load_dep_costly,\n+  store_to_load_dep_costly\n+};\n+\n+/* Types of nop insertion schemes in sched target hook sched_finish.  */\n+enum rs6000_nop_insertion\n+{\n+  sched_finish_regroup_exact = 1000,\n+  sched_finish_pad_groups,\n+  sched_finish_none\n+};\n+\n+/* Dispatch group termination caused by an insn.  */\n+enum group_termination\n+{\n+  current_group,\n+  previous_group\n+};\n+\n+/* Enumeration to give which calling sequence to use.  */\n+enum rs6000_abi {\n+  ABI_NONE,\n+  ABI_AIX,\t\t\t/* IBM's AIX */\n+  ABI_V4,\t\t\t/* System V.4/eabi */\n+  ABI_DARWIN\t\t\t/* Apple's Darwin (OS X kernel) */\n+};\n+\n+/* Small data support types.  */\n+enum rs6000_sdata_type {\n+  SDATA_NONE,\t\t\t/* No small data support.  */\n+  SDATA_DATA,\t\t\t/* Just put data in .sbss/.sdata, don't use relocs.  */\n+  SDATA_SYSV,\t\t\t/* Use r13 to point to .sdata/.sbss.  */\n+  SDATA_EABI\t\t\t/* Use r13 like above, r2 points to .sdata2/.sbss2.  */\n+};\n+\n+/* Type of traceback to use.  */\n+enum  rs6000_traceback_type {\n+  traceback_default = 0,\n+  traceback_none,\n+  traceback_part,\n+  traceback_full\n+};\n+\n+/* Code model for 64-bit linux.\n+   small: 16-bit toc offsets.\n+   medium: 32-bit toc offsets, static data and code within 2G of TOC pointer.\n+   large: 32-bit toc offsets, no limit on static data and code.  */\n+enum rs6000_cmodel {\n+  CMODEL_SMALL,\n+  CMODEL_MEDIUM,\n+  CMODEL_LARGE\n+};\n+\n+/* Describe which vector unit to use for a given machine mode.  */\n+enum rs6000_vector {\n+  VECTOR_NONE,\t\t\t/* Type is not  a vector or not supported */\n+  VECTOR_ALTIVEC,\t\t/* Use altivec for vector processing */\n+  VECTOR_VSX,\t\t\t/* Use VSX for vector processing */\n+  VECTOR_PAIRED,\t\t/* Use paired floating point for vectors */\n+  VECTOR_SPE,\t\t\t/* Use SPE for vector processing */\n+  VECTOR_OTHER\t\t\t/* Some other vector unit */\n+};\n+\n+#endif"}, {"sha": "ebf896fb53ea19818d8174c7c7fa4f352e10ed1a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -175,6 +175,9 @@ extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n \n extern void rs6000_pragma_longcall (struct cpp_reader *);\n extern void rs6000_cpu_cpp_builtins (struct cpp_reader *);\n+#ifdef TREE_CODE\n+extern bool rs6000_pragma_target_parse (tree, tree);\n+#endif\n \n #if TARGET_MACHO\n char *output_call (rtx, rtx *, int, int);"}, {"sha": "cdc727230a101ba8b7329222241bf5316d35bf8a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1210, "deletions": 479, "changes": 1689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -139,7 +139,6 @@ typedef struct GTY(()) machine_function\n \n /* Target cpu type */\n \n-enum processor_type rs6000_cpu;\n struct rs6000_cpu_select rs6000_select[3] =\n {\n   /* switch\t\tname,\t\t\ttune\tarch */\n@@ -148,50 +147,19 @@ struct rs6000_cpu_select rs6000_select[3] =\n   { (const char *)0,\t\"-mtune=\",\t\t1,\t0 },\n };\n \n-/* Always emit branch hint bits.  */\n-static GTY(()) bool rs6000_always_hint;\n-\n-/* Schedule instructions for group formation.  */\n-static GTY(()) bool rs6000_sched_groups;\n-\n-/* Align branch targets.  */\n-static GTY(()) bool rs6000_align_branch_targets;\n-\n-/* Non-zero to allow overriding loop alignment. */\n-static int can_override_loop_align = 0;\n-\n-/* Support for -msched-costly-dep option.  */\n-const char *rs6000_sched_costly_dep_str;\n-enum rs6000_dependence_cost rs6000_sched_costly_dep;\n+/* String variables to hold the various options.  */\n+static const char *rs6000_sched_insert_nops_str;\n+static const char *rs6000_sched_costly_dep_str;\n+static const char *rs6000_recip_name;\n \n-/* Support for -minsert-sched-nops option.  */\n-const char *rs6000_sched_insert_nops_str;\n-enum rs6000_nop_insertion rs6000_sched_insert_nops;\n+#ifdef USING_ELFOS_H\n+static const char *rs6000_abi_name;\n+static const char *rs6000_sdata_name;\n+#endif\n \n /* Support targetm.vectorize.builtin_mask_for_load.  */\n static GTY(()) tree altivec_builtin_mask_for_load;\n \n-/* Size of long double.  */\n-int rs6000_long_double_type_size;\n-\n-/* IEEE quad extended precision long double. */\n-int rs6000_ieeequad;\n-\n-/* Nonzero to use AltiVec ABI.  */\n-int rs6000_altivec_abi;\n-\n-/* Nonzero if we want SPE SIMD instructions.  */\n-int rs6000_spe;\n-\n-/* Nonzero if we want SPE ABI extensions.  */\n-int rs6000_spe_abi;\n-\n-/* Nonzero if floating point operations are done in the GPRs.  */\n-int rs6000_float_gprs = 0;\n-\n-/* Nonzero if we want Darwin's struct-by-value-in-regs ABI.  */\n-int rs6000_darwin64_abi;\n-\n /* Set to nonzero once AIX common-mode calls have been defined.  */\n static GTY(()) int common_mode_defined;\n \n@@ -200,37 +168,13 @@ static GTY(()) int common_mode_defined;\n static int rs6000_pic_labelno;\n \n #ifdef USING_ELFOS_H\n-/* Which abi to adhere to */\n-const char *rs6000_abi_name;\n-\n-/* Semantics of the small data area */\n-enum rs6000_sdata_type rs6000_sdata = SDATA_DATA;\n-\n-/* Which small data model to use */\n-const char *rs6000_sdata_name = (char *)0;\n-\n /* Counter for labels which are to be placed in .fixup.  */\n int fixuplabelno = 0;\n #endif\n \n-/* Bit size of immediate TLS offsets and string from which it is decoded.  */\n-int rs6000_tls_size = 32;\n-const char *rs6000_tls_size_string;\n-\n-/* ABI enumeration available for subtarget to use.  */\n-enum rs6000_abi rs6000_current_abi;\n-\n /* Whether to use variant of AIX ABI for PowerPC64 Linux.  */\n int dot_symbols;\n \n-/* Debug flags */\n-const char *rs6000_debug_name;\n-int rs6000_debug_stack;\t\t/* debug stack applications */\n-int rs6000_debug_arg;\t\t/* debug argument handling */\n-int rs6000_debug_reg;\t\t/* debug register classes */\n-int rs6000_debug_addr;\t\t/* debug memory addressing */\n-int rs6000_debug_cost;\t\t/* debug rtx_costs */\n-\n /* Specify the machine mode that pointers have.  After generation of rtl, the\n    compiler makes no further distinction between pointers and any other objects\n    of this machine mode.  The type is unsigned since not all things that\n@@ -260,14 +204,6 @@ static enum insn_code rs6000_vector_reload[NUM_MACHINE_MODES][2];\n tree rs6000_builtin_types[RS6000_BTI_MAX];\n tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n-const char *rs6000_traceback_name;\n-static enum {\n-  traceback_default = 0,\n-  traceback_none,\n-  traceback_part,\n-  traceback_full\n-} rs6000_traceback;\n-\n /* Flag to say the TOC is initialized */\n int toc_initialized;\n char toc_label_name[10];\n@@ -282,13 +218,6 @@ static GTY(()) section *read_only_private_data_section;\n static GTY(()) section *sdata2_section;\n static GTY(()) section *toc_section;\n \n-/* Control alignment for fields within structures.  */\n-/* String from -malign-XXXXX.  */\n-int rs6000_alignment_flags;\n-\n-/* Code model for 64-bit linux.  */\n-enum rs6000_cmodel cmodel;\n-\n /* True for any options that were explicitly set.  */\n static struct {\n   bool aix_struct_ret;\t\t/* True if -maix-struct-ret was used.  */\n@@ -358,9 +287,6 @@ enum rs6000_recip_mask {\n   RECIP_LOW_PRECISION\t= (RECIP_ALL & ~(RECIP_DF_RSQRT | RECIP_V2DF_RSQRT))\n };\n \n-static unsigned int rs6000_recip_control;\n-static const char *rs6000_recip_name;\n-\n /* -mrecip options.  */\n static struct\n {\n@@ -1145,7 +1071,6 @@ static void rs6000_option_init_struct (struct gcc_options *);\n static void rs6000_option_default_params (void);\n static bool rs6000_handle_option (size_t, const char *, int);\n static int rs6000_loop_align_max_skip (rtx);\n-static void rs6000_parse_tls_size_option (void);\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n static int first_altivec_reg_to_save (void);\n static unsigned int compute_vrsave_mask (void);\n@@ -1302,6 +1227,15 @@ struct GTY(()) builtin_hash_struct\n };\n \n static GTY ((param_is (struct builtin_hash_struct))) htab_t builtin_hash_table;\n+\n+static bool rs6000_valid_attribute_p (tree, tree, tree, int);\n+static void rs6000_function_specific_save (struct cl_target_option *);\n+static void rs6000_function_specific_restore (struct cl_target_option *);\n+static void rs6000_function_specific_print (FILE *, int,\n+\t\t\t\t\t    struct cl_target_option *);\n+static bool rs6000_can_inline_p (tree, tree);\n+static void rs6000_set_current_function (tree);\n+\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -1702,7 +1636,212 @@ static const struct default_options rs6000_option_optimization_table[] =\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE rs6000_function_value\n \n+#undef TARGET_OPTION_VALID_ATTRIBUTE_P\n+#define TARGET_OPTION_VALID_ATTRIBUTE_P rs6000_valid_attribute_p\n+\n+#undef TARGET_OPTION_SAVE\n+#define TARGET_OPTION_SAVE rs6000_function_specific_save\n+\n+#undef TARGET_OPTION_RESTORE\n+#define TARGET_OPTION_RESTORE rs6000_function_specific_restore\n+\n+#undef TARGET_OPTION_PRINT\n+#define TARGET_OPTION_PRINT rs6000_function_specific_print\n+\n+#undef TARGET_CAN_INLINE_P\n+#define TARGET_CAN_INLINE_P rs6000_can_inline_p\n+\n+#undef TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION rs6000_set_current_function\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n+\f\n+\n+/* Simplifications for entries below.  */\n+\n+enum {\n+  POWERPC_BASE_MASK = MASK_POWERPC | MASK_NEW_MNEMONICS,\n+  POWERPC_7400_MASK = POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_ALTIVEC\n+};\n+\n+/* Some OSs don't support saving the high part of 64-bit registers on context\n+   switch.  Other OSs don't support saving Altivec registers.  On those OSs, we\n+   don't touch the MASK_POWERPC64 or MASK_ALTIVEC settings; if the user wants\n+   either, the user must explicitly specify them and we won't interfere with\n+   the user's specification.  */\n+\n+enum {\n+  POWER_MASKS = MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING,\n+  POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT | MASK_STRICT_ALIGN\n+\t\t   | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n+\t\t   | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_MULHW\n+\t\t   | MASK_DLMZB | MASK_CMPB | MASK_MFPGPR | MASK_DFP\n+\t\t   | MASK_POPCNTD | MASK_VSX | MASK_ISEL | MASK_NO_UPDATE\n+\t\t   | MASK_RECIP_PRECISION)\n+};\n+\n+/* Masks for instructions set at various powerpc ISAs.  */\n+enum {\n+  ISA_2_1_MASKS = MASK_MFCRF,\n+  ISA_2_2_MASKS = (ISA_2_1_MASKS | MASK_POPCNTB),\n+  ISA_2_4_MASKS = (ISA_2_2_MASKS | MASK_FPRND),\n+\n+  /* For ISA 2.05, do not add MFPGPR, since it isn't in ISA 2.06, and don't add\n+     ALTIVEC, since in general it isn't a win on power6.  In ISA 2.04, fsel,\n+     fre, fsqrt, etc. were no longer documented as optional.  Group masks by\n+     server and embedded. */\n+  ISA_2_5_MASKS_EMBEDDED = (ISA_2_2_MASKS | MASK_CMPB | MASK_RECIP_PRECISION\n+\t\t\t    | MASK_PPC_GFXOPT | MASK_PPC_GPOPT),\n+  ISA_2_5_MASKS_SERVER = (ISA_2_5_MASKS_EMBEDDED | MASK_DFP),\n+\n+  /* For ISA 2.06, don't add ISEL, since in general it isn't a win, but\n+     altivec is a win so enable it.  */\n+  ISA_2_6_MASKS_EMBEDDED = (ISA_2_5_MASKS_EMBEDDED | MASK_POPCNTD),\n+  ISA_2_6_MASKS_SERVER = (ISA_2_5_MASKS_SERVER | MASK_POPCNTD | MASK_ALTIVEC\n+\t\t\t  | MASK_VSX)\n+};\n+\n+/* This table occasionally claims that a processor does not support a\n+   particular feature even though it does, but the feature is slower than the\n+   alternative.  Thus, it shouldn't be relied on as a complete description of\n+   the processor's support.\n+\n+   Please keep this list in order, and don't forget to update the documentation\n+   in invoke.texi when adding a new processor or flag.  */\n+\n+struct rs6000_ptt\n+{\n+  const char *const name;\t\t/* Canonical processor name.  */\n+  const enum processor_type processor;\t/* Processor type enum value.  */\n+  const int target_enable;\t\t/* Target flags to enable.  */\n+};\n+\n+static struct rs6000_ptt const processor_target_table[] =\n+{\n+  {\"401\", PROCESSOR_PPC403, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"403\", PROCESSOR_PPC403,\n+   POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_STRICT_ALIGN},\n+  {\"405\", PROCESSOR_PPC405,\n+   POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n+  {\"405fp\", PROCESSOR_PPC405,\n+   POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n+  {\"440\", PROCESSOR_PPC440,\n+   POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n+  {\"440fp\", PROCESSOR_PPC440,\n+   POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n+  {\"464\", PROCESSOR_PPC440,\n+   POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n+  {\"464fp\", PROCESSOR_PPC440,\n+   POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n+  {\"476\", PROCESSOR_PPC476,\n+   POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_PPC_GFXOPT | MASK_MFCRF\n+   | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_MULHW | MASK_DLMZB},\n+  {\"476fp\", PROCESSOR_PPC476,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_MFCRF | MASK_POPCNTB\n+   | MASK_FPRND | MASK_CMPB | MASK_MULHW | MASK_DLMZB},\n+  {\"505\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK},\n+  {\"601\", PROCESSOR_PPC601,\n+   MASK_POWER | POWERPC_BASE_MASK | MASK_MULTIPLE | MASK_STRING},\n+  {\"602\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"603\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"603e\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"604\", PROCESSOR_PPC604, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"604e\", PROCESSOR_PPC604e, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"620\", PROCESSOR_PPC620,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n+  {\"630\", PROCESSOR_PPC630,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n+  {\"740\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"7400\", PROCESSOR_PPC7400, POWERPC_7400_MASK},\n+  {\"7450\", PROCESSOR_PPC7450, POWERPC_7400_MASK},\n+  {\"750\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"801\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"821\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"823\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"8540\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n+   | MASK_ISEL},\n+  /* 8548 has a dummy entry for now.  */\n+  {\"8548\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n+   | MASK_ISEL},\n+  {\"a2\", PROCESSOR_PPCA2,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_POPCNTB\n+   | MASK_CMPB | MASK_NO_UPDATE },\n+  {\"e300c2\", PROCESSOR_PPCE300C2, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"e300c3\", PROCESSOR_PPCE300C3, POWERPC_BASE_MASK},\n+  {\"e500mc\", PROCESSOR_PPCE500MC, POWERPC_BASE_MASK | MASK_PPC_GFXOPT\n+   | MASK_ISEL},\n+  {\"e500mc64\", PROCESSOR_PPCE500MC64, POWERPC_BASE_MASK | MASK_POWERPC64\n+   | MASK_PPC_GFXOPT | MASK_ISEL},\n+  {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"970\", PROCESSOR_POWER4,\n+   POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n+  {\"cell\", PROCESSOR_CELL,\n+   POWERPC_7400_MASK  | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n+  {\"common\", PROCESSOR_COMMON, MASK_NEW_MNEMONICS},\n+  {\"ec603e\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n+  {\"G3\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+  {\"G4\",  PROCESSOR_PPC7450, POWERPC_7400_MASK},\n+  {\"G5\", PROCESSOR_POWER4,\n+   POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n+  {\"titan\", PROCESSOR_TITAN,\n+   POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n+  {\"power\", PROCESSOR_POWER, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n+  {\"power2\", PROCESSOR_POWER,\n+   MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING},\n+  {\"power3\", PROCESSOR_PPC630,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n+  {\"power4\", PROCESSOR_POWER4,\n+   POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n+   | MASK_MFCRF},\n+  {\"power5\", PROCESSOR_POWER5,\n+   POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n+   | MASK_MFCRF | MASK_POPCNTB},\n+  {\"power5+\", PROCESSOR_POWER5,\n+   POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n+   | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND},\n+  {\"power6\", PROCESSOR_POWER6,\n+   POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n+   | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n+   | MASK_RECIP_PRECISION},\n+  {\"power6x\", PROCESSOR_POWER6,\n+   POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n+   | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n+   | MASK_MFPGPR | MASK_RECIP_PRECISION},\n+  {\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n+   POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n+   | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n+   | MASK_VSX | MASK_RECIP_PRECISION},\n+  {\"powerpc\", PROCESSOR_POWERPC, POWERPC_BASE_MASK},\n+  {\"powerpc64\", PROCESSOR_POWERPC64,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n+  {\"rios\", PROCESSOR_RIOS1, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n+  {\"rios1\", PROCESSOR_RIOS1, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n+  {\"rios2\", PROCESSOR_RIOS2,\n+   MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING},\n+  {\"rsc\", PROCESSOR_PPC601, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n+  {\"rsc1\", PROCESSOR_PPC601, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n+  {\"rs64\", PROCESSOR_RS64A,\n+   POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64}\n+};\n+\n+/* Look up a processor name for -mcpu=xxx and -mtune=xxx.  Return -1 if the\n+   name is invalid.  */\n+\n+static int\n+rs6000_cpu_name_lookup (const char *name)\n+{\n+  size_t i;\n+\n+  if (name != NULL)\n+    {\n+      for (i = 0; i < ARRAY_SIZE (processor_target_table); i++)\n+\tif (! strcmp (name, processor_target_table[i].name))\n+\t  return (int)i;\n+    }\n+\n+  return -1;\n+}\n+\n \f\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -1886,16 +2025,23 @@ rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)\n     }\n }\n \n+#define DEBUG_FMT_D \"%-32s= %d\\n\"\n+#define DEBUG_FMT_S \"%-32s= %s\\n\"\n+\n /* Print various interesting information with -mdebug=reg.  */\n static void\n rs6000_debug_reg_global (void)\n {\n+  static const char *const tf[2] = { \"false\", \"true\" };\n   const char *nl = (const char *)0;\n   int m;\n   char costly_num[20];\n   char nop_num[20];\n   const char *costly_str;\n   const char *nop_str;\n+  const char *trace_str;\n+  const char *abi_str;\n+  const char *cmodel_str;\n \n   /* Map enum rs6000_vector to string.  */\n   static const char *rs6000_debug_vector_unit[] = {\n@@ -1975,6 +2121,14 @@ rs6000_debug_reg_global (void)\n       fputs (\"\\n\", stderr);\n     }\n \n+  if (rs6000_cpu_index >= 0)\n+    fprintf (stderr, DEBUG_FMT_S, \"cpu\",\n+\t     processor_target_table[rs6000_cpu_index].name);\n+\n+  if (rs6000_tune_index >= 0)\n+    fprintf (stderr, DEBUG_FMT_S, \"tune\",\n+\t     processor_target_table[rs6000_tune_index].name);\n+\n   switch (rs6000_sched_costly_dep)\n     {\n     case max_dep_latency:\n@@ -2003,6 +2157,8 @@ rs6000_debug_reg_global (void)\n       break;\n     }\n \n+  fprintf (stderr, DEBUG_FMT_S, \"sched_costly_dep\", costly_str);\n+\n   switch (rs6000_sched_insert_nops)\n     {\n     case sched_finish_regroup_exact:\n@@ -2023,21 +2179,85 @@ rs6000_debug_reg_global (void)\n       break;\n     }\n \n-  fprintf (stderr,\n-\t   \"always_hint                     = %s\\n\"\n-\t   \"align_branch_targets            = %s\\n\"\n-\t   \"sched_restricted_insns_priority = %d\\n\"\n-\t   \"sched_costly_dep                = %s\\n\"\n-\t   \"sched_insert_nops               = %s\\n\\n\",\n-\t   rs6000_always_hint ? \"true\" : \"false\",\n-\t   rs6000_align_branch_targets ? \"true\" : \"false\",\n-\t   (int)rs6000_sched_restricted_insns_priority,\n-\t   costly_str, nop_str);\n+  fprintf (stderr, DEBUG_FMT_S, \"sched_insert_nops\", nop_str);\n+\n+  switch (rs6000_sdata)\n+    {\n+    default:\n+    case SDATA_NONE:\n+      break;\n+\n+    case SDATA_DATA:\n+      fprintf (stderr, DEBUG_FMT_S, \"sdata\", \"data\");\n+      break;\n+\n+    case SDATA_SYSV:\n+      fprintf (stderr, DEBUG_FMT_S, \"sdata\", \"sysv\");\n+      break;\n+\n+    case SDATA_EABI:\n+      fprintf (stderr, DEBUG_FMT_S, \"sdata\", \"eabi\");\n+      break;\n+\n+    }\n+\n+  switch (rs6000_traceback)\n+    {\n+    case traceback_default:\ttrace_str = \"default\";\tbreak;\n+    case traceback_none:\ttrace_str = \"none\";\tbreak;\n+    case traceback_part:\ttrace_str = \"part\";\tbreak;\n+    case traceback_full:\ttrace_str = \"full\";\tbreak;\n+    default:\t\t\ttrace_str = \"unknown\";\tbreak;\n+    }\n+\n+  fprintf (stderr, DEBUG_FMT_S, \"traceback\", trace_str);\n+\n+  switch (rs6000_current_cmodel)\n+    {\n+    case CMODEL_SMALL:\tcmodel_str = \"small\";\tbreak;\n+    case CMODEL_MEDIUM:\tcmodel_str = \"medium\";\tbreak;\n+    case CMODEL_LARGE:\tcmodel_str = \"large\";\tbreak;\n+    default:\t\tcmodel_str = \"unknown\";\tbreak;\n+    }\n+\n+  fprintf (stderr, DEBUG_FMT_S, \"cmodel\", cmodel_str);\n+\n+  switch (rs6000_current_abi)\n+    {\n+    case ABI_NONE:\tabi_str = \"none\";\tbreak;\n+    case ABI_AIX:\tabi_str = \"aix\";\tbreak;\n+    case ABI_V4:\tabi_str = \"V4\";\t\tbreak;\n+    case ABI_DARWIN:\tabi_str = \"darwin\";\tbreak;\n+    default:\t\tabi_str = \"unknown\";\tbreak;\n+    }\n+\n+  fprintf (stderr, DEBUG_FMT_S, \"abi\", abi_str);\n+\n+  if (rs6000_altivec_abi)\n+    fprintf (stderr, DEBUG_FMT_S, \"altivec_abi\", \"true\");\n+\n+  if (rs6000_spe_abi)\n+    fprintf (stderr, DEBUG_FMT_S, \"spe_abi\", \"true\");\n+\n+  if (rs6000_darwin64_abi)\n+    fprintf (stderr, DEBUG_FMT_S, \"darwin64_abi\", \"true\");\n+\n+  if (rs6000_float_gprs)\n+    fprintf (stderr, DEBUG_FMT_S, \"float_gprs\", \"true\");\n+\n+  fprintf (stderr, DEBUG_FMT_S, \"always_hint\", tf[!!rs6000_always_hint]);\n+  fprintf (stderr, DEBUG_FMT_S, \"align_branch\",\n+\t   tf[!!rs6000_align_branch_targets]);\n+  fprintf (stderr, DEBUG_FMT_D, \"tls_size\", rs6000_tls_size);\n+  fprintf (stderr, DEBUG_FMT_D, \"long_double_size\",\n+\t   rs6000_long_double_type_size);\n+  fprintf (stderr, DEBUG_FMT_D, \"sched_restricted_insns_priority\",\n+\t   (int)rs6000_sched_restricted_insns_priority);\n }\n \n /* Initialize the various global tables that are based on register size.  */\n static void\n-rs6000_init_hard_regno_mode_ok (void)\n+rs6000_init_hard_regno_mode_ok (bool global_init_p)\n {\n   int r, m, c;\n   int align64;\n@@ -2330,40 +2550,43 @@ rs6000_init_hard_regno_mode_ok (void)\n \t}\n     }\n \n-  if (TARGET_DEBUG_REG)\n-    rs6000_debug_reg_global ();\n-\n-  if (TARGET_DEBUG_COST || TARGET_DEBUG_REG)\n-    fprintf (stderr,\n-\t     \"SImode variable mult cost       = %d\\n\"\n-\t     \"SImode constant mult cost       = %d\\n\"\n-\t     \"SImode short constant mult cost = %d\\n\"\n-\t     \"DImode multipliciation cost     = %d\\n\"\n-\t     \"SImode division cost            = %d\\n\"\n-\t     \"DImode division cost            = %d\\n\"\n-\t     \"Simple fp operation cost        = %d\\n\"\n-\t     \"DFmode multiplication cost      = %d\\n\"\n-\t     \"SFmode division cost            = %d\\n\"\n-\t     \"DFmode division cost            = %d\\n\"\n-\t     \"cache line size                 = %d\\n\"\n-\t     \"l1 cache size                   = %d\\n\"\n-\t     \"l2 cache size                   = %d\\n\"\n-\t     \"simultaneous prefetches         = %d\\n\"\n-\t     \"\\n\",\n-\t     rs6000_cost->mulsi,\n-\t     rs6000_cost->mulsi_const,\n-\t     rs6000_cost->mulsi_const9,\n-\t     rs6000_cost->muldi,\n-\t     rs6000_cost->divsi,\n-\t     rs6000_cost->divdi,\n-\t     rs6000_cost->fp,\n-\t     rs6000_cost->dmul,\n-\t     rs6000_cost->sdiv,\n-\t     rs6000_cost->ddiv,\n-\t     rs6000_cost->cache_line_size,\n-\t     rs6000_cost->l1_cache_size,\n-\t     rs6000_cost->l2_cache_size,\n-\t     rs6000_cost->simultaneous_prefetches);\n+  if (global_init_p || TARGET_DEBUG_TARGET)\n+    {\n+      if (TARGET_DEBUG_REG)\n+\trs6000_debug_reg_global ();\n+\n+      if (TARGET_DEBUG_COST || TARGET_DEBUG_REG)\n+\tfprintf (stderr,\n+\t\t \"SImode variable mult cost       = %d\\n\"\n+\t\t \"SImode constant mult cost       = %d\\n\"\n+\t\t \"SImode short constant mult cost = %d\\n\"\n+\t\t \"DImode multipliciation cost     = %d\\n\"\n+\t\t \"SImode division cost            = %d\\n\"\n+\t\t \"DImode division cost            = %d\\n\"\n+\t\t \"Simple fp operation cost        = %d\\n\"\n+\t\t \"DFmode multiplication cost      = %d\\n\"\n+\t\t \"SFmode division cost            = %d\\n\"\n+\t\t \"DFmode division cost            = %d\\n\"\n+\t\t \"cache line size                 = %d\\n\"\n+\t\t \"l1 cache size                   = %d\\n\"\n+\t\t \"l2 cache size                   = %d\\n\"\n+\t\t \"simultaneous prefetches         = %d\\n\"\n+\t\t \"\\n\",\n+\t\t rs6000_cost->mulsi,\n+\t\t rs6000_cost->mulsi_const,\n+\t\t rs6000_cost->mulsi_const9,\n+\t\t rs6000_cost->muldi,\n+\t\t rs6000_cost->divsi,\n+\t\t rs6000_cost->divdi,\n+\t\t rs6000_cost->fp,\n+\t\t rs6000_cost->dmul,\n+\t\t rs6000_cost->sdiv,\n+\t\t rs6000_cost->ddiv,\n+\t\t rs6000_cost->cache_line_size,\n+\t\t rs6000_cost->l1_cache_size,\n+\t\t rs6000_cost->l2_cache_size,\n+\t\t rs6000_cost->simultaneous_prefetches);\n+    }\n }\n \n #if TARGET_MACHO\n@@ -2420,187 +2643,26 @@ darwin_rs6000_override_options (void)\n #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 64\n #endif\n \n-/* Override command line options.  Mostly we process the processor\n-   type and sometimes adjust other TARGET_ options.  */\n+/* Override command line options.  Mostly we process the processor type and\n+   sometimes adjust other TARGET_ options.  */\n \n-static void\n-rs6000_option_override_internal (const char *default_cpu)\n+static bool\n+rs6000_option_override_internal (bool global_init_p)\n {\n-  size_t i, j;\n-  struct rs6000_cpu_select *ptr;\n+  bool ret = true;\n+  const char *default_cpu = OPTION_TARGET_CPU_DEFAULT;\n   int set_masks;\n-\n-  /* Simplifications for entries below.  */\n-\n-  enum {\n-    POWERPC_BASE_MASK = MASK_POWERPC | MASK_NEW_MNEMONICS,\n-    POWERPC_7400_MASK = POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_ALTIVEC\n-  };\n-\n-  /* This table occasionally claims that a processor does not support\n-     a particular feature even though it does, but the feature is slower\n-     than the alternative.  Thus, it shouldn't be relied on as a\n-     complete description of the processor's support.\n-\n-     Please keep this list in order, and don't forget to update the\n-     documentation in invoke.texi when adding a new processor or\n-     flag.  */\n-  static struct ptt\n-    {\n-      const char *const name;\t\t/* Canonical processor name.  */\n-      const enum processor_type processor; /* Processor type enum value.  */\n-      const int target_enable;\t/* Target flags to enable.  */\n-    } const processor_target_table[]\n-      = {{\"401\", PROCESSOR_PPC403, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"403\", PROCESSOR_PPC403,\n-\t  POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_STRICT_ALIGN},\n-\t {\"405\", PROCESSOR_PPC405,\n-\t  POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n-\t {\"405fp\", PROCESSOR_PPC405,\n-\t  POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n-\t {\"440\", PROCESSOR_PPC440,\n-\t  POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n-\t {\"440fp\", PROCESSOR_PPC440,\n-\t  POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n-\t {\"464\", PROCESSOR_PPC440,\n-\t  POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_MULHW | MASK_DLMZB},\n-\t {\"464fp\", PROCESSOR_PPC440,\n-\t  POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n- \t {\"476\", PROCESSOR_PPC476,\n-\t  POWERPC_BASE_MASK | MASK_SOFT_FLOAT | MASK_PPC_GFXOPT | MASK_MFCRF\n-\t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_MULHW | MASK_DLMZB},\n- \t {\"476fp\", PROCESSOR_PPC476,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_MFCRF | MASK_POPCNTB\n-\t  | MASK_FPRND | MASK_CMPB | MASK_MULHW | MASK_DLMZB},\n-\t {\"505\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK},\n-\t {\"601\", PROCESSOR_PPC601,\n-\t  MASK_POWER | POWERPC_BASE_MASK | MASK_MULTIPLE | MASK_STRING},\n-\t {\"602\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"603\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"603e\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"604\", PROCESSOR_PPC604, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"604e\", PROCESSOR_PPC604e, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"620\", PROCESSOR_PPC620,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n-\t {\"630\", PROCESSOR_PPC630,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n-\t {\"740\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"7400\", PROCESSOR_PPC7400, POWERPC_7400_MASK},\n-\t {\"7450\", PROCESSOR_PPC7450, POWERPC_7400_MASK},\n-\t {\"750\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"801\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"821\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"823\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"8540\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n-\t  | MASK_ISEL},\n-\t /* 8548 has a dummy entry for now.  */\n-\t {\"8548\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n-\t  | MASK_ISEL},\n- \t {\"a2\", PROCESSOR_PPCA2,\n- \t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_POPCNTB\n- \t  | MASK_CMPB | MASK_NO_UPDATE },\n-\t {\"e300c2\", PROCESSOR_PPCE300C2, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"e300c3\", PROCESSOR_PPCE300C3, POWERPC_BASE_MASK},\n-\t {\"e500mc\", PROCESSOR_PPCE500MC, POWERPC_BASE_MASK | MASK_PPC_GFXOPT\n-\t  | MASK_ISEL},\n-\t {\"e500mc64\", PROCESSOR_PPCE500MC64, POWERPC_BASE_MASK | MASK_POWERPC64\n-\t  | MASK_PPC_GFXOPT | MASK_ISEL},\n-\t {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"970\", PROCESSOR_POWER4,\n-\t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n-\t {\"cell\", PROCESSOR_CELL,\n-\t  POWERPC_7400_MASK  | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n-\t {\"common\", PROCESSOR_COMMON, MASK_NEW_MNEMONICS},\n-\t {\"ec603e\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"G3\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n-\t {\"G4\",  PROCESSOR_PPC7450, POWERPC_7400_MASK},\n-\t {\"G5\", PROCESSOR_POWER4,\n-\t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n-\t {\"titan\", PROCESSOR_TITAN,\n-\t  POWERPC_BASE_MASK | MASK_MULHW | MASK_DLMZB},\n-\t {\"power\", PROCESSOR_POWER, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n-\t {\"power2\", PROCESSOR_POWER,\n-\t  MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING},\n-\t {\"power3\", PROCESSOR_PPC630,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n-\t {\"power4\", PROCESSOR_POWER4,\n-\t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF},\n-\t {\"power5\", PROCESSOR_POWER5,\n-\t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF | MASK_POPCNTB},\n-\t {\"power5+\", PROCESSOR_POWER5,\n-\t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND},\n- \t {\"power6\", PROCESSOR_POWER6,\n-\t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n-\t  | MASK_RECIP_PRECISION},\n-\t {\"power6x\", PROCESSOR_POWER6,\n-\t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n-\t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n-\t  | MASK_MFPGPR | MASK_RECIP_PRECISION},\n-\t {\"power7\", PROCESSOR_POWER7,   /* Don't add MASK_ISEL by default */\n-\t  POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n-\t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n-\t  | MASK_VSX | MASK_RECIP_PRECISION},\n-\t {\"powerpc\", PROCESSOR_POWERPC, POWERPC_BASE_MASK},\n-\t {\"powerpc64\", PROCESSOR_POWERPC64,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n-\t {\"rios\", PROCESSOR_RIOS1, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n-\t {\"rios1\", PROCESSOR_RIOS1, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n-\t {\"rios2\", PROCESSOR_RIOS2,\n-\t  MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING},\n-\t {\"rsc\", PROCESSOR_PPC601, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n-\t {\"rsc1\", PROCESSOR_PPC601, MASK_POWER | MASK_MULTIPLE | MASK_STRING},\n-\t {\"rs64\", PROCESSOR_RS64A,\n-\t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64}\n-      };\n-\n-  const size_t ptt_size = ARRAY_SIZE (processor_target_table);\n-\n-  /* Some OSs don't support saving the high part of 64-bit registers on\n-     context switch.  Other OSs don't support saving Altivec registers.\n-     On those OSs, we don't touch the MASK_POWERPC64 or MASK_ALTIVEC\n-     settings; if the user wants either, the user must explicitly specify\n-     them and we won't interfere with the user's specification.  */\n-\n-  enum {\n-    POWER_MASKS = MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING,\n-    POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT | MASK_STRICT_ALIGN\n-\t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n-\t\t     | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_MULHW\n-\t\t     | MASK_DLMZB | MASK_CMPB | MASK_MFPGPR | MASK_DFP\n-\t\t     | MASK_POPCNTD | MASK_VSX | MASK_ISEL | MASK_NO_UPDATE\n-\t\t     | MASK_RECIP_PRECISION)\n-  };\n-\n-  /* Masks for instructions set at various powerpc ISAs.  */\n-  enum {\n-    ISA_2_1_MASKS = MASK_MFCRF,\n-    ISA_2_2_MASKS = (ISA_2_1_MASKS | MASK_POPCNTB),\n-    ISA_2_4_MASKS = (ISA_2_2_MASKS | MASK_FPRND),\n-\n-    /* For ISA 2.05, do not add MFPGPR, since it isn't in ISA 2.06, and don't\n-       add ALTIVEC, since in general it isn't a win on power6.  In ISA 2.04,\n-       fsel, fre, fsqrt, etc. were no longer documented as optional.  Group\n-       masks by server and embedded. */\n-    ISA_2_5_MASKS_EMBEDDED = (ISA_2_2_MASKS | MASK_CMPB | MASK_RECIP_PRECISION\n-\t\t\t      | MASK_PPC_GFXOPT | MASK_PPC_GPOPT),\n-    ISA_2_5_MASKS_SERVER = (ISA_2_5_MASKS_EMBEDDED | MASK_DFP),\n-\n-    /* For ISA 2.06, don't add ISEL, since in general it isn't a win, but\n-       altivec is a win so enable it.  */\n-    ISA_2_6_MASKS_EMBEDDED = (ISA_2_5_MASKS_EMBEDDED | MASK_POPCNTD),\n-    ISA_2_6_MASKS_SERVER = (ISA_2_5_MASKS_SERVER | MASK_POPCNTD | MASK_ALTIVEC\n-\t\t\t    | MASK_VSX)\n-  };\n+  int cpu_index;\n+  int tune_index;\n+  struct cl_target_option *main_target_opt\n+    = ((global_init_p || target_option_default_node == NULL)\n+       ? NULL : TREE_TARGET_OPTION (target_option_default_node));\n \n   /* Numerous experiment shows that IRA based loop pressure\n      calculation works better for RTL loop invariant motion on targets\n      with enough (>= 32) registers.  It is an expensive optimization.\n      So it is on only for peak performance.  */\n-  if (optimize >= 3)\n+  if (optimize >= 3 && global_init_p)\n     flag_ira_loop_pressure = 1;\n \n   /* Set the pointer size.  */\n@@ -2629,34 +2691,43 @@ rs6000_option_override_internal (const char *default_cpu)\n   set_masks &= ~target_flags_explicit;\n \n   /* Identify the processor type.  */\n-  rs6000_select[0].string = default_cpu;\n-  rs6000_cpu = TARGET_POWERPC64 ? PROCESSOR_DEFAULT64 : PROCESSOR_DEFAULT;\n-\n-  for (i = 0; i < ARRAY_SIZE (rs6000_select); i++)\n-    {\n-      ptr = &rs6000_select[i];\n-      if (ptr->string != (char *)0 && ptr->string[0] != '\\0')\n-\t{\n-\t  for (j = 0; j < ptt_size; j++)\n-\t    if (! strcmp (ptr->string, processor_target_table[j].name))\n-\t      {\n-\t\tif (ptr->set_tune_p)\n-\t\t  rs6000_cpu = processor_target_table[j].processor;\n+  if (!default_cpu)\n+    {\n+      if (TARGET_POWERPC64)\n+\tdefault_cpu = \"powerpc64\";\n+      else if (TARGET_POWERPC)\n+\tdefault_cpu = \"powerpc\";\n+    }\n+\n+  /* Process the -mcpu=<xxx> and -mtune=<xxx> argument.  If the user changed\n+     the cpu in a target attribute or pragma, but did not specify a tuning\n+     option, use the cpu for the tuning option rather than the option specified\n+     with -mtune on the command line.  */\n+  if (rs6000_cpu_index > 0)\n+    cpu_index = rs6000_cpu_index;\n+  else if (main_target_opt != NULL && main_target_opt->x_rs6000_cpu_index > 0)\n+    rs6000_cpu_index = cpu_index = main_target_opt->x_rs6000_cpu_index;\n+  else\n+    rs6000_cpu_index = cpu_index = rs6000_cpu_name_lookup (default_cpu);\n \n-\t\tif (ptr->set_arch_p)\n-\t\t  {\n-\t\t    target_flags &= ~set_masks;\n-\t\t    target_flags |= (processor_target_table[j].target_enable\n-\t\t\t\t     & set_masks);\n-\t\t  }\n-\t\tbreak;\n-\t      }\n+  if (rs6000_tune_index > 0)\n+    tune_index = rs6000_tune_index;\n+  else\n+    rs6000_tune_index = tune_index = cpu_index;\n \n-\t  if (j == ptt_size)\n-\t    error (\"bad value (%s) for %s switch\", ptr->string, ptr->name);\n-\t}\n+  if (cpu_index >= 0)\n+    {\n+      target_flags &= ~set_masks;\n+      target_flags |= (processor_target_table[cpu_index].target_enable\n+\t\t       & set_masks);\n     }\n \n+  rs6000_cpu = ((tune_index >= 0)\n+\t\t? processor_target_table[tune_index].processor\n+\t\t: (TARGET_POWERPC64\n+\t\t   ? PROCESSOR_DEFAULT64\n+\t\t   : PROCESSOR_DEFAULT));\n+\n   if (rs6000_cpu == PROCESSOR_PPCE300C2 || rs6000_cpu == PROCESSOR_PPCE300C3\n       || rs6000_cpu == PROCESSOR_PPCE500MC || rs6000_cpu == PROCESSOR_PPCE500MC64)\n     {\n@@ -2767,25 +2838,8 @@ rs6000_option_override_internal (const char *default_cpu)\n   if (rs6000_block_move_inline_limit < (TARGET_POWERPC64 ? 64 : 32))\n     rs6000_block_move_inline_limit = (TARGET_POWERPC64 ? 64 : 32);\n \n-  /* Set debug flags */\n-  if (rs6000_debug_name)\n-    {\n-      if (! strcmp (rs6000_debug_name, \"all\"))\n-\trs6000_debug_stack = rs6000_debug_arg = rs6000_debug_reg\n-\t  = rs6000_debug_addr = rs6000_debug_cost = 1;\n-      else if (! strcmp (rs6000_debug_name, \"stack\"))\n-\trs6000_debug_stack = 1;\n-      else if (! strcmp (rs6000_debug_name, \"arg\"))\n-\trs6000_debug_arg = 1;\n-      else if (! strcmp (rs6000_debug_name, \"reg\"))\n-\trs6000_debug_reg = 1;\n-      else if (! strcmp (rs6000_debug_name, \"addr\"))\n-\trs6000_debug_addr = 1;\n-      else if (! strcmp (rs6000_debug_name, \"cost\"))\n-\trs6000_debug_cost = 1;\n-      else\n-\terror (\"unknown -mdebug-%s switch\", rs6000_debug_name);\n-\n+  if (global_init_p)\n+    {\n       /* If the appropriate debug option is enabled, replace the target hooks\n \t with debug versions that call the real version and then prints\n \t debugging information.  */\n@@ -2813,41 +2867,50 @@ rs6000_option_override_internal (const char *default_cpu)\n \t  rs6000_mode_dependent_address_ptr\n \t    = rs6000_debug_mode_dependent_address;\n \t}\n-    }\n \n-  if (rs6000_traceback_name)\n-    {\n-      if (! strncmp (rs6000_traceback_name, \"full\", 4))\n-\trs6000_traceback = traceback_full;\n-      else if (! strncmp (rs6000_traceback_name, \"part\", 4))\n-\trs6000_traceback = traceback_part;\n-      else if (! strncmp (rs6000_traceback_name, \"no\", 2))\n-\trs6000_traceback = traceback_none;\n-      else\n-\terror (\"unknown -mtraceback arg %qs; expecting %<full%>, %<partial%> or %<none%>\",\n-\t       rs6000_traceback_name);\n+      if (rs6000_veclibabi_name)\n+\t{\n+\t  if (strcmp (rs6000_veclibabi_name, \"mass\") == 0)\n+\t    rs6000_veclib_handler = rs6000_builtin_vectorized_libmass;\n+\t  else\n+\t    {\n+\t      error (\"unknown vectorization library ABI type (%s) for \"\n+\t\t     \"-mveclibabi= switch\", rs6000_veclibabi_name);\n+\t      ret = false;\n+\t    }\n+\t}\n     }\n \n-  if (rs6000_veclibabi_name)\n+  if (!rs6000_explicit_options.long_double)\n     {\n-      if (strcmp (rs6000_veclibabi_name, \"mass\") == 0)\n-\trs6000_veclib_handler = rs6000_builtin_vectorized_libmass;\n+      if (main_target_opt != NULL\n+\t  && (main_target_opt->x_rs6000_long_double_type_size\n+\t      != RS6000_DEFAULT_LONG_DOUBLE_SIZE))\n+\terror (\"target attribute or pragma changes long double size\");\n       else\n-\terror (\"unknown vectorization library ABI type (%s) for \"\n-\t       \"-mveclibabi= switch\", rs6000_veclibabi_name);\n+\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n     }\n \n-  if (!rs6000_explicit_options.long_double)\n-    rs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n-\n #ifndef POWERPC_LINUX\n   if (!rs6000_explicit_options.ieee)\n     rs6000_ieeequad = 1;\n #endif\n \n+  /* Disable VSX and Altivec silently if the user switched cpus to power7 in a\n+     target attribute or pragma which automatically enables both options,\n+     unless the altivec ABI was set.  This is set by default for 64-bit, but\n+     not for 32-bit.  */\n+  if (main_target_opt != NULL && !main_target_opt->x_rs6000_altivec_abi)\n+    target_flags &= ~((MASK_VSX | MASK_ALTIVEC) & ~target_flags_explicit);\n+\n   /* Enable Altivec ABI for AIX -maltivec.  */\n   if (TARGET_XCOFF && (TARGET_ALTIVEC || TARGET_VSX))\n-    rs6000_altivec_abi = 1;\n+    {\n+      if (main_target_opt != NULL && !main_target_opt->x_rs6000_altivec_abi)\n+\terror (\"target attribute or pragma changes AltiVec ABI\");\n+      else\n+\trs6000_altivec_abi = 1;\n+    }\n \n   /* The AltiVec ABI is the default for PowerPC-64 GNU/Linux.  For\n      PowerPC-32 GNU/Linux, -maltivec implies the AltiVec ABI.  It can\n@@ -2856,7 +2919,13 @@ rs6000_option_override_internal (const char *default_cpu)\n     {\n       if (!rs6000_explicit_options.altivec_abi\n \t  && (TARGET_64BIT || TARGET_ALTIVEC || TARGET_VSX))\n-\trs6000_altivec_abi = 1;\n+\t{\n+\t  if (main_target_opt != NULL &&\n+\t      !main_target_opt->x_rs6000_altivec_abi)\n+\t    error (\"target attribute or pragma changes AltiVec ABI\");\n+\t  else\n+\t    rs6000_altivec_abi = 1;\n+\t}\n \n       /* Enable VRSAVE for AltiVec ABI, unless explicitly overridden.  */\n       if (!rs6000_explicit_options.vrsave)\n@@ -2869,19 +2938,21 @@ rs6000_option_override_internal (const char *default_cpu)\n       && DEFAULT_ABI == ABI_DARWIN \n       && TARGET_64BIT)\n     {\n-      rs6000_darwin64_abi = 1;\n-      /* Default to natural alignment, for better performance.  */\n-      rs6000_alignment_flags = MASK_ALIGN_NATURAL;\n+      if (main_target_opt != NULL && !main_target_opt->x_rs6000_darwin64_abi)\n+\terror (\"target attribute or pragma changes darwin64 ABI\");\n+      else\n+\t{\n+\t  rs6000_darwin64_abi = 1;\n+\t  /* Default to natural alignment, for better performance.  */\n+\t  rs6000_alignment_flags = MASK_ALIGN_NATURAL;\n+\t}\n     }\n \n   /* Place FP constants in the constant pool instead of TOC\n      if section anchors enabled.  */\n   if (flag_section_anchors)\n     TARGET_NO_FP_IN_TOC = 1;\n \n-  /* Handle -mtls-size option.  */\n-  rs6000_parse_tls_size_option ();\n-\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n@@ -2905,12 +2976,20 @@ rs6000_option_override_internal (const char *default_cpu)\n       /* For the powerpc-eabispe configuration, we set all these by\n \t default, so let's unset them if we manually set another\n \t CPU that is not the E500.  */\n-      if (!rs6000_explicit_options.spe_abi)\n-\trs6000_spe_abi = 0;\n-      if (!rs6000_explicit_options.spe)\n-\trs6000_spe = 0;\n-      if (!rs6000_explicit_options.float_gprs)\n-\trs6000_float_gprs = 0;\n+      if (main_target_opt != NULL\n+\t  && ((main_target_opt->x_rs6000_spe_abi != rs6000_spe_abi)\n+\t      || (main_target_opt->x_rs6000_spe != rs6000_spe)\n+\t      || (main_target_opt->x_rs6000_float_gprs != rs6000_float_gprs)))\n+\terror (\"target attribute or pragma changes SPE ABI\");\n+      else\n+\t{\n+\t  if (!rs6000_explicit_options.spe_abi)\n+\t    rs6000_spe_abi = 0;\n+\t  if (!rs6000_explicit_options.spe)\n+\t    rs6000_spe = 0;\n+\t  if (!rs6000_explicit_options.float_gprs)\n+\t    rs6000_float_gprs = 0;\n+\t}\n       if (!(target_flags_explicit & MASK_ISEL))\n \ttarget_flags &= ~MASK_ISEL;\n     }\n@@ -2983,79 +3062,83 @@ rs6000_option_override_internal (const char *default_cpu)\n \t\t\t\t    atoi (rs6000_sched_insert_nops_str));\n     }\n \n+  if (global_init_p)\n+    {\n #ifdef TARGET_REGNAMES\n-  /* If the user desires alternate register names, copy in the\n-     alternate names now.  */\n-  if (TARGET_REGNAMES)\n-    memcpy (rs6000_reg_names, alt_reg_names, sizeof (rs6000_reg_names));\n+      /* If the user desires alternate register names, copy in the\n+\t alternate names now.  */\n+      if (TARGET_REGNAMES)\n+\tmemcpy (rs6000_reg_names, alt_reg_names, sizeof (rs6000_reg_names));\n #endif\n \n-  /* Set aix_struct_return last, after the ABI is determined.\n-     If -maix-struct-return or -msvr4-struct-return was explicitly\n-     used, don't override with the ABI default.  */\n-  if (!rs6000_explicit_options.aix_struct_ret)\n-    aix_struct_return = (DEFAULT_ABI != ABI_V4 || DRAFT_V4_STRUCT_RET);\n+      /* Set aix_struct_return last, after the ABI is determined.\n+\t If -maix-struct-return or -msvr4-struct-return was explicitly\n+\t used, don't override with the ABI default.  */\n+      if (!rs6000_explicit_options.aix_struct_ret)\n+\taix_struct_return = (DEFAULT_ABI != ABI_V4 || DRAFT_V4_STRUCT_RET);\n \n #if 0\n-  /* IBM XL compiler defaults to unsigned bitfields.  */\n-  if (TARGET_XL_COMPAT)\n-    flag_signed_bitfields = 0;\n+      /* IBM XL compiler defaults to unsigned bitfields.  */\n+      if (TARGET_XL_COMPAT)\n+\tflag_signed_bitfields = 0;\n #endif\n \n-  if (TARGET_LONG_DOUBLE_128 && !TARGET_IEEEQUAD)\n-    REAL_MODE_FORMAT (TFmode) = &ibm_extended_format;\n-\n-  if (TARGET_TOC)\n-    ASM_GENERATE_INTERNAL_LABEL (toc_label_name, \"LCTOC\", 1);\n+      if (TARGET_LONG_DOUBLE_128 && !TARGET_IEEEQUAD)\n+\tREAL_MODE_FORMAT (TFmode) = &ibm_extended_format;\n \n-  /* We can only guarantee the availability of DI pseudo-ops when\n-     assembling for 64-bit targets.  */\n-  if (!TARGET_64BIT)\n-    {\n-      targetm.asm_out.aligned_op.di = NULL;\n-      targetm.asm_out.unaligned_op.di = NULL;\n-    }\n+      if (TARGET_TOC)\n+\tASM_GENERATE_INTERNAL_LABEL (toc_label_name, \"LCTOC\", 1);\n \n-  /* Set branch target alignment, if not optimizing for size.  */\n-  if (!optimize_size)\n-    {\n-      /* Cell wants to be aligned 8byte for dual issue.  Titan wants to be\n-\t aligned 8byte to avoid misprediction by the branch predictor.  */\n-      if (rs6000_cpu == PROCESSOR_TITAN\n-\t  || rs6000_cpu == PROCESSOR_CELL)\n+      /* We can only guarantee the availability of DI pseudo-ops when\n+\t assembling for 64-bit targets.  */\n+      if (!TARGET_64BIT)\n \t{\n-\t  if (align_functions <= 0)\n-\t    align_functions = 8;\n-\t  if (align_jumps <= 0)\n-\t    align_jumps = 8;\n-\t  if (align_loops <= 0)\n-\t    align_loops = 8;\n- \t}\n-      if (rs6000_align_branch_targets)\n+\t  targetm.asm_out.aligned_op.di = NULL;\n+\t  targetm.asm_out.unaligned_op.di = NULL;\n+\t}\n+\n+\n+      /* Set branch target alignment, if not optimizing for size.  */\n+      if (!optimize_size)\n \t{\n-\t  if (align_functions <= 0)\n-\t    align_functions = 16;\n-\t  if (align_jumps <= 0)\n-\t    align_jumps = 16;\n-\t  if (align_loops <= 0)\n+\t  /* Cell wants to be aligned 8byte for dual issue.  Titan wants to be\n+\t     aligned 8byte to avoid misprediction by the branch predictor.  */\n+\t  if (rs6000_cpu == PROCESSOR_TITAN\n+\t      || rs6000_cpu == PROCESSOR_CELL)\n \t    {\n-\t      can_override_loop_align = 1;\n-\t      align_loops = 16;\n+\t      if (align_functions <= 0)\n+\t\talign_functions = 8;\n+\t      if (align_jumps <= 0)\n+\t\talign_jumps = 8;\n+\t      if (align_loops <= 0)\n+\t\talign_loops = 8;\n \t    }\n+\t  if (rs6000_align_branch_targets)\n+\t    {\n+\t      if (align_functions <= 0)\n+\t\talign_functions = 16;\n+\t      if (align_jumps <= 0)\n+\t\talign_jumps = 16;\n+\t      if (align_loops <= 0)\n+\t\t{\n+\t\t  can_override_loop_align = 1;\n+\t\t  align_loops = 16;\n+\t\t}\n+\t    }\n+\t  if (align_jumps_max_skip <= 0)\n+\t    align_jumps_max_skip = 15;\n+\t  if (align_loops_max_skip <= 0)\n+\t    align_loops_max_skip = 15;\n \t}\n-      if (align_jumps_max_skip <= 0)\n-\talign_jumps_max_skip = 15;\n-      if (align_loops_max_skip <= 0)\n-\talign_loops_max_skip = 15;\n-    }\n \n-  /* Arrange to save and restore machine status around nested functions.  */\n-  init_machine_status = rs6000_init_machine_status;\n+      /* Arrange to save and restore machine status around nested functions.  */\n+      init_machine_status = rs6000_init_machine_status;\n \n-  /* We should always be splitting complex arguments, but we can't break\n-     Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */\n-  if (DEFAULT_ABI != ABI_AIX)\n-    targetm.calls.split_complex_arg = NULL;\n+      /* We should always be splitting complex arguments, but we can't break\n+\t Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */\n+      if (DEFAULT_ABI != ABI_AIX)\n+\ttargetm.calls.split_complex_arg = NULL;\n+    }\n \n   /* Initialize rs6000_cost with the appropriate target costs.  */\n   if (optimize_size)\n@@ -3174,25 +3257,29 @@ rs6000_option_override_internal (const char *default_cpu)\n \tgcc_unreachable ();\n       }\n \n-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t rs6000_cost->simultaneous_prefetches,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_SIZE, rs6000_cost->l1_cache_size,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t rs6000_cost->cache_line_size,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-  maybe_set_param_value (PARAM_L2_CACHE_SIZE, rs6000_cost->l2_cache_size,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-\n-  /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (DEFAULT_ABI != ABI_V4)\n-    targetm.expand_builtin_va_start = NULL;\n+  if (global_init_p)\n+    {\n+      maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n+\t\t\t     rs6000_cost->simultaneous_prefetches,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_L1_CACHE_SIZE, rs6000_cost->l1_cache_size,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n+\t\t\t     rs6000_cost->cache_line_size,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+      maybe_set_param_value (PARAM_L2_CACHE_SIZE, rs6000_cost->l2_cache_size,\n+\t\t\t     global_options.x_param_values,\n+\t\t\t     global_options_set.x_param_values);\n+\n+      /* If using typedef char *va_list, signal that\n+\t __builtin_va_start (&ap, 0) can be optimized to\n+\t ap = __builtin_next_arg (0).  */\n+      if (DEFAULT_ABI != ABI_V4)\n+\ttargetm.expand_builtin_va_start = NULL;\n+    }\n \n   /* Set up single/double float flags.  \n      If TARGET_HARD_FLOAT is set, but neither single or double is set, \n@@ -3211,6 +3298,16 @@ rs6000_option_override_internal (const char *default_cpu)\n       rs6000_single_float = rs6000_double_float = 1;\n   }\n \n+  if (main_target_opt)\n+    {\n+      if (main_target_opt->x_rs6000_single_float != rs6000_single_float)\n+\terror (\"target attribute or pragma changes single precision floating \"\n+\t       \"point\");\n+      if (main_target_opt->x_rs6000_double_float != rs6000_double_float)\n+\terror (\"target attribute or pragma changes double precision floating \"\n+\t       \"point\");\n+    }\n+\n   /* If not explicitly specified via option, decide whether to generate indexed\n      load/store instructions.  */\n   if (TARGET_AVOID_XFORM == -1)\n@@ -3254,6 +3351,7 @@ rs6000_option_override_internal (const char *default_cpu)\n \t\t  error (\"unknown option for -mrecip=%s\", q);\n \t\t  invert = false;\n \t\t  mask = 0;\n+\t\t  ret = false;\n \t\t}\n \t    }\n \n@@ -3264,7 +3362,14 @@ rs6000_option_override_internal (const char *default_cpu)\n \t}\n     }\n \n-  rs6000_init_hard_regno_mode_ok ();\n+  rs6000_init_hard_regno_mode_ok (global_init_p);\n+\n+  /* Save the initial options in case the user does function specific options */\n+  if (global_init_p)\n+    target_option_default_node = target_option_current_node\n+      = build_target_option_node ();\n+\n+  return ret;\n }\n \n /* Implement TARGET_OPTION_OVERRIDE.  On the RS/6000 this is used to\n@@ -3273,9 +3378,10 @@ rs6000_option_override_internal (const char *default_cpu)\n static void\n rs6000_option_override (void)\n {\n-  rs6000_option_override_internal (OPTION_TARGET_CPU_DEFAULT);\n+  (void) rs6000_option_override_internal (true);\n }\n \n+\f\n /* Implement targetm.vectorize.builtin_mask_for_load.  */\n static tree\n rs6000_builtin_mask_for_load (void)\n@@ -3712,23 +3818,6 @@ rs6000_parse_yes_no_option (const char *name, const char *value, int *flag)\n     error (\"unknown -m%s= option specified: '%s'\", name, value);\n }\n \n-/* Validate and record the size specified with the -mtls-size option.  */\n-\n-static void\n-rs6000_parse_tls_size_option (void)\n-{\n-  if (rs6000_tls_size_string == 0)\n-    return;\n-  else if (strcmp (rs6000_tls_size_string, \"16\") == 0)\n-    rs6000_tls_size = 16;\n-  else if (strcmp (rs6000_tls_size_string, \"32\") == 0)\n-    rs6000_tls_size = 32;\n-  else if (strcmp (rs6000_tls_size_string, \"64\") == 0)\n-    rs6000_tls_size = 64;\n-  else\n-    error (\"bad value %qs for -mtls-size switch\", rs6000_tls_size_string);\n-}\n-\n /* Implement TARGET_OPTION_INIT_STRUCT.  */\n \n static void\n@@ -4101,6 +4190,7 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n {\n   enum fpu_type_t fpu_type = FPU_NONE;\n   int isel;\n+  char *p, *q;\n \n   switch (code)\n     {\n@@ -4140,11 +4230,11 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n #if defined (HAVE_LD_LARGE_TOC) && defined (TARGET_USES_LINUX64_OPT)\n     case OPT_mcmodel_:\n       if (strcmp (arg, \"small\") == 0)\n-\tcmodel = CMODEL_SMALL;\n+\trs6000_current_cmodel = CMODEL_SMALL;\n       else if (strcmp (arg, \"medium\") == 0)\n-\tcmodel = CMODEL_MEDIUM;\n+\trs6000_current_cmodel = CMODEL_MEDIUM;\n       else if (strcmp (arg, \"large\") == 0)\n-\tcmodel = CMODEL_LARGE;\n+\trs6000_current_cmodel = CMODEL_LARGE;\n       else\n \t{\n \t  error (\"invalid option for -mcmodel: '%s'\", arg);\n@@ -4245,7 +4335,45 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n       break;\n \n     case OPT_mdebug_:\n-      rs6000_debug_name = arg;\n+      p = ASTRDUP (arg);\n+      rs6000_debug = 0;\n+\n+      while ((q = strtok (p, \",\")) != NULL)\n+\t{\n+\t  unsigned mask = 0;\n+\t  bool invert;\n+\n+\t  p = NULL;\n+\t  if (*q == '!')\n+\t    {\n+\t      invert = true;\n+\t      q++;\n+\t    }\n+\t  else\n+\t    invert = false;\n+\n+\t  if (! strcmp (q, \"all\"))\n+\t    mask = MASK_DEBUG_ALL;\n+\t  else if (! strcmp (q, \"stack\"))\n+\t    mask = MASK_DEBUG_STACK;\n+\t  else if (! strcmp (q, \"arg\"))\n+\t    mask = MASK_DEBUG_ARG;\n+\t  else if (! strcmp (q, \"reg\"))\n+\t    mask = MASK_DEBUG_REG;\n+\t  else if (! strcmp (q, \"addr\"))\n+\t    mask = MASK_DEBUG_ADDR;\n+\t  else if (! strcmp (q, \"cost\"))\n+\t    mask = MASK_DEBUG_COST;\n+\t  else if (! strcmp (q, \"target\"))\n+\t    mask = MASK_DEBUG_TARGET;\n+\t  else\n+\t    error (\"unknown -mdebug-%s switch\", q);\n+\n+\t  if (invert)\n+\t    rs6000_debug &= ~mask;\n+\t  else\t\n+\t    rs6000_debug |= mask;\n+\t}\n       break;\n \n #ifdef TARGET_USES_SYSV4_OPT\n@@ -4258,7 +4386,14 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n       break;\n \n     case OPT_mtls_size_:\n-      rs6000_tls_size_string = arg;\n+      if (strcmp (arg, \"16\") == 0)\n+\trs6000_tls_size = 16;\n+      else if (strcmp (arg, \"32\") == 0)\n+\trs6000_tls_size = 32;\n+      else if (strcmp (arg, \"64\") == 0)\n+\trs6000_tls_size = 64;\n+      else\n+\terror (\"bad value %qs for -mtls-size switch\", arg);\n       break;\n \n     case OPT_mrelocatable:\n@@ -4348,14 +4483,28 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n \n     case OPT_mcpu_:\n       rs6000_select[1].string = arg;\n+      rs6000_cpu_index = rs6000_cpu_name_lookup (arg);\n+      if (rs6000_cpu_index < 0)\n+\terror (\"bad value (%s) for -mcpu\", arg);\n       break;\n \n     case OPT_mtune_:\n       rs6000_select[2].string = arg;\n+      rs6000_tune_index = rs6000_cpu_name_lookup (arg);\n+      if (rs6000_tune_index < 0)\n+\terror (\"bad value (%s) for -mtune\", arg);\n       break;\n \n     case OPT_mtraceback_:\n-      rs6000_traceback_name = arg;\n+      if (! strncmp (arg, \"full\", 4))\n+\trs6000_traceback = traceback_full;\n+      else if (! strncmp (arg, \"part\", 4))\n+\trs6000_traceback = traceback_part;\n+      else if (! strncmp (arg, \"no\", 2))\n+\trs6000_traceback = traceback_none;\n+      else\n+\terror (\"unknown -mtraceback arg %qs; expecting %<full%>, \"\n+\t       \"%<partial%> or %<none%>\", arg);\n       break;\n \n     case OPT_mfloat_gprs_:\n@@ -6845,6 +6994,9 @@ rs6000_conditional_register_usage (void)\n {\n   int i;\n \n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_conditional_register_usage called\\n\");\n+\n   /* Set MQ register fixed (already call_used) if not POWER\n      architecture (RIOS1, RIOS2, RSC, and PPC601) so that it will not\n      be allocated.  */\n@@ -27144,6 +27296,585 @@ rs6000_final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n     }\n }\n \n+\f\n+/* Mask options that we want to support inside of attribute((target)) and\n+   #pragma GCC target operations.  Note, we do not include things like\n+   64/32-bit, endianess, hard/soft floating point, etc. that would have\n+   different calling sequences.  */\n+\n+struct rs6000_opt_mask {\n+  const char *name;\t\t/* option name */\n+  int mask;\t\t\t/* mask to set */\n+  bool invert;\t\t\t/* invert sense of mask */\n+  bool valid_target;\t\t/* option is a target option */\n+};\n+\n+static struct rs6000_opt_mask const rs6000_opt_masks[] =\n+{\n+  { \"altivec\",\t\tMASK_ALTIVEC,\t\tfalse, true  },\n+  { \"cmpb\",\t\tMASK_CMPB,\t\tfalse, true  },\n+  { \"dlmzb\",\t\tMASK_DLMZB,\t\tfalse, true  },\n+  { \"fprnd\",\t\tMASK_FPRND,\t\tfalse, true  },\n+  { \"hard-dfp\",\t\tMASK_DFP,\t\tfalse, true  },\n+  { \"isel\",\t\tMASK_ISEL,\t\tfalse, true  },\n+  { \"mfcrf\",\t\tMASK_MFCRF,\t\tfalse, true  },\n+  { \"mfpgpr\",\t\tMASK_MFPGPR,\t\tfalse, true  },\n+  { \"mulhw\",\t\tMASK_MULHW,\t\tfalse, true  },\n+  { \"multiple\",\t\tMASK_MULTIPLE,\t\tfalse, true  },\n+  { \"update\",\t\tMASK_NO_UPDATE,\t\ttrue , true  },\n+  { \"popcntb\",\t\tMASK_POPCNTB,\t\tfalse, true  },\n+  { \"popcntd\",\t\tMASK_POPCNTD,\t\tfalse, true  },\n+  { \"powerpc-gfxopt\",\tMASK_PPC_GFXOPT,\tfalse, true  },\n+  { \"powerpc-gpopt\",\tMASK_PPC_GPOPT,\t\tfalse, true  },\n+  { \"recip-precision\",\tMASK_RECIP_PRECISION,\tfalse, true  },\n+  { \"string\",\t\tMASK_STRING,\t\tfalse, true  },\n+  { \"vsx\",\t\tMASK_VSX,\t\tfalse, true  },\n+#ifdef MASK_64BIT\n+#if TARGET_AIX_OS\n+  { \"aix64\",\t\tMASK_64BIT,\t\tfalse, false },\n+  { \"aix32\",\t\tMASK_64BIT,\t\ttrue,  false },\n+#else\n+  { \"64\",\t\tMASK_64BIT,\t\tfalse, false },\n+  { \"32\",\t\tMASK_64BIT,\t\ttrue,  false },\n+#endif\n+#endif\n+#ifdef MASK_EABI\n+  { \"eabi\",\t\tMASK_EABI,\t\tfalse, false },\n+#endif\n+#ifdef MASK_LITTLE_ENDIAN\n+  { \"little\",\t\tMASK_LITTLE_ENDIAN,\tfalse, false },\n+  { \"big\",\t\tMASK_LITTLE_ENDIAN,\ttrue,  false },\n+#endif\n+#ifdef MASK_RELOCATABLE\n+  { \"relocatable\",\tMASK_RELOCATABLE,\tfalse, false },\n+#endif\n+#ifdef MASK_STRICT_ALIGN\n+  { \"strict-align\",\tMASK_STRICT_ALIGN,\tfalse, false },\n+#endif\n+  { \"power\",\t\tMASK_POWER,\t\tfalse, false },\n+  { \"power2\",\t\tMASK_POWER2,\t\tfalse, false },\n+  { \"powerpc\",\t\tMASK_POWERPC,\t\tfalse, false },\n+  { \"soft-float\",\tMASK_SOFT_FLOAT,\tfalse, false },\n+  { \"string\",\t\tMASK_STRING,\t\tfalse, false },\n+};\n+\n+/* Option variables that we want to support inside attribute((target)) and\n+   #pragma GCC target operations.  */\n+\n+struct rs6000_opt_var {\n+  const char *name;\t\t/* option name */\n+  size_t global_offset;\t\t/* offset of the option in global_options.  */\n+  size_t target_offset;\t\t/* offset of the option in target optiosn.  */\n+};\n+\n+static struct rs6000_opt_var const rs6000_opt_vars[] =\n+{\n+  { \"friz\",\n+    offsetof (struct gcc_options, x_TARGET_FRIZ),\n+    offsetof (struct cl_target_option, x_TARGET_FRIZ), },\n+  { \"avoid-indexed-addresses\",\n+    offsetof (struct gcc_options, x_TARGET_AVOID_XFORM),\n+    offsetof (struct cl_target_option, x_TARGET_AVOID_XFORM) },\n+  { \"paired\",\n+    offsetof (struct gcc_options, x_rs6000_paired_float),\n+    offsetof (struct cl_target_option, x_rs6000_paired_float), },\n+  { \"longcall\",\n+    offsetof (struct gcc_options, x_rs6000_default_long_calls),\n+    offsetof (struct cl_target_option, x_rs6000_default_long_calls), },\n+};\n+\n+/* Inner function to handle attribute((target(\"...\"))) and #pragma GCC target\n+   parsing.  Return true if there were no errors.  */\n+\n+static bool\n+rs6000_inner_target_options (tree args, bool attr_p)\n+{\n+  bool ret = true;\n+\n+  if (args == NULL_TREE)\n+    ;\n+\n+  else if (TREE_CODE (args) == STRING_CST)\n+    {\n+      char *p = ASTRDUP (TREE_STRING_POINTER (args));\n+      char *q;\n+\n+      while ((q = strtok (p, \",\")) != NULL)\n+\t{\n+\t  bool error_p = false;\n+\t  bool not_valid_p = false;\n+\t  const char *cpu_opt = NULL;\n+\n+\t  p = NULL;\n+\t  if (strncmp (q, \"cpu=\", 4) == 0)\n+\t    {\n+\t      int cpu_index = rs6000_cpu_name_lookup (q+4);\n+\t      if (cpu_index >= 0)\n+\t\trs6000_cpu_index = cpu_index;\n+\t      else\n+\t\t{\n+\t\t  error_p = true;\n+\t\t  cpu_opt = q+4;\n+\t\t}\n+\t    }\n+\t  else if (strncmp (q, \"tune=\", 5) == 0)\n+\t    {\n+\t      int tune_index = rs6000_cpu_name_lookup (q+5);\n+\t      if (tune_index >= 0)\n+\t\trs6000_tune_index = tune_index;\n+\t      else\n+\t\t{\n+\t\t  error_p = true;\n+\t\t  cpu_opt = q+5;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      size_t i;\n+\t      bool invert = false;\n+\t      char *r = q;\n+\n+\t      error_p = true;\n+\t      if (strncmp (r, \"no-\", 3) == 0)\n+\t\t{\n+\t\t  invert = true;\n+\t\t  r += 3;\n+\t\t}\n+\n+\t      for (i = 0; i < ARRAY_SIZE (rs6000_opt_masks); i++)\n+\t\tif (strcmp (r, rs6000_opt_masks[i].name) == 0)\n+\t\t  {\n+\t\t    int mask = rs6000_opt_masks[i].mask;\n+\n+\t\t    if (!rs6000_opt_masks[i].valid_target)\n+\t\t      not_valid_p = true;\n+\t\t    else\n+\t\t      {\n+\t\t\terror_p = false;\n+\t\t\ttarget_flags_explicit |= mask;\n+\n+\t\t\tif (rs6000_opt_masks[i].invert)\n+\t\t\t  invert = !invert;\n+\n+\t\t\tif (invert)\n+\t\t\t  target_flags &= ~mask;\n+\t\t\telse\n+\t\t\t  target_flags |= mask;\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\n+\t      if (error_p && !not_valid_p)\n+\t\t{\n+\t\t  for (i = 0; i < ARRAY_SIZE (rs6000_opt_vars); i++)\n+\t\t    if (strcmp (r, rs6000_opt_vars[i].name) == 0)\n+\t\t      {\n+\t\t\tsize_t j = rs6000_opt_vars[i].global_offset;\n+\t\t\t((int *) &global_options)[j] = !invert;\n+\t\t\terror_p = false;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\n+\t  if (error_p)\n+\t    {\n+\t      const char *eprefix, *esuffix;\n+\n+\t      ret = false;\n+\t      if (attr_p)\n+\t\t{\n+\t\t  eprefix = \"__attribute__((__target__(\";\n+\t\t  esuffix = \")))\";\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  eprefix = \"#pragma GCC target \";\n+\t\t  esuffix = \"\";\n+\t\t}\n+\n+\t      if (cpu_opt)\n+\t\terror (\"invalid cpu \\\"%s\\\" for %s\\\"%s\\\"%s\", cpu_opt, eprefix,\n+\t\t       q, esuffix);\n+\t      else if (not_valid_p)\n+\t\terror (\"%s\\\"%s\\\"%s is not allowed\", eprefix, q, esuffix);\n+\t      else\n+\t\terror (\"%s\\\"%s\\\"%s is invalid\", eprefix, q, esuffix);\n+\t    }\n+\t}\n+    }\n+\n+  else if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      do\n+\t{\n+\t  tree value = TREE_VALUE (args);\n+\t  if (value)\n+\t    {\n+\t      bool ret2 = rs6000_inner_target_options (value, attr_p);\n+\t      if (!ret2)\n+\t\tret = false;\n+\t    }\n+\t  args = TREE_CHAIN (args);\n+\t}\n+      while (args != NULL_TREE);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return ret;\n+}\n+\n+/* Print out the target options as a list for -mdebug=target.  */\n+\n+static void\n+rs6000_debug_target_options (tree args, const char *prefix)\n+{\n+  if (args == NULL_TREE)\n+    fprintf (stderr, \"%s<NULL>\", prefix);\n+\n+  else if (TREE_CODE (args) == STRING_CST)\n+    {\n+      char *p = ASTRDUP (TREE_STRING_POINTER (args));\n+      char *q;\n+\n+      while ((q = strtok (p, \",\")) != NULL)\n+\t{\n+\t  p = NULL;\n+\t  fprintf (stderr, \"%s\\\"%s\\\"\", prefix, q);\n+\t  prefix = \", \";\n+\t}\n+    }\n+\n+  else if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      do\n+\t{\n+\t  tree value = TREE_VALUE (args);\n+\t  if (value)\n+\t    {\n+\t      rs6000_debug_target_options (value, prefix);\n+\t      prefix = \", \";\n+\t    }\n+\t  args = TREE_CHAIN (args);\n+\t}\n+      while (args != NULL_TREE);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return;\n+}\n+\n+\f\n+/* Hook to validate attribute((target(\"...\"))).  */\n+\n+static bool\n+rs6000_valid_attribute_p (tree fndecl,\n+\t\t\t  tree ARG_UNUSED (name),\n+\t\t\t  tree args,\n+\t\t\t  int flags)\n+{\n+  struct cl_target_option cur_target;\n+  bool ret;\n+  tree old_optimize = build_optimization_node ();\n+  tree new_target, new_optimize;\n+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+\n+  gcc_assert ((fndecl != NULL_TREE) && (args != NULL_TREE));\n+\n+  if (TARGET_DEBUG_TARGET)\n+    {\n+      tree tname = DECL_NAME (fndecl);\n+      fprintf (stderr, \"\\n==================== rs6000_valid_attribute_p:\\n\");\n+      if (tname)\n+\tfprintf (stderr, \"function: %.*s\\n\",\n+\t\t (int) IDENTIFIER_LENGTH (tname),\n+\t\t IDENTIFIER_POINTER (tname));\n+      else\n+\tfprintf (stderr, \"function: unknown\\n\");\n+  \n+      fprintf (stderr, \"args:\");\n+      rs6000_debug_target_options (args, \" \");\n+      fprintf (stderr, \"\\n\");\n+\n+      if (flags)\n+\tfprintf (stderr, \"flags: 0x%x\\n\", flags);\n+\n+      fprintf (stderr, \"--------------------\\n\");\n+    }\n+\n+  old_optimize = build_optimization_node ();\n+  func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+\n+  /* If the function changed the optimization levels as well as setting target\n+     options, start with the optimizations specified.  */\n+  if (func_optimize && func_optimize != old_optimize)\n+    cl_optimization_restore (&global_options,\n+\t\t\t     TREE_OPTIMIZATION (func_optimize));\n+\n+  /* The target attributes may also change some optimization flags, so update\n+     the optimization options if necessary.  */\n+  cl_target_option_save (&cur_target, &global_options);\n+  rs6000_cpu_index = rs6000_tune_index = -1;\n+  ret = rs6000_inner_target_options (args, true);\n+\n+  /* Set up any additional state.  */\n+  if (ret)\n+    {\n+      ret = rs6000_option_override_internal (false);\n+      new_target = build_target_option_node ();\n+    }\n+  else\n+    new_target = NULL;\n+\n+  new_optimize = build_optimization_node ();\n+\n+  if (!new_target)\n+    ret = false;\n+\n+  else if (fndecl)\n+    {\n+      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_target;\n+\n+      if (old_optimize != new_optimize)\n+\tDECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;\n+    }\n+\n+  cl_target_option_restore (&global_options, &cur_target);\n+\n+  if (old_optimize != new_optimize)\n+    cl_optimization_restore (&global_options,\n+\t\t\t     TREE_OPTIMIZATION (old_optimize));\n+\n+  return ret;\n+}\n+\n+\f\n+/* Hook to validate the current #pragma GCC target and set the state, and\n+   update the macros based on what was changed.  If ARGS is NULL, then\n+   POP_TARGET is used to reset the options.  */\n+\n+bool\n+rs6000_pragma_target_parse (tree args, tree pop_target)\n+{\n+  tree cur_tree;\n+  bool ret;\n+\n+  if (TARGET_DEBUG_TARGET)\n+    {\n+      fprintf (stderr, \"\\n==================== rs6000_pragma_target_parse\\n\");\n+      fprintf (stderr, \"args:\");\n+      rs6000_debug_target_options (args, \" \");\n+      fprintf (stderr, \"\\n\");\n+\n+      if (pop_target)\n+\t{\n+\t  fprintf (stderr, \"pop_target:\\n\");\n+\t  debug_tree (pop_target);\n+\t}\n+      else\n+\tfprintf (stderr, \"pop_target: <NULL>\\n\");\n+\n+      fprintf (stderr, \"--------------------\\n\");\n+    }\n+\n+  if (! args)\n+    {\n+      ret = true;\n+      cur_tree = ((pop_target)\n+\t\t  ? pop_target\n+\t\t  : target_option_default_node);\n+      cl_target_option_restore (&global_options,\n+\t\t\t\tTREE_TARGET_OPTION (cur_tree));\n+    }\n+  else\n+    {\n+      rs6000_cpu_index = rs6000_tune_index = -1;\n+      ret = rs6000_inner_target_options (args, false);\n+      cur_tree = build_target_option_node ();\n+\n+      if (!cur_tree)\n+\tret = false;\n+    }\n+\n+  if (cur_tree)\n+    target_option_current_node = cur_tree;\n+\n+  return ret;\n+}\n+\n+\f\n+/* Remember the last target of rs6000_set_current_function.  */\n+static GTY(()) tree rs6000_previous_fndecl;\n+\n+/* Establish appropriate back-end context for processing the function\n+   FNDECL.  The argument might be NULL to indicate processing at top\n+   level, outside of any function scope.  */\n+static void\n+rs6000_set_current_function (tree fndecl)\n+{\n+  tree old_tree = (rs6000_previous_fndecl\n+\t\t   ? DECL_FUNCTION_SPECIFIC_TARGET (rs6000_previous_fndecl)\n+\t\t   : NULL_TREE);\n+\n+  tree new_tree = (fndecl\n+\t\t   ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)\n+\t\t   : NULL_TREE);\n+\n+  if (TARGET_DEBUG_TARGET)\n+    {\n+      bool print_final = false;\n+      fprintf (stderr, \"\\n==================== rs6000_set_current_function\");\n+\n+      if (fndecl)\n+\tfprintf (stderr, \", fndecl %s (%p)\",\n+\t\t (DECL_NAME (fndecl)\n+\t\t  ? IDENTIFIER_POINTER (DECL_NAME (fndecl))\n+\t\t  : \"<unknown>\"), (void *)fndecl);\n+\n+      if (rs6000_previous_fndecl)\n+\tfprintf (stderr, \", prev_fndecl (%p)\", (void *)rs6000_previous_fndecl);\n+\n+      fprintf (stderr, \"\\n\");\n+      if (new_tree)\n+\t{\n+\t  fprintf (stderr, \"\\nnew fndecl target specific options:\\n\");\n+\t  debug_tree (new_tree);\n+\t  print_final = true;\n+\t}\n+\n+      if (old_tree)\n+\t{\n+\t  fprintf (stderr, \"\\nold fndecl target specific options:\\n\");\n+\t  debug_tree (old_tree);\n+\t  print_final = true;\n+\t}\n+\n+      if (print_final)\n+\tfprintf (stderr, \"--------------------\\n\");\n+    }\n+\n+  /* Only change the context if the function changes.  This hook is called\n+     several times in the course of compiling a function, and we don't want to\n+     slow things down too much or call target_reinit when it isn't safe.  */\n+  if (fndecl && fndecl != rs6000_previous_fndecl)\n+    {\n+      rs6000_previous_fndecl = fndecl;\n+      if (old_tree == new_tree)\n+\t;\n+\n+      else if (new_tree)\n+\t{\n+\t  cl_target_option_restore (&global_options,\n+\t\t\t\t    TREE_TARGET_OPTION (new_tree));\n+\t  target_reinit ();\n+\t}\n+\n+      else if (old_tree)\n+\t{\n+\t  struct cl_target_option *def\n+\t    = TREE_TARGET_OPTION (target_option_current_node);\n+\n+\t  cl_target_option_restore (&global_options, def);\n+\t  target_reinit ();\n+\t}\n+    }\n+}\n+\n+\f\n+/* Save the current options */\n+\n+static void\n+rs6000_function_specific_save (struct cl_target_option *ptr)\n+{\n+  ptr->rs6000_target_flags_explicit = target_flags_explicit;\n+}\n+\n+/* Restore the current options */\n+\n+static void\n+rs6000_function_specific_restore (struct cl_target_option *ptr)\n+{\n+  target_flags_explicit = ptr->rs6000_target_flags_explicit;\n+  (void) rs6000_option_override_internal (false);\n+}\n+\n+/* Print the current options */\n+\n+static void\n+rs6000_function_specific_print (FILE *file, int indent,\n+\t\t\t\tstruct cl_target_option *ptr)\n+{\n+  size_t i;\n+  int flags = ptr->x_target_flags;\n+\n+  /* Print the various mask options.  */\n+  for (i = 0; i < ARRAY_SIZE (rs6000_opt_masks); i++)\n+    if ((flags & rs6000_opt_masks[i].mask) != 0)\n+      {\n+\tflags &= ~ rs6000_opt_masks[i].mask;\n+\tfprintf (file, \"%*s-m%s%s\\n\", indent, \"\",\n+\t\t rs6000_opt_masks[i].invert ? \"no-\" : \"\",\n+\t\t rs6000_opt_masks[i].name);\n+      }\n+\n+  /* Print the various options that are variables.  */\n+  for (i = 0; i < ARRAY_SIZE (rs6000_opt_vars); i++)\n+    {\n+      size_t j = rs6000_opt_vars[i].target_offset;\n+      if (((signed char *) ptr)[j])\n+\tfprintf (file, \"%*s-m%s\\n\", indent, \"\",\n+\t\t rs6000_opt_vars[i].name);\n+    }\n+}\n+\n+\f\n+/* Hook to determine if one function can safely inline another.  */\n+\n+static bool\n+rs6000_can_inline_p (tree caller, tree callee)\n+{\n+  bool ret = false;\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+\n+  /* If callee has no option attributes, then it is ok to inline.  */\n+  if (!callee_tree)\n+    ret = true;\n+\n+  /* If caller has no option attributes, but callee does then it is not ok to\n+     inline.  */\n+  else if (!caller_tree)\n+    ret = false;\n+\n+  else\n+    {\n+      struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);\n+      struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n+\n+      /* Callee's options should a subset of the caller's, i.e. a vsx function\n+\t can inline an altivec function but a non-vsx function can't inline a\n+\t vsx function.  */\n+      if ((caller_opts->x_target_flags & callee_opts->x_target_flags)\n+\t  == callee_opts->x_target_flags)\n+\tret = true;\n+    }\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_can_inline_p:, caller %s, callee %s, %s inline\\n\",\n+\t     (DECL_NAME (caller)\n+\t      ? IDENTIFIER_POINTER (DECL_NAME (caller))\n+\t      : \"<unknown>\"),\n+\t     (DECL_NAME (callee)\n+\t      ? IDENTIFIER_POINTER (DECL_NAME (callee))\n+\t      : \"<unknown>\"),\n+\t     (ret ? \"can\" : \"cannot\"));\n+\n+  return ret;\n+}\n \f\n /* Allocate a stack temp and fixup the address so it meets the particular\n    memory requirements (either offetable or REG+REG addressing).  */"}, {"sha": "7b4a27e54a083381f8c7e015ad8167a0a59f41d2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 24, "deletions": 127, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -29,6 +29,10 @@\n /* Note that some other tm.h files include this one and then override\n    many of the definitions.  */\n \n+#ifndef RS6000_OPTS_H\n+#include \"config/rs6000/rs6000-opts.h\"\n+#endif\n+\n /* Definitions for the object file format.  These are set at\n    compile-time.  */\n \n@@ -299,16 +303,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_SECURE_PLT 0\n #endif\n \n-/* Code model for 64-bit linux.\n-   small: 16-bit toc offsets.\n-   medium: 32-bit toc offsets, static data and code within 2G of TOC pointer.\n-   large: 32-bit toc offsets, no limit on static data and code.  */\n-enum rs6000_cmodel {\n-  CMODEL_SMALL,\n-  CMODEL_MEDIUM,\n-  CMODEL_LARGE\n-};\n-\n #ifndef TARGET_CMODEL\n #define TARGET_CMODEL CMODEL_SMALL\n #endif\n@@ -338,40 +332,6 @@ enum rs6000_cmodel {\n \n #define TARGET_DEFAULT (MASK_POWER | MASK_MULTIPLE | MASK_STRING)\n \n-/* Processor type.  Order must match cpu attribute in MD file.  */\n-enum processor_type\n- {\n-   PROCESSOR_RIOS1,\n-   PROCESSOR_RIOS2,\n-   PROCESSOR_RS64A,\n-   PROCESSOR_MPCCORE,\n-   PROCESSOR_PPC403,\n-   PROCESSOR_PPC405,\n-   PROCESSOR_PPC440,\n-   PROCESSOR_PPC476,\n-   PROCESSOR_PPC601,\n-   PROCESSOR_PPC603,\n-   PROCESSOR_PPC604,\n-   PROCESSOR_PPC604e,\n-   PROCESSOR_PPC620,\n-   PROCESSOR_PPC630,\n-   PROCESSOR_PPC750,\n-   PROCESSOR_PPC7400,\n-   PROCESSOR_PPC7450,\n-   PROCESSOR_PPC8540,\n-   PROCESSOR_PPCE300C2,\n-   PROCESSOR_PPCE300C3,\n-   PROCESSOR_PPCE500MC,\n-   PROCESSOR_PPCE500MC64,\n-   PROCESSOR_POWER4,\n-   PROCESSOR_POWER5,\n-   PROCESSOR_POWER6,\n-   PROCESSOR_POWER7,\n-   PROCESSOR_CELL,\n-   PROCESSOR_PPCA2,\n-   PROCESSOR_TITAN\n-};\n-\n /* FPU operations supported. \n    Each use of TARGET_SINGLE_FLOAT or TARGET_DOUBLE_FLOAT must \n    also test TARGET_HARD_FLOAT.  */\n@@ -381,8 +341,6 @@ enum processor_type\n #define TARGET_SIMPLE_FPU   0\n #define TARGET_XILINX_FPU   0\n \n-extern enum processor_type rs6000_cpu;\n-\n /* Recast the processor type to the cpu attribute.  */\n #define rs6000_cpu_attr ((enum attr_cpu)rs6000_cpu)\n \n@@ -396,47 +354,12 @@ extern enum processor_type rs6000_cpu;\n #define PROCESSOR_DEFAULT   PROCESSOR_RIOS1\n #define PROCESSOR_DEFAULT64 PROCESSOR_RS64A\n \n-/* FP processor type.  */\n-enum fpu_type_t\n-{\n-\tFPU_NONE,\t\t/* No FPU */\n-\tFPU_SF_LITE,\t\t/* Limited Single Precision FPU */\n-\tFPU_DF_LITE,\t\t/* Limited Double Precision FPU */\n-\tFPU_SF_FULL,\t\t/* Full Single Precision FPU */\n-\tFPU_DF_FULL\t\t/* Full Double Single Precision FPU */\n-};\n-\n extern enum fpu_type_t fpu_type;\n \n /* Specify the dialect of assembler to use.  New mnemonics is dialect one\n    and the old mnemonics are dialect zero.  */\n #define ASSEMBLER_DIALECT (TARGET_NEW_MNEMONICS ? 1 : 0)\n \n-/* Types of costly dependences.  */\n-enum rs6000_dependence_cost\n- {\n-   max_dep_latency = 1000,\n-   no_dep_costly,\n-   all_deps_costly,\n-   true_store_to_load_dep_costly,\n-   store_to_load_dep_costly\n- };\n-\n-/* Types of nop insertion schemes in sched target hook sched_finish.  */\n-enum rs6000_nop_insertion\n-  {\n-    sched_finish_regroup_exact = 1000,\n-    sched_finish_pad_groups,\n-    sched_finish_none\n-  };\n-\n-/* Dispatch group termination caused by an insn.  */\n-enum group_termination\n-  {\n-    current_group,\n-    previous_group\n-  };\n-\n /* rs6000_select[0] is reserved for the default cpu defined via --with-cpu */\n struct rs6000_cpu_select\n {\n@@ -449,42 +372,25 @@ struct rs6000_cpu_select\n extern struct rs6000_cpu_select rs6000_select[];\n \n /* Debug support */\n-extern const char *rs6000_debug_name;\t/* Name for -mdebug-xxxx option */\n-extern int rs6000_debug_stack;\t\t/* debug stack applications */\n-extern int rs6000_debug_arg;\t\t/* debug argument handling */\n-extern int rs6000_debug_reg;\t\t/* debug register handling */\n-extern int rs6000_debug_addr;\t\t/* debug memory addressing */\n-extern int rs6000_debug_cost;\t\t/* debug rtx_costs */\n-\n-#define\tTARGET_DEBUG_STACK\trs6000_debug_stack\n-#define\tTARGET_DEBUG_ARG\trs6000_debug_arg\n-#define TARGET_DEBUG_REG\trs6000_debug_reg\n-#define TARGET_DEBUG_ADDR\trs6000_debug_addr\n-#define TARGET_DEBUG_COST\trs6000_debug_cost\n-\n-extern const char *rs6000_traceback_name; /* Type of traceback table.  */\n-\n-/* These are separate from target_flags because we've run out of bits\n-   there.  */\n-extern int rs6000_long_double_type_size;\n-extern int rs6000_ieeequad;\n-extern int rs6000_altivec_abi;\n-extern int rs6000_spe_abi;\n-extern int rs6000_spe;\n-extern int rs6000_float_gprs;\n-extern int rs6000_alignment_flags;\n-extern const char *rs6000_sched_insert_nops_str;\n-extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n-\n-/* Describe which vector unit to use for a given machine mode.  */\n-enum rs6000_vector {\n-  VECTOR_NONE,\t\t\t/* Type is not  a vector or not supported */\n-  VECTOR_ALTIVEC,\t\t/* Use altivec for vector processing */\n-  VECTOR_VSX,\t\t\t/* Use VSX for vector processing */\n-  VECTOR_PAIRED,\t\t/* Use paired floating point for vectors */\n-  VECTOR_SPE,\t\t\t/* Use SPE for vector processing */\n-  VECTOR_OTHER\t\t\t/* Some other vector unit */\n-};\n+#define MASK_DEBUG_STACK\t0x01\t/* debug stack applications */\n+#define\tMASK_DEBUG_ARG\t\t0x02\t/* debug argument handling */\n+#define MASK_DEBUG_REG\t\t0x04\t/* debug register handling */\n+#define MASK_DEBUG_ADDR\t\t0x08\t/* debug memory addressing */\n+#define MASK_DEBUG_COST\t\t0x10\t/* debug rtx codes */\n+#define MASK_DEBUG_TARGET\t0x20\t/* debug target attribute/pragma */\n+#define MASK_DEBUG_ALL\t\t(MASK_DEBUG_STACK \\\n+\t\t\t\t | MASK_DEBUG_ARG \\\n+\t\t\t\t | MASK_DEBUG_REG \\\n+\t\t\t\t | MASK_DEBUG_ADDR \\\n+\t\t\t\t | MASK_DEBUG_COST \\\n+\t\t\t\t | MASK_DEBUG_TARGET)\n+\n+#define\tTARGET_DEBUG_STACK\t(rs6000_debug & MASK_DEBUG_STACK)\n+#define\tTARGET_DEBUG_ARG\t(rs6000_debug & MASK_DEBUG_ARG)\n+#define TARGET_DEBUG_REG\t(rs6000_debug & MASK_DEBUG_REG)\n+#define TARGET_DEBUG_ADDR\t(rs6000_debug & MASK_DEBUG_ADDR)\n+#define TARGET_DEBUG_COST\t(rs6000_debug & MASK_DEBUG_COST)\n+#define TARGET_DEBUG_TARGET\t(rs6000_debug & MASK_DEBUG_TARGET)\n \n extern enum rs6000_vector rs6000_vector_unit[];\n \n@@ -628,6 +534,7 @@ extern unsigned char rs6000_recip_bits[];\n /* Target pragma.  */\n #define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\\\n   c_register_pragma (0, \"longcall\", rs6000_pragma_longcall);\t\\\n+  targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \\\n   targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \\\n } while (0)\n \n@@ -1465,16 +1372,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n \n /* Stack layout; function entry, exit and calling.  */\n \n-/* Enumeration to give which calling sequence to use.  */\n-enum rs6000_abi {\n-  ABI_NONE,\n-  ABI_AIX,\t\t\t/* IBM's AIX */\n-  ABI_V4,\t\t\t/* System V.4/eabi */\n-  ABI_DARWIN\t\t\t/* Apple's Darwin (OS X kernel) */\n-};\n-\n-extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n-\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD"}, {"sha": "2c6a861f84b1319c8fbf73f93276a9e001831f46", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 145, "deletions": 42, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -20,6 +20,109 @@\n ; along with GCC; see the file COPYING3.  If not see\n ; <http://www.gnu.org/licenses/>.\n \n+HeaderInclude\n+config/rs6000/rs6000-opts.h\n+\n+;; Current processor\n+TargetVariable\n+enum processor_type rs6000_cpu = PROCESSOR_RIOS1\n+\n+;; Always emit branch hint bits.\n+TargetVariable\n+unsigned char rs6000_always_hint\n+\n+;; Schedule instructions for group formation.\n+TargetVariable\n+unsigned char rs6000_sched_groups\n+\n+;; Align branch targets.\n+TargetVariable\n+unsigned char rs6000_align_branch_targets\n+\n+;; Support for -msched-costly-dep option.\n+TargetVariable\n+enum rs6000_dependence_cost rs6000_sched_costly_dep = no_dep_costly\n+\n+;; Support for -minsert-sched-nops option.\n+TargetVariable\n+enum rs6000_nop_insertion rs6000_sched_insert_nops = sched_finish_none\n+\n+;; Size of long double.\n+TargetVariable\n+unsigned char rs6000_long_double_type_size\n+\n+;; IEEE quad extended precision long double.\n+TargetVariable\n+unsigned char rs6000_ieeequad\n+\n+;; Nonzero to use AltiVec ABI.\n+TargetVariable\n+unsigned char rs6000_altivec_abi\n+\n+;; Nonzero if we want SPE SIMD instructions.\n+TargetVariable\n+int rs6000_spe\n+\n+;; Nonzero if we want SPE ABI extensions.\n+TargetVariable\n+unsigned char rs6000_spe_abi\n+\n+;; Nonzero if floating point operations are done in the GPRs.\n+TargetVariable\n+unsigned char rs6000_float_gprs\n+\n+;; Nonzero if we want Darwin's struct-by-value-in-regs ABI.\n+TargetVariable\n+unsigned char rs6000_darwin64_abi\n+\n+;; Non-zero to allow overriding loop alignment.\n+TargetVariable\n+unsigned char can_override_loop_align\n+\n+;; Which small data model to use (for System V targets only)\n+TargetVariable\n+enum rs6000_sdata_type rs6000_sdata = SDATA_DATA\n+\n+;; Bit size of immediate TLS offsets and string from which it is decoded.\n+TargetVariable\n+int rs6000_tls_size = 32\n+\n+;; ABI enumeration available for subtarget to use.\n+TargetVariable\n+enum rs6000_abi rs6000_current_abi = ABI_NONE\n+\n+;; Type of traceback to use.\n+TargetVariable\n+enum rs6000_traceback_type rs6000_traceback = traceback_default\n+\n+;; Control alignment for fields within structures.\n+TargetVariable\n+unsigned char rs6000_alignment_flags\n+\n+;; Code model for 64-bit linux.\n+TargetVariable\n+enum rs6000_cmodel rs6000_current_cmodel = CMODEL_SMALL\n+\n+;; What type of reciprocal estimation instructions to generate\n+TargetVariable\n+unsigned int rs6000_recip_control\n+\n+;; -mcpu=<xxx> as an index into the processor_target_table or -1\n+TargetVariable\n+int rs6000_cpu_index = -1\n+\n+;; -mtune=<xxx> as an index into the processor_target_table or -1\n+TargetVariable\n+int rs6000_tune_index = -1\n+\n+;; Debug flags\n+TargetVariable\n+unsigned int rs6000_debug\n+\n+;; Save for target_flags_explicit\n+TargetSave\n+int rs6000_target_flags_explicit\n+\n mpower\n Target Report RejectNegative Mask(POWER)\n Use POWER instruction set\n@@ -45,55 +148,55 @@ Target Report Mask(POWERPC64)\n Use PowerPC-64 instruction set\n \n mpowerpc-gpopt\n-Target Report Mask(PPC_GPOPT)\n+Target Report Mask(PPC_GPOPT) Save\n Use PowerPC General Purpose group optional instructions\n \n mpowerpc-gfxopt\n-Target Report Mask(PPC_GFXOPT)\n+Target Report Mask(PPC_GFXOPT) Save\n Use PowerPC Graphics group optional instructions\n \n mmfcrf\n-Target Report Mask(MFCRF)\n+Target Report Mask(MFCRF) Save\n Use PowerPC V2.01 single field mfcr instruction\n \n mpopcntb\n-Target Report Mask(POPCNTB)\n+Target Report Mask(POPCNTB) Save\n Use PowerPC V2.02 popcntb instruction\n \n mfprnd\n-Target Report Mask(FPRND)\n+Target Report Mask(FPRND) Save\n Use PowerPC V2.02 floating point rounding instructions\n \n mcmpb\n-Target Report Mask(CMPB)\n+Target Report Mask(CMPB) Save\n Use PowerPC V2.05 compare bytes instruction\n \n mmfpgpr\n-Target Report Mask(MFPGPR)\n+Target Report Mask(MFPGPR) Save\n Use extended PowerPC V2.05 move floating point to/from GPR instructions\n \n maltivec\n-Target Report Mask(ALTIVEC)\n+Target Report Mask(ALTIVEC) Save\n Use AltiVec instructions\n \n mhard-dfp\n-Target Report Mask(DFP)\n+Target Report Mask(DFP) Save\n Use decimal floating point instructions\n \n mmulhw\n-Target Report Mask(MULHW)\n+Target Report Mask(MULHW) Save\n Use 4xx half-word multiply instructions\n \n mdlmzb\n-Target Report Mask(DLMZB)\n+Target Report Mask(DLMZB) Save\n Use 4xx string-search dlmzb instruction\n \n mmultiple\n-Target Report Mask(MULTIPLE)\n+Target Report Mask(MULTIPLE) Save\n Generate load/store multiple instructions\n \n mstring\n-Target Report Mask(STRING)\n+Target Report Mask(STRING) Save\n Generate string instructions for block moves\n \n mnew-mnemonics\n@@ -113,19 +216,19 @@ Target Report RejectNegative InverseMask(SOFT_FLOAT, HARD_FLOAT)\n Use hardware floating point\n \n mpopcntd\n-Target Report Mask(POPCNTD)\n+Target Report Mask(POPCNTD) Save\n Use PowerPC V2.06 popcntd instruction\n \n mfriz\n-Target Report Var(TARGET_FRIZ) Init(-1)\n+Target Report Var(TARGET_FRIZ) Init(-1) Save\n Under -ffast-math, generate a FRIZ instruction for (double)(long long) conversions\n \n mveclibabi=\n Target RejectNegative Joined Var(rs6000_veclibabi_name)\n Vector library ABI to use\n \n mvsx\n-Target Report Mask(VSX)\n+Target Report Mask(VSX) Save\n Use vector/scalar (VSX) instructions\n \n mvsx-scalar-double\n@@ -165,38 +268,38 @@ Target Undocumented Report Var(TARGET_VECTORIZE_BUILTINS) Init(-1)\n ; Explicitly control whether we vectorize the builtins or not.\n \n mno-update\n-Target Report RejectNegative Mask(NO_UPDATE)\n+Target Report RejectNegative Mask(NO_UPDATE) Save\n Do not generate load/store with update instructions\n \n mupdate\n Target Report RejectNegative InverseMask(NO_UPDATE, UPDATE)\n Generate load/store with update instructions\n \n mavoid-indexed-addresses\n-Target Report Var(TARGET_AVOID_XFORM) Init(-1)\n+Target Report Var(TARGET_AVOID_XFORM) Init(-1) Save\n Avoid generation of indexed load/store instructions when possible\n \n mtls-markers\n-Target Report Var(tls_markers) Init(1)\n+Target Report Var(tls_markers) Init(1) Save\n Mark __tls_get_addr calls with argument info\n \n msched-epilog\n-Target Undocumented Var(TARGET_SCHED_PROLOG) Init(1)\n+Target Undocumented Var(TARGET_SCHED_PROLOG) Init(1) Save\n \n msched-prolog\n-Target Report Var(TARGET_SCHED_PROLOG)\n+Target Report Var(TARGET_SCHED_PROLOG) Save\n Schedule the start and end of the procedure\n \n maix-struct-return\n-Target Report RejectNegative Var(aix_struct_return)\n+Target Report RejectNegative Var(aix_struct_return) Save\n Return all structures in memory (AIX default)\n \n msvr4-struct-return\n-Target Report RejectNegative Var(aix_struct_return,0)\n+Target Report RejectNegative Var(aix_struct_return,0) Save\n Return small structures in registers (SVR4 default)\n \n mxl-compat\n-Target Report Var(TARGET_XL_COMPAT)\n+Target Report Var(TARGET_XL_COMPAT) Save\n Conform more closely to IBM XLC semantics\n \n mrecip\n@@ -208,23 +311,23 @@ Target Report RejectNegative Joined\n Generate software reciprocal divide and square root for better throughput.\n \n mrecip-precision\n-Target Report Mask(RECIP_PRECISION)\n+Target Report Mask(RECIP_PRECISION) Save\n Assume that the reciprocal estimate instructions provide more accuracy.\n \n mno-fp-in-toc\n-Target Report RejectNegative Var(TARGET_NO_FP_IN_TOC)\n+Target Report RejectNegative Var(TARGET_NO_FP_IN_TOC) Save\n Do not place floating point constants in TOC\n \n mfp-in-toc\n-Target Report RejectNegative Var(TARGET_NO_FP_IN_TOC,0)\n+Target Report RejectNegative Var(TARGET_NO_FP_IN_TOC,0) Save\n Place floating point constants in TOC\n \n mno-sum-in-toc\n-Target RejectNegative Var(TARGET_NO_SUM_IN_TOC)\n+Target RejectNegative Var(TARGET_NO_SUM_IN_TOC) Save\n Do not place symbol+offset constants in TOC\n \n msum-in-toc\n-Target RejectNegative Var(TARGET_NO_SUM_IN_TOC,0)\n+Target RejectNegative Var(TARGET_NO_SUM_IN_TOC,0) Save\n Place symbol+offset constants in TOC\n \n ;  Output only one TOC entry per module.  Normally linking fails if\n@@ -243,19 +346,19 @@ Target Report\n Put everything in the regular TOC\n \n mvrsave\n-Target Report Var(TARGET_ALTIVEC_VRSAVE)\n+Target Report Var(TARGET_ALTIVEC_VRSAVE) Save\n Generate VRSAVE instructions when generating AltiVec code\n \n mvrsave=\n Target RejectNegative Joined\n -mvrsave=yes/no\tDeprecated option.  Use -mvrsave/-mno-vrsave instead\n \n mblock-move-inline-limit=\n-Target Report Var(rs6000_block_move_inline_limit) Init(0) RejectNegative Joined UInteger\n+Target Report Var(rs6000_block_move_inline_limit) Init(0) RejectNegative Joined UInteger Save\n Specify how many bytes should be moved inline before calling out to memcpy/memmove\n \n misel\n-Target Report Mask(ISEL)\n+Target Report Mask(ISEL) Save\n Generate isel instructions\n \n misel=\n@@ -267,7 +370,7 @@ Target\n Generate SPE SIMD instructions on E500\n \n mpaired\n-Target Var(rs6000_paired_float)\n+Target Var(rs6000_paired_float) Save\n Generate PPC750CL paired-single instructions\n \n mspe=\n@@ -295,19 +398,19 @@ Target RejectNegative Joined\n -mtraceback=\tSelect full, part, or no traceback table\n \n mlongcall\n-Target Report Var(rs6000_default_long_calls)\n+Target Report Var(rs6000_default_long_calls) Save\n Avoid all range limits on call instructions\n \n mgen-cell-microcode\n-Target Report Var(rs6000_gen_cell_microcode) Init(-1)\n+Target Report Var(rs6000_gen_cell_microcode) Init(-1) Save\n Generate Cell microcode\n \n mwarn-cell-microcode\n-Target Var(rs6000_warn_cell_microcode) Init(0) Warning\n+Target Var(rs6000_warn_cell_microcode) Init(0) Warning Save\n Warn when a Cell microcoded instruction is emitted\n \n mwarn-altivec-long\n-Target Var(rs6000_warn_altivec_long) Init(1)\n+Target Var(rs6000_warn_altivec_long) Init(1) Save\n Warn about deprecated 'vector long ...' AltiVec type usage\n \n mfloat-gprs=\n@@ -331,27 +434,27 @@ Target RejectNegative Joined\n Specify alignment of structure fields default/natural\n \n mprioritize-restricted-insns=\n-Target RejectNegative Joined UInteger Var(rs6000_sched_restricted_insns_priority)\n+Target RejectNegative Joined UInteger Var(rs6000_sched_restricted_insns_priority) Save\n Specify scheduling priority for dispatch slot restricted insns\n \n msingle-float\n-Target RejectNegative Var(rs6000_single_float)\n+Target RejectNegative Var(rs6000_single_float) Save\n Single-precision floating point unit\n \n mdouble-float\n-Target RejectNegative Var(rs6000_double_float)\n+Target RejectNegative Var(rs6000_double_float) Save\n Double-precision floating point unit\n \n msimple-fpu\n-Target RejectNegative Var(rs6000_simple_fpu)\n+Target RejectNegative Var(rs6000_simple_fpu) Save\n Floating point unit does not support divide & sqrt\n \n mfpu=\n Target RejectNegative Joined \n -mfpu=\tSpecify FP (sp, dp, sp-lite, dp-lite) (implies -mxilinx-fpu)\n \n mxilinx-fpu\n-Target Var(rs6000_xilinx_fpu)\n+Target Var(rs6000_xilinx_fpu) Save\n Specify Xilinx FPU.\n \n "}, {"sha": "d557ce1626a1c0f4c51edb2e0581141b24ffb528", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -41,16 +41,6 @@\n #undef\tASM_DEFAULT_SPEC\n #define\tASM_DEFAULT_SPEC \"-mppc\"\n \n-/* Small data support types.  */\n-enum rs6000_sdata_type {\n-  SDATA_NONE,\t\t\t/* No small data support.  */\n-  SDATA_DATA,\t\t\t/* Just put data in .sbss/.sdata, don't use relocs.  */\n-  SDATA_SYSV,\t\t\t/* Use r13 to point to .sdata/.sbss.  */\n-  SDATA_EABI\t\t\t/* Use r13 like above, r2 points to .sdata2/.sbss2.  */\n-};\n-\n-extern enum rs6000_sdata_type rs6000_sdata;\n-\n #define\tTARGET_TOC\t\t((target_flags & MASK_64BIT)\t\t\\\n \t\t\t\t || ((target_flags & (MASK_RELOCATABLE\t\\\n \t\t\t\t\t\t      | MASK_MINIMAL_TOC)) \\\n@@ -70,10 +60,6 @@ extern enum rs6000_sdata_type rs6000_sdata;\n #define TARGET_SECURE_PLT\tsecure_plt\n #endif\n \n-extern const char *rs6000_abi_name;\n-extern const char *rs6000_sdata_name;\n-extern const char *rs6000_tls_size_string; /* For -mtls-size= */\n-\n #define SDATA_DEFAULT_SIZE 8\n \n /* The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to"}, {"sha": "f1f987d2238ef8960af65a15dcb26d24268370a3", "filename": "gcc/config/rs6000/sysv4.opt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.opt?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -32,7 +32,7 @@ Target RejectNegative Joined\n Specify bit size of immediate TLS offsets\n \n mbit-align\n-Target Report Var(TARGET_NO_BITFIELD_TYPE)\n+Target Report Var(TARGET_NO_BITFIELD_TYPE) Save\n Align to the base type of the bit-field\n \n mstrict-align\n@@ -74,7 +74,7 @@ Target RejectNegative\n no description yet\n \n mprototype\n-Target Var(target_prototype)\n+Target Var(target_prototype) Save\n Assume all variable arg functions are prototyped\n \n ;; FIXME: Does nothing.\n@@ -87,11 +87,11 @@ Target Report Mask(EABI)\n Use EABI\n \n mbit-word\n-Target Report Var(TARGET_NO_BITFIELD_WORD)\n+Target Report Var(TARGET_NO_BITFIELD_WORD) Save\n Allow bit-fields to cross word boundaries\n \n mregnames\n-Target Var(rs6000_regnames)\n+Target Var(rs6000_regnames) Save\n Use alternate register names\n \n ;; This option does nothing and only exists because the compiler\n@@ -137,9 +137,9 @@ Target RejectNegative\n no description yet\n \n msecure-plt\n-Target Report RejectNegative Var(secure_plt, 1)\n+Target Report RejectNegative Var(secure_plt, 1) Save\n Generate code to use a non-exec PLT and GOT\n \n mbss-plt\n-Target Report RejectNegative Var(secure_plt, 0)\n+Target Report RejectNegative Var(secure_plt, 0) Save\n Generate code for old exec BSS PLT"}, {"sha": "ec4ba8e7fdde9af4fa606cd38ef83b214dd6dffa", "filename": "gcc/configure", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -849,7 +849,8 @@ PACKAGE_TARNAME\n PACKAGE_NAME\n PATH_SEPARATOR\n SHELL'\n-ac_subst_files='language_hooks'\n+ac_subst_files='option_includes\n+language_hooks'\n ac_user_opts='\n enable_option_checking\n with_build_libsubdir\n@@ -10638,8 +10639,10 @@ fi\n \n # Convert extra_options into a form suitable for Makefile use.\n extra_opt_files=\n+all_opt_files=\n for f in $extra_options; do\n   extra_opt_files=\"$extra_opt_files \\$(srcdir)/config/$f\"\n+  all_opt_files=\"$all_opt_files $srcdir/config/$f\"\n done\n \n \n@@ -17283,7 +17286,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17286 \"configure\"\n+#line 17289 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -17389,7 +17392,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17392 \"configure\"\n+#line 17395 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -25672,6 +25675,7 @@ do\n \tall_lang_makefrags=\"$all_lang_makefrags \\$(srcdir)/$gcc_subdir/Make-lang.in\"\n \tif test -f $srcdir/$gcc_subdir/lang.opt; then\n \t    lang_opt_files=\"$lang_opt_files $srcdir/$gcc_subdir/lang.opt\"\n+\t    all_opt_files=\"$all_opt_files $srcdir/$gcc_subdir/lang.opt\"\n \tfi\n \tif test -f $srcdir/$gcc_subdir/$subdir-tree.def; then\n \t    lang_tree_files=\"$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def\"\n@@ -25723,6 +25727,14 @@ do\n \techo \"lang.$t: $x\" >> Make-hooks\n done\n \n+# --------\n+# Option include files\n+# --------\n+\n+${AWK} -f $srcdir/opt-include.awk $all_opt_files > option-includes.mk\n+option_includes=\"option-includes.mk\"\n+\n+\n # --------\n # UNSORTED\n # --------\n@@ -27389,3 +27401,4 @@ if test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n $as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\n fi\n \n+"}, {"sha": "0eb2d8bddee79bde16fe3a3563aafd237ee5c68b", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -1382,8 +1382,10 @@ fi\n \n # Convert extra_options into a form suitable for Makefile use.\n extra_opt_files=\n+all_opt_files=\n for f in $extra_options; do\n   extra_opt_files=\"$extra_opt_files \\$(srcdir)/config/$f\"\n+  all_opt_files=\"$all_opt_files $srcdir/config/$f\"\n done\n AC_SUBST(extra_opt_files)\n \n@@ -4458,6 +4460,7 @@ changequote([,])dnl\n \tall_lang_makefrags=\"$all_lang_makefrags \\$(srcdir)/$gcc_subdir/Make-lang.in\"\n \tif test -f $srcdir/$gcc_subdir/lang.opt; then\n \t    lang_opt_files=\"$lang_opt_files $srcdir/$gcc_subdir/lang.opt\"\n+\t    all_opt_files=\"$all_opt_files $srcdir/$gcc_subdir/lang.opt\"\n \tfi\n \tif test -f $srcdir/$gcc_subdir/$subdir-tree.def; then\n \t    lang_tree_files=\"$lang_tree_files $srcdir/$gcc_subdir/$subdir-tree.def\"\n@@ -4507,6 +4510,14 @@ do\n \techo \"lang.$t: $x\" >> Make-hooks\n done\n \n+# --------\n+# Option include files\n+# --------\n+\n+${AWK} -f $srcdir/opt-include.awk $all_opt_files > option-includes.mk\n+option_includes=\"option-includes.mk\"\n+AC_SUBST_FILE(option_includes)\n+\n # --------\n # UNSORTED\n # --------\n@@ -4769,3 +4780,4 @@ done\n ], \n [subdirs='$subdirs'])\n AC_OUTPUT\n+"}, {"sha": "28c25e16261897341f02e098cd5e7e2b2c6b01a0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 189, "deletions": 11, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -3272,6 +3272,8 @@ int core2_func (void) __attribute__ ((__target__ (\"arch=core2\")));\n int sse3_func (void) __attribute__ ((__target__ (\"sse3\")));\n @end smallexample\n \n+@table @samp\n+@item i386 target attributes\n On the 386, the following options are allowed:\n \n @table @samp\n@@ -3414,19 +3416,195 @@ Specify which floating point unit to use.  The\n @code{target(\"fpmath=sse,387\")} option must be specified as\n @code{target(\"fpmath=sse+387\")} because the comma would separate\n different options.\n+\n+@item PowerPC target attributes\n+On the PowerPC, the following options are allowed:\n+\n+@table @samp\n+@item altivec\n+@itemx no-altivec\n+@cindex @code{target(\"altivec\")} attribute\n+Generate code that uses (does not use) AltiVec instructions.  In\n+32-bit code, you cannot enable Altivec instructions unless\n+@option{-mabi=altivec} was used on the command line.\n+\n+@item cmpb\n+@itemx no-cmpb\n+@cindex @code{target(\"cmpb\")} attribute\n+Generate code that uses (does not use) the compare bytes instruction\n+implemented on the POWER6 processor and other processors that support\n+the PowerPC V2.05 architecture.\n+\n+@item dlmzb\n+@itemx no-dlmzb\n+@cindex @code{target(\"dlmzb\")} attribute\n+Generate code that uses (does not use) the string-search @samp{dlmzb}\n+instruction on the IBM 405, 440, 464 and 476 processors.  This instruction is\n+generated by default when targetting those processors.\n+\n+@item fprnd\n+@itemx no-fprnd\n+@cindex @code{target(\"fprnd\")} attribute\n+Generate code that uses (does not use) the FP round to integer\n+instructions implemented on the POWER5+ processor and other processors\n+that support the PowerPC V2.03 architecture.\n+\n+@item hard-dfp\n+@itemx no-hard-dfp\n+@cindex @code{target(\"hard-dfp\")} attribute\n+Generate code that uses (does not use) the decimal floating point\n+instructions implemented on some POWER processors.\n+\n+@item isel\n+@itemx no-isel\n+@cindex @code{target(\"isel\")} attribute\n+Generate code that uses (does not use) ISEL instruction.\n+\n+@item mfcrf\n+@itemx no-mfcrf\n+@cindex @code{target(\"mfcrf\")} attribute\n+Generate code that uses (does not use) the move from condition\n+register field instruction implemented on the POWER4 processor and\n+other processors that support the PowerPC V2.01 architecture.\n+\n+@item mfpgpr\n+@itemx no-mfpgpr\n+@cindex @code{target(\"mfpgpr\")} attribute\n+Generate code that uses (does not use) the FP move to/from general\n+purpose register instructions implemented on the POWER6X processor and\n+other processors that support the extended PowerPC V2.05 architecture.\n+\n+@item mulhw\n+@itemx no-mulhw\n+@cindex @code{target(\"mulhw\")} attribute\n+Generate code that uses (does not use) the half-word multiply and\n+multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors.\n+These instructions are generated by default when targetting those\n+processors.\n+\n+@item multiple\n+@itemx no-multiple\n+@cindex @code{target(\"multiple\")} attribute\n+Generate code that uses (does not use) the load multiple word\n+instructions and the store multiple word instructions.\n+\n+@item update\n+@itemx no-update\n+@cindex @code{target(\"update\")} attribute\n+Generate code that uses (does not use) the load or store instructions\n+that update the base register to the address of the calculated memory\n+location.\n+\n+@item popcntb\n+@itemx no-popcntb\n+@cindex @code{target(\"popcntb\")} attribute\n+Generate code that uses (does not use) the popcount and double\n+precision FP reciprocal estimate instruction implemented on the POWER5\n+processor and other processors that support the PowerPC V2.02\n+architecture.\n+\n+@item popcntd\n+@itemx no-popcntd\n+@cindex @code{target(\"popcntd\")} attribute\n+Generate code that uses (does not use) the popcount instruction\n+implemented on the POWER7 processor and other processors that support\n+the PowerPC V2.06 architecture.\n+\n+@item powerpc-gfxopt\n+@itemx no-powerpc-gfxopt\n+@cindex @code{target(\"powerpc-gfxopt\")} attribute\n+Generate code that uses (does not use) the optional PowerPC\n+architecture instructions in the Graphics group, including\n+floating-point select.\n+\n+@item powerpc-gpopt\n+@itemx no-powerpc-gpopt\n+@cindex @code{target(\"powerpc-gpopt\")} attribute\n+Generate code that uses (does not use) the optional PowerPC\n+architecture instructions in the General Purpose group, including\n+floating-point square root.\n+\n+@item recip-precision\n+@itemx no-recip-precision\n+@cindex @code{target(\"recip-precision\")} attribute\n+Assume (do not assume) that the reciprocal estimate instructions\n+provide higher precision estimates than is mandated by the powerpc\n+ABI.\n+\n+@item string\n+@itemx no-string\n+@cindex @code{target(\"string\")} attribute\n+Generate code that uses (does not use) the load string instructions\n+and the store string word instructions to save multiple registers and\n+do small block moves.\n+\n+@item vsx\n+@itemx no-vsx\n+@cindex @code{target(\"vsx\")} attribute\n+Generate code that uses (does not use) vector/scalar (VSX)\n+instructions, and also enable the use of built-in functions that allow\n+more direct access to the VSX instruction set.  In 32-bit code, you\n+cannot enable VSX or Altivec instructions unless\n+@option{-mabi=altivec} was used on the command line.\n+\n+@item friz\n+@itemx no-friz\n+@cindex @code{target(\"friz\")} attribute\n+Generate (do not generate) the @code{friz} instruction when the\n+@option{-funsafe-math-optimizations} option is used to optimize\n+rounding a floating point value to 64-bit integer and back to floating\n+point.  The @code{friz} instruction does not return the same value if\n+the floating point number is too large to fit in an integer.\n+\n+@item avoid-indexed-addresses\n+@itemx no-avoid-indexed-addresses\n+@cindex @code{target(\"avoid-indexed-addresses\")} attribute\n+Generate code that tries to avoid (not avoid) the use of indexed load\n+or store instructions.\n+\n+@item paired\n+@itemx no-paired\n+@cindex @code{target(\"paired\")} attribute\n+Generate code that uses (does not use) the generation of PAIRED simd\n+instructions.\n+\n+@item longcall\n+@itemx no-longcall\n+@cindex @code{target(\"longcall\")} attribute\n+Generate code that assumes (does not assume) that all calls are far\n+away so that a longer more expensive calling sequence is required.\n+\n+@item cpu=@var{CPU}\n+@cindex @code{target(\"cpu=@var{CPU}\")} attribute\n+Specify the architecture to generate code for in compiling the\n+function.  If you select @code{\"target(\"cpu=power7)\"} attribute when\n+generating 32-bit code, VSX and Altivec instructions are not generated\n+unless you use the @option{-mabi=altivec} option on the command line.\n+\n+@item tune=@var{TUNE}\n+@cindex @code{target(\"tune=@var{TUNE}\")} attribute\n+Specify the architecture to tune for in compiling the function.  If\n+you do not specify the @code{target(\"tune=@var{TUNE}\")} attribute and\n+you do specifiy the @code{target(\"cpu=@var{CPU}\")} attribute,\n+compilation will tune for the @var{CPU} architecture, and not the\n+default tuning specified on the command line.\n+@end table\n+@end table\n @end table\n \n-On the 386, you can use either multiple strings to specify multiple\n-options, or you can separate the option with a comma (@code{,}).\n+On the 386/x86_64 and PowerPC backends, you can use either multiple\n+strings to specify multiple options, or you can separate the option\n+with a comma (@code{,}).\n \n-On the 386, the inliner will not inline a function that has different\n-target options than the caller, unless the callee has a subset of the\n-target options of the caller.  For example a function declared with\n-@code{target(\"sse3\")} can inline a function with\n-@code{target(\"sse2\")}, since @code{-msse3} implies @code{-msse2}.\n+On the 386/x86_64 and PowerPC backends, the inliner will not inline a\n+function that has different target options than the caller, unless the\n+callee has a subset of the target options of the caller.  For example\n+a function declared with @code{target(\"sse3\")} can inline a function\n+with @code{target(\"sse2\")}, since @code{-msse3} implies @code{-msse2}.\n \n The @code{target} attribute is not implemented in GCC versions earlier\n-than 4.4, and at present only the 386 uses it.\n+than 4.4 for the i386/x86_64 and 4.6 for the PowerPC backends.  It is\n+not currently implemented for other backends.\n \n @item tiny_data\n @cindex tiny data section on the H8/300H and H8S\n@@ -13001,9 +13179,9 @@ function.  The parenthesis around the options is optional.\n @xref{Function Attributes}, for more information about the\n @code{target} attribute and the attribute syntax.\n \n-The @samp{#pragma GCC target} pragma is not implemented in GCC\n-versions earlier than 4.4, and is currently only implemented for the\n-386 and x86_64 backends.\n+The @code{#pragma GCC target} attribute is not implemented in GCC versions earlier\n+than 4.4 for the i386/x86_64 and 4.6 for the PowerPC backends.  At\n+present, it is not implemented for other backends.\n @end table\n \n @table @code"}, {"sha": "e8d1d1dac2299b28a448f69eb1ef4e877fb64cc7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -15614,8 +15614,11 @@ is enabled by default when targetting Power6 and disabled otherwise.\n @opindex mfused-madd\n @opindex mno-fused-madd\n Generate code that uses (does not use) the floating point multiply and\n-accumulate instructions.  These instructions are generated by default if\n-hardware floating is used.\n+accumulate instructions.  These instructions are generated by default\n+if hardware floating point is used.  The machine dependent\n+@option{-mfused-madd} option is now mapped to the machine independent\n+@option{-ffp-contract=fast} option, and @option{-mno-fused-madd} is\n+mapped to @option{-ffp-contract=off}.\n \n @item -mmulhw\n @itemx -mno-mulhw"}, {"sha": "8c5c6399316cd48d2c719946a72979335ab392dd", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -51,6 +51,32 @@ record, or duplicating it in many records, would be inappropriate, or\n for variables set in option handlers rather than referenced by\n @code{Var} properties.\n \n+@item\n+A variable record to define a variable used to store option\n+information.  These records have two fields: the string\n+@samp{TargetVariable}, and a declaration of the type and name of the\n+variable, optionally with an initializer (but without any trailing\n+@samp{;}).  @samp{TargetVariable} is a combination of @samp{Variable}\n+and @samp{TargetSave} records in that the variable is defined in the\n+@code{gcc_options} structure, but these variables are also stored in\n+the @code{cl_target_option} structure.  The variables are saved in the\n+target save code and restored in the target restore code.\n+\n+@item\n+A variable record to record any additional files that the\n+@file{options.h} file should include.  This is useful to provide\n+enumeration or structure definitions needed for target variables.\n+These records have two fields: the string @samp{HeaderInclude} and the\n+name of the include file.\n+\n+@item\n+A variable record to record any additional files that the\n+@file{options.c} file should include.  This is useful to provide\n+inline functions needed for target variables and/or @code{#ifdef}\n+sequences to properly set up the initialization.  These records have\n+two fields: the string @samp{SourceInclude} and the name of the\n+include file.\n+\n @item\n An option definition record.  These records have the following fields:\n @enumerate"}, {"sha": "31169aef6faeb897122a1bbcb9a1c4f837492c0a", "filename": "gcc/opt-include.awk", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fopt-include.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fopt-include.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-include.awk?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -0,0 +1,30 @@\n+#  Copyright (C) 2010\n+#  Free Software Foundation, Inc.\n+#  Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This Awk script reads in the option records and emits the include files\n+# listed by the HeaderInclude directive.\n+\n+BEGIN {\n+\th_next = 0\n+\tc_next = 0\n+}\n+\n+(h_next != 0)\t  { print \"OPTIONS_H_EXTRA += $(srcdir)/\" $1; h_next = 0 }\n+(c_next != 0)\t  { print \"OPTIONS_C_EXTRA += $(srcdir)/\" $1; c_next = 0 }\n+/^HeaderInclude$/ { h_next = 1; c_next = 0 }\n+/^SourceInclude$/ { h_next = 0; c_next = 1 }"}, {"sha": "3bf0b8eacbbefde0c43862aee4f58f204d5874bd", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -31,7 +31,10 @@ BEGIN {\n \tn_langs = 0\n \tn_target_save = 0\n \tn_extra_vars = 0\n-        quote = \"\\042\"\n+\tn_extra_target_vars = 0\n+\tn_extra_c_includes = 0\n+\tn_extra_h_includes = 0\n+\tquote = \"\\042\"\n \tcomma = \",\"\n \tFS=SUBSEP\n \t# Default the name of header created from opth-gen.awk to options.h\n@@ -53,6 +56,30 @@ BEGIN {\n \t\t\textra_vars[n_extra_vars] = $2\n \t\t\tn_extra_vars++\n \t\t}\n+\t\telse if ($1 == \"TargetVariable\") {\n+\t\t\t# Combination of TargetSave and Variable\n+\t\t\textra_vars[n_extra_vars] = $2\n+\t\t\tn_extra_vars++\n+\n+\t\t\tvar = $2\n+\t\t\tsub(\" *=.*\", \"\", var)\n+\t\t\torig_var = var\n+\t\t\tname = var\n+\t\t\ttype = var\n+\t\t\tsub(\"^.*[ *]\", \"\", name)\n+\t\t\tsub(\" *\" name \"$\", \"\", type)\n+\t\t\ttarget_save_decl[n_target_save] = type \" x_\" name\n+\t\t\tn_target_save++\n+\n+\t\t\textra_target_vars[n_extra_target_vars] = name\n+\t\t\tn_extra_target_vars++;\n+\t\t}\n+\t\telse if ($1 == \"HeaderInclude\") {\n+\t\t\textra_h_includes[n_extra_h_includes++] = $2;\n+\t\t}\n+\t\telse if ($1 == \"SourceInclude\")  {\n+\t\t\textra_c_includes[n_extra_c_includes++] = $2;\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {\n@@ -82,7 +109,17 @@ print \"#include \" quote \"target.h\" quote\n print \"#endif /* GCC_DRIVER */\"\n print \"\"\n \n+if (n_extra_c_includes > 0) {\n+\tfor (i = 0; i < n_extra_c_includes; i++) {\n+\t\tprint \"#include \" quote extra_c_includes[i] quote\n+\t}\n+\tprint \"\"\n+}\n+\n have_save = 0;\n+if (n_extra_target_vars)\n+\thave_save = 1\n+\n print \"const struct gcc_options global_options_init =\\n{\"\n for (i = 0; i < n_extra_vars; i++) {\n \tvar = extra_vars[i]\n@@ -305,11 +342,13 @@ print \"{\";\n n_opt_char = 2;\n n_opt_short = 0;\n n_opt_int = 0;\n+n_opt_enum = 1;\n n_opt_other = 0;\n var_opt_char[0] = \"optimize\";\n var_opt_char[1] = \"optimize_size\";\n var_opt_range[\"optimize\"] = \"0, 255\";\n var_opt_range[\"optimize_size\"] = \"0, 255\";\n+var_opt_enum[0] = \"flag_fp_contract_mode\";\n \n # Sort by size to mimic how the structure is laid out to be friendlier to the\n # cache.\n@@ -331,6 +370,9 @@ for (i = 0; i < n_opts; i++) {\n \t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n \t\t\tvar_opt_short[n_opt_short++] = name;\n \n+\t\telse if (otype ~ (\"^enum +[_\" alnum \"]+ *\"))\n+\t\t\tvar_opt_enum[n_opt_enum++] = name;\n+\n \t\telse if (otype ~ \"^((un)?signed +)?char *$\") {\n \t\t\tvar_opt_char[n_opt_char++] = name;\n \t\t\tif (otype ~ \"^unsigned +char *$\")\n@@ -358,6 +400,10 @@ for (i = 0; i < n_opt_int; i++) {\n \tprint \"  ptr->x_\" var_opt_int[i] \" = opts->x_\" var_opt_int[i] \";\";\n }\n \n+for (i = 0; i < n_opt_enum; i++) {\n+\tprint \"  ptr->x_\" var_opt_enum[i] \" = opts->x_\" var_opt_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_opt_short; i++) {\n \tprint \"  ptr->x_\" var_opt_short[i] \" = opts->x_\" var_opt_short[i] \";\";\n }\n@@ -382,6 +428,10 @@ for (i = 0; i < n_opt_int; i++) {\n \tprint \"  opts->x_\" var_opt_int[i] \" = ptr->x_\" var_opt_int[i] \";\";\n }\n \n+for (i = 0; i < n_opt_enum; i++) {\n+\tprint \"  opts->x_\" var_opt_enum[i] \" = ptr->x_\" var_opt_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_opt_short; i++) {\n \tprint \"  opts->x_\" var_opt_short[i] \" = ptr->x_\" var_opt_short[i] \";\";\n }\n@@ -420,6 +470,14 @@ for (i = 0; i < n_opt_int; i++) {\n \tprint \"\";\n }\n \n+for (i = 0; i < n_opt_enum; i++) {\n+\tprint \"  fprintf (file, \\\"%*s%s (%#x)\\\\n\\\",\";\n+\tprint \"           indent_to, \\\"\\\",\";\n+\tprint \"           \\\"\" var_opt_enum[i] \"\\\",\";\n+\tprint \"           (int) ptr->x_\" var_opt_enum[i] \");\";\n+\tprint \"\";\n+}\n+\n for (i = 0; i < n_opt_short; i++) {\n \tprint \"  if (ptr->x_\" var_opt_short[i] \")\";\n \tprint \"    fprintf (file, \\\"%*s%s (%#x)\\\\n\\\",\";\n@@ -449,6 +507,7 @@ print \"{\";\n n_target_char = 0;\n n_target_short = 0;\n n_target_int = 0;\n+n_target_enum = 0;\n n_target_other = 0;\n \n if (have_save) {\n@@ -469,6 +528,9 @@ if (have_save) {\n \t\t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n \t\t\t\tvar_target_short[n_target_short++] = name;\n \n+\t\t\telse if (otype ~ (\"^enum +[_\" alnum \"]+ *$\"))\n+\t\t\t\tvar_target_enum[n_target_enum++] = name;\n+\n \t\t\telse if (otype ~ \"^((un)?signed +)?char *$\") {\n \t\t\t\tvar_target_char[n_target_char++] = name;\n \t\t\t\tif (otype ~ \"^unsigned +char *$\")\n@@ -500,10 +562,18 @@ print \"  if (targetm.target_option.save)\";\n print \"    targetm.target_option.save (ptr);\";\n print \"\";\n \n+for (i = 0; i < n_extra_target_vars; i++) {\n+\tprint \"  ptr->x_\" extra_target_vars[i] \" = opts->x_\" extra_target_vars[i] \";\";\n+}\n+\n for (i = 0; i < n_target_other; i++) {\n \tprint \"  ptr->x_\" var_target_other[i] \" = opts->x_\" var_target_other[i] \";\";\n }\n \n+for (i = 0; i < n_target_enum; i++) {\n+\tprint \"  ptr->x_\" var_target_enum[i] \" = opts->x_\" var_target_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_target_int; i++) {\n \tprint \"  ptr->x_\" var_target_int[i] \" = opts->x_\" var_target_int[i] \";\";\n }\n@@ -524,10 +594,18 @@ print \"void\";\n print \"cl_target_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)\";\n print \"{\";\n \n+for (i = 0; i < n_extra_target_vars; i++) {\n+\tprint \"  opts->x_\" extra_target_vars[i] \" = ptr->x_\" extra_target_vars[i] \";\";\n+}\n+\n for (i = 0; i < n_target_other; i++) {\n \tprint \"  opts->x_\" var_target_other[i] \" = ptr->x_\" var_target_other[i] \";\";\n }\n \n+for (i = 0; i < n_target_enum; i++) {\n+\tprint \"  opts->x_\" var_target_enum[i] \" = ptr->x_\" var_target_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_target_int; i++) {\n \tprint \"  opts->x_\" var_target_int[i] \" = ptr->x_\" var_target_int[i] \";\";\n }\n@@ -566,6 +644,15 @@ for (i = 0; i < n_target_other; i++) {\n \tprint \"\";\n }\n \n+for (i = 0; i < n_target_enum; i++) {\n+\tprint \"  if (ptr->x_\" var_target_enum[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (%#x)\\\\n\\\",\";\n+\tprint \"             indent, \\\"\\\",\";\n+\tprint \"             \\\"\" var_target_enum[i] \"\\\",\";\n+\tprint \"             ptr->x_\" var_target_enum[i] \");\";\n+\tprint \"\";\n+}\n+\n for (i = 0; i < n_target_int; i++) {\n \tprint \"  if (ptr->x_\" var_target_int[i] \")\";\n \tprint \"    fprintf (file, \\\"%*s%s (%#x)\\\\n\\\",\";"}, {"sha": "9fafb99d4608c1547f121cfadd9ff4ba8aac6426", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -29,7 +29,12 @@ BEGIN {\n \tn_langs = 0\n \tn_target_save = 0\n \tn_extra_vars = 0\n+\tn_extra_target_vars = 0\n \tn_extra_masks = 0\n+\tn_extra_c_includes = 0\n+\tn_extra_h_includes = 0\n+\thave_save = 0;\n+\tquote = \"\\042\"\n \tFS=SUBSEP\n }\n \n@@ -48,6 +53,30 @@ BEGIN {\n \t\t\textra_vars[n_extra_vars] = $2\n \t\t\tn_extra_vars++\n \t\t}\n+\t\telse if ($1 == \"TargetVariable\") {\n+\t\t\t# Combination of TargetSave and Variable\n+\t\t\textra_vars[n_extra_vars] = $2\n+\t\t\tn_extra_vars++\n+\n+\t\t\tvar = $2\n+\t\t\tsub(\" *=.*\", \"\", var)\n+\t\t\torig_var = var\n+\t\t\tname = var\n+\t\t\ttype = var\n+\t\t\tsub(\"^.*[ *]\", \"\", name)\n+\t\t\tsub(\" *\" name \"$\", \"\", type)\n+\t\t\ttarget_save_decl[n_target_save] = type \" x_\" name\n+\t\t\tn_target_save++\n+\n+\t\t\textra_target_vars[n_extra_target_vars] = name\n+\t\t\tn_extra_target_vars++\n+\t\t}\n+\t\telse if ($1 == \"HeaderInclude\") {\n+\t\t\textra_h_includes[n_extra_h_includes++] = $2;\n+\t\t}\n+\t\telse if ($1 == \"SourceInclude\")  {\n+\t\t\textra_c_includes[n_extra_c_includes++] = $2;\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {\n@@ -73,11 +102,21 @@ print \"\"\n print \"#include \\\"flag-types.h\\\"\"\n print \"\"\n \n-have_save = 0;\n+if (n_extra_h_includes > 0) {\n+\tfor (i = 0; i < n_extra_h_includes; i++) {\n+\t\tprint \"#include \" quote extra_h_includes[i] quote\n+\t}\n+\tprint \"\"\n+}\n \n print \"#if !defined(IN_LIBGCC2) && !defined(IN_TARGET_LIBS) && !defined(IN_RTS)\"\n print \"#ifndef GENERATOR_FILE\"\n-print \"struct gcc_options\\n{\"\n+print \"#if !defined(GCC_DRIVER) && !defined(IN_LIBGCC2) && !defined(IN_TARGET_LIBS)\"\n+print \"struct GTY(()) gcc_options\"\n+print \"#else\"\n+print \"struct gcc_options\"\n+print \"#endif\"\n+print \"{\"\n print \"#endif\"\n \n for (i = 0; i < n_extra_vars; i++) {\n@@ -155,9 +194,11 @@ print \"{\";\n n_opt_char = 2;\n n_opt_short = 0;\n n_opt_int = 0;\n+n_opt_enum = 1;\n n_opt_other = 0;\n var_opt_char[0] = \"unsigned char x_optimize\";\n var_opt_char[1] = \"unsigned char x_optimize_size\";\n+var_opt_enum[0] = \"enum fp_contract_mode x_flag_fp_contract_mode\";\n \n for (i = 0; i < n_opts; i++) {\n \tif (flag_set_p(\"Optimization\", flags[i])) {\n@@ -179,6 +220,9 @@ for (i = 0; i < n_opts; i++) {\n \t\telse if (otype ~ \"^((un)?signed +)?char *$\")\n \t\t\tvar_opt_char[n_opt_char++] = otype \"x_\" name;\n \n+\t\telse if (otype ~ (\"^enum +[_\" alnum \"]+ *$\"))\n+\t\t\tvar_opt_enum[n_opt_enum++] = otype \"x_\" name;\n+\n \t\telse\n \t\t\tvar_opt_other[n_opt_other++] = otype \"x_\" name;\n \t}\n@@ -192,6 +236,10 @@ for (i = 0; i < n_opt_int; i++) {\n \tprint \"  \" var_opt_int[i] \";\";\n }\n \n+for (i = 0; i < n_opt_enum; i++) {\n+\tprint \"  \" var_opt_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_opt_short; i++) {\n \tprint \"  \" var_opt_short[i] \";\";\n }\n@@ -211,6 +259,7 @@ print \"{\";\n n_target_char = 0;\n n_target_short = 0;\n n_target_int = 0;\n+n_target_enum = 0;\n n_target_other = 0;\n \n for (i = 0; i < n_target_save; i++) {\n@@ -223,6 +272,9 @@ for (i = 0; i < n_target_save; i++) {\n \telse if (target_save_decl[i] ~ \"^((un)?signed +)?char +[_ \" alnum \"]+$\")\n \t\tvar_target_char[n_target_char++] = target_save_decl[i];\n \n+\telse if (target_save_decl[i] ~ (\"^enum +[_\" alnum \"]+ +[_\" alnum \"]+$\")) {\n+\t\tvar_target_enum[n_target_enum++] = target_save_decl[i];\n+\t}\n \telse\n \t\tvar_target_other[n_target_other++] = target_save_decl[i];\n }\n@@ -248,6 +300,9 @@ if (have_save) {\n \t\t\telse if (otype ~ \"^((un)?signed +)?char *$\")\n \t\t\t\tvar_target_char[n_target_char++] = otype \"x_\" name;\n \n+\t\t\telse if (otype ~ (\"^enum +[_\" alnum \"]+ +[_\" alnum \"]+\"))\n+\t\t\t\tvar_target_enum[n_target_enum++] = otype \"x_\" name;\n+\n \t\t\telse\n \t\t\t\tvar_target_other[n_target_other++] = otype \"x_\" name;\n \t\t}\n@@ -260,6 +315,10 @@ for (i = 0; i < n_target_other; i++) {\n \tprint \"  \" var_target_other[i] \";\";\n }\n \n+for (i = 0; i < n_target_enum; i++) {\n+\tprint \"  \" var_target_enum[i] \";\";\n+}\n+\n for (i = 0; i < n_target_int; i++) {\n \tprint \"  \" var_target_int[i] \";\";\n }"}, {"sha": "d6c4d2bfb71aa1f01c7031fa6490ddcf37eaade8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -1,3 +1,10 @@\n+2010-11-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc-target-1.c: New file to test target\n+\tattributes on PowerPC.\n+\t* gcc.target/powerpc/ppc-target-2.c: Ditto.\n+\t* gcc.target/powerpc/ppc-target-3.c: Ditto.\n+\n 2010-11-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/attributes/proto-attribute-1.m: Updated."}, {"sha": "c98666c47a0b8d83319927c22462d4b8e7e1d07d", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-target-1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-1.c?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -ffast-math -mcpu=power5 -mabi=altivec\" } */\n+/* { dg-final { scan-assembler-times \"fabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fnabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fsel\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcpsgn\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xscpsgndp\" 1 } } */\n+\n+double normal1 (double, double);\n+double power5  (double, double) __attribute__((__target__(\"cpu=power5\")));\n+double power6  (double, double) __attribute__((__target__(\"cpu=power6\")));\n+double power6x (double, double) __attribute__((__target__(\"cpu=power6x\")));\n+double power7  (double, double) __attribute__((__target__(\"cpu=power7\")));\n+double power7n (double, double) __attribute__((__target__(\"cpu=power7,no-vsx\")));\n+double normal2 (double, double);\n+\n+/* fabs/fnabs/fsel */\n+double normal1 (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fabs/fnabs/fsel */\n+double power5  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power6  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power6x (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* xscpsgndp */\n+double power7  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power7n (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fabs/fnabs/fsel */\n+double normal2 (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}"}, {"sha": "8ef95b7a15b66a81042bcfa23503b751684d0cc4", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-target-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-2.c?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -ffast-math -mcpu=power5 -mabi=altivec\" } */\n+/* { dg-final { scan-assembler-times \"fabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fnabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fsel\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcpsgn\" 3 } } */\n+/* { dg-final { scan-assembler-times \"xscpsgndp\" 1 } } */\n+\n+/* fabs/fnabs/fsel */\n+double normal1 (double a, double b) { return __builtin_copysign (a, b); }\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"cpu=power5\")\n+/* fabs/fnabs/fsel */\n+double power5 (double a, double b) { return __builtin_copysign (a, b); }\n+#pragma GCC pop_options\n+\n+#pragma GCC target (\"cpu=power6\")\n+/* fcpsgn */\n+double power6 (double a, double b) { return __builtin_copysign (a, b); }\n+#pragma GCC reset_options\n+\n+#pragma GCC target (\"cpu=power6x\")\n+/* fcpsgn */\n+double power6x (double a, double b) { return __builtin_copysign (a, b); }\n+#pragma GCC reset_options\n+\n+#pragma GCC target (\"cpu=power7\")\n+/* xscpsgndp */\n+double power7 (double a, double b) { return __builtin_copysign (a, b); }\n+#pragma GCC reset_options\n+\n+#pragma GCC target (\"cpu=power7,no-vsx\")\n+/* fcpsgn */\n+double power7n (double a, double b) { return __builtin_copysign (a, b); }\n+#pragma GCC reset_options\n+\n+/* fabs/fnabs/fsel */\n+double normal2 (double a, double b) { return __builtin_copysign (a, b); }"}, {"sha": "286f31f63cb1c0188aa56fb0f73bafce30590ec6", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-target-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd438373cdd2a5b12d2c17b77922ee8fb8d43847/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-target-3.c?ref=fd438373cdd2a5b12d2c17b77922ee8fb8d43847", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -ffast-math -mcpu=power5 -mabi=no-altivec\" } */\n+/* { dg-final { scan-assembler-times \"fabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fnabs\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fsel\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcpsgn\" 4 } } */\n+/* { dg-final { scan-assembler-not \"xscpsgndp\" } } */\n+\n+/* Like ppc-target-1.c, but do not enable the altivec abi on 32-bit, so the\n+   power7 code should generate fcpsgn and not xscpsgndp.  */\n+\n+double normal1 (double, double);\n+double power5  (double, double) __attribute__((__target__(\"cpu=power5\")));\n+double power6  (double, double) __attribute__((__target__(\"cpu=power6\")));\n+double power6x (double, double) __attribute__((__target__(\"cpu=power6x\")));\n+double power7  (double, double) __attribute__((__target__(\"cpu=power7\")));\n+double power7n (double, double) __attribute__((__target__(\"cpu=power7,no-vsx\")));\n+double normal2 (double, double);\n+\n+/* fabs/fnabs/fsel */\n+double normal1 (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fabs/fnabs/fsel */\n+double power5  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power6  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power6x (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* xscpsgndp */\n+double power7  (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fcpsgn */\n+double power7n (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* fabs/fnabs/fsel */\n+double normal2 (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}"}]}