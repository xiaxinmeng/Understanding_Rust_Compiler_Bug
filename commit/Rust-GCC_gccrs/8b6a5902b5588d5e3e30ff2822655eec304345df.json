{"sha": "8b6a5902b5588d5e3e30ff2822655eec304345df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2YTU5MDJiNTU4OGQ1ZTNlMzBmZjI4MjI2NTVlZWMzMDQzNDVkZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-01-12T23:18:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-01-12T23:18:05Z"}, "message": "c-typeck.c (store_init_value): Don't require constant initializer elements with -pedantic -std=c99.\n\n\t* c-typeck.c (store_init_value): Don't require constant initializer\n\telements with -pedantic -std=c99.\n\t(digest_init): Change error about non-constant initializer elements\n\tinto pedwarn.\n\t(constructor_range_end): Remove.\n\t(constructor_incremental, designator_depth,\n\tdesignator_errorneous): New variables.\n\t(struct constructor_stack): Remove range_end, add incremental.\n\t(struct constructor_range_stack, constructor_range_stack): New.\n\t(struct initializer_stack): Add constructor_range_stack.\n\t(finish_init): Set it.\n\t(start_init): Likewise.  require_constant_elements for non-static\n\ttrees only if not flag_isoc99.\n\t(really_start_incremental_init): Remove constructor_range_end, add\n\tconstructor_incremental.\n\t(pop_init_level): Likewise.\n\t(push_init_level): Likewise.  If implicit and the subobject had some\n\tvalue set already, preinitialize the level with it.\n\tWarn about missing braces only if not pushing due to designators.\n\t(set_designator, push_range_stack): New functions.\n\t(set_init_label): Use them.\n\t(set_init_index): Likewise.  Remove constructor_range_end.\n\tError if designator index is outside of array bounds.\n\t(add_pending_init): Compare values of purpose index trees, not the\n\ttrees themselves.  Allow overwriting of already initialized element.\n\tIssue a warning if it had side-effects.\n\t(set_nonincremental_init, set_nonincremental_init_from_string): New\n\tfunctions.\n\t(pending_init_member): Rename to...\n\t(find_init_member): ...this function.  Call set_nonincremental_init\n\tif necessary.  Compare values of purpose index trees, not the trees\n\tthemselves.  Return the actual value, not just non-zero if something\n\tis found.\n\t(output_init_element): Remove checks for duplicates.\n\tIf field has zero size, only check the initializer for correctness.\n\tCall set_nonincremental_init if necessary.  Push RECORD/ARRAY into AVL\n\tif constructor_incremental is zero.  Change error about initializers\n\tnot computable at load time into pedwarn.\n\t(output_pending_init_elements): Compare bit positions, not\n\tFIELD_DECLs to take into account zero-sized fields.\n\t(process_init_element): Use constructor_range_stack to fill all\n\tranges in the designator lists from current level up.\n\t* extend.texi: Update documentation for labeled elements.\n\n\t* gcc.c-torture/execute/20000801-3.x: Remove.\n\t* gcc.dg/c90-init-1.c: New test.\n\t* gcc.dg/c99-init-1.c: New test.\n\t* gcc.dg/c99-init-2.c: New test.\n\t* gcc.dg/gnu99-init-1.c: New test.\n\nFrom-SVN: r38968", "tree": {"sha": "61018fce6476697759fec1b7443adbb9e7cc463d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61018fce6476697759fec1b7443adbb9e7cc463d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b6a5902b5588d5e3e30ff2822655eec304345df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6a5902b5588d5e3e30ff2822655eec304345df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b6a5902b5588d5e3e30ff2822655eec304345df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6a5902b5588d5e3e30ff2822655eec304345df/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb"}], "stats": {"total": 1033, "additions": 843, "deletions": 190}, "files": [{"sha": "6e89eab2e07014a1843a47b4edca0b5474801ccb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -1,3 +1,49 @@\n+2001-01-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.c (store_init_value): Don't require constant initializer\n+\telements with -pedantic -std=c99.\n+\t(digest_init): Change error about non-constant initializer elements\n+\tinto pedwarn.\n+\t(constructor_range_end): Remove.\n+\t(constructor_incremental, designator_depth,\n+\tdesignator_errorneous): New variables.\n+\t(struct constructor_stack): Remove range_end, add incremental.\n+\t(struct constructor_range_stack, constructor_range_stack): New.\n+\t(struct initializer_stack): Add constructor_range_stack.\n+\t(finish_init): Set it.\n+\t(start_init): Likewise.  require_constant_elements for non-static\n+\ttrees only if not flag_isoc99.\n+\t(really_start_incremental_init): Remove constructor_range_end, add\n+\tconstructor_incremental.\n+\t(pop_init_level): Likewise.\n+\t(push_init_level): Likewise.  If implicit and the subobject had some\n+\tvalue set already, preinitialize the level with it.\n+\tWarn about missing braces only if not pushing due to designators.\n+\t(set_designator, push_range_stack): New functions.\n+\t(set_init_label): Use them.\n+\t(set_init_index): Likewise.  Remove constructor_range_end.\n+\tError if designator index is outside of array bounds.\n+\t(add_pending_init): Compare values of purpose index trees, not the\n+\ttrees themselves.  Allow overwriting of already initialized element.\n+\tIssue a warning if it had side-effects.\n+\t(set_nonincremental_init, set_nonincremental_init_from_string): New\n+\tfunctions.\n+\t(pending_init_member): Rename to...\n+\t(find_init_member): ...this function.  Call set_nonincremental_init\n+\tif necessary.  Compare values of purpose index trees, not the trees\n+\tthemselves.  Return the actual value, not just non-zero if something\n+\tis found.\n+\t(output_init_element): Remove checks for duplicates.\n+\tIf field has zero size, only check the initializer for correctness.\n+\tCall set_nonincremental_init if necessary.  Push RECORD/ARRAY into AVL\n+\tif constructor_incremental is zero.  Change error about initializers\n+\tnot computable at load time into pedwarn.\n+\t(output_pending_init_elements): Compare bit positions, not\n+\tFIELD_DECLs to take into account zero-sized fields.\n+\t(process_init_element): Use constructor_range_stack to fill all\n+\tranges in the designator lists from current level up.\n+\t* extend.texi: Update documentation for labeled elements.\n+\n 2001-01-12  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* calls.c (emit_library_call_value_1): Add USEs and CLOBBERs"}, {"sha": "9db269e9600d9705cb01f23f54dee255daa0135c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 584, "deletions": 188, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -76,8 +76,12 @@ static void warning_init\t\tPARAMS ((const char *));\n static tree digest_init\t\t\tPARAMS ((tree, tree, int, int));\n static void output_init_element\t\tPARAMS ((tree, tree, tree, int));\n static void output_pending_init_elements PARAMS ((int));\n+static int set_designator\t\tPARAMS ((int));\n+static void push_range_stack\t\tPARAMS ((tree));\n static void add_pending_init\t\tPARAMS ((tree, tree));\n-static int pending_init_member\t\tPARAMS ((tree));\n+static void set_nonincremental_init\tPARAMS ((void));\n+static void set_nonincremental_init_from_string\tPARAMS ((tree));\n+static tree find_init_member\t\tPARAMS ((tree));\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n@@ -4410,7 +4414,7 @@ store_init_value (decl, init)\n   /* Digest the specified initializer into an expression.  */\n \n   value = digest_init (type, init, TREE_STATIC (decl),\n-\t\t       TREE_STATIC (decl) || pedantic);\n+\t\t       TREE_STATIC (decl) || (pedantic && !flag_isoc99));\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -4769,10 +4773,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n-\t{\n-\t  error_init (\"initializer element is not computable at load time\");\n-\t  inside_init = error_mark_node;\n-\t}\n+\tpedwarn (\"initializer element is not computable at load time\");\n \n       return inside_init;\n     }\n@@ -4868,11 +4869,6 @@ static tree constructor_fields;\n    at which to store the next element we get.  */\n static tree constructor_index;\n \n-/* For an ARRAY_TYPE, this is the end index of the range\n-   to initialize with the next element, or NULL in the ordinary case\n-   where the element is used just once.  */\n-static tree constructor_range_end;\n-\n /* For an ARRAY_TYPE, this is the maximum index.  */\n static tree constructor_max_index;\n \n@@ -4892,6 +4888,10 @@ static tree constructor_bit_index;\n    most recent first).  */\n static tree constructor_elements;\n \n+/* 1 if constructor should be incrementally stored into a constructor chain,\n+   0 if all the elements should be kept in AVL tree.  */\n+static int constructor_incremental;\n+\n /* 1 if so far this constructor's elements are all compile-time constants.  */\n static int constructor_constant;\n \n@@ -4943,6 +4943,12 @@ static const char *constructor_asmspec;\n /* Nonzero if this is an initializer for a top-level decl.  */\n static int constructor_top_level;\n \n+/* Nesting depth of designator list.  */\n+static int designator_depth;\n+\n+/* Nonzero if there were diagnosed errors in this designator list.  */\n+static int designator_errorneous;\n+\n \f\n /* This stack has a level for each implicit or explicit level of\n    structuring in the initializer, including the outermost one.  It\n@@ -4954,7 +4960,6 @@ struct constructor_stack\n   tree type;\n   tree fields;\n   tree index;\n-  tree range_end;\n   tree max_index;\n   tree unfilled_index;\n   tree unfilled_fields;\n@@ -4971,10 +4976,26 @@ struct constructor_stack\n   char implicit;\n   char erroneous;\n   char outer;\n+  char incremental;\n };\n \n struct constructor_stack *constructor_stack;\n \n+/* This stack represents designators from some range designator up to\n+   the last designator in the list.  */\n+\n+struct constructor_range_stack\n+{\n+  struct constructor_range_stack *next, *prev;\n+  struct constructor_stack *stack;\n+  tree range_start;\n+  tree index;\n+  tree range_end;\n+  tree fields;\n+};\n+\n+struct constructor_range_stack *constructor_range_stack;\n+\n /* This stack records separate initializers that are nested.\n    Nested initializers can't happen in ANSI C, but GNU C allows them\n    in cases like { ... (struct foo) { ... } ... }.  */\n@@ -4985,6 +5006,7 @@ struct initializer_stack\n   tree decl;\n   const char *asmspec;\n   struct constructor_stack *constructor_stack;\n+  struct constructor_range_stack *constructor_range_stack;\n   tree elements;\n   struct spelling *spelling;\n   struct spelling *spelling_base;\n@@ -5018,6 +5040,7 @@ start_init (decl, asmspec_tree, top_level)\n   p->require_constant_value = require_constant_value;\n   p->require_constant_elements = require_constant_elements;\n   p->constructor_stack = constructor_stack;\n+  p->constructor_range_stack = constructor_range_stack;\n   p->elements = constructor_elements;\n   p->spelling = spelling;\n   p->spelling_base = spelling_base;\n@@ -5036,7 +5059,7 @@ start_init (decl, asmspec_tree, top_level)\n     {\n       require_constant_value = TREE_STATIC (decl);\n       require_constant_elements\n-\t= ((TREE_STATIC (decl) || pedantic)\n+\t= ((TREE_STATIC (decl) || (pedantic && !flag_isoc99))\n \t   /* For a scalar, you can always use any value to initialize,\n \t      even within braces.  */\n \t   && (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n@@ -5053,6 +5076,7 @@ start_init (decl, asmspec_tree, top_level)\n     }\n \n   constructor_stack = 0;\n+  constructor_range_stack = 0;\n \n   missing_braces_mentioned = 0;\n \n@@ -5083,12 +5107,16 @@ finish_init ()\n       free (q);\n     }\n \n+  if (constructor_range_stack)\n+    abort ();\n+\n   /* Pop back to the data of the outer initializer (if any).  */\n   constructor_decl = p->decl;\n   constructor_asmspec = p->asmspec;\n   require_constant_value = p->require_constant_value;\n   require_constant_elements = p->require_constant_elements;\n   constructor_stack = p->constructor_stack;\n+  constructor_range_stack = p->constructor_range_stack;\n   constructor_elements = p->elements;\n   spelling = p->spelling;\n   spelling_base = p->spelling_base;\n@@ -5119,7 +5147,6 @@ really_start_incremental_init (type)\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;\n-  p->range_end = constructor_range_end;\n   p->max_index = constructor_max_index;\n   p->unfilled_index = constructor_unfilled_index;\n   p->unfilled_fields = constructor_unfilled_fields;\n@@ -5133,6 +5160,7 @@ really_start_incremental_init (type)\n   p->replacement_value = 0;\n   p->implicit = 0;\n   p->outer = 0;\n+  p->incremental = constructor_incremental;\n   p->next = 0;\n   constructor_stack = p;\n \n@@ -5142,6 +5170,9 @@ really_start_incremental_init (type)\n   constructor_elements = 0;\n   constructor_pending_elts = 0;\n   constructor_type = type;\n+  constructor_incremental = 1;\n+  designator_depth = 0;\n+  designator_errorneous = 0;\n \n   if (TREE_CODE (constructor_type) == RECORD_TYPE\n       || TREE_CODE (constructor_type) == UNION_TYPE)\n@@ -5157,7 +5188,6 @@ really_start_incremental_init (type)\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n-      constructor_range_end = 0;\n       if (TYPE_DOMAIN (constructor_type))\n \t{\n \t  constructor_max_index\n@@ -5187,13 +5217,14 @@ really_start_incremental_init (type)\n /* Push down into a subobject, for initialization.\n    If this is for an explicit set of braces, IMPLICIT is 0.\n    If it is because the next element belongs at a lower level,\n-   IMPLICIT is 1.  */\n+   IMPLICIT is 1 (or 2 if the push is because of designator list).  */\n \n void\n push_init_level (implicit)\n      int implicit;\n {\n   struct constructor_stack *p;\n+  tree value = NULL_TREE;\n \n   /* If we've exhausted any levels that didn't have braces,\n      pop them now.  */\n@@ -5210,11 +5241,22 @@ push_init_level (implicit)\n \tbreak;\n     }\n \n+  /* Unless this is an explicit brace, we need to preserve previous\n+     content if any.  */\n+  if (implicit)\n+    {\n+      if ((TREE_CODE (constructor_type) == RECORD_TYPE\n+\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t  && constructor_fields)\n+\tvalue = find_init_member (constructor_fields);\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\tvalue = find_init_member (constructor_index);\n+    }\n+\n   p = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;\n-  p->range_end = constructor_range_end;\n   p->max_index = constructor_max_index;\n   p->unfilled_index = constructor_unfilled_index;\n   p->unfilled_fields = constructor_unfilled_fields;\n@@ -5228,14 +5270,21 @@ push_init_level (implicit)\n   p->replacement_value = 0;\n   p->implicit = implicit;\n   p->outer = 0;\n+  p->incremental = constructor_incremental;\n   p->next = constructor_stack;\n   constructor_stack = p;\n \n   constructor_constant = 1;\n   constructor_simple = 1;\n   constructor_depth = SPELLING_DEPTH ();\n   constructor_elements = 0;\n+  constructor_incremental = 1;\n   constructor_pending_elts = 0;\n+  if (!implicit)\n+    {\n+      designator_depth = 0;\n+      designator_errorneous = 0;\n+    }\n \n   /* Don't die if an entire brace-pair level is superfluous\n      in the containing level.  */\n@@ -5269,7 +5318,18 @@ push_init_level (implicit)\n       return;\n     }\n \n-  if (implicit && warn_missing_braces && !missing_braces_mentioned)\n+  if (value && TREE_CODE (value) == CONSTRUCTOR)\n+    {\n+      constructor_constant = TREE_CONSTANT (value);\n+      constructor_simple = TREE_STATIC (value);\n+      constructor_elements = TREE_OPERAND (value, 1);\n+      if (constructor_elements\n+\t  && (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t      || TREE_CODE (constructor_type) == ARRAY_TYPE))\n+\tset_nonincremental_init ();\n+    }\n+\n+  if (implicit == 1 && warn_missing_braces && !missing_braces_mentioned)\n     {\n       missing_braces_mentioned = 1;\n       warning_init (\"missing braces around initializer\");\n@@ -5289,7 +5349,6 @@ push_init_level (implicit)\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n-      constructor_range_end = 0;\n       if (TYPE_DOMAIN (constructor_type))\n \t{\n \t  constructor_max_index\n@@ -5307,6 +5366,13 @@ push_init_level (implicit)\n \tconstructor_index = bitsize_zero_node;\n \n       constructor_unfilled_index = constructor_index;\n+      if (value && TREE_CODE (value) == STRING_CST)\n+\t{\n+\t  /* We need to split the char/wchar array into individual\n+\t     characters, so that we don't have to special case it\n+\t     everywhere.  */\n+\t  set_nonincremental_init_from_string (value);\n+\t}\n     }\n   else\n     {\n@@ -5363,7 +5429,7 @@ pop_init_level (implicit)\n \t  else if (pedantic)\n \t    pedwarn_init (\"initialization of a flexible array member\");\n \n-          /* We have already issued an error message for the existance\n+\t  /* We have already issued an error message for the existance\n \t     of a flexible array member not at the end of the structure.\n \t     Discard the initializer so that we do not abort later.  */\n \t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n@@ -5373,7 +5439,7 @@ pop_init_level (implicit)\n \t{\n \t  warning_init (\"deprecated initialization of zero-length array\");\n \n-          /* We must be initializing the last member of a top-level struct.  */\n+\t  /* We must be initializing the last member of a top-level struct.  */\n \t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n \t    {\n \t      error_init (\"initialization of zero-length array before end of structure\");\n@@ -5391,21 +5457,22 @@ pop_init_level (implicit)\n       && TREE_CODE (constructor_type) == RECORD_TYPE\n       && constructor_unfilled_fields)\n     {\n-      /* Do not warn for flexible array members or zero-length arrays.  */\n-      while (constructor_unfilled_fields\n-\t     && (! DECL_SIZE (constructor_unfilled_fields)\n-\t\t || integer_zerop (DECL_SIZE (constructor_unfilled_fields))))\n-\tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n+\t/* Do not warn for flexible array members or zero-length arrays.  */\n+\twhile (constructor_unfilled_fields\n+\t       && (! DECL_SIZE (constructor_unfilled_fields)\n+\t\t   || integer_zerop (DECL_SIZE (constructor_unfilled_fields))))\n+\t  constructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n \n-      if (constructor_unfilled_fields)\n-\t{\n-\t  push_member_name (constructor_unfilled_fields);\n-\t  warning_init (\"missing initializer\");\n-\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n-\t}\n+\tif (constructor_unfilled_fields)\n+\t  {\n+\t    push_member_name (constructor_unfilled_fields);\n+\t    warning_init (\"missing initializer\");\n+\t    RESTORE_SPELLING_DEPTH (constructor_depth);\n+\t  }\n     }\n \n   /* Now output all pending elements.  */\n+  constructor_incremental = 1;\n   output_pending_init_elements (1);\n \n   /* Pad out the end of the structure.  */\n@@ -5423,7 +5490,8 @@ pop_init_level (implicit)\n \t the element, after verifying there is just one.  */\n       if (constructor_elements == 0)\n \t{\n-\t  error_init (\"empty scalar initializer\");\n+\t  if (!constructor_erroneous)\n+\t    error_init (\"empty scalar initializer\");\n \t  constructor = error_mark_node;\n \t}\n       else if (TREE_CHAIN (constructor_elements) != 0)\n@@ -5452,7 +5520,6 @@ pop_init_level (implicit)\n   constructor_type = p->type;\n   constructor_fields = p->fields;\n   constructor_index = p->index;\n-  constructor_range_end = p->range_end;\n   constructor_max_index = p->max_index;\n   constructor_unfilled_index = p->unfilled_index;\n   constructor_unfilled_fields = p->unfilled_fields;\n@@ -5461,6 +5528,7 @@ pop_init_level (implicit)\n   constructor_constant = p->constant;\n   constructor_simple = p->simple;\n   constructor_erroneous = p->erroneous;\n+  constructor_incremental = p->incremental;\n   constructor_pending_elts = p->pending_elts;\n   constructor_depth = p->depth;\n   RESTORE_SPELLING_DEPTH (constructor_depth);\n@@ -5477,6 +5545,97 @@ pop_init_level (implicit)\n   return constructor;\n }\n \n+/* Common handling for both array range and field name designators.\n+   ARRAY argument is non-zero for array ranges.  Returns zero for success.  */\n+\n+static int\n+set_designator (array)\n+     int array;\n+{\n+  tree subtype;\n+  enum tree_code subcode;\n+\n+  /* Don't die if an entire brace-pair level is superfluous\n+     in the containing level.  */\n+  if (constructor_type == 0)\n+    return 1;\n+\n+  /* If there were errors in this designator list already, bail out silently.  */\n+  if (designator_errorneous)\n+    return 1;\n+\n+  if (!designator_depth)\n+    {\n+      if (constructor_range_stack)\n+\tabort ();\n+\n+      /* Designator list starts at the level of closest explicit\n+\t braces.  */\n+      while (constructor_stack->implicit)\n+\tprocess_init_element (pop_init_level (1));\n+      return 0;\n+    }\n+\n+  if (constructor_no_implicit)\n+    {\n+      error_init (\"initialization designators may not nest\");\n+      return 1;\n+    }\n+\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE\n+      || TREE_CODE (constructor_type) == UNION_TYPE)\n+    {\n+      subtype = TREE_TYPE (constructor_fields);\n+      if (subtype != error_mark_node)\n+\tsubtype = TYPE_MAIN_VARIANT (subtype);\n+    }\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      subtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n+    }\n+  else\n+    abort ();\n+\n+  subcode = TREE_CODE (subtype);\n+  if (array && subcode != ARRAY_TYPE)\n+    {\n+      error_init (\"array index in non-array initializer\");\n+      return 1;\n+    }\n+  else if (!array && subcode != RECORD_TYPE && subcode != UNION_TYPE)\n+    {\n+      error_init (\"field name not in record or union initializer\");\n+      return 1;\n+    }\n+\n+  push_init_level (2);\n+  return 0;\n+}\n+\n+/* If there are range designators in designator list, push a new designator\n+   to constructor_range_stack.  RANGE_END is end of such stack range or\n+   NULL_TREE if there is no range designator at this level.  */\n+\n+static void\n+push_range_stack (range_end)\n+     tree range_end;\n+{\n+  struct constructor_range_stack *p;\n+\n+  p = (struct constructor_range_stack *)\n+      ggc_alloc (sizeof (struct constructor_range_stack));\n+  p->prev = constructor_range_stack;\n+  p->next = 0;\n+  p->fields = constructor_fields;\n+  p->range_start = constructor_index;\n+  p->index = constructor_index;\n+  p->stack = constructor_stack;\n+  p->range_end = range_end;\n+  if (constructor_range_stack)\n+    constructor_range_stack->next = p;\n+  constructor_range_stack = p;\n+}\n+\n /* Within an array initializer, specify the next index to be initialized.\n    FIRST is that index.  If LAST is nonzero, then initialize a range\n    of indices, running from FIRST through LAST.  */\n@@ -5485,6 +5644,11 @@ void\n set_init_index (first, last)\n      tree first, last;\n {\n+  if (set_designator (1))\n+    return;\n+\n+  designator_errorneous = 1;\n+\n   while ((TREE_CODE (first) == NOP_EXPR\n \t  || TREE_CODE (first) == CONVERT_EXPR\n \t  || TREE_CODE (first) == NON_LVALUE_EXPR)\n@@ -5504,18 +5668,34 @@ set_init_index (first, last)\n     error_init (\"nonconstant array index in initializer\");\n   else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n     error_init (\"nonconstant array index in initializer\");\n-  else if (! constructor_unfilled_index)\n+  else if (TREE_CODE (constructor_type) != ARRAY_TYPE)\n     error_init (\"array index in non-array initializer\");\n-  else if (tree_int_cst_lt (first, constructor_unfilled_index))\n-    error_init (\"duplicate array index in initializer\");\n+  else if (constructor_max_index\n+\t   && tree_int_cst_lt (constructor_max_index, first))\n+    error_init (\"array index in initializer exceeds array bounds\");\n   else\n     {\n       constructor_index = convert (bitsizetype, first);\n \n       if (last != 0 && tree_int_cst_lt (last, first))\n-\terror_init (\"empty index range in initializer\");\n-      else\n-\tconstructor_range_end = last ? convert (bitsizetype, last) : 0;\n+\t{\n+\t  error_init (\"empty index range in initializer\");\n+\t  last = 0;\n+\t}\n+      else if (last)\n+\t{\n+\t  last = convert (bitsizetype, last);\n+\t  if (constructor_max_index != 0\n+\t      && tree_int_cst_lt (constructor_max_index, last))\n+\t    {\n+\t      error_init (\"array index range in initializer exceeds array bounds\");\n+\t      last = 0;\n+\t    }\n+\t}\n+      designator_depth++;\n+      designator_errorneous = 0;\n+      if (constructor_range_stack || last)\n+\tpush_range_stack (last);\n     }\n }\n \n@@ -5526,30 +5706,37 @@ set_init_label (fieldname)\n      tree fieldname;\n {\n   tree tail;\n-  int passed = 0;\n \n-  /* Don't die if an entire brace-pair level is superfluous\n-     in the containing level.  */\n-  if (constructor_type == 0)\n+  if (set_designator (0))\n     return;\n \n+  designator_errorneous = 1;\n+\n+  if (TREE_CODE (constructor_type) != RECORD_TYPE\n+      && TREE_CODE (constructor_type) != UNION_TYPE)\n+    {\n+      error_init (\"field name not in record or union initializer\");\n+      return;\n+    }\n+    \n   for (tail = TYPE_FIELDS (constructor_type); tail;\n        tail = TREE_CHAIN (tail))\n     {\n-      if (tail == constructor_unfilled_fields)\n-\tpassed = 1;\n       if (DECL_NAME (tail) == fieldname)\n \tbreak;\n     }\n \n   if (tail == 0)\n     error (\"unknown field `%s' specified in initializer\",\n \t   IDENTIFIER_POINTER (fieldname));\n-  else if (!passed)\n-    error (\"field `%s' already initialized\",\n-\t   IDENTIFIER_POINTER (fieldname));\n   else\n-    constructor_fields = tail;\n+    {\n+      constructor_fields = tail;\n+      designator_depth++;\n+      designator_errorneous = 0;\n+      if (constructor_range_stack)\n+\tpush_range_stack (NULL_TREE);\n+    }\n }\n \f\n /* Add a new initializer to the tree of pending initializers.  PURPOSE\n@@ -5572,24 +5759,36 @@ add_pending_init (purpose, value)\n \t  p = *q;\n \t  if (tree_int_cst_lt (purpose, p->purpose))\n \t    q = &p->left;\n-\t  else if (p->purpose != purpose)\n+\t  else if (tree_int_cst_lt (p->purpose, purpose))\n \t    q = &p->right;\n \t  else\n-\t    abort ();\n+\t    {\n+\t      if (TREE_SIDE_EFFECTS (p->value))\n+\t\twarning_init (\"initialized field with side-effects overwritten\");\n+\t      p->value = value;\n+\t      return;\n+\t    }\n \t}\n     }\n   else\n     {\n+      tree bitpos;\n+\n+      bitpos = bit_position (purpose);\n       while (*q != NULL)\n \t{\n \t  p = *q;\n-\t  if (tree_int_cst_lt (bit_position (purpose),\n-\t\t\t       bit_position (p->purpose)))\n+\t  if (tree_int_cst_lt (bitpos, bit_position (p->purpose)))\n \t    q = &p->left;\n \t  else if (p->purpose != purpose)\n \t    q = &p->right;\n \t  else\n-\t    abort ();\n+\t    {\n+\t      if (TREE_SIDE_EFFECTS (p->value))\n+\t\twarning_init (\"initialized field with side-effects overwritten\");\n+\t      p->value = value;\n+\t      return;\n+\t    }\n \t}\n     }\n \n@@ -5758,41 +5957,178 @@ add_pending_init (purpose, value)\n     }\n }\n \n-/* Return nonzero if FIELD is equal to the index of a pending initializer.  */\n+/* Build AVL tree from a sorted chain.  */\n \n-static int\n-pending_init_member (field)\n+static void\n+set_nonincremental_init ()\n+{\n+  tree chain;\n+\n+  if (TREE_CODE (constructor_type) != RECORD_TYPE\n+      && TREE_CODE (constructor_type) != ARRAY_TYPE)\n+    return;\n+\n+  for (chain = constructor_elements; chain; chain = TREE_CHAIN (chain))\n+    add_pending_init (TREE_PURPOSE (chain), TREE_VALUE (chain));\n+  constructor_elements = 0;\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE)\n+    {\n+      constructor_unfilled_fields = TYPE_FIELDS (constructor_type);\n+      /* Skip any nameless bit fields at the beginning.  */\n+      while (constructor_unfilled_fields != 0\n+\t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n+\t     && DECL_NAME (constructor_unfilled_fields) == 0)\n+\tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n+      \n+    }\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      if (TYPE_DOMAIN (constructor_type))\n+\tconstructor_unfilled_index\n+\t    = convert (bitsizetype,\n+\t\t       TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n+      else\n+\tconstructor_unfilled_index = bitsize_zero_node;\n+    }\n+  constructor_incremental = 0;\n+}\n+\n+/* Build AVL tree from a string constant.  */\n+\n+static void\n+set_nonincremental_init_from_string (str)\n+     tree str;\n+{\n+  tree value, purpose, type;\n+  HOST_WIDE_INT val[2];\n+  const char *p, *end;\n+  int byte, wchar_bytes, charwidth, bitpos;\n+\n+  if (TREE_CODE (constructor_type) != ARRAY_TYPE)\n+    abort ();\n+\n+  if (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (str)))\n+      == TYPE_PRECISION (char_type_node))\n+    wchar_bytes = 1;\n+  else if (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (str)))\n+\t   == TYPE_PRECISION (wchar_type_node))\n+    wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n+  else\n+    abort ();\n+\n+  charwidth = TYPE_PRECISION (char_type_node);\n+  type = TREE_TYPE (constructor_type);\n+  p = TREE_STRING_POINTER (str);\n+  end = p + TREE_STRING_LENGTH (str);\n+\n+  for (purpose = bitsize_zero_node;\n+       p < end && !tree_int_cst_lt (constructor_max_index, purpose);\n+       purpose = size_binop (PLUS_EXPR, purpose, bitsize_one_node))\n+    {\n+      if (wchar_bytes == 1)\n+\t{\n+\t  val[1] = (unsigned char) *p++;\n+\t  val[0] = 0;\n+\t}\n+      else\n+\t{\n+\t  val[0] = 0;\n+\t  val[1] = 0;\n+\t  for (byte = 0; byte < wchar_bytes; byte++)\n+\t    {\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\tbitpos = (wchar_bytes - byte - 1) * charwidth;\n+\t      else\n+\t\tbitpos = byte * charwidth;\n+\t      val[bitpos < HOST_BITS_PER_WIDE_INT]\n+\t\t|= ((unsigned HOST_WIDE_INT) ((unsigned char) *p++))\n+\t\t   << (bitpos % HOST_BITS_PER_WIDE_INT);\n+\t    }\n+\t}\n+\n+      if (!TREE_UNSIGNED (type))\n+\t{\n+\t  bitpos = ((wchar_bytes - 1) * charwidth) + HOST_BITS_PER_CHAR;\n+\t  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      if (val[1] & (((HOST_WIDE_INT) 1) << (bitpos - 1)))\n+\t\t{\n+\t\t  val[1] |= ((HOST_WIDE_INT) -1) << bitpos;\n+\t\t  val[0] = -1;\n+\t\t}\n+\t    }\n+\t  else if (bitpos == HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      if (val[1] < 0)\n+\t        val[0] = -1;\n+\t    }\n+\t  else if (val[0] & (((HOST_WIDE_INT) 1)\n+\t\t\t     << (bitpos - 1 - HOST_BITS_PER_WIDE_INT)))\n+\t    val[0] |= ((HOST_WIDE_INT) -1)\n+\t\t      << (bitpos - HOST_BITS_PER_WIDE_INT);\n+\t}\n+\n+      value = build_int_2 (val[1], val[0]);\n+      TREE_TYPE (value) = type;\n+      add_pending_init (purpose, value);\n+    }\n+\n+  constructor_incremental = 0;\n+}\n+\n+/* Return value of FIELD in pending initializer or zero if the field was\n+   not initialized yet.  */\n+\n+static tree\n+find_init_member (field)\n      tree field;\n {\n   struct init_node *p;\n \n-  p = constructor_pending_elts;\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n+      if (constructor_incremental\n+\t  && tree_int_cst_lt (field, constructor_unfilled_index))\n+\tset_nonincremental_init ();\n+\n+      p = constructor_pending_elts;\n       while (p)\n \t{\n-\t  if (field == p->purpose)\n-\t    return 1;\n-\t  else if (tree_int_cst_lt (field, p->purpose))\n+\t  if (tree_int_cst_lt (field, p->purpose))\n \t    p = p->left;\n-\t  else\n+\t  else if (tree_int_cst_lt (p->purpose, field))\n \t    p = p->right;\n+\t  else\n+\t    return p->value;\n \t}\n     }\n-  else\n+  else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n+      tree bitpos = bit_position (field);\n+\n+      if (constructor_incremental\n+\t  && (!constructor_unfilled_fields\n+\t      || tree_int_cst_lt (bitpos,\n+\t\t\t\t  bit_position (constructor_unfilled_fields))))\n+\tset_nonincremental_init ();\n+\n+      p = constructor_pending_elts;\n       while (p)\n \t{\n \t  if (field == p->purpose)\n-\t    return 1;\n-\t  else if (tree_int_cst_lt (bit_position (field),\n-\t\t\t\t    bit_position (p->purpose)))\n+\t    return p->value;\n+\t  else if (tree_int_cst_lt (bitpos, bit_position (p->purpose)))\n \t    p = p->left;\n \t  else\n \t    p = p->right;\n \t}\n     }\n-\n+  else if (TREE_CODE (constructor_type) == UNION_TYPE)\n+    {\n+      if (constructor_elements\n+\t  && TREE_PURPOSE (constructor_elements) == field)\n+\treturn TREE_VALUE (constructor_elements);\n+    }\n   return 0;\n }\n \n@@ -5811,8 +6147,6 @@ output_init_element (value, type, field, pending)\n      tree value, type, field;\n      int pending;\n {\n-  int duplicate = 0;\n-\n   if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n       || (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n \t  && !(TREE_CODE (value) == STRING_CST\n@@ -5840,90 +6174,111 @@ output_init_element (value, type, field, pending)\n     }\n   else if (require_constant_elements\n \t   && initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n-    {\n-      error_init (\"initializer element is not computable at load time\");\n-      value = error_mark_node;\n-    }\n+    pedwarn (\"initializer element is not computable at load time\");\n+\n+  /* If this field is empty (and not at the end of structure),\n+     don't do anything other than checking the initializer.  */\n+  if (field\n+      && (TREE_TYPE (field) == error_mark_node\n+\t  || (COMPLETE_TYPE_P (TREE_TYPE (field))\n+\t      && integer_zerop (TYPE_SIZE (TREE_TYPE (field)))\n+\t      && (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t\t  || TREE_CHAIN (field)))))\n+    return;\n \n-  /* If this element duplicates one on constructor_pending_elts,\n-     print a message and ignore it.  Don't do this when we're\n-     processing elements taken off constructor_pending_elts,\n-     because we'd always get spurious errors.  */\n-  if (pending)\n+  if (value == error_mark_node)\n     {\n-      if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t  || TREE_CODE (constructor_type) == UNION_TYPE\n-\t  || TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  if (pending_init_member (field))\n-\t    {\n-\t      error_init (\"duplicate initializer\");\n-\t      duplicate = 1;\n-\t    }\n-\t}\n+      constructor_erroneous = 1;\n+      return;\n     }\n \n   /* If this element doesn't come next in sequence,\n      put it on constructor_pending_elts.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-      && ! tree_int_cst_equal (field, constructor_unfilled_index))\n+      && (!constructor_incremental\n+\t  || !tree_int_cst_equal (field, constructor_unfilled_index)))\n     {\n-      if (! duplicate)\n-\tadd_pending_init (field,\n-\t\t\t  digest_init (type, value, require_constant_value, \n-\t\t\t\t       require_constant_elements));\n+      if (constructor_incremental\n+\t  && tree_int_cst_lt (field, constructor_unfilled_index))\n+\tset_nonincremental_init ();\n+\n+      add_pending_init (field,\n+\t\t\tdigest_init (type, value, require_constant_value, \n+\t\t\t\t     require_constant_elements));\n+      return;\n     }\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t   && field != constructor_unfilled_fields)\n+\t   && (!constructor_incremental\n+\t       || field != constructor_unfilled_fields))\n     {\n       /* We do this for records but not for unions.  In a union,\n \t no matter which field is specified, it can be initialized\n \t right away since it starts at the beginning of the union.  */\n-      if (!duplicate)\n-\tadd_pending_init (field,\n-\t\t\t  digest_init (type, value, require_constant_value, \n-\t\t\t\t       require_constant_elements));\n+      if (constructor_incremental)\n+\t{\n+\t  if (!constructor_unfilled_fields)\n+\t    set_nonincremental_init ();\n+\t  else\n+\t    {\n+\t      tree bitpos, unfillpos;\n+\n+\t      bitpos = bit_position (field);\n+\t      unfillpos = bit_position (constructor_unfilled_fields);\n+\n+\t      if (tree_int_cst_lt (bitpos, unfillpos))\n+\t\tset_nonincremental_init ();\n+\t    }\n+\t}\n+\n+      add_pending_init (field,\n+\t\t\tdigest_init (type, value, require_constant_value, \n+\t\t\t\t     require_constant_elements));\n+      return;\n     }\n-  else\n+  else if (TREE_CODE (constructor_type) == UNION_TYPE\n+\t   && constructor_elements)\n     {\n-      /* Otherwise, output this element either to\n-\t constructor_elements or to the assembler file.  */\n+      if (TREE_SIDE_EFFECTS (TREE_VALUE (constructor_elements)))\n+\twarning_init (\"initialized field with side-effects overwritten\");\n \n-      if (!duplicate)\n-\t{\n-\t  if (field && TREE_CODE (field) == INTEGER_CST)\n-\t    field = copy_node (field);\n-\t  constructor_elements\n-\t    = tree_cons (field, digest_init (type, value,\n-\t\t\t\t\t     require_constant_value, \n-\t\t\t\t\t     require_constant_elements),\n-\t\t\t constructor_elements);\n-\t}\n+      /* We can have just one union field set.  */\n+      constructor_elements = 0;\n+    }\n \n-      /* Advance the variable that indicates sequential elements output.  */\n-      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\tconstructor_unfilled_index\n-\t  = size_binop (PLUS_EXPR, constructor_unfilled_index,\n-\t\t\tbitsize_one_node);\n-      else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n-\t{\n-\t  constructor_unfilled_fields\n-\t    = TREE_CHAIN (constructor_unfilled_fields);\n-\n-\t  /* Skip any nameless bit fields.  */\n-\t  while (constructor_unfilled_fields != 0\n-\t\t && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n-\t\t && DECL_NAME (constructor_unfilled_fields) == 0)\n-\t    constructor_unfilled_fields =\n-\t      TREE_CHAIN (constructor_unfilled_fields);\n-\t}\n-      else if (TREE_CODE (constructor_type) == UNION_TYPE)\n-\tconstructor_unfilled_fields = 0;\n+  /* Otherwise, output this element either to\n+     constructor_elements or to the assembler file.  */\n+\n+  if (field && TREE_CODE (field) == INTEGER_CST)\n+    field = copy_node (field);\n+  constructor_elements\n+    = tree_cons (field, digest_init (type, value,\n+\t\t\t\t     require_constant_value, \n+\t\t\t\t     require_constant_elements),\n+\t\t constructor_elements);\n+\n+  /* Advance the variable that indicates sequential elements output.  */\n+  if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    constructor_unfilled_index\n+      = size_binop (PLUS_EXPR, constructor_unfilled_index,\n+\t\t    bitsize_one_node);\n+  else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n+    {\n+      constructor_unfilled_fields\n+\t= TREE_CHAIN (constructor_unfilled_fields);\n \n-      /* Now output any pending elements which have become next.  */\n-      if (pending)\n-\toutput_pending_init_elements (0);\n+      /* Skip any nameless bit fields.  */\n+      while (constructor_unfilled_fields != 0\n+\t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n+\t     && DECL_NAME (constructor_unfilled_fields) == 0)\n+\tconstructor_unfilled_fields =\n+\t  TREE_CHAIN (constructor_unfilled_fields);\n     }\n+  else if (TREE_CODE (constructor_type) == UNION_TYPE)\n+    constructor_unfilled_fields = 0;\n+\n+  /* Now output any pending elements which have become next.  */\n+  if (pending)\n+    output_pending_init_elements (0);\n }\n \n /* Output any pending elements which have become next.\n@@ -5999,18 +6354,23 @@ output_pending_init_elements (all)\n       else if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t       || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n+\t  tree ctor_unfilled_bitpos, elt_bitpos;\n+\n \t  /* If the current record is complete we are done.  */\n \t  if (constructor_unfilled_fields == 0)\n \t    break;\n-\t  if (elt->purpose == constructor_unfilled_fields)\n+\n+\t  ctor_unfilled_bitpos = bit_position (constructor_unfilled_fields);\n+\t  elt_bitpos = bit_position (elt->purpose);\n+\t  /* We can't compare fields here because there might be empty\n+\t     fields in between.  */\n+\t  if (tree_int_cst_equal (elt_bitpos, ctor_unfilled_bitpos))\n \t    {\n-\t      output_init_element (elt->value,\n-\t\t\t\t   TREE_TYPE (constructor_unfilled_fields),\n-\t\t\t\t   constructor_unfilled_fields,\n-\t\t\t\t   0);\n+\t      constructor_unfilled_fields = elt->purpose;\n+\t      output_init_element (elt->value, TREE_TYPE (elt->purpose),\n+\t\t\t\t   elt->purpose, 0);\n \t    }\n-\t  else if (tree_int_cst_lt (bit_position (constructor_unfilled_fields),\n-\t\t\t\t    bit_position (elt->purpose)))\n+\t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n \t    {\n \t      /* Advance to the next smaller node.  */\n \t      if (elt->left)\n@@ -6036,9 +6396,8 @@ output_pending_init_elements (all)\n \t\t    elt = elt->parent;\n \t\t  elt = elt->parent;\n \t\t  if (elt\n-\t\t      && (tree_int_cst_lt\n-\t\t\t  (bit_position (constructor_unfilled_fields),\n-\t\t\t   bit_position (elt->purpose))))\n+\t\t      && (tree_int_cst_lt (ctor_unfilled_bitpos,\n+\t\t\t\t\t   bit_position (elt->purpose))))\n \t\t    {\n \t\t      next = elt->purpose;\n \t\t      break;\n@@ -6081,6 +6440,9 @@ process_init_element (value)\n   tree orig_value = value;\n   int string_flag = value != 0 && TREE_CODE (value) == STRING_CST;\n \n+  designator_depth = 0;\n+  designator_errorneous = 0;\n+\n   /* Handle superfluous braces around string cst as in\n      char x[] = {\"foo\"}; */\n   if (string_flag\n@@ -6123,6 +6485,10 @@ process_init_element (value)\n \tbreak;\n     }\n \n+  /* In the case of [LO ... HI] = VALUE, only evaluate VALUE once.  */\n+  if (constructor_range_stack)\n+    value = save_expr (value);\n+\n   while (1)\n     {\n       if (TREE_CODE (constructor_type) == RECORD_TYPE)\n@@ -6191,9 +6557,8 @@ process_init_element (value)\n \t\t && DECL_C_BIT_FIELD (constructor_fields)\n \t\t && DECL_NAME (constructor_fields) == 0)\n \t    constructor_fields = TREE_CHAIN (constructor_fields);\n-\t  break;\n \t}\n-      if (TREE_CODE (constructor_type) == UNION_TYPE)\n+      else if (TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n \t  tree fieldtype;\n \t  enum tree_code fieldcode;\n@@ -6252,9 +6617,8 @@ process_init_element (value)\n \t    }\n \n \t  constructor_fields = 0;\n-\t  break;\n \t}\n-      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \t  enum tree_code eltcode = TREE_CODE (elttype);\n@@ -6285,61 +6649,93 @@ process_init_element (value)\n \t      break;\n \t    }\n \n-\t  /* In the case of [LO .. HI] = VALUE, only evaluate VALUE once.  */\n-\t  if (constructor_range_end)\n+\t  /* Now output the actual element.  */\n+\t  if (value)\n \t    {\n-\t      if (constructor_max_index != 0\n-\t\t  && tree_int_cst_lt (constructor_max_index, \n-\t\t\t\t      constructor_range_end))\n-\t\t{\n-\t\t  pedwarn_init (\"excess elements in array initializer\");\n-\t\t  constructor_range_end = constructor_max_index;\n-\t\t}\n-\n-\t      value = save_expr (value);\n+\t      push_array_bounds (tree_low_cst (constructor_index, 0));\n+\t      output_init_element (value, elttype, constructor_index, 1);\n+\t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \n-\t  /* Now output the actual element.\n-\t     Ordinarily, output once.\n-\t     If there is a range, repeat it till we advance past the range.  */\n-\t  do\n-\t    {\n-\t      if (value)\n-\t\t{\n-\t\t  push_array_bounds (tree_low_cst (constructor_index, 0));\n-\t\t  output_init_element (value, elttype, constructor_index, 1);\n-\t\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n-\t\t}\n-\n-\t      constructor_index\n-\t\t= size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n-\n-\t      if (! value)\n-\t\t/* If we are doing the bookkeeping for an element that was\n-\t\t   directly output as a constructor, we must update\n-\t\t   constructor_unfilled_index.  */\n-\t\tconstructor_unfilled_index = constructor_index;\n-\t    }\n-\t  while (! (constructor_range_end == 0\n-\t\t    || tree_int_cst_lt (constructor_range_end,\n-\t\t\t\t\tconstructor_index)));\n+\t  constructor_index\n+\t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n \n-\t  break;\n+\t  if (! value)\n+\t    /* If we are doing the bookkeeping for an element that was\n+\t       directly output as a constructor, we must update\n+\t       constructor_unfilled_index.  */\n+\t    constructor_unfilled_index = constructor_index;\n \t}\n \n       /* Handle the sole element allowed in a braced initializer\n \t for a scalar variable.  */\n-      if (constructor_fields == 0)\n+      else if (constructor_fields == 0)\n \t{\n \t  pedwarn_init (\"excess elements in scalar initializer\");\n \t  break;\n \t}\n+      else\n+\t{\n+\t  if (value)\n+\t    output_init_element (value, constructor_type, NULL_TREE, 1);\n+\t  constructor_fields = 0;\n+\t}\n+\n+      /* Handle range initializers either at this level or anywhere higher\n+\t in the designator stack.  */\n+      if (constructor_range_stack)\n+\t{\n+\t  struct constructor_range_stack *p, *range_stack;\n+\t  int finish = 0;\n+\n+\t  range_stack = constructor_range_stack;\n+\t  constructor_range_stack = 0;\n+\t  while (constructor_stack != range_stack->stack)\n+\t    {\n+\t      if (!constructor_stack->implicit)\n+\t\tabort ();\n+\t      process_init_element (pop_init_level (1));\n+\t    }\n+\t  for (p = range_stack;\n+\t       !p->range_end || tree_int_cst_equal (p->index, p->range_end);\n+\t       p = p->prev)\n+\t    {\n+\t      if (!constructor_stack->implicit)\n+\t\tabort ();\n+\t      process_init_element (pop_init_level (1));\n+\t    }\n+\n+\t  p->index = size_binop (PLUS_EXPR, p->index, bitsize_one_node);\n+\t  if (tree_int_cst_equal (p->index, p->range_end) && !p->prev)\n+\t    finish = 1;\n+\n+\t  while (1)\n+\t    {\n+\t      constructor_index = p->index;\n+\t      constructor_fields = p->fields;\n+\t      if (finish && p->range_end && p->index == p->range_start)\n+\t\t{\n+\t\t  finish = 0;\n+\t\t  p->prev = 0;\n+\t\t}\n+\t      p = p->next;\n+\t      if (!p)\n+\t\tbreak;\n+\t      push_init_level (2);\n+\t      p->stack = constructor_stack;\n+\t      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))\n+\t\tp->index = p->range_start;\n+\t    }\n+\n+\t  if (!finish)\n+\t    constructor_range_stack = range_stack;\n+\t  continue;\n+\t}\n \n-      if (value)\n-\toutput_init_element (value, constructor_type, NULL_TREE, 1);\n-      constructor_fields = 0;\n       break;\n     }\n+\n+  constructor_range_stack = 0;\n }\n \f\n /* Build an asm-statement, whose components are a CV_QUALIFIER, a"}, {"sha": "005bd7ec848fd89bebd4f2683c41550dffe5dec2", "filename": "gcc/extend.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -1260,6 +1260,10 @@ extension.  For example,\n int widths[] = @{ [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 @};\n @end example\n \n+@noindent\n+If the value in it has side-effects, the side-effects will happen only once,\n+not for each initialized field by the range initializer.\n+\n @noindent\n Note that the length of the array is the highest value specified\n plus one.\n@@ -1345,6 +1349,12 @@ example, with the @samp{struct point} declaration above:\n struct point ptarray[10] = @{ [2].y = yv2, [2].x = xv2, [0].x = xv0 @};\n @end example\n \n+@noindent\n+If the same field is initialized multiple times, it will have value from\n+the last initialization.  If any such overridden initialization has\n+side-effect, it is unspecified whether the side-effect happens or not.\n+Currently, gcc will discard them and issue a warning.\n+\n @node Case Ranges\n @section Case Ranges\n @cindex case ranges"}, {"sha": "f34c384267e0618346c0d8569c6a9f4ec36ad7fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -1,3 +1,11 @@\n+2001-01-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20000801-3.x: Remove.\n+\t* gcc.dg/c90-init-1.c: New test.\n+\t* gcc.dg/c99-init-1.c: New test.\n+\t* gcc.dg/c99-init-2.c: New test.\n+\t* gcc.dg/gnu99-init-1.c: New test.\n+\n 2001-01-12  Richard Earnshaw <rearnsha@arm.com>\n \n \t* lib/f-torture.exp (f_torture_compile): Prune the warnings before"}, {"sha": "2f397b96e51b8dd77baecd30d403a01dfab48caf", "filename": "gcc/testsuite/gcc.c-torture/execute/20000801-3.x", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-3.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-3.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000801-3.x?ref=fafc249b1bdd385ce0c45d2696ad7c1c09c9b2cb", "patch": "@@ -1,2 +0,0 @@\n-set torture_execute_xfail \"*-*-*\"\n-return 0"}, {"sha": "1ea0bdb4006cee24d67c54a6e9dcaf41d38bd6ce", "filename": "gcc/testsuite/gcc.dg/c90-init-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-init-1.c?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -0,0 +1,25 @@\n+/* Test for C99 designated initializers */\n+/* Origin: Jakub Jelinek <jakub@redhat.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct A {\n+  int B;\n+  short C[2];\n+};\n+int a[10] = { 10, [4] = 15 };\t\t\t/* { dg-error \"ISO C89 forbids specifying subobject to initialize\" } */\n+struct A b = { .B = 2 };\t\t\t/* { dg-error \"ISO C89 forbids specifying subobject to initialize\" } */\n+struct A c[] = { [3].C[1] = 1 };\t\t/* { dg-error \"ISO C89 forbids specifying subobject to initialize\" } */\n+struct A d[] = { [4 ... 6].C[0 ... 1] = 2 };\t/* { dg-error \"(forbids specifying range of elements to initialize)|(ISO C89 forbids specifying subobject to initialize)\" } */\n+int e[] = { [2] 2 };\t\t\t\t/* { dg-error \"use of designated initializer without\" } */\n+struct A f = { C: { 0, 1 } };\t\t\t/* { dg-error \"use of designated initializer with \" } */\n+int g;\n+\n+void foo (int *);\n+\n+void bar (void)\n+{\n+  int x[] = { g++, 2 };\t\t\t\t/* { dg-error \"is not computable at load time\" } */\n+\n+  foo (x);\n+}"}, {"sha": "95803c241fc07ba0465658273c19e8f752154a86", "filename": "gcc/testsuite/gcc.dg/c99-init-1.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-1.c?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -0,0 +1,78 @@\n+/* Test for C99 designated initializers */\n+/* Origin: Jakub Jelinek <jakub@redhat.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+extern int memcmp (const void *, const void *, size_t);\n+extern void abort (void);\n+extern void exit (int);\n+\n+int a[10] = { 10, 0, 12, 13, 14, 0, 0, 17, 0, 0 };\n+int b[10] = { 10, [4] = 15, [2] = 12, [4] = 14, [7] = 17 };\n+int c[10] = { 10, [4] = 15, [2] = 12, [3] = 13, 14, [7] = 17 };\n+struct A {\n+  int B;\n+  short C[2];\n+};\n+struct A d[] = { { 0, { 1, 2 } }, { 0, { 0, 0 } }, { 10, { 11, 12 } } };\n+struct A e[] = { 0, 1, 2, [2] = 10, 11, 12 };\n+struct A f[] = { 0, 1, 2, [2].C = 11, 12, 13 };\n+struct A g[] = { 0, 1, 2, [2].C[1] = 12, 13, 14 };\n+struct A h[] = { 0, 1, 2, [2] = { .C[1] = 12 }, 13, 14 };\n+struct A i[] = { 0, 1, 2, [2] = { .C = { [1] = 12 } }, 13, 14 };\n+union D {\n+  int E;\n+  double F;\n+  struct A G;\n+};\n+union D j[] = { [4] = 1, [4].F = 1.0, [1].G.C[1] = 4 };\n+struct H {\n+  char I[6];\n+  int J;\n+} k[] = { { { \"foo\" }, 1 }, [0].I[0] = 'b' };\n+struct K {\n+  wchar_t L[6];\n+  int M;\n+} l[] = { { { L\"foo\" }, 1 }, [0].L[2] = L'x', [0].L[4] = L'y' };\n+struct H m[] = { { { \"foo\" }, 1 }, [0] = { .I[0] = 'b' } };\n+struct H n[] = { { { \"foo\" }, 1 }, [0].I = { \"a\" }, [0].J = 2 };\n+int o = { 22 };\n+\n+int main (void)\n+{\n+  if (b[3])\n+    abort ();\n+  b[3] = 13;\n+  if (memcmp (a, b, sizeof (a)) || memcmp (a, c, sizeof (a)))\n+    abort ();\n+  if (memcmp (d, e, sizeof (d)) || sizeof (d) != sizeof (e))\n+    abort ();\n+  if (f[2].B != 0 || g[2].B != 0 || g[2].C[0] != 0)\n+    abort ();\n+  if (memcmp (g, h, sizeof (g)) || memcmp (g, i, sizeof (g)))\n+    abort ();\n+  f[2].B = 10;\n+  g[2].B = 10;\n+  g[2].C[0] = 11;\n+  if (memcmp (d, f, sizeof (d)) || memcmp (d, g, sizeof (d)))\n+    abort ();\n+  if (f[3].B != 13 || g[3].B != 13 || g[3].C[0] != 14)\n+    abort ();\n+  if (j[0].E || j[1].G.B || j[1].G.C[0] || j[1].G.C[1] != 4)\n+    abort ();\n+  if (j[2].E || j[3].E || j[4].F != 1.0)\n+    abort ();\n+  if (memcmp (k[0].I, \"boo\\0\\0\", 6) || k[0].J != 1)\n+    abort ();\n+  if (memcmp (l[0].L, L\"fox\\0y\", 6 * sizeof(wchar_t)) || l[0].M != 1)\n+    abort ();\n+  if (memcmp (m[0].I, \"b\\0\\0\\0\\0\", 6) || m[0].J)\n+    abort ();\n+  if (memcmp (n[0].I, \"a\\0\\0\\0\\0\", 6) || n[0].J != 2)\n+    abort ();\n+  if (o != 22)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "d3a331ff3552f30fe51eb7a20b9409d7eaadebda", "filename": "gcc/testsuite/gcc.dg/c99-init-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-init-2.c?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -0,0 +1,30 @@\n+/* Test for C99 designated initializer warnings and errors */\n+/* Origin: Jakub Jelinek <jakub@redhat.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -Wall -pedantic-errors\" } */\n+\n+typedef struct {\n+  int B;\n+  short C[2];\n+} A;\n+A a = { [2] = 1 };\t\t\t/* { dg-error \"(array index in non-array)|(near initialization)\" } */\n+int b[] = { .B = 1 };\t\t\t/* { dg-error \"(field name not in record)|(near initialization)\" } */\n+A c[] = { [0].D = 1 };\t\t\t/* { dg-error \"unknown field\" } */\n+int d;\n+int e = { d++ };\t\t\t/* { dg-error \"(is not constant)|(near initialization)\" } */\n+A f[2] = { [0].C[0] = 1, [2] = { 2, { 1, 2 } } };/* { dg-error \"(array index in initializer exceeds array bounds)|(near initialization)\" } */\n+int g[4] = { [1] = 1, 2, [6] = 5 };\t/* { dg-error \"(array index in initializer exceeds array bounds)|(near initialization)\" } */\n+int h[] = { [0 ... 3] = 5 };\t\t/* { dg-error \"forbids specifying range of elements\" } */\n+int i[] = { [2] 4 };\t\t\t/* { dg-error \"use of designated initializer without\" } */\n+A j = { B: 2 };\t\t\t\t/* { dg-error \"use of designated initializer with \" } */\n+\n+void foo (int *, A *);\n+\n+void bar (void)\n+{\n+  int a[] = { d++, [0] = 1 };\t\t/* { dg-warning \"(initialized field with side-effects overwritten)|(near initialization)\" } */\n+  A b = { 1, { d++, 2 }, .C[0] = 3 };/* { dg-warning \"(initialized field with side-effects overwritten)|(near initialization)\" } */\n+  A c = { d++, { 2, 3 }, .B = 4 };\t/* { dg-warning \"(initialized field with side-effects overwritten)|(near initialization)\" } */\n+\n+  foo (a, d ? &b : &c);\n+}"}, {"sha": "c78f17647c87d69944d631d94736575715f52b28", "filename": "gcc/testsuite/gcc.dg/gnu99-init-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6a5902b5588d5e3e30ff2822655eec304345df/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-init-1.c?ref=8b6a5902b5588d5e3e30ff2822655eec304345df", "patch": "@@ -0,0 +1,62 @@\n+/* Test for GNU extensions to C99 designated initializers */\n+/* Origin: Jakub Jelinek <jakub@redhat.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern int memcmp (const void *, const void *, size_t);\n+extern void abort (void);\n+extern void exit (int);\n+\n+int a[][2][4] = { [2 ... 4][0 ... 1][2 ... 3] = 1, [2] = 2, [2][0][2] = 3 };\n+struct E {};\n+struct F { struct E H; };\n+struct G { int I; struct E J; int K; };\n+struct H { int I; struct F J; int K; };\n+struct G k = { .J = {}, 1 };\n+struct H l = { .J.H = {}, 2 };\n+struct H m = { .J = {}, 3 };\n+struct I { int J; int K[3]; int L; };\n+struct M { int N; struct I O[3]; int P; };\n+struct M n[] = { [0 ... 5].O[1 ... 2].K[0 ... 1] = 4, 5, 6, 7 };\n+\n+int main (void)\n+{\n+  int x, y, z;\n+\n+  if (a[2][0][0] != 2 || a[2][0][2] != 3)\n+    abort ();\n+  a[2][0][0] = 0;\n+  a[2][0][2] = 1;\n+  for (x = 0; x <= 4; x++)\n+    for (y = 0; y <= 1; y++)\n+      for (z = 0; z <= 3; z++)\n+\tif (a[x][y][z] != (x >= 2 && z >= 2))\n+\t  abort ();\n+  if (k.I || l.I || m.I || k.K != 1 || l.K != 2 || m.K != 3)\n+    abort ();\n+  for (x = 0; x <= 5; x++)\n+    {\n+      if (n[x].N || n[x].O[0].J || n[x].O[0].L)\n+\tabort ();\n+      for (y = 0; y <= 2; y++)\n+\tif (n[x].O[0].K[y])\n+\t  abort ();\n+      for (y = 1; y <= 2; y++)\n+\t{\n+\t  if (n[x].O[y].J)\n+\t    abort ();\n+\t  if (n[x].O[y].K[0] != 4)\n+\t    abort ();\n+\t  if (n[x].O[y].K[1] != 4)\n+\t    abort ();\n+\t  if ((x < 5 || y < 2) && (n[x].O[y].K[2] || n[x].O[y].L))\n+\t    abort ();\n+\t}\n+      if (x < 5 && n[x].P)\n+\tabort ();\n+    }\n+  if (n[5].O[2].K[2] != 5 || n[5].O[2].L != 6 || n[5].P != 7)\n+    abort ();\n+  exit (0);\n+}"}]}