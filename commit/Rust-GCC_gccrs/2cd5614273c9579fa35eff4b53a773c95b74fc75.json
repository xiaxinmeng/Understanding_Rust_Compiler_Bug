{"sha": "2cd5614273c9579fa35eff4b53a773c95b74fc75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNkNTYxNDI3M2M5NTc5ZmEzNWVmZjRiNTNhNzczYzk1Yjc0ZmM3NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-09-29T21:13:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-09-29T21:13:55Z"}, "message": "re PR libgcj/10596 (Reference and String.intern don't work together)\n\n\tPR libgcj/10596:\n\t* include/jvm.h (_Jv_FinalizeString,\n\t_Jv_RegisterStringFinalizer): Declare.\n\t* java/lang/natString.cc (_Jv_FinalizeString): Renamed from\n\tunintern.\n\t(intern): Updated.\n\t(_Jv_NewStringUtf8Const): Likewise.\n\t* java/lang/ref/natReference.cc (finalize_referred_to_object):\n\tAdd special case when finalizing a String.\n\t(in_hash): New function.\n\t(_Jv_RegisterStringFinalizer): Likewise.\n\t(maybe_add_finalize): Likewise.\n\nFrom-SVN: r71915", "tree": {"sha": "18171d36bf9de87984585bd1c888f405512a3e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18171d36bf9de87984585bd1c888f405512a3e54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cd5614273c9579fa35eff4b53a773c95b74fc75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd5614273c9579fa35eff4b53a773c95b74fc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd5614273c9579fa35eff4b53a773c95b74fc75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd5614273c9579fa35eff4b53a773c95b74fc75/comments", "author": null, "committer": null, "parents": [{"sha": "51ac684e521e8008e2c076e5ca7c139b236f603c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ac684e521e8008e2c076e5ca7c139b236f603c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ac684e521e8008e2c076e5ca7c139b236f603c"}], "stats": {"total": 142, "additions": 116, "deletions": 26}, "files": [{"sha": "d12987a7227d9898c58a7fce363659946d1f4e69", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2cd5614273c9579fa35eff4b53a773c95b74fc75", "patch": "@@ -1,3 +1,18 @@\n+2003-09-29  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/10596:\n+\t* include/jvm.h (_Jv_FinalizeString,\n+\t_Jv_RegisterStringFinalizer): Declare.\n+\t* java/lang/natString.cc (_Jv_FinalizeString): Renamed from\n+\tunintern.\n+\t(intern): Updated.\n+\t(_Jv_NewStringUtf8Const): Likewise.\n+\t* java/lang/ref/natReference.cc (finalize_referred_to_object):\n+\tAdd special case when finalizing a String.\n+\t(in_hash): New function.\n+\t(_Jv_RegisterStringFinalizer): Likewise.\n+\t(maybe_add_finalize): Likewise.\n+\n 2003-09-29  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/InetAddress.java:"}, {"sha": "ed6c61ec50dec16648755a428b7ef6f7e792c97e", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=2cd5614273c9579fa35eff4b53a773c95b74fc75", "patch": "@@ -290,6 +290,12 @@ void _Jv_GCRegisterDisappearingLink (jobject *objp);\n    implement soft references.  */\n jboolean _Jv_GCCanReclaimSoftReference (jobject obj);\n \n+/* Register a finalizer for a String object.  This is only used by\n+   the intern() implementation.  */\n+void _Jv_RegisterStringFinalizer (jobject str);\n+/* This is called to actually finalize a possibly-intern()d String.  */\n+void _Jv_FinalizeString (jobject str);\n+\n /* Return approximation of total size of heap.  */\n long _Jv_GCTotalMemory (void);\n /* Return approximation of total free memory.  */"}, {"sha": "c87844b0d51993a4c96707e0cfb6e58ddfbd6f1a", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=2cd5614273c9579fa35eff4b53a773c95b74fc75", "patch": "@@ -31,7 +31,6 @@ details.  */\n #include <gnu/gcj/runtime/StringBuffer.h>\n #include <jvm.h>\n \n-static void unintern (jobject);\n static jstring* strhash = NULL;\n static int strhash_count = 0;  /* Number of slots used in strhash. */\n static int strhash_size = 0;  /* Number of slots available in strhash.\n@@ -173,50 +172,60 @@ java::lang::String::intern()\n   jstring* ptr = _Jv_StringGetSlot(this);\n   if (*ptr != NULL && *ptr != DELETED_STRING)\n     {\n-      // See description in unintern() to understand this.\n+      // See description in _Jv_FinalizeString() to understand this.\n       *ptr = (jstring) MASK_PTR (*ptr);\n       return (jstring) UNMASK_PTR (*ptr);\n     }\n-  jstring str = this->data == this ? this\n-    : _Jv_NewString(JvGetStringChars(this), this->length());\n+  jstring str = (this->data == this\n+\t\t ? this\n+\t\t : _Jv_NewString(JvGetStringChars(this), this->length()));\n   SET_STRING_IS_INTERNED(str);\n   strhash_count++;\n   *ptr = str;\n   // When string is GC'd, clear the slot in the hash table.\n-  _Jv_RegisterFinalizer ((void *) str, unintern);\n+  _Jv_RegisterStringFinalizer (str);\n   return str;\n }\n \n-/* Called by String fake finalizer. */\n-static void\n-unintern (jobject obj)\n+// The fake String finalizer.  This is only used when the String has\n+// been intern()d.  However, we must check this case, as it might be\n+// called by the Reference code for any String.\n+void\n+_Jv_FinalizeString (jobject obj)\n {\n   JvSynchronize sync (&StringClass);\n+\n+  // We might not actually have intern()d any strings at all, if\n+  // we're being called from Reference.\n+  if (! strhash)\n+    return;\n+\n   jstring str = reinterpret_cast<jstring> (obj);\n-  jstring* ptr = _Jv_StringGetSlot(str);\n-  if (*ptr == NULL || *ptr == DELETED_STRING)\n+  jstring *ptr = _Jv_StringGetSlot(str);\n+  if (*ptr == NULL || *ptr == DELETED_STRING\n+      || (jobject) UNMASK_PTR (*ptr) != obj)\n     return;\n \n   // We assume the lowest bit of the pointer is free for our nefarious\n   // manipulations.  What we do is set it to `0' (implicitly) when\n   // interning the String.  If we subsequently re-intern the same\n   // String, then we set the bit.  When finalizing, if the bit is set\n   // then we clear it and re-register the finalizer.  We know this is\n-  // a safe approach because both intern() and unintern() acquire\n-  // the class lock; this bit can't be manipulated when the lock is\n-  // not held.  So if we are finalizing and the bit is clear then we\n-  // know all references are gone and we can clear the entry in the\n-  // hash table.  The naive approach of simply clearing the pointer\n-  // here fails in the case where a request to intern a new string\n-  // with the same contents is made between the time the intern()d\n-  // string is found to be unreachable and when the finalizer is\n-  // actually run.  In this case we could clear a pointer to a valid\n-  // string, and future intern() calls for that particular value would\n-  // spuriously fail.\n+  // a safe approach because both intern() and _Jv_FinalizeString()\n+  // acquire the class lock; this bit can't be manipulated when the\n+  // lock is not held.  So if we are finalizing and the bit is clear\n+  // then we know all references are gone and we can clear the entry\n+  // in the hash table.  The naive approach of simply clearing the\n+  // pointer here fails in the case where a request to intern a new\n+  // string with the same contents is made between the time the\n+  // intern()d string is found to be unreachable and when the\n+  // finalizer is actually run.  In this case we could clear a pointer\n+  // to a valid string, and future intern() calls for that particular\n+  // value would spuriously fail.\n   if (PTR_MASKED (*ptr))\n     {\n       *ptr = (jstring) UNMASK_PTR (*ptr);\n-      _Jv_RegisterFinalizer ((void *) obj, unintern);\n+      _Jv_RegisterStringFinalizer (obj);\n     }\n   else\n     {\n@@ -292,8 +301,10 @@ _Jv_NewStringUtf8Const (Utf8Const* str)\n   jstr->cachedHashCode = hash;\n   *ptr = jstr;\n   SET_STRING_IS_INTERNED(jstr);\n-  // When string is GC'd, clear the slot in the hash table.\n-  _Jv_RegisterFinalizer ((void *) jstr, unintern);\n+  // When string is GC'd, clear the slot in the hash table.  Note that\n+  // we don't have to call _Jv_RegisterStringFinalizer here, as we\n+  // know the new object cannot be referred to by a Reference.\n+  _Jv_RegisterFinalizer ((void *) jstr, _Jv_FinalizeString);\n   return jstr;\n }\n "}, {"sha": "e322ae37cc820aac675399a3fb90ba0d8ac7a428", "filename": "libjava/java/lang/ref/natReference.cc", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd5614273c9579fa35eff4b53a773c95b74fc75/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc?ref=2cd5614273c9579fa35eff4b53a773c95b74fc75", "patch": "@@ -159,6 +159,19 @@ remove_from_hash (jobject obj)\n     }\n }\n \n+// Return list head if object is in hash, NULL otherwise.\n+object_list *\n+in_hash (jobject obj)\n+{\n+  // The hash table might not yet be initialized.\n+  if (hash == NULL)\n+    return NULL;\n+  object_list *head = find_slot (obj);\n+  if (head->reference != obj)\n+    return NULL;\n+  return head;\n+}\n+\n // FIXME what happens if an object's finalizer creates a Reference to\n // the object, and the object has never before been added to the hash?\n // Madness!\n@@ -212,6 +225,29 @@ add_to_hash (java::lang::ref::Reference *the_reference)\n   *link = n;\n }\n \n+// Add a FINALIZE entry if one doesn't exist.\n+static void\n+maybe_add_finalize (object_list *entry, jobject obj)\n+{\n+  object_list **link = &entry->next;\n+  object_list *iter = *link;\n+  while (iter && iter->weight < FINALIZE)\n+    {\n+      link = &iter->next;\n+      iter = *link;\n+    }\n+\n+  // We want at most one FINALIZE entry in the queue.\n+  if (iter && iter->weight == FINALIZE)\n+    return;\n+\n+  object_list *n = (object_list *) _Jv_Malloc (sizeof (object_list));\n+  n->reference = obj;\n+  n->weight = FINALIZE;\n+  n->next = *link;\n+  *link = n;\n+}\n+\n // This is called when an object is ready to be finalized.  This\n // actually implements the appropriate Reference semantics.\n static void\n@@ -236,16 +272,21 @@ finalize_referred_to_object (jobject obj)\n   enum weight w = head->weight;\n   if (w == FINALIZE)\n     {\n+      // Update the list first, as _Jv_FinalizeString might end up\n+      // looking at this data structure.\n+      list->next = head->next;\n+      _Jv_Free (head);\n+\n       // If we have a Reference A to a Reference B, and B is\n       // finalized, then we have to take special care to make sure\n       // that B is properly deregistered.  This is super gross.  FIXME\n       // will it fail if B's finalizer resurrects B?\n       if (java::lang::ref::Reference::class$.isInstance (obj))\n \tfinalize_reference (obj);\n+      else if (obj->getClass() == &java::lang::String::class$)\n+\t_Jv_FinalizeString (obj);\n       else\n \t_Jv_FinalizeObject (obj);\n-      list->next = head->next;\n-      _Jv_Free (head);\n     }\n   else if (w != SOFT || _Jv_GCCanReclaimSoftReference (obj))\n     {\n@@ -286,6 +327,23 @@ finalize_reference (jobject ref)\n   _Jv_FinalizeObject (ref);\n }\n \n+void\n+_Jv_RegisterStringFinalizer (jobject str)\n+{\n+  // This function might be called before any other Reference method,\n+  // so we must ensure the class is initialized.\n+  _Jv_InitClass (&java::lang::ref::Reference::class$);\n+  JvSynchronize sync (java::lang::ref::Reference::lock);\n+  // If the object is in our hash table, then we might need to add a\n+  // new FINALIZE entry.  Otherwise, we just register an ordinary\n+  // finalizer.\n+  object_list *entry = in_hash (str);\n+  if (entry)\n+    maybe_add_finalize (entry, str);\n+  else\n+    _Jv_RegisterFinalizer ((void *) str, _Jv_FinalizeString);\n+}\n+\n void\n ::java::lang::ref::Reference::create (jobject ref)\n {"}]}