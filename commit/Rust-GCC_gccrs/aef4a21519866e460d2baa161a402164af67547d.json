{"sha": "aef4a21519866e460d2baa161a402164af67547d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmNGEyMTUxOTg2NmU0NjBkMmJhYTE2MWE0MDIxNjRhZjY3NTQ3ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-11-02T01:30:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:30:39Z"}, "message": "decl2.c (decl_constant_var_p): New fn.\n\n\t* decl2.c (decl_constant_var_p): New fn.\n\t(decl_maybe_constant_var_p): New fn.\n\t(mark_used): Rework instantiation of things needed for constant\n\texpressions.\n\t* cp-tree.h: Declare new fns.\n\t* pt.c (instantiate_decl): Handle cp_unevaluated_operand.\n\t(always_instantiate_p): Use decl_maybe_constant_var_p.\n\t(instantiate_decl): Don't defer constexpr functions.\n\t* repo.c (repo_emit_p): Use decl_maybe_constant_var_p.\n\t* semantics.c (finish_id_expression): Use decl_constant_var_p.\n\tCheck for valid name in constant expr after mark_used.\n\nFrom-SVN: r166164", "tree": {"sha": "78573089ef14591417c470516d19451c94823b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78573089ef14591417c470516d19451c94823b25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef4a21519866e460d2baa161a402164af67547d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef4a21519866e460d2baa161a402164af67547d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef4a21519866e460d2baa161a402164af67547d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef4a21519866e460d2baa161a402164af67547d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7bf8ca763de168f22d2b65662a83e47b56d187e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf8ca763de168f22d2b65662a83e47b56d187e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf8ca763de168f22d2b65662a83e47b56d187e8"}], "stats": {"total": 167, "additions": 122, "deletions": 45}, "files": [{"sha": "264683949cbd25fc04ea401d14a6ae679fa6a6e1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -1,3 +1,17 @@\n+2010-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* decl2.c (decl_constant_var_p): New fn.\n+\t(decl_maybe_constant_var_p): New fn.\n+\t(mark_used): Rework instantiation of things needed for constant\n+\texpressions.\n+\t* cp-tree.h: Declare new fns.\n+\t* pt.c (instantiate_decl): Handle cp_unevaluated_operand.\n+\t(always_instantiate_p): Use decl_maybe_constant_var_p.\n+\t(instantiate_decl): Don't defer constexpr functions.\n+\t* repo.c (repo_emit_p): Use decl_maybe_constant_var_p.\n+\t* semantics.c (finish_id_expression): Use decl_constant_var_p.\n+\tCheck for valid name in constant expr after mark_used.\n+\n 2010-10-31  Jason Merrill  <jason@redhat.com>\n \n \t* class.c (is_really_empty_class): Work when type is not complete."}, {"sha": "bc4eb46e7f09d20e8838b74fd5600432f14a7c57", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -4882,6 +4882,8 @@ extern void constrain_class_visibility\t\t(tree);\n extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree\t(tree, VEC(tree,gc) **);\n+extern bool decl_constant_var_p\t\t\t(tree);\n+extern bool decl_maybe_constant_var_p\t\t(tree);\n extern void check_default_args\t\t\t(tree);\n extern void mark_used\t\t\t\t(tree);\n extern void finish_static_data_member_decl\t(tree, tree, bool, tree, int);"}, {"sha": "3f492bbc9e7dc1a9284e88cc5db6503587052644", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 81, "deletions": 26, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -3526,6 +3526,60 @@ decl_defined_p (tree decl)\n     }\n }\n \n+/* Nonzero for a VAR_DECL whose value can be used in a constant expression.\n+\n+      [expr.const]\n+\n+      An integral constant-expression can only involve ... const\n+      variables of integral or enumeration types initialized with\n+      constant expressions ...\n+\n+      C++0x also allows constexpr variables and temporaries initialized\n+      with constant expressions.  We handle the former here, but the latter\n+      are just folded away in cxx_eval_constant_expression.\n+\n+   The standard does not require that the expression be non-volatile.\n+   G++ implements the proposed correction in DR 457.  */\n+\n+bool\n+decl_constant_var_p (tree decl)\n+{\n+  bool ret;\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+  if (DECL_DECLARED_CONSTEXPR_P (decl))\n+    ret = true;\n+  else if (CP_TYPE_CONST_NON_VOLATILE_P (type)\n+\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+    {\n+      /* We don't know if a template static data member is initialized with\n+\t a constant expression until we instantiate its initializer.  */\n+      mark_used (decl);\n+      ret = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl);\n+    }\n+  else\n+    ret = false;\n+\n+  gcc_assert (!ret || DECL_INITIAL (decl));\n+  return ret;\n+}\n+\n+/* Returns true if DECL could be a symbolic constant variable, depending on\n+   its initializer.  */\n+\n+bool\n+decl_maybe_constant_var_p (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+  if (DECL_DECLARED_CONSTEXPR_P (decl))\n+    return true;\n+  return (CP_TYPE_CONST_NON_VOLATILE_P (type)\n+\t  && INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n+}\n+\n /* Complain that DECL uses a type with no linkage but is never defined.  */\n \n static void\n@@ -4074,8 +4128,6 @@ possibly_inlined_p (tree decl)\n void\n mark_used (tree decl)\n {\n-  HOST_WIDE_INT saved_processing_template_decl = 0;\n-\n   /* If DECL is a BASELINK for a single function, then treat it just\n      like the DECL for the function.  Otherwise, if the BASELINK is\n      for an overloaded function, we don't know which function was\n@@ -4113,9 +4165,6 @@ mark_used (tree decl)\n \terror_at (DECL_SOURCE_LOCATION (decl), \"declared here\");\n       return;\n     }\n-  /* If we don't need a value, then we don't need to synthesize DECL.  */\n-  if (cp_unevaluated_operand != 0)\n-    return;\n \n   /* We can only check DECL_ODR_USED on variables or functions with\n      DECL_LANG_SPECIFIC set, and these are also the only decls that we\n@@ -4139,31 +4188,39 @@ mark_used (tree decl)\n       return;\n     }\n \n-  /* Normally, we can wait until instantiation-time to synthesize\n-     DECL.  However, if DECL is a static data member initialized with\n-     a constant, we need the value right now because a reference to\n-     such a data member is not value-dependent.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)\n-      && DECL_CLASS_SCOPE_P (decl))\n+  /* Normally, we can wait until instantiation-time to synthesize DECL.\n+     However, if DECL is a static data member initialized with a constant\n+     or a constexpr function, we need it right now because a reference to\n+     such a data member or a call to such function is not value-dependent.  */\n+  if ((decl_maybe_constant_var_p (decl)\n+       || (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && DECL_DECLARED_CONSTEXPR_P (decl)))\n+      && !DECL_INITIAL (decl)\n+      && DECL_LANG_SPECIFIC (decl)\n+      && DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n-      /* Don't try to instantiate members of dependent types.  We\n-\t cannot just use dependent_type_p here because this function\n-\t may be called from fold_non_dependent_expr, and then we may\n-\t see dependent types, even though processing_template_decl\n-\t will not be set.  */\n-      if (CLASSTYPE_TEMPLATE_INFO ((DECL_CONTEXT (decl)))\n-\t  && uses_template_parms (CLASSTYPE_TI_ARGS (DECL_CONTEXT (decl))))\n-\treturn;\n-      /* Pretend that we are not in a template, even if we are, so\n-\t that the static data member initializer will be processed.  */\n-      saved_processing_template_decl = processing_template_decl;\n-      processing_template_decl = 0;\n+      /* Instantiating a function will result in garbage collection.  We\n+\t must treat this situation as if we were within the body of a\n+\t function so as to avoid collecting live data only referenced from\n+\t the stack (such as overload resolution candidates).  */\n+      ++function_depth;\n+      instantiate_decl (decl, /*defer_ok=*/false,\n+\t\t\t/*expl_inst_class_mem_p=*/false);\n+      --function_depth;\n     }\n \n+  /* If we don't need a value, then we don't need to synthesize DECL.  */\n+  if (cp_unevaluated_operand != 0)\n+    return;\n+\n   if (processing_template_decl)\n     return;\n \n+  /* Check this too in case we're within fold_non_dependent_expr.  */\n+  if (DECL_TEMPLATE_INFO (decl)\n+      && uses_template_parms (DECL_TI_ARGS (decl)))\n+    return;\n+\n   DECL_ODR_USED (decl) = 1;\n   if (DECL_CLONED_FUNCTION_P (decl))\n     DECL_ODR_USED (DECL_CLONED_FUNCTION (decl)) = 1;\n@@ -4233,8 +4290,6 @@ mark_used (tree decl)\n        need.  Therefore, we always try to defer instantiation.  */\n     instantiate_decl (decl, /*defer_ok=*/true,\n \t\t      /*expl_inst_class_mem_p=*/false);\n-\n-  processing_template_decl = saved_processing_template_decl;\n }\n \n #include \"gt-cp-decl2.h\""}, {"sha": "0047aaeb6fb830214cb5b5bbb8597b4d21c1a6a1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -16714,7 +16714,7 @@ always_instantiate_p (tree decl)\n \t     their initializers are available in integral constant\n \t     expressions.  */\n \t  || (TREE_CODE (decl) == VAR_DECL\n-\t      && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)));\n+\t      && decl_maybe_constant_var_p (decl)));\n }\n \n /* Produce the definition of D, a _DECL generated from a template.  If\n@@ -16750,7 +16750,8 @@ instantiate_decl (tree d, int defer_ok,\n      case that an expression refers to the value of the variable --\n      if the variable has a constant value the referring expression can\n      take advantage of that fact.  */\n-  if (TREE_CODE (d) == VAR_DECL)\n+  if (TREE_CODE (d) == VAR_DECL\n+      || DECL_DECLARED_CONSTEXPR_P (d))\n     defer_ok = 0;\n \n   /* Don't instantiate cloned functions.  Instead, instantiate the\n@@ -16926,6 +16927,11 @@ instantiate_decl (tree d, int defer_ok,\n \tpermerror (input_location,  \"explicit instantiation of %qD \"\n \t\t   \"but no definition available\", d);\n \n+      /* If we're in unevaluated context, we just wanted to get the\n+\t constant value; this isn't an odr use, so don't queue\n+\t a full instantiation.  */\n+      if (cp_unevaluated_operand != 0)\n+\tgoto out;\n       /* ??? Historically, we have instantiated inline functions, even\n \t when marked as \"extern template\".  */\n       if (!(external_p && TREE_CODE (d) == VAR_DECL))"}, {"sha": "357dcd976508fbdf9cc0ca95f20fb07ccf5bb1a9", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -319,7 +319,7 @@ repo_emit_p (tree decl)\n \t available.  Still record them into *.rpo files, so if they\n \t weren't actually emitted and collect2 requests them, they can\n \t be provided.  */\n-      if (DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+      if (decl_maybe_constant_var_p (decl)\n \t  && DECL_CLASS_SCOPE_P (decl))\n \tret = 2;\n     }"}, {"sha": "ad26abb0930f01a02f03ca23bb39186f4cd7b5a6", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef4a21519866e460d2baa161a402164af67547d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=aef4a21519866e460d2baa161a402164af67547d", "patch": "@@ -2826,7 +2826,7 @@ finish_id_expression (tree id_expression,\n \t     the complexity of the problem\"\n \n \t     FIXME update for final resolution of core issue 696.  */\n-\t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n+\t  if (decl_constant_var_p (decl))\n \t    return integral_constant_value (decl);\n \n \t  if (TYPE_P (context))\n@@ -3077,21 +3077,6 @@ finish_id_expression (tree id_expression,\n \t  return id_expression;\n \t}\n \n-      /* Only certain kinds of names are allowed in constant\n-\t expression.  Enumerators and template parameters have already\n-\t been handled above.  */\n-      if (integral_constant_expression_p\n-\t  && ! DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n-\t  && ! builtin_valid_in_constant_expr_p (decl))\n-\t{\n-\t  if (!allow_non_integral_constant_expression_p)\n-\t    {\n-\t      error (\"%qD cannot appear in a constant-expression\", decl);\n-\t      return error_mark_node;\n-\t    }\n-\t  *non_integral_constant_expression_p = true;\n-\t}\n-\n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t{\n \t  error (\"use of namespace %qD as expression\", decl);\n@@ -3118,6 +3103,21 @@ finish_id_expression (tree id_expression,\n \t  || TREE_CODE (decl) == RESULT_DECL)\n \tmark_used (decl);\n \n+      /* Only certain kinds of names are allowed in constant\n+\t expression.  Enumerators and template parameters have already\n+\t been handled above.  */\n+      if (integral_constant_expression_p\n+\t  && ! decl_constant_var_p (decl)\n+\t  && ! builtin_valid_in_constant_expr_p (decl))\n+\t{\n+\t  if (!allow_non_integral_constant_expression_p)\n+\t    {\n+\t      error (\"%qD cannot appear in a constant-expression\", decl);\n+\t      return error_mark_node;\n+\t    }\n+\t  *non_integral_constant_expression_p = true;\n+\t}\n+\n       if (scope)\n \t{\n \t  decl = (adjust_result_of_qualified_name_lookup"}]}