{"sha": "c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlZTdiNDUzNGY1NzMwMjYzZjlkNjUzZDRjOGQ1OGMzZWEwMmFjZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-03-15T13:37:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-03-15T13:37:23Z"}, "message": "re PR c++/13954 ([tree-ssa] SRA does not work for classes that use inheritance with an empty base)\n\n2011-03-15  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/13954\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Look through memcpy\n\tand friends.\n\n\t* g++.dg/tree-ssa/pr13954.C: New testcase.\n\nFrom-SVN: r170994", "tree": {"sha": "871d4458a82b725b653f90b1c5ac68630aa4626f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/871d4458a82b725b653f90b1c5ac68630aa4626f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2ad5e3738bdf0c957dea0973400320995f185c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ad5e3738bdf0c957dea0973400320995f185c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ad5e3738bdf0c957dea0973400320995f185c5"}], "stats": {"total": 189, "additions": 183, "deletions": 6}, "files": [{"sha": "dc5f897ca74077fe5086ec209ca1e3f0253958d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "patch": "@@ -1,3 +1,9 @@\n+2011-03-15  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/13954\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Look through memcpy\n+\tand friends.\n+\n 2011-03-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48037"}, {"sha": "0257a77908ddf7ebcd0cadbee53dcafc3c1d2a61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "patch": "@@ -1,3 +1,8 @@\n+2011-03-15  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/13954\n+\t* g++.dg/tree-ssa/pr13954.C: New testcase.\n+\n 2011-03-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48037"}, {"sha": "169497a9c47b46bc84ecbc10bb5440e6827edd57", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr13954.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13954.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13954.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr13954.C?ref=c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+void link_error (void);\n+\n+class base\n+{\n+};\n+\n+class teststruct: public base\n+{\n+public:\n+  double d;\n+  char f1;\n+};\n+\n+void\n+copystruct1 (teststruct param)\n+{\n+  teststruct local;\n+  param.f1 = 0;\n+  local = param;\n+  if (local.f1 != 0)\n+    link_error ();\n+}\n+\n+/* There should be no reference to link_error. */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a346243020956d8895aa8b899572fd77811742b2", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 143, "deletions": 6, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ee7b4534f5730263f9d653d4c8d58c3ea02acf/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c7ee7b4534f5730263f9d653d4c8d58c3ea02acf", "patch": "@@ -1288,7 +1288,6 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n   gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n-  tree fndecl;\n   tree base;\n   HOST_WIDE_INT offset, maxsize;\n   static VEC (vn_reference_op_s, heap) *lhs_ops = NULL;\n@@ -1326,10 +1325,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n      from that defintion.\n      1) Memset.  */\n   if (is_gimple_reg_type (vr->type)\n-      && is_gimple_call (def_stmt)\n-      && (fndecl = gimple_call_fndecl (def_stmt))\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MEMSET\n+      && gimple_call_builtin_p (def_stmt, BUILT_IN_MEMSET)\n       && integer_zerop (gimple_call_arg (def_stmt, 1))\n       && host_integerp (gimple_call_arg (def_stmt, 2), 1)\n       && TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR)\n@@ -1379,7 +1375,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n \t}\n     }\n \n-  /* For aggregate copies translate the reference through them if\n+  /* 3) For aggregate copies translate the reference through them if\n      the copy kills ref.  */\n   else if (vn_walk_kind == VN_WALKREWRITE\n \t   && gimple_assign_single_p (def_stmt)\n@@ -1464,6 +1460,147 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n       return NULL;\n     }\n \n+  /* 4) For memcpy copies translate the reference through them if\n+     the copy kills ref.  */\n+  else if (vn_walk_kind == VN_WALKREWRITE\n+\t   && is_gimple_reg_type (vr->type)\n+\t   /* ???  Handle BCOPY as well.  */\n+\t   && (gimple_call_builtin_p (def_stmt, BUILT_IN_MEMCPY)\n+\t       || gimple_call_builtin_p (def_stmt, BUILT_IN_MEMPCPY)\n+\t       || gimple_call_builtin_p (def_stmt, BUILT_IN_MEMMOVE))\n+\t   && (TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR\n+\t       || TREE_CODE (gimple_call_arg (def_stmt, 0)) == SSA_NAME)\n+\t   && (TREE_CODE (gimple_call_arg (def_stmt, 1)) == ADDR_EXPR\n+\t       || TREE_CODE (gimple_call_arg (def_stmt, 1)) == SSA_NAME)\n+\t   && host_integerp (gimple_call_arg (def_stmt, 2), 1))\n+    {\n+      tree lhs, rhs;\n+      ao_ref r;\n+      HOST_WIDE_INT rhs_offset, copy_size, lhs_offset;\n+      vn_reference_op_s op;\n+      HOST_WIDE_INT at;\n+\n+\n+      /* Only handle non-variable, addressable refs.  */\n+      if (ref->size != maxsize\n+\t  || offset % BITS_PER_UNIT != 0\n+\t  || ref->size % BITS_PER_UNIT != 0)\n+\treturn (void *)-1;\n+\n+      /* Extract a pointer base and an offset for the destination.  */\n+      lhs = gimple_call_arg (def_stmt, 0);\n+      lhs_offset = 0;\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+\tlhs = SSA_VAL (lhs);\n+      if (TREE_CODE (lhs) == ADDR_EXPR)\n+\t{\n+\t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (lhs, 0),\n+\t\t\t\t\t\t    &lhs_offset);\n+\t  if (!tem)\n+\t    return (void *)-1;\n+\t  if (TREE_CODE (tem) == MEM_REF\n+\t      && host_integerp (TREE_OPERAND (tem, 1), 1))\n+\t    {\n+\t      lhs = TREE_OPERAND (tem, 0);\n+\t      lhs_offset += TREE_INT_CST_LOW (TREE_OPERAND (tem, 1));\n+\t    }\n+\t  else if (DECL_P (tem))\n+\t    lhs = build_fold_addr_expr (tem);\n+\t  else\n+\t    return (void *)-1;\n+\t}\n+      if (TREE_CODE (lhs) != SSA_NAME\n+\t  && TREE_CODE (lhs) != ADDR_EXPR)\n+\treturn (void *)-1;\n+\n+      /* Extract a pointer base and an offset for the source.  */\n+      rhs = gimple_call_arg (def_stmt, 1);\n+      rhs_offset = 0;\n+      if (TREE_CODE (rhs) == SSA_NAME)\n+\trhs = SSA_VAL (rhs);\n+      if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t{\n+\t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t\t    &rhs_offset);\n+\t  if (!tem)\n+\t    return (void *)-1;\n+\t  if (TREE_CODE (tem) == MEM_REF\n+\t      && host_integerp (TREE_OPERAND (tem, 1), 1))\n+\t    {\n+\t      rhs = TREE_OPERAND (tem, 0);\n+\t      rhs_offset += TREE_INT_CST_LOW (TREE_OPERAND (tem, 1));\n+\t    }\n+\t  else if (DECL_P (tem))\n+\t    rhs = build_fold_addr_expr (tem);\n+\t  else\n+\t    return (void *)-1;\n+\t}\n+      if (TREE_CODE (rhs) != SSA_NAME\n+\t  && TREE_CODE (rhs) != ADDR_EXPR)\n+\treturn (void *)-1;\n+\n+      copy_size = TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2));\n+\n+      /* The bases of the destination and the references have to agree.  */\n+      if ((TREE_CODE (base) != MEM_REF\n+\t   && !DECL_P (base))\n+\t  || (TREE_CODE (base) == MEM_REF\n+\t      && (TREE_OPERAND (base, 0) != lhs\n+\t\t  || !host_integerp (TREE_OPERAND (base, 1), 1)))\n+\t  || (DECL_P (base)\n+\t      && (TREE_CODE (lhs) != ADDR_EXPR\n+\t\t  || TREE_OPERAND (lhs, 0) != base)))\n+\treturn (void *)-1;\n+\n+      /* And the access has to be contained within the memcpy destination.  */\n+      at = offset / BITS_PER_UNIT;\n+      if (TREE_CODE (base) == MEM_REF)\n+\tat += TREE_INT_CST_LOW (TREE_OPERAND (base, 1));\n+      if (lhs_offset > at\n+\t  || lhs_offset + copy_size < at + maxsize / BITS_PER_UNIT)\n+\treturn (void *)-1;\n+\n+      /* Make room for 2 operands in the new reference.  */\n+      if (VEC_length (vn_reference_op_s, vr->operands) < 2)\n+\t{\n+\t  VEC (vn_reference_op_s, heap) *old = vr->operands;\n+\t  VEC_safe_grow (vn_reference_op_s, heap, vr->operands, 2);\n+\t  if (old == shared_lookup_references\n+\t      && vr->operands != old)\n+\t    shared_lookup_references = NULL;\n+\t}\n+      else\n+\tVEC_truncate (vn_reference_op_s, vr->operands, 2);\n+\n+      /* The looked-through reference is a simple MEM_REF.  */\n+      memset (&op, 0, sizeof (op));\n+      op.type = vr->type;\n+      op.opcode = MEM_REF;\n+      op.op0 = build_int_cst (ptr_type_node, at - rhs_offset);\n+      op.off = at - lhs_offset + rhs_offset;\n+      VEC_replace (vn_reference_op_s, vr->operands, 0, &op);\n+      op.type = TYPE_MAIN_VARIANT (TREE_TYPE (rhs));\n+      op.opcode = TREE_CODE (rhs);\n+      op.op0 = rhs;\n+      op.off = -1;\n+      VEC_replace (vn_reference_op_s, vr->operands, 1, &op);\n+      vr->hashcode = vn_reference_compute_hash (vr);\n+\n+      /* Adjust *ref from the new operands.  */\n+      if (!ao_ref_init_from_vn_reference (&r, vr->set, vr->type, vr->operands))\n+\treturn (void *)-1;\n+      /* This can happen with bitfields.  */\n+      if (ref->size != r.size)\n+\treturn (void *)-1;\n+      *ref = r;\n+\n+      /* Do not update last seen VUSE after translating.  */\n+      last_vuse_ptr = NULL;\n+\n+      /* Keep looking for the adjusted *REF / VR pair.  */\n+      return NULL;\n+    }\n+\n   /* Bail out and stop walking.  */\n   return (void *)-1;\n }"}]}