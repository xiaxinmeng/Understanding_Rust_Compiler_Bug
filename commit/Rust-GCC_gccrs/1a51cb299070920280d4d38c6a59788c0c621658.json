{"sha": "1a51cb299070920280d4d38c6a59788c0c621658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1MWNiMjk5MDcwOTIwMjgwZDRkMzhjNmE1OTc4OGMwYzYyMTY1OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-04T21:26:58Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-05T06:06:17Z"}, "message": "libcc1: share GDB plugin code\n\nThe two GDB plugins in libcc1 share a fair amount of code.  This was\ndone by copy-and-paste, though in reality the underlying code is\nnearly identical.\n\nlibcc1\n\n\t* libcp1.cc (struct libcp1): Derive from base_gdb_plugin.  Remove\n\tshared code.\n\t(class libcp1_connection): Remove.\n\t(rpc): Remove.\n\t(libcp1_set_verbose, libcp1_compile): Update.\n\t(cp_call_binding_oracle, cp_call_symbol_address)\n\t(cp_call_enter_scope, cp_call_leave_scope): Update.\n\t* libcc1.cc (struct libcc1): Derive from base_gdb_plugin.  Remove\n\tshared code.\n\t(class libcc1_connection): Remove.\n\t(c_call_binding_oracle, c_call_symbol_address): Update.\n\t(rpc): Remove.\n\t(libcc1_set_verbose, libcc1_compile): Update.\n\t* gdbctx.hh: New file.", "tree": {"sha": "120bb198598925cb02ed976d8958aaa886b9028f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120bb198598925cb02ed976d8958aaa886b9028f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a51cb299070920280d4d38c6a59788c0c621658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a51cb299070920280d4d38c6a59788c0c621658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a51cb299070920280d4d38c6a59788c0c621658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a51cb299070920280d4d38c6a59788c0c621658/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0624823260f953050447a909da87f031488dba13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0624823260f953050447a909da87f031488dba13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0624823260f953050447a909da87f031488dba13"}], "stats": {"total": 323, "additions": 145, "deletions": 178}, "files": [{"sha": "1c8d87dff021288cc66a53fbbcf6f9745f34bfa9", "filename": "libcc1/gdbctx.hh", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Fgdbctx.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Fgdbctx.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fgdbctx.hh?ref=1a51cb299070920280d4d38c6a59788c0c621658", "patch": "@@ -0,0 +1,105 @@\n+/* Generic GDB-side plugin\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CC1_PLUGIN_GDBCTX_HH\n+#define CC1_PLUGIN_GDBCTX_HH\n+\n+namespace cc1_plugin\n+{\n+  // The compiler context that we hand back to our caller.\n+  template<typename T>\n+  struct base_gdb_plugin : public T\n+  {\n+    explicit base_gdb_plugin (const gcc_base_vtable *v)\n+      : verbose (false),\n+\tcompilerp (new compiler (verbose))\n+    {\n+      this->base.ops = v;\n+    }\n+\n+    // A convenience function to print something.\n+    void print (const char *str)\n+    {\n+      this->print_function (this->print_datum, str);\n+    }\n+\n+    // Set the verbose flag.\n+    void set_verbose (bool v)\n+    {\n+      verbose = v;\n+      if (compilerp != nullptr)\n+\tcompilerp->set_verbose (v);\n+    }\n+\n+    // Make a new connection.\n+    void set_connection (int fd, int aux_fd)\n+    {\n+      connection.reset (new local_connection (fd, aux_fd, this));\n+    }\n+\n+    // A local subclass of connection that holds a back-pointer to the\n+    // context object that we provide to our caller.\n+    class local_connection : public cc1_plugin::connection\n+    {\n+    public:\n+\n+      local_connection (int fd, int aux_fd, base_gdb_plugin<T> *b)\n+\t: connection (fd, aux_fd),\n+\t  back_ptr (b)\n+      {\n+      }\n+\n+      void print (const char *buf) override\n+      {\n+\tback_ptr->print (buf);\n+      }\n+\n+      base_gdb_plugin<T> *back_ptr;\n+    };\n+\n+    std::unique_ptr<local_connection> connection;\n+\n+    void (*print_function) (void *datum, const char *message) = nullptr;\n+    void *print_datum = nullptr;\n+\n+    std::vector<std::string> args;\n+    std::string source_file;\n+\n+    /* Non-zero as an equivalent to gcc driver option \"-v\".  */\n+    bool verbose;\n+\n+    std::unique_ptr<cc1_plugin::compiler> compilerp;\n+  };\n+\n+  // Instances of this rpc<> template function are installed into the\n+  // \"vtable\"s.  These functions are parameterized by type and method\n+  // name and forward the call via the connection.\n+  template<typename CTX, typename R, const char *&NAME, typename... Arg>\n+  R rpc (CTX *s, Arg... rest)\n+  {\n+    base_gdb_plugin<CTX> *self = (base_gdb_plugin<CTX> *) s;\n+    R result;\n+    \n+    if (!cc1_plugin::call (self->connection.get (), NAME, &result, rest...))\n+      return 0;\n+    return result;\n+  }\n+}\n+\n+#endif // CC1_PLUGIN_GDBCTX_HH"}, {"sha": "b9f1eb343aaf822d73821026e3f1d055c9b4150d", "filename": "libcc1/libcc1.cc", "status": "modified", "additions": 18, "deletions": 87, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Flibcc1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Flibcc1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1.cc?ref=1a51cb299070920280d4d38c6a59788c0c621658", "patch": "@@ -37,73 +37,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"compiler-name.hh\"\n #include \"gcc-c-interface.h\"\n #include \"compiler.hh\"\n-\n-struct libcc1;\n-\n-class libcc1_connection;\n+#include \"gdbctx.hh\"\n \n // The C compiler context that we hand back to our caller.\n-struct libcc1 : public gcc_c_context\n+struct libcc1 : public cc1_plugin::base_gdb_plugin<gcc_c_context>\n {\n   libcc1 (const gcc_base_vtable *, const gcc_c_fe_vtable *);\n \n-  // A convenience function to print something.\n-  void print (const char *str)\n-  {\n-    this->print_function (this->print_datum, str);\n-  }\n-\n-  std::unique_ptr<libcc1_connection> connection;\n-\n-  gcc_c_oracle_function *binding_oracle;\n-  gcc_c_symbol_address_function *address_oracle;\n-  void *oracle_datum;\n-\n-  void (*print_function) (void *datum, const char *message);\n-  void *print_datum;\n-\n-  std::vector<std::string> args;\n-  std::string source_file;\n-\n-  /* Non-zero as an equivalent to gcc driver option \"-v\".  */\n-  bool verbose;\n-\n-  std::unique_ptr<cc1_plugin::compiler> compilerp;\n+  gcc_c_oracle_function *binding_oracle = nullptr;\n+  gcc_c_symbol_address_function *address_oracle = nullptr;\n+  void *oracle_datum = nullptr;\n };\n \n-// A local subclass of connection that holds a back-pointer to the\n-// gcc_c_context object that we provide to our caller.\n-class libcc1_connection : public cc1_plugin::connection\n+libcc1::libcc1 (const gcc_base_vtable *v, const gcc_c_fe_vtable *cv)\n+  : cc1_plugin::base_gdb_plugin<gcc_c_context> (v)\n {\n-public:\n-\n-  libcc1_connection (int fd, int aux_fd, libcc1 *b)\n-    : connection (fd, aux_fd),\n-      back_ptr (b)\n-  {\n-  }\n-\n-  void print (const char *buf) override\n-  {\n-    back_ptr->print (buf);\n-  }\n-\n-  libcc1 *back_ptr;\n-};\n-\n-libcc1::libcc1 (const gcc_base_vtable *v,\n-\t\tconst gcc_c_fe_vtable *cv)\n-  : binding_oracle (NULL),\n-    address_oracle (NULL),\n-    oracle_datum (NULL),\n-    print_function (NULL),\n-    print_datum (NULL),\n-    args (),\n-    source_file (),\n-    verbose (false),\n-    compilerp (new cc1_plugin::compiler (verbose))\n-{\n-  base.ops = v;\n   c_ops = cv;\n }\n \n@@ -122,7 +70,7 @@ namespace {\n \t\t\t enum gcc_c_oracle_request request,\n \t\t\t const char *identifier)\n   {\n-    libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n+    libcc1 *self = (libcc1 *) (((libcc1::local_connection *) conn)->back_ptr);\n \n     self->binding_oracle (self->oracle_datum, self, request, identifier);\n     return 1;\n@@ -133,7 +81,7 @@ namespace {\n   gcc_address\n   c_call_symbol_address (cc1_plugin::connection *conn, const char *identifier)\n   {\n-    libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n+    libcc1 *self = (libcc1 *) (((libcc1::local_connection *) conn)->back_ptr);\n \n     return self->address_oracle (self->oracle_datum, self, identifier);\n   }\n@@ -154,40 +102,25 @@ set_callbacks (struct gcc_c_context *s,\n   self->oracle_datum = datum;\n }\n \n-// Instances of this rpc<> template function are installed into the\n-// \"c_vtable\".  These functions are parameterized by type and method\n-// name and forward the call via the connection.\n-\n-template<typename R, const char *&NAME, typename... Arg>\n-R rpc (struct gcc_c_context *s, Arg... rest)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-  R result;\n-\n-  if (!cc1_plugin::call (self->connection.get (), NAME, &result, rest...))\n-    return 0;\n-  return result;\n-}\n-\n static const struct gcc_c_fe_vtable c_vtable =\n {\n   GCC_C_FE_VERSION_0,\n   set_callbacks,\n \n #define GCC_METHOD0(R, N) \\\n-  rpc<R, cc1_plugin::c::N>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N>,\n #define GCC_METHOD1(R, N, A) \\\n-  rpc<R, cc1_plugin::c::N, A>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A>,\n #define GCC_METHOD2(R, N, A, B) \\\n-  rpc<R, cc1_plugin::c::N, A, B>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A, B>,\n #define GCC_METHOD3(R, N, A, B, C) \\\n-  rpc<R, cc1_plugin::c::N, A, B, C>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A, B, C>,\n #define GCC_METHOD4(R, N, A, B, C, D) \\\n-  rpc<R, cc1_plugin::c::N, A, B, C, D>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A, B, C, D>,\n #define GCC_METHOD5(R, N, A, B, C, D, E) \\\n-  rpc<R, cc1_plugin::c::N, A, B, C, D, E>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A, B, C, D, E>,\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n-  rpc<R, cc1_plugin::c::N, A, B, C, D, E, F, G>,\n+  cc1_plugin::rpc<gcc_c_context, R, cc1_plugin::c::N, A, B, C, D, E, F, G>,\n \n #include \"gcc-c-fe.def\"\n \n@@ -207,9 +140,7 @@ libcc1_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n {\n   libcc1 *self = (libcc1 *) s;\n \n-  self->verbose = verbose != 0;\n-  if (self->compilerp != nullptr)\n-    self->compilerp->set_verbose (self->verbose);\n+  self->set_verbose (verbose != 0);\n }\n \n static char *\n@@ -386,7 +317,7 @@ libcc1_compile (struct gcc_base_context *s,\n   if (self->verbose)\n     self->args.push_back (\"-v\");\n \n-  self->connection.reset (new libcc1_connection (fds[0], stderr_fds[0], self));\n+  self->set_connection (fds[0], stderr_fds[0]);\n \n   cc1_plugin::callback_ftype *fun\n     = cc1_plugin::callback<int,"}, {"sha": "6fb9fb4c9a6c80db324c8224da6889f5ccc448ae", "filename": "libcc1/libcp1.cc", "status": "modified", "additions": 22, "deletions": 91, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Flibcp1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a51cb299070920280d4d38c6a59788c0c621658/libcc1%2Flibcp1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1.cc?ref=1a51cb299070920280d4d38c6a59788c0c621658", "patch": "@@ -36,75 +36,23 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libiberty.h\"\n #include \"compiler-name.hh\"\n #include \"compiler.hh\"\n-\n-struct libcp1;\n-\n-class libcp1_connection;\n+#include \"gdbctx.hh\"\n \n // The C compiler context that we hand back to our caller.\n-struct libcp1 : public gcc_cp_context\n+struct libcp1 : public cc1_plugin::base_gdb_plugin<gcc_cp_context>\n {\n   libcp1 (const gcc_base_vtable *, const gcc_cp_fe_vtable *);\n \n-  // A convenience function to print something.\n-  void print (const char *str)\n-  {\n-    this->print_function (this->print_datum, str);\n-  }\n-\n-  std::unique_ptr<libcp1_connection> connection;\n-\n-  gcc_cp_oracle_function *binding_oracle;\n-  gcc_cp_symbol_address_function *address_oracle;\n-  gcc_cp_enter_leave_user_expr_scope_function *enter_scope;\n-  gcc_cp_enter_leave_user_expr_scope_function *leave_scope;\n-  void *oracle_datum;\n-\n-  void (*print_function) (void *datum, const char *message);\n-  void *print_datum;\n-\n-  std::vector<std::string> args;\n-  std::string source_file;\n-\n-  /* Non-zero as an equivalent to gcc driver option \"-v\".  */\n-  bool verbose;\n-\n-  std::unique_ptr<cc1_plugin::compiler> compilerp;\n+  gcc_cp_oracle_function *binding_oracle = nullptr;\n+  gcc_cp_symbol_address_function *address_oracle = nullptr;\n+  gcc_cp_enter_leave_user_expr_scope_function *enter_scope = nullptr;\n+  gcc_cp_enter_leave_user_expr_scope_function *leave_scope = nullptr;\n+  void *oracle_datum = nullptr;\n };\n \n-// A local subclass of connection that holds a back-pointer to the\n-// gcc_c_context object that we provide to our caller.\n-class libcp1_connection : public cc1_plugin::connection\n+libcp1::libcp1 (const gcc_base_vtable *v, const gcc_cp_fe_vtable *cv)\n+  : cc1_plugin::base_gdb_plugin<gcc_cp_context> (v)\n {\n-public:\n-\n-  libcp1_connection (int fd, int aux_fd, libcp1 *b)\n-    : connection (fd, aux_fd),\n-      back_ptr (b)\n-  {\n-  }\n-\n-  void print (const char *buf) override\n-  {\n-    back_ptr->print (buf);\n-  }\n-\n-  libcp1 *back_ptr;\n-};\n-\n-libcp1::libcp1 (const gcc_base_vtable *v,\n-\t\t  const gcc_cp_fe_vtable *cv)\n-  : binding_oracle (NULL),\n-    address_oracle (NULL),\n-    oracle_datum (NULL),\n-    print_function (NULL),\n-    print_datum (NULL),\n-    args (),\n-    source_file (),\n-    verbose (false),\n-    compilerp (new cc1_plugin::compiler (verbose))\n-{\n-  base.ops = v;\n   cp_ops = cv;\n }\n \n@@ -123,7 +71,7 @@ namespace {\n \t\t       enum gcc_cp_oracle_request request,\n \t\t       const char *identifier)\n   {\n-    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+    libcp1 *self = (libcp1 *) (((libcp1::local_connection *) conn)->back_ptr);\n \n     self->binding_oracle (self->oracle_datum, self, request, identifier);\n     return 1;\n@@ -134,15 +82,15 @@ namespace {\n   gcc_address\n   cp_call_symbol_address (cc1_plugin::connection *conn, const char *identifier)\n   {\n-    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+    libcp1 *self = (libcp1 *) (((libcp1::local_connection *) conn)->back_ptr);\n \n     return self->address_oracle (self->oracle_datum, self, identifier);\n   }\n \n   int\n   cp_call_enter_scope (cc1_plugin::connection *conn)\n   {\n-    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+    libcp1 *self = (libcp1 *) (((libcp1::local_connection *) conn)->back_ptr);\n \n     self->enter_scope (self->oracle_datum, self);\n     return 1;\n@@ -151,7 +99,7 @@ namespace {\n   int\n   cp_call_leave_scope (cc1_plugin::connection *conn)\n   {\n-    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+    libcp1 *self = (libcp1 *) (((libcp1::local_connection *) conn)->back_ptr);\n \n     self->leave_scope (self->oracle_datum, self);\n     return 1;\n@@ -177,40 +125,25 @@ set_callbacks (struct gcc_cp_context *s,\n   self->oracle_datum = datum;\n }\n \n-// Instances of this rpc<> template function are installed into the\n-// \"cp_vtable\".  These functions are parameterized by type and method\n-// name and forward the call via the connection.\n-\n-template<typename R, const char *&NAME, typename... Arg>\n-R rpc (struct gcc_cp_context *s, Arg... rest)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-  R result;\n-\n-  if (!cc1_plugin::call (self->connection.get (), NAME, &result, rest...))\n-    return 0;\n-  return result;\n-}\n-\n static const struct gcc_cp_fe_vtable cp_vtable =\n {\n   GCC_CP_FE_VERSION_0,\n   set_callbacks,\n \n #define GCC_METHOD0(R, N) \\\n-  rpc<R, cc1_plugin::cp::N>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N>,\n #define GCC_METHOD1(R, N, A) \\\n-  rpc<R, cc1_plugin::cp::N, A>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A>,\n #define GCC_METHOD2(R, N, A, B) \\\n-  rpc<R, cc1_plugin::cp::N, A, B>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A, B>,\n #define GCC_METHOD3(R, N, A, B, C) \\\n-  rpc<R, cc1_plugin::cp::N, A, B, C>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A, B, C>,\n #define GCC_METHOD4(R, N, A, B, C, D) \\\n-  rpc<R, cc1_plugin::cp::N, A, B, C, D>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A, B, C, D>,\n #define GCC_METHOD5(R, N, A, B, C, D, E) \\\n-  rpc<R, cc1_plugin::cp::N, A, B, C, D, E>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A, B, C, D, E>,\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n-  rpc<R, cc1_plugin::cp::N, A, B, C, D, E, F, G>,\n+  cc1_plugin::rpc<gcc_cp_context, R, cc1_plugin::cp::N, A, B, C, D, E, F, G>,\n \n #include \"gcc-cp-fe.def\"\n \n@@ -230,9 +163,7 @@ libcp1_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n {\n   libcp1 *self = (libcp1 *) s;\n \n-  self->verbose = verbose != 0;\n-  if (self->compilerp != nullptr)\n-    self->compilerp->set_verbose (self->verbose);\n+  self->set_verbose (verbose != 0);\n }\n \n static char *\n@@ -409,7 +340,7 @@ libcp1_compile (struct gcc_base_context *s,\n   if (self->verbose)\n     self->args.push_back (\"-v\");\n \n-  self->connection.reset (new libcp1_connection (fds[0], stderr_fds[0], self));\n+  self->set_connection (fds[0], stderr_fds[0]);\n \n   cc1_plugin::callback_ftype *fun\n     = cc1_plugin::callback<int,"}]}