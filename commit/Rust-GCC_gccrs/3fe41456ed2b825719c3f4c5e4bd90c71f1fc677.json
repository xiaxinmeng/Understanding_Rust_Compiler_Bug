{"sha": "3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlNDE0NTZlZDJiODI1NzE5YzNmNGM1ZTRiZDkwYzcxZjFmYzY3Nw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-17T15:28:05Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-17T15:28:05Z"}, "message": "ggc-common.c: PROTO -> PARAMS.\n\n        * ggc-common.c: PROTO -> PARAMS.\n        * ggc-page.c: Likewise.\n        * ggc-simple.c: Likewise.\n        * ggc.h: Likewise.\n        * global.c: Likewise.\n        * graph.c: Likewise.\n        * gthr-win32.h: Likewise.\n        * haifa-sched.c: Likewise.\n        * halfpic.h: Likewise.\n        * integrate.c: Likewise.\n        * integrate.h: Likewise.\n        * jump.c: Likewise.\n        * lcm.c: Likewise.\n        * local-alloc.c: Likewise.\n        * loop.c: Likewise.\n        * loop.h: Likewise.\n\nFrom-SVN: r31458", "tree": {"sha": "7858a169a40f096f95d32ca31da195365adcf856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7858a169a40f096f95d32ca31da195365adcf856"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/comments", "author": null, "committer": null, "parents": [{"sha": "a94ae8f5dd6e7b921a0169c0471d6a38d49cdca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94ae8f5dd6e7b921a0169c0471d6a38d49cdca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94ae8f5dd6e7b921a0169c0471d6a38d49cdca9"}], "stats": {"total": 677, "additions": 348, "deletions": 329}, "files": [{"sha": "3e27e91cc426711bc7483cb0c2a086a11d1f7fea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -1,3 +1,22 @@\n+2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ggc-common.c: PROTO -> PARAMS.\n+\t* ggc-page.c: Likewise.\n+\t* ggc-simple.c: Likewise.\n+\t* ggc.h: Likewise.\n+\t* global.c: Likewise.\n+\t* graph.c: Likewise.\n+\t* gthr-win32.h: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* halfpic.h: Likewise.\n+\t* integrate.c: Likewise.\n+\t* integrate.h: Likewise.\n+\t* jump.c: Likewise.\n+\t* lcm.c: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* loop.h: Likewise.\n+\n 2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* genattr.c: PROTO -> PARAMS."}, {"sha": "7691926d43ef8a0536c73019c2c5093a92dfd7d7", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -51,7 +51,7 @@ struct ggc_root\n   void *base;\n   int nelt;\n   int size;\n-  void (*cb) PROTO ((void *));\n+  void (*cb) PARAMS ((void *));\n };\n \n static struct ggc_root *roots;\n@@ -117,7 +117,7 @@ void\n ggc_add_root (base, nelt, size, cb)\n      void *base;\n      int nelt, size;\n-     void (*cb) PROTO ((void *));\n+     void (*cb) PARAMS ((void *));\n {\n   struct ggc_root *x = (struct ggc_root *) xmalloc (sizeof (*x));\n \n@@ -217,7 +217,7 @@ ggc_mark_roots ()\n     {\n       char *elt = x->base;\n       int s = x->size, n = x->nelt;\n-      void (*cb) PROTO ((void *)) = x->cb;\n+      void (*cb) PARAMS ((void *)) = x->cb;\n       int i;\n \n       for (i = 0; i < n; ++i, elt += s)"}, {"sha": "f05d93af02f6e0f940e0d6f053509be407bda16f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -266,22 +266,22 @@ static struct globals\n #define GGC_MIN_LAST_ALLOCATED (4 * 1024 * 1024)\n \n \f\n-static int ggc_allocated_p PROTO ((const void *));\n-static page_entry *lookup_page_table_entry PROTO ((const void *));\n-static void set_page_table_entry PROTO ((void *, page_entry *));\n-static char *alloc_anon PROTO ((char *, size_t));\n-static struct page_entry * alloc_page PROTO ((unsigned));\n-static void free_page PROTO ((struct page_entry *));\n-static void release_pages PROTO ((void));\n-static void clear_marks PROTO ((void));\n-static void sweep_pages PROTO ((void));\n-static void ggc_recalculate_in_use_p PROTO ((page_entry *));\n+static int ggc_allocated_p PARAMS ((const void *));\n+static page_entry *lookup_page_table_entry PARAMS ((const void *));\n+static void set_page_table_entry PARAMS ((void *, page_entry *));\n+static char *alloc_anon PARAMS ((char *, size_t));\n+static struct page_entry * alloc_page PARAMS ((unsigned));\n+static void free_page PARAMS ((struct page_entry *));\n+static void release_pages PARAMS ((void));\n+static void clear_marks PARAMS ((void));\n+static void sweep_pages PARAMS ((void));\n+static void ggc_recalculate_in_use_p PARAMS ((page_entry *));\n \n #ifdef GGC_POISON\n-static void poison_pages PROTO ((void));\n+static void poison_pages PARAMS ((void));\n #endif\n \n-void debug_print_page_list PROTO ((int));\n+void debug_print_page_list PARAMS ((int));\n \f\n /* Returns non-zero if P was allocated in GC'able memory.  */\n "}, {"sha": "ea8544e7a13cae7f49d49d7c2d8c7f3528cf4928", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -135,15 +135,15 @@ static struct globals\n \n /* Local function prototypes.  */\n \n-static void tree_insert PROTO ((struct ggc_mem *));\n-static int tree_lookup PROTO ((struct ggc_mem *));\n-static void clear_marks PROTO ((struct ggc_mem *));\n-static void sweep_objs PROTO ((struct ggc_mem **));\n-static void ggc_pop_context_1 PROTO ((struct ggc_mem *, int));\n+static void tree_insert PARAMS ((struct ggc_mem *));\n+static int tree_lookup PARAMS ((struct ggc_mem *));\n+static void clear_marks PARAMS ((struct ggc_mem *));\n+static void sweep_objs PARAMS ((struct ggc_mem **));\n+static void ggc_pop_context_1 PARAMS ((struct ggc_mem *, int));\n \n #ifdef GGC_BALANCE\n-extern void debug_ggc_balance PROTO ((void));\n-static void tally_leaves PROTO ((struct ggc_mem *, int, size_t *, size_t *));\n+extern void debug_ggc_balance PARAMS ((void));\n+static void tally_leaves PARAMS ((struct ggc_mem *, int, size_t *, size_t *));\n #endif\n \n /* Insert V into the search tree.  */"}, {"sha": "8ddae2b5667d0b8df1c58e40aac152137b0b2c7e", "filename": "gcc/ggc.h", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -46,23 +46,23 @@ struct varray_head_tag;\n extern char *empty_string;\n \n /* Manipulate global roots that are needed between calls to gc.  */\n-void ggc_add_root PROTO ((void *base, int nelt, int size, void (*)(void *)));\n-void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n-void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n-void ggc_add_string_root PROTO ((char **, int nelt));\n-void ggc_add_tree_varray_root PROTO ((struct varray_head_tag **, int nelt));\n-void ggc_add_tree_hash_table_root PROTO ((struct hash_table **, int nelt));\n-void ggc_del_root PROTO ((void *base));\n+void ggc_add_root PARAMS ((void *base, int nelt, int size, void (*)(void *)));\n+void ggc_add_rtx_root PARAMS ((struct rtx_def **, int nelt));\n+void ggc_add_tree_root PARAMS ((union tree_node **, int nelt));\n+void ggc_add_string_root PARAMS ((char **, int nelt));\n+void ggc_add_tree_varray_root PARAMS ((struct varray_head_tag **, int nelt));\n+void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **, int nelt));\n+void ggc_del_root PARAMS ((void *base));\n \n /* Mark nodes from the gc_add_root callback.  These functions follow\n    pointers to mark other objects too.  */\n-extern void ggc_mark_tree_varray PROTO ((struct varray_head_tag *));\n-extern void ggc_mark_tree_hash_table PROTO ((struct hash_table *));\n-extern void ggc_mark_roots PROTO((void));\n+extern void ggc_mark_tree_varray PARAMS ((struct varray_head_tag *));\n+extern void ggc_mark_tree_hash_table PARAMS ((struct hash_table *));\n+extern void ggc_mark_roots PARAMS ((void));\n \n-extern void ggc_mark_rtx_children PROTO ((struct rtx_def *));\n-extern void ggc_mark_rtvec_children PROTO ((struct rtvec_def *));\n-extern void ggc_mark_tree_children PROTO ((union tree_node *));\n+extern void ggc_mark_rtx_children PARAMS ((struct rtx_def *));\n+extern void ggc_mark_rtvec_children PARAMS ((struct rtvec_def *));\n+extern void ggc_mark_tree_children PARAMS ((union tree_node *));\n \n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n@@ -105,25 +105,25 @@ extern void ggc_mark_tree_children PROTO ((union tree_node *));\n   } while (0)\n \n /* Mark, but only if it was allocated in collectable memory.  */\n-extern void ggc_mark_if_gcable PROTO ((void *));\n+extern void ggc_mark_if_gcable PARAMS ((void *));\n \n /* A GC implementation must provide these functions.  */\n \n /* Initialize the garbage collector.   */\n-extern void init_ggc PROTO ((void));\n+extern void init_ggc PARAMS ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n-extern void ggc_push_context PROTO ((void));\n+extern void ggc_push_context PARAMS ((void));\n \n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n-extern void ggc_pop_context PROTO ((void));\n+extern void ggc_pop_context PARAMS ((void));\n \n /* Allocation.  */\n \n /* The internal primitive.  */\n-void *ggc_alloc_obj PROTO ((size_t, int));\n+void *ggc_alloc_obj PARAMS ((size_t, int));\n \n #define ggc_alloc_rtx(NSLOTS)\t\t\t\t\t\t     \\\n   ((struct rtx_def *) ggc_alloc_obj (sizeof (struct rtx_def)\t\t     \\\n@@ -138,38 +138,38 @@ void *ggc_alloc_obj PROTO ((size_t, int));\n \n #define ggc_alloc(SIZE)  ggc_alloc_obj((SIZE), 0)\n \n-char *ggc_alloc_string PROTO ((const char *contents, int length));\n+char *ggc_alloc_string PARAMS ((const char *contents, int length));\n \n /* Invoke the collector.  This is really just a hint, but in the case of\n    the simple collector, the only time it will happen.  */\n-void ggc_collect PROTO ((void));\n+void ggc_collect PARAMS ((void));\n \n /* Actually set the mark on a particular region of memory, but don't\n    follow pointers.  This function is called by ggc_mark_*.  It\n    returns zero if the object was not previously marked; non-zero if\n    the object was already marked, or if, for any other reason,\n    pointers in this data structure should not be traversed.  */\n-int ggc_set_mark PROTO ((void *));\n+int ggc_set_mark PARAMS ((void *));\n \n /* Callbacks to the languages.  */\n \n /* This is the language's opportunity to mark nodes held through\n    the lang_specific hooks in the tree.  */\n-void lang_mark_tree PROTO ((union tree_node *));\n+void lang_mark_tree PARAMS ((union tree_node *));\n \n /* The FALSE_LABEL_STACK, declared in except.h, has\n    language-dependent semantics.  Each front-end should define this\n    function appropriately.  */\n-void lang_mark_false_label_stack PROTO ((struct label_node *));\n+void lang_mark_false_label_stack PARAMS ((struct label_node *));\n \n /* Mark functions for various structs scattered about.  */\n \n-void mark_eh_status PROTO ((struct eh_status *));\n-void mark_emit_status PROTO ((struct emit_status *));\n-void mark_expr_status PROTO ((struct expr_status *));\n-void mark_stmt_status PROTO ((struct stmt_status *));\n-void mark_varasm_status PROTO ((struct varasm_status *));\n-void mark_optab PROTO ((void *));\n+void mark_eh_status PARAMS ((struct eh_status *));\n+void mark_emit_status PARAMS ((struct emit_status *));\n+void mark_expr_status PARAMS ((struct expr_status *));\n+void mark_stmt_status PARAMS ((struct stmt_status *));\n+void mark_varasm_status PARAMS ((struct varasm_status *));\n+void mark_optab PARAMS ((void *));\n \n /* Statistics.  */\n \n@@ -198,8 +198,8 @@ typedef struct ggc_statistics\n } ggc_statistics;\n \n /* Return the number of bytes allocated at the indicated address.  */\n-size_t ggc_get_size PROTO ((void *));\n+size_t ggc_get_size PARAMS ((void *));\n \n /* Used by the various collectors to gather and print statistics that\n    do not depend on the collector in use.  */\n-void ggc_print_statistics PROTO ((FILE *, ggc_statistics *));\n+void ggc_print_statistics PARAMS ((FILE *, ggc_statistics *));"}, {"sha": "4e0bed35822f7faac317c0be005a293081bd7622", "filename": "gcc/global.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -287,25 +287,25 @@ static int n_regs_set;\n \n static HARD_REG_SET eliminable_regset;\n \n-static int allocno_compare\tPROTO((const PTR, const PTR));\n-static void global_conflicts\tPROTO((void));\n-static void mirror_conflicts\tPROTO((void));\n-static void expand_preferences\tPROTO((void));\n-static void prune_preferences\tPROTO((void));\n-static void find_reg\t\tPROTO((int, HARD_REG_SET, int, int, int));\n-static void record_one_conflict PROTO((int));\n-static void record_conflicts\tPROTO((int *, int));\n-static void mark_reg_store\tPROTO((rtx, rtx, void *));\n-static void mark_reg_clobber\tPROTO((rtx, rtx, void *));\n-static void mark_reg_conflicts\tPROTO((rtx));\n-static void mark_reg_death\tPROTO((rtx));\n-static void mark_reg_live_nc\tPROTO((int, enum machine_mode));\n-static void set_preference\tPROTO((rtx, rtx));\n-static void dump_conflicts\tPROTO((FILE *));\n-static void reg_becomes_live\tPROTO((rtx, rtx, void *));\n-static void reg_dies\t\tPROTO((int, enum machine_mode,\n+static int allocno_compare\tPARAMS ((const PTR, const PTR));\n+static void global_conflicts\tPARAMS ((void));\n+static void mirror_conflicts\tPARAMS ((void));\n+static void expand_preferences\tPARAMS ((void));\n+static void prune_preferences\tPARAMS ((void));\n+static void find_reg\t\tPARAMS ((int, HARD_REG_SET, int, int, int));\n+static void record_one_conflict PARAMS ((int));\n+static void record_conflicts\tPARAMS ((int *, int));\n+static void mark_reg_store\tPARAMS ((rtx, rtx, void *));\n+static void mark_reg_clobber\tPARAMS ((rtx, rtx, void *));\n+static void mark_reg_conflicts\tPARAMS ((rtx));\n+static void mark_reg_death\tPARAMS ((rtx));\n+static void mark_reg_live_nc\tPARAMS ((int, enum machine_mode));\n+static void set_preference\tPARAMS ((rtx, rtx));\n+static void dump_conflicts\tPARAMS ((FILE *));\n+static void reg_becomes_live\tPARAMS ((rtx, rtx, void *));\n+static void reg_dies\t\tPARAMS ((int, enum machine_mode,\n \t\t\t\t       struct insn_chain *));\n-static void build_insn_chain\tPROTO((rtx));\n+static void build_insn_chain\tPARAMS ((rtx));\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,"}, {"sha": "f40b0dd91ee8cdbfaf6a4d09ea137e5cffa2d24b", "filename": "gcc/graph.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -37,12 +37,12 @@ static const char *graph_ext[] =\n   /* vcg */      \".vcg\",\n };\n \n-static void start_fct PROTO ((FILE *));\n-static void start_bb PROTO ((FILE *, int));\n-static void node_data PROTO ((FILE *, rtx));\n-static void draw_edge PROTO ((FILE *, int, int, int, int));\n-static void end_fct PROTO ((FILE *));\n-static void end_bb PROTO ((FILE *));\n+static void start_fct PARAMS ((FILE *));\n+static void start_bb PARAMS ((FILE *, int));\n+static void node_data PARAMS ((FILE *, rtx));\n+static void draw_edge PARAMS ((FILE *, int, int, int, int));\n+static void end_fct PARAMS ((FILE *));\n+static void end_bb PARAMS ((FILE *));\n \n /* Output text for new basic block.  */\n static void"}, {"sha": "31b4779873bb91edc7259456edfa7d8d584e89fe", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -85,7 +85,7 @@ typedef HANDLE __gthread_mutex_t;\n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n #define MINGW32_SUPPORTS_MT_EH 1\n-extern int __mingwthr_key_dtor PROTO((DWORD, void (*) (void *)));\n+extern int __mingwthr_key_dtor PARAMS ((DWORD, void (*) (void *)));\n /* Mingw runtime >= v0.3 provides a magic variable that is set to non-zero\n    if -mthreads option was specified, or 0 otherwise. This is to get around \n    the lack of weak symbols in PE-COFF.  */"}, {"sha": "b2ff9d6dbf52669aa0bb642ae99f88fc284ffb86", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -464,37 +464,37 @@ static int q_size = 0;\n #define NEXT_Q_AFTER(X, C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n \n /* Forward declarations.  */\n-static void add_dependence PROTO ((rtx, rtx, enum reg_note));\n+static void add_dependence PARAMS ((rtx, rtx, enum reg_note));\n #ifdef HAVE_cc0\n-static void remove_dependence PROTO ((rtx, rtx));\n+static void remove_dependence PARAMS ((rtx, rtx));\n #endif\n-static rtx find_insn_list PROTO ((rtx, rtx));\n-static int insn_unit PROTO ((rtx));\n-static unsigned int blockage_range PROTO ((int, rtx));\n-static void clear_units PROTO ((void));\n-static int actual_hazard_this_instance PROTO ((int, int, rtx, int, int));\n-static void schedule_unit PROTO ((int, rtx, int));\n-static int actual_hazard PROTO ((int, rtx, int, int));\n-static int potential_hazard PROTO ((int, rtx, int));\n-static int insn_cost PROTO ((rtx, rtx, rtx));\n-static int priority PROTO ((rtx));\n-static void free_pending_lists PROTO ((void));\n-static void add_insn_mem_dependence PROTO ((struct deps *, rtx *, rtx *, rtx,\n+static rtx find_insn_list PARAMS ((rtx, rtx));\n+static int insn_unit PARAMS ((rtx));\n+static unsigned int blockage_range PARAMS ((int, rtx));\n+static void clear_units PARAMS ((void));\n+static int actual_hazard_this_instance PARAMS ((int, int, rtx, int, int));\n+static void schedule_unit PARAMS ((int, rtx, int));\n+static int actual_hazard PARAMS ((int, rtx, int, int));\n+static int potential_hazard PARAMS ((int, rtx, int));\n+static int insn_cost PARAMS ((rtx, rtx, rtx));\n+static int priority PARAMS ((rtx));\n+static void free_pending_lists PARAMS ((void));\n+static void add_insn_mem_dependence PARAMS ((struct deps *, rtx *, rtx *, rtx,\n \t\t\t\t\t    rtx));\n-static void flush_pending_lists PROTO ((struct deps *, rtx, int));\n-static void sched_analyze_1 PROTO ((struct deps *, rtx, rtx));\n-static void sched_analyze_2 PROTO ((struct deps *, rtx, rtx));\n-static void sched_analyze_insn PROTO ((struct deps *, rtx, rtx, rtx));\n-static void sched_analyze PROTO ((struct deps *, rtx, rtx));\n-static int rank_for_schedule PROTO ((const PTR, const PTR));\n-static void swap_sort PROTO ((rtx *, int));\n-static void queue_insn PROTO ((rtx, int));\n-static int schedule_insn PROTO ((rtx, rtx *, int, int));\n-static void find_insn_reg_weight PROTO ((int));\n-static int schedule_block PROTO ((int, int));\n-static char *safe_concat PROTO ((char *, char *, const char *));\n-static int insn_issue_delay PROTO ((rtx));\n-static void adjust_priority PROTO ((rtx));\n+static void flush_pending_lists PARAMS ((struct deps *, rtx, int));\n+static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n+static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n+static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n+static void sched_analyze PARAMS ((struct deps *, rtx, rtx));\n+static int rank_for_schedule PARAMS ((const PTR, const PTR));\n+static void swap_sort PARAMS ((rtx *, int));\n+static void queue_insn PARAMS ((rtx, int));\n+static int schedule_insn PARAMS ((rtx, rtx *, int, int));\n+static void find_insn_reg_weight PARAMS ((int));\n+static int schedule_block PARAMS ((int, int));\n+static char *safe_concat PARAMS ((char *, char *, const char *));\n+static int insn_issue_delay PARAMS ((rtx));\n+static void adjust_priority PARAMS ((rtx));\n \n /* Control flow graph edges are kept in circular lists.  */\n typedef struct\n@@ -525,9 +525,9 @@ static int *out_edges;\n \n \n \n-static int is_cfg_nonregular PROTO ((void));\n-static int build_control_flow PROTO ((struct edge_list *));\n-static void new_edge PROTO ((int, int));\n+static int is_cfg_nonregular PARAMS ((void));\n+static int build_control_flow PARAMS ((struct edge_list *));\n+static void new_edge PARAMS ((int, int));\n \n \n /* A region is the main entity for interblock scheduling: insns\n@@ -563,12 +563,12 @@ static int *containing_rgn;\n #define BLOCK_TO_BB(block) (block_to_bb[block])\n #define CONTAINING_RGN(block) (containing_rgn[block])\n \n-void debug_regions PROTO ((void));\n-static void find_single_block_region PROTO ((void));\n-static void find_rgns PROTO ((struct edge_list *, sbitmap *));\n-static int too_large PROTO ((int, int *, int *));\n+void debug_regions PARAMS ((void));\n+static void find_single_block_region PARAMS ((void));\n+static void find_rgns PARAMS ((struct edge_list *, sbitmap *));\n+static int too_large PARAMS ((int, int *, int *));\n \n-extern void debug_live PROTO ((int, int));\n+extern void debug_live PARAMS ((int, int));\n \n /* Blocks of the current region being scheduled.  */\n static int current_nr_blocks;\n@@ -593,8 +593,8 @@ static int bitlst_table_last;\n static int bitlst_table_size;\n static int *bitlst_table;\n \n-static char bitset_member PROTO ((bitset, int, int));\n-static void extract_bitlst PROTO ((bitset, int, int, bitlst *));\n+static char bitset_member PARAMS ((bitset, int, int));\n+static void extract_bitlst PARAMS ((bitset, int, int, bitlst *));\n \n /* Target info declarations.\n \n@@ -635,10 +635,10 @@ static int target_bb;\n typedef bitlst edgelst;\n \n /* Target info functions.  */\n-static void split_edges PROTO ((int, int, edgelst *));\n-static void compute_trg_info PROTO ((int));\n-void debug_candidate PROTO ((int));\n-void debug_candidates PROTO ((int));\n+static void split_edges PARAMS ((int, int, edgelst *));\n+static void compute_trg_info PARAMS ((int));\n+void debug_candidate PARAMS ((int));\n+void debug_candidates PARAMS ((int));\n \n \n /* Bit-set of bbs, where bit 'i' stands for bb 'i'.  */\n@@ -698,7 +698,7 @@ static edgeset *pot_split;\n /* For every bb, a set of its ancestor edges.  */\n static edgeset *ancestor_edges;\n \n-static void compute_dom_prob_ps PROTO ((int));\n+static void compute_dom_prob_ps PARAMS ((int));\n \n #define ABS_VALUE(x) (((x)<0)?(-(x)):(x))\n #define INSN_PROBABILITY(INSN) (SRC_PROB (BLOCK_TO_BB (BLOCK_NUM (INSN))))\n@@ -711,24 +711,24 @@ static void compute_dom_prob_ps PROTO ((int));\n #define MIN_PROB_DIFF 10\n \n /* Speculative scheduling functions.  */\n-static int check_live_1 PROTO ((int, rtx));\n-static void update_live_1 PROTO ((int, rtx));\n-static int check_live PROTO ((rtx, int));\n-static void update_live PROTO ((rtx, int));\n-static void set_spec_fed PROTO ((rtx));\n-static int is_pfree PROTO ((rtx, int, int));\n-static int find_conditional_protection PROTO ((rtx, int));\n-static int is_conditionally_protected PROTO ((rtx, int, int));\n-static int may_trap_exp PROTO ((rtx, int));\n-static int haifa_classify_insn PROTO ((rtx));\n-static int is_prisky PROTO ((rtx, int, int));\n-static int is_exception_free PROTO ((rtx, int, int));\n-\n-static char find_insn_mem_list PROTO ((rtx, rtx, rtx, rtx));\n-static void compute_block_forward_dependences PROTO ((int));\n-static void add_branch_dependences PROTO ((rtx, rtx));\n-static void compute_block_backward_dependences PROTO ((int));\n-void debug_dependencies PROTO ((void));\n+static int check_live_1 PARAMS ((int, rtx));\n+static void update_live_1 PARAMS ((int, rtx));\n+static int check_live PARAMS ((rtx, int));\n+static void update_live PARAMS ((rtx, int));\n+static void set_spec_fed PARAMS ((rtx));\n+static int is_pfree PARAMS ((rtx, int, int));\n+static int find_conditional_protection PARAMS ((rtx, int));\n+static int is_conditionally_protected PARAMS ((rtx, int, int));\n+static int may_trap_exp PARAMS ((rtx, int));\n+static int haifa_classify_insn PARAMS ((rtx));\n+static int is_prisky PARAMS ((rtx, int, int));\n+static int is_exception_free PARAMS ((rtx, int, int));\n+\n+static char find_insn_mem_list PARAMS ((rtx, rtx, rtx, rtx));\n+static void compute_block_forward_dependences PARAMS ((int));\n+static void add_branch_dependences PARAMS ((rtx, rtx));\n+static void compute_block_backward_dependences PARAMS ((int));\n+void debug_dependencies PARAMS ((void));\n \n /* Notes handling mechanism:\n    =========================\n@@ -753,41 +753,41 @@ void debug_dependencies PROTO ((void));\n    unlink_other_notes ()).  After scheduling the block, these notes are\n    inserted at the beginning of the block (in schedule_block()).  */\n \n-static rtx unlink_other_notes PROTO ((rtx, rtx));\n-static rtx unlink_line_notes PROTO ((rtx, rtx));\n-static void rm_line_notes PROTO ((int));\n-static void save_line_notes PROTO ((int));\n-static void restore_line_notes PROTO ((int));\n-static void rm_redundant_line_notes PROTO ((void));\n-static void rm_other_notes PROTO ((rtx, rtx));\n-static rtx reemit_notes PROTO ((rtx, rtx));\n-\n-static void get_block_head_tail PROTO ((int, rtx *, rtx *));\n-static void get_bb_head_tail PROTO ((int, rtx *, rtx *));\n-\n-static int queue_to_ready PROTO ((rtx [], int));\n-\n-static void debug_ready_list PROTO ((rtx[], int));\n-static void init_target_units PROTO ((void));\n-static void insn_print_units PROTO ((rtx));\n-static int get_visual_tbl_length PROTO ((void));\n-static void init_block_visualization PROTO ((void));\n-static void print_block_visualization PROTO ((int, const char *));\n-static void visualize_scheduled_insns PROTO ((int, int));\n-static void visualize_no_unit PROTO ((rtx));\n-static void visualize_stall_cycles PROTO ((int, int));\n-static void print_exp PROTO ((char *, rtx, int));\n-static void print_value PROTO ((char *, rtx, int));\n-static void print_pattern PROTO ((char *, rtx, int));\n-static void print_insn PROTO ((char *, rtx, int));\n-void debug_reg_vector PROTO ((regset));\n-\n-static rtx move_insn1 PROTO ((rtx, rtx));\n-static rtx move_insn PROTO ((rtx, rtx));\n-static rtx group_leader PROTO ((rtx));\n-static int set_priorities PROTO ((int));\n-static void init_deps PROTO ((struct deps *));\n-static void schedule_region PROTO ((int));\n+static rtx unlink_other_notes PARAMS ((rtx, rtx));\n+static rtx unlink_line_notes PARAMS ((rtx, rtx));\n+static void rm_line_notes PARAMS ((int));\n+static void save_line_notes PARAMS ((int));\n+static void restore_line_notes PARAMS ((int));\n+static void rm_redundant_line_notes PARAMS ((void));\n+static void rm_other_notes PARAMS ((rtx, rtx));\n+static rtx reemit_notes PARAMS ((rtx, rtx));\n+\n+static void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n+static void get_bb_head_tail PARAMS ((int, rtx *, rtx *));\n+\n+static int queue_to_ready PARAMS ((rtx [], int));\n+\n+static void debug_ready_list PARAMS ((rtx[], int));\n+static void init_target_units PARAMS ((void));\n+static void insn_print_units PARAMS ((rtx));\n+static int get_visual_tbl_length PARAMS ((void));\n+static void init_block_visualization PARAMS ((void));\n+static void print_block_visualization PARAMS ((int, const char *));\n+static void visualize_scheduled_insns PARAMS ((int, int));\n+static void visualize_no_unit PARAMS ((rtx));\n+static void visualize_stall_cycles PARAMS ((int, int));\n+static void print_exp PARAMS ((char *, rtx, int));\n+static void print_value PARAMS ((char *, rtx, int));\n+static void print_pattern PARAMS ((char *, rtx, int));\n+static void print_insn PARAMS ((char *, rtx, int));\n+void debug_reg_vector PARAMS ((regset));\n+\n+static rtx move_insn1 PARAMS ((rtx, rtx));\n+static rtx move_insn PARAMS ((rtx, rtx));\n+static rtx group_leader PARAMS ((rtx));\n+static int set_priorities PARAMS ((int));\n+static void init_deps PARAMS ((struct deps *));\n+static void schedule_region PARAMS ((int));\n \n #endif /* INSN_SCHEDULING */\n \f"}, {"sha": "c29f0d1b8f28b10e3af214652bef14d9c45b3939", "filename": "gcc/halfpic.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fhalfpic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fhalfpic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.h?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -39,12 +39,12 @@ int (*ptr_half_pic_address_p) ();\t/* ptr to half_pic_address_p () */\n \n extern int  half_pic_number_ptrs;\t\t\t\t/* # distinct pointers found */\n extern int  half_pic_number_refs;\t\t\t\t/* # half-pic references */\n-extern void half_pic_encode PROTO((union tree_node *));\t\t/* encode whether half-pic */\n-extern void half_pic_declare PROTO((char *));\t\t\t/* declare object local */\n-extern void half_pic_external PROTO((char *));\t\t\t/* declare object external */\n-extern void half_pic_init PROTO((void));\t\t\t/* half_pic initialization */\n-extern int  half_pic_address_p PROTO((struct rtx_def *));\t/* true if an address is half-pic */\n-extern struct rtx_def *half_pic_ptr PROTO((struct rtx_def *));\t/* return RTX for half-pic pointer */\n+extern void half_pic_encode PARAMS ((union tree_node *));\t\t/* encode whether half-pic */\n+extern void half_pic_declare PARAMS ((char *));\t\t\t/* declare object local */\n+extern void half_pic_external PARAMS ((char *));\t\t\t/* declare object external */\n+extern void half_pic_init PARAMS ((void));\t\t\t/* half_pic initialization */\n+extern int  half_pic_address_p PARAMS ((struct rtx_def *));\t/* true if an address is half-pic */\n+extern struct rtx_def *half_pic_ptr PARAMS ((struct rtx_def *));\t/* return RTX for half-pic pointer */\n /* Can't use prototype since FILE isn't defined yet.  */\n extern void half_pic_finish (/* FILE * */);\t\t/* half_pic termination */\n "}, {"sha": "bd48cd8e98dfce07131939b2572cbf7dddadd458", "filename": "gcc/integrate.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -62,24 +62,24 @@ extern struct obstack *function_maybepermanent_obstack;\n    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))\n #endif\n \f\n-static rtvec initialize_for_inline\tPROTO((tree));\n-static void note_modified_parmregs\tPROTO((rtx, rtx, void *));\n-static void integrate_parm_decls\tPROTO((tree, struct inline_remap *,\n+static rtvec initialize_for_inline\tPARAMS ((tree));\n+static void note_modified_parmregs\tPARAMS ((rtx, rtx, void *));\n+static void integrate_parm_decls\tPARAMS ((tree, struct inline_remap *,\n \t\t\t\t\t       rtvec));\n-static tree integrate_decl_tree\t\tPROTO((tree,\n+static tree integrate_decl_tree\t\tPARAMS ((tree,\n \t\t\t\t\t       struct inline_remap *));\n-static void subst_constants\t\tPROTO((rtx *, rtx,\n+static void subst_constants\t\tPARAMS ((rtx *, rtx,\n \t\t\t\t\t       struct inline_remap *, int));\n-static void set_block_origin_self\tPROTO((tree));\n-static void set_decl_origin_self\tPROTO((tree));\n-static void set_block_abstract_flags\tPROTO((tree, int));\n-static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n+static void set_block_origin_self\tPARAMS ((tree));\n+static void set_decl_origin_self\tPARAMS ((tree));\n+static void set_block_abstract_flags\tPARAMS ((tree, int));\n+static void process_reg_param\t\tPARAMS ((struct inline_remap *, rtx,\n \t\t\t\t\t       rtx));\n-void set_decl_abstract_flags\t\tPROTO((tree, int));\n-static rtx expand_inline_function_eh_labelmap PROTO((rtx));\n-static void mark_stores                 PROTO((rtx, rtx, void *));\n-static int compare_blocks               PROTO((const PTR, const PTR));\n-static int find_block                   PROTO((const PTR, const PTR));\n+void set_decl_abstract_flags\t\tPARAMS ((tree, int));\n+static rtx expand_inline_function_eh_labelmap PARAMS ((rtx));\n+static void mark_stores                 PARAMS ((rtx, rtx, void *));\n+static int compare_blocks               PARAMS ((const PTR, const PTR));\n+static int find_block                   PARAMS ((const PTR, const PTR));\n \n /* The maximum number of instructions accepted for inlining a\n    function.  Increasing values mean more agressive inlining."}, {"sha": "53b78663fd77dca951f9b7b2956c83186ef3596c", "filename": "gcc/integrate.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -116,18 +116,18 @@ struct inline_remap\n \n /* Return a copy of an rtx (as needed), substituting pseudo-register,\n    labels, and frame-pointer offsets as necessary.  */\n-extern rtx copy_rtx_and_substitute PROTO((rtx, struct inline_remap *, int));\n+extern rtx copy_rtx_and_substitute PARAMS ((rtx, struct inline_remap *, int));\n \n /* Copy a declaration when one function is substituted inline into\n    another.  */\n-extern union tree_node *copy_decl_for_inlining PROTO((union tree_node *,\n+extern union tree_node *copy_decl_for_inlining PARAMS ((union tree_node *,\n \t\t\t\t\t\t      union tree_node *,\n \t\t\t\t\t\t      union tree_node *));\n \n-extern void try_constants PROTO((rtx, struct inline_remap *));\n+extern void try_constants PARAMS ((rtx, struct inline_remap *));\n \n /* Return the label indicated.  */\n-extern rtx get_label_from_map PROTO((struct inline_remap *, int));\n+extern rtx get_label_from_map PARAMS ((struct inline_remap *, int));\n \n /* Set the label indicated.  */\n #define set_label_in_map(MAP, I, X) ((MAP)->label_map[I] = (X))"}, {"sha": "785aa41faa1a0168cc3aa8d875dd2203e135ad7c", "filename": "gcc/jump.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -107,29 +107,29 @@ int can_reach_end;\n \n static int cross_jump_death_matters = 0;\n \n-static int init_label_info\t\tPROTO((rtx));\n-static void delete_barrier_successors\tPROTO((rtx));\n-static void mark_all_labels\t\tPROTO((rtx, int));\n-static rtx delete_unreferenced_labels\tPROTO((rtx));\n-static void delete_noop_moves\t\tPROTO((rtx));\n-static int calculate_can_reach_end\tPROTO((rtx, int, int));\n-static int duplicate_loop_exit_test\tPROTO((rtx));\n-static void find_cross_jump\t\tPROTO((rtx, rtx, int, rtx *, rtx *));\n-static void do_cross_jump\t\tPROTO((rtx, rtx, rtx));\n-static int jump_back_p\t\t\tPROTO((rtx, rtx));\n-static int tension_vector_labels\tPROTO((rtx, int));\n-static void mark_jump_label\t\tPROTO((rtx, rtx, int));\n-static void delete_computation\t\tPROTO((rtx));\n-static void delete_from_jump_chain\tPROTO((rtx));\n-static int delete_labelref_insn\t\tPROTO((rtx, rtx, int));\n-static void mark_modified_reg\t\tPROTO((rtx, rtx, void *));\n-static void redirect_tablejump\t\tPROTO((rtx, rtx));\n-static void jump_optimize_1\t\tPROTO ((rtx, int, int, int, int));\n+static int init_label_info\t\tPARAMS ((rtx));\n+static void delete_barrier_successors\tPARAMS ((rtx));\n+static void mark_all_labels\t\tPARAMS ((rtx, int));\n+static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n+static void delete_noop_moves\t\tPARAMS ((rtx));\n+static int calculate_can_reach_end\tPARAMS ((rtx, int, int));\n+static int duplicate_loop_exit_test\tPARAMS ((rtx));\n+static void find_cross_jump\t\tPARAMS ((rtx, rtx, int, rtx *, rtx *));\n+static void do_cross_jump\t\tPARAMS ((rtx, rtx, rtx));\n+static int jump_back_p\t\t\tPARAMS ((rtx, rtx));\n+static int tension_vector_labels\tPARAMS ((rtx, int));\n+static void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\n+static void delete_computation\t\tPARAMS ((rtx));\n+static void delete_from_jump_chain\tPARAMS ((rtx));\n+static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n+static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n+static void redirect_tablejump\t\tPARAMS ((rtx, rtx));\n+static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int));\n #if ! defined(HAVE_cc0) && ! defined(HAVE_conditional_arithmetic)\n-static rtx find_insert_position         PROTO((rtx, rtx));\n+static rtx find_insert_position         PARAMS ((rtx, rtx));\n #endif\n-static int returnjump_p_1\t        PROTO((rtx *, void *));\n-static void delete_prior_computation    PROTO((rtx, rtx));\n+static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n+static void delete_prior_computation    PARAMS ((rtx, rtx));\n \n /* Main external entry point into the jump optimizer.  See comments before\n    jump_optimize_1 for descriptions of the arguments.  */"}, {"sha": "f0fa6a9402e15c1a0bf86d4dd8eae1ee62cbb947", "filename": "gcc/lcm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -63,24 +63,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"basic-block.h\"\n \n /* Edge based LCM routines.  */\n-static void compute_antinout_edge  PROTO ((sbitmap *, sbitmap *,\n+static void compute_antinout_edge  PARAMS ((sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *));\n-static void compute_earliest  PROTO((struct edge_list *, int, sbitmap *,\n+static void compute_earliest  PARAMS ((struct edge_list *, int, sbitmap *,\n \t\t\t\t     sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t     sbitmap *));\n-static void compute_laterin  PROTO((struct edge_list *, sbitmap *,\n+static void compute_laterin  PARAMS ((struct edge_list *, sbitmap *,\n \t\t\t\t    sbitmap *, sbitmap *, sbitmap *));\n-static void compute_insert_delete  PROTO ((struct edge_list *edge_list,\n+static void compute_insert_delete  PARAMS ((struct edge_list *edge_list,\n \t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *));\n \n /* Edge based LCM routines on a reverse flowgraph.  */\n-static void compute_farthest\tPROTO  ((struct edge_list *, int, sbitmap *,\n+static void compute_farthest\tPARAMS ((struct edge_list *, int, sbitmap *,\n \t\t\t\t\t sbitmap *, sbitmap*, sbitmap *,\n \t\t\t\t\t sbitmap *));\n-static void compute_nearerout\tPROTO((struct edge_list *, sbitmap *,\n+static void compute_nearerout\tPARAMS ((struct edge_list *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap *));\n-static void compute_rev_insert_delete  PROTO ((struct edge_list *edge_list,\n+static void compute_rev_insert_delete  PARAMS ((struct edge_list *edge_list,\n \t\t\t\t\t       sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t\t       sbitmap *, sbitmap *));\n "}, {"sha": "20857a908abd863956d2f06c56f336d4bf10f02b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -250,31 +250,31 @@ static rtx *reg_equiv_init_insns;\n /* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n static int recorded_label_ref;\n \n-static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n-static void validate_equiv_mem_from_store PROTO((rtx, rtx, void *));\n-static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n-static int contains_replace_regs PROTO((rtx, char *));\n-static int memref_referenced_p\tPROTO((rtx, rtx));\n-static int memref_used_between_p PROTO((rtx, rtx, rtx));\n-static void update_equiv_regs\tPROTO((void));\n-static void no_equiv\t\tPROTO((rtx, rtx, void *));\n-static void block_alloc\t\tPROTO((int));\n-static int qty_sugg_compare    \tPROTO((int, int));\n-static int qty_sugg_compare_1\tPROTO((const PTR, const PTR));\n-static int qty_compare    \tPROTO((int, int));\n-static int qty_compare_1\tPROTO((const PTR, const PTR));\n-static int combine_regs\t\tPROTO((rtx, rtx, int, int, rtx, int));\n-static int reg_meets_class_p\tPROTO((int, enum reg_class));\n-static void update_qty_class\tPROTO((int, int));\n-static void reg_is_set\t\tPROTO((rtx, rtx, void *));\n-static void reg_is_born\t\tPROTO((rtx, int));\n-static void wipe_dead_reg\tPROTO((rtx, int));\n-static int find_free_reg\tPROTO((enum reg_class, enum machine_mode,\n+static void alloc_qty\t\tPARAMS ((int, enum machine_mode, int, int));\n+static void validate_equiv_mem_from_store PARAMS ((rtx, rtx, void *));\n+static int validate_equiv_mem\tPARAMS ((rtx, rtx, rtx));\n+static int contains_replace_regs PARAMS ((rtx, char *));\n+static int memref_referenced_p\tPARAMS ((rtx, rtx));\n+static int memref_used_between_p PARAMS ((rtx, rtx, rtx));\n+static void update_equiv_regs\tPARAMS ((void));\n+static void no_equiv\t\tPARAMS ((rtx, rtx, void *));\n+static void block_alloc\t\tPARAMS ((int));\n+static int qty_sugg_compare    \tPARAMS ((int, int));\n+static int qty_sugg_compare_1\tPARAMS ((const PTR, const PTR));\n+static int qty_compare    \tPARAMS ((int, int));\n+static int qty_compare_1\tPARAMS ((const PTR, const PTR));\n+static int combine_regs\t\tPARAMS ((rtx, rtx, int, int, rtx, int));\n+static int reg_meets_class_p\tPARAMS ((int, enum reg_class));\n+static void update_qty_class\tPARAMS ((int, int));\n+static void reg_is_set\t\tPARAMS ((rtx, rtx, void *));\n+static void reg_is_born\t\tPARAMS ((rtx, int));\n+static void wipe_dead_reg\tPARAMS ((rtx, int));\n+static int find_free_reg\tPARAMS ((enum reg_class, enum machine_mode,\n \t\t\t\t       int, int, int, int, int));\n-static void mark_life\t\tPROTO((int, enum machine_mode, int));\n-static void post_mark_life\tPROTO((int, enum machine_mode, int, int, int));\n-static int no_conflict_p\tPROTO((rtx, rtx, rtx));\n-static int requires_inout\tPROTO((const char *));\n+static void mark_life\t\tPARAMS ((int, enum machine_mode, int));\n+static void post_mark_life\tPARAMS ((int, enum machine_mode, int, int, int));\n+static int no_conflict_p\tPARAMS ((rtx, rtx, rtx));\n+static int requires_inout\tPARAMS ((const char *));\n \f\n /* Allocate a new quantity (new within current basic block)\n    for register number REGNO which is born at index BIRTH"}, {"sha": "88782f6db903f4d4ca2b9bd602bbc4ae05d81192", "filename": "gcc/loop.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -234,70 +234,70 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n-static void verify_dominator PROTO((struct loop *));\n-static void find_and_verify_loops PROTO((rtx, struct loops *));\n-static void mark_loop_jump PROTO((rtx, struct loop *));\n-static void prescan_loop PROTO((struct loop *));\n-static int reg_in_basic_block_p PROTO((rtx, rtx));\n-static int consec_sets_invariant_p PROTO((rtx, int, rtx));\n-static int labels_in_range_p PROTO((rtx, int));\n-static void count_one_set PROTO((rtx, rtx, varray_type, rtx *));\n-\n-static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n+static void verify_dominator PARAMS ((struct loop *));\n+static void find_and_verify_loops PARAMS ((rtx, struct loops *));\n+static void mark_loop_jump PARAMS ((rtx, struct loop *));\n+static void prescan_loop PARAMS ((struct loop *));\n+static int reg_in_basic_block_p PARAMS ((rtx, rtx));\n+static int consec_sets_invariant_p PARAMS ((rtx, int, rtx));\n+static int labels_in_range_p PARAMS ((rtx, int));\n+static void count_one_set PARAMS ((rtx, rtx, varray_type, rtx *));\n+\n+static void count_loop_regs_set PARAMS ((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n-static void note_addr_stored PROTO((rtx, rtx, void *));\n-static void note_set_pseudo_multiple_uses PROTO((rtx, rtx, void *));\n-static int loop_reg_used_before_p PROTO((const struct loop *, rtx, rtx));\n-static void scan_loop PROTO((struct loop*, int, int));\n+static void note_addr_stored PARAMS ((rtx, rtx, void *));\n+static void note_set_pseudo_multiple_uses PARAMS ((rtx, rtx, void *));\n+static int loop_reg_used_before_p PARAMS ((const struct loop *, rtx, rtx));\n+static void scan_loop PARAMS ((struct loop*, int, int));\n #if 0\n-static void replace_call_address PROTO((rtx, rtx, rtx));\n+static void replace_call_address PARAMS ((rtx, rtx, rtx));\n #endif\n-static rtx skip_consec_insns PROTO((rtx, int));\n-static int libcall_benefit PROTO((rtx));\n-static void ignore_some_movables PROTO((struct movable *));\n-static void force_movables PROTO((struct movable *));\n-static void combine_movables PROTO((struct movable *, int));\n-static int regs_match_p PROTO((rtx, rtx, struct movable *));\n-static int rtx_equal_for_loop_p PROTO((rtx, rtx, struct movable *));\n-static void add_label_notes PROTO((rtx, rtx));\n-static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n-static int count_nonfixed_reads PROTO((rtx));\n-static void strength_reduce PROTO((struct loop *, int, int, int));\n-static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n-static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n-static void find_mem_givs PROTO((rtx, rtx, int, int, rtx, rtx));\n-static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int, int));\n-static void check_final_value PROTO((struct induction *, rtx, rtx, \n+static rtx skip_consec_insns PARAMS ((rtx, int));\n+static int libcall_benefit PARAMS ((rtx));\n+static void ignore_some_movables PARAMS ((struct movable *));\n+static void force_movables PARAMS ((struct movable *));\n+static void combine_movables PARAMS ((struct movable *, int));\n+static int regs_match_p PARAMS ((rtx, rtx, struct movable *));\n+static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movable *));\n+static void add_label_notes PARAMS ((rtx, rtx));\n+static void move_movables PARAMS ((struct movable *, int, int, rtx, rtx, int));\n+static int count_nonfixed_reads PARAMS ((rtx));\n+static void strength_reduce PARAMS ((struct loop *, int, int, int));\n+static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n+static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n+static void find_mem_givs PARAMS ((rtx, rtx, int, int, rtx, rtx));\n+static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int, int));\n+static void check_final_value PARAMS ((struct induction *, rtx, rtx, \n \t\t\t\t     unsigned HOST_WIDE_INT));\n-static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n-static void update_giv_derive PROTO((rtx));\n-static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, int, rtx *, rtx *, rtx **, int *));\n-static rtx simplify_giv_expr PROTO((rtx, int *));\n-static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n-static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n-static int check_dbra_loop PROTO((struct loop *, int));\n-static rtx express_from_1 PROTO((rtx, rtx, rtx));\n-static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n-static void combine_givs PROTO((struct iv_class *));\n+static void record_giv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n+static void update_giv_derive PARAMS ((rtx));\n+static int basic_induction_var PARAMS ((rtx, enum machine_mode, rtx, rtx, int, rtx *, rtx *, rtx **, int *));\n+static rtx simplify_giv_expr PARAMS ((rtx, int *));\n+static int general_induction_var PARAMS ((rtx, rtx *, rtx *, rtx *, int, int *));\n+static int consec_sets_giv PARAMS ((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n+static int check_dbra_loop PARAMS ((struct loop *, int));\n+static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n+static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n+static void combine_givs PARAMS ((struct iv_class *));\n struct recombine_givs_stats;\n-static int find_life_end PROTO((rtx, struct recombine_givs_stats *, rtx, rtx));\n-static void recombine_givs PROTO((struct iv_class *, rtx, rtx, int));\n-static int product_cheap_p PROTO((rtx, rtx));\n-static int maybe_eliminate_biv PROTO((struct iv_class *, rtx, rtx, int, int, int));\n-static int maybe_eliminate_biv_1 PROTO((rtx, rtx, struct iv_class *, int, rtx));\n-static int last_use_this_basic_block PROTO((rtx, rtx));\n-static void record_initial PROTO((rtx, rtx, void *));\n-static void update_reg_last_use PROTO((rtx, rtx));\n-static rtx next_insn_in_loop PROTO((const struct loop *, rtx));\n-static void load_mems_and_recount_loop_regs_set PROTO((const struct loop*,\n+static int find_life_end PARAMS ((rtx, struct recombine_givs_stats *, rtx, rtx));\n+static void recombine_givs PARAMS ((struct iv_class *, rtx, rtx, int));\n+static int product_cheap_p PARAMS ((rtx, rtx));\n+static int maybe_eliminate_biv PARAMS ((struct iv_class *, rtx, rtx, int, int, int));\n+static int maybe_eliminate_biv_1 PARAMS ((rtx, rtx, struct iv_class *, int, rtx));\n+static int last_use_this_basic_block PARAMS ((rtx, rtx));\n+static void record_initial PARAMS ((rtx, rtx, void *));\n+static void update_reg_last_use PARAMS ((rtx, rtx));\n+static rtx next_insn_in_loop PARAMS ((const struct loop *, rtx));\n+static void load_mems_and_recount_loop_regs_set PARAMS ((const struct loop*,\n \t\t\t\t\t\t       int *));\n-static void load_mems PROTO((const struct loop *));\n-static int insert_loop_mem PROTO((rtx *, void *));\n-static int replace_loop_mem PROTO((rtx *, void *));\n-static int replace_loop_reg PROTO((rtx *, void *));\n-static void note_reg_stored PROTO((rtx, rtx, void *));\n-static void try_copy_prop PROTO((const struct loop *, rtx, int));\n-static int replace_label PROTO((rtx *, void *));\n+static void load_mems PARAMS ((const struct loop *));\n+static int insert_loop_mem PARAMS ((rtx *, void *));\n+static int replace_loop_mem PARAMS ((rtx *, void *));\n+static int replace_loop_reg PARAMS ((rtx *, void *));\n+static void note_reg_stored PARAMS ((rtx, rtx, void *));\n+static void try_copy_prop PARAMS ((const struct loop *, rtx, int));\n+static int replace_label PARAMS ((rtx *, void *));\n \n typedef struct rtx_and_int {\n   rtx r;\n@@ -317,19 +317,19 @@ typedef struct rtx_pair {\n \n #ifdef HAVE_decrement_and_branch_on_count\n /* Test whether BCT applicable and safe.  */\n-static void insert_bct PROTO((struct loop *));\n+static void insert_bct PARAMS ((struct loop *));\n \n /* Auxiliary function that inserts the BCT pattern into the loop.  */\n-static void instrument_loop_bct PROTO((rtx, rtx, rtx));\n+static void instrument_loop_bct PARAMS ((rtx, rtx, rtx));\n #endif /* HAVE_decrement_and_branch_on_count */\n \n /* Indirect_jump_in_function is computed once per function.  */\n int indirect_jump_in_function = 0;\n-static int indirect_jump_in_function_p PROTO((rtx));\n+static int indirect_jump_in_function_p PARAMS ((rtx));\n \n-static int compute_luids PROTO((rtx, rtx, int));\n+static int compute_luids PARAMS ((rtx, rtx, int));\n \n-static int biv_elimination_giv_has_0_offset PROTO((struct induction *,\n+static int biv_elimination_giv_has_0_offset PARAMS ((struct induction *,\n \t\t\t\t\t\t   struct induction *, rtx));\n \f\n /* Relative gain of eliminating various kinds of operations.  */"}, {"sha": "b72034d186c314b29e09804fa0c1f4f0eac93484", "filename": "gcc/loop.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe41456ed2b825719c3f4c5e4bd90c71f1fc677/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=3fe41456ed2b825719c3f4c5e4bd90c71f1fc677", "patch": "@@ -227,26 +227,26 @@ extern int first_increment_giv, last_increment_giv;\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */\n-int invariant_p PROTO((rtx));\n-rtx get_condition_for_loop PROTO((rtx));\n-void emit_iv_add_mult PROTO((rtx, rtx, rtx, rtx, rtx));\n-rtx express_from PROTO((struct induction *, struct induction *));\n-\n-void unroll_loop PROTO((struct loop *, int, rtx, int));\n-rtx biv_total_increment PROTO((struct iv_class *, rtx, rtx));\n-unsigned HOST_WIDE_INT loop_iterations PROTO((struct loop *));\n-int precondition_loop_p PROTO((rtx, struct loop_info *, \n+int invariant_p PARAMS ((rtx));\n+rtx get_condition_for_loop PARAMS ((rtx));\n+void emit_iv_add_mult PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+rtx express_from PARAMS ((struct induction *, struct induction *));\n+\n+void unroll_loop PARAMS ((struct loop *, int, rtx, int));\n+rtx biv_total_increment PARAMS ((struct iv_class *, rtx, rtx));\n+unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n+int precondition_loop_p PARAMS ((rtx, struct loop_info *, \n \t\t\t       rtx *, rtx *, rtx *, \n \t\t\t       enum machine_mode *mode));\n-rtx final_biv_value PROTO((struct iv_class *, rtx, rtx,\n+rtx final_biv_value PARAMS ((struct iv_class *, rtx, rtx,\n \t\t\t   unsigned HOST_WIDE_INT));\n-rtx final_giv_value PROTO((struct induction *, rtx, rtx,\n+rtx final_giv_value PARAMS ((struct induction *, rtx, rtx,\n \t\t\t   unsigned HOST_WIDE_INT));\n-void emit_unrolled_add PROTO((rtx, rtx, rtx));\n-int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n+void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n+int back_branch_in_range_p PARAMS ((rtx, rtx, rtx));\n \n-int loop_insn_first_p PROTO((rtx, rtx));\n+int loop_insn_first_p PARAMS ((rtx, rtx));\n \n /* Forward declarations for non-static functions declared in stmt.c.  */\n-void find_loop_tree_blocks PROTO((void));\n-void unroll_block_trees PROTO((void));\n+void find_loop_tree_blocks PARAMS ((void));\n+void unroll_block_trees PARAMS ((void));"}]}