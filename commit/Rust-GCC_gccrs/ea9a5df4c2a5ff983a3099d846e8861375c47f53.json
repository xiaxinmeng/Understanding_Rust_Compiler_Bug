{"sha": "ea9a5df4c2a5ff983a3099d846e8861375c47f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5YTVkZjRjMmE1ZmY5ODNhMzA5OWQ4NDZlODg2MTM3NWM0N2Y1Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-07-08T18:49:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-07-08T18:49:05Z"}, "message": "re PR tree-optimization/22360 (upper_bound_in_type and lower_bound_in_type are buggy)\n\n\tPR tree-optimization/22360\n\t* tree.c (upper_bound_in_type): Fix calculations for casting\n\tto a non-wider signed type and casting a signed value to a\n\twider unsigned type.\n\t(lower_bound_in_type): Fix calculations for casting to a\n\tnon-wider signed type.\n\nFrom-SVN: r101785", "tree": {"sha": "2b169e2dac4a9fc33a703bd4fb0f2964c782273a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b169e2dac4a9fc33a703bd4fb0f2964c782273a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea9a5df4c2a5ff983a3099d846e8861375c47f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9a5df4c2a5ff983a3099d846e8861375c47f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea9a5df4c2a5ff983a3099d846e8861375c47f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9a5df4c2a5ff983a3099d846e8861375c47f53/comments", "author": null, "committer": null, "parents": [{"sha": "d5c77941577bbb6ace7a8e13dfca2c3b61a4ded9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c77941577bbb6ace7a8e13dfca2c3b61a4ded9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c77941577bbb6ace7a8e13dfca2c3b61a4ded9"}], "stats": {"total": 130, "additions": 88, "deletions": 42}, "files": [{"sha": "db2a8ea62d7e31cd17542946ddee9bd5f04698eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9a5df4c2a5ff983a3099d846e8861375c47f53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9a5df4c2a5ff983a3099d846e8861375c47f53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea9a5df4c2a5ff983a3099d846e8861375c47f53", "patch": "@@ -1,3 +1,12 @@\n+2005-07-08  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR tree-optimization/22360\n+\t* tree.c (upper_bound_in_type): Fix calculations for casting\n+\tto a non-wider signed type and casting a signed value to a\n+\twider unsigned type.\n+\t(lower_bound_in_type): Fix calculations for casting to a\n+\tnon-wider signed type.\n+\n 2005-07-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/22356"}, {"sha": "f4e052c4c6a7bce50ee451aa6099878e052d186f", "filename": "gcc/tree.c", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9a5df4c2a5ff983a3099d846e8861375c47f53/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9a5df4c2a5ff983a3099d846e8861375c47f53/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ea9a5df4c2a5ff983a3099d846e8861375c47f53", "patch": "@@ -6417,43 +6417,64 @@ tree\n upper_bound_in_type (tree outer, tree inner)\n {\n   unsigned HOST_WIDE_INT lo, hi;\n-  unsigned bits = TYPE_PRECISION (inner);\n+  unsigned int det = 0;\n+  unsigned oprec = TYPE_PRECISION (outer);\n+  unsigned iprec = TYPE_PRECISION (inner);\n+  unsigned prec;\n+\n+  /* Compute a unique number for every combination.  */\n+  det |= (oprec > iprec) ? 4 : 0;\n+  det |= TYPE_UNSIGNED (outer) ? 2 : 0;\n+  det |= TYPE_UNSIGNED (inner) ? 1 : 0;\n+\n+  /* Determine the exponent to use.  */\n+  switch (det)\n+    {\n+    case 0:\n+    case 1:\n+      /* oprec <= iprec, outer: signed, inner: don't care.  */\n+      prec = oprec - 1;\n+      break;\n+    case 2:\n+    case 3:\n+      /* oprec <= iprec, outer: unsigned, inner: don't care.  */\n+      prec = oprec;\n+      break;\n+    case 4:\n+      /* oprec > iprec, outer: signed, inner: signed.  */\n+      prec = iprec - 1;\n+      break;\n+    case 5:\n+      /* oprec > iprec, outer: signed, inner: unsigned.  */\n+      prec = iprec;\n+      break;\n+    case 6:\n+      /* oprec > iprec, outer: unsigned, inner: signed.  */\n+      prec = oprec;\n+      break;\n+    case 7:\n+      /* oprec > iprec, outer: unsigned, inner: unsigned.  */\n+      prec = iprec;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+  /* Compute 2^^prec - 1.  */\n+  if (prec <= HOST_BITS_PER_WIDE_INT)\n     {\n-      /* Zero extending in these cases.  */\n-      if (bits <= HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (HOST_BITS_PER_WIDE_INT - bits);\n-\t}\n-      else\n-\t{\n-\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits);\n-\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n-\t}\n+      hi = 0;\n+      lo = ((~(unsigned HOST_WIDE_INT) 0)\n+\t    >> (HOST_BITS_PER_WIDE_INT - prec));\n     }\n   else\n     {\n-      /* Sign extending in these cases.  */\n-      if (bits <= HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (HOST_BITS_PER_WIDE_INT - bits) >> 1;\n-\t}\n-      else\n-\t{\n-\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n-\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits) >> 1;\n-\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n-\t}\n+      hi = ((~(unsigned HOST_WIDE_INT) 0)\n+\t    >> (2 * HOST_BITS_PER_WIDE_INT - prec));\n+      lo = ~(unsigned HOST_WIDE_INT) 0;\n     }\n \n-  return fold_convert (outer,\n-\t\t       build_int_cst_wide (inner, lo, hi));\n+  return build_int_cst_wide (outer, lo, hi);\n }\n \n /* Returns the smallest value obtainable by casting something in INNER type to\n@@ -6463,23 +6484,39 @@ tree\n lower_bound_in_type (tree outer, tree inner)\n {\n   unsigned HOST_WIDE_INT lo, hi;\n-  unsigned bits = TYPE_PRECISION (inner);\n-\n-  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+  unsigned oprec = TYPE_PRECISION (outer);\n+  unsigned iprec = TYPE_PRECISION (inner);\n+\n+  /* If OUTER type is unsigned, we can definitely cast 0 to OUTER type\n+     and obtain 0.  */\n+  if (TYPE_UNSIGNED (outer)\n+      /* If we are widening something of an unsigned type, OUTER type\n+\t contains all values of INNER type.  In particular, both INNER\n+\t and OUTER types have zero in common.  */\n+      || (oprec > iprec && TYPE_UNSIGNED (inner)))\n     lo = hi = 0;\n-  else if (bits <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      hi = ~(unsigned HOST_WIDE_INT) 0;\n-      lo = (~(unsigned HOST_WIDE_INT) 0) << (bits - 1);\n-    }\n   else\n     {\n-      hi = (~(unsigned HOST_WIDE_INT) 0) << (bits - HOST_BITS_PER_WIDE_INT - 1);\n-      lo = 0;\n+      /* If we are widening a signed type to another signed type, we\n+\t want to obtain -2^^(iprec-1).  If we are keeping the\n+\t precision or narrowing to a signed type, we want to obtain\n+\t -2^(oprec-1).  */\n+      unsigned prec = oprec > iprec ? iprec : oprec;\n+\n+      if (prec <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = ~(unsigned HOST_WIDE_INT) 0;\n+\t  lo = (~(unsigned HOST_WIDE_INT) 0) << (prec - 1);\n+\t}\n+      else\n+\t{\n+\t  hi = ((~(unsigned HOST_WIDE_INT) 0)\n+\t\t<< (prec - HOST_BITS_PER_WIDE_INT - 1));\n+\t  lo = 0;\n+\t}\n     }\n \n-  return fold_convert (outer,\n-\t\t       build_int_cst_wide (inner, lo, hi));\n+  return build_int_cst_wide (outer, lo, hi);\n }\n \n /* Return nonzero if two operands that are suitable for PHI nodes are"}]}