{"sha": "070e3489678380354027144c6b0cef02e7601a37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwZTM0ODk2NzgzODAzNTQwMjcxNDRjNmIwY2VmMDJlNzYwMWEzNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-11-20T17:03:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-20T17:03:43Z"}, "message": "Implement inline call summaries.\n\n\t* ipa-fnsummary.c (ipa_fn_summary::account_size_time): Add CALL\n\tparameter and update call_size_time_table.\n\t(ipa_fn_summary::max_size_time_table_size): New constant.\n\t(estimate_calls_size_and_time_1): Break out from ...\n\t(estimate_calls_size_and_time): ... here; implement summary production.\n\t(summarize_calls_size_and_time): New function.\n\t(ipa_call_context::estimate_size_and_time): Bypass\n\testimate_calls_size_and_time for leaf functions.\n\t(ipa_update_overall_fn_summary): Likewise.\n\t* ipa-fnsummary.h (call_size_time_table): New.\n\t(ipa_fn_summary::account_size_time): Update prototype.\n\nFrom-SVN: r278513", "tree": {"sha": "35be7ab7c8c44f60813d77d3f70237b784179952", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35be7ab7c8c44f60813d77d3f70237b784179952"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/070e3489678380354027144c6b0cef02e7601a37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070e3489678380354027144c6b0cef02e7601a37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070e3489678380354027144c6b0cef02e7601a37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070e3489678380354027144c6b0cef02e7601a37/comments", "author": null, "committer": null, "parents": [{"sha": "73248b1d2665661b840c1f00cfa1a5b844775cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73248b1d2665661b840c1f00cfa1a5b844775cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73248b1d2665661b840c1f00cfa1a5b844775cdd"}], "stats": {"total": 252, "additions": 220, "deletions": 32}, "files": [{"sha": "0f526b1a9f7f8ac36878524f4737db05d4bad23a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070e3489678380354027144c6b0cef02e7601a37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070e3489678380354027144c6b0cef02e7601a37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=070e3489678380354027144c6b0cef02e7601a37", "patch": "@@ -1,3 +1,17 @@\n+2019-11-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-fnsummary.c (ipa_fn_summary::account_size_time): Add CALL\n+\tparameter and update call_size_time_table.\n+\t(ipa_fn_summary::max_size_time_table_size): New constant.\n+\t(estimate_calls_size_and_time_1): Break out from ...\n+\t(estimate_calls_size_and_time): ... here; implement summary production.\n+\t(summarize_calls_size_and_time): New function.\n+\t(ipa_call_context::estimate_size_and_time): Bypass\n+\testimate_calls_size_and_time for leaf functions.\n+\t(ipa_update_overall_fn_summary): Likewise.\n+\t* ipa-fnsummary.h (call_size_time_table): New.\n+\t(ipa_fn_summary::account_size_time): Update prototype.\n+\n 2019-11-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/invoke.texi (-Wc11-c2x-compat): Document."}, {"sha": "0652207220a66f4fc89d3a5081a6a317a6244fc3", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 194, "deletions": 29, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070e3489678380354027144c6b0cef02e7601a37/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070e3489678380354027144c6b0cef02e7601a37/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=070e3489678380354027144c6b0cef02e7601a37", "patch": "@@ -146,17 +146,22 @@ ipa_dump_hints (FILE *f, ipa_hints hints)\n /* Record SIZE and TIME to SUMMARY.\n    The accounted code will be executed when EXEC_PRED is true.\n    When NONCONST_PRED is false the code will evaulate to constant and\n-   will get optimized out in specialized clones of the function.   */\n+   will get optimized out in specialized clones of the function.\n+   If CALL is true account to call_size_time_table rather than\n+   size_time_table.   */\n \n void\n ipa_fn_summary::account_size_time (int size, sreal time,\n \t\t\t\t   const predicate &exec_pred,\n-\t\t\t\t   const predicate &nonconst_pred_in)\n+\t\t\t\t   const predicate &nonconst_pred_in,\n+\t\t\t\t   bool call)\n {\n   size_time_entry *e;\n   bool found = false;\n   int i;\n   predicate nonconst_pred;\n+  vec<size_time_entry, va_gc> *table = call\n+\t \t\t\t       ? call_size_time_table : size_time_table;\n \n   if (exec_pred == false)\n     return;\n@@ -168,23 +173,23 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n \n   /* We need to create initial empty unconitional clause, but otherwie\n      we don't need to account empty times and sizes.  */\n-  if (!size && time == 0 && size_time_table)\n+  if (!size && time == 0 && table)\n     return;\n \n   gcc_assert (time >= 0);\n \n-  for (i = 0; vec_safe_iterate (size_time_table, i, &e); i++)\n+  for (i = 0; vec_safe_iterate (table, i, &e); i++)\n     if (e->exec_predicate == exec_pred\n \t&& e->nonconst_predicate == nonconst_pred)\n       {\n \tfound = true;\n \tbreak;\n       }\n-  if (i == 256)\n+  if (i == max_size_time_table_size)\n     {\n       i = 0;\n       found = true;\n-      e = &(*size_time_table)[0];\n+      e = &(*table)[0];\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"\\t\\tReached limit on number of entries, \"\n@@ -212,7 +217,10 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n       new_entry.time = time;\n       new_entry.exec_predicate = exec_pred;\n       new_entry.nonconst_predicate = nonconst_pred;\n-      vec_safe_push (size_time_table, new_entry);\n+      if (call)\n+        vec_safe_push (call_size_time_table, new_entry);\n+      else\n+        vec_safe_push (size_time_table, new_entry);\n     }\n   else\n     {\n@@ -642,6 +650,7 @@ ipa_fn_summary::~ipa_fn_summary ()\n     edge_predicate_pool.remove (loop_stride);\n   vec_free (conds);\n   vec_free (size_time_table);\n+  vec_free (call_size_time_table);\n }\n \n void\n@@ -2973,31 +2982,33 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n }\n \n \n-\n /* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n    calls in NODE.  POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n-   describe context of the call site.  */\n+   describe context of the call site.\n+ \n+   Helper for estimate_calls_size_and_time which does the same but\n+   (in most cases) faster.  */\n \n static void\n-estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n-\t\t\t      int *min_size, sreal *time,\n-\t\t\t      ipa_hints *hints,\n-\t\t\t      clause_t possible_truths,\n-\t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_value_set> known_aggs)\n+estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n+\t\t\t        int *min_size, sreal *time,\n+\t\t\t        ipa_hints *hints,\n+\t\t\t        clause_t possible_truths,\n+\t\t\t        vec<tree> known_vals,\n+\t\t\t        vec<ipa_polymorphic_call_context> known_contexts,\n+\t\t\t        vec<ipa_agg_value_set> known_aggs)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       if (!e->inline_failed)\n \t{\n \t  gcc_checking_assert (!ipa_call_summaries->get (e));\n-\t  estimate_calls_size_and_time (e->callee, size, min_size, time,\n-\t\t\t\t\thints,\n-\t\t\t\t\tpossible_truths,\n-\t\t\t\t\tknown_vals, known_contexts,\n-\t\t\t\t\tknown_aggs);\n+\t  estimate_calls_size_and_time_1 (e->callee, size, min_size, time,\n+\t\t\t\t\t  hints,\n+\t\t\t\t\t  possible_truths,\n+\t\t\t\t\t  known_vals, known_contexts,\n+\t\t\t\t\t  known_aggs);\n \t  continue;\n \t}\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n@@ -3033,6 +3044,157 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     }\n }\n \n+/* Populate sum->call_size_time_table for edges from NODE.  */\n+\n+static void\n+summarize_calls_size_and_time (struct cgraph_node *node,\n+    \t\t\t       ipa_fn_summary *sum)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->inline_failed)\n+\t{\n+\t  gcc_checking_assert (!ipa_call_summaries->get (e));\n+\t  summarize_calls_size_and_time (e->callee, sum);\n+\t  continue;\n+\t}\n+      int size = 0;\n+      sreal time = 0;\n+\n+      estimate_edge_size_and_time (e, &size, NULL, &time,\n+\t\t\t\t   vNULL, vNULL, vNULL, NULL);\n+\n+      struct predicate pred = true;\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n+\n+      if (es->predicate)\n+\tpred = *es->predicate;\n+      sum->account_size_time (size, time, pred, pred, true);\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      int size = 0;\n+      sreal time = 0;\n+\n+      estimate_edge_size_and_time (e, &size, NULL, &time,\n+\t\t\t\t   vNULL, vNULL, vNULL, NULL);\n+      struct predicate pred = true;\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n+\n+      if (es->predicate)\n+\tpred = *es->predicate;\n+      sum->account_size_time (size, time, pred, pred, true);\n+    }\n+}\n+\n+/* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n+   calls in NODE.  POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n+   describe context of the call site.  */\n+\n+static void\n+estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n+\t\t\t      int *min_size, sreal *time,\n+\t\t\t      ipa_hints *hints,\n+\t\t\t      clause_t possible_truths,\n+\t\t\t      vec<tree> known_vals,\n+\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n+\t\t\t      vec<ipa_agg_value_set> known_aggs)\n+{\n+  class ipa_fn_summary *sum = ipa_fn_summaries->get (node);\n+  bool use_table = true;\n+\n+  gcc_assert (node->callees || node->indirect_calls);\n+\n+  /* During early inlining we do not calculate info for very\n+     large functions and thus there is no need for producing\n+     summaries.  */\n+  if (!ipa_node_params_sum)\n+    use_table = false;\n+  /* Do not calculate summaries for simple wrappers; it is waste\n+     of memory.  */\n+  else if (node->callees && node->indirect_calls\n+           && node->callees->inline_failed && !node->callees->next_callee)\n+    use_table = false;\n+  /* If there is an indirect edge that may be optimized, we need\n+     to go the slow way.  */\n+  else if ((known_vals.length ()\n+     \t    || known_contexts.length ()\n+\t    || known_aggs.length ()) && hints)\n+    {\n+      class ipa_node_params *params_summary = IPA_NODE_REF (node);\n+      unsigned int nargs = params_summary\n+\t\t\t   ? ipa_get_param_count (params_summary) : 0;\n+\n+      for (unsigned int i = 0; i < nargs && use_table; i++)\n+\t{\n+\t  if (ipa_is_param_used_by_indirect_call (params_summary, i)\n+\t      && ((known_vals.length () > i && known_vals[i])\n+\t\t  || (known_aggs.length () > i\n+\t\t      && known_aggs[i].items.length ())))\n+\t    use_table = false;\n+\t  else if (ipa_is_param_used_by_polymorphic_call (params_summary, i)\n+\t\t   && (known_contexts.length () > i\n+\t\t       && !known_contexts[i].useless_p ()))\n+\t    use_table = false;\n+\t}\n+    }\n+\n+  /* Fast path is via the call size time table.  */\n+  if (use_table)\n+    {\n+      /* Build summary if it is absent.  */\n+      if (!sum->call_size_time_table)\n+\t{\n+\t  predicate true_pred = true;\n+\t  sum->account_size_time (0, 0, true_pred, true_pred, true);\n+\t  summarize_calls_size_and_time (node, sum);\n+\t}\n+\n+      int old_size = *size;\n+      sreal old_time = time ? *time : 0;\n+\n+      if (min_size)\n+\t*min_size += (*sum->call_size_time_table)[0].size;\n+\n+      unsigned int i;\n+      size_time_entry *e;\n+\n+      /* Walk the table and account sizes and times.  */\n+      for (i = 0; vec_safe_iterate (sum->call_size_time_table, i, &e);\n+\t   i++)\n+\tif (e->exec_predicate.evaluate (possible_truths))\n+\t  {\n+\t    *size += e->size;\n+\t    if (time)\n+\t      *time += e->time;\n+\t  }\n+\n+      /* Be careful and see if both methods agree.  */\n+      if ((flag_checking || dump_file)\n+\t  /* Do not try to sanity check when we know we lost some\n+\t     precision.  */\n+\t  && sum->call_size_time_table->length ()\n+\t     < ipa_fn_summary::max_size_time_table_size)\n+\t{\n+\t  estimate_calls_size_and_time_1 (node, &old_size, NULL, &old_time, NULL,\n+\t\t\t\t\t  possible_truths, known_vals,\n+\t\t\t\t\t  known_contexts, known_aggs);\n+\t  gcc_assert (*size == old_size);\n+\t  if (time && (*time - old_time > 1 || *time - old_time < -1)\n+\t      && dump_file)\n+\t    fprintf (dump_file, \"Time mismatch in call summary %f!=%f\",\n+\t\t     old_time.to_double (),\n+\t\t     time->to_double ());\n+\t}\n+    }\n+  /* Slow path by walking all edges.  */\n+  else\n+    estimate_calls_size_and_time_1 (node, size, min_size, time, hints,\n+\t\t\t\t    possible_truths, known_vals, known_contexts,\n+\t\t\t\t    known_aggs);\n+}\n+\n /* Default constructor for ipa call context.\n    Memory alloction of known_vals, known_contexts\n    and known_aggs vectors is owned by the caller, but can\n@@ -3303,10 +3465,11 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n \t  }\n     }\n \n-  estimate_calls_size_and_time (m_node, &size, &min_size,\n-\t\t\t\tret_time ? &time : NULL,\n-\t\t\t\tret_hints ? &hints : NULL, m_possible_truths,\n-\t\t\t\tm_known_vals, m_known_contexts, m_known_aggs);\n+  if (m_node->callees || m_node->indirect_calls)\n+    estimate_calls_size_and_time (m_node, &size, &min_size,\n+\t\t\t\t  ret_time ? &time : NULL,\n+\t\t\t\t  ret_hints ? &hints : NULL, m_possible_truths,\n+\t\t\t\t  m_known_vals, m_known_contexts, m_known_aggs);\n \n   sreal nonspecialized_time = time;\n \n@@ -3760,10 +3923,12 @@ ipa_update_overall_fn_summary (struct cgraph_node *node)\n       info->time += e->time;\n     }\n   info->min_size = (*info->size_time_table)[0].size;\n-  estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n-\t\t\t\t&info->time, NULL,\n-\t\t\t\t~(clause_t) (1 << predicate::false_condition),\n-\t\t\t\tvNULL, vNULL, vNULL);\n+  vec_free (info->call_size_time_table);\n+  if (node->callees || node->indirect_calls)\n+    estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n+\t\t\t\t  &info->time, NULL,\n+\t\t\t\t  ~(clause_t) (1 << predicate::false_condition),\n+\t\t\t\t  vNULL, vNULL, vNULL);\n   size_info->size = RDIV (size_info->size, ipa_fn_summary::size_scale);\n   info->min_size = RDIV (info->min_size, ipa_fn_summary::size_scale);\n }"}, {"sha": "5822adbce203816039290e50cd58ea272eaa5589", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070e3489678380354027144c6b0cef02e7601a37/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070e3489678380354027144c6b0cef02e7601a37/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=070e3489678380354027144c6b0cef02e7601a37", "patch": "@@ -117,8 +117,8 @@ class GTY(()) ipa_fn_summary\n       inlinable (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n       time (0), conds (NULL),\n-      size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),\n-      growth (0), scc_no (0)\n+      size_time_table (NULL), call_size_time_table (NULL), loop_iterations (NULL),\n+      loop_stride (NULL), growth (0), scc_no (0)\n   {\n   }\n \n@@ -129,6 +129,7 @@ class GTY(()) ipa_fn_summary\n     fp_expressions (s.fp_expressions),\n     estimated_stack_size (s.estimated_stack_size),\n     time (s.time), conds (s.conds), size_time_table (s.size_time_table),\n+    call_size_time_table (NULL),\n     loop_iterations (s.loop_iterations), loop_stride (s.loop_stride),\n     growth (s.growth), scc_no (s.scc_no)\n   {}\n@@ -161,7 +162,12 @@ class GTY(()) ipa_fn_summary\n   /* Conditional size/time information.  The summaries are being\n      merged during inlining.  */\n   conditions conds;\n+  /* Normal code is acocunted in size_time_table, while calls are\n+     accounted in call_size_time_table.  This is because calls\n+     are often adjusted by IPA optimizations and thus this summary\n+     is generated from call summary information when needed.  */\n   vec<size_time_entry, va_gc> *size_time_table;\n+  vec<size_time_entry, va_gc> *call_size_time_table;\n \n   /* Predicate on when some loop in the function becomes to have known\n      bounds.   */\n@@ -179,10 +185,13 @@ class GTY(()) ipa_fn_summary\n   int scc_no;\n \n   /* Record time and size under given predicates.  */\n-  void account_size_time (int, sreal, const predicate &, const predicate &);\n+  void account_size_time (int, sreal, const predicate &, const predicate &,\n+\t\t  \t  bool call = false);\n \n   /* We keep values scaled up, so fractional sizes can be accounted.  */\n   static const int size_scale = 2;\n+  /* Maximal size of size_time_table before we start to be conservative.  */\n+  static const int max_size_time_table_size = 256;\n };\n \n class GTY((user)) ipa_fn_summary_t:"}]}