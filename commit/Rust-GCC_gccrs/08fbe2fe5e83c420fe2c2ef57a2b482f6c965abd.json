{"sha": "08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmYmUyZmU1ZTgzYzQyMGZlMmMyZWY1N2EyYjQ4MmY2Yzk2NWFiZA==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-11-19T10:29:41Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-11-19T10:29:41Z"}, "message": "trans-expr.c (conv_isocbinding_procedure): New function.\n\n2009-11-19  Janus Weil  <janus@gcc.gnu.org>\n\n\t* trans-expr.c (conv_isocbinding_procedure): New function.\n\t(gfc_conv_procedure_call): Move ISO_C_BINDING stuff to\n\tseparate function.\n\nFrom-SVN: r154327", "tree": {"sha": "074ccde199bcf788584911b01bacbfd989c89770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/074ccde199bcf788584911b01bacbfd989c89770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae5882f9ce598ed5c3adb89e21989f41b547bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae5882f9ce598ed5c3adb89e21989f41b547bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae5882f9ce598ed5c3adb89e21989f41b547bbd"}], "stats": {"total": 277, "additions": 153, "deletions": 124}, "files": [{"sha": "95e761fb6e38030ca507a43dfa074e216f74a259", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "patch": "@@ -1,3 +1,9 @@\n+2009-11-19  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* trans-expr.c (conv_isocbinding_procedure): New function.\n+\t(gfc_conv_procedure_call): Move ISO_C_BINDING stuff to\n+\tseparate function.\n+\n 2009-11-19  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi (Interoperable Subroutines and Functions): Fix"}, {"sha": "c0df67827501fb89bad1197b2fd1740267e89a5a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 147, "deletions": 124, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=08fbe2fe5e83c420fe2c2ef57a2b482f6c965abd", "patch": "@@ -2533,6 +2533,150 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n }\n \n \n+/* The following routine generates code for the intrinsic\n+   procedures from the ISO_C_BINDING module:\n+    * C_LOC           (function)\n+    * C_FUNLOC        (function)\n+    * C_F_POINTER     (subroutine)\n+    * C_F_PROCPOINTER (subroutine)\n+    * C_ASSOCIATED    (function)\n+   One exception which is not handled here is C_F_POINTER with non-scalar\n+   arguments. Returns 1 if the call was replaced by inline code (else: 0).  */\n+\n+static int\n+conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n+\t\t\t    gfc_actual_arglist * arg)\n+{\n+  gfc_symbol *fsym;\n+  gfc_ss *argss;\n+    \n+  if (sym->intmod_sym_id == ISOCBINDING_LOC)\n+    {\n+      if (arg->expr->rank == 0)\n+\tgfc_conv_expr_reference (se, arg->expr);\n+      else\n+\t{\n+\t  int f;\n+\t  /* This is really the actual arg because no formal arglist is\n+\t     created for C_LOC.\t */\n+\t  fsym = arg->expr->symtree->n.sym;\n+\n+\t  /* We should want it to do g77 calling convention.  */\n+\t  f = (fsym != NULL)\n+\t    && !(fsym->attr.pointer || fsym->attr.allocatable)\n+\t    && fsym->as->type != AS_ASSUMED_SHAPE;\n+\t  f = f || !sym->attr.always_explicit;\n+      \n+\t  argss = gfc_walk_expr (arg->expr);\n+\t  gfc_conv_array_parameter (se, arg->expr, argss, f,\n+\t\t\t\t    NULL, NULL, NULL);\n+\t}\n+\n+      /* TODO -- the following two lines shouldn't be necessary, but if\n+\t they're removed, a bug is exposed later in the code path.\n+\t This workaround was thus introduced, but will have to be\n+\t removed; please see PR 35150 for details about the issue.  */\n+      se->expr = convert (pvoid_type_node, se->expr);\n+      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+\n+      return 1;\n+    }\n+  else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n+    {\n+      arg->expr->ts.type = sym->ts.u.derived->ts.type;\n+      arg->expr->ts.f90_type = sym->ts.u.derived->ts.f90_type;\n+      arg->expr->ts.kind = sym->ts.u.derived->ts.kind;\n+      gfc_conv_expr_reference (se, arg->expr);\n+  \n+      return 1;\n+    }\n+  else if ((sym->intmod_sym_id == ISOCBINDING_F_POINTER\n+\t    && arg->next->expr->rank == 0)\n+\t   || sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER)\n+    {\n+      /* Convert c_f_pointer if fptr is a scalar\n+\t and convert c_f_procpointer.  */\n+      gfc_se cptrse;\n+      gfc_se fptrse;\n+\n+      gfc_init_se (&cptrse, NULL);\n+      gfc_conv_expr (&cptrse, arg->expr);\n+      gfc_add_block_to_block (&se->pre, &cptrse.pre);\n+      gfc_add_block_to_block (&se->post, &cptrse.post);\n+\n+      gfc_init_se (&fptrse, NULL);\n+      if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n+\t  || gfc_is_proc_ptr_comp (arg->next->expr, NULL))\n+\tfptrse.want_pointer = 1;\n+\n+      gfc_conv_expr (&fptrse, arg->next->expr);\n+      gfc_add_block_to_block (&se->pre, &fptrse.pre);\n+      gfc_add_block_to_block (&se->post, &fptrse.post);\n+      \n+      if (arg->next->expr->symtree->n.sym->attr.proc_pointer\n+\t  && arg->next->expr->symtree->n.sym->attr.dummy)\n+\tfptrse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t   fptrse.expr);\n+      \n+      se->expr = fold_build2 (MODIFY_EXPR, TREE_TYPE (fptrse.expr),\n+\t\t\t      fptrse.expr,\n+\t\t\t      fold_convert (TREE_TYPE (fptrse.expr),\n+\t\t\t\t\t    cptrse.expr));\n+\n+      return 1;\n+    }\n+  else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n+    {\n+      gfc_se arg1se;\n+      gfc_se arg2se;\n+\n+      /* Build the addr_expr for the first argument.  The argument is\n+\t already an *address* so we don't need to set want_pointer in\n+\t the gfc_se.  */\n+      gfc_init_se (&arg1se, NULL);\n+      gfc_conv_expr (&arg1se, arg->expr);\n+      gfc_add_block_to_block (&se->pre, &arg1se.pre);\n+      gfc_add_block_to_block (&se->post, &arg1se.post);\n+\n+      /* See if we were given two arguments.  */\n+      if (arg->next == NULL)\n+\t/* Only given one arg so generate a null and do a\n+\t   not-equal comparison against the first arg.  */\n+\tse->expr = fold_build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n+\t\t\t\tfold_convert (TREE_TYPE (arg1se.expr),\n+\t\t\t\t\t      null_pointer_node));\n+      else\n+\t{\n+\t  tree eq_expr;\n+\t  tree not_null_expr;\n+\t  \n+\t  /* Given two arguments so build the arg2se from second arg.  */\n+\t  gfc_init_se (&arg2se, NULL);\n+\t  gfc_conv_expr (&arg2se, arg->next->expr);\n+\t  gfc_add_block_to_block (&se->pre, &arg2se.pre);\n+\t  gfc_add_block_to_block (&se->post, &arg2se.post);\n+\n+\t  /* Generate test to compare that the two args are equal.  */\n+\t  eq_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t arg1se.expr, arg2se.expr);\n+\t  /* Generate test to ensure that the first arg is not null.  */\n+\t  not_null_expr = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t       arg1se.expr, null_pointer_node);\n+\n+\t  /* Finally, the generated test must check that both arg1 is not\n+\t     NULL and that it is equal to the second arg.  */\n+\t  se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  not_null_expr, eq_expr);\n+\t}\n+\n+      return 1;\n+    }\n+    \n+  /* Nothing was done.  */\n+  return 0;\n+}\n+\n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -2576,130 +2720,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   len = NULL_TREE;\n   gfc_clear_ts (&ts);\n \n-  if (sym->from_intmod == INTMOD_ISO_C_BINDING)\n-    {\n-      if (sym->intmod_sym_id == ISOCBINDING_LOC)\n-\t{\n-\t  if (arg->expr->rank == 0)\n-\t    gfc_conv_expr_reference (se, arg->expr);\n-\t  else\n-\t    {\n-\t      int f;\n-\t      /* This is really the actual arg because no formal arglist is\n-\t\t created for C_LOC.\t */\n-\t      fsym = arg->expr->symtree->n.sym;\n-\n-\t      /* We should want it to do g77 calling convention.  */\n-\t      f = (fsym != NULL)\n-\t\t&& !(fsym->attr.pointer || fsym->attr.allocatable)\n-\t\t&& fsym->as->type != AS_ASSUMED_SHAPE;\n-\t      f = f || !sym->attr.always_explicit;\n-\t  \n-\t      argss = gfc_walk_expr (arg->expr);\n-\t      gfc_conv_array_parameter (se, arg->expr, argss, f,\n-\t\t\t\t\tNULL, NULL, NULL);\n-\t    }\n-\n-\t  /* TODO -- the following two lines shouldn't be necessary, but\n-\t    they're removed a bug is exposed later in the codepath.\n-\t    This is workaround was thus introduced, but will have to be\n-\t    removed; please see PR 35150 for details about the issue.  */\n-\t  se->expr = convert (pvoid_type_node, se->expr);\n-\t  se->expr = gfc_evaluate_now (se->expr, &se->pre);\n-\n-\t  return 0;\n-\t}\n-      else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n-\t{\n-\t  arg->expr->ts.type = sym->ts.u.derived->ts.type;\n-\t  arg->expr->ts.f90_type = sym->ts.u.derived->ts.f90_type;\n-\t  arg->expr->ts.kind = sym->ts.u.derived->ts.kind;\n-\t  gfc_conv_expr_reference (se, arg->expr);\n-      \n-\t  return 0;\n-\t}\n-      else if ((sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t         && arg->next->expr->rank == 0)\n-\t       || sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER)\n-\t{\n-\t  /* Convert c_f_pointer if fptr is a scalar\n-\t     and convert c_f_procpointer.  */\n-\t  gfc_se cptrse;\n-\t  gfc_se fptrse;\n-\n-\t  gfc_init_se (&cptrse, NULL);\n-\t  gfc_conv_expr (&cptrse, arg->expr);\n-\t  gfc_add_block_to_block (&se->pre, &cptrse.pre);\n-\t  gfc_add_block_to_block (&se->post, &cptrse.post);\n-\n-\t  gfc_init_se (&fptrse, NULL);\n-\t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t      || gfc_is_proc_ptr_comp (arg->next->expr, NULL))\n-\t    fptrse.want_pointer = 1;\n-\n-\t  gfc_conv_expr (&fptrse, arg->next->expr);\n-\t  gfc_add_block_to_block (&se->pre, &fptrse.pre);\n-\t  gfc_add_block_to_block (&se->post, &fptrse.post);\n-\t  \n-\t  if (arg->next->expr->symtree->n.sym->attr.proc_pointer\n-\t      && arg->next->expr->symtree->n.sym->attr.dummy)\n-\t    fptrse.expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t       fptrse.expr);\n-\t  \n-\t  se->expr = fold_build2 (MODIFY_EXPR, TREE_TYPE (fptrse.expr),\n-\t\t\t\t  fptrse.expr,\n-\t\t\t\t  fold_convert (TREE_TYPE (fptrse.expr),\n-\t\t\t\t\t\tcptrse.expr));\n-\n-\t  return 0;\n-\t}\n-      else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n-        {\n-\t  gfc_se arg1se;\n-\t  gfc_se arg2se;\n-\n-\t  /* Build the addr_expr for the first argument.  The argument is\n-\t     already an *address* so we don't need to set want_pointer in\n-\t     the gfc_se.  */\n-\t  gfc_init_se (&arg1se, NULL);\n-\t  gfc_conv_expr (&arg1se, arg->expr);\n-\t  gfc_add_block_to_block (&se->pre, &arg1se.pre);\n-\t  gfc_add_block_to_block (&se->post, &arg1se.post);\n-\n-\t  /* See if we were given two arguments.  */\n-\t  if (arg->next == NULL)\n-\t    /* Only given one arg so generate a null and do a\n-\t       not-equal comparison against the first arg.  */\n-\t    se->expr = fold_build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n-\t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n-\t\t\t\t\t\t  null_pointer_node));\n-\t  else\n-\t    {\n-\t      tree eq_expr;\n-\t      tree not_null_expr;\n-\t      \n-\t      /* Given two arguments so build the arg2se from second arg.  */\n-\t      gfc_init_se (&arg2se, NULL);\n-\t      gfc_conv_expr (&arg2se, arg->next->expr);\n-\t      gfc_add_block_to_block (&se->pre, &arg2se.pre);\n-\t      gfc_add_block_to_block (&se->post, &arg2se.post);\n-\n-\t      /* Generate test to compare that the two args are equal.  */\n-\t      eq_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t     arg1se.expr, arg2se.expr);\n-\t      /* Generate test to ensure that the first arg is not null.  */\n-\t      not_null_expr = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t   arg1se.expr, null_pointer_node);\n-\n-\t      /* Finally, the generated test must check that both arg1 is not\n-\t\t NULL and that it is equal to the second arg.  */\n-\t      se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t      not_null_expr, eq_expr);\n-\t    }\n-\n-\t  return 0;\n-\t}\n-    }\n+  if (sym->from_intmod == INTMOD_ISO_C_BINDING\n+      && conv_isocbinding_procedure (se, sym, arg))\n+    return 0;\n \n   gfc_is_proc_ptr_comp (expr, &comp);\n "}]}