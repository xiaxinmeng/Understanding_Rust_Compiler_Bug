{"sha": "83d48fad1f3dc5d869fd3f567293ef12bf495392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkNDhmYWQxZjNkYzVkODY5ZmQzZjU2NzI5M2VmMTJiZjQ5NTM5Mg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-09-26T00:43:11Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-09-26T00:43:11Z"}, "message": "re PR middle-end/37535 (gcc/libgcc2.c:404: internal compiler error: Floating point exception)\n\n2008-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/37535\n\n\t* ira-lives.c (mark_reg_live, mark_reg_dead): New functions.\n\t(mark_ref_live, mark_ref_dead): Use them.\n\t(def_conflicts_with_inputs_p): Remove.\n\t(mark_early_clobbers): New function.\n\t(process_bb_node_lives): Call preprocess_constraints and\n\tmark_early_clobbers.\n\n\t* doc/rtx.texi (clobber): Change how RA deals with clobbers.\n\nFrom-SVN: r140679", "tree": {"sha": "623650abb3bee835f51cbee9bd50331745975687", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/623650abb3bee835f51cbee9bd50331745975687"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d48fad1f3dc5d869fd3f567293ef12bf495392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d48fad1f3dc5d869fd3f567293ef12bf495392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d48fad1f3dc5d869fd3f567293ef12bf495392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d48fad1f3dc5d869fd3f567293ef12bf495392/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fcac00fec7d8643bb723d5921858a61d8db38ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcac00fec7d8643bb723d5921858a61d8db38ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fcac00fec7d8643bb723d5921858a61d8db38ac"}], "stats": {"total": 151, "additions": 107, "deletions": 44}, "files": [{"sha": "86d2c46d6a90e277c522007b72cdae57ee717ffb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83d48fad1f3dc5d869fd3f567293ef12bf495392", "patch": "@@ -1,3 +1,16 @@\n+2008-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/37535\n+\n+\t* ira-lives.c (mark_reg_live, mark_reg_dead): New functions.\n+\t(mark_ref_live, mark_ref_dead): Use them.\n+\t(def_conflicts_with_inputs_p): Remove.\n+\t(mark_early_clobbers): New function.\n+\t(process_bb_node_lives): Call preprocess_constraints and\n+\tmark_early_clobbers.\n+\n+\t* doc/rtl.texi (clobber): Change how RA deals with clobbers.\n+\n 2008-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/37448"}, {"sha": "984ee4326419711789bbc4079d2d113bcc921c80", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=83d48fad1f3dc5d869fd3f567293ef12bf495392", "patch": "@@ -2930,12 +2930,13 @@ constituent instructions might not.\n When a @code{clobber} expression for a register appears inside a\n @code{parallel} with other side effects, the register allocator\n guarantees that the register is unoccupied both before and after that\n-insn.  However, the reload phase may allocate a register used for one of\n-the inputs unless the @samp{&} constraint is specified for the selected\n-alternative (@pxref{Modifiers}).  You can clobber either a specific hard\n-register, a pseudo register, or a @code{scratch} expression; in the\n-latter two cases, GCC will allocate a hard register that is available\n-there for use as a temporary.\n+insn if the @samp{&} constraint is specified for at least one\n+alternative (@pxref{Modifiers}) of the clobber.  However, the reload\n+phase may allocate a register used for one of the inputs unless the\n+@samp{&} constraint is specified for the selected alternative.  You\n+can clobber either a specific hard register, a pseudo register, or a\n+@code{scratch} expression; in the latter two cases, GCC will allocate\n+a hard register that is available there for use as a temporary.\n \n For instructions that require a temporary register, you should use\n @code{scratch} instead of a pseudo-register because this will allow the"}, {"sha": "e49860fa927def8de53a1b0f4158a97e03ba00fa", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d48fad1f3dc5d869fd3f567293ef12bf495392/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=83d48fad1f3dc5d869fd3f567293ef12bf495392", "patch": "@@ -209,20 +209,15 @@ clear_allocno_live (ira_allocno_t a)\n   sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n-/* Mark the register referenced by use or def REF as live\n-   Store a 1 in hard_regs_live or allocnos_live for this register or\n-   the corresponding allocno, record how many consecutive hardware\n-   registers it actually needs.  */\n-\n+/* Mark the register REG as live.  Store a 1 in hard_regs_live or\n+   allocnos_live for this register or the corresponding allocno,\n+   record how many consecutive hardware registers it actually\n+   needs.  */\n static void\n-mark_ref_live (struct df_ref *ref)\n+mark_reg_live (rtx reg)\n {\n-  rtx reg;\n   int regno;\n \n-  reg = DF_REF_REG (ref);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -269,32 +264,25 @@ mark_ref_live (struct df_ref *ref)\n     }\n }\n \n-/* Return true if the definition described by DEF conflicts with the\n-   instruction's inputs.  */\n-static bool\n-def_conflicts_with_inputs_p (struct df_ref *def)\n+/* Mark the register referenced by use or def REF as live.  */\n+static void\n+mark_ref_live (struct df_ref *ref)\n {\n-  /* Conservatively assume that the condition is true for all clobbers.  */\n-  return DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER);\n+  rtx reg;\n+\n+  reg = DF_REF_REG (ref);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  mark_reg_live (reg);\n }\n \n-/* Mark the register referenced by definition DEF as dead, if the\n-   definition is a total one.  Store a 0 in hard_regs_live or\n+/* Mark the register REG as dead.  Store a 0 in hard_regs_live or\n    allocnos_live for the register.  */\n static void\n-mark_ref_dead (struct df_ref *def)\n+mark_reg_dead (rtx reg)\n {\n-  unsigned int i;\n-  rtx reg;\n   int regno;\n \n-  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n-      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n-    return;\n-\n-  reg = DF_REF_REG (def);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -312,6 +300,7 @@ mark_ref_dead (struct df_ref *def)\n     }\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n+      unsigned int i;\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       enum reg_class cover_class;\n \n@@ -343,6 +332,71 @@ mark_ref_dead (struct df_ref *def)\n     }\n }\n \n+/* Mark the register referenced by definition DEF as dead, if the\n+   definition is a total one.  */\n+static void\n+mark_ref_dead (struct df_ref *def)\n+{\n+  rtx reg;\n+\n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n+    return;\n+\n+  reg = DF_REF_REG (def);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  mark_reg_dead (reg);\n+}\n+\n+/* Mark early clobber registers of the current INSN as live (if\n+   LIVE_P) or dead.  Return true if there are such registers.  */\n+static bool\n+mark_early_clobbers (rtx insn, bool live_p)\n+{\n+  int alt;\n+  int def;\n+  struct df_ref **def_rec;\n+  bool set_p = false;\n+  bool asm_p = asm_noperands (PATTERN (insn)) >= 0;\n+\n+  if (asm_p)\n+    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+      if (DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MUST_CLOBBER))\n+\t{\n+\t  if (live_p)\n+\t    mark_ref_live (*def_rec);\n+\t  else\n+\t    mark_ref_dead (*def_rec);\n+\t  set_p = true;\n+\t}\n+\n+  for (def = 0; def < recog_data.n_operands; def++)\n+    {\n+      rtx dreg = recog_data.operand[def];\n+      \n+      if (GET_CODE (dreg) == SUBREG)\n+\tdreg = SUBREG_REG (dreg);\n+      if (! REG_P (dreg))\n+\tcontinue;\n+\n+      for (alt = 0; alt < recog_data.n_alternatives; alt++)\n+\tif ((recog_op_alt[def][alt].earlyclobber)\n+\t    && (recog_op_alt[def][alt].cl != NO_REGS))\n+\t  break;\n+\n+      if (alt >= recog_data.n_alternatives)\n+\tcontinue;\n+\n+      if (live_p)\n+\tmark_reg_live (dreg);\n+      else\n+\tmark_reg_dead (dreg);\n+      set_p = true;\n+    }\n+  return set_p;\n+}\n+\n /* Checks that CONSTRAINTS permits to use only one hard register.  If\n    it is so, the function returns the class of the hard register.\n    Otherwise it returns NO_REGS.  */\n@@ -580,6 +634,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n   bitmap_iterator bi;\n   bitmap reg_live_out;\n   unsigned int px;\n+  bool set_p;\n \n   bb = loop_tree_node->bb;\n   if (bb != NULL)\n@@ -698,6 +753,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      }\n \t  \n \t  extract_insn (insn);\n+\t  preprocess_constraints ();\n \t  process_single_reg_class_operands (false, freq);\n \t  \n \t  /* See which defined values die here.  */\n@@ -733,19 +789,12 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n \t    mark_ref_live (*use_rec);\n \n-\t  /* If any defined values conflict with the inputs, mark those\n-\t     defined values as live.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (def_conflicts_with_inputs_p (*def_rec))\n-\t      mark_ref_live (*def_rec);\n+\t  set_p = mark_early_clobbers (insn, true);\n \n \t  process_single_reg_class_operands (true, freq);\n \t  \n-\t  /* See which of the defined values we marked as live are dead\n-\t     before the instruction.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (def_conflicts_with_inputs_p (*def_rec))\n-\t      mark_ref_dead (*def_rec);\n+\t  if (set_p)\n+\t    mark_early_clobbers (insn, false);\n \n \t  curr_point++;\n \t}"}]}