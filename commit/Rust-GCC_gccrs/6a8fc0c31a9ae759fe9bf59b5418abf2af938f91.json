{"sha": "6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE4ZmMwYzMxYTlhZTc1OWZlOWJmNTliNTQxOGFiZjJhZjkzOGY5MQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-02-16T15:28:06Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-03-04T15:21:52Z"}, "message": "profiling: fix streaming of TOPN counters\n\nlibgcc/ChangeLog:\n\n\tPR gcov-profile/99105\n\t* libgcov-driver.c (write_top_counters): Rename to ...\n\t(write_topn_counters): ... this.\n\t(write_one_data): Pre-allocate buffer for number of items\n\tin the corresponding linked lists.\n\t* libgcov.h (malloc_mmap): New function.\n\t(allocate_gcov_kvp): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR gcov-profile/99105\n\t* gcc.dg/tree-prof/indir-call-prof-malloc.c: Use profile\n\tcorrection as the wrapped malloc is called one more time\n\tfrom libgcov.\n\t* gcc.dg/tree-prof/pr97461.c: Likewise.", "tree": {"sha": "d0f65e009207e8142f7e5882e2c9e059c3e1b6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0f65e009207e8142f7e5882e2c9e059c3e1b6b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9816196328a4f4b927f08cf2f66cf255849da0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9816196328a4f4b927f08cf2f66cf255849da0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9816196328a4f4b927f08cf2f66cf255849da0b"}], "stats": {"total": 76, "additions": 63, "deletions": 13}, "files": [{"sha": "7bda4aedfc89332c26a84ffac58b94678db685f3", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof-malloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c?ref=6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -ldl\" } */\n+/* { dg-options \"-O2 -ldl -fprofile-correction\" } */\n \n #define _GNU_SOURCE\n #include <stdio.h>"}, {"sha": "f684be4d80f4b0d3207c0e80867f513e05d9ff37", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr97461.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c?ref=6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "patch": "@@ -1,5 +1,5 @@\n /* PR gcov-profile/97461 */\n-/* { dg-options \"-O2 -ldl\" } */\n+/* { dg-options \"-O2 -ldl -fprofile-correction\" } */\n \n #define _GNU_SOURCE\n "}, {"sha": "a1338b6e5255997e817a552718b02b6ebedc3a95", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "patch": "@@ -42,6 +42,10 @@ void __gcov_init (struct gcov_info *p __attribute__ ((unused))) {}\n #include <sys/stat.h>\n #endif\n \n+#if HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+\n #ifdef L_gcov\n \n /* A utility function for outputting errors.  */\n@@ -334,30 +338,65 @@ merge_one_data (const char *filename,\n   return -1;\n }\n \n+#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n+\n /* Store all TOP N counters where each has a dynamic length.  */\n \n static void\n-write_top_counters (const struct gcov_ctr_info *ci_ptr,\n-\t\t    unsigned t_ix,\n-\t\t    gcov_unsigned_t n_counts)\n+write_topn_counters (const struct gcov_ctr_info *ci_ptr,\n+\t\t     unsigned t_ix,\n+\t\t     gcov_unsigned_t n_counts)\n {\n   unsigned counters = n_counts / GCOV_TOPN_MEM_COUNTERS;\n   gcc_assert (n_counts % GCOV_TOPN_MEM_COUNTERS == 0);\n+\n+  /* It can happen in a multi-threaded environment that number of counters is\n+     different from the size of the corresponding linked lists.  */\n+#define LIST_SIZE_MIN_LENGTH 4 * 1024\n+\n+  static unsigned *list_sizes = NULL;\n+  static unsigned list_size_length = 0;\n+\n+  if (list_sizes == NULL || counters > list_size_length)\n+    {\n+      list_size_length = MAX (LIST_SIZE_MIN_LENGTH, 2 * counters);\n+#if HAVE_SYS_MMAN_H\n+      list_sizes\n+\t= (unsigned *)malloc_mmap (list_size_length * sizeof (unsigned));\n+#endif\n+\n+      /* Malloc fallback.  */\n+      if (list_sizes == NULL)\n+\tlist_sizes = (unsigned *)xmalloc (list_size_length * sizeof (unsigned));\n+    }\n+\n+  memset (list_sizes, 0, counters * sizeof (unsigned));\n   unsigned pair_total = 0;\n+\n   for (unsigned i = 0; i < counters; i++)\n-    pair_total += ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 1];\n+    {\n+      gcov_type start = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 2];\n+      for (struct gcov_kvp *node = (struct gcov_kvp *)(intptr_t)start;\n+\t   node != NULL; node = node->next)\n+\t{\n+\t  ++pair_total;\n+\t  ++list_sizes[i];\n+\t}\n+    }\n+\n   unsigned disk_size = GCOV_TOPN_DISK_COUNTERS * counters + 2 * pair_total;\n   gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n \t\t\t GCOV_TAG_COUNTER_LENGTH (disk_size));\n \n   for (unsigned i = 0; i < counters; i++)\n     {\n-      gcov_type pair_count = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 1];\n       gcov_write_counter (ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i]);\n-      gcov_write_counter (pair_count);\n+      gcov_write_counter (list_sizes[i]);\n       gcov_type start = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 2];\n+\n+      unsigned j = 0;\n       for (struct gcov_kvp *node = (struct gcov_kvp *)(intptr_t)start;\n-\t   node != NULL; node = node->next)\n+\t   j < list_sizes[i]; node = node->next, j++)\n \t{\n \t  gcov_write_counter (node->value);\n \t  gcov_write_counter (node->count);\n@@ -425,7 +464,7 @@ write_one_data (const struct gcov_info *gi_ptr,\n \t  n_counts = ci_ptr->num;\n \n \t  if (t_ix == GCOV_COUNTER_V_TOPN || t_ix == GCOV_COUNTER_V_INDIR)\n-\t    write_top_counters (ci_ptr, t_ix, n_counts);\n+\t    write_topn_counters (ci_ptr, t_ix, n_counts);\n \t  else\n \t    {\n \t      /* Do not stream when all counters are zero.  */"}, {"sha": "2780cc098c86dd709a5b02cb07a5a7ba168411b6", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8fc0c31a9ae759fe9bf59b5418abf2af938f91/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=6a8fc0c31a9ae759fe9bf59b5418abf2af938f91", "patch": "@@ -409,6 +409,19 @@ gcov_counter_add (gcov_type *counter, gcov_type value,\n     *counter += value;\n }\n \n+#if HAVE_SYS_MMAN_H\n+\n+/* Allocate LENGTH with mmap function.  */\n+\n+static inline void *\n+malloc_mmap (size_t length)\n+{\n+  return mmap (NULL, length, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+}\n+\n+#endif\n+\n /* Allocate gcov_kvp from statically pre-allocated pool,\n    or use heap otherwise.  */\n \n@@ -424,9 +437,7 @@ allocate_gcov_kvp (void)\n   if (__gcov_kvp_dynamic_pool == NULL\n       || __gcov_kvp_dynamic_pool_index >= __gcov_kvp_dynamic_pool_size)\n     {\n-      void *ptr = mmap (NULL, MMAP_CHUNK_SIZE,\n-\t\t\tPROT_READ | PROT_WRITE,\n-\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+      void *ptr = malloc_mmap (MMAP_CHUNK_SIZE);\n       if (ptr != MAP_FAILED)\n \t{\n \t  __gcov_kvp_dynamic_pool = ptr;"}]}