{"sha": "ca44152fc58297f5c0bef56190b6968549e1438e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0NDE1MmZjNTgyOTdmNWMwYmVmNTYxOTBiNjk2ODU0OWUxNDM4ZQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2008-04-08T06:55:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:55:06Z"}, "message": "sem_aggr.adb (Analyze_N_Extension_Aggregate): Add legality checks for the ancestor part of an extension aggregate for a...\n\n2008-04-08  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb (Analyze_N_Extension_Aggregate): Add legality checks for\n\tthe ancestor part of an extension aggregate for a limited type.\n\t(Resolve_Array_Aggregate): Issue warning for sliding of aggregate with\n\tenumeration index bounds.\n\t(Resolve_Array_Aggregate): Add circuit for diagnosing missing choices\n\twhen array is too short.\n\t(Check_Expr_OK_In_Limited_Aggregate): Move function\n\tCheck_Non_Limited_Type from Resolve_Record_Aggregate to top level (and\n\tchange name).\n\t(Resolve_Array_Aggregate.Resolve_Aggr_Expr):\n\tCheck_Expr_OK_In_Limited_Aggregates called to check for illegal limited\n\tcomponent associations.\n\t(Check_Non_Limited_Type): Moved to outer level and renamed.\n\t(Resolve_Record_Aggregate): In an extension aggregate, an association\n\twith a box initialization can only designate a component of the\n\textension, not a component inherited from the given ancestor\n\n\t* sem_case.adb: Use new Is_Standard_Character_Type predicate\n\nFrom-SVN: r134049", "tree": {"sha": "8558caa298fd9fd8a83a4440596ce4716e5405de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8558caa298fd9fd8a83a4440596ce4716e5405de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca44152fc58297f5c0bef56190b6968549e1438e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca44152fc58297f5c0bef56190b6968549e1438e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca44152fc58297f5c0bef56190b6968549e1438e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca44152fc58297f5c0bef56190b6968549e1438e/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f89b7956cbaad5bb0e7f84c1a44b49a88080b99c"}], "stats": {"total": 269, "additions": 209, "deletions": 60}, "files": [{"sha": "60998611f7e09d65e525489815bd643834314bdc", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 206, "deletions": 49, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca44152fc58297f5c0bef56190b6968549e1438e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca44152fc58297f5c0bef56190b6968549e1438e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=ca44152fc58297f5c0bef56190b6968549e1438e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -89,6 +89,11 @@ package body Sem_Aggr is\n    --\n    --  It would be better to pass the proper type for Typ ???\n \n+   procedure Check_Expr_OK_In_Limited_Aggregate (Expr : Node_Id);\n+   --  Check that Expr is either not limited or else is one of the cases of\n+   --  expressions allowed for a limited component association (namely, an\n+   --  aggregate, function call, or <> notation). Report error for violations.\n+\n    ------------------------------------------------------\n    -- Subprograms used for RECORD AGGREGATE Processing --\n    ------------------------------------------------------\n@@ -215,10 +220,10 @@ package body Sem_Aggr is\n       Index          : Node_Id;\n       Index_Constr   : Node_Id;\n       Component_Typ  : Entity_Id;\n-      Others_Allowed : Boolean)\n-      return           Boolean;\n+      Others_Allowed : Boolean) return Boolean;\n    --  This procedure performs the semantic checks for an array aggregate.\n    --  True is returned if the aggregate resolution succeeds.\n+   --\n    --  The procedure works by recursively checking each nested aggregate.\n    --  Specifically, after checking a sub-aggregate nested at the i-th level\n    --  we recursively check all the subaggregates at the i+1-st level (if any).\n@@ -412,7 +417,7 @@ package body Sem_Aggr is\n       --  This is really expansion activity, so make sure that expansion\n       --  is on and is allowed.\n \n-      if not Expander_Active or else In_Default_Expression then\n+      if not Expander_Active or else In_Spec_Expression then\n          return;\n       end if;\n \n@@ -680,7 +685,6 @@ package body Sem_Aggr is\n       Set_First_Index    (Itype, First (Index_Constraints));\n       Set_Is_Constrained (Itype, True);\n       Set_Is_Internal    (Itype, True);\n-      Init_Size_Align    (Itype);\n \n       --  A simple optimization: purely positional aggregates of static\n       --  components should be passed to gigi unexpanded whenever possible,\n@@ -698,7 +702,7 @@ package body Sem_Aggr is\n       --  and we must not generate a freeze node for the type, or else it\n       --  will appear incomplete to gigi.\n \n-      if Is_Packed (Itype) and then not In_Default_Expression\n+      if Is_Packed (Itype) and then not In_Spec_Expression\n         and then Expander_Active\n       then\n          Freeze_Itype (Itype, N);\n@@ -762,6 +766,23 @@ package body Sem_Aggr is\n       end if;\n    end Check_Misspelled_Component;\n \n+   ----------------------------------------\n+   -- Check_Expr_OK_In_Limited_Aggregate --\n+   ----------------------------------------\n+\n+   procedure Check_Expr_OK_In_Limited_Aggregate (Expr : Node_Id) is\n+   begin\n+      if Is_Limited_Type (Etype (Expr))\n+         and then Comes_From_Source (Expr)\n+         and then not In_Instance_Body\n+      then\n+         if not OK_For_Limited_Init (Expr) then\n+            Error_Msg_N (\"initialization not allowed for limited types\", Expr);\n+            Explain_Limited_Type (Etype (Expr), Expr);\n+         end if;\n+      end if;\n+   end Check_Expr_OK_In_Limited_Aggregate;\n+\n    ----------------------------------------\n    -- Check_Static_Discriminated_Subtype --\n    ----------------------------------------\n@@ -909,18 +930,14 @@ package body Sem_Aggr is\n \n          --  First a special test, for the case of a positional aggregate\n          --  of characters which can be replaced by a string literal.\n+\n          --  Do not perform this transformation if this was a string literal\n          --  to start with, whose components needed constraint checks, or if\n          --  the component type is non-static, because it will require those\n          --  checks and be transformed back into an aggregate.\n \n          if Number_Dimensions (Typ) = 1\n-           and then\n-             (Root_Type (Component_Type (Typ)) = Standard_Character\n-                or else\n-              Root_Type (Component_Type (Typ)) = Standard_Wide_Character\n-                or else\n-              Root_Type (Component_Type (Typ)) = Standard_Wide_Wide_Character)\n+           and then Is_Standard_Character_Type (Component_Type (Typ))\n            and then No (Component_Associations (N))\n            and then not Is_Limited_Composite (Typ)\n            and then not Is_Private_Composite (Typ)\n@@ -1078,8 +1095,7 @@ package body Sem_Aggr is\n       Index          : Node_Id;\n       Index_Constr   : Node_Id;\n       Component_Typ  : Entity_Id;\n-      Others_Allowed : Boolean)\n-      return           Boolean\n+      Others_Allowed : Boolean) return Boolean\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -1126,8 +1142,7 @@ package body Sem_Aggr is\n \n       function Resolve_Aggr_Expr\n         (Expr        : Node_Id;\n-         Single_Elmt : Boolean)\n-         return        Boolean;\n+         Single_Elmt : Boolean) return Boolean;\n       --  Resolves aggregate expression Expr. Returs False if resolution\n       --  fails. If Single_Elmt is set to False, the expression Expr may be\n       --  used to initialize several array aggregate elements (this can\n@@ -1377,8 +1392,7 @@ package body Sem_Aggr is\n \n       function Resolve_Aggr_Expr\n         (Expr        : Node_Id;\n-         Single_Elmt : Boolean)\n-         return        Boolean\n+         Single_Elmt : Boolean) return Boolean\n       is\n          Nxt_Ind        : constant Node_Id := Next_Index (Index);\n          Nxt_Ind_Constr : constant Node_Id := Next_Index (Index_Constr);\n@@ -1435,9 +1449,10 @@ package body Sem_Aggr is\n \n          elsif Single_Elmt\n            or else not Expander_Active\n-           or else In_Default_Expression\n+           or else In_Spec_Expression\n          then\n             Analyze_And_Resolve (Expr, Component_Typ);\n+            Check_Expr_OK_In_Limited_Aggregate (Expr);\n             Check_Non_Static_Context (Expr);\n             Aggregate_Constraint_Checks (Expr, Component_Typ);\n             Check_Unset_Reference (Expr);\n@@ -1560,7 +1575,6 @@ package body Sem_Aggr is\n       --  STEP 2: Process named components\n \n       if No (Expressions (N)) then\n-\n          if Others_Present then\n             Case_Table_Size := Nb_Choices - 1;\n          else\n@@ -1622,6 +1636,8 @@ package body Sem_Aggr is\n                         return Failure;\n                      end if;\n \n+                  --  Case of subtype indication\n+\n                   elsif Nkind (Choice) = N_Subtype_Indication then\n                      Resolve_Discrete_Subtype_Indication (Choice, Index_Base);\n \n@@ -1631,7 +1647,9 @@ package body Sem_Aggr is\n                      Get_Index_Bounds (Choice, Low, High);\n                      Check_Bounds (S_Low, S_High, Low, High);\n \n-                  else  --  Choice is a range or an expression\n+                  --  Case of range or expression\n+\n+                  else\n                      Resolve (Choice, Index_Base);\n                      Check_Unset_Reference (Choice);\n                      Check_Non_Static_Context (Choice);\n@@ -1737,7 +1755,6 @@ package body Sem_Aggr is\n                      return Failure;\n \n                   elsif not Others_Present then\n-\n                      Hi_Val := Expr_Value (Table (J).Choice_Hi);\n                      Lo_Val := Expr_Value (Table (J + 1).Choice_Lo);\n \n@@ -1805,10 +1822,123 @@ package body Sem_Aggr is\n                Choices_High := Table (Nb_Discrete_Choices).Choice_Hi;\n             end if;\n \n+            --  If Others is present, then bounds of aggregate come from the\n+            --  index constraint (not the choices in the aggregate itself).\n+\n             if Others_Present then\n                Get_Index_Bounds (Index_Constr, Aggr_Low, Aggr_High);\n \n+            --  No others clause present\n+\n             else\n+               --  Special processing if others allowed and not present. This\n+               --  means that the bounds of the aggregate come from the index\n+               --  constraint (and the length must match).\n+\n+               if Others_Allowed then\n+                  Get_Index_Bounds (Index_Constr, Aggr_Low, Aggr_High);\n+\n+                  --  If others allowed, and no others present, then the array\n+                  --  should cover all index values. If it does not, we will\n+                  --  get a length check warning, but there is two cases where\n+                  --  an additional warning is useful:\n+\n+                  --  If we have no positional components, and the length is\n+                  --  wrong (which we can tell by others being allowed with\n+                  --  missing components), and the index type is an enumeration\n+                  --  type, then issue appropriate warnings about these missing\n+                  --  components. They are only warnings, since the aggregate\n+                  --  is fine, it's just the wrong length. We skip this check\n+                  --  for standard character types (since there are no literals\n+                  --  and it is too much trouble to concoct them), and also if\n+                  --  any of the bounds have not-known-at-compile-time values.\n+\n+                  --  Another case warranting a warning is when the length is\n+                  --  right, but as above we have an index type that is an\n+                  --  enumeration, and the bounds do not match. This is a\n+                  --  case where dubious sliding is allowed and we generate\n+                  --  a warning that the bounds do not match.\n+\n+                  if No (Expressions (N))\n+                    and then Nkind (Index) = N_Range\n+                    and then Is_Enumeration_Type (Etype (Index))\n+                    and then not Is_Standard_Character_Type (Etype (Index))\n+                    and then Compile_Time_Known_Value (Aggr_Low)\n+                    and then Compile_Time_Known_Value (Aggr_High)\n+                    and then Compile_Time_Known_Value (Choices_Low)\n+                    and then Compile_Time_Known_Value (Choices_High)\n+                  then\n+                     declare\n+                        ALo : constant Node_Id := Expr_Value_E (Aggr_Low);\n+                        AHi : constant Node_Id := Expr_Value_E (Aggr_High);\n+                        CLo : constant Node_Id := Expr_Value_E (Choices_Low);\n+                        CHi : constant Node_Id := Expr_Value_E (Choices_High);\n+\n+                        Ent : Entity_Id;\n+\n+                     begin\n+                        --  Warning case one, missing values at start/end. Only\n+                        --  do the check if the number of entries is too small.\n+\n+                        if (Enumeration_Pos (CHi) - Enumeration_Pos (CLo))\n+                              <\n+                           (Enumeration_Pos (AHi) - Enumeration_Pos (ALo))\n+                        then\n+                           Error_Msg_N\n+                             (\"missing index value(s) in array aggregate?\", N);\n+\n+                           --  Output missing value(s) at start\n+\n+                           if Chars (ALo) /= Chars (CLo) then\n+                              Ent := Prev (CLo);\n+\n+                              if Chars (ALo) = Chars (Ent) then\n+                                 Error_Msg_Name_1 := Chars (ALo);\n+                                 Error_Msg_N (\"\\  %?\", N);\n+                              else\n+                                 Error_Msg_Name_1 := Chars (ALo);\n+                                 Error_Msg_Name_2 := Chars (Ent);\n+                                 Error_Msg_N (\"\\  % .. %?\", N);\n+                              end if;\n+                           end if;\n+\n+                           --  Output missing value(s) at end\n+\n+                           if Chars (AHi) /= Chars (CHi) then\n+                              Ent := Next (CHi);\n+\n+                              if Chars (AHi) = Chars (Ent) then\n+                                 Error_Msg_Name_1 := Chars (Ent);\n+                                 Error_Msg_N (\"\\  %?\", N);\n+                              else\n+                                 Error_Msg_Name_1 := Chars (Ent);\n+                                 Error_Msg_Name_2 := Chars (AHi);\n+                                 Error_Msg_N (\"\\  % .. %?\", N);\n+                              end if;\n+                           end if;\n+\n+                        --  Warning case 2, dubious sliding. The First_Subtype\n+                        --  test distinguishes between a constrained type where\n+                        --  sliding is not allowed (so we will get a warning\n+                        --  later that Constraint_Error will be raised), and\n+                        --  the unconstrained case where sliding is permitted.\n+\n+                        elsif (Enumeration_Pos (CHi) - Enumeration_Pos (CLo))\n+                                 =\n+                              (Enumeration_Pos (AHi) - Enumeration_Pos (ALo))\n+                          and then Chars (ALo) /= Chars (CLo)\n+                          and then\n+                            not Is_Constrained (First_Subtype (Etype (N)))\n+                        then\n+                           Error_Msg_N\n+                             (\"bounds of aggregate do not match target?\", N);\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               --  If no others, aggregate bounds come from aggegate\n+\n                Aggr_Low  := Choices_Low;\n                Aggr_High := Choices_High;\n             end if;\n@@ -1976,10 +2106,44 @@ package body Sem_Aggr is\n       I      : Interp_Index;\n       It     : Interp;\n \n+      function Valid_Limited_Ancestor (Anc : Node_Id) return Boolean;\n+      --  If the type is limited, verify that the ancestor part is a legal\n+      --  expression (aggregate or function call, including 'Input)) that\n+      --  does not require a copy, as specified in 7.5 (2).\n+\n       function Valid_Ancestor_Type return Boolean;\n       --  Verify that the type of the ancestor part is a non-private ancestor\n       --  of the expected type.\n \n+      ----------------------------\n+      -- Valid_Limited_Ancestor --\n+      ----------------------------\n+\n+      function Valid_Limited_Ancestor (Anc : Node_Id) return Boolean is\n+      begin\n+         if Is_Entity_Name (Anc)\n+           and then Is_Type (Entity (Anc))\n+         then\n+            return True;\n+\n+         elsif Nkind_In (Anc, N_Aggregate, N_Function_Call) then\n+            return True;\n+\n+         elsif Nkind (Anc) = N_Attribute_Reference\n+           and then Attribute_Name (Anc) = Name_Input\n+         then\n+            return True;\n+\n+         elsif\n+           Nkind (Anc) = N_Qualified_Expression\n+         then\n+            return Valid_Limited_Ancestor (Expression (Anc));\n+\n+         else\n+            return False;\n+         end if;\n+      end Valid_Limited_Ancestor;\n+\n       -------------------------\n       -- Valid_Ancestor_Type --\n       -------------------------\n@@ -2020,6 +2184,13 @@ package body Sem_Aggr is\n             Error_Msg_N (\"aggregate type cannot be limited\", N);\n             Explain_Limited_Type (Typ, N);\n             return;\n+\n+         elsif Valid_Limited_Ancestor (A) then\n+            null;\n+\n+         else\n+            Error_Msg_N\n+              (\"limited ancestor part must be aggregate or function call\", A);\n          end if;\n \n       elsif Is_Class_Wide_Type (Typ) then\n@@ -2429,31 +2600,6 @@ package body Sem_Aggr is\n          return Expr;\n       end Get_Value;\n \n-      procedure Check_Non_Limited_Type (Expr : Node_Id);\n-      --  Relax check to allow the default initialization of limited types.\n-      --  For example:\n-      --      record\n-      --         C : Lim := (..., others => <>);\n-      --      end record;\n-\n-      ----------------------------\n-      -- Check_Non_Limited_Type --\n-      ----------------------------\n-\n-      procedure Check_Non_Limited_Type (Expr : Node_Id) is\n-      begin\n-         if Is_Limited_Type (Etype (Expr))\n-            and then Comes_From_Source (Expr)\n-            and then not In_Instance_Body\n-         then\n-            if not OK_For_Limited_Init (Expr) then\n-               Error_Msg_N\n-                 (\"initialization not allowed for limited types\", N);\n-               Explain_Limited_Type (Etype (Expr), Expr);\n-            end if;\n-         end if;\n-      end Check_Non_Limited_Type;\n-\n       -----------------------\n       -- Resolve_Aggr_Expr --\n       -----------------------\n@@ -2574,7 +2720,7 @@ package body Sem_Aggr is\n          end if;\n \n          Analyze_And_Resolve (Expr, Expr_Type);\n-         Check_Non_Limited_Type (Expr);\n+         Check_Expr_OK_In_Limited_Aggregate (Expr);\n          Check_Non_Static_Context (Expr);\n          Check_Unset_Reference (Expr);\n \n@@ -3246,7 +3392,18 @@ package body Sem_Aggr is\n                         C := First_Component (Typ);\n                         while Present (C) loop\n                            if Chars (C) = Chars (Selectr) then\n-                              exit;\n+\n+                              --  If the context is an extension aggregate,\n+                              --  the component must not be inherited from\n+                              --  the ancestor part of the aggregate.\n+\n+                              if Nkind (N) /= N_Extension_Aggregate\n+                                or else\n+                                  Scope (Original_Record_Component (C)) /=\n+                                                     Etype (Ancestor_Part (N))\n+                              then\n+                                 exit;\n+                              end if;\n                            end if;\n \n                            Next_Component (C);"}, {"sha": "d85d7970b88c0b2b955d107337ae48aa68e198fe", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca44152fc58297f5c0bef56190b6968549e1438e/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca44152fc58297f5c0bef56190b6968549e1438e/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=ca44152fc58297f5c0bef56190b6968549e1438e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -268,10 +268,7 @@ package body Sem_Case is\n       --  For character, or wide [wide] character. If 7-bit ASCII graphic\n       --  range, then build and return appropriate character literal name\n \n-      if Rtp = Standard_Character\n-        or else Rtp = Standard_Wide_Character\n-        or else Rtp = Standard_Wide_Wide_Character\n-      then\n+      if Is_Standard_Character_Type (Ctype) then\n          C := UI_To_Int (Value);\n \n          if C in 16#20# .. 16#7E# then\n@@ -425,12 +422,7 @@ package body Sem_Case is\n          --  of literals to search. Instead, a N_Character_Literal node\n          --  is created with the appropriate Char_Code and Chars fields.\n \n-         if Root_Type (Choice_Type) = Standard_Character\n-              or else\n-            Root_Type (Choice_Type) = Standard_Wide_Character\n-              or else\n-            Root_Type (Choice_Type) = Standard_Wide_Wide_Character\n-         then\n+         if Is_Standard_Character_Type (Choice_Type) then\n             Set_Character_Literal_Name (Char_Code (UI_To_Int (Value)));\n             Lit := New_Node (N_Character_Literal, Loc);\n             Set_Chars (Lit, Name_Find);"}]}