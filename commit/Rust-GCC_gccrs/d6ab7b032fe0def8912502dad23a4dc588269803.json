{"sha": "d6ab7b032fe0def8912502dad23a4dc588269803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZhYjdiMDMyZmUwZGVmODkxMjUwMmRhZDIzYTRkYzU4ODI2OTgwMw==", "commit": {"author": {"name": "Helge Deller", "email": "deller@gmx.de", "date": "2008-09-07T16:53:31Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2008-09-07T16:53:31Z"}, "message": "linux-atomic.c: New file.\n\n        * pa/linux-atomic.c: New file.\n\t* pa/t-linux (LIB2FUNCS_STATIC_EXTRA): Define.\n\t* pa/t-linux64 (LIB2FUNCS_STATIC_EXTRA): Define.\n\nFrom-SVN: r140091", "tree": {"sha": "a428ba3e82e701c45def5913d100de25d574ae21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a428ba3e82e701c45def5913d100de25d574ae21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6ab7b032fe0def8912502dad23a4dc588269803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ab7b032fe0def8912502dad23a4dc588269803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ab7b032fe0def8912502dad23a4dc588269803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ab7b032fe0def8912502dad23a4dc588269803/comments", "author": {"login": "hdeller", "id": 32447367, "node_id": "MDQ6VXNlcjMyNDQ3MzY3", "avatar_url": "https://avatars.githubusercontent.com/u/32447367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hdeller", "html_url": "https://github.com/hdeller", "followers_url": "https://api.github.com/users/hdeller/followers", "following_url": "https://api.github.com/users/hdeller/following{/other_user}", "gists_url": "https://api.github.com/users/hdeller/gists{/gist_id}", "starred_url": "https://api.github.com/users/hdeller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hdeller/subscriptions", "organizations_url": "https://api.github.com/users/hdeller/orgs", "repos_url": "https://api.github.com/users/hdeller/repos", "events_url": "https://api.github.com/users/hdeller/events{/privacy}", "received_events_url": "https://api.github.com/users/hdeller/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a834e097ead6d8cc126bb17170b186e199e686e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a834e097ead6d8cc126bb17170b186e199e686e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a834e097ead6d8cc126bb17170b186e199e686e4"}], "stats": {"total": 309, "additions": 309, "deletions": 0}, "files": [{"sha": "7e482f488517c692ec6e8dfa54930ad6147744e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6ab7b032fe0def8912502dad23a4dc588269803", "patch": "@@ -1,3 +1,9 @@\n+2008-09-07  Helge Deller  <deller@gmx.de>\n+\n+        * pa/linux-atomic.c: New file.\n+\t* pa/t-linux (LIB2FUNCS_STATIC_EXTRA): Define.\n+\t* pa/t-linux64 (LIB2FUNCS_STATIC_EXTRA): Define.\n+\n 2008-09-07  Richard Guenther  <rguenther@suse.de>\n             Ira Rosen  <irar@il.ibm.com>\n "}, {"sha": "23f5f736c657821b91f3ee55bc2a8960b2fb0e1c", "filename": "gcc/config/pa/linux-atomic.c", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Flinux-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Flinux-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flinux-atomic.c?ref=d6ab7b032fe0def8912502dad23a4dc588269803", "patch": "@@ -0,0 +1,300 @@\n+/* Linux-specific atomic operations for PA Linux.\n+   Copyright (C) 2008 Free Software Foundation, Inc.\n+   Based on code contributed by CodeSourcery for ARM EABI Linux.\n+   Modifications for PA Linux by Helge Deller <deller@gmx.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include <errno.h>\n+\n+/* All PA-RISC implementations supported by linux have strongly\n+   ordered loads and stores.  Only cache flushes and purges can be\n+   delayed.  The data cache implementations are all globally\n+   coherent.  Thus, there is no need to synchonize memory accesses.\n+\n+   GCC automatically issues a asm memory barrier when it encounters\n+   a __sync_synchronize builtin.  Thus, we do not need to define this\n+   builtin.\n+\n+   We implement byte, short and int versions of each atomic operation\n+   using the kernel helper defined below.  There is no support for\n+   64-bit operations yet.  */\n+\n+/* A privileged instruction to crash a userspace program with SIGILL.  */\n+#define ABORT_INSTRUCTION asm (\"iitlbp %r0,(%sr0, %r0)\")\n+\n+/* Determine kernel LWS function call (0=32-bit, 1=64-bit userspace).  */\n+#define LWS_CAS (sizeof(unsigned long) == 4 ? 0 : 1)\n+\n+/* Kernel helper for compare-and-exchange a 32-bit value.  */\n+static inline long\n+__kernel_cmpxchg (int oldval, int newval, int *mem)\n+{\n+  register unsigned long lws_mem asm(\"r26\") = (unsigned long) (mem);\n+  register long lws_ret   asm(\"r28\");\n+  register long lws_errno asm(\"r21\");\n+  register int lws_old asm(\"r25\") = oldval;\n+  register int lws_new asm(\"r24\") = newval;\n+  asm volatile (\t\"ble\t0xb0(%%sr2, %%r0)\t\\n\\t\"\n+\t\t\t\"ldi\t%5, %%r20\t\t\\n\\t\"\n+\t: \"=r\" (lws_ret), \"=r\" (lws_errno), \"=r\" (lws_mem),\n+\t  \"=r\" (lws_old), \"=r\" (lws_new)\n+\t: \"i\" (LWS_CAS), \"2\" (lws_mem), \"3\" (lws_old), \"4\" (lws_new)\n+\t: \"r1\", \"r20\", \"r22\", \"r23\", \"r29\", \"r31\", \"memory\"\n+  );\n+  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))\n+    ABORT_INSTRUCTION;\n+  return lws_errno;\n+}\n+\n+#define HIDDEN __attribute__ ((visibility (\"hidden\")))\n+\n+/* Big endian masks  */\n+#define INVERT_MASK_1 24\n+#define INVERT_MASK_2 16\n+\n+#define MASK_1 0xffu\n+#define MASK_2 0xffffu\n+\n+#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_fetch_and_##OP##_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure, tmp;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      tmp = *ptr;\t\t\t\t\t\t\t\\\n+      failure = __kernel_cmpxchg (tmp, PFX_OP tmp INF_OP val, ptr);\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return tmp;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FETCH_AND_OP_WORD (add,   , +)\n+FETCH_AND_OP_WORD (sub,   , -)\n+FETCH_AND_OP_WORD (or,    , |)\n+FETCH_AND_OP_WORD (and,   , &)\n+FETCH_AND_OP_WORD (xor,   , ^)\n+FETCH_AND_OP_WORD (nand, ~, &)\n+\n+#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH\n+#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH\n+\n+/* Implement both __sync_<op>_and_fetch and __sync_fetch_and_<op> for\n+   subword-sized quantities.  */\n+\n+#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, WIDTH, RETURN)\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  NAME##_##RETURN (OP, WIDTH) (TYPE *ptr, TYPE val)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned long) ptr & ~3);\t\t\t\\\n+    unsigned int mask, shift, oldval, newval;\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      oldval = *wordptr;\t\t\t\t\t\t\\\n+      newval = ((PFX_OP ((oldval & mask) >> shift)\t\t\t\\\n+                 INF_OP (unsigned int) val) << shift) & mask;\t\t\\\n+      newval |= oldval & ~mask;\t\t\t\t\t\t\\\n+      failure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (RETURN & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_SYNC_OP (add,   , +, short, 2, oldval)\n+SUBWORD_SYNC_OP (sub,   , -, short, 2, oldval)\n+SUBWORD_SYNC_OP (or,    , |, short, 2, oldval)\n+SUBWORD_SYNC_OP (and,   , &, short, 2, oldval)\n+SUBWORD_SYNC_OP (xor,   , ^, short, 2, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, short, 2, oldval)\n+\n+SUBWORD_SYNC_OP (add,   , +, char, 1, oldval)\n+SUBWORD_SYNC_OP (sub,   , -, char, 1, oldval)\n+SUBWORD_SYNC_OP (or,    , |, char, 1, oldval)\n+SUBWORD_SYNC_OP (and,   , &, char, 1, oldval)\n+SUBWORD_SYNC_OP (xor,   , ^, char, 1, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, char, 1, oldval)\n+\n+#define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_##OP##_and_fetch_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int tmp, failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      tmp = *ptr;\t\t\t\t\t\t\t\\\n+      failure = __kernel_cmpxchg (tmp, PFX_OP tmp INF_OP val, ptr);\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return PFX_OP tmp INF_OP val;\t\t\t\t\t\\\n+  }\n+\n+OP_AND_FETCH_WORD (add,   , +)\n+OP_AND_FETCH_WORD (sub,   , -)\n+OP_AND_FETCH_WORD (or,    , |)\n+OP_AND_FETCH_WORD (and,   , &)\n+OP_AND_FETCH_WORD (xor,   , ^)\n+OP_AND_FETCH_WORD (nand, ~, &)\n+\n+SUBWORD_SYNC_OP (add,   , +, short, 2, newval)\n+SUBWORD_SYNC_OP (sub,   , -, short, 2, newval)\n+SUBWORD_SYNC_OP (or,    , |, short, 2, newval)\n+SUBWORD_SYNC_OP (and,   , &, short, 2, newval)\n+SUBWORD_SYNC_OP (xor,   , ^, short, 2, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, short, 2, newval)\n+\n+SUBWORD_SYNC_OP (add,   , +, char, 1, newval)\n+SUBWORD_SYNC_OP (sub,   , -, char, 1, newval)\n+SUBWORD_SYNC_OP (or,    , |, char, 1, newval)\n+SUBWORD_SYNC_OP (and,   , &, char, 1, newval)\n+SUBWORD_SYNC_OP (xor,   , ^, char, 1, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, char, 1, newval)\n+\n+int HIDDEN\n+__sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int actual_oldval, fail;\n+    \n+  while (1)\n+    {\n+      actual_oldval = *ptr;\n+\n+      if (oldval != actual_oldval)\n+\treturn actual_oldval;\n+\n+      fail = __kernel_cmpxchg (actual_oldval, newval, ptr);\n+  \n+      if (!fail)\n+\treturn oldval;\n+    }\n+}\n+\n+#define SUBWORD_VAL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t       TYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *)((unsigned long) ptr & ~3), fail;\t\t\\\n+    unsigned int mask, shift, actual_oldval, actual_newval;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    while (1)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tactual_oldval = *wordptr;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (((actual_oldval & mask) >> shift) != (unsigned int) oldval)\t\\\n+          return (actual_oldval & mask) >> shift;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tactual_newval = (actual_oldval & ~mask)\t\t\t\t\\\n+\t\t\t| (((unsigned int) newval << shift) & mask);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfail = __kernel_cmpxchg (actual_oldval, actual_newval,\t\t\\\n+\t\t\t\t wordptr);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (!fail)\t\t\t\t\t\t\t\\\n+\t  return oldval;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_VAL_CAS (short, 2)\n+SUBWORD_VAL_CAS (char,  1)\n+\n+typedef unsigned char bool;\n+\n+bool HIDDEN\n+__sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int failure = __kernel_cmpxchg (oldval, newval, ptr);\n+  return (failure == 0);\n+}\n+\n+#define SUBWORD_BOOL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  bool HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t\tTYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE actual_oldval\t\t\t\t\t\t\t\\\n+      = __sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval);\t\\\n+    return (oldval == actual_oldval);\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_BOOL_CAS (short, 2)\n+SUBWORD_BOOL_CAS (char,  1)\n+\n+int HIDDEN\n+__sync_lock_test_and_set_4 (int *ptr, int val)\n+{\n+  int failure, oldval;\n+\n+  do {\n+    oldval = *ptr;\n+    failure = __kernel_cmpxchg (oldval, val, ptr);\n+  } while (failure != 0);\n+\n+  return oldval;\n+}\n+\n+#define SUBWORD_TEST_AND_SET(TYPE, WIDTH)\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+    unsigned int oldval, newval, shift, mask;\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned long) ptr & ~3);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      oldval = *wordptr;\t\t\t\t\t\t\\\n+      newval = (oldval & ~mask)\t\t\t\t\t\t\\\n+\t       | (((unsigned int) val << shift) & mask);\t\t\\\n+      failure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+    } while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (oldval & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_TEST_AND_SET (short, 2)\n+SUBWORD_TEST_AND_SET (char,  1)\n+\n+#define SYNC_LOCK_RELEASE(TYPE, WIDTH)\t\t\t\t\t\\\n+  void HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_release_##WIDTH (TYPE *ptr)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    *ptr = 0;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SYNC_LOCK_RELEASE (int,   4)\n+SYNC_LOCK_RELEASE (short, 2)\n+SYNC_LOCK_RELEASE (char,  1)"}, {"sha": "4b56debac55e07eae1548696a8ea9d2cbb0e163e", "filename": "gcc/config/pa/t-linux", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-linux?ref=d6ab7b032fe0def8912502dad23a4dc588269803", "patch": "@@ -9,6 +9,7 @@ LIB1ASMSRC = pa/milli64.S\n TARGET_LIBGCC2_CFLAGS = -fPIC -DELF=1 -DLINUX=1\n \n LIB2FUNCS_EXTRA=fptr.c\n+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/pa/linux-atomic.c\n \n fptr.c: $(srcdir)/config/pa/fptr.c\n \trm -f fptr.c"}, {"sha": "48d45168cbdad2c9dad56ca36cf0257750cfe73c", "filename": "gcc/config/pa/t-linux64", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Ft-linux64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ab7b032fe0def8912502dad23a4dc588269803/gcc%2Fconfig%2Fpa%2Ft-linux64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-linux64?ref=d6ab7b032fe0def8912502dad23a4dc588269803", "patch": "@@ -8,5 +8,7 @@ LIB1ASMSRC = pa/milli64.S\n # Actually, hppa64 is always PIC but adding -fPIC does no harm.\n CRTSTUFF_T_CFLAGS_S = -fPIC\n \n+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/pa/linux-atomic.c\n+\n # Compile libgcc2.a as PIC.\n TARGET_LIBGCC2_CFLAGS = -fPIC -Dpa64=1 -DELF=1"}]}