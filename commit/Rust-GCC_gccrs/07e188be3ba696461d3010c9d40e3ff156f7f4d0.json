{"sha": "07e188be3ba696461d3010c9d40e3ff156f7f4d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlMTg4YmUzYmE2OTY0NjFkMzAxMGM5ZDQwZTNmZjE1NmY3ZjRkMA==", "commit": {"author": {"name": "Pascal Obry", "email": "obry@adacore.com", "date": "2015-01-06T09:47:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:47:48Z"}, "message": "adaint.c (ProcListEvt): Set to NULL.\n\n2015-01-06  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c (ProcListEvt): Set to NULL.\n\t* rtinit.c: New file.\n\t(__gnat_rt_init_count): New reference counter set to 0.\n\t(__gnat_runtime_initialize): Move code here from __gnat_initialize when\n\tthis code is actually needed for the runtime initialization. This\n\troutine returns immediately if the initialization has already been done.\n\t* final.c: Revert previous change.\n\t* rtfinal.c: New file.\n\t(__gnat_runtime_finalize)[Win32]: Add finalization of the critical\n\tsection and event. The default version of this routine is empty (except\n\tfor the reference counting code). This routine returns immediately if\n\tsome others libraries are referencing the runtime.\n\t* bindgen.adb (Gen_Adainit): Generate call to Runtime_Initialize\n\tremove circuitry to initialize the signal handler as this is\n\tnow done by the runtime initialization routine.\n\t(Gen_Adafinal): Generate call to Runtime_Finalize.\n\t* gnat_ugn.texi: Update documentation about concurrency and\n\tinitialization/finalization of the run-time.\n\t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in: Add\n\treferences to rtfinal.o and rtinit.o\n\nFrom-SVN: r219238", "tree": {"sha": "49e5167fbe92e8c71bbc6d289a4ae8a5c223d70b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e5167fbe92e8c71bbc6d289a4ae8a5c223d70b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07e188be3ba696461d3010c9d40e3ff156f7f4d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e188be3ba696461d3010c9d40e3ff156f7f4d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e188be3ba696461d3010c9d40e3ff156f7f4d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e188be3ba696461d3010c9d40e3ff156f7f4d0/comments", "author": {"login": "TurboGit", "id": 467069, "node_id": "MDQ6VXNlcjQ2NzA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/467069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TurboGit", "html_url": "https://github.com/TurboGit", "followers_url": "https://api.github.com/users/TurboGit/followers", "following_url": "https://api.github.com/users/TurboGit/following{/other_user}", "gists_url": "https://api.github.com/users/TurboGit/gists{/gist_id}", "starred_url": "https://api.github.com/users/TurboGit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TurboGit/subscriptions", "organizations_url": "https://api.github.com/users/TurboGit/orgs", "repos_url": "https://api.github.com/users/TurboGit/repos", "events_url": "https://api.github.com/users/TurboGit/events{/privacy}", "received_events_url": "https://api.github.com/users/TurboGit/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7665df2248b579883409aa636b08c99325c9810e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7665df2248b579883409aa636b08c99325c9810e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7665df2248b579883409aa636b08c99325c9810e"}], "stats": {"total": 1761, "additions": 1028, "deletions": 733}, "files": [{"sha": "6afb823f9e99bf756c8304f0e1e1c847b5f57114", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -1,3 +1,26 @@\n+2015-01-06  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c (ProcListEvt): Set to NULL.\n+\t* rtinit.c: New file.\n+\t(__gnat_rt_init_count): New reference counter set to 0.\n+\t(__gnat_runtime_initialize): Move code here from __gnat_initialize when\n+\tthis code is actually needed for the runtime initialization. This\n+\troutine returns immediately if the initialization has already been done.\n+\t* final.c: Revert previous change.\n+\t* rtfinal.c: New file.\n+\t(__gnat_runtime_finalize)[Win32]: Add finalization of the critical\n+\tsection and event. The default version of this routine is empty (except\n+\tfor the reference counting code). This routine returns immediately if\n+\tsome others libraries are referencing the runtime.\n+\t* bindgen.adb (Gen_Adainit): Generate call to Runtime_Initialize\n+\tremove circuitry to initialize the signal handler as this is\n+\tnow done by the runtime initialization routine.\n+\t(Gen_Adafinal): Generate call to Runtime_Finalize.\n+\t* gnat_ugn.texi: Update documentation about concurrency and\n+\tinitialization/finalization of the run-time.\n+\t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in: Add\n+\treferences to rtfinal.o and rtinit.o\n+\n 2015-01-06  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_attr.adb (Expand_N_Attribute_Reference): Add dummy entry"}, {"sha": "1bf7d667629a99f01805413496e5cd222009b267", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -2318,7 +2318,7 @@ static void SignalListChanged (void) {}\n #else\n \n CRITICAL_SECTION ProcListCS;\n-HANDLE ProcListEvt;\n+HANDLE ProcListEvt = NULL;\n \n static void EnterCS (void)\n {"}, {"sha": "0a9ece0b33db6854c67b04ecc1269af2e47c4d0e", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -390,6 +390,11 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n+      WBI (\"\");\n+      WBI (\"      procedure Runtime_Finalize;\");\n+      WBI (\"      pragma Import (C, Runtime_Finalize, \" &\n+             \"\"\"__gnat_runtime_finalize\"\");\");\n+      WBI (\"\");\n       WBI (\"   begin\");\n \n       if not CodePeer_Mode then\n@@ -399,6 +404,8 @@ package body Bindgen is\n          WBI (\"      Is_Elaborated := False;\");\n       end if;\n \n+      WBI (\"      Runtime_Finalize;\");\n+\n       --  On non-virtual machine targets, finalization is done differently\n       --  depending on whether this is the main program or a library.\n \n@@ -599,13 +606,9 @@ package body Bindgen is\n          --  installation, and indication of if it's been called previously.\n \n          WBI (\"\");\n-         WBI (\"      procedure Install_Handler;\");\n-         WBI (\"      pragma Import (C, Install_Handler, \" &\n-              \"\"\"__gnat_install_handler\"\");\");\n-         WBI (\"\");\n-         WBI (\"      Handler_Installed : Integer;\");\n-         WBI (\"      pragma Import (C, Handler_Installed, \" &\n-              \"\"\"__gnat_handler_installed\"\");\");\n+         WBI (\"      procedure Runtime_Initialize;\");\n+         WBI (\"      pragma Import (C, Runtime_Initialize, \" &\n+              \"\"\"__gnat_runtime_initialize\"\");\");\n \n          --  Import handlers attach procedure for sequential elaboration policy\n \n@@ -835,13 +838,9 @@ package body Bindgen is\n          --  In .NET, when binding with -z, we don't install the signal handler\n          --  to let the caller handle the last exception handler.\n \n-         if VM_Target /= CLI_Target\n-           or else Bind_Main_Program\n-         then\n+         if Bind_Main_Program then\n             WBI (\"\");\n-            WBI (\"      if Handler_Installed = 0 then\");\n-            WBI (\"         Install_Handler;\");\n-            WBI (\"      end if;\");\n+            WBI (\"      Runtime_Initialize;\");\n          end if;\n       end if;\n "}, {"sha": "2afcfa51bf501698a5e0ea6b0f8d8b653e7c03dd", "filename": "gcc/ada/final.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffinal.c?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -40,28 +40,10 @@ extern void __gnat_finalize (void);\n    at all, the intention is that this be replaced by system specific code\n    where finalization is required.  */\n \n-#if defined (__MINGW32__)\n-#include \"mingw32.h\"\n-#include <windows.h>\n-\n-extern CRITICAL_SECTION ProcListCS;\n-extern HANDLE ProcListEvt;\n-\n-void\n-__gnat_finalize (void)\n-{\n-  /* delete critical section and event handle used for the\n-     processes chain list */\n-  DeleteCriticalSection(&ProcListCS);\n-  CloseHandle (ProcListEvt);\n-}\n-\n-#else\n void\n __gnat_finalize (void)\n {\n }\n-#endif\n \n #ifdef __cplusplus\n }"}, {"sha": "6fa4f4cffc57d636f959f4819de3eeb1dc4dbe80", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -223,8 +223,8 @@ GCC_LLINK=$(LLINKER) $(GCC_LINKERFLAGS) $(LDFLAGS)\n # Object files for gnat1 from C sources.\n GNAT1_C_OBJS = ada/adadecode.o ada/adaint.o ada/argv.o ada/cio.o \\\n  ada/cstreams.o ada/env.o ada/init.o ada/initialize.o ada/raise.o \\\n- ada/seh_init.o ada/targext.o ada/cuintp.o ada/decl.o \\\n- ada/misc.o ada/utils.o ada/utils2.o ada/trans.o ada/targtyps.o\n+ ada/seh_init.o ada/targext.o ada/cuintp.o ada/decl.o ada/rtfinal.o \\\n+ ada/rtinit.o ada/misc.o ada/utils.o ada/utils2.o ada/trans.o ada/targtyps.o\n \n # Object files from Ada sources that are used by gnat1\n GNAT_ADA_OBJS =\t\\\n@@ -513,6 +513,8 @@ GNATBIND_OBJS = \\\n  ada/raise.o      \\\n  ada/restrict.o   \\\n  ada/rident.o     \\\n+ ada/rtfinal.o    \\\n+ ada/rtinit.o     \\\n  ada/s-addope.o   \\\n  ada/s-assert.o   \\\n  ada/s-carun8.o   \\"}, {"sha": "870cfab5ea59274684176db893c17d5840aa3ec8", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -2400,7 +2400,7 @@ endif\n # thread.c is special as put into GNATRTL_TASKING_OBJS by Makefile.rtl\n LIBGNAT_OBJS = adadecode.o adaint.o argv.o aux-io.o \t\t\t\\\n   cal.o cio.o cstreams.o ctrl_c.o\t\t\t\t\t\\\n-  env.o errno.o exit.o expect.o final.o \t\t\t\t\\\n+  env.o errno.o exit.o expect.o final.o rtfinal.o rtinit.o\t\t\\\n   init.o initialize.o locales.o mkdir.o\t\t\t\t\t\\\n   raise.o seh_init.o socket.o sysdep.o\t\t\t\t\t\\\n   targext.o terminals.o tracebak.o \t\t\t\t\t\\\n@@ -3046,6 +3046,8 @@ errno.o   : errno.c\n exit.o    : adaint.h exit.c\n expect.o  : expect.c\n final.o   : final.c\n+rtfinal.o : rtfinal.c\n+rtinit.o  : rtinit.c\n locales.o : locales.c\n mkdir.o   : mkdir.c\n socket.o  : socket.c gsocket.h"}, {"sha": "9e487dbb4ffc6b399477553b1aa1955c81ae82c6", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 514, "deletions": 475, "changes": 989, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -17544,6 +17544,13 @@ finalization of all Ada libraries must be performed at the end of the program.\n No call to these libraries or to the Ada run-time library should be made\n after the finalization phase.\n \n+@noindent\n+Note also that special care must be taken with multi-tasks\n+applications. The initialization and finalization routines are not\n+protected against concurrent access. If such requirement is needed it\n+must be ensured at the application level using a specific operating\n+system services like a mutex or a critical-section.\n+\n @node Restrictions in Stand-alone Libraries\n @subsection Restrictions in Stand-alone Libraries\n \n@@ -22308,11 +22315,10 @@ Comments have been added for clarification purposes.\n --  as a unit name in the partition, in which case some other unique\n --  name is used.\n \n+@b{pragma} Ada_95;\n @b{with} System;\n @b{package} ada_main @b{is}\n-\n-   Elab_Final_Code : Integer;\n-   @b{pragma} Import (C, Elab_Final_Code, \"__gnat_inside_elab_final_code\");\n+   @b{pragma} Warnings (Off);\n \n    --  The main program saves the parameters (argument count,\n    --  argument values, environment pointer) in global variables\n@@ -22337,16 +22343,11 @@ Comments have been added for clarification purposes.\n    @b{pragma} Import (C, gnat_exit_status);\n \n    GNAT_Version : @b{constant} String :=\n-                    \"GNAT Version: 6.0.0w (20061115)\";\n+                    \"GNAT Version: Pro 7.4.0w (20141119-49)\" & ASCII.NUL;\n    @b{pragma} Export (C, GNAT_Version, \"__gnat_version\");\n \n-   --  This is the generated adafinal routine that performs\n-   --  finalization at the end of execution. In the case where\n-   --  Ada is the main program, this main program makes a call\n-   --  to adafinal at program termination.\n-\n-   @b{procedure} adafinal;\n-   @b{pragma} Export (C, adafinal, \"adafinal\");\n+   Ada_Main_Program_Name : constant String := \"_ada_hello\" & ASCII.NUL;\n+   @b{pragma} Export (C, Ada_Main_Program_Name, \"__gnat_ada_main_program_name\");\n \n    --  This is the generated adainit routine that performs\n    --  initialization at the start of execution. In the case\n@@ -22356,13 +22357,18 @@ Comments have been added for clarification purposes.\n    @b{procedure} adainit;\n    @b{pragma} Export (C, adainit, \"adainit\");\n \n+   --  This is the generated adafinal routine that performs\n+   --  finalization at the end of execution. In the case where\n+   --  Ada is the main program, this main program makes a call\n+   --  to adafinal at program termination.\n+\n+   @b{procedure} adafinal;\n+   @b{pragma} Export (C, adafinal, \"adafinal\");\n+\n    --  This routine is called at the start of execution. It is\n    --  a dummy routine that is used by the debugger to breakpoint\n    --  at the start of execution.\n \n-   @b{procedure} Break_Start;\n-   @b{pragma} Import (C, Break_Start, \"__gnat_break_start\");\n-\n    --  This is the actual generated main program (it would be\n    --  suppressed if the no main program switch were used). As\n    --  required by standard system conventions, this program has\n@@ -22382,207 +22388,395 @@ Comments have been added for clarification purposes.\n    --  string that would be returned by use of the\n    --  Body_Version or Version attributes.\n \n-   @b{type} Version_32 @b{is} @b{mod} 2 ** 32;\n-   u00001 : @b{constant} Version_32 := 16#7880BEB3#;\n-   u00002 : @b{constant} Version_32 := 16#0D24CBD0#;\n-   u00003 : @b{constant} Version_32 := 16#3283DBEB#;\n-   u00004 : @b{constant} Version_32 := 16#2359F9ED#;\n-   u00005 : @b{constant} Version_32 := 16#664FB847#;\n-   u00006 : @b{constant} Version_32 := 16#68E803DF#;\n-   u00007 : @b{constant} Version_32 := 16#5572E604#;\n-   u00008 : @b{constant} Version_32 := 16#46B173D8#;\n-   u00009 : @b{constant} Version_32 := 16#156A40CF#;\n-   u00010 : @b{constant} Version_32 := 16#033DABE0#;\n-   u00011 : @b{constant} Version_32 := 16#6AB38FEA#;\n-   u00012 : @b{constant} Version_32 := 16#22B6217D#;\n-   u00013 : @b{constant} Version_32 := 16#68A22947#;\n-   u00014 : @b{constant} Version_32 := 16#18CC4A56#;\n-   u00015 : @b{constant} Version_32 := 16#08258E1B#;\n-   u00016 : @b{constant} Version_32 := 16#367D5222#;\n-   u00017 : @b{constant} Version_32 := 16#20C9ECA4#;\n-   u00018 : @b{constant} Version_32 := 16#50D32CB6#;\n-   u00019 : @b{constant} Version_32 := 16#39A8BB77#;\n-   u00020 : @b{constant} Version_32 := 16#5CF8FA2B#;\n-   u00021 : @b{constant} Version_32 := 16#2F1EB794#;\n-   u00022 : @b{constant} Version_32 := 16#31AB6444#;\n-   u00023 : @b{constant} Version_32 := 16#1574B6E9#;\n-   u00024 : @b{constant} Version_32 := 16#5109C189#;\n-   u00025 : @b{constant} Version_32 := 16#56D770CD#;\n-   u00026 : @b{constant} Version_32 := 16#02F9DE3D#;\n-   u00027 : @b{constant} Version_32 := 16#08AB6B2C#;\n-   u00028 : @b{constant} Version_32 := 16#3FA37670#;\n-   u00029 : @b{constant} Version_32 := 16#476457A0#;\n-   u00030 : @b{constant} Version_32 := 16#731E1B6E#;\n-   u00031 : @b{constant} Version_32 := 16#23C2E789#;\n-   u00032 : @b{constant} Version_32 := 16#0F1BD6A1#;\n-   u00033 : @b{constant} Version_32 := 16#7C25DE96#;\n-   u00034 : @b{constant} Version_32 := 16#39ADFFA2#;\n-   u00035 : @b{constant} Version_32 := 16#571DE3E7#;\n-   u00036 : @b{constant} Version_32 := 16#5EB646AB#;\n-   u00037 : @b{constant} Version_32 := 16#4249379B#;\n-   u00038 : @b{constant} Version_32 := 16#0357E00A#;\n-   u00039 : @b{constant} Version_32 := 16#3784FB72#;\n-   u00040 : @b{constant} Version_32 := 16#2E723019#;\n-   u00041 : @b{constant} Version_32 := 16#623358EA#;\n-   u00042 : @b{constant} Version_32 := 16#107F9465#;\n-   u00043 : @b{constant} Version_32 := 16#6843F68A#;\n-   u00044 : @b{constant} Version_32 := 16#63305874#;\n-   u00045 : @b{constant} Version_32 := 16#31E56CE1#;\n-   u00046 : @b{constant} Version_32 := 16#02917970#;\n-   u00047 : @b{constant} Version_32 := 16#6CCBA70E#;\n-   u00048 : @b{constant} Version_32 := 16#41CD4204#;\n-   u00049 : @b{constant} Version_32 := 16#572E3F58#;\n-   u00050 : @b{constant} Version_32 := 16#20729FF5#;\n-   u00051 : @b{constant} Version_32 := 16#1D4F93E8#;\n-   u00052 : @b{constant} Version_32 := 16#30B2EC3D#;\n-   u00053 : @b{constant} Version_32 := 16#34054F96#;\n-   u00054 : @b{constant} Version_32 := 16#5A199860#;\n-   u00055 : @b{constant} Version_32 := 16#0E7F912B#;\n-   u00056 : @b{constant} Version_32 := 16#5760634A#;\n-   u00057 : @b{constant} Version_32 := 16#5D851835#;\n-\n    --  The following Export pragmas export the version numbers\n    --  with symbolic names ending in B (for body) or S\n    --  (for spec) so that they can be located in a link. The\n    --  information provided here is sufficient to track down\n    --  the exact versions of units used in a given build.\n \n+\n+   @b{type} Version_32 @b{is} @b{mod} 2 ** 32;\n+   u00001 : @b{constant} Version_32 := 16#8ad6e54a#;\n    @b{pragma} Export (C, u00001, \"helloB\");\n+   u00002 : @b{constant} Version_32 := 16#fbff4c67#;\n    @b{pragma} Export (C, u00002, \"system__standard_libraryB\");\n+   u00003 : @b{constant} Version_32 := 16#1ec6fd90#;\n    @b{pragma} Export (C, u00003, \"system__standard_libraryS\");\n+   u00004 : @b{constant} Version_32 := 16#3ffc8e18#;\n    @b{pragma} Export (C, u00004, \"adaS\");\n+   u00005 : @b{constant} Version_32 := 16#28f088c2#;\n    @b{pragma} Export (C, u00005, \"ada__text_ioB\");\n+   u00006 : @b{constant} Version_32 := 16#f372c8ac#;\n    @b{pragma} Export (C, u00006, \"ada__text_ioS\");\n+   u00007 : @b{constant} Version_32 := 16#2c143749#;\n    @b{pragma} Export (C, u00007, \"ada__exceptionsB\");\n+   u00008 : @b{constant} Version_32 := 16#f4f0cce8#;\n    @b{pragma} Export (C, u00008, \"ada__exceptionsS\");\n-   @b{pragma} Export (C, u00009, \"gnatS\");\n-   @b{pragma} Export (C, u00010, \"gnat__heap_sort_aB\");\n-   @b{pragma} Export (C, u00011, \"gnat__heap_sort_aS\");\n-   @b{pragma} Export (C, u00012, \"systemS\");\n-   @b{pragma} Export (C, u00013, \"system__exception_tableB\");\n-   @b{pragma} Export (C, u00014, \"system__exception_tableS\");\n-   @b{pragma} Export (C, u00015, \"gnat__htableB\");\n-   @b{pragma} Export (C, u00016, \"gnat__htableS\");\n-   @b{pragma} Export (C, u00017, \"system__exceptionsS\");\n-   @b{pragma} Export (C, u00018, \"system__machine_state_operationsB\");\n-   @b{pragma} Export (C, u00019, \"system__machine_state_operationsS\");\n-   @b{pragma} Export (C, u00020, \"system__machine_codeS\");\n-   @b{pragma} Export (C, u00021, \"system__storage_elementsB\");\n-   @b{pragma} Export (C, u00022, \"system__storage_elementsS\");\n-   @b{pragma} Export (C, u00023, \"system__secondary_stackB\");\n-   @b{pragma} Export (C, u00024, \"system__secondary_stackS\");\n-   @b{pragma} Export (C, u00025, \"system__parametersB\");\n-   @b{pragma} Export (C, u00026, \"system__parametersS\");\n-   @b{pragma} Export (C, u00027, \"system__soft_linksB\");\n-   @b{pragma} Export (C, u00028, \"system__soft_linksS\");\n-   @b{pragma} Export (C, u00029, \"system__stack_checkingB\");\n-   @b{pragma} Export (C, u00030, \"system__stack_checkingS\");\n+   u00009 : @b{constant} Version_32 := 16#a46739c0#;\n+   @b{pragma} Export (C, u00009, \"ada__exceptions__last_chance_handlerB\");\n+   u00010 : @b{constant} Version_32 := 16#3aac8c92#;\n+   @b{pragma} Export (C, u00010, \"ada__exceptions__last_chance_handlerS\");\n+   u00011 : @b{constant} Version_32 := 16#1d274481#;\n+   @b{pragma} Export (C, u00011, \"systemS\");\n+   u00012 : @b{constant} Version_32 := 16#a207fefe#;\n+   @b{pragma} Export (C, u00012, \"system__soft_linksB\");\n+   u00013 : @b{constant} Version_32 := 16#467d9556#;\n+   @b{pragma} Export (C, u00013, \"system__soft_linksS\");\n+   u00014 : @b{constant} Version_32 := 16#b01dad17#;\n+   @b{pragma} Export (C, u00014, \"system__parametersB\");\n+   u00015 : @b{constant} Version_32 := 16#630d49fe#;\n+   @b{pragma} Export (C, u00015, \"system__parametersS\");\n+   u00016 : @b{constant} Version_32 := 16#b19b6653#;\n+   @b{pragma} Export (C, u00016, \"system__secondary_stackB\");\n+   u00017 : @b{constant} Version_32 := 16#b6468be8#;\n+   @b{pragma} Export (C, u00017, \"system__secondary_stackS\");\n+   u00018 : @b{constant} Version_32 := 16#39a03df9#;\n+   @b{pragma} Export (C, u00018, \"system__storage_elementsB\");\n+   u00019 : @b{constant} Version_32 := 16#30e40e85#;\n+   @b{pragma} Export (C, u00019, \"system__storage_elementsS\");\n+   u00020 : @b{constant} Version_32 := 16#41837d1e#;\n+   @b{pragma} Export (C, u00020, \"system__stack_checkingB\");\n+   u00021 : @b{constant} Version_32 := 16#93982f69#;\n+   @b{pragma} Export (C, u00021, \"system__stack_checkingS\");\n+   u00022 : @b{constant} Version_32 := 16#393398c1#;\n+   @b{pragma} Export (C, u00022, \"system__exception_tableB\");\n+   u00023 : @b{constant} Version_32 := 16#b33e2294#;\n+   @b{pragma} Export (C, u00023, \"system__exception_tableS\");\n+   u00024 : @b{constant} Version_32 := 16#ce4af020#;\n+   @b{pragma} Export (C, u00024, \"system__exceptionsB\");\n+   u00025 : @b{constant} Version_32 := 16#75442977#;\n+   @b{pragma} Export (C, u00025, \"system__exceptionsS\");\n+   u00026 : @b{constant} Version_32 := 16#37d758f1#;\n+   @b{pragma} Export (C, u00026, \"system__exceptions__machineS\");\n+   u00027 : @b{constant} Version_32 := 16#b895431d#;\n+   @b{pragma} Export (C, u00027, \"system__exceptions_debugB\");\n+   u00028 : @b{constant} Version_32 := 16#aec55d3f#;\n+   @b{pragma} Export (C, u00028, \"system__exceptions_debugS\");\n+   u00029 : @b{constant} Version_32 := 16#570325c8#;\n+   @b{pragma} Export (C, u00029, \"system__img_intB\");\n+   u00030 : @b{constant} Version_32 := 16#1ffca443#;\n+   @b{pragma} Export (C, u00030, \"system__img_intS\");\n+   u00031 : @b{constant} Version_32 := 16#b98c3e16#;\n    @b{pragma} Export (C, u00031, \"system__tracebackB\");\n+   u00032 : @b{constant} Version_32 := 16#831a9d5a#;\n    @b{pragma} Export (C, u00032, \"system__tracebackS\");\n-   @b{pragma} Export (C, u00033, \"ada__streamsS\");\n-   @b{pragma} Export (C, u00034, \"ada__tagsB\");\n-   @b{pragma} Export (C, u00035, \"ada__tagsS\");\n-   @b{pragma} Export (C, u00036, \"system__string_opsB\");\n-   @b{pragma} Export (C, u00037, \"system__string_opsS\");\n-   @b{pragma} Export (C, u00038, \"interfacesS\");\n-   @b{pragma} Export (C, u00039, \"interfaces__c_streamsB\");\n-   @b{pragma} Export (C, u00040, \"interfaces__c_streamsS\");\n-   @b{pragma} Export (C, u00041, \"system__file_ioB\");\n-   @b{pragma} Export (C, u00042, \"system__file_ioS\");\n-   @b{pragma} Export (C, u00043, \"ada__finalizationB\");\n-   @b{pragma} Export (C, u00044, \"ada__finalizationS\");\n-   @b{pragma} Export (C, u00045, \"system__finalization_rootB\");\n-   @b{pragma} Export (C, u00046, \"system__finalization_rootS\");\n-   @b{pragma} Export (C, u00047, \"system__finalization_implementationB\");\n-   @b{pragma} Export (C, u00048, \"system__finalization_implementationS\");\n-   @b{pragma} Export (C, u00049, \"system__string_ops_concat_3B\");\n-   @b{pragma} Export (C, u00050, \"system__string_ops_concat_3S\");\n-   @b{pragma} Export (C, u00051, \"system__stream_attributesB\");\n-   @b{pragma} Export (C, u00052, \"system__stream_attributesS\");\n-   @b{pragma} Export (C, u00053, \"ada__io_exceptionsS\");\n-   @b{pragma} Export (C, u00054, \"system__unsigned_typesS\");\n-   @b{pragma} Export (C, u00055, \"system__file_control_blockS\");\n-   @b{pragma} Export (C, u00056, \"ada__finalization__list_controllerB\");\n-   @b{pragma} Export (C, u00057, \"ada__finalization__list_controllerS\");\n-\n-   -- BEGIN ELABORATION ORDER\n-   -- ada (spec)\n-   -- gnat (spec)\n-   -- gnat.heap_sort_a (spec)\n-   -- gnat.heap_sort_a (body)\n-   -- gnat.htable (spec)\n-   -- gnat.htable (body)\n-   -- interfaces (spec)\n-   -- system (spec)\n-   -- system.machine_code (spec)\n-   -- system.parameters (spec)\n-   -- system.parameters (body)\n-   -- interfaces.c_streams (spec)\n-   -- interfaces.c_streams (body)\n-   -- system.standard_library (spec)\n-   -- ada.exceptions (spec)\n-   -- system.exception_table (spec)\n-   -- system.exception_table (body)\n-   -- ada.io_exceptions (spec)\n-   -- system.exceptions (spec)\n-   -- system.storage_elements (spec)\n-   -- system.storage_elements (body)\n-   -- system.machine_state_operations (spec)\n-   -- system.machine_state_operations (body)\n-   -- system.secondary_stack (spec)\n-   -- system.stack_checking (spec)\n-   -- system.soft_links (spec)\n-   -- system.soft_links (body)\n-   -- system.stack_checking (body)\n-   -- system.secondary_stack (body)\n-   -- system.standard_library (body)\n-   -- system.string_ops (spec)\n-   -- system.string_ops (body)\n-   -- ada.tags (spec)\n-   -- ada.tags (body)\n-   -- ada.streams (spec)\n-   -- system.finalization_root (spec)\n-   -- system.finalization_root (body)\n-   -- system.string_ops_concat_3 (spec)\n-   -- system.string_ops_concat_3 (body)\n-   -- system.traceback (spec)\n-   -- system.traceback (body)\n-   -- ada.exceptions (body)\n-   -- system.unsigned_types (spec)\n-   -- system.stream_attributes (spec)\n-   -- system.stream_attributes (body)\n-   -- system.finalization_implementation (spec)\n-   -- system.finalization_implementation (body)\n-   -- ada.finalization (spec)\n-   -- ada.finalization (body)\n-   -- ada.finalization.list_controller (spec)\n-   -- ada.finalization.list_controller (body)\n-   -- system.file_control_block (spec)\n-   -- system.file_io (spec)\n-   -- system.file_io (body)\n-   -- ada.text_io (spec)\n-   -- ada.text_io (body)\n-   -- hello (body)\n-   -- END ELABORATION ORDER\n+   u00033 : @b{constant} Version_32 := 16#9ed49525#;\n+   @b{pragma} Export (C, u00033, \"system__traceback_entriesB\");\n+   u00034 : @b{constant} Version_32 := 16#1d7cb2f1#;\n+   @b{pragma} Export (C, u00034, \"system__traceback_entriesS\");\n+   u00035 : @b{constant} Version_32 := 16#8c33a517#;\n+   @b{pragma} Export (C, u00035, \"system__wch_conB\");\n+   u00036 : @b{constant} Version_32 := 16#065a6653#;\n+   @b{pragma} Export (C, u00036, \"system__wch_conS\");\n+   u00037 : @b{constant} Version_32 := 16#9721e840#;\n+   @b{pragma} Export (C, u00037, \"system__wch_stwB\");\n+   u00038 : @b{constant} Version_32 := 16#2b4b4a52#;\n+   @b{pragma} Export (C, u00038, \"system__wch_stwS\");\n+   u00039 : @b{constant} Version_32 := 16#92b797cb#;\n+   @b{pragma} Export (C, u00039, \"system__wch_cnvB\");\n+   u00040 : @b{constant} Version_32 := 16#09eddca0#;\n+   @b{pragma} Export (C, u00040, \"system__wch_cnvS\");\n+   u00041 : @b{constant} Version_32 := 16#6033a23f#;\n+   @b{pragma} Export (C, u00041, \"interfacesS\");\n+   u00042 : @b{constant} Version_32 := 16#ece6fdb6#;\n+   @b{pragma} Export (C, u00042, \"system__wch_jisB\");\n+   u00043 : @b{constant} Version_32 := 16#899dc581#;\n+   @b{pragma} Export (C, u00043, \"system__wch_jisS\");\n+   u00044 : @b{constant} Version_32 := 16#10558b11#;\n+   @b{pragma} Export (C, u00044, \"ada__streamsB\");\n+   u00045 : @b{constant} Version_32 := 16#2e6701ab#;\n+   @b{pragma} Export (C, u00045, \"ada__streamsS\");\n+   u00046 : @b{constant} Version_32 := 16#db5c917c#;\n+   @b{pragma} Export (C, u00046, \"ada__io_exceptionsS\");\n+   u00047 : @b{constant} Version_32 := 16#12c8cd7d#;\n+   @b{pragma} Export (C, u00047, \"ada__tagsB\");\n+   u00048 : @b{constant} Version_32 := 16#ce72c228#;\n+   @b{pragma} Export (C, u00048, \"ada__tagsS\");\n+   u00049 : @b{constant} Version_32 := 16#c3335bfd#;\n+   @b{pragma} Export (C, u00049, \"system__htableB\");\n+   u00050 : @b{constant} Version_32 := 16#99e5f76b#;\n+   @b{pragma} Export (C, u00050, \"system__htableS\");\n+   u00051 : @b{constant} Version_32 := 16#089f5cd0#;\n+   @b{pragma} Export (C, u00051, \"system__string_hashB\");\n+   u00052 : @b{constant} Version_32 := 16#3bbb9c15#;\n+   @b{pragma} Export (C, u00052, \"system__string_hashS\");\n+   u00053 : @b{constant} Version_32 := 16#807fe041#;\n+   @b{pragma} Export (C, u00053, \"system__unsigned_typesS\");\n+   u00054 : @b{constant} Version_32 := 16#d27be59e#;\n+   @b{pragma} Export (C, u00054, \"system__val_lluB\");\n+   u00055 : @b{constant} Version_32 := 16#fa8db733#;\n+   @b{pragma} Export (C, u00055, \"system__val_lluS\");\n+   u00056 : @b{constant} Version_32 := 16#27b600b2#;\n+   @b{pragma} Export (C, u00056, \"system__val_utilB\");\n+   u00057 : @b{constant} Version_32 := 16#b187f27f#;\n+   @b{pragma} Export (C, u00057, \"system__val_utilS\");\n+   u00058 : @b{constant} Version_32 := 16#d1060688#;\n+   @b{pragma} Export (C, u00058, \"system__case_utilB\");\n+   u00059 : @b{constant} Version_32 := 16#392e2d56#;\n+   @b{pragma} Export (C, u00059, \"system__case_utilS\");\n+   u00060 : @b{constant} Version_32 := 16#84a27f0d#;\n+   @b{pragma} Export (C, u00060, \"interfaces__c_streamsB\");\n+   u00061 : @b{constant} Version_32 := 16#8bb5f2c0#;\n+   @b{pragma} Export (C, u00061, \"interfaces__c_streamsS\");\n+   u00062 : @b{constant} Version_32 := 16#6db6928f#;\n+   @b{pragma} Export (C, u00062, \"system__crtlS\");\n+   u00063 : @b{constant} Version_32 := 16#4e6a342b#;\n+   @b{pragma} Export (C, u00063, \"system__file_ioB\");\n+   u00064 : @b{constant} Version_32 := 16#ba56a5e4#;\n+   @b{pragma} Export (C, u00064, \"system__file_ioS\");\n+   u00065 : @b{constant} Version_32 := 16#b7ab275c#;\n+   @b{pragma} Export (C, u00065, \"ada__finalizationB\");\n+   u00066 : @b{constant} Version_32 := 16#19f764ca#;\n+   @b{pragma} Export (C, u00066, \"ada__finalizationS\");\n+   u00067 : @b{constant} Version_32 := 16#95817ed8#;\n+   @b{pragma} Export (C, u00067, \"system__finalization_rootB\");\n+   u00068 : @b{constant} Version_32 := 16#52d53711#;\n+   @b{pragma} Export (C, u00068, \"system__finalization_rootS\");\n+   u00069 : @b{constant} Version_32 := 16#769e25e6#;\n+   @b{pragma} Export (C, u00069, \"interfaces__cB\");\n+   u00070 : @b{constant} Version_32 := 16#4a38bedb#;\n+   @b{pragma} Export (C, u00070, \"interfaces__cS\");\n+   u00071 : @b{constant} Version_32 := 16#07e6ee66#;\n+   @b{pragma} Export (C, u00071, \"system__os_libB\");\n+   u00072 : @b{constant} Version_32 := 16#d7b69782#;\n+   @b{pragma} Export (C, u00072, \"system__os_libS\");\n+   u00073 : @b{constant} Version_32 := 16#1a817b8e#;\n+   @b{pragma} Export (C, u00073, \"system__stringsB\");\n+   u00074 : @b{constant} Version_32 := 16#639855e7#;\n+   @b{pragma} Export (C, u00074, \"system__stringsS\");\n+   u00075 : @b{constant} Version_32 := 16#e0b8de29#;\n+   @b{pragma} Export (C, u00075, \"system__file_control_blockS\");\n+   u00076 : @b{constant} Version_32 := 16#b5b2aca1#;\n+   @b{pragma} Export (C, u00076, \"system__finalization_mastersB\");\n+   u00077 : @b{constant} Version_32 := 16#69316dc1#;\n+   @b{pragma} Export (C, u00077, \"system__finalization_mastersS\");\n+   u00078 : @b{constant} Version_32 := 16#57a37a42#;\n+   @b{pragma} Export (C, u00078, \"system__address_imageB\");\n+   u00079 : @b{constant} Version_32 := 16#bccbd9bb#;\n+   @b{pragma} Export (C, u00079, \"system__address_imageS\");\n+   u00080 : @b{constant} Version_32 := 16#7268f812#;\n+   @b{pragma} Export (C, u00080, \"system__img_boolB\");\n+   u00081 : @b{constant} Version_32 := 16#e8fe356a#;\n+   @b{pragma} Export (C, u00081, \"system__img_boolS\");\n+   u00082 : @b{constant} Version_32 := 16#d7aac20c#;\n+   @b{pragma} Export (C, u00082, \"system__ioB\");\n+   u00083 : @b{constant} Version_32 := 16#8365b3ce#;\n+   @b{pragma} Export (C, u00083, \"system__ioS\");\n+   u00084 : @b{constant} Version_32 := 16#6d4d969a#;\n+   @b{pragma} Export (C, u00084, \"system__storage_poolsB\");\n+   u00085 : @b{constant} Version_32 := 16#e87cc305#;\n+   @b{pragma} Export (C, u00085, \"system__storage_poolsS\");\n+   u00086 : @b{constant} Version_32 := 16#e34550ca#;\n+   @b{pragma} Export (C, u00086, \"system__pool_globalB\");\n+   u00087 : @b{constant} Version_32 := 16#c88d2d16#;\n+   @b{pragma} Export (C, u00087, \"system__pool_globalS\");\n+   u00088 : @b{constant} Version_32 := 16#9d39c675#;\n+   @b{pragma} Export (C, u00088, \"system__memoryB\");\n+   u00089 : @b{constant} Version_32 := 16#445a22b5#;\n+   @b{pragma} Export (C, u00089, \"system__memoryS\");\n+   u00090 : @b{constant} Version_32 := 16#6a859064#;\n+   @b{pragma} Export (C, u00090, \"system__storage_pools__subpoolsB\");\n+   u00091 : @b{constant} Version_32 := 16#e3b008dc#;\n+   @b{pragma} Export (C, u00091, \"system__storage_pools__subpoolsS\");\n+   u00092 : @b{constant} Version_32 := 16#63f11652#;\n+   @b{pragma} Export (C, u00092, \"system__storage_pools__subpools__finalizationB\");\n+   u00093 : @b{constant} Version_32 := 16#fe2f4b3a#;\n+   @b{pragma} Export (C, u00093, \"system__storage_pools__subpools__finalizationS\");\n+\n+   --  BEGIN ELABORATION ORDER\n+   --  ada%s\n+   --  interfaces%s\n+   --  system%s\n+   --  system.case_util%s\n+   --  system.case_util%b\n+   --  system.htable%s\n+   --  system.img_bool%s\n+   --  system.img_bool%b\n+   --  system.img_int%s\n+   --  system.img_int%b\n+   --  system.io%s\n+   --  system.io%b\n+   --  system.parameters%s\n+   --  system.parameters%b\n+   --  system.crtl%s\n+   --  interfaces.c_streams%s\n+   --  interfaces.c_streams%b\n+   --  system.standard_library%s\n+   --  system.exceptions_debug%s\n+   --  system.exceptions_debug%b\n+   --  system.storage_elements%s\n+   --  system.storage_elements%b\n+   --  system.stack_checking%s\n+   --  system.stack_checking%b\n+   --  system.string_hash%s\n+   --  system.string_hash%b\n+   --  system.htable%b\n+   --  system.strings%s\n+   --  system.strings%b\n+   --  system.os_lib%s\n+   --  system.traceback_entries%s\n+   --  system.traceback_entries%b\n+   --  ada.exceptions%s\n+   --  system.soft_links%s\n+   --  system.unsigned_types%s\n+   --  system.val_llu%s\n+   --  system.val_util%s\n+   --  system.val_util%b\n+   --  system.val_llu%b\n+   --  system.wch_con%s\n+   --  system.wch_con%b\n+   --  system.wch_cnv%s\n+   --  system.wch_jis%s\n+   --  system.wch_jis%b\n+   --  system.wch_cnv%b\n+   --  system.wch_stw%s\n+   --  system.wch_stw%b\n+   --  ada.exceptions.last_chance_handler%s\n+   --  ada.exceptions.last_chance_handler%b\n+   --  system.address_image%s\n+   --  system.exception_table%s\n+   --  system.exception_table%b\n+   --  ada.io_exceptions%s\n+   --  ada.tags%s\n+   --  ada.streams%s\n+   --  ada.streams%b\n+   --  interfaces.c%s\n+   --  system.exceptions%s\n+   --  system.exceptions%b\n+   --  system.exceptions.machine%s\n+   --  system.finalization_root%s\n+   --  system.finalization_root%b\n+   --  ada.finalization%s\n+   --  ada.finalization%b\n+   --  system.storage_pools%s\n+   --  system.storage_pools%b\n+   --  system.finalization_masters%s\n+   --  system.storage_pools.subpools%s\n+   --  system.storage_pools.subpools.finalization%s\n+   --  system.storage_pools.subpools.finalization%b\n+   --  system.memory%s\n+   --  system.memory%b\n+   --  system.standard_library%b\n+   --  system.pool_global%s\n+   --  system.pool_global%b\n+   --  system.file_control_block%s\n+   --  system.file_io%s\n+   --  system.secondary_stack%s\n+   --  system.file_io%b\n+   --  system.storage_pools.subpools%b\n+   --  system.finalization_masters%b\n+   --  interfaces.c%b\n+   --  ada.tags%b\n+   --  system.soft_links%b\n+   --  system.os_lib%b\n+   --  system.secondary_stack%b\n+   --  system.address_image%b\n+   --  system.traceback%s\n+   --  ada.exceptions%b\n+   --  system.traceback%b\n+   --  ada.text_io%s\n+   --  ada.text_io%b\n+   --  hello%b\n+   --  END ELABORATION ORDER\n \n @b{end} ada_main;\n \n+@b{pragma} Ada_95;\n --  The following source file name pragmas allow the generated file\n --  names to be unique for different main programs. They are needed\n --  since the package name will always be Ada_Main.\n \n @b{pragma} Source_File_Name (ada_main, Spec_File_Name => \"b~hello.ads\");\n @b{pragma} Source_File_Name (ada_main, Body_File_Name => \"b~hello.adb\");\n \n+@b{pragma} Suppress (Overflow_Check);\n+@b{with} Ada.Exceptions;\n+\n --  Generated package body for Ada_Main starts here\n \n @b{package} @b{body} ada_main @b{is}\n+   @b{pragma} Warnings (Off);\n \n-   --  The actual finalization is performed by calling the\n-   --  library routine in System.Standard_Library.Adafinal\n-\n-   @b{procedure} Do_Finalize;\n-   @b{pragma} Import (C, Do_Finalize, \"system__standard_library__adafinal\");\n+   --  These values are reference counter associated to units which have\n+   --  been elaborated. It is also used to avoid elaborating the\n+   --  same unit twice.\n+\n+   E72 : Short_Integer; @b{pragma} Import (Ada, E72, \"system__os_lib_E\");\n+   E13 : Short_Integer; @b{pragma} Import (Ada, E13, \"system__soft_links_E\");\n+   E23 : Short_Integer; @b{pragma} Import (Ada, E23, \"system__exception_table_E\");\n+   E46 : Short_Integer; @b{pragma} Import (Ada, E46, \"ada__io_exceptions_E\");\n+   E48 : Short_Integer; @b{pragma} Import (Ada, E48, \"ada__tags_E\");\n+   E45 : Short_Integer; @b{pragma} Import (Ada, E45, \"ada__streams_E\");\n+   E70 : Short_Integer; @b{pragma} Import (Ada, E70, \"interfaces__c_E\");\n+   E25 : Short_Integer; @b{pragma} Import (Ada, E25, \"system__exceptions_E\");\n+   E68 : Short_Integer; @b{pragma} Import (Ada, E68, \"system__finalization_root_E\");\n+   E66 : Short_Integer; @b{pragma} Import (Ada, E66, \"ada__finalization_E\");\n+   E85 : Short_Integer; @b{pragma} Import (Ada, E85, \"system__storage_pools_E\");\n+   E77 : Short_Integer; @b{pragma} Import (Ada, E77, \"system__finalization_masters_E\");\n+   E91 : Short_Integer; @b{pragma} Import (Ada, E91, \"system__storage_pools__subpools_E\");\n+   E87 : Short_Integer; @b{pragma} Import (Ada, E87, \"system__pool_global_E\");\n+   E75 : Short_Integer; @b{pragma} Import (Ada, E75, \"system__file_control_block_E\");\n+   E64 : Short_Integer; @b{pragma} Import (Ada, E64, \"system__file_io_E\");\n+   E17 : Short_Integer; @b{pragma} Import (Ada, E17, \"system__secondary_stack_E\");\n+   E06 : Short_Integer; @b{pragma} Import (Ada, E06, \"ada__text_io_E\");\n+\n+   Local_Priority_Specific_Dispatching : @b{constant} String := \"\";\n+   Local_Interrupt_States : @b{constant} String := \"\";\n+\n+   Is_Elaborated : Boolean := False;\n+\n+@findex finalize_library\n+   @b{procedure} finalize_library @b{is}\n+   @b{begin}\n+      E06 := E06 - 1;\n+      @b{declare}\n+         @b{procedure} F1;\n+         @b{pragma} Import (Ada, F1, \"ada__text_io__finalize_spec\");\n+      @b{begin}\n+         F1;\n+      @b{end};\n+      E77 := E77 - 1;\n+      E91 := E91 - 1;\n+      @b{declare}\n+         @b{procedure} F2;\n+         @b{pragma} Import (Ada, F2, \"system__file_io__finalize_body\");\n+      @b{begin}\n+         E64 := E64 - 1;\n+         F2;\n+      @b{end};\n+      @b{declare}\n+         @b{procedure} F3;\n+         @b{pragma} Import (Ada, F3, \"system__file_control_block__finalize_spec\");\n+      @b{begin}\n+         E75 := E75 - 1;\n+         F3;\n+      @b{end};\n+      E87 := E87 - 1;\n+      @b{declare}\n+         @b{procedure} F4;\n+         @b{pragma} Import (Ada, F4, \"system__pool_global__finalize_spec\");\n+      @b{begin}\n+         F4;\n+      @b{end};\n+      @b{declare}\n+         @b{procedure} F5;\n+         @b{pragma} Import (Ada, F5, \"system__storage_pools__subpools__finalize_spec\");\n+      @b{begin}\n+         F5;\n+      @b{end};\n+      @b{declare}\n+         @b{procedure} F6;\n+         @b{pragma} Import (Ada, F6, \"system__finalization_masters__finalize_spec\");\n+      @b{begin}\n+         F6;\n+      @b{end};\n+      @b{declare}\n+         @b{procedure} Reraise_Library_Exception_If_Any;\n+         @b{pragma} Import (Ada, Reraise_Library_Exception_If_Any, \"__gnat_reraise_library_exception_if_any\");\n+      @b{begin}\n+         Reraise_Library_Exception_If_Any;\n+      @b{end};\n+   @b{end} finalize_library;\n \n    -------------\n    -- adainit --\n@@ -22591,290 +22785,122 @@ Comments have been added for clarification purposes.\n @findex adainit\n    @b{procedure} adainit @b{is}\n \n-      --  These booleans are set to True once the associated unit has\n-      --  been elaborated. It is also used to avoid elaborating the\n-      --  same unit twice.\n-\n-      E040 : Boolean;\n-      @b{pragma} Import (Ada, E040, \"interfaces__c_streams_E\");\n-\n-      E008 : Boolean;\n-      @b{pragma} Import (Ada, E008, \"ada__exceptions_E\");\n-\n-      E014 : Boolean;\n-      @b{pragma} Import (Ada, E014, \"system__exception_table_E\");\n-\n-      E053 : Boolean;\n-      @b{pragma} Import (Ada, E053, \"ada__io_exceptions_E\");\n-\n-      E017 : Boolean;\n-      @b{pragma} Import (Ada, E017, \"system__exceptions_E\");\n-\n-      E024 : Boolean;\n-      @b{pragma} Import (Ada, E024, \"system__secondary_stack_E\");\n-\n-      E030 : Boolean;\n-      @b{pragma} Import (Ada, E030, \"system__stack_checking_E\");\n-\n-      E028 : Boolean;\n-      @b{pragma} Import (Ada, E028, \"system__soft_links_E\");\n-\n-      E035 : Boolean;\n-      @b{pragma} Import (Ada, E035, \"ada__tags_E\");\n-\n-      E033 : Boolean;\n-      @b{pragma} Import (Ada, E033, \"ada__streams_E\");\n-\n-      E046 : Boolean;\n-      @b{pragma} Import (Ada, E046, \"system__finalization_root_E\");\n-\n-      E048 : Boolean;\n-      @b{pragma} Import (Ada, E048, \"system__finalization_implementation_E\");\n-\n-      E044 : Boolean;\n-      @b{pragma} Import (Ada, E044, \"ada__finalization_E\");\n-\n-      E057 : Boolean;\n-      @b{pragma} Import (Ada, E057, \"ada__finalization__list_controller_E\");\n-\n-      E055 : Boolean;\n-      @b{pragma} Import (Ada, E055, \"system__file_control_block_E\");\n-\n-      E042 : Boolean;\n-      @b{pragma} Import (Ada, E042, \"system__file_io_E\");\n-\n-      E006 : Boolean;\n-      @b{pragma} Import (Ada, E006, \"ada__text_io_E\");\n-\n-      --  Set_Globals is a library routine that stores away the\n-      --  value of the indicated set of global values in global\n-      --  variables within the library.\n-\n-      @b{procedure} Set_Globals\n-        (Main_Priority            : Integer;\n-         Time_Slice_Value         : Integer;\n-         WC_Encoding              : Character;\n-         Locking_Policy           : Character;\n-         Queuing_Policy           : Character;\n-         Task_Dispatching_Policy  : Character;\n-         Adafinal                 : System.Address;\n-         Unreserve_All_Interrupts : Integer;\n-         Exception_Tracebacks     : Integer);\n-@findex __gnat_set_globals\n-      @b{pragma} Import (C, Set_Globals, \"__gnat_set_globals\");\n-\n-      --  SDP_Table_Build is a library routine used to build the\n-      --  exception tables. See unit Ada.Exceptions in files\n-      --  a-except.ads/adb for full details of how zero cost\n-      --  exception handling works. This procedure, the call to\n-      --  it, and the two following tables are all omitted if the\n-      --  build is in longjmp/setjmp exception mode.\n-\n-@findex SDP_Table_Build\n-@findex Zero Cost Exceptions\n-      @b{procedure} SDP_Table_Build\n-        (SDP_Addresses   : System.Address;\n-         SDP_Count       : Natural;\n-         Elab_Addresses  : System.Address;\n-         Elab_Addr_Count : Natural);\n-      @b{pragma} Import (C, SDP_Table_Build, \"__gnat_SDP_Table_Build\");\n-\n-      --  Table of Unit_Exception_Table addresses. Used for zero\n-      --  cost exception handling to build the top level table.\n-\n-      ST : @b{aliased} @b{constant} @b{array} (1 .. 23) @b{of} System.Address := (\n-        Hello'UET_Address,\n-        Ada.Text_Io'UET_Address,\n-        Ada.Exceptions'UET_Address,\n-        Gnat.Heap_Sort_A'UET_Address,\n-        System.Exception_Table'UET_Address,\n-        System.Machine_State_Operations'UET_Address,\n-        System.Secondary_Stack'UET_Address,\n-        System.Parameters'UET_Address,\n-        System.Soft_Links'UET_Address,\n-        System.Stack_Checking'UET_Address,\n-        System.Traceback'UET_Address,\n-        Ada.Streams'UET_Address,\n-        Ada.Tags'UET_Address,\n-        System.String_Ops'UET_Address,\n-        Interfaces.C_Streams'UET_Address,\n-        System.File_Io'UET_Address,\n-        Ada.Finalization'UET_Address,\n-        System.Finalization_Root'UET_Address,\n-        System.Finalization_Implementation'UET_Address,\n-        System.String_Ops_Concat_3'UET_Address,\n-        System.Stream_Attributes'UET_Address,\n-        System.File_Control_Block'UET_Address,\n-        Ada.Finalization.List_Controller'UET_Address);\n-\n-      --  Table of addresses of elaboration routines. Used for\n-      --  zero cost exception handling to make sure these\n-      --  addresses are included in the top level procedure\n-      --  address table.\n-\n-      EA : @b{aliased} @b{constant} @b{array} (1 .. 23) @b{of} System.Address := (\n-        adainit'Code_Address,\n-        Do_Finalize'Code_Address,\n-        Ada.Exceptions'Elab_Spec'Address,\n-        System.Exceptions'Elab_Spec'Address,\n-        Interfaces.C_Streams'Elab_Spec'Address,\n-        System.Exception_Table'Elab_Body'Address,\n-        Ada.Io_Exceptions'Elab_Spec'Address,\n-        System.Stack_Checking'Elab_Spec'Address,\n-        System.Soft_Links'Elab_Body'Address,\n-        System.Secondary_Stack'Elab_Body'Address,\n-        Ada.Tags'Elab_Spec'Address,\n-        Ada.Tags'Elab_Body'Address,\n-        Ada.Streams'Elab_Spec'Address,\n-        System.Finalization_Root'Elab_Spec'Address,\n-        Ada.Exceptions'Elab_Body'Address,\n-        System.Finalization_Implementation'Elab_Spec'Address,\n-        System.Finalization_Implementation'Elab_Body'Address,\n-        Ada.Finalization'Elab_Spec'Address,\n-        Ada.Finalization.List_Controller'Elab_Spec'Address,\n-        System.File_Control_Block'Elab_Spec'Address,\n-        System.File_Io'Elab_Body'Address,\n-        Ada.Text_Io'Elab_Spec'Address,\n-        Ada.Text_Io'Elab_Body'Address);\n+      Main_Priority : Integer;\n+      @b{pragma} Import (C, Main_Priority, \"__gl_main_priority\");\n+      Time_Slice_Value : Integer;\n+      @b{pragma} Import (C, Time_Slice_Value, \"__gl_time_slice_val\");\n+      WC_Encoding : Character;\n+      @b{pragma} Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+      Locking_Policy : Character;\n+      pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+      Queuing_Policy : Character;\n+      @b{pragma} Import (C, Queuing_Policy, \"__gl_queuing_policy\");\n+      Task_Dispatching_Policy : Character;\n+      @b{pragma} Import (C, Task_Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+      Priority_Specific_Dispatching : System.Address;\n+      @b{pragma} Import (C, Priority_Specific_Dispatching, \"__gl_priority_specific_dispatching\");\n+      Num_Specific_Dispatching : Integer;\n+      @b{pragma} Import (C, Num_Specific_Dispatching, \"__gl_num_specific_dispatching\");\n+      Main_CPU : Integer;\n+      @b{pragma} Import (C, Main_CPU, \"__gl_main_cpu\");\n+      Interrupt_States : System.Address;\n+      @b{pragma} Import (C, Interrupt_States, \"__gl_interrupt_states\");\n+      Num_Interrupt_States : Integer;\n+      @b{pragma} Import (C, Num_Interrupt_States, \"__gl_num_interrupt_states\");\n+      Unreserve_All_Interrupts : Integer;\n+      @b{pragma} Import (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+      Detect_Blocking : Integer;\n+      @b{pragma} Import (C, Detect_Blocking, \"__gl_detect_blocking\");\n+      Default_Stack_Size : Integer;\n+      @b{pragma} Import (C, Default_Stack_Size, \"__gl_default_stack_size\");\n+      Leap_Seconds_Support : Integer;\n+      @b{pragma} Import (C, Leap_Seconds_Support, \"__gl_leap_seconds_support\");\n+\n+      procedure Runtime_Initialize;\n+      @b{pragma} Import (C, Runtime_Initialize, \"__gnat_runtime_initialize\");\n+\n+      Finalize_Library_Objects : No_Param_Proc;\n+      @b{pragma} Import (C, Finalize_Library_Objects, \"__gnat_finalize_library_objects\");\n \n    --  Start of processing for adainit\n \n    @b{begin}\n \n-      --  Call SDP_Table_Build to build the top level procedure\n-      --  table for zero cost exception handling (omitted in\n-      --  longjmp/setjmp mode).\n-\n-      SDP_Table_Build (ST'Address, 23, EA'Address, 23);\n-\n-      --  Call Set_Globals to record various information for\n-      --  this partition.  The values are derived by the binder\n-      --  from information stored in the ali files by the compiler.\n-\n-@findex __gnat_set_globals\n-      Set_Globals\n-        (Main_Priority            => -1,\n-         --  Priority of main program, -1 if no pragma Priority used\n-\n-         Time_Slice_Value         => -1,\n-         --  Time slice from Time_Slice pragma, -1 if none used\n-\n-         WC_Encoding              => 'b',\n-         --  Wide_Character encoding used, default is brackets\n-\n-         Locking_Policy           => ' ',\n-         --  Locking_Policy used, default of space means not\n-         --  specified, otherwise it is the first character of\n-         --  the policy name.\n-\n-         Queuing_Policy           => ' ',\n-         --  Queuing_Policy used, default of space means not\n-         --  specified, otherwise it is the first character of\n-         --  the policy name.\n-\n-         Task_Dispatching_Policy  => ' ',\n-         --  Task_Dispatching_Policy used, default of space means\n-         --  not specified, otherwise first character of the\n-         --  policy name.\n-\n-         Adafinal                 => System.Null_Address,\n-         --  Address of Adafinal routine, not used anymore\n-\n-         Unreserve_All_Interrupts => 0,\n-         --  Set true if pragma Unreserve_All_Interrupts was used\n-\n-         Exception_Tracebacks     => 0);\n-         --  Indicates if exception tracebacks are enabled\n-\n-      Elab_Final_Code := 1;\n+      --  Record various information for this partition.  The values\n+      --  are derived by the binder from information stored in the ali\n+      --  files by the compiler.\n+\n+      @b{if} Is_Elaborated @b{then}\n+         @b{return};\n+      @b{end if};\n+      Is_Elaborated := True;\n+      Main_Priority := -1;\n+      Time_Slice_Value := -1;\n+      WC_Encoding := 'b';\n+      Locking_Policy := ' ';\n+      Queuing_Policy := ' ';\n+      Task_Dispatching_Policy := ' ';\n+      Priority_Specific_Dispatching :=\n+        Local_Priority_Specific_Dispatching'Address;\n+      Num_Specific_Dispatching := 0;\n+      Main_CPU := -1;\n+      Interrupt_States := Local_Interrupt_States'Address;\n+      Num_Interrupt_States := 0;\n+      Unreserve_All_Interrupts := 0;\n+      Detect_Blocking := 0;\n+      Default_Stack_Size := -1;\n+      Leap_Seconds_Support := 0;\n+\n+      Runtime_Initialize;\n+\n+      Finalize_Library_Objects := finalize_library'access;\n \n       --  Now we have the elaboration calls for all units in the partition.\n       --  The Elab_Spec and Elab_Body attributes generate references to the\n       --  implicit elaboration procedures generated by the compiler for\n-      --  each unit that requires elaboration.\n-\n-      @b{if} @b{not} E040 @b{then}\n-         Interfaces.C_Streams'Elab_Spec;\n-      @b{end} @b{if};\n-      E040 := True;\n-      @b{if} @b{not} E008 @b{then}\n-         Ada.Exceptions'Elab_Spec;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E014 @b{then}\n-         System.Exception_Table'Elab_Body;\n-         E014 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E053 @b{then}\n-         Ada.Io_Exceptions'Elab_Spec;\n-         E053 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E017 @b{then}\n-         System.Exceptions'Elab_Spec;\n-         E017 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E030 @b{then}\n-         System.Stack_Checking'Elab_Spec;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E028 @b{then}\n-         System.Soft_Links'Elab_Body;\n-         E028 := True;\n-      @b{end} @b{if};\n-      E030 := True;\n-      @b{if} @b{not} E024 @b{then}\n-         System.Secondary_Stack'Elab_Body;\n-         E024 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E035 @b{then}\n-         Ada.Tags'Elab_Spec;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E035 @b{then}\n-         Ada.Tags'Elab_Body;\n-         E035 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E033 @b{then}\n-         Ada.Streams'Elab_Spec;\n-         E033 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E046 @b{then}\n-         System.Finalization_Root'Elab_Spec;\n-      @b{end} @b{if};\n-      E046 := True;\n-      @b{if} @b{not} E008 @b{then}\n-         Ada.Exceptions'Elab_Body;\n-         E008 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E048 @b{then}\n-         System.Finalization_Implementation'Elab_Spec;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E048 @b{then}\n-         System.Finalization_Implementation'Elab_Body;\n-         E048 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E044 @b{then}\n-         Ada.Finalization'Elab_Spec;\n-      @b{end} @b{if};\n-      E044 := True;\n-      @b{if} @b{not} E057 @b{then}\n-         Ada.Finalization.List_Controller'Elab_Spec;\n-      @b{end} @b{if};\n-      E057 := True;\n-      @b{if} @b{not} E055 @b{then}\n-         System.File_Control_Block'Elab_Spec;\n-         E055 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E042 @b{then}\n-         System.File_Io'Elab_Body;\n-         E042 := True;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E006 @b{then}\n-         Ada.Text_Io'Elab_Spec;\n-      @b{end} @b{if};\n-      @b{if} @b{not} E006 @b{then}\n-         Ada.Text_Io'Elab_Body;\n-         E006 := True;\n-      @b{end} @b{if};\n-\n-      Elab_Final_Code := 0;\n+      --  each unit that requires elaboration. Increment a counter of\n+      --  reference for each unit.\n+\n+      System.Soft_Links'Elab_Spec;\n+      System.Exception_Table'Elab_Body;\n+      E23 := E23 + 1;\n+      Ada.Io_Exceptions'Elab_Spec;\n+      E46 := E46 + 1;\n+      Ada.Tags'Elab_Spec;\n+      Ada.Streams'Elab_Spec;\n+      E45 := E45 + 1;\n+      Interfaces.C'Elab_Spec;\n+      System.Exceptions'Elab_Spec;\n+      E25 := E25 + 1;\n+      System.Finalization_Root'Elab_Spec;\n+      E68 := E68 + 1;\n+      Ada.Finalization'Elab_Spec;\n+      E66 := E66 + 1;\n+      System.Storage_Pools'Elab_Spec;\n+      E85 := E85 + 1;\n+      System.Finalization_Masters'Elab_Spec;\n+      System.Storage_Pools.Subpools'Elab_Spec;\n+      System.Pool_Global'Elab_Spec;\n+      E87 := E87 + 1;\n+      System.File_Control_Block'Elab_Spec;\n+      E75 := E75 + 1;\n+      System.File_Io'Elab_Body;\n+      E64 := E64 + 1;\n+      E91 := E91 + 1;\n+      System.Finalization_Masters'Elab_Body;\n+      E77 := E77 + 1;\n+      E70 := E70 + 1;\n+      Ada.Tags'Elab_Body;\n+      E48 := E48 + 1;\n+      System.Soft_Links'Elab_Body;\n+      E13 := E13 + 1;\n+      System.Os_Lib'Elab_Body;\n+      E72 := E72 + 1;\n+      System.Secondary_Stack'Elab_Body;\n+      E17 := E17 + 1;\n+      Ada.Text_Io'Elab_Spec;\n+      Ada.Text_Io'Elab_Body;\n+      E06 := E06 + 1;\n    @b{end} adainit;\n \n    --------------\n@@ -22883,10 +22909,31 @@ Comments have been added for clarification purposes.\n \n @findex adafinal\n    @b{procedure} adafinal @b{is}\n+      @b{procedure} s_stalib_adafinal;\n+      @b{pragma} Import (C, s_stalib_adafinal, \"system__standard_library__adafinal\");\n+\n+      @b{procedure} Runtime_Finalize;\n+      @b{pragma} Import (C, Runtime_Finalize, \"__gnat_runtime_finalize\");\n+\n    @b{begin}\n-      Do_Finalize;\n+      @b{if not} Is_Elaborated @b{then}\n+         @b{return};\n+      @b{end if};\n+      Is_Elaborated := False;\n+      Runtime_Finalize;\n+      s_stalib_adafinal;\n    @b{end} adafinal;\n \n+   --  We get to the main program of the partition by using\n+   --  pragma Import because if we try to with the unit and\n+   --  call it Ada style, then not only do we waste time\n+   --  recompiling it, but also, we don't really know the right\n+   --  switches (e.g.@: identifier character set) to be used\n+   --  to compile it.\n+\n+   @b{procedure} Ada_Main_Program;\n+   @b{pragma} Import (Ada, Ada_Main_Program, \"_ada_hello\");\n+\n    ----------\n    -- main --\n    ----------\n@@ -22923,15 +22970,12 @@ Comments have been added for clarification purposes.\n       @b{procedure} finalize;\n       @b{pragma} Import (C, finalize, \"__gnat_finalize\");\n \n-      --  We get to the main program of the partition by using\n-      --  pragma Import because if we try to with the unit and\n-      --  call it Ada style, then not only do we waste time\n-      --  recompiling it, but also, we don't really know the right\n-      --  switches (e.g.@: identifier character set) to be used\n-      --  to compile it.\n+      --  The following is to initialize the SEH exceptions\n+\n+      SEH : @b{aliased array} (1 .. 2) of Integer;\n \n-      @b{procedure} Ada_Main_Program;\n-      @b{pragma} Import (Ada, Ada_Main_Program, \"_ada_hello\");\n+      Ensure_Reference : aliased System.Address := Ada_Main_Program_Name'Address;\n+      @b{pragma} Volatile (Ensure_Reference);\n \n    --  Start of processing for main\n \n@@ -22944,17 +22988,12 @@ Comments have been added for clarification purposes.\n \n       --  Call low level system initialization\n \n-      Initialize;\n+      Initialize (SEH'Address);\n \n       --  Call our generated Ada initialization routine\n \n       adainit;\n \n-      --  This is the point at which we want the debugger to get\n-      --  control\n-\n-      Break_Start;\n-\n       --  Now we call the main program of the partition\n \n       Ada_Main_Program;"}, {"sha": "8282ba57cf59e8e8a3ed719eea14ec49c62ff966", "filename": "gcc/ada/initialize.c", "status": "modified", "additions": 1, "deletions": 223, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -62,230 +62,15 @@ extern \"C\" {\n /* __gnat_initialize (NT-mingw32 Version) */\n /******************************************/\n \n-int __gnat_wide_text_translation_required = 0;\n-/* wide text translation, 0=none, 1=activated */\n+extern void __gnat_install_handler(void);\n \n #if defined (__MINGW32__)\n-#include \"mingw32.h\"\n-#include <windows.h>\n \n-extern void __gnat_init_float (void);\n extern void __gnat_install_SEH_handler (void *);\n \n-extern int gnat_argc;\n-extern char **gnat_argv;\n-extern CRITICAL_SECTION ProcListCS;\n-extern HANDLE ProcListEvt;\n-\n-#ifdef GNAT_UNICODE_SUPPORT\n-\n-#define EXPAND_ARGV_RATE 128\n-\n-static void\n-append_arg (int *index, LPWSTR dir, LPWSTR value,\n-\t    char ***argv, int *last, int quoted)\n-{\n-  int size;\n-  LPWSTR fullvalue;\n-  int vallen = _tcslen (value);\n-  int dirlen;\n-\n-  if (dir == NULL)\n-    {\n-      /* no dir prefix */\n-      dirlen = 0;\n-      fullvalue = (LPWSTR) xmalloc ((vallen + 1) * sizeof(TCHAR));\n-    }\n-  else\n-    {\n-      /* Add dir first */\n-      dirlen = _tcslen (dir);\n-\n-      fullvalue = (LPWSTR) xmalloc ((dirlen + vallen + 1) * sizeof(TCHAR));\n-      _tcscpy (fullvalue, dir);\n-    }\n-\n-  /* Append value */\n-\n-  if (quoted)\n-    {\n-      _tcsncpy (fullvalue + dirlen, value + 1, vallen - 1);\n-      fullvalue [dirlen + vallen - sizeof(TCHAR)] = _T('\\0');\n-    }\n-  else\n-    _tcscpy (fullvalue + dirlen, value);\n-\n-  if (*last <= *index)\n-    {\n-      *last += EXPAND_ARGV_RATE;\n-      *argv = (char **) xrealloc (*argv, (*last) * sizeof (char *));\n-    }\n-\n-  size = WS2SC (NULL, fullvalue, 0);\n-  (*argv)[*index] = (char *) xmalloc (size + sizeof(TCHAR));\n-  WS2SC ((*argv)[*index], fullvalue, size);\n-\n-  free (fullvalue);\n-\n-  (*index)++;\n-}\n-#endif\n-\n void\n __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n {\n-   /* Initialize floating-point coprocessor. This call is needed because\n-      the MS libraries default to 64-bit precision instead of 80-bit\n-      precision, and we require the full precision for proper operation,\n-      given that we have set Max_Digits etc with this in mind */\n-   __gnat_init_float ();\n-\n-   /* Initialize the critical section and event handle for the win32_wait()\n-      implementation, see adaint.c */\n-   InitializeCriticalSection (&ProcListCS);\n-   ProcListEvt = CreateEvent (NULL, FALSE, FALSE, NULL);\n-\n-#ifdef GNAT_UNICODE_SUPPORT\n-   /* Set current code page for filenames handling. */\n-   {\n-     char *codepage = getenv (\"GNAT_CODE_PAGE\");\n-\n-     /* Default code page is UTF-8.  */\n-     CurrentCodePage = CP_UTF8;\n-\n-     if (codepage != NULL)\n-       {\n-\t if (strcmp (codepage, \"CP_ACP\") == 0)\n-\t   CurrentCodePage = CP_ACP;\n-\t else if (strcmp (codepage, \"CP_UTF8\") == 0)\n-\t   CurrentCodePage = CP_UTF8;\n-       }\n-   }\n-\n-   /* Set current encoding for the IO.  */\n-   {\n-     char *ccsencoding = getenv (\"GNAT_CCS_ENCODING\");\n-\n-     /* Default CCS Encoding.  */\n-     CurrentCCSEncoding = _O_TEXT;\n-     __gnat_wide_text_translation_required = 0;\n-\n-     if (ccsencoding != NULL)\n-       {\n-\t if (strcmp (ccsencoding, \"U16TEXT\") == 0)\n-           {\n-             CurrentCCSEncoding = _O_U16TEXT;\n-             __gnat_wide_text_translation_required = 1;\n-           }\n-\t else if (strcmp (ccsencoding, \"TEXT\") == 0)\n-           {\n-             CurrentCCSEncoding = _O_TEXT;\n-             __gnat_wide_text_translation_required = 0;\n-           }\n-\t else if (strcmp (ccsencoding, \"WTEXT\") == 0)\n-           {\n-             CurrentCCSEncoding = _O_WTEXT;\n-             __gnat_wide_text_translation_required = 1;\n-           }\n-\t else if (strcmp (ccsencoding, \"U8TEXT\") == 0)\n-           {\n-             CurrentCCSEncoding = _O_U8TEXT;\n-             __gnat_wide_text_translation_required = 1;\n-           }\n-       }\n-   }\n-\n-   /* Adjust gnat_argv to support Unicode characters. */\n-   {\n-     LPWSTR *wargv;\n-     int wargc;\n-     int k;\n-     int last;\n-     int argc_expanded = 0;\n-     TCHAR result [MAX_PATH];\n-     int quoted;\n-\n-     wargv = CommandLineToArgvW (GetCommandLineW(), &wargc);\n-\n-     if (wargv != NULL)\n-       {\n-\t /* Set gnat_argv with arguments encoded in UTF-8. */\n-\t last = wargc + 1;\n-\t gnat_argv = (char **) xmalloc ((last) * sizeof (char *));\n-\n-\t /* argv[0] is the executable full path-name. */\n-\n-\t SearchPath (NULL, wargv[0], _T(\".exe\"), MAX_PATH, result, NULL);\n-\t append_arg (&argc_expanded, NULL, result, &gnat_argv, &last, 0);\n-\n-\t for (k=1; k<wargc; k++)\n-\t   {\n-\t     quoted = (wargv[k][0] == _T('\\''));\n-\n-\t     /* Check for wildcard expansion if the argument is not quoted. */\n-\t     if (!quoted\n-\t\t && (_tcsstr (wargv[k], _T(\"?\")) != 0 ||\n-\t\t     _tcsstr (wargv[k], _T(\"*\")) != 0))\n-\t       {\n-\t\t /* Wilcards are present, append all corresponding matches. */\n-\t\t WIN32_FIND_DATA FileData;\n-\t\t HANDLE hDir = FindFirstFile (wargv[k], &FileData);\n-\t\t LPWSTR dir = NULL;\n-\t\t LPWSTR ldir = _tcsrchr (wargv[k], _T('\\\\'));\n-\n-\t\t if (ldir == NULL)\n-\t\t   ldir = _tcsrchr (wargv[k], _T('/'));\n-\n-\t\t if (hDir == INVALID_HANDLE_VALUE)\n-\t\t   {\n-\t\t     /* No match, append arg as-is. */\n-\t\t     append_arg (&argc_expanded, NULL, wargv[k],\n-\t\t\t\t &gnat_argv, &last, quoted);\n-\t\t   }\n-\t\t else\n-\t\t   {\n-\t\t     if (ldir != NULL)\n-\t\t       {\n-\t\t\t int n = ldir - wargv[k] + 1;\n-\t\t\t dir = (LPWSTR) xmalloc ((n + 1) * sizeof (TCHAR));\n-\t\t\t _tcsncpy (dir, wargv[k], n);\n-\t\t\t dir[n] = _T('\\0');\n-\t\t       }\n-\n-\t\t     /* Append first match and all remaining ones.  */\n-\n-\t\t     do {\n-\t\t       /* Do not add . and .. special entries */\n-\n-\t\t       if (_tcscmp (FileData.cFileName, _T(\".\")) != 0\n-\t\t\t   && _tcscmp (FileData.cFileName, _T(\"..\")) != 0)\n-\t\t\t append_arg (&argc_expanded, dir, FileData.cFileName,\n-\t\t\t\t     &gnat_argv, &last, 0);\n-\t\t     } while (FindNextFile (hDir, &FileData));\n-\n-\t\t     FindClose (hDir);\n-\n-\t\t     if (dir != NULL)\n-\t\t       free (dir);\n-\t\t   }\n-\t       }\n-\t     else\n-\t       {\n-\t\t /*  No wildcard. Store parameter as-is. Remove quote if\n-\t\t     needed. */\n-\t\t append_arg (&argc_expanded, NULL, wargv[k],\n-\t\t\t     &gnat_argv, &last, quoted);\n-\t       }\n-\t   }\n-\n-\t LocalFree (wargv);\n-\t gnat_argc = argc_expanded;\n-\t gnat_argv = (char **) xrealloc\n-\t   (gnat_argv, argc_expanded * sizeof (char *));\n-       }\n-   }\n-#endif\n-\n    /* Note that we do not activate this for the compiler itself to avoid a\n       bootstrap path problem.  Older version of gnatbind will generate a call\n       to __gnat_initialize() without argument. Therefore we cannot use eh in\n@@ -305,12 +90,9 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n #elif defined (__Lynx__) || defined (__FreeBSD__) || defined(__NetBSD__) \\\n   || defined (__OpenBSD__)\n \n-extern void __gnat_init_float (void);\n-\n void\n __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n {\n-   __gnat_init_float ();\n }\n \n /***************************************/\n@@ -319,12 +101,9 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n \n #elif defined(__vxworks)\n \n-extern void __gnat_init_float (void);\n-\n void\n __gnat_initialize (void *eh)\n {\n-  __gnat_init_float ();\n }\n \n #elif defined(_T_HPUX10) || (!defined(IN_RTS) && defined(_X_HPUX10))\n@@ -354,7 +133,6 @@ void\n __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n {\n }\n-\n #endif\n \n #ifdef __cplusplus"}, {"sha": "05009643c67d71a0534bb301b367d424ac8f0aa1", "filename": "gcc/ada/rtfinal.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Frtfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Frtfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtfinal.c?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -0,0 +1,89 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                              R T F I N A L                               *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *             Copyright (C) 2014-2015, Free Software Foundation, Inc.      *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * You should have received a copy of the GNU General Public License and    *\n+ * a copy of the GCC Runtime Library Exception along with this program;     *\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern void __gnat_runtime_finalize (void);\n+\n+/* This routine is called at the extreme end of execution of an Ada program\n+   (the call is generated by the binder). The standard routine does nothing\n+   at all, the intention is that this be replaced by system specific code\n+   where finalization is required.\n+\n+   Note that __gnat_runtime_initialize() is called in adafinal()   */\n+\n+extern int __gnat_rt_init_count;\n+/*  see initialize.c  */\n+\n+#if defined (__MINGW32__)\n+#include \"mingw32.h\"\n+#include <windows.h>\n+\n+extern CRITICAL_SECTION ProcListCS;\n+extern HANDLE ProcListEvt;\n+\n+void\n+__gnat_runtime_finalize (void)\n+{\n+  /*  decrement the reference counter */\n+\n+  __gnat_rt_init_count--;\n+\n+  /*  if still some referenced return now */\n+  if (__gnat_rt_init_count > 0)\n+    return;\n+\n+  /* delete critical section and event handle used for the\n+     processes chain list */\n+  DeleteCriticalSection(&ProcListCS);\n+  CloseHandle (ProcListEvt);\n+}\n+\n+#else\n+\n+void\n+__gnat_runtime_finalize (void)\n+{\n+  /*  decrement the reference counter */\n+\n+  __gnat_rt_init_count--;\n+\n+  /*  if still some referenced return now */\n+  if (__gnat_rt_init_count > 0)\n+    return;\n+}\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "59bac0f1036ea2407a005b3ad817858b86faf6b9", "filename": "gcc/ada/rtinit.c", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Frtinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e188be3ba696461d3010c9d40e3ff156f7f4d0/gcc%2Fada%2Frtinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtinit.c?ref=07e188be3ba696461d3010c9d40e3ff156f7f4d0", "patch": "@@ -0,0 +1,381 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                           I N I T I A L I Z E                            *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *            Copyright (C) 2014-2015, Free Software Foundation, Inc.       *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * You should have received a copy of the GNU General Public License and    *\n+ * a copy of the GCC Runtime Library Exception along with this program;     *\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/*  This unit provides implementation for __gnat_runtime_initialize ()\n+    which is called in adainit() to do special initialization needed by\n+    the GNAT runtime.  */\n+\n+\n+/* The following include is here to meet the published VxWorks requirement\n+   that the __vxworks header appear before any other include.  */\n+#ifdef __vxworks\n+#include \"vxWorks.h\"\n+#endif\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+/* We don't have libiberty, so use malloc.  */\n+#define xmalloc(S) malloc (S)\n+#define xrealloc(V,S) realloc (V,S)\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"raise.h\"\n+#include <fcntl.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/**************************************************/\n+/* __gnat_runtime_initialize (NT-mingw32 Version) */\n+/**************************************************/\n+\n+extern void __gnat_install_handler(void);\n+\n+int __gnat_wide_text_translation_required = 0;\n+/* wide text translation, 0=none, 1=activated */\n+\n+int __gnat_rt_init_count = 0;\n+/* number of references to the GNAT runtime, this is used to initialize\n+   and finalize properly the run-time. */\n+\n+#if defined (__MINGW32__)\n+#include \"mingw32.h\"\n+#include <windows.h>\n+\n+extern void __gnat_init_float (void);\n+extern void __gnat_install_SEH_handler (void *);\n+\n+extern int gnat_argc;\n+extern char **gnat_argv;\n+extern CRITICAL_SECTION ProcListCS;\n+extern HANDLE ProcListEvt;\n+\n+#ifdef GNAT_UNICODE_SUPPORT\n+\n+#define EXPAND_ARGV_RATE 128\n+\n+static void\n+append_arg (int *index, LPWSTR dir, LPWSTR value,\n+\t    char ***argv, int *last, int quoted)\n+{\n+  int size;\n+  LPWSTR fullvalue;\n+  int vallen = _tcslen (value);\n+  int dirlen;\n+\n+  if (dir == NULL)\n+    {\n+      /* no dir prefix */\n+      dirlen = 0;\n+      fullvalue = (LPWSTR) xmalloc ((vallen + 1) * sizeof(TCHAR));\n+    }\n+  else\n+    {\n+      /* Add dir first */\n+      dirlen = _tcslen (dir);\n+\n+      fullvalue = (LPWSTR) xmalloc ((dirlen + vallen + 1) * sizeof(TCHAR));\n+      _tcscpy (fullvalue, dir);\n+    }\n+\n+  /* Append value */\n+\n+  if (quoted)\n+    {\n+      _tcsncpy (fullvalue + dirlen, value + 1, vallen - 1);\n+      fullvalue [dirlen + vallen - sizeof(TCHAR)] = _T('\\0');\n+    }\n+  else\n+    _tcscpy (fullvalue + dirlen, value);\n+\n+  if (*last <= *index)\n+    {\n+      *last += EXPAND_ARGV_RATE;\n+      *argv = (char **) xrealloc (*argv, (*last) * sizeof (char *));\n+    }\n+\n+  size = WS2SC (NULL, fullvalue, 0);\n+  (*argv)[*index] = (char *) xmalloc (size + sizeof(TCHAR));\n+  WS2SC ((*argv)[*index], fullvalue, size);\n+\n+  free (fullvalue);\n+\n+  (*index)++;\n+}\n+#endif\n+\n+void\n+__gnat_runtime_initialize(void)\n+{\n+  /*  increment the reference counter */\n+\n+  __gnat_rt_init_count++;\n+\n+  /*  if already initialized return now */\n+  if (__gnat_rt_init_count > 1)\n+    return;\n+\n+   /* Initialize floating-point coprocessor. This call is needed because\n+      the MS libraries default to 64-bit precision instead of 80-bit\n+      precision, and we require the full precision for proper operation,\n+      given that we have set Max_Digits etc with this in mind */\n+\n+   __gnat_init_float ();\n+\n+   /* Initialize the critical section and event handle for the win32_wait()\n+      implementation, see adaint.c */\n+\n+   InitializeCriticalSection (&ProcListCS);\n+   ProcListEvt = CreateEvent (NULL, FALSE, FALSE, NULL);\n+\n+#ifdef GNAT_UNICODE_SUPPORT\n+   /* Set current code page for filenames handling. */\n+   {\n+     char *codepage = getenv (\"GNAT_CODE_PAGE\");\n+\n+     /* Default code page is UTF-8.  */\n+     CurrentCodePage = CP_UTF8;\n+\n+     if (codepage != NULL)\n+       {\n+\t if (strcmp (codepage, \"CP_ACP\") == 0)\n+\t   CurrentCodePage = CP_ACP;\n+\t else if (strcmp (codepage, \"CP_UTF8\") == 0)\n+\t   CurrentCodePage = CP_UTF8;\n+       }\n+   }\n+\n+   /* Set current encoding for the IO.  */\n+   {\n+     char *ccsencoding = getenv (\"GNAT_CCS_ENCODING\");\n+\n+     /* Default CCS Encoding.  */\n+     CurrentCCSEncoding = _O_TEXT;\n+     __gnat_wide_text_translation_required = 0;\n+\n+     if (ccsencoding != NULL)\n+       {\n+\t if (strcmp (ccsencoding, \"U16TEXT\") == 0)\n+           {\n+             CurrentCCSEncoding = _O_U16TEXT;\n+             __gnat_wide_text_translation_required = 1;\n+           }\n+\t else if (strcmp (ccsencoding, \"TEXT\") == 0)\n+           {\n+             CurrentCCSEncoding = _O_TEXT;\n+             __gnat_wide_text_translation_required = 0;\n+           }\n+\t else if (strcmp (ccsencoding, \"WTEXT\") == 0)\n+           {\n+             CurrentCCSEncoding = _O_WTEXT;\n+             __gnat_wide_text_translation_required = 1;\n+           }\n+\t else if (strcmp (ccsencoding, \"U8TEXT\") == 0)\n+           {\n+             CurrentCCSEncoding = _O_U8TEXT;\n+             __gnat_wide_text_translation_required = 1;\n+           }\n+       }\n+   }\n+\n+   /* Adjust gnat_argv to support Unicode characters. */\n+   {\n+     LPWSTR *wargv;\n+     int wargc;\n+     int k;\n+     int last;\n+     int argc_expanded = 0;\n+     TCHAR result [MAX_PATH];\n+     int quoted;\n+\n+     wargv = CommandLineToArgvW (GetCommandLineW(), &wargc);\n+\n+     if (wargv != NULL)\n+       {\n+\t /* Set gnat_argv with arguments encoded in UTF-8. */\n+\t last = wargc + 1;\n+\t gnat_argv = (char **) xmalloc ((last) * sizeof (char *));\n+\n+\t /* argv[0] is the executable full path-name. */\n+\n+\t SearchPath (NULL, wargv[0], _T(\".exe\"), MAX_PATH, result, NULL);\n+\t append_arg (&argc_expanded, NULL, result, &gnat_argv, &last, 0);\n+\n+\t for (k=1; k<wargc; k++)\n+\t   {\n+\t     quoted = (wargv[k][0] == _T('\\''));\n+\n+\t     /* Check for wildcard expansion if the argument is not quoted. */\n+\t     if (!quoted\n+\t\t && (_tcsstr (wargv[k], _T(\"?\")) != 0 ||\n+\t\t     _tcsstr (wargv[k], _T(\"*\")) != 0))\n+\t       {\n+\t\t /* Wilcards are present, append all corresponding matches. */\n+\t\t WIN32_FIND_DATA FileData;\n+\t\t HANDLE hDir = FindFirstFile (wargv[k], &FileData);\n+\t\t LPWSTR dir = NULL;\n+\t\t LPWSTR ldir = _tcsrchr (wargv[k], _T('\\\\'));\n+\n+\t\t if (ldir == NULL)\n+\t\t   ldir = _tcsrchr (wargv[k], _T('/'));\n+\n+\t\t if (hDir == INVALID_HANDLE_VALUE)\n+\t\t   {\n+\t\t     /* No match, append arg as-is. */\n+\t\t     append_arg (&argc_expanded, NULL, wargv[k],\n+\t\t\t\t &gnat_argv, &last, quoted);\n+\t\t   }\n+\t\t else\n+\t\t   {\n+\t\t     if (ldir != NULL)\n+\t\t       {\n+\t\t\t int n = ldir - wargv[k] + 1;\n+\t\t\t dir = (LPWSTR) xmalloc ((n + 1) * sizeof (TCHAR));\n+\t\t\t _tcsncpy (dir, wargv[k], n);\n+\t\t\t dir[n] = _T('\\0');\n+\t\t       }\n+\n+\t\t     /* Append first match and all remaining ones.  */\n+\n+\t\t     do {\n+\t\t       /* Do not add . and .. special entries */\n+\n+\t\t       if (_tcscmp (FileData.cFileName, _T(\".\")) != 0\n+\t\t\t   && _tcscmp (FileData.cFileName, _T(\"..\")) != 0)\n+\t\t\t append_arg (&argc_expanded, dir, FileData.cFileName,\n+\t\t\t\t     &gnat_argv, &last, 0);\n+\t\t     } while (FindNextFile (hDir, &FileData));\n+\n+\t\t     FindClose (hDir);\n+\n+\t\t     if (dir != NULL)\n+\t\t       free (dir);\n+\t\t   }\n+\t       }\n+\t     else\n+\t       {\n+\t\t /*  No wildcard. Store parameter as-is. Remove quote if\n+\t\t     needed. */\n+\t\t append_arg (&argc_expanded, NULL, wargv[k],\n+\t\t\t     &gnat_argv, &last, quoted);\n+\t       }\n+\t   }\n+\n+\t LocalFree (wargv);\n+\t gnat_argc = argc_expanded;\n+\t gnat_argv = (char **) xrealloc\n+\t   (gnat_argv, argc_expanded * sizeof (char *));\n+       }\n+   }\n+#endif\n+\n+   __gnat_install_handler();\n+}\n+\n+/**************************************************/\n+/* __gnat_runtime_initialize (init_float version) */\n+/**************************************************/\n+\n+#elif defined (__Lynx__) || defined (__FreeBSD__) || defined(__NetBSD__) \\\n+  || defined (__OpenBSD__)\n+\n+extern void __gnat_init_float (void);\n+\n+void\n+__gnat_runtime_initialize(void)\n+{\n+  /*  increment the reference counter */\n+\n+  __gnat_rt_init_count++;\n+\n+  /*  if already initialized return now */\n+  if (__gnat_rt_init_count > 1)\n+    return;\n+\n+   __gnat_init_float ();\n+\n+   __gnat_install_handler();\n+}\n+\n+/***********************************************/\n+/* __gnat_runtime_initialize (VxWorks Version) */\n+/***********************************************/\n+\n+#elif defined(__vxworks)\n+\n+extern void __gnat_init_float (void);\n+\n+void\n+__gnat_runtime_initialize(void)\n+{\n+  /*  increment the reference counter */\n+\n+  __gnat_rt_init_count++;\n+\n+  /*  if already initialized return now */\n+  if (__gnat_rt_init_count > 1)\n+    return;\n+\n+  __gnat_init_float ();\n+\n+  __gnat_install_handler();\n+}\n+\n+#else\n+\n+/***********************************************/\n+/* __gnat_runtime_initialize (default version) */\n+/***********************************************/\n+\n+void\n+__gnat_runtime_initialize(void)\n+{\n+  /*  increment the reference counter */\n+\n+  __gnat_rt_init_count++;\n+\n+  /*  if already initialized return now */\n+  if (__gnat_rt_init_count > 1)\n+    return;\n+\n+  __gnat_install_handler();\n+}\n+\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif"}]}