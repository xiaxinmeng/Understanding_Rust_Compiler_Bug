{"sha": "b7c3f201be582553f9e3506536aa406bbd7ee71c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdjM2YyMDFiZTU4MjU1M2Y5ZTM1MDY1MzZhYTQwNmJiZDdlZTcxYw==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2021-01-07T20:07:06Z"}, "committer": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2021-01-07T20:52:37Z"}, "message": "libstdc++: Add support for C++20 barriers\n\nAdds <barrier>\n\nlibstdc++-v3/ChangeLog:\n\n\t* doc/doxygen/user.cfg.in: Add new header.\n\t* include/Makefile.am (std_headers): likewise.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Add new header.\n\t* include/std/barrier: New file.\n\t* include/std/version: Add __cpp_lib_barrier feature test macro.\n\t* testsuite/30_threads/barrier/1.cc: New test.\n\t* testsuite/30_threads/barrier/2.cc: Likewise.\n\t* testsuite/30_threads/barrier/arrive_and_drop.cc: Likewise.\n\t* testsuite/30_threads/barrier/arrive_and_wait.cc: Likewise.\n\t* testsuite/30_threads/barrier/arrive.cc: Likewise.\n\t* testsuite/30_threads/barrier/completion.cc: Likewise.", "tree": {"sha": "6e070a70358a6df1db144dbf6abec1d7634a7a15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e070a70358a6df1db144dbf6abec1d7634a7a15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7c3f201be582553f9e3506536aa406bbd7ee71c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c3f201be582553f9e3506536aa406bbd7ee71c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c3f201be582553f9e3506536aa406bbd7ee71c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c3f201be582553f9e3506536aa406bbd7ee71c/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677759f753d321bde52d7343227f842b7e759d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0677759f753d321bde52d7343227f842b7e759d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0677759f753d321bde52d7343227f842b7e759d2"}], "stats": {"total": 505, "additions": 505, "deletions": 0}, "files": [{"sha": "fb90db65e559022cc00eba1f558b1449fc5d5824", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -850,6 +850,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/any \\\n                          include/array \\\n                          include/atomic \\\n+                         include/barrier \\\n                          include/bit \\\n                          include/bitset \\\n                          include/charconv \\"}, {"sha": "90508a8fe8338beb26bb848457762182443c117f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -30,6 +30,7 @@ std_headers = \\\n \t${std_srcdir}/any \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n+\t${std_srcdir}/barrier \\\n \t${std_srcdir}/bit \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/charconv \\"}, {"sha": "922ba440df09a8eaf8846a867b856baef26efa3b", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -380,6 +380,7 @@ std_headers = \\\n \t${std_srcdir}/any \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n+\t${std_srcdir}/barrier \\\n \t${std_srcdir}/bit \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/charconv \\"}, {"sha": "d2601d7859db94fb00efdf5d77be5d0ddf4ed1fa", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -134,6 +134,7 @@\n #endif\n \n #if __cplusplus > 201703L\n+#include <barrier>\n #include <bit>\n #include <compare>\n #include <concepts>"}, {"sha": "f1143da89b4cbe0ad180e90199ff9a0384ed6b8a", "filename": "libstdc++-v3/include/std/barrier", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,247 @@\n+// <barrier> -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This implementation is based on libcxx/include/barrier\n+//===-- barrier.h --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===---------------------------------------------------------------===//\n+\n+/** @file include/barrier\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_BARRIER\n+#define _GLIBCXX_BARRIER 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L\n+#include <bits/atomic_base.h>\n+#if __cpp_lib_atomic_wait && __cpp_aligned_new\n+#include <bits/std_thread.h>\n+#include <bits/unique_ptr.h>\n+\n+#include <array>\n+\n+#define __cpp_lib_barrier 201907L\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  struct __empty_completion\n+  {\n+    _GLIBCXX_ALWAYS_INLINE void\n+    operator()() noexcept\n+    { }\n+  };\n+\n+/*\n+\n+The default implementation of __tree_barrier is a classic tree barrier.\n+\n+It looks different from literature pseudocode for two main reasons:\n+ 1. Threads that call into std::barrier functions do not provide indices,\n+    so a numbering step is added before the actual barrier algorithm,\n+    appearing as an N+1 round to the N rounds of the tree barrier.\n+ 2. A great deal of attention has been paid to avoid cache line thrashing\n+    by flattening the tree structure into cache-line sized arrays, that\n+    are indexed in an efficient way.\n+\n+*/\n+\n+  enum class __barrier_phase_t : unsigned char { };\n+\n+  template<typename _CompletionF>\n+    class __tree_barrier\n+    {\n+      using __atomic_phase_ref_t = std::__atomic_ref<__barrier_phase_t>;\n+      using __atomic_phase_const_ref_t = std::__atomic_ref<const __barrier_phase_t>;\n+      static constexpr auto __phase_alignment =\n+\t\t      __atomic_phase_ref_t::required_alignment;\n+\n+      using __tickets_t = std::array<__barrier_phase_t, 64>;\n+      struct alignas(64) /* naturally-align the heap state */ __state_t\n+      {\n+\talignas(__phase_alignment) __tickets_t __tickets;\n+      };\n+\n+      ptrdiff_t _M_expected;\n+      unique_ptr<__state_t[]> _M_state;\n+      __atomic_base<ptrdiff_t> _M_expected_adjustment;\n+      _CompletionF _M_completion;\n+\n+      alignas(__phase_alignment) __barrier_phase_t  _M_phase;\n+\n+      bool\n+      _M_arrive(__barrier_phase_t __old_phase)\n+      {\n+\tconst auto __old_phase_val = static_cast<unsigned char>(__old_phase);\n+\tconst auto __half_step =\n+\t\t\t   static_cast<__barrier_phase_t>(__old_phase_val + 1);\n+\tconst auto __full_step =\n+\t\t\t   static_cast<__barrier_phase_t>(__old_phase_val + 2);\n+\n+\tsize_t __current_expected = _M_expected;\n+\tstd::hash<std::thread::id>__hasher;\n+\tsize_t __current = __hasher(std::this_thread::get_id())\n+\t\t\t\t\t  % ((_M_expected + 1) >> 1);\n+\n+\tfor (int __round = 0; ; ++__round)\n+\t  {\n+\t    if (__current_expected <= 1)\n+\t\treturn true;\n+\t    size_t const __end_node = ((__current_expected + 1) >> 1),\n+\t\t\t __last_node = __end_node - 1;\n+\t    for ( ; ; ++__current)\n+\t      {\n+\t\tif (__current == __end_node)\n+\t\t  __current = 0;\n+\t\tauto __expect = __old_phase;\n+\t\t__atomic_phase_ref_t __phase(_M_state[__current]\n+\t\t\t\t\t\t.__tickets[__round]);\n+\t\tif (__current == __last_node && (__current_expected & 1))\n+\t\t  {\n+\t\t    if (__phase.compare_exchange_strong(__expect, __full_step,\n+\t\t\t\t\t\t        memory_order_acq_rel))\n+\t\t      break;     // I'm 1 in 1, go to next __round\n+\t\t  }\n+\t\telse if (__phase.compare_exchange_strong(__expect, __half_step,\n+\t\t\t\t\t\t         memory_order_acq_rel))\n+\t\t  {\n+\t\t    return false; // I'm 1 in 2, done with arrival\n+\t\t  }\n+\t\telse if (__expect == __half_step)\n+\t\t  {\n+\t\t    if (__phase.compare_exchange_strong(__expect, __full_step,\n+\t\t\t\t\t\t        memory_order_acq_rel))\n+\t\t      break;    // I'm 2 in 2, go to next __round\n+\t\t  }\n+\t      }\n+\t    __current_expected = __last_node + 1;\n+\t    __current >>= 1;\n+\t  }\n+      }\n+\n+    public:\n+      using arrival_token = __barrier_phase_t;\n+\n+      static constexpr ptrdiff_t\n+      max() noexcept\n+      { return __PTRDIFF_MAX__; }\n+\n+      __tree_barrier(ptrdiff_t __expected, _CompletionF __completion)\n+\t  : _M_expected(__expected), _M_expected_adjustment(0),\n+\t    _M_completion(move(__completion)),\n+\t    _M_phase(static_cast<__barrier_phase_t>(0))\n+      {\n+\tsize_t const __count = (_M_expected + 1) >> 1;\n+\n+\t_M_state = std::make_unique<__state_t[]>(__count);\n+      }\n+\n+      [[nodiscard]] arrival_token\n+      arrive(ptrdiff_t __update)\n+      {\n+\t__atomic_phase_ref_t __phase(_M_phase);\n+\tconst auto __old_phase = __phase.load(memory_order_relaxed);\n+\tconst auto __cur = static_cast<unsigned char>(__old_phase);\n+\tfor(; __update; --__update)\n+\t  {\n+\t    if(_M_arrive(__old_phase))\n+\t      {\n+\t\t_M_completion();\n+\t\t_M_expected += _M_expected_adjustment.load(memory_order_relaxed);\n+\t\t_M_expected_adjustment.store(0, memory_order_relaxed);\n+\t\tauto __new_phase = static_cast<__barrier_phase_t>(__cur + 2);\n+\t\t__phase.store(__new_phase, memory_order_release);\n+\t\t__phase.notify_all();\n+\t      }\n+\t  }\n+\treturn __old_phase;\n+      }\n+\n+      void\n+      wait(arrival_token&& __old_phase) const\n+      {\n+\t__atomic_phase_const_ref_t __phase(_M_phase);\n+\tauto const __test_fn = [=, this]\n+\t  {\n+\t    return __phase.load(memory_order_acquire) != __old_phase;\n+\t  };\n+\tstd::__atomic_wait(&_M_phase, __old_phase, __test_fn);\n+      }\n+\n+      void\n+      arrive_and_drop()\n+      {\n+\t_M_expected_adjustment.fetch_sub(1, memory_order_relaxed);\n+\t(void)arrive(1);\n+      }\n+    };\n+\n+  template<typename _CompletionF = __empty_completion>\n+    class barrier\n+    {\n+      // Note, we may introduce a \"central\" barrier algorithm at some point\n+      // for more space constrained targets\n+      using __algorithm_t = __tree_barrier<_CompletionF>;\n+      __algorithm_t _M_b;\n+\n+    public:\n+      using arrival_token = typename __tree_barrier<_CompletionF>::arrival_token;\n+\n+      static constexpr ptrdiff_t\n+      max() noexcept\n+      { return __algorithm_t::max(); }\n+\n+      explicit barrier(ptrdiff_t __count,\n+\t\t       _CompletionF __completion = _CompletionF())\n+\t  : _M_b(__count, std::move(__completion))\n+      { }\n+\n+      barrier(barrier const&) = delete;\n+      barrier& operator=(barrier const&) = delete;\n+\n+      [[nodiscard]] arrival_token\n+      arrive(ptrdiff_t __update = 1)\n+      { return _M_b.arrive(__update); }\n+\n+      void\n+      wait(arrival_token&& __phase) const\n+      { _M_b.wait(std::move(__phase)); }\n+\n+      void\n+      arrive_and_wait()\n+      { wait(arrive()); }\n+\n+      void\n+      arrive_and_drop()\n+      { _M_b.arrive_and_drop(); }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // __cpp_lib_atomic_wait && __cpp_aligned_new\n+#endif // __cplusplus > 201703L\n+#endif // _GLIBCXX_BARRIER"}, {"sha": "9516558d8b45ae91801d4cf0745f4320ddbf6554", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -199,6 +199,9 @@\n #define __cpp_lib_assume_aligned 201811L\n #if defined _GLIBCXX_HAS_GTHREADS || defined _GLIBCXX_HAVE_LINUX_FUTEX\n # define __cpp_lib_atomic_wait 201907L\n+# if __cpp_aligned_new\n+# define __cpp_lib_barrier 201907L\n+#endif\n #endif\n #define __cpp_lib_bind_front 201907L\n #if __has_builtin(__builtin_bit_cast)"}, {"sha": "4c15deb1398b39ea414caa5da848ad0af988ba98", "filename": "libstdc++-v3/testsuite/30_threads/barrier/1.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F1.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-require-effective-target gthreads }\n+\n+#include <barrier>\n+\n+#ifndef __cpp_lib_barrier\n+# error \"Feature-test macro for barrier missing in <barrier>\"\n+#elif __cpp_lib_barrier != 201907L\n+# error \"Feature-test macro for barrier has wrong value in <barrier>\"\n+#endif\n+\n+static_assert(std::barrier<>::max() > 0);"}, {"sha": "0fac1ef3f3ce433f0ed32ce039f6b34f5425a7f1", "filename": "libstdc++-v3/testsuite/30_threads/barrier/2.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2F2.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-require-effective-target gthreads }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_barrier\n+# error \"Feature-test macro for barrier missing in <version>\"\n+#elif __cpp_lib_barrier != 201907L\n+# error \"Feature-test macro for barrier has wrong value in <version>\"\n+#endif"}, {"sha": "6e64e378cb005873b09d55cca8042b0d90c11e5a", "filename": "libstdc++-v3/testsuite/30_threads/barrier/arrive.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-gthreads \"\" }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This test is based on libcxx/test/std/thread/thread.barrier/arrive.pass.cpp\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include <barrier>\n+#include <thread>\n+\n+int main(int, char**)\n+{\n+  std::barrier<> b(2);\n+\n+  auto tok = b.arrive();\n+  std::thread t([&](){\n+    (void)b.arrive();\n+  });\n+  b.wait(std::move(tok));\n+  t.join();\n+\n+  auto tok2 = b.arrive(2);\n+  b.wait(std::move(tok2));\n+}"}, {"sha": "55f40e1706242d688c2316ce32f02a2404e3f1d1", "filename": "libstdc++-v3/testsuite/30_threads/barrier/arrive_and_drop.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_drop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_drop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_drop.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-gthreads \"\" }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This test is based on libcxx/test/std/thread/thread.barrier/arrive_and_drop.pass.cpp\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include <barrier>\n+#include <thread>\n+\n+int main(int, char**)\n+{\n+  std::barrier<> b(2);\n+\n+  std::thread t([&](){\n+    b.arrive_and_drop();\n+  });\n+\n+  b.arrive_and_wait();\n+  b.arrive_and_wait();\n+  t.join();\n+}"}, {"sha": "2a3a69ae3c06f56a5beff1b1b8fe65fcfc30fd01", "filename": "libstdc++-v3/testsuite/30_threads/barrier/arrive_and_wait.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_wait.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_wait.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Farrive_and_wait.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-gthreads \"\" }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This test is based on libcxx/test/std/thread/thread.barrier/arrive_and_wait.pass.cpp\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include <barrier>\n+#include <thread>\n+\n+int main(int, char**)\n+{\n+  std::barrier<> b(2);\n+\n+  std::thread t([&](){\n+    for(int i = 0; i < 10; ++i)\n+      b.arrive_and_wait();\n+  });\n+  for(int i = 0; i < 10; ++i)\n+    b.arrive_and_wait();\n+  t.join();\n+}"}, {"sha": "ef6d2c3eac639685e79a9806593f62e36360564a", "filename": "libstdc++-v3/testsuite/30_threads/barrier/completion.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Fcompletion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c3f201be582553f9e3506536aa406bbd7ee71c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Fcompletion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fbarrier%2Fcompletion.cc?ref=b7c3f201be582553f9e3506536aa406bbd7ee71c", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-gthreads \"\" }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This test is based on libcxx/test/std/thread/thread.barrier/completion.pass.cpp\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include <barrier>\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n+\n+int main(int, char**)\n+{\n+  int x = 0;\n+  auto comp = [&] { x += 1; };\n+  std::barrier<decltype(comp)> b(2, comp);\n+\n+  std::thread t([&](){\n+      for(int i = 0; i < 10; ++i)\n+\tb.arrive_and_wait();\n+  });\n+\n+  for(int i = 0; i < 10; ++i)\n+    b.arrive_and_wait();\n+\n+  VERIFY( x == 10 );\n+  t.join();\n+}"}]}