{"sha": "e4057a3920490abb69bb22237ebe380ac4fd64f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwNTdhMzkyMDQ5MGFiYjY5YmIyMjIzN2ViZTM4MGFjNGZkNjRmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:25:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:25:39Z"}, "message": "[34/46] Alter interface to vect_get_vec_def_for_stmt_copy\n\nThis patch makes vect_get_vec_def_for_stmt_copy take a vec_info\nrather than a vect_def_type.  If the vector operand passed in is\ndefined in the vectorised region, we should look for copies in\nthe normal way.  If it's defined in an external statement\n(such as by vect_init_vector_1) we should just use the original value.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_get_vec_defs_for_stmt_copy)\n\t(vect_get_vec_def_for_stmt_copy): Take a vec_info rather than\n\ta vect_def_type for the first argument.\n\t* tree-vect-stmts.c (vect_get_vec_defs_for_stmt_copy): Likewise.\n\t(vect_get_vec_def_for_stmt_copy): Likewise.  Return the original\n\toperand if it isn't defined by a vectorized statement.\n\t(vect_build_gather_load_calls): Remove the mask_dt argument and\n\tupdate calls to vect_get_vec_def_for_stmt_copy.\n\t(vectorizable_bswap): Likewise the dt argument.\n\t(vectorizable_call): Update calls to vectorizable_bswap and\n\tvect_get_vec_def_for_stmt_copy.\n\t(vectorizable_simd_clone_call, vectorizable_assignment)\n\t(vectorizable_shift, vectorizable_operation, vectorizable_condition)\n\t(vectorizable_comparison): Update calls to\n\tvect_get_vec_def_for_stmt_copy.\n\t(vectorizable_store): Likewise.  Remove now-unnecessary calls to\n\tvect_is_simple_use.\n\t(vect_get_loop_based_defs): Remove dt argument and update call\n\tto vect_get_vec_def_for_stmt_copy.\n\t(vectorizable_conversion): Update calls to vect_get_loop_based_defs\n\tand vect_get_vec_def_for_stmt_copy.\n\t(vectorizable_load): Update calls to vect_build_gather_load_calls\n\tand vect_get_vec_def_for_stmt_copy.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction)\n\t(vectorizable_reduction, vectorizable_live_operation): Update calls\n\tto vect_get_vec_def_for_stmt_copy.\n\nFrom-SVN: r263149", "tree": {"sha": "213309e3bfefb1678e2bbcfb8b29aa4e7ef52580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/213309e3bfefb1678e2bbcfb8b29aa4e7ef52580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4057a3920490abb69bb22237ebe380ac4fd64f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4057a3920490abb69bb22237ebe380ac4fd64f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4057a3920490abb69bb22237ebe380ac4fd64f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4057a3920490abb69bb22237ebe380ac4fd64f5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d7609678843a0711cf77b5530149658c3997a906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7609678843a0711cf77b5530149658c3997a906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7609678843a0711cf77b5530149658c3997a906"}], "stats": {"total": 194, "additions": 104, "deletions": 90}, "files": [{"sha": "a6d947d4910db85db6e9c46b898fbe64e2659a8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4057a3920490abb69bb22237ebe380ac4fd64f5", "patch": "@@ -1,3 +1,32 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_get_vec_defs_for_stmt_copy)\n+\t(vect_get_vec_def_for_stmt_copy): Take a vec_info rather than\n+\ta vect_def_type for the first argument.\n+\t* tree-vect-stmts.c (vect_get_vec_defs_for_stmt_copy): Likewise.\n+\t(vect_get_vec_def_for_stmt_copy): Likewise.  Return the original\n+\toperand if it isn't defined by a vectorized statement.\n+\t(vect_build_gather_load_calls): Remove the mask_dt argument and\n+\tupdate calls to vect_get_vec_def_for_stmt_copy.\n+\t(vectorizable_bswap): Likewise the dt argument.\n+\t(vectorizable_call): Update calls to vectorizable_bswap and\n+\tvect_get_vec_def_for_stmt_copy.\n+\t(vectorizable_simd_clone_call, vectorizable_assignment)\n+\t(vectorizable_shift, vectorizable_operation, vectorizable_condition)\n+\t(vectorizable_comparison): Update calls to\n+\tvect_get_vec_def_for_stmt_copy.\n+\t(vectorizable_store): Likewise.  Remove now-unnecessary calls to\n+\tvect_is_simple_use.\n+\t(vect_get_loop_based_defs): Remove dt argument and update call\n+\tto vect_get_vec_def_for_stmt_copy.\n+\t(vectorizable_conversion): Update calls to vect_get_loop_based_defs\n+\tand vect_get_vec_def_for_stmt_copy.\n+\t(vectorizable_load): Update calls to vect_build_gather_load_calls\n+\tand vect_get_vec_def_for_stmt_copy.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction)\n+\t(vectorizable_reduction, vectorizable_live_operation): Update calls\n+\tto vect_get_vec_def_for_stmt_copy.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-data-refs.c (vect_record_base_alignment): Replace vec_info"}, {"sha": "553916a837745ca3951c277313f3db9abe36791c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e4057a3920490abb69bb22237ebe380ac4fd64f5", "patch": "@@ -4421,7 +4421,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n   auto_vec<stmt_vec_info> inner_phis;\n-  enum vect_def_type dt = vect_unknown_def_type;\n   int j, i;\n   auto_vec<tree> scalar_results;\n   unsigned int group_size = 1, k, ratio;\n@@ -4528,8 +4527,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n \t      if (nested_in_vect_loop)\n \t\tvec_init_def\n-\t\t  = vect_get_vec_def_for_stmt_copy (initial_def_dt,\n-\t\t\t\t\t\t    vec_init_def);\n+\t\t  = vect_get_vec_def_for_stmt_copy (loop_vinfo, vec_init_def);\n \t    }\n \n \t  /* Set the loop-entry arg of the reduction-phi.  */\n@@ -4556,7 +4554,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n           /* Set the loop-latch arg for the reduction-phi.  */\n           if (j > 0)\n-            def = vect_get_vec_def_for_stmt_copy (vect_unknown_def_type, def);\n+\t    def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n \n \t  add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n@@ -4697,7 +4695,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n             new_phis.quick_push (phi);\n           else\n \t    {\n-\t      def = vect_get_vec_def_for_stmt_copy (dt, def);\n+\t      def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n \t      STMT_VINFO_RELATED_STMT (prev_phi_info) = phi_info;\n \t    }\n \n@@ -7111,19 +7109,22 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\tvec_oprnds0[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t      else\n \t\tvec_oprnds0[0]\n-\t\t  = vect_get_vec_def_for_stmt_copy (dts[0], vec_oprnds0[0]);\n+\t\t  = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t    vec_oprnds0[0]);\n \t      if (single_defuse_cycle && reduc_index == 1)\n \t\tvec_oprnds1[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t      else\n \t\tvec_oprnds1[0]\n-\t\t  = vect_get_vec_def_for_stmt_copy (dts[1], vec_oprnds1[0]);\n+\t\t  = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t    vec_oprnds1[0]);\n \t      if (op_type == ternary_op)\n \t\t{\n \t\t  if (single_defuse_cycle && reduc_index == 2)\n \t\t    vec_oprnds2[0] = gimple_get_lhs (new_stmt_info->stmt);\n \t\t  else\n \t\t    vec_oprnds2[0] \n-\t\t      = vect_get_vec_def_for_stmt_copy (dts[2], vec_oprnds2[0]);\n+\t\t      = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t\tvec_oprnds2[0]);\n \t\t}\n             }\n         }\n@@ -7945,8 +7946,7 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n \n       /* For multiple copies, get the last copy.  */\n       for (int i = 1; i < ncopies; ++i)\n-\tvec_lhs = vect_get_vec_def_for_stmt_copy (vect_unknown_def_type,\n-\t\t\t\t\t\t  vec_lhs);\n+\tvec_lhs = vect_get_vec_def_for_stmt_copy (loop_vinfo, vec_lhs);\n \n       /* Get the last lane in the vector.  */\n       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);"}, {"sha": "2a513355d64a675dc123d9c27aa2a8610e2563a5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 63, "deletions": 78, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e4057a3920490abb69bb22237ebe380ac4fd64f5", "patch": "@@ -1580,8 +1580,7 @@ vect_get_vec_def_for_operand (tree op, stmt_vec_info stmt_vinfo, tree vectype)\n    created in case the vectorized result cannot fit in one vector, and several\n    copies of the vector-stmt are required.  In this case the vector-def is\n    retrieved from the vector stmt recorded in the STMT_VINFO_RELATED_STMT field\n-   of the stmt that defines VEC_OPRND.\n-   DT is the type of the vector def VEC_OPRND.\n+   of the stmt that defines VEC_OPRND.  VINFO describes the vectorization.\n \n    Context:\n         In case the vectorization factor (VF) is bigger than the number\n@@ -1625,29 +1624,24 @@ vect_get_vec_def_for_operand (tree op, stmt_vec_info stmt_vinfo, tree vectype)\n    STMT_VINFO_RELATED_STMT field of 'VS1.0' we obtain the next copy - 'VS1.1',\n    and return its def ('vx.1').\n    Overall, to create the above sequence this function will be called 3 times:\n-        vx.1 = vect_get_vec_def_for_stmt_copy (dt, vx.0);\n-        vx.2 = vect_get_vec_def_for_stmt_copy (dt, vx.1);\n-        vx.3 = vect_get_vec_def_for_stmt_copy (dt, vx.2);  */\n+\tvx.1 = vect_get_vec_def_for_stmt_copy (vinfo, vx.0);\n+\tvx.2 = vect_get_vec_def_for_stmt_copy (vinfo, vx.1);\n+\tvx.3 = vect_get_vec_def_for_stmt_copy (vinfo, vx.2);  */\n \n tree\n-vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n+vect_get_vec_def_for_stmt_copy (vec_info *vinfo, tree vec_oprnd)\n {\n-  gimple *vec_stmt_for_operand;\n-  stmt_vec_info def_stmt_info;\n-\n-  /* Do nothing; can reuse same def.  */\n-  if (dt == vect_external_def || dt == vect_constant_def )\n+  stmt_vec_info def_stmt_info = vinfo->lookup_def (vec_oprnd);\n+  if (!def_stmt_info)\n+    /* Do nothing; can reuse same def.  */\n     return vec_oprnd;\n \n-  vec_stmt_for_operand = SSA_NAME_DEF_STMT (vec_oprnd);\n-  def_stmt_info = vinfo_for_stmt (vec_stmt_for_operand);\n+  def_stmt_info = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (def_stmt_info);\n-  vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n-  gcc_assert (vec_stmt_for_operand);\n-  if (gimple_code (vec_stmt_for_operand) == GIMPLE_PHI)\n-    vec_oprnd = PHI_RESULT (vec_stmt_for_operand);\n+  if (gphi *phi = dyn_cast <gphi *> (def_stmt_info->stmt))\n+    vec_oprnd = PHI_RESULT (phi);\n   else\n-    vec_oprnd = gimple_get_lhs (vec_stmt_for_operand);\n+    vec_oprnd = gimple_get_lhs (def_stmt_info->stmt);\n   return vec_oprnd;\n }\n \n@@ -1656,19 +1650,19 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n    stmt.  See vect_get_vec_def_for_stmt_copy () for details.  */\n \n void\n-vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n+vect_get_vec_defs_for_stmt_copy (vec_info *vinfo,\n \t\t\t\t vec<tree> *vec_oprnds0,\n \t\t\t\t vec<tree> *vec_oprnds1)\n {\n   tree vec_oprnd = vec_oprnds0->pop ();\n \n-  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd);\n+  vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd);\n   vec_oprnds0->quick_push (vec_oprnd);\n \n   if (vec_oprnds1 && vec_oprnds1->length ())\n     {\n       vec_oprnd = vec_oprnds1->pop ();\n-      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd);\n+      vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd);\n       vec_oprnds1->quick_push (vec_oprnd);\n     }\n }\n@@ -2662,7 +2656,7 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \t\t\t      gimple_stmt_iterator *gsi,\n \t\t\t      stmt_vec_info *vec_stmt,\n \t\t\t      gather_scatter_info *gs_info,\n-\t\t\t      tree mask, vect_def_type mask_dt)\n+\t\t\t      tree mask)\n {\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -2767,8 +2761,8 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \top = vec_oprnd0\n \t  = vect_get_vec_def_for_operand (gs_info->offset, stmt_info);\n       else\n-\top = vec_oprnd0\n-\t  = vect_get_vec_def_for_stmt_copy (gs_info->offset_dt, vec_oprnd0);\n+\top = vec_oprnd0 = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t\t  vec_oprnd0);\n \n       if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n \t{\n@@ -2791,7 +2785,8 @@ vect_build_gather_load_calls (stmt_vec_info stmt_info,\n \t      if (j == 0)\n \t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt_info);\n \t      else\n-\t\tvec_mask = vect_get_vec_def_for_stmt_copy (mask_dt, vec_mask);\n+\t\tvec_mask = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t\t   vec_mask);\n \n \t      mask_op = vec_mask;\n \t      if (!useless_type_conversion_p (masktype, TREE_TYPE (vec_mask)))\n@@ -2951,11 +2946,11 @@ vect_get_data_ptr_increment (data_reference *dr, tree aggr_type,\n static bool\n vectorizable_bswap (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n-\t\t    tree vectype_in, enum vect_def_type *dt,\n-\t\t    stmt_vector_for_cost *cost_vec)\n+\t\t    tree vectype_in, stmt_vector_for_cost *cost_vec)\n {\n   tree op, vectype;\n   gcall *stmt = as_a <gcall *> (stmt_info->stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   unsigned ncopies;\n   unsigned HOST_WIDE_INT nunits, num_bytes;\n@@ -3021,7 +3016,7 @@ vectorizable_bswap (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (j == 0)\n \tvect_get_vec_defs (op, NULL, stmt_info, &vec_oprnds, NULL, slp_node);\n       else\n-        vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n+\tvect_get_vec_defs_for_stmt_copy (vinfo, &vec_oprnds, NULL);\n \n       /* Arguments are ready. create the new vector stmt.  */\n       unsigned i;\n@@ -3301,7 +3296,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t   || gimple_call_builtin_p (stmt, BUILT_IN_BSWAP32)\n \t\t   || gimple_call_builtin_p (stmt, BUILT_IN_BSWAP64)))\n \treturn vectorizable_bswap (stmt_info, gsi, vec_stmt, slp_node,\n-\t\t\t\t   vectype_in, dt, cost_vec);\n+\t\t\t\t   vectype_in, cost_vec);\n       else\n \t{\n \t  if (dump_enabled_p ())\n@@ -3450,7 +3445,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  = vect_get_vec_def_for_operand (op, stmt_info);\n \t      else\n \t\tvec_oprnd0\n-\t\t  = vect_get_vec_def_for_stmt_copy (dt[i], orig_vargs[i]);\n+\t\t  = vect_get_vec_def_for_stmt_copy (vinfo, orig_vargs[i]);\n \n \t      orig_vargs[i] = vargs[i] = vec_oprnd0;\n \t    }\n@@ -3582,16 +3577,16 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  vec_oprnd0\n \t\t    = vect_get_vec_def_for_operand (op, stmt_info);\n \t\t  vec_oprnd1\n-\t\t    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd0);\n+\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n \t\t}\n \t      else\n \t\t{\n \t\t  vec_oprnd1 = gimple_call_arg (new_stmt_info->stmt,\n \t\t\t\t\t\t2 * i + 1);\n \t\t  vec_oprnd0\n-\t\t    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd1);\n+\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n \t\t  vec_oprnd1\n-\t\t    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd0);\n+\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n \t\t}\n \n \t      vargs.quick_push (vec_oprnd0);\n@@ -4103,7 +4098,7 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n \t\t\t  vec_oprnd0 = arginfo[i].op;\n \t\t\t  if ((m & (k - 1)) == 0)\n \t\t\t    vec_oprnd0\n-\t\t\t      = vect_get_vec_def_for_stmt_copy (arginfo[i].dt,\n+\t\t\t      = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t\tvec_oprnd0);\n \t\t\t}\n \t\t      arginfo[i].op = vec_oprnd0;\n@@ -4134,7 +4129,7 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n \t\t\t      = vect_get_vec_def_for_operand (op, stmt_info);\n \t\t\t  else\n \t\t\t    vec_oprnd0\n-\t\t\t      = vect_get_vec_def_for_stmt_copy (arginfo[i].dt,\n+\t\t\t      = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t\targinfo[i].op);\n \t\t\t  arginfo[i].op = vec_oprnd0;\n \t\t\t  if (k == 1)\n@@ -4440,9 +4435,9 @@ vect_gen_widened_results_half (enum tree_code code,\n \n static void\n vect_get_loop_based_defs (tree *oprnd, stmt_vec_info stmt_info,\n-\t\t\t  enum vect_def_type dt, vec<tree> *vec_oprnds,\n-\t\t\t  int multi_step_cvt)\n+\t\t\t  vec<tree> *vec_oprnds, int multi_step_cvt)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree vec_oprnd;\n \n   /* Get first vector operand.  */\n@@ -4451,20 +4446,20 @@ vect_get_loop_based_defs (tree *oprnd, stmt_vec_info stmt_info,\n   if (TREE_CODE (TREE_TYPE (*oprnd)) != VECTOR_TYPE)\n     vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt_info);\n   else\n-    vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, *oprnd);\n+    vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo, *oprnd);\n \n   vec_oprnds->quick_push (vec_oprnd);\n \n   /* Get second vector operand.  */\n-  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+  vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd);\n   vec_oprnds->quick_push (vec_oprnd);\n \n   *oprnd = vec_oprnd;\n \n   /* For conversion in multiple steps, continue to get operands\n      recursively.  */\n   if (multi_step_cvt)\n-    vect_get_loop_based_defs (oprnd, stmt_info, dt, vec_oprnds,\n+    vect_get_loop_based_defs (oprnd, stmt_info, vec_oprnds,\n \t\t\t      multi_step_cvt - 1);\n }\n \n@@ -4983,7 +4978,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    vect_get_vec_defs (op0, NULL, stmt_info, &vec_oprnds0,\n \t\t\t       NULL, slp_node);\n \t  else\n-\t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n+\t    vect_get_vec_defs_for_stmt_copy (vinfo, &vec_oprnds0, NULL);\n \n \t  FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t    {\n@@ -5070,15 +5065,15 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    {\n-\t      vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+\t      vec_oprnd0 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n \t      vec_oprnds0.truncate (0);\n \t      vec_oprnds0.quick_push (vec_oprnd0);\n \t      if (op_type == binary_op)\n \t\t{\n \t\t  if (code == WIDEN_LSHIFT_EXPR)\n \t\t    vec_oprnd1 = op1;\n \t\t  else\n-\t\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1],\n+\t\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t\t vec_oprnd1);\n \t\t  vec_oprnds1.truncate (0);\n \t\t  vec_oprnds1.quick_push (vec_oprnd1);\n@@ -5160,8 +5155,7 @@ vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  else\n \t    {\n \t      vec_oprnds0.truncate (0);\n-\t      vect_get_loop_based_defs (&last_oprnd, stmt_info, dt[0],\n-\t\t\t\t\t&vec_oprnds0,\n+\t      vect_get_loop_based_defs (&last_oprnd, stmt_info, &vec_oprnds0,\n \t\t\t\t\tvect_pow2 (multi_step_cvt) - 1);\n \t    }\n \n@@ -5338,7 +5332,7 @@ vectorizable_assignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (j == 0)\n \tvect_get_vec_defs (op, NULL, stmt_info, &vec_oprnds, NULL, slp_node);\n       else\n-        vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n+\tvect_get_vec_defs_for_stmt_copy (vinfo, &vec_oprnds, NULL);\n \n       /* Arguments are ready. create the new vector stmt.  */\n       stmt_vec_info new_stmt_info = NULL;\n@@ -5742,7 +5736,7 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t       slp_node);\n         }\n       else\n-        vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n+\tvect_get_vec_defs_for_stmt_copy (vinfo, &vec_oprnds0, &vec_oprnds1);\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n       stmt_vec_info new_stmt_info = NULL;\n@@ -6120,11 +6114,11 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t}\n       else\n \t{\n-\t  vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n+\t  vect_get_vec_defs_for_stmt_copy (vinfo, &vec_oprnds0, &vec_oprnds1);\n \t  if (op_type == ternary_op)\n \t    {\n \t      tree vec_oprnd = vec_oprnds2.pop ();\n-\t      vec_oprnds2.quick_push (vect_get_vec_def_for_stmt_copy (dt[2],\n+\t      vec_oprnds2.quick_push (vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t           vec_oprnd));\n \t    }\n \t}\n@@ -6533,7 +6527,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      if (modifier == WIDEN)\n \t\t{\n \t\t  src = vec_oprnd1\n-\t\t    = vect_get_vec_def_for_stmt_copy (rhs_dt, vec_oprnd1);\n+\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n \t\t  op = permute_vec_elements (vec_oprnd0, vec_oprnd0, perm_mask,\n \t\t\t\t\t     stmt_info, gsi);\n \t\t}\n@@ -6542,19 +6536,17 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  src = permute_vec_elements (vec_oprnd1, vec_oprnd1, perm_mask,\n \t\t\t\t\t      stmt_info, gsi);\n \t\t  op = vec_oprnd0\n-\t\t    = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n-\t\t\t\t\t\t      vec_oprnd0);\n+\t\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n \t\t}\n \t      else\n \t\tgcc_unreachable ();\n \t    }\n \t  else\n \t    {\n \t      src = vec_oprnd1\n-\t\t= vect_get_vec_def_for_stmt_copy (rhs_dt, vec_oprnd1);\n+\t\t= vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n \t      op = vec_oprnd0\n-\t\t= vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n-\t\t\t\t\t\t  vec_oprnd0);\n+\t\t= vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd0);\n \t    }\n \n \t  if (!useless_type_conversion_p (srctype, TREE_TYPE (src)))\n@@ -6811,11 +6803,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t  if (slp)\n \t\t    vec_oprnd = vec_oprnds[j];\n \t\t  else\n-\t\t    {\n-\t\t      vect_is_simple_use (op, vinfo, &rhs_dt);\n-\t\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (rhs_dt,\n-\t\t\t\t\t\t\t\t  vec_oprnd);\n-\t\t    }\n+\t\t    vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo,\n+\t\t\t\t\t\t\t\tvec_oprnd);\n \t\t}\n \t      /* Pun the vector to extract from if necessary.  */\n \t      if (lvectype != vectype)\n@@ -7060,19 +7049,17 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = oprnds[i];\n-\t      vect_is_simple_use (op, vinfo, &rhs_dt);\n-\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (rhs_dt, op);\n+\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (vinfo, op);\n \t      dr_chain[i] = vec_oprnd;\n \t      oprnds[i] = vec_oprnd;\n \t    }\n \t  if (mask)\n-\t    vec_mask = vect_get_vec_def_for_stmt_copy (mask_dt, vec_mask);\n+\t    vec_mask = vect_get_vec_def_for_stmt_copy (vinfo, vec_mask);\n \t  if (dataref_offset)\n \t    dataref_offset\n \t      = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-\t    vec_offset = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n-\t\t\t\t\t\t\t vec_offset);\n+\t    vec_offset = vect_get_vec_def_for_stmt_copy (vinfo, vec_offset);\n \t  else\n \t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t   stmt_info, bump);\n@@ -7680,8 +7667,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   if (memory_access_type == VMAT_GATHER_SCATTER && gs_info.decl)\n     {\n-      vect_build_gather_load_calls (stmt_info, gsi, vec_stmt, &gs_info, mask,\n-\t\t\t\t    mask_dt);\n+      vect_build_gather_load_calls (stmt_info, gsi, vec_stmt, &gs_info, mask);\n       return true;\n     }\n \n@@ -8233,13 +8219,12 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset,\n \t\t\t\t\t      bump);\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-\t    vec_offset = vect_get_vec_def_for_stmt_copy (gs_info.offset_dt,\n-\t\t\t\t\t\t\t vec_offset);\n+\t    vec_offset = vect_get_vec_def_for_stmt_copy (vinfo, vec_offset);\n \t  else\n \t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t   stmt_info, bump);\n \t  if (mask)\n-\t    vec_mask = vect_get_vec_def_for_stmt_copy (mask_dt, vec_mask);\n+\t    vec_mask = vect_get_vec_def_for_stmt_copy (vinfo, vec_mask);\n \t}\n \n       if (grouped_load || slp_perm)\n@@ -8733,6 +8718,7 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\tint reduc_index, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n   tree cond_expr, cond_expr0 = NULL_TREE, cond_expr1 = NULL_TREE;\n@@ -8994,16 +8980,14 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       else\n \t{\n \t  vec_cond_lhs\n-\t    = vect_get_vec_def_for_stmt_copy (dts[0],\n-\t\t\t\t\t      vec_oprnds0.pop ());\n+\t    = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnds0.pop ());\n \t  if (!masked)\n \t    vec_cond_rhs\n-\t      = vect_get_vec_def_for_stmt_copy (dts[1],\n-\t\t\t\t\t\tvec_oprnds1.pop ());\n+\t      = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnds1.pop ());\n \n-\t  vec_then_clause = vect_get_vec_def_for_stmt_copy (dts[2],\n+\t  vec_then_clause = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t    vec_oprnds2.pop ());\n-\t  vec_else_clause = vect_get_vec_def_for_stmt_copy (dts[3],\n+\t  vec_else_clause = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t\t    vec_oprnds3.pop ());\n \t}\n \n@@ -9135,6 +9119,7 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t stmt_vec_info *vec_stmt, tree reduc_def,\n \t\t\t slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree lhs, rhs1, rhs2;\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -9331,9 +9316,9 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t}\n       else\n \t{\n-\t  vec_rhs1 = vect_get_vec_def_for_stmt_copy (dts[0],\n+\t  vec_rhs1 = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t     vec_oprnds0.pop ());\n-\t  vec_rhs2 = vect_get_vec_def_for_stmt_copy (dts[1],\n+\t  vec_rhs2 = vect_get_vec_def_for_stmt_copy (vinfo,\n \t\t\t\t\t\t     vec_oprnds1.pop ());\n \t}\n "}, {"sha": "37f8b87e110daf8b2d9fd921bec74a3142888ccb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4057a3920490abb69bb22237ebe380ac4fd64f5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e4057a3920490abb69bb22237ebe380ac4fd64f5", "patch": "@@ -1514,11 +1514,11 @@ extern tree vect_get_vec_def_for_operand_1 (stmt_vec_info, enum vect_def_type);\n extern tree vect_get_vec_def_for_operand (tree, stmt_vec_info, tree = NULL);\n extern void vect_get_vec_defs (tree, tree, stmt_vec_info, vec<tree> *,\n \t\t\t       vec<tree> *, slp_tree);\n-extern void vect_get_vec_defs_for_stmt_copy (enum vect_def_type *,\n+extern void vect_get_vec_defs_for_stmt_copy (vec_info *,\n \t\t\t\t\t     vec<tree> *, vec<tree> *);\n extern tree vect_init_vector (stmt_vec_info, tree, tree,\n                               gimple_stmt_iterator *);\n-extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n+extern tree vect_get_vec_def_for_stmt_copy (vec_info *, tree);\n extern bool vect_transform_stmt (stmt_vec_info, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (stmt_vec_info);"}]}