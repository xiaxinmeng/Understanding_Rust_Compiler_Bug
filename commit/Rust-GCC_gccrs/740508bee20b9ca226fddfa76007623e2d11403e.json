{"sha": "740508bee20b9ca226fddfa76007623e2d11403e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQwNTA4YmVlMjBiOWNhMjI2ZmRkZmE3NjAwNzYyM2UyZDExNDAzZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-05-23T23:08:41Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-05-23T23:08:41Z"}, "message": "tuple: Replace int -> size_t throughout per DR 775.\n\n2008-05-23  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/tuple: Replace int -> size_t throughout per DR 775. \n\t* include/tr1_impl/array: Likewise.\n\t* include/tr1_impl/utility: Likewise.\n\t* doc/xml/manual/intro.xml: Add an entry for DR 775.\n\nFrom-SVN: r135834", "tree": {"sha": "54a74c28709b13b024d0283aae0eacdf82f73fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a74c28709b13b024d0283aae0eacdf82f73fe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/740508bee20b9ca226fddfa76007623e2d11403e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740508bee20b9ca226fddfa76007623e2d11403e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740508bee20b9ca226fddfa76007623e2d11403e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740508bee20b9ca226fddfa76007623e2d11403e/comments", "author": null, "committer": null, "parents": [{"sha": "fbcfcb3cc3c93d7af538b220b3d57e3254ac6651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbcfcb3cc3c93d7af538b220b3d57e3254ac6651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbcfcb3cc3c93d7af538b220b3d57e3254ac6651"}], "stats": {"total": 168, "additions": 117, "deletions": 51}, "files": [{"sha": "ca2eb74234a013489f64e9b0ed2408bc6bed3fd9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=740508bee20b9ca226fddfa76007623e2d11403e", "patch": "@@ -1,3 +1,10 @@\n+2008-05-23  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/tuple: Replace int -> size_t throughout per DR 775. \n+\t* include/tr1_impl/array: Likewise.\n+\t* include/tr1_impl/utility: Likewise.\n+\t* doc/xml/manual/intro.xml: Add an entry for DR 775.\n+\n 2008-05-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* doc/xml/manual/intro.xml: Adjust links to ISO documents."}, {"sha": "0287c9e55628b9b4ca8092aaae570f4d3cccff61", "filename": "libstdc++-v3/doc/xml/manual/intro.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml?ref=740508bee20b9ca226fddfa76007623e2d11403e", "patch": "@@ -635,6 +635,12 @@\n     <listitem><para>In C++0x mode, add at() and at() const.\n     </para></listitem></varlistentry>\n \n+    <varlistentry><term><ulink url=\"../ext/lwg-active.html#775\">775</ulink>:\n+        <emphasis>Tuple indexing should be unsigned?</emphasis>\n+    </term>\n+    <listitem><para>Implement the int -> size_t replacements.\n+    </para></listitem></varlistentry>\n+\n     <varlistentry><term><ulink url=\"../ext/lwg-active.html#778\">778</ulink>:\n         <emphasis>std::bitset does not have any constructor taking a string literal</emphasis>\n     </term>"}, {"sha": "83a81ee497aa1b049abb4b982aa4ae94c04454b5", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=740508bee20b9ca226fddfa76007623e2d11403e", "patch": "@@ -62,10 +62,10 @@ namespace std\n     struct __add_ref<_Tp&>\n     { typedef _Tp& type; };\n \n-  template<int _Idx, typename _Head, bool _IsEmpty>\n+  template<std::size_t _Idx, typename _Head, bool _IsEmpty>\n     struct _Head_base;\n \n-  template<int _Idx, typename _Head>\n+  template<std::size_t _Idx, typename _Head>\n     struct _Head_base<_Idx, _Head, true>\n     : public _Head\n     {\n@@ -83,7 +83,7 @@ namespace std\n       const _Head& _M_head() const { return *this; }\n     };\n \n-  template<int _Idx, typename _Head>\n+  template<std::size_t _Idx, typename _Head>\n     struct _Head_base<_Idx, _Head, false>\n     {\n       _Head_base()\n@@ -110,22 +110,22 @@ namespace std\n    * point in the hierarchy; we use it to implement a constant-time\n    * get() operation.\n    */\n-  template<int _Idx, typename... _Elements>\n+  template<std::size_t _Idx, typename... _Elements>\n     struct _Tuple_impl; \n \n   /**\n    * Zero-element tuple implementation. This is the basis case for the \n    * inheritance recursion.\n    */\n-  template<int _Idx>\n+  template<std::size_t _Idx>\n     struct _Tuple_impl<_Idx> { };\n \n   /**\n    * Recursive tuple implementation. Here we store the @c Head element\n    * and derive from a @c Tuple_impl containing the remaining elements\n    * (which contains the @c Tail).\n    */\n-  template<int _Idx, typename _Head, typename... _Tail>\n+  template<std::size_t _Idx, typename _Head, typename... _Tail>\n     struct _Tuple_impl<_Idx, _Head, _Tail...>\n     : public _Tuple_impl<_Idx + 1, _Tail...>,\n       private _Head_base<_Idx, _Head, std::is_empty<_Head>::value>\n@@ -372,14 +372,14 @@ namespace std\n \n \n   /// Gives the type of the ith element of a given tuple type.\n-  template<int __i, typename _Tp>\n+  template<std::size_t __i, typename _Tp>\n     struct tuple_element;\n \n   /**\n    * Recursive case for tuple_element: strip off the first element in\n    * the tuple and retrieve the (i-1)th element of the remaining tuple.\n    */\n-  template<int __i, typename _Head, typename... _Tail>\n+  template<std::size_t __i, typename _Head, typename... _Tail>\n     struct tuple_element<__i, tuple<_Head, _Tail...> >\n     : tuple_element<__i - 1, tuple<_Tail...> > { };\n \n@@ -400,61 +400,61 @@ namespace std\n   template<typename... _Elements>\n     struct tuple_size<tuple<_Elements...> >\n     {\n-      static const int value = sizeof...(_Elements);\n+      static const std::size_t value = sizeof...(_Elements);\n     };\n \n   template<typename... _Elements>\n-    const int tuple_size<tuple<_Elements...> >::value;\n+    const std::size_t tuple_size<tuple<_Elements...> >::value;\n \n-  template<int __i, typename _Head, typename... _Tail>\n+  template<std::size_t __i, typename _Head, typename... _Tail>\n     inline typename __add_ref<_Head>::type\n     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)\n     { return __t._M_head(); }\n \n-  template<int __i, typename _Head, typename... _Tail>\n+  template<std::size_t __i, typename _Head, typename... _Tail>\n     inline typename __add_c_ref<_Head>::type\n     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n     { return __t._M_head(); }\n \n   // Return a reference (const reference) to the ith element of a tuple.\n   // Any const or non-const ref elements are returned with their original type.\n-  template<int __i, typename... _Elements>\n+  template<std::size_t __i, typename... _Elements>\n     inline typename __add_ref<\n                       typename tuple_element<__i, tuple<_Elements...> >::type\n                     >::type\n     get(tuple<_Elements...>& __t)\n     { return __get_helper<__i>(__t); }\n \n-  template<int __i, typename... _Elements>\n+  template<std::size_t __i, typename... _Elements>\n     inline typename __add_c_ref<\n                       typename tuple_element<__i, tuple<_Elements...> >::type\n                     >::type\n     get(const tuple<_Elements...>& __t)\n     { return __get_helper<__i>(__t); }\n \n   // This class helps construct the various comparison operations on tuples\n-  template<int __check_equal_size, int __i, int __j,\n+  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,\n \t   typename _Tp, typename _Up>\n     struct __tuple_compare;\n \n-  template<int __i, int __j, typename _Tp, typename _Up>\n+  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>\n     struct __tuple_compare<0, __i, __j, _Tp, _Up>\n     {\n       static bool __eq(const _Tp& __t, const _Up& __u)\n       {\n \treturn (get<__i>(__t) == get<__i>(__u) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n+\t\t__tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));\n       }\n      \n       static bool __less(const _Tp& __t, const _Up& __u)\n       {\n \treturn ((get<__i>(__t) < get<__i>(__u))\n \t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n-\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n+\t\t__tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));\n       }\n     };\n \n-  template<int __i, typename _Tp, typename _Up>\n+  template<std::size_t __i, typename _Tp, typename _Up>\n     struct __tuple_compare<0, __i, __i, _Tp, _Up>\n     {\n       static bool __eq(const _Tp&, const _Up&)\n@@ -520,12 +520,13 @@ namespace std\n       return __result_type(std::forward<_Elements>(__args)...);\n     }\n \n-  template<int...> struct __index_holder { };    \n+  template<std::size_t...> struct __index_holder { };    \n \n-  template<int __i, typename _IdxHolder, typename... _Elements>\n+  template<std::size_t __i, typename _IdxHolder, typename... _Elements>\n     struct __index_holder_impl;\n \n-  template<int __i, int... _Indexes, typename _IdxHolder, typename... _Elements>\n+  template<std::size_t __i, std::size_t... _Indexes, typename _IdxHolder,\n+\t   typename... _Elements>\n     struct __index_holder_impl<__i, __index_holder<_Indexes...>,\n \t\t\t       _IdxHolder, _Elements...> \n     {\n@@ -534,16 +535,16 @@ namespace std\n \t\t\t\t\t   _Elements...>::type type;\n     };\n  \n-  template<int __i, int... _Indexes>\n+  template<std::size_t __i, std::size_t... _Indexes>\n     struct __index_holder_impl<__i, __index_holder<_Indexes...> >\n     { typedef __index_holder<_Indexes...> type; };\n \n   template<typename... _Elements>\n     struct __make_index_holder \n     : __index_holder_impl<0, __index_holder<>, _Elements...> { };\n     \n-  template<typename... _TElements, int... _TIdx,\n-\t   typename... _UElements, int... _UIdx> \n+  template<typename... _TElements, std::size_t... _TIdx,\n+\t   typename... _UElements, std::size_t... _UIdx> \n     inline tuple<_TElements..., _UElements...> \n     __tuple_cat_helper(const tuple<_TElements...>& __t,\n \t\t       const __index_holder<_TIdx...>&,\n@@ -552,8 +553,8 @@ namespace std\n     { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,\n \t\t\t\t\t\t get<_UIdx>(__u)...); }\n \n-  template<typename... _TElements, int... _TIdx,\n-\t   typename... _UElements, int... _UIdx> \n+  template<typename... _TElements, std::size_t... _TIdx,\n+\t   typename... _UElements, std::size_t... _UIdx> \n     inline tuple<_TElements..., _UElements...> \n     __tuple_cat_helper(tuple<_TElements...>&& __t,\n \t\t       const __index_holder<_TIdx...>&, \n@@ -562,8 +563,8 @@ namespace std\n     { return tuple<_TElements..., _UElements...>\n \t(std::move(get<_TIdx>(__t))..., get<_UIdx>(__u)...); }\n \n-  template<typename... _TElements, int... _TIdx,\n-\t   typename... _UElements, int... _UIdx>\n+  template<typename... _TElements, std::size_t... _TIdx,\n+\t   typename... _UElements, std::size_t... _UIdx>\n     inline tuple<_TElements..., _UElements...> \n     __tuple_cat_helper(const tuple<_TElements...>& __t,\n \t\t       const __index_holder<_TIdx...>&, \n@@ -572,8 +573,8 @@ namespace std\n     { return tuple<_TElements..., _UElements...>\n \t(get<_TIdx>(__t)..., std::move(get<_UIdx>(__u))...); }\n \n-  template<typename... _TElements, int... _TIdx,\n-\t   typename... _UElements, int... _UIdx> \n+  template<typename... _TElements, std::size_t... _TIdx,\n+\t   typename... _UElements, std::size_t... _UIdx> \n     inline tuple<_TElements..., _UElements...> \n     __tuple_cat_helper(tuple<_TElements...>&& __t,\n \t\t       const __index_holder<_TIdx...>&, \n@@ -585,7 +586,7 @@ namespace std\n   template<typename... _TElements, typename... _UElements>\n     inline tuple<_TElements..., _UElements...> \n     tuple_cat(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n-    { \n+    {\n       return __tuple_cat_helper(__t, typename\n \t\t\t\t__make_index_holder<_TElements...>::type(),\n \t\t\t\t__u, typename"}, {"sha": "a9047438843cf8a4d6b6db5e6e888b337653ca0e", "filename": "libstdc++-v3/include/tr1_impl/array", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Farray?ref=740508bee20b9ca226fddfa76007623e2d11403e", "patch": "@@ -1,6 +1,6 @@\n // class template array -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -222,26 +222,51 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     class tuple_size;\n \n   /// tuple_element\n-  template<int _Int, typename _Tp> \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, typename _Tp>\n+#else\n+  template<int _Int, typename _Tp>\n+#endif\n     class tuple_element;\n \n   template<typename _Tp, std::size_t _Nm>\n     struct tuple_size<array<_Tp, _Nm> >\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    { static const std::size_t value = _Nm; };\n+#else\n     { static const int value = _Nm; };\n+#endif\n \n   template<typename _Tp, std::size_t _Nm>\n-    const int tuple_size<array<_Tp, _Nm> >::value;\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    const std::size_t\n+#else\n+    const int\n+#endif\n+    tuple_size<array<_Tp, _Nm> >::value;  \n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+#else\n   template<int _Int, typename _Tp, std::size_t _Nm>\n+#endif\n     struct tuple_element<_Int, array<_Tp, _Nm> >\n     { typedef _Tp type; };\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+#else\n   template<int _Int, typename _Tp, std::size_t _Nm>\n+#endif\n     inline _Tp&\n     get(array<_Tp, _Nm>& __arr)\n     { return __arr[_Int]; }\n \n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, typename _Tp, std::size_t _Nm>\n+#else\n   template<int _Int, typename _Tp, std::size_t _Nm>\n+#endif\n     inline const _Tp&\n     get(const array<_Tp, _Nm>& __arr)\n     { return __arr[_Int]; }"}, {"sha": "c70ed9b63cfcc107411d0e4d01535232a29f0b5c", "filename": "libstdc++-v3/include/tr1_impl/utility", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740508bee20b9ca226fddfa76007623e2d11403e/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Futility?ref=740508bee20b9ca226fddfa76007623e2d11403e", "patch": "@@ -1,7 +1,6 @@\n-\n // TR1 utility -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -37,16 +36,32 @@ namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE_TR1\n \n-  template<class _Tp> class tuple_size;\n-  template<int _Int, class _Tp> class tuple_element;\n+  template<class _Tp>\n+    class tuple_size;\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, class _Tp>\n+#else\n+  template<int _Int, class _Tp>\n+#endif\n+    class tuple_element;\n \n    // Various functions which give std::pair a tuple-like interface.\n   template<class _Tp1, class _Tp2>\n     struct tuple_size<std::pair<_Tp1, _Tp2> >\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    { static const std::size_t value = 2; };\n+#else\n     { static const int value = 2; };\n+#endif\n \n   template<class _Tp1, class _Tp2>\n-    const int tuple_size<std::pair<_Tp1, _Tp2> >::value;\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+    const std::size_t\n+#else\n+    const int\n+#endif\n+    tuple_size<std::pair<_Tp1, _Tp2> >::value;\n \n   template<class _Tp1, class _Tp2>\n     struct tuple_element<0, std::pair<_Tp1, _Tp2> >\n@@ -55,9 +70,13 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   template<class _Tp1, class _Tp2>\n     struct tuple_element<1, std::pair<_Tp1, _Tp2> >\n     { typedef _Tp2 type; };\n- \n \n-  template<int _Int> struct __pair_get;\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int>\n+#else\n+  template<int _Int>\n+#endif\n+    struct __pair_get;\n \n   template<>\n     struct __pair_get<0>\n@@ -83,15 +102,23 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       { return __pair.second; }\n     };\n \n-   template<int _Int, class _Tp1, class _Tp2>\n-     inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-     get(std::pair<_Tp1, _Tp2>& __in)\n-     { return __pair_get<_Int>::__get(__in); }\n- \n-   template<int _Int, class _Tp1, class _Tp2>\n-     inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n-     get(const std::pair<_Tp1, _Tp2>& __in)\n-     { return __pair_get<_Int>::__const_get(__in); }\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, class _Tp1, class _Tp2>\n+#else\n+  template<int _Int, class _Tp1, class _Tp2>\n+#endif\n+    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__get(__in); }\n+\n+#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n+  template<std::size_t _Int, class _Tp1, class _Tp2>\n+#else\n+  template<int _Int, class _Tp1, class _Tp2>\n+#endif\n+    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&\n+    get(const std::pair<_Tp1, _Tp2>& __in)\n+    { return __pair_get<_Int>::__const_get(__in); }\n \n _GLIBCXX_END_NAMESPACE_TR1\n }"}]}