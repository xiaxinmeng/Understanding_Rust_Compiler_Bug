{"sha": "649a1a476c573b145a2af341f30755d2c4edf10b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5YTFhNDc2YzU3M2IxNDVhMmFmMzQxZjMwNzU1ZDJjNGVkZjEwYg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-16T13:45:01Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-16T13:45:01Z"}, "message": "i2003-12-16  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/ObjectInputStream.java\n\t(lookupClass): New method.\n\t(currentLoader): New method.\n\t(inputGetObjectStreamClasses): New method.\n\t(assignNewHandle): Documented.\n\t(currentClassLoader): Documented.\n\t* java/io/ObjectStreamClass.java\n\t(setClass): Changed API. Better handling of the imported/exported\n\tfields.\n\t(getSerialPersistentFields): Make it throw previously caught exceptions\n\tso they can handled in setClass.\n\nFrom-SVN: r74693", "tree": {"sha": "889b18b0b1d393d1428a9faac932db2fc5df9564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/889b18b0b1d393d1428a9faac932db2fc5df9564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/649a1a476c573b145a2af341f30755d2c4edf10b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649a1a476c573b145a2af341f30755d2c4edf10b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649a1a476c573b145a2af341f30755d2c4edf10b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649a1a476c573b145a2af341f30755d2c4edf10b/comments", "author": null, "committer": null, "parents": [{"sha": "b1660ae9ea563c14c045d212d3e81db007673afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1660ae9ea563c14c045d212d3e81db007673afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1660ae9ea563c14c045d212d3e81db007673afd"}], "stats": {"total": 237, "additions": 201, "deletions": 36}, "files": [{"sha": "05d0fb8938239081e6760d6d865c600d5f20fbb6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=649a1a476c573b145a2af341f30755d2c4edf10b", "patch": "@@ -1,3 +1,17 @@\n+i2003-12-16  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(lookupClass): New method.\n+\t(currentLoader): New method.\n+\t(inputGetObjectStreamClasses): New method.\n+\t(assignNewHandle): Documented.\n+\t(currentClassLoader): Documented.\n+\t* java/io/ObjectStreamClass.java\n+\t(setClass): Changed API. Better handling of the imported/exported\n+\tfields.\n+\t(getSerialPersistentFields): Make it throw previously caught exceptions\n+\tso they can handled in setClass.\n+\n 2003-12-16 Guilhem Lavaux <guilhem@kaffe.org>\n  \n \t* java/io/ObjectStreamField.java: A few methods were added in prevision"}, {"sha": "974b12df0c2780eac5754b01886203621c166dc4", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 86, "deletions": 14, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=649a1a476c573b145a2af341f30755d2c4edf10b", "patch": "@@ -203,7 +203,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      Class cl = resolveProxyClass(intfs);\n \t      setBlockDataMode(oldmode);\n \t      \n-\t      ObjectStreamClass osc = ObjectStreamClass.lookup(cl);\n+\t      ObjectStreamClass osc = lookupClass(cl);\n \t      assignNewHandle (osc);\n \t      \n \t      if (!is_consumed)\n@@ -332,7 +332,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      int handle = assignNewHandle (obj);\n \t      this.currentObject = obj;\n \t      ObjectStreamClass[] hierarchy =\n-\t\tObjectStreamClass.getObjectStreamClasses (clazz);\n+\t\tinputGetObjectStreamClasses(clazz);\n \t      \n \t      for (int i=0; i < hierarchy.length; i++)\n \t\t{\n@@ -455,8 +455,10 @@ protected ObjectStreamClass readClassDescriptor ()\n \t  new ObjectStreamField (field_name, class_name);\n       }\n \t      \n+    Class clazz = resolveClass(osc);\n     boolean oldmode = setBlockDataMode (true);\n-    osc.setClass (resolveClass (osc));\n+    osc.setClass (clazz, lookupClass(clazz.getSuperclass()));\n+    classLookupTable.put(clazz, osc);\n     setBlockDataMode (oldmode);\n \t      \n     return osc;\n@@ -549,20 +551,79 @@ public void registerValidation (ObjectInputValidation validator,\n    */\n   protected Class resolveClass (ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n+  {\n+    return Class.forName(osc.getName(), true, currentLoader());\n+  }\n+\n+  private ClassLoader currentLoader()\n   {\n     SecurityManager sm = System.getSecurityManager ();\n     if (sm == null)\n       sm = new SecurityManager () {};\n+    \n+    return currentClassLoader(sm);\n+  }\n \n-    // FIXME: currentClassLoader doesn't yet do anything useful. We need\n-    // to call forName() with the classloader of the class which called \n-    // readObject(). See SecurityManager.getClassContext().\n-    ClassLoader cl = currentClassLoader (sm);\n+  /**\n+   * Lookup a class stored in the local hashtable. If it is not\n+   * use the global lookup function in ObjectStreamClass to build\n+   * the ObjectStreamClass. This method is requested according to\n+   * the behaviour detected in the JDK by Kaffe's team.\n+   *\n+   * @param clazz Class to lookup in the hash table or for which\n+   * we must build a descriptor.\n+   * @return A valid instance of ObjectStreamClass corresponding\n+   * to the specified class.\n+   */\n+  private ObjectStreamClass lookupClass (Class clazz)\n+  {\n+    ObjectStreamClass oclazz;\n \n-    if (cl == null)\n-      return Class.forName (osc.getName ());\n+    oclazz = (ObjectStreamClass) classLookupTable.get(clazz);\n+    if (oclazz == null)\n+      return ObjectStreamClass.lookup (clazz);\n     else\n-      return cl.loadClass (osc.getName ());\n+      return oclazz;\n+  }\n+\n+  /**\n+   * Reconstruct class hierarchy the same way\n+   * {@link java.io.ObjectStreamClass.getObjectStreamClasses(java.lang.Class)} does\n+   * but using lookupClass instead of ObjectStreamClass.lookup. This\n+   * dup is necessary localize the lookup table. Hopefully some future rewritings will\n+   * be able to prevent this.\n+   *\n+   * @param clazz This is the class for which we want the hierarchy.\n+   *\n+   * @return An array of valid {@link java.io.ObjectStreamClass} instances which\n+   * represent the class hierarchy for clazz.\n+   */\n+  private ObjectStreamClass[] inputGetObjectStreamClasses (Class clazz)\n+  {\n+    ObjectStreamClass osc = lookupClass (clazz);\n+\n+    ObjectStreamClass[] ret_val;\n+\n+    if (osc == null)\n+      return new ObjectStreamClass[0];\n+    else\n+      {\n+        Vector oscs = new Vector();\n+\n+        while (osc != null)\n+          {\n+            oscs.addElement(osc);\n+            osc = osc.getSuper();\n+\t  }\n+\n+        int count = oscs.size();\n+\tObjectStreamClass[] sorted_oscs = new ObjectStreamClass[count];\n+\n+        for (int i = count - 1; i >= 0; i--)\n+          sorted_oscs[count - i - 1] = (ObjectStreamClass) oscs.elementAt(i);\n+\n+        return sorted_oscs;\n+      }\n   }\n \n   /**\n@@ -1061,7 +1122,12 @@ protected Object readObjectOverride ()\n     throw new IOException (\"Subclass of ObjectInputStream must implement readObjectOverride\");\n   }\n \n-  // assigns the next availible handle to OBJ\n+  /**\n+   * Assigns the next available handle to <code>obj</code>.\n+   *\n+   * @param obj The object for which we want a new handle.\n+   * @return A valid handle for the specified object.\n+   */\n   private int assignNewHandle (Object obj)\n   {\n     this.objectLookupTable.put (new Integer (this.nextOID),\n@@ -1213,7 +1279,7 @@ private void readFields (Object obj, ObjectStreamClass stream_osc)\n   {\n     ObjectStreamField[] stream_fields = stream_osc.fields;\n     ObjectStreamField[] real_fields =\n-      ObjectStreamClass.lookup (stream_osc.forClass ()).fields;\n+      lookupClass(stream_osc.forClass()).fields;\n \n     boolean default_initialize, set_value;\n     String field_name = null;\n@@ -1406,8 +1472,13 @@ private void invokeValidators () throws InvalidObjectException\n       }\n   }\n \n-  // this native method is used to get access to the protected method\n-  // of the same name in SecurityManger\n+  /**\n+   * This native method is used to get access to the protected method\n+   * of the same name in SecurityManger.\n+   *\n+   * @param sm SecurityManager instance which should be called.\n+   * @return The current class loader in the calling stack.\n+   */\n   private static ClassLoader currentClassLoader (SecurityManager sm)\n   {\n     // FIXME: This is too simple.\n@@ -1757,6 +1828,7 @@ private void setObjectField (Object obj, Class klass, String field_name,\n   private boolean isDeserializing;\n   private boolean fieldsAlreadyRead;\n   private Vector validators;\n+  private Hashtable classLookupTable;\n \n   private static boolean dump;\n "}, {"sha": "0be9a7e50537829818608a9dc142d391d9671335", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 101, "deletions": 22, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649a1a476c573b145a2af341f30755d2c4edf10b/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=649a1a476c573b145a2af341f30755d2c4edf10b", "patch": "@@ -291,7 +291,18 @@ int getFlags ()\n     this.fields = fields;\n   }\n \n-  void setClass (Class cl) throws InvalidClassException\n+  /**\n+   * This method builds the internal description corresponding to a Java Class.\n+   * As the constructor only assign a name to the current ObjectStreamClass instance,\n+   * that method sets the serial UID, chose the fields which will be serialized,\n+   * and compute the position of the fields in the serialized stream.\n+   *\n+   * @param cl The Java class which is used as a reference for building the descriptor.\n+   * @param superClass The descriptor of the super class for this class descriptor.\n+   * @throws InvalidClassException if an incompatibility between computed UID and\n+   * already set UID is found.\n+   */\n+  void setClass (Class cl, ObjectStreamClass superClass) throws InvalidClassException\n   {\n     this.clazz = cl;\n \n@@ -312,11 +323,87 @@ void setClass (Class cl) throws InvalidClassException\n       }\n \n     isProxyClass = clazz != null && Proxy.isProxyClass (clazz);\n-    ObjectStreamClass osc = (ObjectStreamClass)classLookupTable.get (clazz);\n-    if (osc == null)\n-      classLookupTable.put (clazz, this);\n-    superClass = lookupForClassObject (clazz.getSuperclass ());\n+    this.superClass = superClass;\n     calculateOffsets ();\n+\n+    try\n+      {\n+        ObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);\n+\n+        if (exportedFields == null)\n+          return;\n+\n+        ObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];\n+        int i, j, k;\n+\n+        /* We now check the import fields against the exported fields.\n+         * There should not be contradiction (e.g. int x and String x)\n+         * but extra virtual fields can be added to the class.\n+         */\n+\n+        Arrays.sort(exportedFields);\n+\n+        i = 0; j = 0; k = 0;\n+        while (i < fields.length && j < exportedFields.length)\n+          {\n+            int comp = fields[i].getName().compareTo (exportedFields[j].getName());\n+            if (comp < 0)\n+              {\n+                newFieldList[k] = fields[i];\n+                fields[i].setPersistent(false);\n+                fields[i].setToSet(false);\n+                i++;\n+              }\n+            else if (comp > 0)\n+              {\n+                /* field not found in imported fields. We add it\n+                 * in the list of supported fields.\n+                 */\n+                newFieldList[k] = exportedFields[j];\n+                newFieldList[k].setPersistent(true);\n+                newFieldList[k].setToSet(false);\n+                j++;\n+              }\n+            else\n+              {\n+                if (!fields[i].getType().equals (exportedFields[j].getType()))\n+                  throw new InvalidClassException (\"serialPersistentFields must be compatible with\" +\n+                                                   \" imported fields (about \" + fields[i].getName() + \")\");\n+                newFieldList[k] = fields[i];\n+                fields[i].setPersistent(true);\n+                i++;\n+                j++;\n+              }\n+            k++;\n+          }\n+\n+        if (i < fields.length)\n+          for (; i < fields.length; i++, k++)\n+            {\n+              fields[i].setPersistent(false);\n+              fields[i].setToSet(false);\n+              newFieldList[k] = fields[i];\n+            }\n+          else\n+            if (j < exportedFields.length)\n+              for (; j < exportedFields.length; j++, k++)\n+                {\n+                  exportedFields[j].setPersistent(true);\n+                  exportedFields[j].setToSet(false);\n+                  newFieldList[k] = exportedFields[j];\n+               }\n+\n+        fields = new ObjectStreamField[k];\n+        System.arraycopy (newFieldList, 0, fields, 0, k);\n+      }\n+    catch (NoSuchFieldException ignore)\n+      {\n+        return;\n+      }\n+    catch (IllegalAccessException ignore)\n+      {\n+        return;\n+      }\n   }\n \n   void setSuperclass (ObjectStreamClass osc)\n@@ -436,6 +523,9 @@ private void setFields (Class cl)\n     }\n     catch (NoSuchFieldException ignore)\n     {}\n+    catch (IllegalAccessException ignore)\n+      {\n+      }\n \n     int num_good_fields = 0;\n     Field[] all_fields = cl.getDeclaredFields ();\n@@ -613,24 +703,13 @@ private long getClassUID (Class cl)\n   // Returns the value of CLAZZ's private static final field named\n   // `serialPersistentFields'.\n   private ObjectStreamField[] getSerialPersistentFields (Class clazz)\n+    throws NoSuchFieldException, IllegalAccessException\n   {\n-    ObjectStreamField[] o = null;\n-    try\n-      {\n-\t// Use getDeclaredField rather than getField for the same reason\n-\t// as above in getDefinedSUID.\n-\tField f = clazz.getDeclaredField (\"serialPersistentFields\");\n-\tf.setAccessible(true);\n-\to = (ObjectStreamField[])f.get (null);\n-      }\n-    catch (java.lang.NoSuchFieldException e)\n-      {\n-      }\n-    catch (java.lang.IllegalAccessException e)\n-      {\n-      }\n-\n-    return o;\n+    // Use getDeclaredField rather than getField for the same reason\n+    // as above in getDefinedSUID.\n+    Field f = clazz.getDeclaredField(\"serialPersistentFields\");\n+    f.setAccessible(true);\n+    return (ObjectStreamField[]) f.get(null);\n   }\n \n   public static final ObjectStreamField[] NO_FIELDS = {};"}]}