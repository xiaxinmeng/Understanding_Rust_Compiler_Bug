{"sha": "aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEzMmQ4NDE1ODYxYjRhNDFlMGIzZjM4NjU0YmM0MjVjYjdjYjY0ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-08-11T20:23:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-11T20:23:53Z"}, "message": "* Integrate tlink patch from jason@cygnus.com\n        * gcc.c (SWITCH_TAKES_ARG): Add 'V', 'B' and 'b'.\n        (process_command): Increment n_switches for them.  Don't discard\n        their args.  Validate them.\n        (main): Escape \" marks when creating COLLECT_GCC_OPTIONS.\n        From Rohan Lenard.\n        (process_command): Set include_prefixes from COMPILER_PATH.\n        (main): Set COLLECT_GCC_OPTIONS sooner.\n        * confiugre.in: Link ../ld/ld.new to collect-ld rather than real-ld.\n        * tlink.c, hash.c, hash.h: New files.\n        * Makefile.in (USE_COLLECT2): Always use collect2.\n        (collect2): Depend on and link in hash.o and tlink.o.\n        (tlink.o, hash.o): Add dependencies.\n\ntlink patches from Jason.\n\nFrom-SVN: r14769", "tree": {"sha": "fd4878ed0cdfb269f8e71f6bb4319c96a290414b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd4878ed0cdfb269f8e71f6bb4319c96a290414b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/comments", "author": null, "committer": null, "parents": [{"sha": "9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae8ffe751384e446477c47f8cf670d3a1e92fe9"}], "stats": {"total": 1127, "additions": 1073, "deletions": 54}, "files": [{"sha": "ff0aa85597ec509a28a7ab10e48329e26b83d341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -1,3 +1,19 @@\n+Mon Aug 11 14:15:02 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Integrate tlink patch from jason@cygnus.com\n+\t* gcc.c (SWITCH_TAKES_ARG): Add 'V', 'B' and 'b'.\n+  \t(process_command): Increment n_switches for them.  Don't discard\n+ \ttheir args.  Validate them.\n+\t(main): Escape \" marks when creating COLLECT_GCC_OPTIONS.\n+\tFrom Rohan Lenard.\n+\t(process_command): Set include_prefixes from COMPILER_PATH.\n+\t(main): Set COLLECT_GCC_OPTIONS sooner.\n+\t* confiugre.in: Link ../ld/ld.new to collect-ld rather than real-ld.\n+\t* tlink.c, hash.c, hash.h: New files.\n+\t* Makefile.in (USE_COLLECT2): Always use collect2.\n+\t(collect2): Depend on and link in hash.o and tlink.o.\n+\t(tlink.o, hash.o): Add dependencies.\n+\n Mon Aug 11 10:04:49 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* Integrate alias analysis changes from jfc@mit.edu"}, {"sha": "76d83967f483795acd784dc983c11986159dbb84", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -313,6 +313,7 @@ USE_COLLECT2 = @will_use_collect2@\n MAYBE_USE_COLLECT2 = @maybe_use_collect2@\n # It is convenient for configure to add the assignment at the beginning,\n # so don't override it here.\n+USE_COLLECT2 = ld\n \n # List of extra C and assembler files to add to libgcc1.a.\n # Assembler files should have names ending in `.asm'.\n@@ -1169,18 +1170,20 @@ ld: collect2\n \tln collect2$(exeext) ld$(exeext) > /dev/null 2>&1 \\\n \t   || cp collect2$(exeext) ld$(exeext)\n \n-collect2 : collect2.o cplus-dem.o underscore.o version.o \\\n+collect2: collect2.o tlink.o hash.o cplus-dem.o underscore.o version.o \\\n \tchoose-temp.o $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n \t-rm -f collect2$(exeext)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ collect2.o \\\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ collect2.o tlink.o hash.o \\\n \t  cplus-dem.o underscore.o version.o choose-temp.o $(LIBS)\n \n collect2.o : collect2.c $(CONFIG_H) gstab.h obstack.h demangle.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" $(MAYBE_USE_COLLECT2) \\\n \t-c `echo $(srcdir)/collect2.c | sed 's,^\\./,,'`\n \n+tlink.o: tlink.c demangle.h hash.h $(CONFIG_H)\n+hash.o: hash.c hash.h\n cplus-dem.o: cplus-dem.c demangle.h\n \n underscore.c: stamp-under ; @true"}, {"sha": "64d98d78db78804bd9de220984ac16e0b464cb1d", "filename": "gcc/collect2.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -1368,17 +1368,20 @@ main (argc, argv)\n       fprintf (stderr, \"\\n\");\n     }\n \n-  /* Load the program, searching all libraries.  */\n+  /* Load the program, searching all libraries and attempting to provide\n+     undefined symbols from repository information.  */\n \n-  collect_execute (\"ld\", ld1_argv, ldout);\n-  do_wait (\"ld\");\n-  dump_file (ldout);\n-  unlink (ldout);\n+  do_tlink (ld1_argv, object_lst);\n \n   /* If -r or they'll be run via some other method, don't build the\n      constructor or destructor list, just return now.  */\n   if (rflag || ! do_collecting)\n-    return 0;\n+    {\n+      /* But make sure we delete the export file we may have created.  */\n+      if (export_file != 0 && export_file[0])\n+\tmaybe_unlink (export_file);\n+      return 0;\n+    }\n \n   /* Examine the namelist with nm and search it for static constructors\n      and destructors to call."}, {"sha": "64999d034abb169ab18dce1d7ed23560ed3d8a95", "filename": "gcc/configure", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -4219,13 +4219,13 @@ if [ -f ../gas/Makefile ]; then\n fi\n \n # If we have ld in the build tree, make a link to it.\n-if [ -f ../ld/Makefile ]; then\n-\tif [ x$use_collect2 = x ]; then\n-\t\trm -f ld; $symbolic_link ../ld/ld.new ld 2>/dev/null\n-\telse\n-\t\trm -f collect-ld; $symbolic_link ../ld/ld.new collect-ld 2>/dev/null\n-\tfi\n-fi\n+#if [ -f ../ld/Makefile ]; then\n+#\tif [ x$use_collect2 = x ]; then\n+#\t\trm -f ld; $symbolic_link ../ld/ld.new ld 2>/dev/null\n+#\telse\n+#\t\trm -f collect-ld; $symbolic_link ../ld/ld.new collect-ld 2>/dev/null\n+#\tfi\n+#fi\n \n # Figure out what language subdirectories are present.\n subdirs="}, {"sha": "da6bdb630ea4f584972c95222968a217345e283f", "filename": "gcc/configure.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -2886,11 +2886,11 @@ fi\n \n # If we have ld in the build tree, make a link to it.\n if [[ -f ../ld/Makefile ]]; then\n-\tif [[ x$use_collect2 = x ]]; then\n-\t\trm -f ld; $symbolic_link ../ld/ld.new ld 2>/dev/null\n-\telse\n+#\tif [[ x$use_collect2 = x ]]; then\n+#\t\trm -f ld; $symbolic_link ../ld/ld.new ld 2>/dev/null\n+#\telse\n \t\trm -f collect-ld; $symbolic_link ../ld/ld.new collect-ld 2>/dev/null\n-\tfi\n+#\tfi\n fi\n \n # Figure out what language subdirectories are present."}, {"sha": "4f6237cde636f5eecf13b3e6b847cea11297692a", "filename": "gcc/gcc.c", "status": "modified", "additions": 62, "deletions": 35, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -525,11 +525,12 @@ static struct user_specs *user_specs_head, *user_specs_tail;\n \n /* This defines which switch letters take arguments.  */\n \n-#define DEFAULT_SWITCH_TAKES_ARG(CHAR)      \\\n+#define DEFAULT_SWITCH_TAKES_ARG(CHAR) \\\n   ((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \\\n    || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \\\n    || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x' \\\n-   || (CHAR) == 'L' || (CHAR) == 'A')\n+   || (CHAR) == 'L' || (CHAR) == 'A' || (CHAR) == 'V' \\\n+   || (CHAR) == 'B' || (CHAR) == 'b')\n \n #ifndef SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR) DEFAULT_SWITCH_TAKES_ARG(CHAR)\n@@ -2391,6 +2392,9 @@ process_command (argc, argv)\n \t      else\n \t\tnstore[endp-startp] = 0;\n \t      add_prefix (&exec_prefixes, nstore, 0, 0, NULL_PTR);\n+\t      add_prefix (&include_prefixes,\n+\t\t\t  concat (nstore, \"include\", NULL_PTR),\n+\t\t\t  0, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n \t      endp = startp = endp + 1;\n@@ -2630,6 +2634,7 @@ process_command (argc, argv)\n \t  switch (c)\n \t    {\n \t    case 'b':\n+              n_switches++;\n \t      if (p[1] == 0 && i + 1 == argc)\n \t\tfatal (\"argument to `-b' is missing\");\n \t      if (p[1] == 0)\n@@ -2681,6 +2686,7 @@ process_command (argc, argv)\n \t\t\t}\n \t\t    }\n \t\t}\n+                n_switches++;\n \t      }\n \t      break;\n \n@@ -2694,6 +2700,7 @@ process_command (argc, argv)\n \t      break;\n \n \t    case 'V':\n+\t      n_switches++;\n \t      if (p[1] == 0 && i + 1 == argc)\n \t\tfatal (\"argument to `-V' is missing\");\n \t      if (p[1] == 0)\n@@ -2884,13 +2891,6 @@ process_command (argc, argv)\n \t  register char *p = &argv[i][1];\n \t  register int c = *p;\n \n-\t  if (c == 'B' || c == 'b' || c == 'V')\n-\t    {\n-\t      /* Skip a separate arg, if any.  */\n-\t      if (p[1] == 0)\n-\t\ti++;\n-\t      continue;\n-\t    }\n \t  if (c == 'x')\n \t    {\n \t      if (p[1] == 0 && i + 1 == argc)\n@@ -2952,6 +2952,12 @@ process_command (argc, argv)\n \t  /* This is always valid, since gcc.c itself understands it.  */\n \t  if (!strcmp (p, \"save-temps\"))\n \t    switches[n_switches].valid = 1;\n+          else\n+            {\n+              char ch = switches[n_switches].part1[0];\n+              if (ch == 'V' || ch == 'b' || ch == 'B')\n+                switches[n_switches].valid = 1;\n+            }\n \t  n_switches++;\n \t}\n       else\n@@ -4373,6 +4379,53 @@ main (argc, argv)\n \n   process_command (argc, argv);\n \n+  {\n+    int i;\n+    int first_time;\n+\n+    /* Build COLLECT_GCC_OPTIONS to have all of the options specified to\n+       the compiler.  */\n+    obstack_grow (&collect_obstack, \"COLLECT_GCC_OPTIONS=\",\n+\t\t  sizeof (\"COLLECT_GCC_OPTIONS=\")-1);\n+\n+    first_time = TRUE;\n+    for (i = 0; i < n_switches; i++)\n+      {\n+\tchar **args;\n+\tchar *p, *q;\n+\tif (!first_time)\n+\t  obstack_grow (&collect_obstack, \" \", 1);\n+\n+\tfirst_time = FALSE;\n+\tobstack_grow (&collect_obstack, \"'-\", 2);\n+        q = switches[i].part1;\n+\twhile (p = (char *) index (q,'\\''))\n+          {\n+            obstack_grow (&collect_obstack, q, p-q);\n+            obstack_grow (&collect_obstack, \"'\\\\''\", 4);\n+            q = ++p;\n+          }\n+        obstack_grow (&collect_obstack, q, strlen (q));\n+\tobstack_grow (&collect_obstack, \"'\", 1);\n+\n+\tfor (args = switches[i].args; args && *args; args++)\n+\t  {\n+\t    obstack_grow (&collect_obstack, \" '\", 2);\n+\t    q = *args;\n+\t    while (p = (char *) index (q,'\\''))\n+\t      {\n+\t\tobstack_grow (&collect_obstack, q, p-q);\n+\t\tobstack_grow (&collect_obstack, \"'\\\\''\", 4);\n+\t\tq = ++p;\n+\t      }\n+\t    obstack_grow (&collect_obstack, q, strlen (q));\n+\t    obstack_grow (&collect_obstack, \"'\", 1);\n+\t  }\n+      }\n+    obstack_grow (&collect_obstack, \"\\0\", 1);\n+    putenv (obstack_finish (&collect_obstack));\n+  }\n+\n   /* Initialize the vector of specs to just the default.\n      This means one element containing 0s, as a terminator.  */\n \n@@ -4676,32 +4729,6 @@ main (argc, argv)\n       putenv_from_prefixes (&exec_prefixes, \"COMPILER_PATH=\");\n       putenv_from_prefixes (&startfile_prefixes, \"LIBRARY_PATH=\");\n \n-      /* Build COLLECT_GCC_OPTIONS to have all of the options specified to\n-\t the compiler.  */\n-      obstack_grow (&collect_obstack, \"COLLECT_GCC_OPTIONS=\",\n-\t\t    sizeof (\"COLLECT_GCC_OPTIONS=\")-1);\n-\n-      first_time = TRUE;\n-      for (i = 0; i < n_switches; i++)\n-\t{\n-\t  char **args;\n-\t  if (!first_time)\n-\t    obstack_grow (&collect_obstack, \" \", 1);\n-\n-\t  first_time = FALSE;\n-\t  obstack_grow (&collect_obstack, \"-\", 1);\n-\t  obstack_grow (&collect_obstack, switches[i].part1,\n-\t\t\tstrlen (switches[i].part1));\n-\n-\t  for (args = switches[i].args; args && *args; args++)\n-\t    {\n-\t      obstack_grow (&collect_obstack, \" \", 1);\n-\t      obstack_grow (&collect_obstack, *args, strlen (*args));\n-\t    }\n-\t}\n-      obstack_grow (&collect_obstack, \"\\0\", 1);\n-      putenv (obstack_finish (&collect_obstack));\n-\n       value = do_spec (link_command_spec);\n       if (value < 0)\n \terror_count = 1;"}, {"sha": "155ffbf70f800b3bd92478a27ff49be61cabcac8", "filename": "gcc/hash.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.c?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -0,0 +1,208 @@\n+/* CYGNUS LOCAL: whole file jason */\n+/* hash.c -- hash table routines\n+   Copyright (C) 1993, 94 Free Software Foundation, Inc.\n+   Written by Steve Chamberlain <sac@cygnus.com>\n+\n+This file was lifted from BFD, the Binary File Descriptor library.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"hash.h\"\n+#include \"obstack.h\"\n+\n+extern void free PARAMS ((PTR));\n+\n+/* Obstack allocation and deallocation routines.  */\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern char * xmalloc ();\n+\n+/* The default number of entries to use when creating a hash table.  */\n+#define DEFAULT_SIZE (1009)\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+/* Create a new hash table, given a number of entries.  */\n+\n+boolean\n+hash_table_init_n (table, newfunc, size)\n+     struct hash_table *table;\n+     struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\tstruct hash_table *,\n+\t\t\t\t\t\tconst char *));\n+     unsigned int size;\n+{\n+  unsigned int alloc;\n+\n+  alloc = size * sizeof (struct hash_entry *);\n+  if (!obstack_begin (&table->memory, alloc))\n+    {\n+      error (\"no memory\");\n+      return false;\n+    }\n+  table->table = ((struct hash_entry **)\n+\t\t  obstack_alloc (&table->memory, alloc));\n+  if (!table->table)\n+    {\n+      error (\"no memory\");\n+      return false;\n+    }\n+  memset ((PTR) table->table, 0, alloc);\n+  table->size = size;\n+  table->newfunc = newfunc;\n+  return true;\n+}\n+\n+/* Create a new hash table with the default number of entries.  */\n+\n+boolean\n+hash_table_init (table, newfunc)\n+     struct hash_table *table;\n+     struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\tstruct hash_table *,\n+\t\t\t\t\t\tconst char *));\n+{\n+  return hash_table_init_n (table, newfunc, DEFAULT_SIZE);\n+}\n+\n+/* Free a hash table.  */\n+\n+void\n+hash_table_free (table)\n+     struct hash_table *table;\n+{\n+  obstack_free (&table->memory, (PTR) NULL);\n+}\n+\n+/* Look up a string in a hash table.  */\n+\n+struct hash_entry *\n+hash_lookup (table, string, create, copy)\n+     struct hash_table *table;\n+     const char *string;\n+     boolean create;\n+     boolean copy;\n+{\n+  register const unsigned char *s;\n+  register unsigned long hash;\n+  register unsigned int c;\n+  struct hash_entry *hashp;\n+  unsigned int len;\n+  unsigned int index;\n+  \n+  hash = 0;\n+  len = 0;\n+  s = (const unsigned char *) string;\n+  while ((c = *s++) != '\\0')\n+    {\n+      hash += c + (c << 17);\n+      hash ^= hash >> 2;\n+      ++len;\n+    }\n+  hash += len + (len << 17);\n+  hash ^= hash >> 2;\n+\n+  index = hash % table->size;\n+  for (hashp = table->table[index];\n+       hashp != (struct hash_entry *) NULL;\n+       hashp = hashp->next)\n+    {\n+      if (hashp->hash == hash\n+\t  && strcmp (hashp->string, string) == 0)\n+\treturn hashp;\n+    }\n+\n+  if (! create)\n+    return (struct hash_entry *) NULL;\n+\n+  hashp = (*table->newfunc) ((struct hash_entry *) NULL, table, string);\n+  if (hashp == (struct hash_entry *) NULL)\n+    return (struct hash_entry *) NULL;\n+  if (copy)\n+    {\n+      char *new;\n+\n+      new = (char *) obstack_alloc (&table->memory, len + 1);\n+      if (!new)\n+\t{\n+\t  error (\"no memory\");\n+\t  return (struct hash_entry *) NULL;\n+\t}\n+      strcpy (new, string);\n+      string = new;\n+    }\n+  hashp->string = string;\n+  hashp->hash = hash;\n+  hashp->next = table->table[index];\n+  table->table[index] = hashp;\n+\n+  return hashp;\n+}\n+\n+/* Base method for creating a new hash table entry.  */\n+\n+/*ARGSUSED*/\n+struct hash_entry *\n+hash_newfunc (entry, table, string)\n+     struct hash_entry *entry;\n+     struct hash_table *table;\n+     const char *string;\n+{\n+  if (entry == (struct hash_entry *) NULL)\n+    entry = ((struct hash_entry *)\n+\t     hash_allocate (table, sizeof (struct hash_entry)));\n+  return entry;\n+}\n+\n+/* Allocate space in a hash table.  */\n+\n+PTR\n+hash_allocate (table, size)\n+     struct hash_table *table;\n+     unsigned int size;\n+{\n+  PTR ret;\n+\n+  ret = obstack_alloc (&table->memory, size);\n+  if (ret == NULL && size != 0)\n+    error (\"no memory\");\n+  return ret;\n+}\n+\n+/* Traverse a hash table.  */\n+\n+void\n+hash_traverse (table, func, info)\n+     struct hash_table *table;\n+     boolean (*func) PARAMS ((struct hash_entry *, PTR));\n+     PTR info;\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < table->size; i++)\n+    {\n+      struct hash_entry *p;\n+\n+      for (p = table->table[i]; p != NULL; p = p->next)\n+\t{\n+\t  if (! (*func) (p, info))\n+\t    return;\n+\t}\n+    }\n+}"}, {"sha": "388532abd655435673a43639a97eb0f976b0adc5", "filename": "gcc/hash.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.h?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -0,0 +1,131 @@\n+/* CYGNUS LOCAL: whole file jason */\n+/* Header file for generic hash table support.\n+   Copyright (C) 1993, 94 Free Software Foundation, Inc.\n+   Written by Steve Chamberlain <sac@cygnus.com>\n+\n+This file was lifted from BFD, the Binary File Descriptor library.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifdef IN_GCC\n+\n+/* Add prototype support.  */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+#define PARAMS(ARGS) PROTO(ARGS)\n+\n+#ifdef __STDC__\n+#define PTR void *\n+#else\n+#ifndef const\n+#define const\n+#endif\n+#define PTR char *\n+#endif\n+\n+#else /* ! IN_GCC */\n+#include <ansidecl.h>\n+#endif /* IN_GCC */\n+\n+#include \"obstack.h\"\n+\n+typedef enum {false, true} boolean;\n+\n+/* Hash table routines.  There is no way to free up a hash table.  */\n+\n+/* An element in the hash table.  Most uses will actually use a larger\n+   structure, and an instance of this will be the first field.  */\n+\n+struct hash_entry\n+{\n+  /* Next entry for this hash code.  */\n+  struct hash_entry *next;\n+  /* String being hashed.  */\n+  const char *string;\n+  /* Hash code.  This is the full hash code, not the index into the\n+     table.  */\n+  unsigned long hash;\n+};\n+\n+/* A hash table.  */\n+\n+struct hash_table\n+{\n+  /* The hash array.  */\n+  struct hash_entry **table;\n+  /* The number of slots in the hash table.  */\n+  unsigned int size;\n+  /* A function used to create new elements in the hash table.  The\n+     first entry is itself a pointer to an element.  When this\n+     function is first invoked, this pointer will be NULL.  However,\n+     having the pointer permits a hierarchy of method functions to be\n+     built each of which calls the function in the superclass.  Thus\n+     each function should be written to allocate a new block of memory\n+     only if the argument is NULL.  */\n+  struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n+\t\t\t\t\t struct hash_table *,\n+\t\t\t\t\t const char *));\n+  /* An obstack for this hash table.  */\n+  struct obstack memory;\n+};\n+\n+/* Initialize a hash table.  */\n+extern boolean hash_table_init\n+  PARAMS ((struct hash_table *,\n+\t   struct hash_entry *(*) (struct hash_entry *,\n+\t\t\t\t   struct hash_table *,\n+\t\t\t\t   const char *)));\n+\n+/* Initialize a hash table specifying a size.  */\n+extern boolean hash_table_init_n\n+  PARAMS ((struct hash_table *,\n+\t   struct hash_entry *(*) (struct hash_entry *,\n+\t\t\t\t   struct hash_table *,\n+\t\t\t\t   const char *),\n+\t   unsigned int size));\n+\n+/* Free up a hash table.  */\n+extern void hash_table_free PARAMS ((struct hash_table *));\n+\n+/* Look up a string in a hash table.  If CREATE is true, a new entry\n+   will be created for this string if one does not already exist.  The\n+   COPY argument must be true if this routine should copy the string\n+   into newly allocated memory when adding an entry.  */\n+extern struct hash_entry *hash_lookup\n+  PARAMS ((struct hash_table *, const char *, boolean create,\n+\t   boolean copy));\n+\n+/* Base method for creating a hash table entry.  */\n+extern struct hash_entry *hash_newfunc\n+  PARAMS ((struct hash_entry *, struct hash_table *,\n+\t   const char *));\n+\n+/* Grab some space for a hash table entry.  */\n+extern PTR hash_allocate PARAMS ((struct hash_table *,\n+\t\t\t\t  unsigned int));\n+\n+/* Traverse a hash table in a random order, calling a function on each\n+   element.  If the function returns false, the traversal stops.  The\n+   INFO argument is passed to the function.  */\n+extern void hash_traverse PARAMS ((struct hash_table *,\n+\t\t\t\t   boolean (*) (struct hash_entry *,\n+\t\t\t\t\t\tPTR),\n+\t\t\t\t   PTR info));"}, {"sha": "77b7875c19347e43f525549237497b0096d7b686", "filename": "gcc/tlink.c", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32d8415861b4a41e0b3f38654bc425cb7cb64d/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "patch": "@@ -0,0 +1,631 @@\n+/* CYGNUS LOCAL: whole file jason */\n+/* Scan linker error messages for missing template instantiations and provide\n+   them.\n+\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill (jason@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"hash.h\"\n+#include \"demangle.h\"\n+\n+#define MAX_ITERATIONS 17\n+\n+/* Obstack allocation and deallocation routines.  */\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern char * xmalloc PARAMS((unsigned));\n+extern void free ();\n+extern char * getenv ();\n+\n+/* Defined in collect2.c.  */\n+extern int vflag, debug;\n+extern char *ldout;\n+extern char *c_file_name;\n+extern struct obstack temporary_obstack;\n+extern struct obstack permanent_obstack;\n+extern char * temporary_firstobj;\n+\n+/* Defined in the automatically-generated underscore.c.  */\n+extern int prepends_underscore;\n+\n+static int tlink_verbose;\n+\f\n+/* Hash table code.  */\n+\n+typedef struct symbol_hash_entry\n+{\n+  struct hash_entry root;\n+  struct file_hash_entry *file;\n+  int chosen;\n+  int tweaking;\n+  int tweaked;\n+} symbol;\n+\n+typedef struct file_hash_entry\n+{\n+  struct hash_entry root;\n+  const char *args;\n+  const char *dir;\n+  const char *main;\n+  int tweaking;\n+} file;\n+\n+typedef struct demangled_hash_entry\n+{\n+  struct hash_entry root;\n+  const char *mangled;\n+} demangled;\n+\n+static struct hash_table symbol_table;\n+\n+static struct hash_entry *\n+symbol_hash_newfunc (entry, table, string)\n+     struct hash_entry *entry;\n+     struct hash_table *table;\n+     const char *string;\n+{\n+  struct symbol_hash_entry *ret = (struct symbol_hash_entry *) entry;\n+  if (ret == NULL)\n+    {\n+      ret = ((struct symbol_hash_entry *)\n+\t     hash_allocate (table, sizeof (struct symbol_hash_entry)));\n+      if (ret == NULL)\n+\treturn NULL;\n+    }\n+  ret = ((struct symbol_hash_entry *)\n+     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+  ret->file = NULL;\n+  ret->chosen = 0;\n+  ret->tweaking = 0;\n+  ret->tweaked = 0;\n+  return (struct hash_entry *) ret;\n+}\n+\n+static struct symbol_hash_entry *\n+symbol_hash_lookup (string, create)\n+     const char *string;\n+     boolean create;\n+{\n+  return ((struct symbol_hash_entry *)\n+\t  hash_lookup (&symbol_table, string, create, true));\n+}\n+\n+static struct hash_table file_table;\n+\n+static struct hash_entry *\n+file_hash_newfunc (entry, table, string)\n+     struct hash_entry *entry;\n+     struct hash_table *table;\n+     const char *string;\n+{\n+   struct file_hash_entry *ret = (struct file_hash_entry *) entry;\n+  if (ret == NULL)\n+    {\n+      ret = ((struct file_hash_entry *)\n+\t     hash_allocate (table, sizeof (struct file_hash_entry)));\n+      if (ret == NULL)\n+\treturn NULL;\n+    }\n+  ret = ((struct file_hash_entry *)\n+     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+  ret->args = NULL;\n+  ret->dir = NULL;\n+  ret->main = NULL;\n+  ret->tweaking = 0;\n+  return (struct hash_entry *) ret;\n+}\n+\n+static struct file_hash_entry *\n+file_hash_lookup (string)\n+     const char *string;\n+{\n+  return ((struct file_hash_entry *)\n+\t  hash_lookup (&file_table, string, true, true));\n+}\n+\n+static struct hash_table demangled_table;\n+\n+static struct hash_entry *\n+demangled_hash_newfunc (entry, table, string)\n+     struct hash_entry *entry;\n+     struct hash_table *table;\n+     const char *string;\n+{\n+  struct demangled_hash_entry *ret = (struct demangled_hash_entry *) entry;\n+  if (ret == NULL)\n+    {\n+      ret = ((struct demangled_hash_entry *)\n+\t     hash_allocate (table, sizeof (struct demangled_hash_entry)));\n+      if (ret == NULL)\n+\treturn NULL;\n+    }\n+  ret = ((struct demangled_hash_entry *)\n+     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+  ret->mangled = NULL;\n+  return (struct hash_entry *) ret;\n+}\n+\n+static struct demangled_hash_entry *\n+demangled_hash_lookup (string, create)\n+     const char *string;\n+     boolean create;\n+{\n+  return ((struct demangled_hash_entry *)\n+\t  hash_lookup (&demangled_table, string, create, true));\n+}\n+\f\n+/* Stack code.  */\n+\n+struct symbol_stack_entry\n+{\n+  symbol *value;\n+  struct symbol_stack_entry *next;\n+};\n+struct obstack symbol_stack_obstack;\n+struct symbol_stack_entry *symbol_stack;\n+\n+struct file_stack_entry\n+{\n+  file *value;\n+  struct file_stack_entry *next;\n+};\n+struct obstack file_stack_obstack;\n+struct file_stack_entry *file_stack;\n+\n+static void\n+symbol_push (p)\n+     symbol *p;\n+{\n+  struct symbol_stack_entry *ep = (struct symbol_stack_entry *) obstack_alloc\n+    (&symbol_stack_obstack, sizeof (struct symbol_stack_entry));\n+  ep->value = p;\n+  ep->next = symbol_stack;\n+  symbol_stack = ep;\n+}\n+\n+static symbol *\n+symbol_pop ()\n+{\n+  struct symbol_stack_entry *ep = symbol_stack;\n+  symbol *p;\n+  if (ep == NULL)\n+    return NULL;\n+  p = ep->value;\n+  symbol_stack = ep->next;\n+  obstack_free (&symbol_stack_obstack, ep);\n+  return p;\n+}\n+\n+static void\n+file_push (p)\n+     file *p;\n+{\n+  struct file_stack_entry *ep;\n+\n+  if (p->tweaking)\n+    return;\n+\n+  ep = (struct file_stack_entry *) obstack_alloc\n+    (&file_stack_obstack, sizeof (struct file_stack_entry));\n+  ep->value = p;\n+  ep->next = file_stack;\n+  file_stack = ep;\n+  p->tweaking = 1;\n+}\n+\n+static file *\n+file_pop ()\n+{\n+  struct file_stack_entry *ep = file_stack;\n+  file *p;\n+  if (ep == NULL)\n+    return NULL;\n+  p = ep->value;\n+  file_stack = ep->next;\n+  obstack_free (&file_stack_obstack, ep);\n+  p->tweaking = 0;\n+  return p;\n+}\n+\f\n+/* Other machinery.  */\n+\n+static void\n+tlink_init ()\n+{\n+  char *p;\n+\n+  hash_table_init (&symbol_table, symbol_hash_newfunc);\n+  hash_table_init (&file_table, file_hash_newfunc);\n+  hash_table_init (&demangled_table, demangled_hash_newfunc);\n+  obstack_begin (&symbol_stack_obstack, 0);\n+  obstack_begin (&file_stack_obstack, 0);\n+\n+  p = getenv (\"TLINK_VERBOSE\");\n+  if (p)\n+    tlink_verbose = atoi (p);\n+  else\n+    {\n+      tlink_verbose = 1;\n+      if (vflag)\n+\ttlink_verbose = 2;\n+      if (debug)\n+\ttlink_verbose = 3;\n+    }\n+}\n+\n+static int\n+tlink_execute (prog, argv, redir)\n+     char *prog;\n+     char **argv;\n+     char *redir;\n+{\n+  collect_execute (prog, argv, redir);\n+  return collect_wait (prog);\n+} \n+\n+static char *\n+frob_extension (s, ext)\n+     char *s, *ext;\n+{\n+  char *p = (char *) rindex (s, '/');\n+  if (! p)\n+    p = s;\n+  p = (char *) rindex (p, '.');\n+  if (! p)\n+    p = s + strlen (s);\n+\n+  obstack_grow (&temporary_obstack, s, p - s);\n+  return obstack_copy0 (&temporary_obstack, ext, strlen (ext));\n+}\n+\n+static char *\n+obstack_fgets (stream, ob)\n+     FILE *stream;\n+     struct obstack *ob;\n+{\n+  int c;\n+  while ((c = getc (stream)) != EOF && c != '\\n')\n+    obstack_1grow (ob, c);\n+  if (obstack_object_size (ob) == 0)\n+    return NULL;\n+  obstack_1grow (ob, '\\0');\n+  return obstack_finish (ob);\n+}\n+\n+static char *\n+tfgets (stream)\n+     FILE *stream;\n+{\n+  return obstack_fgets (stream, &temporary_obstack);\n+}\n+\n+static char *\n+pfgets (stream)\n+     FILE *stream;\n+{\n+  return obstack_fgets (stream, &permanent_obstack);\n+}\n+\f\n+/* Real tlink code.  */\n+\n+static void\n+freadsym (stream, f, chosen)\n+     FILE *stream;\n+     file *f;\n+     int chosen;\n+{\n+  symbol *sym;\n+\n+  {\n+    char *name = tfgets (stream);\n+    sym = symbol_hash_lookup (name, true);\n+  }\n+\n+  if (sym->file == NULL)\n+    {\n+      symbol_push (sym);\n+      sym->file = f;\n+      sym->chosen = chosen;\n+    }\n+  else if (chosen)\n+    {\n+      if (sym->chosen && sym->file != f)\n+\t{\n+\t  if (sym->chosen == 1)\n+\t    file_push (sym->file);\n+\t  else\n+\t    {\n+\t      file_push (f);\n+\t      f = sym->file;\n+\t      chosen = sym->chosen;\n+\t    }\n+\t}\n+      sym->file = f;\n+      sym->chosen = chosen;\n+    }\n+}\n+\n+static void\n+read_repo_file (f)\n+     file *f;\n+{\n+  char c;\n+  FILE *stream = fopen (f->root.string, \"r\");\n+\n+  if (tlink_verbose >= 2)\n+    fprintf (stderr, \"collect: reading %s\\n\", f->root.string);\n+\n+  while (fscanf (stream, \"%c \", &c) == 1)\n+    {\n+      switch (c)\n+\t{\n+\tcase 'A':\n+\t  f->args = pfgets (stream);\n+\t  break;\n+\tcase 'D':\n+\t  f->dir = pfgets (stream);\n+\t  break;\n+\tcase 'M':\n+\t  f->main = pfgets (stream);\n+\t  break;\n+\tcase 'P':\n+\t  freadsym (stream, f, 2);\n+\t  break;\n+\tcase 'C':\n+\t  freadsym (stream, f, 1);\n+\t  break;\n+\tcase 'O':\n+\t  freadsym (stream, f, 0);\n+\t  break;\n+\t}\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+    }\n+  fclose (stream);\n+  if (f->args == NULL)\n+    f->args = getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (f->dir == NULL)\n+    f->dir = \".\";\n+}\n+\n+static void\n+maybe_tweak (line, f)\n+     char *line;\n+     file *f;\n+{\n+  symbol *sym = symbol_hash_lookup (line + 2, false);\n+\n+  if ((sym->file == f && sym->tweaking)\n+      || (sym->file != f && line[0] == 'C'))\n+    {\n+      sym->tweaking = 0;\n+      sym->tweaked = 1;\n+\n+      if (line[0] == 'O')\n+\tline[0] = 'C';\n+      else\n+\tline[0] = 'O';\n+    }\n+}\n+\n+static int\n+recompile_files ()\n+{\n+  file *f;\n+\n+  while ((f = file_pop ()) != NULL)\n+    {\n+      char *line, *command;\n+      FILE *stream = fopen (f->root.string, \"r\");\n+      char *outname = frob_extension (f->root.string, \".rnw\");\n+      FILE *output = fopen (outname, \"w\");\n+\n+      while ((line = tfgets (stream)) != NULL)\n+\t{\n+\t  switch (line[0])\n+\t    {\n+\t    case 'C':\n+\t    case 'O':\n+\t      maybe_tweak (line, f);\n+\t    }\n+\t  fprintf (output, \"%s\\n\", line);\n+\t}\n+      fclose (stream);\n+      fclose (output);\n+      rename (outname, f->root.string);\n+\n+      obstack_grow (&temporary_obstack, \"cd \", 3);\n+      obstack_grow (&temporary_obstack, f->dir, strlen (f->dir));\n+      obstack_grow (&temporary_obstack, \"; \", 2);\n+      obstack_grow (&temporary_obstack, c_file_name, strlen (c_file_name));\n+      obstack_1grow (&temporary_obstack, ' ');\n+      obstack_grow (&temporary_obstack, f->args, strlen (f->args));\n+      obstack_1grow (&temporary_obstack, ' ');\n+      command = obstack_copy0 (&temporary_obstack, f->main, strlen (f->main));\n+\n+      if (tlink_verbose)\n+\tfprintf (stderr, \"collect: recompiling %s\\n\", f->main);\n+      if (tlink_verbose >= 3)\n+\tfprintf (stderr, \"%s\\n\", command);\n+\n+      if (system (command) != 0)\n+\treturn 0;\n+\n+      read_repo_file (f);\n+\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+    }\n+  return 1;\n+}\n+\n+static int\n+read_repo_files (object_lst)\n+     char **object_lst;\n+{\n+  char **object = object_lst;\n+\n+  for (; *object; object++)\n+    {\n+      char *p = frob_extension (*object, \".rpo\");\n+      file *f;\n+\n+      if (! file_exists (p))\n+\tcontinue;\n+\n+      f = file_hash_lookup (p);\n+\n+      read_repo_file (f);\n+    }\n+\n+  if (file_stack != NULL && ! recompile_files ())\n+    return 0;\n+\n+  return (symbol_stack != NULL);\n+}\n+\n+static void\n+demangle_new_symbols ()\n+{\n+  symbol *sym;\n+\n+  while ((sym = symbol_pop ()) != NULL)\n+    {\n+      demangled *dem;\n+      char *p = cplus_demangle (sym->root.string, DMGL_PARAMS | DMGL_ANSI);\n+\n+      if (! p)\n+\tcontinue;\n+\n+      dem = demangled_hash_lookup (p, true);\n+      dem->mangled = sym->root.string;\n+    }\n+}\n+\n+static int\n+scan_linker_output (fname)\n+     char *fname;\n+{\n+  FILE *stream = fopen (fname, \"r\");\n+  char *line;\n+\n+  while ((line = tfgets (stream)) != NULL)\n+    {\n+      char *p = line, *q;\n+      symbol *sym;\n+      int end;\n+      \n+      while (*p && isspace (*p))\n+\t++p;\n+\n+      if (! *p)\n+\tcontinue;\n+\n+      for (q = p; *q && ! isspace (*q); ++q)\n+\t;\n+\n+      /* Try the first word on the line.  */\n+      if (*p == '.')\n+\t++p;\n+      if (*p == '_' && prepends_underscore)\n+\t++p;\n+\n+      end = ! *q;\n+      *q = 0;\n+      sym = symbol_hash_lookup (p, false);\n+\n+      if (! sym && ! end)\n+\t/* Try a mangled name in `quotes'.  */\n+\t{\n+\t  demangled *dem = 0;\n+\t  p = (char *) index (q+1, '`');\n+\t  q = 0;\n+\n+#define MUL \"multiple definition of \"\n+#define UND \"undefined reference to \"\n+\n+\t  if (p && (p - line > sizeof (MUL)))\n+\t    {\n+\t      char *beg = p - sizeof (MUL) + 1;\n+\t      *p = 0;\n+\t      if (!strcmp (beg, MUL) || !strcmp (beg, UND))\n+\t\tp++, q = (char *) index (p, '\\'');\n+\t    }\n+\t  if (q)\n+\t    *q = 0, dem = demangled_hash_lookup (p, false);\n+\t  if (dem)\n+\t    sym = symbol_hash_lookup (dem->mangled, false);\n+\t}\n+\n+      if (sym && sym->tweaked)\n+\treturn 0;\n+      if (sym && !sym->tweaking)\n+\t{\n+\t  if (tlink_verbose >= 2)\n+\t    fprintf (stderr, \"collect: tweaking %s in %s\\n\",\n+\t\t     sym->root.string, sym->file->root.string);\n+\t  sym->tweaking = 1;\n+\t  file_push (sym->file);\n+\t}\n+\t\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+    }\n+\n+  return (file_stack != NULL);\n+}\n+\n+void\n+do_tlink (ld_argv, object_lst)\n+     char **ld_argv, **object_lst;\n+{\n+  int exit = tlink_execute (\"ld\", ld_argv, ldout);\n+\n+  tlink_init ();\n+\n+  if (exit)\n+    {\n+      int i = 0;\n+\n+      /* Until collect does a better job of figuring out which are object\n+\t files, assume that everything on the command line could be.  */\n+      if (read_repo_files (ld_argv))\n+\twhile (exit && i++ < MAX_ITERATIONS)\n+\t  {\n+\t    if (tlink_verbose >= 3)\n+\t      dump_file (ldout);\n+\t    demangle_new_symbols ();\n+\t    if (! scan_linker_output (ldout))\n+\t      break;\n+\t    if (! recompile_files ())\n+\t      break;\n+\t    if (tlink_verbose)\n+\t      fprintf (stderr, \"collect: relinking\\n\");\n+\t    exit = tlink_execute (\"ld\", ld_argv, ldout);\n+\t  }\n+    }\n+\n+  dump_file (ldout);\n+  unlink (ldout);\n+  if (exit)\n+    {\n+      error (\"ld returned %d exit status\", exit);\n+      collect_exit (exit);\n+    }\n+}"}]}