{"sha": "2f939d94068972c5b14ab98f50c6789621810a4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5MzlkOTQwNjg5NzJjNWIxNGFiOThmNTBjNjc4OTYyMTgxMGE0YQ==", "commit": {"author": {"name": "Theodore Papadopoulo", "email": "Theodore.Papadopoulo@sophia.inria.fr", "date": "2000-03-23T00:41:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-23T00:41:05Z"}, "message": "builtin.c (get_pointer_alignment): Use DECL_P and TYPE_P macros.\n\n        * builtin.c (get_pointer_alignment): Use DECL_P and TYPE_P macros.\n\t* c-common.c (decl_attributes,check_format_info,truthvalue_conversion,\n\t  c_get_alias_set): Likewise.\n\t* c-decl.c (duplicate_decls): Likewise.\n\t* c-typeck.c (default_conversion,build_unary_op): Likewise.\n\t* calls.c (initialize_argument_information): Likewise.\n\t* dwarf2out.c (decl_class_context,add_abstract_origin_attribute):\n\tLikewise.\n\t* dwarfout.c (decl_class_context,output_type): Likewise.\n\t* expr.c (get_inner_reference): Likewise.\n\t* fold-const.c (simple_operand_p,fold): Likewise.\n\t* function.c (aggregate_value_p): Likewise.\n\t* stmt.c (expand_asm_operands): Likewise.\n\t* varasm.c (named_section): Likewise.\n\n\t* call.c (check_dtor_name,build_new_method_call): Likewise.\n\t* decl.c (push_class_binding,poplevel,pushtag,lookup_namespace_name,\n\tmake_typename_type,check_initializer,cp_finish_decl,xref_tag): Likewise.\n\t* decl2.c (grokfield,build_expr_from_tree,build_expr_from_tree,\n\tdecl_namespace,arg_assoc_template_arg,arg_assoc,\n\tvalidate_nonmember_using_decl,do_class_using_decl): Likewise.\n\t* error.c (dump_template_argument,dump_expr,cp_file_of,cp_line_of,\n\targs_to_string): Likewise.\n\t* friend.c (is_friend): Likewise.\n\t* lex.c (note_got_semicolon,note_list_got_semicolon,is_global): Likewise.\n\t* method.c (build_overload_nested_name,build_overload_value,\n\tbuild_qualified_name,build_qualified_name,hack_identifier): Likewise.\n\t* parse.y (typename_sub,typename_sub1): Likewise.\n\t* pt.c (push_inline_template_parms_recursive,check_template_shadow,\n\tprocess_partial_specialization,convert_template_argument,\n\ttemplate_args_equal,add_pending_template,lookup_template_class,\n\tfor_each_template_parm_r,maybe_fold_nontype_arg,\n\ttsubst,instantiate_template,type_unification_real,unify,\n\tinstantiate_pending_templates,set_mangled_name_for_template_decl):\n\tLikewise.\n\t* repo.c (repo_get_id,repo_template_used): Likewise.\n\t* search.c (lookup_field_1): Likewise.\n\t* tree.c (walk_tree,get_type_decl,cp_tree_equal,member_p): Likewise.\n\t* xref.c (classname): Likewise.\n\nFrom-SVN: r32698", "tree": {"sha": "3588211f05cbc41af8eb3dfc8cba0426d5fc4960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3588211f05cbc41af8eb3dfc8cba0426d5fc4960"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f939d94068972c5b14ab98f50c6789621810a4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f939d94068972c5b14ab98f50c6789621810a4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f939d94068972c5b14ab98f50c6789621810a4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f939d94068972c5b14ab98f50c6789621810a4a/comments", "author": {"login": "papadop", "id": 1387516, "node_id": "MDQ6VXNlcjEzODc1MTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1387516?v=4", "gravatar_id": "", "url": "https://api.github.com/users/papadop", "html_url": "https://github.com/papadop", "followers_url": "https://api.github.com/users/papadop/followers", "following_url": "https://api.github.com/users/papadop/following{/other_user}", "gists_url": "https://api.github.com/users/papadop/gists{/gist_id}", "starred_url": "https://api.github.com/users/papadop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/papadop/subscriptions", "organizations_url": "https://api.github.com/users/papadop/orgs", "repos_url": "https://api.github.com/users/papadop/repos", "events_url": "https://api.github.com/users/papadop/events{/privacy}", "received_events_url": "https://api.github.com/users/papadop/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a574f8e87319a6229ad1b1a91d0c3a34e605a1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a574f8e87319a6229ad1b1a91d0c3a34e605a1f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a574f8e87319a6229ad1b1a91d0c3a34e605a1f0"}], "stats": {"total": 253, "additions": 136, "deletions": 117}, "files": [{"sha": "99faa4f04dfa9f3b8fcda00e906a877eb4e5fc7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1,3 +1,20 @@\n+2000-03-22  Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>\n+\n+        * builtin.c (get_pointer_alignment): Use DECL_P and TYPE_P macros.\n+\t* c-common.c (decl_attributes,check_format_info,truthvalue_conversion,\n+\t  c_get_alias_set): Likewise.\n+\t* c-decl.c (duplicate_decls): Likewise.\n+\t* c-typeck.c (default_conversion,build_unary_op): Likewise.\n+\t* calls.c (initialize_argument_information): Likewise.\n+\t* dwarf2out.c (decl_class_context,add_abstract_origin_attribute):\n+\tLikewise.\n+\t* dwarfout.c (decl_class_context,output_type): Likewise.\n+\t* expr.c (get_inner_reference): Likewise.\n+\t* fold-const.c (simple_operand_p,fold): Likewise.\n+\t* function.c (aggregate_value_p): Likewise.\n+\t* stmt.c (expand_asm_operands): Likewise.\n+\t* varasm.c (named_section): Likewise.\n+\n 2000-03-22  Jason Merrill  <jason@casey.cygnus.com>\n \n \tImplement dwarf2 exception handling for the ARM."}, {"sha": "f03b70e0a1d4512481b3a6f3ae9226c4d237b94f", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -158,7 +158,7 @@ get_pointer_alignment (exp, max_align)\n \t  exp = TREE_OPERAND (exp, 0);\n \t  if (TREE_CODE (exp) == FUNCTION_DECL)\n \t    align = FUNCTION_BOUNDARY;\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+\t  else if (DECL_P (exp))\n \t    align = DECL_ALIGN (exp);\n #ifdef CONSTANT_ALIGNMENT\n \t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')"}, {"sha": "9ef9590ff9a7709f2a8465764ef211a7f53981c3", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -494,13 +494,13 @@ decl_attributes (node, attributes, prefix_attributes)\n   if (attrtab_idx == 0)\n     init_attributes ();\n \n-  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'd')\n+  if (DECL_P (node))\n     {\n       decl = node;\n       type = TREE_TYPE (decl);\n       is_type = TREE_CODE (node) == TYPE_DECL;\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't')\n+  else if (TYPE_P (node))\n     type = node, is_type = 1;\n \n #ifdef PRAGMA_INSERT_ATTRIBUTES\n@@ -1954,8 +1954,7 @@ check_format_info (info, params)\n \t  && (TYPE_READONLY (cur_type)\n \t      || (cur_param != 0\n \t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n-\t\t      || (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'd'\n-\t\t\t  && TREE_READONLY (cur_param))))))\n+\t\t      || (DECL_P (cur_param) && TREE_READONLY (cur_param))))))\n \twarning (\"writing into constant object (arg %d)\", arg_num);\n \n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n@@ -2882,7 +2881,7 @@ truthvalue_conversion (expr)\n     case ADDR_EXPR:\n       /* If we are taking the address of a external decl, it might be zero\n \t if it is weak, so we cannot optimize.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (expr, 0))) == 'd'\n+      if (DECL_P (TREE_OPERAND (expr, 0))\n \t  && DECL_EXTERNAL (TREE_OPERAND (expr, 0)))\n \tbreak;\n \n@@ -3315,8 +3314,7 @@ c_get_alias_set (t)\n   if (t == error_mark_node)\n     return 0;\n \n-  type = (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    ? t : TREE_TYPE (t);\n+  type = (TYPE_P (t)) ? t : TREE_TYPE (t);\n \n   if (type == error_mark_node)\n     return 0;"}, {"sha": "a5cc45826a16b18c0ede4b76f92baf8322f11499", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1380,7 +1380,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   tree newtype = TREE_TYPE (newdecl);\n   int errmsg = 0;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (olddecl)) == 'd')\n+  if (DECL_P (olddecl))\n     DECL_MACHINE_ATTRIBUTES (newdecl)\n       =  merge_machine_decl_attributes (olddecl, newdecl);\n "}, {"sha": "abdd2a72812103cc358d247c8b87936c9e6cd9b4", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -950,8 +950,7 @@ default_conversion (exp)\n       int constp = 0;\n       int volatilep = 0;\n \n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r'\n-\t  || TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r' || DECL_P (exp))\n \t{\n \t  constp = TREE_READONLY (exp);\n \t  volatilep = TREE_THIS_VOLATILE (exp);\n@@ -2987,8 +2986,7 @@ build_unary_op (code, xarg, noconvert)\n          to which the address will point.  Note that you can't get a\n \t restricted pointer by taking the address of something, so we\n \t only have to deal with `const' and `volatile' here.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'd'\n-\t  || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n+      if (DECL_P (arg) || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n \t{\n \t  if (TREE_READONLY (arg) || TREE_THIS_VOLATILE (arg))\n \t    argtype = c_build_type_variant (argtype,"}, {"sha": "4c8d573d222f2a6dd0b364bf8cc708fb63e0682b", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1086,9 +1086,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t         make a bitwise copy of the argument. */\n \t\t \n \t      if (TREE_CODE (args[i].tree_value) == TARGET_EXPR\n-\t\t  && (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND\n-\t\t\t\t\t\t  (args[i].tree_value, 1)))\n-\t\t      == 'd')\n+\t\t  && (DECL_P (TREE_OPERAND (args[i].tree_value, 1)))\n \t\t  && ! REG_P (DECL_RTL (TREE_OPERAND (args[i].tree_value, 1))))\n \t\targs[i].tree_value = TREE_OPERAND (args[i].tree_value, 1);\n "}, {"sha": "433c62913979e01d8ad4aff0f79608d943689f6b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1,3 +1,30 @@\n+2000-03-20 Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>\n+\n+\t* call.c (check_dtor_name,build_new_method_call): Likewise.\n+\t* decl.c (push_class_binding,poplevel,pushtag,lookup_namespace_name,\n+\tmake_typename_type,check_initializer,cp_finish_decl,xref_tag): Likewise.\n+\t* decl2.c (grokfield,build_expr_from_tree,build_expr_from_tree,\n+\tdecl_namespace,arg_assoc_template_arg,arg_assoc,\n+\tvalidate_nonmember_using_decl,do_class_using_decl): Likewise.\n+\t* error.c (dump_template_argument,dump_expr,cp_file_of,cp_line_of,\n+\targs_to_string): Likewise.\n+\t* friend.c (is_friend): Likewise.\n+\t* lex.c (note_got_semicolon,note_list_got_semicolon,is_global): Likewise.\n+\t* method.c (build_overload_nested_name,build_overload_value,\n+\tbuild_qualified_name,build_qualified_name,hack_identifier): Likewise.\n+\t* parse.y (typename_sub,typename_sub1): Likewise.\n+\t* pt.c (push_inline_template_parms_recursive,check_template_shadow,\n+\tprocess_partial_specialization,convert_template_argument,\n+\ttemplate_args_equal,add_pending_template,lookup_template_class,\n+\tfor_each_template_parm_r,maybe_fold_nontype_arg,\n+\ttsubst,instantiate_template,type_unification_real,unify,\n+\tinstantiate_pending_templates,set_mangled_name_for_template_decl):\n+\tLikewise.\n+\t* repo.c (repo_get_id,repo_template_used): Likewise.\n+\t* search.c (lookup_field_1): Likewise.\n+\t* tree.c (walk_tree,get_type_decl,cp_tree_equal,member_p): Likewise.\n+\t* xref.c (classname): Likewise.\n+\t\n 2000-03-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (BINFO_FOR_VBASE): Adjust documentation."}, {"sha": "6e7c4fb6670478e74068eba9fe678266e3e29b9b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -189,7 +189,7 @@ check_dtor_name (basetype, name)\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     name = TREE_TYPE (name);\n-  else if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+  else if (TYPE_P (name))\n     /* OK */;\n   else if (TREE_CODE (name) == IDENTIFIER_NODE)\n     {\n@@ -4192,7 +4192,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     {\n       explicit_targs = TREE_OPERAND (name, 1);\n       name = TREE_OPERAND (name, 0);\n-      if (TREE_CODE_CLASS (TREE_CODE (name)) == 'd')\n+      if (DECL_P (name))\n \tname = DECL_NAME (name);\n       else\n \t{"}, {"sha": "491315aaba7630b7f60aef06212a3b0b1f9bf703", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1128,8 +1128,7 @@ push_class_binding (id, decl)\n \t    context = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n \t  else\n \t    {\n-\t      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd',\n-\t\t\t\t  0);\n+\t      my_friendly_assert (DECL_P (decl), 0);\n \t      context = CP_DECL_CONTEXT (decl);\n \t    }\n \n@@ -1453,7 +1452,7 @@ poplevel (keep, reverse, functionbody)\n \t  decl = link;\n \t  if (TREE_CODE (decl) == TREE_LIST)\n \t    decl = TREE_VALUE (decl);\n-\t  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+\t  if (DECL_P (decl))\n \t    pop_binding (DECL_NAME (decl), decl);\n \t  else if (TREE_CODE (decl) == OVERLOAD)\n \t    pop_binding (DECL_NAME (OVL_FUNCTION (decl)), decl);\n@@ -2788,8 +2787,7 @@ pushtag (name, type, globalize)\n \n \t      if (! globalize)\n \t\tcontext = cs;\n-\t      else if (cs != NULL_TREE\n-\t\t       && TREE_CODE_CLASS (TREE_CODE (cs)) == 't')\n+\t      else if (cs != NULL_TREE && TYPE_P (cs))\n \t\t/* When declaring a friend class of a local class, we want\n \t\t   to inject the newly named class into the scope\n \t\t   containing the local class, not the namespace scope.  */\n@@ -5229,7 +5227,7 @@ lookup_namespace_name (namespace, name)\n       name = TREE_OPERAND (name, 0);\n       if (TREE_CODE (name) == OVERLOAD)\n \tname = DECL_NAME (OVL_CURRENT (name));\n-      else if (TREE_CODE_CLASS (TREE_CODE (name)) == 'd')\n+      else if (DECL_P (name))\n \tname = DECL_NAME (name);\n     }\n \n@@ -5379,7 +5377,7 @@ make_typename_type (context, name, complain)\n {\n   tree fullname;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+  if (TYPE_P (name))\n     {\n       if (!(TYPE_LANG_SPECIFIC (name)\n \t    && (CLASSTYPE_IS_TEMPLATE (name)\n@@ -7549,7 +7547,7 @@ check_initializer (decl, init)\n     }\n   else if (DECL_EXTERNAL (decl))\n     ;\n-  else if (TREE_CODE_CLASS (TREE_CODE (type)) == 't'\n+  else if (TYPE_P (type)\n \t   && (IS_AGGR_TYPE (type) || TYPE_NEEDS_CONSTRUCTING (type)))\n     {\n       tree core_type = strip_array_types (type);\n@@ -7902,7 +7900,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n   if (type == error_mark_node)\n     return;\n-\n+  \n   /* Add this declaration to the statement-tree.  */\n   if (building_stmt_tree () && at_function_scope_p ())\n     add_decl_stmt (decl);\n@@ -8050,7 +8048,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       {\n \ttree context = CP_DECL_CONTEXT (decl);\n \tif (context\n-\t    && TREE_CODE_CLASS (TREE_CODE (context)) == 't'\n+\t    && TYPE_P (context)\n \t    && (TREE_CODE (decl) == VAR_DECL\n \t\t/* We also have a pushclass done that we need to undo here\n \t\t   if we're at top level and declare a method.  */\n@@ -12376,7 +12374,7 @@ xref_tag (code_type_node, name, globalize)\n \n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+  if (TYPE_P (name))\n     {\n       t = name;\n       name = TYPE_IDENTIFIER (t);"}, {"sha": "5c1f7f8bb307d577883d41e96ce959d0ed2f9ec5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1676,8 +1676,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t\t static, since references are initialized with the address.  */\n \t      if (TREE_CODE (TREE_TYPE (value)) != REFERENCE_TYPE\n \t\t  || (TREE_STATIC (init) == 0\n-\t\t      && (TREE_CODE_CLASS (TREE_CODE (init)) != 'd'\n-\t\t\t  || DECL_EXTERNAL (init) == 0)))\n+\t\t      && (!DECL_P (init) || DECL_EXTERNAL (init) == 0)))\n \t\t{\n \t\t  error (\"field initializer is not constant\");\n \t\t  init = error_mark_node;\n@@ -3878,7 +3877,7 @@ build_expr_from_tree (t)\n     case ALIGNOF_EXPR:\n       {\n \ttree r = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\tif (TREE_CODE_CLASS (TREE_CODE (r)) != 't')\n+\tif (!TYPE_P (r))\n \t  r = TREE_TYPE (r);\n \treturn TREE_CODE (t) == SIZEOF_EXPR ? c_sizeof (r) : c_alignof (r);\n       }\n@@ -4046,7 +4045,7 @@ build_expr_from_tree (t)\n       }\n \n     case TYPEID_EXPR:\n-      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 0))) == 't')\n+      if (TYPE_P (TREE_OPERAND (t, 0)))\n \treturn get_typeid (TREE_OPERAND (t, 0));\n       return build_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n@@ -4473,9 +4472,9 @@ decl_namespace (decl)\n       decl = DECL_CONTEXT (decl);\n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n \treturn decl;\n-      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n+      if (TYPE_P (decl))\n \tdecl = TYPE_STUB_DECL (decl);\n-      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd', 390);\n+      my_friendly_assert (DECL_P (decl), 390);\n     }\n \n   return global_namespace;\n@@ -4656,7 +4655,7 @@ arg_assoc_template_arg (k, arg)\n     }\n   /* It's not a template template argument, but it is a type template\n      argument.  */\n-  else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 't')\n+  else if (TYPE_P (arg))\n     return arg_assoc_type (k, arg);\n   /* It's a non-type template argument.  */\n   else\n@@ -4794,7 +4793,7 @@ arg_assoc (k, n)\n   if (n == error_mark_node)\n     return 0;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (n)) == 't')\n+  if (TYPE_P (n))\n     return arg_assoc_type (k, n);\n \n   if (! type_unknown_p (n))\n@@ -4959,7 +4958,7 @@ validate_nonmember_using_decl (decl, scope, name)\n     }\n   else\n     my_friendly_abort (382);\n-  if (TREE_CODE_CLASS (TREE_CODE (*name)) == 'd')\n+  if (DECL_P (*name))\n     *name = DECL_NAME (*name);\n   /* Make a USING_DECL. */\n   return push_using_decl (*scope, *name);\n@@ -5136,7 +5135,7 @@ do_class_using_decl (decl)\n   tree name, value;\n \n   if (TREE_CODE (decl) != SCOPE_REF\n-      || TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (decl, 0))) != 't')\n+      || !TYPE_P (TREE_OPERAND (decl, 0)))\n     {\n       cp_error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;"}, {"sha": "a0be98f8f5fa56f4473faf8474ba37f197b65852", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -221,8 +221,7 @@ dump_template_argument (arg, flags)\n      tree arg;\n      enum tree_string_flags flags;\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n-      || TREE_CODE (arg) == TEMPLATE_DECL)\n+  if (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL)\n     dump_type (arg, flags & ~TS_AGGR_TAGS);\n   else\n     dump_expr (arg, (flags | TS_EXPR_PARENS) & ~TS_AGGR_TAGS);\n@@ -1965,7 +1964,7 @@ dump_expr (t, flags)\n \t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n \t  OB_PUTS (\"__alignof__ (\");\n \t}\n-      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 0))) == 't')\n+      if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n \tdump_unary_op (\"*\", t, flags | TS_EXPR_PARENS);\n@@ -2165,7 +2164,7 @@ cp_file_of (t)\n {\n   if (TREE_CODE (t) == PARM_DECL && DECL_CONTEXT (t))\n     return DECL_SOURCE_FILE (DECL_CONTEXT (t));\n-  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  else if (TYPE_P (t))\n     return DECL_SOURCE_FILE (TYPE_MAIN_DECL (t));\n   else if (TREE_CODE (t) == OVERLOAD)\n     return DECL_SOURCE_FILE (OVL_FUNCTION (t));\n@@ -2184,7 +2183,7 @@ cp_line_of (t)\n       && TYPE_MAIN_DECL (TREE_TYPE (t)))\n     t = TREE_TYPE (t);\n \n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  if (TYPE_P (t))\n     line = DECL_SOURCE_LINE (TYPE_MAIN_DECL (t));\n   else if (TREE_CODE (t) == OVERLOAD)\n     line = DECL_SOURCE_LINE (OVL_FUNCTION (t));\n@@ -2365,7 +2364,7 @@ args_to_string (p, verbose)\n   if (p == NULL_TREE)\n     return \"\";\n \n-  if (TREE_CODE_CLASS (TREE_CODE (TREE_VALUE (p))) == 't')\n+  if (TYPE_P (TREE_VALUE (p)))\n     return type_as_string (p, flags);\n \n   OB_INIT ();"}, {"sha": "fee00a8cf35cd53ffd93c33d4e5b4fa756e174c3", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -42,7 +42,7 @@ is_friend (type, supplicant)\n   if (supplicant == NULL_TREE || type == NULL_TREE)\n     return 0;\n \n-  declp = (TREE_CODE_CLASS (TREE_CODE (supplicant)) == 'd');\n+  declp = DECL_P (supplicant);\n \n   if (declp)\n     /* It's a function decl.  */"}, {"sha": "d90f4723d46a9c594d14d6d754a5bb9b3ba28398", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -2148,7 +2148,7 @@ void\n note_got_semicolon (type)\n      tree type;\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (type)) != 't')\n+  if (!TYPE_P (type))\n     my_friendly_abort (60);\n   if (CLASS_TYPE_P (type))\n     CLASSTYPE_GOT_SEMICOLON (type) = 1;\n@@ -2163,7 +2163,7 @@ note_list_got_semicolon (declspecs)\n   for (link = declspecs; link; link = TREE_CHAIN (link))\n     {\n       tree type = TREE_VALUE (link);\n-      if (TREE_CODE_CLASS (TREE_CODE (type)) == 't')\n+      if (TYPE_P (type))\n \tnote_got_semicolon (type);\n     }\n   clear_anon_tags ();\n@@ -3418,7 +3418,7 @@ is_global (d)\n       case OVERLOAD: d = OVL_FUNCTION (d); continue;\n       case TREE_LIST: d = TREE_VALUE (d); continue;\n       default:\n-        my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (d)) == 'd', 980629);\n+        my_friendly_assert (DECL_P (d), 980629);\n \n \treturn DECL_NAMESPACE_SCOPE_P (d);\n       }"}, {"sha": "9d5defcf09bff9fbcec74b67c96d6f63fa3ef25b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -446,7 +446,7 @@ build_overload_nested_name (decl)\n       build_mangled_name_for_type (context);\n     else\n     {\n-      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+      if (TYPE_P (context))\n         context = TYPE_NAME (context);\n       build_overload_nested_name (context);\n     }\n@@ -692,7 +692,7 @@ build_overload_value (type, value, flags)\n      tree type, value;\n      mangling_flags flags;\n {\n-  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (type)) == 't', 0);\n+  my_friendly_assert (TYPE_P (type), 0);\n \n   while (TREE_CODE (value) == NON_LVALUE_EXPR\n \t || TREE_CODE (value) == NOP_EXPR)\n@@ -1044,7 +1044,7 @@ build_qualified_name (decl)\n   tree context;\n   int i = 1;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n+  if (TYPE_P (decl))\n     decl = TYPE_NAME (decl);\n \n   /* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n@@ -1072,7 +1072,7 @@ build_qualified_name (decl)\n \t  if (check_ktype (context, FALSE) != -1)\n \t    /* Found one!  */\n \t    break;\n-\t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\t  if (TYPE_P (context))\n \t    context = TYPE_NAME (context);\n \t}\n     }\n@@ -1985,7 +1985,7 @@ hack_identifier (value, name)\n \t}\n     }\n \n-  if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n+  if (DECL_P (value) && DECL_NONLOCAL (value))\n     {\n       if (DECL_CLASS_SCOPE_P (value)\n \t  && DECL_CONTEXT (value) != current_class_type)"}, {"sha": "01312a502495c43799b34f0bdace17ad838d5d64", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -7295,7 +7295,7 @@ case 644:\n case 645:\n #line 2947 \"parse.y\"\n {\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n+\t\t  if (TYPE_P (yyvsp[-1].ttype))\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype, /*complain=*/1);\n \t\t  else if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", yyvsp[0].ttype);\n@@ -7329,7 +7329,7 @@ case 649:\n case 650:\n #line 2974 \"parse.y\"\n {\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n+\t\t  if (TYPE_P (yyvsp[-1].ttype))\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype, /*complain=*/1);\n \t\t  else if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", yyvsp[0].ttype);"}, {"sha": "a666fd8819679a2778744cc8359e6ebc4f89b235", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -2945,7 +2945,7 @@ typename_sub:\n typename_sub0:\n \t  typename_sub1 identifier %prec EMPTY\n \t\t{\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n+\t\t  if (TYPE_P ($1))\n \t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n@@ -2972,7 +2972,7 @@ typename_sub1:\n \t\t}\n \t| typename_sub1 typename_sub2\n \t\t{\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n+\t\t  if (TYPE_P ($1))\n \t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", $2);"}, {"sha": "0978ec9e36354b24e87702e7ed205b8c0d8aff7a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -321,7 +321,7 @@ push_inline_template_parms_recursive (parmlist, levels)\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i) \n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (parm)) == 'd', 0);\n+      my_friendly_assert (DECL_P (parm), 0);\n \n       switch (TREE_CODE (parm))\n \t{\n@@ -1666,8 +1666,7 @@ check_template_shadow (decl)\n      that OLDDECL might be an OVERLOAD (or perhaps even an\n      ERROR_MARK), so we can't just blithely assume it to be a _DECL\n      node.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (olddecl)) != 'd'\n-      || !DECL_TEMPLATE_PARM_P (olddecl))\n+  if (!DECL_P (olddecl) || !DECL_TEMPLATE_PARM_P (olddecl))\n     return;\n \n   /* We check for decl != olddecl to avoid bogus errors for using a\n@@ -2118,7 +2117,7 @@ process_partial_specialization (decl)\n     {\n       tree arg = TREE_VEC_ELT (inner_args, i);\n       if (/* These first two lines are the `non-type' bit.  */\n-\t  TREE_CODE_CLASS (TREE_CODE (arg)) != 't'\n+\t  !TYPE_P (arg)\n \t  && TREE_CODE (arg) != TEMPLATE_DECL\n \t  /* This next line is the `argument expression is not just a\n \t     simple identifier' condition and also the `specialized\n@@ -3166,7 +3165,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n   else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n     arg = CLASSTYPE_TI_TEMPLATE (arg);\n \n-  is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n+  is_type = TYPE_P (arg) || is_tmpl_type;\n \n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n@@ -3420,7 +3419,7 @@ template_args_equal (ot, nt)\n   if (TREE_CODE (nt) == TREE_VEC)\n     /* For member templates */\n     return comp_template_args (ot, nt);\n-  else if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n+  else if (TYPE_P (ot))\n     return same_type_p (ot, nt);\n   else\n     return (cp_tree_equal (ot, nt) > 0);\n@@ -3575,12 +3574,7 @@ static void\n add_pending_template (d)\n      tree d;\n {\n-  tree ti;\n-\n-  if (TREE_CODE_CLASS (TREE_CODE (d)) == 't')\n-    ti = CLASSTYPE_TEMPLATE_INFO (d);\n-  else\n-    ti = DECL_TEMPLATE_INFO (d);\n+  tree ti = (TYPE_P (d)) ? CLASSTYPE_TEMPLATE_INFO (d) : DECL_TEMPLATE_INFO (d);\n \n   if (TI_PENDING_TEMPLATE_FLAG (ti))\n     return;\n@@ -3699,8 +3693,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t}\n     }\n   else if (TREE_CODE (d1) == ENUMERAL_TYPE \n-\t   || (TREE_CODE_CLASS (TREE_CODE (d1)) == 't' \n-\t       && IS_AGGR_TYPE (d1)))\n+\t   || (TYPE_P (d1) && IS_AGGR_TYPE (d1)))\n     {\n       template = TYPE_TI_TEMPLATE (d1);\n       d1 = DECL_NAME (template);\n@@ -3864,8 +3857,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t\t scopes.  */\n \t      for (ctx = current_class_type; \n \t\t   ctx; \n-\t\t   ctx = (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't') \n-\t\t     ? TYPE_CONTEXT (ctx) : DECL_CONTEXT (ctx))\n+\t\t   ctx = (TYPE_P (ctx)) ? TYPE_CONTEXT (ctx) : DECL_CONTEXT (ctx))\n \t\tif (same_type_p (ctx, template_type))\n \t\t  break;\n \t      \n@@ -4065,7 +4057,7 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n   tree_fn_t fn = pfd->fn;\n   void *data = pfd->data;\n   \n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n+  if (TYPE_P (t)\n       && for_each_template_parm (TYPE_CONTEXT (t), fn, data))\n     return error_mark_node;\n \n@@ -5136,8 +5128,7 @@ maybe_fold_nontype_arg (arg)\n   if (! processing_template_decl)\n     return arg;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't'\n-      && !uses_template_parms (arg))\n+  if (!TYPE_P (arg) && !uses_template_parms (arg))\n     {\n       /* Sometimes, one of the args was an expression involving a\n \t template constant parameter, like N - 1.  Now that we've\n@@ -6161,7 +6152,7 @@ tsubst (t, args, complain, in_decl)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+  if (DECL_P (t))\n     return tsubst_decl (t, args, type, in_decl);\n \n   switch (TREE_CODE (t))\n@@ -6283,8 +6274,7 @@ tsubst (t, args, complain, in_decl)\n \t      {\n \t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t\t  {\n-\t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n-\t\t\t\t\t== 't', 0);\n+\t\t    my_friendly_assert (TYPE_P (arg), 0);\n \t\t    return cp_build_qualified_type_real\n \t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t),\n \t\t       complain);\n@@ -7430,7 +7420,7 @@ instantiate_template (tmpl, targ_ptr)\n   while (i--)\n     {\n       tree t = TREE_VEC_ELT (inner_args, i);\n-      if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+      if (TYPE_P (t))\n \t{\n \t  tree nt = target_type (t);\n \t  if (IS_AGGR_TYPE (nt) && decl_function_context (TYPE_MAIN_DECL (nt)))\n@@ -7750,7 +7740,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t{\n \t  tree type;\n \n-\t  if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n+\t  if (!TYPE_P (arg))\n \t    type = TREE_TYPE (arg);\n \t  else\n \t    {\n@@ -7772,7 +7762,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t  return 1;\n \t}\n \t\n-      if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n+      if (!TYPE_P (arg))\n \t{\n \t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n \t  if (type_unknown_p (arg))\n@@ -8246,7 +8236,7 @@ unify (tparms, targs, parm, arg, strict)\n   /* Immediately reject some pairs that won't unify because of\n      cv-qualification mismatches.  */\n   if (TREE_CODE (arg) == TREE_CODE (parm)\n-      && TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n+      && TYPE_P (arg)\n       /* We check the cv-qualifiers when unifying with template type\n \t parameters below.  We want to allow ARG `const T' to unify with\n \t PARM `T' for example, when computing which of two templates\n@@ -9649,7 +9639,7 @@ instantiate_pending_templates ()\n \t  input_filename = SRCLOC_FILE (srcloc);\n \t  lineno = SRCLOC_LINE (srcloc);\n \n-\t  if (TREE_CODE_CLASS (TREE_CODE (instantiation)) == 't')\n+\t  if (TYPE_P (instantiation))\n \t    {\n \t      tree fn;\n \n@@ -9960,7 +9950,7 @@ set_mangled_name_for_template_decl (decl)\n      mangled name. Unfortunately, build_decl_overload_real does not\n      get the decl to mangle, so it relies on the current\n      namespace. Therefore, we set that here temporarily. */\n-  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd', 980702);\n+  my_friendly_assert (DECL_P (decl), 980702);\n   saved_namespace = current_namespace;\n   current_namespace = CP_DECL_CONTEXT (decl);  \n "}, {"sha": "99d53f089d1eff9f0aafb928b1d1aa37ef863506", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -95,7 +95,7 @@ static tree\n repo_get_id (t)\n      tree t;\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  if (TYPE_P (t))\n     {\n       /* If we're not done setting up the class, we may not have set up\n \t the vtable, so going ahead would give the wrong answer.\n@@ -126,12 +126,12 @@ repo_template_used (t)\n   if (id == NULL_TREE)\n     return;\n   \n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  if (TYPE_P (t))\n     {\n       if (IDENTIFIER_REPO_CHOSEN (id))\n \tmark_class_instantiated (t, 0);\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+  else if (DECL_P (t))\n     {\n       if (IDENTIFIER_REPO_CHOSEN (id))\n \tmark_decl_instantiated (t, 0);"}, {"sha": "cafdfc2ee6333fc41a0fb28476fed339ade8eab4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -644,7 +644,7 @@ lookup_field_1 (type, name)\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;\n #endif /* GATHER_STATISTICS */\n-      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (field)) == 'd', 0);\n+      my_friendly_assert (DECL_P (field), 0);\n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{"}, {"sha": "d1c7d2d54ae19e67a4279d75075fed3081ccef68", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1262,7 +1262,7 @@ walk_tree (tp, func, data)\n \t{\n \t  if (code == DECL_STMT \n \t      && DECL_STMT_DECL (*tp) \n-\t      && TREE_CODE_CLASS (TREE_CODE (DECL_STMT_DECL (*tp))) == 'd')\n+\t      && DECL_P (DECL_STMT_DECL (*tp)))\n \t    {\n \t      /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n \t\t into declarations that are just mentioned, rather than\n@@ -1730,7 +1730,7 @@ get_type_decl (t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     return t;\n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+  if (TYPE_P (t))\n     return TYPE_STUB_DECL (t);\n   \n   my_friendly_abort (42);\n@@ -1915,7 +1915,7 @@ cp_tree_equal (t1, t2)\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t1, 0)) != TREE_CODE (TREE_OPERAND (t2, 0)))\n \treturn 0;\n-      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t1, 0))) == 't')\n+      if (TYPE_P (TREE_OPERAND (t1, 0)))\n \treturn same_type_p (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n       break;\n \n@@ -2051,8 +2051,8 @@ int\n member_p (decl)\n      tree decl;\n {\n-  tree ctx = DECL_CONTEXT (decl);\n-  return (ctx && TREE_CODE_CLASS (TREE_CODE (ctx)) == 't');\n+  const tree ctx = DECL_CONTEXT (decl);\n+  return (ctx && TYPE_P (ctx));\n }\n \n /* Create a placeholder for member access where we don't actually have an"}, {"sha": "9a1fd976202695501f755c658a16cd3be3363541", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -541,9 +541,9 @@ static const char *\n classname (cls)\n      tree cls;\n {\n-  if (cls && TREE_CODE_CLASS (TREE_CODE (cls)) == 't')\n+  if (cls && TYPE_P (cls))\n     cls = TYPE_NAME (cls);\n-  if (cls && TREE_CODE_CLASS (TREE_CODE (cls)) == 'd')\n+  if (cls && DECL_P (cls))\n     cls = DECL_NAME (cls);\n   if (cls && TREE_CODE (cls) == IDENTIFIER_NODE)\n     return IDENTIFIER_POINTER (cls);"}, {"sha": "6510bc9b28a0996bc9d10d2802a2bb6f086d1b77", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -3467,7 +3467,7 @@ decl_class_context (decl)\n     context = TYPE_MAIN_VARIANT\n       (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n \n-  if (context && TREE_CODE_CLASS (TREE_CODE (context)) != 't')\n+  if (context && !TYPE_P (context))\n     context = NULL_TREE;\n \n   return context;\n@@ -7386,9 +7386,9 @@ add_abstract_origin_attribute (die, origin)\n \tgen_abstract_function (fn);\n     }\n \n-  if (TREE_CODE_CLASS (TREE_CODE (origin)) == 'd')\n+  if (DECL_P (origin))\n     origin_die = lookup_decl_die (origin);\n-  else if (TREE_CODE_CLASS (TREE_CODE (origin)) == 't')\n+  else if (TYPE_P (origin))\n     origin_die = lookup_type_die (origin);\n \n   if (origin_die == NULL)"}, {"sha": "400dc785ca134f528b11af6d99e9fc9fd3ed7589", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1217,7 +1217,7 @@ decl_class_context (decl)\n     context = TYPE_MAIN_VARIANT\n       (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n \n-  if (context && TREE_CODE_CLASS (TREE_CODE (context)) != 't')\n+  if (context && !TYPE_P (context))\n     context = NULL_TREE;\n \n   return context;\n@@ -4287,7 +4287,7 @@ output_type (type, containing_scope)\n      written out yet, writing it out will cover this one, too.  */\n \n   if (TYPE_CONTEXT (type)\n-      && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'\n+      && TYPE_P (TYPE_CONTEXT (type))\n       && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n     {\n       output_type (TYPE_CONTEXT (type), containing_scope);"}, {"sha": "09d4063dcd23fbd6a248b9d4cdeff5593bcd332f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -5094,7 +5094,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n       exp = TREE_OPERAND (exp, 0);\n     }\n \n-  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+  if (DECL_P (exp))\n     alignment = MIN (alignment, DECL_ALIGN (exp));\n   else if (TREE_TYPE (exp) != 0)\n     alignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));"}, {"sha": "0f38f7f1339cd0b3629ae410eecb327ea1e00b98", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -3181,7 +3181,7 @@ simple_operand_p (exp)\n     exp = TREE_OPERAND (exp, 0);\n \n   return (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c'\n-\t  || (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+\t  || (DECL_P (exp)\n \t      && ! TREE_ADDRESSABLE (exp)\n \t      && ! TREE_THIS_VOLATILE (exp)\n \t      && ! DECL_NONLOCAL (exp)\n@@ -6968,10 +6968,10 @@ fold (expr)\n \n       /* If the second operand is simpler than the third, swap them\n \t since that produces better jump optimization results.  */\n-      if ((TREE_CONSTANT (arg1) || TREE_CODE_CLASS (TREE_CODE (arg1)) == 'd'\n+      if ((TREE_CONSTANT (arg1) || DECL_P (arg1)\n \t   || TREE_CODE (arg1) == SAVE_EXPR)\n \t  && ! (TREE_CONSTANT (TREE_OPERAND (t, 2))\n-\t\t|| TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 2))) == 'd'\n+\t\t|| DECL_P (TREE_OPERAND (t, 2))\n \t\t|| TREE_CODE (TREE_OPERAND (t, 2)) == SAVE_EXPR))\n \t{\n \t  /* See if this can be inverted.  If it can't, possibly because"}, {"sha": "60535922c4b0e7cc3adecf51eed1e5322be5a8ee", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -4013,11 +4013,8 @@ aggregate_value_p (exp)\n {\n   int i, regno, nregs;\n   rtx reg;\n-  tree type;\n-  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 't')\n-    type = exp;\n-  else\n-    type = TREE_TYPE (exp);\n+\n+  tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);\n \n   if (RETURN_IN_MEMORY (type))\n     return 1;"}, {"sha": "6ac6f6ec552d6c1f873b39b93377ee2c414ef359", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -1514,7 +1514,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       real_output_rtx[i] = NULL_RTX;\n       if ((TREE_CODE (val) == INDIRECT_REF\n \t   && allows_mem)\n-\t  || (TREE_CODE_CLASS (TREE_CODE (val)) == 'd'\n+\t  || (DECL_P (val)\n \t      && (allows_mem || GET_CODE (DECL_RTL (val)) == REG)\n \t      && ! (GET_CODE (DECL_RTL (val)) == REG\n \t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n@@ -1990,7 +1990,7 @@ warn_if_unused_value (exp)\n       \n     default:\n       /* Referencing a volatile value is a side effect, so don't warn.  */\n-      if ((TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+      if ((DECL_P (exp)\n \t   || TREE_CODE_CLASS (TREE_CODE (exp)) == 'r')\n \t  && TREE_THIS_VOLATILE (exp))\n \treturn 0;"}, {"sha": "3aaca2aa6d465afe4c1c82d5a3c2f1dfac80d7fd", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f939d94068972c5b14ab98f50c6789621810a4a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2f939d94068972c5b14ab98f50c6789621810a4a", "patch": "@@ -301,8 +301,7 @@ named_section (decl, name, reloc)\n      const char *name;\n      int reloc ATTRIBUTE_UNUSED;\n {\n-  if (decl != NULL_TREE\n-      && TREE_CODE_CLASS (TREE_CODE (decl)) != 'd')\n+  if (decl != NULL_TREE && !DECL_P (decl))\n     abort ();\n   if (name == NULL)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n@@ -1727,8 +1726,7 @@ assemble_external (decl)\n      tree decl ATTRIBUTE_UNUSED;\n {\n #ifdef ASM_OUTPUT_EXTERNAL\n-  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n-      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))\n+  if (DECL_P (decl) && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))\n     {\n       rtx rtl = DECL_RTL (decl);\n "}]}