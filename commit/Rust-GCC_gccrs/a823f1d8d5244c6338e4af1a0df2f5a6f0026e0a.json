{"sha": "a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyM2YxZDhkNTI0NGM2MzM4ZTRhZjFhMGRmMmY1YTZmMDAyNmUwYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-22T23:46:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-22T23:46:27Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r820", "tree": {"sha": "041fa8d3066b5341e47b5f6c534407bd5e6b8083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/041fa8d3066b5341e47b5f6c534407bd5e6b8083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a/comments", "author": null, "committer": null, "parents": [{"sha": "cd2b37d9f7d7ea299d071d64641bc3ae105fa808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd2b37d9f7d7ea299d071d64641bc3ae105fa808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd2b37d9f7d7ea299d071d64641bc3ae105fa808"}], "stats": {"total": 113, "additions": 53, "deletions": 60}, "files": [{"sha": "3e0de048d81e4c7bd433ef9aed396ce7dd08ed8a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 53, "deletions": 60, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=a823f1d8d5244c6338e4af1a0df2f5a6f0026e0a", "patch": "@@ -1346,73 +1346,66 @@ dbxout_symbol (decl, local)\n \n       FORCE_TEXT;\n \n-      if (DECL_NAME (decl))\n-\t{\n-\t  /* Nonzero means we must output a tag as well as a typedef.  */\n-\t  int tag_also = ((TREE_CODE (type) == RECORD_TYPE\n-\t\t\t   || TREE_CODE (type) == UNION_TYPE)\n-\t\t\t  && TYPE_NAME (type) == decl);\n+      {\n+\tint tag_needed = 1;\n \n-\t  /* Output typedef name.  */\n-\t  fprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\tif (DECL_NAME (decl))\n+\t  {\n+\t    /* Nonzero means we must output a tag as well as a typedef.  */\n+\t    tag_needed = 0;\n \n-\t  /* Short cut way to output a tag also.  */\n-\t  if (tag_also && use_gdb_dbx_extensions && have_used_extensions)\n-\t    putc ('T', asmfile);\n+\t    /* Output typedef name.  */\n+\t    fprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n-\t  putc ('t', asmfile);\n-\t  current_sym_code = DBX_DECL_STABS_CODE;\n+\t    /* Short cut way to output a tag also.  */\n+\t    if ((TREE_CODE (type) == RECORD_TYPE\n+\t\t || TREE_CODE (type) == UNION_TYPE)\n+\t\t&& TYPE_NAME (type) == decl)\n+\t      {\n+\t\tif (use_gdb_dbx_extensions && have_used_extensions)\n+\t\t  {\n+\t\t    putc ('T', asmfile);\n+\t\t    TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n+\t\t  }\n+\t\telse\n+\t\t  tag_needed = 1;\n+\t      }\n \n-\t  dbxout_type (type, 1, 0);\n-\t  dbxout_finish_symbol (decl);\n+\t    putc ('t', asmfile);\n+\t    current_sym_code = DBX_DECL_STABS_CODE;\n \n-\t  /* Long way to output a tag also.  */\n-\t  if (tag_also && ! (use_gdb_dbx_extensions && have_used_extensions))\n-\t    {\n-\t      /* Output the tag for the type, not using GDB extensions.\n-\t\t This represents `struct foo' as opposed to `typedef foo'.  */\n-\t      /* In C++, the name of a type is the corresponding typedef.\n-\t\t In C, it is an IDENTIFIER_NODE.  */\n-\t      tree name = TYPE_NAME (type);\n-\t      if (TREE_CODE (name) == TYPE_DECL)\n-\t\tname = DECL_NAME (name);\n-\n-\t      current_sym_code = DBX_DECL_STABS_CODE;\n-\t      current_sym_value = 0;\n-\t      current_sym_addr = 0;\n-\t      current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n+\t    dbxout_type (type, 1, 0);\n+\t    dbxout_finish_symbol (decl);\n+\t  }\n \n-\t      fprintf (asmfile, \"%s \\\"%s:T\", ASM_STABS_OP,\n-\t\t       IDENTIFIER_POINTER (name));\n-\t      dbxout_type (type, 1, 0);\n-\t      dbxout_finish_symbol (0);\n-\t    }\n-\t}\n-      else if (TYPE_NAME (type) != 0 && !TREE_ASM_WRITTEN (TYPE_NAME (type)))\n-\t{\n-\t  /* Output a tag (a TYPE_DECL with no name, but the type has a name).\n-\t     This is what represents `struct foo' with no typedef.  */\n-\t  /* In C++, the name of a type is the corresponding typedef.\n-\t     In C, it is an IDENTIFIER_NODE.  */\n-\t  tree name = TYPE_NAME (type);\n-\t  if (TREE_CODE (name) == TYPE_DECL)\n-\t    name = DECL_NAME (name);\n-\n-\t  current_sym_code = DBX_DECL_STABS_CODE;\n-\t  current_sym_value = 0;\n-\t  current_sym_addr = 0;\n-\t  current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n-\n-\t  fprintf (asmfile, \"%s \\\"%s:T\", ASM_STABS_OP,\n-\t\t   IDENTIFIER_POINTER (name));\n-\t  dbxout_type (type, 1, 0);\n-\t  dbxout_finish_symbol (0);\n-\t}\n+\tif (tag_needed && TYPE_NAME (type) != 0\n+\t    && !TREE_ASM_WRITTEN (TYPE_NAME (type)))\n+\t  {\n+\t    /* For a TYPE_DECL with no name, but the type has a name,\n+\t       output a tag.\n+\t       This is what represents `struct foo' with no typedef.  */\n+\t    /* In C++, the name of a type is the corresponding typedef.\n+\t       In C, it is an IDENTIFIER_NODE.  */\n+\t    tree name = TYPE_NAME (type);\n+\t    if (TREE_CODE (name) == TYPE_DECL)\n+\t      name = DECL_NAME (name);\n+\n+\t    current_sym_code = DBX_DECL_STABS_CODE;\n+\t    current_sym_value = 0;\n+\t    current_sym_addr = 0;\n+\t    current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n \n-      /* Prevent duplicate output of a typedef.  */\n-      TREE_ASM_WRITTEN (decl) = 1;\n-      break;\n+\t    fprintf (asmfile, \"%s \\\"%s:T\", ASM_STABS_OP,\n+\t\t     IDENTIFIER_POINTER (name));\n+\t    dbxout_type (type, 1, 0);\n+\t    dbxout_finish_symbol (0);\n+\t  }\n+\n+\t/* Prevent duplicate output of a typedef.  */\n+\tTREE_ASM_WRITTEN (decl) = 1;\n+\tbreak;\n+      }\n \n     case PARM_DECL:\n       /* Parm decls go in their own separate chains"}]}