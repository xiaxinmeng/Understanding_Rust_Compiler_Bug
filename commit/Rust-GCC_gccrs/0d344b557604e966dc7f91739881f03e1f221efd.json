{"sha": "0d344b557604e966dc7f91739881f03e1f221efd", "node_id": "C_kwDOANBUbNoAKDBkMzQ0YjU1NzYwNGU5NjZkYzdmOTE3Mzk4ODFmMDNlMWYyMjFlZmQ", "commit": {"author": {"name": "Szabolcs Nagy", "email": "szabolcs.nagy@arm.com", "date": "2022-02-10T17:42:56Z"}, "committer": {"name": "Szabolcs Nagy", "email": "szabolcs.nagy@arm.com", "date": "2022-05-25T08:17:06Z"}, "message": "aarch64: Fix pac-ret with unusual dwarf in libgcc unwinder [PR104689]\n\nThe RA_SIGN_STATE dwarf pseudo-register is normally only set using the\nDW_CFA_AARCH64_negate_ra_state (== DW_CFA_window_save) operation which\ntoggles the return address signedness state (the default state is 0).\n(It may be set by remember/restore_state CFI too, those save/restore\nthe state of all registers.)\n\nHowever RA_SIGN_STATE can be set directly via DW_CFA_val_expression too.\nGCC does not generate such CFI but some other compilers reportedly do.\n\nNote: the toggle operation must not be mixed with other dwarf register\nrule CFI within the same CIE and FDE.\n\nIn libgcc we assume REG_UNSAVED means the RA_STATE is set using toggle\noperations, otherwise we assume its value is set by other CFI.\n\nlibgcc/ChangeLog:\n\n\tPR target/104689\n\t* config/aarch64/aarch64-unwind.h (aarch64_frob_update_context):\n\tHandle the !REG_UNSAVED case.\n\t* unwind-dw2.c (execute_cfa_program): Fail toggle if !REG_UNSAVED.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/104689\n\t* gcc.target/aarch64/pr104689.c: New test.", "tree": {"sha": "1f4c049fd1aea8937286c1d1d678b3fea1500985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f4c049fd1aea8937286c1d1d678b3fea1500985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d344b557604e966dc7f91739881f03e1f221efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d344b557604e966dc7f91739881f03e1f221efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d344b557604e966dc7f91739881f03e1f221efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d344b557604e966dc7f91739881f03e1f221efd/comments", "author": {"login": "nsz-arm", "id": 30925343, "node_id": "MDQ6VXNlcjMwOTI1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/30925343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nsz-arm", "html_url": "https://github.com/nsz-arm", "followers_url": "https://api.github.com/users/nsz-arm/followers", "following_url": "https://api.github.com/users/nsz-arm/following{/other_user}", "gists_url": "https://api.github.com/users/nsz-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/nsz-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nsz-arm/subscriptions", "organizations_url": "https://api.github.com/users/nsz-arm/orgs", "repos_url": "https://api.github.com/users/nsz-arm/repos", "events_url": "https://api.github.com/users/nsz-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/nsz-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nsz-arm", "id": 30925343, "node_id": "MDQ6VXNlcjMwOTI1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/30925343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nsz-arm", "html_url": "https://github.com/nsz-arm", "followers_url": "https://api.github.com/users/nsz-arm/followers", "following_url": "https://api.github.com/users/nsz-arm/following{/other_user}", "gists_url": "https://api.github.com/users/nsz-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/nsz-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nsz-arm/subscriptions", "organizations_url": "https://api.github.com/users/nsz-arm/orgs", "repos_url": "https://api.github.com/users/nsz-arm/repos", "events_url": "https://api.github.com/users/nsz-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/nsz-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "768f49a20f467648c8e006e2431d0da3eab11846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768f49a20f467648c8e006e2431d0da3eab11846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768f49a20f467648c8e006e2431d0da3eab11846"}], "stats": {"total": 161, "additions": 159, "deletions": 2}, "files": [{"sha": "3b7adbdfe7d6f969e72ce7ef757e572a1ac409ee", "filename": "gcc/testsuite/gcc.target/aarch64/pr104689.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d344b557604e966dc7f91739881f03e1f221efd/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr104689.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d344b557604e966dc7f91739881f03e1f221efd/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr104689.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr104689.c?ref=0d344b557604e966dc7f91739881f03e1f221efd", "patch": "@@ -0,0 +1,149 @@\n+/* PR target/104689. Unwind across pac-ret frames with unusual dwarf.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-fexceptions -O2\" } */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#define die() \\\n+  do { \\\n+    printf (\"%s:%d: reached unexpectedly.\\n\", __FILE__, __LINE__); \\\n+    fflush (stdout); \\\n+    abort (); \\\n+  } while (0)\n+\n+\n+/* Code to invoke unwinding with a logging callback.  */\n+\n+static struct _Unwind_Exception exc;\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  printf (\"%s: CFA: %p PC: %p actions: %d\\n\",\n+\t  __func__,\n+\t  (void *)_Unwind_GetCFA (context),\n+\t  (void *)_Unwind_GetIP (context),\n+\t  (int)actions);\n+  if (actions & _UA_END_OF_STACK)\n+    die ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind (void)\n+{\n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (&exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (&exc, force_unwind_stop, 0);\n+#endif\n+}\n+\n+\n+/* Define functions with unusual pac-ret dwarf via top level asm.  */\n+\n+#define STR(x) #x\n+#define DW_CFA_val_expression 0x16\n+#define RA_SIGN_STATE 34\n+#define DW_OP_lit0 0x30\n+#define DW_OP_lit1 0x31\n+\n+#define cfi_escape(a1, a2, a3, a4) \\\n+  \".cfi_escape \" STR(a1) \", \" STR(a2) \", \" STR(a3) \", \" STR(a4)\n+\n+/* Bytes: 0x16 0x22 0x01 0x30  */\n+#define SET_RA_STATE_0 \\\n+  cfi_escape (DW_CFA_val_expression, RA_SIGN_STATE, 1, DW_OP_lit0)\n+\n+/* Bytes: 0x16 0x22 0x01 0x31  */\n+#define SET_RA_STATE_1 \\\n+  cfi_escape (DW_CFA_val_expression, RA_SIGN_STATE, 1, DW_OP_lit1)\n+\n+/* These function call their argument.  */\n+void unusual_pac_ret (void *);\n+void unusual_no_pac_ret (void *);\n+\n+asm(\"\"\n+\".global unusual_pac_ret\\n\"\n+\".type unusual_pac_ret, %function\\n\"\n+\"unusual_pac_ret:\\n\"\n+\"\t.cfi_startproc\\n\"\n+\"\t\" SET_RA_STATE_0 \"\\n\"\n+\"\thint\t25 // paciasp\\n\"\n+\"\t\" SET_RA_STATE_1 \"\\n\"\n+\"\tstp\tx29, x30, [sp, -16]!\\n\"\n+\"\t.cfi_def_cfa_offset 16\\n\"\n+\"\t.cfi_offset 29, -16\\n\"\n+\"\t.cfi_offset 30, -8\\n\"\n+\"\tmov\tx29, sp\\n\"\n+\"\tblr\tx0\\n\"\n+\"\tldp\tx29, x30, [sp], 16\\n\"\n+\"\t.cfi_restore 30\\n\"\n+\"\t.cfi_restore 29\\n\"\n+\"\t.cfi_def_cfa_offset 0\\n\"\n+\"\thint\t29 // autiasp\\n\"\n+\"\t\" SET_RA_STATE_0 \"\\n\"\n+\"\tret\\n\"\n+\"\t.cfi_endproc\\n\");\n+\n+asm(\"\"\n+\".global unusual_no_pac_ret\\n\"\n+\".type unusual_no_pac_ret, %function\\n\"\n+\"unusual_no_pac_ret:\\n\"\n+\"\t.cfi_startproc\\n\"\n+\"\t\" SET_RA_STATE_0 \"\\n\"\n+\"\tstp\tx29, x30, [sp, -16]!\\n\"\n+\"\t.cfi_def_cfa_offset 16\\n\"\n+\"\t.cfi_offset 29, -16\\n\"\n+\"\t.cfi_offset 30, -8\\n\"\n+\"\tmov\tx29, sp\\n\"\n+\"\tblr\tx0\\n\"\n+\"\tldp\tx29, x30, [sp], 16\\n\"\n+\"\t.cfi_restore 30\\n\"\n+\"\t.cfi_restore 29\\n\"\n+\"\t.cfi_def_cfa_offset 0\\n\"\n+\"\tret\\n\"\n+\"\t.cfi_endproc\\n\");\n+\n+\n+/* Functions to create a call chain with mixed pac-ret dwarf.  */\n+\n+__attribute__((target(\"branch-protection=pac-ret\")))\n+static void f2_pac_ret (void)\n+{\n+  force_unwind ();\n+  die ();\n+}\n+\n+__attribute__((target(\"branch-protection=none\")))\n+static void f1_no_pac_ret (void)\n+{\n+  unusual_pac_ret (f2_pac_ret);\n+  die ();\n+}\n+\n+__attribute__((noinline, target(\"branch-protection=pac-ret\")))\n+static void f0_pac_ret (void)\n+{\n+  unusual_no_pac_ret (f1_no_pac_ret);\n+  die ();\n+}\n+\n+static void cleanup_handler (void *p)\n+{\n+  printf (\"%s: Success.\\n\", __func__);\n+  exit (0);\n+}\n+\n+int main ()\n+{\n+  char dummy __attribute__((cleanup (cleanup_handler)));\n+  f0_pac_ret ();\n+  die ();\n+}"}, {"sha": "e082e957821f96e645f28020b8fe07323999a452", "filename": "libgcc/config/aarch64/aarch64-unwind.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d344b557604e966dc7f91739881f03e1f221efd/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d344b557604e966dc7f91739881f03e1f221efd/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h?ref=0d344b557604e966dc7f91739881f03e1f221efd", "patch": "@@ -78,7 +78,13 @@ static inline void\n aarch64_frob_update_context (struct _Unwind_Context *context,\n \t\t\t     _Unwind_FrameState *fs)\n {\n-  if (fs->regs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset & 0x1)\n+  const int reg = DWARF_REGNUM_AARCH64_RA_STATE;\n+  int ra_signed;\n+  if (fs->regs.reg[reg].how == REG_UNSAVED)\n+    ra_signed = fs->regs.reg[reg].loc.offset & 0x1;\n+  else\n+    ra_signed = _Unwind_GetGR (context, reg) & 0x1;\n+  if (ra_signed)\n     /* The flag is used for re-authenticating EH handler's address.  */\n     context->flags |= RA_SIGNED_BIT;\n   else"}, {"sha": "a2eb66dc0dedc43746263bce597c16b538ee9fc4", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d344b557604e966dc7f91739881f03e1f221efd/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d344b557604e966dc7f91739881f03e1f221efd/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=0d344b557604e966dc7f91739881f03e1f221efd", "patch": "@@ -1204,7 +1204,9 @@ execute_cfa_program (const unsigned char *insn_ptr,\n #if defined (__aarch64__) && !defined (__ILP32__)\n \t  /* This CFA is multiplexed with Sparc.  On AArch64 it's used to toggle\n \t     return address signing status.  */\n-\t  fs->regs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset ^= 1;\n+\t  reg = DWARF_REGNUM_AARCH64_RA_STATE;\n+\t  gcc_assert (fs->regs.reg[reg].how == REG_UNSAVED);\n+\t  fs->regs.reg[reg].loc.offset ^= 1;\n #else\n \t  /* ??? Hardcoded for SPARC register window configuration.  */\n \t  if (__LIBGCC_DWARF_FRAME_REGISTERS__ >= 32)"}]}