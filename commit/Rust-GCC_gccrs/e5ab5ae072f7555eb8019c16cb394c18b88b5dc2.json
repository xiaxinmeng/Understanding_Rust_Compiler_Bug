{"sha": "e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVhYjVhZTA3MmY3NTU1ZWI4MDE5YzE2Y2IzOTRjMThiODhiNWRjMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-01-08T13:05:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-01-08T13:05:47Z"}, "message": "re PR middle-end/86554 (Incorrect code generation with signed/unsigned comparison)\n\n2019-01-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/86554\n\t* tree-ssa-sccvn.c (eliminate_dom_walker, rpo_elim,\n\trpo_avail): Move earlier.\n\t(visit_nary_op): When value-numbering to expressions\n\twith different overflow behavior make sure there's an\n\tavailable expression on the path.\n\n\t* gcc.dg/torture/pr86554-1.c: New testcase.\n\t* gcc.dg/torture/pr86554-2.c: Likewise.\n\nFrom-SVN: r267725", "tree": {"sha": "6fbf7804f5e6f760444f547ffee26aa86028134b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fbf7804f5e6f760444f547ffee26aa86028134b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e93bfd2de58609270d56730eeae9d31ec994aeba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93bfd2de58609270d56730eeae9d31ec994aeba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93bfd2de58609270d56730eeae9d31ec994aeba"}], "stats": {"total": 269, "additions": 188, "deletions": 81}, "files": [{"sha": "bc313e171af483da1683a33f6ca945d67a9088a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "patch": "@@ -1,3 +1,12 @@\n+2019-01-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/86554\n+\t* tree-ssa-sccvn.c (eliminate_dom_walker, rpo_elim,\n+\trpo_avail): Move earlier.\n+\t(visit_nary_op): When value-numbering to expressions\n+\twith different overflow behavior make sure there's an\n+\tavailable expression on the path.\n+\n 2019-01-08  Sam Tebbs  <sam.tebbs@arm.com>\n \n \t* config/aarch64/aarch64.c (BRANCH_PROTECT_STR_MAX,"}, {"sha": "98a851c072cf4c133254db3b0633c70383aa0e0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "patch": "@@ -1,3 +1,9 @@\n+2019-01-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/86554\n+\t* gcc.dg/torture/pr86554-1.c: New testcase.\n+\t* gcc.dg/torture/pr86554-2.c: Likewise.\n+\n 2019-01-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/diagnostic/thread1.C: Tweak expected error #line 13 to"}, {"sha": "64f851e896ec8fce12302a67eb2ea1bd5375f096", "filename": "gcc/testsuite/gcc.dg/torture/pr86554-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-1.c?ref=e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+\n+struct foo\n+{\n+  unsigned x;\n+};\n+typedef struct foo foo;\n+\n+static inline int zot(foo *f)\n+{\n+  int ret;\n+\n+  if (f->x > 0x7FFFFFFF)\n+    ret = (int)(f->x - 0x7FFFFFFF);\n+  else\n+    ret = (int)f->x - 0x7FFFFFFF;\n+  return ret;\n+}\n+\n+void __attribute__((noinline,noclone)) bar(foo *f)\n+{\n+  int ret = zot(f);\n+  volatile int x = ret;\n+  if (ret < 1)\n+    __builtin_abort ();\n+}\n+\n+int main()\n+{\n+  foo f;\n+  f.x = 0x800003f8;\n+\n+  bar(&f);\n+  return 0;\n+}"}, {"sha": "9e57a9ca725060c59b75d756567cbb0fc5688796", "filename": "gcc/testsuite/gcc.dg/torture/pr86554-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr86554-2.c?ref=e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target int32plus } */\n+\n+struct s { __INT64_TYPE__ e; };\n+\n+static void f (struct s *ps)\n+{\n+  volatile __INT64_TYPE__ m = 9223372036854775807;\n+  const char *str = \"11E\";\n+  int r;\n+  __INT64_TYPE__ sum;\n+\n+  ps->e = 0;\n+\n+  for (;;)\n+    {\n+      if (*str++ != '1')\n+\tbreak;\n+      ps->e ++;\n+    }\n+\n+  r = 1;\n+  sum = m;\n+\n+  if (sum >= 0 && ps->e >= 0)\n+    {\n+      __UINT64_TYPE__ uc;\n+      uc = (__UINT64_TYPE__) sum + (__UINT64_TYPE__) ps->e;\n+      if (uc > 9223372036854775807)\n+\tr = 2;\n+      else\n+\tsum = 17;\n+    }\n+  else\n+    sum = sum + ps->e;\n+\n+  if (sum != 9223372036854775807)\n+    __builtin_abort ();\n+  if (r != 2)\n+    __builtin_abort ();\n+  ps->e = sum;\n+}\n+\n+int main (void)\n+{\n+  struct s s;\n+  f (&s);\n+  return 0;\n+}"}, {"sha": "ff54a66534e57c3bb6a07210825665ae52dafaa6", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ab5ae072f7555eb8019c16cb394c18b88b5dc2/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=e5ab5ae072f7555eb8019c16cb394c18b88b5dc2", "patch": "@@ -1865,6 +1865,86 @@ vn_nary_simplify (vn_nary_op_t nary)\n   return vn_nary_build_or_lookup_1 (&op, false);\n }\n \n+/* Elimination engine.  */\n+\n+class eliminate_dom_walker : public dom_walker\n+{\n+public:\n+  eliminate_dom_walker (cdi_direction, bitmap);\n+  ~eliminate_dom_walker ();\n+\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+  virtual tree eliminate_avail (basic_block, tree op);\n+  virtual void eliminate_push_avail (basic_block, tree op);\n+  tree eliminate_insert (basic_block, gimple_stmt_iterator *gsi, tree val);\n+\n+  void eliminate_stmt (basic_block, gimple_stmt_iterator *);\n+\n+  unsigned eliminate_cleanup (bool region_p = false);\n+\n+  bool do_pre;\n+  unsigned int el_todo;\n+  unsigned int eliminations;\n+  unsigned int insertions;\n+\n+  /* SSA names that had their defs inserted by PRE if do_pre.  */\n+  bitmap inserted_exprs;\n+\n+  /* Blocks with statements that have had their EH properties changed.  */\n+  bitmap need_eh_cleanup;\n+\n+  /* Blocks with statements that have had their AB properties changed.  */\n+  bitmap need_ab_cleanup;\n+\n+  /* Local state for the eliminate domwalk.  */\n+  auto_vec<gimple *> to_remove;\n+  auto_vec<gimple *> to_fixup;\n+  auto_vec<tree> avail;\n+  auto_vec<tree> avail_stack;\n+};\n+\n+/* Adaptor to the elimination engine using RPO availability.  */\n+\n+class rpo_elim : public eliminate_dom_walker\n+{\n+public:\n+  rpo_elim(basic_block entry_)\n+    : eliminate_dom_walker (CDI_DOMINATORS, NULL), entry (entry_) {}\n+  ~rpo_elim();\n+\n+  virtual tree eliminate_avail (basic_block, tree op);\n+\n+  virtual void eliminate_push_avail (basic_block, tree);\n+\n+  basic_block entry;\n+  /* Instead of having a local availability lattice for each\n+     basic-block and availability at X defined as union of\n+     the local availabilities at X and its dominators we're\n+     turning this upside down and track availability per\n+     value given values are usually made available at very\n+     few points (at least one).\n+     So we have a value -> vec<location, leader> map where\n+     LOCATION is specifying the basic-block LEADER is made\n+     available for VALUE.  We push to this vector in RPO\n+     order thus for iteration we can simply pop the last\n+     entries.\n+     LOCATION is the basic-block index and LEADER is its\n+     SSA name version.  */\n+  /* ???  We'd like to use auto_vec here with embedded storage\n+     but that doesn't play well until we can provide move\n+     constructors and use std::move on hash-table expansion.\n+     So for now this is a bit more expensive than necessary.\n+     We eventually want to switch to a chaining scheme like\n+     for hashtable entries for unwinding which would make\n+     making the vector part of the vn_ssa_aux structure possible.  */\n+  typedef hash_map<tree, vec<std::pair<int, int> > > rpo_avail_t;\n+  rpo_avail_t m_rpo_avail;\n+};\n+\n+/* Global RPO state for access from hooks.  */\n+static rpo_elim *rpo_avail;\n basic_block vn_context_bb;\n \n /* Callback for walk_non_aliased_vuses.  Tries to perform a lookup\n@@ -3843,7 +3923,15 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t  ops[0] = vn_nary_op_lookup_pieces\n \t\t      (2, gimple_assign_rhs_code (def), type, ops, NULL);\n \t\t  /* We have wider operation available.  */\n-\t\t  if (ops[0])\n+\t\t  if (ops[0]\n+\t\t      /* If the leader is a wrapping operation we can\n+\t\t         insert it for code hoisting w/o introducing\n+\t\t\t undefined overflow.  If it is not it has to\n+\t\t\t be available.  See PR86554.  */\n+\t\t      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (ops[0]))\n+\t\t\t  || (rpo_avail && vn_context_bb\n+\t\t\t      && rpo_avail->eliminate_avail (vn_context_bb,\n+\t\t\t\t\t\t\t     ops[0]))))\n \t\t    {\n \t\t      unsigned lhs_prec = TYPE_PRECISION (type);\n \t\t      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));\n@@ -4654,45 +4742,6 @@ vn_nary_may_trap (vn_nary_op_t nary)\n   return false;\n }\n \n-\n-class eliminate_dom_walker : public dom_walker\n-{\n-public:\n-  eliminate_dom_walker (cdi_direction, bitmap);\n-  ~eliminate_dom_walker ();\n-\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-  virtual tree eliminate_avail (basic_block, tree op);\n-  virtual void eliminate_push_avail (basic_block, tree op);\n-  tree eliminate_insert (basic_block, gimple_stmt_iterator *gsi, tree val);\n-\n-  void eliminate_stmt (basic_block, gimple_stmt_iterator *);\n-\n-  unsigned eliminate_cleanup (bool region_p = false);\n-\n-  bool do_pre;\n-  unsigned int el_todo;\n-  unsigned int eliminations;\n-  unsigned int insertions;\n-\n-  /* SSA names that had their defs inserted by PRE if do_pre.  */\n-  bitmap inserted_exprs;\n-\n-  /* Blocks with statements that have had their EH properties changed.  */\n-  bitmap need_eh_cleanup;\n-\n-  /* Blocks with statements that have had their AB properties changed.  */\n-  bitmap need_ab_cleanup;\n-\n-  /* Local state for the eliminate domwalk.  */\n-  auto_vec<gimple *> to_remove;\n-  auto_vec<gimple *> to_fixup;\n-  auto_vec<tree> avail;\n-  auto_vec<tree> avail_stack;\n-};\n-\n eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,\n \t\t\t\t\t    bitmap inserted_exprs_)\n   : dom_walker (direction), do_pre (inserted_exprs_ != NULL),\n@@ -5648,47 +5697,6 @@ free_rpo_vn (void)\n   BITMAP_FREE (constant_value_ids);\n }\n \n-/* Adaptor to the elimination engine using RPO availability.  */\n-\n-class rpo_elim : public eliminate_dom_walker\n-{\n-public:\n-  rpo_elim(basic_block entry_)\n-    : eliminate_dom_walker (CDI_DOMINATORS, NULL), entry (entry_) {}\n-  ~rpo_elim();\n-\n-  virtual tree eliminate_avail (basic_block, tree op);\n-\n-  virtual void eliminate_push_avail (basic_block, tree);\n-\n-  basic_block entry;\n-  /* Instead of having a local availability lattice for each\n-     basic-block and availability at X defined as union of\n-     the local availabilities at X and its dominators we're\n-     turning this upside down and track availability per\n-     value given values are usually made available at very\n-     few points (at least one).\n-     So we have a value -> vec<location, leader> map where\n-     LOCATION is specifying the basic-block LEADER is made\n-     available for VALUE.  We push to this vector in RPO\n-     order thus for iteration we can simply pop the last\n-     entries.\n-     LOCATION is the basic-block index and LEADER is its\n-     SSA name version.  */\n-  /* ???  We'd like to use auto_vec here with embedded storage\n-     but that doesn't play well until we can provide move\n-     constructors and use std::move on hash-table expansion.\n-     So for now this is a bit more expensive than necessary.\n-     We eventually want to switch to a chaining scheme like\n-     for hashtable entries for unwinding which would make\n-     making the vector part of the vn_ssa_aux structure possible.  */\n-  typedef hash_map<tree, vec<std::pair<int, int> > > rpo_avail_t;\n-  rpo_avail_t m_rpo_avail;\n-};\n-\n-/* Global RPO state for access from hooks.  */\n-static rpo_elim *rpo_avail;\n-\n /* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n \n static tree"}]}