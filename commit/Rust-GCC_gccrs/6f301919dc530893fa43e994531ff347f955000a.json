{"sha": "6f301919dc530893fa43e994531ff347f955000a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzMDE5MTlkYzUzMDg5M2ZhNDNlOTk0NTMxZmYzNDdmOTU1MDAwYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:31:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:31:54Z"}, "message": "2006-02-13  Arnaud Charlet  <charlet@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* a-exexpr.adb, a-exexpr-gcc.adb\n\t(Process_Raise_Exception): Removed, merged with Propagate_Exception.\n\t(Propagate_Exception): Now take extra From_Signal_Handler parameter.\n\tRemove code unused for exception propagation for the compiler itself\n \tfrom a-except.adb and update to still share separate packages.\n\n\t* a-except.ads, a-except.adb: Ditto.\n\tAdd comments that this version is now used only by the compiler and\n\tother basic tools. The full version that includes the Ada 2005 stuff\n\tis in separate files a-except-2005.ads/adb. The reason is that we do\n\tnot want to cause bootstrap problems with compilers not recognizing\n\tWide_Wide_String.\n\tAdd exception reason code PE_Implicit_Return\n\tAdd new exception reason code (Null Exception_Id)\n\n\t* a-except-2005.adb, a-except-2005.ads: New files.\n\n\t* s-wchcon.ads: (Get_WC_Encoding_Method): New function.\n\n\t* s-wchcon.adb: New file.\n\n\t* Makefile.in (LIBGNAT_SRCS): Add tb-gcc.c.\n\t(traceback.o deps): Likewise.\n\t(SPARC/Solaris): Accept sparc[64|v9]-sun-solaris.\n\tActivate build of GMEM instrumentation library on VMS targets.\n\t(gnatlib-sjlj, gnatlib-zcx): Pass EH_MECHANISM to make gnatlib.\n\tUse a-except-2005.ads/adb for all run-time library builds unless\n\tspecified otherwise.\n\t[VMS] (LIBGNAT_TARGET_PAIRS_AUX1,2): Rename s-parame-vms.ads to\n\ts-parame-vms-alpha.ads and add s-parame-vms-ia64.ads.\n\tUse s-parame.adb on all native platforms.\n\tUse s-parame-vxworks.adb on all vxworks platforms.\n\tAdd env.c env.h in LIBGNAT_SRCS\n\tAdd env.o in LIBGNAT_OBJS\n\t(GNATMAKE_OBJS): Remove ctrl_c.o object.\n\t(LIBGNAT_TARGET_PAIRS for x86-vxworks): Use an specialized version of\n\ts-osinte.adb, s-tpopsp.adb, and system.ads for the run time that\n\tsupports VxWorks 6 RTPs.\n\t(EXTRA_GNATRTL_NONTASKING_OBJS for x86-vxworks): Remove the use of\n\ti-vxworks and i-vxwoio from the run time that supports VxWorks 6 RTPs.\n\n\t* types.h, types.ads (Terminate_Program): New exception\n\tAdd comment on modifying multiple versions of a-except.adb when the\n\ttable of exception reasons is modified.\n\tAdd exception reason code PE_Implicit_Return\n\tAdd new exception reason code (Null Exception_Id)\n\n        * clean.adb (Initialize): Get the target parameters before checking\n        if target is OpenVMS. Move the OpenVMS specific code here from package\n        body elaboration code.\n\nFrom-SVN: r111031", "tree": {"sha": "14eb42b222454b2b7f3b3060688e866bdb0b0127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14eb42b222454b2b7f3b3060688e866bdb0b0127"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f301919dc530893fa43e994531ff347f955000a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f301919dc530893fa43e994531ff347f955000a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f301919dc530893fa43e994531ff347f955000a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f301919dc530893fa43e994531ff347f955000a/comments", "author": null, "committer": null, "parents": [{"sha": "5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b47742c2d278f8f8a4b1e02c6e1f786340da38f"}], "stats": {"total": 2429, "additions": 2103, "deletions": 326}, "files": [{"sha": "c53832b206c7f11d02d02a5c864dee6827b5b946", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 129, "deletions": 92, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -302,7 +302,7 @@ GNATLINK_OBJS = gnatlink.o \\\n  sdefault.o snames.o stylesw.o switch.o system.o table.o targparm.o tree_io.o \\\n  types.o validsw.o widechar.o\n \n-GNATMAKE_OBJS = a-except.o ctrl_c.o ali.o ali-util.o s-casuti.o \\\n+GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n  alloc.o atree.o binderr.o butil.o casing.o csets.o debug.o elists.o einfo.o\\\n  erroutc.o errutil.o err_vars.o fmap.o fname.o fname-uf.o fname-sf.o \\\n  gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o \\\n@@ -399,6 +399,7 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n@@ -435,6 +436,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n@@ -473,6 +475,57 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n endif\n \n+# vxworksae / vxworks 653\n+ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n+  # target pairs for kernel + vthreads runtime\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-elchha.adb<a-elchha-vxworks-ppc-full.adb \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  a-sytaco.ads<1asytaco.ads \\\n+  a-sytaco.adb<1asytaco.adb \\\n+  g-io.adb<g-io-vxworks-ppc-cert.adb \\\n+  g-io.ads<g-io-vxworks-ppc-cert.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-ae653.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-ppc.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  system.ads<system-vxworks-ppc-vthread.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  # Extra pairs for the vthreads runtime\n+  ifeq ($(strip $(filter-out vthreads,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-thread.adb<s-thread-ae653.adb\n+    EXTRA_GNATRTL_NONTASKING_OBJS += s-thread.o\n+  endif\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+endif\n+\n ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-vxworks.ads \\\n@@ -485,6 +538,7 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n@@ -511,19 +565,17 @@ ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n   s-intman.adb<s-intman-vxworks.adb \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   a-numaux.ads<a-numaux-x86.ads \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n   s-vxwork.ads<s-vxwork-x86.ads \\\n   g-soccon.ads<g-soccon-vxworks.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  system.ads<system-vxworks-x86.ads\n+  g-socthi.adb<g-socthi-vxworks.adb\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n \n@@ -536,7 +588,22 @@ ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n     s-tfsetr.adb<s-tfsetr-vxworks.adb\n   endif\n \n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n+    system.ads<system-vxworks-x86-rtp.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+    system.ads<system-vxworks-x86.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  endif\n+\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n endif\n \n@@ -552,6 +619,7 @@ ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n@@ -580,6 +648,7 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n   s-stchop.adb<s-stchop-vxworks.adb \\\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n@@ -596,65 +665,14 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n endif\n \n-# vxworksae / vxworks 653\n-ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n-  # target pairs for kernel + vthreads runtime\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-elchha.adb<a-elchha-vxworks-ppc-full.adb \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  a-sytaco.ads<1asytaco.ads \\\n-  a-sytaco.adb<1asytaco.adb \\\n-  g-io.adb<g-io-vxworks-ppc-cert.adb \\\n-  g-io.ads<g-io-vxworks-ppc-cert.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-ae653.ads \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-ppc.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  system.ads<system-vxworks-ppc-vthread.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  # Extra pairs for the vthreads runtime\n-  ifeq ($(strip $(filter-out vthreads,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-thread.adb<s-thread-ae653.adb\n-    EXTRA_GNATRTL_NONTASKING_OBJS += s-thread.o\n-  endif\n-\n-  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-traces.adb<s-traces-default.adb \\\n-    s-trafor.adb<s-trafor-default.adb \\\n-    s-trafor.ads<s-trafor-default.ads \\\n-    s-tratas.adb<s-tratas-default.adb \\\n-    s-tfsetr.adb<s-tfsetr-vxworks.adb\n-  endif\n-endif\n-\n-ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n+ifeq ($(strip $(filter-out sparc% sun solaris%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_32 = \\\n   a-intnam.ads<a-intnam-solaris.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-solaris.adb \\\n   s-osinte.adb<s-osinte-solaris.adb \\\n   s-osinte.ads<s-osinte-solaris.ads \\\n   s-osprim.adb<s-osprim-solaris.adb \\\n-  s-parame.adb<s-parame-solaris.adb \\\n   s-taprop.adb<s-taprop-solaris.adb \\\n   s-tasinf.adb<s-tasinf-solaris.adb \\\n   s-tasinf.ads<s-tasinf-solaris.ads \\\n@@ -664,6 +682,28 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n   g-soliop.ads<g-soliop-solaris.ads \\\n   system.ads<system-solaris-sparc.ads\n \n+  LIBGNAT_TARGET_PAIRS_64 = \\\n+  a-intnam.ads<a-intnam-solaris.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-solaris.adb \\\n+  s-osinte.adb<s-osinte-solaris.adb \\\n+  s-osinte.ads<s-osinte-solaris.ads \\\n+  s-osprim.adb<s-osprim-solaris.adb \\\n+  s-taprop.adb<s-taprop-solaris.adb \\\n+  s-tasinf.adb<s-tasinf-solaris.adb \\\n+  s-tasinf.ads<s-tasinf-solaris.ads \\\n+  s-taspri.ads<s-taspri-solaris.ads \\\n+  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n+  g-soccon.ads<g-soccon-solaris-64.ads \\\n+  g-soliop.ads<g-soliop-solaris.ads \\\n+  system.ads<system-solaris-sparcv9.ads\n+\n+  ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_32)\n+  else\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n+  endif\n+  \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-solaris.adb\n \n   EH_MECHANISM=-gcc\n@@ -694,22 +734,7 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n   endif\n \n   ifeq ($(strip $(filter-out m64,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-solaris.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-solaris.adb \\\n-    s-osinte.adb<s-osinte-solaris.adb \\\n-    s-osinte.ads<s-osinte-solaris.ads \\\n-    s-osprim.adb<s-osprim-solaris.adb \\\n-    s-parame.adb<s-parame-solaris.adb \\\n-    s-taprop.adb<s-taprop-solaris.adb \\\n-    s-tasinf.adb<s-tasinf-solaris.adb \\\n-    s-tasinf.ads<s-tasinf-solaris.ads \\\n-    s-taspri.ads<s-taspri-solaris.ads \\\n-    s-tpopsp.adb<s-tpopsp-solaris.adb \\\n-    g-soccon.ads<g-soccon-solaris-64.ads \\\n-    g-soliop.ads<g-soliop-solaris.ads \\\n-    system.ads<system-solaris-sparcv9.ads\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n   endif\n endif\n \n@@ -723,7 +748,6 @@ ifeq ($(strip $(filter-out %86 solaris2%,$(arch) $(osys))),)\n   s-osinte.adb<s-osinte-solaris.adb \\\n   s-osinte.ads<s-osinte-solaris.ads \\\n   s-osprim.adb<s-osprim-solaris.adb \\\n-  s-parame.adb<s-parame-solaris.adb \\\n   s-taprop.adb<s-taprop-solaris.adb \\\n   s-tasinf.adb<s-tasinf-solaris.adb \\\n   s-tasinf.ads<s-tasinf-solaris.ads \\\n@@ -758,7 +782,6 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-parame.adb<s-parame-linux.adb \\\n   system.ads<system-linux-x86.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -811,7 +834,6 @@ ifeq ($(strip $(filter-out s390% linux%,$(arch) $(osys))),)\n     s-taprop.adb<s-taprop-linux.adb \\\n     s-taspri.ads<s-taspri-posix.ads \\\n     s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    s-parame.adb<s-parame-linux.adb \\\n     system.ads<system-linux-s390x.ads\n   else\n     LIBGNAT_TARGET_PAIRS = \\\n@@ -824,7 +846,6 @@ ifeq ($(strip $(filter-out s390% linux%,$(arch) $(osys))),)\n     s-taprop.adb<s-taprop-linux.adb \\\n     s-taspri.ads<s-taspri-posix.ads \\\n     s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    s-parame.adb<s-parame-linux.adb \\\n     system.ads<system-linux-s390.ads\n   endif\n \n@@ -1055,6 +1076,9 @@ ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n   s-osinte.ads<s-osinte-vms-ia64.ads \\\n   s-vaflop.adb<s-vaflop-vms-ia64.adb \\\n   system.ads<system-vms_64.ads\n+\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n+  s-parame.ads<s-parame-vms-ia64.ads\n else\n ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS_AUX1 = \\\n@@ -1067,14 +1091,15 @@ ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n   s-osinte.ads<s-osinte-vms.ads \\\n   s-vaflop.adb<s-vaflop-vms-alpha.adb \\\n   system.ads<system-vms_64.ads\n-endif\n-endif\n+\n ifeq ($(strip $(filter-out express EXPRESS,$(THREAD_KIND))),)\n   LIBGNAT_TARGET_PAIRS_AUX2 = \\\n   s-parame.ads<s-parame-vms-restrict.ads\n else\n   LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-  s-parame.ads<s-parame-vms.ads\n+  s-parame.ads<s-parame-vms-alpha.ads\n+endif\n+endif\n endif\n \n   LIBGNAT_TARGET_PAIRS = \\\n@@ -1118,6 +1143,8 @@ else\n   symbols-processing.adb<symbols-processing-vms-alpha.adb\n endif\n \n+\n+  GMEM_LIB = gmemlib\n   EH_MECHANISM=-gcc\n   GNATLIB_SHARED=gnatlib-shared-vms\n ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n@@ -1153,7 +1180,6 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   s-osprim.adb<s-osprim-mingw.adb \\\n   s-taprop.adb<s-taprop-mingw.adb \\\n   s-taspri.ads<s-taspri-mingw.ads \\\n-  s-parame.adb<s-parame-mingw.adb \\\n   g-socthi.ads<g-socthi-mingw.ads \\\n   g-socthi.adb<g-socthi-mingw.adb \\\n   g-soccon.ads<g-soccon-mingw.ads \\\n@@ -1189,7 +1215,6 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-parame.adb<s-parame-linux.adb \\\n   system.ads<system-linux-ppc.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1215,7 +1240,6 @@ ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-parame.adb<s-parame-linux.adb \\\n   system.ads<system-linux-sparc.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1241,7 +1265,6 @@ ifeq ($(strip $(filter-out hppa% linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-parame.adb<s-parame-linux.adb \\\n   system.ads<system-linux-hppa.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1372,6 +1395,18 @@ ifneq ($(EH_MECHANISM),)\n   EXTRA_LIBGNAT_OBJS+=raise$(EH_MECHANISM).o\n endif\n \n+# Use the Ada 2005 version of Ada.Exceptions by default, unless specified\n+# explicitely already. The base files (a-except.ad?) are used only for building\n+# the compiler and other basic tools.\n+# These base versions lack Ada 2005 additions which would cause bootstrap\n+# problems if included in the compiler and other basic tools.\n+\n+ifeq ($(filter-out a-except%,$(LIBGNAT_TARGET_PAIRS)),$(LIBGNAT_TARGET_PAIRS))\n+  LIBGNAT_TARGET_PAIRS += \\\n+    a-except.ads<a-except-2005.ads \\\n+    a-except.adb<a-except-2005.adb\n+endif\n+\n # The runtime library for gnat comprises two directories.  One contains the\n # Ada source files that the compiler (gnat1) needs -- these files are listed\n # by ADA_INCLUDE_SRCS -- and the other contains the object files and their\n@@ -1382,12 +1417,12 @@ endif\n # go into the directory.  The pthreads emulation is built in the threads\n # subdirectory and copied.\n LIBGNAT_SRCS = ada.h adaint.c adaint.h argv.c cio.c cstreams.c \\\n-  errno.c exit.c cal.c ctrl_c.c \\\n+  errno.c exit.c cal.c ctrl_c.c env.c env.h \\\n   raise.h raise.c sysdep.c aux-io.c init.c initialize.c seh_init.c \\\n-  final.c tracebak.c tb-alvms.c tb-alvxw.c expect.c mkdir.c socket.c gsocket.h \\\n-  targext.c $(EXTRA_LIBGNAT_SRCS)\n+  final.c tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c expect.c mkdir.c \\\n+  socket.c gsocket.h targext.c $(EXTRA_LIBGNAT_SRCS)\n \n-LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o \\\n+LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o env.o \\\n   raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o \\\n   final.o tracebak.o expect.o mkdir.o socket.o targext.o $(EXTRA_LIBGNAT_OBJS)\n \n@@ -1811,7 +1846,8 @@ gnatlib-sjlj:\n \tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := False;/' rts/system.ads > rts/s.ads\n \t$(MV) rts/s.ads rts/system.ads\n \t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     EH_MECHANISM=\"\" \\\n+\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n \t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n \t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n \t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n@@ -1821,6 +1857,7 @@ gnatlib-zcx:\n \tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := True;/' rts/system.ads > rts/s.ads\n \t$(MV) rts/s.ads rts/system.ads\n \t$(MAKE) $(FLAGS_TO_PASS) \\\n+\t     EH_MECHANISM=\"-gcc\" \\\n \t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n \t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n \t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n@@ -1935,7 +1972,7 @@ seh_init.o : seh_init.c raise.h\n \n # Need to keep the frame pointer in this file to pop the stack properly on\n # some targets.\n-tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c\n+tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c\n \t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t      -fno-omit-frame-pointer $< $(OUTPUT_OPTION)\n "}, {"sha": "7325723d7f84b6ba4ad0424a273ccf57a2540a0c", "filename": "gcc/ada/a-except-2005.adb", "status": "added", "additions": 1355, "deletions": 0, "changes": 1355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -0,0 +1,1355 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . E X C E P T I O N S                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version is used for all Ada 2005 builds. It differs from a-except.ads\n+--  only with respect to the addition of Wide_[Wide]Exception_Name functions.\n+\n+--  The reason for this splitting off of a separate version is that bootstrap\n+--  compilers often will be used that do not support Ada 2005 features, and\n+--  Ada.Exceptions is part of the compiler sources.\n+\n+--  The base version of this unit Ada.Exceptions omits the Wide version of\n+--  Exception_Name and is used to build the compiler and other basic tools.\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we get\n+--  elaboration circularities with System.Exception_Tables.\n+\n+with System;                  use System;\n+with System.Standard_Library; use System.Standard_Library;\n+with System.Soft_Links;       use System.Soft_Links;\n+with System.WCh_Con;          use System.WCh_Con;\n+with System.WCh_StW;          use System.WCh_StW;\n+\n+package body Ada.Exceptions is\n+\n+   pragma Suppress (All_Checks);\n+   --  We definitely do not want exceptions occurring within this unit, or\n+   --  we are in big trouble. If an exceptional situation does occur, better\n+   --  that it not be raised, since raising it can cause confusing chaos.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   --  Note: the exported subprograms in this package body are called directly\n+   --  from C clients using the given external name, even though they are not\n+   --  technically visible in the Ada sense.\n+\n+   function Code_Address_For_AAA return System.Address;\n+   function Code_Address_For_ZZZ return System.Address;\n+   --  Return start and end of procedures in this package\n+   --\n+   --  These procedures are used to provide exclusion bounds in\n+   --  calls to Call_Chain at exception raise points from this unit. The\n+   --  purpose is to arrange for the exception tracebacks not to include\n+   --  frames from routines involved in the raise process, as these are\n+   --  meaningless from the user's standpoint.\n+   --\n+   --  For these bounds to be meaningful, we need to ensure that the object\n+   --  code for the routines involved in processing a raise is located after\n+   --  the object code Code_Address_For_AAA and before the object code\n+   --  Code_Address_For_ZZZ. This will indeed be the case as long as the\n+   --  following rules are respected:\n+   --\n+   --  1) The bodies of the subprograms involved in processing a raise\n+   --     are located after the body of Code_Address_For_AAA and before the\n+   --     body of Code_Address_For_ZZZ.\n+   --\n+   --  2) No pragma Inline applies to any of these subprograms, as this\n+   --     could delay the corresponding assembly output until the end of\n+   --     the unit.\n+\n+   procedure Call_Chain (Excep : EOA);\n+   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n+   --  call chain.\n+\n+   procedure To_Stderr (S : String);\n+   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n+   --  Little routine to output string to stderr that is also used\n+   --  in the tasking run time.\n+\n+   procedure To_Stderr (C : Character);\n+   pragma Inline (To_Stderr);\n+   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr_char\");\n+   --  Little routine to output a character to stderr, used by some of\n+   --  the separate units below.\n+\n+   package Exception_Data is\n+\n+      ---------------------------------\n+      -- Exception messages routines --\n+      ---------------------------------\n+\n+      procedure Set_Exception_C_Msg\n+        (Id   : Exception_Id;\n+         Msg1 : System.Address;\n+         Line : Integer        := 0;\n+         Msg2 : System.Address := System.Null_Address);\n+      --  This routine is called to setup the exception referenced by the\n+      --  Current_Excep field in the TSD to contain the indicated Id value\n+      --  and message. Msg1 is a null terminated string which is generated\n+      --  as the exception message. If line is non-zero, then a colon and\n+      --  the decimal representation of this integer is appended to the\n+      --  message. When Msg2 is non-null, a space and this additional null\n+      --  terminated string is added to the message.\n+\n+      procedure Set_Exception_Msg\n+        (Id      : Exception_Id;\n+         Message : String);\n+      --  This routine is called to setup the exception referenced by the\n+      --  Current_Excep field in the TSD to contain the indicated Id value\n+      --  and message. Message is a string which is generated as the\n+      --  exception message.\n+\n+      --------------------------------------\n+      -- Exception information subprogram --\n+      --------------------------------------\n+\n+      function Exception_Information (X : Exception_Occurrence) return String;\n+      --  The format of the exception information is as follows:\n+      --\n+      --    Exception_Name: <exception name> (as in Exception_Name)\n+      --    Message: <message> (only if Exception_Message is empty)\n+      --    PID=nnnn (only if != 0)\n+      --    Call stack traceback locations:  (only if at least one location)\n+      --    <0xyyyyyyyy 0xyyyyyyyy ...>      (is recorded)\n+      --\n+      --  The lines are separated by a ASCII.LF character.\n+      --  The nnnn is the partition Id given as decimal digits.\n+      --  The 0x... line represents traceback program counter locations, in\n+      --  execution order with the first one being the exception location. It\n+      --  is present only\n+      --\n+      --  The Exception_Name and Message lines are omitted in the abort\n+      --  signal case, since this is not really an exception.\n+\n+      --  !! If the format of the generated string is changed, please note\n+      --  !! that an equivalent modification to the routine String_To_EO must\n+      --  !! be made to preserve proper functioning of the stream attributes.\n+\n+      ---------------------------------------\n+      -- Exception backtracing subprograms --\n+      ---------------------------------------\n+\n+      --  What is automatically output when exception tracing is on is the\n+      --  usual exception information with the call chain backtrace possibly\n+      --  tailored by a backtrace decorator. Modifying Exception_Information\n+      --  itself is not a good idea because the decorated output is completely\n+      --  out of control and would break all our code related to the streaming\n+      --  of exceptions.  We then provide an alternative function to compute\n+      --  the possibly tailored output, which is equivalent if no decorator is\n+      --  currently set:\n+\n+      function Tailored_Exception_Information\n+        (X : Exception_Occurrence) return String;\n+      --  Exception information to be output in the case of automatic tracing\n+      --  requested through GNAT.Exception_Traces.\n+      --\n+      --  This is the same as Exception_Information if no backtrace decorator\n+      --  is currently in place. Otherwise, this is Exception_Information with\n+      --  the call chain raw addresses replaced by the result of a call to the\n+      --  current decorator provided with the call chain addresses.\n+\n+      pragma Export\n+        (Ada, Tailored_Exception_Information,\n+           \"__gnat_tailored_exception_information\");\n+      --  This is currently used by System.Tasking.Stages\n+\n+   end Exception_Data;\n+\n+   package Exception_Traces is\n+\n+      use Exception_Data;\n+      --  Imports Tailored_Exception_Information\n+\n+      ----------------------------------------------\n+      -- Run-Time Exception Notification Routines --\n+      ----------------------------------------------\n+\n+      --  These subprograms provide a common run-time interface to trigger the\n+      --  actions required when an exception is about to be propagated (e.g.\n+      --  user specified actions or output of exception information). They are\n+      --  exported to be usable by the Ada exception handling personality\n+      --  routine when the GCC 3 mechanism is used.\n+\n+      procedure Notify_Handled_Exception;\n+      pragma Export\n+        (C, Notify_Handled_Exception, \"__gnat_notify_handled_exception\");\n+      --  This routine is called for a handled occurrence is about to be\n+      --  propagated.\n+\n+      procedure Notify_Unhandled_Exception;\n+      pragma Export\n+        (C, Notify_Unhandled_Exception, \"__gnat_notify_unhandled_exception\");\n+      --  This routine is called when an unhandled occurrence is about to be\n+      --  propagated.\n+\n+      procedure Unhandled_Exception_Terminate;\n+      pragma No_Return (Unhandled_Exception_Terminate);\n+      --  This procedure is called to terminate execution following an\n+      --  unhandled exception. The exception information, including\n+      --  traceback if available is output, and execution is then\n+      --  terminated. Note that at the point where this routine is\n+      --  called, the stack has typically been destroyed.\n+\n+   end Exception_Traces;\n+\n+   package Exception_Propagation is\n+\n+      use Exception_Traces;\n+      --  Imports Notify_Unhandled_Exception and\n+      --  Unhandled_Exception_Terminate\n+\n+      ------------------------------------\n+      -- Exception propagation routines --\n+      ------------------------------------\n+\n+      procedure Setup_Exception\n+        (Excep    : EOA;\n+         Current  : EOA;\n+         Reraised : Boolean := False);\n+      --  Perform the necessary operations to prepare the propagation of Excep\n+      --  in a task where Current is the current occurrence. Excep is assumed\n+      --  to be a valid (non null) pointer.\n+      --\n+      --  This should be called before any (re-)setting of the current\n+      --  occurrence. Any such (re-)setting shall take care *not* to clobber\n+      --  the Private_Data component.\n+      --\n+      --  Having Current provided as an argument (instead of retrieving it via\n+      --  Get_Current_Excep internally) is required to allow one task to setup\n+      --  an exception for another task, which is used by Transfer_Occurrence.\n+\n+      procedure Propagate_Exception\n+        (E                   : Exception_Id;\n+         From_Signal_Handler : Boolean);\n+      pragma No_Return (Propagate_Exception);\n+      --  This procedure propagates the exception represented by the occurrence\n+      --  referenced by Current_Excep in the TSD for the current task.\n+\n+   end Exception_Propagation;\n+\n+   package Stream_Attributes is\n+\n+      --------------------------------\n+      -- Stream attributes routines --\n+      --------------------------------\n+\n+      function EId_To_String (X : Exception_Id) return String;\n+      function String_To_EId (S : String) return Exception_Id;\n+      --  Functions for implementing Exception_Id stream attributes\n+\n+      function EO_To_String (X : Exception_Occurrence) return String;\n+      function String_To_EO (S : String) return Exception_Occurrence;\n+      --  Functions for implementing Exception_Occurrence stream\n+      --  attributes\n+\n+   end Stream_Attributes;\n+\n+   procedure Raise_Current_Excep (E : Exception_Id);\n+   pragma No_Return (Raise_Current_Excep);\n+   pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n+   --  This is a simple wrapper to Exception_Propagation.Propagate_Exception\n+   --  setting the From_Signal_Handler argument to False.\n+   --\n+   --  This external name for Raise_Current_Excep is historical, and probably\n+   --  should be changed but for now we keep it, because gdb and gigi know\n+   --  about it.\n+\n+   procedure Raise_Exception_No_Defer\n+      (E : Exception_Id; Message : String := \"\");\n+   pragma Export\n+    (Ada, Raise_Exception_No_Defer,\n+     \"ada__exceptions__raise_exception_no_defer\");\n+   pragma No_Return (Raise_Exception_No_Defer);\n+   --  Similar to Raise_Exception, but with no abort deferral\n+\n+   procedure Raise_With_Msg (E : Exception_Id);\n+   pragma No_Return (Raise_With_Msg);\n+   pragma Export (C, Raise_With_Msg, \"__gnat_raise_with_msg\");\n+   --  Raises an exception with given exception id value. A message\n+   --  is associated with the raise, and has already been stored in the\n+   --  exception occurrence referenced by the Current_Excep in the TSD.\n+   --  Abort is deferred before the raise call.\n+\n+   procedure Raise_With_Location_And_Msg\n+     (E : Exception_Id;\n+      F : System.Address;\n+      L : Integer;\n+      M : System.Address := System.Null_Address);\n+   pragma No_Return (Raise_With_Location_And_Msg);\n+   --  Raise an exception with given exception id value. A filename and line\n+   --  number is associated with the raise and is stored in the exception\n+   --  occurrence and in addition a string message M is appended to\n+   --  this (if M is not null).\n+\n+   procedure Raise_Constraint_Error\n+     (File : System.Address;\n+      Line : Integer);\n+   pragma No_Return (Raise_Constraint_Error);\n+   pragma Export\n+     (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n+   --  Raise constraint error with file:line information\n+\n+   procedure Raise_Constraint_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address);\n+   pragma No_Return (Raise_Constraint_Error_Msg);\n+   pragma Export\n+     (C, Raise_Constraint_Error_Msg, \"__gnat_raise_constraint_error_msg\");\n+   --  Raise constraint error with file:line + msg information\n+\n+   procedure Raise_Program_Error\n+     (File : System.Address;\n+      Line : Integer);\n+   pragma No_Return (Raise_Program_Error);\n+   pragma Export\n+     (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n+   --  Raise program error with file:line information\n+\n+   procedure Raise_Program_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address);\n+   pragma No_Return (Raise_Program_Error_Msg);\n+   pragma Export\n+     (C, Raise_Program_Error_Msg, \"__gnat_raise_program_error_msg\");\n+   --  Raise program error with file:line + msg information\n+\n+   procedure Raise_Storage_Error\n+     (File : System.Address;\n+      Line : Integer);\n+   pragma No_Return (Raise_Storage_Error);\n+   pragma Export\n+     (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n+   --  Raise storage error with file:line information\n+\n+   procedure Raise_Storage_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address);\n+   pragma No_Return (Raise_Storage_Error_Msg);\n+   pragma Export\n+     (C, Raise_Storage_Error_Msg, \"__gnat_raise_storage_error_msg\");\n+   --  Raise storage error with file:line + reason msg information\n+\n+   --  The exception raising process and the automatic tracing mechanism rely\n+   --  on some careful use of flags attached to the exception occurrence. The\n+   --  graph below illustrates the relations between the Raise_ subprograms\n+   --  and identifies the points where basic flags such as Exception_Raised\n+   --  are initialized.\n+   --\n+   --  (i) signs indicate the flags initialization points. R stands for Raise,\n+   --  W for With, and E for Exception.\n+   --\n+   --                   R_No_Msg    R_E   R_Pe  R_Ce  R_Se\n+   --                       |        |     |     |     |\n+   --                       +--+  +--+     +---+ | +---+\n+   --                          |  |            | | |\n+   --     R_E_No_Defer(i)    R_W_Msg(i)       R_W_Loc\n+   --           |               |              |   |\n+   --           +------------+  |  +-----------+   +--+\n+   --                        |  |  |                  |\n+   --                        |  |  |             Set_E_C_Msg(i)\n+   --                        |  |  |\n+   --                   Raise_Current_Excep\n+\n+   procedure Reraise;\n+   pragma No_Return (Reraise);\n+   pragma Export (C, Reraise, \"__gnat_reraise\");\n+   --  Reraises the exception referenced by the Current_Excep field of\n+   --  the TSD (all fields of this exception occurrence are set). Abort\n+   --  is deferred before the reraise operation.\n+\n+   --  Save_Occurrence variations: As the management of the private data\n+   --  attached to occurrences is delicate, wether or not pointers to such\n+   --  data has to be copied in various situations is better made explicit.\n+   --  The following procedures provide an internal interface to help making\n+   --  this explicit.\n+\n+   procedure Save_Occurrence_No_Private\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence);\n+   --  Copy all the components of Source to Target, except the\n+   --  Private_Data pointer.\n+\n+   procedure Transfer_Occurrence\n+     (Target : Exception_Occurrence_Access;\n+      Source : Exception_Occurrence);\n+   pragma Export (C, Transfer_Occurrence, \"__gnat_transfer_occurrence\");\n+   --  Called from System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n+   --  to setup Target from Source as an exception to be propagated in the\n+   --  caller task. Target is expected to be a pointer to the fixed TSD\n+   --  occurrence for this task.\n+\n+   -----------------------------\n+   -- Run-Time Check Routines --\n+   -----------------------------\n+\n+   --  These routines are called from the runtime to raise a specific\n+   --  exception with a reason message attached. The parameters are\n+   --  the file name and line number in each case. The names are keyed\n+   --  to the codes defined in Types.ads and a-types.h (for example,\n+   --  the name Rcheck_05 refers to the Reason whose Pos code is 5).\n+\n+   procedure Rcheck_00 (File : System.Address; Line : Integer);\n+   procedure Rcheck_01 (File : System.Address; Line : Integer);\n+   procedure Rcheck_02 (File : System.Address; Line : Integer);\n+   procedure Rcheck_03 (File : System.Address; Line : Integer);\n+   procedure Rcheck_04 (File : System.Address; Line : Integer);\n+   procedure Rcheck_05 (File : System.Address; Line : Integer);\n+   procedure Rcheck_06 (File : System.Address; Line : Integer);\n+   procedure Rcheck_07 (File : System.Address; Line : Integer);\n+   procedure Rcheck_08 (File : System.Address; Line : Integer);\n+   procedure Rcheck_09 (File : System.Address; Line : Integer);\n+   procedure Rcheck_10 (File : System.Address; Line : Integer);\n+   procedure Rcheck_11 (File : System.Address; Line : Integer);\n+   procedure Rcheck_12 (File : System.Address; Line : Integer);\n+   procedure Rcheck_13 (File : System.Address; Line : Integer);\n+   procedure Rcheck_14 (File : System.Address; Line : Integer);\n+   procedure Rcheck_15 (File : System.Address; Line : Integer);\n+   procedure Rcheck_16 (File : System.Address; Line : Integer);\n+   procedure Rcheck_17 (File : System.Address; Line : Integer);\n+   procedure Rcheck_18 (File : System.Address; Line : Integer);\n+   procedure Rcheck_19 (File : System.Address; Line : Integer);\n+   procedure Rcheck_20 (File : System.Address; Line : Integer);\n+   procedure Rcheck_21 (File : System.Address; Line : Integer);\n+   procedure Rcheck_22 (File : System.Address; Line : Integer);\n+   procedure Rcheck_23 (File : System.Address; Line : Integer);\n+   procedure Rcheck_24 (File : System.Address; Line : Integer);\n+   procedure Rcheck_25 (File : System.Address; Line : Integer);\n+   procedure Rcheck_26 (File : System.Address; Line : Integer);\n+   procedure Rcheck_27 (File : System.Address; Line : Integer);\n+   procedure Rcheck_28 (File : System.Address; Line : Integer);\n+   procedure Rcheck_29 (File : System.Address; Line : Integer);\n+   procedure Rcheck_30 (File : System.Address; Line : Integer);\n+   procedure Rcheck_31 (File : System.Address; Line : Integer);\n+   procedure Rcheck_32 (File : System.Address; Line : Integer);\n+\n+   pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n+   pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n+   pragma Export (C, Rcheck_02, \"__gnat_rcheck_02\");\n+   pragma Export (C, Rcheck_03, \"__gnat_rcheck_03\");\n+   pragma Export (C, Rcheck_04, \"__gnat_rcheck_04\");\n+   pragma Export (C, Rcheck_05, \"__gnat_rcheck_05\");\n+   pragma Export (C, Rcheck_06, \"__gnat_rcheck_06\");\n+   pragma Export (C, Rcheck_07, \"__gnat_rcheck_07\");\n+   pragma Export (C, Rcheck_08, \"__gnat_rcheck_08\");\n+   pragma Export (C, Rcheck_09, \"__gnat_rcheck_09\");\n+   pragma Export (C, Rcheck_10, \"__gnat_rcheck_10\");\n+   pragma Export (C, Rcheck_11, \"__gnat_rcheck_11\");\n+   pragma Export (C, Rcheck_12, \"__gnat_rcheck_12\");\n+   pragma Export (C, Rcheck_13, \"__gnat_rcheck_13\");\n+   pragma Export (C, Rcheck_14, \"__gnat_rcheck_14\");\n+   pragma Export (C, Rcheck_15, \"__gnat_rcheck_15\");\n+   pragma Export (C, Rcheck_16, \"__gnat_rcheck_16\");\n+   pragma Export (C, Rcheck_17, \"__gnat_rcheck_17\");\n+   pragma Export (C, Rcheck_18, \"__gnat_rcheck_18\");\n+   pragma Export (C, Rcheck_19, \"__gnat_rcheck_19\");\n+   pragma Export (C, Rcheck_20, \"__gnat_rcheck_20\");\n+   pragma Export (C, Rcheck_21, \"__gnat_rcheck_21\");\n+   pragma Export (C, Rcheck_22, \"__gnat_rcheck_22\");\n+   pragma Export (C, Rcheck_23, \"__gnat_rcheck_23\");\n+   pragma Export (C, Rcheck_24, \"__gnat_rcheck_24\");\n+   pragma Export (C, Rcheck_25, \"__gnat_rcheck_25\");\n+   pragma Export (C, Rcheck_26, \"__gnat_rcheck_26\");\n+   pragma Export (C, Rcheck_27, \"__gnat_rcheck_27\");\n+   pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n+   pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n+   pragma Export (C, Rcheck_30, \"__gnat_rcheck_30\");\n+   pragma Export (C, Rcheck_31, \"__gnat_rcheck_31\");\n+   pragma Export (C, Rcheck_32, \"__gnat_rcheck_32\");\n+\n+   --  None of these procedures ever returns (they raise an exception!). By\n+   --  using pragma No_Return, we ensure that any junk code after the call,\n+   --  such as normal return epilog stuff, can be eliminated).\n+\n+   pragma No_Return (Rcheck_00);\n+   pragma No_Return (Rcheck_01);\n+   pragma No_Return (Rcheck_02);\n+   pragma No_Return (Rcheck_03);\n+   pragma No_Return (Rcheck_04);\n+   pragma No_Return (Rcheck_05);\n+   pragma No_Return (Rcheck_06);\n+   pragma No_Return (Rcheck_07);\n+   pragma No_Return (Rcheck_08);\n+   pragma No_Return (Rcheck_09);\n+   pragma No_Return (Rcheck_10);\n+   pragma No_Return (Rcheck_11);\n+   pragma No_Return (Rcheck_12);\n+   pragma No_Return (Rcheck_13);\n+   pragma No_Return (Rcheck_14);\n+   pragma No_Return (Rcheck_15);\n+   pragma No_Return (Rcheck_16);\n+   pragma No_Return (Rcheck_17);\n+   pragma No_Return (Rcheck_18);\n+   pragma No_Return (Rcheck_19);\n+   pragma No_Return (Rcheck_20);\n+   pragma No_Return (Rcheck_21);\n+   pragma No_Return (Rcheck_22);\n+   pragma No_Return (Rcheck_23);\n+   pragma No_Return (Rcheck_24);\n+   pragma No_Return (Rcheck_25);\n+   pragma No_Return (Rcheck_26);\n+   pragma No_Return (Rcheck_27);\n+   pragma No_Return (Rcheck_28);\n+   pragma No_Return (Rcheck_29);\n+   pragma No_Return (Rcheck_30);\n+   pragma No_Return (Rcheck_32);\n+\n+   ---------------------------------------------\n+   -- Reason Strings for Run-Time Check Calls --\n+   ---------------------------------------------\n+\n+   --  These strings are null-terminated and are used by Rcheck_nn. The\n+   --  strings correspond to the definitions for Types.RT_Exception_Code.\n+\n+   use ASCII;\n+\n+   Rmsg_00 : constant String := \"access check failed\"              & NUL;\n+   Rmsg_01 : constant String := \"access parameter is null\"         & NUL;\n+   Rmsg_02 : constant String := \"discriminant check failed\"        & NUL;\n+   Rmsg_03 : constant String := \"divide by zero\"                   & NUL;\n+   Rmsg_04 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_05 : constant String := \"index check failed\"               & NUL;\n+   Rmsg_06 : constant String := \"invalid data\"                     & NUL;\n+   Rmsg_07 : constant String := \"length check failed\"              & NUL;\n+   Rmsg_08 : constant String := \"null Exception_Id\"                & NUL;\n+   Rmsg_09 : constant String := \"null-exclusion check failed\"      & NUL;\n+   Rmsg_10 : constant String := \"overflow check failed\"            & NUL;\n+   Rmsg_11 : constant String := \"partition check failed\"           & NUL;\n+   Rmsg_12 : constant String := \"range check failed\"               & NUL;\n+   Rmsg_13 : constant String := \"tag check failed\"                 & NUL;\n+   Rmsg_14 : constant String := \"access before elaboration\"        & NUL;\n+   Rmsg_15 : constant String := \"accessibility check failed\"       & NUL;\n+   Rmsg_16 : constant String := \"all guards closed\"                & NUL;\n+   Rmsg_17 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_18 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_19 : constant String := \"finalize/adjust raised exception\" & NUL;\n+   Rmsg_20 : constant String := \"implicit return with No_Return\"   & NUL;\n+   Rmsg_21 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_22 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_23 : constant String := \"overlaid controlled object\"       & NUL;\n+   Rmsg_24 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_25 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_26 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_27 : constant String := \"illegal use of remote access-to-\" &\n+                                \"class-wide type, see RM E.4(18)\"  & NUL;\n+   Rmsg_28 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_29 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_30 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_31 : constant String := \"object too large\"                 & NUL;\n+   Rmsg_32 : constant String := \"restriction violation\"            & NUL;\n+\n+   -----------------------\n+   -- Polling Interface --\n+   -----------------------\n+\n+   type Unsigned is mod 2 ** 32;\n+\n+   Counter : Unsigned := 0;\n+   pragma Warnings (Off, Counter);\n+   --  This counter is provided for convenience. It can be used in Poll to\n+   --  perform periodic but not systematic operations.\n+\n+   procedure Poll is separate;\n+   --  The actual polling routine is separate, so that it can easily\n+   --  be replaced with a target dependent version.\n+\n+   --------------------------\n+   -- Code_Address_For_AAA --\n+   --------------------------\n+\n+   --  This function gives us the start of the PC range for addresses\n+   --  within the exception unit itself. We hope that gigi/gcc keep all the\n+   --  procedures in their original order!\n+\n+   function Code_Address_For_AAA return System.Address is\n+   begin\n+      --  We are using a label instead of merely using\n+      --  Code_Address_For_AAA'Address because on some platforms the latter\n+      --  does not yield the address we want, but the address of a stub or of\n+      --  a descriptor instead. This is the case at least on Alpha-VMS and\n+      --  PA-HPUX.\n+\n+      <<Start_Of_AAA>>\n+      return Start_Of_AAA'Address;\n+   end Code_Address_For_AAA;\n+\n+   ----------------\n+   -- Call_Chain --\n+   ----------------\n+\n+   procedure Call_Chain (Excep : EOA) is separate;\n+   --  The actual Call_Chain routine is separate, so that it can easily\n+   --  be dummied out when no exception traceback information is needed.\n+\n+   ------------------------------\n+   -- Current_Target_Exception --\n+   ------------------------------\n+\n+   function Current_Target_Exception return Exception_Occurrence is\n+   begin\n+      return Null_Occurrence;\n+   end Current_Target_Exception;\n+\n+   -------------------\n+   -- EId_To_String --\n+   -------------------\n+\n+   function EId_To_String (X : Exception_Id) return String\n+     renames Stream_Attributes.EId_To_String;\n+\n+   ------------------\n+   -- EO_To_String --\n+   ------------------\n+\n+   --  We use the null string to represent the null occurrence, otherwise\n+   --  we output the Exception_Information string for the occurrence.\n+\n+   function EO_To_String (X : Exception_Occurrence) return String\n+     renames Stream_Attributes.EO_To_String;\n+\n+   ------------------------\n+   -- Exception_Identity --\n+   ------------------------\n+\n+   function Exception_Identity\n+     (X : Exception_Occurrence) return Exception_Id\n+   is\n+   begin\n+      --  Note that the following test used to be here for the original\n+      --  Ada 95 semantics, but these were modified by AI-241 to require\n+      --  returning Null_Id instead of raising Constraint_Error.\n+\n+      --  if X.Id = Null_Id then\n+      --     raise Constraint_Error;\n+      --  end if;\n+\n+      return X.Id;\n+   end Exception_Identity;\n+\n+   ---------------------------\n+   -- Exception_Information --\n+   ---------------------------\n+\n+   function Exception_Information (X : Exception_Occurrence) return String is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Exception_Data.Exception_Information (X);\n+   end Exception_Information;\n+\n+   -----------------------\n+   -- Exception_Message --\n+   -----------------------\n+\n+   function Exception_Message (X : Exception_Occurrence) return String is\n+   begin\n+      if X.Id = Null_Id then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return X.Msg (1 .. X.Msg_Length);\n+   end Exception_Message;\n+\n+   --------------------\n+   -- Exception_Name --\n+   --------------------\n+\n+   function Exception_Name (Id : Exception_Id) return String is\n+   begin\n+      if Id = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return To_Ptr (Id.Full_Name) (1 .. Id.Name_Length - 1);\n+   end Exception_Name;\n+\n+   function Exception_Name (X : Exception_Occurrence) return String is\n+   begin\n+      return Exception_Name (X.Id);\n+   end Exception_Name;\n+\n+   ---------------------------\n+   -- Exception_Name_Simple --\n+   ---------------------------\n+\n+   function Exception_Name_Simple (X : Exception_Occurrence) return String is\n+      Name : constant String := Exception_Name (X);\n+      P    : Natural;\n+\n+   begin\n+      P := Name'Length;\n+      while P > 1 loop\n+         exit when Name (P - 1) = '.';\n+         P := P - 1;\n+      end loop;\n+\n+      --  Return result making sure lower bound is 1\n+\n+      declare\n+         subtype Rname is String (1 .. Name'Length - P + 1);\n+      begin\n+         return Rname (Name (P .. Name'Length));\n+      end;\n+   end Exception_Name_Simple;\n+\n+   --------------------\n+   -- Exception_Data --\n+   --------------------\n+\n+   package body Exception_Data is separate;\n+   --  This package can be easily dummied out if we do not want the\n+   --  basic support for exception messages (such as in Ada 83).\n+\n+   ---------------------------\n+   -- Exception_Propagation --\n+   ---------------------------\n+\n+   package body Exception_Propagation is separate;\n+   --  Depending on the actual exception mechanism used (front-end or\n+   --  back-end based), the implementation will differ, which is why this\n+   --  package is separated.\n+\n+   ----------------------\n+   -- Exception_Traces --\n+   ----------------------\n+\n+   package body Exception_Traces is separate;\n+   --  Depending on the underlying support for IO the implementation\n+   --  will differ. Moreover we would like to dummy out this package\n+   --  in case we do not want any exception tracing support. This is\n+   --  why this package is separated.\n+\n+   -----------------------\n+   -- Stream Attributes --\n+   -----------------------\n+\n+   package body Stream_Attributes is separate;\n+   --  This package can be easily dummied out if we do not want the\n+   --  support for streaming Exception_Ids and Exception_Occurrences.\n+\n+   ----------------------------\n+   -- Raise_Constraint_Error --\n+   ----------------------------\n+\n+   procedure Raise_Constraint_Error\n+     (File : System.Address;\n+      Line : Integer)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Constraint_Error_Def'Access, File, Line);\n+   end Raise_Constraint_Error;\n+\n+   --------------------------------\n+   -- Raise_Constraint_Error_Msg --\n+   --------------------------------\n+\n+   procedure Raise_Constraint_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Constraint_Error_Def'Access, File, Line, Msg);\n+   end Raise_Constraint_Error_Msg;\n+\n+   -------------------------\n+   -- Raise_Current_Excep --\n+   -------------------------\n+\n+   procedure Raise_Current_Excep (E : Exception_Id) is\n+\n+      pragma Inspection_Point (E);\n+      --  This is so the debugger can reliably inspect the parameter when\n+      --  inserting a breakpoint at the start of this procedure.\n+\n+      Id : Exception_Id := E;\n+      pragma Volatile (Id);\n+      pragma Warnings (Off, Id);\n+      --  In order to provide support for breakpoints on unhandled exceptions,\n+      --  the debugger will also need to be able to inspect the value of E from\n+      --  another (inner) frame. So we need to make sure that if E is passed in\n+      --  a register, its value is also spilled on stack. For this, we store\n+      --  the parameter value in a local variable, and add a pragma Volatile to\n+      --  make sure it is spilled. The pragma Warnings (Off) is needed because\n+      --  the compiler knows that Id is not referenced and that this use of\n+      --  pragma Volatile is peculiar!\n+\n+   begin\n+      Exception_Propagation.Propagate_Exception\n+        (E => E, From_Signal_Handler => False);\n+   end Raise_Current_Excep;\n+\n+   ---------------------\n+   -- Raise_Exception --\n+   ---------------------\n+\n+   procedure Raise_Exception\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+   begin\n+      if E /= null then\n+         Exception_Data.Set_Exception_Msg (E, Message);\n+         Abort_Defer.all;\n+         Raise_Current_Excep (E);\n+      end if;\n+\n+      --  Note: if E is null, then we simply return, which is correct Ada 95\n+      --  semantics. If we are operating in Ada 2005 mode, then the expander\n+      --  generates a raise Constraint_Error immediately following the call\n+      --  to provide the required Ada 2005 semantics (see AI-329). We do it\n+      --  this way to avoid having run time dependencies on the Ada version.\n+\n+      return;\n+   end Raise_Exception;\n+\n+   ----------------------------\n+   -- Raise_Exception_Always --\n+   ----------------------------\n+\n+   procedure Raise_Exception_Always\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+   begin\n+      Exception_Data.Set_Exception_Msg (E, Message);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_Exception_Always;\n+\n+   -------------------------------\n+   -- Raise_From_Signal_Handler --\n+   -------------------------------\n+\n+   procedure Raise_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address)\n+   is\n+   begin\n+      Exception_Data.Set_Exception_C_Msg (E, M);\n+      Abort_Defer.all;\n+      Exception_Propagation.Propagate_Exception\n+        (E => E, From_Signal_Handler => True);\n+   end Raise_From_Signal_Handler;\n+\n+   -------------------------\n+   -- Raise_Program_Error --\n+   -------------------------\n+\n+   procedure Raise_Program_Error\n+     (File : System.Address;\n+      Line : Integer)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Program_Error_Def'Access, File, Line);\n+   end Raise_Program_Error;\n+\n+   -----------------------------\n+   -- Raise_Program_Error_Msg --\n+   -----------------------------\n+\n+   procedure Raise_Program_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Program_Error_Def'Access, File, Line, Msg);\n+   end Raise_Program_Error_Msg;\n+\n+   -------------------------\n+   -- Raise_Storage_Error --\n+   -------------------------\n+\n+   procedure Raise_Storage_Error\n+     (File : System.Address;\n+      Line : Integer)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Storage_Error_Def'Access, File, Line);\n+   end Raise_Storage_Error;\n+\n+   -----------------------------\n+   -- Raise_Storage_Error_Msg --\n+   -----------------------------\n+\n+   procedure Raise_Storage_Error_Msg\n+     (File : System.Address;\n+      Line : Integer;\n+      Msg  : System.Address)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Storage_Error_Def'Access, File, Line, Msg);\n+   end Raise_Storage_Error_Msg;\n+\n+   ---------------------------------\n+   -- Raise_With_Location_And_Msg --\n+   ---------------------------------\n+\n+   procedure Raise_With_Location_And_Msg\n+     (E : Exception_Id;\n+      F : System.Address;\n+      L : Integer;\n+      M : System.Address := System.Null_Address)\n+   is\n+   begin\n+      Exception_Data.Set_Exception_C_Msg (E, F, L, M);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Location_And_Msg;\n+\n+   --------------------\n+   -- Raise_With_Msg --\n+   --------------------\n+\n+   procedure Raise_With_Msg (E : Exception_Id) is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Exception_Propagation.Setup_Exception (Excep, Excep);\n+\n+      Excep.Exception_Raised := False;\n+      Excep.Id               := E;\n+      Excep.Num_Tracebacks   := 0;\n+      Excep.Cleanup_Flag     := False;\n+      Excep.Pid              := Local_Partition_ID;\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Msg;\n+\n+   --------------------------------------\n+   -- Calls to Run-Time Check Routines --\n+   --------------------------------------\n+\n+   procedure Rcheck_00 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_00'Address);\n+   end Rcheck_00;\n+\n+   procedure Rcheck_01 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_01'Address);\n+   end Rcheck_01;\n+\n+   procedure Rcheck_02 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_02'Address);\n+   end Rcheck_02;\n+\n+   procedure Rcheck_03 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_03'Address);\n+   end Rcheck_03;\n+\n+   procedure Rcheck_04 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_04'Address);\n+   end Rcheck_04;\n+\n+   procedure Rcheck_05 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_05'Address);\n+   end Rcheck_05;\n+\n+   procedure Rcheck_06 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_06'Address);\n+   end Rcheck_06;\n+\n+   procedure Rcheck_07 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_07'Address);\n+   end Rcheck_07;\n+\n+   procedure Rcheck_08 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_08'Address);\n+   end Rcheck_08;\n+\n+   procedure Rcheck_09 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_09'Address);\n+   end Rcheck_09;\n+\n+   procedure Rcheck_10 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_10'Address);\n+   end Rcheck_10;\n+\n+   procedure Rcheck_11 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_11'Address);\n+   end Rcheck_11;\n+\n+   procedure Rcheck_12 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_12'Address);\n+   end Rcheck_12;\n+\n+   procedure Rcheck_13 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_13'Address);\n+   end Rcheck_13;\n+\n+   procedure Rcheck_14 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_14'Address);\n+   end Rcheck_14;\n+\n+   procedure Rcheck_15 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_15'Address);\n+   end Rcheck_15;\n+\n+   procedure Rcheck_16 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_16'Address);\n+   end Rcheck_16;\n+\n+   procedure Rcheck_17 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_17'Address);\n+   end Rcheck_17;\n+\n+   procedure Rcheck_18 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_18'Address);\n+   end Rcheck_18;\n+\n+   procedure Rcheck_19 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_19'Address);\n+   end Rcheck_19;\n+\n+   procedure Rcheck_20 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_20'Address);\n+   end Rcheck_20;\n+\n+   procedure Rcheck_21 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_21'Address);\n+   end Rcheck_21;\n+\n+   procedure Rcheck_22 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_22'Address);\n+   end Rcheck_22;\n+\n+   procedure Rcheck_23 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_23'Address);\n+   end Rcheck_23;\n+\n+   procedure Rcheck_24 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_24'Address);\n+   end Rcheck_24;\n+\n+   procedure Rcheck_25 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_25'Address);\n+   end Rcheck_25;\n+\n+   procedure Rcheck_26 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_26'Address);\n+   end Rcheck_26;\n+\n+   procedure Rcheck_27 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_27'Address);\n+   end Rcheck_27;\n+\n+   procedure Rcheck_28 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_28'Address);\n+   end Rcheck_28;\n+\n+   procedure Rcheck_29 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_29'Address);\n+   end Rcheck_29;\n+\n+   procedure Rcheck_30 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_30'Address);\n+   end Rcheck_30;\n+\n+   procedure Rcheck_31 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_31'Address);\n+   end Rcheck_31;\n+\n+   procedure Rcheck_32 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_32'Address);\n+   end Rcheck_32;\n+\n+   -------------\n+   -- Reraise --\n+   -------------\n+\n+   procedure Reraise is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      Abort_Defer.all;\n+      Exception_Propagation.Setup_Exception (Excep, Excep, Reraised => True);\n+      Raise_Current_Excep (Excep.Id);\n+   end Reraise;\n+\n+   ------------------------\n+   -- Reraise_Occurrence --\n+   ------------------------\n+\n+   procedure Reraise_Occurrence (X : Exception_Occurrence) is\n+   begin\n+      if X.Id /= null then\n+         Abort_Defer.all;\n+         Exception_Propagation.Setup_Exception\n+           (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n+         Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n+         Raise_Current_Excep (X.Id);\n+      end if;\n+   end Reraise_Occurrence;\n+\n+   -------------------------------\n+   -- Reraise_Occurrence_Always --\n+   -------------------------------\n+\n+   procedure Reraise_Occurrence_Always (X : Exception_Occurrence) is\n+   begin\n+      Abort_Defer.all;\n+      Exception_Propagation.Setup_Exception\n+        (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n+      Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n+      Raise_Current_Excep (X.Id);\n+   end Reraise_Occurrence_Always;\n+\n+   ---------------------------------\n+   -- Reraise_Occurrence_No_Defer --\n+   ---------------------------------\n+\n+   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n+   begin\n+      Exception_Propagation.Setup_Exception\n+        (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n+      Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n+      Raise_Current_Excep (X.Id);\n+   end Reraise_Occurrence_No_Defer;\n+\n+   ---------------------\n+   -- Save_Occurrence --\n+   ---------------------\n+\n+   procedure Save_Occurrence\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence)\n+   is\n+   begin\n+      Save_Occurrence_No_Private (Target, Source);\n+   end Save_Occurrence;\n+\n+   function Save_Occurrence (Source : Exception_Occurrence) return EOA is\n+      Target : constant EOA := new Exception_Occurrence;\n+   begin\n+      Save_Occurrence (Target.all, Source);\n+      return Target;\n+   end Save_Occurrence;\n+\n+   --------------------------------\n+   -- Save_Occurrence_No_Private --\n+   --------------------------------\n+\n+   procedure Save_Occurrence_No_Private\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence)\n+   is\n+   begin\n+      Target.Id             := Source.Id;\n+      Target.Msg_Length     := Source.Msg_Length;\n+      Target.Num_Tracebacks := Source.Num_Tracebacks;\n+      Target.Pid            := Source.Pid;\n+      Target.Cleanup_Flag   := Source.Cleanup_Flag;\n+\n+      Target.Msg (1 .. Target.Msg_Length) :=\n+        Source.Msg (1 .. Target.Msg_Length);\n+\n+      Target.Tracebacks (1 .. Target.Num_Tracebacks) :=\n+        Source.Tracebacks (1 .. Target.Num_Tracebacks);\n+   end Save_Occurrence_No_Private;\n+\n+   -------------------------\n+   -- Transfer_Occurrence --\n+   -------------------------\n+\n+   procedure Transfer_Occurrence\n+     (Target : Exception_Occurrence_Access;\n+      Source : Exception_Occurrence)\n+   is\n+   begin\n+      --  Setup Target as an exception to be propagated in the calling task\n+      --  (rendezvous-wise), taking care not to clobber the associated private\n+      --  data.  Target is expected to be a pointer to the calling task's\n+      --  fixed TSD occurrence, which is very different from Get_Current_Excep\n+      --  here because this subprogram is called from the called task.\n+\n+      Exception_Propagation.Setup_Exception (Target, Target);\n+      Save_Occurrence_No_Private (Target.all, Source);\n+   end Transfer_Occurrence;\n+\n+   -------------------\n+   -- String_To_EId --\n+   -------------------\n+\n+   function String_To_EId (S : String) return Exception_Id\n+     renames Stream_Attributes.String_To_EId;\n+\n+   ------------------\n+   -- String_To_EO --\n+   ------------------\n+\n+   function String_To_EO (S : String) return Exception_Occurrence\n+     renames Stream_Attributes.String_To_EO;\n+\n+   ------------------------------\n+   -- Raise_Exception_No_Defer --\n+   ------------------------------\n+\n+   procedure Raise_Exception_No_Defer\n+     (E       : Exception_Id;\n+      Message : String := \"\")\n+   is\n+   begin\n+      Exception_Data.Set_Exception_Msg (E, Message);\n+\n+      --  Do not call Abort_Defer.all, as specified by the spec\n+\n+      Raise_Current_Excep (E);\n+   end Raise_Exception_No_Defer;\n+\n+   ---------------\n+   -- To_Stderr --\n+   ---------------\n+\n+   procedure To_Stderr (C : Character) is\n+\n+      type int is new Integer;\n+\n+      procedure put_char_stderr (C : int);\n+      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n+\n+   begin\n+      put_char_stderr (Character'Pos (C));\n+   end To_Stderr;\n+\n+   procedure To_Stderr (S : String) is\n+   begin\n+      for J in S'Range loop\n+         if S (J) /= ASCII.CR then\n+            To_Stderr (S (J));\n+         end if;\n+      end loop;\n+   end To_Stderr;\n+\n+   -------------------------\n+   -- Wide_Exception_Name --\n+   -------------------------\n+\n+   WC_Encoding : Character;\n+   pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Encoding method for source, as exported by binder\n+\n+   function Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_String is\n+   begin\n+      return String_To_Wide_String\n+        (Exception_Name (Id), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Exception_Name;\n+\n+   function Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_String is\n+   begin\n+      return String_To_Wide_String\n+        (Exception_Name (X), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Exception_Name;\n+\n+   ----------------------------\n+   -- Wide_Wide_Exception_Name --\n+   -----------------------------\n+\n+   function Wide_Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_Wide_String\n+   is\n+   begin\n+      return String_To_Wide_Wide_String\n+        (Exception_Name (Id), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Wide_Exception_Name;\n+\n+   function Wide_Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_Wide_String\n+   is\n+   begin\n+      return String_To_Wide_Wide_String\n+        (Exception_Name (X), Get_WC_Encoding_Method (WC_Encoding));\n+   end Wide_Wide_Exception_Name;\n+\n+   --------------------------\n+   -- Code_Address_For_ZZZ --\n+   --------------------------\n+\n+   --  This function gives us the end of the PC range for addresses\n+   --  within the exception unit itself. We hope that gigi/gcc keeps all the\n+   --  procedures in their original order!\n+\n+   function Code_Address_For_ZZZ return System.Address is\n+   begin\n+      <<Start_Of_ZZZ>>\n+      return Start_Of_ZZZ'Address;\n+   end Code_Address_For_ZZZ;\n+\n+end Ada.Exceptions;"}, {"sha": "ff06e9801a06fe82f67e08692280aa2a34b8a0b2", "filename": "gcc/ada/a-except-2005.ads", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except-2005.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except-2005.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.ads?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -0,0 +1,335 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       A D A . E X C E P T I O N S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version is used for all Ada 2005 builds. It differs from a-except.ads\n+--  only with respect to the addition of Wide_[Wide]Exception_Name functions.\n+--  The additional entities are marked with pragma Ada_05, so this extended\n+--  unit is also perfectly suitable for use in Ada 95 or Ada 83 mode.\n+\n+--  The reason for this splitting off of a separate version is that bootstrap\n+--  compilers often will be used that do not support Ada 2005 features, and\n+--  Ada.Exceptions is part of the compiler sources.\n+\n+--  The base version of this unit Ada.Exceptions omits the Wide version of\n+--  Exception_Name and is used to build the compiler and other basic tools.\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we get\n+--  elaboration circularities with ourself.\n+\n+with System;\n+with System.Parameters;\n+with System.Standard_Library;\n+with System.Traceback_Entries;\n+\n+package Ada.Exceptions is\n+   pragma Warnings (Off);\n+   pragma Preelaborate_05;\n+   pragma Warnings (On);\n+   --  In accordance with Ada 2005 AI-362. The warnings pragmas are so that we\n+   --  can compile this using older compiler versions, which will ignore the\n+   --  pragma, which is fine for the bootstrap.\n+\n+   type Exception_Id is private;\n+   Null_Id : constant Exception_Id;\n+\n+   type Exception_Occurrence is limited private;\n+   type Exception_Occurrence_Access is access all Exception_Occurrence;\n+\n+   Null_Occurrence : constant Exception_Occurrence;\n+\n+   function Exception_Name (Id : Exception_Id) return String;\n+\n+   function Exception_Name (X : Exception_Occurrence) return String;\n+\n+   function Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_String;\n+   pragma Ada_05 (Wide_Exception_Name);\n+\n+   function Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_String;\n+   pragma Ada_05 (Wide_Exception_Name);\n+\n+   function Wide_Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Exception_Name);\n+\n+   function Wide_Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Exception_Name);\n+\n+   procedure Raise_Exception (E : Exception_Id; Message : String := \"\");\n+   --  Note: it would be really nice to give a pragma No_Return for this\n+   --  procedure, but it would be wrong, since Raise_Exception does return\n+   --  if given the null exception. However we do special case the name in\n+   --  the test in the compiler for issuing a warning for a missing return\n+   --  after this call. Program_Error seems reasonable enough in such a case.\n+   --  See also the routine Raise_Exception_Always in the private part.\n+\n+   function Exception_Message (X : Exception_Occurrence) return String;\n+\n+   procedure Reraise_Occurrence (X : Exception_Occurrence);\n+   --  Note: it would be really nice to give a pragma No_Return for this\n+   --  procedure, but it would be wrong, since Reraise_Occurrence does return\n+   --  if the argument is the null exception occurrence. See also procedure\n+   --  Reraise_Occurrence_Always in the private part of this package.\n+\n+   function Exception_Identity (X : Exception_Occurrence) return Exception_Id;\n+\n+   function Exception_Information (X : Exception_Occurrence) return String;\n+   --  The format of the exception information is as follows:\n+   --\n+   --    exception name (as in Exception_Name)\n+   --    message (or a null line if no message)\n+   --    PID=nnnn\n+   --    0xyyyyyyyy 0xyyyyyyyy ...\n+   --\n+   --  The lines are separated by a ASCII.LF character\n+   --  The nnnn is the partition Id given as decimal digits.\n+   --  The 0x... line represents traceback program counter locations,\n+   --  in order with the first one being the exception location.\n+\n+   --  Note on ordering: the compiler uses the Save_Occurrence procedure, but\n+   --  not the function from Rtsfind, so it is important that the procedure\n+   --  come first, since Rtsfind finds the first matching entity.\n+\n+   procedure Save_Occurrence\n+     (Target : out Exception_Occurrence;\n+      Source : Exception_Occurrence);\n+\n+   function Save_Occurrence\n+     (Source : Exception_Occurrence)\n+      return   Exception_Occurrence_Access;\n+\n+private\n+   package SSL renames System.Standard_Library;\n+   package SP renames System.Parameters;\n+\n+   subtype EOA is Exception_Occurrence_Access;\n+\n+   Exception_Msg_Max_Length : constant := SP.Default_Exception_Msg_Max_Length;\n+\n+   ------------------\n+   -- Exception_Id --\n+   ------------------\n+\n+   subtype Code_Loc is System.Address;\n+   --  Code location used in building exception tables and for call addresses\n+   --  when propagating an exception. Values of this type are created by using\n+   --  Label'Address or extracted from machine states using Get_Code_Loc.\n+\n+   Null_Loc : constant Code_Loc := System.Null_Address;\n+   --  Null code location, used to flag outer level frame\n+\n+   type Exception_Id is new SSL.Exception_Data_Ptr;\n+\n+   function EId_To_String (X : Exception_Id) return String;\n+   function String_To_EId (S : String) return Exception_Id;\n+   pragma Stream_Convert (Exception_Id, String_To_EId, EId_To_String);\n+   --  Functions for implementing Exception_Id stream attributes\n+\n+   Null_Id : constant Exception_Id := null;\n+\n+   -------------------------\n+   -- Private Subprograms --\n+   -------------------------\n+\n+   function Current_Target_Exception return Exception_Occurrence;\n+   pragma Export\n+     (Ada, Current_Target_Exception,\n+      \"__gnat_current_target_exception\");\n+   --  This routine should return the current raised exception on targets\n+   --  which have built-in exception handling such as the Java Virtual\n+   --  Machine. For other targets this routine is simply ignored. Currently,\n+   --  only JGNAT uses this. See 4jexcept.ads for details. The pragma Export\n+   --  allows this routine to be accessed elsewhere in the run-time, even\n+   --  though it is in the private part of this package (it is not allowed\n+   --  to be in the visible part, since this is set by the reference manual).\n+\n+   function Exception_Name_Simple (X : Exception_Occurrence) return String;\n+   --  Like Exception_Name, but returns the simple non-qualified name of the\n+   --  exception. This is used to implement the Exception_Name function in\n+   --  Current_Exceptions (the DEC compatible unit). It is called from the\n+   --  compiler generated code (using Rtsfind, which does not respect the\n+   --  private barrier, so we can place this function in the private part\n+   --  where the compiler can find it, but the spec is unchanged.)\n+\n+   procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n+   pragma No_Return (Raise_Exception_Always);\n+   pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");\n+   --  This differs from Raise_Exception only in that the caller has determined\n+   --  that for sure the parameter E is not null, and that therefore the call\n+   --  to this procedure cannot return. The expander converts Raise_Exception\n+   --  calls to Raise_Exception_Always if it can determine this is the case.\n+   --  The Export allows this routine to be accessed from Pure units.\n+\n+   procedure Raise_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address);\n+   pragma Export\n+     (Ada, Raise_From_Signal_Handler,\n+           \"ada__exceptions__raise_from_signal_handler\");\n+   pragma No_Return (Raise_From_Signal_Handler);\n+   --  This routine is used to raise an exception from a signal handler. The\n+   --  signal handler has already stored the machine state (i.e. the state that\n+   --  corresponds to the location at which the signal was raised). E is the\n+   --  Exception_Id specifying what exception is being raised, and M is a\n+   --  pointer to a null-terminated string which is the message to be raised.\n+   --  Note that this routine never returns, so it is permissible to simply\n+   --  jump to this routine, rather than call it. This may be appropriate for\n+   --  systems where the right way to get out of signal handler is to alter the\n+   --  PC value in the machine state or in some other way ask the operating\n+   --  system to return here rather than to the original location.\n+\n+   procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n+   pragma No_Return (Reraise_Occurrence_Always);\n+   --  This differs from Raise_Occurrence only in that the caller guarantees\n+   --  that for sure the parameter X is not the null occurrence, and that\n+   --  therefore this procedure cannot return. The expander uses this routine\n+   --  in the translation of a raise statement with no parameter (reraise).\n+\n+   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence);\n+   pragma No_Return (Reraise_Occurrence_No_Defer);\n+   --  Exactly like Reraise_Occurrence, except that abort is not deferred\n+   --  before the call and the parameter X is known not to be the null\n+   --  occurrence. This is used in generated code when it is known that\n+   --  abort is already deferred.\n+\n+   -----------------------\n+   -- Polling Interface --\n+   -----------------------\n+\n+   --  The GNAT compiler has an option to generate polling calls to the Poll\n+   --  routine in this package. Specifying the -gnatP option for a compilation\n+   --  causes a call to Ada.Exceptions.Poll to be generated on every subprogram\n+   --  entry and on every iteration of a loop, thus avoiding the possibility of\n+   --  a case of unbounded time between calls.\n+\n+   --  This polling interface may be used for instrumentation or debugging\n+   --  purposes (e.g. implementing watchpoints in software or in the debugger).\n+\n+   --  In the GNAT technology itself, this interface is used to implement\n+   --  immediate aynschronous transfer of control and immediate abort on\n+   --  targets which do not provide for one thread interrupting another.\n+\n+   --  Note: this used to be in a separate unit called System.Poll, but that\n+   --  caused horrible circular elaboration problems between System.Poll and\n+   --  Ada.Exceptions. One way of solving such circularities is unification!\n+\n+   procedure Poll;\n+   --  Check for asynchronous abort. Note that we do not inline the body.\n+   --  This makes the interface more useful for debugging purposes.\n+\n+   --------------------------\n+   -- Exception_Occurrence --\n+   --------------------------\n+\n+   package TBE renames System.Traceback_Entries;\n+\n+   Max_Tracebacks : constant := 50;\n+   --  Maximum number of trace backs stored in exception occurrence\n+\n+   type Tracebacks_Array is array (1 .. Max_Tracebacks) of TBE.Traceback_Entry;\n+   --  Traceback array stored in exception occurrence\n+\n+   type Exception_Occurrence is record\n+      Id : Exception_Id;\n+      --  Exception_Identity for this exception occurrence\n+      --  WARNING System.System.Finalization_Implementation.Finalize_List\n+      --  relies on the fact that this field is always first in the exception\n+      --  occurrence\n+\n+      Msg_Length : Natural := 0;\n+      --  Length of message (zero = no message)\n+\n+      Msg : String (1 .. Exception_Msg_Max_Length);\n+      --  Characters of message\n+\n+      Cleanup_Flag : Boolean := False;\n+      --  The cleanup flag is normally False, it is set True for an exception\n+      --  occurrence passed to a cleanup routine, and will still be set True\n+      --  when the cleanup routine does a Reraise_Occurrence call using this\n+      --  exception occurrence. This is used to avoid recording a bogus trace\n+      --  back entry from this reraise call.\n+\n+      Exception_Raised : Boolean := False;\n+      --  Set to true to indicate that this exception occurrence has actually\n+      --  been raised. When an exception occurrence is first created, this is\n+      --  set to False, then when it is processed by Raise_Current_Exception,\n+      --  it is set to True. If Raise_Current_Exception is used to raise an\n+      --  exception for which this flag is already True, then it knows that\n+      --  it is dealing with the reraise case (which is useful to distinguish\n+      --  for exception tracing purposes).\n+\n+      Pid : Natural := 0;\n+      --  Partition_Id for partition raising exception\n+\n+      Num_Tracebacks : Natural range 0 .. Max_Tracebacks := 0;\n+      --  Number of traceback entries stored\n+\n+      Tracebacks : Tracebacks_Array;\n+      --  Stored tracebacks (in Tracebacks (1 .. Num_Tracebacks))\n+\n+      Private_Data : System.Address := System.Null_Address;\n+      --  Field used by low level exception mechanism to store specific data.\n+      --  Currently used by the GCC exception mechanism to store a pointer to\n+      --  a GNAT_GCC_Exception.\n+   end record;\n+\n+   function \"=\" (Left, Right : Exception_Occurrence) return Boolean\n+     is abstract;\n+   --  Don't allow comparison on exception occurrences, we should not need\n+   --  this, and it would not work right, because of the Msg and Tracebacks\n+   --  fields which have unused entries not copied by Save_Occurrence.\n+\n+   function EO_To_String (X : Exception_Occurrence) return String;\n+   function String_To_EO (S : String) return Exception_Occurrence;\n+   pragma Stream_Convert (Exception_Occurrence, String_To_EO, EO_To_String);\n+   --  Functions for implementing Exception_Occurrence stream attributes\n+\n+   Null_Occurrence : constant Exception_Occurrence := (\n+     Id               => null,\n+     Msg_Length       => 0,\n+     Msg              => (others => ' '),\n+     Cleanup_Flag     => False,\n+     Exception_Raised => False,\n+     Pid              => 0,\n+     Num_Tracebacks   => 0,\n+     Tracebacks       => (others => TBE.Null_TB_Entry),\n+     Private_Data     => System.Null_Address);\n+\n+end Ada.Exceptions;"}, {"sha": "2539501f172b79eabad7eb3568a66aaf4e6266b6", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 107, "deletions": 155, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,15 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This version of Ada.Exceptions is a full Ada 95 version, but lacks the\n+--  additional definitions of Exception_Name returning Wide_[Wide_]String.\n+--  It is used for building the compiler and the basic tools, since these\n+--  builds may be done with bootstrap compilers that cannot handle these\n+--  additions. The full version of Ada.Exceptions can be found in the files\n+--  a-except-2005.ads/adb, and is used for all other builds where full Ada\n+--  2005 functionality is required. in particular, it is used for building\n+--  run times on all targets.\n+\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with System.Exception_Tables.\n@@ -54,45 +63,11 @@ package body Ada.Exceptions is\n    --  from C clients using the given external name, even though they are not\n    --  technically visible in the Ada sense.\n \n-   function Code_Address_For_AAA return System.Address;\n-   function Code_Address_For_ZZZ return System.Address;\n-   --  Return start and end of procedures in this package\n-   --\n-   --  These procedures are used to provide exclusion bounds in\n-   --  calls to Call_Chain at exception raise points from this unit. The\n-   --  purpose is to arrange for the exception tracebacks not to include\n-   --  frames from routines involved in the raise process, as these are\n-   --  meaningless from the user's standpoint.\n-   --\n-   --  For these bounds to be meaningful, we need to ensure that the object\n-   --  code for the routines involved in processing a raise is located after\n-   --  the object code Code_Address_For_AAA and before the object code\n-   --  Code_Address_For_ZZZ. This will indeed be the case as long as the\n-   --  following rules are respected:\n-   --\n-   --  1) The bodies of the subprograms involved in processing a raise\n-   --     are located after the body of Code_Address_For_AAA and before the\n-   --     body of Code_Address_For_ZZZ.\n-   --\n-   --  2) No pragma Inline applies to any of these subprograms, as this\n-   --     could delay the corresponding assembly output until the end of\n-   --     the unit.\n-\n-   procedure Call_Chain (Excep : EOA);\n-   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n-   --  call chain.\n-\n-   procedure Process_Raise_Exception\n-     (E                   : Exception_Id;\n-      From_Signal_Handler : Boolean);\n+   procedure Process_Raise_Exception (E : Exception_Id);\n    pragma No_Return (Process_Raise_Exception);\n    --  This is the lowest level raise routine. It raises the exception\n    --  referenced by Current_Excep.all in the TSD, without deferring abort\n    --  (the caller must ensure that abort is deferred on entry).\n-   --\n-   --  This is the common implementation for Raise_Current_Excep and\n-   --  Raise_From_Signal_Handler. The origin of the call is indicated by the\n-   --  From_Signal_Handler argument.\n \n    procedure To_Stderr (S : String);\n    pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n@@ -227,34 +202,11 @@ package body Ada.Exceptions is\n \n    package Exception_Propagation is\n \n-      use Exception_Traces;\n-      --  Imports Notify_Unhandled_Exception and\n-      --  Unhandled_Exception_Terminate\n-\n-      ------------------------------------\n-      -- Exception propagation routines --\n-      ------------------------------------\n-\n       procedure Setup_Exception\n         (Excep    : EOA;\n          Current  : EOA;\n          Reraised : Boolean := False);\n-      --  Perform the necessary operations to prepare the propagation of Excep\n-      --  in a task where Current is the current occurrence. Excep is assumed\n-      --  to be a valid (non null) pointer.\n-      --\n-      --  This should be called before any (re-)setting of the current\n-      --  occurrence. Any such (re-)setting shall take care *not* to clobber\n-      --  the Private_Data component.\n-      --\n-      --  Having Current provided as an argument (instead of retrieving it via\n-      --  Get_Current_Excep internally) is required to allow one task to setup\n-      --  an exception for another task, which is used by Transfer_Occurrence.\n-\n-      procedure Propagate_Exception (From_Signal_Handler : Boolean);\n-      pragma No_Return (Propagate_Exception);\n-      --  This procedure propagates the exception represented by the occurrence\n-      --  referenced by Current_Excep in the TSD for the current task.\n+      --  Dummy routine used to share a-exexda.adb, do nothing.\n \n    end Exception_Propagation;\n \n@@ -278,8 +230,7 @@ package body Ada.Exceptions is\n    procedure Raise_Current_Excep (E : Exception_Id);\n    pragma No_Return (Raise_Current_Excep);\n    pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n-   --  This is a simple wrapper to Process_Raise_Exception setting the\n-   --  From_Signal_Handler argument to False.\n+   --  This is a simple wrapper to Process_Raise_Exception.\n    --\n    --  This external name for Raise_Current_Excep is historical, and probably\n    --  should be changed but for now we keep it, because gdb and gigi know\n@@ -453,6 +404,8 @@ package body Ada.Exceptions is\n    procedure Rcheck_28 (File : System.Address; Line : Integer);\n    procedure Rcheck_29 (File : System.Address; Line : Integer);\n    procedure Rcheck_30 (File : System.Address; Line : Integer);\n+   procedure Rcheck_31 (File : System.Address; Line : Integer);\n+   procedure Rcheck_32 (File : System.Address; Line : Integer);\n \n    pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n    pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n@@ -485,6 +438,8 @@ package body Ada.Exceptions is\n    pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n    pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n    pragma Export (C, Rcheck_30, \"__gnat_rcheck_30\");\n+   pragma Export (C, Rcheck_31, \"__gnat_rcheck_31\");\n+   pragma Export (C, Rcheck_32, \"__gnat_rcheck_32\");\n \n    --  None of these procedures ever returns (they raise an exception!). By\n    --  using pragma No_Return, we ensure that any junk code after the call,\n@@ -521,6 +476,7 @@ package body Ada.Exceptions is\n    pragma No_Return (Rcheck_28);\n    pragma No_Return (Rcheck_29);\n    pragma No_Return (Rcheck_30);\n+   pragma No_Return (Rcheck_32);\n \n    ---------------------------------------------\n    -- Reason Strings for Run-Time Check Calls --\n@@ -539,30 +495,32 @@ package body Ada.Exceptions is\n    Rmsg_05 : constant String := \"index check failed\"               & NUL;\n    Rmsg_06 : constant String := \"invalid data\"                     & NUL;\n    Rmsg_07 : constant String := \"length check failed\"              & NUL;\n-   Rmsg_08 : constant String := \"null-exclusion check failed\"      & NUL;\n-   Rmsg_09 : constant String := \"overflow check failed\"            & NUL;\n-   Rmsg_10 : constant String := \"partition check failed\"           & NUL;\n-   Rmsg_11 : constant String := \"range check failed\"               & NUL;\n-   Rmsg_12 : constant String := \"tag check failed\"                 & NUL;\n-   Rmsg_13 : constant String := \"access before elaboration\"        & NUL;\n-   Rmsg_14 : constant String := \"accessibility check failed\"       & NUL;\n-   Rmsg_15 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_16 : constant String := \"duplicated entry address\"         & NUL;\n-   Rmsg_17 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_18 : constant String := \"finalize/adjust raised exception\" & NUL;\n-   Rmsg_19 : constant String := \"misaligned address value\"         & NUL;\n-   Rmsg_20 : constant String := \"missing return\"                   & NUL;\n-   Rmsg_21 : constant String := \"overlaid controlled object\"       & NUL;\n-   Rmsg_22 : constant String := \"potentially blocking operation\"   & NUL;\n-   Rmsg_23 : constant String := \"stubbed subprogram called\"        & NUL;\n-   Rmsg_24 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_25 : constant String := \"illegal use of\"\n-             & \" remote access-to-class-wide type, see RM E.4(18)\" & NUL;\n-   Rmsg_26 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_27 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_28 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_29 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_30 : constant String := \"restriction violation\"            & NUL;\n+   Rmsg_08 : constant String := \"null Exception_Id\"                & NUL;\n+   Rmsg_09 : constant String := \"null-exclusion check failed\"      & NUL;\n+   Rmsg_10 : constant String := \"overflow check failed\"            & NUL;\n+   Rmsg_11 : constant String := \"partition check failed\"           & NUL;\n+   Rmsg_12 : constant String := \"range check failed\"               & NUL;\n+   Rmsg_13 : constant String := \"tag check failed\"                 & NUL;\n+   Rmsg_14 : constant String := \"access before elaboration\"        & NUL;\n+   Rmsg_15 : constant String := \"accessibility check failed\"       & NUL;\n+   Rmsg_16 : constant String := \"all guards closed\"                & NUL;\n+   Rmsg_17 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_18 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_19 : constant String := \"finalize/adjust raised exception\" & NUL;\n+   Rmsg_20 : constant String := \"implicit return with No_Return\"   & NUL;\n+   Rmsg_21 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_22 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_23 : constant String := \"overlaid controlled object\"       & NUL;\n+   Rmsg_24 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_25 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_26 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_27 : constant String := \"illegal use of remote access-to-\" &\n+                                \"class-wide type, see RM E.4(18)\"  & NUL;\n+   Rmsg_28 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_29 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_30 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_31 : constant String := \"object too large\"                 & NUL;\n+   Rmsg_32 : constant String := \"restriction violation\"            & NUL;\n \n    -----------------------\n    -- Polling Interface --\n@@ -579,34 +537,6 @@ package body Ada.Exceptions is\n    --  The actual polling routine is separate, so that it can easily\n    --  be replaced with a target dependent version.\n \n-   --------------------------\n-   -- Code_Address_For_AAA --\n-   --------------------------\n-\n-   --  This function gives us the start of the PC range for addresses\n-   --  within the exception unit itself. We hope that gigi/gcc keep all the\n-   --  procedures in their original order!\n-\n-   function Code_Address_For_AAA return System.Address is\n-   begin\n-      --  We are using a label instead of merely using\n-      --  Code_Address_For_AAA'Address because on some platforms the latter\n-      --  does not yield the address we want, but the address of a stub or of\n-      --  a descriptor instead. This is the case at least on Alpha-VMS and\n-      --  PA-HPUX.\n-\n-      <<Start_Of_AAA>>\n-      return Start_Of_AAA'Address;\n-   end Code_Address_For_AAA;\n-\n-   ----------------\n-   -- Call_Chain --\n-   ----------------\n-\n-   procedure Call_Chain (Excep : EOA) is separate;\n-   --  The actual Call_Chain routine is separate, so that it can easily\n-   --  be dummied out when no exception traceback information is needed.\n-\n    ------------------------------\n    -- Current_Target_Exception --\n    ------------------------------\n@@ -728,14 +658,21 @@ package body Ada.Exceptions is\n    --  This package can be easily dummied out if we do not want the\n    --  basic support for exception messages (such as in Ada 83).\n \n-   ---------------------------\n-   -- Exception_Propagation --\n-   ---------------------------\n+   package body Exception_Propagation is\n+\n+      procedure Setup_Exception\n+        (Excep    : EOA;\n+         Current  : EOA;\n+         Reraised : Boolean := False)\n+      is\n+         pragma Warnings (Off, Excep);\n+         pragma Warnings (Off, Current);\n+         pragma Warnings (Off, Reraised);\n+      begin\n+         null;\n+      end Setup_Exception;\n \n-   package body Exception_Propagation is separate;\n-   --  Depending on the actual exception mechanism used (front-end or\n-   --  back-end based), the implementation will differ, which is why this\n-   --  package is separated.\n+   end Exception_Propagation;\n \n    ----------------------\n    -- Exception_Traces --\n@@ -759,12 +696,17 @@ package body Ada.Exceptions is\n    -- Process_Raise_Exception --\n    -----------------------------\n \n-   procedure Process_Raise_Exception\n-     (E                   : Exception_Id;\n-      From_Signal_Handler : Boolean)\n-   is\n+   procedure Process_Raise_Exception (E : Exception_Id) is\n       pragma Inspection_Point (E);\n       --  This is so the debugger can reliably inspect the parameter\n+\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+      Excep       : constant EOA := Get_Current_Excep.all;\n+\n+      procedure builtin_longjmp (buffer : Address; Flag : Integer);\n+      pragma No_Return (builtin_longjmp);\n+      pragma Import (C, builtin_longjmp, \"_gnat_builtin_longjmp\");\n+\n    begin\n       --  WARNING: There should be no exception handler for this body\n       --  because this would cause gigi to prepend a setup for a new\n@@ -773,7 +715,23 @@ package body Ada.Exceptions is\n       --  one for the exception we are handling, which would completely break\n       --  the whole design of this procedure.\n \n-      Exception_Propagation.Propagate_Exception (From_Signal_Handler);\n+      --  If the jump buffer pointer is non-null, transfer control using\n+      --  it. Otherwise announce an unhandled exception (note that this\n+      --  means that we have no finalizations to do other than at the outer\n+      --  level). Perform the necessary notification tasks in both cases.\n+\n+      if Jumpbuf_Ptr /= Null_Address then\n+         if not Excep.Exception_Raised then\n+            Excep.Exception_Raised := True;\n+            Exception_Traces.Notify_Handled_Exception;\n+         end if;\n+\n+         builtin_longjmp (Jumpbuf_Ptr, 1);\n+\n+      else\n+         Exception_Traces.Notify_Unhandled_Exception;\n+         Exception_Traces.Unhandled_Exception_Terminate;\n+      end if;\n    end Process_Raise_Exception;\n \n    ----------------------------\n@@ -826,7 +784,7 @@ package body Ada.Exceptions is\n       --  pragma Volatile is peculiar!\n \n    begin\n-      Process_Raise_Exception (E => E, From_Signal_Handler => False);\n+      Process_Raise_Exception (E);\n    end Raise_Current_Excep;\n \n    ---------------------\n@@ -843,6 +801,14 @@ package body Ada.Exceptions is\n          Abort_Defer.all;\n          Raise_Current_Excep (E);\n       end if;\n+\n+      --  Note: if E is null, then we simply return, which is correct Ada 95\n+      --  semantics. If we are operating in Ada 2005 mode, then the expander\n+      --  generates a raise Constraint_Error immediately following the call\n+      --  to provide the required Ada 2005 semantics (see AI-329). We do it\n+      --  this way to avoid having run time dependencies on the Ada version.\n+\n+      return;\n    end Raise_Exception;\n \n    ----------------------------\n@@ -870,7 +836,7 @@ package body Ada.Exceptions is\n    begin\n       Exception_Data.Set_Exception_C_Msg (E, M);\n       Abort_Defer.all;\n-      Process_Raise_Exception (E => E, From_Signal_Handler => True);\n+      Process_Raise_Exception (E);\n    end Raise_From_Signal_Handler;\n \n    -------------------------\n@@ -951,8 +917,6 @@ package body Ada.Exceptions is\n       Excep : constant EOA := Get_Current_Excep.all;\n \n    begin\n-      Exception_Propagation.Setup_Exception (Excep, Excep);\n-\n       Excep.Exception_Raised := False;\n       Excep.Id               := E;\n       Excep.Num_Tracebacks   := 0;\n@@ -1033,7 +997,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_13 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_13'Address);\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_13'Address);\n    end Rcheck_13;\n \n    procedure Rcheck_14 (File : System.Address; Line : Integer) is\n@@ -1098,12 +1062,12 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_26 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_26'Address);\n+      Raise_Program_Error_Msg (File, Line, Rmsg_26'Address);\n    end Rcheck_26;\n \n    procedure Rcheck_27 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_27'Address);\n+      Raise_Program_Error_Msg (File, Line, Rmsg_27'Address);\n    end Rcheck_27;\n \n    procedure Rcheck_28 (File : System.Address; Line : Integer) is\n@@ -1121,6 +1085,16 @@ package body Ada.Exceptions is\n       Raise_Storage_Error_Msg (File, Line, Rmsg_30'Address);\n    end Rcheck_30;\n \n+   procedure Rcheck_31 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_31'Address);\n+   end Rcheck_31;\n+\n+   procedure Rcheck_32 (File : System.Address; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_32'Address);\n+   end Rcheck_32;\n+\n    -------------\n    -- Reraise --\n    -------------\n@@ -1130,7 +1104,6 @@ package body Ada.Exceptions is\n \n    begin\n       Abort_Defer.all;\n-      Exception_Propagation.Setup_Exception (Excep, Excep, Reraised => True);\n       Raise_Current_Excep (Excep.Id);\n    end Reraise;\n \n@@ -1142,8 +1115,6 @@ package body Ada.Exceptions is\n    begin\n       if X.Id /= null then\n          Abort_Defer.all;\n-         Exception_Propagation.Setup_Exception\n-           (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n          Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n          Raise_Current_Excep (X.Id);\n       end if;\n@@ -1156,8 +1127,6 @@ package body Ada.Exceptions is\n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence) is\n    begin\n       Abort_Defer.all;\n-      Exception_Propagation.Setup_Exception\n-        (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n       Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n       Raise_Current_Excep (X.Id);\n    end Reraise_Occurrence_Always;\n@@ -1168,8 +1137,6 @@ package body Ada.Exceptions is\n \n    procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n    begin\n-      Exception_Propagation.Setup_Exception\n-        (X'Unrestricted_Access, Get_Current_Excep.all, Reraised => True);\n       Save_Occurrence_No_Private (Get_Current_Excep.all.all, X);\n       Raise_Current_Excep (X.Id);\n    end Reraise_Occurrence_No_Defer;\n@@ -1230,7 +1197,6 @@ package body Ada.Exceptions is\n       --  fixed TSD occurrence, which is very different from Get_Current_Excep\n       --  here because this subprogram is called from the called task.\n \n-      Exception_Propagation.Setup_Exception (Target, Target);\n       Save_Occurrence_No_Private (Target.all, Source);\n    end Transfer_Occurrence;\n \n@@ -1288,18 +1254,4 @@ package body Ada.Exceptions is\n       end loop;\n    end To_Stderr;\n \n-   --------------------------\n-   -- Code_Address_For_ZZZ --\n-   --------------------------\n-\n-   --  This function gives us the end of the PC range for addresses\n-   --  within the exception unit itself. We hope that gigi/gcc keeps all the\n-   --  procedures in their original order!\n-\n-   function Code_Address_For_ZZZ return System.Address is\n-   begin\n-      <<Start_Of_ZZZ>>\n-      return Start_Of_ZZZ'Address;\n-   end Code_Address_For_ZZZ;\n-\n end Ada.Exceptions;"}, {"sha": "e010c56a9f020651bee0e11cd6b89b24ff4f587d", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -35,6 +35,15 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This version of Ada.Exceptions is a full Ada 95 version, but lacks the\n+--  additional definitions of Exception_Name returning Wide_[Wide_]String.\n+--  It is used for building the compiler and the basic tools, since these\n+--  builds may be done with bootstrap compilers that cannot handle these\n+--  additions. The full version of Ada.Exceptions can be found in the files\n+--  a-except-2005.ads/adb, and is used for all other builds where full Ada\n+--  2005 functionality is required. in particular, it is used for building\n+--  run times on all targets.\n+\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with ourself."}, {"sha": "fdec8d0399567441933718eeb202309d4bab8a61", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -532,7 +532,11 @@ package body Exception_Propagation is\n    --  Unwind_RaiseException to actually throw, taking care of handling\n    --  the two phase scheme it implements.\n \n-   procedure Propagate_Exception (From_Signal_Handler : Boolean) is\n+   procedure Propagate_Exception\n+     (E                   : Exception_Id;\n+      From_Signal_Handler : Boolean)\n+   is\n+      pragma Inspection_Point (E);\n       pragma Unreferenced (From_Signal_Handler);\n \n       Excep         : constant EOA := Get_Current_Excep.all;"}, {"sha": "1a300b57e5b1ba03b1b6834b33f2f13a615154a4", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,7 +69,12 @@ package body Exception_Propagation is\n    -- Propagate_Exception --\n    -------------------------\n \n-   procedure Propagate_Exception (From_Signal_Handler : Boolean) is\n+   procedure Propagate_Exception\n+     (E                   : Exception_Id;\n+      From_Signal_Handler : Boolean)\n+   is\n+      pragma Inspection_Point (E);\n+\n       Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n       Excep       : constant EOA := Get_Current_Excep.all;\n    begin"}, {"sha": "08459060345b6ef076ce2bb1c718ea4096060968", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,7 @@\n \n with ALI;      use ALI;\n with Csets;\n-with Gnatvsn;\n+with Gnatvsn;  use Gnatvsn;\n with Makeutl;\n with MLib.Tgt; use MLib.Tgt;\n with Namet;    use Namet;\n@@ -1288,8 +1288,11 @@ package body Clean is\n    begin\n       if not Copyright_Displayed then\n          Copyright_Displayed := True;\n-         Put_Line (\"GNATCLEAN \" & Gnatvsn.Gnat_Version_String\n-                   & \" Copyright 2003-2005 Free Software Foundation, Inc.\");\n+         Put_Line\n+           (\"GNATCLEAN \" & Gnatvsn.Gnat_Version_String\n+            & \" Copyright 2003-\"\n+            & Current_Year\n+            & \" Free Software Foundation, Inc.\");\n       end if;\n    end Display_Copyright;\n \n@@ -1308,7 +1311,6 @@ package body Clean is\n \n    procedure Extract_From_Q (Lib_File : out File_Name_Type) is\n       Lib : constant File_Name_Type := Q.Table (Q_Front);\n-\n    begin\n       Q_Front  := Q_Front + 1;\n       Lib_File := Lib;\n@@ -1501,12 +1503,27 @@ package body Clean is\n       if not Initialized then\n          Initialized := True;\n \n+         --  Get default search directories to locate system.ads when calling\n+         --  Targparm.Get_Target_Parameters.\n+\n+         Osint.Add_Default_Search_Dirs;\n+\n          --  Initialize some packages\n \n          Csets.Initialize;\n          Namet.Initialize;\n          Snames.Initialize;\n          Prj.Initialize (Project_Tree);\n+\n+         --  Check if the platform is VMS and, if it is, change some variables\n+\n+         Targparm.Get_Target_Parameters;\n+\n+         if OpenVMS_On_Target then\n+            Debug_Suffix (Debug_Suffix'First) := '_';\n+            Repinfo_Suffix (Repinfo_Suffix'First) := '_';\n+            B_Start := new String'(\"b__\");\n+         end if;\n       end if;\n \n       --  Reset global variables\n@@ -1897,11 +1914,4 @@ package body Clean is\n          New_Line;\n       end if;\n    end Usage;\n-\n-begin\n-   if OpenVMS_On_Target then\n-      Debug_Suffix (Debug_Suffix'First) := '_';\n-      Repinfo_Suffix (Repinfo_Suffix'First) := '_';\n-      B_Start := new String'(\"b__\");\n-   end if;\n end Clean;"}, {"sha": "ad55243fc3ce468b67b5fbe048b5eec149ca08df", "filename": "gcc/ada/s-wchcon.adb", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fs-wchcon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fs-wchcon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcon.adb?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . W C H _ C O N                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.WCh_Con is\n+\n+   ----------------------------\n+   -- Get_WC_Encoding_Method --\n+   ----------------------------\n+\n+   function Get_WC_Encoding_Method (C : Character) return WC_Encoding_Method is\n+   begin\n+      for Method in WC_Encoding_Method loop\n+         if C = WC_Encoding_Letters (Method) then\n+            return Method;\n+         end if;\n+      end loop;\n+\n+      raise Constraint_Error;\n+   end Get_WC_Encoding_Method;\n+\n+end System.WCh_Con;"}, {"sha": "d0c9b8f307b862751bc178384684ec50e9419e42", "filename": "gcc/ada/s-wchcon.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fs-wchcon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Fs-wchcon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcon.ads?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -182,4 +182,8 @@ package System.WCh_Con is\n    --  The longest number of characters that can be used for a wide character\n    --  or wide wide character sequence for any of the active encoding methods.\n \n+   function Get_WC_Encoding_Method (C : Character) return WC_Encoding_Method;\n+   --  Given a character C, returns corresponding encoding method (see array\n+   --  WC_Encoding_Letters above). Raises Constraint_Error if not in list.\n+\n end System.WCh_Con;"}, {"sha": "f29ec011b1a7013eb16f065400928aa09a417a50", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -725,7 +725,7 @@ package Types is\n    -----------------------------------\n \n    --  This section contains declarations of exceptions that are used\n-   --  throughout the compiler.\n+   --  throughout the compiler or in other GNAT tools.\n \n    Unrecoverable_Error : exception;\n    --  This exception is raised to immediately terminate the compilation\n@@ -734,6 +734,14 @@ package Types is\n    --  reached, or a required file is not found). Also raised when the\n    --  compiler finds itself in trouble after an error (see Comperr).\n \n+   Terminate_Program : exception;\n+   --  This exception is raised to immediately terminate the tool being\n+   --  executed. Each tool where this exception may be raised must have\n+   --  a single exception handler that contains only a null statement and\n+   --  that is the last statement of the program. If needed, procedure\n+   --  Set_Exit_Status is called with the appropriate exit status before\n+   --  raising Terminate_Program.\n+\n    ---------------------------------\n    -- Parameter Mechanism Control --\n    ---------------------------------\n@@ -774,42 +782,45 @@ package Types is\n    --       the definition of last_reason_code.\n \n    --    3. Add a new routine in Ada.Exceptions with the appropriate call\n-   --       and static string constant\n-\n-   type RT_Exception_Code is (\n-     CE_Access_Check_Failed,\n-     CE_Access_Parameter_Is_Null,\n-     CE_Discriminant_Check_Failed,\n-     CE_Divide_By_Zero,\n-     CE_Explicit_Raise,\n-     CE_Index_Check_Failed,\n-     CE_Invalid_Data,\n-     CE_Length_Check_Failed,\n-     CE_Null_Not_Allowed,\n-     CE_Overflow_Check_Failed,\n-     CE_Partition_Check_Failed,\n-     CE_Range_Check_Failed,\n-     CE_Tag_Check_Failed,\n-\n-     PE_Access_Before_Elaboration,\n-     PE_Accessibility_Check_Failed,\n-     PE_All_Guards_Closed,\n-     PE_Duplicated_Entry_Address,\n-     PE_Explicit_Raise,\n-     PE_Finalize_Raised_Exception,\n-     PE_Misaligned_Address_Value,\n-     PE_Missing_Return,\n-     PE_Overlaid_Controlled_Object,\n-     PE_Potentially_Blocking_Operation,\n-     PE_Stubbed_Subprogram_Called,\n-     PE_Unchecked_Union_Restriction,\n-     PE_Illegal_RACW_E_4_18,\n-\n-     SE_Empty_Storage_Pool,\n-     SE_Explicit_Raise,\n-     SE_Infinite_Recursion,\n-     SE_Object_Too_Large,\n-     SE_Restriction_Violation);\n+   --       and static string constant. Note that there is more than one\n+   --       version of a-except.adb which must be modified.\n+\n+   type RT_Exception_Code is\n+     (CE_Access_Check_Failed,            -- 00\n+      CE_Access_Parameter_Is_Null,       -- 01\n+      CE_Discriminant_Check_Failed,      -- 02\n+      CE_Divide_By_Zero,                 -- 03\n+      CE_Explicit_Raise,                 -- 04\n+      CE_Index_Check_Failed,             -- 05\n+      CE_Invalid_Data,                   -- 06\n+      CE_Length_Check_Failed,            -- 07\n+      CE_Null_Exception_Id,              -- 08\n+      CE_Null_Not_Allowed,               -- 09\n+      CE_Overflow_Check_Failed,          -- 10\n+      CE_Partition_Check_Failed,         -- 11\n+      CE_Range_Check_Failed,             -- 12\n+      CE_Tag_Check_Failed,               -- 13\n+\n+      PE_Access_Before_Elaboration,      -- 14\n+      PE_Accessibility_Check_Failed,     -- 15\n+      PE_All_Guards_Closed,              -- 16\n+      PE_Duplicated_Entry_Address,       -- 17\n+      PE_Explicit_Raise,                 -- 18\n+      PE_Finalize_Raised_Exception,      -- 19\n+      PE_Implicit_Return,                -- 20\n+      PE_Misaligned_Address_Value,       -- 21\n+      PE_Missing_Return,                 -- 22\n+      PE_Overlaid_Controlled_Object,     -- 23\n+      PE_Potentially_Blocking_Operation, -- 24\n+      PE_Stubbed_Subprogram_Called,      -- 25\n+      PE_Unchecked_Union_Restriction,    -- 26\n+      PE_Illegal_RACW_E_4_18,            -- 27\n+\n+      SE_Empty_Storage_Pool,             -- 28\n+      SE_Explicit_Raise,                 -- 29\n+      SE_Infinite_Recursion,             -- 30\n+      SE_Object_Too_Large,               -- 31\n+      SE_Restriction_Violation);         -- 32\n \n    subtype RT_CE_Exceptions is RT_Exception_Code range\n      CE_Access_Check_Failed .."}, {"sha": "94f9b248042ac7624375d7bf14fcaba7cb7599cf", "filename": "gcc/ada/types.h", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f301919dc530893fa43e994531ff347f955000a/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=6f301919dc530893fa43e994531ff347f955000a", "patch": "@@ -338,28 +338,32 @@ typedef Int Mechanism_Type;\n #define CE_Index_Check_Failed               5\n #define CE_Invalid_Data                     6\n #define CE_Length_Check_Failed              7\n-#define CE_Null_Not_Allowed                 8\n-#define CE_Overflow_Check_Failed            9\n-#define CE_Partition_Check_Failed          10\n-#define CE_Range_Check_Failed              11\n-#define CE_Tag_Check_Failed                12\n-#define PE_Access_Before_Elaboration       13\n-#define PE_Accessibility_Check_Failed      14\n-#define PE_All_Guards_Closed               15\n-#define PE_Duplicated_Entry_Address        16\n-#define PE_Explicit_Raise                  17\n-#define PE_Finalize_Raised_Exception       18\n-#define PE_Misaligned_Address_Value        19\n-#define PE_Missing_Return                  20\n-#define PE_Overlaid_Controlled_Object      21\n-#define PE_Potentially_Blocking_Operation  22\n-#define PE_Stubbed_Subprogram_Called       23\n-#define PE_Unchecked_Union_Restriction     24\n-#define PE_Illegal_RACW_E_4_18             25\n-#define SE_Empty_Storage_Pool              26\n-#define SE_Explicit_Raise                  27\n-#define SE_Infinite_Recursion              28\n-#define SE_Object_Too_Large                29\n-#define SE_Restriction_Violation           30\n-\n-#define LAST_REASON_CODE                   30\n+#define CE_Null_Exception_Id                9\n+#define CE_Null_Not_Allowed                 9\n+#define CE_Overflow_Check_Failed           10\n+#define CE_Partition_Check_Failed          11\n+#define CE_Range_Check_Failed              12\n+#define CE_Tag_Check_Failed                13\n+\n+#define PE_Access_Before_Elaboration       14\n+#define PE_Accessibility_Check_Failed      15\n+#define PE_All_Guards_Closed               16\n+#define PE_Duplicated_Entry_Address        17\n+#define PE_Explicit_Raise                  18\n+#define PE_Finalize_Raised_Exception       19\n+#define PE_Implicit_Return                 20\n+#define PE_Misaligned_Address_Value        21\n+#define PE_Missing_Return                  22\n+#define PE_Overlaid_Controlled_Object      23\n+#define PE_Potentially_Blocking_Operation  24\n+#define PE_Stubbed_Subprogram_Called       25\n+#define PE_Unchecked_Union_Restriction     26\n+#define PE_Illegal_RACW_E_4_18             27\n+\n+#define SE_Empty_Storage_Pool              28\n+#define SE_Explicit_Raise                  29\n+#define SE_Infinite_Recursion              30\n+#define SE_Object_Too_Large                31\n+#define SE_Restriction_Violation           32\n+\n+#define LAST_REASON_CODE                   31"}]}