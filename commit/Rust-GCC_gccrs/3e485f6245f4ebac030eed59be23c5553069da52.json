{"sha": "3e485f6245f4ebac030eed59be23c5553069da52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0ODVmNjI0NWY0ZWJhYzAzMGVlZDU5YmUyM2M1NTUzMDY5ZGE1Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-25T13:13:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-25T13:13:31Z"}, "message": "tree-pass.h (pass_split_functions): Declare.\n\n\n\t* tree-pass.h (pass_split_functions): Declare.\n\t* opts.c (decode_options): Enable function splitting at -O2\n\t* timevar.def (TV_IPA_FNSPLIT): New macro.\n\t* ipa-split.c: New file.\n\t* common.opt (-fpartial-inlining): New flag.\n\t* Makefile.in (ipa-split.o): New object file.\n\t* passes.c (init_optimization_passes): Add ipa-split.\n\t* params.def (max-inline-insns-auto): Reduce max-inline-insns-auto to 40.\n\t(partial-inlining-entry-probability): New parameters.\n\t* doc/invoke.texi (-fpartial-inlining): New.\n\t\n\t* testsuite/gcc.dg/tree-ssa/ipa-split.c\n\nFrom-SVN: r161382", "tree": {"sha": "80bfab2edb3bbe1286a628a18c5db82efaebf956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80bfab2edb3bbe1286a628a18c5db82efaebf956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e485f6245f4ebac030eed59be23c5553069da52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e485f6245f4ebac030eed59be23c5553069da52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e485f6245f4ebac030eed59be23c5553069da52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e485f6245f4ebac030eed59be23c5553069da52/comments", "author": null, "committer": null, "parents": [{"sha": "129473197de2fcc13154db476a610dd596a81fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129473197de2fcc13154db476a610dd596a81fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/129473197de2fcc13154db476a610dd596a81fdb"}], "stats": {"total": 1148, "additions": 1147, "deletions": 1}, "files": [{"sha": "b77b914a3248b829532680bec310ab8b922646cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -1,3 +1,15 @@\n+2010-06-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (pass_split_functions): Declare.\n+\t* opts.c (decode_options): Enable function splitting at -O2\n+\t* timevar.def (TV_IPA_FNSPLIT): New macro.\n+\t* ipa-split.c: New file.\n+\t* common.opt (-fpartial-inlining): New flag.\n+\t* Makefile.in (ipa-split.o): New object file.\n+\t* passes.c (init_optimization_passes): Add ipa-split.\n+\t* params.def (partial-inlining-entry-probability): New parameters.\n+\t* doc/invoke.texi (-fpartial-inlining): New.\n+\n 2010-06-25  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 44665"}, {"sha": "8b27fa247ce37276e9cce599b9959cc82670c49e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -1441,6 +1441,7 @@ OBJS-archive = \\\n \tcppdefault.o \\\n \tincpath.o \\\n \tipa-cp.o \\\n+        ipa-split.o \\\n \tipa-inline.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n@@ -3003,6 +3004,10 @@ ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n    $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H) tree-pretty-print.h\n+ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n+   $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n+   $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n+   $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H)\n matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TM_H) $(TREE_H) $(RTL_H) $(TREE_INLINE_H) $(TREE_FLOW_H) \\\n    tree-flow-inline.h langhooks.h $(HASHTAB_H) $(TOPLEV_H) $(FLAGS_H) $(GGC_H) \\"}, {"sha": "82a4e75e89094bc0d84664fa74ed695459b83f67", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -884,6 +884,10 @@ foptimize-sibling-calls\n Common Report Var(flag_optimize_sibling_calls) Optimization\n Optimize sibling and tail recursive calls\n \n+fpartial-inlining\n+Common Report Var(flag_partial_inlining)\n+Perform partial inlining\n+\n fpre-ipa-mem-report\n Common Report Var(pre_ipa_mem_report)\n Report on memory allocation before interprocedural optimization"}, {"sha": "8c51387ae25fc5c31c45a93a1e7bf1a6e49f3e11", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -362,7 +362,7 @@ Objective-C and Objective-C++ Dialects}.\n -fno-sched-interblock -fno-sched-spec -fno-signed-zeros @gol\n -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol\n--fpeel-loops -fpredictive-commoning -fprefetch-loop-arrays @gol\n+-fpartial-inlining -fpeel-loops -fpredictive-commoning -fprefetch-loop-arrays @gol\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n@@ -5870,6 +5870,7 @@ also turns on the following optimization flags:\n -findirect-inlining @gol\n -fipa-sra @gol\n -foptimize-sibling-calls @gol\n+-fpartial-inlining @gol\n -fpeephole2 @gol\n -fregmove @gol\n -freorder-blocks  -freorder-functions @gol\n@@ -7027,6 +7028,14 @@ This optimization is enabled by default.\n With this option, the compiler will create multiple copies of some\n local variables when unrolling a loop which can result in superior code.\n \n+@item -fpartial-inlining\n+@opindex fpartial-inlining\n+Inline parts of functions.  This option has any effect only\n+when inlining itself is turned on by the @option{-finline-functions}\n+or @option{-finline-small-functions} options.\n+\n+Enabled at level @option{-O2}.\n+\n @item -fpredictive-commoning\n @opindex fpredictive-commoning\n Perform predictive commoning optimization, i.e., reusing computations"}, {"sha": "6085e0b677cf8021ae7df7e1577e9d887c2a99bf", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1070, "deletions": 0, "changes": 1070, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -0,0 +1,1070 @@\n+/* Function splitting pass\n+   Copyright (C) 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka  <jh@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* The purpose of this pass is to split function bodies to improve\n+   inlining.  I.e. for function of the form:\n+\n+   func (...)\n+     {\n+       if (cheap_test)\n+\t something_small\n+       else\n+\t something_big\n+     }\n+\n+   Produce:\n+\n+   func.part (...)\n+     {\n+\tsomething_big\n+     }\n+\n+   func (...)\n+     {\n+       if (cheap_test)\n+\t something_small\n+       else\n+\t func.part (...);\n+     }\n+\n+   When func becomes inlinable and when cheap_test is often true, inlining func,\n+   but not fund.part leads to performance imrovement similar as inlining\n+   original func while the code size growth is smaller.\n+\n+   The pass is organized in three stages:\n+   1) Collect local info about basic block into BB_INFO structure and\n+      compute function body estimated size and time.\n+   2) Via DFS walk find all possible basic blocks where we can split\n+      and chose best one.\n+   3) If split point is found, split at the specified BB by creating a clone\n+      and updating function to call it.  \n+\n+   The decisions what functions to split are in execute_split_functions\n+   and consider_split.  \n+\n+   There are several possible future improvements for this pass including:\n+\n+   1) Splitting to break up large functions\n+   2) Splitting to reduce stack frame usage\n+   3) Allow split part of function to use values computed in the header part.\n+      The values needs to be passed to split function, perhaps via same\n+      interface as for nested functions or as argument.\n+   4) Support for simple rematerialization.  I.e. when split part use\n+      value computed in header from function parameter in very cheap way, we\n+      can just recompute it.\n+   5) Support splitting of nested functions.\n+   6) Support non-SSA arguments.  \n+   7) There is nothing preventing us from producing multiple parts of single function\n+      when needed or splitting also the parts.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"ipa-prop.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-inline.h\"\n+#include \"fibheap.h\"\n+#include \"params.h\"\n+#include \"gimple-pretty-print.h\"\n+\n+/* Per basic block info.  */\n+\n+typedef struct\n+{\n+  unsigned int size;\n+  unsigned int time;\n+} bb_info;\n+DEF_VEC_O(bb_info);\n+DEF_VEC_ALLOC_O(bb_info,heap);\n+\n+static VEC(bb_info, heap) *bb_info_vec;\n+\n+/* Description of split point.  */\n+\n+struct split_point\n+{\n+  /* Size of the partitions.  */\n+  unsigned int header_time, header_size, split_time, split_size;\n+\n+  /* SSA names that need to be passed into spit funciton.  */\n+  bitmap ssa_names_to_pass;\n+\n+  /* Basic block where we split (that will become entry point of new function.  */\n+  basic_block entry_bb;\n+\n+  /* Basic blocks we are splitting away.  */\n+  bitmap split_bbs;\n+};\n+\n+/* Best split point found.  */\n+\n+struct split_point best_split_point;\n+\n+/* Callback for walk_stmt_load_store_addr_ops.  If T is non-ssa automatic\n+   variable, check it if it is present in bitmap passed via DATA.  */\n+\n+static bool\n+test_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t,\n+\t         void *data ATTRIBUTE_UNUSED)\n+{\n+  t = get_base_address (t);\n+\n+  if (t && !is_gimple_reg (t)\n+      && ((TREE_CODE (t) == VAR_DECL\n+\t  && auto_var_in_fn_p (t, current_function_decl))\n+\t  || (TREE_CODE (t) == PARM_DECL)))\n+    return bitmap_bit_p ((bitmap)data, DECL_UID (t));\n+  return false;\n+}\n+\n+/* Dump split point CURRENT.  */\n+\n+static void\n+dump_split_point (FILE * file, struct split_point *current)\n+{\n+  fprintf (file,\n+\t   \"Split point at BB %i header time:%i header size: %i\"\n+\t   \" split time: %i split size: %i\\n  bbs: \",\n+\t   current->entry_bb->index, current->header_time,\n+\t   current->header_size, current->split_time, current->split_size);\n+  dump_bitmap (file, current->split_bbs);\n+  fprintf (file, \"  SSA names to pass: \");\n+  dump_bitmap (file, current->ssa_names_to_pass);\n+}\n+\n+/* We found an split_point CURRENT.  NON_SSA_VARS is bitmap of all non ssa\n+   variables used and RETURN_BB is return basic block.\n+   See if we can split function here.  */\n+\n+static void\n+consider_split (struct split_point *current, bitmap non_ssa_vars,\n+\t\tbasic_block return_bb)\n+{\n+  tree parm;\n+  unsigned int num_args = 0;\n+  unsigned int call_overhead;\n+  edge e;\n+  edge_iterator ei;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_split_point (dump_file, current);\n+\n+  /* Do not split when we would end up calling function anyway.  */\n+  if (current->entry_bb->frequency\n+      >= (ENTRY_BLOCK_PTR->frequency\n+\t  * PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: split BB frequency is too large.\\n\");\n+      return;\n+    }\n+\n+  if (!current->header_size)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  Refused: header empty\\n\");\n+      gcc_unreachable ();\n+      return;\n+    }\n+\n+  /* FIXME: We can do better: if the split region start with a loop and there\n+     is only one entry point from outer wrold, we can update PHI.  */\n+  if (!gsi_end_p (gsi_start_phis (current->entry_bb)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: entry BB has PHI\\n\");\n+      return;\n+    }\n+\n+\n+  /* See what argument we will pass to the split function and compute\n+     call overhead.  */\n+  call_overhead = eni_size_weights.call_cost;\n+  for (parm = DECL_ARGUMENTS (current_function_decl); parm;\n+       parm = TREE_CHAIN (parm))\n+    {\n+      if (!is_gimple_reg (parm))\n+\t{\n+\t  if (bitmap_bit_p (non_ssa_vars, DECL_UID (parm)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"  Refused: need to pass non-ssa param values\\n\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (gimple_default_def (cfun, parm)\n+\t       && bitmap_bit_p (current->ssa_names_to_pass,\n+\t\t\t\tSSA_NAME_VERSION (gimple_default_def\n+\t\t\t\t\t\t  (cfun, parm))))\n+\t{\n+\t  if (!VOID_TYPE_P (TREE_TYPE (parm)))\n+\t    call_overhead += estimate_move_cost (TREE_TYPE (parm));\n+\t  num_args++;\n+\t}\n+    }\n+  if (!VOID_TYPE_P (TREE_TYPE (current_function_decl)))\n+    call_overhead += estimate_move_cost (TREE_TYPE (current_function_decl));\n+\n+  if (current->split_size <= call_overhead)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: split size is smaller than call overhead\\n\");\n+      return;\n+    }\n+  if (current->header_size + call_overhead\n+      >= (unsigned int)(DECL_DECLARED_INLINE_P (current_function_decl)\n+\t\t\t? MAX_INLINE_INSNS_SINGLE\n+\t\t\t: MAX_INLINE_INSNS_AUTO))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: header size is too large for inline candidate\\n\");\n+      return;\n+    }\n+\n+  /* FIXME: we currently can pass only SSA function parameters to the split\n+     arguments.  Once parm_adjustment infrastructure is supported by clonning,\n+     we can pass more than that.  */\n+  if (num_args != bitmap_count_bits (current->ssa_names_to_pass))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: need to pass non-param values\\n\");\n+      return;\n+    }\n+\n+  /* When there are non-ssa vars used in the split region, see if they\n+     are used in the header region.  If so, reject the split.\n+     FIXME: we can use nested function support to access both.  */\n+  if (!bitmap_empty_p (non_ssa_vars))\n+    {\n+      basic_block bb;\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  gimple_stmt_iterator bsi;\n+\t  if (!bitmap_bit_p (current->split_bbs, bb->index))\n+\t    continue;\n+\t  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t    {\n+\t      if (is_gimple_debug (gsi_stmt (bsi)))\n+\t\tcontinue;\n+\t      if (walk_stmt_load_store_addr_ops\n+\t\t  (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n+\t\t   test_nonssa_use, test_nonssa_use))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"  Refused: split part has non-ssa uses\\n\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t    {\n+\t      if (is_gimple_debug (gsi_stmt (bsi)))\n+\t\tcontinue;\n+\t      if (walk_stmt_load_store_addr_ops\n+\t\t  (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n+\t\t   test_nonssa_use, test_nonssa_use))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"  Refused: split part has non-ssa uses\\n\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (e->dest != return_bb)\n+\t\tcontinue;\n+\t      for (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi);\n+\t\t   gsi_next (&bsi))\n+\t\t{\n+\t\t  gimple stmt = gsi_stmt (bsi);\n+\t\t  tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n+\n+\t\t  if (!is_gimple_reg (gimple_phi_result (stmt)))\n+\t\t    continue;\n+\t\t  if (TREE_CODE (op) != SSA_NAME\n+\t\t      && test_nonssa_use (stmt, op, non_ssa_vars))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"  Refused: split part has non-ssa uses\\n\");\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  }\n+      return;\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  Accepted!\\n\");\n+\n+  /* At the moment chose split point with lowest frequency and that leaves\n+     out smallest size of header.\n+     In future we might re-consider this heuristics.  */\n+  if (!best_split_point.split_bbs\n+      || best_split_point.entry_bb->frequency > current->entry_bb->frequency\n+      || (best_split_point.entry_bb->frequency == current->entry_bb->frequency\n+\t  && best_split_point.split_size < current->split_size))\n+\t\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  New best split point!\\n\");\n+      if (best_split_point.ssa_names_to_pass)\n+\t{\n+\t  BITMAP_FREE (best_split_point.ssa_names_to_pass);\n+\t  BITMAP_FREE (best_split_point.split_bbs);\n+\t}\n+      best_split_point = *current;\n+      best_split_point.ssa_names_to_pass = BITMAP_ALLOC (NULL);\n+      bitmap_copy (best_split_point.ssa_names_to_pass,\n+\t\t   current->ssa_names_to_pass);\n+      best_split_point.split_bbs = BITMAP_ALLOC (NULL);\n+      bitmap_copy (best_split_point.split_bbs, current->split_bbs);\n+    }\n+}\n+\n+/* Return basic block containing RETURN statement, or EXIT_BLOCK_PTR if none\n+   found. \n+   When there are multiple RETURN statement, chose one with return value,\n+   since that one is more likely shared by multiple code paths.\n+   TODO: We might support multiple return blocks.  */\n+\n+static basic_block\n+find_return_bb (void)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block return_bb = EXIT_BLOCK_PTR;\n+\n+  if (EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 1)\n+    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      {\n+\tgimple_stmt_iterator bsi;\n+\tbool found_return = false;\n+\ttree retval = NULL_TREE;\n+\n+\tfor (bsi = gsi_start_bb (e->src); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t  if (gimple_code (gsi_stmt (bsi)) != GIMPLE_RETURN\n+\t      && gimple_code (gsi_stmt (bsi)) != GIMPLE_LABEL\n+\t      && !is_gimple_debug (gsi_stmt (bsi)))\n+\t    break;\n+\t  else if (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+\t    {\n+\t      found_return = true;\n+\t      retval = gimple_return_retval (gsi_stmt (bsi));\n+\t    }\n+\tif (gsi_end_p (bsi) && found_return)\n+\t  {\n+\t    if (retval)\n+\t      return e->src;\n+\t    else\n+\t      return_bb = e->src;\n+\t  }\n+      }\n+  return return_bb;\n+}\n+\n+/* Callback for walk_stmt_load_store_addr_ops.  If T is non-ssa automatic\n+   variable, mark it as used in bitmap passed via DATA. \n+   Return true when access to T prevents splitting the function.  */\n+\n+static bool\n+mark_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t,\n+\t         void *data ATTRIBUTE_UNUSED)\n+{\n+  t = get_base_address (t);\n+\n+  if (!t || is_gimple_reg (t))\n+    return false;\n+\n+  /* At present we can't pass non-SSA arguments to split function.\n+     FIXME: this can be relaxed by passing references to arguments.  */\n+  if (TREE_CODE (t) == PARM_DECL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Can not split use of non-ssa function parameter.\\n\");\n+      return true;\n+    }\n+\n+  if (TREE_CODE (t) == VAR_DECL && auto_var_in_fn_p (t, current_function_decl))\n+    bitmap_set_bit ((bitmap)data, DECL_UID (t));\n+  return false;\n+}\n+\n+/* Compute local properties of basic block BB we collect when looking for\n+   split points.  We look for ssa defs and store them in SET_SSA_NAMES,\n+   for ssa uses and store them in USED_SSA_NAMES and for any non-SSA automatic\n+   vars stored in NON_SSA_VARS.\n+\n+   When BB has edge to RETURN_BB, collect uses in RETURN_BB too.  \n+\n+   Return false when BB contains something that prevents it from being put into\n+   split function.  */\n+\n+static bool\n+visit_bb (basic_block bb, basic_block return_bb,\n+\t  bitmap set_ssa_names, bitmap used_ssa_names,\n+\t  bitmap non_ssa_vars)\n+{\n+  gimple_stmt_iterator bsi;\n+  edge e;\n+  edge_iterator ei;\n+  bool can_split = true;\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    {\n+      gimple stmt = gsi_stmt (bsi);\n+      tree op;\n+      ssa_op_iter iter;\n+      tree decl;\n+\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      /* FIXME: We can split regions containing EH.  We can not however\n+\t split RESX, EH_DISPATCH and EH_POINTER referring to same region\n+\t into different partitions.  This would require tracking of\n+\t EH regions and checking in consider_split_point if they \n+\t are not used elsewhere.  */\n+      if (gimple_code (stmt) == GIMPLE_RESX\n+\t  && stmt_can_throw_external (stmt))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Can not split external resx.\\n\");\n+\t  can_split = false;\n+\t}\n+      if (gimple_code (stmt) == GIMPLE_EH_DISPATCH)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Can not split eh dispatch.\\n\");\n+\t  can_split = false;\n+\t}\n+\n+      /* Check builtins that prevent splitting.  */\n+      if (gimple_code (stmt) == GIMPLE_CALL\n+\t  && (decl = gimple_call_fndecl (stmt)) != NULL_TREE\n+\t  && DECL_BUILT_IN (decl)\n+\t  && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n+\tswitch (DECL_FUNCTION_CODE (decl))\n+\t  {\n+\t  /* FIXME: once we will allow passing non-parm values to split part,\n+\t     we need to be sure to handle correct builtin_stack_save and\n+\t     builtin_stack_restore.  At the moment we are safe; there is no\n+\t     way to store builtin_stack_save result in non-SSA variable\n+\t     since all calls to those are compiler generated.  */\n+\t  case BUILT_IN_APPLY:\n+\t  case BUILT_IN_VA_START:\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Can not split builtin_apply and va_start.\\n\");\n+\t    can_split = false;\n+\t    break;\n+\t  case BUILT_IN_EH_POINTER:\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Can not split builtin_eh_pointer.\\n\");\n+\t    can_split = false;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n+\tbitmap_set_bit (set_ssa_names, SSA_NAME_VERSION (op));\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\tbitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+      can_split &= !walk_stmt_load_store_addr_ops (stmt, non_ssa_vars,\n+\t\t\t\t\t\t   mark_nonssa_use,\n+\t\t\t\t\t\t   mark_nonssa_use,\n+\t\t\t\t\t\t   mark_nonssa_use);\n+    }\n+  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    {\n+      gimple stmt = gsi_stmt (bsi);\n+      tree op;\n+      ssa_op_iter iter;\n+\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (!is_gimple_reg (gimple_phi_result (stmt)))\n+\tcontinue;\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n+\tbitmap_set_bit (set_ssa_names, SSA_NAME_VERSION (op));\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\tbitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+      can_split &= !walk_stmt_load_store_addr_ops (stmt, non_ssa_vars,\n+\t\t\t\t\t\t   mark_nonssa_use,\n+\t\t\t\t\t\t   mark_nonssa_use,\n+\t\t\t\t\t\t   mark_nonssa_use);\n+    }\n+  /* Record also uses comming from PHI operand in return BB.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->dest == return_bb)\n+      {\n+\tbool found_phi = false;\n+\tfor (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t  {\n+\t    gimple stmt = gsi_stmt (bsi);\n+\t    tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n+\n+\t    if (is_gimple_debug (stmt))\n+\t      continue;\n+\t    if (!is_gimple_reg (gimple_phi_result (stmt)))\n+\t      continue;\n+\t    found_phi = true;\n+\t    if (TREE_CODE (op) == SSA_NAME)\n+\t      bitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+\t    else\n+\t      can_split &= !mark_nonssa_use (stmt, op, non_ssa_vars);\n+\t  }\n+\tif (!gsi_end_p (gsi_last_bb (return_bb)))\n+\t  {\n+\t    ssa_op_iter iter;\n+\t    gimple stmt = gsi_stmt (gsi_last_bb (return_bb));\n+\t    tree op;\n+\t    if (!found_phi)\n+\t      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\t\tbitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+\t    can_split &= !walk_stmt_load_store_addr_ops (stmt, non_ssa_vars,\n+\t\t\t\t\t\t\t mark_nonssa_use,\n+\t\t\t\t\t\t\t mark_nonssa_use,\n+\t\t\t\t\t\t\t mark_nonssa_use);\n+\t  }\n+      }\n+  return can_split;\n+}\n+\n+/* Stack entry for recursive DFS walk in find_split_point.  */\n+\n+typedef struct\n+{\n+  /* Basic block we are examining.  */\n+  basic_block bb;\n+\n+  /* SSA names set and used by the BB and all BBs reachable\n+     from it via DFS walk.  */\n+  bitmap set_ssa_names, used_ssa_names;\n+  bitmap non_ssa_vars;\n+\n+  /* All BBS visited from this BB via DFS walk.  */\n+  bitmap bbs_visited;\n+\n+  /* Last examined edge in DFS walk.  Since we walk unoriented graph,\n+     the value is up to sum of incomming and outgoing edges of BB.  */\n+  unsigned int edge_num;\n+\n+  /* Stack entry index of earliest BB reachable from current BB\n+     or any BB visited later in DFS valk.  */\n+  int earliest;\n+\n+  /* Overall time and size of all BBs reached from this BB in DFS walk.  */\n+  int overall_time, overall_size;\n+\n+  /* When false we can not split on this BB.  */\n+  bool can_split;\n+} stack_entry;\n+DEF_VEC_O(stack_entry);\n+DEF_VEC_ALLOC_O(stack_entry,heap);\n+\n+\n+/* Find all articulations and call consider_split on them.\n+   OVERALL_TIME and OVERALL_SIZE is time and size of the function.\n+\n+   We perform basic algorithm for finding an articulation in a graph\n+   created from CFG by considering it to be an unoriented graph.\n+\n+   The articulation is discovered via DFS walk. We collect earliest\n+   basic block on stack that is reachable via backward edge.  Articulation\n+   is any basic block such that there is no backward edge bypassing it.\n+   To reduce stack usage we maintain heap allocated stack in STACK vector.\n+   AUX pointer of BB is set to index it appears in the stack or -1 once\n+   it is visited and popped off the stack.\n+\n+   The algorithm finds articulation after visiting the whole component\n+   reachable by it.  This makes it convenient to collect information about\n+   the component used by consider_split.  */\n+\n+static void\n+find_split_points (int overall_time, int overall_size)\n+{\n+  stack_entry first;\n+  VEC(stack_entry, heap) *stack = NULL;\n+  basic_block bb;\n+  basic_block return_bb = find_return_bb ();\n+  struct split_point current;\n+\n+  current.header_time = overall_time;\n+  current.header_size = overall_size;\n+  current.split_time = 0;\n+  current.split_size = 0;\n+  current.ssa_names_to_pass = BITMAP_ALLOC (NULL);\n+\n+  first.bb = ENTRY_BLOCK_PTR;\n+  first.edge_num = 0;\n+  first.overall_time = 0;\n+  first.overall_size = 0;\n+  first.earliest = INT_MAX;\n+  first.set_ssa_names = 0;\n+  first.used_ssa_names = 0;\n+  first.bbs_visited = 0;\n+  VEC_safe_push (stack_entry, heap, stack, &first);\n+  ENTRY_BLOCK_PTR->aux = (void *)(intptr_t)-1;\n+\n+  while (!VEC_empty (stack_entry, stack))\n+    {\n+      stack_entry *entry = VEC_last (stack_entry, stack);\n+\n+      /* We are walking an acyclic graph, so edge_num counts\n+\t succ and pred edges together.  However when considering\n+         articulation, we want to have processed everything reachable\n+\t from articulation but nothing that reaches into it.  */\n+      if (entry->edge_num == EDGE_COUNT (entry->bb->succs)\n+\t  && entry->bb != ENTRY_BLOCK_PTR)\n+\t{\n+\t  int pos = VEC_length (stack_entry, stack);\n+\t  entry->can_split &= visit_bb (entry->bb, return_bb,\n+\t\t\t\t\tentry->set_ssa_names,\n+\t\t\t\t\tentry->used_ssa_names,\n+\t\t\t\t\tentry->non_ssa_vars);\n+\t  if (pos <= entry->earliest && !entry->can_split\n+\t      && dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"found articulation at bb %i but can not split\\n\",\n+\t\t     entry->bb->index);\n+\t  if (pos <= entry->earliest && entry->can_split)\n+\t     {\n+\t       if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t fprintf (dump_file, \"found articulation at bb %i\\n\",\n+\t\t\t  entry->bb->index);\n+\t       current.entry_bb = entry->bb;\n+\t       current.ssa_names_to_pass = BITMAP_ALLOC (NULL);\n+\t       bitmap_and_compl (current.ssa_names_to_pass,\n+\t\t\t\t entry->used_ssa_names, entry->set_ssa_names);\n+\t       current.header_time = overall_time - entry->overall_time;\n+\t       current.header_size = overall_size - entry->overall_size;\n+\t       current.split_time = entry->overall_time;\n+\t       current.split_size = entry->overall_size;\n+\t       current.split_bbs = entry->bbs_visited;\n+\t       consider_split (&current, entry->non_ssa_vars, return_bb);\n+\t       BITMAP_FREE (current.ssa_names_to_pass);\n+\t     }\n+\t}\n+      /* Do actual DFS walk.  */\n+      if (entry->edge_num\n+\t  < (EDGE_COUNT (entry->bb->succs)\n+\t     + EDGE_COUNT (entry->bb->preds)))\n+\t{\n+          edge e;\n+\t  basic_block dest;\n+\t  if (entry->edge_num < EDGE_COUNT (entry->bb->succs))\n+\t    {\n+\t      e = EDGE_SUCC (entry->bb, entry->edge_num);\n+\t      dest = e->dest;\n+\t    }\n+\t  else\n+\t    {\n+\t      e = EDGE_PRED (entry->bb, entry->edge_num\n+\t\t\t     - EDGE_COUNT (entry->bb->succs));\n+\t      dest = e->src;\n+\t    }\n+\n+\t  entry->edge_num++;\n+\n+\t  /* New BB to visit, push it to the stack.  */\n+\t  if (dest != return_bb && dest != EXIT_BLOCK_PTR\n+\t      && !dest->aux)\n+\t    {\n+\t      stack_entry new_entry;\n+\n+\t      new_entry.bb = dest;\n+\t      new_entry.edge_num = 0;\n+\t      new_entry.overall_time\n+\t\t = VEC_index (bb_info, bb_info_vec, dest->index)->time;\n+\t      new_entry.overall_size\n+\t\t = VEC_index (bb_info, bb_info_vec, dest->index)->size;\n+\t      new_entry.earliest = INT_MAX;\n+\t      new_entry.set_ssa_names = BITMAP_ALLOC (NULL);\n+\t      new_entry.used_ssa_names = BITMAP_ALLOC (NULL);\n+\t      new_entry.bbs_visited = BITMAP_ALLOC (NULL);\n+\t      new_entry.non_ssa_vars = BITMAP_ALLOC (NULL);\n+\t      new_entry.can_split = true;\n+\t      bitmap_set_bit (new_entry.bbs_visited, dest->index);\n+\t      VEC_safe_push (stack_entry, heap, stack, &new_entry);\n+\t      dest->aux = (void *)(intptr_t)VEC_length (stack_entry, stack);\n+\t    }\n+\t  /* Back edge found, record the earliest point.  */\n+\t  else if ((intptr_t)dest->aux > 0\n+\t\t   && (intptr_t)dest->aux < entry->earliest)\n+\t    entry->earliest = (intptr_t)dest->aux;\n+\t}\n+      /* We are done with examing the edges. pop off the value from stack and\n+\t merge stuff we cummulate during the walk.  */\n+      else if (entry->bb != ENTRY_BLOCK_PTR)\n+\t{\n+\t  stack_entry *prev = VEC_index (stack_entry, stack,\n+\t\t\t\t\t VEC_length (stack_entry, stack) - 2);\n+\n+\t  entry->bb->aux = (void *)(intptr_t)-1;\n+\t  prev->can_split &= entry->can_split;\n+\t  if (prev->set_ssa_names)\n+\t    {\n+\t      bitmap_ior_into (prev->set_ssa_names, entry->set_ssa_names);\n+\t      bitmap_ior_into (prev->used_ssa_names, entry->used_ssa_names);\n+\t      bitmap_ior_into (prev->bbs_visited, entry->bbs_visited);\n+\t      bitmap_ior_into (prev->non_ssa_vars, entry->non_ssa_vars);\n+\t    }\n+\t  if (prev->earliest > entry->earliest)\n+\t    prev->earliest = entry->earliest;\n+\t  prev->overall_time += entry->overall_time;\n+\t  prev->overall_size += entry->overall_size;\n+\t  BITMAP_FREE (entry->set_ssa_names);\n+\t  BITMAP_FREE (entry->used_ssa_names);\n+\t  BITMAP_FREE (entry->bbs_visited);\n+\t  BITMAP_FREE (entry->non_ssa_vars);\n+\t  VEC_pop (stack_entry, stack);\n+\t}\n+      else\n+        VEC_pop (stack_entry, stack);\n+    }\n+  ENTRY_BLOCK_PTR->aux = NULL;\n+  FOR_EACH_BB (bb)\n+    bb->aux = NULL;\n+  BITMAP_FREE (current.ssa_names_to_pass);\n+}\n+\n+/* Split function at SPLIT_POINT.  */\n+\n+static void\n+split_function (struct split_point *split_point)\n+{\n+  VEC (tree, heap) *args_to_pass = NULL;\n+  bitmap args_to_skip = BITMAP_ALLOC (NULL);\n+  tree parm;\n+  int num = 0;\n+  struct cgraph_node *node;\n+  basic_block return_bb = find_return_bb ();\n+  basic_block call_bb;\n+  gimple_stmt_iterator gsi;\n+  gimple call;\n+  edge e;\n+  edge_iterator ei;\n+  tree retval = NULL, real_retval = NULL;\n+  bool split_part_return_p = false;\n+  gimple last_stmt = NULL;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\\nSplitting function at:\\n\");\n+      dump_split_point (dump_file, split_point);\n+    }\n+\n+  /* Collect the parameters of new function and args_to_skip bitmap.  */\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm; parm = TREE_CHAIN (parm), num++)\n+    if (!is_gimple_reg (parm)\n+\t|| !gimple_default_def (cfun, parm)\n+\t|| !bitmap_bit_p (split_point->ssa_names_to_pass,\n+\t\t\t  SSA_NAME_VERSION (gimple_default_def (cfun, parm))))\n+      bitmap_set_bit (args_to_skip, num);\n+    else\n+      VEC_safe_push (tree, heap, args_to_pass, gimple_default_def (cfun, parm));\n+\n+  /* See if the split function will return.  */\n+  FOR_EACH_EDGE (e, ei, return_bb->preds)\n+    if (bitmap_bit_p (split_point->split_bbs, e->src->index))\n+      break;\n+  if (e)\n+    split_part_return_p = true;\n+\n+  /* If we return, we will need the return block.  */\n+  if (return_bb != EXIT_BLOCK_PTR && split_part_return_p)\n+    bitmap_set_bit (split_point->split_bbs, return_bb->index);\n+\n+  /* Now create the actual clone.  */\n+  rebuild_cgraph_edges ();\n+  node = cgraph_function_versioning (cgraph_node (current_function_decl),\n+\t\t\t\t     NULL, NULL,\n+\t\t\t\t     args_to_skip,\n+\t\t\t\t     split_point->split_bbs,\n+\t\t\t\t     split_point->entry_bb, \"_part\");\n+  cgraph_node_remove_callees (cgraph_node (current_function_decl));\n+  if (!split_part_return_p)\n+    TREE_THIS_VOLATILE (node->decl) = 1;\n+  if (dump_file)\n+    dump_function_to_file (node->decl, dump_file, dump_flags);\n+\n+  /* Create the basic block we place call into.  It is the entry basic block\n+     split after last label.  */\n+  call_bb = split_point->entry_bb;\n+  for (gsi = gsi_start_bb (call_bb); !gsi_end_p (gsi);)\n+    if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+      {\n+\tlast_stmt = gsi_stmt (gsi);\n+\tgsi_next (&gsi);\n+      }\n+    else\n+      break;\n+  e = split_block (split_point->entry_bb, last_stmt);\n+  remove_edge (e);\n+\n+  /* Produce the call statement.  */\n+  gsi = gsi_last_bb (call_bb);\n+  call = gimple_build_call_vec (node->decl, args_to_pass);\n+  gimple_set_block (call, DECL_INITIAL (current_function_decl));\n+\n+  /* Update return value.  This is bit tricky.  When we do not return,\n+     do nothing.  When we return we might need to update return_bb\n+     or produce a new return statement.  */\n+  if (!split_part_return_p)\n+    gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+  else\n+    {\n+      e = make_edge (call_bb, return_bb,\n+\t\t     return_bb == EXIT_BLOCK_PTR ? 0 : EDGE_FALLTHRU);\n+      e->count = call_bb->count;\n+      e->probability = REG_BR_PROB_BASE;\n+      if (return_bb != EXIT_BLOCK_PTR)\n+\t{\n+\t  gimple return_stmt = gsi_stmt (gsi_last_bb (return_bb));\n+\t  gcc_assert (gimple_code (return_stmt) == GIMPLE_RETURN);\n+\n+\t  if ((real_retval = retval = gimple_return_retval (return_stmt))\n+\t      && !is_gimple_min_invariant (retval)\n+\t      && (TREE_CODE (retval) != SSA_NAME\n+\t\t  || !SSA_NAME_IS_DEFAULT_DEF (retval)))\n+\t    {\n+\t      gimple_stmt_iterator psi;\n+\n+\t      /* See if there is PHI definind return value.  */\n+\t      for (psi = gsi_start_phis (return_bb);\n+\t\t   !gsi_end_p (psi); gsi_next (&psi))\n+\t\tif (is_gimple_reg (gimple_phi_result (gsi_stmt (psi))))\n+\t\t  break;\n+\n+\t      /* When we have PHI, update PHI.  When there is no PHI,\n+\t\t update the return statement itself.  */\n+\t      if (TREE_CODE (retval) == SSA_NAME)\n+\t\t{\n+\t\t  retval = make_ssa_name (SSA_NAME_VAR (retval), call);\n+\t\t  if (TREE_CODE (retval) == SSA_NAME\n+\t\t      && !gsi_end_p (psi))\n+\t\t    add_phi_arg (gsi_stmt (psi), retval, e, UNKNOWN_LOCATION);\n+\t\t  else if (TREE_CODE (retval) == SSA_NAME)\n+\t\t    {\n+\t\t      gimple_return_set_retval (return_stmt, retval);\n+\t\t      update_stmt (return_stmt);\n+\t\t    }\n+\t\t}\n+\t      gimple_call_set_lhs (call, retval);\n+\t    }\n+          gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  gimple ret;\n+\t  if (!VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n+\t    {\n+\t      retval\n+\t        = create_tmp_var (TREE_TYPE (TREE_TYPE (current_function_decl)),\n+\t\t\t\t  \"RET\");\n+\t      if (is_gimple_reg (retval))\n+\t\tretval = make_ssa_name (retval, call);\n+\t      gimple_call_set_lhs (call, retval);\n+\t    }\n+          gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+\t  ret = gimple_build_return (retval);\n+\t  gsi_insert_after (&gsi, ret, GSI_NEW_STMT);\n+\t}\n+    }\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  compute_inline_parameters (node);\n+}\n+\n+/* Execute function splitting pass.  */\n+\n+static unsigned int\n+execute_split_functions (void)\n+{\n+  gimple_stmt_iterator bsi;\n+  basic_block bb;\n+  int overall_time = 0, overall_size = 0;\n+  int todo = 0;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+\n+  if (flags_from_decl_or_type (current_function_decl) & ECF_NORETURN)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: noreturn function.\\n\");\n+      return 0;\n+    }\n+  if (MAIN_NAME_P (DECL_NAME (current_function_decl)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: main function.\\n\");\n+      return 0;\n+    }\n+  /* This can be relaxed; function might become inlinable after splitting\n+     away the uninlinable part.  */\n+  if (!node->local.inlinable)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");\n+      return 0;\n+    }\n+  if (node->local.disregard_inline_limits)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: disregading inline limits.\\n\");\n+      return 0;\n+    }\n+  /* This can be relaxed; most of versioning tests actually prevents\n+     a duplication.  */\n+  if (!tree_versionable_function_p (current_function_decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: not versionable.\\n\");\n+      return 0;\n+    }\n+  /* FIXME: we could support this.  */\n+  if (DECL_STRUCT_FUNCTION (current_function_decl)->static_chain_decl)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: nested function.\\n\");\n+      return 0;\n+    }\n+  /* FIXME: Should be easy to support.  */\n+  if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: returns value by reference.\\n\");\n+      return 0;\n+    }\n+\n+  /* See if it makes sense to try to split.\n+     It makes sense to split if we inline, that is if we have direct calls to\n+     handle or direct calls are possibly going to appear as result of indirect\n+     inlining or LTO.\n+     Note that we are not completely conservative about disqualifying functions\n+     called once.  It is possible that the caller is called more then once and\n+     then inlining would still benefit.  */\n+  if ((!node->callers || !node->callers->next_caller)\n+      && !node->address_taken\n+      && ((!flag_lto && !flag_whopr) || !node->local.externally_visible))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: not called directly \"\n+\t\t \"or called once.\\n\");\n+      return 0;\n+    }\n+\n+  /* FIXME: We can actually split if splitting reduces call overhead.  */\n+  if (!flag_inline_small_functions\n+      && !DECL_DECLARED_INLINE_P (current_function_decl))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not splitting: not autoinlining and function\"\n+\t\t \" is not inline.\\n\");\n+      return 0;\n+    }\n+\n+  /* Compute local info about basic blocks and determine function size/time.  */\n+  VEC_safe_grow_cleared (bb_info, heap, bb_info_vec, last_basic_block + 1);\n+  memset (&best_split_point, 0, sizeof (best_split_point));\n+  FOR_EACH_BB (bb)\n+    {\n+      int time = 0;\n+      int size = 0;\n+      int freq = compute_call_stmt_bb_frequency (current_function_decl, bb);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Basic block %i\\n\", bb->index);\n+\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  int this_time, this_size;\n+\t  gimple stmt = gsi_stmt (bsi);\n+\n+\t  this_size = estimate_num_insns (stmt, &eni_size_weights);\n+\t  this_time = estimate_num_insns (stmt, &eni_time_weights) * freq;\n+\t  size += this_size;\n+\t  time += this_time;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \",\n+\t\t       freq, this_size, this_time);\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    }\n+\t}\n+      overall_time += time;\n+      overall_size += size;\n+      VEC_index (bb_info, bb_info_vec, bb->index)->time = time;\n+      VEC_index (bb_info, bb_info_vec, bb->index)->size = size;\n+    }\n+  find_split_points (overall_time, overall_size);\n+  if (best_split_point.split_bbs)\n+    {\n+      split_function (&best_split_point);\n+      BITMAP_FREE (best_split_point.ssa_names_to_pass);\n+      BITMAP_FREE (best_split_point.split_bbs);\n+      todo = TODO_update_ssa | TODO_cleanup_cfg;\n+    }\n+  VEC_free (bb_info, heap, bb_info_vec);\n+  bb_info_vec = NULL;\n+  return todo;\n+}\n+\n+static bool\n+gate_split_functions (void)\n+{\n+  return flag_partial_inlining;\n+}\n+\n+struct gimple_opt_pass pass_split_functions =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"fnsplit\",\t\t\t\t/* name */\n+  gate_split_functions,\t\t\t/* gate */\n+  execute_split_functions,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_FNSPLIT,\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "c30ff2ea4fc7bf35f0b3f811b0c40d729f80ee65", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -825,6 +825,7 @@ decode_options (unsigned int argc, const char **argv,\n   opt2 = (optimize >= 2);\n   flag_inline_small_functions = opt2;\n   flag_indirect_inlining = opt2;\n+  flag_partial_inlining = opt2;\n   flag_thread_jumps = opt2;\n   flag_crossjumping = opt2;\n   flag_optimize_sibling_calls = opt2;"}, {"sha": "d4321e4267deccf1746d3aaf1923c22ecb562aba", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -117,6 +117,12 @@ DEFPARAM (PARAM_EARLY_INLINER_MAX_ITERATIONS,\n \t  \"The maximum number of nested indirect inlining performed by early inliner\",\n \t  10, 0, 0)\n \n+/* Limit on probability of entry BB.  */\n+DEFPARAM (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY,\n+\t  \"partial-inlining-entry-probability\",\n+\t  \"Maximum probability of the entry BB of split region (in percent relative to entry BB of the function) to make partial inlining happen\",\n+\t  70, 0, 0)\n+\n /* Limit the number of expansions created by the variable expansion\n    optimization to avoid register pressure.  */\n DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,"}, {"sha": "03de5810fb430e4706014ecfaeb1f2ccbcc8dc57", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -795,6 +795,10 @@ init_optimization_passes (void)\n           NEXT_PASS (pass_cleanup_eh);\n           NEXT_PASS (pass_profile);\n           NEXT_PASS (pass_local_pure_const);\n+\t  /* Split functions creates parts that are not run through\n+\t     early optimizations again.  It is thus good idea to do this\n+\t     late.  */\n+          NEXT_PASS (pass_split_functions);\n \t}\n       NEXT_PASS (pass_release_ssa_names);\n       NEXT_PASS (pass_rebuild_cgraph_edges);"}, {"sha": "738ada28def13e27240bae02b05af9460e07bb10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -1,3 +1,7 @@\n+2010-06-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* testsuite/gcc.dg/tree-ssa/ipa-split-1.c\n+\n 2010-06-25  Martin Jambor  <mjambor@suse.cz>\n \n \t* g++.dg/ipa/iinline-2.C: New test."}, {"sha": "a31e8ea7a47316d238df63a8813dcbb6558efa14", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-split-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-1.c?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-fnsplit\" } */\n+int test2(a)\n+{\n+   if (a<100)\n+     return 1;\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   do_something_big ();\n+   return 0;\n+}\n+\n+test()\n+{\n+  test2(10);\n+  test2(20);\n+}\n+/* { dg-final { scan-tree-dump-times \"Splitting function\" 1 \"fnsplit\"} } */\n+/* { dg-final { cleanup-tree-dump \"fnsplit\" } } */"}, {"sha": "e4e61fb2f1ab5357f1e9c1f893b636f0326cc01b", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -52,6 +52,7 @@ DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n DEFTIMEVAR (TV_VARPOOL               , \"varpool construction\")\n DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n+DEFTIMEVAR (TV_IPA_FNSPLIT           , \"ipa function splitting\")\n DEFTIMEVAR (TV_IPA_LTO_GIMPLE_IO     , \"ipa lto gimple I/O\")\n DEFTIMEVAR (TV_IPA_LTO_DECL_IO       , \"ipa lto decl I/O\")\n DEFTIMEVAR (TV_IPA_LTO_DECL_INIT_IO  , \"ipa lto decl init I/O\")"}, {"sha": "a4c97b39155b0f4977d7ec0b55e18e03112ea52c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e485f6245f4ebac030eed59be23c5553069da52/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=3e485f6245f4ebac030eed59be23c5553069da52", "patch": "@@ -442,6 +442,7 @@ extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_local_pure_const;\n extern struct gimple_opt_pass pass_tracer;\n extern struct gimple_opt_pass pass_warn_unused_result;\n+extern struct gimple_opt_pass pass_split_functions;\n \n /* IPA Passes */\n extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;"}]}