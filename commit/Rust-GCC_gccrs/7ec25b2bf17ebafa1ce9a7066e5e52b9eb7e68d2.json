{"sha": "7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjMjViMmJmMTdlYmFmYTFjZTlhNzA2NmU1ZTUyYjllYjdlNjhkMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T11:52:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T11:52:28Z"}, "message": "[multiple changes]\n\n2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-comlin.adb, exp_aggr.adb, exp_ch6.adb, frontend.adb, gnatbind.adb,\n\tsem_ch3.adb, sem_util.adb: Minor reformatting.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* freeze.adb (Check_Inherited_Conditions): Rewriting\n\tof inherited preconditions and postconditions should only occur\n\tin GNATprove mode, that is, when GNATprove_Mode is True, not to\n\tbe confused with SPARK_Mode being On.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_warn.adb (Check_References): Take into\n\taccount possibility of attribute reference as original node.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Protect against invalid\n\tuse of attribute.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb (Split_Unconstrained_Function): Also set Is_Inlined\n\ton the procedure created to encapsulate the body.\n\t* sem_ch7.adb: Add with clause for GNAT.HTable.\n\t(Entity_Table_Size): New constant.\n\t(Entity_Hash): New function.\n\t(Subprogram_Table): New instantiation of GNAT.Htable.Simple_HTable.\n\t(Is_Subprogram_Ref): Rename into...\n\t(Scan_Subprogram_Ref): ...this. Record references to subprograms in\n\tthe table instead of bailing out on them. Scan the value of constants\n\tif it is not known at compile time.\n\t(Contains_Subprograms_Refs): Rename into...\n\t(Scan_Subprogram_Refs): ...this.\n\t(Has_Referencer): Scan the body of all inlined subprograms. Reset the\n\tIs_Public flag on subprograms if they are not actually referenced.\n\t(Hide_Public_Entities): Beef up comment on the algorithm.\n\tReset the table of subprograms on entry.\n\nFrom-SVN: r251781", "tree": {"sha": "54b3897bca2b75985a9cc0bce9004d96c83d1e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54b3897bca2b75985a9cc0bce9004d96c83d1e91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/comments", "author": null, "committer": null, "parents": [{"sha": "527b7b195744f1cf687ebca87d748edf7840970e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527b7b195744f1cf687ebca87d748edf7840970e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527b7b195744f1cf687ebca87d748edf7840970e"}], "stats": {"total": 367, "additions": 227, "deletions": 140}, "files": [{"sha": "0f142f5fe1212405cb70bbd1341981ae54bb1ab3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -1,3 +1,44 @@\n+2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-comlin.adb, exp_aggr.adb, exp_ch6.adb, frontend.adb, gnatbind.adb,\n+\tsem_ch3.adb, sem_util.adb: Minor reformatting.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* freeze.adb (Check_Inherited_Conditions): Rewriting\n+\tof inherited preconditions and postconditions should only occur\n+\tin GNATprove mode, that is, when GNATprove_Mode is True, not to\n+\tbe confused with SPARK_Mode being On.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_warn.adb (Check_References): Take into\n+\taccount possibility of attribute reference as original node.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Protect against invalid\n+\tuse of attribute.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* inline.adb (Split_Unconstrained_Function): Also set Is_Inlined\n+\ton the procedure created to encapsulate the body.\n+\t* sem_ch7.adb: Add with clause for GNAT.HTable.\n+\t(Entity_Table_Size): New constant.\n+\t(Entity_Hash): New function.\n+\t(Subprogram_Table): New instantiation of GNAT.Htable.Simple_HTable.\n+\t(Is_Subprogram_Ref): Rename into...\n+\t(Scan_Subprogram_Ref): ...this. Record references to subprograms in\n+\tthe table instead of bailing out on them. Scan the value of constants\n+\tif it is not known at compile time.\n+\t(Contains_Subprograms_Refs): Rename into...\n+\t(Scan_Subprogram_Refs): ...this.\n+\t(Has_Referencer): Scan the body of all inlined subprograms. Reset the\n+\tIs_Public flag on subprograms if they are not actually referenced.\n+\t(Hide_Public_Entities): Beef up comment on the algorithm.\n+\tReset the table of subprograms on entry.\n+\n 2017-09-06  Yannick Moy  <moy@adacore.com>\n \n \t* inline.adb: Add comments to Can_Be_Inlined_In_GNATprove_Mode."}, {"sha": "a555410cf1393d6ac4a92014bb344adafad83ed1", "filename": "gcc/ada/a-comlin.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fa-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fa-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -63,7 +63,7 @@ package body Ada.Command_Line is\n \n       declare\n          Num : constant Positive :=\n-           (if Remove_Args = null then Number else Remove_Args (Number));\n+                 (if Remove_Args = null then Number else Remove_Args (Number));\n          Arg : aliased String (1 .. Len_Arg (Num));\n       begin\n          Fill_Arg (Arg'Address, Num);"}, {"sha": "9ab9573edd12bf8411ea0c77054c8ac5ed053383", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -644,16 +644,16 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n-         --  Checks 11: The C code generator cannot handle aggregates that\n-         --  are not part of an object declaration.\n+         --  Checks 11: The C code generator cannot handle aggregates that are\n+         --  not part of an object declaration.\n \n          if Modify_Tree_For_C then\n             declare\n                Par : Node_Id := Parent (N);\n \n             begin\n                --  Skip enclosing nested aggregates and their qualified\n-               --  expressions\n+               --  expressions.\n \n                while Nkind (Par) = N_Aggregate\n                  or else Nkind (Par) = N_Qualified_Expression"}, {"sha": "60a975fe049bff3cd8b5a4e8fd3d30e8a4783740", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -6884,7 +6884,8 @@ package body Exp_Attr is\n          --  are any non-valid scalar subcomponents, and call the function.\n \n          elsif Is_Record_Type (Ftyp)\n-            and then Nkind (Type_Definition (Declaration_Node (Ftyp))) =\n+           and then Present (Declaration_Node (Ftyp))\n+           and then Nkind (Type_Definition (Declaration_Node (Ftyp))) =\n                                                         N_Record_Definition\n          then\n             Rewrite (N,"}, {"sha": "0a219f5c10f54acc42fb501dc2c1395dcce18950", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -3952,9 +3952,9 @@ package body Exp_Ch6 is\n                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));\n             return;\n \n-         --  A call to a null procedure is replaced by a null statement, but\n-         --  we are not allowed to ignore possible side effects of the call,\n-         --  so we make sure that actuals are evaluated.\n+         --  A call to a null procedure is replaced by a null statement, but we\n+         --  are not allowed to ignore possible side effects of the call, so we\n+         --  make sure that actuals are evaluated.\n \n          elsif Is_Null_Procedure (Subp) then\n             Actual := First_Actual (Call_Node);"}, {"sha": "caccb7e425ba833200ffb1ba9a8805a3674973c5", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -1494,12 +1494,12 @@ package body Freeze is\n \n             Analyze_Entry_Or_Subprogram_Contract (Par_Prim);\n \n-            --  In SPARK mode this is where we can collect the inherited\n+            --  In GNATprove mode this is where we can collect the inherited\n             --  conditions, because we do not create the Check pragmas that\n             --  normally convey the the modified class-wide conditions on\n             --  overriding operations.\n \n-            if SPARK_Mode = On then\n+            if GNATprove_Mode then\n                Collect_Inherited_Class_Wide_Conditions (Prim);\n \n             --  Otherwise build the corresponding pragmas to check for legality"}, {"sha": "378aacdffd1bbbaeaa88374db8011e65d1ffc2ed", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -133,15 +133,15 @@ begin\n    --  Read and process configuration pragma files if present\n \n    declare\n-      Config_Pragmas : List_Id := Empty_List;\n-      --  Gather configuration pragmas\n-\n-      Gnat_Adc : constant File_Name_Type := Name_Find (\"gnat.adc\");\n       Dot_Gnat_Adc : constant File_Name_Type := Name_Find (\"./gnat.adc\");\n+      Gnat_Adc     : constant File_Name_Type := Name_Find (\"gnat.adc\");\n \n       Save_Style_Check : constant Boolean := Opt.Style_Check;\n       --  Save style check mode so it can be restored later\n \n+      Config_Pragmas : List_Id := Empty_List;\n+      --  Gather configuration pragmas\n+\n       Source_Config_File : Source_File_Index;\n       --  Source reference for -gnatec configuration file\n \n@@ -191,19 +191,21 @@ begin\n             declare\n                Len : constant Natural := Config_File_Names (Index)'Length;\n                Str : constant String (1 .. Len) :=\n-                 Config_File_Names (Index).all;\n+                       Config_File_Names (Index).all;\n+\n                Config_Name : constant File_Name_Type := Name_Find (Str);\n-               Temp_File : constant Boolean := Len > 4\n-                 and then\n-                  (Str (Len - 3 .. Len) = \".TMP\"\n-                     or else\n-                   Str (Len - 3 .. Len) = \".tmp\");\n+               Temp_File   : constant Boolean :=\n+                               Len > 4\n+                                 and then\n+                                   (Str (Len - 3 .. Len) = \".TMP\"\n+                                      or else\n+                                    Str (Len - 3 .. Len) = \".tmp\");\n                --  Extension indicating a temporary config file?\n \n             begin\n                --  Skip it if it's the default name, already loaded above.\n-               --  Otherwise, we get confusing warning messages about\n-               --  seeing the same thing twice.\n+               --  Otherwise, we get confusing warning messages about seeing\n+               --  the same thing twice.\n \n                if Config_Name /= Gnat_Adc\n                  and then Config_Name /= Dot_Gnat_Adc"}, {"sha": "baba9feef7c962fe69971251ac0ecd856d9541fe", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -522,10 +522,10 @@ procedure Gnatbind is\n                      declare\n                         Arguments : constant Argument_List :=\n                           System.Response_File.Arguments_From\n-                                        (Response_File_Name        =>\n-                                           Next_Argv (2 .. Next_Argv'Last),\n-                                         Recursive                 => True,\n-                                         Ignore_Non_Existing_Files => True);\n+                            (Response_File_Name        =>\n+                               Next_Argv (2 .. Next_Argv'Last),\n+                             Recursive                 => True,\n+                             Ignore_Non_Existing_Files => True);\n                      begin\n                         for J in Arguments'Range loop\n                            Action (Arguments (J).all);"}, {"sha": "f023d721824dab02cb8bf039410c102aefc85d40", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -1607,7 +1607,7 @@ package body Inline is\n       --  N is an inlined function body that returns an unconstrained type and\n       --  has a single extended return statement. Split N in two subprograms:\n       --  a procedure P' and a function F'. The formals of P' duplicate the\n-      --  formals of N plus an extra formal which is used return a value;\n+      --  formals of N plus an extra formal which is used to return a value;\n       --  its body is composed by the declarations and list of statements\n       --  of the extended return statement of N.\n \n@@ -1915,6 +1915,7 @@ package body Inline is\n             Pop_Scope;\n             Build_Procedure (Proc_Id, Decl_List);\n             Insert_Actions (N, Decl_List);\n+            Set_Is_Inlined (Proc_Id);\n             Push_Scope (Scope);\n          end;\n "}, {"sha": "b1ecf5285f1faf7b4ab0aa90cb4b152f62f63835", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -16311,7 +16311,7 @@ package body Sem_Ch3 is\n       then\n          declare\n             Partial_View : constant Entity_Id :=\n-              Find_Partial_View (Parent_Type);\n+                             Find_Partial_View (Parent_Type);\n \n          begin\n             --  If the partial view was not found then the parent type is not a\n@@ -16321,9 +16321,9 @@ package body Sem_Ch3 is\n             if Present (Partial_View)\n               and then not Is_Tagged_Type (Partial_View)\n             then\n-               Error_Msg_NE (\"cannot derive from & declared as \"\n-                             & \"untagged private (SPARK RM 3.4(1))\",\n-                             N, Partial_View);\n+               Error_Msg_NE\n+                 (\"cannot derive from & declared as untagged private \"\n+                  & \"(SPARK RM 3.4(1))\", N, Partial_View);\n             end if;\n          end;\n       end if;"}, {"sha": "841aff8a5db88deb4be878ac9d301e5744e45763", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 136, "deletions": 102, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -70,6 +70,8 @@ with Sinput;    use Sinput;\n with Style;\n with Uintp;     use Uintp;\n \n+with GNAT.HTable;\n+\n package body Sem_Ch7 is\n \n    -----------------------------------\n@@ -187,6 +189,38 @@ package body Sem_Ch7 is\n       end if;\n    end Analyze_Package_Body;\n \n+   ------------------------------------------------------\n+   -- Analyze_Package_Body_Helper Data and Subprograms --\n+   ------------------------------------------------------\n+\n+   Entity_Table_Size : constant := 4096;\n+   --  Number of headers in hash table\n+\n+   subtype Entity_Header_Num is Integer range 0 .. Entity_Table_Size - 1;\n+   --  Range of headers in hash table\n+\n+   function Entity_Hash (Id : Entity_Id) return Entity_Header_Num;\n+   --  Simple hash function for Entity_Ids\n+\n+   package Subprogram_Table is new GNAT.Htable.Simple_HTable\n+     (Header_Num => Entity_Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Entity_Id,\n+      Hash       => Entity_Hash,\n+      Equal      => \"=\");\n+   --  Hash table to record which subprograms are referenced. It is declared\n+   --  at library level to avoid elaborating it for every call to Analyze.\n+\n+   -----------------\n+   -- Entity_Hash --\n+   -----------------\n+\n+   function Entity_Hash (Id : Entity_Id) return Entity_Header_Num is\n+   begin\n+      return Entity_Header_Num (Id mod Entity_Table_Size);\n+   end Entity_Hash;\n+\n    ---------------------------------\n    -- Analyze_Package_Body_Helper --\n    ---------------------------------\n@@ -200,8 +234,8 @@ package body Sem_Ch7 is\n       --  Attempt to hide all public entities found in declarative list Decls\n       --  by resetting their Is_Public flag to False depending on whether the\n       --  entities are not referenced by inlined or generic bodies. This kind\n-      --  of processing is a conservative approximation and may still leave\n-      --  certain entities externally visible.\n+      --  of processing is a conservative approximation and will still leave\n+      --  entities externally visible if the package is not simple enough.\n \n       procedure Install_Composite_Operations (P : Entity_Id);\n       --  Composite types declared in the current scope may depend on types\n@@ -214,11 +248,6 @@ package body Sem_Ch7 is\n       --------------------------\n \n       procedure Hide_Public_Entities (Decls : List_Id) is\n-         function Contains_Subprograms_Refs (N : Node_Id) return Boolean;\n-         --  Subsidiary to routine Has_Referencer. Determine whether a node\n-         --  contains a reference to a subprogram.\n-         --  WARNING: this is a very expensive routine as it performs a full\n-         --  tree traversal.\n \n          function Has_Referencer\n            (Decls     : List_Id;\n@@ -229,76 +258,15 @@ package body Sem_Ch7 is\n          --  in the range Last (Decls) .. Referencer are hidden from external\n          --  visibility.\n \n-         -------------------------------\n-         -- Contains_Subprograms_Refs --\n-         -------------------------------\n-\n-         function Contains_Subprograms_Refs (N : Node_Id) return Boolean is\n-            Reference_Seen : Boolean := False;\n-\n-            function Is_Subprogram_Ref (N : Node_Id) return Traverse_Result;\n-            --  Determine whether a node denotes a reference to a subprogram\n-\n-            -----------------------\n-            -- Is_Subprogram_Ref --\n-            -----------------------\n-\n-            function Is_Subprogram_Ref\n-              (N : Node_Id) return Traverse_Result\n-            is\n-               Val : Node_Id;\n-\n-            begin\n-               --  Detect a reference of the form\n-               --    Subp_Call\n-\n-               if Nkind (N) in N_Subprogram_Call\n-                 and then Is_Entity_Name (Name (N))\n-               then\n-                  Reference_Seen := True;\n-                  return Abandon;\n-\n-               --  Detect a reference of the form\n-               --    Subp'Some_Attribute\n-\n-               elsif Nkind (N) = N_Attribute_Reference\n-                 and then Is_Entity_Name (Prefix (N))\n-                 and then Present (Entity (Prefix (N)))\n-                 and then Is_Subprogram (Entity (Prefix (N)))\n-               then\n-                  Reference_Seen := True;\n-                  return Abandon;\n-\n-               --  Constants can be substituted by their value in gigi, which\n-               --  may contain a reference, so be conservative for them.\n-\n-               elsif Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then Ekind (Entity (N)) = E_Constant\n-               then\n-                  Val := Constant_Value (Entity (N));\n-\n-                  if Present (Val)\n-                    and then not Compile_Time_Known_Value (Val)\n-                  then\n-                     Reference_Seen := True;\n-                     return Abandon;\n-                  end if;\n-               end if;\n+         function Scan_Subprogram_Ref (N : Node_Id) return Traverse_Result;\n+         --  Determine whether a node denotes a reference to a subprogram\n \n-               return OK;\n-            end Is_Subprogram_Ref;\n-\n-            procedure Find_Subprograms_Ref is\n-              new Traverse_Proc (Is_Subprogram_Ref);\n-\n-         --  Start of processing for Contains_Subprograms_Refs\n-\n-         begin\n-            Find_Subprograms_Ref (N);\n-\n-            return Reference_Seen;\n-         end Contains_Subprograms_Refs;\n+         procedure Scan_Subprogram_Refs is\n+           new Traverse_Proc (Scan_Subprogram_Ref);\n+         --  Subsidiary to routine Has_Referencer. Determine whether a node\n+         --  contains references to a subprogram and record them.\n+         --  WARNING: this is a very expensive routine as it performs a full\n+         --  tree traversal.\n \n          --------------------\n          -- Has_Referencer --\n@@ -313,10 +281,9 @@ package body Sem_Ch7 is\n             Spec    : Node_Id;\n \n             Has_Non_Subprograms_Referencer : Boolean := False;\n-            --  Flag set if a subprogram body was detected as a referencer but\n-            --  does not contain references to other subprograms. In this case,\n-            --  if we still are top level, we do not return True immediately,\n-            --  but keep hiding subprograms from external visibility.\n+            --  Set if an inlined subprogram body was detected as a referencer.\n+            --  In this case, we do not return True immediately but keep hiding\n+            --  subprograms from external visibility.\n \n          begin\n             if No (Decls) then\n@@ -402,39 +369,36 @@ package body Sem_Ch7 is\n                      if Is_Inlined (Decl_Id)\n                        or else Has_Pragma_Inline (Decl_Id)\n                      then\n+                        Has_Non_Subprograms_Referencer := True;\n+\n                         --  Inspect the statements of the subprogram body\n                         --  to determine whether the body references other\n                         --  subprograms.\n \n-                        if Top_Level\n-                          and then not Contains_Subprograms_Refs (Decl)\n-                        then\n-                           Has_Non_Subprograms_Referencer := True;\n-                        else\n-                           return True;\n-                        end if;\n+                        Scan_Subprogram_Refs (Decl);\n                      end if;\n \n                   --  Otherwise this is a stand alone subprogram body\n \n                   else\n                      Decl_Id := Defining_Entity (Decl);\n \n-                     --  An inlined body acts as a referencer, see above. Note\n-                     --  that an inlined subprogram remains Is_Public as gigi\n-                     --  requires the flag to be set.\n+                     --  An inlined subprogram body acts as a referencer\n \n                      if Is_Inlined (Decl_Id)\n                        or else Has_Pragma_Inline (Decl_Id)\n                      then\n-                        if Top_Level\n-                          and then not Contains_Subprograms_Refs (Decl)\n-                        then\n-                           Has_Non_Subprograms_Referencer := True;\n-                        else\n-                           return True;\n-                        end if;\n-                     else\n+                        Has_Non_Subprograms_Referencer := True;\n+\n+                        --  Inspect the statements of the subprogram body\n+                        --  to determine whether the body references other\n+                        --  subprograms.\n+\n+                        Scan_Subprogram_Refs (Decl);\n+\n+                     --  Otherwise we can reset Is_Public right away\n+\n+                     elsif not Subprogram_Table.Get (Decl_Id) then\n                         Set_Is_Public (Decl_Id, False);\n                      end if;\n                   end if;\n@@ -443,9 +407,7 @@ package body Sem_Ch7 is\n                --  if they are not followed by a construct which can reference\n                --  and export them. The Is_Public flag is reset on top level\n                --  entities only as anything nested is local to its context.\n-               --  Likewise for subprograms, but we work harder for them as\n-               --  their visibility can have a significant impact on inlining\n-               --  decisions in the back end.\n+               --  Likewise for subprograms, but we work harder for them.\n \n                elsif Nkind_In (Decl, N_Exception_Declaration,\n                                      N_Object_Declaration,\n@@ -461,7 +423,8 @@ package body Sem_Ch7 is\n                     and then No (Interface_Name (Decl_Id))\n                     and then\n                       (not Has_Non_Subprograms_Referencer\n-                        or else Nkind (Decl) = N_Subprogram_Declaration)\n+                        or else (Nkind (Decl) = N_Subprogram_Declaration\n+                                  and then not Subprogram_Table.Get (Decl_Id)))\n                   then\n                      Set_Is_Public (Decl_Id, False);\n                   end if;\n@@ -473,6 +436,53 @@ package body Sem_Ch7 is\n             return Has_Non_Subprograms_Referencer;\n          end Has_Referencer;\n \n+         -------------------------\n+         -- Scan_Subprogram_Ref --\n+         -------------------------\n+\n+         function Scan_Subprogram_Ref (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  Detect a reference of the form\n+            --    Subp_Call\n+\n+            if Nkind (N) in N_Subprogram_Call\n+              and then Is_Entity_Name (Name (N))\n+              and then Present (Entity (Name (N)))\n+              and then Is_Subprogram (Entity (Name (N)))\n+            then\n+               Subprogram_Table.Set (Entity (Name (N)), True);\n+\n+            --  Detect a reference of the form\n+            --    Subp'Some_Attribute\n+\n+            elsif Nkind (N) = N_Attribute_Reference\n+              and then Is_Entity_Name (Prefix (N))\n+              and then Present (Entity (Prefix (N)))\n+              and then Is_Subprogram (Entity (Prefix (N)))\n+            then\n+               Subprogram_Table.Set (Entity (Prefix (N)), True);\n+\n+            --  Constants can be substituted by their value in gigi, which may\n+            --  contain a reference, so scan the value recursively.\n+\n+            elsif Is_Entity_Name (N)\n+              and then Present (Entity (N))\n+              and then Ekind (Entity (N)) = E_Constant\n+            then\n+               declare\n+                  Val : constant Node_Id := Constant_Value (Entity (N));\n+               begin\n+                  if Present (Val)\n+                    and then not Compile_Time_Known_Value (Val)\n+                  then\n+                     Scan_Subprogram_Refs (Val);\n+                  end if;\n+               end;\n+            end if;\n+\n+            return OK;\n+         end Scan_Subprogram_Ref;\n+\n          --  Local variables\n \n          Discard : Boolean := True;\n@@ -513,6 +523,30 @@ package body Sem_Ch7 is\n          --  not always be the case. The algorithm takes a conservative stance\n          --  and leaves entity External_Obj public.\n \n+         --  This very conservative algorithm is supplemented by a more precise\n+         --  processing for inlined bodies. For them, we traverse the syntactic\n+         --  tree and record which subprograms are actually referenced from it.\n+         --  This makes it possible to compute a much smaller set of externally\n+         --  visible subprograms, which can have a significant impact on the\n+         --  inlining decisions made in the back end. We do it only for inlined\n+         --  bodies because they are supposed to be reasonably small and tree\n+         --  traversal is very expensive.\n+\n+         --  Note that even this special processing is not optimal for inlined\n+         --  bodies, because we treat all inlined subprograms alike. An optimal\n+         --  algorithm would require computing the transitive closure of the\n+         --  inlined subprograms that can really be referenced from other units\n+         --  in the source code.\n+\n+         --  We could extend this processing for inlined bodies and record all\n+         --  entities, not just subprograms, referenced from them, which would\n+         --  make it possible to compute a much smaller set of all externally\n+         --  visible entities in the absence of generic bodies. But this would\n+         --  mean implementing a more thorough tree traversal of the bodies,\n+         --  i.e. not just syntactic, and the gain would very likely be worth\n+         --  neither the hassle nor the slowdown of the compiler.\n+\n+         Subprogram_Table.Reset;\n          Discard := Has_Referencer (Decls, Top_Level => True);\n       end Hide_Public_Entities;\n "}, {"sha": "c4d09a29e99d120abe6ea6ffa5a535ee45c4afad", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -14131,15 +14131,15 @@ package body Sem_Util is\n    function Is_Object_Image (Prefix : Node_Id) return Boolean is\n    begin\n       --  When the type of the prefix is not scalar then the prefix is not\n-      --  valid in any senario.\n+      --  valid in any scenario.\n \n       if not Is_Scalar_Type (Etype (Prefix)) then\n          return False;\n       end if;\n \n       --  Here we test for the case that the prefix is not a type and assume\n       --  if it is not then it must be a named value or an object reference.\n-      --  This is because the parser always checks that prefix's of attributes\n+      --  This is because the parser always checks that prefixes of attributes\n       --  are named.\n \n       return not (Is_Entity_Name (Prefix) and then Is_Type (Entity (Prefix)));\n@@ -15554,7 +15554,9 @@ package body Sem_Util is\n \n    begin\n       case Ekind (E) is\n-         when Entry_Kind | Subprogram_Kind =>\n+         when Entry_Kind\n+            | Subprogram_Kind\n+         =>\n             Scop := Scope (E);\n \n             while Present (Scop) loop"}, {"sha": "ecc47e4f24cbf9668abdd0e48283398eed636e31", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "patch": "@@ -1382,16 +1382,22 @@ package body Sem_Warn is\n                   --  deal with case where original unset reference has been\n                   --  rewritten during expansion.\n \n-                  --  In some cases, the original node may be a type conversion\n-                  --  or qualification, and in this case we want the object\n-                  --  entity inside.\n+                  --  In some cases, the original node may be a type\n+                  --  conversion, a qualification or an attribute reference and\n+                  --  in this case we want the object entity inside. Same for\n+                  --  an expression with actions.\n \n                   UR := Original_Node (UR);\n                   while Nkind (UR) = N_Type_Conversion\n                     or else Nkind (UR) = N_Qualified_Expression\n                     or else Nkind (UR) = N_Expression_With_Actions\n+                    or else Nkind (UR) = N_Attribute_Reference\n                   loop\n-                     UR := Expression (UR);\n+                     if Nkind (UR) = N_Attribute_Reference then\n+                        UR := Prefix (UR);\n+                     else\n+                        UR := Expression (UR);\n+                     end if;\n                   end loop;\n \n                   --  Don't issue warning if appearing inside Initial_Condition"}]}