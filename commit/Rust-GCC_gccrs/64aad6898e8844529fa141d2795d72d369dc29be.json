{"sha": "64aad6898e8844529fa141d2795d72d369dc29be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRhYWQ2ODk4ZTg4NDQ1MjlmYTE0MWQyNzk1ZDcyZDM2OWRjMjliZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2010-11-16T15:33:53Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2010-11-16T15:33:53Z"}, "message": "gensupport.c (MNEMONIC_ATTR_NAME, [...]): New macros.\n\n2010-11-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gensupport.c (MNEMONIC_ATTR_NAME, MNEMONIC_HTAB_SIZE): New\n\tmacros.\n\t(htab_eq_string, add_mnemonic_string, gen_mnemonic_setattr)\n\t(mnemonic_htab_callback, gen_mnemonic_attr): New functions.\n\t(init_rtx_reader_args_cb): Invoke gen_mnemonic_attr.\n\nFrom-SVN: r166804", "tree": {"sha": "630b3da18b0a5ff7ed35481d43ca885e1a7aca4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/630b3da18b0a5ff7ed35481d43ca885e1a7aca4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64aad6898e8844529fa141d2795d72d369dc29be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64aad6898e8844529fa141d2795d72d369dc29be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64aad6898e8844529fa141d2795d72d369dc29be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64aad6898e8844529fa141d2795d72d369dc29be/comments", "author": null, "committer": null, "parents": [{"sha": "c2ed6cf88c524f8a981a272fc2aaa23e77e09f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ed6cf88c524f8a981a272fc2aaa23e77e09f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ed6cf88c524f8a981a272fc2aaa23e77e09f9b"}], "stats": {"total": 226, "additions": 226, "deletions": 0}, "files": [{"sha": "0016f5155e16561454cc33ace5e1ccdc375f532a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64aad6898e8844529fa141d2795d72d369dc29be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64aad6898e8844529fa141d2795d72d369dc29be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64aad6898e8844529fa141d2795d72d369dc29be", "patch": "@@ -1,3 +1,11 @@\n+2010-11-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gensupport.c (MNEMONIC_ATTR_NAME, MNEMONIC_HTAB_SIZE): New\n+\tmacros.\n+\t(htab_eq_string, add_mnemonic_string, gen_mnemonic_setattr)\n+\t(mnemonic_htab_callback, gen_mnemonic_attr): New functions.\n+\t(init_rtx_reader_args_cb): Invoke gen_mnemonic_attr.\n+\n 2010-11-16  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* builtins.c (std_gimplify_va_arg_expr): Use"}, {"sha": "e81682c7c21723019788786f81b0d5714a7b37d6", "filename": "gcc/gensupport.c", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64aad6898e8844529fa141d2795d72d369dc29be/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64aad6898e8844529fa141d2795d72d369dc29be/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=64aad6898e8844529fa141d2795d72d369dc29be", "patch": "@@ -60,6 +60,9 @@ struct queue_elem\n   struct queue_elem *split;\n };\n \n+#define MNEMONIC_ATTR_NAME \"mnemonic\"\n+#define MNEMONIC_HTAB_SIZE 1024\n+\n static struct queue_elem *define_attr_queue;\n static struct queue_elem **define_attr_tail = &define_attr_queue;\n static struct queue_elem *define_pred_queue;\n@@ -782,6 +785,218 @@ rtx_handle_directive (int lineno, const char *rtx_name)\n       process_rtx (XEXP (x, 0), lineno);\n }\n \n+/* Comparison function for the mnemonic hash table.  */\n+\n+static int\n+htab_eq_string (const void *s1, const void *s2)\n+{\n+  return strcmp ((const char*)s1, (const char*)s2) == 0;\n+}\n+\n+/* Add mnemonic STR with length LEN to the mnemonic hash table\n+   MNEMONIC_HTAB.  A trailing zero end character is appendend to STR\n+   and a permanent heap copy of STR is created.  */\n+\n+static void\n+add_mnemonic_string (htab_t mnemonic_htab, const char *str, int len)\n+{\n+  char *new_str;\n+  void **slot;\n+  char *str_zero = (char*)alloca (len + 1);\n+\n+  memcpy (str_zero, str, len);\n+  str_zero[len] = '\\0';\n+\n+  slot = htab_find_slot (mnemonic_htab, str_zero, INSERT);\n+\n+  if (*slot)\n+    return;\n+\n+  /* Not found; create a permanent copy and add it to the hash table.  */\n+  new_str = XNEWVAR (char, len + 1);\n+  memcpy (new_str, str_zero, len + 1);\n+  *slot = new_str;\n+}\n+\n+/* Scan INSN for mnemonic strings and add them to the mnemonic hash\n+   table in MNEMONIC_HTAB.\n+\n+   The mnemonics cannot be found if they are emitted using C code.\n+\n+   If a mnemonic string contains ';' or a newline the string assumed\n+   to consist of more than a single instruction.  The attribute value\n+   will then be set to the user defined default value.  */\n+\n+static void\n+gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n+{\n+  const char *template_code, *cp;\n+  int i;\n+  int vec_len;\n+  rtx set_attr;\n+  char *attr_name;\n+  rtvec new_vec;\n+\n+  template_code = XTMPL (insn, 3);\n+\n+  /* Skip patterns which use C code to emit the template.  */\n+  if (template_code[0] == '*')\n+    return;\n+\n+  if (template_code[0] == '@')\n+    cp = &template_code[1];\n+  else\n+    cp = &template_code[0];\n+\n+  for (i = 0; *cp; )\n+    {\n+      const char *ep, *sp;\n+      int size = 0;\n+\n+      while (ISSPACE (*cp))\n+\tcp++;\n+\n+      for (ep = sp = cp; !IS_VSPACE (*ep) && *ep != '\\0'; ++ep)\n+\tif (!ISSPACE (*ep))\n+\t  sp = ep + 1;\n+\n+      if (i > 0)\n+\tobstack_1grow (&string_obstack, ',');\n+\n+      while (cp < sp && ((*cp >= '0' && *cp <= '9')\n+\t\t\t || (*cp >= 'a' && *cp <= 'z')))\n+\n+\t{\n+\t  obstack_1grow (&string_obstack, *cp);\n+\t  cp++;\n+\t  size++;\n+\t}\n+\n+      while (cp < sp)\n+\t{\n+\t  if (*cp == ';' || (*cp == '\\\\' && cp[1] == 'n'))\n+\t    {\n+\t      /* Don't set a value if there are more than one\n+\t\t instruction in the string.  */\n+\t      obstack_next_free (&string_obstack) =\n+\t\tobstack_next_free (&string_obstack) - size;\n+\t      size = 0;\n+\n+\t      cp = sp;\n+\t      break;\n+\t    }\n+\t  cp++;\n+\t}\n+      if (size == 0)\n+\tobstack_1grow (&string_obstack, '*');\n+      else\n+\tadd_mnemonic_string (mnemonic_htab,\n+\t\t\t     obstack_next_free (&string_obstack) - size,\n+\t\t\t     size);\n+      i++;\n+    }\n+\n+  /* An insn definition might emit an empty string.  */\n+  if (obstack_object_size (&string_obstack) == 0)\n+    return;\n+\n+  obstack_1grow (&string_obstack, '\\0');\n+\n+  set_attr = rtx_alloc (SET_ATTR);\n+  XSTR (set_attr, 1) = XOBFINISH (&string_obstack, char *);\n+  attr_name = XNEWVAR (char, strlen (MNEMONIC_ATTR_NAME) + 1);\n+  strcpy (attr_name, MNEMONIC_ATTR_NAME);\n+  XSTR (set_attr, 0) = attr_name;\n+\n+  if (!XVEC (insn, 4))\n+    vec_len = 0;\n+  else\n+    vec_len = XVECLEN (insn, 4);\n+\n+  new_vec = rtvec_alloc (vec_len + 1);\n+  for (i = 0; i < vec_len; i++)\n+    RTVEC_ELT (new_vec, i) = XVECEXP (insn, 4, i);\n+  RTVEC_ELT (new_vec, vec_len) = set_attr;\n+  XVEC (insn, 4) = new_vec;\n+}\n+\n+/* This function is called for the elements in the mnemonic hashtable\n+   and generates a comma separated list of the mnemonics.  */\n+\n+static int\n+mnemonic_htab_callback (void **slot, void *info ATTRIBUTE_UNUSED)\n+{\n+  obstack_grow (&string_obstack, (char*)*slot, strlen ((char*)*slot));\n+  obstack_1grow (&string_obstack, ',');\n+  return 1;\n+}\n+\n+/* Generate (set_attr \"mnemonic\" \"..\") RTXs and append them to every\n+   insn definition in case the back end requests it by defining the\n+   mnemonic attribute.  The values for the attribute will be extracted\n+   from the output patterns of the insn definitions as far as\n+   possible.  */\n+\n+static void\n+gen_mnemonic_attr (void)\n+{\n+  struct queue_elem *elem;\n+  rtx mnemonic_attr = NULL;\n+  htab_t mnemonic_htab;\n+  const char *str, *p;\n+  int i;\n+\n+  if (have_error)\n+    return;\n+\n+  /* Look for the DEFINE_ATTR for `mnemonic'.  */\n+  for (elem = define_attr_queue; elem != *define_attr_tail; elem = elem->next)\n+    if (GET_CODE (elem->data) == DEFINE_ATTR\n+\t&& strcmp (XSTR (elem->data, 0), MNEMONIC_ATTR_NAME) == 0)\n+      {\n+\tmnemonic_attr = elem->data;\n+\tbreak;\n+      }\n+\n+  /* A (define_attr \"mnemonic\" \"...\") indicates that the back-end\n+     wants a mnemonic attribute to be generated.  */\n+  if (!mnemonic_attr)\n+    return;\n+\n+  mnemonic_htab = htab_create_alloc (MNEMONIC_HTAB_SIZE, htab_hash_string,\n+\t\t\t\t     htab_eq_string, 0, xcalloc, free);\n+\n+  for (elem = define_insn_queue; elem; elem = elem->next)\n+    {\n+      rtx insn = elem->data;\n+      bool found = false;\n+\n+      /* Check if the insn definition already has\n+\t (set_attr \"mnemonic\" ...).  */\n+      if (XVEC (insn, 4))\n+ \tfor (i = 0; i < XVECLEN (insn, 4); i++)\n+\t  if (strcmp (XSTR (XVECEXP (insn, 4, i), 0), MNEMONIC_ATTR_NAME) == 0)\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\n+      if (!found)\n+\tgen_mnemonic_setattr (mnemonic_htab, insn);\n+    }\n+\n+  /* Add the user defined values to the hash table.  */\n+  str = XSTR (mnemonic_attr, 1);\n+  while ((p = scan_comma_elt (&str)) != NULL)\n+    add_mnemonic_string (mnemonic_htab, p, str - p);\n+\n+  htab_traverse (mnemonic_htab, mnemonic_htab_callback, NULL);\n+\n+  /* Replace the last ',' with the zero end character.  */\n+  *((char *)obstack_next_free (&string_obstack) - 1) = '\\0';\n+  XSTR (mnemonic_attr, 1) = XOBFINISH (&string_obstack, char *);\n+}\n+\n /* The entry point for initializing the reader.  */\n \n bool\n@@ -800,6 +1015,9 @@ init_rtx_reader_args_cb (int argc, char **argv,\n   if (define_cond_exec_queue != NULL)\n     process_define_cond_exec ();\n \n+  if (define_attr_queue != NULL)\n+    gen_mnemonic_attr ();\n+\n   return !have_error;\n }\n "}]}