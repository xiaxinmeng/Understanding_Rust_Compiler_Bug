{"sha": "483b9fd0fe4e0da56b15a09be666c2012169274d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzYjlmZDBmZTRlMGRhNTZiMTVhMDliZTY2NmMyMDEyMTY5Mjc0ZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-02-02T11:02:05Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-02-02T11:02:05Z"}, "message": "fp-bit.h (MAX_USI_INT, MAX_SI_INT): Don't assume unsigned is wide enough.\n\n* config/fp-bit.h (MAX_USI_INT, MAX_SI_INT): Don't assume\nunsigned is wide enough.\n(BITS_PER_SI): New.\n* config/fp-bit.c (_fpmul_parts): Don't assume 32-bits SI.\n(si_to_float): Likewise.\n(float_to_si, float_to_usi): Use BITS_PER_SI.\n\nFrom-SVN: r39407", "tree": {"sha": "ca61b43d721d282dcd07da1ad5edbec6fa4f85ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca61b43d721d282dcd07da1ad5edbec6fa4f85ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/483b9fd0fe4e0da56b15a09be666c2012169274d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483b9fd0fe4e0da56b15a09be666c2012169274d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483b9fd0fe4e0da56b15a09be666c2012169274d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483b9fd0fe4e0da56b15a09be666c2012169274d/comments", "author": null, "committer": null, "parents": [{"sha": "567a2f0e204d3e557913b9a6440b1b2d000fa312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567a2f0e204d3e557913b9a6440b1b2d000fa312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567a2f0e204d3e557913b9a6440b1b2d000fa312"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "415c9ea023a86cb17b2eb8725cfadae590827b95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=483b9fd0fe4e0da56b15a09be666c2012169274d", "patch": "@@ -1,3 +1,12 @@\n+2001-02-02  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/fp-bit.h (MAX_USI_INT, MAX_SI_INT): Don't assume\n+\tunsigned is wide enough.\n+\t(BITS_PER_SI): New.\n+\t* config/fp-bit.c (_fpmul_parts): Don't assume 32-bits SI.\n+\t(si_to_float): Likewise.\n+\t(float_to_si, float_to_usi): Use BITS_PER_SI.\n+\n 2001-02-01  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* dwarf2out.c: Added explanation of abbreviations."}, {"sha": "f94259eebcb55516704fed4801914231c73bff87", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=483b9fd0fe4e0da56b15a09be666c2012169274d", "patch": "@@ -624,8 +624,8 @@ _fpmul_parts ( fp_number_type *  a,\n       return b;\n     }\n \n-  /* Calculate the mantissa by multiplying both 64bit numbers to get a\n-     128 bit number */\n+  /* Calculate the mantissa by multiplying both numbers to get a\n+     twice-as-wide number.  */\n   {\n #if defined(NO_DI_MODE)\n     {\n@@ -654,22 +654,22 @@ _fpmul_parts ( fp_number_type *  a,\n \t}\n     }\n #elif defined(FLOAT) \n+    /* Multiplying two USIs to get a UDI, we're safe.  */\n     {\n-      /* Multiplying two 32 bit numbers to get a 64 bit number  on \n-        a machine with DI, so we're safe */\n-\n-      DItype answer = (DItype)(a->fraction.ll) * (DItype)(b->fraction.ll);\n+      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;\n       \n-      high = answer >> 32;\n+      high = answer >> BITS_PER_SI;\n       low = answer;\n     }\n #else\n-    /* Doing a 64*64 to 128 */\n+    /* fractype is DImode, but we need the result to be twice as wide.\n+       Assuming a widening multiply from DImode to TImode is not\n+       available, build one by hand.  */\n     {\n-      USItype nl = a->fraction.ll & 0xffffffff;\n-      USItype nh = a->fraction.ll >> 32;\n-      USItype ml = b->fraction.ll & 0xffffffff;\n-      USItype mh = b->fraction.ll >>32;\n+      USItype nl = a->fraction.ll;\n+      USItype nh = a->fraction.ll >> BITS_PER_SI;\n+      USItype ml = b->fraction.ll;\n+      USItype mh = b->fraction.ll >> BITS_PER_SI;\n       UDItype pp_ll = (UDItype) ml * nl;\n       UDItype pp_hl = (UDItype) mh * nl;\n       UDItype pp_lh = (UDItype) ml * nh;\n@@ -678,12 +678,12 @@ _fpmul_parts ( fp_number_type *  a,\n       UDItype res0 = 0;\n       UDItype ps_hh__ = pp_hl + pp_lh;\n       if (ps_hh__ < pp_hl)\n-\tres2 += 0x100000000LL;\n-      pp_hl = (ps_hh__ << 32) & 0xffffffff00000000LL;\n+\tres2 += (UDItype)1 << BITS_PER_SI;\n+      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;\n       res0 = pp_ll + pp_hl;\n       if (res0 < pp_ll)\n \tres2++;\n-      res2 += ((ps_hh__ >> 32) & 0xffffffffL) + pp_hh;\n+      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;\n       high = res2;\n       low = res0;\n     }\n@@ -1151,9 +1151,9 @@ si_to_float (SItype arg_a)\n \t{\n \t  /* Special case for minint, since there is no +ve integer\n \t     representation for it */\n-\t  if (arg_a == (SItype) 0x80000000)\n+\t  if (arg_a == (- MAX_SI_INT - 1))\n \t    {\n-\t      return -2147483648.0;\n+\t      return (FLO_type)(- MAX_SI_INT - 1);\n \t    }\n \t  in.fraction.ll = (-arg_a);\n \t}\n@@ -1223,7 +1223,7 @@ float_to_si (FLO_type arg_a)\n   /* it is a number, but a small one */\n   if (a.normal_exp < 0)\n     return 0;\n-  if (a.normal_exp > 4 * BITS_PER_UNIT - 2)\n+  if (a.normal_exp > BITS_PER_SI - 2)\n     return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;\n   tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n   return a.sign ? (-tmp) : (tmp);\n@@ -1260,7 +1260,7 @@ float_to_usi (FLO_type arg_a)\n   /* it is a number, but a small one */\n   if (a.normal_exp < 0)\n     return 0;\n-  if (a.normal_exp > 4 * BITS_PER_UNIT - 1)\n+  if (a.normal_exp > BITS_PER_SI - 1)\n     return MAX_USI_INT;\n   else if (a.normal_exp > (FRACBITS + NGARDS))\n     return a.fraction.ll << (a.normal_exp - (FRACBITS + NGARDS));"}, {"sha": "f4471f9067a0a6182b2f88220421dc8f6c2c09c4", "filename": "gcc/config/fp-bit.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2Fconfig%2Ffp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483b9fd0fe4e0da56b15a09be666c2012169274d/gcc%2Fconfig%2Ffp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.h?ref=483b9fd0fe4e0da56b15a09be666c2012169274d", "patch": "@@ -103,9 +103,9 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n typedef unsigned int USItype __attribute__ ((mode (SI)));\n typedef unsigned int UDItype __attribute__ ((mode (DI)));\n \n-#define MAX_SI_INT   ((SItype) ((unsigned) (~0)>>1))\n-#define MAX_USI_INT  ((USItype) ~0)\n-\n+#define MAX_USI_INT  (~(USItype)0)\n+#define MAX_SI_INT   ((SItype) (MAX_USI_INT >> 1))\n+#define BITS_PER_SI  (4 * BITS_PER_UNIT)\n \n #ifdef FLOAT_ONLY\n #define NO_DI_MODE"}]}