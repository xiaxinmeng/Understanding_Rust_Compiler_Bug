{"sha": "c8e9d8c3465954947924050f77c899626631f15d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhlOWQ4YzM0NjU5NTQ5NDc5MjQwNTBmNzdjODk5NjI2NjMxZjE1ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-06T07:24:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-06T07:24:11Z"}, "message": "basic-block.h (class control_dependences): New.\n\n2013-09-06  Richard Biener  <rguenther@suse.de>\n\n\t* basic-block.h (class control_dependences): New.\n\t* tree-ssa-dce.c (control_dependence_map): Remove.\n\t(cd): New global.\n\t(EXECUTE_IF_CONTROL_DEPENDENT): Remove.\n\t(set_control_dependence_map_bit, clear_control_dependence_bitmap,\n\tfind_pdom, find_control_dependence, find_all_control_dependences):\n\tMove to cfganal.c.\n\t(mark_control_dependent_edges_necessary, find_obviously_necessary_stmts,\n\tpropagate_necessity, tree_dce_init, tree_dce_done,\n\tperform_tree_ssa_dce): Adjust.\n\t* cfganal.c (set_control_dependence_map_bit,\n\tclear_control_dependence_bitmap, find_pdom, find_control_dependence,\n\tfind_all_control_dependences): Move from tree-ssa-dce.c and\n\timplement as methods of control_dependences class.\n\t(control_dependences::control_dependences): New.\n\t(control_dependences::~control_dependences): Likewise.\n\t(control_dependences::get_edges_dependent_on): Likewise.\n\t(control_dependences::get_edge): Likewise.\n\nFrom-SVN: r202309", "tree": {"sha": "a8acf76c03845d011a108b0a59783c1a9c395538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8acf76c03845d011a108b0a59783c1a9c395538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8e9d8c3465954947924050f77c899626631f15d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e9d8c3465954947924050f77c899626631f15d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8e9d8c3465954947924050f77c899626631f15d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e9d8c3465954947924050f77c899626631f15d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1576de517f65cd51b786bb0ef9e53225da12b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1576de517f65cd51b786bb0ef9e53225da12b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1576de517f65cd51b786bb0ef9e53225da12b8e"}], "stats": {"total": 294, "additions": 169, "deletions": 125}, "files": [{"sha": "44ddc1a61f7905d684e7ce1072e23156cea9b6c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e9d8c3465954947924050f77c899626631f15d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e9d8c3465954947924050f77c899626631f15d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8e9d8c3465954947924050f77c899626631f15d", "patch": "@@ -1,3 +1,24 @@\n+2013-09-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* basic-block.h (class control_dependences): New.\n+\t* tree-ssa-dce.c (control_dependence_map): Remove.\n+\t(cd): New global.\n+\t(EXECUTE_IF_CONTROL_DEPENDENT): Remove.\n+\t(set_control_dependence_map_bit, clear_control_dependence_bitmap,\n+\tfind_pdom, find_control_dependence, find_all_control_dependences):\n+\tMove to cfganal.c.\n+\t(mark_control_dependent_edges_necessary, find_obviously_necessary_stmts,\n+\tpropagate_necessity, tree_dce_init, tree_dce_done,\n+\tperform_tree_ssa_dce): Adjust.\n+\t* cfganal.c (set_control_dependence_map_bit,\n+\tclear_control_dependence_bitmap, find_pdom, find_control_dependence,\n+\tfind_all_control_dependences): Move from tree-ssa-dce.c and\n+\timplement as methods of control_dependences class.\n+\t(control_dependences::control_dependences): New.\n+\t(control_dependences::~control_dependences): Likewise.\n+\t(control_dependences::get_edges_dependent_on): Likewise.\n+\t(control_dependences::get_edge): Likewise.\n+\n 2013-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (types_same_for_odr): Drop overactive check."}, {"sha": "ad04d4de83e42f970c78dffd630e3166fb867176", "filename": "gcc/basic-block.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c8e9d8c3465954947924050f77c899626631f15d", "patch": "@@ -465,6 +465,23 @@ struct edge_list\n   edge *index_to_edge;\n };\n \n+/* Class to compute and manage control dependences on an edge-list.  */\n+class control_dependences\n+{\n+public:\n+  control_dependences (edge_list *);\n+  ~control_dependences ();\n+  bitmap get_edges_dependent_on (int);\n+  edge get_edge (int);\n+\n+private:\n+  void set_control_dependence_map_bit (basic_block, int);\n+  void clear_control_dependence_bitmap (basic_block);\n+  void find_control_dependence (int);\n+  vec<bitmap> control_dependence_map;\n+  edge_list *el;\n+};\n+\n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n "}, {"sha": "8a04f03ea1b3b49aa173ef4316d0b3ff781234f3", "filename": "gcc/cfganal.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=c8e9d8c3465954947924050f77c899626631f15d", "patch": "@@ -340,6 +340,120 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n       }\n }\n \n+\n+/* Functions to compute control dependences.  */\n+\n+/* Indicate block BB is control dependent on an edge with index EDGE_INDEX.  */\n+void\n+control_dependences::set_control_dependence_map_bit (basic_block bb,\n+\t\t\t\t\t\t     int edge_index)\n+{\n+  if (bb == ENTRY_BLOCK_PTR)\n+    return;\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n+  bitmap_set_bit (control_dependence_map[bb->index], edge_index);\n+}\n+\n+/* Clear all control dependences for block BB.  */\n+void\n+control_dependences::clear_control_dependence_bitmap (basic_block bb)\n+{\n+  bitmap_clear (control_dependence_map[bb->index]);\n+}\n+\n+/* Find the immediate postdominator PDOM of the specified basic block BLOCK.\n+   This function is necessary because some blocks have negative numbers.  */\n+\n+static inline basic_block\n+find_pdom (basic_block block)\n+{\n+  gcc_assert (block != ENTRY_BLOCK_PTR);\n+\n+  if (block == EXIT_BLOCK_PTR)\n+    return EXIT_BLOCK_PTR;\n+  else\n+    {\n+      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n+      if (! bb)\n+\treturn EXIT_BLOCK_PTR;\n+      return bb;\n+    }\n+}\n+\n+/* Determine all blocks' control dependences on the given edge with edge_list\n+   EL index EDGE_INDEX, ala Morgan, Section 3.6.  */\n+\n+void\n+control_dependences::find_control_dependence (int edge_index)\n+{\n+  basic_block current_block;\n+  basic_block ending_block;\n+\n+  gcc_assert (INDEX_EDGE_PRED_BB (el, edge_index) != EXIT_BLOCK_PTR);\n+\n+  if (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n+    ending_block = single_succ (ENTRY_BLOCK_PTR);\n+  else\n+    ending_block = find_pdom (INDEX_EDGE_PRED_BB (el, edge_index));\n+\n+  for (current_block = INDEX_EDGE_SUCC_BB (el, edge_index);\n+       current_block != ending_block && current_block != EXIT_BLOCK_PTR;\n+       current_block = find_pdom (current_block))\n+    {\n+      edge e = INDEX_EDGE (el, edge_index);\n+\n+      /* For abnormal edges, we don't make current_block control\n+\t dependent because instructions that throw are always necessary\n+\t anyway.  */\n+      if (e->flags & EDGE_ABNORMAL)\n+\tcontinue;\n+\n+      set_control_dependence_map_bit (current_block, edge_index);\n+    }\n+}\n+\n+/* Record all blocks' control dependences on all edges in the edge\n+   list EL, ala Morgan, Section 3.6.  */\n+\n+control_dependences::control_dependences (struct edge_list *edges)\n+  : el (edges)\n+{\n+  timevar_push (TV_CONTROL_DEPENDENCES);\n+  control_dependence_map.create (last_basic_block);\n+  for (int i = 0; i < last_basic_block; ++i)\n+    control_dependence_map.quick_push (BITMAP_ALLOC (NULL));\n+  for (int i = 0; i < NUM_EDGES (el); ++i)\n+    find_control_dependence (i);\n+  timevar_pop (TV_CONTROL_DEPENDENCES);\n+}\n+\n+/* Free control dependences and the associated edge list.  */\n+\n+control_dependences::~control_dependences ()\n+{\n+  for (int i = 0; i < last_basic_block; ++i)\n+    BITMAP_FREE (control_dependence_map[i]);\n+  control_dependence_map.release ();\n+  free_edge_list (el);\n+}\n+\n+/* Returns the bitmap of edges the basic-block I is dependent on.  */\n+\n+bitmap\n+control_dependences::get_edges_dependent_on (int i)\n+{\n+  return control_dependence_map[i];\n+}\n+\n+/* Returns the edge with index I from the edge list.  */\n+\n+edge\n+control_dependences::get_edge (int i)\n+{\n+  return INDEX_EDGE (el, i);\n+}\n+\n+\n /* Given PRED and SUCC blocks, return the edge which connects the blocks.\n    If no such edge exists, return NULL.  */\n "}, {"sha": "ecc8c6f22645847e4d4855709e1aa8b9a0a3d444", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 17, "deletions": 125, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e9d8c3465954947924050f77c899626631f15d/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=c8e9d8c3465954947924050f77c899626631f15d", "patch": "@@ -87,7 +87,7 @@ static sbitmap bb_contains_live_stmts;\n    use a bitmap for each block recording its edges.  An array holds the\n    bitmap.  The Ith bit in the bitmap is set if that block is dependent\n    on the Ith edge.  */\n-static bitmap *control_dependence_map;\n+static control_dependences *cd;\n \n /* Vector indicating that a basic block has already had all the edges\n    processed that it is control dependent on.  */\n@@ -100,96 +100,6 @@ static sbitmap visited_control_parents;\n    to be recomputed.  */\n static bool cfg_altered;\n \n-/* Execute code that follows the macro for each edge (given number\n-   EDGE_NUMBER within the CODE) for which the block with index N is\n-   control dependent.  */\n-#define EXECUTE_IF_CONTROL_DEPENDENT(BI, N, EDGE_NUMBER)\t\\\n-  EXECUTE_IF_SET_IN_BITMAP (control_dependence_map[(N)], 0,\t\\\n-\t\t\t    (EDGE_NUMBER), (BI))\n-\n-\n-/* Indicate block BB is control dependent on an edge with index EDGE_INDEX.  */\n-static inline void\n-set_control_dependence_map_bit (basic_block bb, int edge_index)\n-{\n-  if (bb == ENTRY_BLOCK_PTR)\n-    return;\n-  gcc_assert (bb != EXIT_BLOCK_PTR);\n-  bitmap_set_bit (control_dependence_map[bb->index], edge_index);\n-}\n-\n-/* Clear all control dependences for block BB.  */\n-static inline void\n-clear_control_dependence_bitmap (basic_block bb)\n-{\n-  bitmap_clear (control_dependence_map[bb->index]);\n-}\n-\n-\n-/* Find the immediate postdominator PDOM of the specified basic block BLOCK.\n-   This function is necessary because some blocks have negative numbers.  */\n-\n-static inline basic_block\n-find_pdom (basic_block block)\n-{\n-  gcc_assert (block != ENTRY_BLOCK_PTR);\n-\n-  if (block == EXIT_BLOCK_PTR)\n-    return EXIT_BLOCK_PTR;\n-  else\n-    {\n-      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n-      if (! bb)\n-\treturn EXIT_BLOCK_PTR;\n-      return bb;\n-    }\n-}\n-\n-\n-/* Determine all blocks' control dependences on the given edge with edge_list\n-   EL index EDGE_INDEX, ala Morgan, Section 3.6.  */\n-\n-static void\n-find_control_dependence (struct edge_list *el, int edge_index)\n-{\n-  basic_block current_block;\n-  basic_block ending_block;\n-\n-  gcc_assert (INDEX_EDGE_PRED_BB (el, edge_index) != EXIT_BLOCK_PTR);\n-\n-  if (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n-    ending_block = single_succ (ENTRY_BLOCK_PTR);\n-  else\n-    ending_block = find_pdom (INDEX_EDGE_PRED_BB (el, edge_index));\n-\n-  for (current_block = INDEX_EDGE_SUCC_BB (el, edge_index);\n-       current_block != ending_block && current_block != EXIT_BLOCK_PTR;\n-       current_block = find_pdom (current_block))\n-    {\n-      edge e = INDEX_EDGE (el, edge_index);\n-\n-      /* For abnormal edges, we don't make current_block control\n-\t dependent because instructions that throw are always necessary\n-\t anyway.  */\n-      if (e->flags & EDGE_ABNORMAL)\n-\tcontinue;\n-\n-      set_control_dependence_map_bit (current_block, edge_index);\n-    }\n-}\n-\n-\n-/* Record all blocks' control dependences on all edges in the edge\n-   list EL, ala Morgan, Section 3.6.  */\n-\n-static void\n-find_all_control_dependences (struct edge_list *el)\n-{\n-  int i;\n-\n-  for (i = 0; i < NUM_EDGES (el); ++i)\n-    find_control_dependence (el, i);\n-}\n \n /* If STMT is not already marked necessary, mark it, and add it to the\n    worklist if ADD_TO_WORKLIST is true.  */\n@@ -400,8 +310,7 @@ mark_last_stmt_necessary (basic_block bb)\n    When IGNORE_SELF is true, ignore BB in the list of control dependences.  */\n \n static void\n-mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el,\n-\t\t\t\t\tbool ignore_self)\n+mark_control_dependent_edges_necessary (basic_block bb, bool ignore_self)\n {\n   bitmap_iterator bi;\n   unsigned edge_number;\n@@ -412,9 +321,10 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el,\n   if (bb == ENTRY_BLOCK_PTR)\n     return;\n \n-  EXECUTE_IF_CONTROL_DEPENDENT (bi, bb->index, edge_number)\n+  EXECUTE_IF_SET_IN_BITMAP (cd->get_edges_dependent_on (bb->index),\n+\t\t\t    0, edge_number, bi)\n     {\n-      basic_block cd_bb = INDEX_EDGE_PRED_BB (el, edge_number);\n+      basic_block cd_bb = cd->get_edge (edge_number)->src;\n \n       if (ignore_self && cd_bb == bb)\n \t{\n@@ -439,7 +349,7 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el,\n    dependence analysis.  */\n \n static void\n-find_obviously_necessary_stmts (struct edge_list *el)\n+find_obviously_necessary_stmts (bool aggressive)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n@@ -461,7 +371,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t{\n \t  stmt = gsi_stmt (gsi);\n \t  gimple_set_plf (stmt, STMT_NECESSARY, false);\n-\t  mark_stmt_if_obviously_necessary (stmt, el != NULL);\n+\t  mark_stmt_if_obviously_necessary (stmt, aggressive);\n \t}\n     }\n \n@@ -472,7 +382,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n     return;\n \n   /* Prevent the empty possibly infinite loops from being removed.  */\n-  if (el)\n+  if (aggressive)\n     {\n       loop_iterator li;\n       struct loop *loop;\n@@ -488,7 +398,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t          if (dump_file)\n \t            fprintf (dump_file, \"Marking back edge of irreducible loop %i->%i\\n\",\n \t\t    \t     e->src->index, e->dest->index);\n-\t\t  mark_control_dependent_edges_necessary (e->dest, el, false);\n+\t\t  mark_control_dependent_edges_necessary (e->dest, false);\n \t\t}\n \t  }\n \n@@ -497,7 +407,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \"can not prove finiteness of loop %i\\n\", loop->num);\n-\t    mark_control_dependent_edges_necessary (loop->latch, el, false);\n+\t    mark_control_dependent_edges_necessary (loop->latch, false);\n \t  }\n       scev_finalize ();\n     }\n@@ -690,10 +600,9 @@ degenerate_phi_p (gimple phi)\n    In conservative mode, EL is NULL.  */\n \n static void\n-propagate_necessity (struct edge_list *el)\n+propagate_necessity (bool aggressive)\n {\n   gimple stmt;\n-  bool aggressive = (el ? true : false);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nProcessing worklist:\\n\");\n@@ -718,7 +627,7 @@ propagate_necessity (struct edge_list *el)\n \t  basic_block bb = gimple_bb (stmt);\n \t  if (bb != ENTRY_BLOCK_PTR\n \t      && !bitmap_bit_p (visited_control_parents, bb->index))\n-\t    mark_control_dependent_edges_necessary (bb, el, false);\n+\t    mark_control_dependent_edges_necessary (bb, false);\n \t}\n \n       if (gimple_code (stmt) == GIMPLE_PHI\n@@ -825,7 +734,7 @@ propagate_necessity (struct edge_list *el)\n \t\t  else if (arg_bb != ENTRY_BLOCK_PTR\n \t\t           && !bitmap_bit_p (visited_control_parents,\n \t\t\t\t\t arg_bb->index))\n-\t\t    mark_control_dependent_edges_necessary (arg_bb, el, true);\n+\t\t    mark_control_dependent_edges_necessary (arg_bb, true);\n \t\t}\n \t    }\n \t}\n@@ -1486,12 +1395,6 @@ tree_dce_init (bool aggressive)\n \n   if (aggressive)\n     {\n-      int i;\n-\n-      control_dependence_map = XNEWVEC (bitmap, last_basic_block);\n-      for (i = 0; i < last_basic_block; ++i)\n-\tcontrol_dependence_map[i] = BITMAP_ALLOC (NULL);\n-\n       last_stmt_necessary = sbitmap_alloc (last_basic_block);\n       bitmap_clear (last_stmt_necessary);\n       bb_contains_live_stmts = sbitmap_alloc (last_basic_block);\n@@ -1512,12 +1415,7 @@ tree_dce_done (bool aggressive)\n {\n   if (aggressive)\n     {\n-      int i;\n-\n-      for (i = 0; i < last_basic_block; ++i)\n-\tBITMAP_FREE (control_dependence_map[i]);\n-      free (control_dependence_map);\n-\n+      delete cd;\n       sbitmap_free (visited_control_parents);\n       sbitmap_free (last_stmt_necessary);\n       sbitmap_free (bb_contains_live_stmts);\n@@ -1546,7 +1444,6 @@ tree_dce_done (bool aggressive)\n static unsigned int\n perform_tree_ssa_dce (bool aggressive)\n {\n-  struct edge_list *el = NULL;\n   bool something_changed = 0;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -1563,19 +1460,16 @@ perform_tree_ssa_dce (bool aggressive)\n   if (aggressive)\n     {\n       /* Compute control dependence.  */\n-      timevar_push (TV_CONTROL_DEPENDENCES);\n       calculate_dominance_info (CDI_POST_DOMINATORS);\n-      el = create_edge_list ();\n-      find_all_control_dependences (el);\n-      timevar_pop (TV_CONTROL_DEPENDENCES);\n+      cd = new control_dependences (create_edge_list ());\n \n       visited_control_parents = sbitmap_alloc (last_basic_block);\n       bitmap_clear (visited_control_parents);\n \n       mark_dfs_back_edges ();\n     }\n \n-  find_obviously_necessary_stmts (el);\n+  find_obviously_necessary_stmts (aggressive);\n \n   if (aggressive)\n     loop_optimizer_finalize ();\n@@ -1585,7 +1479,7 @@ perform_tree_ssa_dce (bool aggressive)\n   nr_walks = 0;\n   chain_ovfl = false;\n   visited = BITMAP_ALLOC (NULL);\n-  propagate_necessity (el);\n+  propagate_necessity (aggressive);\n   BITMAP_FREE (visited);\n \n   something_changed |= eliminate_unnecessary_stmts ();\n@@ -1609,8 +1503,6 @@ perform_tree_ssa_dce (bool aggressive)\n \n   tree_dce_done (aggressive);\n \n-  free_edge_list (el);\n-\n   if (something_changed)\n     return TODO_update_ssa | TODO_cleanup_cfg;\n   return 0;"}]}