{"sha": "cd8d6792e3375d86e3ca810f261deef4f3f12048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q4ZDY3OTJlMzM3NWQ4NmUzY2E4MTBmMjYxZGVlZjRmM2YxMjA0OA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-10-27T11:54:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-27T11:54:29Z"}, "message": "namet.adb, namet.ads: Minor reformatting.\n\n2015-10-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* namet.adb, namet.ads: Minor reformatting.\n\nFrom-SVN: r229426", "tree": {"sha": "1296c6a36b3da1e2d76b761c628df9e819e69a75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1296c6a36b3da1e2d76b761c628df9e819e69a75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd8d6792e3375d86e3ca810f261deef4f3f12048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8d6792e3375d86e3ca810f261deef4f3f12048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8d6792e3375d86e3ca810f261deef4f3f12048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8d6792e3375d86e3ca810f261deef4f3f12048/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "461e4145898e7bdf5b6a0aec280246c0046fe807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461e4145898e7bdf5b6a0aec280246c0046fe807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461e4145898e7bdf5b6a0aec280246c0046fe807"}], "stats": {"total": 332, "additions": 171, "deletions": 161}, "files": [{"sha": "d11df2e81145f962f01bf97d4360b0c62e223fb6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cd8d6792e3375d86e3ca810f261deef4f3f12048", "patch": "@@ -1,3 +1,7 @@\n+2015-10-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* namet.adb, namet.ads: Minor reformatting.\n+\n 2015-10-27  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Allocator): Do not perform legality check"}, {"sha": "902f347b93806b78211ceb9e735d0171e1dcb3ff", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=cd8d6792e3375d86e3ca810f261deef4f3f12048", "patch": "@@ -628,7 +628,11 @@ package body Namet is\n    -- Get_Last_Two_Chars --\n    ------------------------\n \n-   procedure Get_Last_Two_Chars (N : Name_Id; C1, C2 : out Character) is\n+   procedure Get_Last_Two_Chars\n+     (N  : Name_Id;\n+      C1 : out Character;\n+      C2 : out Character)\n+   is\n       NE  : Name_Entry renames Name_Entries.Table (N);\n       NEL : constant Int := Int (NE.Name_Len);\n \n@@ -1309,6 +1313,37 @@ package body Namet is\n              T = V11;\n    end Nam_In;\n \n+   -----------------\n+   -- Name_Equals --\n+   -----------------\n+\n+   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean is\n+   begin\n+      if N1 = N2 then\n+         return True;\n+      end if;\n+\n+      declare\n+         L1 : constant Int := Int (Name_Entries.Table (N1).Name_Len);\n+         L2 : constant Int := Int (Name_Entries.Table (N2).Name_Len);\n+\n+      begin\n+         if L1 /= L2 then\n+            return False;\n+         end if;\n+\n+         declare\n+            use Name_Chars;\n+            I1 : constant Int := Name_Entries.Table (N1).Name_Chars_Index;\n+            I2 : constant Int := Name_Entries.Table (N2).Name_Chars_Index;\n+\n+         begin\n+            return (Name_Chars.Table (1 + I1 .. I1 + L1) =\n+                    Name_Chars.Table (1 + I2 .. I2 + L2));\n+         end;\n+      end;\n+   end Name_Equals;\n+\n    ------------------\n    -- Reinitialize --\n    ------------------\n@@ -1421,7 +1456,6 @@ package body Namet is\n    -----------------------------\n \n    procedure Store_Encoded_Character (C : Char_Code) is\n-\n       procedure Set_Hex_Chars (C : Char_Code);\n       --  Stores given value, which is in the range 0 .. 255, as two hex\n       --  digits (using lower case a-f) in Name_Buffer, incrementing Name_Len.\n@@ -1639,36 +1673,6 @@ package body Namet is\n       end if;\n    end Write_Name_Decoded;\n \n-   -----------------\n-   -- Name_Equals --\n-   -----------------\n-\n-   function Name_Equals (N1, N2 : Name_Id) return Boolean is\n-   begin\n-      if N1 = N2 then\n-         return True;\n-      end if;\n-\n-      declare\n-         L1 : constant Int := Int (Name_Entries.Table (N1).Name_Len);\n-         L2 : constant Int := Int (Name_Entries.Table (N2).Name_Len);\n-      begin\n-         if L1 /= L2 then\n-            return False;\n-         end if;\n-\n-         declare\n-            use Name_Chars;\n-\n-            I1 : constant Int := Name_Entries.Table (N1).Name_Chars_Index;\n-            I2 : constant Int := Name_Entries.Table (N2).Name_Chars_Index;\n-         begin\n-            return (Name_Chars.Table (1 + I1 .. I1 + L1)\n-                    = Name_Chars.Table (1 + I2 .. I2 + L2));\n-         end;\n-      end;\n-   end Name_Equals;\n-\n --  Package initialization, initialize tables\n \n begin"}, {"sha": "fa30a8ad780a32ad05ca84f78468b6169f796241", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 131, "deletions": 129, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8d6792e3375d86e3ca810f261deef4f3f12048/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=cd8d6792e3375d86e3ca810f261deef4f3f12048", "patch": "@@ -309,52 +309,31 @@ package Namet is\n    -- Subprograms --\n    -----------------\n \n+   procedure Add_Char_To_Name_Buffer (C : Character);\n+   pragma Inline (Add_Char_To_Name_Buffer);\n+   --  Add given character to the end of the string currently stored in the\n+   --  Name_Buffer, incrementing Name_Len.\n+\n+   procedure Add_Nat_To_Name_Buffer (V : Nat);\n+   --  Add decimal representation of given value to the end of the string\n+   --  currently stored in Name_Buffer, incrementing Name_Len as required.\n+\n+   procedure Add_Str_To_Name_Buffer (S : String);\n+   --  Add characters of string S to the end of the string currently stored in\n+   --  the Name_Buffer, incrementing Name_Len by the length of the string.\n+\n    procedure Finalize;\n    --  Called at the end of a use of the Namet package (before a subsequent\n    --  call to Initialize). Currently this routine is only used to generate\n    --  debugging output.\n \n-   procedure Get_Name_String (Id : Name_Id);\n-   --  Get_Name_String is used to retrieve the string associated with an entry\n-   --  in the names table. The resulting string is stored in Name_Buffer and\n-   --  Name_Len is set. It is an error to call Get_Name_String with one of the\n-   --  special name Id values (No_Name or Error_Name).\n-\n-   function Get_Name_String (Id : Name_Id) return String;\n-   --  This functional form returns the result as a string without affecting\n-   --  the contents of either Name_Buffer or Name_Len. The lower bound is 1.\n-\n-   procedure Get_Unqualified_Name_String (Id : Name_Id);\n-   --  Similar to the above except that qualification (as defined in unit\n-   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n-   --  also the suffixes used to indicate package body entities and to\n-   --  distinguish between overloaded entities). Note that names are not\n-   --  qualified until just before the call to gigi, so this routine is only\n-   --  needed by processing that occurs after gigi has been called. This\n-   --  includes all ASIS processing, since ASIS works on the tree written\n-   --  after gigi has been called.\n-\n-   procedure Get_Name_String_And_Append (Id : Name_Id);\n-   --  Like Get_Name_String but the resulting characters are appended to the\n-   --  current contents of the entry stored in Name_Buffer, and Name_Len is\n-   --  incremented to include the added characters.\n-\n    procedure Get_Decoded_Name_String (Id : Name_Id);\n    --  Same calling sequence an interface as Get_Name_String, except that the\n    --  result is decoded, so that upper half characters and wide characters\n    --  appear as originally found in the source program text, operators have\n    --  their source forms (special characters and enclosed in quotes), and\n    --  character literals appear surrounded by apostrophes.\n \n-   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id);\n-   --  Similar to the above except that qualification (as defined in unit\n-   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n-   --  also the suffix used to indicate package body entities). Note that\n-   --  names are not qualified until just before the call to gigi, so this\n-   --  routine is only needed by processing that occurs after gigi has been\n-   --  called. This includes all ASIS processing, since ASIS works on the tree\n-   --  written after gigi has been called.\n-\n    procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id);\n    --  This routine is similar to Decoded_Name, except that the brackets\n    --  notation (Uhh replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"],\n@@ -366,6 +345,34 @@ package Namet is\n    --  by the character set options (e.g. in the binder generation of\n    --  symbols).\n \n+   procedure Get_Last_Two_Chars\n+     (N  : Name_Id;\n+      C1 : out Character;\n+      C2 : out Character);\n+   --  Obtains last two characters of a name. C1 is last but one character and\n+   --  C2 is last character. If name is less than two characters long then both\n+   --  C1 and C2 are set to ASCII.NUL on return.\n+\n+   procedure Get_Name_String (Id : Name_Id);\n+   --  Get_Name_String is used to retrieve the string associated with an entry\n+   --  in the names table. The resulting string is stored in Name_Buffer and\n+   --  Name_Len is set. It is an error to call Get_Name_String with one of the\n+   --  special name Id values (No_Name or Error_Name).\n+\n+   function Get_Name_String (Id : Name_Id) return String;\n+   --  This functional form returns the result as a string without affecting\n+   --  the contents of either Name_Buffer or Name_Len. The lower bound is 1.\n+\n+   procedure Get_Name_String_And_Append (Id : Name_Id);\n+   --  Like Get_Name_String but the resulting characters are appended to the\n+   --  current contents of the entry stored in Name_Buffer, and Name_Len is\n+   --  incremented to include the added characters.\n+\n+   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean;\n+   --  Fetches the Boolean values associated with the given name\n+\n    function Get_Name_Table_Byte (Id : Name_Id) return Byte;\n    pragma Inline (Get_Name_Table_Byte);\n    --  Fetches the Byte value associated with the given name\n@@ -374,14 +381,24 @@ package Namet is\n    pragma Inline (Get_Name_Table_Int);\n    --  Fetches the Int value associated with the given name\n \n-   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean;\n-   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean;\n-   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean;\n-   --  Fetches the Boolean values associated with the given name\n+   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id);\n+   --  Similar to the above except that qualification (as defined in unit\n+   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n+   --  also the suffix used to indicate package body entities). Note that\n+   --  names are not qualified until just before the call to gigi, so this\n+   --  routine is only needed by processing that occurs after gigi has been\n+   --  called. This includes all ASIS processing, since ASIS works on the tree\n+   --  written after gigi has been called.\n \n-   function Is_Operator_Name (Id : Name_Id) return Boolean;\n-   --  Returns True if name given is of the form of an operator (that\n-   --  is, it starts with an upper case O).\n+   procedure Get_Unqualified_Name_String (Id : Name_Id);\n+   --  Similar to the above except that qualification (as defined in unit\n+   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n+   --  also the suffixes used to indicate package body entities and to\n+   --  distinguish between overloaded entities). Note that names are not\n+   --  qualified until just before the call to gigi, so this routine is only\n+   --  needed by processing that occurs after gigi has been called. This\n+   --  includes all ASIS processing, since ASIS works on the tree written\n+   --  after gigi has been called.\n \n    procedure Initialize;\n    --  This is a dummy procedure. It is retained for easy compatibility with\n@@ -391,16 +408,48 @@ package Namet is\n    --  of Initialize being called more than once. See also Reinitialize which\n    --  allows reinitialization of the tables.\n \n-   procedure Lock;\n-   --  Lock name tables before calling back end. We reserve some extra space\n-   --  before locking to avoid unnecessary inefficiencies when we unlock.\n+   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n+   --  Inserts given string in name buffer, starting at Index. Any existing\n+   --  characters at or past this location get moved beyond the inserted string\n+   --  and Name_Len is incremented by the length of the string.\n \n-   procedure Reinitialize;\n-   --  Clears the name tables and removes all existing entries from the table.\n+   function Is_Internal_Name return Boolean;\n+   --  Like the form with an Id argument, except that the name to be tested is\n+   --  passed in Name_Buffer and Name_Len (which are not affected by the call).\n+   --  Name_Buffer (it loads these as for Get_Name_String).\n \n-   procedure Unlock;\n-   --  Unlocks the name table to allow use of the extra space reserved by the\n-   --  call to Lock. See gnat1drv for details of the need for this.\n+   function Is_Internal_Name (Id : Name_Id) return Boolean;\n+   --  Returns True if the name is an internal name (i.e. contains a character\n+   --  for which Is_OK_Internal_Letter is true, or if the name starts or ends\n+   --  with an underscore. This call destroys the value of Name_Len and\n+   --  Name_Buffer (it loads these as for Get_Name_String).\n+   --\n+   --  Note: if the name is qualified (has a double underscore), then only the\n+   --  final entity name is considered, not the qualifying names. Consider for\n+   --  example that the name:\n+   --\n+   --    pkg__B_1__xyz\n+   --\n+   --  is not an internal name, because the B comes from the internal name of\n+   --  a qualifying block, but the xyz means that this was indeed a declared\n+   --  identifier called \"xyz\" within this block and there is nothing internal\n+   --  about that name.\n+\n+   function Is_OK_Internal_Letter (C : Character) return Boolean;\n+   pragma Inline (Is_OK_Internal_Letter);\n+   --  Returns true if C is a suitable character for using as a prefix or a\n+   --  suffix of an internally generated name, i.e. it is an upper case letter\n+   --  other than one of the ones used for encoding source names (currently the\n+   --  set of reserved letters is O, Q, U, W) and also returns False for the\n+   --  letter X, which is reserved for debug output (see Exp_Dbug).\n+\n+   function Is_Operator_Name (Id : Name_Id) return Boolean;\n+   --  Returns True if name given is of the form of an operator (that is, it\n+   --  starts with an upper case O).\n+\n+   function Is_Valid_Name (Id : Name_Id) return Boolean;\n+   --  True if Id is a valid name - points to a valid entry in the Name_Entries\n+   --  table.\n \n    function Length_Of_Name (Id : Name_Id) return Nat;\n    pragma Inline (Length_Of_Name);\n@@ -409,25 +458,14 @@ package Namet is\n    --  calling Get_Name_String and reading Name_Len, except that a call to\n    --  Length_Of_Name does not affect the contents of Name_Len and Name_Buffer.\n \n+   procedure Lock;\n+   --  Lock name tables before calling back end. We reserve some extra space\n+   --  before locking to avoid unnecessary inefficiencies when we unlock.\n+\n    function Name_Chars_Address return System.Address;\n    --  Return starting address of name characters table (used in Back_End call\n    --  to Gigi).\n \n-   function Name_Find return Name_Id;\n-   --  Name_Find is called with a string stored in Name_Buffer whose length is\n-   --  in Name_Len (i.e. the characters of the name are in subscript positions\n-   --  1 to Name_Len in Name_Buffer). It searches the names table to see if the\n-   --  string has already been stored. If so the Id of the existing entry is\n-   --  returned. Otherwise a new entry is created with its Name_Table_Int\n-   --  fields set to zero/false. The contents of Name_Buffer and Name_Len are\n-   --  not modified by this call. Note that it is permissible for Name_Len to\n-   --  be set to zero to lookup the null name string.\n-\n-   function Name_Find_Str (S : String) return Name_Id;\n-   --  Similar to Name_Find, except that the string is provided as an argument.\n-   --  This call destroys the contents of Name_Buffer and Name_Len (by storing\n-   --  the given string there.\n-\n    function Name_Enter return Name_Id;\n    --  Name_Enter has the same calling interface as Name_Find. The difference\n    --  is that it does not search the table for an existing match, and also\n@@ -445,79 +483,47 @@ package Namet is\n    function Name_Entries_Count return Nat;\n    --  Return current number of entries in the names table\n \n-   function Is_OK_Internal_Letter (C : Character) return Boolean;\n-   pragma Inline (Is_OK_Internal_Letter);\n-   --  Returns true if C is a suitable character for using as a prefix or a\n-   --  suffix of an internally generated name, i.e. it is an upper case letter\n-   --  other than one of the ones used for encoding source names (currently\n-   --  the set of reserved letters is O, Q, U, W) and also returns False for\n-   --  the letter X, which is reserved for debug output (see Exp_Dbug).\n+   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean;\n+   --  Return whether N1 and N2 denote the same character sequence\n \n-   function Is_Internal_Name (Id : Name_Id) return Boolean;\n-   --  Returns True if the name is an internal name (i.e. contains a character\n-   --  for which Is_OK_Internal_Letter is true, or if the name starts or ends\n-   --  with an underscore. This call destroys the value of Name_Len and\n-   --  Name_Buffer (it loads these as for Get_Name_String).\n-   --\n-   --  Note: if the name is qualified (has a double underscore), then only the\n-   --  final entity name is considered, not the qualifying names. Consider for\n-   --  example that the name:\n-   --\n-   --    pkg__B_1__xyz\n-   --\n-   --  is not an internal name, because the B comes from the internal name of\n-   --  a qualifying block, but the xyz means that this was indeed a declared\n-   --  identifier called \"xyz\" within this block and there is nothing internal\n-   --  about that name.\n+   function Name_Find return Name_Id;\n+   --  Name_Find is called with a string stored in Name_Buffer whose length is\n+   --  in Name_Len (i.e. the characters of the name are in subscript positions\n+   --  1 to Name_Len in Name_Buffer). It searches the names table to see if the\n+   --  string has already been stored. If so the Id of the existing entry is\n+   --  returned. Otherwise a new entry is created with its Name_Table_Int\n+   --  fields set to zero/false. The contents of Name_Buffer and Name_Len are\n+   --  not modified by this call. Note that it is permissible for Name_Len to\n+   --  be set to zero to lookup the null name string.\n \n-   function Is_Internal_Name return Boolean;\n-   --  Like the form with an Id argument, except that the name to be tested is\n-   --  passed in Name_Buffer and Name_Len (which are not affected by the call).\n-   --  Name_Buffer (it loads these as for Get_Name_String).\n+   function Name_Find_Str (S : String) return Name_Id;\n+   --  Similar to Name_Find, except that the string is provided as an argument.\n+   --  This call destroys the contents of Name_Buffer and Name_Len (by storing\n+   --  the given string there.\n \n-   function Is_Valid_Name (Id : Name_Id) return Boolean;\n-   --  True if Id is a valid name -- points to a valid entry in the\n-   --  Name_Entries table.\n+   procedure Reinitialize;\n+   --  Clears the name tables and removes all existing entries from the table.\n \n    procedure Reset_Name_Table;\n-   --  This procedure is used when there are multiple source files to reset\n-   --  the name table info entries associated with current entries in the\n-   --  names table. There is no harm in keeping the names entries themselves\n-   --  from one compilation to another, but we can't keep the entity info,\n-   --  since this refers to tree nodes, which are destroyed between each main\n-   --  source file.\n-\n-   procedure Add_Char_To_Name_Buffer (C : Character);\n-   pragma Inline (Add_Char_To_Name_Buffer);\n-   --  Add given character to the end of the string currently stored in the\n-   --  Name_Buffer, incrementing Name_Len.\n-\n-   procedure Add_Nat_To_Name_Buffer (V : Nat);\n-   --  Add decimal representation of given value to the end of the string\n-   --  currently stored in Name_Buffer, incrementing Name_Len as required.\n-\n-   procedure Add_Str_To_Name_Buffer (S : String);\n-   --  Add characters of string S to the end of the string currently stored\n-   --  in the Name_Buffer, incrementing Name_Len by the length of the string.\n-\n-   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n-   --  Inserts given string in name buffer, starting at Index. Any existing\n-   --  characters at or past this location get moved beyond the inserted string\n-   --  and Name_Len is incremented by the length of the string.\n+   --  This procedure is used when there are multiple source files to reset the\n+   --  name table info entries associated with current entries in the names\n+   --  table. There is no harm in keeping the names entries themselves from one\n+   --  compilation to another, but we can't keep the entity info, since this\n+   --  refers to tree nodes, which are destroyed between each main source file.\n \n    procedure Set_Character_Literal_Name (C : Char_Code);\n    --  This procedure sets the proper encoded name for the character literal\n    --  for the given character code. On return Name_Buffer and Name_Len are\n    --  set to reflect the stored name.\n \n-   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int);\n-   pragma Inline (Set_Name_Table_Int);\n-   --  Sets the Int value associated with the given name\n-\n    procedure Set_Name_Table_Byte (Id : Name_Id; Val : Byte);\n    pragma Inline (Set_Name_Table_Byte);\n    --  Sets the Byte value associated with the given name\n \n+   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int);\n+   pragma Inline (Set_Name_Table_Int);\n+   --  Sets the Int value associated with the given name\n+\n    procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean);\n    procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean);\n    procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean);\n@@ -543,10 +549,9 @@ package Namet is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n-   procedure Get_Last_Two_Chars (N : Name_Id; C1, C2 : out Character);\n-   --  Obtains last two characters of a name. C1 is last but one character\n-   --  and C2 is last character. If name is less than two characters long,\n-   --  then both C1 and C2 are set to ASCII.NUL on return.\n+   procedure Unlock;\n+   --  Unlocks the name table to allow use of the extra space reserved by the\n+   --  call to Lock. See gnat1drv for details of the need for this.\n \n    procedure Write_Name (Id : Name_Id);\n    --  Write_Name writes the characters of the specified name using the\n@@ -561,9 +566,6 @@ package Namet is\n    --  described for Get_Decoded_Name_String, and the resulting value stored\n    --  in Name_Len and Name_Buffer is the decoded name.\n \n-   function Name_Equals (N1, N2 : Name_Id) return Boolean;\n-   --  Return whether N1 and N2 denote the same character sequence\n-\n    ------------------------------\n    -- File and Unit Name Types --\n    ------------------------------"}]}