{"sha": "d60a05a1c4bfb76cb83594b531df4a3884c30829", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwYTA1YTFjNGJmYjc2Y2I4MzU5NGI1MzFkZjRhMzg4NGMzMDgyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-29T20:12:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-29T20:12:03Z"}, "message": "(alpha_sa_size): Round size to 16-byte boundary.\n\n(add_long_const): Add new arg, TEMP_REG.\n(output_{pro,epi}log): Rework to put save area between outgoing args and\nlocal variables.\n\nFrom-SVN: r7606", "tree": {"sha": "15b7ced0a82e31f01fe95c619a65e99ac5707613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15b7ced0a82e31f01fe95c619a65e99ac5707613"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60a05a1c4bfb76cb83594b531df4a3884c30829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60a05a1c4bfb76cb83594b531df4a3884c30829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60a05a1c4bfb76cb83594b531df4a3884c30829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60a05a1c4bfb76cb83594b531df4a3884c30829/comments", "author": null, "committer": null, "parents": [{"sha": "9ff3516a35fc7223000fd245f62da36045eeb6a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff3516a35fc7223000fd245f62da36045eeb6a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff3516a35fc7223000fd245f62da36045eeb6a9"}], "stats": {"total": 177, "additions": 81, "deletions": 96}, "files": [{"sha": "ffe80cb5b6d55dd6a80b6c494b2264ac3d900755", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 81, "deletions": 96, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60a05a1c4bfb76cb83594b531df4a3884c30829/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60a05a1c4bfb76cb83594b531df4a3884c30829/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=d60a05a1c4bfb76cb83594b531df4a3884c30829", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the DEC Alpha.\n    Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n+   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n \n@@ -58,6 +58,10 @@ static int inside_function = FALSE;\n int alpha_function_needs_gp;\n \n extern char *version_string;\n+\n+/* Declarations of static functions.  */\n+static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n+static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n \n@@ -1127,6 +1131,10 @@ alpha_sa_size ()\n   if (size != 0 && ! regs_ever_live[26])\n     size++;\n \n+  /* Our size must be even (multiple of 16 bytes).  */\n+  if (size & 1)\n+    size ++;\n+\n   return size * 8;\n }\n \n@@ -1162,13 +1170,16 @@ alpha_write_verstamp (file)\n }\n \f\n /* Write code to add constant C to register number IN_REG (possibly 31)\n-   and put the result into OUT_REG.  Write the code to FILE.  */\n+   and put the result into OUT_REG.  Use TEMP_REG as a scratch register;\n+   usually this will be OUT_REG, but should not be if OUT_REG is \n+   STACK_POINTER_REGNUM, since it must be updated in a single instruction.\n+   Write the code to FILE.  */\n \n static void\n-add_long_const (file, c, in_reg, out_reg)\n-     HOST_WIDE_INT c;\n-     int in_reg, out_reg;\n+add_long_const (file, c, in_reg, out_reg, temp_reg)\n      FILE *file;\n+     HOST_WIDE_INT c;\n+     int in_reg, out_reg, temp_reg;\n {\n   HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n   HOST_WIDE_INT tmp1 = c - low;\n@@ -1194,17 +1205,22 @@ add_long_const (file, c, in_reg, out_reg)\n \n   if (low != 0)\n     {\n+      int result_reg = (extra == 0 && high == 0) ? out_reg : temp_reg;\n+\n       if (low >= 0 && low < 255)\n-\tfprintf (file, \"\\taddq $%d,%d,$%d\\n\", in_reg, low, out_reg);\n+\tfprintf (file, \"\\taddq $%d,%d,$%d\\n\", in_reg, low, result_reg);\n       else\n-\tfprintf (file, \"\\tlda $%d,%d($%d)\\n\", out_reg, low, in_reg);\n-      in_reg = out_reg;\n+\tfprintf (file, \"\\tlda $%d,%d($%d)\\n\", result_reg, low, in_reg);\n+\n+      in_reg = result_reg;\n     }\n \n   if (extra)\n     {\n-      fprintf (file, \"\\tldah $%d,%d($%d)\\n\", out_reg, extra, in_reg);\n-      in_reg = out_reg;\n+      int result_reg = (high == 0) ? out_reg : temp_reg;\n+\n+      fprintf (file, \"\\tldah $%d,%d($%d)\\n\", result_reg, extra, in_reg);\n+      in_reg = result_reg;\n     }\n \n   if (high)\n@@ -1218,20 +1234,21 @@ output_prolog (file, size)\n      FILE *file;\n      int size;\n {\n-  HOST_WIDE_INT vars_size = (size + 7) & ~7;\n-  HOST_WIDE_INT frame_size = ((vars_size + current_function_outgoing_args_size\n-\t\t\t       + current_function_pretend_args_size\n-\t\t\t       + alpha_sa_size () + 15) & ~15);\n-  HOST_WIDE_INT reg_offset = vars_size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT out_args_size\n+    = ALPHA_ROUND (current_function_outgoing_args_size);\n+  HOST_WIDE_INT sa_size = alpha_sa_size ();\n+  HOST_WIDE_INT frame_size\n+    = (out_args_size + sa_size\n+       + ALPHA_ROUND (size + current_function_pretend_args_size));\n+  HOST_WIDE_INT reg_offset = out_args_size;\n   HOST_WIDE_INT start_reg_offset = reg_offset;\n   HOST_WIDE_INT actual_start_reg_offset = start_reg_offset;\n   int int_reg_save_area_size = 0;\n   rtx insn;\n-  int reg_offset_base_reg = 30;\n   unsigned reg_mask = 0;\n   int i;\n \n-  /* Ecoff can handle multiple .file directives, put out file and lineno.\n+  /* Ecoff can handle multiple .file directives, so put out file and lineno.\n      We have to do that before the .ent directive as we cannot switch\n      files within procedures with native ecoff because line numbers are\n      linked to procedure descriptors.\n@@ -1244,7 +1261,8 @@ output_prolog (file, size)\n       ASM_OUTPUT_SOURCE_FILENAME (file,\n \t\t\t\t  DECL_SOURCE_FILE (current_function_decl));\n       if (debug_info_level != DINFO_LEVEL_TERSE)\n-        ASM_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl));\n+        ASM_OUTPUT_SOURCE_LINE (file,\n+\t\t\t\tDECL_SOURCE_LINE (current_function_decl));\n     }\n \n   /* The assembly language programmer's guide states that the second argument\n@@ -1300,14 +1318,15 @@ output_prolog (file, size)\n       if (frame_size > 4096)\n \t{\n \t  int probed = 4096;\n-\t  int regnum = 2;\n+\t  int regnum = 1;\n \n \t  fprintf (file, \"\\tldq $%d,-%d($30)\\n\", regnum++, probed);\n \n \t  while (probed + 8192 < frame_size)\n \t    fprintf (file, \"\\tldq $%d,-%d($30)\\n\", regnum++, probed += 8192);\n \n-\t  if (probed + 4096 < frame_size)\n+\t  /* We only have to do this probe if we aren't saving registers.  */\n+\t  if (sa_size == 0 && probed + 4096 < frame_size)\n \t    fprintf (file, \"\\tldq $%d,-%d($30)\\n\", regnum++, probed += 4096);\n \n \t  if (regnum > 9)\n@@ -1322,12 +1341,13 @@ output_prolog (file, size)\n       /* Here we generate code to set R4 to SP + 4096 and set R5 to the\n \t number of 8192 byte blocks to probe.  We then probe each block\n \t in the loop and then set SP to the proper location.  If the\n-\t amount remaining is > 4096, we have to do one more probe.  */\n+\t amount remaining is > 4096, we have to do one more probe if we\n+\t are not saving any registers.  */\n \n       HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;\n       HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;\n \n-      add_long_const (file, blocks, 31, 5);\n+      add_long_const (file, blocks, 31, 5, 5);\n \n       fprintf (file, \"\\tlda $4,4096($30)\\n\");\n \n@@ -1344,31 +1364,21 @@ output_prolog (file, size)\n \n       fprintf (file, \"\\tlda $30,-%d($4)\\n\", leftover);\n \n-      if (leftover > 4096)\n+      if (leftover > 4096 && sa_size == 0)\n \tfprintf (file, \"\\tldq $2,%d($30)\\n\", leftover - 4096);\n     }\n \n   /* Describe our frame.  */\n   fprintf (file, \"\\t.frame $%d,%d,$26,%d\\n\", \n-\t   frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM,\n+\t   (frame_pointer_needed\n+\t    ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM),\n \t   frame_size, current_function_pretend_args_size);\n     \n-  /* If reg_offset is \"close enough\" to 2**15 that one of the offsets would\n-     overflow a store instruction, compute the base of the register save\n-     area into $28.  */\n-  if (reg_offset >= 32768 - alpha_sa_size () && alpha_sa_size () != 0)\n-    {\n-      add_long_const (file, reg_offset, 30, 28);\n-      reg_offset_base_reg = 28;\n-      reg_offset = start_reg_offset = 0;\n-    }\n-\n-  /* Save register 26 if it is used or if any other register needs to\n-     be saved.  */\n-  if (regs_ever_live[26] || alpha_sa_size () != 0)\n+  /* Save register 26 if any other register needs to be saved.  */\n+  if (sa_size != 0)\n     {\n       reg_mask |= 1 << 26;\n-      fprintf (file, \"\\tstq $26,%d($%d)\\n\", reg_offset, reg_offset_base_reg);\n+      fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n       reg_offset += 8;\n       int_reg_save_area_size += 8;\n     }\n@@ -1378,8 +1388,7 @@ output_prolog (file, size)\n     if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i] && i != 26)\n       {\n \treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstq $%d,%d($%d)\\n\",\n-\t\t i, reg_offset, reg_offset_base_reg);\n+\tfprintf (file, \"\\tstq $%d,%d($30)\\n\", i, reg_offset);\n \treg_offset += 8;\n \tint_reg_save_area_size += 8;\n       }\n@@ -1397,8 +1406,7 @@ output_prolog (file, size)\n \t&& regs_ever_live[i + 32])\n       {\n \treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstt $f%d,%d($%d)\\n\",\n-\t\t i, reg_offset, reg_offset_base_reg);\n+\tfprintf (file, \"\\tstt $f%d,%d($30)\\n\", i, reg_offset);\n \treg_offset += 8;\n       }\n \n@@ -1424,13 +1432,16 @@ output_epilog (file, size)\n      int size;\n {\n   rtx insn = get_last_insn ();\n-  HOST_WIDE_INT vars_size = (size + 7) & ~7;\n-  HOST_WIDE_INT frame_size = ((vars_size + current_function_outgoing_args_size\n-\t\t\t       + current_function_pretend_args_size\n-\t\t\t       + alpha_sa_size () + 15) & ~15);\n-  HOST_WIDE_INT reg_offset = vars_size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT out_args_size\n+    = ALPHA_ROUND (current_function_outgoing_args_size);\n+  HOST_WIDE_INT sa_size = alpha_sa_size ();\n+  HOST_WIDE_INT frame_size\n+    = (out_args_size + sa_size\n+       + ALPHA_ROUND (size + current_function_pretend_args_size));\n+  HOST_WIDE_INT reg_offset = out_args_size;\n   HOST_WIDE_INT frame_size_from_reg_save = frame_size - reg_offset;\n-  int reg_offset_base_reg = 30;\n+  int restore_fp\n+    = frame_pointer_needed && regs_ever_live[HARD_FRAME_POINTER_REGNUM];\n   int i;\n \n   /* If the last insn was a BARRIER, we don't have to write anything except\n@@ -1445,21 +1456,11 @@ output_epilog (file, size)\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n \n-      /* If the register save area is out of range, put its address into\n-\t $28.  */\n-      if (reg_offset >= 32768 - alpha_sa_size () && alpha_sa_size () != 0)\n-\t{\n-\t  add_long_const (file, reg_offset, 30, 28);\n-\t  reg_offset_base_reg = 28;\n-\t  reg_offset = 0;\n-\t}\n-\n       /* Restore all the registers, starting with the return address\n \t register.  */\n-      if (regs_ever_live[26] || alpha_sa_size () != 0)\n+      if (sa_size != 0)\n \t{\n-\t  fprintf (file, \"\\tldq $26,%d($%d)\\n\",\n-\t\t   reg_offset, reg_offset_base_reg);\n+\t  fprintf (file, \"\\tldq $26,%d($30)\\n\", reg_offset);\n \t  reg_offset += 8;\n \t}\n \n@@ -1471,59 +1472,43 @@ output_epilog (file, size)\n \tif (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i]\n \t    && i != 26)\n \t  {\n-\t    if (i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+\t    if (i == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n \t      fp_offset = reg_offset;\n \t    else\n-\t      fprintf (file, \"\\tldq $%d,%d($%d)\\n\",\n-\t\t       i, reg_offset, reg_offset_base_reg);\n+\t      fprintf (file, \"\\tldq $%d,%d($30)\\n\", i, reg_offset);\n \t    reg_offset += 8;\n \t  }\n \n       for (i = 0; i < 32; i++)\n \tif (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n \t    && regs_ever_live[i + 32])\n \t  {\n-\t    fprintf (file, \"\\tldt $f%d,%d($%d)\\n\",\n-\t\t     i, reg_offset, reg_offset_base_reg);\n+\t    fprintf (file, \"\\tldt $f%d,%d($30)\\n\", i, reg_offset);\n \t    reg_offset += 8;\n \t  }\n \n-      /* If the stack size is large, compute the size of the stack into\n-\t a register because the old FP restore, stack pointer adjust,\n-\t and return are required to be consecutive instructions.  \n-\t However, if the new stack pointer can be computed by adding the\n-\t a constant to the start of the register save area, we can do\n-\t it that way.  */\n-      if (frame_size > 32767\n-\t  && ! (reg_offset_base_reg != 30\n-\t\t&& frame_size_from_reg_save < 32768))\n-\tadd_long_const (file, frame_size, 31, 1);\n+      /* If the stack size is large and we have a frame pointer, compute the\n+\t size of the stack into a register because the old FP restore, stack\n+\t pointer adjust, and return are required to be consecutive\n+\t instructions.   */\n+      if (frame_size > 32767 && restore_fp)\n+\tadd_long_const (file, frame_size, 31, 1, 1);\n \n       /* If we needed a frame pointer and we have to restore it, do it\n \t now.  This must be done in one instruction immediately\n \t before the SP update.  */\n-      if (frame_pointer_needed && regs_ever_live[FRAME_POINTER_REGNUM])\n-\tfprintf (file, \"\\tldq $15,%d($%d)\\n\", fp_offset, reg_offset_base_reg);\n+      if (restore_fp)\n+\tfprintf (file, \"\\tldq $15,%d($30)\\n\", fp_offset);\n \n-      /* Now update the stack pointer, if needed.  This must be done in\n-\t one, stylized, instruction.  */\n-      if (frame_size > 32768)\n-\t{\n-\t  if (reg_offset_base_reg != 30\n-\t      && frame_size_from_reg_save < 32768)\n-\t    {\n-\t      if (frame_size_from_reg_save < 255)\n-\t\tfprintf (file, \"\\taddq $%d,%d,$30\\n\",\n-\t\t\t reg_offset_base_reg, frame_size_from_reg_save);\n-\t      else\n-\t\tfprintf (file, \"\\tlda %30,%d($%d)\\n\",\n-\t\t\t frame_size_from_reg_save, reg_offset_base_reg);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\taddq $1,$30,$30\\n\");\n-\t}\n-      else if (frame_size != 0)\n-\tfprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n+      /* Now update the stack pointer, if needed.  Only one instruction must\n+\t modify the stack pointer.  It must be the last instruction in the\n+\t sequence and must be an ADDQ or LDA instruction.  If the frame\n+\t pointer was loaded above, we may only put one instruction here.  */\n+\n+      if (frame_size > 32768 && restore_fp)\n+\tfprintf  (file, \"\\taddq $1,$30,$30\\n\");\n+      else\n+\tadd_long_const (file, frame_size, 30, 30, 1);\n \n       /* Finally return to the caller.  */\n       fprintf (file, \"\\tret $31,($26),1\\n\");"}]}