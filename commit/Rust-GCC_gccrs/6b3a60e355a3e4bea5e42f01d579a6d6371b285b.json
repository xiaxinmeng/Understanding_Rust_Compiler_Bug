{"sha": "6b3a60e355a3e4bea5e42f01d579a6d6371b285b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzYTYwZTM1NWEzZTRiZWE1ZTQyZjAxZDU3OWE2ZDYzNzFiMjg1Yg==", "commit": {"author": {"name": "Roland McGrath", "email": "roland@gcc.gnu.org", "date": "1992-02-17T18:46:57Z"}, "committer": {"name": "Roland McGrath", "email": "roland@gcc.gnu.org", "date": "1992-02-17T18:46:57Z"}, "message": "entered into RCS\n\nFrom-SVN: r335", "tree": {"sha": "ce01982f8d6e7a11e773116f0d3b1ca659cb2483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce01982f8d6e7a11e773116f0d3b1ca659cb2483"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b3a60e355a3e4bea5e42f01d579a6d6371b285b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3a60e355a3e4bea5e42f01d579a6d6371b285b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3a60e355a3e4bea5e42f01d579a6d6371b285b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3a60e355a3e4bea5e42f01d579a6d6371b285b/comments", "author": null, "committer": null, "parents": [{"sha": "fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff9e713b5d8d6a7bd89abe715fb56cc363116e7"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "bc532e641a8d383cba34c49b98949861fb3026e5", "filename": "gcc/PROBLEMS", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3a60e355a3e4bea5e42f01d579a6d6371b285b/gcc%2FPROBLEMS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3a60e355a3e4bea5e42f01d579a6d6371b285b/gcc%2FPROBLEMS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROBLEMS?ref=6b3a60e355a3e4bea5e42f01d579a6d6371b285b", "patch": "@@ -0,0 +1,117 @@\n+3. When find_reloads is used to count number of spills needed\n+it does not take into account the fact that a reload may\n+turn out to be a dummy.\n+\n+I'm not sure this really happens any more.  Doesn't it find\n+all the dummies on both passes?\n+\n+10.     movl a3@,a0\n+\tmovl a3@(16),a1\n+\tclrb a0@(a1:l)\n+is generated and may be worse than\n+\tmovl a3@,a0\n+\taddl a3@(16),a0\n+\tclrb a0@\n+If ordering of operands is improved, many more\n+such cases will be generated from typical array accesses.\n+\n+38. Hack expand_mult so that if there is no same-modes multiply\n+it will use a widening multiply and then truncate rather than\n+calling the library.\n+\n+39. Hack expanding of division to notice cases for\n+long -> short division.\n+\n+40. Represent divide insns as (DIV:SI ...) followed by\n+a separate lowpart extract.  Represent remainder insns as DIV:SI\n+followed by a separate highpart extract.  Then cse can work on\n+the DIV:SI part.  Problem is, this may not be desirable on machines\n+where computing the quotient alone does not necessarily give\n+a remainder--such as the 68020 for long operands.\n+\n+52. Reloading can look at how reload_contents got set up.\n+If it was copied from a register, just reload from that register.\n+Otherwise, perhaps can change the previous insn to move the\n+data via the reload reg, thus avoiding one memory ref.\n+\n+63. Potential problem in cc_status.value2, if it ever activates itself\n+after a two-address subtraction (which currently cannot happen).\n+It is supposed to compare the current value of the destination\n+but eliminating it would use the results of the subtraction, equivalent\n+to comparing the previous value of the destination.\n+\n+65. Should loops that neither start nor end with a break\n+be rearranged to end with the last break?\n+\n+69. Define the floating point converting arithmetic instructions\n+for the 68881.\n+\n+74. Combine loop opt with cse opt in one pass.  Do cse on each loop,\n+then loop opt on that loop, and go from innermost loops outward.\n+Make loop invariants available for cse at end of loop.\n+\n+85. pea can force a value to be reloaded into an areg\n+which can make it worse than separate adding and pushing.\n+This can only happen for adding something within addql range\n+and it only loses if the qty becomes dead at that point\n+so it can be added to with no copying.\n+\n+93. If a pseudo doesn't get a hard reg everywhere,\n+can it get one during a loop?\n+\n+96. Can do SImode bitfield insns without reloading, but must\n+alter the operands in special ways.\n+\n+99. final could check loop-entry branches to see if they\n+screw up deletion of a test instruction.  If they do,\n+can put another test instruction before the branch and\n+make it conditional and redirect it.\n+\n+106. Aliasing may be impossible if data types of refs differ\n+and data type of containing objects also differ.\n+(But check this wrt unions.)\n+\n+108. Can speed up flow analysis by making a table saying which\n+register is set and which registers are used by each instruction that\n+only sets one register and only uses two.  This way avoid the tree\n+walk for such instructions (most instructions).\n+\n+109. It is desirable to avoid converting INDEX to SImode if a\n+narrower mode suffices, as HImode does on the 68000.\n+How can this be done?\n+\n+110. Possible special combination pattern:\n+If the two operands to a comparison die there and both come from insns\n+that are identical except for replacing one operand with the other,\n+throw away those insns.  Ok if insns being discarded are known 1 to 1.\n+An andl #1 after a seq is 1 to 1, but how should compiler know that?\n+\n+112. Can convert float to unsigned int by subtracting a constant,\n+converting to signed int, and changing the sign bit.\n+\n+117. Any number of slow zero-extensions in one loop, that have\n+their clr insns moved out of the loop, can share one register\n+if their original life spans are disjoint.\n+But it may be hard to be sure of this since\n+the life span data that regscan produces may be hard to interpret\n+validly or may be incorrect after cse.\n+\n+118. In cse, when a bfext insn refers to a register, if the field\n+corresponds to a halfword or a byte and the register is equivalent\n+to a memory location, it would be possible to detect this and\n+replace it with a simple memory reference.\n+\n+121. Insns that store two values cannot be moved out of loops.\n+The code in scan_loop doesn't even try to deal with them.\n+\n+122. When insn-output.c turns a bit-test into a sign-test,\n+it should see whether the cc is already set up with that sign.\n+\n+123. When a conditional expression is used as a function arg, it would\n+be faster (and in some cases shorter) to push each alternative rather\n+than compute in a register and push that.  This would require\n+being able to specify \"push this\" as a target for expand_expr.\n+\n+124. On the 386, bad code results from foo (bar ()) when bar\n+returns a double, because the pseudo used fails to get preferenced\n+into an fp reg because of the distinction between regs 8 and 9."}]}