{"sha": "aa47fcfa218c053e0cb704e38cdee74242d66edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0N2ZjZmEyMThjMDUzZTBjYjcwNGUzOGNkZWU3NDI0MmQ2NmVkYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-02-16T06:14:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-02-16T06:14:13Z"}, "message": "gcse.c (blocks_with_calls): New bitmap.\n\n\n\t* gcse.c (blocks_with_calls): New bitmap.\n\t(alloc_gcse_mem): Allocate it.\n\t(free_gcse_mem): Free it.\n\t(clear_modifY_mem_tables): Clear it.\n\t(record_last_mem_set_info): Set the proper bit in BLOCK_WITH_CALLS\n\twhen we encounter CALL_INSNs.\n\t(compute_transp, case MEM): Handle blocks with calls separate\n\tfrom blocks without calls.  Use bitmap iterators rather than\n\tFOR_EACH_BB.\n\nFrom-SVN: r95097", "tree": {"sha": "8d58f56b7c657f91ef4dc6c6fcf30c5c9c3d8e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d58f56b7c657f91ef4dc6c6fcf30c5c9c3d8e2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa47fcfa218c053e0cb704e38cdee74242d66edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa47fcfa218c053e0cb704e38cdee74242d66edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa47fcfa218c053e0cb704e38cdee74242d66edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa47fcfa218c053e0cb704e38cdee74242d66edc/comments", "author": null, "committer": null, "parents": [{"sha": "489ce9e7ab25a049ae546f36aada3f5e5a3646d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/489ce9e7ab25a049ae546f36aada3f5e5a3646d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/489ce9e7ab25a049ae546f36aada3f5e5a3646d8"}], "stats": {"total": 92, "additions": 61, "deletions": 31}, "files": [{"sha": "fbbe2b5187878aa9ca3ebd07952deadb6d5cafaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa47fcfa218c053e0cb704e38cdee74242d66edc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa47fcfa218c053e0cb704e38cdee74242d66edc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa47fcfa218c053e0cb704e38cdee74242d66edc", "patch": "@@ -1,3 +1,15 @@\n+2005-02-15  Jeff Law  <law@redhat.com>\n+\n+\t* gcse.c (blocks_with_calls): New bitmap.\n+\t(alloc_gcse_mem): Allocate it.\n+\t(free_gcse_mem): Free it.\n+\t(clear_modifY_mem_tables): Clear it.\n+\t(record_last_mem_set_info): Set the proper bit in BLOCK_WITH_CALLS\n+\twhen we encounter CALL_INSNs.\n+\t(compute_transp, case MEM): Handle blocks with calls separate\n+\tfrom blocks without calls.  Use bitmap iterators rather than\n+\tFOR_EACH_BB.\n+\n 2005-02-15  Peter O'Gorman  <peter@pogma.com>\n \n \tPR bootstrap/18810"}, {"sha": "cb26c0b3b921213860940f4d9d06fab046367e57", "filename": "gcc/gcse.c", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa47fcfa218c053e0cb704e38cdee74242d66edc/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa47fcfa218c053e0cb704e38cdee74242d66edc/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=aa47fcfa218c053e0cb704e38cdee74242d66edc", "patch": "@@ -501,6 +501,10 @@ static bitmap modify_mem_list_set;\n /* This array parallels modify_mem_list, but is kept canonicalized.  */\n static rtx * canon_modify_mem_list;\n \n+/* Bitmap indexed by block numbers to record which blocks contain\n+   function calls.  */\n+static bitmap blocks_with_calls;\n+\n /* Various variables for statistics gathering.  */\n \n /* Memory used in a pass.\n@@ -967,6 +971,7 @@ alloc_gcse_mem (rtx f)\n   modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n   canon_modify_mem_list = gcalloc (last_basic_block, sizeof (rtx));\n   modify_mem_list_set = BITMAP_XMALLOC ();\n+  blocks_with_calls = BITMAP_XMALLOC ();\n }\n \n /* Free memory allocated by alloc_gcse_mem.  */\n@@ -982,6 +987,7 @@ free_gcse_mem (void)\n   sbitmap_vector_free (reg_set_in_block);\n   free_modify_mem_tables ();\n   BITMAP_XFREE (modify_mem_list_set);\n+  BITMAP_XFREE (blocks_with_calls);\n }\n \f\n /* Compute the local properties of each recorded expression.\n@@ -1971,6 +1977,7 @@ record_last_mem_set_info (rtx insn)\n \t need to insert a pair of items, as canon_list_insert does.  */\n       canon_modify_mem_list[bb] =\n \talloc_INSN_LIST (insn, canon_modify_mem_list[bb]);\n+      bitmap_set_bit (blocks_with_calls, bb);\n     }\n   else\n     note_stores (PATTERN (insn), canon_list_insert, (void*) insn);\n@@ -2197,6 +2204,7 @@ clear_modify_mem_tables (void)\n       free_insn_expr_list_list (canon_modify_mem_list + i);\n     }\n   bitmap_clear (modify_mem_list_set);\n+  bitmap_clear (blocks_with_calls);\n }\n \n /* Release memory used by modify_mem_list_set.  */\n@@ -2460,41 +2468,51 @@ compute_transp (rtx x, int indx, sbitmap *bmap, int set_p)\n       return;\n \n     case MEM:\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  rtx list_entry = canon_modify_mem_list[bb->index];\n+      {\n+\tbitmap_iterator bi;\n+\tunsigned bb_index;\n \n-\t  while (list_entry)\n-\t    {\n-\t      rtx dest, dest_addr;\n+\t/* First handle all the blocks with calls.  We don't need to\n+\t   do any list walking for them.  */\n+\tEXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n+\t  {\n+\t    if (set_p)\n+\t      SET_BIT (bmap[bb_index], indx);\n+\t    else\n+\t      RESET_BIT (bmap[bb_index], indx);\n+\t  }\n \n-\t      if (CALL_P (XEXP (list_entry, 0)))\n-\t\t{\n-\t\t  if (set_p)\n-\t\t    SET_BIT (bmap[bb->index], indx);\n-\t\t  else\n-\t\t    RESET_BIT (bmap[bb->index], indx);\n-\t\t  break;\n-\t\t}\n-\t      /* LIST_ENTRY must be an INSN of some kind that sets memory.\n-\t\t Examine each hunk of memory that is modified.  */\n+\t/* Now iterate over the blocks which have memory modifications\n+\t   but which do not have any calls.  */\n+\tEXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set, blocks_with_calls,\n+\t\t\t\t\t0, bb_index, bi)\n+\t  {\n+\t    rtx list_entry = canon_modify_mem_list[bb_index];\n \n-\t      dest = XEXP (list_entry, 0);\n-\t      list_entry = XEXP (list_entry, 1);\n-\t      dest_addr = XEXP (list_entry, 0);\n+\t    while (list_entry)\n+\t      {\n+\t\trtx dest, dest_addr;\n \n-\t      if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n-\t\t\t\t\t x, rtx_addr_varies_p))\n-\t\t{\n-\t\t  if (set_p)\n-\t\t    SET_BIT (bmap[bb->index], indx);\n-\t\t  else\n-\t\t    RESET_BIT (bmap[bb->index], indx);\n-\t\t  break;\n-\t\t}\n-\t      list_entry = XEXP (list_entry, 1);\n-\t    }\n-\t}\n+\t\t/* LIST_ENTRY must be an INSN of some kind that sets memory.\n+\t\t   Examine each hunk of memory that is modified.  */\n+\n+\t\tdest = XEXP (list_entry, 0);\n+\t\tlist_entry = XEXP (list_entry, 1);\n+\t\tdest_addr = XEXP (list_entry, 0);\n+\n+\t\tif (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n+\t\t\t\t\t   x, rtx_addr_varies_p))\n+\t\t  {\n+\t\t    if (set_p)\n+\t\t      SET_BIT (bmap[bb_index], indx);\n+\t\t    else\n+\t\t      RESET_BIT (bmap[bb_index], indx);\n+\t\t    break;\n+\t\t  }\n+\t\tlist_entry = XEXP (list_entry, 1);\n+\t      }\n+\t  }\n+      }\n \n       x = XEXP (x, 0);\n       goto repeat;"}]}