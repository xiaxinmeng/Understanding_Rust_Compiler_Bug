{"sha": "cefce34c6701df7ddd07ece4874465f9049b812c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VmY2UzNGM2NzAxZGY3ZGRkMDdlY2U0ODc0NDY1ZjkwNDliODEyYw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2010-08-10T14:29:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-08-10T14:29:36Z"}, "message": "sem_aggr.adb (Resolve_Extension_Aggregate): Warn on the use of C++ constructors that leave the object partially initialized.\n\n2010-08-10  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Extension_Aggregate): Warn on the use of C++\n\tconstructors that leave the object partially initialized.\n\t* exp_atag.ads, exp_atags.adb (Build_Inherit_CPP_Prims): New subprogram\n\tthat copies from parent of Typ the dispatch table slots of inherited\n\tC++ primitives. It handles primary and secondary dispatch tables.\n\t* einfo.adb (Related_Type): Moved from Node26 to Node27. Required to\n\tuse this attribute with E_Variable entities.\n\t(Set_Is_Tag): Relax assertion to allow its use with variables that\n\tstore tags.\n\t(Set_Related_Type): Relax assertion to allow its use with variables\n\tthat store the tag of a C++ class.\n\t(Write_26_Field_Name): Remove Related_Type.\n\t(Write_27_Field_Name): Add Related_Type.\n\t* einfo.ads (Related_Type): Moved from Node26 to Node27. Available also\n\twith E_Variable entities.\n\t* sem_prag.adb (CPP_Constructor): Warn on duplicated occurrence of this\n\tpragma.\n\t* sem_util.adb (Search_Tag): Add missing support for CPP types.\n\t(Enclosing_CPP_Parent): New subprogram.\n\t(Has_Suffix): New subprogram.\n\t* sem_util.ads (Enclosing_CPP_Parent): New subprogram that returns the\n\tclosest ancestor of a type that is a C++ type.\n\t(Has_Suffix): New subprogram. Used in assertions to check the suffix of\n\tinternal entities.\n\t* sem_attr.adb (Analyze_Access_Attribute): Check wrong use of current\n\tinstance in derivations of C++ types.\n\t* exp_tss.adb (CPP_Init_Proc): New subprogram.\n\t(Is_CPP_Init_Proc): New subprogram.\n\t(Set_TSS): Handle new C++ init routines.\n\t* exp_tss.ads (TSS_CPP_Init): New TSS name. For initialization of C++\n\tdispatch tables.\n\t(CPP_Init_Proc): New subprogram.\n\t(Is_CPP_Init_Proc): New subprogram.\n\t* exp_disp.adb (CPP_Num_Prims): New subprogram.\n\t(Has_CPP_Constructors): New subprogram.\n\t(Make_Secondary_DT, Make_DT): For derivations of CPP types, do not\n\tinitialize slots located in the C++ part of the dispatch table.\n\t(Make_Tags): For CPP types declare variables used by the IP routine to\n\tstore the C++ tag values after the first invocation of the C++\n\tconstructor.\n\t(Build_CPP_Init_DT): New subprogram.\n\t(Set_CPP_Constructors): New implementation that builds an IP for each\n\tCPP constructor. These IP are wrappers of the C++ constructors that,\n\tafter the first invocation of the constructor, read the C++ tags from\n\tthe object and save them locally. These copies of the C++ tags are used\n\tby the IC routines to initialize tables of Ada derivations of CPP types.\n\t(Write_DT): Indicate what primitives are imported from C++\n\t* exp_disp.ads (CPP_Num_Prims): New subprogram.\n\t(Has_CPP_Constructors): New subprogram.\n\t* exp_aggr.adb (Build_Record_Aggr_Code): For derivations of C++ types\n\tinvoke the IC routine to inherit the slots of the parents.\n\t* sem_ch13.adb (Analyze_Freeze_Entity): Add new warnings on CPP types.\n\t* exp_ch3.adb (Is_Variable_Size_Array): New subprogram.\n\t(Is_Variable_Size_Record): Factorize code calling\n\tIs_Variable_Size_Array.\n\t(Build_CPP_Init_Procedure): New subprogram that builds the tree\n\tcorresponding to the procedure that initializes the C++ part of the\n\tdispatch table of an Ada tagged type that is a derivation of a CPP type.\n\t(Build_Init_Procedure): Adding documentation plus code reorganization to\n\tleave more clear the construction of the IP with C++ types.\n\t(Expand_Freeze_Record_Type): Delay call to Set_CPP_Constructors because\n\tit cannot be called after Make_Tags has been invoked.\n\t(Inherit_CPP_Tag): Removed.\n\t(Init_Secondary_Tags): For derivations of CPP types, warn on tags\n\tlocated at variable offset.\n\t* freeze.ads: Minor reformating.\n\t* sem_ch8.adb (Write_Scopes): Add pragma export. Required to have it\n\tavailable in gdb.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\nFrom-SVN: r163065", "tree": {"sha": "c31c3b8d10a4d714d2f074e0150cd4419e5b882a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c31c3b8d10a4d714d2f074e0150cd4419e5b882a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cefce34c6701df7ddd07ece4874465f9049b812c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cefce34c6701df7ddd07ece4874465f9049b812c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cefce34c6701df7ddd07ece4874465f9049b812c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cefce34c6701df7ddd07ece4874465f9049b812c/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "774038e62efa7caa5b00101fffcbe1df01686fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774038e62efa7caa5b00101fffcbe1df01686fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774038e62efa7caa5b00101fffcbe1df01686fd9"}], "stats": {"total": 2322, "additions": 1764, "deletions": 558}, "files": [{"sha": "56fdcb682e32b0d67debecdf1e98009810e758b5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -1,3 +1,75 @@\n+2010-08-10  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Extension_Aggregate): Warn on the use of C++\n+\tconstructors that leave the object partially initialized.\n+\t* exp_atag.ads, exp_atags.adb (Build_Inherit_CPP_Prims): New subprogram\n+\tthat copies from parent of Typ the dispatch table slots of inherited\n+\tC++ primitives. It handles primary and secondary dispatch tables.\n+\t* einfo.adb (Related_Type): Moved from Node26 to Node27. Required to\n+\tuse this attribute with E_Variable entities.\n+\t(Set_Is_Tag): Relax assertion to allow its use with variables that\n+\tstore tags.\n+\t(Set_Related_Type): Relax assertion to allow its use with variables\n+\tthat store the tag of a C++ class.\n+\t(Write_26_Field_Name): Remove Related_Type.\n+\t(Write_27_Field_Name): Add Related_Type.\n+\t* einfo.ads (Related_Type): Moved from Node26 to Node27. Available also\n+\twith E_Variable entities.\n+\t* sem_prag.adb (CPP_Constructor): Warn on duplicated occurrence of this\n+\tpragma.\n+\t* sem_util.adb (Search_Tag): Add missing support for CPP types.\n+\t(Enclosing_CPP_Parent): New subprogram.\n+\t(Has_Suffix): New subprogram.\n+\t* sem_util.ads (Enclosing_CPP_Parent): New subprogram that returns the\n+\tclosest ancestor of a type that is a C++ type.\n+\t(Has_Suffix): New subprogram. Used in assertions to check the suffix of\n+\tinternal entities.\n+\t* sem_attr.adb (Analyze_Access_Attribute): Check wrong use of current\n+\tinstance in derivations of C++ types.\n+\t* exp_tss.adb (CPP_Init_Proc): New subprogram.\n+\t(Is_CPP_Init_Proc): New subprogram.\n+\t(Set_TSS): Handle new C++ init routines.\n+\t* exp_tss.ads (TSS_CPP_Init): New TSS name. For initialization of C++\n+\tdispatch tables.\n+\t(CPP_Init_Proc): New subprogram.\n+\t(Is_CPP_Init_Proc): New subprogram.\n+\t* exp_disp.adb (CPP_Num_Prims): New subprogram.\n+\t(Has_CPP_Constructors): New subprogram.\n+\t(Make_Secondary_DT, Make_DT): For derivations of CPP types, do not\n+\tinitialize slots located in the C++ part of the dispatch table.\n+\t(Make_Tags): For CPP types declare variables used by the IP routine to\n+\tstore the C++ tag values after the first invocation of the C++\n+\tconstructor.\n+\t(Build_CPP_Init_DT): New subprogram.\n+\t(Set_CPP_Constructors): New implementation that builds an IP for each\n+\tCPP constructor. These IP are wrappers of the C++ constructors that,\n+\tafter the first invocation of the constructor, read the C++ tags from\n+\tthe object and save them locally. These copies of the C++ tags are used\n+\tby the IC routines to initialize tables of Ada derivations of CPP types.\n+\t(Write_DT): Indicate what primitives are imported from C++\n+\t* exp_disp.ads (CPP_Num_Prims): New subprogram.\n+\t(Has_CPP_Constructors): New subprogram.\n+\t* exp_aggr.adb (Build_Record_Aggr_Code): For derivations of C++ types\n+\tinvoke the IC routine to inherit the slots of the parents.\n+\t* sem_ch13.adb (Analyze_Freeze_Entity): Add new warnings on CPP types.\n+\t* exp_ch3.adb (Is_Variable_Size_Array): New subprogram.\n+\t(Is_Variable_Size_Record): Factorize code calling\n+\tIs_Variable_Size_Array.\n+\t(Build_CPP_Init_Procedure): New subprogram that builds the tree\n+\tcorresponding to the procedure that initializes the C++ part of the\n+\tdispatch table of an Ada tagged type that is a derivation of a CPP type.\n+\t(Build_Init_Procedure): Adding documentation plus code reorganization to\n+\tleave more clear the construction of the IP with C++ types.\n+\t(Expand_Freeze_Record_Type): Delay call to Set_CPP_Constructors because\n+\tit cannot be called after Make_Tags has been invoked.\n+\t(Inherit_CPP_Tag): Removed.\n+\t(Init_Secondary_Tags): For derivations of CPP types, warn on tags\n+\tlocated at variable offset.\n+\t* freeze.ads: Minor reformating.\n+\t* sem_ch8.adb (Write_Scopes): Add pragma export. Required to have it\n+\tavailable in gdb.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n 2010-08-10  Robert Dewar  <dewar@adacore.com>\n \n \t* a-chahan.ads: Add comments on handling of obsolescent entries."}, {"sha": "4a9e31730754601d856259ec219cfd2ea9ac599a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -219,11 +219,11 @@ package body Einfo is\n    --    Last_Assignment                 Node26\n    --    Overridden_Operation            Node26\n    --    Package_Instantiation           Node26\n-   --    Related_Type                    Node26\n    --    Relative_Deadline_Variable      Node26\n    --    Static_Initialization           Node26\n \n    --    Current_Use_Clause              Node27\n+   --    Related_Type                    Node27\n    --    Wrapped_Entity                  Node27\n \n    --    Extra_Formals                   Node28\n@@ -1481,7 +1481,6 @@ package body Einfo is\n \n    function Has_Thunks (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Constant);\n       return Flag228 (Id);\n    end Has_Thunks;\n \n@@ -2442,8 +2441,8 @@ package body Einfo is\n \n    function Related_Type (Id : E) return E is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Component, E_Constant));\n-      return Node26 (Id);\n+      pragma Assert (Ekind_In (Id, E_Component, E_Constant, E_Variable));\n+      return Node27 (Id);\n    end Related_Type;\n \n    function Relative_Deadline_Variable (Id : E) return E is\n@@ -3884,8 +3883,7 @@ package body Einfo is\n \n    procedure Set_Has_Thunks (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Tag (Id)\n-        and then Ekind (Id) = E_Constant);\n+      pragma Assert (Is_Tag (Id));\n       Set_Flag228 (Id, V);\n    end Set_Has_Thunks;\n \n@@ -4452,7 +4450,7 @@ package body Einfo is\n \n    procedure Set_Is_Tag (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Component, E_Constant));\n+      pragma Assert (Ekind_In (Id, E_Component, E_Constant, E_Variable));\n       Set_Flag78 (Id, V);\n    end Set_Is_Tag;\n \n@@ -4883,8 +4881,8 @@ package body Einfo is\n \n    procedure Set_Related_Type (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Component, E_Constant));\n-      Set_Node26 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Component, E_Constant, E_Variable));\n+      Set_Node27 (Id, V);\n    end Set_Related_Type;\n \n    procedure Set_Relative_Deadline_Variable (Id : E; V : E) is\n@@ -8011,10 +8009,6 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Component                                  |\n-              E_Constant                                   =>\n-            Write_Str (\"Related_Type\");\n-\n          when E_Generic_Package                            |\n               E_Package                                    =>\n             Write_Str (\"Package_Instantiation\");\n@@ -8052,6 +8046,11 @@ package body Einfo is\n    procedure Write_Field27_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Component                                  |\n+              E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Related_Type\");\n+\n          when E_Procedure                                  =>\n             Write_Str (\"Wrapped_Entity\");\n "}, {"sha": "de742cd46d468b7ea467994d29fcc4f5187bffb5", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -3306,10 +3306,10 @@ package Einfo is\n --       wrapper package, but for debugging purposes its external symbol\n --       must correspond to the name and scope of the related instance.\n \n---    Related_Type (Node26)\n---       Present in components and constants associated with dispatch tables.\n---       Set to point to the entity of the associated tagged type or interface\n---       type.\n+--    Related_Type (Node27)\n+--       Present in components, constants and variables. Set when there is an\n+--       associated dispatch table to point to entities containing primary or\n+--       secondary tags. Not set in the _tag component of record types.\n \n --    Relative_Deadline_Variable (Node26) [implementation base type only]\n --       Present in task type entities. This flag is set if a valid and\n@@ -4827,7 +4827,7 @@ package Einfo is\n    --    Interface_Name                      (Node21)   (JGNAT usage only)\n    --    Original_Record_Component           (Node22)\n    --    DT_Offset_To_Top_Func               (Node25)\n-   --    Related_Type                        (Node26)\n+   --    Related_Type                        (Node27)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Per_Object_Constraint           (Flag154)\n    --    Is_Atomic                           (Flag85)\n@@ -4850,7 +4850,7 @@ package Einfo is\n    --    Size_Check_Code                     (Node19)   (constants only)\n    --    Prival_Link                         (Node20)   (privals only)\n    --    Interface_Name                      (Node21)\n-   --    Related_Type                        (Node26)   (constants only)\n+   --    Related_Type                        (Node27)   (constants only)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -5479,6 +5479,7 @@ package Einfo is\n    --    Related_Expression                  (Node24)\n    --    Debug_Renaming_Link                 (Node25)\n    --    Last_Assignment                     (Node26)\n+   --    Related_Type                        (Node27)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)"}, {"sha": "e2bd125399f994e58d9bc928b9fd75394375ca16", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -34,6 +34,7 @@ with Exp_Util; use Exp_Util;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n@@ -2840,12 +2841,61 @@ package body Exp_Aggr is\n       --  constructor to ensure the proper initialization of the _Tag\n       --  component.\n \n-      if Is_CPP_Class (Typ) then\n-         pragma Assert (Present (Base_Init_Proc (Typ)));\n-         Append_List_To (L,\n-           Build_Initialization_Call (Loc,\n-             Id_Ref => Lhs,\n-             Typ    => Typ));\n+      if Is_CPP_Class (Root_Type (Typ))\n+        and then CPP_Num_Prims (Typ) > 0\n+      then\n+         Invoke_Constructor : declare\n+            CPP_Parent : constant Entity_Id :=\n+                           Enclosing_CPP_Parent (Typ);\n+\n+            procedure Invoke_IC_Proc (T : Entity_Id);\n+            --  Recursive routine used to climb to parents. Required because\n+            --  parents must be initialized before descendants to ensure\n+            --  propagation of inherited C++ slots.\n+\n+            --------------------\n+            -- Invoke_IC_Proc --\n+            --------------------\n+\n+            procedure Invoke_IC_Proc (T : Entity_Id) is\n+            begin\n+               --  Avoid generating extra calls. Initialization required\n+               --  only for types defined from the level of derivation of\n+               --  type of the constructor and the type of the aggregate.\n+\n+               if T = CPP_Parent then\n+                  return;\n+               end if;\n+\n+               Invoke_IC_Proc (Etype (T));\n+\n+               --  Generate call to the IC routine\n+\n+               if Present (CPP_Init_Proc (T)) then\n+                  Append_To (L,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      New_Reference_To (CPP_Init_Proc (T), Loc)));\n+               end if;\n+            end Invoke_IC_Proc;\n+\n+         --  Start of processing for Invoke_Constructor\n+\n+         begin\n+            --  Implicit invocation of the C++ constructor\n+\n+            if Nkind (N) = N_Aggregate then\n+               Append_To (L,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To\n+                       (Base_Init_Proc (CPP_Parent), Loc),\n+                   Parameter_Associations => New_List (\n+                     Unchecked_Convert_To (CPP_Parent,\n+                       New_Copy_Tree (Lhs)))));\n+            end if;\n+\n+            Invoke_IC_Proc (Typ);\n+         end Invoke_Constructor;\n       end if;\n \n       --  Generate the assignments, component by component"}, {"sha": "a3270c84a6e978566be19888cfe1f5c6ca3b733b", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 255, "deletions": 1, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,13 +26,15 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Util; use Sem_Util;\n with Stand;    use Stand;\n with Snames;   use Snames;\n@@ -327,6 +329,258 @@ package body Exp_Atag is\n             New_List (Make_Integer_Literal (Loc, Position)));\n    end Build_Get_Predefined_Prim_Op_Address;\n \n+   -----------------------------\n+   -- Build_Inherit_CPP_Prims --\n+   -----------------------------\n+\n+   function Build_Inherit_CPP_Prims (Typ : Entity_Id) return List_Id is\n+      Loc          : constant Source_Ptr := Sloc (Typ);\n+      CPP_Nb_Prims : constant Nat := CPP_Num_Prims (Typ);\n+      CPP_Table    : array (1 .. CPP_Nb_Prims) of Boolean := (others => False);\n+      CPP_Typ      : constant Entity_Id := Enclosing_CPP_Parent (Typ);\n+      Result       : constant List_Id   := New_List;\n+      Parent_Typ   : constant Entity_Id := Etype (Typ);\n+      E            : Entity_Id;\n+      Elmt         : Elmt_Id;\n+      Parent_Tag   : Entity_Id;\n+      Prim         : Entity_Id;\n+      Prim_Pos     : Nat;\n+      Typ_Tag      : Entity_Id;\n+\n+   begin\n+      pragma Assert (not Is_CPP_Class (Typ));\n+\n+      --  No code needed if this type has no primitives inherited from C++\n+\n+      if CPP_Nb_Prims = 0 then\n+         return Result;\n+      end if;\n+\n+      --  Stage 1: Inherit and override C++ slots of the primary dispatch table\n+\n+      --  Generate:\n+      --     Typ'Tag (Prim_Pos) := Prim'Unrestricted_Access;\n+\n+      Parent_Tag := Node (First_Elmt (Access_Disp_Table (Parent_Typ)));\n+      Typ_Tag    := Node (First_Elmt (Access_Disp_Table (Typ)));\n+\n+      Elmt := First_Elmt (Primitive_Operations (Typ));\n+      while Present (Elmt) loop\n+         Prim     := Node (Elmt);\n+         E        := Ultimate_Alias (Prim);\n+         Prim_Pos := UI_To_Int (DT_Position (E));\n+\n+         --  Skip predefined, abstract, and eliminated primitives. Skip also\n+         --  primitives not located in the C++ part of the dispatch table.\n+\n+         if not Is_Predefined_Dispatching_Operation (Prim)\n+           and then not Is_Predefined_Dispatching_Operation (E)\n+           and then not Present (Interface_Alias (Prim))\n+           and then not Is_Abstract_Subprogram (E)\n+           and then not Is_Eliminated (E)\n+           and then Prim_Pos <= CPP_Nb_Prims\n+           and then Find_Dispatching_Type (E) = Typ\n+         then\n+            --  Remember that this slot is used\n+\n+            pragma Assert (CPP_Table (Prim_Pos) = False);\n+            CPP_Table (Prim_Pos) := True;\n+\n+            Append_To (Result,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Indexed_Component (Loc,\n+                    Prefix =>\n+                      Make_Explicit_Dereference (Loc,\n+                        Unchecked_Convert_To\n+                          (Node (Last_Elmt (Access_Disp_Table (Typ))),\n+                           New_Reference_To (Typ_Tag, Loc))),\n+                    Expressions =>\n+                       New_List (Make_Integer_Literal (Loc, Prim_Pos))),\n+\n+               Expression =>\n+                 Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Reference_To (E, Loc),\n+                     Attribute_Name => Name_Unrestricted_Access))));\n+         end if;\n+\n+         Next_Elmt (Elmt);\n+      end loop;\n+\n+      --  If all primitives have been overridden then there is no need to copy\n+      --  from Typ's parent its dispatch table. Otherwise, if some primitive is\n+      --  inherited from the parent we copy only the C++ part of the dispatch\n+      --  table from the parent before the assignments that initialize the\n+      --  overridden primitives.\n+\n+      --  Generate:\n+\n+      --     type CPP_TypG is array (1 .. CPP_Nb_Prims) ofd Prim_Ptr;\n+      --     type CPP_TypH is access CPP_TypG;\n+      --     CPP_TypG!(Typ_Tag).all := CPP_TypG!(Parent_Tag).all;\n+\n+      --   Note: There is no need to duplicate the declarations of CPP_TypG and\n+      --         CPP_TypH because, for expansion of dispatching calls, these\n+      --         entities are stored in the last elements of Access_Disp_Table.\n+\n+      for J in CPP_Table'Range loop\n+         if not CPP_Table (J) then\n+            Prepend_To (Result,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Explicit_Dereference (Loc,\n+                    Unchecked_Convert_To\n+                      (Node (Last_Elmt (Access_Disp_Table (CPP_Typ))),\n+                       New_Reference_To (Typ_Tag, Loc))),\n+                Expression =>\n+                  Make_Explicit_Dereference (Loc,\n+                    Unchecked_Convert_To\n+                      (Node (Last_Elmt (Access_Disp_Table (CPP_Typ))),\n+                       New_Reference_To (Parent_Tag, Loc)))));\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Stage 2: Inherit and override C++ slots of secondary dispatch tables\n+\n+      declare\n+         Iface                   : Entity_Id;\n+         Iface_Nb_Prims          : Nat;\n+         Parent_Ifaces_List      : Elist_Id;\n+         Parent_Ifaces_Comp_List : Elist_Id;\n+         Parent_Ifaces_Tag_List  : Elist_Id;\n+         Parent_Iface_Tag_Elmt   : Elmt_Id;\n+         Typ_Ifaces_List         : Elist_Id;\n+         Typ_Ifaces_Comp_List    : Elist_Id;\n+         Typ_Ifaces_Tag_List     : Elist_Id;\n+         Typ_Iface_Tag_Elmt      : Elmt_Id;\n+\n+      begin\n+         Collect_Interfaces_Info\n+           (T               => Parent_Typ,\n+            Ifaces_List     => Parent_Ifaces_List,\n+            Components_List => Parent_Ifaces_Comp_List,\n+            Tags_List       => Parent_Ifaces_Tag_List);\n+\n+         Collect_Interfaces_Info\n+           (T               => Typ,\n+            Ifaces_List     => Typ_Ifaces_List,\n+            Components_List => Typ_Ifaces_Comp_List,\n+            Tags_List       => Typ_Ifaces_Tag_List);\n+\n+         Parent_Iface_Tag_Elmt := First_Elmt (Parent_Ifaces_Tag_List);\n+         Typ_Iface_Tag_Elmt    := First_Elmt (Typ_Ifaces_Tag_List);\n+         while Present (Parent_Iface_Tag_Elmt) loop\n+            Parent_Tag := Node (Parent_Iface_Tag_Elmt);\n+            Typ_Tag    := Node (Typ_Iface_Tag_Elmt);\n+\n+            pragma Assert\n+              (Related_Type (Parent_Tag) = Related_Type (Typ_Tag));\n+            Iface := Related_Type (Parent_Tag);\n+\n+            Iface_Nb_Prims :=\n+              UI_To_Int (DT_Entry_Count (First_Tag_Component (Iface)));\n+\n+            if Iface_Nb_Prims > 0 then\n+\n+               --  Update slots of overridden primitives\n+\n+               declare\n+                  Last_Nod : constant Node_Id := Last (Result);\n+                  Nb_Prims : constant Nat := UI_To_Int\n+                                              (DT_Entry_Count\n+                                               (First_Tag_Component (Iface)));\n+                  Elmt     : Elmt_Id;\n+                  Prim     : Entity_Id;\n+                  E        : Entity_Id;\n+                  Prim_Pos : Nat;\n+\n+                  Prims_Table : array (1 .. Nb_Prims) of Boolean;\n+\n+               begin\n+                  Prims_Table := (others => False);\n+\n+                  Elmt := First_Elmt (Primitive_Operations (Typ));\n+                  while Present (Elmt) loop\n+                     Prim := Node (Elmt);\n+                     E    := Ultimate_Alias (Prim);\n+\n+                     if not Is_Predefined_Dispatching_Operation (Prim)\n+                       and then Present (Interface_Alias (Prim))\n+                       and then Find_Dispatching_Type (Interface_Alias (Prim))\n+                                  = Iface\n+                       and then not Is_Abstract_Subprogram (E)\n+                       and then not Is_Eliminated (E)\n+                       and then Find_Dispatching_Type (E) = Typ\n+                     then\n+                        Prim_Pos := UI_To_Int (DT_Position (Prim));\n+\n+                        --  Remember that this slot is already initialized\n+\n+                        pragma Assert (Prims_Table (Prim_Pos) = False);\n+                        Prims_Table (Prim_Pos) := True;\n+\n+                        Append_To (Result,\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              Make_Indexed_Component (Loc,\n+                                Prefix =>\n+                                  Make_Explicit_Dereference (Loc,\n+                                    Unchecked_Convert_To\n+                                      (Node\n+                                        (Last_Elmt\n+                                          (Access_Disp_Table (Iface))),\n+                                       New_Reference_To (Typ_Tag, Loc))),\n+                                Expressions =>\n+                                   New_List\n+                                    (Make_Integer_Literal (Loc, Prim_Pos))),\n+\n+                            Expression =>\n+                              Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix => New_Reference_To (E, Loc),\n+                                  Attribute_Name =>\n+                                    Name_Unrestricted_Access))));\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  --  Check if all primitives from the parent have been\n+                  --  overridden (to avoid copying the whole secondary\n+                  --  table from the parent).\n+\n+                  --   IfaceG!(Typ_Sec_Tag).all := IfaceG!(Parent_Sec_Tag).all;\n+\n+                  for J in Prims_Table'Range loop\n+                     if not Prims_Table (J) then\n+                        Insert_After (Last_Nod,\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              Make_Explicit_Dereference (Loc,\n+                                Unchecked_Convert_To\n+                                 (Node (Last_Elmt (Access_Disp_Table (Iface))),\n+                                  New_Reference_To (Typ_Tag, Loc))),\n+                            Expression =>\n+                              Make_Explicit_Dereference (Loc,\n+                                Unchecked_Convert_To\n+                                 (Node (Last_Elmt (Access_Disp_Table (Iface))),\n+                                  New_Reference_To (Parent_Tag, Loc)))));\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end;\n+            end if;\n+\n+            Next_Elmt (Typ_Iface_Tag_Elmt);\n+            Next_Elmt (Parent_Iface_Tag_Elmt);\n+         end loop;\n+      end;\n+\n+      return Result;\n+   end Build_Inherit_CPP_Prims;\n+\n    -------------------------\n    -- Build_Inherit_Prims --\n    -------------------------"}, {"sha": "384a2d0baa3a03cee853cf9dbe01d85f1ca758f8", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,6 +97,11 @@ package Exp_Atag is\n    --\n    --  Generates: TSD (Tag).Transportable;\n \n+   function Build_Inherit_CPP_Prims (Typ : Entity_Id) return List_Id;\n+   --  Build code that copies from Typ's parent the dispatch table slots of\n+   --  inherited primitives and updates slots of overridden primitives. The\n+   --  generated code handles primary and secondary dispatch tables of Typ.\n+\n    function Build_Inherit_Predefined_Prims\n      (Loc          : Source_Ptr;\n       Old_Tag_Node : Node_Id;"}, {"sha": "1bfa9f2de67e6da32cb4716b36c6f29da8b6785d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 352, "deletions": 180, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -214,6 +214,9 @@ package body Exp_Ch3 is\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n \n+   function Is_Variable_Size_Array (E : Entity_Id) return Boolean;\n+   --  Returns true if E has variable size components\n+\n    function Is_Variable_Size_Record (E : Entity_Id) return Boolean;\n    --  Returns true if E has variable size components\n \n@@ -1777,6 +1780,12 @@ package body Exp_Ch3 is\n       --\n       --  This function builds the call statement in this _init_proc.\n \n+      procedure Build_CPP_Init_Procedure;\n+      --  Build the tree corresponding to the procedure specification and body\n+      --  of the IC procedure that initializes the C++ part of the dispatch\n+      --  table of an Ada tagged type that is a derivation of a CPP type.\n+      --  Install it as the CPP_Init TSS.\n+\n       procedure Build_Init_Procedure;\n       --  Build the tree corresponding to the procedure specification and body\n       --  of the initialization procedure (by calling all the preceding\n@@ -2209,6 +2218,104 @@ package body Exp_Ch3 is\n          end loop;\n       end Build_Offset_To_Top_Functions;\n \n+      ------------------------------\n+      -- Build_CPP_Init_Procedure --\n+      ------------------------------\n+\n+      procedure Build_CPP_Init_Procedure is\n+         Body_Node         : Node_Id;\n+         Body_Stmts        : List_Id;\n+         Flag_Id           : Entity_Id;\n+         Flag_Decl         : Node_Id;\n+         Handled_Stmt_Node : Node_Id;\n+         Init_Tags_List    : List_Id;\n+         Proc_Id           : Entity_Id;\n+         Proc_Spec_Node    : Node_Id;\n+\n+      begin\n+         --  Check cases requiring no IC routine\n+\n+         if not Is_CPP_Class (Root_Type (Rec_Type))\n+           or else Is_CPP_Class (Rec_Type)\n+           or else CPP_Num_Prims (Rec_Type) = 0\n+           or else not Tagged_Type_Expansion\n+           or else No_Run_Time_Mode\n+         then\n+            return;\n+         end if;\n+\n+         --  Generate:\n+\n+         --     Flag : Boolean := False;\n+         --\n+         --     procedure Typ_IC is\n+         --     begin\n+         --        if not Flag then\n+         --           Copy C++ dispatch table slots from parent\n+         --           Update C++ slots of overridden primitives\n+         --        end if;\n+         --     end;\n+\n+         Flag_Id := Make_Temporary (Loc, 'F');\n+\n+         Flag_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Flag_Id,\n+             Object_Definition =>\n+               New_Reference_To (Standard_Boolean, Loc),\n+             Expression =>\n+               New_Reference_To (Standard_True, Loc));\n+\n+         Analyze (Flag_Decl);\n+         Append_Freeze_Action (Rec_Type, Flag_Decl);\n+\n+         Body_Stmts := New_List;\n+         Body_Node := New_Node (N_Subprogram_Body, Loc);\n+\n+         Proc_Spec_Node := New_Node (N_Procedure_Specification, Loc);\n+\n+         Proc_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => Make_TSS_Name (Rec_Type, TSS_CPP_Init_Proc));\n+\n+         Set_Ekind       (Proc_Id, E_Procedure);\n+         Set_Is_Internal (Proc_Id);\n+\n+         Set_Defining_Unit_Name (Proc_Spec_Node, Proc_Id);\n+\n+         Set_Parameter_Specifications (Proc_Spec_Node, New_List);\n+         Set_Specification (Body_Node, Proc_Spec_Node);\n+         Set_Declarations (Body_Node, New_List);\n+\n+         Init_Tags_List := Build_Inherit_CPP_Prims (Rec_Type);\n+\n+         Append_To (Init_Tags_List,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               New_Reference_To (Flag_Id, Loc),\n+             Expression =>\n+               New_Reference_To (Standard_False, Loc)));\n+\n+         Append_To (Body_Stmts,\n+           Make_If_Statement (Loc,\n+             Condition => New_Occurrence_Of (Flag_Id, Loc),\n+             Then_Statements => Init_Tags_List));\n+\n+         Handled_Stmt_Node :=\n+           New_Node (N_Handled_Sequence_Of_Statements, Loc);\n+         Set_Statements (Handled_Stmt_Node, Body_Stmts);\n+         Set_Exception_Handlers (Handled_Stmt_Node, No_List);\n+         Set_Handled_Statement_Sequence (Body_Node, Handled_Stmt_Node);\n+\n+         if not Debug_Generated_Code then\n+            Set_Debug_Info_Off (Proc_Id);\n+         end if;\n+\n+         --  Associate CPP_Init_Proc with type\n+\n+         Set_Init_Proc (Rec_Type, Proc_Id);\n+      end Build_CPP_Init_Procedure;\n+\n       --------------------------\n       -- Build_Init_Procedure --\n       --------------------------\n@@ -2239,9 +2346,7 @@ package body Exp_Ch3 is\n          --  a type extension. If the flag is false, we do not set the tag\n          --  because it has been set already in the extension.\n \n-         if Is_Tagged_Type (Rec_Type)\n-           and then not Is_CPP_Class (Rec_Type)\n-         then\n+         if Is_Tagged_Type (Rec_Type) then\n             Set_Tag := Make_Temporary (Loc, 'P');\n \n             Append_To (Parameters,\n@@ -2312,133 +2417,154 @@ package body Exp_Ch3 is\n          --  the C++ side.\n \n          if Is_Tagged_Type (Rec_Type)\n-           and then not Is_CPP_Class (Rec_Type)\n            and then Tagged_Type_Expansion\n            and then not No_Run_Time_Mode\n          then\n-            --  Initialize the primary tag\n+            --  Case 1: Ada tagged types with no CPP ancestor. Set the tags of\n+            --  the actual object and invoke the IP of the parent (in this\n+            --  order). The tag must be initialized before the call to the IP\n+            --  of the parent and the assignments to other components because\n+            --  the initial value of the components may depend on the tag (eg.\n+            --  through a dispatching operation on an access to the current\n+            --  type). The tag assignment is not done when initializing the\n+            --  parent component of a type extension, because in that case the\n+            --  tag is set in the extension.\n \n-            Init_Tags_List := New_List (\n-              Make_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix => Make_Identifier (Loc, Name_uInit),\n-                    Selector_Name =>\n-                      New_Reference_To (First_Tag_Component (Rec_Type), Loc)),\n-\n-                Expression =>\n-                  New_Reference_To\n-                    (Node (First_Elmt (Access_Disp_Table (Rec_Type))), Loc)));\n+            if not Is_CPP_Class (Root_Type (Rec_Type)) then\n \n-            --  Ada 2005 (AI-251): Initialize the secondary tags components\n-            --  located at fixed positions (tags whose position depends on\n-            --  variable size components are initialized later ---see below).\n+               --  Initialize the primary tag component\n \n-            if Ada_Version >= Ada_05\n-              and then not Is_Interface (Rec_Type)\n-              and then Has_Interfaces (Rec_Type)\n-            then\n-               Init_Secondary_Tags\n-                 (Typ            => Rec_Type,\n-                  Target         => Make_Identifier (Loc, Name_uInit),\n-                  Stmts_List     => Init_Tags_List,\n-                  Fixed_Comps    => True,\n-                  Variable_Comps => False);\n-            end if;\n+               Init_Tags_List := New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => Make_Identifier (Loc, Name_uInit),\n+                       Selector_Name =>\n+                         New_Reference_To\n+                           (First_Tag_Component (Rec_Type), Loc)),\n+                   Expression =>\n+                     New_Reference_To\n+                       (Node\n+                         (First_Elmt (Access_Disp_Table (Rec_Type))), Loc)));\n \n-            --  The tag must be inserted before the assignments to other\n-            --  components,  because the initial value of the component may\n-            --  depend on the tag (eg. through a dispatching operation on\n-            --  an access to the current type). The tag assignment is not done\n-            --  when initializing the parent component of a type extension,\n-            --  because in that case the tag is set in the extension.\n+               --  Ada 2005 (AI-251): Initialize the secondary tags components\n+               --  located at fixed positions (tags whose position depends on\n+               --  variable size components are initialized later ---see below)\n \n-            --  Extensions of imported C++ classes add a final complication,\n-            --  because we cannot inhibit tag setting in the constructor for\n-            --  the parent. In that case we insert the tag initialization\n-            --  after the calls to initialize the parent.\n+               if Ada_Version >= Ada_05\n+                 and then not Is_Interface (Rec_Type)\n+                 and then Has_Interfaces (Rec_Type)\n+               then\n+                  Init_Secondary_Tags\n+                    (Typ            => Rec_Type,\n+                     Target         => Make_Identifier (Loc, Name_uInit),\n+                     Stmts_List     => Init_Tags_List,\n+                     Fixed_Comps    => True,\n+                     Variable_Comps => False);\n+               end if;\n \n-            if not Is_CPP_Class (Root_Type (Rec_Type)) then\n                Prepend_To (Body_Stmts,\n                  Make_If_Statement (Loc,\n                    Condition => New_Occurrence_Of (Set_Tag, Loc),\n                    Then_Statements => Init_Tags_List));\n \n-            --  CPP_Class derivation: In this case the dispatch table of the\n-            --  parent was built in the C++ side and we copy the table of the\n-            --  parent to initialize the new dispatch table.\n+            --  Case 2: CPP type. The imported C++ constructor takes care of\n+            --  tags initialization. No action needed here because the IP\n+            --  is built by Set_CPP_Constructors; in this case the IP is a\n+            --  wrapper that invokes the C++ constructor and copies the C++\n+            --  tags locally. Done to inherit the C++ slots in Ada derivations\n+            --  (see case 3).\n+\n+            elsif Is_CPP_Class (Rec_Type) then\n+               pragma Assert (False);\n+               null;\n+\n+            --  Case 3: Combined hierarchy containing C++ types and Ada tagged\n+            --  type derivations. Derivations of imported C++ classes add a\n+            --  complication, because we cannot inhibit tag setting in the\n+            --  constructor for the parent. Hence we initialize the tag after\n+            --  the call to the parent IP (that is, in reverse order compared\n+            --  with pure Ada hierarchies ---see comment on case 1).\n \n             else\n+               --  Initialize the primary tag\n+\n+               Init_Tags_List := New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => Make_Identifier (Loc, Name_uInit),\n+                       Selector_Name =>\n+                         New_Reference_To\n+                           (First_Tag_Component (Rec_Type), Loc)),\n+                   Expression =>\n+                     New_Reference_To\n+                       (Node\n+                         (First_Elmt (Access_Disp_Table (Rec_Type))), Loc)));\n+\n+               --  Ada 2005 (AI-251): Initialize the secondary tags components\n+               --  located at fixed positions (tags whose position depends on\n+               --  variable size components are initialized later ---see below)\n+\n+               if Ada_Version >= Ada_05\n+                 and then not Is_Interface (Rec_Type)\n+                 and then Has_Interfaces (Rec_Type)\n+               then\n+                  Init_Secondary_Tags\n+                    (Typ            => Rec_Type,\n+                     Target         => Make_Identifier (Loc, Name_uInit),\n+                     Stmts_List     => Init_Tags_List,\n+                     Fixed_Comps    => True,\n+                     Variable_Comps => False);\n+               end if;\n+\n+               --  Initialize the tag component after invocation of parent IP.\n+\n+               --  Generate:\n+               --     parent_IP(_init.parent); // Invokes the C++ constructor\n+               --     [ typIC; ]               // Inherit C++ slots from parent\n+               --     init_tags\n+\n                declare\n-                  Nod : Node_Id;\n+                  Ins_Nod : Node_Id;\n \n                begin\n-                  --  We assume the first init_proc call is for the parent\n+                  --  Search for the call to the IP of the parent. We assume\n+                  --  that the first init_proc call is for the parent.\n \n-                  Nod := First (Body_Stmts);\n-                  while Present (Next (Nod))\n-                    and then (Nkind (Nod) /= N_Procedure_Call_Statement\n-                               or else not Is_Init_Proc (Name (Nod)))\n+                  Ins_Nod := First (Body_Stmts);\n+                  while Present (Next (Ins_Nod))\n+                     and then (Nkind (Ins_Nod) /= N_Procedure_Call_Statement\n+                                or else not Is_Init_Proc (Name (Ins_Nod)))\n                   loop\n-                     Nod := Next (Nod);\n+                     Next (Ins_Nod);\n                   end loop;\n \n-                  --  Generate:\n-                  --     ancestor_constructor (_init.parent);\n-                  --     if Arg2 then\n-                  --        inherit_prim_ops (_init._tag, new_dt, num_prims);\n-                  --        _init._tag := new_dt;\n-                  --     end if;\n-\n-                  Prepend_To (Init_Tags_List,\n-                    Build_Inherit_Prims (Loc,\n-                      Typ          => Rec_Type,\n-                      Old_Tag_Node =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix        =>\n-                            Make_Identifier (Loc,\n-                              Chars => Name_uInit),\n-                          Selector_Name =>\n-                            New_Reference_To\n-                              (First_Tag_Component (Rec_Type), Loc)),\n-                      New_Tag_Node =>\n-                        New_Reference_To\n-                          (Node (First_Elmt (Access_Disp_Table (Rec_Type))),\n-                           Loc),\n-                      Num_Prims    =>\n-                        UI_To_Int\n-                          (DT_Entry_Count (First_Tag_Component (Rec_Type)))));\n-\n-                  Insert_After (Nod,\n-                    Make_If_Statement (Loc,\n-                      Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                      Then_Statements => Init_Tags_List));\n-\n-                  --  We have inherited table of the parent from the CPP side.\n-                  --  Now we fill the slots associated with Ada primitives.\n-                  --  This needs more work to avoid its execution each time\n-                  --  an object is initialized???\n+                  --  The IC routine copies the inherited slots of the C+ part\n+                  --  of the dispatch table from the parent and updates the\n+                  --  overridden C++ slots.\n \n-                  declare\n-                     E    : Elmt_Id;\n-                     Prim : Node_Id;\n+                  if CPP_Num_Prims (Rec_Type) > 0 then\n+                     declare\n+                        Init_DT : Entity_Id;\n+                        New_Nod : Node_Id;\n \n-                  begin\n-                     E := First_Elmt (Primitive_Operations (Rec_Type));\n-                     while Present (E) loop\n-                        Prim := Node (E);\n+                     begin\n+                        Init_DT := CPP_Init_Proc (Rec_Type);\n+                        pragma Assert (Present (Init_DT));\n \n-                        if not Is_Imported (Prim)\n-                          and then Convention (Prim) = Convention_CPP\n-                          and then not Present (Interface_Alias (Prim))\n-                        then\n-                           Append_List_To (Init_Tags_List,\n-                             Register_Primitive (Loc, Prim => Prim));\n-                        end if;\n+                        New_Nod :=\n+                          Make_Procedure_Call_Statement (Loc,\n+                            New_Reference_To (Init_DT, Loc));\n+                        Insert_After (Ins_Nod, New_Nod);\n \n-                        Next_Elmt (E);\n-                     end loop;\n-                  end;\n+                        --  Update location of init tag statements\n+\n+                        Ins_Nod := New_Nod;\n+                     end;\n+                  end if;\n+\n+                  Insert_List_After (Ins_Nod, Init_Tags_List);\n                end;\n             end if;\n \n@@ -3116,7 +3242,8 @@ package body Exp_Ch3 is\n          --     at the other end of the call, even if it does nothing!)\n \n          --  Note: the reason we exclude the CPP_Class case is because in this\n-         --  case the initialization is performed in the C++ side.\n+         --  case the initialization is performed by the C++ constructors, and\n+         --  the IP is built by Set_CPP_Constructors.\n \n          if Is_CPP_Class (Rec_Id) then\n             return False;\n@@ -3243,6 +3370,7 @@ package body Exp_Ch3 is\n          end if;\n \n          Build_Offset_To_Top_Functions;\n+         Build_CPP_Init_Procedure;\n          Build_Init_Procedure;\n          Set_Is_Public (Proc_Id, Is_Public (Pe));\n \n@@ -5720,14 +5848,15 @@ package body Exp_Ch3 is\n \n          if Is_CPP_Class (Def_Id) then\n             Set_All_DT_Position (Def_Id);\n-            Set_CPP_Constructors (Def_Id);\n \n             --  Create the tag entities with a minimum decoration\n \n             if Tagged_Type_Expansion then\n                Append_Freeze_Actions (Def_Id, Make_Tags (Def_Id));\n             end if;\n \n+            Set_CPP_Constructors (Def_Id);\n+\n          else\n             if not Has_Static_DT then\n \n@@ -6930,11 +7059,6 @@ package body Exp_Ch3 is\n    is\n       Loc : constant Source_Ptr := Sloc (Target);\n \n-      procedure Inherit_CPP_Tag\n-        (Typ       : Entity_Id;\n-         Iface     : Entity_Id;\n-         Tag_Comp  : Entity_Id;\n-         Iface_Tag : Node_Id);\n       --  Inherit the C++ tag of the secondary dispatch table of Typ associated\n       --  with Iface. Tag_Comp is the component of Typ that stores Iface_Tag.\n \n@@ -6949,32 +7073,6 @@ package body Exp_Ch3 is\n       --  of Typ CPP tagged type we generate code to inherit the contents of\n       --  the dispatch table directly from the ancestor.\n \n-      ---------------------\n-      -- Inherit_CPP_Tag --\n-      ---------------------\n-\n-      procedure Inherit_CPP_Tag\n-        (Typ       : Entity_Id;\n-         Iface     : Entity_Id;\n-         Tag_Comp  : Entity_Id;\n-         Iface_Tag : Node_Id)\n-      is\n-      begin\n-         pragma Assert (Is_CPP_Class (Etype (Typ)));\n-\n-         Append_To (Stmts_List,\n-           Build_Inherit_Prims (Loc,\n-             Typ          => Iface,\n-             Old_Tag_Node =>\n-               Make_Selected_Component (Loc,\n-                 Prefix        => New_Copy_Tree (Target),\n-                 Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n-             New_Tag_Node =>\n-               New_Reference_To (Iface_Tag, Loc),\n-             Num_Prims    =>\n-               UI_To_Int (DT_Entry_Count (First_Tag_Component (Iface)))));\n-      end Inherit_CPP_Tag;\n-\n       --------------------\n       -- Initialize_Tag --\n       --------------------\n@@ -7175,26 +7273,85 @@ package body Exp_Ch3 is\n       while Present (Iface_Elmt) loop\n          Tag_Comp := Node (Iface_Comp_Elmt);\n \n+         --  Check if parent of record type has variable size components\n+\n+         In_Variable_Pos := Scope (Tag_Comp) /= Etype (Scope (Tag_Comp))\n+           and then Is_Variable_Size_Record (Etype (Scope (Tag_Comp)));\n+\n          --  If we are compiling under the CPP full ABI compatibility mode and\n          --  the ancestor is a CPP_Pragma tagged type then we generate code to\n-         --  inherit the contents of the dispatch table directly from the\n-         --  ancestor.\n+         --  initialize the secondary tag components from tags that reference\n+         --  secondary tables filled with copy of parent slots.\n \n-         if Is_CPP_Class (Etype (Full_Typ)) then\n-            Inherit_CPP_Tag (Full_Typ,\n-              Iface     => Node (Iface_Elmt),\n-              Tag_Comp  => Tag_Comp,\n-              Iface_Tag => Node (Iface_Tag_Elmt));\n+         if Is_CPP_Class (Root_Type (Full_Typ)) then\n \n-         --  Otherwise generate code to initialize the tag\n+            --  Reject interface components located at variable offset in\n+            --  C++ derivations. This is currently unsupported.\n \n-         else\n-            --  Check if the parent of the record type has variable size\n-            --  components.\n+            if not Fixed_Comps and then In_Variable_Pos then\n+\n+               --  Locate the first dynamic component of the record. Done to\n+               --  improve the text of the warning.\n \n-            In_Variable_Pos := Scope (Tag_Comp) /= Etype (Scope (Tag_Comp))\n-              and then Is_Variable_Size_Record (Etype (Scope (Tag_Comp)));\n+               declare\n+                  Comp     : Entity_Id;\n+                  Comp_Typ : Entity_Id;\n+\n+               begin\n+                  Comp := First_Entity (Typ);\n+                  while Present (Comp) loop\n+                     Comp_Typ := Etype (Comp);\n+\n+                     if Ekind (Comp) /= E_Discriminant\n+                       and then not Is_Tag (Comp)\n+                     then\n+                        exit when\n+                          (Is_Record_Type (Comp_Typ)\n+                             and then Is_Variable_Size_Record\n+                                        (Base_Type (Comp_Typ)))\n+                         or else\n+                           (Is_Array_Type (Comp_Typ)\n+                              and then Is_Variable_Size_Array (Comp_Typ));\n+                     end if;\n+\n+                     Next_Entity (Comp);\n+                  end loop;\n \n+                  pragma Assert (Present (Comp));\n+                  Error_Msg_Node_2 := Comp;\n+                  Error_Msg_NE\n+                    (\"parent type & with dynamic component & cannot be parent\"\n+                       & \" of 'C'P'P derivation if new interfaces are present\",\n+                     Typ, Scope (Original_Record_Component (Comp)));\n+\n+                  Error_Msg_Sloc :=\n+                    Sloc (Scope (Original_Record_Component (Comp)));\n+                  Error_Msg_NE\n+                    (\"type derived from 'C'P'P type & defined #\",\n+                     Typ, Scope (Original_Record_Component (Comp)));\n+\n+                  --  Avoid duplicated warnings\n+\n+                  exit;\n+               end;\n+\n+            --  Initialize secondary tags\n+\n+            else\n+               Append_To (Stmts_List,\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => New_Copy_Tree (Target),\n+                       Selector_Name =>\n+                         New_Reference_To (Node (Iface_Comp_Elmt), Loc)),\n+                   Expression =>\n+                     New_Reference_To (Node (Iface_Tag_Elmt), Loc)));\n+            end if;\n+\n+         --  Otherwise generate code to initialize the tag\n+\n+         else\n             if (In_Variable_Pos and then Variable_Comps)\n               or else (not In_Variable_Pos and then Fixed_Comps)\n             then\n@@ -7211,14 +7368,11 @@ package body Exp_Ch3 is\n       end loop;\n    end Init_Secondary_Tags;\n \n-   -----------------------------\n-   -- Is_Variable_Size_Record --\n-   -----------------------------\n+   ----------------------------\n+   -- Is_Variable_Size_Array --\n+   ----------------------------\n \n-   function Is_Variable_Size_Record (E : Entity_Id) return Boolean is\n-      Comp     : Entity_Id;\n-      Comp_Typ : Entity_Id;\n-      Idx      : Node_Id;\n+   function Is_Variable_Size_Array (E : Entity_Id) return Boolean is\n \n       function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n       --  To simplify handling of array components. Determines whether the\n@@ -7244,42 +7398,60 @@ package body Exp_Ch3 is\n          end if;\n       end Is_Constant_Bound;\n \n-   --  Start of processing for Is_Variable_Sized_Record\n+      --  Local variables\n \n-   begin\n-      pragma Assert (Is_Record_Type (E));\n+      Idx : Node_Id;\n \n-      Comp := First_Entity (E);\n-      while Present (Comp) loop\n-         Comp_Typ := Etype (Comp);\n+   --  Start of processing for Is_Variable_Sized_Array\n \n-         if Is_Record_Type (Comp_Typ) then\n+   begin\n+      pragma Assert (Is_Array_Type (E));\n \n-            --  Recursive call if the record type has discriminants\n+      --  Check if some index is initialized with a non-constant value\n \n-            if Has_Discriminants (Comp_Typ)\n-              and then Is_Variable_Size_Record (Comp_Typ)\n+      Idx := First_Index (E);\n+      while Present (Idx) loop\n+         if Nkind (Idx) = N_Range then\n+            if not Is_Constant_Bound (Low_Bound (Idx))\n+              or else not Is_Constant_Bound (High_Bound (Idx))\n             then\n                return True;\n             end if;\n+         end if;\n \n-         elsif Is_Array_Type (Comp_Typ) then\n+         Idx := Next_Index (Idx);\n+      end loop;\n \n-            --  Check if some index is initialized with a non-constant value\n+      return False;\n+   end Is_Variable_Size_Array;\n \n-            Idx := First_Index (Comp_Typ);\n-            while Present (Idx) loop\n-               if Nkind (Idx) = N_Range then\n-                  if not Is_Constant_Bound (Low_Bound  (Idx))\n-                       or else\n-                     not Is_Constant_Bound (High_Bound (Idx))\n-                  then\n-                     return True;\n-                  end if;\n-               end if;\n+   -----------------------------\n+   -- Is_Variable_Size_Record --\n+   -----------------------------\n \n-               Idx := Next_Index (Idx);\n-            end loop;\n+   function Is_Variable_Size_Record (E : Entity_Id) return Boolean is\n+      Comp     : Entity_Id;\n+      Comp_Typ : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Record_Type (E));\n+\n+      Comp := First_Entity (E);\n+      while Present (Comp) loop\n+         Comp_Typ := Etype (Comp);\n+\n+         --  Recursive call if the record type has discriminants\n+\n+         if Is_Record_Type (Comp_Typ)\n+           and then Has_Discriminants (Comp_Typ)\n+           and then Is_Variable_Size_Record (Comp_Typ)\n+         then\n+            return True;\n+\n+         elsif Is_Array_Type (Comp_Typ)\n+           and then Is_Variable_Size_Array (Comp_Typ)\n+         then\n+            return True;\n          end if;\n \n          Next_Entity (Comp);"}, {"sha": "5411f04d05dc51653c75fcd63cb6e8304ab72089", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 665, "deletions": 248, "changes": 913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -464,6 +464,52 @@ package body Exp_Disp is\n       end if;\n    end Build_Static_Dispatch_Tables;\n \n+   -------------------\n+   -- CPP_Num_Prims --\n+   -------------------\n+\n+   function CPP_Num_Prims (Typ : Entity_Id) return Nat is\n+      CPP_Typ  : Entity_Id;\n+      Tag_Comp : Entity_Id;\n+\n+   begin\n+      if not Is_Tagged_Type (Typ)\n+        or else not Is_CPP_Class (Root_Type (Typ))\n+      then\n+         return 0;\n+\n+      else\n+         CPP_Typ  := Enclosing_CPP_Parent (Typ);\n+         Tag_Comp := First_Tag_Component (CPP_Typ);\n+\n+         --  If the number of primitives is already set in the tag component\n+         --  then use it\n+\n+         if Present (Tag_Comp)\n+           and then DT_Entry_Count (Tag_Comp) /= No_Uint\n+         then\n+            return UI_To_Int (DT_Entry_Count (Tag_Comp));\n+\n+         --  Otherwise, count the primitives of the enclosing CPP type\n+\n+         else\n+            declare\n+               Count : Nat := 0;\n+               Elmt  : Elmt_Id;\n+\n+            begin\n+               Elmt := First_Elmt (Primitive_Operations (CPP_Typ));\n+               while Present (Elmt) loop\n+                  Count := Count + 1;\n+                  Next_Elmt (Elmt);\n+               end loop;\n+\n+               return Count;\n+            end;\n+         end if;\n+      end if;\n+   end CPP_Num_Prims;\n+\n    ------------------------------\n    -- Default_Prim_Op_Position --\n    ------------------------------\n@@ -1733,6 +1779,30 @@ package body Exp_Disp is\n       end if;\n    end Expand_Interface_Thunk;\n \n+   --------------------------\n+   -- Has_CPP_Constructors --\n+   --------------------------\n+\n+   function Has_CPP_Constructors (Typ : Entity_Id) return Boolean is\n+      E : Entity_Id;\n+\n+   begin\n+      --  Look for the constructor entities\n+\n+      E := Next_Entity (Typ);\n+      while Present (E) loop\n+         if Ekind (E) = E_Function\n+           and then Is_Constructor (E)\n+         then\n+            return True;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      return False;\n+   end Has_CPP_Constructors;\n+\n    ------------\n    -- Has_DT --\n    ------------\n@@ -3936,56 +4006,66 @@ package body Exp_Disp is\n             Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n          elsif Is_Abstract_Type (Typ)\n-           or else not Building_Static_DT (Typ)\n+           or else not Static_Dispatch_Tables\n+           or else not Is_Library_Level_Tagged_Type (Typ)\n          then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n             end loop;\n \n          else\n             declare\n-               Prim_Table : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n-               Pos        : Nat;\n-               Thunk_Code : Node_Id;\n-               Thunk_Id   : Entity_Id;\n+               CPP_Nb_Prims : constant Nat := CPP_Num_Prims (Typ);\n+               E            : Entity_Id;\n+               Prim_Pos     : Nat;\n+               Prim_Table   : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n+               Thunk_Code   : Node_Id;\n+               Thunk_Id     : Entity_Id;\n \n             begin\n                Prim_Table := (others => Empty);\n \n                Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n                while Present (Prim_Elmt) loop\n-                  Prim := Node (Prim_Elmt);\n+                  Prim     := Node (Prim_Elmt);\n+                  E        := Ultimate_Alias (Prim);\n+                  Prim_Pos := UI_To_Int (DT_Position (E));\n \n-                  --  Do not reference predefined primitives because they\n-                  --  are located in a separate dispatch table; skip also\n-                  --  abstract and eliminated primitives.\n+                  --  Do not reference predefined primitives because they are\n+                  --  located in a separate dispatch table; skip abstract and\n+                  --  eliminated primitives; skip primitives located in the C++\n+                  --  part of the dispatch table because their slot is set by\n+                  --  the IC routine.\n \n                   if not Is_Predefined_Dispatching_Operation (Prim)\n                     and then Present (Interface_Alias (Prim))\n                     and then not Is_Abstract_Subprogram (Alias (Prim))\n                     and then not Is_Eliminated (Alias (Prim))\n+                    and then (not Is_CPP_Class (Root_Type (Typ))\n+                               or else Prim_Pos > CPP_Nb_Prims)\n                     and then Find_Dispatching_Type\n                                (Interface_Alias (Prim)) = Iface\n \n                      --  Generate the code of the thunk only if the abstract\n                      --  interface type is not an immediate ancestor of\n-                     --  Tagged_Type; otherwise the DT associated with the\n+                     --  Tagged_Type. Otherwise the DT associated with the\n                      --  interface is the primary DT.\n \n                     and then not Is_Ancestor (Iface, Typ)\n                   then\n                      if not Build_Thunks then\n-                        Pos :=\n+                        Prim_Pos :=\n                           UI_To_Int (DT_Position (Interface_Alias (Prim)));\n-                        Prim_Table (Pos) := Alias (Prim);\n+                        Prim_Table (Prim_Pos) := Alias (Prim);\n+\n                      else\n                         Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n                         if Present (Thunk_Id) then\n-                           Pos :=\n+                           Prim_Pos :=\n                              UI_To_Int (DT_Position (Interface_Alias (Prim)));\n \n-                           Prim_Table (Pos) := Thunk_Id;\n+                           Prim_Table (Prim_Pos) := Thunk_Id;\n                            Append_To (Result, Thunk_Code);\n                         end if;\n                      end if;\n@@ -4001,6 +4081,7 @@ package body Exp_Disp is\n                          Make_Attribute_Reference (Loc,\n                            Prefix => New_Reference_To (Prim_Table (J), Loc),\n                            Attribute_Name => Name_Unrestricted_Access));\n+\n                   else\n                      New_Node := Make_Null (Loc);\n                   end if;\n@@ -4238,9 +4319,7 @@ package body Exp_Disp is\n       --  register the primitives in the slots will be generated later --- when\n       --  each primitive is frozen (see Freeze_Subprogram).\n \n-      if Building_Static_DT (Typ)\n-        and then not Is_CPP_Class (Typ)\n-      then\n+      if Building_Static_DT (Typ) then\n          declare\n             Save      : constant Boolean := Freezing_Library_Level_Tagged_Type;\n             Prim      : Entity_Id;\n@@ -4297,6 +4376,7 @@ package body Exp_Disp is\n \n          AI_Tag_Comp := First_Elmt (Typ_Comps);\n          while Present (AI_Tag_Comp) loop\n+            pragma Assert (Has_Suffix (Node (AI_Tag_Elmt), 'P'));\n \n             --  Build the secondary table containing pointers to thunks\n \n@@ -4311,33 +4391,40 @@ package body Exp_Disp is\n               Build_Thunks    => True,\n               Result          => Result);\n \n-            --  Skip secondary dispatch table and secondary dispatch table of\n-            --  predefined primitives\n+            --  Skip secondary dispatch table referencing thunks to predefined\n+            --  primitives.\n \n             Next_Elmt (AI_Tag_Elmt);\n+            pragma Assert (Has_Suffix (Node (AI_Tag_Elmt), 'Y'));\n+\n+            --  Secondary dispatch table referencing user-defined primitives\n+            --  covered by this interface.\n+\n             Next_Elmt (AI_Tag_Elmt);\n+            pragma Assert (Has_Suffix (Node (AI_Tag_Elmt), 'D'));\n \n             --  Build the secondary table containing pointers to primitives\n             --  (used to give support to Generic Dispatching Constructors).\n \n             Make_Secondary_DT\n-             (Typ             => Typ,\n-              Iface           => Base_Type (Related_Type (Node (AI_Tag_Comp))),\n-              Suffix_Index    => -1,\n-              Num_Iface_Prims =>  UI_To_Int\n-                                   (DT_Entry_Count (Node (AI_Tag_Comp))),\n-              Iface_DT_Ptr    => Node (AI_Tag_Elmt),\n-              Predef_Prims_Ptr => Node (Next_Elmt (AI_Tag_Elmt)),\n-              Build_Thunks    => False,\n-              Result          => Result);\n-\n-            --  Skip secondary dispatch table and secondary dispatch table of\n-            --  predefined primitives\n+              (Typ              => Typ,\n+               Iface            => Base_Type\n+                                     (Related_Type (Node (AI_Tag_Comp))),\n+               Suffix_Index     => -1,\n+               Num_Iface_Prims  => UI_To_Int\n+                                     (DT_Entry_Count (Node (AI_Tag_Comp))),\n+               Iface_DT_Ptr     => Node (AI_Tag_Elmt),\n+               Predef_Prims_Ptr => Node (Next_Elmt (AI_Tag_Elmt)),\n+               Build_Thunks     => False,\n+               Result           => Result);\n+\n+            --  Skip secondary dispatch table referencing predefined primitives\n \n             Next_Elmt (AI_Tag_Elmt);\n-            Next_Elmt (AI_Tag_Elmt);\n+            pragma Assert (Has_Suffix (Node (AI_Tag_Elmt), 'Z'));\n \n             Suffix_Index := Suffix_Index + 1;\n+            Next_Elmt (AI_Tag_Elmt);\n             Next_Elmt (AI_Tag_Comp);\n          end loop;\n       end if;\n@@ -4942,7 +5029,7 @@ package body Exp_Disp is\n                         (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n                      pragma Assert (Has_Thunks (Node (Elmt)));\n \n-                     while Ekind (Node (Elmt)) = E_Constant\n+                     while Is_Tag (Node (Elmt))\n                         and then not\n                           Is_Ancestor (Node (AI), Related_Type (Node (Elmt)))\n                      loop\n@@ -5447,17 +5534,21 @@ package body Exp_Disp is\n          if Nb_Prim = 0 then\n             Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n-         elsif not Building_Static_DT (Typ) then\n+         elsif not Static_Dispatch_Tables\n+           or else not Is_Library_Level_Tagged_Type (Typ)\n+         then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n             end loop;\n \n          else\n             declare\n-               Prim_Table : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n-               E          : Entity_Id;\n-               Prim       : Entity_Id;\n-               Prim_Elmt  : Elmt_Id;\n+               CPP_Nb_Prims : constant Nat := CPP_Num_Prims (Typ);\n+               E            : Entity_Id;\n+               Prim         : Entity_Id;\n+               Prim_Elmt    : Elmt_Id;\n+               Prim_Pos     : Nat;\n+               Prim_Table   : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n \n             begin\n                Prim_Table := (others => Empty);\n@@ -5469,19 +5560,24 @@ package body Exp_Disp is\n                   --  Retrieve the ultimate alias of the primitive for proper\n                   --  handling of renamings and eliminated primitives.\n \n-                  E := Ultimate_Alias (Prim);\n+                  E        := Ultimate_Alias (Prim);\n+                  Prim_Pos := UI_To_Int (DT_Position (E));\n \n                   --  Do not reference predefined primitives because they are\n                   --  located in a separate dispatch table; skip entities with\n                   --  attribute Interface_Alias because they are only required\n-                  --  to build secondary dispatch tables; skip also abstract\n-                  --  and eliminated primitives.\n+                  --  to build secondary dispatch tables; skip abstract and\n+                  --  eliminated primitives; for derivations of CPP types skip\n+                  --  primitives located in the C++ part of the dispatch table\n+                  --  because their slot is initialized by the IC routine.\n \n                   if not Is_Predefined_Dispatching_Operation (Prim)\n                     and then not Is_Predefined_Dispatching_Operation (E)\n                     and then not Present (Interface_Alias (Prim))\n                     and then not Is_Abstract_Subprogram (E)\n                     and then not Is_Eliminated (E)\n+                    and then (not Is_CPP_Class (Root_Type (Typ))\n+                               or else Prim_Pos > CPP_Nb_Prims)\n                   then\n                      pragma Assert\n                        (UI_To_Int (DT_Position (Prim)) <= Nb_Prim);\n@@ -5592,7 +5688,9 @@ package body Exp_Disp is\n       --  because the whole dispatch table (including inherited primitives) has\n       --  been already built.\n \n-      if Building_Static_DT (Typ) then\n+      if Static_Dispatch_Tables\n+        and then Is_Library_Level_Tagged_Type (Typ)\n+      then\n          null;\n \n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n@@ -6190,234 +6288,296 @@ package body Exp_Disp is\n    --  Start of processing for Make_Tags\n \n    begin\n-      --  1) Generate the primary and secondary tag entities\n-\n-      --  Collect the components associated with secondary dispatch tables\n-\n-      if Has_Interfaces (Typ) then\n-         Collect_Interface_Components (Typ, Typ_Comps);\n-      end if;\n+      pragma Assert (No (Access_Disp_Table (Typ)));\n+      Set_Access_Disp_Table (Typ, New_Elmt_List);\n \n       --  1) Generate the primary tag entities\n \n       --  Primary dispatch table containing user-defined primitives\n \n-      DT_Ptr := Make_Defining_Identifier (Loc,\n-                  New_External_Name (Tname, 'P'));\n-      Set_Etype (DT_Ptr, RTE (RE_Tag));\n-\n-      --  Primary dispatch table containing predefined primitives\n-\n-      Predef_Prims_Ptr :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Tname, 'Y'));\n-      Set_Etype (Predef_Prims_Ptr, RTE (RE_Address));\n+      DT_Ptr := Make_Defining_Identifier (Loc, New_External_Name (Tname, 'P'));\n+      Set_Etype   (DT_Ptr, RTE (RE_Tag));\n+      Append_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n \n-      --  Import the forward declaration of the Dispatch Table wrapper record\n-      --  (Make_DT will take care of its exportation)\n+      --  Minimum decoration\n \n-      if Building_Static_DT (Typ) then\n-         Set_Dispatch_Table_Wrappers (Typ, New_Elmt_List);\n-\n-         DT :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Tname, 'T'));\n+      Set_Ekind        (DT_Ptr, E_Variable);\n+      Set_Related_Type (DT_Ptr, Typ);\n \n-         Import_DT (Typ, DT, Is_Secondary_DT => False);\n+      --  For CPP types there is no need to build the dispatch tables since\n+      --  they are imported from the C++ side. If the CPP type has an IP\n+      --  then we declare now the variable that will store the copy of the\n+      --  C++ tag.\n \n-         if Has_DT (Typ) then\n+      if Is_CPP_Class (Typ) then\n+         if Has_CPP_Constructors (Typ) then\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT_Ptr,\n-                Constant_Present    => True,\n                 Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n                 Expression =>\n                   Unchecked_Convert_To (RTE (RE_Tag),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Reference_To (DT, Loc),\n-                        Selector_Name =>\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-                      Attribute_Name => Name_Address))));\n+                    New_Reference_To (RTE (RE_Null_Address), Loc))));\n \n-            --  Generate the SCIL node for the previous object declaration\n-            --  because it has a tag initialization.\n+            Set_Is_Statically_Allocated (DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n+         end if;\n \n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Set_SCIL_Node (Last (Result), New_Node);\n-            end if;\n+      --  Ada types\n \n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Predef_Prims_Ptr,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To\n-                                            (RTE (RE_Address), Loc),\n-                Expression =>\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix =>\n-                      Make_Selected_Component (Loc,\n-                        Prefix => New_Reference_To (DT, Loc),\n-                      Selector_Name =>\n-                        New_Occurrence_Of\n-                          (RTE_Record_Component (RE_Predef_Prims), Loc)),\n-                    Attribute_Name => Name_Address)));\n+      else\n+         --  Primary dispatch table containing predefined primitives\n \n-         --  No dispatch table required\n+         Predef_Prims_Ptr :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Tname, 'Y'));\n+         Set_Etype   (Predef_Prims_Ptr, RTE (RE_Address));\n+         Append_Elmt (Predef_Prims_Ptr, Access_Disp_Table (Typ));\n \n-         else\n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => DT_Ptr,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n-                Expression =>\n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Reference_To (DT, Loc),\n-                        Selector_Name =>\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n-                      Attribute_Name => Name_Address))));\n-         end if;\n+         --  Import the forward declaration of the Dispatch Table wrapper\n+         --  record (Make_DT will take care of its exportation)\n \n-         Set_Is_True_Constant (DT_Ptr);\n-         Set_Is_Statically_Allocated (DT_Ptr);\n-      end if;\n+         if Building_Static_DT (Typ) then\n+            Set_Dispatch_Table_Wrappers (Typ, New_Elmt_List);\n \n-      pragma Assert (No (Access_Disp_Table (Typ)));\n-      Set_Access_Disp_Table (Typ, New_Elmt_List);\n-      Append_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n-      Append_Elmt (Predef_Prims_Ptr, Access_Disp_Table (Typ));\n+            DT :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Tname, 'T'));\n+\n+            Import_DT (Typ, DT, Is_Secondary_DT => False);\n+\n+            if Has_DT (Typ) then\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => DT_Ptr,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n+                   Expression =>\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix => New_Reference_To (DT, Loc),\n+                           Selector_Name =>\n+                             New_Occurrence_Of\n+                               (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+                         Attribute_Name => Name_Address))));\n+\n+               --  Generate the SCIL node for the previous object declaration\n+               --  because it has a tag initialization.\n+\n+               if Generate_SCIL then\n+                  New_Node :=\n+                    Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n+                  Set_SCIL_Entity (New_Node, Typ);\n+                  Set_SCIL_Node (Last (Result), New_Node);\n+               end if;\n+\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Predef_Prims_Ptr,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To\n+                                               (RTE (RE_Address), Loc),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         Make_Selected_Component (Loc,\n+                           Prefix => New_Reference_To (DT, Loc),\n+                         Selector_Name =>\n+                           New_Occurrence_Of\n+                             (RTE_Record_Component (RE_Predef_Prims), Loc)),\n+                       Attribute_Name => Name_Address)));\n+\n+            --  No dispatch table required\n+\n+            else\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => DT_Ptr,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n+                   Expression =>\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix => New_Reference_To (DT, Loc),\n+                           Selector_Name =>\n+                             New_Occurrence_Of\n+                               (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n+                         Attribute_Name => Name_Address))));\n+            end if;\n+\n+            Set_Is_True_Constant (DT_Ptr);\n+            Set_Is_Statically_Allocated (DT_Ptr);\n+         end if;\n+      end if;\n \n       --  2) Generate the secondary tag entities\n \n+      --  Collect the components associated with secondary dispatch tables\n+\n       if Has_Interfaces (Typ) then\n+         Collect_Interface_Components (Typ, Typ_Comps);\n \n-         --  Note: The following value of Suffix_Index must be in sync with\n-         --  the Suffix_Index values of secondary dispatch tables generated\n-         --  by Make_DT.\n+         --  For each interface type we build an unique external name\n+         --  associated with its secondary dispatch table. This name is used to\n+         --  declare an object that references this secondary dispatch table,\n+         --  value that will be used for the elaboration of Typ's objects and\n+         --  also for the elaboration of objects of derivations of Typ that do\n+         --  not override the primitives of this interface type.\n \n          Suffix_Index := 1;\n \n-         --  For each interface type we build an unique external name\n-         --  associated with its corresponding secondary dispatch table.\n-         --  This external name will be used to declare an object that\n-         --  references this secondary dispatch table, value that will be\n-         --  used for the elaboration of Typ's objects and also for the\n-         --  elaboration of objects of derivations of Typ that do not\n-         --  override the primitive operation of this interface type.\n+         --  Note: The value of Suffix_Index must be in sync with the\n+         --  Suffix_Index values of secondary dispatch tables generated\n+         --  by Make_DT.\n \n-         AI_Tag_Comp := First_Elmt (Typ_Comps);\n-         while Present (AI_Tag_Comp) loop\n-            Get_Secondary_DT_External_Name\n-              (Typ, Related_Type (Node (AI_Tag_Comp)), Suffix_Index);\n-            Typ_Name := Name_Find;\n+         if Is_CPP_Class (Typ) then\n+            AI_Tag_Comp := First_Elmt (Typ_Comps);\n+            while Present (AI_Tag_Comp) loop\n+               Get_Secondary_DT_External_Name\n+                 (Typ, Related_Type (Node (AI_Tag_Comp)), Suffix_Index);\n+               Typ_Name := Name_Find;\n \n-            if Building_Static_DT (Typ) then\n-               Iface_DT :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name\n-                              (Typ_Name, 'T', Suffix_Index => -1));\n-               Import_DT\n-                 (Tag_Typ => Related_Type (Node (AI_Tag_Comp)),\n-                  DT      => Iface_DT,\n-                  Is_Secondary_DT => True);\n-            end if;\n+               --  Declare variables that will store the copy of the C++\n+               --  secondary tags\n \n-            --  Secondary dispatch table referencing thunks to user-defined\n-            --  primitives covered by this interface.\n+               Iface_DT_Ptr :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Typ_Name, 'P'));\n+               Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n+               Set_Ekind (Iface_DT_Ptr, E_Variable);\n+               Set_Is_Tag (Iface_DT_Ptr);\n \n-            Iface_DT_Ptr :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Typ_Name, 'P'));\n-            Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n-            Set_Ekind (Iface_DT_Ptr, E_Constant);\n-            Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Has_Thunks (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n-              Is_Library_Level_Tagged_Type (Typ));\n-            Set_Is_True_Constant (Iface_DT_Ptr);\n-            Set_Related_Type\n-              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n-            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+               Set_Has_Thunks (Iface_DT_Ptr);\n+               Set_Related_Type\n+                 (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n \n-            if Building_Static_DT (Typ) then\n                Append_To (Result,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Iface_DT_Ptr,\n-                   Constant_Present    => True,\n                    Object_Definition   => New_Reference_To\n                                             (RTE (RE_Interface_Tag), Loc),\n                    Expression =>\n                      Unchecked_Convert_To (RTE (RE_Interface_Tag),\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix =>\n-                           Make_Selected_Component (Loc,\n-                             Prefix => New_Reference_To (Iface_DT, Loc),\n-                           Selector_Name =>\n-                             New_Occurrence_Of\n-                               (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-                         Attribute_Name => Name_Address))));\n-            end if;\n+                       New_Reference_To (RTE (RE_Null_Address), Loc))));\n \n-            --  Secondary dispatch table referencing thunks to predefined\n-            --  primitives.\n+               Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+                 Is_Library_Level_Tagged_Type (Typ));\n \n-            Iface_DT_Ptr :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Typ_Name, 'Y'));\n-            Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n-            Set_Ekind (Iface_DT_Ptr, E_Constant);\n-            Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Has_Thunks (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n-              Is_Library_Level_Tagged_Type (Typ));\n-            Set_Is_True_Constant (Iface_DT_Ptr);\n-            Set_Related_Type\n-              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n-            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+               Next_Elmt (AI_Tag_Comp);\n+            end loop;\n \n-            --  Secondary dispatch table referencing user-defined primitives\n-            --  covered by this interface.\n+         --  This is not a CPP_Class type\n \n-            Iface_DT_Ptr :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Typ_Name, 'D'));\n-            Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n-            Set_Ekind (Iface_DT_Ptr, E_Constant);\n-            Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n-              Is_Library_Level_Tagged_Type (Typ));\n-            Set_Is_True_Constant (Iface_DT_Ptr);\n-            Set_Related_Type\n-              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n-            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+         else\n+            AI_Tag_Comp := First_Elmt (Typ_Comps);\n+            while Present (AI_Tag_Comp) loop\n+               Get_Secondary_DT_External_Name\n+                 (Typ, Related_Type (Node (AI_Tag_Comp)), Suffix_Index);\n+               Typ_Name := Name_Find;\n \n-            --  Secondary dispatch table referencing predefined primitives\n+               if Building_Static_DT (Typ) then\n+                  Iface_DT :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => New_External_Name\n+                                 (Typ_Name, 'T', Suffix_Index => -1));\n+                  Import_DT\n+                    (Tag_Typ => Related_Type (Node (AI_Tag_Comp)),\n+                     DT      => Iface_DT,\n+                     Is_Secondary_DT => True);\n+               end if;\n \n-            Iface_DT_Ptr :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Typ_Name, 'Z'));\n-            Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n-            Set_Ekind (Iface_DT_Ptr, E_Constant);\n-            Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n-              Is_Library_Level_Tagged_Type (Typ));\n-            Set_Is_True_Constant (Iface_DT_Ptr);\n-            Set_Related_Type\n-              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n-            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+               --  Secondary dispatch table referencing thunks to user-defined\n+               --  primitives covered by this interface.\n \n-            Next_Elmt (AI_Tag_Comp);\n-         end loop;\n+               Iface_DT_Ptr :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Typ_Name, 'P'));\n+               Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n+               Set_Ekind (Iface_DT_Ptr, E_Constant);\n+               Set_Is_Tag (Iface_DT_Ptr);\n+               Set_Has_Thunks (Iface_DT_Ptr);\n+               Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+                 Is_Library_Level_Tagged_Type (Typ));\n+               Set_Is_True_Constant (Iface_DT_Ptr);\n+               Set_Related_Type\n+                 (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+               if Building_Static_DT (Typ) then\n+                  Append_To (Result,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Iface_DT_Ptr,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Reference_To\n+                                               (RTE (RE_Interface_Tag), Loc),\n+                      Expression =>\n+                        Unchecked_Convert_To (RTE (RE_Interface_Tag),\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix => New_Reference_To (Iface_DT, Loc),\n+                              Selector_Name =>\n+                                New_Occurrence_Of\n+                                  (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+                            Attribute_Name => Name_Address))));\n+               end if;\n+\n+               --  Secondary dispatch table referencing thunks to predefined\n+               --  primitives.\n+\n+               Iface_DT_Ptr :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Typ_Name, 'Y'));\n+               Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n+               Set_Ekind (Iface_DT_Ptr, E_Constant);\n+               Set_Is_Tag (Iface_DT_Ptr);\n+               Set_Has_Thunks (Iface_DT_Ptr);\n+               Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+                 Is_Library_Level_Tagged_Type (Typ));\n+               Set_Is_True_Constant (Iface_DT_Ptr);\n+               Set_Related_Type\n+                 (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+               --  Secondary dispatch table referencing user-defined primitives\n+               --  covered by this interface.\n+\n+               Iface_DT_Ptr :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Typ_Name, 'D'));\n+               Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n+               Set_Ekind (Iface_DT_Ptr, E_Constant);\n+               Set_Is_Tag (Iface_DT_Ptr);\n+               Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+                 Is_Library_Level_Tagged_Type (Typ));\n+               Set_Is_True_Constant (Iface_DT_Ptr);\n+               Set_Related_Type\n+                 (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+               --  Secondary dispatch table referencing predefined primitives\n+\n+               Iface_DT_Ptr :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Typ_Name, 'Z'));\n+               Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n+               Set_Ekind (Iface_DT_Ptr, E_Constant);\n+               Set_Is_Tag (Iface_DT_Ptr);\n+               Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+                 Is_Library_Level_Tagged_Type (Typ));\n+               Set_Is_True_Constant (Iface_DT_Ptr);\n+               Set_Related_Type\n+                 (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+               Next_Elmt (AI_Tag_Comp);\n+            end loop;\n+         end if;\n       end if;\n \n       --  3) At the end of Access_Disp_Table, if the type has user-defined\n@@ -6479,6 +6639,13 @@ package body Exp_Disp is\n             Analyze_List (Result);\n             Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n \n+            --  Add the freezing nodes of these declarations; required to avoid\n+            --  generating these freezing nodes in wrong scopes (for example in\n+            --  the IC routine of a derivation of Typ).\n+\n+            Append_List_To (Result, Freeze_Entity (DT_Prims, Loc));\n+            Append_List_To (Result, Freeze_Entity (DT_Prims_Acc, Loc));\n+\n             --  Mark entity of dispatch table. Required by the back end to\n             --  handle them properly.\n \n@@ -6499,7 +6666,12 @@ package body Exp_Disp is\n          Set_Is_Dispatch_Table_Entity (Etype (Iface_DT));\n       end if;\n \n-      Set_Ekind        (DT_Ptr, E_Constant);\n+      if Is_CPP_Class (Root_Type (Typ)) then\n+         Set_Ekind (DT_Ptr, E_Variable);\n+      else\n+         Set_Ekind (DT_Ptr, E_Constant);\n+      end if;\n+\n       Set_Is_Tag       (DT_Ptr);\n       Set_Related_Type (DT_Ptr, Typ);\n \n@@ -6704,17 +6876,24 @@ package body Exp_Disp is\n          else\n             pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n-            DT_Ptr := Node (First_Elmt (Access_Disp_Table (Tag_Typ)));\n-            Append_To (L,\n-              Build_Set_Prim_Op_Address (Loc,\n-                Typ          => Tag_Typ,\n-                Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n-                Position     => Pos,\n-                Address_Node =>\n-                  Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (Prim, Loc),\n-                      Attribute_Name => Name_Unrestricted_Access))));\n+            --  Skip registration of primitives located in the C++ part of the\n+            --  dispatch table. Their slot is set by the IC routine.\n+\n+            if not Is_CPP_Class (Root_Type (Tag_Typ))\n+              or else Pos > CPP_Num_Prims (Tag_Typ)\n+            then\n+               DT_Ptr := Node (First_Elmt (Access_Disp_Table (Tag_Typ)));\n+               Append_To (L,\n+                 Build_Set_Prim_Op_Address (Loc,\n+                   Typ          => Tag_Typ,\n+                   Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n+                   Position     => Pos,\n+                   Address_Node =>\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Prim, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access))));\n+            end if;\n          end if;\n \n       --  Ada 2005 (AI-251): Primitive associated with an interface type\n@@ -6734,6 +6913,16 @@ package body Exp_Disp is\n \n          if Is_Ancestor (Iface_Typ, Tag_Typ) then\n             return L;\n+\n+         --  No action needed for primitives located in the C++ part of the\n+         --  dispatch table. Their slot is set by the IC routine.\n+\n+         elsif Is_CPP_Class (Root_Type (Tag_Typ))\n+            and then DT_Position (Alias (Prim)) <= CPP_Num_Prims (Tag_Typ)\n+            and then not Is_Predefined_Dispatching_Operation (Prim)\n+            and then not Is_Predefined_Dispatching_Alias (Prim)\n+         then\n+            return L;\n          end if;\n \n          Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n@@ -7327,31 +7516,132 @@ package body Exp_Disp is\n    --------------------------\n \n    procedure Set_CPP_Constructors (Typ : Entity_Id) is\n+\n+      procedure Set_CPP_Constructors_Old (Typ : Entity_Id);\n+      --  For backward compatibility this routine handles CPP constructors\n+      --  of non-tagged types.\n+\n+      procedure Set_CPP_Constructors_Old (Typ : Entity_Id) is\n+         Loc   : Source_Ptr;\n+         Init  : Entity_Id;\n+         E     : Entity_Id;\n+         Found : Boolean := False;\n+         P     : Node_Id;\n+         Parms : List_Id;\n+\n+      begin\n+         --  Look for the constructor entities\n+\n+         E := Next_Entity (Typ);\n+         while Present (E) loop\n+            if Ekind (E) = E_Function\n+              and then Is_Constructor (E)\n+            then\n+               --  Create the init procedure\n+\n+               Found := True;\n+               Loc   := Sloc (E);\n+               Init  := Make_Defining_Identifier (Loc,\n+                          Make_Init_Proc_Name (Typ));\n+               Parms :=\n+                 New_List (\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier =>\n+                       Make_Defining_Identifier (Loc, Name_X),\n+                     Parameter_Type =>\n+                       New_Reference_To (Typ, Loc)));\n+\n+               if Present (Parameter_Specifications (Parent (E))) then\n+                  P := First (Parameter_Specifications (Parent (E)));\n+                  while Present (P) loop\n+                     Append_To (Parms,\n+                       Make_Parameter_Specification (Loc,\n+                         Defining_Identifier =>\n+                           Make_Defining_Identifier (Loc,\n+                             Chars (Defining_Identifier (P))),\n+                         Parameter_Type =>\n+                           New_Copy_Tree (Parameter_Type (P))));\n+                     Next (P);\n+                  end loop;\n+               end if;\n+\n+               Discard_Node (\n+                 Make_Subprogram_Declaration (Loc,\n+                   Make_Procedure_Specification (Loc,\n+                     Defining_Unit_Name => Init,\n+                     Parameter_Specifications => Parms)));\n+\n+               Set_Init_Proc (Typ, Init);\n+               Set_Is_Imported    (Init);\n+               Set_Interface_Name (Init, Interface_Name (E));\n+               Set_Convention     (Init, Convention_C);\n+               Set_Is_Public      (Init);\n+               Set_Has_Completion (Init);\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+\n+         --  If there are no constructors, mark the type as abstract since we\n+         --  won't be able to declare objects of that type.\n+\n+         if not Found then\n+            Set_Is_Abstract_Type (Typ);\n+         end if;\n+      end Set_CPP_Constructors_Old;\n+\n+      --  Local variables\n+\n       Loc   : Source_Ptr;\n-      Init  : Entity_Id;\n       E     : Entity_Id;\n       Found : Boolean := False;\n       P     : Node_Id;\n       Parms : List_Id;\n \n+      Constructor_Decl_Node : Node_Id;\n+      Constructor_Id        : Entity_Id;\n+      Wrapper_Id            : Entity_Id;\n+      Wrapper_Body_Node     : Node_Id;\n+      Actuals               : List_Id;\n+      Body_Stmts            : List_Id;\n+      Init_Tags_List        : List_Id;\n+\n    begin\n+      pragma Assert (Is_CPP_Class (Typ));\n+\n+      --  For backward compatibility the compiler accepts C++ classes\n+      --  imported through non-tagged record types. In such case the\n+      --  wrapper of the C++ constructor is useless because the _tag\n+      --  component is not available.\n+\n+      --  Example:\n+      --     type Root is limited record ...\n+      --     pragma Import (CPP, Root);\n+      --     function New_Root return Root;\n+      --     pragma CPP_Constructor (New_Root, ... );\n+\n+      if not Is_Tagged_Type (Typ) then\n+         Set_CPP_Constructors_Old (Typ);\n+         return;\n+      end if;\n+\n       --  Look for the constructor entities\n \n       E := Next_Entity (Typ);\n       while Present (E) loop\n          if Ekind (E) = E_Function\n            and then Is_Constructor (E)\n          then\n-            --  Create the init procedure\n-\n             Found := True;\n             Loc   := Sloc (E);\n-            Init  := Make_Defining_Identifier (Loc, Make_Init_Proc_Name (Typ));\n+\n+            --  Generate the declaration of the imported C++ constructor\n+\n             Parms :=\n               New_List (\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_X),\n+                    Make_Defining_Identifier (Loc, Name_uInit),\n                   Parameter_Type =>\n                     New_Reference_To (Typ, Loc)));\n \n@@ -7368,18 +7658,128 @@ package body Exp_Disp is\n                end loop;\n             end if;\n \n-            Discard_Node (\n+            Constructor_Id := Make_Temporary (Loc, 'P');\n+\n+            Constructor_Decl_Node :=\n               Make_Subprogram_Declaration (Loc,\n                 Make_Procedure_Specification (Loc,\n-                  Defining_Unit_Name => Init,\n-                  Parameter_Specifications => Parms)));\n-\n-            Set_Init_Proc (Typ, Init);\n-            Set_Is_Imported    (Init);\n-            Set_Interface_Name (Init, Interface_Name (E));\n-            Set_Convention     (Init, Convention_C);\n-            Set_Is_Public      (Init);\n-            Set_Has_Completion (Init);\n+                  Defining_Unit_Name => Constructor_Id,\n+                  Parameter_Specifications => Parms));\n+\n+            Set_Is_Imported    (Constructor_Id);\n+            Set_Interface_Name (Constructor_Id, Interface_Name (E));\n+            Set_Convention     (Constructor_Id, Convention_C);\n+            Set_Is_Public      (Constructor_Id);\n+            Set_Has_Completion (Constructor_Id);\n+\n+            --  Build the wrapper of this constructor\n+\n+            Parms :=\n+              New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier =>\n+                    Make_Defining_Identifier (Loc, Name_uInit),\n+                  Parameter_Type =>\n+                    New_Reference_To (Typ, Loc)));\n+\n+            if Present (Parameter_Specifications (Parent (E))) then\n+               P := First (Parameter_Specifications (Parent (E)));\n+               while Present (P) loop\n+                  Append_To (Parms,\n+                    Make_Parameter_Specification (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars (Defining_Identifier (P))),\n+                      Parameter_Type => New_Copy_Tree (Parameter_Type (P))));\n+                  Next (P);\n+               end loop;\n+            end if;\n+\n+            Body_Stmts := New_List;\n+\n+            --  Invoke the C++ constructor\n+\n+            Actuals := New_List;\n+\n+            P := First (Parms);\n+            while Present (P) loop\n+               Append_To (Actuals,\n+                 New_Reference_To (Defining_Identifier (P), Loc));\n+               Next (P);\n+            end loop;\n+\n+            Append_To (Body_Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (Constructor_Id, Loc),\n+                Parameter_Associations => Actuals));\n+\n+            --  Initialize copies of C++ primary and secondary tags\n+\n+            Init_Tags_List := New_List;\n+\n+            declare\n+               Tag_Elmt : Elmt_Id;\n+               Tag_Comp : Node_Id;\n+\n+            begin\n+               Tag_Elmt := First_Elmt (Access_Disp_Table (Typ));\n+               Tag_Comp := First_Tag_Component (Typ);\n+\n+               while Present (Tag_Elmt)\n+                 and then Is_Tag (Node (Tag_Elmt))\n+               loop\n+                  --  Skip the following assertion with primary tags because\n+                  --  Related_Type is not set on primary tag components\n+\n+                  pragma Assert (Tag_Comp = First_Tag_Component (Typ)\n+                    or else Related_Type (Node (Tag_Elmt))\n+                              = Related_Type (Tag_Comp));\n+\n+                  Append_To (Init_Tags_List,\n+                    Make_Assignment_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (Node (Tag_Elmt), Loc),\n+                      Expression =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => Make_Identifier (Loc, Name_uInit),\n+                          Selector_Name =>\n+                            New_Reference_To (Tag_Comp, Loc))));\n+\n+                     Tag_Comp := Next_Tag_Component (Tag_Comp);\n+                  Next_Elmt (Tag_Elmt);\n+               end loop;\n+            end;\n+\n+            Append_To (Body_Stmts,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Op_Eq (Loc,\n+                    Left_Opnd =>\n+                      New_Reference_To\n+                        (Node (First_Elmt (Access_Disp_Table (Typ))),\n+                         Loc),\n+                    Right_Opnd =>\n+                      Unchecked_Convert_To (RTE (RE_Tag),\n+                        New_Reference_To (RTE (RE_Null_Address), Loc))),\n+                Then_Statements => Init_Tags_List));\n+\n+            Wrapper_Id := Make_Defining_Identifier (Loc,\n+                            Make_Init_Proc_Name (Typ));\n+\n+            Wrapper_Body_Node :=\n+              Make_Subprogram_Body (Loc,\n+                Specification =>\n+                  Make_Procedure_Specification (Loc,\n+                    Defining_Unit_Name => Wrapper_Id,\n+                    Parameter_Specifications => Parms),\n+                Declarations => New_List (Constructor_Decl_Node),\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => Body_Stmts,\n+                    Exception_Handlers => No_List));\n+\n+            Discard_Node (Wrapper_Body_Node);\n+            Set_Init_Proc (Typ, Wrapper_Id);\n          end if;\n \n          Next_Entity (E);\n@@ -7391,6 +7791,17 @@ package body Exp_Disp is\n       if not Found then\n          Set_Is_Abstract_Type (Typ);\n       end if;\n+\n+      --  If the CPP type has constructors then it must import also the default\n+      --  C++ constructor. It is required for default initialization of objects\n+      --  of the type. It is also required to elaborate objects of Ada types\n+      --  that are defined as derivations of this CPP type.\n+\n+      if Has_CPP_Constructors (Typ)\n+        and then No (Init_Proc (Typ))\n+      then\n+         Error_Msg_N (\"?default constructor must be imported from C++\", Typ);\n+      end if;\n    end Set_CPP_Constructors;\n \n    --------------------------\n@@ -7586,6 +7997,12 @@ package body Exp_Disp is\n             Write_Str (\" (eliminated)\");\n          end if;\n \n+         if Is_Imported (Prim)\n+           and then Convention (Prim) = Convention_CPP\n+         then\n+            Write_Str (\" (C++)\");\n+         end if;\n+\n          Write_Eol;\n \n          Next_Elmt (Elmt);"}, {"sha": "5c3796ba410d6ffd13c9979eba9feb3fe1eea0f5", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -186,6 +186,10 @@ package Exp_Disp is\n    --  bodies they are added to the end of the list of declarations of the\n    --  package body.\n \n+   function CPP_Num_Prims (Typ : Entity_Id) return Nat;\n+   --  Return the number of primitives of the C++ part of the dispatch table.\n+   --  For types that are not derivations of CPP types return 0.\n+\n    procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n    --  the required tag checks when appropriate. For CPP types tag checks are\n@@ -215,6 +219,9 @@ package Exp_Disp is\n    --  Otherwise they are set to the defining identifier and the subprogram\n    --  body of the generated thunk.\n \n+   function Has_CPP_Constructors (Typ : Entity_Id) return Boolean;\n+   --  Returns true if the type has CPP constructors\n+\n    function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n "}, {"sha": "8b19f9190dbae4bdc851b937f0f8387326cb507b", "filename": "gcc/ada/exp_tss.adb", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -109,6 +109,35 @@ package body Exp_Tss is\n       Prepend_Elmt (TSS, TSS_Elist (FN));\n    end Copy_TSS;\n \n+   -------------------\n+   -- CPP_Init_Proc --\n+   -------------------\n+\n+   function CPP_Init_Proc (Typ  : Entity_Id) return Entity_Id is\n+      FN   : constant Node_Id := Freeze_Node (Typ);\n+      Elmt : Elmt_Id;\n+\n+   begin\n+      if not Is_CPP_Class (Root_Type (Typ))\n+        or else No (FN)\n+        or else No (TSS_Elist (FN))\n+      then\n+         return Empty;\n+\n+      else\n+         Elmt := First_Elmt (TSS_Elist (FN));\n+         while Present (Elmt) loop\n+            if Is_CPP_Init_Proc (Node (Elmt)) then\n+               return Node (Elmt);\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end CPP_Init_Proc;\n+\n    ------------------------\n    -- Find_Inherited_TSS --\n    ------------------------\n@@ -276,6 +305,18 @@ package body Exp_Tss is\n       return Empty;\n    end Init_Proc;\n \n+   ----------------------\n+   -- Is_CPP_Init_Proc --\n+   ----------------------\n+\n+   function Is_CPP_Init_Proc (E : Entity_Id) return Boolean is\n+      C1 : Character;\n+      C2 : Character;\n+   begin\n+      Get_Last_Two_Chars (Chars (E), C1, C2);\n+      return C1 = TSS_CPP_Init_Proc (1) and then C2 = TSS_CPP_Init_Proc (2);\n+   end Is_CPP_Init_Proc;\n+\n    ------------------\n    -- Is_Init_Proc --\n    ------------------\n@@ -393,7 +434,7 @@ package body Exp_Tss is\n       --  Skip this for Init_Proc with No_Default_Initialization, since the\n       --  Init proc is a dummy void entity in this case to be ignored.\n \n-      if Is_Init_Proc (TSS)\n+      if (Is_Init_Proc (TSS) or else Is_CPP_Init_Proc (TSS))\n         and then Restriction_Active (No_Default_Initialization)\n       then\n          null;"}, {"sha": "d6a18fb1bfe6761575f0e9f6216937057d270808", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -84,6 +84,7 @@ package Exp_Tss is\n    TSS_Composite_Equality : constant TNT := \"EQ\";  -- Composite Equality\n    TSS_From_Any           : constant TNT := \"FA\";  -- PolyORB/DSA From_Any\n    TSS_Init_Proc          : constant TNT := \"IP\";  -- Initialization Procedure\n+   TSS_CPP_Init_Proc      : constant TNT := \"IC\";  -- Init C++ dispatch tables\n    TSS_RAS_Access         : constant TNT := \"RA\";  -- RAS type access\n    TSS_RAS_Dereference    : constant TNT := \"RD\";  -- RAS type dereference\n    TSS_Rep_To_Pos         : constant TNT := \"RP\";  -- Rep to Pos conversion\n@@ -104,6 +105,7 @@ package Exp_Tss is\n       TSS_Composite_Equality,\n       TSS_From_Any,\n       TSS_Init_Proc,\n+      TSS_CPP_Init_Proc,\n       TSS_RAS_Access,\n       TSS_RAS_Dereference,\n       TSS_Rep_To_Pos,\n@@ -140,15 +142,18 @@ package Exp_Tss is\n    function Make_Init_Proc_Name (Typ : Entity_Id) return Name_Id;\n    --  Version for init procs, same as Make_TSS_Name (Typ, TSS_Init_Proc)\n \n+   function Is_CPP_Init_Proc (E : Entity_Id) return Boolean;\n+   --  Version for CPP init procs, same as Is_TSS (E, TSS_CPP_Init_Proc);\n+\n+   function Is_Init_Proc (E : Entity_Id) return Boolean;\n+   --  Version for init procs, same as Is_TSS (E, TSS_Init_Proc);\n+\n    function Is_TSS (E : Entity_Id; Nam : TSS_Name_Type) return Boolean;\n    --  Determines if given entity (E) is the name of a TSS identified by Nam\n \n    function Is_TSS (N : Name_Id; Nam : TSS_Name_Type) return Boolean;\n    --  Same test applied directly to a Name_Id value\n \n-   function Is_Init_Proc (E : Entity_Id) return Boolean;\n-   --  Version for init procs, same as Is_TSS (E, TSS_Init_Proc);\n-\n    -----------------------------------------\n    -- TSS Data structures and Subprograms --\n    -----------------------------------------\n@@ -188,6 +193,11 @@ package Exp_Tss is\n    --  used to initially install a TSS in the case where the subprogram for the\n    --  TSS has already been created and its declaration processed.\n \n+   function CPP_Init_Proc (Typ : Entity_Id) return Entity_Id;\n+   --  Obtains the CPP_Init TSS entity the given type. The CPP_Init TSS is a\n+   --  procedure used to initialize the C++ part of the primary and secondary\n+   --  dispatch tables of a tagged type derived from CPP types.\n+\n    function Init_Proc\n      (Typ : Entity_Id;\n       Ref : Entity_Id := Empty) return Entity_Id;"}, {"sha": "81dab28d30ec58ef09ff89bbed48d2ecb00c2c6a", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -175,7 +175,7 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n-   function  Is_Atomic_Aggregate\n+   function Is_Atomic_Aggregate\n      (E   : Entity_Id;\n       Typ : Entity_Id) return Boolean;\n "}, {"sha": "1cb612d2a7a2c5801a521fc8ddceb97904bb6d13", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -1765,11 +1765,11 @@ ada/exp_ch11.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n    ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n    ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/exp_ch12.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n@@ -1845,13 +1845,13 @@ ada/exp_ch3.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n    ada/stand.ads ada/stringt.ads ada/system.ads ada/s-exctab.ads \\\n    ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/validsw.ads \n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \n \n ada/exp_ch4.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -1973,12 +1973,13 @@ ada/exp_ch7.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n    ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n    ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n-   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/validsw.ads \n \n ada/exp_ch8.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2249,11 +2250,11 @@ ada/exp_prag.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sinput.adb ada/snames.ads ada/snames.adb ada/stand.ads \\\n    ada/stringt.ads ada/stringt.adb ada/system.ads ada/s-exctab.ads \\\n    ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/exp_sel.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n@@ -2476,13 +2477,13 @@ ada/frontend.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n    ada/system.ads ada/s-crc32.ads ada/s-crc32.adb ada/s-exctab.ads \\\n    ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/widechar.ads \n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/g-byorma.o : ada/gnat.ads ada/g-byorma.ads ada/g-byorma.adb \\\n    ada/system.ads \n@@ -2996,18 +2997,19 @@ ada/restrict.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/casing.ads ada/debug.ads ada/einfo.ads ada/einfo.adb \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/fname.ads \\\n    ada/fname-uf.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n-   ada/hostparm.ads ada/lib.ads ada/lib.adb ada/lib-list.adb \\\n-   ada/lib-sort.adb ada/namet.ads ada/nlists.ads ada/nlists.adb \\\n-   ada/opt.ads ada/output.ads ada/restrict.ads ada/restrict.adb \\\n-   ada/rident.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/sinput.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/hostparm.ads ada/interfac.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-sort.adb ada/namet.ads ada/namet.adb \\\n+   ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/restrict.adb ada/rident.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/snames.ads \\\n+   ada/stand.ads ada/stringt.ads ada/system.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/widechar.ads \n \n ada/rident.o : ada/rident.ads ada/system.ads ada/s-rident.ads \n \n@@ -3302,33 +3304,33 @@ ada/sem_attr.o : ada/ada.ads ada/a-charac.ads ada/a-chlat1.ads \\\n    ada/exp_ch11.ads ada/exp_ch2.ads ada/exp_ch4.ads ada/exp_ch6.ads \\\n    ada/exp_ch7.ads ada/exp_disp.ads ada/exp_dist.ads ada/exp_pakd.ads \\\n    ada/exp_tss.ads ada/exp_util.ads ada/exp_util.adb ada/expander.ads \\\n-   ada/fname.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n-   ada/g-htable.ads ada/gnatvsn.ads ada/hostparm.ads ada/inline.ads \\\n-   ada/interfac.ads ada/itypes.ads ada/lib.ads ada/lib-xref.ads \\\n-   ada/namet.ads ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads \\\n-   ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n-   ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads \\\n-   ada/scng.adb ada/sdefault.ads ada/sem.ads ada/sem_aggr.ads \\\n-   ada/sem_attr.ads ada/sem_attr.adb ada/sem_aux.ads ada/sem_aux.adb \\\n-   ada/sem_cat.ads ada/sem_ch10.ads ada/sem_ch13.ads ada/sem_ch3.ads \\\n-   ada/sem_ch4.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n-   ada/sem_dist.ads ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads \\\n-   ada/sem_eval.adb ada/sem_intr.ads ada/sem_res.ads ada/sem_res.adb \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/sinput.adb \\\n-   ada/snames.ads ada/snames.adb ada/sprint.ads ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n-   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypef.ads ada/ttypes.ads \\\n-   ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n-   ada/validsw.ads ada/widechar.ads \n+   ada/fname.ads ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads \\\n+   ada/gnat.ads ada/g-htable.ads ada/gnatvsn.ads ada/hostparm.ads \\\n+   ada/inline.ads ada/interfac.ads ada/itypes.ads ada/lib.ads \\\n+   ada/lib-xref.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/restrict.adb ada/rident.ads ada/rtsfind.ads \\\n+   ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sdefault.ads \\\n+   ada/sem.ads ada/sem_aggr.ads ada/sem_attr.ads ada/sem_attr.adb \\\n+   ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads ada/sem_ch10.ads \\\n+   ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch4.ads ada/sem_ch6.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_elab.ads \\\n+   ada/sem_elim.ads ada/sem_eval.ads ada/sem_eval.adb ada/sem_intr.ads \\\n+   ada/sem_res.ads ada/sem_res.adb ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n+   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/snames.adb \\\n+   ada/sprint.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n+   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n+   ada/system.ads ada/s-carun8.ads ada/s-crc32.ads ada/s-exctab.ads \\\n+   ada/s-exctab.adb ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypef.ads ada/ttypes.ads ada/types.ads ada/types.adb ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/urealp.adb ada/validsw.ads ada/widechar.ads \n \n ada/sem_aux.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -3399,23 +3401,24 @@ ada/sem_ch10.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/lib-load.ads ada/lib-sort.adb ada/lib-xref.ads ada/namet.ads \\\n    ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n    ada/opt.ads ada/output.ads ada/par_sco.ads ada/restrict.ads \\\n-   ada/rident.ads ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads \\\n-   ada/scng.adb ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads \\\n-   ada/sem_ch10.ads ada/sem_ch10.adb ada/sem_ch3.ads ada/sem_ch6.ads \\\n-   ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads \\\n-   ada/sem_eval.ads ada/sem_prag.ads ada/sem_res.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinfo-cn.ads ada/sinput.ads ada/sinput.adb \\\n-   ada/snames.ads ada/stand.ads ada/stringt.ads ada/style.ads \\\n-   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n-   ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tree_io.ads \\\n-   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/restrict.adb ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n+   ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_attr.ads \\\n+   ada/sem_aux.ads ada/sem_ch10.ads ada/sem_ch10.adb ada/sem_ch3.ads \\\n+   ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n+   ada/sem_dist.ads ada/sem_eval.ads ada/sem_prag.ads ada/sem_res.ads \\\n+   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n+   ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads ada/sinput.ads \\\n+   ada/sinput.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\\n+   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n+   ada/system.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/widechar.ads \n \n ada/sem_ch11.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\"}, {"sha": "35f5717b3ccb9a28543869af2065a807df1640df", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -2417,6 +2417,36 @@ package body Sem_Aggr is\n                Error_Msg_N\n                  (\"type of limited ancestor part must be constrained\", A);\n \n+            --  Reject the use of CPP constructors that leave objects partially\n+            --  initialized. For example:\n+\n+            --    type CPP_Root is tagged limited record ...\n+            --    pragma Import (CPP, CPP_Root);\n+\n+            --    type CPP_DT is new CPP_Root and Iface ...\n+            --    pragma Import (CPP, CPP_DT);\n+\n+            --    type Ada_DT is new CPP_DT with ...\n+\n+            --    Obj : Ada_DT := Ada_DT'(New_CPP_Root with others => <>);\n+\n+            --  Using the constructor of CPP_Root the slots of the dispatch\n+            --  table of CPP_DT cannot be set, and the secondary tag of\n+            --  CPP_DT is unknown.\n+\n+            elsif Nkind (A) = N_Function_Call\n+              and then Is_CPP_Constructor_Call (A)\n+              and then Enclosing_CPP_Parent (Typ) /= A_Type\n+            then\n+               Error_Msg_NE\n+                 (\"?must use 'C'P'P constructor for type &\", A,\n+                  Enclosing_CPP_Parent (Typ));\n+\n+               --  The following call is not needed if the previous warning\n+               --  is promoted to an error.\n+\n+               Resolve_Record_Aggregate (N, Typ);\n+\n             elsif Is_Class_Wide_Type (Etype (A))\n               and then Nkind (Original_Node (A)) = N_Function_Call\n             then"}, {"sha": "93473732d8dd86778ec17bb1a1acc7eedca18d58", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -697,6 +697,12 @@ package body Sem_Attr is\n                        (\"current instance attribute must appear alone\", N);\n                   end if;\n \n+                  if Is_CPP_Class (Root_Type (Typ)) then\n+                     Error_Msg_N\n+                       (\"?current instance unsupported for derivations of \"\n+                        & \"'C'P'P types\", N);\n+                  end if;\n+\n                --  OK if we are in initialization procedure for the type\n                --  in question, in which case the reference to the type\n                --  is rewritten as a reference to the current object."}, {"sha": "67a913919e3c9721cf690806daeb4d6dbc48d7ad", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n@@ -2385,6 +2387,70 @@ package body Sem_Ch13 is\n \n          Add_Internal_Interface_Entities (E);\n       end if;\n+\n+      --  Check CPP types\n+\n+      if Ekind (E) = E_Record_Type\n+        and then Is_CPP_Class (E)\n+        and then Is_Tagged_Type (E)\n+        and then Tagged_Type_Expansion\n+        and then Expander_Active\n+      then\n+         if CPP_Num_Prims (E) = 0 then\n+\n+            --  If the CPP type has user defined components then it must import\n+            --  primitives from C++. This is required because if the C++ class\n+            --  has no primitives then the C++ compiler does not added the _tag\n+            --  component to the type.\n+\n+            pragma Assert (Chars (First_Entity (E)) = Name_uTag);\n+\n+            if First_Entity (E) /= Last_Entity (E) then\n+               Error_Msg_N\n+                 (\"?'C'P'P type must import at least one primitive from C++\",\n+                  E);\n+            end if;\n+         end if;\n+\n+         --  Check that all its primitives are abstract or imported from C++.\n+         --  Check also availability of the C++ constructor.\n+\n+         declare\n+            Has_Constructors : constant Boolean := Has_CPP_Constructors (E);\n+            Elmt             : Elmt_Id;\n+            Error_Reported   : Boolean := False;\n+            Prim             : Node_Id;\n+\n+         begin\n+            Elmt := First_Elmt (Primitive_Operations (E));\n+            while Present (Elmt) loop\n+               Prim := Node (Elmt);\n+\n+               if Comes_From_Source (Prim) then\n+                  if Is_Abstract_Subprogram (Prim) then\n+                     null;\n+\n+                  elsif not Is_Imported (Prim)\n+                    or else Convention (Prim) /= Convention_CPP\n+                  then\n+                     Error_Msg_N\n+                       (\"?primitives of 'C'P'P types must be imported from C++\"\n+                        & \" or abstract\", Prim);\n+\n+                  elsif not Has_Constructors\n+                     and then not Error_Reported\n+                  then\n+                     Error_Msg_Name_1 := Chars (E);\n+                     Error_Msg_N\n+                       (\"?'C'P'P constructor required for type %\", Prim);\n+                     Error_Reported := True;\n+                  end if;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end;\n+      end if;\n    end Analyze_Freeze_Entity;\n \n    ------------------------------------------"}, {"sha": "15995b8f416103d086966a4541740c9237f9ddf8", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -513,6 +513,7 @@ package body Sem_Ch8 is\n \n    procedure Write_Scopes;\n    pragma Warnings (Off, Write_Scopes);\n+   pragma Export (Ada, Write_Scopes);\n    --  Debugging information: dump all entities on scope stack\n \n    --------------------------------"}, {"sha": "08b0087a6cd1fb55c4cfc2b3b8befc257bfd174f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -6554,6 +6554,14 @@ package body Sem_Prag is\n \n             Def_Id := Entity (Id);\n \n+            --  Check if already defined as constructor\n+\n+            if Is_Constructor (Def_Id) then\n+               Error_Msg_N\n+                 (\"?duplicate argument for pragma 'C'P'P_Constructor\", Arg1);\n+               return;\n+            end if;\n+\n             if Ekind (Def_Id) = E_Function\n               and then (Is_CPP_Class (Etype (Def_Id))\n                          or else (Is_Class_Wide_Type (Etype (Def_Id))"}, {"sha": "156d24762d6cda5e48e08265b1be938912e0bad4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -1564,22 +1564,48 @@ package body Sem_Util is\n \n       function Search_Tag (Iface : Entity_Id) return Entity_Id is\n          ADT : Elmt_Id;\n-\n       begin\n-         ADT := Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (T))));\n+         if not Is_CPP_Class (T) then\n+            ADT := Next_Elmt (Next_Elmt (First_Elmt (Access_Disp_Table (T))));\n+         else\n+            ADT := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n+         end if;\n+\n          while Present (ADT)\n-            and then Ekind (Node (ADT)) = E_Constant\n+            and then Is_Tag (Node (ADT))\n             and then Related_Type (Node (ADT)) /= Iface\n          loop\n-            --  Skip the secondary dispatch tables of Iface\n+            --  Skip secondary dispatch table referencing thunks to user\n+            --  defined primitives covered by this interface.\n \n+            pragma Assert (Has_Suffix (Node (ADT), 'P'));\n             Next_Elmt (ADT);\n-            Next_Elmt (ADT);\n-            Next_Elmt (ADT);\n-            Next_Elmt (ADT);\n+\n+            --  Skip secondary dispatch tables of Ada types\n+\n+            if not Is_CPP_Class (T) then\n+\n+               --  Skip secondary dispatch table referencing thunks to\n+               --  predefined primitives.\n+\n+               pragma Assert (Has_Suffix (Node (ADT), 'Y'));\n+               Next_Elmt (ADT);\n+\n+               --  Skip secondary dispatch table referencing user-defined\n+               --  primitives covered by this interface.\n+\n+               pragma Assert (Has_Suffix (Node (ADT), 'D'));\n+               Next_Elmt (ADT);\n+\n+               --  Skip secondary dispatch table referencing predefined\n+               --  primitives\n+\n+               pragma Assert (Has_Suffix (Node (ADT), 'Z'));\n+               Next_Elmt (ADT);\n+            end if;\n          end loop;\n \n-         pragma Assert (Ekind (Node (ADT)) = E_Constant);\n+         pragma Assert (Is_Tag (Node (ADT)));\n          return Node (ADT);\n       end Search_Tag;\n \n@@ -2499,6 +2525,28 @@ package body Sem_Util is\n       end if;\n    end Designate_Same_Unit;\n \n+   --------------------------\n+   -- Enclosing_CPP_Parent --\n+   --------------------------\n+\n+   function Enclosing_CPP_Parent (Typ : Entity_Id) return Entity_Id is\n+      Parent_Typ : Entity_Id := Typ;\n+\n+   begin\n+      while not Is_CPP_Class (Parent_Typ)\n+         and then Etype (Parent_Typ) /= Parent_Typ\n+      loop\n+         Parent_Typ := Etype (Parent_Typ);\n+\n+         if Is_Private_Type (Parent_Typ) then\n+            Parent_Typ := Full_View (Base_Type (Parent_Typ));\n+         end if;\n+      end loop;\n+\n+      pragma Assert (Is_CPP_Class (Parent_Typ));\n+      return Parent_Typ;\n+   end Enclosing_CPP_Parent;\n+\n    ----------------------------\n    -- Enclosing_Generic_Body --\n    ----------------------------\n@@ -5208,6 +5256,16 @@ package body Sem_Util is\n       end if;\n    end Has_Stream;\n \n+   ----------------\n+   -- Has_Suffix --\n+   ----------------\n+\n+   function Has_Suffix (E : Entity_Id; Suffix : Character) return Boolean is\n+   begin\n+      Get_Name_String (Chars (E));\n+      return Name_Buffer (Name_Len) = Suffix;\n+   end Has_Suffix;\n+\n    --------------------------\n    -- Has_Tagged_Component --\n    --------------------------"}, {"sha": "80eaf9c62b1fcbd8d79a2065c178871e8e7bef6b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cefce34c6701df7ddd07ece4874465f9049b812c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=cefce34c6701df7ddd07ece4874465f9049b812c", "patch": "@@ -279,6 +279,9 @@ package Sem_Util is\n    --  these names is supposed to be a selected component name, an expanded\n    --  name, a defining program unit name or an identifier.\n \n+   function Enclosing_CPP_Parent (Typ : Entity_Id) return Entity_Id;\n+   --  Returns the closest ancestor of Typ that is a CPP type.\n+\n    function Enclosing_Generic_Body\n      (N : Node_Id) return Node_Id;\n    --  Returns the Node_Id associated with the innermost enclosing generic\n@@ -578,6 +581,9 @@ package Sem_Util is\n    --  applied to the underlying type (or returns False if there is no\n    --  underlying type).\n \n+   function Has_Suffix (E : Entity_Id; Suffix : Character) return Boolean;\n+   --  Returns true if the last character of E is Suffix. Used in Assertions.\n+\n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n    --  Returns True if Typ is a composite type (array or record) which is\n    --  either itself a tagged type, or has a component (recursively) which is"}]}