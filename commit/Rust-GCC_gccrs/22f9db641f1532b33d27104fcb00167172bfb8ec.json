{"sha": "22f9db641f1532b33d27104fcb00167172bfb8ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmOWRiNjQxZjE1MzJiMzNkMjcxMDRmY2IwMDE2NzE3MmJmYjhlYw==", "commit": {"author": {"name": "Charles Baylis", "email": "charles.baylis@linaro.org", "date": "2015-11-11T01:08:43Z"}, "committer": {"name": "Charles Baylis", "email": "cbaylis@gcc.gnu.org", "date": "2015-11-11T01:08:43Z"}, "message": "[ARM] PR63870 Mark lane indices of vldN/vstN with appropriate qualifier\n\n2015-11-11  Charles Baylis  <charles.baylis@linaro.org>\n\n\tPR target/63870\n\t* config/arm/arm-builtins.c: (arm_load1_qualifiers) Use\n\tqualifier_struct_load_store_lane_index.\n\t(arm_storestruct_lane_qualifiers) Likewise.\n\t* config/arm/neon.md: (neon_vld1_lane<mode>) Reverse lane numbers for\n\tbig-endian.\n\t(neon_vst1_lane<mode>) Likewise.\n\t(neon_vld2_lane<mode>) Likewise.\n\t(neon_vst2_lane<mode>) Likewise.\n\t(neon_vld3_lane<mode>) Likewise.\n\t(neon_vst3_lane<mode>) Likewise.\n\t(neon_vld4_lane<mode>) Likewise.\n\t(neon_vst4_lane<mode>) Likewise.\n\nFrom-SVN: r230143", "tree": {"sha": "7d478971f9d6629afd3be69e2dc854fd00a0d852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d478971f9d6629afd3be69e2dc854fd00a0d852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22f9db641f1532b33d27104fcb00167172bfb8ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22f9db641f1532b33d27104fcb00167172bfb8ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22f9db641f1532b33d27104fcb00167172bfb8ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22f9db641f1532b33d27104fcb00167172bfb8ec/comments", "author": null, "committer": null, "parents": [{"sha": "2f7d18ddd7f99fc8a67f13a2d97c1305bdcd05cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7d18ddd7f99fc8a67f13a2d97c1305bdcd05cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7d18ddd7f99fc8a67f13a2d97c1305bdcd05cc"}], "stats": {"total": 102, "additions": 77, "deletions": 25}, "files": [{"sha": "f0865eb5294a66e3de65979a6651f794a7939e32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22f9db641f1532b33d27104fcb00167172bfb8ec", "patch": "@@ -1,3 +1,19 @@\n+2015-11-11  Charles Baylis  <charles.baylis@linaro.org>\n+\n+\tPR target/63870\n+\t* config/arm/arm-builtins.c: (arm_load1_qualifiers) Use\n+\tqualifier_struct_load_store_lane_index.\n+\t(arm_storestruct_lane_qualifiers) Likewise.\n+\t* config/arm/neon.md: (neon_vld1_lane<mode>) Reverse lane numbers for\n+\tbig-endian.\n+\t(neon_vst1_lane<mode>) Likewise.\n+\t(neon_vld2_lane<mode>) Likewise.\n+\t(neon_vst2_lane<mode>) Likewise.\n+\t(neon_vld3_lane<mode>) Likewise.\n+\t(neon_vst3_lane<mode>) Likewise.\n+\t(neon_vld4_lane<mode>) Likewise.\n+\t(neon_vst4_lane<mode>) Likewise.\n+\n 2015-11-11  Charles Baylis  <charles.baylis@linaro.org>\n \n \tPR target/63870"}, {"sha": "f73afc269c3ea10739bd9cba3af9f069e71da839", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=22f9db641f1532b33d27104fcb00167172bfb8ec", "patch": "@@ -152,7 +152,7 @@ arm_load1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n static enum arm_type_qualifiers\n arm_load1_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_const_pointer_map_mode,\n-      qualifier_none, qualifier_immediate };\n+      qualifier_none, qualifier_struct_load_store_lane_index };\n #define LOAD1LANE_QUALIFIERS (arm_load1_lane_qualifiers)\n \n /* The first argument (return type) of a store should be void type,\n@@ -171,7 +171,7 @@ arm_store1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n static enum arm_type_qualifiers\n arm_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_void, qualifier_pointer_map_mode,\n-      qualifier_none, qualifier_immediate };\n+      qualifier_none, qualifier_struct_load_store_lane_index };\n #define STORE1LANE_QUALIFIERS (arm_storestruct_lane_qualifiers)\n \n #define v8qi_UP  V8QImode"}, {"sha": "c70e08a39aecc1947a9fd0b01cdc3129be5abd27", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22f9db641f1532b33d27104fcb00167172bfb8ec/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=22f9db641f1532b33d27104fcb00167172bfb8ec", "patch": "@@ -4253,6 +4253,9 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_load1_1reg<q>\")]\n )\n \n+;; The lane numbers in the RTL are in GCC lane order, having been flipped\n+;; in arm_expand_neon_args. The lane numbers are restored to architectural\n+;; lane order here.\n (define_insn \"neon_vld1_lane<mode>\"\n   [(set (match_operand:VDX 0 \"s_register_operand\" \"=w\")\n         (unspec:VDX [(match_operand:<V_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4261,8 +4264,9 @@ if (BYTES_BIG_ENDIAN)\n                     UNSPEC_VLD1_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n+  operands[3] = GEN_INT (lane);\n   if (lane < 0 || lane >= max)\n     error (\"lane out of range\");\n   if (max == 1)\n@@ -4273,6 +4277,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_load1_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld1_lane<mode>\"\n   [(set (match_operand:VQX 0 \"s_register_operand\" \"=w\")\n         (unspec:VQX [(match_operand:<V_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4281,8 +4287,9 @@ if (BYTES_BIG_ENDIAN)\n                     UNSPEC_VLD1_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n+  operands[3] = GEN_INT (lane);\n   int regno = REGNO (operands[0]);\n   if (lane < 0 || lane >= max)\n     error (\"lane out of range\");\n@@ -4359,6 +4366,8 @@ if (BYTES_BIG_ENDIAN)\n   \"vst1.<V_sz_elem>\\t%h1, %A0\"\n   [(set_attr \"type\" \"neon_store1_1reg<q>\")])\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst1_lane<mode>\"\n   [(set (match_operand:<V_elem> 0 \"neon_struct_operand\" \"=Um\")\n \t(unspec:<V_elem>\n@@ -4367,8 +4376,9 @@ if (BYTES_BIG_ENDIAN)\n \t  UNSPEC_VST1_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n+  operands[2] = GEN_INT (lane);\n   if (lane < 0 || lane >= max)\n     error (\"lane out of range\");\n   if (max == 1)\n@@ -4379,6 +4389,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_store1_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst1_lane<mode>\"\n   [(set (match_operand:<V_elem> 0 \"neon_struct_operand\" \"=Um\")\n \t(unspec:<V_elem>\n@@ -4387,7 +4399,7 @@ if (BYTES_BIG_ENDIAN)\n \t  UNSPEC_VST1_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   if (lane < 0 || lane >= max)\n@@ -4396,8 +4408,8 @@ if (BYTES_BIG_ENDIAN)\n     {\n       lane -= max / 2;\n       regno += 2;\n-      operands[2] = GEN_INT (lane);\n     }\n+  operands[2] = GEN_INT (lane);\n   operands[1] = gen_rtx_REG (<V_HALF>mode, regno);\n   if (max == 2)\n     return \"vst1.<V_sz_elem>\\t{%P1}, %A0\";\n@@ -4448,6 +4460,8 @@ if (BYTES_BIG_ENDIAN)\n   \"vld2.<V_sz_elem>\\t%h0, %A1\"\n   [(set_attr \"type\" \"neon_load2_2reg_q\")])\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld2_lane<mode>\"\n   [(set (match_operand:TI 0 \"s_register_operand\" \"=w\")\n         (unspec:TI [(match_operand:<V_two_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4457,7 +4471,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD2_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[4];\n@@ -4466,13 +4480,15 @@ if (BYTES_BIG_ENDIAN)\n   ops[0] = gen_rtx_REG (DImode, regno);\n   ops[1] = gen_rtx_REG (DImode, regno + 2);\n   ops[2] = operands[1];\n-  ops[3] = operands[3];\n+  ops[3] = GEN_INT (lane);\n   output_asm_insn (\"vld2.<V_sz_elem>\\t{%P0[%c3], %P1[%c3]}, %A2\", ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_load2_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld2_lane<mode>\"\n   [(set (match_operand:OI 0 \"s_register_operand\" \"=w\")\n         (unspec:OI [(match_operand:<V_two_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4482,7 +4498,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD2_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[4];\n@@ -4563,6 +4579,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_store2_4reg<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst2_lane<mode>\"\n   [(set (match_operand:<V_two_elem> 0 \"neon_struct_operand\" \"=Um\")\n \t(unspec:<V_two_elem>\n@@ -4572,7 +4590,7 @@ if (BYTES_BIG_ENDIAN)\n \t  UNSPEC_VST2_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[4];\n@@ -4581,13 +4599,15 @@ if (BYTES_BIG_ENDIAN)\n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (DImode, regno);\n   ops[2] = gen_rtx_REG (DImode, regno + 2);\n-  ops[3] = operands[2];\n+  ops[3] = GEN_INT (lane);\n   output_asm_insn (\"vst2.<V_sz_elem>\\t{%P1[%c3], %P2[%c3]}, %A0\", ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_store2_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst2_lane<mode>\"\n   [(set (match_operand:<V_two_elem> 0 \"neon_struct_operand\" \"=Um\")\n         (unspec:<V_two_elem>\n@@ -4597,7 +4617,7 @@ if (BYTES_BIG_ENDIAN)\n            UNSPEC_VST2_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[4];\n@@ -4707,6 +4727,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_load3_3reg<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld3_lane<mode>\"\n   [(set (match_operand:EI 0 \"s_register_operand\" \"=w\")\n         (unspec:EI [(match_operand:<V_three_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4716,7 +4738,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD3_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[5];\n@@ -4726,14 +4748,16 @@ if (BYTES_BIG_ENDIAN)\n   ops[1] = gen_rtx_REG (DImode, regno + 2);\n   ops[2] = gen_rtx_REG (DImode, regno + 4);\n   ops[3] = operands[1];\n-  ops[4] = operands[3];\n+  ops[4] = GEN_INT (lane);\n   output_asm_insn (\"vld3.<V_sz_elem>\\t{%P0[%c4], %P1[%c4], %P2[%c4]}, %3\",\n                    ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_load3_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld3_lane<mode>\"\n   [(set (match_operand:CI 0 \"s_register_operand\" \"=w\")\n         (unspec:CI [(match_operand:<V_three_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -4743,7 +4767,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD3_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[5];\n@@ -4879,6 +4903,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_store3_3reg<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst3_lane<mode>\"\n   [(set (match_operand:<V_three_elem> 0 \"neon_struct_operand\" \"=Um\")\n         (unspec:<V_three_elem>\n@@ -4888,7 +4914,7 @@ if (BYTES_BIG_ENDIAN)\n            UNSPEC_VST3_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[5];\n@@ -4898,14 +4924,16 @@ if (BYTES_BIG_ENDIAN)\n   ops[1] = gen_rtx_REG (DImode, regno);\n   ops[2] = gen_rtx_REG (DImode, regno + 2);\n   ops[3] = gen_rtx_REG (DImode, regno + 4);\n-  ops[4] = operands[2];\n+  ops[4] = GEN_INT (lane);\n   output_asm_insn (\"vst3.<V_sz_elem>\\t{%P1[%c4], %P2[%c4], %P3[%c4]}, %0\",\n                    ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_store3_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst3_lane<mode>\"\n   [(set (match_operand:<V_three_elem> 0 \"neon_struct_operand\" \"=Um\")\n         (unspec:<V_three_elem>\n@@ -4915,7 +4943,7 @@ if (BYTES_BIG_ENDIAN)\n            UNSPEC_VST3_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[5];\n@@ -5029,6 +5057,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_load4_4reg<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld4_lane<mode>\"\n   [(set (match_operand:OI 0 \"s_register_operand\" \"=w\")\n         (unspec:OI [(match_operand:<V_four_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -5038,7 +5068,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD4_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[6];\n@@ -5049,14 +5079,16 @@ if (BYTES_BIG_ENDIAN)\n   ops[2] = gen_rtx_REG (DImode, regno + 4);\n   ops[3] = gen_rtx_REG (DImode, regno + 6);\n   ops[4] = operands[1];\n-  ops[5] = operands[3];\n+  ops[5] = GEN_INT (lane);\n   output_asm_insn (\"vld4.<V_sz_elem>\\t{%P0[%c5], %P1[%c5], %P2[%c5], %P3[%c5]}, %A4\",\n                    ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_load4_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vld4_lane<mode>\"\n   [(set (match_operand:XI 0 \"s_register_operand\" \"=w\")\n         (unspec:XI [(match_operand:<V_four_elem> 1 \"neon_struct_operand\" \"Um\")\n@@ -5066,7 +5098,7 @@ if (BYTES_BIG_ENDIAN)\n                    UNSPEC_VLD4_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[3]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[3]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[0]);\n   rtx ops[6];\n@@ -5209,6 +5241,8 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_store4_4reg<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst4_lane<mode>\"\n   [(set (match_operand:<V_four_elem> 0 \"neon_struct_operand\" \"=Um\")\n         (unspec:<V_four_elem>\n@@ -5218,7 +5252,7 @@ if (BYTES_BIG_ENDIAN)\n            UNSPEC_VST4_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[6];\n@@ -5229,14 +5263,16 @@ if (BYTES_BIG_ENDIAN)\n   ops[2] = gen_rtx_REG (DImode, regno + 2);\n   ops[3] = gen_rtx_REG (DImode, regno + 4);\n   ops[4] = gen_rtx_REG (DImode, regno + 6);\n-  ops[5] = operands[2];\n+  ops[5] = GEN_INT (lane);\n   output_asm_insn (\"vst4.<V_sz_elem>\\t{%P1[%c5], %P2[%c5], %P3[%c5], %P4[%c5]}, %A0\",\n                    ops);\n   return \"\";\n }\n   [(set_attr \"type\" \"neon_store4_one_lane<q>\")]\n )\n \n+;; see comment on neon_vld1_lane for reason why the lane numbers are reversed\n+;; here on big endian targets.\n (define_insn \"neon_vst4_lane<mode>\"\n   [(set (match_operand:<V_four_elem> 0 \"neon_struct_operand\" \"=Um\")\n         (unspec:<V_four_elem>\n@@ -5246,7 +5282,7 @@ if (BYTES_BIG_ENDIAN)\n            UNSPEC_VST4_LANE))]\n   \"TARGET_NEON\"\n {\n-  HOST_WIDE_INT lane = INTVAL (operands[2]);\n+  HOST_WIDE_INT lane = NEON_ENDIAN_LANE_N(<MODE>mode, INTVAL (operands[2]));\n   HOST_WIDE_INT max = GET_MODE_NUNITS (<MODE>mode);\n   int regno = REGNO (operands[1]);\n   rtx ops[6];"}]}