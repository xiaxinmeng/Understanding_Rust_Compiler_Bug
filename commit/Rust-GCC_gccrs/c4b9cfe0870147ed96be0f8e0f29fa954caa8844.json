{"sha": "c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiOWNmZTA4NzAxNDdlZDk2YmUwZjhlMGYyOWZhOTU0Y2FhODg0NA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-30T11:54:36Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-30T11:54:36Z"}, "message": "backport: regex.c: Declare wcs functions only if compiling with MBS_SUPPORT.\n\nMerge from glibc:\n        * regex.c: Declare wcs functions only if compiling with\n        MBS_SUPPORT.\n        Don't use #elif for traditional C.\n\n        * regex.c: Revamp memory allocation for WCHAR functions to\n        not use too much stack.\n\nFrom-SVN: r44471", "tree": {"sha": "02f53b5bb5bf6bc03c905d61d5b9d8a978001d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02f53b5bb5bf6bc03c905d61d5b9d8a978001d2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b9cfe0870147ed96be0f8e0f29fa954caa8844/comments", "author": null, "committer": null, "parents": [{"sha": "592a6d1d968e6dba552439bb22a428240118285f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592a6d1d968e6dba552439bb22a428240118285f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592a6d1d968e6dba552439bb22a428240118285f"}], "stats": {"total": 270, "additions": 174, "deletions": 96}, "files": [{"sha": "9d5e08588210650c68c1a26bf8580d44ba99c75c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 67, "deletions": 50, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b9cfe0870147ed96be0f8e0f29fa954caa8844/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b9cfe0870147ed96be0f8e0f29fa954caa8844/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "patch": "@@ -1,3 +1,20 @@\n+2001-07-30  Andreas Jaeger  <aj@suse.de>\n+\n+\t* regex.c: Declare wcs functions only if compiling with\n+\tMBS_SUPPORT.\n+\tDon't use #elif for traditional C.\n+\n+2001-07-23  Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* regex.c: Revamp memory allocation for WCHAR functions to\n+\tnot use too much stack.\n+\n+2001-07-30  Andreas Jaeger  <aj@suse.de>\n+\n+\t* regex.c: Declare wcs functions only if compiling with\n+\tMBS_SUPPORT.\n+\tDon't use #elif for traditional C.\n+\n 2001-07-25  Daniel Jacobowitz  <drow@mvista.com>\n \n \t* Makefile.in (regex.o): Add dependency on config.h.\n@@ -299,12 +316,12 @@\n 2000-11-04  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* hashtab.c (htab_expand): Change to return int.  Use calloc or\n- \txcalloc depending on htab->return_allocation_failure.  Return zero\n- \tif calloc fails.\n+\txcalloc depending on htab->return_allocation_failure.  Return zero\n+\tif calloc fails.\n \t(htab_create): Update comment to cover memory allocation.\n \t(htab_try_create): New.\n \t(htab_find_slot_with_hash): Return NULL if htab_expand fails.\n-  \tUpdate comment to cover this.\n+\tUpdate comment to cover this.\n \n 2000-11-03  Hans-Peter Nilsson  <hp@bitrange.com>\n \n@@ -807,7 +824,7 @@ Tue May 30 15:07:52 2000  Jeffrey A Law  (law@cygnus.com)\n 2000-05-23  Mike Stump  <mrs@wrs.com>\n \n \t* Makefile.in (xmalloc.o): Add dependency for config.h, fixes make\n- \t-j3.\n+\t-j3.\n \n 2000-05-18  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n@@ -1440,9 +1457,9 @@ Tue Dec 22 09:43:35 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \t* choose-temp.c: Include stdlib.h.\n \n \t* cplus-dem.c (demangle_arm_pt): Remove unused prototype.\n-  \t(snarf_numeric_literal): Constify first parameter.\n-  \t(code_for_qualifier): Avoid a gcc extension, make the parameter an\n- \tint, not a char.\n+\t(snarf_numeric_literal): Constify first parameter.\n+\t(code_for_qualifier): Avoid a gcc extension, make the parameter an\n+\tint, not a char.\n \t(demangle_qualifier): Likewise.\n \t(demangle_signature): Cast the argument of a ctype function to\n \tunsigned char.\n@@ -1455,11 +1472,11 @@ Tue Dec 22 09:43:35 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \tCast the argument of a ctype function to unsigned char.\n \n \t* floatformat.c (floatformat_to_double): Add explicit braces to\n- \tavoid ambiguous `else'.\n+\tavoid ambiguous `else'.\n \n \t* fnmatch.c (fnmatch): Change type of variables `c', `c1',\n- \t`cstart' and `cend' to unsigned char.  Cast the argument of macro\n- \t`FOLD', which uses ctype functions, to unsigned char.\n+\t`cstart' and `cend' to unsigned char.  Cast the argument of macro\n+\t`FOLD', which uses ctype functions, to unsigned char.\n \n \t* objalloc.c (free): Add prototype.\n \n@@ -1470,7 +1487,7 @@ Sun Dec 20 16:03:46 1998  Hans-Peter Nilsson  <hp@axis.se>\n Fri Dec 18 17:50:18 1998  David Taylor  <taylor@texas.cygnus.com>\n \n \t* cplus-dem.c (demangle_arm_pt): remove declaration -- function\n- \tdoesn't exist.\n+\tdoesn't exist.\n \t(do_hpacc_template_literal): remove unused variable `i'.\n \n Fri Dec 18 16:11:43 EST 1998  Andrew MacLeod  <amacleod@cygnus.com>\n@@ -1514,48 +1531,48 @@ Fri Dec  4 13:51:04 1998  David Taylor   <taylor@texas.cygnus.com>\n \t* HP aCC demangling support.\n \t* cplus-dem.c\n \t(main): Remove default to HP style demangling, set to EDG\n- \tdemangling correctly when -edg specified; set the demangling style\n- \twhen user specifies 'edg'. Set strip_underscore to\n- \tprepends_underscore, if not HPUXHPPA.  Set\n- \tcurrent_demangling_style to hp_demangling if HPUXHPPA.  Set\n- \tcurrent demangling style correctly if the switch is hp.  Read\n- \tlabel correctly also in the HP style case.\n+\tdemangling correctly when -edg specified; set the demangling style\n+\twhen user specifies 'edg'. Set strip_underscore to\n+\tprepends_underscore, if not HPUXHPPA.  Set\n+\tcurrent_demangling_style to hp_demangling if HPUXHPPA.  Set\n+\tcurrent demangling style correctly if the switch is hp.  Read\n+\tlabel correctly also in the HP style case.\n \t(work_stuff): add temp_start field; add field for volatile member\n- \tfunction.\n+\tfunction.\n \t(arm_pt): handle ARM_DEMANGLING and EDG_DEMANGLING styles; HP\n- \tstyle for this case is the same as ARM.\n+\tstyle for this case is the same as ARM.\n \t(demangle_args): handle EDG_DEMANGLING style; support HP style.\n \t(demangle_arm_hp_template): new function. (It was\n- \tdemangle_arm_pt.); check and set value of temp_start field in\n- \tmultiple places. Also, when ceching for end of template args,\n- \tcheck to see if at end of static member of template class.\n+\tdemangle_arm_pt.); check and set value of temp_start field in\n+\tmultiple places. Also, when ceching for end of template args,\n+\tcheck to see if at end of static member of template class.\n \t(demangle_class): new local variable : save_class_name_end Don't\n- \tinclude template args in string defining class.\n+\tinclude template args in string defining class.\n \t(demangle_class_name): use demangel_arm_hp_template.\n \t(demangle_function_name): handle case where demangling style is\n- \tHP_DEMANGLING and currently point at an 'X' in the mangled name.\n-  \tHandle EDG_DEMANGLING style.  Handle constructor and destructor\n- \tops for HP style.\n+\tHP_DEMANGLING and currently point at an 'X' in the mangled name.\n+\tHandle EDG_DEMANGLING style.  Handle constructor and destructor\n+\tops for HP style.\n \t(demangle_prefix): handle EDG_DEMANGLING and ARM_DEMANGLING\n- \tstyles.  global destructor and constructor for HP style are same\n- \tas for ARM style. Same for local variables.\n+\tstyles.  global destructor and constructor for HP style are same\n+\tas for ARM style. Same for local variables.\n \t(demangle_qualified): handle EDG_DEMANGLING style.\n \t(demangle_signature): add case for volatile member function.  For\n- \tcases '1' - '9' : initialize the temp_start field to -1 and handle\n- \tthe EDG_DEMANGLING style.  for case 'F' : handle EDG_DEMANGLING\n- \tand AUTO_DEMANGLING styles.  If expecting a function and managed\n- \tto demangle the funct args, then handle the LUCID_DEMANGLING,\n- \tARM_DEMANGLING, and EDG_DEMANGLING styles.  Add case for local\n- \tclass name after \"Lnnn_ in HP style case. HP style too needs to\n- \tforget types.  _nnn is OK for HP style, so don't report failure.\n+\tcases '1' - '9' : initialize the temp_start field to -1 and handle\n+\tthe EDG_DEMANGLING style.  for case 'F' : handle EDG_DEMANGLING\n+\tand AUTO_DEMANGLING styles.  If expecting a function and managed\n+\tto demangle the funct args, then handle the LUCID_DEMANGLING,\n+\tARM_DEMANGLING, and EDG_DEMANGLING styles.  Add case for local\n+\tclass name after \"Lnnn_ in HP style case. HP style too needs to\n+\tforget types.  _nnn is OK for HP style, so don't report failure.\n \t(do_hpacc_template_const_value): new function. Handle template's\n- \tvalue param for HP/aCC.\n+\tvalue param for HP/aCC.\n \t(do_hpacc_template_literal): new function.  Handle a template's\n- \tliteral parameter for HP aCC.\n+\tliteral parameter for HP aCC.\n \t(recursively_demangle): new function\n \t(snarf_numeric_literal): new function.\n \t(usage): add 'edg' to the list of demangling styles; add hp switch\n- \tto message.\n+\tto message.\n \n Sat Nov 28 17:25:22 1998  Christopher Faylor <cgf@cygnus.com>\n \n@@ -1637,13 +1654,13 @@ Mon Nov  2 15:05:33 1998  Geoffrey Noer  <noer@cygnus.com>\n Mon Nov  2 10:22:01 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* pexecute.c: Check HAVE_CONFIG_H, not IN_GCC, when determining\n- \twhether to include config.h.  Possibly include unistd.h in the\n- \t!IN_GCC case.  Define VFORK_STRING as a printable function call\n- \tfor error messages (either \"vfork\" or \"fork\".)  If HAVE_VFORK_H is\n- \tdefined, include vfork.h.  If VMS is defined, define vfork()\n- \tappropriately.  Remove vfork check on USG, we're using autoconf.\n-  \t(pexecute): Set `errmsg_fmt' to VFORK_STRING instead of checking\n- \tlocally what string to use.\n+\twhether to include config.h.  Possibly include unistd.h in the\n+\t!IN_GCC case.  Define VFORK_STRING as a printable function call\n+\tfor error messages (either \"vfork\" or \"fork\".)  If HAVE_VFORK_H is\n+\tdefined, include vfork.h.  If VMS is defined, define vfork()\n+\tappropriately.  Remove vfork check on USG, we're using autoconf.\n+\t(pexecute): Set `errmsg_fmt' to VFORK_STRING instead of checking\n+\tlocally what string to use.\n \n 1998-10-26  Mark Mitchell  <mark@markmitchell.com>\n \n@@ -1749,8 +1766,8 @@ Thu Oct  8 23:42:08 1998  Jeffrey A Law  (law@cygnus.com)\n Mon Sep  7 23:29:01 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mkstemp.c: Include config.h even when not IN_GCC.  Wrap header\n- \tinclusions inside HAVE_*_H macros.  Include ansidecl.h when not\n- \tIN_GCC.\n+\tinclusions inside HAVE_*_H macros.  Include ansidecl.h when not\n+\tIN_GCC.\n \n \t* vasprintf.c: Include stdarg.h/varargs.h first.\n \n@@ -2064,7 +2081,7 @@ Mon May  4 13:00:28 1998  Ian Lance Taylor  <ian@cygnus.com>\n \t* config/mh-sysv4 (RANLIB, INSTALL): Don't define.\n \t* config.table: Change config_shell to CONFIG_SHELL, and use\n \tlibiberty_topdir to find move-if-change.\n- \t(m68k-apollo-bsd*, m68k-apollo-sysv*): Remove.\n+\t(m68k-apollo-bsd*, m68k-apollo-sysv*): Remove.\n \t(i[3456]86-ncr-sysv4*, *-*-dgux*, hppa*-hp-bsd*): Remove.\n \t(*-*-irix*, *-*-m88kbcs*, *-*-sysv*): Remove.\n \t* Makefile.in (srcdir): Set to @srcdir@.\n@@ -2281,7 +2298,7 @@ Wed Sep 24 00:31:59 1997  Felix Lee  <flee@yin.cygnus.com>\n \n \t* asprintf.c: stdarg.h when ALMOST_STDC\n \t* config/mh-windows (EXTRA_OFILES): add asprintf.o and\n- \tstrncasecmp.o.\n+\tstrncasecmp.o.\n \n Thu Aug 28 14:27:15 1997  Andrew Cagney  <cagney@b1.cygnus.com>\n \n@@ -4323,7 +4340,7 @@ Thu Jan 30 22:48:41 1992  Stu Grossman  (grossman at cygnus.com)\n \n Mon Jan 20 18:53:23 1992  Stu Grossman  (grossman at cygnus.com)\n \n- \t* getopt.c, getopt1.c, ../include/getopt.h:  Get latest versions.\n+\t* getopt.c, getopt1.c, ../include/getopt.h:  Get latest versions.\n \n Sat Jan 18 16:53:01 1992  Fred Fish  (fnf at cygnus.com)\n "}, {"sha": "555d3bbf66aaebe74dd139b151277d5015216d15", "filename": "libiberty/regex.c", "status": "modified", "additions": 107, "deletions": 46, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b9cfe0870147ed96be0f8e0f29fa954caa8844/libiberty%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b9cfe0870147ed96be0f8e0f29fa954caa8844/libiberty%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fregex.c?ref=c4b9cfe0870147ed96be0f8e0f29fa954caa8844", "patch": "@@ -410,16 +410,26 @@ typedef char boolean;\n static reg_errcode_t byte_regex_compile _RE_ARGS ((const char *pattern, size_t size,\n                                                    reg_syntax_t syntax,\n                                                    struct re_pattern_buffer *bufp));\n-static reg_errcode_t wcs_regex_compile _RE_ARGS ((const char *pattern, size_t size,\n-                                                   reg_syntax_t syntax,\n-                                                   struct re_pattern_buffer *bufp));\n \n static int byte_re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,\n \t\t\t\t\t     const char *string1, int size1,\n \t\t\t\t\t     const char *string2, int size2,\n \t\t\t\t\t     int pos,\n \t\t\t\t\t     struct re_registers *regs,\n \t\t\t\t\t     int stop));\n+static int byte_re_search_2 PARAMS ((struct re_pattern_buffer *bufp,\n+\t\t\t\t     const char *string1, int size1,\n+\t\t\t\t     const char *string2, int size2,\n+\t\t\t\t     int startpos, int range,\n+\t\t\t\t     struct re_registers *regs, int stop));\n+static int byte_re_compile_fastmap PARAMS ((struct re_pattern_buffer *bufp));\n+\n+#ifdef MBS_SUPPORT\n+static reg_errcode_t wcs_regex_compile _RE_ARGS ((const char *pattern, size_t size,\n+                                                   reg_syntax_t syntax,\n+                                                   struct re_pattern_buffer *bufp));\n+\n+\n static int wcs_re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,\n \t\t\t\t\t    const char *cstring1, int csize1,\n \t\t\t\t\t    const char *cstring2, int csize2,\n@@ -429,19 +439,13 @@ static int wcs_re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,\n \t\t\t\t\t    wchar_t *string1, int size1,\n \t\t\t\t\t    wchar_t *string2, int size2,\n \t\t\t\t\t    int *mbs_offset1, int *mbs_offset2));\n-static int byte_re_search_2 PARAMS ((struct re_pattern_buffer *bufp,\n-\t\t\t\t     const char *string1, int size1,\n-\t\t\t\t     const char *string2, int size2,\n-\t\t\t\t     int startpos, int range,\n-\t\t\t\t     struct re_registers *regs, int stop));\n static int wcs_re_search_2 PARAMS ((struct re_pattern_buffer *bufp,\n \t\t\t\t    const char *string1, int size1,\n \t\t\t\t    const char *string2, int size2,\n \t\t\t\t    int startpos, int range,\n \t\t\t\t    struct re_registers *regs, int stop));\n-static int byte_re_compile_fastmap PARAMS ((struct re_pattern_buffer *bufp));\n static int wcs_re_compile_fastmap PARAMS ((struct re_pattern_buffer *bufp));\n-\n+#endif\n \f\n /* These are the command codes that appear in compiled regular\n    expressions.  Some opcodes are followed by argument bytes.  A\n@@ -611,29 +615,31 @@ typedef enum\n # define PREFIX(name) byte_##name\n # define ARG_PREFIX(name) name\n # define PUT_CHAR(c) putchar (c)\n-#elif defined WCHAR\n-# define CHAR_T wchar_t\n-# define UCHAR_T wchar_t\n-# define COMPILED_BUFFER_VAR wc_buffer\n-# define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */\n-# define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)\n-# define PREFIX(name) wcs_##name\n-# define ARG_PREFIX(name) c##name\n-/* Should we use wide stream??  */\n-# define PUT_CHAR(c) printf (\"%C\", c);\n-# define TRUE 1\n-# define FALSE 0\n #else\n-# ifdef MBS_SUPPORT\n-#  define WCHAR\n+# ifdef WCHAR\n+#  define CHAR_T wchar_t\n+#  define UCHAR_T wchar_t\n+#  define COMPILED_BUFFER_VAR wc_buffer\n+#  define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */\n+#  define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)\n+#  define PREFIX(name) wcs_##name\n+#  define ARG_PREFIX(name) c##name\n+/* Should we use wide stream??  */\n+#  define PUT_CHAR(c) printf (\"%C\", c);\n+#  define TRUE 1\n+#  define FALSE 0\n+# else\n+#  ifdef MBS_SUPPORT\n+#   define WCHAR\n+#   define INSIDE_RECURSION\n+#   include \"regex.c\"\n+#   undef INSIDE_RECURSION\n+#  endif\n+#  define BYTE\n #  define INSIDE_RECURSION\n #  include \"regex.c\"\n #  undef INSIDE_RECURSION\n # endif\n-# define BYTE\n-# define INSIDE_RECURSION\n-# include \"regex.c\"\n-# undef INSIDE_RECURSION\n #endif\n \n #ifdef INSIDE_RECURSION\n@@ -5076,16 +5082,35 @@ weak_alias (__re_search_2, re_search_2)\n #endif\n \n #ifdef WCHAR\n-# define FREE_WCS_BUFFERS()    \\\n-  do {                         \\\n-    FREE_VAR (string1);                \\\n-    FREE_VAR (string2);                \\\n-    FREE_VAR (mbs_offset1);    \\\n-    FREE_VAR (mbs_offset2);    \\\n+# define MAX_ALLOCA_SIZE\t2000\n+\n+# define FREE_WCS_BUFFERS() \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    if (size1 > MAX_ALLOCA_SIZE)\t\t\t\t\t      \\\n+      {\t\t\t\t\t\t\t\t\t      \\\n+\tfree (wcs_string1);\t\t\t\t\t\t      \\\n+\tfree (mbs_offset1);\t\t\t\t\t\t      \\\n+      }\t\t\t\t\t\t\t\t\t      \\\n+    else\t\t\t\t\t\t\t\t      \\\n+      {\t\t\t\t\t\t\t\t\t      \\\n+\tFREE_VAR (wcs_string1);\t\t\t\t\t\t      \\\n+\tFREE_VAR (mbs_offset1);\t\t\t\t\t\t      \\\n+      }\t\t\t\t\t\t\t\t\t      \\\n+    if (size2 > MAX_ALLOCA_SIZE) \t\t\t\t\t      \\\n+      {\t\t\t\t\t\t\t\t\t      \\\n+\tfree (wcs_string2);\t\t\t\t\t\t      \\\n+\tfree (mbs_offset2);\t\t\t\t\t\t      \\\n+      }\t\t\t\t\t\t\t\t\t      \\\n+    else\t\t\t\t\t\t\t\t      \\\n+      {\t\t\t\t\t\t\t\t\t      \\\n+\tFREE_VAR (wcs_string2);\t\t\t\t\t\t      \\\n+\tFREE_VAR (mbs_offset2);\t\t\t\t\t\t      \\\n+      }\t\t\t\t\t\t\t\t\t      \\\n   } while (0)\n \n #endif\n \n+\n static int\n PREFIX(re_search_2) (bufp, string1, size1, string2, size2, startpos, range,\n \t\t     regs, stop)\n@@ -5160,36 +5185,72 @@ PREFIX(re_search_2) (bufp, string1, size1, string2, size2, startpos, range,\n      fill them with converted string.  */\n   if (size1 != 0)\n     {\n-      wcs_string1 = REGEX_TALLOC (size1 + 1, CHAR_T);\n-      mbs_offset1 = REGEX_TALLOC (size1 + 1, int);\n-      is_binary = REGEX_TALLOC (size1 + 1, char);\n+      if (size1 > MAX_ALLOCA_SIZE)\n+\t{\n+\t  wcs_string1 = TALLOC (size1 + 1, CHAR_T);\n+\t  mbs_offset1 = TALLOC (size1 + 1, int);\n+\t  is_binary = TALLOC (size1 + 1, char);\n+\t}\n+      else\n+\t{\n+\t  wcs_string1 = REGEX_TALLOC (size1 + 1, CHAR_T);\n+\t  mbs_offset1 = REGEX_TALLOC (size1 + 1, int);\n+\t  is_binary = REGEX_TALLOC (size1 + 1, char);\n+\t}\n       if (!wcs_string1 || !mbs_offset1 || !is_binary)\n \t{\n-\t  FREE_VAR (wcs_string1);\n-\t  FREE_VAR (mbs_offset1);\n-\t  FREE_VAR (is_binary);\n+\t  if (size1 > MAX_ALLOCA_SIZE)\n+\t    {\n+\t      free (wcs_string1);\n+\t      free (mbs_offset1);\n+\t      free (is_binary);\n+\t    }\n+\t  else\n+\t    {\n+\t      FREE_VAR (wcs_string1);\n+\t      FREE_VAR (mbs_offset1);\n+\t      FREE_VAR (is_binary);\n+\t    }\n \t  return -2;\n \t}\n       wcs_size1 = convert_mbs_to_wcs(wcs_string1, string1, size1,\n \t\t\t\t     mbs_offset1, is_binary);\n       wcs_string1[wcs_size1] = L'\\0'; /* for a sentinel  */\n-      FREE_VAR (is_binary);\n+      if (size1 > MAX_ALLOCA_SIZE)\n+\tfree (is_binary);\n+      else\n+\tFREE_VAR (is_binary);\n     }\n   if (size2 != 0)\n     {\n-      wcs_string2 = REGEX_TALLOC (size2 + 1, CHAR_T);\n-      mbs_offset2 = REGEX_TALLOC (size2 + 1, int);\n-      is_binary = REGEX_TALLOC (size2 + 1, char);\n+      if (size2 > MAX_ALLOCA_SIZE)\n+\t{\n+\t  wcs_string2 = TALLOC (size2 + 1, CHAR_T);\n+\t  mbs_offset2 = TALLOC (size2 + 1, int);\n+\t  is_binary = TALLOC (size2 + 1, char);\n+\t}\n+      else\n+\t{\n+\t  wcs_string2 = REGEX_TALLOC (size2 + 1, CHAR_T);\n+\t  mbs_offset2 = REGEX_TALLOC (size2 + 1, int);\n+\t  is_binary = REGEX_TALLOC (size2 + 1, char);\n+\t}\n       if (!wcs_string2 || !mbs_offset2 || !is_binary)\n \t{\n \t  FREE_WCS_BUFFERS ();\n-\t  FREE_VAR (is_binary);\n+\t  if (size2 > MAX_ALLOCA_SIZE)\n+\t    free (is_binary);\n+\t  else\n+\t    FREE_VAR (is_binary);\n \t  return -2;\n \t}\n       wcs_size2 = convert_mbs_to_wcs(wcs_string2, string2, size2,\n \t\t\t\t     mbs_offset2, is_binary);\n       wcs_string2[wcs_size2] = L'\\0'; /* for a sentinel  */\n-      FREE_VAR (is_binary);\n+      if (size2 > MAX_ALLOCA_SIZE)\n+\tfree (is_binary);\n+      else\n+\tFREE_VAR (is_binary);\n     }\n #endif /* WCHAR */\n "}]}