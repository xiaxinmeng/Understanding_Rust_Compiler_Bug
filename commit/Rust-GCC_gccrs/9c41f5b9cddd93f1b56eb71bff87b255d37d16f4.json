{"sha": "9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM0MWY1YjljZGRkOTNmMWI1NmViNzFiZmY4N2IyNTVkMzdkMTZmNA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-06-29T23:42:03Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-07-27T09:16:27Z"}, "message": "Fix OpenACC \"ephemeral\" asynchronous host-to-device copies\n\nThis patch fixes several places in libgomp/target.c where \"ephemeral\" data\n(on the stack or in temporary heap locations) may be used as the source of\nan asynchronous host-to-device copy that may not complete before the host\ndata disappears.\n\nAn existing, but flawed, workaround for this problem in the AMD GCN\nlibgomp offloading plugin is currently present on mainline, and was\nposted for the og9 branch here:\n\n  https://gcc.gnu.org/legacy-ml/gcc-patches/2019-08/msg00901.html\n\nand previous versions of this patch were posted here (for mainline/og9):\n\n  https://gcc.gnu.org/legacy-ml/gcc-patches/2019-11/msg01482.html\n  https://gcc.gnu.org/legacy-ml/gcc-patches/2019-09/msg01026.html\n\nlibgomp/\n\t* libgomp.h (gomp_copy_host2dev): Update prototype.\n\t* oacc-mem.c (memcpy_tofrom_device, update_dev_host): Add new\n\targument to gomp_copy_host2dev (false).\n\t* plugin/plugin-gcn.c (struct copy_data): Remove free_src field.\n\t(copy_data): Don't free src.\n\t(queue_push_copy): Remove free_src handling.\n\t(GOMP_OFFLOAD_dev2dev): Update call to queue_push_copy.\n\t(GOMP_OFFLOAD_openacc_async_host2dev): Remove source-data\n\tsnapshotting.\n\t(GOMP_OFFLOAD_openacc_async_dev2host): Update call to\n\tqueue_push_copy.\n\t* target.c (goacc_device_copy_async): Add SRCADDR_ORIG parameter.\n\t(gomp_copy_host2dev): Add EPHEMERAL parameter.  Snapshot source\n\tdata when true, and set up deferred freeing of temporary buffer.\n\t(gomp_copy_dev2host): Update call to goacc_device_copy_async.\n\t(gomp_map_vars_existing, gomp_map_pointer, gomp_attach_pointer)\n\t(gomp_detach_pointer, gomp_map_vars_internal, gomp_update): Update\n\tcalls to gomp_copy_host2dev with appropriate ephemeral argument.\n\t* testsuite/libgomp.oacc-c-c++-common/async-data-1-1.c: Remove\n\tXFAIL.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "575141d79a9a03bddcfef0c5eb5c6abeae5f1ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/575141d79a9a03bddcfef0c5eb5c6abeae5f1ad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c40c36db8a52d2c630aa61ee54e33908e9daec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c40c36db8a52d2c630aa61ee54e33908e9daec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c40c36db8a52d2c630aa61ee54e33908e9daec"}], "stats": {"total": 108, "additions": 64, "deletions": 44}, "files": [{"sha": "e8901da1069737cfd8403e1899be5486eec0b853", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "patch": "@@ -1226,7 +1226,7 @@ extern void gomp_acc_declare_allocate (bool, size_t, void **, size_t *,\n struct gomp_coalesce_buf;\n extern void gomp_copy_host2dev (struct gomp_device_descr *,\n \t\t\t\tstruct goacc_asyncqueue *, void *, const void *,\n-\t\t\t\tsize_t, struct gomp_coalesce_buf *);\n+\t\t\t\tsize_t, bool, struct gomp_coalesce_buf *);\n extern void gomp_copy_dev2host (struct gomp_device_descr *,\n \t\t\t\tstruct goacc_asyncqueue *, void *, const void *,\n \t\t\t\tsize_t);"}, {"sha": "5988db0b8867d4a97eabc18906718ab6806930aa", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "patch": "@@ -202,7 +202,7 @@ memcpy_tofrom_device (bool from, void *d, void *h, size_t s, int async,\n   if (from)\n     gomp_copy_dev2host (thr->dev, aq, h, d, s);\n   else\n-    gomp_copy_host2dev (thr->dev, aq, d, h, s, /* TODO: cbuf? */ NULL);\n+    gomp_copy_host2dev (thr->dev, aq, d, h, s, false, /* TODO: cbuf? */ NULL);\n \n   if (profiling_p)\n     {\n@@ -874,7 +874,7 @@ update_dev_host (int is_dev, void *h, size_t s, int async)\n   goacc_aq aq = get_goacc_asyncqueue (async);\n \n   if (is_dev)\n-    gomp_copy_host2dev (acc_dev, aq, d, h, s, /* TODO: cbuf? */ NULL);\n+    gomp_copy_host2dev (acc_dev, aq, d, h, s, false, /* TODO: cbuf? */ NULL);\n   else\n     gomp_copy_dev2host (acc_dev, aq, h, d, s);\n "}, {"sha": "2548614a2e58cc7b2b2117c8a434ffda5810b229", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "patch": "@@ -292,7 +292,6 @@ struct copy_data\n   void *dst;\n   const void *src;\n   size_t len;\n-  bool free_src;\n   struct goacc_asyncqueue *aq;\n };\n \n@@ -2914,8 +2913,6 @@ copy_data (void *data_)\n \t     data->aq->agent->device_id, data->aq->id, data->len, data->src,\n \t     data->dst);\n   hsa_memory_copy_wrapper (data->dst, data->src, data->len);\n-  if (data->free_src)\n-    free ((void *) data->src);\n   free (data);\n }\n \n@@ -2929,12 +2926,11 @@ gomp_offload_free (void *ptr)\n }\n \n /* Request an asynchronous data copy, to or from a device, on a given queue.\n-   The event will be registered as a callback.  If FREE_SRC is true\n-   then the source data will be freed following the copy.  */\n+   The event will be registered as a callback.  */\n \n static void\n queue_push_copy (struct goacc_asyncqueue *aq, void *dst, const void *src,\n-\t\t size_t len, bool free_src)\n+\t\t size_t len)\n {\n   if (DEBUG_QUEUES)\n     GCN_DEBUG (\"queue_push_copy %d:%d: %zu bytes from (%p) to (%p)\\n\",\n@@ -2944,7 +2940,6 @@ queue_push_copy (struct goacc_asyncqueue *aq, void *dst, const void *src,\n   data->dst = dst;\n   data->src = src;\n   data->len = len;\n-  data->free_src = free_src;\n   data->aq = aq;\n   queue_push_callback (aq, copy_data, data);\n }\n@@ -3646,7 +3641,7 @@ GOMP_OFFLOAD_dev2dev (int device, void *dst, const void *src, size_t n)\n     {\n       struct agent_info *agent = get_agent_info (device);\n       maybe_init_omp_async (agent);\n-      queue_push_copy (agent->omp_async_queue, dst, src, n, false);\n+      queue_push_copy (agent->omp_async_queue, dst, src, n);\n       return true;\n     }\n \n@@ -3916,15 +3911,7 @@ GOMP_OFFLOAD_openacc_async_host2dev (int device, void *dst, const void *src,\n {\n   struct agent_info *agent = get_agent_info (device);\n   assert (agent == aq->agent);\n-  /* The source data does not necessarily remain live until the deferred\n-     copy happens.  Taking a snapshot of the data here avoids reading\n-     uninitialised data later, but means that (a) data is copied twice and\n-     (b) modifications to the copied data between the \"spawning\" point of\n-     the asynchronous kernel and when it is executed will not be seen.\n-     But, that is probably correct.  */\n-  void *src_copy = GOMP_PLUGIN_malloc (n);\n-  memcpy (src_copy, src, n);\n-  queue_push_copy (aq, dst, src_copy, n, true);\n+  queue_push_copy (aq, dst, src, n);\n   return true;\n }\n \n@@ -3936,7 +3923,7 @@ GOMP_OFFLOAD_openacc_async_dev2host (int device, void *dst, const void *src,\n {\n   struct agent_info *agent = get_agent_info (device);\n   assert (agent == aq->agent);\n-  queue_push_copy (aq, dst, src, n, false);\n+  queue_push_copy (aq, dst, src, n);\n   return true;\n }\n "}, {"sha": "5576e57f82280dd53c1b98fc52e77c11de8d45c5", "filename": "libgomp/target.c", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "patch": "@@ -214,13 +214,24 @@ goacc_device_copy_async (struct gomp_device_descr *devicep,\n \t\t\t\t\t    struct goacc_asyncqueue *),\n \t\t\t const char *dst, void *dstaddr,\n \t\t\t const char *src, const void *srcaddr,\n+\t\t\t const void *srcaddr_orig,\n \t\t\t size_t size, struct goacc_asyncqueue *aq)\n {\n   if (!copy_func (devicep->target_id, dstaddr, srcaddr, size, aq))\n     {\n       gomp_mutex_unlock (&devicep->lock);\n-      gomp_fatal (\"Copying of %s object [%p..%p) to %s object [%p..%p) failed\",\n-\t\t  src, srcaddr, srcaddr + size, dst, dstaddr, dstaddr + size);\n+      if (srcaddr_orig && srcaddr_orig != srcaddr)\n+\tgomp_fatal (\"Copying of %s object [%p..%p)\"\n+\t\t    \" via buffer %s object [%p..%p)\"\n+\t\t    \" to %s object [%p..%p) failed\",\n+\t\t    src, srcaddr_orig, srcaddr_orig + size,\n+\t\t    src, srcaddr, srcaddr + size,\n+\t\t    dst, dstaddr, dstaddr + size);\n+      else\n+\tgomp_fatal (\"Copying of %s object [%p..%p)\"\n+\t\t    \" to %s object [%p..%p) failed\",\n+\t\t    src, srcaddr, srcaddr + size,\n+\t\t    dst, dstaddr, dstaddr + size);\n     }\n }\n \n@@ -317,11 +328,16 @@ gomp_to_device_kind_p (int kind)\n     }\n }\n \n+/* Copy host memory to an offload device.  In asynchronous mode (if AQ is\n+   non-NULL), when the source data is stack or may otherwise be deallocated\n+   before the asynchronous copy takes place, EPHEMERAL must be passed as\n+   TRUE.  */\n+\n attribute_hidden void\n gomp_copy_host2dev (struct gomp_device_descr *devicep,\n \t\t    struct goacc_asyncqueue *aq,\n \t\t    void *d, const void *h, size_t sz,\n-\t\t    struct gomp_coalesce_buf *cbuf)\n+\t\t    bool ephemeral, struct gomp_coalesce_buf *cbuf)\n {\n   if (cbuf)\n     {\n@@ -349,8 +365,23 @@ gomp_copy_host2dev (struct gomp_device_descr *devicep,\n \t}\n     }\n   if (__builtin_expect (aq != NULL, 0))\n-    goacc_device_copy_async (devicep, devicep->openacc.async.host2dev_func,\n-\t\t\t     \"dev\", d, \"host\", h, sz, aq);\n+    {\n+      void *h_buf = (void *) h;\n+      if (ephemeral)\n+\t{\n+\t  /* We're queueing up an asynchronous copy from data that may\n+\t     disappear before the transfer takes place (i.e. because it is a\n+\t     stack local in a function that is no longer executing).  Make a\n+\t     copy of the data into a temporary buffer in those cases.  */\n+\t  h_buf = gomp_malloc (sz);\n+\t  memcpy (h_buf, h, sz);\n+\t}\n+      goacc_device_copy_async (devicep, devicep->openacc.async.host2dev_func,\n+\t\t\t       \"dev\", d, \"host\", h_buf, h, sz, aq);\n+      if (ephemeral)\n+\t/* Free temporary buffer once the transfer has completed.  */\n+\tdevicep->openacc.async.queue_callback_func (aq, free, h_buf);\n+    }\n   else\n     gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n }\n@@ -362,7 +393,7 @@ gomp_copy_dev2host (struct gomp_device_descr *devicep,\n {\n   if (__builtin_expect (aq != NULL, 0))\n     goacc_device_copy_async (devicep, devicep->openacc.async.dev2host_func,\n-\t\t\t     \"host\", h, \"dev\", d, sz, aq);\n+\t\t\t     \"host\", h, \"dev\", d, NULL, sz, aq);\n   else\n     gomp_device_copy (devicep, devicep->dev2host_func, \"host\", h, \"dev\", d, sz);\n }\n@@ -521,7 +552,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n \t\t\t\t  + newn->host_start - oldn->host_start),\n \t\t\t(void *) newn->host_start,\n-\t\t\tnewn->host_end - newn->host_start, cbuf);\n+\t\t\tnewn->host_end - newn->host_start, false, cbuf);\n \n   gomp_increment_refcount (oldn, refcount_set);\n }\n@@ -548,8 +579,8 @@ gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,\n       cur_node.tgt_offset = (uintptr_t) NULL;\n       gomp_copy_host2dev (devicep, aq,\n \t\t\t  (void *) (tgt->tgt_start + target_offset),\n-\t\t\t  (void *) &cur_node.tgt_offset,\n-\t\t\t  sizeof (void *), cbuf);\n+\t\t\t  (void *) &cur_node.tgt_offset, sizeof (void *),\n+\t\t\t  true, cbuf);\n       return;\n     }\n   /* Add bias to the pointer value.  */\n@@ -569,7 +600,8 @@ gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,\n      to initialize the pointer with.  */\n   cur_node.tgt_offset -= bias;\n   gomp_copy_host2dev (devicep, aq, (void *) (tgt->tgt_start + target_offset),\n-\t\t      (void *) &cur_node.tgt_offset, sizeof (void *), cbuf);\n+\t\t      (void *) &cur_node.tgt_offset, sizeof (void *),\n+\t\t      true, cbuf);\n }\n \n static void\n@@ -702,7 +734,7 @@ gomp_attach_pointer (struct gomp_device_descr *devicep,\n \t\t  (void *) (n->tgt->tgt_start + n->tgt_offset), (void *) data);\n \n       gomp_copy_host2dev (devicep, aq, (void *) devptr, (void *) &data,\n-\t\t\t  sizeof (void *), cbufp);\n+\t\t\t  sizeof (void *), true, cbufp);\n     }\n   else\n     gomp_debug (1, \"%s: attach count for %p -> %u\\n\", __FUNCTION__,\n@@ -755,7 +787,7 @@ gomp_detach_pointer (struct gomp_device_descr *devicep,\n \t\t  (void *) target);\n \n       gomp_copy_host2dev (devicep, aq, (void *) devptr, (void *) &target,\n-\t\t\t  sizeof (void *), cbufp);\n+\t\t\t  sizeof (void *), true, cbufp);\n     }\n   else\n     gomp_debug (1, \"%s: attach count for %p -> %u\\n\", __FUNCTION__,\n@@ -1218,7 +1250,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\tlen = sizes[i];\n \t\tgomp_copy_host2dev (devicep, aq,\n \t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n-\t\t\t\t    (void *) hostaddrs[i], len, cbufp);\n+\t\t\t\t    (void *) hostaddrs[i], len, false, cbufp);\n \t\ttgt_size += len;\n \t\tcontinue;\n \t      case GOMP_MAP_FIRSTPRIVATE_INT:\n@@ -1312,7 +1344,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t      + cur_node.host_start\n \t\t\t\t\t      - n->host_start),\n \t\t\t\t    (void *) &cur_node.tgt_offset,\n-\t\t\t\t    sizeof (void *), cbufp);\n+\t\t\t\t    sizeof (void *), true, cbufp);\n \t\tcur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n \t\t\t\t      + cur_node.host_start - n->host_start;\n \t\tcontinue;\n@@ -1450,7 +1482,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tk->host_end - k->host_start, cbufp);\n+\t\t\t\t\tk->host_end - k->host_start,\n+\t\t\t\t\tfalse, cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_POINTER:\n \t\t    gomp_map_pointer (tgt, aq,\n@@ -1462,7 +1495,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tk->host_end - k->host_start, cbufp);\n+\t\t\t\t\tk->host_end - k->host_start,\n+\t\t\t\t\tfalse, cbufp);\n \t\t    tgt->list[i].has_null_ptr_assoc = false;\n \n \t\t    for (j = i + 1; j < mapnum; j++)\n@@ -1525,7 +1559,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t(void *) (tgt->tgt_start\n \t\t\t\t\t\t  + k->tgt_offset),\n \t\t\t\t\t(void *) k->host_start,\n-\t\t\t\t\tsizeof (void *), cbufp);\n+\t\t\t\t\tsizeof (void *), false, cbufp);\n \t\t    break;\n \t\t  default:\n \t\t    gomp_mutex_unlock (&devicep->lock);\n@@ -1541,7 +1575,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t    /* We intentionally do not use coalescing here, as it's not\n \t\t       data allocated by the current call to this function.  */\n \t\t    gomp_copy_host2dev (devicep, aq, (void *) n->tgt_offset,\n-\t\t\t\t\t&tgt_addr, sizeof (void *), NULL);\n+\t\t\t\t\t&tgt_addr, sizeof (void *), true, NULL);\n \t\t  }\n \t\tarray++;\n \t      }\n@@ -1556,7 +1590,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  gomp_copy_host2dev (devicep, aq,\n \t\t\t      (void *) (tgt->tgt_start + i * sizeof (void *)),\n \t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *),\n-\t\t\t      cbufp);\n+\t\t\t      true, cbufp);\n \t}\n     }\n \n@@ -1568,7 +1602,8 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t    (void *) (tgt->tgt_start + cbuf.chunks[c].start),\n \t\t\t    (char *) cbuf.buf + (cbuf.chunks[c].start\n \t\t\t\t\t\t - cbuf.chunks[0].start),\n-\t\t\t    cbuf.chunks[c].end - cbuf.chunks[c].start, NULL);\n+\t\t\t    cbuf.chunks[c].end - cbuf.chunks[c].start,\n+\t\t\t    true, NULL);\n       free (cbuf.buf);\n       cbuf.buf = NULL;\n       cbufp = NULL;\n@@ -1892,7 +1927,7 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \n \t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n \t      gomp_copy_host2dev (devicep, NULL, devaddr, hostaddr, size,\n-\t\t\t\t  NULL);\n+\t\t\t\t  false, NULL);\n \t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n \t      gomp_copy_dev2host (devicep, NULL, hostaddr, devaddr, size);\n \t  }"}, {"sha": "9f2bed8aca82c5ef9fe6ee069440247ac734016a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/async-data-1-1.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasync-data-1-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c41f5b9cddd93f1b56eb71bff87b255d37d16f4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasync-data-1-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasync-data-1-1.c?ref=9c41f5b9cddd93f1b56eb71bff87b255d37d16f4", "patch": "@@ -3,8 +3,6 @@\n    Due to one data mapping, this isn't using the libgomp 'cbuf' buffering.\n */\n \n-/* { dg-xfail-run-if \"TODO\" { openacc_radeon_accel_selected } } */\n-\n \n #include <stdlib.h>\n "}]}