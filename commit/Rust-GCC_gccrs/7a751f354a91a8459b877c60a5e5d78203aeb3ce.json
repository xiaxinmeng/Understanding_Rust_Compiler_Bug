{"sha": "7a751f354a91a8459b877c60a5e5d78203aeb3ce", "node_id": "C_kwDOANBUbNoAKDdhNzUxZjM1NGE5MWE4NDU5Yjg3N2M2MGE1ZTVkNzgyMDNhZWIzY2U", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-15T19:29:10Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-16T21:02:11Z"}, "message": "Replace Btype use with GCC tree", "tree": {"sha": "6905b25bbe6a6e9042ee93992e752987ed22dc15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6905b25bbe6a6e9042ee93992e752987ed22dc15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a751f354a91a8459b877c60a5e5d78203aeb3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a751f354a91a8459b877c60a5e5d78203aeb3ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a751f354a91a8459b877c60a5e5d78203aeb3ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a751f354a91a8459b877c60a5e5d78203aeb3ce/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd"}], "stats": {"total": 799, "additions": 376, "deletions": 423}, "files": [{"sha": "82c02f8c42a1975cda9079d0307545882c265a07", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -60,20 +60,20 @@ class Context\n \tok = tyctx->lookup_type (ref, &lookup);\n \trust_assert (ok);\n \n-\tBtype *compiled = TyTyCompile::compile (backend, lookup);\n-\tcompiled_type_map.insert (std::pair<HirId, Btype *> (ref, compiled));\n+\ttree compiled = TyTyCompile::compile (backend, lookup);\n+\tcompiled_type_map.insert (std::pair<HirId, tree > (ref, compiled));\n \tbuiltin_range.insert (ref);\n       }\n   }\n \n-  bool lookup_compiled_types (HirId id, ::Btype **type,\n+  bool lookup_compiled_types (HirId id, ::tree *type,\n \t\t\t      const TyTy::BaseType *ref = nullptr)\n   {\n     if (ref != nullptr)\n       {\n \tfor (auto it = mono.begin (); it != mono.end (); it++)\n \t  {\n-\t    std::pair<HirId, ::Btype *> &val = it->second;\n+\t    std::pair<HirId, ::tree > &val = it->second;\n \t    const TyTy::BaseType *r = it->first;\n \n \t    if (ref->is_equal (*r))\n@@ -94,14 +94,14 @@ class Context\n     return true;\n   }\n \n-  void insert_compiled_type (HirId id, ::Btype *type,\n+  void insert_compiled_type (HirId id, ::tree type,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     rust_assert (builtin_range.find (id) == builtin_range.end ());\n-    compiled_type_map.insert (std::pair<HirId, Btype *> (id, type));\n+    compiled_type_map.insert (std::pair<HirId, tree > (id, type));\n     if (ref != nullptr)\n       {\n-\tstd::pair<HirId, ::Btype *> elem (id, type);\n+\tstd::pair<HirId, ::tree > elem (id, type);\n \tmono[ref] = std::move (elem);\n       }\n   }\n@@ -247,7 +247,7 @@ class Context\n   void pop_fn () { fn_stack.pop_back (); }\n   fncontext peek_fn () { return fn_stack.back (); }\n \n-  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_type (::tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }\n   void push_const (::Bexpression *c) { const_decls.push_back (c); }\n   void push_function (::Bfunction *f) { func_decls.push_back (f); }\n@@ -322,20 +322,20 @@ class Context\n   // state\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n-  std::map<HirId, ::Btype *> compiled_type_map;\n+  std::map<HirId, ::tree > compiled_type_map;\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n   std::map<HirId, ::Bexpression *> compiled_consts;\n   std::map<HirId, ::Blabel *> compiled_labels;\n   std::vector<::std::vector<Bstatement *>> statements;\n   std::vector<::Bblock *> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n   std::vector<::Blabel *> loop_begin_labels;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *>> mono;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, ::tree >> mono;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, ::Bfunction *>>>\n     mono_fns;\n \n   // To GCC middle-end\n-  std::vector<::Btype *> type_decls;\n+  std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;\n   std::vector<::Bexpression *> const_decls;\n   std::vector<::Bfunction *> func_decls;\n@@ -344,7 +344,7 @@ class Context\n class TyTyResolveCompile : public TyTy::TyConstVisitor\n {\n public:\n-  static ::Btype *compile (Context *ctx, const TyTy::BaseType *ty,\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n \t\t\t   bool trait_object_mode = false)\n   {\n     TyTyResolveCompile compiler (ctx, trait_object_mode);\n@@ -375,16 +375,16 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret\n \t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret,\n \t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n       }\n@@ -395,7 +395,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \tauto compiled_param_type\n \t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pair.first->as_string (), compiled_param_type,\n \t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n \n@@ -414,12 +414,12 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnPtr &type) override\n   {\n-    Btype *result_type\n+    tree result_type\n       = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n \n-    std::vector<Btype *> parameters;\n+    std::vector<tree > parameters;\n     type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n-      Btype *pty = TyTyResolveCompile::compile (ctx, p);\n+      tree pty = TyTyResolveCompile::compile (ctx, p);\n       parameters.push_back (pty);\n       return true;\n     });\n@@ -439,25 +439,25 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     rust_assert (type.number_of_variants () == 1);\n \n     TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < variant.num_fields (); i++)\n       {\n \tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-\tBtype *compiled_field_ty\n+\ttree compiled_field_ty\n \t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n \n-\tBackend::Btyped_identifier f (field->get_name (), compiled_field_ty,\n+\tBackend::typed_identifier f (field->get_name (), compiled_field_ty,\n \t\t\t\t      ctx->get_mappings ()->lookup_location (\n \t\t\t\t\ttype.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record;\n+    tree type_record;\n     if (type.is_union ())\n       type_record = ctx->get_backend ()->union_type (fields);\n     else\n       type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -482,27 +482,27 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n       return;\n \n     // create implicit struct\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < type.num_fields (); i++)\n       {\n \tTyTy::BaseType *field = type.get_field (i);\n-\tBtype *compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\ttree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n \n \t// rustc uses the convention __N, where N is an integer, to\n \t// name the fields of a tuple.  We follow this as well,\n \t// because this is used by GDB.  One further reason to prefer\n \t// this, rather than simply emitting the integer, is that this\n \t// approach makes it simpler to use a C-only debugger, or\n \t// GDB's C mode, when debugging Rust.\n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i),\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i),\n \t\t\t\t      compiled_field_ty,\n \t\t\t\t      ctx->get_mappings ()->lookup_location (\n \t\t\t\t\ttype.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -514,71 +514,71 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::ArrayType &type) override\n   {\n-    Btype *element_type\n+    tree element_type\n       = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n     translated\n       = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n   }\n \n   void visit (const TyTy::BoolType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::IntType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::UintType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::FloatType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::USizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ISizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::CharType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ReferenceType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -593,7 +593,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::PointerType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -608,7 +608,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::StrType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    ::tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n@@ -633,32 +633,32 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n     // create implicit struct\n     auto items = type.get_object_items ();\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n \n-    Btype *uint = ctx->get_backend ()->integer_type (\n+    tree uint = ctx->get_backend ()->integer_type (\n       true, ctx->get_backend ()->get_pointer_size ());\n-    Btype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+    tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-    Backend::Btyped_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+    Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n \t\t\t\t  ctx->get_mappings ()->lookup_location (\n \t\t\t\t    type.get_ty_ref ()));\n     fields.push_back (std::move (f));\n \n     for (size_t i = 0; i < items.size (); i++)\n       {\n \t// mrustc seems to make a vtable consisting of uintptr's\n-\tBtype *uint = ctx->get_backend ()->integer_type (\n+\ttree uint = ctx->get_backend ()->integer_type (\n \t  true, ctx->get_backend ()->get_pointer_size ());\n-\tBtype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\ttree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n \t\t\t\t      ctx->get_mappings ()->lookup_location (\n \t\t\t\t\ttype.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -679,7 +679,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   Context *ctx;\n   bool trait_object_mode;\n-  ::Btype *translated;\n+  ::tree translated;\n   size_t recursion_count;\n \n   static const size_t kDefaultRecusionLimit = 5;"}, {"sha": "0279ef93cf8af4d707e603c4199188bb32bf17e0", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -150,7 +150,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     {\n       TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n       auto indirect_ty = r->get_base ();\n-      Btype *indrect_compiled_tyty\n+      tree indrect_compiled_tyty\n \t= TyTyResolveCompile::compile (ctx, indirect_ty);\n \n       Bexpression *indirect\n@@ -171,7 +171,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\t\t    expr_locus);\n \n   // cast it to the correct fntype\n-  Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n   Bexpression *fn_convert_expr\n     = ctx->get_backend ()->convert_expression (expected_fntype,\n \t\t\t\t\t       fn_vtable_access, expr_locus);\n@@ -370,7 +370,7 @@ CompileExpr::resolve_operator_overload (\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n+\t  tree expected_type\n \t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \t  self\n \t    = ctx->get_backend ()->indirect_expression (expected_type, self,"}, {"sha": "d2f79ec68f9a888ef12e7bf2fd0e38d828733103", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -58,7 +58,7 @@ class CompileExpr : public HIRCompileBase\n \tTyTy::ReferenceType *r\n \t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n \tTyTy::BaseType *tuple_type = r->get_base ();\n-\tBtype *tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n+\ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n \n \tBexpression *indirect\n \t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n@@ -88,7 +88,7 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (tuple_type != nullptr);\n \n     // this assumes all fields are in order from type resolution\n@@ -259,7 +259,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -285,7 +285,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n@@ -341,7 +341,7 @@ class CompileExpr : public HIRCompileBase\n \t      indexes.push_back (i);\n \t    }\n \n-\t  Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+\t  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n \t  Bexpression *constructed\n \t    = ctx->get_backend ()->array_constructor_expression (\n \t      array_type, indexes, vals, expr.get_locus ());\n@@ -414,7 +414,7 @@ class CompileExpr : public HIRCompileBase\n     TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n     capacity_expr = array_tyty->get_capacity ();\n \n-    Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+    tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n     rust_assert (array_type != nullptr);\n \n     expr.get_internal_elements ()->accept_vis (*this);\n@@ -517,7 +517,7 @@ class CompileExpr : public HIRCompileBase\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n \tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -554,7 +554,7 @@ class CompileExpr : public HIRCompileBase\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n \tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -590,7 +590,7 @@ class CompileExpr : public HIRCompileBase\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n \tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -640,7 +640,7 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (type != nullptr);\n \n     // this assumes all fields are in order from type resolution and if a base\n@@ -705,7 +705,7 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t &field_index);\n \trust_assert (ok);\n \n-\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n \tBexpression *indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n@@ -743,7 +743,7 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -975,7 +975,7 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n     bool known_valid = true;\n     translated\n       = ctx->get_backend ()->indirect_expression (expected_type, main_expr,"}, {"sha": "2d3d251bb3042c74c2036c2125c4840e5028d224", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -55,7 +55,7 @@ class CompileExternItem : public HIRCompileBase\n     // FIXME this is assuming C ABI\n     std::string asm_name = name;\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     bool is_external = true;\n     bool is_hidden = false;\n     bool in_unique_section = false;\n@@ -128,7 +128,7 @@ class CompileExternItem : public HIRCompileBase\n \treturn;\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n     compiled_fn_type\n       = ctx->get_backend ()->specify_abi_attribute (compiled_fn_type,\n \t\t\t\t\t\t    fntype->get_abi ());"}, {"sha": "903f8395cb693520212071b474558f35dc6907f8", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -30,7 +30,7 @@ class CompileFnParam : public HIRCompileBase\n \n public:\n   static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::FunctionParam *param, Btype *decl_type,\n+\t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n     CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n@@ -51,14 +51,14 @@ class CompileFnParam : public HIRCompileBase\n   }\n \n private:\n-  CompileFnParam (Context *ctx, ::Bfunction *fndecl, ::Btype *decl_type,\n+  CompileFnParam (Context *ctx, ::Bfunction *fndecl, tree decl_type,\n \t\t  Location locus)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n       locus (locus), translated (nullptr)\n   {}\n \n   ::Bfunction *fndecl;\n-  ::Btype *decl_type;\n+  tree decl_type;\n   Location locus;\n   ::Bvariable *translated;\n };\n@@ -67,7 +67,7 @@ class CompileSelfParam : public HIRCompileBase\n {\n public:\n   static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::SelfParam &self, Btype *decl_type,\n+\t\t\t     HIR::SelfParam &self, tree decl_type,\n \t\t\t     Location locus)\n   {\n     bool is_immutable"}, {"sha": "51a691f4a7686261da569ce678c2fcaf7f9af761", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -60,7 +60,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n@@ -136,7 +136,7 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n \n@@ -178,7 +178,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self_param ().get_locus (),\n@@ -275,7 +275,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -349,7 +349,7 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (concrete != nullptr);\n     TyTy::BaseType *resolved_type = concrete;\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value\n       = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n \n@@ -404,7 +404,7 @@ class CompileTraitItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     HIR::TraitFunctionDecl &function = func.get_decl ();\n     unsigned int flags = 0;\n@@ -440,7 +440,7 @@ class CompileTraitItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self ().get_locus (),\n@@ -536,7 +536,7 @@ class CompileTraitItem : public HIRCompileBase\n     Bvariable *return_address = nullptr;\n     if (function.has_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n \tBstatement *ret_var_stmt = nullptr;"}, {"sha": "87c577cb8de9791d2b3ee41156a9961559bb7409", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -61,7 +61,7 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n@@ -97,7 +97,7 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n@@ -174,7 +174,7 @@ class CompileItem : public HIRCompileBase\n \tfntype->override_context ();\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n     bool is_main_fn = function.get_function_name ().compare (\"main\") == 0;\n@@ -275,7 +275,7 @@ class CompileItem : public HIRCompileBase\n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n \tBstatement *ret_var_stmt = nullptr;"}, {"sha": "80566f66b83eb9dbb918ef4053ca2e1968fdc5ce", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -56,7 +56,7 @@ class CompileStmt : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;"}, {"sha": "04a3ecd222ea0c4db1134ed876a1c64de09e16ec", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -34,7 +34,7 @@ namespace Compile {\n class TyTyCompile : public TyTy::TyVisitor\n {\n public:\n-  static ::Btype *compile (::Backend *backend, TyTy::BaseType *ty)\n+  static tree compile (::Backend *backend, TyTy::BaseType *ty)\n   {\n     TyTyCompile compiler (backend);\n     ty->accept_vis (compiler);\n@@ -72,15 +72,15 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret = TyTyCompile::compile (backend, hir_type);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n       }\n \n@@ -90,7 +90,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \tauto param_tyty = params.second;\n \tauto compiled_param_type = TyTyCompile::compile (backend, param_tyty);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pattern->as_string (), compiled_param_type,\n \t  mappings->lookup_location (param_tyty->get_ref ()));\n \n@@ -227,7 +227,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -248,7 +248,7 @@ class TyTyCompile : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  tree translated;\n   Analysis::Mappings *mappings;\n };\n "}, {"sha": "deabd7df34337e6b74cd8cd9e88b0c7936d26bdf", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -70,7 +70,7 @@ class CompileVarDecl : public HIRCompileBase\n   {}\n \n   ::Bfunction *fndecl;\n-  ::Btype *translated_type;\n+  tree translated_type;\n   Location locus;\n   ::Bvariable *translated;\n };"}, {"sha": "cb736f3b16fd2b08f08663cf00829b321c7837f3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -72,7 +72,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-      Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n       rust_assert (!adt->is_enum ());\n       rust_assert (adt->number_of_variants () == 1);\n@@ -275,7 +275,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n+\t  tree expected_type\n \t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \t  self = ctx->get_backend ()->indirect_expression (\n \t    expected_type, self, true, /* known_valid*/\n@@ -587,7 +587,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n \t\t\t\t      Location locus)\n {\n-  Btype *dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n \n   //' this assumes ordering and current the structure is\n   // __trait_object_ptr"}, {"sha": "3bdd0c6936b66a63190a44ec812f7b9ffa0a000d", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -29,6 +29,8 @@\n #include \"operator.h\"\n #include \"rust-abi.h\"\n \n+#include \"tree.h\"\n+\n extern bool\n saw_errors (void);\n \n@@ -39,9 +41,6 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend representation of a type.\n-class Btype;\n-\n // The backend represention of an expression.\n class Bexpression;\n \n@@ -70,24 +69,24 @@ class Backend\n \n   // Name/type/location.  Used for function parameters, struct fields,\n   // interface methods.\n-  struct Btyped_identifier\n+  struct typed_identifier\n   {\n     std::string name;\n-    Btype *btype;\n+    tree type;\n     Location location;\n \n-    Btyped_identifier ()\n-      : name (), btype (NULL), location (Linemap::unknown_location ())\n+    typed_identifier ()\n+      : name (), type (NULL_TREE), location (Linemap::unknown_location ())\n     {}\n \n-    Btyped_identifier (const std::string &a_name, Btype *a_btype,\n+    typed_identifier (const std::string &a_name, tree a_type,\n \t\t       Location a_location)\n-      : name (a_name), btype (a_btype), location (a_location)\n+      : name (a_name), type (a_type), location (a_location)\n     {}\n   };\n \n   // debug\n-  virtual void debug (Btype *) = 0;\n+  virtual void debug (tree) = 0;\n   virtual void debug (Bexpression *) = 0;\n   virtual void debug (Bstatement *) = 0;\n   virtual void debug (Bfunction *) = 0;\n@@ -147,50 +146,50 @@ class Backend\n \n   // Produce an error type.  Actually the backend could probably just\n   // crash if this is called.\n-  virtual Btype *error_type () = 0;\n+  virtual tree error_type () = 0;\n \n   // Get a void type.  This is used in (at least) two ways: 1) as the\n   // return type of a function with no result parameters; 2)\n   // unsafe.Pointer is represented as *void.\n-  virtual Btype *void_type () = 0;\n+  virtual tree void_type () = 0;\n \n   // get unit-type\n-  virtual Btype *unit_type () = 0;\n+  virtual tree unit_type () = 0;\n \n   // Get the unnamed boolean type.\n-  virtual Btype *bool_type () = 0;\n+  virtual tree bool_type () = 0;\n \n   // Get the char type\n-  virtual Btype *char_type () = 0;\n+  virtual tree char_type () = 0;\n \n   // Get the wchar type\n-  virtual Btype *wchar_type () = 0;\n+  virtual tree wchar_type () = 0;\n \n   // Get the Host pointer size in bits\n   virtual int get_pointer_size () = 0;\n \n   // Get the raw str type const char*\n-  virtual Btype *raw_str_type () = 0;\n+  virtual tree raw_str_type () = 0;\n \n   // Get an unnamed integer type with the given signedness and number\n   // of bits.\n-  virtual Btype *integer_type (bool is_unsigned, int bits) = 0;\n+  virtual tree integer_type (bool is_unsigned, int bits) = 0;\n \n   // Get an unnamed floating point type with the given number of bits\n   // (32 or 64).\n-  virtual Btype *float_type (int bits) = 0;\n+  virtual tree float_type (int bits) = 0;\n \n   // Get an unnamed complex type with the given number of bits (64 or 128).\n-  virtual Btype *complex_type (int bits) = 0;\n+  virtual tree complex_type (int bits) = 0;\n \n   // Get a pointer type.\n-  virtual Btype *pointer_type (Btype *to_type) = 0;\n+  virtual tree pointer_type (tree to_type) = 0;\n \n   // Get a reference type.\n-  virtual Btype *reference_type (Btype *to_type) = 0;\n+  virtual tree reference_type (tree to_type) = 0;\n \n   // make type immutable\n-  virtual Btype *immutable_type (Btype *base) = 0;\n+  virtual tree immutable_type (tree base) = 0;\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n@@ -201,62 +200,62 @@ class Backend\n   // one result, RESULT_STRUCT is a struct type to hold the results,\n   // and RESULTS may be ignored; if there are zero or one results,\n   // RESULT_STRUCT is NULL.\n-  virtual Btype *\n-  function_type (const Btyped_identifier &receiver,\n-\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t const std::vector<Btyped_identifier> &results,\n-\t\t Btype *result_struct, Location location)\n+  virtual tree\n+  function_type (const typed_identifier &receiver,\n+\t\t const std::vector<typed_identifier> &parameters,\n+\t\t const std::vector<typed_identifier> &results,\n+\t\t tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *\n-  function_type_varadic (const Btyped_identifier &receiver,\n-\t\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t\t const std::vector<Btyped_identifier> &results,\n-\t\t\t Btype *result_struct, Location location)\n+  virtual tree\n+  function_type_varadic (const typed_identifier &receiver,\n+\t\t\t const std::vector<typed_identifier> &parameters,\n+\t\t\t const std::vector<typed_identifier> &results,\n+\t\t\t tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *function_ptr_type (Btype *result,\n-\t\t\t\t    const std::vector<Btype *> &praameters,\n-\t\t\t\t    Location location)\n+  virtual tree function_ptr_type (tree result,\n+\t\t\t\t  const std::vector<tree> &praameters,\n+\t\t\t\t  Location location)\n     = 0;\n \n   // Get a struct type.\n-  virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree struct_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get a union type.\n-  virtual Btype *union_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree union_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get an array type.\n-  virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n+  virtual tree array_type (tree element_type, Bexpression *length) = 0;\n \n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n   // created via placeholder_pointer_type, placeholder_struct_type, or\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n-  virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n+  virtual tree named_type (const std::string &name, tree, Location) = 0;\n \n   // Return the size of a type.\n-  virtual int64_t type_size (Btype *) = 0;\n+  virtual int64_t type_size (tree) = 0;\n \n   // Return the alignment of a type.\n-  virtual int64_t type_alignment (Btype *) = 0;\n+  virtual int64_t type_alignment (tree) = 0;\n \n   // Return the alignment of a struct field of this type.  This is\n   // normally the same as type_alignment, but not always.\n-  virtual int64_t type_field_alignment (Btype *) = 0;\n+  virtual int64_t type_field_alignment (tree) = 0;\n \n   // Return the offset of field INDEX in a struct type.  INDEX is the\n   // entry in the FIELDS std::vector parameter of struct_type or\n   // set_placeholder_struct_type.\n-  virtual int64_t type_field_offset (Btype *, size_t index) = 0;\n+  virtual int64_t type_field_offset (tree, size_t index) = 0;\n \n   // Expressions.\n \n   // Return an expression for a zero value of the given type.  This is\n   // used for cases such as local variable initialization and\n   // converting nil to other types.\n-  virtual Bexpression *zero_expression (Btype *) = 0;\n+  virtual Bexpression *zero_expression (tree) = 0;\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n@@ -278,27 +277,25 @@ class Backend\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n   // is known to point to a valid memory location.  BTYPE is the expected type\n   // of the indirected EXPR.\n-  virtual Bexpression *indirect_expression (Btype *btype, Bexpression *expr,\n+  virtual Bexpression *indirect_expression (tree btype, Bexpression *expr,\n \t\t\t\t\t    bool known_valid, Location)\n     = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE.\n-  virtual Bexpression *named_constant_expression (Btype *btype,\n+  virtual Bexpression *named_constant_expression (tree btype,\n \t\t\t\t\t\t  const std::string &name,\n \t\t\t\t\t\t  Bexpression *val, Location)\n     = 0;\n \n   // Return an expression for the multi-precision integer VAL in BTYPE.\n-  virtual Bexpression *integer_constant_expression (Btype *btype, mpz_t val)\n-    = 0;\n+  virtual Bexpression *integer_constant_expression (tree btype, mpz_t val) = 0;\n \n   // Return an expression for the floating point value VAL in BTYPE.\n-  virtual Bexpression *float_constant_expression (Btype *btype, mpfr_t val) = 0;\n+  virtual Bexpression *float_constant_expression (tree btype, mpfr_t val) = 0;\n \n   // Return an expression for the complex value VAL in BTYPE.\n-  virtual Bexpression *complex_constant_expression (Btype *btype, mpc_t val)\n-    = 0;\n+  virtual Bexpression *complex_constant_expression (tree btype, mpc_t val) = 0;\n \n   // Return an expression for the string value VAL.\n   virtual Bexpression *string_constant_expression (const std::string &val) = 0;\n@@ -326,7 +323,7 @@ class Backend\n     = 0;\n \n   // Return an expression that converts EXPR to TYPE.\n-  virtual Bexpression *convert_expression (Btype *type, Bexpression *expr,\n+  virtual Bexpression *convert_expression (tree type, Bexpression *expr,\n \t\t\t\t\t   Location)\n     = 0;\n \n@@ -350,10 +347,10 @@ class Backend\n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual Bexpression *\n-  conditional_expression (Bfunction *function, Btype *btype,\n-\t\t\t  Bexpression *condition, Bexpression *then_expr,\n-\t\t\t  Bexpression *else_expr, Location)\n+  virtual Bexpression *conditional_expression (Bfunction *function, tree btype,\n+\t\t\t\t\t       Bexpression *condition,\n+\t\t\t\t\t       Bexpression *then_expr,\n+\t\t\t\t\t       Bexpression *else_expr, Location)\n     = 0;\n \n   // Return an expression for the negation operation OP EXPR.\n@@ -388,15 +385,15 @@ class Backend\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n   virtual Bexpression *\n-  constructor_expression (Btype *btype, const std::vector<Bexpression *> &vals,\n+  constructor_expression (tree btype, const std::vector<Bexpression *> &vals,\n \t\t\t  int, Location)\n     = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and\n   // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n   // in INDEXES must be in the same order as the corresponding value in VALS.\n   virtual Bexpression *array_constructor_expression (\n-    Btype *btype, const std::vector<unsigned long> &indexes,\n+    tree btype, const std::vector<unsigned long> &indexes,\n     const std::vector<Bexpression *> &vals, Location)\n     = 0;\n \n@@ -535,7 +532,7 @@ class Backend\n   // permit the linker to garbage collect the variable if it is not\n   // referenced.  LOCATION is where the variable was defined.\n   virtual Bvariable *global_variable (const std::string &name,\n-\t\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t\t      const std::string &asm_name, tree btype,\n \t\t\t\t      bool is_external, bool is_hidden,\n \t\t\t\t      bool in_unique_section, Location location)\n     = 0;\n@@ -561,22 +558,22 @@ class Backend\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n   virtual Bvariable *\n-  local_variable (Bfunction *function, const std::string &name, Btype *type,\n+  local_variable (Bfunction *function, const std::string &name, tree type,\n \t\t  Bvariable *decl_var, bool is_address_taken, Location location)\n     = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n   virtual Bvariable *\n-  parameter_variable (Bfunction *function, const std::string &name, Btype *type,\n+  parameter_variable (Bfunction *function, const std::string &name, tree type,\n \t\t      bool is_address_taken, Location location)\n     = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n   virtual Bvariable *static_chain_variable (Bfunction *function,\n-\t\t\t\t\t    const std::string &name,\n-\t\t\t\t\t    Btype *type, Location location)\n+\t\t\t\t\t    const std::string &name, tree type,\n+\t\t\t\t\t    Location location)\n     = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n@@ -591,7 +588,7 @@ class Backend\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n   virtual Bvariable *\n-  temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *init,\n+  temporary_variable (Bfunction *, Bblock *, tree, Bexpression *init,\n \t\t      bool address_is_taken, Location location,\n \t\t      Bstatement **pstatement)\n     = 0;\n@@ -622,10 +619,10 @@ class Backend\n   // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable *\n-  implicit_variable (const std::string &name, const std::string &asm_name,\n-\t\t     Btype *type, bool is_hidden, bool is_constant,\n-\t\t     bool is_common, int64_t alignment)\n+  virtual Bvariable *implicit_variable (const std::string &name,\n+\t\t\t\t\tconst std::string &asm_name, tree type,\n+\t\t\t\t\tbool is_hidden, bool is_constant,\n+\t\t\t\t\tbool is_common, int64_t alignment)\n     = 0;\n \n   // Set the initial value of a variable created by implicit_variable.\n@@ -639,7 +636,7 @@ class Backend\n   // If IS_COMMON is true, INIT will be NULL, and the\n   // variable should be initialized to all zeros.\n   virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t   Btype *type, bool is_hidden,\n+\t\t\t\t\t   tree type, bool is_hidden,\n \t\t\t\t\t   bool is_constant, bool is_common,\n \t\t\t\t\t   Bexpression *init)\n     = 0;\n@@ -651,7 +648,7 @@ class Backend\n   // variable in C.\n   virtual Bvariable *implicit_variable_reference (const std::string &name,\n \t\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t\t  Btype *type)\n+\t\t\t\t\t\t  tree type)\n     = 0;\n \n   // Create a named immutable initialized data structure.  This is\n@@ -684,7 +681,7 @@ class Backend\n   // immutable_struct_set_init.\n   virtual Bvariable *\n   immutable_struct (const std::string &name, const std::string &asm_name,\n-\t\t    bool is_hidden, bool is_common, Btype *type, Location)\n+\t\t    bool is_hidden, bool is_common, tree type, Location)\n     = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n@@ -696,7 +693,7 @@ class Backend\n   // immutable_struct.\n   virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n \t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  Btype *type, Location,\n+\t\t\t\t\t  tree type, Location,\n \t\t\t\t\t  Bexpression *initializer)\n     = 0;\n \n@@ -707,7 +704,7 @@ class Backend\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable *immutable_struct_reference (const std::string &name,\n \t\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t\t Btype *type, Location)\n+\t\t\t\t\t\t tree type, Location)\n     = 0;\n \n   // Labels.\n@@ -774,12 +771,12 @@ class Backend\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n-  virtual Bfunction *function (Btype *fntype, const std::string &name,\n+  virtual Bfunction *function (tree fntype, const std::string &name,\n \t\t\t       const std::string &asm_name, unsigned int flags,\n \t\t\t       Location)\n     = 0;\n \n-  virtual Btype *specify_abi_attribute (Btype *type, Rust::ABI abi) = 0;\n+  virtual tree specify_abi_attribute (tree type, Rust::ABI abi) = 0;\n \n   // Create a statement that runs all deferred calls for FUNCTION.  This should\n   // be a statement that looks like this in C++:\n@@ -814,7 +811,7 @@ class Backend\n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n   virtual void\n-  write_global_definitions (const std::vector<Btype *> &type_decls,\n+  write_global_definitions (const std::vector<tree> &type_decls,\n \t\t\t    const std::vector<Bexpression *> &constant_decls,\n \t\t\t    const std::vector<Bfunction *> &function_decls,\n \t\t\t    const std::vector<Bvariable *> &variable_decls)"}, {"sha": "a205d65bc8cc65bfe6162f2418fbd72959ef8ef0", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 191, "deletions": 235, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -69,11 +69,6 @@ class Gcc_tree\n };\n \n // In gcc, types, expressions, and statements are all trees.\n-class Btype : public Gcc_tree\n-{\n-public:\n-  Btype (tree t) : Gcc_tree (t) {}\n-};\n \n class Bexpression : public Gcc_tree\n {\n@@ -159,7 +154,7 @@ class Gcc_backend : public Backend\n public:\n   Gcc_backend ();\n \n-  void debug (Btype *t) { debug_tree (t->get_tree ()); };\n+  void debug (tree t) { debug_tree (t); };\n   void debug (Bexpression *t) { debug_tree (t->get_tree ()); };\n   void debug (Bstatement *t) { debug_tree (t->get_tree ()); };\n   void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n@@ -168,13 +163,13 @@ class Gcc_backend : public Backend\n   void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n \n   // Types.\n-  Btype *error_type () { return this->make_type (error_mark_node); }\n+  tree error_type () { return error_mark_node; }\n \n-  Btype *void_type () { return this->make_type (void_type_node); }\n+  tree void_type () { return void_type_node; }\n \n-  Btype *unit_type ()\n+  tree unit_type ()\n   {\n-    static Btype *unit_type;\n+    static tree unit_type;\n     if (unit_type == nullptr)\n       {\n \tauto unit_type_node = integer_type (true, 0);\n@@ -185,9 +180,9 @@ class Gcc_backend : public Backend\n     return unit_type;\n   }\n \n-  Btype *bool_type () { return this->make_type (boolean_type_node); }\n+  tree bool_type () { return boolean_type_node; }\n \n-  Btype *char_type () { return this->make_type (char_type_node); }\n+  tree char_type () { return char_type_node; }\n \n   bool const_size_cast (Bexpression *expr, size_t *result)\n   {\n@@ -221,72 +216,71 @@ class Gcc_backend : public Backend\n \n   bool const_values_equal (Bexpression *a, Bexpression *b)\n   {\n-    return operand_equal_p (a->get_tree (), b->get_tree (),\n-\t\t\t    OEP_ONLY_CONST | OEP_PURE_SAME);\n+    return operand_equal_p (a->get_tree (), b->get_tree (), OEP_ONLY_CONST | OEP_PURE_SAME);\n     // printf (\"comparing!\\n\");\n     // debug_tree (a->get_tree ());\n     // debug_tree (b->get_tree ());\n     // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n   }\n \n-  Btype *wchar_type ()\n+  tree wchar_type ()\n   {\n     tree wchar = make_unsigned_type (32);\n     TYPE_STRING_FLAG (wchar) = 1;\n-    return this->make_type (wchar);\n+    return wchar;\n   }\n \n   int get_pointer_size ();\n \n-  Btype *raw_str_type ();\n+  tree raw_str_type ();\n \n-  Btype *integer_type (bool, int);\n+  tree integer_type (bool, int);\n \n-  Btype *float_type (int);\n+  tree float_type (int);\n \n-  Btype *complex_type (int);\n+  tree complex_type (int);\n \n-  Btype *pointer_type (Btype *);\n+  tree pointer_type (tree);\n \n-  Btype *reference_type (Btype *);\n+  tree reference_type (tree);\n \n-  Btype *immutable_type (Btype *);\n+  tree immutable_type (tree);\n \n-  Btype *specify_abi_attribute (Btype *, Rust::ABI);\n+  tree specify_abi_attribute (tree, Rust::ABI);\n \n-  Btype *insert_type_attribute (Btype *, const std::string &);\n+  tree insert_type_attribute (tree, const std::string &);\n \n-  Btype *function_type (const Btyped_identifier &,\n-\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n+  tree function_type (const typed_identifier &,\n+\t\t\tconst std::vector<typed_identifier> &,\n+\t\t\tconst std::vector<typed_identifier> &, tree,\n \t\t\tconst Location);\n \n-  Btype *function_type_varadic (const Btyped_identifier &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n+  tree function_type_varadic (const typed_identifier &,\n+\t\t\t\tconst std::vector<typed_identifier> &,\n+\t\t\t\tconst std::vector<typed_identifier> &, tree,\n \t\t\t\tconst Location);\n \n-  Btype *function_ptr_type (Btype *, const std::vector<Btype *> &, Location);\n+  tree function_ptr_type (tree, const std::vector<tree> &, Location);\n \n-  Btype *struct_type (const std::vector<Btyped_identifier> &);\n+  tree struct_type (const std::vector<typed_identifier> &);\n \n-  Btype *union_type (const std::vector<Btyped_identifier> &);\n+  tree union_type (const std::vector<typed_identifier> &);\n \n-  Btype *array_type (Btype *, Bexpression *);\n+  tree array_type (tree, Bexpression *);\n \n-  Btype *named_type (const std::string &, Btype *, Location);\n+  tree named_type (const std::string &, tree, Location);\n \n-  int64_t type_size (Btype *);\n+  int64_t type_size (tree);\n \n-  int64_t type_alignment (Btype *);\n+  int64_t type_alignment (tree);\n \n-  int64_t type_field_alignment (Btype *);\n+  int64_t type_field_alignment (tree);\n \n-  int64_t type_field_offset (Btype *, size_t index);\n+  int64_t type_field_offset (tree, size_t index);\n \n   // Expressions.\n \n-  Bexpression *zero_expression (Btype *);\n+  Bexpression *zero_expression (tree);\n \n   Bexpression *error_expression ()\n   {\n@@ -310,17 +304,17 @@ class Gcc_backend : public Backend\n \n   Bexpression *var_expression (Bvariable *var, Location);\n \n-  Bexpression *indirect_expression (Btype *, Bexpression *expr,\n+  Bexpression *indirect_expression (tree, Bexpression *expr,\n \t\t\t\t    bool known_valid, Location);\n \n-  Bexpression *named_constant_expression (Btype *btype, const std::string &name,\n+  Bexpression *named_constant_expression (tree type, const std::string &name,\n \t\t\t\t\t  Bexpression *val, Location);\n \n-  Bexpression *integer_constant_expression (Btype *btype, mpz_t val);\n+  Bexpression *integer_constant_expression (tree type, mpz_t val);\n \n-  Bexpression *float_constant_expression (Btype *btype, mpfr_t val);\n+  Bexpression *float_constant_expression (tree type, mpfr_t val);\n \n-  Bexpression *complex_constant_expression (Btype *btype, mpc_t val);\n+  Bexpression *complex_constant_expression (tree type, mpc_t val);\n \n   Bexpression *string_constant_expression (const std::string &val);\n \n@@ -337,7 +331,7 @@ class Gcc_backend : public Backend\n   Bexpression *complex_expression (Bexpression *breal, Bexpression *bimag,\n \t\t\t\t   Location);\n \n-  Bexpression *convert_expression (Btype *type, Bexpression *expr, Location);\n+  Bexpression *convert_expression (tree type, Bexpression *expr, Location);\n \n   Bexpression *function_code_expression (Bfunction *, Location);\n \n@@ -347,7 +341,7 @@ class Gcc_backend : public Backend\n \n   Bexpression *compound_expression (Bstatement *, Bexpression *, Location);\n \n-  Bexpression *conditional_expression (Bfunction *, Btype *, Bexpression *,\n+  Bexpression *conditional_expression (Bfunction *, tree, Bexpression *,\n \t\t\t\t       Bexpression *, Bexpression *, Location);\n \n   Bexpression *negation_expression (NegationOperator op, Bexpression *expr,\n@@ -364,11 +358,11 @@ class Gcc_backend : public Backend\n \t\t\t\t\tBexpression *left, Bexpression *right,\n \t\t\t\t\tLocation);\n \n-  Bexpression *constructor_expression (Btype *,\n+  Bexpression *constructor_expression (tree,\n \t\t\t\t       const std::vector<Bexpression *> &, int,\n \t\t\t\t       Location);\n \n-  Bexpression *array_constructor_expression (Btype *,\n+  Bexpression *array_constructor_expression (tree,\n \t\t\t\t\t     const std::vector<unsigned long> &,\n \t\t\t\t\t     const std::vector<Bexpression *> &,\n \t\t\t\t\t     Location);\n@@ -434,41 +428,41 @@ class Gcc_backend : public Backend\n   Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n \n   Bvariable *global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location);\n \n   void global_variable_set_init (Bvariable *, Bexpression *);\n \n-  Bvariable *local_variable (Bfunction *, const std::string &, Btype *,\n+  Bvariable *local_variable (Bfunction *, const std::string &, tree,\n \t\t\t     Bvariable *, bool, Location);\n \n-  Bvariable *parameter_variable (Bfunction *, const std::string &, Btype *,\n+  Bvariable *parameter_variable (Bfunction *, const std::string &, tree,\n \t\t\t\t bool, Location);\n \n-  Bvariable *static_chain_variable (Bfunction *, const std::string &, Btype *,\n+  Bvariable *static_chain_variable (Bfunction *, const std::string &, tree,\n \t\t\t\t    Location);\n \n-  Bvariable *temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *,\n+  Bvariable *temporary_variable (Bfunction *, Bblock *, tree, Bexpression *,\n \t\t\t\t bool, Location, Bstatement **);\n \n   Bvariable *implicit_variable (const std::string &, const std::string &,\n-\t\t\t\tBtype *, bool, bool, bool, int64_t);\n+\t\t\t\ttree, bool, bool, bool, int64_t);\n \n-  void implicit_variable_set_init (Bvariable *, const std::string &, Btype *,\n+  void implicit_variable_set_init (Bvariable *, const std::string &, tree,\n \t\t\t\t   bool, bool, bool, Bexpression *);\n \n   Bvariable *implicit_variable_reference (const std::string &,\n-\t\t\t\t\t  const std::string &, Btype *);\n+\t\t\t\t\t  const std::string &, tree);\n \n   Bvariable *immutable_struct (const std::string &, const std::string &, bool,\n-\t\t\t       bool, Btype *, Location);\n+\t\t\t       bool, tree, Location);\n \n   void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  Btype *, Location, Bexpression *);\n+\t\t\t\t  tree, Location, Bexpression *);\n \n   Bvariable *immutable_struct_reference (const std::string &,\n-\t\t\t\t\t const std::string &, Btype *,\n+\t\t\t\t\t const std::string &, tree,\n \t\t\t\t\t Location);\n \n   // Labels.\n@@ -485,7 +479,7 @@ class Gcc_backend : public Backend\n \n   Bfunction *error_function () { return this->make_function (error_mark_node); }\n \n-  Bfunction *function (Btype *fntype, const std::string &name,\n+  Bfunction *function (tree fntype, const std::string &name,\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location);\n \n@@ -502,7 +496,7 @@ class Gcc_backend : public Backend\n \n   Bfunction *lookup_builtin_by_rust_name (const std::string &);\n \n-  void write_global_definitions (const std::vector<Btype *> &,\n+  void write_global_definitions (const std::vector<tree> &,\n \t\t\t\t const std::vector<Bexpression *> &,\n \t\t\t\t const std::vector<Bfunction *> &,\n \t\t\t\t const std::vector<Bvariable *> &);\n@@ -516,14 +510,11 @@ class Gcc_backend : public Backend\n   // Make a Bstatement from a tree.\n   Bstatement *make_statement (tree t) { return new Bstatement (t); }\n \n-  // Make a Btype from a tree.\n-  Btype *make_type (tree t) { return new Btype (t); }\n-\n   Bfunction *make_function (tree t) { return new Bfunction (t); }\n \n-  Btype *fill_in_fields (Btype *, const std::vector<Btyped_identifier> &);\n+  tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n \n-  Btype *fill_in_array (Btype *, Btype *, Bexpression *);\n+  tree fill_in_array (tree, tree, Bexpression *);\n \n   tree non_zero_size_type (tree);\n \n@@ -791,15 +782,15 @@ Gcc_backend::get_pointer_size ()\n   return POINTER_SIZE;\n }\n \n-Btype *\n+tree\n Gcc_backend::raw_str_type ()\n {\n   tree char_ptr = build_pointer_type (char_type_node);\n   tree const_char_type = build_qualified_type (char_ptr, TYPE_QUAL_CONST);\n-  return this->make_type (const_char_type);\n+  return const_char_type;\n }\n \n-Btype *\n+tree\n Gcc_backend::integer_type (bool is_unsigned, int bits)\n {\n   tree type;\n@@ -829,12 +820,12 @@ Gcc_backend::integer_type (bool is_unsigned, int bits)\n       else\n \ttype = make_signed_type (bits);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed float type.\n \n-Btype *\n+tree\n Gcc_backend::float_type (int bits)\n {\n   tree type;\n@@ -850,12 +841,12 @@ Gcc_backend::float_type (int bits)\n       TYPE_PRECISION (type) = bits;\n       layout_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed complex type.\n \n-Btype *\n+tree\n Gcc_backend::complex_type (int bits)\n {\n   tree type;\n@@ -872,49 +863,46 @@ Gcc_backend::complex_type (int bits)\n       layout_type (type);\n       type = build_complex_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get a pointer type.\n \n-Btype *\n-Gcc_backend::pointer_type (Btype *to_type)\n+tree\n+Gcc_backend::pointer_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_pointer_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_pointer_type (to_type);\n+  return type;\n }\n \n // Get a reference type.\n \n-Btype *\n-Gcc_backend::reference_type (Btype *to_type)\n+tree\n+Gcc_backend::reference_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_reference_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_reference_type (to_type);\n+  return type;\n }\n \n // Get immutable type\n \n-Btype *\n-Gcc_backend::immutable_type (Btype *base)\n+tree\n+Gcc_backend::immutable_type (tree base)\n {\n-  tree type_tree = base->get_tree ();\n-  if (type_tree == error_mark_node)\n+  if (base == error_mark_node)\n     return this->error_type ();\n-  tree constified = build_qualified_type (type_tree, TYPE_QUAL_CONST);\n-  return this->make_type (constified);\n+  tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n+  return constified;\n }\n \n // ABI\n \n-Btype *\n-Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n+tree\n+Gcc_backend::specify_abi_attribute (tree type, Rust::ABI abi)\n {\n   std::string abi_string;\n   switch (abi)\n@@ -940,46 +928,46 @@ Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n   return insert_type_attribute (type, abi_string);\n }\n \n-Btype *\n-Gcc_backend::insert_type_attribute (Btype *type, const std::string &attrname)\n+tree\n+Gcc_backend::insert_type_attribute (tree type, const std::string &attrname)\n {\n   tree ident = get_identifier (attrname.c_str ());\n \n   tree attribs = NULL_TREE;\n-  tree old_attrs = TYPE_ATTRIBUTES (type->get_tree ());\n+  tree old_attrs = TYPE_ATTRIBUTES (type);\n   if (old_attrs)\n     attribs = merge_type_attributes (old_attrs,\n \t\t\t\t     tree_cons (ident, NULL_TREE, NULL_TREE));\n   else\n     attribs = tree_cons (ident, NULL_TREE, NULL_TREE);\n \n-  tree res = build_type_attribute_variant (type->get_tree (), attribs);\n-  return this->make_type (res);\n+  tree res = build_type_attribute_variant (type, attribs);\n+  return res;\n }\n \n // Make a function type.\n \n-Btype *\n-Gcc_backend::function_type (const Btyped_identifier &receiver,\n-\t\t\t    const std::vector<Btyped_identifier> &parameters,\n-\t\t\t    const std::vector<Btyped_identifier> &results,\n-\t\t\t    Btype *result_struct, Location)\n+tree\n+Gcc_backend::function_type (const typed_identifier &receiver,\n+\t\t\t    const std::vector<typed_identifier> &parameters,\n+\t\t\t    const std::vector<typed_identifier> &results,\n+\t\t\t    tree result_struct, Location)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n@@ -994,11 +982,11 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n       gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1015,32 +1003,32 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n+tree\n Gcc_backend::function_type_varadic (\n-  const Btyped_identifier &receiver,\n-  const std::vector<Btyped_identifier> &parameters,\n-  const std::vector<Btyped_identifier> &results, Btype *result_struct, Location)\n+  const typed_identifier &receiver,\n+  const std::vector<typed_identifier> &parameters,\n+  const std::vector<typed_identifier> &results, tree result_struct, Location)\n {\n-  size_t n = parameters.size () + (receiver.btype != NULL ? 1 : 0);\n+  size_t n = parameters.size () + (receiver.type != NULL_TREE ? 1 : 0);\n   tree *args = XALLOCAVEC (tree, n);\n   size_t offs = 0;\n \n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n \n       args[offs++] = t;\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       args[offs++] = t;\n@@ -1050,11 +1038,11 @@ Gcc_backend::function_type_varadic (\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n-      gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      gcc_assert (result_struct != NULL_TREE);\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1071,113 +1059,107 @@ Gcc_backend::function_type_varadic (\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n-Gcc_backend::function_ptr_type (Btype *result_type,\n-\t\t\t\tconst std::vector<Btype *> &parameters,\n+tree\n+Gcc_backend::function_ptr_type (tree result_type,\n+\t\t\t\tconst std::vector<tree> &parameters,\n \t\t\t\tLocation /* locus */)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n \n   for (auto &param : parameters)\n     {\n-      tree t = param->get_tree ();\n-      if (t == error_mark_node)\n+      if (param == error_mark_node)\n \treturn this->error_type ();\n \n-      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n   *pp = void_list_node;\n \n-  tree result = result_type->get_tree ();\n+  tree result = result_type;\n   if (result != void_type_node && int_size_in_bytes (result) == 0)\n     result = void_type_node;\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n // Make a struct type.\n \n-Btype *\n-Gcc_backend::struct_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::struct_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (RECORD_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (RECORD_TYPE), fields);\n }\n \n // Make a union type.\n \n-Btype *\n-Gcc_backend::union_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::union_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (UNION_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (UNION_TYPE), fields);\n }\n \n // Fill in the fields of a struct or union type.\n \n-Btype *\n-Gcc_backend::fill_in_fields (Btype *fill,\n-\t\t\t     const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::fill_in_fields (tree fill,\n+\t\t\t     const std::vector<typed_identifier> &fields)\n {\n-  tree fill_tree = fill->get_tree ();\n   tree field_trees = NULL_TREE;\n   tree *pp = &field_trees;\n-  for (std::vector<Btyped_identifier>::const_iterator p = fields.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = fields.begin ();\n        p != fields.end (); ++p)\n     {\n       tree name_tree = get_identifier_from_string (p->name);\n-      tree type_tree = p->btype->get_tree ();\n+      tree type_tree = p->type;\n       if (type_tree == error_mark_node)\n \treturn this->error_type ();\n       tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n \t\t\t       name_tree, type_tree);\n-      DECL_CONTEXT (field) = fill_tree;\n+      DECL_CONTEXT (field) = fill;\n       *pp = field;\n       pp = &DECL_CHAIN (field);\n     }\n-  TYPE_FIELDS (fill_tree) = field_trees;\n-  layout_type (fill_tree);\n+  TYPE_FIELDS (fill) = field_trees;\n+  layout_type (fill);\n \n   // Because Rust permits converting between named struct types and\n   // equivalent struct types, for which we use VIEW_CONVERT_EXPR, and\n   // because we don't try to maintain TYPE_CANONICAL for struct types,\n   // we need to tell the middle-end to use structural equality.\n-  SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n+  SET_TYPE_STRUCTURAL_EQUALITY (fill);\n \n   return fill;\n }\n \n // Make an array type.\n \n-Btype *\n-Gcc_backend::array_type (Btype *element_btype, Bexpression *length)\n+tree\n+Gcc_backend::array_type (tree element_type, Bexpression *length)\n {\n-  return this->fill_in_array (this->make_type (make_node (ARRAY_TYPE)),\n-\t\t\t      element_btype, length);\n+  return this->fill_in_array (make_node (ARRAY_TYPE), element_type, length);\n }\n \n // Fill in an array type.\n \n-Btype *\n-Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n+tree\n+Gcc_backend::fill_in_array (tree fill, tree element_type,\n \t\t\t    Bexpression *length)\n {\n-  tree element_type_tree = element_type->get_tree ();\n   tree length_tree = length->get_tree ();\n-  if (element_type_tree == error_mark_node || length_tree == error_mark_node)\n+  if (element_type == error_mark_node || length_tree == error_mark_node)\n     return this->error_type ();\n \n-  gcc_assert (TYPE_SIZE (element_type_tree) != NULL_TREE);\n+  gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n \n   length_tree = fold_convert (sizetype, length_tree);\n \n@@ -1186,30 +1168,27 @@ Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n   tree index_type_tree = build_index_type (\n     fold_build2 (MINUS_EXPR, sizetype, length_tree, size_one_node));\n \n-  tree fill_tree = fill->get_tree ();\n-  TREE_TYPE (fill_tree) = element_type_tree;\n-  TYPE_DOMAIN (fill_tree) = index_type_tree;\n-  TYPE_ADDR_SPACE (fill_tree) = TYPE_ADDR_SPACE (element_type_tree);\n-  layout_type (fill_tree);\n+  TREE_TYPE (fill) = element_type;\n+  TYPE_DOMAIN (fill) = index_type_tree;\n+  TYPE_ADDR_SPACE (fill) = TYPE_ADDR_SPACE (element_type);\n+  layout_type (fill);\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (element_type_tree))\n-    SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n-  else if (TYPE_CANONICAL (element_type_tree) != element_type_tree\n+  if (TYPE_STRUCTURAL_EQUALITY_P (element_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (fill);\n+  else if (TYPE_CANONICAL (element_type) != element_type\n \t   || TYPE_CANONICAL (index_type_tree) != index_type_tree)\n-    TYPE_CANONICAL (fill_tree)\n-      = build_array_type (TYPE_CANONICAL (element_type_tree),\n+    TYPE_CANONICAL (fill)\n+      = build_array_type (TYPE_CANONICAL (element_type),\n \t\t\t  TYPE_CANONICAL (index_type_tree));\n \n   return fill;\n }\n \n // Return a named version of a type.\n \n-Btype *\n-Gcc_backend::named_type (const std::string &name, Btype *btype,\n-\t\t\t Location location)\n+tree\n+Gcc_backend::named_type (const std::string &name, tree type, Location location)\n {\n-  tree type = btype->get_tree ();\n   if (type == error_mark_node)\n     return this->error_type ();\n \n@@ -1225,23 +1204,22 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n       tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n \t\t\t      get_identifier_from_string (name), type);\n       TYPE_NAME (type) = decl;\n-      return this->make_type (type);\n+      return type;\n     }\n \n   tree copy = build_variant_type_copy (type);\n   tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n \t\t\t  get_identifier_from_string (name), copy);\n   DECL_ORIGINAL_TYPE (decl) = type;\n   TYPE_NAME (copy) = decl;\n-  return this->make_type (copy);\n+  return copy;\n }\n \n // Return the size of a type.\n \n int64_t\n-Gcc_backend::type_size (Btype *btype)\n+Gcc_backend::type_size (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   if (t == void_type_node)\n@@ -1258,9 +1236,8 @@ Gcc_backend::type_size (Btype *btype)\n // Return the alignment of a type.\n \n int64_t\n-Gcc_backend::type_alignment (Btype *btype)\n+Gcc_backend::type_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return TYPE_ALIGN_UNIT (t);\n@@ -1269,9 +1246,8 @@ Gcc_backend::type_alignment (Btype *btype)\n // Return the alignment of a struct field of type BTYPE.\n \n int64_t\n-Gcc_backend::type_field_alignment (Btype *btype)\n+Gcc_backend::type_field_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return rust_field_alignment (t);\n@@ -1280,9 +1256,8 @@ Gcc_backend::type_field_alignment (Btype *btype)\n // Return the offset of a field in a struct.\n \n int64_t\n-Gcc_backend::type_field_offset (Btype *btype, size_t index)\n+Gcc_backend::type_field_offset (tree struct_tree, size_t index)\n {\n-  tree struct_tree = btype->get_tree ();\n   if (struct_tree == error_mark_node)\n     return 0;\n   gcc_assert (TREE_CODE (struct_tree) == RECORD_TYPE);\n@@ -1301,9 +1276,8 @@ Gcc_backend::type_field_offset (Btype *btype, size_t index)\n // Return the zero value for a type.\n \n Bexpression *\n-Gcc_backend::zero_expression (Btype *btype)\n+Gcc_backend::zero_expression (tree t)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     ret = error_mark_node;\n@@ -1326,11 +1300,10 @@ Gcc_backend::var_expression (Bvariable *var, Location location)\n // An expression that indirectly references an expression.\n \n Bexpression *\n-Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n+Gcc_backend::indirect_expression (tree type_tree, Bexpression *expr,\n \t\t\t\t  bool known_valid, Location location)\n {\n   tree expr_tree = expr->get_tree ();\n-  tree type_tree = btype->get_tree ();\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1351,10 +1324,9 @@ Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n // constant value VAL in BTYPE.\n \n Bexpression *\n-Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n+Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n \t\t\t\t\tBexpression *val, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   tree const_val = val->get_tree ();\n   if (type_tree == error_mark_node || const_val == error_mark_node)\n     return this->error_expression ();\n@@ -1373,9 +1345,8 @@ Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n // Return a typed value as a constant integer.\n \n Bexpression *\n-Gcc_backend::integer_constant_expression (Btype *btype, mpz_t val)\n+Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return this->error_expression ();\n \n@@ -1386,9 +1357,8 @@ Gcc_backend::integer_constant_expression (Btype *btype, mpz_t val)\n // Return a typed value as a constant floating-point number.\n \n Bexpression *\n-Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n+Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1404,9 +1374,8 @@ Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n // Return a typed real and imaginary value as a constant complex number.\n \n Bexpression *\n-Gcc_backend::complex_constant_expression (Btype *btype, mpc_t val)\n+Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1444,14 +1413,14 @@ Gcc_backend::string_constant_expression (const std::string &val)\n Bexpression *\n Gcc_backend::wchar_constant_expression (wchar_t c)\n {\n-  tree ret = build_int_cst (this->wchar_type ()->get_tree (), c);\n+  tree ret = build_int_cst (this->wchar_type (), c);\n   return this->make_expression (ret);\n }\n \n Bexpression *\n Gcc_backend::char_constant_expression (char c)\n {\n-  tree ret = build_int_cst (this->char_type ()->get_tree (), c);\n+  tree ret = build_int_cst (this->char_type (), c);\n   return this->make_expression (ret);\n }\n \n@@ -1516,17 +1485,16 @@ Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n // An expression that converts an expression to a different type.\n \n Bexpression *\n-Gcc_backend::convert_expression (Btype *type, Bexpression *expr,\n+Gcc_backend::convert_expression (tree type_tree, Bexpression *expr,\n \t\t\t\t Location location)\n {\n-  tree type_tree = type->get_tree ();\n   tree expr_tree = expr->get_tree ();\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n   tree ret;\n-  if (this->type_size (type) == 0 || TREE_TYPE (expr_tree) == void_type_node)\n+  if (this->type_size (type_tree) == 0 || TREE_TYPE (expr_tree) == void_type_node)\n     {\n       // Do not convert zero-sized types.\n       ret = expr_tree;\n@@ -1628,12 +1596,11 @@ Gcc_backend::compound_expression (Bstatement *bstat, Bexpression *bexpr,\n // ELSE_EXPR otherwise.\n \n Bexpression *\n-Gcc_backend::conditional_expression (Bfunction *, Btype *btype,\n+Gcc_backend::conditional_expression (Bfunction *, tree type_tree,\n \t\t\t\t     Bexpression *condition,\n \t\t\t\t     Bexpression *then_expr,\n \t\t\t\t     Bexpression *else_expr, Location location)\n {\n-  tree type_tree = btype == NULL ? void_type_node : btype->get_tree ();\n   tree cond_tree = condition->get_tree ();\n   tree then_tree = then_expr->get_tree ();\n   tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree ();\n@@ -1876,11 +1843,10 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n // Return an expression that constructs BTYPE with VALS.\n \n Bexpression *\n-Gcc_backend::constructor_expression (Btype *btype,\n+Gcc_backend::constructor_expression (tree type_tree,\n \t\t\t\t     const std::vector<Bexpression *> &vals,\n \t\t\t\t     int union_index, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1965,10 +1931,9 @@ Gcc_backend::constructor_expression (Btype *btype,\n \n Bexpression *\n Gcc_backend::array_constructor_expression (\n-  Btype *array_btype, const std::vector<unsigned long> &indexes,\n+  tree type_tree, const std::vector<unsigned long> &indexes,\n   const std::vector<Bexpression *> &vals, Location location)\n {\n-  tree type_tree = array_btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2674,11 +2639,10 @@ Gcc_backend::convert_tree (tree type_tree, tree expr_tree, Location location)\n \n Bvariable *\n Gcc_backend::global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type_tree,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -2742,10 +2706,9 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n \n Bvariable *\n Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n-\t\t\t     Btype *btype, Bvariable *decl_var,\n+\t\t\t     tree type_tree, Bvariable *decl_var,\n \t\t\t     bool is_address_taken, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), VAR_DECL,\n@@ -2767,10 +2730,9 @@ Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n \n Bvariable *\n Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n-\t\t\t\t Btype *btype, bool is_address_taken,\n+\t\t\t\t tree type_tree, bool is_address_taken,\n \t\t\t\t Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n@@ -2788,10 +2750,9 @@ Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n \n Bvariable *\n Gcc_backend::static_chain_variable (Bfunction *function,\n-\t\t\t\t    const std::string &name, Btype *btype,\n+\t\t\t\t    const std::string &name, tree type_tree,\n \t\t\t\t    Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n@@ -2823,13 +2784,12 @@ Gcc_backend::static_chain_variable (Bfunction *function,\n \n Bvariable *\n Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n-\t\t\t\t Btype *btype, Bexpression *binit,\n+\t\t\t\t tree type_tree, Bexpression *binit,\n \t\t\t\t bool is_address_taken, Location location,\n \t\t\t\t Bstatement **pstatement)\n {\n   gcc_assert (function != NULL);\n   tree decl = function->get_tree ();\n-  tree type_tree = btype->get_tree ();\n   tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree ();\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n       || decl == error_mark_node)\n@@ -2870,7 +2830,7 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       BIND_EXPR_VARS (bind_tree) = BLOCK_VARS (block_tree);\n     }\n \n-  if (this->type_size (btype) != 0 && init_tree != NULL_TREE\n+  if (this->type_size (type_tree) != 0 && init_tree != NULL_TREE\n       && TREE_TYPE (init_tree) != void_type_node)\n     DECL_INITIAL (var) = this->convert_tree (type_tree, init_tree, location);\n \n@@ -2883,7 +2843,7 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   // For a zero sized type, don't initialize VAR with BINIT, but still\n   // evaluate BINIT for its side effects.\n   if (init_tree != NULL_TREE\n-      && (this->type_size (btype) == 0\n+      && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n     *pstatement\n       = this->compound_statement (this->expression_statement (function, binit),\n@@ -2897,11 +2857,10 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n \n Bvariable *\n Gcc_backend::implicit_variable (const std::string &name,\n-\t\t\t\tconst std::string &asm_name, Btype *type,\n+\t\t\t\tconst std::string &asm_name, tree type_tree,\n \t\t\t\tbool is_hidden, bool is_constant,\n \t\t\t\tbool is_common, int64_t alignment)\n {\n-  tree type_tree = type->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -2952,7 +2911,7 @@ Gcc_backend::implicit_variable (const std::string &name,\n \n void\n Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\t Btype *, bool, bool, bool is_common,\n+\t\t\t\t\t tree, bool, bool, bool is_common,\n \t\t\t\t\t Bexpression *init)\n {\n   tree decl = var->get_decl ();\n@@ -2984,9 +2943,8 @@ Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::implicit_variable_reference (const std::string &name,\n \t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t  Btype *btype)\n+\t\t\t\t\t  tree type_tree)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -3007,9 +2965,9 @@ Gcc_backend::implicit_variable_reference (const std::string &name,\n Bvariable *\n Gcc_backend::immutable_struct (const std::string &name,\n \t\t\t       const std::string &asm_name, bool is_hidden,\n-\t\t\t       bool is_common, Btype *btype, Location location)\n+\t\t\t       bool is_common, tree type_tree,\n+\t\t\t       Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3053,7 +3011,7 @@ Gcc_backend::immutable_struct (const std::string &name,\n \n void\n Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\tbool, bool is_common, Btype *, Location,\n+\t\t\t\t\tbool, bool is_common, tree, Location,\n \t\t\t\t\tBexpression *initializer)\n {\n   tree decl = var->get_decl ();\n@@ -3084,9 +3042,8 @@ Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::immutable_struct_reference (const std::string &name,\n \t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t Btype *btype, Location location)\n+\t\t\t\t\t tree type_tree, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3173,11 +3130,10 @@ Gcc_backend::label_address (Blabel *label, Location location)\n // Declare or define a new function.\n \n Bfunction *\n-Gcc_backend::function (Btype *fntype, const std::string &name,\n+Gcc_backend::function (tree functype, const std::string &name,\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location location)\n {\n-  tree functype = fntype->get_tree ();\n   if (functype != error_mark_node)\n     {\n       gcc_assert (FUNCTION_POINTER_TYPE_P (functype));\n@@ -3330,7 +3286,7 @@ Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n \n void\n Gcc_backend::write_global_definitions (\n-  const std::vector<Btype *> &type_decls,\n+  const std::vector<tree> &type_decls,\n   const std::vector<Bexpression *> &constant_decls,\n   const std::vector<Bfunction *> &function_decls,\n   const std::vector<Bvariable *> &variable_decls)\n@@ -3354,10 +3310,10 @@ Gcc_backend::write_global_definitions (\n \t}\n     }\n \n-  for (std::vector<Btype *>::const_iterator p = type_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = type_decls.begin ();\n        p != type_decls.end (); ++p)\n     {\n-      tree type_tree = (*p)->get_tree ();\n+      tree type_tree = (*p);\n       if (type_tree != error_mark_node && IS_TYPE_OR_DECL_P (type_tree))\n \t{\n \t  defs[i] = TYPE_NAME (type_tree);"}, {"sha": "d68879c633b4c522d8a94edefdac424a8bd3b191", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -85,7 +85,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \n   for (auto &value : elems.get_values ())\n     {\n@@ -94,7 +94,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n \n@@ -112,7 +112,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n   Bexpression *elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n \n   // num copies expr was already folded in rust-hir-type-check-expr; lookup the\n@@ -132,7 +132,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n "}, {"sha": "a45a7f20a3e322c1f02051047cbde5747cd66cb9", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a751f354a91a8459b877c60a5e5d78203aeb3ce/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=7a751f354a91a8459b877c60a5e5d78203aeb3ce", "patch": "@@ -28,7 +28,7 @@ namespace ConstFold {\n class ConstFoldType : public TyTy::TyVisitor\n {\n public:\n-  static Btype *fold (TyTy::BaseType *type, ::Backend *backend)\n+  static tree fold (TyTy::BaseType *type, ::Backend *backend)\n   {\n     ConstFoldType folder (backend);\n     type->accept_vis (folder);\n@@ -43,13 +43,13 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &type) override\n   {\n-    Btype *element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n+    tree element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n     translated = backend->array_type (element_ty, type.get_capacity ());\n   }\n \n   void visit (TyTy::ReferenceType &type) override\n   {\n-    Btype *base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n     if (type.is_mutable ())\n       {\n \ttranslated = backend->reference_type (base_compiled_type);\n@@ -63,7 +63,7 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::PointerType &type) override\n   {\n-    Btype *base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n     if (type.is_mutable ())\n       {\n \ttranslated = backend->pointer_type (base_compiled_type);\n@@ -212,7 +212,7 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -229,7 +229,7 @@ class ConstFoldType : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  ::tree translated;\n };\n \n class ConstFoldItem : public ConstFoldBase\n@@ -369,7 +369,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -400,7 +400,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n \treturn;\n@@ -480,7 +480,7 @@ class ConstFoldExpr : public ConstFoldBase\n \treturn;\n       }\n \n-    Btype *expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+    tree expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n     bool known_valid = true;\n     folded = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n \t\t\t\t\t\t       known_valid,"}]}