{"sha": "b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc3NTNmNzVlYTE2NDRjM2QxOGRjZmFmOTg3OGZiNWVjMTQ2MGM2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-22T21:41:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-22T21:41:57Z"}, "message": "SUBREG_PROMOTED_VAR_P handling in expand_direct_optab_fn\n\nThis is needed by the later SVE LAST reductions, where an 8-bit\nor 16-bit result is zero- rather than sign-extended to 32 bits.\nI think it could occur in other situations too.\n\n2017-09-19  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* internal-fn.c (expand_direct_optab_fn): Don't assign directly\n\tto a SUBREG_PROMOTED_VAR.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r253992", "tree": {"sha": "d028c05d20720e17819a5d21a031798677278e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d028c05d20720e17819a5d21a031798677278e6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a/comments", "author": null, "committer": null, "parents": [{"sha": "bb06a2d85567fc0d5d82d28629ebc54453c35f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb06a2d85567fc0d5d82d28629ebc54453c35f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb06a2d85567fc0d5d82d28629ebc54453c35f17"}], "stats": {"total": 17, "additions": 16, "deletions": 1}, "files": [{"sha": "64ee44ec6f3931b2f00c74b43b1cd0cee97208bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "patch": "@@ -1,3 +1,10 @@\n+2017-10-22  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* internal-fn.c (expand_direct_optab_fn): Don't assign directly\n+\tto a SUBREG_PROMOTED_VAR.\n+\n 2017-10-22  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "94873c2948ad01c8ffaeb2a3473409b74b9ed6f5", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b7753f75ea1644c3d18dcfaf9878fb5ec1460c6a", "patch": "@@ -2606,7 +2606,15 @@ expand_direct_optab_fn (internal_fn fn, gcall *stmt, direct_optab optab,\n   tree lhs = gimple_call_lhs (stmt);\n   tree lhs_type = TREE_TYPE (lhs);\n   rtx lhs_rtx = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n-  create_output_operand (&ops[0], lhs_rtx, insn_data[icode].operand[0].mode);\n+\n+  /* Do not assign directly to a promoted subreg, since there is no\n+     guarantee that the instruction will leave the upper bits of the\n+     register in the state required by SUBREG_PROMOTED_SIGN.  */\n+  rtx dest = lhs_rtx;\n+  if (GET_CODE (dest) == SUBREG && SUBREG_PROMOTED_VAR_P (dest))\n+    dest = NULL_RTX;\n+\n+  create_output_operand (&ops[0], dest, insn_data[icode].operand[0].mode);\n \n   for (unsigned int i = 0; i < nargs; ++i)\n     {"}]}