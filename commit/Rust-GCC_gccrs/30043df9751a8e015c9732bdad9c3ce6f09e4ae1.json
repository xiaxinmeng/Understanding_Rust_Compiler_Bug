{"sha": "30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAwNDNkZjk3NTFhOGUwMTVjOTczMmJkYWQ5YzNjZTZmMDllNGFlMQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-06-21T23:13:25Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-06-21T23:13:25Z"}, "message": "pack02.c: Use __ibm128 instead of long double if the long double format is IEEE 128-bit...\n\n2018-06-21  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* gcc.target/powerpc/pack02.c: Use __ibm128 instead of long double\n\tif the long double format is IEEE 128-bit for tests that are\n\texplicitly testing IBM extended double support.  Use the\n\tappropriate pack and unpack built-in functions.  Change calls from\n\t__builtin_isinfl to __builtin_isinf since the later supports all\n\tfloating point types.\n\t* gcc.target/powerpc/pr57150.c: Likewise.\n\t* gcc.target/powerpc/pr60203.c: Likewise.\n\t* gcc.target/powerpc/pr67808.c: Likewise.\n\t* gcc.target/powerpc/pr70117.c: Likewise.\n\t* gcc.target/powerpc/tfmode_off.c: Likewise.\n\nFrom-SVN: r261872", "tree": {"sha": "7c12242381a57027fd535e1c28a9b1a353edee38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c12242381a57027fd535e1c28a9b1a353edee38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/comments", "author": null, "committer": null, "parents": [{"sha": "27fbc519e01f3fd9d7c449074cac5af156cf5521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27fbc519e01f3fd9d7c449074cac5af156cf5521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27fbc519e01f3fd9d7c449074cac5af156cf5521"}], "stats": {"total": 160, "additions": 130, "deletions": 30}, "files": [{"sha": "bb7aa6073f1776ee0414dfc1d932d1d6d438de50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -1,3 +1,17 @@\n+2018-06-21  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* gcc.target/powerpc/pack02.c: Use __ibm128 instead of long double\n+\tif the long double format is IEEE 128-bit for tests that are\n+\texplicitly testing IBM extended double support.  Use the\n+\tappropriate pack and unpack built-in functions.  Change calls from\n+\t__builtin_isinfl to __builtin_isinf since the later supports all\n+\tfloating point types.\n+\t* gcc.target/powerpc/pr57150.c: Likewise.\n+\t* gcc.target/powerpc/pr60203.c: Likewise.\n+\t* gcc.target/powerpc/pr67808.c: Likewise.\n+\t* gcc.target/powerpc/pr70117.c: Likewise.\n+\t* gcc.target/powerpc/tfmode_off.c: Likewise.\n+\n 2018-06-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/49630"}, {"sha": "2cc2396235b1a21b730a3ddef48f6f7009b8cce0", "filename": "gcc/testsuite/gcc.target/powerpc/pack02.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpack02.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -13,36 +13,54 @@\n #include <stdio.h>\n #endif\n \n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double, and to use the appropriate pack/unpack routines.  We can't use\n+   __ibm128 on systems that don't support IEEE 128-bit floating point, because\n+   the type is not enabled on those systems.  */\n+#define PACK __builtin_pack_ibm128\n+#define UNPACK __builtin_unpack_ibm128\n+#define LDOUBLE __ibm128\n+\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define PACK __builtin_pack_longdouble\n+#define UNPACK __builtin_unpack_longdouble\n+#define LDOUBLE long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n+\n int\n main (void)\n {\n   double high = pow (2.0, 60);\n   double low  = 2.0;\n-  long double a = ((long double)high) + ((long double)low);\n-  double x0 = __builtin_unpack_longdouble (a, 0);\n-  double x1 = __builtin_unpack_longdouble (a, 1);\n-  long double b = __builtin_pack_longdouble (x0, x1);\n+  LDOUBLE a = ((LDOUBLE)high) + ((LDOUBLE)low);\n+  double x0 = UNPACK (a, 0);\n+  double x1 = UNPACK (a, 1);\n+  LDOUBLE b = PACK (x0, x1);\n \n #ifdef DEBUG\n   {\n     size_t i;\n     union {\n-      long double ld;\n+      LDOUBLE ld;\n       double d;\n-      unsigned char uc[sizeof (long double)];\n-      char c[sizeof (long double)];\n+      unsigned char uc[sizeof (LDOUBLE)];\n+      char c[sizeof (LDOUBLE)];\n     } u;\n \n     printf (\"a  = 0x\");\n     u.ld = a;\n-    for (i = 0; i < sizeof (long double); i++)\n+    for (i = 0; i < sizeof (LDOUBLE); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n     printf (\", %Lg\\n\", a);\n \n     printf (\"b  = 0x\");\n     u.ld = b;\n-    for (i = 0; i < sizeof (long double); i++)\n+    for (i = 0; i < sizeof (LDOUBLE); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n     printf (\", %Lg\\n\", b);\n@@ -52,28 +70,28 @@ main (void)\n     for (i = 0; i < sizeof (double); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n-    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", high);\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (LDOUBLE) - sizeof (double))), \"\", high);\n \n     printf (\"lo = 0x\");\n     u.d = low;\n     for (i = 0; i < sizeof (double); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n-    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", low);\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (LDOUBLE) - sizeof (double))), \"\", low);\n \n     printf (\"x0 = 0x\");\n     u.d = x0;\n     for (i = 0; i < sizeof (double); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n-    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", x0);\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (LDOUBLE) - sizeof (double))), \"\", x0);\n \n     printf (\"x1 = 0x\");\n     u.d = x1;\n     for (i = 0; i < sizeof (double); i++)\n       printf (\"%.2x\", u.uc[i]);\n \n-    printf (\",%*s %g\\n\", (int)(2 * (sizeof (long double) - sizeof (double))), \"\", x1);\n+    printf (\",%*s %g\\n\", (int)(2 * (sizeof (LDOUBLE) - sizeof (double))), \"\", x1);\n   }\n #endif\n "}, {"sha": "1afacae9725a37223cb79b5b5c428fa6ff236ee0", "filename": "gcc/testsuite/gcc.target/powerpc/pr57150.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -12,10 +12,24 @@\n \n /* Insure caller save on long double does not use VSX instructions.  */\n \n-extern long double modify (long double);\n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double.  We can't use __ibm128 on systems that don't support IEEE\n+   128-bit floating point, because the type is not enabled on those\n+   systems.  */\n+#define LDOUBLE __ibm128\n+\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define LDOUBLE long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n+\n+extern LDOUBLE modify (LDOUBLE);\n \n void\n-sum (long double *ptr, long double value, unsigned long n)\n+sum (LDOUBLE *ptr, LDOUBLE value, unsigned long n)\n {\n   unsigned long i;\n "}, {"sha": "df9fb9aa6bb52f97df0e463fbb4d7f1c71fcaeba", "filename": "gcc/testsuite/gcc.target/powerpc/pr60203.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60203.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60203.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60203.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -4,9 +4,23 @@\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-mcpu=power8 -O3\" } */\n \n-union u_ld { long double ld; double d[2]; };\n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double.  We can't use __ibm128 on systems that don't support IEEE\n+   128-bit floating point, because the type is not enabled on those\n+   systems.  */\n+#define LDOUBLE __ibm128\n \n-long double\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define LDOUBLE long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n+\n+union u_ld { LDOUBLE ld; double d[2]; };\n+\n+LDOUBLE\n pack (double a, double aa)\n {\n   union u_ld u;\n@@ -16,15 +30,15 @@ pack (double a, double aa)\n }\n \n double\n-unpack_0 (long double x)\n+unpack_0 (LDOUBLE x)\n {\n   union u_ld u;\n   u.ld = x;\n   return u.d[0];\n }\n \n double\n-unpack_1 (long double x)\n+unpack_1 (LDOUBLE x)\n {\n   union u_ld u;\n   u.ld = x;"}, {"sha": "96376a59629f52ba03e60504ccd375b6623af3a8", "filename": "gcc/testsuite/gcc.target/powerpc/pr67808.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67808.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67808.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr67808.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -6,37 +6,51 @@\n \n /* PR 67808: LRA ICEs on simple double to long double conversion test case */\n \n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double.  We can't use __ibm128 on systems that don't support IEEE\n+   128-bit floating point, because the type is not enabled on those\n+   systems.  */\n+#define LDOUBLE __ibm128\n+\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define LDOUBLE long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n+\n void\n-dfoo (long double *ldb1, double *db1)\n+dfoo (LDOUBLE *ldb1, double *db1)\n {\n   *ldb1 = *db1;\n }\n \n-long double\n+LDOUBLE\n dfoo2 (double *db1)\n {\n   return *db1;\n }\n \n-long double\n+LDOUBLE\n dfoo3 (double x)\n {\n   return x;\n }\n \n void\n-ffoo (long double *ldb1, float *db1)\n+ffoo (LDOUBLE *ldb1, float *db1)\n {\n   *ldb1 = *db1;\n }\n \n-long double\n+LDOUBLE\n ffoo2 (float *db1)\n {\n   return *db1;\n }\n \n-long double\n+LDOUBLE\n ffoo3 (float x)\n {\n   return x;"}, {"sha": "3bbd2c595e0426d55e782a77097385eb081db125", "filename": "gcc/testsuite/gcc.target/powerpc/pr70117.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -3,10 +3,24 @@\n \n #include <float.h>\n \n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double.  We can't use __ibm128 on systems that don't support IEEE\n+   128-bit floating point, because the type is not enabled on those\n+   systems.  */\n+#define LDOUBLE __ibm128\n+\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define LDOUBLE long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n+\n union gl_long_double_union\n {\n   struct { double hi; double lo; } dd;\n-  long double ld;\n+  LDOUBLE ld;\n };\n \n /* This is gnulib's LDBL_MAX which, being 107 bits in precision, is\n@@ -22,13 +36,13 @@ volatile double dnan = 0.0/0.0;\n int\n main (void)\n {\n-  long double ld;\n+  LDOUBLE ld;\n \n   ld = gl_LDBL_MAX.ld;\n-  if (__builtin_isinfl (ld))\n+  if (__builtin_isinf (ld))\n     __builtin_abort ();\n   ld = -gl_LDBL_MAX.ld;\n-  if (__builtin_isinfl (ld))\n+  if (__builtin_isinf (ld))\n     __builtin_abort ();\n \n   ld = gl_LDBL_MAX.ld;"}, {"sha": "af588867ec5144ae03eefaea8e9febf7687e405c", "filename": "gcc/testsuite/gcc.target/powerpc/tfmode_off.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftfmode_off.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30043df9751a8e015c9732bdad9c3ce6f09e4ae1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftfmode_off.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftfmode_off.c?ref=30043df9751a8e015c9732bdad9c3ce6f09e4ae1", "patch": "@@ -4,7 +4,19 @@\n /* { dg-require-effective-target longdouble128 } */\n /* { dg-options \"-O2 -fno-align-functions -fno-asynchronous-unwind-tables -mtraceback=no -save-temps\" } */\n \n-typedef float TFmode __attribute__ ((mode (TF)));\n+#if defined(__LONG_DOUBLE_IEEE128__)\n+/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n+   long double.  We can't use __ibm128 on systems that don't support IEEE\n+   128-bit floating point, because the type is not enabled on those\n+   systems.  */\n+#define TFmode __ibm128\n+\n+#elif defined(__LONG_DOUBLE_IBM128__)\n+#define TFmode long double\n+\n+#else\n+#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#endif\n \n void w1 (void *x, TFmode y) { *(TFmode *) (x + 32767) = y; }\n void w2 (void *x, TFmode y) { *(TFmode *) (x + 32766) = y; }"}]}