{"sha": "93079c819b40a76d626ba5b0adc757d170f665ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMwNzljODE5YjQwYTc2ZDYyNmJhNWIwYWRjNzU3ZDE3MGY2NjVlZg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-03-28T08:34:12Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-03-28T08:34:12Z"}, "message": "xregex2.h (_RE_ARGS): Remove definition and uses.\n\ninclude/\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n        * xregex2.h (_RE_ARGS): Remove definition and uses.\n\nlibiberty/\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n        Convert libiberty to use ISO C prototype style 7/n.\n        * regex.c (PARAMS): Remove definition.\n        (PREFIX): Unconditionaly define using ISO C ## operator.\n        (init_syntax_once, extract_number, extract_number_and_incr,\n        print_fastmap, print_partial_compiled_pattern,\n        print_compiled_pattern, print_double_string, printchar,\n        convert_mbs_to_wcs, re_set_syntax, regex_grow_registers,\n        regex_compile, store_op1, store_op2, insert_op1, insert_op2,\n        at_begline_loc_p, at_endline_p, group_in_compile_stack,\n        insert_space, wcs_compile_range, byte_compile_range,\n        truncate_wchar, re_compile_fastmap, re_compile_fastmap,\n        re_set_registers, re_search, re_search_2, re_search_3,\n        re_match,\n        re_match_2, count_mbs_length, wcs_re_match_2_internal,\n        byte_re_match_2_internal, group_match_null_string_p,\n        alt_match_null_string_p, common_op_match_null_string_p,\n        bcmp_translate, re_compile_pattern, re_comp, re_exec, regcomp,\n        regexec, regerror, regfree): Use ISO C prototype style.\n        * partition.c: (elem_compare): Likewise.\n        * cp-demangle.c (print_usage): Likewise.\n\nFrom-SVN: r97129", "tree": {"sha": "fae0c48b0fc1c8a82f44cf8191c4cf8596671ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fae0c48b0fc1c8a82f44cf8191c4cf8596671ec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93079c819b40a76d626ba5b0adc757d170f665ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93079c819b40a76d626ba5b0adc757d170f665ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93079c819b40a76d626ba5b0adc757d170f665ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93079c819b40a76d626ba5b0adc757d170f665ef/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "551ca039ecd06c92f3909d960c5e4be3a6368f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551ca039ecd06c92f3909d960c5e4be3a6368f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551ca039ecd06c92f3909d960c5e4be3a6368f62"}], "stats": {"total": 567, "additions": 230, "deletions": 337}, "files": [{"sha": "379b0850413e9483a06c30323e49690f8d63860c", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -1,3 +1,7 @@\n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* xregex2.h (_RE_ARGS): Remove definition and uses.\n+\n 2005-03-27  Gabriel Dos Reis  <gdr@integreable-solutions.net>\n \n \t* ternary.h: Don't use PARAMS anymore."}, {"sha": "812518bbe39019378f267527efe40d09a7b931b1", "filename": "include/xregex2.h", "status": "modified", "additions": 32, "deletions": 44, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/include%2Fxregex2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/include%2Fxregex2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fxregex2.h?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -434,64 +434,51 @@ typedef struct\n    unfortunately clutters up the declarations a bit, but I think it's\n    worth it.  */\n \n-#if __STDC__\n-\n-# define _RE_ARGS(args) args\n-\n-#else /* not __STDC__ */\n-\n-# define _RE_ARGS(args) ()\n-\n-#endif /* not __STDC__ */\n-\n /* Sets the current default syntax to SYNTAX, and return the old syntax.\n    You can also simply assign to the `re_syntax_options' variable.  */\n-extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n+extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);\n \n /* Compile the regular expression PATTERN, with length LENGTH\n    and syntax given by the global `re_syntax_options', into the buffer\n    BUFFER.  Return NULL if successful, and an error string if not.  */\n-extern const char *re_compile_pattern\n-  _RE_ARGS ((const char *pattern, size_t length,\n-             struct re_pattern_buffer *buffer));\n+extern const char *re_compile_pattern (const char *pattern, size_t length,\n+                                       struct re_pattern_buffer *buffer);\n \n \n /* Compile a fastmap for the compiled pattern in BUFFER; used to\n    accelerate searches.  Return 0 if successful and -2 if was an\n    internal error.  */\n-extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n+extern int re_compile_fastmap (struct re_pattern_buffer *buffer);\n \n \n /* Search in the string STRING (with length LENGTH) for the pattern\n    compiled into BUFFER.  Start searching at position START, for RANGE\n    characters.  Return the starting position of the match, -1 for no\n    match, or -2 for an internal error.  Also return register\n    information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\n-extern int re_search\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-            int length, int start, int range, struct re_registers *regs));\n+extern int re_search (struct re_pattern_buffer *buffer, const char *string,\n+                      int length, int start, int range,\n+                      struct re_registers *regs);\n \n \n /* Like `re_search', but search in the concatenation of STRING1 and\n    STRING2.  Also, stop searching at index START + STOP.  */\n-extern int re_search_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, int range, struct re_registers *regs, int stop));\n+extern int re_search_2 (struct re_pattern_buffer *buffer, const char *string1,\n+                        int length1, const char *string2, int length2,\n+                        int start, int range, struct re_registers *regs,\n+                        int stop);\n \n \n /* Like `re_search', but return how many characters in STRING the regexp\n    in BUFFER matched, starting at position START.  */\n-extern int re_match\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-             int length, int start, struct re_registers *regs));\n+extern int re_match (struct re_pattern_buffer *buffer, const char *string,\n+                     int length, int start, struct re_registers *regs);\n \n \n /* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\n-extern int re_match_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, struct re_registers *regs, int stop));\n+extern int re_match_2 (struct re_pattern_buffer *buffer, const char *string1,\n+                       int length1, const char *string2, int length2,\n+                       int start, struct re_registers *regs, int stop);\n \n \n /* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n@@ -506,15 +493,16 @@ extern int re_match_2\n    Unless this function is called, the first search or match using\n    PATTERN_BUFFER will allocate its own register data, without\n    freeing the old data.  */\n-extern void re_set_registers\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n-             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n+extern void re_set_registers (struct re_pattern_buffer *buffer,\n+                              struct re_registers *regs,\n+                              unsigned num_regs, regoff_t *starts,\n+                              regoff_t *ends);\n \n #if defined _REGEX_RE_COMP || defined _LIBC\n # ifndef _CRAY\n /* 4.2 bsd compatibility.  */\n-extern char *re_comp _RE_ARGS ((const char *));\n-extern int re_exec _RE_ARGS ((const char *));\n+extern char *re_comp (const char *);\n+extern int re_exec (const char *);\n # endif\n #endif\n \n@@ -541,19 +529,19 @@ extern int re_exec _RE_ARGS ((const char *));\n #endif\n \n /* POSIX compatibility.  */\n-extern int regcomp _RE_ARGS ((regex_t *__restrict __preg,\n-\t\t\t      const char *__restrict __pattern,\n-\t\t\t      int __cflags));\n+extern int regcomp (regex_t *__restrict __preg,\n+                    const char *__restrict __pattern,\n+                    int __cflags);\n \n-extern int regexec _RE_ARGS ((const regex_t *__restrict __preg,\n-\t\t\t      const char *__restrict __string, size_t __nmatch,\n-\t\t\t      regmatch_t __pmatch[__restrict_arr],\n-\t\t\t      int __eflags));\n+extern int regexec (const regex_t *__restrict __preg,\n+                    const char *__restrict __string, size_t __nmatch,\n+                    regmatch_t __pmatch[__restrict_arr],\n+                    int __eflags);\n \n-extern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n-\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n+extern size_t regerror (int __errcode, const regex_t *__preg,\n+                        char *__errbuf, size_t __errbuf_size);\n \n-extern void regfree _RE_ARGS ((regex_t *__preg));\n+extern void regfree (regex_t *__preg);\n \n \n #ifdef __cplusplus"}, {"sha": "683df3f8e666e59dc9c45040069355c286d5527a", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -1,3 +1,25 @@\n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert libiberty to use ISO C prototype style 7/n.\n+\t* regex.c (PARAMS): Remove definition.\n+\t(PREFIX): Unconditionaly define using ISO C ## operator.\n+\t(init_syntax_once, extract_number, extract_number_and_incr, \n+\tprint_fastmap, print_partial_compiled_pattern,\n+\tprint_compiled_pattern, print_double_string, printchar, \n+\tconvert_mbs_to_wcs, re_set_syntax, regex_grow_registers,\n+\tregex_compile, store_op1, store_op2, insert_op1, insert_op2,\n+\tat_begline_loc_p, at_endline_p, group_in_compile_stack, \n+\tinsert_space, wcs_compile_range, byte_compile_range, \n+\ttruncate_wchar, re_compile_fastmap, re_compile_fastmap, \n+\tre_set_registers, re_search, re_search_2, re_search_3, re_match, \n+\tre_match_2, count_mbs_length, wcs_re_match_2_internal,\n+\tbyte_re_match_2_internal, group_match_null_string_p,\n+\talt_match_null_string_p, common_op_match_null_string_p,\n+\tbcmp_translate, re_compile_pattern, re_comp, re_exec, regcomp, \n+\tregexec, regerror, regfree): Use ISO C prototype style.\n+\t* partition.c: (elem_compare): Likewise.\n+\t* cp-demangle.c (print_usage): Likewise.\n+\n 2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert libiberty to use ISO C prototype style 5/n."}, {"sha": "5bea354beee94e0117baf2f0a21fcd1258e33ac3", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -4144,7 +4144,7 @@ is_gnu_v3_mangled_dtor (const char *name)\n #include \"getopt.h\"\n #include \"dyn-string.h\"\n \n-static void print_usage PARAMS ((FILE* fp, int exit_value));\n+static void print_usage (FILE* fp, int exit_value);\n \n #define IS_ALPHA(CHAR)                                                  \\\n   (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \\"}, {"sha": "24a99122d5599fdc645eb80671212bd28e545bf5", "filename": "libiberty/partition.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fpartition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fpartition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpartition.c?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -34,7 +34,7 @@\n #include \"libiberty.h\"\n #include \"partition.h\"\n \n-static int elem_compare PARAMS ((const void *, const void *));\n+static int elem_compare (const void *, const void *);\n \n /* Creates a partition of NUM_ELEMENTS elements.  Initially each\n    element is in a class by itself.  */"}, {"sha": "779998278b9dbcc03b535816e4df50677d560766", "filename": "libiberty/regex.c", "status": "modified", "additions": 170, "deletions": 291, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93079c819b40a76d626ba5b0adc757d170f665ef/libiberty%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fregex.c?ref=93079c819b40a76d626ba5b0adc757d170f665ef", "patch": "@@ -40,14 +40,6 @@\n \n #include <ansidecl.h>\n \n-#ifndef PARAMS\n-# if defined __GNUC__ || (defined __STDC__ && __STDC__)\n-#  define PARAMS(args) args\n-# else\n-#  define PARAMS(args) ()\n-# endif  /* GCC.  */\n-#endif  /* Not PARAMS.  */\n-\n #ifndef INSIDE_RECURSION\n \n # if defined STDC_HEADERS && !defined emacs\n@@ -277,10 +269,10 @@ extern char *re_syntax_table;\n \n static char re_syntax_table[CHAR_SET_SIZE];\n \n-static void init_syntax_once PARAMS ((void));\n+static void init_syntax_once (void);\n \n static void\n-init_syntax_once ()\n+init_syntax_once (void)\n {\n    register int c;\n    static int done = 0;\n@@ -411,44 +403,44 @@ typedef char boolean;\n # define false 0\n # define true 1\n \n-static reg_errcode_t byte_regex_compile _RE_ARGS ((const char *pattern, size_t size,\n-                                                   reg_syntax_t syntax,\n-                                                   struct re_pattern_buffer *bufp));\n-\n-static int byte_re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,\n-\t\t\t\t\t     const char *string1, int size1,\n-\t\t\t\t\t     const char *string2, int size2,\n-\t\t\t\t\t     int pos,\n-\t\t\t\t\t     struct re_registers *regs,\n-\t\t\t\t\t     int stop));\n-static int byte_re_search_2 PARAMS ((struct re_pattern_buffer *bufp,\n-\t\t\t\t     const char *string1, int size1,\n-\t\t\t\t     const char *string2, int size2,\n-\t\t\t\t     int startpos, int range,\n-\t\t\t\t     struct re_registers *regs, int stop));\n-static int byte_re_compile_fastmap PARAMS ((struct re_pattern_buffer *bufp));\n+static reg_errcode_t byte_regex_compile (const char *pattern, size_t size,\n+                                         reg_syntax_t syntax,\n+                                         struct re_pattern_buffer *bufp);\n+\n+static int byte_re_match_2_internal (struct re_pattern_buffer *bufp,\n+                                     const char *string1, int size1,\n+                                     const char *string2, int size2,\n+                                     int pos,\n+                                     struct re_registers *regs,\n+                                     int stop);\n+static int byte_re_search_2 (struct re_pattern_buffer *bufp,\n+                             const char *string1, int size1,\n+                             const char *string2, int size2,\n+                             int startpos, int range,\n+                             struct re_registers *regs, int stop);\n+static int byte_re_compile_fastmap (struct re_pattern_buffer *bufp);\n \n #ifdef MBS_SUPPORT\n-static reg_errcode_t wcs_regex_compile _RE_ARGS ((const char *pattern, size_t size,\n-                                                   reg_syntax_t syntax,\n-                                                   struct re_pattern_buffer *bufp));\n-\n-\n-static int wcs_re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,\n-\t\t\t\t\t    const char *cstring1, int csize1,\n-\t\t\t\t\t    const char *cstring2, int csize2,\n-\t\t\t\t\t    int pos,\n-\t\t\t\t\t    struct re_registers *regs,\n-\t\t\t\t\t    int stop,\n-\t\t\t\t\t    wchar_t *string1, int size1,\n-\t\t\t\t\t    wchar_t *string2, int size2,\n-\t\t\t\t\t    int *mbs_offset1, int *mbs_offset2));\n-static int wcs_re_search_2 PARAMS ((struct re_pattern_buffer *bufp,\n-\t\t\t\t    const char *string1, int size1,\n-\t\t\t\t    const char *string2, int size2,\n-\t\t\t\t    int startpos, int range,\n-\t\t\t\t    struct re_registers *regs, int stop));\n-static int wcs_re_compile_fastmap PARAMS ((struct re_pattern_buffer *bufp));\n+static reg_errcode_t wcs_regex_compile (const char *pattern, size_t size,\n+                                        reg_syntax_t syntax,\n+                                        struct re_pattern_buffer *bufp);\n+\n+\n+static int wcs_re_match_2_internal (struct re_pattern_buffer *bufp,\n+                                    const char *cstring1, int csize1,\n+                                    const char *cstring2, int csize2,\n+                                    int pos,\n+                                    struct re_registers *regs,\n+                                    int stop,\n+                                    wchar_t *string1, int size1,\n+                                    wchar_t *string2, int size2,\n+                                    int *mbs_offset1, int *mbs_offset2);\n+static int wcs_re_search_2 (struct re_pattern_buffer *bufp,\n+                            const char *string1, int size1,\n+                            const char *string2, int size2,\n+                            int startpos, int range,\n+                            struct re_registers *regs, int stop);\n+static int wcs_re_compile_fastmap (struct re_pattern_buffer *bufp);\n #endif\n \f\n /* These are the command codes that appear in compiled regular\n@@ -616,11 +608,7 @@ typedef enum\n # define UCHAR_T unsigned char\n # define COMPILED_BUFFER_VAR bufp->buffer\n # define OFFSET_ADDRESS_SIZE 2\n-# if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)\n-#  define PREFIX(name) byte_##name\n-# else\n-#  define PREFIX(name) byte_/**/name\n-# endif\n+# define PREFIX(name) byte_##name\n # define ARG_PREFIX(name) name\n # define PUT_CHAR(c) putchar (c)\n #else\n@@ -630,13 +618,8 @@ typedef enum\n #  define COMPILED_BUFFER_VAR wc_buffer\n #  define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */\n #  define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)\n-#  if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)\n-#   define PREFIX(name) wcs_##name\n-#   define ARG_PREFIX(name) c##name\n-#  else\n-#   define PREFIX(name) wcs_/**/name\n-#   define ARG_PREFIX(name) c/**/name\n-#  endif\n+#  define PREFIX(name) wcs_##name\n+#  define ARG_PREFIX(name) c##name\n /* Should we use wide stream??  */\n #  define PUT_CHAR(c) printf (\"%C\", c);\n #  define TRUE 1\n@@ -703,11 +686,9 @@ typedef enum\n # endif\n \n # ifdef DEBUG\n-static void PREFIX(extract_number) _RE_ARGS ((int *dest, UCHAR_T *source));\n+static void PREFIX(extract_number) (int *dest, UCHAR_T *source);\n static void\n-PREFIX(extract_number) (dest, source)\n-    int *dest;\n-    UCHAR_T *source;\n+PREFIX(extract_number) (int *dest, UCHAR_T *source)\n {\n #  ifdef WCHAR\n   *dest = *source;\n@@ -735,12 +716,10 @@ PREFIX(extract_number) (dest, source)\n   } while (0)\n \n # ifdef DEBUG\n-static void PREFIX(extract_number_and_incr) _RE_ARGS ((int *destination,\n-\t\t\t\t\t\t       UCHAR_T **source));\n+static void PREFIX(extract_number_and_incr) (int *destination,\n+                                             UCHAR_T **source);\n static void\n-PREFIX(extract_number_and_incr) (destination, source)\n-    int *destination;\n-    UCHAR_T **source;\n+PREFIX(extract_number_and_incr) (int *destination, UCHAR_T **source)\n {\n   PREFIX(extract_number) (destination, *source);\n   *source += OFFSET_ADDRESS_SIZE;\n@@ -791,8 +770,7 @@ static int debug;\n \n #  ifndef DEFINED_ONCE\n void\n-print_fastmap (fastmap)\n-    char *fastmap;\n+print_fastmap (char *fastmap)\n {\n   unsigned was_a_range = 0;\n   unsigned i = 0;\n@@ -824,9 +802,7 @@ print_fastmap (fastmap)\n    the START pointer into it and ending just before the pointer END.  */\n \n void\n-PREFIX(print_partial_compiled_pattern) (start, end)\n-    UCHAR_T *start;\n-    UCHAR_T *end;\n+PREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)\n {\n   int mcnt, mcnt2;\n   UCHAR_T *p1;\n@@ -1159,8 +1135,7 @@ PREFIX(print_partial_compiled_pattern) (start, end)\n \n \n void\n-PREFIX(print_compiled_pattern) (bufp)\n-    struct re_pattern_buffer *bufp;\n+PREFIX(print_compiled_pattern) (struct re_pattern_buffer *bufp)\n {\n   UCHAR_T *buffer = (UCHAR_T*) bufp->buffer;\n \n@@ -1192,12 +1167,8 @@ PREFIX(print_compiled_pattern) (bufp)\n \n \n void\n-PREFIX(print_double_string) (where, string1, size1, string2, size2)\n-    const CHAR_T *where;\n-    const CHAR_T *string1;\n-    const CHAR_T *string2;\n-    int size1;\n-    int size2;\n+PREFIX(print_double_string) (const CHAR_T *where, const CHAR_T *string1,\n+                             int size1, const CHAR_T *string2, int size2)\n {\n   int this_char;\n \n@@ -1230,8 +1201,7 @@ PREFIX(print_double_string) (where, string1, size1, string2, size2)\n \n #  ifndef DEFINED_ONCE\n void\n-printchar (c)\n-     int c;\n+printchar (int c)\n {\n   putc (c, stderr);\n }\n@@ -1268,11 +1238,8 @@ static size_t convert_mbs_to_wcs (CHAR_T *dest, const unsigned char* src,\n \t\t\t\t  size_t len, int *offset_buffer,\n \t\t\t\t  char *is_binary);\n static size_t\n-convert_mbs_to_wcs (dest, src, len, offset_buffer, is_binary)\n-     CHAR_T *dest;\n-     const unsigned char* src;\n-     size_t len; /* the length of multibyte string.  */\n-\n+convert_mbs_to_wcs (CHAR_T *dest, const unsigned char*src, size_t len,\n+                    int *offset_buffer, char *is_binary)\n      /* It hold correspondances between src(char string) and\n \tdest(wchar_t string) for optimization.\n \te.g. src  = \"xxxyzz\"\n@@ -1282,8 +1249,6 @@ convert_mbs_to_wcs (dest, src, len, offset_buffer, is_binary)\n \t  offset_buffer = {0, 0+3(\"xxx\"), 0+3+1(\"y\"), 0+3+1+2(\"zz\")}\n \t  \t        = {0, 3, 4, 6}\n      */\n-     int *offset_buffer;\n-     char *is_binary;\n {\n   wchar_t *pdest = dest;\n   const unsigned char *psrc = src;\n@@ -1354,8 +1319,7 @@ reg_syntax_t re_syntax_options;\n    defined in regex.h.  We return the old syntax.  */\n \n reg_syntax_t\n-re_set_syntax (syntax)\n-    reg_syntax_t syntax;\n+re_set_syntax (reg_syntax_t syntax)\n {\n   reg_syntax_t ret = re_syntax_options;\n \n@@ -1874,35 +1838,35 @@ static CHAR_T PREFIX(reg_unset_dummy);\n # define REG_UNSET(e) ((e) == REG_UNSET_VALUE)\n \n /* Subroutine declarations and macros for regex_compile.  */\n-static void PREFIX(store_op1) _RE_ARGS ((re_opcode_t op, UCHAR_T *loc, int arg));\n-static void PREFIX(store_op2) _RE_ARGS ((re_opcode_t op, UCHAR_T *loc,\n-\t\t\t\t int arg1, int arg2));\n-static void PREFIX(insert_op1) _RE_ARGS ((re_opcode_t op, UCHAR_T *loc,\n-\t\t\t\t  int arg, UCHAR_T *end));\n-static void PREFIX(insert_op2) _RE_ARGS ((re_opcode_t op, UCHAR_T *loc,\n-\t\t\t\t  int arg1, int arg2, UCHAR_T *end));\n-static boolean PREFIX(at_begline_loc_p) _RE_ARGS ((const CHAR_T *pattern,\n-\t\t\t\t\t   const CHAR_T *p,\n-\t\t\t\t\t   reg_syntax_t syntax));\n-static boolean PREFIX(at_endline_loc_p) _RE_ARGS ((const CHAR_T *p,\n-\t\t\t\t\t   const CHAR_T *pend,\n-\t\t\t\t\t   reg_syntax_t syntax));\n+static void PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg);\n+static void PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc,\n+                               int arg1, int arg2);\n+static void PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc,\n+                                int arg, UCHAR_T *end);\n+static void PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc,\n+                                int arg1, int arg2, UCHAR_T *end);\n+static boolean PREFIX(at_begline_loc_p) (const CHAR_T *pattern,\n+                                         const CHAR_T *p,\n+                                         reg_syntax_t syntax);\n+static boolean PREFIX(at_endline_loc_p) (const CHAR_T *p,\n+                                         const CHAR_T *pend,\n+                                         reg_syntax_t syntax);\n # ifdef WCHAR\n-static reg_errcode_t wcs_compile_range _RE_ARGS ((CHAR_T range_start,\n-\t\t\t\t\t\t  const CHAR_T **p_ptr,\n-\t\t\t\t\t\t  const CHAR_T *pend,\n-\t\t\t\t\t\t  char *translate,\n-\t\t\t\t\t\t  reg_syntax_t syntax,\n-\t\t\t\t\t\t  UCHAR_T *b,\n-\t\t\t\t\t\t  CHAR_T *char_set));\n-static void insert_space _RE_ARGS ((int num, CHAR_T *loc, CHAR_T *end));\n+static reg_errcode_t wcs_compile_range (CHAR_T range_start,\n+                                        const CHAR_T **p_ptr,\n+                                        const CHAR_T *pend,\n+                                        char *translate,\n+                                        reg_syntax_t syntax,\n+                                        UCHAR_T *b,\n+                                        CHAR_T *char_set);\n+static void insert_space (int num, CHAR_T *loc, CHAR_T *end);\n # else /* BYTE */\n-static reg_errcode_t byte_compile_range _RE_ARGS ((unsigned int range_start,\n-\t\t\t\t\t\t   const char **p_ptr,\n-\t\t\t\t\t\t   const char *pend,\n-\t\t\t\t\t\t   char *translate,\n-\t\t\t\t\t\t   reg_syntax_t syntax,\n-\t\t\t\t\t\t   unsigned char *b));\n+static reg_errcode_t byte_compile_range (unsigned int range_start,\n+                                         const char **p_ptr,\n+                                         const char *pend,\n+                                         char *translate,\n+                                         reg_syntax_t syntax,\n+                                         unsigned char *b);\n # endif /* WCHAR */\n \n /* Fetch the next character in the uncompiled pattern---translating it\n@@ -2260,8 +2224,7 @@ static PREFIX(register_info_type) *PREFIX(reg_info_dummy);\n    but don't make them smaller.  */\n \n static void\n-PREFIX(regex_grow_registers) (num_regs)\n-     int num_regs;\n+PREFIX(regex_grow_registers) (int num_regs)\n {\n   if (num_regs > regs_allocated_size)\n     {\n@@ -2282,9 +2245,8 @@ PREFIX(regex_grow_registers) (num_regs)\n # endif /* not MATCH_MAY_ALLOCATE */\n \f\n # ifndef DEFINED_ONCE\n-static boolean group_in_compile_stack _RE_ARGS ((compile_stack_type\n-\t\t\t\t\t\t compile_stack,\n-\t\t\t\t\t\t regnum_t regnum));\n+static boolean group_in_compile_stack (compile_stack_type compile_stack,\n+                                       regnum_t regnum);\n # endif /* not DEFINED_ONCE */\n \n /* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.\n@@ -2315,11 +2277,9 @@ static boolean group_in_compile_stack _RE_ARGS ((compile_stack_type\n # endif /* WCHAR */\n \n static reg_errcode_t\n-PREFIX(regex_compile) (ARG_PREFIX(pattern), ARG_PREFIX(size), syntax, bufp)\n-     const char *ARG_PREFIX(pattern);\n-     size_t ARG_PREFIX(size);\n-     reg_syntax_t syntax;\n-     struct re_pattern_buffer *bufp;\n+PREFIX(regex_compile) (const char *ARG_PREFIX(pattern),\n+                       size_t ARG_PREFIX(size), reg_syntax_t syntax,\n+                       struct re_pattern_buffer *bufp)\n {\n   /* We fetch characters from PATTERN here.  Even though PATTERN is\n      `char *' (i.e., signed), we declare these variables as unsigned, so\n@@ -4264,10 +4224,7 @@ PREFIX(regex_compile) (ARG_PREFIX(pattern), ARG_PREFIX(size), syntax, bufp)\n /* ifdef WCHAR, integer parameter is 1 wchar_t.  */\n \n static void\n-PREFIX(store_op1) (op, loc, arg)\n-    re_opcode_t op;\n-    UCHAR_T *loc;\n-    int arg;\n+PREFIX(store_op1) (re_opcode_t op, UCHAR_T *loc, int arg)\n {\n   *loc = (UCHAR_T) op;\n   STORE_NUMBER (loc + 1, arg);\n@@ -4278,10 +4235,7 @@ PREFIX(store_op1) (op, loc, arg)\n /* ifdef WCHAR, integer parameter is 1 wchar_t.  */\n \n static void\n-PREFIX(store_op2) (op, loc, arg1, arg2)\n-    re_opcode_t op;\n-    UCHAR_T *loc;\n-    int arg1, arg2;\n+PREFIX(store_op2) (re_opcode_t op, UCHAR_T *loc, int arg1, int arg2)\n {\n   *loc = (UCHAR_T) op;\n   STORE_NUMBER (loc + 1, arg1);\n@@ -4294,11 +4248,7 @@ PREFIX(store_op2) (op, loc, arg1, arg2)\n /* ifdef WCHAR, integer parameter is 1 wchar_t.  */\n \n static void\n-PREFIX(insert_op1) (op, loc, arg, end)\n-    re_opcode_t op;\n-    UCHAR_T *loc;\n-    int arg;\n-    UCHAR_T *end;\n+PREFIX(insert_op1) (re_opcode_t op, UCHAR_T *loc, int arg, UCHAR_T *end)\n {\n   register UCHAR_T *pfrom = end;\n   register UCHAR_T *pto = end + 1 + OFFSET_ADDRESS_SIZE;\n@@ -4314,11 +4264,8 @@ PREFIX(insert_op1) (op, loc, arg, end)\n /* ifdef WCHAR, integer parameter is 1 wchar_t.  */\n \n static void\n-PREFIX(insert_op2) (op, loc, arg1, arg2, end)\n-    re_opcode_t op;\n-    UCHAR_T *loc;\n-    int arg1, arg2;\n-    UCHAR_T *end;\n+PREFIX(insert_op2) (re_opcode_t op, UCHAR_T *loc, int arg1,\n+                    int arg2, UCHAR_T *end)\n {\n   register UCHAR_T *pfrom = end;\n   register UCHAR_T *pto = end + 1 + 2 * OFFSET_ADDRESS_SIZE;\n@@ -4335,9 +4282,8 @@ PREFIX(insert_op2) (op, loc, arg1, arg2, end)\n    least one character before the ^.  */\n \n static boolean\n-PREFIX(at_begline_loc_p) (pattern, p, syntax)\n-    const CHAR_T *pattern, *p;\n-    reg_syntax_t syntax;\n+PREFIX(at_begline_loc_p) (const CHAR_T *pattern, const CHAR_T *p,\n+                          reg_syntax_t syntax)\n {\n   const CHAR_T *prev = p - 2;\n   boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\\\';\n@@ -4354,9 +4300,8 @@ PREFIX(at_begline_loc_p) (pattern, p, syntax)\n    at least one character after the $, i.e., `P < PEND'.  */\n \n static boolean\n-PREFIX(at_endline_loc_p) (p, pend, syntax)\n-    const CHAR_T *p, *pend;\n-    reg_syntax_t syntax;\n+PREFIX(at_endline_loc_p) (const CHAR_T *p, const CHAR_T *pend,\n+                          reg_syntax_t syntax)\n {\n   const CHAR_T *next = p;\n   boolean next_backslash = *next == '\\\\';\n@@ -4377,9 +4322,7 @@ PREFIX(at_endline_loc_p) (p, pend, syntax)\n    false if it's not.  */\n \n static boolean\n-group_in_compile_stack (compile_stack, regnum)\n-    compile_stack_type compile_stack;\n-    regnum_t regnum;\n+group_in_compile_stack (compile_stack_type compile_stack, regnum_t regnum)\n {\n   int this_element;\n \n@@ -4399,10 +4342,7 @@ group_in_compile_stack (compile_stack, regnum)\n /* This insert space, which size is \"num\", into the pattern at \"loc\".\n    \"end\" must point the end of the allocated buffer.  */\n static void\n-insert_space (num, loc, end)\n-     int num;\n-     CHAR_T *loc;\n-     CHAR_T *end;\n+insert_space (int num, CHAR_T *loc, CHAR_T *end)\n {\n   register CHAR_T *pto = end;\n   register CHAR_T *pfrom = end - num;\n@@ -4414,13 +4354,9 @@ insert_space (num, loc, end)\n \n #ifdef WCHAR\n static reg_errcode_t\n-wcs_compile_range (range_start_char, p_ptr, pend, translate, syntax, b,\n-\t\t   char_set)\n-     CHAR_T range_start_char;\n-     const CHAR_T **p_ptr, *pend;\n-     CHAR_T *char_set, *b;\n-     RE_TRANSLATE_TYPE translate;\n-     reg_syntax_t syntax;\n+wcs_compile_range (CHAR_T range_start_char, const CHAR_T **p_ptr,\n+                   const CHAR_T *pend, RE_TRANSLATE_TYPE translate,\n+                   reg_syntax_t syntax, CHAR_T *b, CHAR_T *char_set)\n {\n   const CHAR_T *p = *p_ptr;\n   CHAR_T range_start, range_end;\n@@ -4501,12 +4437,9 @@ wcs_compile_range (range_start_char, p_ptr, pend, translate, syntax, b,\n    `regex_compile' itself.  */\n \n static reg_errcode_t\n-byte_compile_range (range_start_char, p_ptr, pend, translate, syntax, b)\n-     unsigned int range_start_char;\n-     const char **p_ptr, *pend;\n-     RE_TRANSLATE_TYPE translate;\n-     reg_syntax_t syntax;\n-     unsigned char *b;\n+byte_compile_range (unsigned int range_start_char, const char **p_ptr,\n+                    const char *pend, RE_TRANSLATE_TYPE translate,\n+                    reg_syntax_t syntax, unsigned char *b)\n {\n   unsigned this_char;\n   const char *p = *p_ptr;\n@@ -4587,8 +4520,7 @@ byte_compile_range (range_start_char, p_ptr, pend, translate, syntax, b)\n static unsigned char truncate_wchar (CHAR_T c);\n \n static unsigned char\n-truncate_wchar (c)\n-     CHAR_T c;\n+truncate_wchar (CHAR_T c)\n {\n   unsigned char buf[MB_CUR_MAX];\n   mbstate_t state;\n@@ -4604,8 +4536,7 @@ truncate_wchar (c)\n #endif /* WCHAR */\n \n static int\n-PREFIX(re_compile_fastmap) (bufp)\n-     struct re_pattern_buffer *bufp;\n+PREFIX(re_compile_fastmap) (struct re_pattern_buffer *bufp)\n {\n   int j, k;\n #ifdef MATCH_MAY_ALLOCATE\n@@ -4924,8 +4855,7 @@ PREFIX(re_compile_fastmap) (bufp)\n #else /* not INSIDE_RECURSION */\n \n int\n-re_compile_fastmap (bufp)\n-     struct re_pattern_buffer *bufp;\n+re_compile_fastmap (struct re_pattern_buffer *bufp)\n {\n # ifdef MBS_SUPPORT\n   if (MB_CUR_MAX != 1)\n@@ -4953,11 +4883,9 @@ weak_alias (__re_compile_fastmap, re_compile_fastmap)\n    freeing the old data.  */\n \n void\n-re_set_registers (bufp, regs, num_regs, starts, ends)\n-    struct re_pattern_buffer *bufp;\n-    struct re_registers *regs;\n-    unsigned num_regs;\n-    regoff_t *starts, *ends;\n+re_set_registers (struct re_pattern_buffer *bufp,\n+                  struct re_registers *regs, unsigned num_regs,\n+                  regoff_t *starts, regoff_t *ends)\n {\n   if (num_regs)\n     {\n@@ -4983,11 +4911,8 @@ weak_alias (__re_set_registers, re_set_registers)\n    doesn't let you say where to stop matching.  */\n \n int\n-re_search (bufp, string, size, startpos, range, regs)\n-     struct re_pattern_buffer *bufp;\n-     const char *string;\n-     int size, startpos, range;\n-     struct re_registers *regs;\n+re_search (struct re_pattern_buffer *bufp, const char *string, int size,\n+           int startpos, int range, struct re_registers *regs)\n {\n   return re_search_2 (bufp, NULL, 0, string, size, startpos, range,\n \t\t      regs, size);\n@@ -5019,14 +4944,9 @@ weak_alias (__re_search, re_search)\n    stack overflow).  */\n \n int\n-re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)\n-     struct re_pattern_buffer *bufp;\n-     const char *string1, *string2;\n-     int size1, size2;\n-     int startpos;\n-     int range;\n-     struct re_registers *regs;\n-     int stop;\n+re_search_2 (struct re_pattern_buffer *bufp, const char *string1, int size1,\n+             const char *string2, int size2, int startpos, int range,\n+             struct re_registers *regs, int stop)\n {\n # ifdef MBS_SUPPORT\n   if (MB_CUR_MAX != 1)\n@@ -5082,15 +5002,10 @@ weak_alias (__re_search_2, re_search_2)\n \n \n static int\n-PREFIX(re_search_2) (bufp, string1, size1, string2, size2, startpos, range,\n-\t\t     regs, stop)\n-     struct re_pattern_buffer *bufp;\n-     const char *string1, *string2;\n-     int size1, size2;\n-     int startpos;\n-     int range;\n-     struct re_registers *regs;\n-     int stop;\n+PREFIX(re_search_2) (struct re_pattern_buffer *bufp, const char *string1,\n+                     int size1, const char *string2, int size2,\n+                     int startpos, int range,\n+                     struct re_registers *regs, int stop)\n {\n   int val;\n   register char *fastmap = bufp->fastmap;\n@@ -5473,11 +5388,8 @@ PREFIX(re_search_2) (bufp, string1, size1, string2, size2, startpos, range,\n /* re_match is like re_match_2 except it takes only a single string.  */\n \n int\n-re_match (bufp, string, size, pos, regs)\n-     struct re_pattern_buffer *bufp;\n-     const char *string;\n-     int size, pos;\n-     struct re_registers *regs;\n+re_match (struct re_pattern_buffer *bufp, const char *string,\n+          int size, int pos, struct re_registers *regs)\n {\n   int result;\n # ifdef MBS_SUPPORT\n@@ -5504,17 +5416,17 @@ weak_alias (__re_match, re_match)\n #endif /* not INSIDE_RECURSION */\n \n #ifdef INSIDE_RECURSION\n-static boolean PREFIX(group_match_null_string_p) _RE_ARGS ((UCHAR_T **p,\n-\t\t\t\t\t\t    UCHAR_T *end,\n-\t\t\t\t\tPREFIX(register_info_type) *reg_info));\n-static boolean PREFIX(alt_match_null_string_p) _RE_ARGS ((UCHAR_T *p,\n-\t\t\t\t\t\t  UCHAR_T *end,\n-\t\t\t\t\tPREFIX(register_info_type) *reg_info));\n-static boolean PREFIX(common_op_match_null_string_p) _RE_ARGS ((UCHAR_T **p,\n-\t\t\t\t\t\t\tUCHAR_T *end,\n-\t\t\t\t\tPREFIX(register_info_type) *reg_info));\n-static int PREFIX(bcmp_translate) _RE_ARGS ((const CHAR_T *s1, const CHAR_T *s2,\n-\t\t\t\t     int len, char *translate));\n+static boolean PREFIX(group_match_null_string_p) (UCHAR_T **p,\n+                                                  UCHAR_T *end,\n+\t\t\t\t\tPREFIX(register_info_type) *reg_info);\n+static boolean PREFIX(alt_match_null_string_p) (UCHAR_T *p,\n+                                                UCHAR_T *end,\n+\t\t\t\t\tPREFIX(register_info_type) *reg_info);\n+static boolean PREFIX(common_op_match_null_string_p) (UCHAR_T **p,\n+                                                      UCHAR_T *end,\n+\t\t\t\t\tPREFIX(register_info_type) *reg_info);\n+static int PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2,\n+                                   int len, char *translate);\n #else /* not INSIDE_RECURSION */\n \n /* re_match_2 matches the compiled pattern in BUFP against the\n@@ -5531,13 +5443,9 @@ static int PREFIX(bcmp_translate) _RE_ARGS ((const CHAR_T *s1, const CHAR_T *s2,\n    matched substring.  */\n \n int\n-re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)\n-     struct re_pattern_buffer *bufp;\n-     const char *string1, *string2;\n-     int size1, size2;\n-     int pos;\n-     struct re_registers *regs;\n-     int stop;\n+re_match_2 (struct re_pattern_buffer *bufp, const char *string1, int size1,\n+            const char *string2, int size2, int pos,\n+            struct re_registers *regs, int stop)\n {\n   int result;\n # ifdef MBS_SUPPORT\n@@ -5566,17 +5474,15 @@ weak_alias (__re_match_2, re_match_2)\n #ifdef INSIDE_RECURSION\n \n #ifdef WCHAR\n-static int count_mbs_length PARAMS ((int *, int));\n+static int count_mbs_length (int *, int);\n \n /* This check the substring (from 0, to length) of the multibyte string,\n    to which offset_buffer correspond. And count how many wchar_t_characters\n    the substring occupy. We use offset_buffer to optimization.\n    See convert_mbs_to_wcs.  */\n \n static int\n-count_mbs_length(offset_buffer, length)\n-     int *offset_buffer;\n-     int length;\n+count_mbs_length(int *offset_buffer, int length)\n {\n   int upper, lower;\n \n@@ -5617,33 +5523,26 @@ count_mbs_length(offset_buffer, length)\n    afterwards.  */\n #ifdef WCHAR\n static int\n-wcs_re_match_2_internal (bufp, cstring1, csize1, cstring2, csize2, pos,\n-\t\t\t regs, stop, string1, size1, string2, size2,\n-\t\t\t mbs_offset1, mbs_offset2)\n-     struct re_pattern_buffer *bufp;\n-     const char *cstring1, *cstring2;\n-     int csize1, csize2;\n-     int pos;\n-     struct re_registers *regs;\n-     int stop;\n+wcs_re_match_2_internal (struct re_pattern_buffer *bufp,\n+                         const char *cstring1, int csize1,\n+                         const char *cstring2, int csize2,\n+                         int pos,\n+\t\t\t struct re_registers *regs,\n+                         int stop,\n      /* string1 == string2 == NULL means string1/2, size1/2 and\n \tmbs_offset1/2 need seting up in this function.  */\n      /* We need wchar_t* buffers correspond to cstring1, cstring2.  */\n-     wchar_t *string1, *string2;\n-     /* We need the size of wchar_t buffers correspond to csize1, csize2.  */\n-     int size1, size2;\n+                         wchar_t *string1, int size1,\n+                         wchar_t *string2, int size2,\n      /* offset buffer for optimizatoin. See convert_mbs_to_wc.  */\n-     int *mbs_offset1, *mbs_offset2;\n+\t\t\t int *mbs_offset1, int *mbs_offset2)\n #else /* BYTE */\n static int\n-byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n-\t\t\t  regs, stop)\n-     struct re_pattern_buffer *bufp;\n-     const char *string1, *string2;\n-     int size1, size2;\n-     int pos;\n-     struct re_registers *regs;\n-     int stop;\n+byte_re_match_2_internal (struct re_pattern_buffer *bufp,\n+                          const char *string1, int size1,\n+                          const char *string2, int size2,\n+                          int pos,\n+\t\t\t  struct re_registers *regs, int stop)\n #endif /* BYTE */\n {\n   /* General temporaries.  */\n@@ -7593,9 +7492,8 @@ byte_re_match_2_internal (bufp, string1, size1,string2, size2, pos,\n    We don't handle duplicates properly (yet).  */\n \n static boolean\n-PREFIX(group_match_null_string_p) (p, end, reg_info)\n-    UCHAR_T **p, *end;\n-    PREFIX(register_info_type) *reg_info;\n+PREFIX(group_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,\n+                                   PREFIX(register_info_type) *reg_info)\n {\n   int mcnt;\n   /* Point to after the args to the start_memory.  */\n@@ -7705,9 +7603,8 @@ PREFIX(group_match_null_string_p) (p, end, reg_info)\n    byte past the last. The alternative can contain groups.  */\n \n static boolean\n-PREFIX(alt_match_null_string_p) (p, end, reg_info)\n-    UCHAR_T *p, *end;\n-    PREFIX(register_info_type) *reg_info;\n+PREFIX(alt_match_null_string_p) (UCHAR_T *p, UCHAR_T *end,\n+                                 PREFIX(register_info_type) *reg_info)\n {\n   int mcnt;\n   UCHAR_T *p1 = p;\n@@ -7742,9 +7639,8 @@ PREFIX(alt_match_null_string_p) (p, end, reg_info)\n    Sets P to one after the op and its arguments, if any.  */\n \n static boolean\n-PREFIX(common_op_match_null_string_p) (p, end, reg_info)\n-    UCHAR_T **p, *end;\n-    PREFIX(register_info_type) *reg_info;\n+PREFIX(common_op_match_null_string_p) (UCHAR_T **p, UCHAR_T *end,\n+                                       PREFIX(register_info_type) *reg_info)\n {\n   int mcnt;\n   boolean ret;\n@@ -7830,10 +7726,8 @@ PREFIX(common_op_match_null_string_p) (p, end, reg_info)\n    bytes; nonzero otherwise.  */\n \n static int\n-PREFIX(bcmp_translate) (s1, s2, len, translate)\n-     const CHAR_T *s1, *s2;\n-     register int len;\n-     RE_TRANSLATE_TYPE translate;\n+PREFIX(bcmp_translate) (const CHAR_T *s1, const CHAR_T *s2, register int len,\n+                        RE_TRANSLATE_TYPE translate)\n {\n   register const UCHAR_T *p1 = (const UCHAR_T *) s1;\n   register const UCHAR_T *p2 = (const UCHAR_T *) s2;\n@@ -7866,10 +7760,8 @@ PREFIX(bcmp_translate) (s1, s2, len, translate)\n    We call regex_compile to do the actual compilation.  */\n \n const char *\n-re_compile_pattern (pattern, length, bufp)\n-     const char *pattern;\n-     size_t length;\n-     struct re_pattern_buffer *bufp;\n+re_compile_pattern (const char *pattern, size_t length,\n+                    struct re_pattern_buffer *bufp)\n {\n   reg_errcode_t ret;\n \n@@ -7915,8 +7807,7 @@ char *\n    regcomp/regexec below without link errors.  */\n weak_function\n #endif\n-re_comp (s)\n-    const char *s;\n+re_comp (const char *s)\n {\n   reg_errcode_t ret;\n \n@@ -7964,8 +7855,7 @@ int\n #ifdef _LIBC\n weak_function\n #endif\n-re_exec (s)\n-    const char *s;\n+re_exec (const char *s)\n {\n   const int len = strlen (s);\n   return\n@@ -8014,10 +7904,7 @@ re_exec (s)\n    the return codes and their meanings.)  */\n \n int\n-regcomp (preg, pattern, cflags)\n-    regex_t *preg;\n-    const char *pattern;\n-    int cflags;\n+regcomp (regex_t *preg, const char *pattern, int cflags)\n {\n   reg_errcode_t ret;\n   reg_syntax_t syntax\n@@ -8110,12 +7997,8 @@ weak_alias (__regcomp, regcomp)\n    We return 0 if we find a match and REG_NOMATCH if not.  */\n \n int\n-regexec (preg, string, nmatch, pmatch, eflags)\n-    const regex_t *preg;\n-    const char *string;\n-    size_t nmatch;\n-    regmatch_t pmatch[];\n-    int eflags;\n+regexec (const regex_t *preg, const char *string, size_t nmatch,\n+         regmatch_t pmatch[], int eflags)\n {\n   int ret;\n   struct re_registers regs;\n@@ -8177,11 +8060,8 @@ weak_alias (__regexec, regexec)\n    from either regcomp or regexec.   We don't use PREG here.  */\n \n size_t\n-regerror (errcode, preg, errbuf, errbuf_size)\n-    int errcode;\n-    const regex_t *preg ATTRIBUTE_UNUSED;\n-    char *errbuf;\n-    size_t errbuf_size;\n+regerror (int errcode, const regex_t *preg ATTRIBUTE_UNUSED,\n+          char *errbuf, size_t errbuf_size)\n {\n   const char *msg;\n   size_t msg_size;\n@@ -8224,8 +8104,7 @@ weak_alias (__regerror, regerror)\n /* Free dynamically allocated space used by PREG.  */\n \n void\n-regfree (preg)\n-    regex_t *preg;\n+regfree (regex_t *preg)\n {\n   if (preg->buffer != NULL)\n     free (preg->buffer);"}]}