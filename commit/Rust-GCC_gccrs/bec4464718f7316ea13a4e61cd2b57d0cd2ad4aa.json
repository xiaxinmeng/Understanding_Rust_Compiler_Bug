{"sha": "bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjNDQ2NDcxOGY3MzE2ZWExM2E0ZTYxY2QyYjU3ZDBjZDJhZDRhYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-13T06:07:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-13T06:07:03Z"}, "message": "tree-ssa-forwprop.c (vars, [...]): Remove.\n\n\t* tree-ssa-forwprop.c (vars,\n\trecord_single_argument_cond_exprs,\n\tsubstitute_single_use_vars): Remove.\n\t(forward_propagate_into_cond_1, forward_propagate_into_cond):\n\tNew.\n\t(tree_ssa_forward_propagate_single_use_vars): Call\n\tforward_propagate_into_cond for each COND_EXPR.\n\nFrom-SVN: r98072", "tree": {"sha": "e5605b78db83dc6e838d1f41bf16ea885f3ef05e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5605b78db83dc6e838d1f41bf16ea885f3ef05e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa/comments", "author": null, "committer": null, "parents": [{"sha": "8450a17040a3bc40fe8893163d89bf413a101a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8450a17040a3bc40fe8893163d89bf413a101a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8450a17040a3bc40fe8893163d89bf413a101a95"}], "stats": {"total": 558, "additions": 224, "deletions": 334}, "files": [{"sha": "7fbb81349ec8013dc96406718e8902238fc8842f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "patch": "@@ -4,6 +4,14 @@\n \n \t* cgraphunit.c (INSNS_PER_CALL): Remove.\n \n+\t* tree-ssa-forwprop.c (vars,\n+\trecord_single_argument_cond_exprs,\n+\tsubstitute_single_use_vars): Remove.\n+\t(forward_propagate_into_cond_1, forward_propagate_into_cond):\n+\tNew.\n+\t(tree_ssa_forward_propagate_single_use_vars): Call\n+\tforward_propagate_into_cond for each COND_EXPR.\n+\n 2005-04-12  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_prepare_sse_fp_compare_args): Split ..."}, {"sha": "75fe6e17c764535f42cd3e29919d110e7df0b876", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 216, "deletions": 334, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=bec4464718f7316ea13a4e61cd2b57d0cd2ad4aa", "patch": "@@ -100,7 +100,7 @@ Boston, MA 02111-1307, USA.  */\n \n    In addition to eliminating the variable and the statement which assigns\n    a value to the variable, we may be able to later thread the jump without\n-   adding insane complexity in the dominator optimizer. \n+   adding insane complexity in the dominator optimizer.\n \n    Also note these transformations can cascade.  We handle this by having\n    a worklist of COND_EXPR statements to examine.  As we make a change to\n@@ -109,293 +109,131 @@ Boston, MA 02111-1307, USA.  */\n \n    This will (of course) be extended as other needs arise.  */\n \n-/* Bitmap of variables for which we want immediate uses.  This is set\n-   by record_single_argument_cond_exprs and tested in need_imm_uses_for.  */\n-static bitmap vars;\n-\n-static void tree_ssa_forward_propagate_single_use_vars (void);\n-static void record_single_argument_cond_exprs (varray_type,\n-\t\t\t\t\t       varray_type *,\n-\t\t\t\t\t       bitmap);\n-static void substitute_single_use_vars (varray_type *, varray_type);\n-\n-/* Find all COND_EXPRs with a condition that is a naked SSA_NAME or\n-   an equality comparison against a constant.\n-\n-   Record the identified COND_EXPRs and the SSA_NAME used in the COND_EXPR\n-   into a virtual array, which is returned to the caller.  Also record\n-   into VARS that we will need immediate uses for the identified SSA_NAME.\n-\n-   The more uninteresting COND_EXPRs and associated SSA_NAMEs we can\n-   filter out here, the faster this pass will run since its runtime is\n-   dominated by the time to build immediate uses.  */\n-\n-static void\n-record_single_argument_cond_exprs (varray_type cond_worklist,\n-\t\t\t\t   varray_type *vars_worklist,\n-\t\t\t\t   bitmap vars)\n+/* Forward propagate a single-use variable into COND once.  Return a\n+   new condition if successful.  Return NULL_TREE otherwise.  */\n \n+static tree\n+forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n {\n-  /* The first pass over the blocks gathers the set of variables we need\n-     immediate uses for as well as the set of interesting COND_EXPRs.\n-\n-     A simpler implementation may be appropriate if/when we have a lower\n-     overhead means of getting immediate use information.  */\n-  while (VARRAY_ACTIVE_SIZE (cond_worklist) > 0)\n+  tree new_cond = NULL_TREE;\n+  enum tree_code cond_code = TREE_CODE (cond);\n+  tree test_var = NULL_TREE;\n+  tree def;\n+  tree def_rhs;\n+\n+  /* If the condition is not a lone variable or an equality test of an\n+     SSA_NAME against an integral constant, then we do not have an\n+     optimizable case.\n+\n+     Note these conditions also ensure the COND_EXPR has no\n+     virtual operands or other side effects.  */\n+  if (cond_code != SSA_NAME\n+      && !((cond_code == EQ_EXPR || cond_code == NE_EXPR)\n+\t   && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n+\t   && CONSTANT_CLASS_P (TREE_OPERAND (cond, 1))\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n+    return NULL_TREE;\n+\n+  /* Extract the single variable used in the test into TEST_VAR.  */\n+  if (cond_code == SSA_NAME)\n+    test_var = cond;\n+  else\n+    test_var = TREE_OPERAND (cond, 0);\n+\n+  /* Now get the defining statement for TEST_VAR.  Skip this case if\n+     it's not defined by some MODIFY_EXPR.  */\n+  def = SSA_NAME_DEF_STMT (test_var);\n+  if (TREE_CODE (def) != MODIFY_EXPR)\n+    return NULL_TREE;\n+\n+  def_rhs = TREE_OPERAND (def, 1);\n+\n+  /* If TEST_VAR is set by adding or subtracting a constant\n+     from an SSA_NAME, then it is interesting to us as we\n+     can adjust the constant in the conditional and thus\n+     eliminate the arithmetic operation.  */\n+  if (TREE_CODE (def_rhs) == PLUS_EXPR\n+      || TREE_CODE (def_rhs) == MINUS_EXPR)\n     {\n-      tree last = VARRAY_TOP_TREE (cond_worklist);\n-\n-      VARRAY_POP (cond_worklist);\n-\n-      /* See if this block ends in a COND_EXPR.  */\n-      if (last && TREE_CODE (last) == COND_EXPR)\n+      tree op0 = TREE_OPERAND (def_rhs, 0);\n+      tree op1 = TREE_OPERAND (def_rhs, 1);\n+\n+      /* The first operand must be an SSA_NAME and the second\n+\t operand must be a constant.  */\n+      if (TREE_CODE (op0) != SSA_NAME\n+\t  || !CONSTANT_CLASS_P (op1)\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n+\treturn NULL_TREE;\n+\n+      /* Don't propagate if the first operand occurs in\n+\t an abnormal PHI.  */\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n+\treturn NULL_TREE;\n+\n+      if (has_single_use (test_var))\n \t{\n-\t  tree cond = COND_EXPR_COND (last);\n-\t  enum tree_code cond_code = TREE_CODE (cond);\n-\n-\t  /* If the condition is a lone variable or an equality test of\n-\t     an SSA_NAME against an integral constant, then we may have an \n-\t     optimizable case.\n-\n-\t     Note these conditions also ensure the COND_EXPR has no\n-\t     virtual operands or other side effects.  */\n-\t  if (cond_code == SSA_NAME\n-\t      || ((cond_code == EQ_EXPR || cond_code == NE_EXPR)\n-\t\t  && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n-\t\t  && CONSTANT_CLASS_P (TREE_OPERAND (cond, 1))\n-\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n-\t    {\n-\t      tree def;\n-\t      tree test_var;\n-\n-\t      /* Extract the single variable used in the test into TEST_VAR.  */\n-\t      if (cond_code == SSA_NAME)\n-\t\ttest_var = cond;\n-\t      else\n-\t\ttest_var = TREE_OPERAND (cond, 0);\n-\n-\t      /* If we have already recorded this SSA_NAME as interesting,\n-\t\t do not do so again.  */\n-\t      if (bitmap_bit_p (vars, SSA_NAME_VERSION (test_var)))\n-\t\tcontinue;\n-\n-\t      /* Now get the defining statement for TEST_VAR and see if it\n-\t\t something we are interested in.  */\n-\t      def = SSA_NAME_DEF_STMT (test_var);\n-\t      if (TREE_CODE (def) == MODIFY_EXPR)\n-\t\t{\n-\t\t  tree def_rhs = TREE_OPERAND (def, 1);\n-\n-\t\t  /* If TEST_VAR is set by adding or subtracting a constant\n-\t\t     from an SSA_NAME, then it is interesting to us as we\n-\t\t     can adjust the constant in the conditional and thus\n-\t\t     eliminate the arithmetic operation.  */\n-\t\t  if (TREE_CODE (def_rhs) == PLUS_EXPR\n-\t\t\t || TREE_CODE (def_rhs) == MINUS_EXPR)\n-\t\t    {\n-\t\t      tree op0 = TREE_OPERAND (def_rhs, 0);\n-\t\t      tree op1 = TREE_OPERAND (def_rhs, 1);\n-\n-\t\t      /* The first operand must be an SSA_NAME and the second\n-\t\t\t operand must be a constant.  */\n-\t\t      if (TREE_CODE (op0) != SSA_NAME\n-\t\t\t  || !CONSTANT_CLASS_P (op1)\n-\t\t\t  || !INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n-\t\t\tcontinue;\n-\t\t      \n-\t\t      /* Don't propagate if the first operand occurs in\n-\t\t         an abnormal PHI.  */\n-\t\t      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n-\t\t        continue;\n-\t\t    }\n-\n-\t\t  /* These cases require comparisons of a naked SSA_NAME or\n-\t\t     comparison of an SSA_NAME against zero or one.  */\n-\t\t  else if (TREE_CODE (cond) == SSA_NAME\n-\t\t\t   || integer_zerop (TREE_OPERAND (cond, 1))\n-\t\t\t   || integer_onep (TREE_OPERAND (cond, 1)))\n-\t\t    {\n-\t\t      /* If TEST_VAR is set from a relational operation\n-\t\t\t between two SSA_NAMEs or a combination of an SSA_NAME\n-\t\t\t and a constant, then it is interesting.  */\n-\t\t      if (COMPARISON_CLASS_P (def_rhs))\n-\t\t\t{\n-\t\t\t  tree op0 = TREE_OPERAND (def_rhs, 0);\n-\t\t\t  tree op1 = TREE_OPERAND (def_rhs, 1);\n-\n-\t\t\t  /* Both operands of DEF_RHS must be SSA_NAMEs or\n-\t\t\t     constants.  */\n-\t\t\t  if ((TREE_CODE (op0) != SSA_NAME\n-\t\t\t       && !is_gimple_min_invariant (op0))\n-\t\t\t      || (TREE_CODE (op1) != SSA_NAME\n-\t\t\t\t  && !is_gimple_min_invariant (op1)))\n-\t\t\t    continue;\n-\t\t      \n-\t\t\t  /* Don't propagate if the first operand occurs in\n-\t\t\t     an abnormal PHI.  */\n-\t\t\t  if (TREE_CODE (op0) == SSA_NAME\n-\t\t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n-\t\t\t    continue;\n-\t\t      \n-\t\t\t  /* Don't propagate if the second operand occurs in\n-\t\t\t     an abnormal PHI.  */\n-\t\t\t  if (TREE_CODE (op1) == SSA_NAME\n-\t\t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op1))\n-\t\t\t    continue;\n-\t\t        }\n-\n-\t\t      /* If TEST_VAR is set from a TRUTH_NOT_EXPR, then it\n-\t\t\t is interesting.  */\n-\t\t      else if (TREE_CODE (def_rhs) == TRUTH_NOT_EXPR)\n-\t\t\t{\n-\t\t\t  def_rhs = TREE_OPERAND (def_rhs, 0);\n-\n-\t\t\t  /* DEF_RHS must be an SSA_NAME or constant.  */\n-\t\t\t  if (TREE_CODE (def_rhs) != SSA_NAME\n-\t\t\t      && !is_gimple_min_invariant (def_rhs))\n-\t\t\t    continue;\n-\t\t      \n-\t\t\t  /* Don't propagate if the operand occurs in\n-\t\t\t     an abnormal PHI.  */\n-\t\t\t  if (TREE_CODE (def_rhs) == SSA_NAME\n-\t\t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def_rhs))\n-\t\t\t    continue;\n-\t\t\t}\n-\n-\t\t      /* If TEST_VAR was set from a cast of an integer type\n-\t\t\t to a boolean type or a cast of a boolean to an\n-\t\t\t integral, then it is interesting.  */\n-\t\t      else if (TREE_CODE (def_rhs) == NOP_EXPR\n-\t\t\t       || TREE_CODE (def_rhs) == CONVERT_EXPR)\n-\t\t\t{\n-\t\t\t  tree outer_type;\n-\t\t\t  tree inner_type;\n-\n-\t\t\t  outer_type = TREE_TYPE (def_rhs);\n-\t\t\t  inner_type = TREE_TYPE (TREE_OPERAND (def_rhs, 0));\n-\n-\t\t\t  if ((TREE_CODE (outer_type) == BOOLEAN_TYPE\n-\t\t\t       && INTEGRAL_TYPE_P (inner_type))\n-\t\t\t      || (TREE_CODE (inner_type) == BOOLEAN_TYPE\n-\t\t\t\t  && INTEGRAL_TYPE_P (outer_type)))\n-\t\t\t    ;\n-\t\t\t  else\n-\t\t\t    continue;\n-\t\t      \n-\t\t\t  /* Don't propagate if the operand occurs in\n-\t\t\t     an abnormal PHI.  */\n-\t\t\t  if (TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME\n-\t\t\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND\n-\t\t\t\t\t                          (def_rhs, 0)))\n-\t\t\t    continue;\n-\t\t\t}\n-\t\t      else\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  else\n-\t\t    continue;\n-\n-\t\t  /* All the tests passed, record TEST_VAR as interesting.  */\n-\t\t  VARRAY_PUSH_TREE (*vars_worklist, test_var);\n-\t\t  bitmap_set_bit (vars, SSA_NAME_VERSION (test_var));\n-\t\t}\n-\t    }\n+\t  tree op0 = TREE_OPERAND (def_rhs, 0);\n+\t  tree op1 = TREE_OPERAND (def_rhs, 1);\n+\t  enum tree_code new_code;\n+\t  tree t;\n+\n+\t  /* If the variable was defined via X + C, then we must\n+\t     subtract C from the constant in the conditional.\n+\t     Otherwise we add C to the constant in the\n+\t     conditional.  The result must fold into a valid\n+\t     gimple operand to be optimizable.  */\n+\t  new_code = (TREE_CODE (def_rhs) == PLUS_EXPR\n+\t\t      ? MINUS_EXPR : PLUS_EXPR);\n+\t  t = int_const_binop (new_code, TREE_OPERAND (cond, 1), op1, 0);\n+\t  if (!is_gimple_val (t))\n+\t    return NULL_TREE;\n+\n+\t  new_cond = build (cond_code, boolean_type_node, op0, t);\n \t}\n     }\n-}\n \n-/* Given FORWPROP_DATA containing SSA_NAMEs which are used in COND_EXPRs\n-   that we may be able to optimize, attempt to rewrite the condition\n-   in each COND_EXPR to use the RHS of the statement which defines the\n-   SSA_NAME used in the COND_EXPR.  */\n-  \n-static void\n-substitute_single_use_vars (varray_type *cond_worklist,\n-\t\t\t    varray_type vars_worklist)\n-{\n-  use_operand_p use_p;\n-  while (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n+  /* These cases require comparisons of a naked SSA_NAME or\n+     comparison of an SSA_NAME against zero or one.  */\n+  else if (TREE_CODE (cond) == SSA_NAME\n+\t   || integer_zerop (TREE_OPERAND (cond, 1))\n+\t   || integer_onep (TREE_OPERAND (cond, 1)))\n     {\n-      tree test_var = VARRAY_TOP_TREE (vars_worklist);\n-      tree def_stmt = SSA_NAME_DEF_STMT (test_var);\n-      tree def;\n-      int num_uses, propagated_uses;\n-      imm_use_iterator imm_iter;\n-\n-      VARRAY_POP (vars_worklist);\n-\n-      propagated_uses = 0;\n-      num_uses = 0;\n-\n-      if (NUM_DEFS (STMT_DEF_OPS (def_stmt)) != 1)\n-\tcontinue;\n-\n-      def = DEF_OP (STMT_DEF_OPS (def_stmt), 0);\n-\n-      /* If TEST_VAR is used more than once and is not a boolean set\n-\t via TRUTH_NOT_EXPR with another SSA_NAME as its argument, then\n-\t we can not optimize.  */\n-      if (has_single_use (def)\n-\t  || (TREE_CODE (TREE_TYPE (test_var)) == BOOLEAN_TYPE\n-\t      && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_NOT_EXPR\n-\t      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0))\n-\t\t  == SSA_NAME)))\n-\t;\n-      else\n-\tcontinue;\n-\n-      /* Walk over each use and try to forward propagate the RHS of\n-\t DEF into the use.  */\n-      FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, def)\n+      /* If TEST_VAR is set from a relational operation\n+\t between two SSA_NAMEs or a combination of an SSA_NAME\n+\t and a constant, then it is interesting.  */\n+      if (COMPARISON_CLASS_P (def_rhs))\n \t{\n-\t  tree cond_stmt;\n-\t  tree cond;\n-\t  enum tree_code cond_code;\n-\t  tree def_rhs;\n-\t  enum tree_code def_rhs_code;\n-\t  tree new_cond;\n-\n-\t  cond_stmt = USE_STMT (use_p);\n-\t  num_uses++;\n-\n-\t  /* For now we can only propagate into COND_EXPRs.  */\n-\t  if (TREE_CODE (cond_stmt) != COND_EXPR) \n-\t    continue;\n-\n-\t  cond = COND_EXPR_COND (cond_stmt);\n-\t  cond_code = TREE_CODE (cond);\n-\t  def_rhs = TREE_OPERAND (def_stmt, 1);\n-\t  def_rhs_code = TREE_CODE (def_rhs);\n-\n-\t  /* If the definition of the single use variable was from an\n-\t     arithmetic operation, then we just need to adjust the\n-\t     constant in the COND_EXPR_COND and update the variable tested.  */\n-\t  if (def_rhs_code == PLUS_EXPR || def_rhs_code == MINUS_EXPR)\n-\t    {\n-\t      tree op0 = TREE_OPERAND (def_rhs, 0);\n-\t      tree op1 = TREE_OPERAND (def_rhs, 1);\n-\t      enum tree_code new_code;\n-\t      tree t;\n-\n-\t      /* If the variable was defined via X + C, then we must subtract\n-\t\t C from the constant in the conditional.  Otherwise we add\n-\t\t C to the constant in the conditional.  The result must fold\n-\t\t into a valid gimple operand to be optimizable.  */\n-\t      new_code = def_rhs_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n-\t      t = int_const_binop (new_code, TREE_OPERAND (cond, 1), op1, 0);\n-\t      if (!is_gimple_val (t))\n-\t\tcontinue;\n-\n-\t      new_cond = build (cond_code, boolean_type_node, op0, t);\n-\t    }\n-\t  /* If the variable is defined by a conditional expression... */\n-\t  else if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n+\t  tree op0 = TREE_OPERAND (def_rhs, 0);\n+\t  tree op1 = TREE_OPERAND (def_rhs, 1);\n+\n+\t  /* Both operands of DEF_RHS must be SSA_NAMEs or\n+\t     constants.  */\n+\t  if ((TREE_CODE (op0) != SSA_NAME\n+\t       && !is_gimple_min_invariant (op0))\n+\t      || (TREE_CODE (op1) != SSA_NAME\n+\t\t  && !is_gimple_min_invariant (op1)))\n+\t    return NULL_TREE;\n+\n+\t  /* Don't propagate if the first operand occurs in\n+\t     an abnormal PHI.  */\n+\t  if (TREE_CODE (op0) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n+\t    return NULL_TREE;\n+\n+\t  /* Don't propagate if the second operand occurs in\n+\t     an abnormal PHI.  */\n+\t  if (TREE_CODE (op1) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op1))\n+\t    return NULL_TREE;\n+\n+\t  if (has_single_use (test_var))\n \t    {\n \t      /* TEST_VAR was set from a relational operator.  */\n \t      tree op0 = TREE_OPERAND (def_rhs, 0);\n \t      tree op1 = TREE_OPERAND (def_rhs, 1);\n \n-\t      new_cond = build (def_rhs_code, boolean_type_node, op0, op1);\n+\t      new_cond = build (TREE_CODE (def_rhs),\n+\t\t\t\tboolean_type_node, op0, op1);\n \n \t      /* Invert the conditional if necessary.  */\n \t      if ((cond_code == EQ_EXPR\n@@ -405,23 +243,81 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t\t{\n \t\t  new_cond = invert_truthvalue (new_cond);\n \n-\t\t  /* If we did not get a simple relational expression or\n-\t\t     bare SSA_NAME, then we can not optimize this case.  */\n+\t\t  /* If we did not get a simple relational\n+\t\t     expression or bare SSA_NAME, then we can\n+\t\t     not optimize this case.  */\n \t\t  if (!COMPARISON_CLASS_P (new_cond)\n \t\t      && TREE_CODE (new_cond) != SSA_NAME)\n-\t\t    continue;\n+\t\t    new_cond = NULL_TREE;\n \t\t}\n \t    }\n+\t}\n+\n+      /* If TEST_VAR is set from a TRUTH_NOT_EXPR, then it\n+\t is interesting.  */\n+      else if (TREE_CODE (def_rhs) == TRUTH_NOT_EXPR)\n+\t{\n+\t  enum tree_code new_code;\n+\n+\t  def_rhs = TREE_OPERAND (def_rhs, 0);\n+\n+\t  /* DEF_RHS must be an SSA_NAME or constant.  */\n+\t  if (TREE_CODE (def_rhs) != SSA_NAME\n+\t      && !is_gimple_min_invariant (def_rhs))\n+\t    return NULL_TREE;\n+\n+\t  /* Don't propagate if the operand occurs in\n+\t     an abnormal PHI.  */\n+\t  if (TREE_CODE (def_rhs) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def_rhs))\n+\t    return NULL_TREE;\n+\n+\t  if (cond_code == SSA_NAME\n+\t      || (cond_code == NE_EXPR\n+\t\t  && integer_zerop (TREE_OPERAND (cond, 1)))\n+\t      || (cond_code == EQ_EXPR\n+\t\t  && integer_onep (TREE_OPERAND (cond, 1))))\n+\t    new_code = EQ_EXPR;\n+\t  else\n+\t    new_code = NE_EXPR;\n+\n+\t  new_cond = build2 (new_code, boolean_type_node, def_rhs,\n+\t\t\t     fold_convert (TREE_TYPE (def_rhs),\n+\t\t\t\t\t   integer_zero_node));\n+\t}\n+\n+      /* If TEST_VAR was set from a cast of an integer type\n+\t to a boolean type or a cast of a boolean to an\n+\t integral, then it is interesting.  */\n+      else if (TREE_CODE (def_rhs) == NOP_EXPR\n+\t       || TREE_CODE (def_rhs) == CONVERT_EXPR)\n+\t{\n+\t  tree outer_type;\n+\t  tree inner_type;\n+\n+\t  outer_type = TREE_TYPE (def_rhs);\n+\t  inner_type = TREE_TYPE (TREE_OPERAND (def_rhs, 0));\n+\n+\t  if ((TREE_CODE (outer_type) == BOOLEAN_TYPE\n+\t       && INTEGRAL_TYPE_P (inner_type))\n+\t      || (TREE_CODE (inner_type) == BOOLEAN_TYPE\n+\t\t  && INTEGRAL_TYPE_P (outer_type)))\n+\t    ;\n \t  else\n+\t    return NULL_TREE;\n+\n+\t  /* Don't propagate if the operand occurs in\n+\t     an abnormal PHI.  */\n+\t  if (TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND\n+\t\t\t\t\t\t  (def_rhs, 0)))\n+\t    return NULL_TREE;\n+\n+\t  if (has_single_use (test_var))\n \t    {\n-\t      bool invert = false;\n \t      enum tree_code new_code;\n \t      tree new_arg;\n \n-\t      /* TEST_VAR was set from a TRUTH_NOT_EXPR or a NOP_EXPR.  */\n-\t      if (def_rhs_code == TRUTH_NOT_EXPR)\n-\t\tinvert = true;\n-\t\t\n \t      if (cond_code == SSA_NAME\n \t\t  || (cond_code == NE_EXPR\n \t\t      && integer_zerop (TREE_OPERAND (cond, 1)))\n@@ -431,38 +327,53 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t      else\n \t\tnew_code = EQ_EXPR;\n \n-\t      if (invert)\n-\t\tnew_code = (new_code == EQ_EXPR ? NE_EXPR  : EQ_EXPR);\n-\n \t      new_arg = TREE_OPERAND (def_rhs, 0);\n \t      new_cond = build2 (new_code, boolean_type_node, new_arg,\n \t\t\t\t fold_convert (TREE_TYPE (new_arg),\n \t\t\t\t\t       integer_zero_node));\n \t    }\n+\t}\n+    }\n \n-\t  /* Dump details.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"  Replaced '\");\n-\t      print_generic_expr (dump_file, cond, dump_flags);\n-\t      fprintf (dump_file, \"' with '\");\n-\t      print_generic_expr (dump_file, new_cond, dump_flags);\n-\t      fprintf (dump_file, \"'\\n\");\n-\t    }\n+  *test_var_p = test_var;\n+  return new_cond;\n+}\n+\n+/* Forward propagate a single-use variable into COND_EXPR as many\n+   times as possible.  */\n \n-\t  /* Replace the condition.  */\n-\t  COND_EXPR_COND (cond_stmt) = new_cond;\n-\t  update_stmt (cond_stmt);\n-\t  propagated_uses++;\n-\t  VARRAY_PUSH_TREE (*cond_worklist, cond_stmt);\n+static void\n+forward_propagate_into_cond (tree cond_expr)\n+{\n+  gcc_assert (TREE_CODE (cond_expr) == COND_EXPR);\n+\n+  while (1)\n+    {\n+      tree test_var = NULL_TREE;\n+      tree cond = COND_EXPR_COND (cond_expr);\n+      tree new_cond = forward_propagate_into_cond_1 (cond, &test_var);\n+\n+      /* Return if unsuccessful.  */\n+      if (new_cond == NULL_TREE)\n+\tbreak;\n+\n+      /* Dump details.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, cond, dump_flags);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, new_cond, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n \t}\n \n-      /* If we propagated into all the uses, then we can delete DEF.\n-\t Unfortunately, we have to find the defining statement in\n-\t whatever block it might be in.  */\n-      if (num_uses && num_uses == propagated_uses)\n+      COND_EXPR_COND (cond_expr) = new_cond;\n+      update_stmt (cond_expr);\n+\n+      if (has_zero_uses (test_var))\n \t{\n-\t  block_stmt_iterator bsi = bsi_for_stmt (def_stmt);\n+\t  tree def = SSA_NAME_DEF_STMT (test_var);\n+\t  block_stmt_iterator bsi = bsi_for_stmt (def);\n \t  bsi_remove (&bsi);\n \t}\n     }\n@@ -474,42 +385,13 @@ static void\n tree_ssa_forward_propagate_single_use_vars (void)\n {\n   basic_block bb;\n-  varray_type vars_worklist, cond_worklist;\n-\n-  vars = BITMAP_ALLOC (NULL);\n-  VARRAY_TREE_INIT (vars_worklist, 10, \"VARS worklist\");\n-  VARRAY_TREE_INIT (cond_worklist, 10, \"COND worklist\");\n \n-  /* Prime the COND_EXPR worklist by placing all the COND_EXPRs on the\n-     worklist.  */\n   FOR_EACH_BB (bb)\n     {\n       tree last = last_stmt (bb);\n       if (last && TREE_CODE (last) == COND_EXPR)\n-\tVARRAY_PUSH_TREE (cond_worklist, last);\n+\tforward_propagate_into_cond (last);\n     }\n-\n-  while (VARRAY_ACTIVE_SIZE (cond_worklist) > 0)\n-    {\n-      /* First get a list of all the interesting COND_EXPRs and potential\n-\t single use variables which feed those COND_EXPRs.  This will drain\n-\t COND_WORKLIST and initialize VARS_WORKLIST.  */\n-      record_single_argument_cond_exprs (cond_worklist, &vars_worklist, vars);\n-\n-      if (VARRAY_ACTIVE_SIZE (vars_worklist) > 0)\n-\t{\n-\t  /* We've computed immediate uses, so we can/must clear the VARS\n-\t     bitmap for the next iteration.  */\n-\t  bitmap_clear (vars);\n-\n-\t  /* And optimize.  This will drain VARS_WORKLIST and initialize\n-\t     COND_WORKLIST for the next iteration.  */\n-\t  substitute_single_use_vars (&cond_worklist, vars_worklist);\n-\t}\n-    }\n-\n-  /* All done.  Clean up.  */\n-  BITMAP_FREE (vars);\n }\n \n "}]}