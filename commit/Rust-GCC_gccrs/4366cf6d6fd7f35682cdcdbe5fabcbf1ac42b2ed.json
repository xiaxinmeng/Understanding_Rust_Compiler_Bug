{"sha": "4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2NmNmNmQ2ZmQ3ZjM1NjgyY2RjZGJlNWZhYmNiZjFhYzQyYjJlZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-01-19T22:50:04Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-01-19T22:50:04Z"}, "message": "re PR tree-optimization/19038 (tree-ssa causing loops to have more than one BB)\n\n\tPR tree-optimization/19038\n\t* tree-ssa-loop-ivopts.c (allow_ip_end_pos_p): New function.\n\t(add_candidate): Add ivs with increment in latch only if\n\tallow_ip_end_pos_p is true.\n\t(determine_iv_cost): Use empty_block_p.\n\nFrom-SVN: r93925", "tree": {"sha": "29e5422130765c2da580006f646d90ee08cd9e2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29e5422130765c2da580006f646d90ee08cd9e2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed/comments", "author": null, "committer": null, "parents": [{"sha": "75aa3f658cb028f17b0d80fcbf322b3da0e615cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75aa3f658cb028f17b0d80fcbf322b3da0e615cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75aa3f658cb028f17b0d80fcbf322b3da0e615cb"}], "stats": {"total": 47, "additions": 35, "deletions": 12}, "files": [{"sha": "5141fc03c8cb62d542b8533e20d6526e7bafdbf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "patch": "@@ -1,3 +1,11 @@\n+2005-01-19  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/19038\n+\t* tree-ssa-loop-ivopts.c (allow_ip_end_pos_p): New function.\n+\t(add_candidate): Add ivs with increment in latch only if\n+\tallow_ip_end_pos_p is true.\n+\t(determine_iv_cost): Use empty_block_p.\n+\n 2005-01-19  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* cfganal.c (compute_dominance_frontiers_1): Replace with new algorithm"}, {"sha": "3288080ac52873f096cbe953d832394dcffd097e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4366cf6d6fd7f35682cdcdbe5fabcbf1ac42b2ed", "patch": "@@ -1779,6 +1779,27 @@ add_candidate_1 (struct ivopts_data *data,\n   return cand;\n }\n \n+/* Returns true if incrementing the induction variable at the end of the LOOP\n+   is allowed.\n+\n+   The purpose is to avoid splitting latch edge with a biv increment, thus\n+   creating a jump, possibly confusing other optimization passes and leaving\n+   less freedom to scheduler.  So we allow IP_END_POS only if IP_NORMAL_POS\n+   is not available (so we do not have a better alternative), or if the latch\n+   edge is already nonempty.  */\n+\n+static bool\n+allow_ip_end_pos_p (struct loop *loop)\n+{\n+  if (!ip_normal_pos (loop))\n+    return true;\n+\n+  if (!empty_block_p (ip_end_pos (loop)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and\n    position to POS.  If USE is not NULL, the candidate is set as related to\n    it.  The candidate computation is scheduled on all available positions.  */\n@@ -1789,7 +1810,8 @@ add_candidate (struct ivopts_data *data,\n {\n   if (ip_normal_pos (data->current_loop))\n     add_candidate_1 (data, base, step, important, IP_NORMAL, use, NULL_TREE);\n-  if (ip_end_pos (data->current_loop))\n+  if (ip_end_pos (data->current_loop)\n+      && allow_ip_end_pos_p (data->current_loop))\n     add_candidate_1 (data, base, step, important, IP_END, use, NULL_TREE);\n }\n \n@@ -3518,8 +3540,7 @@ static void\n determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n {\n   unsigned cost_base, cost_step;\n-  tree base, last;\n-  basic_block bb;\n+  tree base;\n \n   if (!cand->iv)\n     {\n@@ -3543,15 +3564,9 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n   \n   /* Prefer not to insert statements into latch unless there are some\n      already (so that we do not create unnecessary jumps).  */\n-  if (cand->pos == IP_END)\n-    {\n-      bb = ip_end_pos (data->current_loop);\n-      last = last_stmt (bb);\n-\n-      if (!last\n-\t  || TREE_CODE (last) == LABEL_EXPR)\n-\tcand->cost++;\n-    }\n+  if (cand->pos == IP_END\n+      && empty_block_p (ip_end_pos (data->current_loop)))\n+    cand->cost++;\n }\n \n /* Determines costs of computation of the candidates.  */"}]}