{"sha": "189086f9746bfebab192de43e8669154eeaa5c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg5MDg2Zjk3NDZiZmViYWIxOTJkZTQzZTg2NjkxNTRlZWFhNWM1NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T19:27:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T19:27:59Z"}, "message": "(find_dummy_reload): New parameter earlyclobber.\n\n(find_dummy_reload): New parameter earlyclobber.  If set then don't\nuse IN for the reload if it also appears elsewhere in the insn.  All\ncallers changed.\n\nFrom-SVN: r13795", "tree": {"sha": "fb501cc5f2af428035995ea986c08feb316f05a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb501cc5f2af428035995ea986c08feb316f05a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/189086f9746bfebab192de43e8669154eeaa5c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/189086f9746bfebab192de43e8669154eeaa5c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/189086f9746bfebab192de43e8669154eeaa5c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/189086f9746bfebab192de43e8669154eeaa5c55/comments", "author": null, "committer": null, "parents": [{"sha": "03dda8e3c3b2f14dfa18b92189290d8f764910bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dda8e3c3b2f14dfa18b92189290d8f764910bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03dda8e3c3b2f14dfa18b92189290d8f764910bd"}], "stats": {"total": 26, "additions": 19, "deletions": 7}, "files": [{"sha": "d4d0b1e2c9c707f054d5d6ec5eb009dcb1b2d211", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/189086f9746bfebab192de43e8669154eeaa5c55/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/189086f9746bfebab192de43e8669154eeaa5c55/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=189086f9746bfebab192de43e8669154eeaa5c55", "patch": "@@ -317,7 +317,7 @@ static void push_replacement\tPROTO((rtx *, int, enum machine_mode));\n static void combine_reloads\tPROTO((void));\n static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       enum reg_class, int));\n+\t\t\t\t       enum reg_class, int, int));\n static int earlyclobber_operand_p PROTO((rtx));\n static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n static struct decomposition decompose PROTO((rtx));\n@@ -1379,7 +1379,8 @@ push_reload (in, out, inloc, outloc, class,\n     {\n       reload_reg_rtx[i] = find_dummy_reload (in, out, inloc, outloc,\n \t\t\t\t\t     inmode, outmode,\n-\t\t\t\t\t     reload_reg_class[i], i);\n+\t\t\t\t\t     reload_reg_class[i], i,\n+\t\t\t\t\t     reload_earlyclobbers[i] != NULL);\n \n       /* If the outgoing register already contains the same value\n \t as the incoming one, we can dispense with loading it.\n@@ -1689,16 +1690,22 @@ combine_reloads ()\n    to be computed, clear out reload_out[FOR_REAL].\n \n    If FOR_REAL is -1, this should not be done, because this call\n-   is just to see if a register can be found, not to find and install it.  */\n+   is just to see if a register can be found, not to find and install it.\n+\n+   EARLYCLOBBER is non-zero if OUT is an earlyclobber operand.  This\n+   puts an additional constraint on being able to use IN for OUT since\n+   IN must not appear elsewhere in the insn (it is assumed that IN itself\n+   is safe from the earlyclobber).  */\n \n static rtx\n find_dummy_reload (real_in, real_out, inloc, outloc,\n-\t\t   inmode, outmode, class, for_real)\n+\t\t   inmode, outmode, class, for_real, earlyclobber)\n      rtx real_in, real_out;\n      rtx *inloc, *outloc;\n      enum machine_mode inmode, outmode;\n      enum reg_class class;\n      int for_real;\n+     int earlyclobber;\n {\n   rtx in = real_in;\n   rtx out = real_out;\n@@ -1780,7 +1787,8 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n      or if OUT dies in this insn (like the quotient in a divmod insn).\n      We can't use IN unless it is dies in this insn,\n      which means we must know accurately which hard regs are live.\n-     Also, the result can't go in IN if IN is used within OUT.  */\n+     Also, the result can't go in IN if IN is used within OUT,\n+     or if OUT is an earlyclobber and IN appears elsewhere in the insn.  */\n   if (hard_regs_live_known\n       && GET_CODE (in) == REG\n       && REGNO (in) < FIRST_PSEUDO_REGISTER\n@@ -1801,7 +1809,10 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \n       if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, NULL_PTR)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n-\t\t\t\t    PATTERN (this_insn)))\n+\t\t\t\t    PATTERN (this_insn))\n+\t  && (! earlyclobber\n+\t      || ! refers_to_regno_for_reload_p (regno, regno + nwords,\n+\t\t\t\t\t\t PATTERN (this_insn), inloc)))\n \t{\n \t  int i;\n \t  for (i = 0; i < nwords; i++)\n@@ -2872,7 +2883,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t      = find_dummy_reload (recog_operand[i], recog_operand[c],\n \t\t\t\t\t   recog_operand_loc[i], recog_operand_loc[c],\n \t\t\t\t\t   operand_mode[i], operand_mode[c],\n-\t\t\t\t\t   this_alternative[c], -1);\n+\t\t\t\t\t   this_alternative[c], -1,\n+\t\t\t\t\t   this_alternative_earlyclobber[c]);\n \n \t\t    if (value != 0)\n \t\t      losers--;"}]}