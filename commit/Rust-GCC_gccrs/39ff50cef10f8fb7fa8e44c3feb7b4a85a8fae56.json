{"sha": "39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmZjUwY2VmMTBmOGZiN2ZhOGU0NGMzZmViN2I0YTg1YThmYWU1Ng==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-28T15:03:09Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-28T15:03:09Z"}, "message": "tree-predcom.c: (struct chain): Handle store-store chain in which stores for elimination only...\n\n\t* tree-predcom.c: (struct chain): Handle store-store chain in which\n\tstores for elimination only store loop invariant values.\n\t(execute_pred_commoning_chain): Ditto.\n\t(prepare_initializers_chain_store_elim): Ditto.\n\t(prepare_finalizers): Ditto.\n\t(is_inv_store_elimination_chain): New function.\n\t(initialize_root_vars_store_elim_1): New function.\n\nFrom-SVN: r250670", "tree": {"sha": "9e1702e8c04bd73af894e541d55a3cf103dfcf78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1702e8c04bd73af894e541d55a3cf103dfcf78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56/comments", "author": null, "committer": null, "parents": [{"sha": "d9c259efd71ab62d4994b0ad489aa977f3ff736d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c259efd71ab62d4994b0ad489aa977f3ff736d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c259efd71ab62d4994b0ad489aa977f3ff736d"}], "stats": {"total": 141, "additions": 135, "deletions": 6}, "files": [{"sha": "cf3e7e5e602724685d509351183ae45222518cc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "patch": "@@ -1,3 +1,13 @@\n+2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-predcom.c: (struct chain): Handle store-store chain in which\n+\tstores for elimination only store loop invariant values.\n+\t(execute_pred_commoning_chain): Ditto.\n+\t(prepare_initializers_chain_store_elim): Ditto.\n+\t(prepare_finalizers): Ditto.\n+\t(is_inv_store_elimination_chain): New function.\n+\t(initialize_root_vars_store_elim_1): New function.\n+\n 2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-predcom.c: Revise general description of the pass."}, {"sha": "a4011bf46980978db8fa1308134a836553d5bbd4", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 125, "deletions": 6, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "patch": "@@ -331,6 +331,10 @@ typedef struct chain\n \n   /* True if this chain was combined together with some other chain.  */\n   unsigned combined : 1;\n+\n+  /* True if this is store elimination chain and eliminated stores store\n+     loop invariant value into memory.  */\n+  unsigned inv_store_elimination : 1;\n } *chain_p;\n \n \n@@ -1634,6 +1638,98 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n     }\n }\n \n+/* For inter-iteration store elimination CHAIN in LOOP, returns true if\n+   all stores to be eliminated store loop invariant values into memory.\n+   In this case, we can use these invariant values directly after LOOP.  */\n+\n+static bool\n+is_inv_store_elimination_chain (struct loop *loop, chain_p chain)\n+{\n+  if (chain->length == 0 || chain->type != CT_STORE_STORE)\n+    return false;\n+\n+  gcc_assert (!chain->has_max_use_after);\n+\n+  /* If loop iterates for unknown times or fewer times than chain->lenght,\n+     we still need to setup root variable and propagate it with PHI node.  */\n+  tree niters = number_of_latch_executions (loop);\n+  if (TREE_CODE (niters) != INTEGER_CST || wi::leu_p (niters, chain->length))\n+    return false;\n+\n+  /* Check stores in chain for elimination if they only store loop invariant\n+     values.  */\n+  for (unsigned i = 0; i < chain->length; i++)\n+    {\n+      dref a = get_chain_last_ref_at (chain, i);\n+      if (a == NULL)\n+\tcontinue;\n+\n+      gimple *def_stmt, *stmt = a->stmt;\n+      if (!gimple_assign_single_p (stmt))\n+\treturn false;\n+\n+      tree val = gimple_assign_rhs1 (stmt);\n+      if (TREE_CLOBBER_P (val))\n+\treturn false;\n+\n+      if (CONSTANT_CLASS_P (val))\n+\tcontinue;\n+\n+      if (TREE_CODE (val) != SSA_NAME)\n+\treturn false;\n+\n+      def_stmt = SSA_NAME_DEF_STMT (val);\n+      if (gimple_nop_p (def_stmt))\n+\tcontinue;\n+\n+      if (flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Creates root variables for store elimination CHAIN in which stores for\n+   elimination only store loop invariant values.  In this case, we neither\n+   need to load root variables before loop nor propagate it with PHI nodes.  */\n+\n+static void\n+initialize_root_vars_store_elim_1 (chain_p chain)\n+{\n+  tree var;\n+  unsigned i, n = chain->length;\n+\n+  chain->vars.create (n);\n+  chain->vars.safe_grow_cleared (n);\n+\n+  /* Initialize root value for eliminated stores at each distance.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      dref a = get_chain_last_ref_at (chain, i);\n+      if (a == NULL)\n+\tcontinue;\n+\n+      var = gimple_assign_rhs1 (a->stmt);\n+      chain->vars[a->distance] = var;\n+    }\n+\n+  /* We don't propagate values with PHI nodes, so manually propagate value\n+     to bubble positions.  */\n+  var = chain->vars[0];\n+  for (i = 1; i < n; i++)\n+    {\n+      if (chain->vars[i] != NULL_TREE)\n+\t{\n+\t  var = chain->vars[i];\n+\t  continue;\n+\t}\n+      chain->vars[i] = var;\n+    }\n+\n+  /* Revert the vector.  */\n+  for (i = 0; i < n / 2; i++)\n+    std::swap (chain->vars[i], chain->vars[n - i - 1]);\n+}\n+\n /* Creates root variables for store elimination CHAIN in which stores for\n    elimination store loop variant values.  In this case, we may need to\n    load root variables before LOOP and propagate it with PHI nodes.  Uids\n@@ -1957,10 +2053,20 @@ execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n     {\n       if (chain->length > 0)\n \t{\n-\t  /* For inter-iteration store elimination chain, set up the\n-\t     variables by loading from memory before loop, copying from rhs\n-\t     of stores for elimination and propagate it with PHI nodes.  */\n-\t  initialize_root_vars_store_elim_2 (loop, chain, tmp_vars);\n+\t  if (chain->inv_store_elimination)\n+\t    {\n+\t      /* If dead stores in this chain only store loop invariant\n+\t\t values, we can simply record the invariant value and use\n+\t\t it directly after loop.  */\n+\t      initialize_root_vars_store_elim_1 (chain);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If dead stores in this chain store loop variant values,\n+\t\t we need to set up the variables by loading from memory\n+\t\t before loop and propagating it with PHI nodes.  */\n+\t      initialize_root_vars_store_elim_2 (loop, chain, tmp_vars);\n+\t    }\n \n \t  /* For inter-iteration store elimination chain, stores at each\n \t     distance in loop's last (chain->length - 1) iterations can't\n@@ -2661,7 +2767,7 @@ try_combine_chains (vec<chain_p> *chains)\n    otherwise.  */\n \n static bool\n-prepare_initializers_chain_store_elim (struct loop *, chain_p chain)\n+prepare_initializers_chain_store_elim (struct loop *loop, chain_p chain)\n {\n   unsigned i, n = chain->length;\n \n@@ -2674,6 +2780,15 @@ prepare_initializers_chain_store_elim (struct loop *, chain_p chain)\n   if (n == 0 && chain->type == CT_STORE_STORE)\n     return true;\n \n+  /* For store elimination chain, there is nothing to initialize if stores\n+     to be eliminated only store loop invariant values into memory.  */\n+  if (chain->type == CT_STORE_STORE\n+      && is_inv_store_elimination_chain (loop, chain))\n+    {\n+      chain->inv_store_elimination = true;\n+      return true;\n+    }\n+\n   chain->inits.create (n);\n   chain->inits.safe_grow_cleared (n);\n \n@@ -2866,7 +2981,11 @@ prepare_finalizers (struct loop *loop, vec<chain_p> chains)\n       if (prepare_finalizers_chain (loop, chain))\n \t{\n \t  i++;\n-\t  loop_closed_ssa = true;\n+\t  /* We don't corrupt loop closed ssa form for store elimination\n+\t     chain if eliminated stores only store loop invariant values\n+\t     into memory.  */\n+\t  if (!chain->inv_store_elimination)\n+\t    loop_closed_ssa |= (!chain->inv_store_elimination);\n \t}\n       else\n \t{"}]}