{"sha": "154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU0ZTRhMGE4ZDM2Nzk3MmI2MWViM2ZkOTZjYzhlNGJiNzU3MmVhOQ==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-09-17T22:12:54Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-09-17T22:12:54Z"}, "message": "fixed-bit.h: New file.\n\n\t* config/fixed-bit.h: New file.\n\t* config/fixed-bit.c: New file.\n\t* doc/libgcc.texi (Fixed-point fractional library routines): New node.\n\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r128556", "tree": {"sha": "f56a7627a95ddba00f8106522cf85969fd44af03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f56a7627a95ddba00f8106522cf85969fd44af03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/comments", "author": null, "committer": null, "parents": [{"sha": "9cef5f55ffde40dd3a9e125bf5d270416ab2377a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cef5f55ffde40dd3a9e125bf5d270416ab2377a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cef5f55ffde40dd3a9e125bf5d270416ab2377a"}], "stats": {"total": 3944, "additions": 3942, "deletions": 2}, "files": [{"sha": "a59b58e4b8b4061c7c9f17526a0fd319ad107f35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "patch": "@@ -1,3 +1,10 @@\n+2007-09-17  Chao-ying Fu  <fu@mips.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\n+\t* config/fixed-bit.h: New file.\n+\t* config/fixed-bit.c: New file.\n+\t* doc/libgcc.texi (Fixed-point fractional library routines): New node.\n+\n 2007-09-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-format.h (format_kind_info): Add alloc_char field."}, {"sha": "317df5452095b1c033cbe9b2558aa2d0e80202c3", "filename": "gcc/config/fixed-bit.c", "status": "added", "additions": 1221, "deletions": 0, "changes": 1221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fconfig%2Ffixed-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fconfig%2Ffixed-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffixed-bit.c?ref=154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "patch": "@@ -0,0 +1,1221 @@\n+/* This is a software fixed-point library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This implements fixed-point arithmetic.\n+\n+   Contributed by Chao-ying Fu  <fu@mips.com>.  */\n+\n+/* To use this file, we need to define one of the following:\n+   QQ_MODE, UQQ_MODE, HQ_MODE, UHQ_MODE, SQ_MODE, USQ_MODE, DQ_MODE, UDQ_MODE,\n+   TQ_MODE, UTQ_MODE, HA_MODE, UHA_MODE, SA_MODE, USA_MODE, DA_MODE, UDA_MODE,\n+   TA_MODE, UTA_MODE.\n+   Then, all operators for this machine mode will be created.\n+\n+   Or, we need to define FROM_* TO_* for conversions from one mode to another\n+   mode.  The mode could be one of the following:\n+   Fract: QQ, UQQ, HQ, UHQ, SQ, USQ, DQ, UDQ, TQ, UTQ\n+   Accum: HA, UHA, SA, USA, DA, UDA, TA, UTA\n+   Signed integer: QI, HI, SI, DI, TI\n+   Unsigned integer: UQI, UHI, USI, UDI, UTI\n+   Floating-point: SF, DF\n+   Ex: If we define FROM_QQ and TO_SI, the conversion from QQ to SI is\n+   generated.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+#ifndef MIN_UNITS_PER_WORD\n+#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n+#endif\n+\n+#include \"config/fixed-bit.h\"\n+\n+#if defined(FIXED_ADD) && defined(L_add)\n+FIXED_C_TYPE\n+FIXED_ADD (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x + y;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_ADD */\n+\n+#if defined(FIXED_SSADD) && defined(L_ssadd)\n+FIXED_C_TYPE\n+FIXED_SSADD (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x + y;\n+  if ((((x ^ y) >> I_F_BITS) & 1) == 0)\n+    {\n+      if (((z ^ x) >> I_F_BITS) & 1)\n+        {\n+          z = 1;\n+          z = z << I_F_BITS;\n+          if (x >= 0)\n+            z--;\n+        }\n+    }\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_SSADD */\n+\n+#if defined(FIXED_USADD) && defined(L_usadd)\n+FIXED_C_TYPE\n+FIXED_USADD (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x + y;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  if (z < x || z < y) /* max */\n+    {\n+       z = -1;\n+#if HAVE_PADDING_BITS\n+       z = z << PADDING_BITS;\n+       z = z >> PADDING_BITS;\n+#endif\n+    }\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_USADD */\n+\n+#if defined(FIXED_SUB) && defined(L_sub)\n+FIXED_C_TYPE\n+FIXED_SUB (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x - y;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_SUB */\n+\n+#if defined(FIXED_SSSUB) && defined(L_sssub)\n+FIXED_C_TYPE\n+FIXED_SSSUB (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x - y;\n+  if (((x ^ y) >> I_F_BITS) & 1)\n+    {\n+      if (((z ^ x) >> I_F_BITS) & 1)\n+        {\n+          z = 1;\n+          z = z << I_F_BITS;\n+          if (x >= 0)\n+            z--;\n+        }\n+    }\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_SSSUB */\n+\n+#if defined(FIXED_USSUB) && defined(L_ussub)\n+FIXED_C_TYPE\n+FIXED_USSUB (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  z = x - y;\n+  if (x < y)\n+    z = 0;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_USSUB */\n+\n+#if defined(FIXED_SATURATE1) && defined(L_saturate1)\n+void\n+FIXED_SATURATE1 (DINT_C_TYPE *a)\n+{\n+  DINT_C_TYPE max, min;\n+  max = (DINT_C_TYPE)1 << I_F_BITS;\n+  max = max - 1;\n+#if MODE_UNSIGNED == 0\n+  min = (DINT_C_TYPE)1 << (2 * FIXED_WIDTH - 1);\n+  min = min >> (2 * FIXED_WIDTH - 1 - I_F_BITS);\n+#else\n+  min = 0;\n+#endif\n+  if (*a > max)\n+    *a = max;\n+  else if (*a < min)\n+    *a = min;\n+}\n+#endif /* FIXED_SATURATE1 */\n+\n+#if defined(FIXED_SATURATE2) && defined(L_saturate2)\n+void\n+FIXED_SATURATE2 (INT_C_TYPE *high, INT_C_TYPE *low)\n+{\n+  INT_C_TYPE r_max, s_max, r_min, s_min;\n+  r_max = 0;\n+#if (MODE_UNSIGNED == 0) || HAVE_PADDING_BITS\n+  s_max = (INT_C_TYPE)1 << I_F_BITS;\n+  s_max = s_max - 1;\n+#else\n+  s_max = -1;\n+#endif\n+#if MODE_UNSIGNED == 0\n+  r_min = -1;\n+  s_min = (INT_C_TYPE)1 << (FIXED_WIDTH - 1);\n+  s_min = s_min >> (FIXED_WIDTH - 1 - I_F_BITS);\n+#else\n+  r_min = 0;\n+  s_min = 0;\n+#endif\n+\n+  if (*high > r_max\n+      || (*high == r_max && (UINT_C_TYPE)(*low) > (UINT_C_TYPE)s_max))\n+    {\n+      *high = r_max;\n+      *low = s_max;\n+    }\n+  else if (*high < r_min ||\n+\t   (*high == r_min && (UINT_C_TYPE)(*low) < (UINT_C_TYPE)s_min))\n+    {\n+      *high = r_min;\n+      *low = s_min;\n+    }\n+}\n+#endif /* FIXED_SATURATE2 */\n+\n+#if defined(FIXED_MULHELPER) && defined(L_mulhelper)\n+FIXED_C_TYPE\n+FIXED_MULHELPER (FIXED_C_TYPE a, FIXED_C_TYPE b, word_type satp)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y;\n+\n+#if defined (DINT_C_TYPE)\n+  INT_C_TYPE z;\n+  DINT_C_TYPE dx, dy, dz;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  dx = (DINT_C_TYPE) x;\n+  dy = (DINT_C_TYPE) y;\n+  dz = dx * dy;\n+  /* Round the result by adding (1 << (FBITS -1)).  */\n+  dz += ((DINT_C_TYPE) 1 << (FBITS - 1));\n+  dz = dz >> FBITS;\n+  if (satp)\n+    FIXED_SATURATE1 (&dz);\n+\n+  z = (INT_C_TYPE) dz;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+\n+#else /* No DINT_C_TYPE */\n+  /* The result of multiplication expands to two INT_C_TYPE.  */\n+  INTunion aa, bb;\n+  INTunion a_high, a_low, b_high, b_low;\n+  INTunion high_high, high_low, low_high, low_low;\n+  INTunion r, s, temp1, temp2;\n+  INT_C_TYPE carry = 0;\n+  INT_C_TYPE z;\n+\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+\n+  /* Decompose a and b.  */\n+  aa.ll = x;\n+  bb.ll = y;\n+\n+  a_high.s.low = aa.s.high;\n+  a_high.s.high = 0;\n+  a_low.s.low = aa.s.low;\n+  a_low.s.high = 0;\n+  b_high.s.low = bb.s.high;\n+  b_high.s.high = 0;\n+  b_low.s.low = bb.s.low;\n+  b_low.s.high = 0;\n+\n+  /* Perform four multiplications.  */\n+  low_low.ll = a_low.ll * b_low.ll;\n+  low_high.ll = a_low.ll * b_high.ll;\n+  high_low.ll = a_high.ll * b_low.ll;\n+  high_high.ll = a_high.ll * b_high.ll;\n+\n+  /* Accumulate four results to {r, s}.  */\n+  temp1.s.high = high_low.s.low;\n+  temp1.s.low = 0;\n+  s.ll = low_low.ll + temp1.ll;\n+  if ((UINT_C_TYPE) s.ll < (UINT_C_TYPE) low_low.ll\n+      || (UINT_C_TYPE) s.ll < (UINT_C_TYPE) temp1.ll)\n+    carry ++; /* Carry.  */\n+  temp1.ll = s.ll;\n+  temp2.s.high = low_high.s.low;\n+  temp2.s.low = 0;\n+  s.ll = temp1.ll + temp2.ll;\n+  if ((UINT_C_TYPE) s.ll < (UINT_C_TYPE) temp1.ll\n+      || (UINT_C_TYPE) s.ll < (UINT_C_TYPE) temp2.ll)\n+    carry ++; /* Carry.  */\n+\n+  temp1.s.low = high_low.s.high;\n+  temp1.s.high = 0;\n+  r.ll = high_high.ll + temp1.ll;\n+  temp1.s.low = low_high.s.high;\n+  temp1.s.high = 0;\n+  r.ll = r.ll + temp1.ll + carry;\n+\n+#if MODE_UNSIGNED == 0\n+  /* For signed types, we need to add neg(y) to r, if x < 0.  */\n+  if (x < 0)\n+    r.ll = r.ll - y;\n+  /* We need to add neg(x) to r, if y < 0.  */\n+  if (y < 0)\n+    r.ll = r.ll - x;\n+#endif\n+\n+  /* Round the result by adding (1 << (FBITS -1)).  */\n+  temp1.ll = s.ll;\n+  s.ll += ((INT_C_TYPE) 1 << (FBITS -1));\n+  if ((UINT_C_TYPE) s.ll < (UINT_C_TYPE) temp1.ll\n+      || (UINT_C_TYPE) s.ll < (UINT_C_TYPE) ((INT_C_TYPE) 1 << (FBITS -1)))\n+    r.ll += 1;\n+\n+  /* Shift right the result by FBITS.  */\n+#if FBITS == FIXED_WIDTH\n+  /* This happens only for unsigned types without any padding bits.\n+     So, it is safe to set r.ll to 0 as it is logically shifted right.  */\n+  s.ll = r.ll;\n+  r.ll = 0;\n+#else\n+  s.ll = ((UINT_C_TYPE)s.ll) >> FBITS;\n+  temp1.ll = r.ll << (FIXED_WIDTH - FBITS);\n+  s.ll = s.ll | temp1.ll;\n+  r.ll = r.ll >> FBITS;\n+#endif\n+\n+  if (satp)\n+    FIXED_SATURATE2 (&r.ll, &s.ll);\n+\n+  z = (INT_C_TYPE) s.ll;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+#endif\n+}\n+#endif /* FIXED_MULHELPER */\n+\n+#if defined(FIXED_MUL) && defined(L_mul)\n+FIXED_C_TYPE\n+FIXED_MUL (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_MULHELPER (a, b, 0);\n+}\n+#endif /* FIXED_MUL */\n+\n+#if defined(FIXED_SSMUL) && defined(L_ssmul)\n+FIXED_C_TYPE\n+FIXED_SSMUL (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_MULHELPER (a, b, 1);\n+}\n+#endif /* FIXED_SSMUL */\n+\n+#if defined(FIXED_USMUL) && defined(L_usmul)\n+FIXED_C_TYPE\n+FIXED_USMUL (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_MULHELPER (a, b, 1);\n+}\n+#endif /* FIXED_USMUL */\n+\n+#if defined(FIXED_DIVHELPER) && defined(L_divhelper)\n+FIXED_C_TYPE\n+FIXED_DIVHELPER (FIXED_C_TYPE a, FIXED_C_TYPE b, word_type satp)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y;\n+  INT_C_TYPE z;\n+\n+#if defined (DINT_C_TYPE)\n+  DINT_C_TYPE dx, dy, dz;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  dx = (DINT_C_TYPE) x;\n+  dy = (DINT_C_TYPE) y;\n+  dx = dx << FBITS;\n+  dz = dx / dy;\n+  if (satp)\n+    FIXED_SATURATE1 (&dz);\n+  z = (INT_C_TYPE) dz;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+\n+#else /* No DINT_C_TYPE */\n+  INT_C_TYPE pos_a, pos_b, r, s;\n+  INT_C_TYPE quo_r, quo_s, mod, temp;\n+  word_type i;\n+#if MODE_UNSIGNED == 0\n+  word_type num_of_neg = 0;\n+#endif\n+\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+  pos_a = x;\n+  pos_b = y;\n+\n+#if MODE_UNSIGNED == 0\n+  /* If a < 0, negate a.  */\n+  if (pos_a < 0)\n+    {\n+      pos_a = -pos_a;\n+      num_of_neg ++;\n+    }\n+  /* If b < 0, negate b.  */\n+  if (pos_b < 0)\n+    {\n+      pos_b = -pos_b;\n+      num_of_neg ++;\n+    }\n+#endif\n+\n+  /* Left shift pos_a to {r, s} by FBITS.  */\n+#if FBITS == FIXED_WIDTH\n+  /* This happens only for unsigned types without any padding bits.  */\n+  r = pos_a;\n+  s = 0;\n+#else\n+  s = pos_a << FBITS;\n+  r = pos_a >> (FIXED_WIDTH - FBITS);\n+#endif\n+\n+  /* Unsigned divide r by pos_b to quo_r.  The remanider is in mod.  */\n+  quo_r = (UINT_C_TYPE)r / (UINT_C_TYPE)pos_b;\n+  mod = (UINT_C_TYPE)r % (UINT_C_TYPE)pos_b;\n+  quo_s = 0;\n+\n+  for (i = 0; i < FIXED_WIDTH; i++)\n+    {\n+      /* Record the leftmost bit of mod.  */\n+      word_type leftmost_mode = (mod >> (FIXED_WIDTH - 1)) & 1;\n+      /* Shift left mod by 1 bit.  */\n+      mod = mod << 1;\n+      /* Test the leftmost bit of s to add to mod.  */\n+      if ((s >> (FIXED_WIDTH - 1)) & 1)\n+\tmod ++;\n+      /* Shift left quo_s by 1 bit.  */\n+      quo_s = quo_s << 1;\n+      /* Try to calculate (mod - pos_b).  */\n+      temp = mod - pos_b;\n+      if (leftmost_mode || (UINT_C_TYPE)mod >= (UINT_C_TYPE)pos_b)\n+\t{\n+\t  quo_s ++;\n+\t  mod = temp;\n+\t}\n+      /* Shift left s by 1 bit.  */\n+      s = s << 1;\n+    }\n+\n+#if MODE_UNSIGNED == 0\n+    if (num_of_neg == 1)\n+      {\n+\tquo_s = -quo_s;\n+\tif (quo_s == 0)\n+\t  quo_r = -quo_r;\n+\telse\n+\t  quo_r = ~quo_r;\n+      }\n+#endif\n+  if (satp)\n+    FIXED_SATURATE2 (&quo_r, &quo_s);\n+  z = quo_s;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+#endif\n+}\n+#endif /* FIXED_DIVHELPER */\n+\n+#if defined(FIXED_DIV) && defined(L_div)\n+FIXED_C_TYPE\n+FIXED_DIV (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_DIVHELPER (a, b, 0);\n+}\n+#endif /* FIXED_DIV */\n+\n+\n+#if defined(FIXED_UDIV) && defined(L_udiv)\n+FIXED_C_TYPE\n+FIXED_UDIV (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_DIVHELPER (a, b, 0);\n+}\n+#endif /* FIXED_UDIV */\n+\n+#if defined(FIXED_SSDIV) && defined(L_ssdiv)\n+FIXED_C_TYPE\n+FIXED_SSDIV (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_DIVHELPER (a, b, 1);\n+}\n+#endif /* FIXED_SSDIV */\n+\n+#if defined(FIXED_USDIV) && defined(L_usdiv)\n+FIXED_C_TYPE\n+FIXED_USDIV (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  return FIXED_DIVHELPER (a, b, 1);\n+}\n+#endif /* FIXED_USDIV */\n+\n+#if defined(FIXED_NEG) && defined(L_neg)\n+FIXED_C_TYPE\n+FIXED_NEG (FIXED_C_TYPE a)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  z = -x;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_NEG */\n+\n+#if defined(FIXED_SSNEG) && defined(L_ssneg)\n+FIXED_C_TYPE\n+FIXED_SSNEG (FIXED_C_TYPE a)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, y, z;\n+  memcpy (&y, &a, FIXED_SIZE);\n+  x = 0;\n+  z = x - y;\n+  if (((x ^ y) >> I_F_BITS) & 1)\n+    {\n+      if (((z ^ x) >> I_F_BITS) & 1)\n+        {\n+          z = 1;\n+          z = z << I_F_BITS;\n+          if (x >= 0)\n+            z--;\n+        }\n+    }\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_SSNEG */\n+\n+#if defined(FIXED_USNEG) && defined(L_usneg)\n+FIXED_C_TYPE\n+FIXED_USNEG (FIXED_C_TYPE a __attribute__ ((__unused__)))\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE z;\n+  z = 0;\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_USNEG */\n+\n+#if defined(FIXED_ASHLHELPER) && defined(L_ashlhelper)\n+FIXED_C_TYPE\n+FIXED_ASHLHELPER (FIXED_C_TYPE a, word_type b, word_type satp)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, z;\n+\n+#if defined (DINT_C_TYPE)\n+  DINT_C_TYPE dx, dz;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  dx = (DINT_C_TYPE) x;\n+  if (b >= FIXED_WIDTH)\n+    dz = dx << FIXED_WIDTH;\n+  else\n+    dz = dx << b;\n+  if (satp)\n+    FIXED_SATURATE1 (&dz);\n+  z = (INT_C_TYPE) dz;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+\n+#else /* No DINT_C_TYPE */\n+  INT_C_TYPE r, s;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  /* We need to shift left x by b bits to {r, s}.  */\n+  if (b >= FIXED_WIDTH)\n+    {\n+      r = b;\n+      s = 0;\n+    }\n+  else\n+    {\n+      s = x << b;\n+      r = x >> (FIXED_WIDTH - b);\n+    }\n+  if (satp)\n+    FIXED_SATURATE2 (&r, &s);\n+  z = s;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+#endif\n+}\n+#endif /* FIXED_ASHLHELPER */\n+\n+#if defined(FIXED_ASHL) && defined(L_ashl)\n+FIXED_C_TYPE\n+FIXED_ASHL (FIXED_C_TYPE a, word_type b)\n+{\n+  return FIXED_ASHLHELPER (a, b, 0);\n+}\n+#endif /* FIXED_ASHL */\n+\n+#if defined(FIXED_ASHR) && defined(L_ashr)\n+FIXED_C_TYPE\n+FIXED_ASHR (FIXED_C_TYPE a, word_type b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  z = x >> b;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_ASHR */\n+\n+#if defined(FIXED_LSHR) && defined(L_lshr)\n+FIXED_C_TYPE\n+FIXED_LSHR (FIXED_C_TYPE a, word_type b)\n+{\n+  FIXED_C_TYPE c;\n+  INT_C_TYPE x, z;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  z = x >> b;\n+#if HAVE_PADDING_BITS\n+  z = z << PADDING_BITS;\n+  z = z >> PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FIXED_LSHR */\n+\n+#if defined(FIXED_SSASHL) && defined(L_ssashl)\n+FIXED_C_TYPE\n+FIXED_SSASHL (FIXED_C_TYPE a, word_type b)\n+{\n+  return FIXED_ASHLHELPER (a, b, 1);\n+}\n+#endif /* FIXED_SSASHL */\n+\n+#if defined(FIXED_USASHL) && defined(L_usashl)\n+FIXED_C_TYPE\n+FIXED_USASHL (FIXED_C_TYPE a, word_type b)\n+{\n+  return FIXED_ASHLHELPER (a, b, 1);\n+}\n+#endif /* FIXED_USASHL */\n+\n+#if defined(FIXED_CMP) && defined(L_cmp)\n+word_type\n+FIXED_CMP (FIXED_C_TYPE a, FIXED_C_TYPE b)\n+{\n+  INT_C_TYPE x, y;\n+  memcpy (&x, &a, FIXED_SIZE);\n+  memcpy (&y, &b, FIXED_SIZE);\n+\n+  if (x < y)\n+    return 0;\n+  else if (x > y)\n+    return 2;\n+\n+  return 1;\n+}\n+#endif /* FIXED_CMP */\n+\n+/* Fixed -> Fixed.  */\n+#if defined(FRACT) && defined(L_fract) && FROM_TYPE == 4 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+FRACT (FROM_FIXED_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  FROM_INT_C_TYPE x;\n+  TO_INT_C_TYPE z;\n+  int shift_amount;\n+  memcpy (&x, &a, FROM_FIXED_SIZE);\n+#if TO_FBITS > FROM_FBITS  /* Need left shift.  */\n+  shift_amount = TO_FBITS - FROM_FBITS;\n+  z = (TO_INT_C_TYPE) x;\n+  z = z << shift_amount;\n+#else /* TO_FBITS <= FROM_FBITS.  Need right Shift.  */\n+  shift_amount = FROM_FBITS - TO_FBITS;\n+  x = x >> shift_amount;\n+  z = (TO_INT_C_TYPE) x;\n+#endif /* TO_FBITS > FROM_FBITS  */\n+\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* FRACT && FROM_TYPE == 4 && TO_TYPE == 4  */\n+\n+/* Fixed -> Fixed with saturation.  */\n+#if defined(SATFRACT) && defined(L_satfract) && FROM_TYPE == 4 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+SATFRACT (FROM_FIXED_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  TO_INT_C_TYPE z;\n+  FROM_INT_C_TYPE x;\n+#if FROM_MODE_UNSIGNED == 0\n+  BIG_SINT_C_TYPE high, low;\n+  BIG_SINT_C_TYPE max_high, max_low;\n+  BIG_SINT_C_TYPE min_high, min_low;\n+#else\n+  BIG_UINT_C_TYPE high, low;\n+  BIG_UINT_C_TYPE max_high, max_low;\n+  BIG_UINT_C_TYPE min_high, min_low;\n+#endif\n+#if TO_FBITS > FROM_FBITS\n+  BIG_UINT_C_TYPE utemp;\n+#endif\n+#if TO_MODE_UNSIGNED == 0\n+  BIG_SINT_C_TYPE stemp;\n+#endif\n+#if TO_FBITS != FROM_FBITS\n+  int shift_amount;\n+#endif\n+  memcpy (&x, &a, FROM_FIXED_SIZE);\n+\n+  /* Step 1. We need to store x to {high, low}.  */\n+#if FROM_MODE_UNSIGNED == 0\n+  low = (BIG_SINT_C_TYPE) x;\n+  if (x < 0)\n+    high = -1;\n+  else\n+    high = 0;\n+#else\n+  low = (BIG_UINT_C_TYPE) x;\n+  high = 0;\n+#endif\n+\n+  /* Step 2. We need to shift {high, low}.  */\n+#if TO_FBITS > FROM_FBITS /* Left shift.  */\n+  shift_amount = TO_FBITS - FROM_FBITS;\n+  utemp = (BIG_UINT_C_TYPE) low;\n+  utemp = utemp >> (BIG_WIDTH - shift_amount);\n+  high = ((BIG_UINT_C_TYPE)(high << shift_amount)) | utemp;\n+  low = low << shift_amount;\n+#elif TO_FBITS < FROM_FBITS /* Right shift.  */\n+  shift_amount = FROM_FBITS - TO_FBITS;\n+  low = low >> shift_amount;\n+#endif\n+\n+  /* Step 3. Compare {high, low} with max and  min of TO_FIXED_C_TYPE.  */\n+  max_high = 0;\n+#if BIG_WIDTH > TO_FIXED_WIDTH || TO_MODE_UNSIGNED == 0 || TO_HAVE_PADDING_BITS\n+  max_low = (BIG_UINT_C_TYPE)1 << TO_I_F_BITS;\n+  max_low = max_low - 1;\n+#else\n+  max_low = -1;\n+#endif\n+\n+#if TO_MODE_UNSIGNED == 0\n+  min_high = -1;\n+  stemp = (BIG_SINT_C_TYPE)1 << (BIG_WIDTH - 1);\n+  stemp = stemp >> (BIG_WIDTH - 1 - TO_I_F_BITS);\n+  min_low = stemp;\n+#else\n+  min_high = 0;\n+  min_low = 0;\n+#endif\n+\n+#if FROM_MODE_UNSIGNED == 0 && TO_MODE_UNSIGNED == 0\n+  /* Signed -> Signed.  */\n+  if ((BIG_SINT_C_TYPE) high > (BIG_SINT_C_TYPE) max_high\n+      || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) max_high\n+\t  && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+  else if ((BIG_SINT_C_TYPE) high < (BIG_SINT_C_TYPE) min_high\n+\t   || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) min_high\n+\t       && (BIG_UINT_C_TYPE) low < (BIG_UINT_C_TYPE) min_low))\n+    low = min_low; /* Minimum.  */\n+#elif FROM_MODE_UNSIGNED == 1 && TO_MODE_UNSIGNED == 1\n+  /* Unigned -> Unsigned.  */\n+  if ((BIG_UINT_C_TYPE) high > (BIG_UINT_C_TYPE) max_high\n+      || ((BIG_UINT_C_TYPE) high == (BIG_UINT_C_TYPE) max_high\n+\t  && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#elif FROM_MODE_UNSIGNED == 0 && TO_MODE_UNSIGNED == 1\n+  /* Signed -> Unsigned.  */\n+  if (x < 0)\n+    low = 0; /* Minimum.  */\n+  else if ((BIG_UINT_C_TYPE) high > (BIG_UINT_C_TYPE) max_high\n+\t   || ((BIG_UINT_C_TYPE) high == (BIG_UINT_C_TYPE) max_high\n+\t       && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#elif FROM_MODE_UNSIGNED == 1 && TO_MODE_UNSIGNED == 0\n+  /* Unsigned -> Signed.  */\n+  if ((BIG_SINT_C_TYPE) high < 0)\n+    low = max_low; /* Maximum.  */\n+  else if ((BIG_SINT_C_TYPE) high > (BIG_SINT_C_TYPE) max_high\n+\t   || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) max_high\n+\t       && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#endif\n+\n+  /* Step 4. Store the result.  */\n+  z = (TO_INT_C_TYPE) low;\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(SATFRACT) && FROM_TYPE == 4 && TO_TYPE == 4  */\n+\n+/* Fixed -> Int.  */\n+#if defined(FRACT) && defined(L_fract) && FROM_TYPE == 4 && TO_TYPE == 1\n+TO_INT_C_TYPE\n+FRACT (FROM_FIXED_C_TYPE a)\n+{\n+  FROM_INT_C_TYPE x;\n+  TO_INT_C_TYPE z;\n+  FROM_INT_C_TYPE i = 0;\n+  memcpy (&x, &a, FROM_FIXED_SIZE);\n+\n+#if FROM_MODE_UNSIGNED == 0\n+  if (x < 0)\n+    {\n+#if FROM_FIXED_WIDTH == FROM_FBITS\n+      if (x != 0)\n+\ti = 1;\n+#else\n+      if (((FROM_INT_C_TYPE)(x << (FROM_FIXED_WIDTH - FROM_FBITS))) != 0)\n+\ti = 1;\n+#endif\n+    }\n+#endif\n+\n+#if FROM_FIXED_WIDTH == FROM_FBITS\n+  x = 0;\n+#else\n+  x = x >> FROM_FBITS;\n+#endif\n+  x = x + i;\n+  z = (TO_INT_C_TYPE) x;\n+  return z;\n+}\n+#endif /* defined(FRACT) && FROM_TYPE == 4 && TO_TYPE == 1  */\n+\n+/* Fixed -> Unsigned int.  */\n+#if defined(FRACTUNS) && defined(L_fractuns) && FROM_TYPE == 4 && TO_TYPE == 2\n+TO_INT_C_TYPE\n+FRACTUNS (FROM_FIXED_C_TYPE a)\n+{\n+  FROM_INT_C_TYPE x;\n+  TO_INT_C_TYPE z;\n+  FROM_INT_C_TYPE i = 0;\n+  memcpy (&x, &a, FROM_FIXED_SIZE);\n+\n+#if FROM_MODE_UNSIGNED == 0\n+  if (x < 0)\n+    {\n+#if FROM_FIXED_WIDTH == FROM_FBITS\n+      if (x != 0)\n+\ti = 1;\n+#else\n+      if (((FROM_INT_C_TYPE)(x << (FROM_FIXED_WIDTH - FROM_FBITS))) != 0)\n+\ti = 1;\n+#endif\n+    }\n+#endif\n+\n+#if FROM_FIXED_WIDTH == FROM_FBITS\n+  x = 0;\n+#else\n+  x = x >> FROM_FBITS;\n+#endif\n+  x = x + i;\n+  z = (TO_INT_C_TYPE) x;\n+  return z;\n+}\n+#endif /* defined(FRACTUNS) && FROM_TYPE == 4 && TO_TYPE == 2  */\n+\n+/* Int -> Fixed.  */\n+#if defined(FRACT) && defined(L_fract) && FROM_TYPE == 1 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+FRACT (FROM_INT_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  TO_INT_C_TYPE z;\n+  z = (TO_INT_C_TYPE) a;\n+#if TO_FIXED_WIDTH == TO_FBITS\n+  z = 0;\n+#else\n+  z = z << TO_FBITS;\n+#endif\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(FRACT) && FROM_TYPE == 1 && TO_TYPE == 4  */\n+\n+/* Signed int -> Fixed with saturation.  */\n+#if defined(SATFRACT) && defined(L_satfract) &&FROM_TYPE == 1 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+SATFRACT (FROM_INT_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  TO_INT_C_TYPE z;\n+  FROM_INT_C_TYPE x = a;\n+  BIG_SINT_C_TYPE high, low;\n+  BIG_SINT_C_TYPE max_high, max_low;\n+  BIG_SINT_C_TYPE min_high, min_low;\n+#if TO_MODE_UNSIGNED == 0\n+  BIG_SINT_C_TYPE stemp;\n+#endif\n+#if BIG_WIDTH != TO_FBITS\n+  BIG_UINT_C_TYPE utemp;\n+  int shift_amount;\n+#endif\n+\n+  /* Step 1. We need to store x to {high, low}.  */\n+  low = (BIG_SINT_C_TYPE) x;\n+  if (x < 0)\n+    high = -1;\n+  else\n+    high = 0;\n+\n+  /* Step 2. We need to left shift {high, low}.  */\n+#if BIG_WIDTH == TO_FBITS\n+  high = low;\n+  low = 0;\n+#else\n+  shift_amount = TO_FBITS;\n+  utemp = (BIG_UINT_C_TYPE) low;\n+  utemp = utemp >> (BIG_WIDTH - shift_amount);\n+  high = ((BIG_UINT_C_TYPE)(high << shift_amount)) | utemp;\n+  low = low << shift_amount;\n+#endif\n+\n+  /* Step 3. Compare {high, low} with max and  min of TO_FIXED_C_TYPE.  */\n+  max_high = 0;\n+#if BIG_WIDTH > TO_FIXED_WIDTH || TO_MODE_UNSIGNED == 0 || TO_HAVE_PADDING_BITS\n+  max_low = (BIG_UINT_C_TYPE)1 << TO_I_F_BITS;\n+  max_low = max_low - 1;\n+#else\n+  max_low = -1;\n+#endif\n+\n+#if TO_MODE_UNSIGNED == 0\n+  min_high = -1;\n+  stemp = (BIG_SINT_C_TYPE)1 << (BIG_WIDTH - 1);\n+  stemp = stemp >> (BIG_WIDTH - 1 - TO_I_F_BITS);\n+  min_low = stemp;\n+#else\n+  min_high = 0;\n+  min_low = 0;\n+#endif\n+\n+#if TO_MODE_UNSIGNED == 0\n+  /* Signed -> Signed.  */\n+  if ((BIG_SINT_C_TYPE) high > (BIG_SINT_C_TYPE) max_high\n+      || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) max_high\n+          && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+  else if ((BIG_SINT_C_TYPE) high < (BIG_SINT_C_TYPE) min_high\n+           || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) min_high\n+               && (BIG_UINT_C_TYPE) low < (BIG_UINT_C_TYPE) min_low))\n+    low = min_low; /* Minimum.  */\n+#else\n+  /* Signed -> Unsigned.  */\n+  if (x < 0)\n+    low = 0; /* Minimum.  */\n+  else if ((BIG_UINT_C_TYPE) high > (BIG_UINT_C_TYPE) max_high\n+           || ((BIG_UINT_C_TYPE) high == (BIG_UINT_C_TYPE) max_high\n+               && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#endif\n+\n+  /* Step 4. Store the result.  */\n+  z = (TO_INT_C_TYPE) low;\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(SATFRACT) && FROM_TYPE == 1 && TO_TYPE == 4  */\n+\n+/* Unsigned int -> Fixed.  */\n+#if defined(FRACTUNS) && defined(L_fractuns) &&FROM_TYPE == 2 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+FRACTUNS (FROM_INT_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  TO_INT_C_TYPE z;\n+  z = (TO_INT_C_TYPE) a;\n+#if TO_FIXED_WIDTH == TO_FBITS\n+  z = 0;\n+#else\n+  z = z << TO_FBITS;\n+#endif\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(FRACTUNS) && FROM_TYPE == 2 && TO_TYPE == 4  */\n+\n+/* Unsigned int -> Fixed with saturation.  */\n+#if defined(SATFRACTUNS) && defined(L_satfractuns) && FROM_TYPE == 2 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+SATFRACTUNS (FROM_INT_C_TYPE a)\n+{\n+  TO_FIXED_C_TYPE c;\n+  TO_INT_C_TYPE z;\n+  FROM_INT_C_TYPE x = a;\n+  BIG_UINT_C_TYPE high, low;\n+  BIG_UINT_C_TYPE max_high, max_low;\n+#if BIG_WIDTH != TO_FBITS\n+  BIG_UINT_C_TYPE utemp;\n+  int shift_amount;\n+#endif\n+\n+  /* Step 1. We need to store x to {high, low}.  */\n+  low = (BIG_UINT_C_TYPE) x;\n+  high = 0;\n+\n+  /* Step 2. We need to left shift {high, low}.  */\n+#if BIG_WIDTH == TO_FBITS\n+  high = low;\n+  low = 0;\n+#else\n+  shift_amount = TO_FBITS;\n+  utemp = (BIG_UINT_C_TYPE) low;\n+  utemp = utemp >> (BIG_WIDTH - shift_amount);\n+  high = ((BIG_UINT_C_TYPE)(high << shift_amount)) | utemp;\n+  low = low << shift_amount;\n+#endif\n+\n+  /* Step 3. Compare {high, low} with max and  min of TO_FIXED_C_TYPE.  */\n+  max_high = 0;\n+#if BIG_WIDTH > TO_FIXED_WIDTH || TO_MODE_UNSIGNED == 0 || TO_HAVE_PADDING_BITS\n+  max_low = (BIG_UINT_C_TYPE)1 << TO_I_F_BITS;\n+  max_low = max_low - 1;\n+#else\n+  max_low = -1;\n+#endif\n+\n+#if TO_MODE_UNSIGNED == 1\n+  /* Unigned -> Unsigned.  */\n+  if ((BIG_UINT_C_TYPE) high > (BIG_UINT_C_TYPE) max_high\n+      || ((BIG_UINT_C_TYPE) high == (BIG_UINT_C_TYPE) max_high\n+          && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#else\n+  /* Unsigned -> Signed.  */\n+  if ((BIG_SINT_C_TYPE) high < 0)\n+    low = max_low; /* Maximum.  */\n+  else if ((BIG_SINT_C_TYPE) high > (BIG_SINT_C_TYPE) max_high\n+           || ((BIG_SINT_C_TYPE) high == (BIG_SINT_C_TYPE) max_high\n+               && (BIG_UINT_C_TYPE) low > (BIG_UINT_C_TYPE) max_low))\n+    low = max_low; /* Maximum.  */\n+#endif\n+\n+  /* Step 4. Store the result.  */\n+  z = (TO_INT_C_TYPE) low;\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(SATFRACTUNS) && FROM_TYPE == 2 && TO_TYPE == 4  */\n+\n+/* Fixed -> Float.  */\n+#if defined(FRACT) && defined(L_fract) && FROM_TYPE == 4 && TO_TYPE == 3\n+TO_FLOAT_C_TYPE\n+FRACT (FROM_FIXED_C_TYPE a)\n+{\n+  FROM_INT_C_TYPE x;\n+  TO_FLOAT_C_TYPE z;\n+  memcpy (&x, &a, FROM_FIXED_SIZE);\n+  z = (TO_FLOAT_C_TYPE) x;\n+  z = z / BASE;\n+  return z;\n+}\n+#endif /* defined(FRACT) && FROM_TYPE == 4 && TO_TYPE == 3  */\n+\n+/* Float -> Fixed.  */\n+#if defined(FRACT) && defined(L_fract) && FROM_TYPE == 3 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+FRACT (FROM_FLOAT_C_TYPE a)\n+{\n+  FROM_FLOAT_C_TYPE temp;\n+  TO_INT_C_TYPE z;\n+  TO_FIXED_C_TYPE c;\n+\n+  temp = a * BASE;\n+  z = (TO_INT_C_TYPE) temp;\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(FRACT) && FROM_TYPE == 3 && TO_TYPE == 4  */\n+\n+/* Float -> Fixed with saturation.  */\n+#if defined(SATFRACT) && defined(L_satfract) && FROM_TYPE == 3 && TO_TYPE == 4\n+TO_FIXED_C_TYPE\n+SATFRACT (FROM_FLOAT_C_TYPE a)\n+{\n+  FROM_FLOAT_C_TYPE temp;\n+  TO_INT_C_TYPE z;\n+  TO_FIXED_C_TYPE c;\n+\n+  if (a >= FIXED_MAX)\n+    {\n+#if TO_MODE_UNSIGNED == 0 || TO_HAVE_PADDING_BITS\n+      z = (TO_INT_C_TYPE)1 << TO_I_F_BITS;\n+      z = z - 1;\n+#else\n+      z = -1;\n+#endif\n+    }\n+  else if (a <= FIXED_MIN)\n+    {\n+#if TO_MODE_UNSIGNED == 0\n+      z = (TO_INT_C_TYPE)1 << TO_I_F_BITS;\n+#else\n+      z = 0;\n+#endif\n+    }\n+  else\n+    {\n+      temp = a * BASE;\n+      z = (TO_INT_C_TYPE) temp;\n+    }\n+\n+#if TO_HAVE_PADDING_BITS\n+  z = z << TO_PADDING_BITS;\n+  z = z >> TO_PADDING_BITS;\n+#endif\n+  memcpy (&c, &z, TO_FIXED_SIZE);\n+  return c;\n+}\n+#endif /* defined(SATFRACT) && FROM_TYPE == 3 && TO_TYPE == 4  */\n+"}, {"sha": "8b3cb6105471898d3dcbc5b5e4fcc1ae638bdd2b", "filename": "gcc/config/fixed-bit.h", "status": "added", "additions": 1289, "deletions": 0, "changes": 1289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fconfig%2Ffixed-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fconfig%2Ffixed-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffixed-bit.h?ref=154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9", "patch": "@@ -0,0 +1,1289 @@\n+/* This is a software fixed-point library.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef _FIXED_BIT_H\n+#define _FIXED_BIT_H\n+\n+/* To use this file we need to define one of the following:\n+   QQ_MODE, UQQ_MODE, HQ_MODE, UHQ_MODE, SQ_MODE, USQ_MODE, DQ_MODE, UDQ_MODE,\n+   TQ_MODE, UTQ_MODE, HA_MODE, UHA_MODE, SA_MODE, USA_MODE, DA_MODE, UDA_MODE,\n+   TA_MODE, UTA_MODE.\n+   Then, all operators for this machine mode will be created.\n+\n+   Or, we need to define FROM_* TO_* for conversions from one mode to another\n+   mode.  The mode could be one of the following:\n+   Fract: QQ, UQQ, HQ, UHQ, SQ, USQ, DQ, UDQ, TQ, UTQ\n+   Accum: HA, UHA, SA, USA, DA, UDA, TA, UTA\n+   Signed integer: QI, HI, SI, DI, TI\n+   Unsigned integer: UQI, UHI, USI, UDI, UTI\n+   Floating-point: SF, DF\n+   Ex: If we define FROM_QQ and TO_SI, the conversion from QQ to SI is\n+   generated.  */\n+\n+/* Permit the tm.h file to select the endianness to use just for this\n+   file.  This is used when the endianness is determined when the\n+   compiler is run.  */\n+\n+#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n+#ifndef LIBGCC2_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE\n+#endif\n+#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+#ifndef LIBGCC2_HAS_SF_MODE\n+#define LIBGCC2_HAS_SF_MODE (BITS_PER_UNIT == 8)\n+#endif\n+\n+#ifndef LIBGCC2_HAS_DF_MODE\n+#define LIBGCC2_HAS_DF_MODE \\\n+  (BITS_PER_UNIT == 8 \\\n+   && (LIBGCC2_DOUBLE_TYPE_SIZE == 64 \\\n+       || LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64))\n+#endif\n+\n+typedef          int QItype     __attribute__ ((mode (QI)));\n+typedef unsigned int UQItype    __attribute__ ((mode (QI)));\n+typedef          int HItype     __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype    __attribute__ ((mode (HI)));\n+typedef          _Fract QQtype  __attribute__ ((mode (QQ)));\n+typedef unsigned _Fract UQQtype __attribute__ ((mode (UQQ)));\n+typedef          _Fract HQtype  __attribute__ ((mode (HQ)));\n+typedef unsigned _Fract UHQtype __attribute__ ((mode (UHQ)));\n+typedef          _Fract HAtype  __attribute__ ((mode (HA)));\n+typedef unsigned _Fract UHAtype __attribute__ ((mode (UHA)));\n+#define HAVE_QQ\t\t1\n+#define HAVE_UQQ\t1\n+#define HAVE_HQ\t\t1\n+#define HAVE_UHQ\t1\n+#define HAVE_HA\t\t1\n+#define HAVE_UHA\t1\n+#define HAVE_QI\t\t1\n+#define HAVE_UQI\t1\n+#define HAVE_HI\t\t1\n+#define HAVE_UHI\t1\n+#if MIN_UNITS_PER_WORD > 1\n+/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1.  */\n+typedef          int SItype     __attribute__ ((mode (SI)));\n+typedef unsigned int USItype    __attribute__ ((mode (SI)));\n+typedef          _Fract SQtype  __attribute__ ((mode (SQ)));\n+typedef unsigned _Fract USQtype __attribute__ ((mode (USQ)));\n+typedef          _Fract SAtype  __attribute__ ((mode (SA)));\n+typedef unsigned _Fract USAtype __attribute__ ((mode (USA)));\n+#define HAVE_SQ\t\t1\n+#define HAVE_USQ\t1\n+#define HAVE_SA\t\t1\n+#define HAVE_USA\t1\n+#define HAVE_SI\t\t1\n+#define HAVE_USI\t1\n+#if LONG_LONG_TYPE_SIZE > 32\n+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2.  */\n+typedef          int DItype     __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype    __attribute__ ((mode (DI)));\n+typedef          _Fract DQtype  __attribute__ ((mode (DQ)));\n+typedef unsigned _Fract UDQtype __attribute__ ((mode (UDQ)));\n+typedef          _Fract DAtype  __attribute__ ((mode (DA)));\n+typedef unsigned _Fract UDAtype __attribute__ ((mode (UDA)));\n+#define HAVE_DQ\t\t1\n+#define HAVE_UDQ\t1\n+#define HAVE_DA\t\t1\n+#define HAVE_UDA\t1\n+#define HAVE_DI\t\t1\n+#define HAVE_UDI\t1\n+#if MIN_UNITS_PER_WORD > 4\n+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 4.  */\n+typedef          int TItype     __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype    __attribute__ ((mode (TI)));\n+typedef          _Fract TQtype  __attribute__ ((mode (TQ)));\n+typedef unsigned _Fract UTQtype __attribute__ ((mode (UTQ)));\n+typedef          _Fract TAtype  __attribute__ ((mode (TA)));\n+typedef unsigned _Fract UTAtype __attribute__ ((mode (UTA)));\n+#define HAVE_TQ\t\t1\n+#define HAVE_UTQ\t1\n+#define HAVE_TA\t\t1\n+#define HAVE_UTA\t1\n+#define HAVE_TI\t\t1\n+#define HAVE_UTI\t1\n+#endif\n+#endif\n+#endif\n+\n+#if LIBGCC2_HAS_SF_MODE\n+typedef float SFtype __attribute__ ((mode (SF)));\n+#define HAVE_SF\t\t1\n+#endif\n+#if LIBGCC2_HAS_DF_MODE\n+typedef float DFtype __attribute__ ((mode (DF)));\n+#define HAVE_DF\t\t1\n+#endif\n+\n+typedef int word_type __attribute__ ((mode (__word__)));\n+\n+/* Based on modes, we create many defines.  */\n+\n+#if defined (QQ_MODE) && (HAVE_QQ == 1)\n+#define FIXED_SIZE\t1\t/* in bytes.  */\n+#define INT_C_TYPE\tQItype\n+#define UINT_C_TYPE\tUQItype\n+#define DINT_C_TYPE\tHItype\n+#define DUINT_C_TYPE\tUHItype\n+#define MODE_NAME\tQQ\n+#define MODE_NAME_S\tqq\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UQQ_MODE) && (HAVE_UQQ == 1)\n+#define FIXED_SIZE\t1\t/* in bytes.  */\n+#define INT_C_TYPE\tUQItype\n+#define UINT_C_TYPE\tUQItype\n+#define DINT_C_TYPE\tUHItype\n+#define DUINT_C_TYPE\tUHItype\n+#define MODE_NAME\tUQQ\n+#define MODE_NAME_S\tuqq\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (HQ_MODE) && (HAVE_HQ == 1)\n+#define FIXED_SIZE\t2\t/* in bytes.  */\n+#define INT_C_TYPE\tHItype\n+#define UINT_C_TYPE\tUHItype\n+\n+#if HAVE_SI == 1\n+#define DINT_C_TYPE\tSItype\n+#define DUINT_C_TYPE\tUSItype\n+#else\n+#define HINT_C_TYPE\tQItype\n+#define HUINT_C_TYPE\tUQItype\n+#endif\n+\n+#define MODE_NAME\tHQ\n+#define MODE_NAME_S\thq\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UHQ_MODE) && (HAVE_UHQ == 1)\n+#define FIXED_SIZE\t2\t/* in bytes.  */\n+#define INT_C_TYPE\tUHItype\n+#define UINT_C_TYPE\tUHItype\n+\n+#if HAVE_SI == 1\n+#define DINT_C_TYPE\tUSItype\n+#define DUINT_C_TYPE\tUSItype\n+#else\n+#define HINT_C_TYPE\tUQItype\n+#define HUINT_C_TYPE\tUQItype\n+#endif\n+\n+#define MODE_NAME\tUHQ\n+#define MODE_NAME_S\tuhq\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (SQ_MODE) && (HAVE_SQ == 1)\n+#define FIXED_SIZE\t4\t/* in bytes.  */\n+#define INT_C_TYPE\tSItype\n+#define UINT_C_TYPE\tUSItype\n+\n+#if HAVE_DI == 1\n+#define DINT_C_TYPE\tDItype\n+#define DUINT_C_TYPE\tUDItype\n+#else\n+#define HINT_C_TYPE\tHItype\n+#define HUINT_C_TYPE\tUHItype\n+#endif\n+\n+#define MODE_NAME\tSQ\n+#define MODE_NAME_S\tsq\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (USQ_MODE) && (HAVE_USQ == 1)\n+#define FIXED_SIZE\t4\t/* in bytes.  */\n+#define INT_C_TYPE\tUSItype\n+#define UINT_C_TYPE\tUSItype\n+\n+#if HAVE_DI == 1\n+#define DINT_C_TYPE\tUDItype\n+#define DUINT_C_TYPE\tUDItype\n+#else\n+#define HINT_C_TYPE\tUHItype\n+#define HUINT_C_TYPE\tUHItype\n+#endif\n+\n+#define MODE_NAME\tUSQ\n+#define MODE_NAME_S\tusq\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (DQ_MODE) && (HAVE_DQ == 1)\n+#define FIXED_SIZE\t8\t/* in bytes.  */\n+#define INT_C_TYPE\tDItype\n+#define UINT_C_TYPE\tUDItype\n+\n+#if HAVE_TI == 1\n+#define DINT_C_TYPE\tTItype\n+#define DUINT_C_TYPE\tUTItype\n+#else\n+#define HINT_C_TYPE\tSItype\n+#define HUINT_C_TYPE\tUSItype\n+#endif\n+\n+#define MODE_NAME\tDQ\n+#define MODE_NAME_S\tdq\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UDQ_MODE) && (HAVE_UDQ == 1)\n+#define FIXED_SIZE\t8\t/* in bytes.  */\n+#define INT_C_TYPE\tUDItype\n+#define UINT_C_TYPE\tUDItype\n+\n+#if HAVE_TI == 1\n+#define DINT_C_TYPE\tUTItype\n+#define DUINT_C_TYPE\tUTItype\n+#else\n+#define HINT_C_TYPE\tUSItype\n+#define HUINT_C_TYPE\tUSItype\n+#endif\n+\n+#define MODE_NAME\tUDQ\n+#define MODE_NAME_S\tudq\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (TQ_MODE) && (HAVE_TQ == 1)\n+#define FIXED_SIZE\t16\t/* in bytes.  */\n+#define INT_C_TYPE\tTItype\n+#define UINT_C_TYPE\tUTItype\n+#define HINT_C_TYPE\tDItype\n+#define HUINT_C_TYPE\tUDItype\n+#define MODE_NAME\tTQ\n+#define MODE_NAME_S\ttq\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UTQ_MODE) && (HAVE_UTQ == 1)\n+#define FIXED_SIZE\t16\t/* in bytes.  */\n+#define INT_C_TYPE\tUTItype\n+#define UINT_C_TYPE\tUTItype\n+#define HINT_C_TYPE\tUDItype\n+#define HUINT_C_TYPE\tUDItype\n+#define MODE_NAME\tUTQ\n+#define MODE_NAME_S\tutq\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (HA_MODE) && (HAVE_HA == 1)\n+#define FIXED_SIZE\t2\t/* in bytes.  */\n+#define INT_C_TYPE\tHItype\n+#define UINT_C_TYPE\tUHItype\n+\n+#if HAVE_SI == 1\n+#define DINT_C_TYPE\tSItype\n+#define DUINT_C_TYPE\tUSItype\n+#else\n+#define HINT_C_TYPE\tQItype\n+#define HUINT_C_TYPE\tUQItype\n+#endif\n+\n+#define MODE_NAME\tHA\n+#define MODE_NAME_S\tha\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UHA_MODE) && (HAVE_UHA == 1)\n+#define FIXED_SIZE\t2\t/* in bytes.  */\n+#define INT_C_TYPE\tUHItype\n+#define UINT_C_TYPE\tUHItype\n+\n+#if HAVE_SI == 1\n+#define DINT_C_TYPE\tUSItype\n+#define DUINT_C_TYPE\tUSItype\n+#else\n+#define HINT_C_TYPE\tUQItype\n+#define HUINT_C_TYPE\tUQItype\n+#endif\n+\n+#define MODE_NAME\tUHA\n+#define MODE_NAME_S\tuha\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (SA_MODE) && (HAVE_SA == 1)\n+#define FIXED_SIZE\t4\t/* in bytes.  */\n+#define INT_C_TYPE\tSItype\n+#define UINT_C_TYPE\tUSItype\n+\n+#if HAVE_DI == 1\n+#define DINT_C_TYPE\tDItype\n+#define DUINT_C_TYPE\tUDItype\n+#else\n+#define HINT_C_TYPE\tHItype\n+#define HUINT_C_TYPE\tUHItype\n+#endif\n+\n+#define MODE_NAME\tSA\n+#define MODE_NAME_S\tsa\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (USA_MODE) && (HAVE_USA == 1)\n+#define FIXED_SIZE\t4\t/* in bytes.  */\n+#define INT_C_TYPE\tUSItype\n+#define UINT_C_TYPE\tUSItype\n+\n+#if HAVE_DI == 1\n+#define DINT_C_TYPE\tUDItype\n+#define DUINT_C_TYPE\tUDItype\n+#else\n+#define HINT_C_TYPE\tUHItype\n+#define HUINT_C_TYPE\tUHItype\n+#endif\n+\n+#define MODE_NAME\tUSA\n+#define MODE_NAME_S\tusa\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (DA_MODE) && (HAVE_DA == 1)\n+#define FIXED_SIZE\t8\t/* in bytes.  */\n+#define INT_C_TYPE\tDItype\n+#define UINT_C_TYPE\tUDItype\n+\n+#if HAVE_TI == 1\n+#define DINT_C_TYPE\tTItype\n+#define DUINT_C_TYPE\tUTItype\n+#else\n+#define HINT_C_TYPE\tSItype\n+#define HUINT_C_TYPE\tUSItype\n+#endif\n+\n+#define MODE_NAME\tDA\n+#define MODE_NAME_S\tda\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UDA_MODE) && (HAVE_UDA == 1)\n+#define FIXED_SIZE\t8\t/* in bytes.  */\n+#define INT_C_TYPE\tUDItype\n+#define UINT_C_TYPE\tUDItype\n+\n+#if HAVE_TI == 1\n+#define DINT_C_TYPE\tUTItype\n+#define DUINT_C_TYPE\tUTItype\n+#else\n+#define HINT_C_TYPE\tUSItype\n+#define HUINT_C_TYPE\tUSItype\n+#endif\n+\n+#define MODE_NAME\tUDA\n+#define MODE_NAME_S\tuda\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+#if defined (TA_MODE) && (HAVE_TA == 1)\n+#define FIXED_SIZE\t16\t/* in bytes.  */\n+#define INT_C_TYPE\tTItype\n+#define UINT_C_TYPE\tUTItype\n+#define HINT_C_TYPE\tDItype\n+#define HUINT_C_TYPE\tUDItype\n+#define MODE_NAME\tTA\n+#define MODE_NAME_S\tta\n+#define MODE_UNSIGNED\t0\n+#endif\n+\n+#if defined (UTA_MODE) && (HAVE_UTA == 1)\n+#define FIXED_SIZE\t16\t/* in bytes.  */\n+#define INT_C_TYPE\tUTItype\n+#define UINT_C_TYPE\tUTItype\n+#define HINT_C_TYPE\tUDItype\n+#define HUINT_C_TYPE\tUDItype\n+#define MODE_NAME\tUTA\n+#define MODE_NAME_S\tuta\n+#define MODE_UNSIGNED\t1\n+#endif\n+\n+/* The following defines are based on the previous defines.  */\n+\n+#if defined (HINT_C_TYPE)\n+#if LIBGCC2_WORDS_BIG_ENDIAN\n+  struct INTstruct {HINT_C_TYPE high, low;};\n+#else\n+  struct INTstruct {HINT_C_TYPE low, high;};\n+#endif\n+\n+typedef union\n+{\n+  struct INTstruct s;\n+  INT_C_TYPE ll;\n+} INTunion;\n+#endif\n+\n+#define FIXED_WIDTH\t(FIXED_SIZE * BITS_PER_UNIT) /* in bits.  */\n+#define FIXED_C_TYPE1(NAME)\tNAME ## type\n+#define FIXED_C_TYPE2(NAME)\tFIXED_C_TYPE1(NAME)\n+#define FIXED_C_TYPE\tFIXED_C_TYPE2(MODE_NAME)\n+#define FBITS1(NAME)\t__ ## NAME ## _FBIT__\n+#define FBITS2(NAME)\tFBITS1(NAME)\n+#define FBITS\t\tFBITS2(MODE_NAME)\n+#define IBITS1(NAME)\t__ ## NAME ## _IBIT__\n+#define IBITS2(NAME)\tIBITS1(NAME)\n+#define IBITS\t\tIBITS2(MODE_NAME)\n+#define I_F_BITS\t(FBITS + IBITS)\n+\n+#define FIXED_OP(OP,MODE,NUM)\tOP ## MODE ## NUM\n+\n+#define FIXED_SATURATE1_TEMP(NAME)\tFIXED_OP(__saturate1,NAME,)\n+#define FIXED_SATURATE2_TEMP(NAME)\tFIXED_OP(__saturate2,NAME,)\n+#define FIXED_MULHELPER_TEMP(NAME)\tFIXED_OP(__mulhelper,NAME,)\n+#define FIXED_DIVHELPER_TEMP(NAME)\tFIXED_OP(__divhelper,NAME,)\n+#define FIXED_ASHLHELPER_TEMP(NAME)\tFIXED_OP(__ashlhelper,NAME,)\n+#define FIXED_ADD_TEMP(NAME)\tFIXED_OP(__add,NAME,3)\n+#define FIXED_SSADD_TEMP(NAME)\tFIXED_OP(__ssadd,NAME,3)\n+#define FIXED_USADD_TEMP(NAME)\tFIXED_OP(__usadd,NAME,3)\n+#define FIXED_SUB_TEMP(NAME)\tFIXED_OP(__sub,NAME,3)\n+#define FIXED_SSSUB_TEMP(NAME)\tFIXED_OP(__sssub,NAME,3)\n+#define FIXED_USSUB_TEMP(NAME)\tFIXED_OP(__ussub,NAME,3)\n+#define FIXED_MUL_TEMP(NAME)\tFIXED_OP(__mul,NAME,3)\n+#define FIXED_SSMUL_TEMP(NAME)\tFIXED_OP(__ssmul,NAME,3)\n+#define FIXED_USMUL_TEMP(NAME)\tFIXED_OP(__usmul,NAME,3)\n+#define FIXED_DIV_TEMP(NAME)\tFIXED_OP(__div,NAME,3)\n+#define FIXED_UDIV_TEMP(NAME)\tFIXED_OP(__udiv,NAME,3)\n+#define FIXED_SSDIV_TEMP(NAME)\tFIXED_OP(__ssdiv,NAME,3)\n+#define FIXED_USDIV_TEMP(NAME)\tFIXED_OP(__usdiv,NAME,3)\n+#define FIXED_NEG_TEMP(NAME)\tFIXED_OP(__neg,NAME,2)\n+#define FIXED_SSNEG_TEMP(NAME)\tFIXED_OP(__ssneg,NAME,2)\n+#define FIXED_USNEG_TEMP(NAME)\tFIXED_OP(__usneg,NAME,2)\n+#define FIXED_ASHL_TEMP(NAME)\tFIXED_OP(__ashl,NAME,3)\n+#define FIXED_ASHR_TEMP(NAME)\tFIXED_OP(__ashr,NAME,3)\n+#define FIXED_LSHR_TEMP(NAME)\tFIXED_OP(__lshr,NAME,3)\n+#define FIXED_SSASHL_TEMP(NAME)\tFIXED_OP(__ssashl,NAME,3)\n+#define FIXED_USASHL_TEMP(NAME)\tFIXED_OP(__usashl,NAME,3)\n+#define FIXED_CMP_TEMP(NAME)\tFIXED_OP(__cmp,NAME,2)\n+\n+#if defined (MODE_NAME)\n+#if defined (DINT_C_TYPE)\n+#define FIXED_SATURATE1\tFIXED_SATURATE1_TEMP(MODE_NAME_S)\n+#else\n+#define FIXED_SATURATE2\tFIXED_SATURATE2_TEMP(MODE_NAME_S)\n+#endif\n+#define FIXED_MULHELPER\tFIXED_MULHELPER_TEMP(MODE_NAME_S)\n+#define FIXED_DIVHELPER\tFIXED_DIVHELPER_TEMP(MODE_NAME_S)\n+#define FIXED_ASHLHELPER\tFIXED_ASHLHELPER_TEMP(MODE_NAME_S)\n+#define FIXED_ADD\tFIXED_ADD_TEMP(MODE_NAME_S)\n+#define FIXED_SUB\tFIXED_SUB_TEMP(MODE_NAME_S)\n+#define FIXED_MUL\tFIXED_MUL_TEMP(MODE_NAME_S)\n+#define FIXED_NEG\tFIXED_NEG_TEMP(MODE_NAME_S)\n+#define FIXED_ASHL\tFIXED_ASHL_TEMP(MODE_NAME_S)\n+#define FIXED_CMP\tFIXED_CMP_TEMP(MODE_NAME_S)\n+\n+/* The following functions are for all fixed-point modes.  */\n+#if defined (DINT_C_TYPE)\n+extern void FIXED_SATURATE1 (DINT_C_TYPE *);\n+#else\n+extern void FIXED_SATURATE2 (INT_C_TYPE *, INT_C_TYPE *);\n+#endif\n+extern FIXED_C_TYPE FIXED_MULHELPER (FIXED_C_TYPE, FIXED_C_TYPE, word_type);\n+extern FIXED_C_TYPE FIXED_DIVHELPER (FIXED_C_TYPE, FIXED_C_TYPE, word_type);\n+extern FIXED_C_TYPE FIXED_ASHLHELPER (FIXED_C_TYPE, word_type, word_type);\n+extern FIXED_C_TYPE FIXED_ADD (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SUB (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_MUL (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_NEG (FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_ASHL (FIXED_C_TYPE, word_type);\n+extern word_type FIXED_CMP (FIXED_C_TYPE, FIXED_C_TYPE);\n+#endif\n+\n+#if MODE_UNSIGNED == 0 /* Signed types.  */\n+#define PADDING_BITS\t(FIXED_WIDTH - 1 - I_F_BITS)\n+#define NONPADDING_BITS\t(1 + I_F_BITS)\n+\n+#if defined (MODE_NAME)\n+#define FIXED_DIV\tFIXED_DIV_TEMP(MODE_NAME_S)\n+#define FIXED_ASHR\tFIXED_ASHR_TEMP(MODE_NAME_S)\n+#define FIXED_SSADD\tFIXED_SSADD_TEMP(MODE_NAME_S)\n+#define FIXED_SSSUB\tFIXED_SSSUB_TEMP(MODE_NAME_S)\n+#define FIXED_SSMUL\tFIXED_SSMUL_TEMP(MODE_NAME_S)\n+#define FIXED_SSDIV\tFIXED_SSDIV_TEMP(MODE_NAME_S)\n+#define FIXED_SSNEG\tFIXED_SSNEG_TEMP(MODE_NAME_S)\n+#define FIXED_SSASHL\tFIXED_SSASHL_TEMP(MODE_NAME_S)\n+\n+/* The following functions are for signed fixed-point modes.  */\n+extern FIXED_C_TYPE FIXED_DIV (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_ASHR (FIXED_C_TYPE, word_type);\n+extern FIXED_C_TYPE FIXED_SSADD (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SSSUB (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SSMUL (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SSDIV (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SSNEG (FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_SSASHL (FIXED_C_TYPE, word_type);\n+#endif\n+\n+#else /* Unsigned types.  */\n+#define PADDING_BITS\t(FIXED_WIDTH - I_F_BITS)\n+#define NONPADDING_BITS\t(I_F_BITS)\n+\n+#if defined (MODE_NAME)\n+#define FIXED_UDIV\tFIXED_UDIV_TEMP(MODE_NAME_S)\n+#define FIXED_LSHR\tFIXED_LSHR_TEMP(MODE_NAME_S)\n+#define FIXED_USDIV\tFIXED_USDIV_TEMP(MODE_NAME_S)\n+#define FIXED_USADD\tFIXED_USADD_TEMP(MODE_NAME_S)\n+#define FIXED_USSUB\tFIXED_USSUB_TEMP(MODE_NAME_S)\n+#define FIXED_USMUL\tFIXED_USMUL_TEMP(MODE_NAME_S)\n+#define FIXED_USNEG\tFIXED_USNEG_TEMP(MODE_NAME_S)\n+#define FIXED_USASHL\tFIXED_USASHL_TEMP(MODE_NAME_S)\n+\n+/* The following functions are for unsigned fixed-point modes.  */\n+extern FIXED_C_TYPE FIXED_UDIV (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_LSHR (FIXED_C_TYPE, word_type);\n+extern FIXED_C_TYPE FIXED_USADD (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_USSUB (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_USMUL (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_USDIV (FIXED_C_TYPE, FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_USNEG (FIXED_C_TYPE);\n+extern FIXED_C_TYPE FIXED_USASHL (FIXED_C_TYPE, word_type);\n+#endif\n+\n+#endif /* End of testing MODE_UNSIGNED.  */\n+\n+/* This define is to check if this mode have any padding bits.  */\n+#define HAVE_PADDING_BITS\t(PADDING_BITS > 0)\n+\n+/* ------------------------------------------------------------------------ */\n+/* The following defines are for conversions.  */\n+\n+#if defined (FROM_QI) && HAVE_QI == 1\n+#define FROM_TYPE\t\t1\t/* Signed integer.  */\n+#define FROM_INT_C_TYPE\t\tQItype\n+#define FROM_SINT_C_TYPE\tQItype\n+#define FROM_UINT_C_TYPE\tUQItype\n+#define FROM_MODE_NAME_S\tqi\n+#define FROM_INT_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (FROM_HI) && HAVE_HI == 1\n+#define FROM_TYPE\t\t1\t/* Signed integer.  */\n+#define FROM_INT_C_TYPE\t\tHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_NAME_S\thi\n+#define FROM_INT_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_SI) && HAVE_SI == 1\n+#define FROM_TYPE\t\t1\t/* Signed integer.  */\n+#define FROM_INT_C_TYPE\t\tSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_NAME_S\tsi\n+#define FROM_INT_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_DI) && HAVE_DI == 1\n+#define FROM_TYPE\t\t1\t/* Signed integer.  */\n+#define FROM_INT_C_TYPE\t\tDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_NAME_S\tdi\n+#define FROM_INT_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_TI) && HAVE_TI == 1\n+#define FROM_TYPE\t\t1\t/* Signed integer.  */\n+#define FROM_INT_C_TYPE\t\tTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_NAME_S\tti\n+#define FROM_INT_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (FROM_UQI) && HAVE_UQI == 1\n+#define FROM_TYPE\t\t2\t/* Unsigned integer.  */\n+#define FROM_INT_C_TYPE\t\tQItype\n+#define FROM_SINT_C_TYPE\tQItype\n+#define FROM_UINT_C_TYPE\tUQItype\n+#define FROM_MODE_NAME_S\tqi\n+#define FROM_INT_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (FROM_UHI) && HAVE_UHI == 1\n+#define FROM_TYPE\t\t2\t/* Unsigned integer.  */\n+#define FROM_INT_C_TYPE\t\tUHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_NAME_S\thi\n+#define FROM_INT_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_USI) && HAVE_USI == 1\n+#define FROM_TYPE\t\t2\t/* Unsigned integer.  */\n+#define FROM_INT_C_TYPE\t\tUSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_NAME_S\tsi\n+#define FROM_INT_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_UDI) && HAVE_UDI == 1\n+#define FROM_TYPE\t\t2\t/* Unsigned integer.  */\n+#define FROM_INT_C_TYPE\t\tUDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_NAME_S\tdi\n+#define FROM_INT_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_UTI) && HAVE_UTI == 1\n+#define FROM_TYPE\t\t2\t/* Unsigned integer.  */\n+#define FROM_INT_C_TYPE\t\tUTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_NAME_S\tti\n+#define FROM_INT_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (FROM_SF) && HAVE_SF == 1\n+#define FROM_TYPE\t\t3\t/* Floating-point.  */\n+#define FROM_FLOAT_C_TYPE\tSFtype\n+#define FROM_MODE_NAME_S\tsf\n+\n+#elif defined (FROM_DF) && HAVE_DF == 1\n+#define FROM_TYPE\t\t3\t/* Floating-point.  */\n+#define FROM_FLOAT_C_TYPE\tDFtype\n+#define FROM_MODE_NAME_S\tdf\n+\n+#elif defined (FROM_QQ) && HAVE_QQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tQQ\n+#define FROM_MODE_NAME_S\tqq\n+#define FROM_INT_C_TYPE\t\tQItype\n+#define FROM_SINT_C_TYPE\tQItype\n+#define FROM_UINT_C_TYPE\tUQItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (FROM_HQ) && HAVE_HQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tHQ\n+#define FROM_MODE_NAME_S\thq\n+#define FROM_INT_C_TYPE\t\tHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_SQ) && HAVE_SQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tSQ\n+#define FROM_MODE_NAME_S\tsq\n+#define FROM_INT_C_TYPE\t\tSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_DQ) && HAVE_DQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tDQ\n+#define FROM_MODE_NAME_S\tdq\n+#define FROM_INT_C_TYPE\t\tDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_TQ) && HAVE_TQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tTQ\n+#define FROM_MODE_NAME_S\ttq\n+#define FROM_INT_C_TYPE\t\tTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (FROM_UQQ) && HAVE_UQQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUQQ\n+#define FROM_MODE_NAME_S\tuqq\n+#define FROM_INT_C_TYPE\t\tUQItype\n+#define FROM_SINT_C_TYPE\tQItype\n+#define FROM_UINT_C_TYPE\tUQItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (FROM_UHQ) && HAVE_UHQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUHQ\n+#define FROM_MODE_NAME_S\tuhq\n+#define FROM_INT_C_TYPE\t\tUHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_USQ) && HAVE_USQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUSQ\n+#define FROM_MODE_NAME_S\tusq\n+#define FROM_INT_C_TYPE\t\tUSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_UDQ) && HAVE_UDQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUDQ\n+#define FROM_MODE_NAME_S\tudq\n+#define FROM_INT_C_TYPE\t\tUDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_UTQ) && HAVE_UTQ == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUTQ\n+#define FROM_MODE_NAME_S\tutq\n+#define FROM_INT_C_TYPE\t\tUTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (FROM_HA) && HAVE_HA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tHA\n+#define FROM_MODE_NAME_S\tha\n+#define FROM_INT_C_TYPE\t\tHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_SA) && HAVE_SA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tSA\n+#define FROM_MODE_NAME_S\tsa\n+#define FROM_INT_C_TYPE\t\tSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_DA) && HAVE_DA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tDA\n+#define FROM_MODE_NAME_S\tda\n+#define FROM_INT_C_TYPE\t\tDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_TA) && HAVE_TA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tTA\n+#define FROM_MODE_NAME_S\tta\n+#define FROM_INT_C_TYPE\t\tTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_UNSIGNED\t0\n+#define FROM_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (FROM_UHA) && HAVE_UHA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUHA\n+#define FROM_MODE_NAME_S\tuha\n+#define FROM_INT_C_TYPE\t\tUHItype\n+#define FROM_SINT_C_TYPE\tHItype\n+#define FROM_UINT_C_TYPE\tUHItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (FROM_USA) && HAVE_USA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUSA\n+#define FROM_MODE_NAME_S\tusa\n+#define FROM_INT_C_TYPE\t\tUSItype\n+#define FROM_SINT_C_TYPE\tSItype\n+#define FROM_UINT_C_TYPE\tUSItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (FROM_UDA) && HAVE_UDA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUDA\n+#define FROM_MODE_NAME_S\tuda\n+#define FROM_INT_C_TYPE\t\tUDItype\n+#define FROM_SINT_C_TYPE\tDItype\n+#define FROM_UINT_C_TYPE\tUDItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (FROM_UTA) && HAVE_UTA == 1\n+#define FROM_TYPE\t\t4\t/* Fixed-point.  */\n+#define FROM_MODE_NAME\t\tUTA\n+#define FROM_MODE_NAME_S\tuta\n+#define FROM_INT_C_TYPE\t\tUTItype\n+#define FROM_SINT_C_TYPE\tTItype\n+#define FROM_UINT_C_TYPE\tUTItype\n+#define FROM_MODE_UNSIGNED\t1\n+#define FROM_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#endif\n+\n+#if defined (TO_QI) && HAVE_QI == 1 && !defined (FROM_QI)\n+#define TO_TYPE\t\t\t1\t/* Signed integer.  */\n+#define TO_INT_C_TYPE\t\tQItype\n+#define TO_SINT_C_TYPE\t\tQItype\n+#define TO_UINT_C_TYPE\t\tUQItype\n+#define TO_MODE_NAME_S\t\tqi\n+\n+#elif defined (TO_HI) && HAVE_HI == 1 && !defined (FROM_HI)\n+#define TO_TYPE\t\t\t1\t/* Signed integer.  */\n+#define TO_INT_C_TYPE\t\tHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_NAME_S\t\thi\n+\n+#elif defined (TO_SI) && HAVE_SI == 1 && !defined (FROM_SI)\n+#define TO_TYPE\t\t\t1\t/* Signed integer.  */\n+#define TO_INT_C_TYPE\t\tSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_NAME_S\t\tsi\n+\n+#elif defined (TO_DI) && HAVE_DI == 1 && !defined (FROM_DI)\n+#define TO_TYPE\t\t\t1\t/* Signed integer.  */\n+#define TO_INT_C_TYPE\t\tDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_NAME_S\t\tdi\n+\n+#elif defined (TO_TI) && HAVE_TI == 1 && !defined (FROM_TI)\n+#define TO_TYPE\t\t\t1\t/* Signed integer.  */\n+#define TO_INT_C_TYPE\t\tTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_NAME_S\t\tti\n+\n+#elif defined (TO_UQI) && HAVE_UQI == 1 && !defined (FROM_UQI)\n+#define TO_TYPE\t\t\t2\t/* Unsigned integer.  */\n+#define TO_INT_C_TYPE\t\tUQItype\n+#define TO_SINT_C_TYPE\t\tQItype\n+#define TO_UINT_C_TYPE\t\tUQItype\n+#define TO_MODE_NAME_S\t\tqi\n+\n+#elif defined (TO_UHI) && HAVE_UHI == 1 && !defined (FROM_UHI)\n+#define TO_TYPE\t\t\t2\t/* Unsigned integer.  */\n+#define TO_INT_C_TYPE\t\tUHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_NAME_S\t\thi\n+\n+#elif defined (TO_USI) && HAVE_USI == 1 && !defined (FROM_USI)\n+#define TO_TYPE\t\t\t2\t/* Unsigned integer.  */\n+#define TO_INT_C_TYPE\t\tUSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_NAME_S\t\tsi\n+\n+#elif defined (TO_UDI) && HAVE_UDI == 1 && !defined (FROM_UDI)\n+#define TO_TYPE\t\t\t2\t/* Unsigned integer.  */\n+#define TO_INT_C_TYPE\t\tUDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_NAME_S\t\tdi\n+\n+#elif defined (TO_UTI) && HAVE_UTI == 1 && !defined (FROM_UTI)\n+#define TO_TYPE\t\t\t2\t/* Unsigned integer.  */\n+#define TO_INT_C_TYPE\t\tUTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_NAME_S\t\tti\n+\n+#elif defined (TO_SF) && HAVE_SF == 1 && !defined (FROM_SF)\n+#define TO_TYPE\t\t\t3\t/* Floating-point.  */\n+#define TO_FLOAT_C_TYPE\t\tSFtype\n+#define TO_MODE_NAME_S\t\tsf\n+\n+#elif defined (TO_DF) && HAVE_DF == 1 && !defined (FROM_DF)\n+#define TO_TYPE\t\t\t3\t/* Floating-point.  */\n+#define TO_FLOAT_C_TYPE\t\tDFtype\n+#define TO_MODE_NAME_S\t\tdf\n+\n+#elif defined (TO_QQ) && HAVE_QQ == 1 && !defined (FROM_QQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tQQ\n+#define TO_MODE_NAME_S\t\tqq\n+#define TO_INT_C_TYPE\t\tQItype\n+#define TO_SINT_C_TYPE\t\tQItype\n+#define TO_UINT_C_TYPE\t\tUQItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (TO_HQ) && HAVE_HQ == 1 && !defined (FROM_HQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tHQ\n+#define TO_MODE_NAME_S\t\thq\n+#define TO_INT_C_TYPE\t\tHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (TO_SQ) && HAVE_SQ == 1 && !defined (FROM_SQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tSQ\n+#define TO_MODE_NAME_S\t\tsq\n+#define TO_INT_C_TYPE\t\tSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (TO_DQ) && HAVE_DQ == 1 && !defined (FROM_DQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tDQ\n+#define TO_MODE_NAME_S\t\tdq\n+#define TO_INT_C_TYPE\t\tDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (TO_TQ) && HAVE_TQ == 1 && !defined (FROM_TQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tTQ\n+#define TO_MODE_NAME_S\t\ttq\n+#define TO_INT_C_TYPE\t\tTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (TO_UQQ) && HAVE_UQQ == 1 && !defined (FROM_UQQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUQQ\n+#define TO_MODE_NAME_S\t\tuqq\n+#define TO_INT_C_TYPE\t\tUQItype\n+#define TO_SINT_C_TYPE\t\tQItype\n+#define TO_UINT_C_TYPE\t\tUQItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t1\t/* in bytes.  */\n+\n+#elif defined (TO_UHQ) && HAVE_UHQ == 1 && !defined (FROM_UHQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUHQ\n+#define TO_MODE_NAME_S\t\tuhq\n+#define TO_INT_C_TYPE\t\tUHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (TO_USQ) && HAVE_USQ == 1 && !defined (FROM_USQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUSQ\n+#define TO_MODE_NAME_S\t\tusq\n+#define TO_INT_C_TYPE\t\tUSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (TO_UDQ) && HAVE_UDQ == 1 && !defined (FROM_UDQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUDQ\n+#define TO_MODE_NAME_S\t\tudq\n+#define TO_INT_C_TYPE\t\tUDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (TO_UTQ) && HAVE_UTQ == 1 && !defined (FROM_UTQ)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUTQ\n+#define TO_MODE_NAME_S\t\tutq\n+#define TO_INT_C_TYPE\t\tUTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (TO_HA) && HAVE_HA == 1 && !defined (FROM_HA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tHA\n+#define TO_MODE_NAME_S\t\tha\n+#define TO_INT_C_TYPE\t\tHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (TO_SA) && HAVE_SA == 1 && !defined (FROM_SA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tSA\n+#define TO_MODE_NAME_S\t\tsa\n+#define TO_INT_C_TYPE\t\tSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (TO_DA) && HAVE_DA == 1 && !defined (FROM_DA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tDA\n+#define TO_MODE_NAME_S\t\tda\n+#define TO_INT_C_TYPE\t\tDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (TO_TA) && HAVE_TA == 1 && !defined (FROM_TA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tTA\n+#define TO_MODE_NAME_S\t\tta\n+#define TO_INT_C_TYPE\t\tTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_UNSIGNED\t0\n+#define TO_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#elif defined (TO_UHA) && HAVE_UHA == 1 && !defined (FROM_UHA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUHA\n+#define TO_MODE_NAME_S\t\tuha\n+#define TO_INT_C_TYPE\t\tUHItype\n+#define TO_SINT_C_TYPE\t\tHItype\n+#define TO_UINT_C_TYPE\t\tUHItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t2\t/* in bytes.  */\n+\n+#elif defined (TO_USA) && HAVE_USA == 1 && !defined (FROM_USA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUSA\n+#define TO_MODE_NAME_S\t\tusa\n+#define TO_INT_C_TYPE\t\tUSItype\n+#define TO_SINT_C_TYPE\t\tSItype\n+#define TO_UINT_C_TYPE\t\tUSItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t4\t/* in bytes.  */\n+\n+#elif defined (TO_UDA) && HAVE_UDA == 1 && !defined (FROM_UDA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUDA\n+#define TO_MODE_NAME_S\t\tuda\n+#define TO_INT_C_TYPE\t\tUDItype\n+#define TO_SINT_C_TYPE\t\tDItype\n+#define TO_UINT_C_TYPE\t\tUDItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t8\t/* in bytes.  */\n+\n+#elif defined (TO_UTA) && HAVE_UTA == 1 && !defined (FROM_UTA)\n+#define TO_TYPE\t\t\t4\t/* Fixed-point.  */\n+#define TO_MODE_NAME\t\tUTA\n+#define TO_MODE_NAME_S\t\tuta\n+#define TO_INT_C_TYPE\t\tUTItype\n+#define TO_SINT_C_TYPE\t\tTItype\n+#define TO_UINT_C_TYPE\t\tUTItype\n+#define TO_MODE_UNSIGNED\t1\n+#define TO_FIXED_SIZE\t\t16\t/* in bytes.  */\n+\n+#endif\n+\n+#if defined (FROM_MODE_NAME_S) && defined (TO_MODE_NAME_S)\n+\n+#if FROM_TYPE == 1\t/* Signed integer.  */\n+#define FROM_INT_WIDTH\t\t(FROM_INT_SIZE * BITS_PER_UNIT)\n+#endif\n+\n+#if FROM_TYPE == 2\t/* Unsigned integer.  */\n+#define FROM_INT_WIDTH\t\t(FROM_INT_SIZE * BITS_PER_UNIT)\n+#endif\n+\n+#if FROM_TYPE == 4\t/* Fixed-point.  */\n+#define FROM_FIXED_C_TYPE\tFIXED_C_TYPE2(FROM_MODE_NAME)\n+#define FROM_FBITS\t\tFBITS2(FROM_MODE_NAME)\n+#define FROM_FIXED_WIDTH\t(FROM_FIXED_SIZE * BITS_PER_UNIT)\n+#define FROM_FBITS\t\tFBITS2(FROM_MODE_NAME)\n+#define FROM_IBITS\t\tIBITS2(FROM_MODE_NAME)\n+#define FROM_I_F_BITS\t\t(FROM_FBITS + FROM_IBITS)\n+\n+#if FROM_MODE_UNSIGNED == 0 /* Signed types.  */\n+#define FROM_PADDING_BITS\t(FROM_FIXED_WIDTH - 1 - FROM_I_F_BITS)\n+#define FROM_NONPADDING_BITS\t(1 + FROM_I_F_BITS)\n+#else /* Unsigned types.  */\n+#define FROM_PADDING_BITS\t(FROM_FIXED_WIDTH - FROM_I_F_BITS)\n+#define FROM_NONPADDING_BITS\t(FROM_I_F_BITS)\n+#endif\n+#define FROM_HAVE_PADDING_BITS\t(FROM_PADDING_BITS > 0)\n+#endif /* FROM_TYPE == 4  */\n+\n+#if TO_TYPE == 4\t/* Fixed-point.  */\n+#define TO_FIXED_C_TYPE\t\tFIXED_C_TYPE2(TO_MODE_NAME)\n+#define TO_FBITS\t\tFBITS2(TO_MODE_NAME)\n+#define TO_FIXED_WIDTH\t\t(TO_FIXED_SIZE * BITS_PER_UNIT)\n+#define TO_FBITS\t\tFBITS2(TO_MODE_NAME)\n+#define TO_IBITS\t\tIBITS2(TO_MODE_NAME)\n+#define TO_I_F_BITS\t\t(TO_FBITS + TO_IBITS)\n+\n+#if TO_MODE_UNSIGNED == 0 /* Signed types.  */\n+#define TO_PADDING_BITS\t\t(TO_FIXED_WIDTH - 1 - TO_I_F_BITS)\n+#define TO_NONPADDING_BITS\t(1 + TO_I_F_BITS)\n+#else /* Unsigned types.  */\n+#define TO_PADDING_BITS\t\t(TO_FIXED_WIDTH - TO_I_F_BITS)\n+#define TO_NONPADDING_BITS\t(TO_I_F_BITS)\n+#endif\n+#define TO_HAVE_PADDING_BITS\t(TO_PADDING_BITS > 0)\n+#endif /* TO_TYPE == 4  */\n+\n+#define FIXED_CONVERT_OP(OP,FROM,TO)\tOP ## FROM ## TO\n+#define FIXED_CONVERT_OP2(OP,FROM,TO)\tOP ## FROM ## TO ## 2\n+#define FRACT_TEMP(N1,N2)\t\tFIXED_CONVERT_OP(__fract,N1,N2)\n+#define FRACT2_TEMP(N1,N2)\t\tFIXED_CONVERT_OP2(__fract,N1,N2)\n+#define SATFRACT_TEMP(N1,N2)\t\tFIXED_CONVERT_OP(__satfract,N1,N2)\n+#define SATFRACT2_TEMP(N1,N2)\t\tFIXED_CONVERT_OP2(__satfract,N1,N2)\n+#define FRACTUNS_TEMP(N1,N2)\t\tFIXED_CONVERT_OP(__fractuns,N1,N2)\n+#define SATFRACTUNS_TEMP(N1,N2)\t\tFIXED_CONVERT_OP(__satfractuns,N1,N2)\n+\n+/* Define conversions from fixed-point to fixed-point.  */\n+#if FROM_TYPE == 4 && TO_TYPE == 4\n+\n+#if FROM_FIXED_SIZE > TO_FIXED_SIZE\n+#define BIG_SINT_C_TYPE\tFROM_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tFROM_UINT_C_TYPE\n+#define BIG_WIDTH\tFROM_FIXED_WIDTH\n+#else\n+#define BIG_SINT_C_TYPE\tTO_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tTO_UINT_C_TYPE\n+#define BIG_WIDTH\tTO_FIXED_WIDTH\n+#endif\n+\n+/* Check if FROM* and TO* are in the same machine class.  */\n+#if ((FROM_MODE_UNSIGNED == TO_MODE_UNSIGNED) \\\n+     && ((FROM_IBITS == 0) == (TO_IBITS == 0)))\n+/* Same modes: append '2' to conversion function names */\n+#define FRACT\t\tFRACT2_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#define SATFRACT\tSATFRACT2_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#else\n+/* Different modes: don't append '2' to conversion function names */\n+#define FRACT\t\tFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#define SATFRACT\tSATFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#endif\n+\n+extern TO_FIXED_C_TYPE FRACT (FROM_FIXED_C_TYPE);\n+extern TO_FIXED_C_TYPE SATFRACT (FROM_FIXED_C_TYPE);\n+#endif /* FROM_TYPE == 4 && TO_TYPE == 4  */\n+\n+/* Define conversions from fixed-point to signed integer.  */\n+#if FROM_TYPE == 4 && TO_TYPE == 1\n+#define FRACT\t\tFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_INT_C_TYPE\tFRACT (FROM_FIXED_C_TYPE);\n+#endif /* FROM_TYPE == 4 && TO_TYPE == 1  */\n+\n+/* Define conversions from fixed-point to unsigned integer.  */\n+#if FROM_TYPE == 4 && TO_TYPE == 2\n+#define FRACTUNS\tFRACTUNS_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_INT_C_TYPE \tFRACTUNS (FROM_FIXED_C_TYPE);\n+#endif /* FROM_TYPE == 4 && TO_TYPE == 2  */\n+\n+/* Define conversions from fixed-point to floating-point.  */\n+#if FROM_TYPE == 4 && TO_TYPE == 3\n+#define BASE1(NUM)\t0x1.0p ## NUM\n+#define BASE2(NUM)\tBASE1(NUM)\n+#define BASE\t\tBASE2(FROM_FBITS)\n+#define FRACT\t\tFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_FLOAT_C_TYPE\tFRACT (FROM_FIXED_C_TYPE);\n+#endif /* FROM_TYPE == 4 && TO_TYPE == 3  */\n+\n+/* Define conversions from signed integer to fixed-point.  */\n+#if FROM_TYPE == 1 && TO_TYPE == 4\n+\n+#if FROM_INT_SIZE > TO_FIXED_SIZE\n+#define BIG_SINT_C_TYPE\tFROM_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tFROM_UINT_C_TYPE\n+#define BIG_WIDTH\tFROM_INT_WIDTH\n+#else\n+#define BIG_SINT_C_TYPE\tTO_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tTO_UINT_C_TYPE\n+#define BIG_WIDTH\tTO_FIXED_WIDTH\n+#endif\n+\n+#define FRACT\t\tFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#define SATFRACT\tSATFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_FIXED_C_TYPE\tFRACT (FROM_INT_C_TYPE);\n+extern TO_FIXED_C_TYPE\tSATFRACT (FROM_INT_C_TYPE);\n+#endif /* FROM_TYPE == 1 && TO_TYPE == 4  */\n+\n+/* Define conversions from unsigned integer to fixed-point.  */\n+#if FROM_TYPE == 2 && TO_TYPE == 4\n+\n+#if FROM_INT_SIZE > TO_FIXED_SIZE\n+#define BIG_SINT_C_TYPE\tFROM_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tFROM_UINT_C_TYPE\n+#define BIG_WIDTH\tFROM_INT_WIDTH\n+#else\n+#define BIG_SINT_C_TYPE\tTO_SINT_C_TYPE\n+#define BIG_UINT_C_TYPE\tTO_UINT_C_TYPE\n+#define BIG_WIDTH\tTO_FIXED_WIDTH\n+#endif\n+\n+#define FRACTUNS\tFRACTUNS_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#define SATFRACTUNS\tSATFRACTUNS_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_FIXED_C_TYPE\tFRACTUNS (FROM_INT_C_TYPE);\n+extern TO_FIXED_C_TYPE\tSATFRACTUNS (FROM_INT_C_TYPE);\n+#endif /* FROM_TYPE == 2 && TO_TYPE == 4  */\n+\n+/* Define conversions from floating-point to fixed-point.  */\n+#if FROM_TYPE == 3 && TO_TYPE == 4\n+\n+#define BASE1(NUM)\t(0x1.0p ## NUM)\n+#define BASE2(NUM)\tBASE1(NUM)\n+#define BASE\t\tBASE2(TO_FBITS)\n+\n+#define FIXED_MAX1(NUM1,NUM2)\t(0x1.0p ## NUM1 - 0x1.0p- ## NUM2)\n+#define FIXED_MAX2(NUM1,NUM2)\tFIXED_MAX1(NUM1,NUM2)\n+#define FIXED_MAX\tFIXED_MAX2(TO_IBITS,TO_FBITS)\n+\n+#define FIXED_MIN1(NUM)\t(-0x1.0p ## NUM)\n+#define FIXED_MIN2(NUM)\tFIXED_MIN1(NUM)\n+#if TO_MODE_UNSIGNED == 0\n+#define FIXED_MIN\tFIXED_MIN2(TO_IBITS)\n+#else\n+#define FIXED_MIN\t0.0\n+#endif\n+\n+#define FRACT\t\tFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+#define SATFRACT\tSATFRACT_TEMP(FROM_MODE_NAME_S,TO_MODE_NAME_S)\n+extern TO_FIXED_C_TYPE\tFRACT (FROM_FLOAT_C_TYPE);\n+extern TO_FIXED_C_TYPE\tSATFRACT (FROM_FLOAT_C_TYPE);\n+#endif /* FROM_TYPE == 3 && TO_TYPE == 4  */\n+\n+#endif /* defined (FROM_MODE_NAME_S) && defined (TO_MODE_NAME_S)  */\n+\n+#endif  /* _FIXED_BIT_H */"}, {"sha": "b274965dbba99a26b143ade4ce0dddf7460785df", "filename": "gcc/doc/libgcc.texi", "status": "modified", "additions": 1425, "deletions": 2, "changes": 1427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fdoc%2Flibgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9/gcc%2Fdoc%2Flibgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flibgcc.texi?ref=154e4a0a8d367972b61eb3fd96cc8e4bb7572ea9"}]}