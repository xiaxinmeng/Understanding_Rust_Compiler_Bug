{"sha": "30d55936c5231f0e15104492cd979cc2ff84e0d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkNTU5MzZjNTIzMWYwZTE1MTA0NDkyY2Q5NzljYzJmZjg0ZTBkNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-01T08:55:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-01T08:55:04Z"}, "message": "tree-loop-distribution.c (enum partition_kind): New enum.\n\n2012-06-01  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (enum partition_kind): New enum.\n\t(struct partition_s): Add kind and main_stmt members.\n\t(partition_alloc): Initialize kind to PKIND_NORMAL.\n\t(partition_builtin_p): New function.\n\t(copy_loop_before): Remove failure path and assert instead.\n\t(generate_loops_for_partition): Likewise.\n\t(generate_memset_zero): Fold into ...\n\t(generate_memset_builtin): ... this.\n\t(classify_partition): New function with code from\n\tcan_generate_builtin and generate_builtin.\n\t(generate_builtin): Remove.\n\t(can_generate_builtin): Likewise.\n\t(fuse_partitions_with_similar_memory_accesses): Call\n\tpartition_builtin_p instead of can_generate_builtin.\n\t(rdg_build_partitions): Do not call\n\tfuse_partitions_with_similar_memory_accesses here...\n\t(ldist_gen): ... but here after classifying all partitions.\n\tRemove failure path of generate_code_for_partition.\n\t(generate_code_for_partition): Generate code according\n\tto partition classification.\n\nFrom-SVN: r188104", "tree": {"sha": "07d4b03d8e187ce6dbe5508022b4bcd63398bfaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07d4b03d8e187ce6dbe5508022b4bcd63398bfaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30d55936c5231f0e15104492cd979cc2ff84e0d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d55936c5231f0e15104492cd979cc2ff84e0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d55936c5231f0e15104492cd979cc2ff84e0d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d55936c5231f0e15104492cd979cc2ff84e0d4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3a43311c13fb31610cdc82f8600dd0c254169c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a43311c13fb31610cdc82f8600dd0c254169c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a43311c13fb31610cdc82f8600dd0c254169c9"}], "stats": {"total": 306, "additions": 163, "deletions": 143}, "files": [{"sha": "c7a656516d10b469f41caad1c318cff3f966f298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d55936c5231f0e15104492cd979cc2ff84e0d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d55936c5231f0e15104492cd979cc2ff84e0d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30d55936c5231f0e15104492cd979cc2ff84e0d4", "patch": "@@ -1,3 +1,26 @@\n+2012-06-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (enum partition_kind): New enum.\n+\t(struct partition_s): Add kind and main_stmt members.\n+\t(partition_alloc): Initialize kind to PKIND_NORMAL.\n+\t(partition_builtin_p): New function.\n+\t(copy_loop_before): Remove failure path and assert instead.\n+\t(generate_loops_for_partition): Likewise.\n+\t(generate_memset_zero): Fold into ...\n+\t(generate_memset_builtin): ... this.\n+\t(classify_partition): New function with code from\n+\tcan_generate_builtin and generate_builtin.\n+\t(generate_builtin): Remove.\n+\t(can_generate_builtin): Likewise.\n+\t(fuse_partitions_with_similar_memory_accesses): Call\n+\tpartition_builtin_p instead of can_generate_builtin.\n+\t(rdg_build_partitions): Do not call\n+\tfuse_partitions_with_similar_memory_accesses here...\n+\t(ldist_gen): ... but here after classifying all partitions.\n+\tRemove failure path of generate_code_for_partition.\n+\t(generate_code_for_partition): Generate code according\n+\tto partition classification.\n+\n 2012-06-01  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n             Jonathan Wakely  <jwakely.gcc@gmail.com>\n "}, {"sha": "84a871736fb6b706484be66d2a602047ba3864ca", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 140, "deletions": 143, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d55936c5231f0e15104492cd979cc2ff84e0d4/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d55936c5231f0e15104492cd979cc2ff84e0d4/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=30d55936c5231f0e15104492cd979cc2ff84e0d4", "patch": "@@ -52,9 +52,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n \n+enum partition_kind { PKIND_NORMAL, PKIND_MEMSET };\n+\n typedef struct partition_s\n {\n   bitmap stmts;\n+  enum partition_kind kind;\n+  /* Main statement a kind != PKIND_NORMAL partition is about.  */\n+  gimple main_stmt;\n } *partition_t;\n \n DEF_VEC_P (partition_t);\n@@ -67,6 +72,7 @@ partition_alloc (bitmap stmts)\n {\n   partition_t partition = XCNEW (struct partition_s);\n   partition->stmts = stmts ? stmts : BITMAP_ALLOC (NULL);\n+  partition->kind = PKIND_NORMAL;\n   return partition;\n }\n \n@@ -79,6 +85,13 @@ partition_free (partition_t partition)\n   free (partition);\n }\n \n+/* Returns true if the partition can be generated as a builtin.  */\n+\n+static bool\n+partition_builtin_p (partition_t partition)\n+{\n+  return partition->kind != PKIND_NORMAL;\n+}\n \n /* If bit I is not set, it means that this node represents an\n    operation that has already been performed, and that should not be\n@@ -183,16 +196,11 @@ copy_loop_before (struct loop *loop)\n   struct loop *res;\n   edge preheader = loop_preheader_edge (loop);\n \n-  if (!single_exit (loop))\n-    return NULL;\n-\n   initialize_original_copy_tables ();\n   res = slpeel_tree_duplicate_loop_to_edge_cfg (loop, preheader);\n+  gcc_assert (res != NULL);\n   free_original_copy_tables ();\n \n-  if (!res)\n-    return NULL;\n-\n   update_phis_for_loop_copy (loop, res);\n   rename_variables_in_loop (res);\n \n@@ -216,10 +224,9 @@ create_bb_after_loop (struct loop *loop)\n    copied when COPY_P is true.  All the statements not flagged in the\n    PARTITION bitmap are removed from the loop or from its copy.  The\n    statements are indexed in sequence inside a basic block, and the\n-   basic blocks of a loop are taken in dom order.  Returns true when\n-   the code gen succeeded. */\n+   basic blocks of a loop are taken in dom order.  */\n \n-static bool\n+static void\n generate_loops_for_partition (struct loop *loop, partition_t partition,\n \t\t\t      bool copy_p)\n {\n@@ -230,13 +237,11 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n   if (copy_p)\n     {\n       loop = copy_loop_before (loop);\n+      gcc_assert (loop != NULL);\n       create_preheader (loop, CP_SIMPLE_PREHEADERS);\n       create_bb_after_loop (loop);\n     }\n \n-  if (loop == NULL)\n-    return false;\n-\n   /* Remove stmts not in the PARTITION bitmap.  The order in which we\n      visit the phi nodes and the statements is exactly as in\n      stmts_from_loop.  */\n@@ -293,7 +298,6 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n     }\n \n   free (bbs);\n-  return true;\n }\n \n /* Build the size argument for a memset call.  */\n@@ -313,19 +317,29 @@ build_size_arg_loc (location_t loc, tree nb_iter, tree op,\n   return x;\n }\n \n-/* Generate a call to memset.  Return true when the operation succeeded.  */\n+/* Generate a call to memset for PARTITION in LOOP.  */\n \n static void\n-generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n-\t\t      gimple_stmt_iterator bsi)\n+generate_memset_builtin (struct loop *loop, partition_t partition)\n {\n-  tree addr_base, nb_bytes;\n-  bool res = false;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt, fn_call;\n+  tree op0, nb_iter, mem, fn, addr_base, nb_bytes;\n   gimple_seq stmt_list = NULL, stmts;\n-  gimple fn_call;\n-  tree mem, fn;\n   struct data_reference *dr = XCNEW (struct data_reference);\n-  location_t loc = gimple_location (stmt);\n+  location_t loc;\n+  bool res;\n+\n+  stmt = partition->main_stmt;\n+  loc = gimple_location (stmt);\n+  op0 = gimple_assign_lhs (stmt);\n+  if (gimple_bb (stmt) == loop->latch)\n+    nb_iter = number_of_latch_executions (loop);\n+  else\n+    nb_iter = number_of_exit_cond_executions (loop);\n+\n+  /* The new statements will be placed before LOOP.  */\n+  gsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n \n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = op0;\n@@ -353,121 +367,64 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   fn = build_fold_addr_expr (builtin_decl_implicit (BUILT_IN_MEMSET));\n   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);\n   gimple_seq_add_stmt (&stmt_list, fn_call);\n-  gsi_insert_seq_after (&bsi, stmt_list, GSI_CONTINUE_LINKING);\n+  gsi_insert_seq_after (&gsi, stmt_list, GSI_CONTINUE_LINKING);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"generated memset zero\\n\");\n \n   free_data_ref (dr);\n }\n \n-/* Tries to generate a builtin function for the instructions of LOOP\n-   pointed to by the bits set in PARTITION.  Returns true when the\n-   operation succeeded.  */\n+/* Remove and destroy the loop LOOP.  */\n \n-static bool\n-generate_builtin (struct loop *loop, partition_t partition, bool copy_p)\n+static void\n+destroy_loop (struct loop *loop)\n {\n-  bool res = false;\n-  unsigned i, x = 0;\n+  unsigned nbbs = loop->num_nodes;\n+  edge exit = single_exit (loop);\n+  basic_block src = loop_preheader_edge (loop)->src, dest = exit->dest;\n   basic_block *bbs;\n-  gimple write = NULL;\n-  gimple_stmt_iterator bsi;\n-  tree nb_iter = number_of_exit_cond_executions (loop);\n-\n-  if (!nb_iter || nb_iter == chrec_dont_know)\n-    return false;\n+  unsigned i;\n \n   bbs = get_loop_body_in_dom_order (loop);\n \n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = bbs[i];\n-\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tx++;\n-\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (bsi);\n-\n-\t  if (gimple_code (stmt) == GIMPLE_LABEL\n-\t      || is_gimple_debug (stmt))\n-\t    continue;\n-\n-\t  if (!bitmap_bit_p (partition->stmts, x++))\n-\t    continue;\n-\n-\t  /* If the stmt has uses outside of the loop fail.\n-\t     ???  If the stmt is generated in another partition that\n-\t     is not created as builtin we can ignore this.  */\n-\t  if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"not generating builtin, partition has \"\n-\t\t\t \"scalar uses outside of the loop\\n\");\n-\t      goto end;\n-\t    }\n-\n-\t  if (is_gimple_assign (stmt)\n-\t      && !is_gimple_reg (gimple_assign_lhs (stmt)))\n-\t    {\n-\t      /* Don't generate the builtins when there are more than\n-\t\t one memory write.  */\n-\t      if (write != NULL)\n-\t\tgoto end;\n-\n-\t      write = stmt;\n-\t      if (bb == loop->latch)\n-\t\tnb_iter = number_of_latch_executions (loop);\n-\t    }\n-\t}\n-    }\n-\n-  if (!stmt_with_adjacent_zero_store_dr_p (write))\n-    goto end;\n-\n-  /* The new statements will be placed before LOOP.  */\n-  bsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n-  generate_memset_zero (write, gimple_assign_lhs (write), nb_iter, bsi);\n-  res = true;\n-\n-  /* If this is the last partition for which we generate code, we have\n-     to destroy the loop.  */\n-  if (!copy_p)\n-    {\n-      unsigned nbbs = loop->num_nodes;\n-      edge exit = single_exit (loop);\n-      basic_block src = loop_preheader_edge (loop)->src, dest = exit->dest;\n-      redirect_edge_pred (exit, src);\n-      exit->flags &= ~(EDGE_TRUE_VALUE|EDGE_FALSE_VALUE);\n-      exit->flags |= EDGE_FALLTHRU;\n-      cancel_loop_tree (loop);\n-      rescan_loop_exit (exit, false, true);\n-\n-      for (i = 0; i < nbbs; i++)\n-\tdelete_basic_block (bbs[i]);\n-\n-      set_immediate_dominator (CDI_DOMINATORS, dest,\n-\t\t\t       recompute_dominator (CDI_DOMINATORS, dest));\n-    }\n+  redirect_edge_pred (exit, src);\n+  exit->flags &= ~(EDGE_TRUE_VALUE|EDGE_FALSE_VALUE);\n+  exit->flags |= EDGE_FALLTHRU;\n+  cancel_loop_tree (loop);\n+  rescan_loop_exit (exit, false, true);\n \n- end:\n+  for (i = 0; i < nbbs; i++)\n+    delete_basic_block (bbs[i]);\n   free (bbs);\n-  return res;\n+\n+  set_immediate_dominator (CDI_DOMINATORS, dest,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, dest));\n }\n \n-/* Generates code for PARTITION.  For simple loops, this function can\n-   generate a built-in.  */\n+/* Generates code for PARTITION.  */\n \n-static bool\n+static void\n generate_code_for_partition (struct loop *loop, partition_t partition,\n \t\t\t     bool copy_p)\n {\n-  if (generate_builtin (loop, partition, copy_p))\n-    return true;\n-\n-  return generate_loops_for_partition (loop, partition, copy_p);\n+  switch (partition->kind)\n+    {\n+    case PKIND_MEMSET:\n+      generate_memset_builtin (loop, partition);\n+      /* If this is the last partition for which we generate code, we have\n+\t to destroy the loop.  */\n+      if (!copy_p)\n+\tdestroy_loop (loop);\n+      break;\n+\n+    case PKIND_NORMAL:\n+      generate_loops_for_partition (loop, partition, copy_p);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n \n@@ -828,32 +785,71 @@ rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices,\n   BITMAP_FREE (saved_components);\n }\n \n-/* Returns true when it is possible to generate a builtin pattern for\n-   the PARTITION of RDG.  For the moment we detect only the memset\n-   zero pattern.  */\n+/* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n+   For the moment we detect only the memset zero pattern.  */\n \n-static bool\n-can_generate_builtin (struct graph *rdg, partition_t partition)\n+static void\n+classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n {\n-  unsigned i;\n   bitmap_iterator bi;\n-  int nb_reads = 0;\n-  int nb_writes = 0;\n-  int stores_zero = 0;\n+  unsigned i;\n+  tree nb_iter;\n+\n+  partition->kind = PKIND_NORMAL;\n+  partition->main_stmt = NULL;\n+\n+  /* Perform general partition disqualification for builtins.  */\n+  nb_iter = number_of_exit_cond_executions (loop);\n+  if (!nb_iter || nb_iter == chrec_dont_know)\n+    return;\n \n   EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n-    if (RDG_MEM_READS_STMT (rdg, i))\n-      nb_reads++;\n-    else if (RDG_MEM_WRITE_STMT (rdg, i))\n-      {\n-\tgimple stmt = RDG_STMT (rdg, i);\n-\tnb_writes++;\n-\tif (!gimple_has_volatile_ops (stmt)\n-\t    && stmt_with_adjacent_zero_store_dr_p (stmt))\n-\t  stores_zero++;\n-      }\n+    {\n+      gimple stmt = RDG_STMT (rdg, i);\n+\n+      if (gimple_has_volatile_ops (stmt))\n+\treturn;\n \n-  return stores_zero == 1 && nb_writes == 1 && nb_reads == 0;\n+      /* If the stmt has uses outside of the loop fail.\n+\t ???  If the stmt is generated in another partition that\n+\t is not created as builtin we can ignore this.  */\n+      if (gimple_code (stmt) != GIMPLE_PHI\n+\t  && stmt_has_scalar_dependences_outside_loop (loop, stmt))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"not generating builtin, partition has \"\n+\t\t     \"scalar uses outside of the loop\\n\");\n+\t  return;\n+\t}\n+    }\n+\n+  /* Detect memset.  */\n+  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n+    {\n+      gimple stmt = RDG_STMT (rdg, i);\n+\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tcontinue;\n+\n+      /* Any scalar stmts are ok.  */\n+      if (!gimple_vuse (stmt))\n+\tcontinue;\n+\n+      /* Exactly one store.  */\n+      if (gimple_assign_single_p (stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (stmt)))\n+\t{\n+\t  if (partition->main_stmt != NULL)\n+\t    return;\n+\t  partition->main_stmt = stmt;\n+\t}\n+      else\n+\treturn;\n+    }\n+\n+  if (partition->main_stmt != NULL\n+      && stmt_with_adjacent_zero_store_dr_p (partition->main_stmt))\n+    partition->kind = PKIND_MEMSET;\n }\n \n /* Returns true when PARTITION1 and PARTITION2 have similar memory\n@@ -891,10 +887,10 @@ fuse_partitions_with_similar_memory_accesses (struct graph *rdg,\n   partition_t partition1, partition2;\n \n   FOR_EACH_VEC_ELT (partition_t, *partitions, p1, partition1)\n-    if (!can_generate_builtin (rdg, partition1))\n+    if (!partition_builtin_p (partition1))\n       FOR_EACH_VEC_ELT (partition_t, *partitions, p2, partition2)\n \tif (p1 != p2\n-\t    && !can_generate_builtin (rdg, partition2)\n+\t    && !partition_builtin_p (partition2)\n \t    && similar_memory_accesses (rdg, partition1, partition2))\n \t  {\n \t    bitmap_ior_into (partition1->stmts, partition2->stmts);\n@@ -971,8 +967,6 @@ rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n     VEC_safe_push (partition_t, heap, *partitions, partition);\n   else\n     partition_free (partition);\n-\n-  fuse_partitions_with_similar_memory_accesses (rdg, partitions);\n }\n \n /* Dump to FILE the PARTITIONS.  */\n@@ -1101,11 +1095,15 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t\t\tprocessed);\n   BITMAP_FREE (processed);\n \n+  FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n+    classify_partition (loop, rdg, partition);\n+\n+  fuse_partitions_with_similar_memory_accesses (rdg, &partitions);\n+\n   nbp = VEC_length (partition_t, partitions);\n   if (nbp == 0\n       || (nbp == 1\n-\t  && !can_generate_builtin (rdg,\n-\t\t\t\t    VEC_index (partition_t, partitions, 0)))\n+\t  && !partition_builtin_p (VEC_index (partition_t, partitions, 0)))\n       || (nbp > 1\n \t  && partition_contains_all_rw (rdg, partitions)))\n     goto ldist_done;\n@@ -1114,8 +1112,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n     dump_rdg_partitions (dump_file, partitions);\n \n   FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n-    if (!generate_code_for_partition (loop, partition, i < nbp - 1))\n-      goto ldist_done;\n+    generate_code_for_partition (loop, partition, i < nbp - 1);\n \n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   mark_sym_for_renaming (gimple_vop (cfun));"}]}