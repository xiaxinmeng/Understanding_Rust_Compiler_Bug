{"sha": "ff596ca15ca105fc571e95cdf35c074cb4f011d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY1OTZjYTE1Y2ExMDVmYzU3MWU5NWNkZjM1YzA3NGNiNGYwMTFkNA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-09-04T08:03:01Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-09-04T08:03:01Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.c (prepare_cbranch_operands): Pull out comparison\n\tcanonicalization code into...\n\t* (sh_canonicalize_comparison): This new function.\n\t* config/sh/sh-protos.h: Declare it.\n\t* config/sh/sh.h: Use it in new macro CANONICALIZE_COMPARISON.\n\t* config/sh/sh.md (cbranchsi4): Remove TARGET_CBRANCHDI4 check and\n\talways invoke expand_cbranchsi4.\n\nFrom-SVN: r190909", "tree": {"sha": "c07fbfdbec90f271f3495e4f0de1a986ff16687d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c07fbfdbec90f271f3495e4f0de1a986ff16687d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff596ca15ca105fc571e95cdf35c074cb4f011d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff596ca15ca105fc571e95cdf35c074cb4f011d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff596ca15ca105fc571e95cdf35c074cb4f011d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff596ca15ca105fc571e95cdf35c074cb4f011d4/comments", "author": null, "committer": null, "parents": [{"sha": "8945d42254c782529c006f7691d5bdc01fa90231", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8945d42254c782529c006f7691d5bdc01fa90231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8945d42254c782529c006f7691d5bdc01fa90231"}], "stats": {"total": 183, "additions": 131, "deletions": 52}, "files": [{"sha": "059967a8c3b7a83f1f2377b8237cbf538216317e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff596ca15ca105fc571e95cdf35c074cb4f011d4", "patch": "@@ -1,3 +1,14 @@\n+2012-09-04  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.c (prepare_cbranch_operands): Pull out comparison\n+\tcanonicalization code into...\n+\t* (sh_canonicalize_comparison): This new function.\n+\t* config/sh/sh-protos.h: Declare it.\n+\t* config/sh/sh.h: Use it in new macro CANONICALIZE_COMPARISON.\n+\t* config/sh/sh.md (cbranchsi4): Remove TARGET_CBRANCHDI4 check and\n+\talways invoke expand_cbranchsi4.\n+\n 2012-09-03  Andi Kleen <ak@linux.intel.com>\n \n \t* tree-ssa-sccvn.c (vn_reference_fold_indirect): Initialize"}, {"sha": "2bb318b1bc32fb205071d4819eda0617f6a5aee4", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=ff596ca15ca105fc571e95cdf35c074cb4f011d4", "patch": "@@ -106,6 +106,9 @@ extern bool sh_expand_t_scc (rtx *);\n extern rtx sh_gen_truncate (enum machine_mode, rtx, int);\n extern bool sh_vector_mode_supported_p (enum machine_mode);\n extern bool sh_cfun_trap_exit_p (void);\n+extern void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n+\t\t\t\t\tenum machine_mode mode = VOIDmode);\n+\n #endif /* RTX_CODE */\n \n extern const char *output_jump_label_table (void);"}, {"sha": "5055d1ff929e5272cff827013f7145e972bdb97f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 111, "deletions": 49, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ff596ca15ca105fc571e95cdf35c074cb4f011d4", "patch": "@@ -21,6 +21,12 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* FIXME: This is a temporary hack, so that we can include <algorithm>\n+   below.  <algorithm> will try to include <cstdlib> which will reference\n+   malloc & co, which are poisoned by \"system.h\".  The proper solution is\n+   to include <cstdlib> in \"system.h\" instead of <stdlib.h>.  */\n+#include <cstdlib>\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -56,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm-constrs.h\"\n #include \"opts.h\"\n \n+#include <algorithm>\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -1791,65 +1798,124 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n     }\n }\n \n-enum rtx_code\n-prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n-\t\t\t  enum rtx_code comparison)\n+/* Implement the CANONICALIZE_COMPARISON macro for the combine pass.\n+   This function is also re-used to canonicalize comparisons in cbranch\n+   pattern expanders.  */\n+void\n+sh_canonicalize_comparison (enum rtx_code& cmp, rtx& op0, rtx& op1,\n+\t\t\t    enum machine_mode mode)\n {\n-  rtx op1;\n-  rtx scratch = NULL_RTX;\n+  /* When invoked from within the combine pass the mode is not specified,\n+     so try to get it from one of the operands.  */\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op1);\n \n-  if (comparison == LAST_AND_UNUSED_RTX_CODE)\n-    comparison = GET_CODE (operands[0]);\n-  else\n-    scratch = operands[4];\n-  if (CONST_INT_P (operands[1])\n-      && !CONST_INT_P (operands[2]))\n-    {\n-      rtx tmp = operands[1];\n+  // We need to have a mode to do something useful here.\n+  if (mode == VOIDmode)\n+    return;\n+\n+  // Currently, we don't deal with floats here.\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return;\n \n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-      comparison = swap_condition (comparison);\n+  // Make sure that the constant operand is the second operand.\n+  if (CONST_INT_P (op0) && !CONST_INT_P (op1))\n+    {\n+      std::swap (op0, op1);\n+      cmp = swap_condition (cmp);\n     }\n-  if (CONST_INT_P (operands[2]))\n+\n+  if (CONST_INT_P (op1))\n     {\n-      HOST_WIDE_INT val = INTVAL (operands[2]);\n-      if ((val == -1 || val == -0x81)\n-\t  && (comparison == GT || comparison == LE))\n+      /* Try to adjust the constant operand in such a way that available\n+         comparison insns can be utilized better and the constant can be\n+         loaded with a 'mov #imm,Rm' insn.  This avoids a load from the\n+         constant pool.  */\n+      const HOST_WIDE_INT val = INTVAL (op1);\n+\n+      /* x > -1\t\t  --> x >= 0\n+\t x > 0xFFFFFF7F\t  --> x >= 0xFFFFFF80\n+\t x <= -1\t  --> x < 0\n+\t x <= 0xFFFFFF7F  --> x < 0xFFFFFF80  */\n+      if ((val == -1 || val == -0x81) && (cmp == GT || cmp == LE))\n+\t{\n+\t  cmp = cmp == GT ? GE : LT;\n+\t  op1 = gen_int_mode (val + 1, mode);\n+        }\n+\n+      /* x >= 1     --> x > 0\n+\t x >= 0x80  --> x > 0x7F\n+\t x < 1      --> x <= 0\n+\t x < 0x80   --> x <= 0x7F  */\n+      else if ((val == 1 || val == 0x80) && (cmp == GE || cmp == LT))\n \t{\n-\t  comparison = (comparison == GT) ? GE : LT;\n-\t  operands[2] = gen_int_mode (val + 1, mode);\n+\t  cmp = cmp == GE ? GT : LE;\n+\t  op1 = gen_int_mode (val - 1, mode);\n \t}\n-      else if ((val == 1 || val == 0x80)\n-\t       && (comparison == GE || comparison == LT))\n+\n+      /* unsigned x >= 1  --> x != 0\n+\t unsigned x < 1   --> x == 0  */\n+      else if (val == 1 && (cmp == GEU || cmp == LTU))\n \t{\n-\t  comparison = (comparison == GE) ? GT : LE;\n-\t  operands[2] = gen_int_mode (val - 1, mode);\n+\t  cmp = cmp == GEU ? NE : EQ;\n+\t  op1 = CONST0_RTX (mode);\n \t}\n-      else if (val == 1 && (comparison == GEU || comparison == LTU))\n+\n+      /* unsigned x >= 0x80  --> unsigned x > 0x7F\n+\t unsigned x < 0x80   --> unsigned x < 0x7F  */\n+      else if (val == 0x80 && (cmp == GEU || cmp == LTU))\n \t{\n-\t  comparison = (comparison == GEU) ? NE : EQ;\n-\t  operands[2] = CONST0_RTX (mode);\n+\t  cmp = cmp == GEU ? GTU : LEU;\n+\t  op1 = gen_int_mode (val - 1, mode);\n \t}\n-      else if (val == 0x80 && (comparison == GEU || comparison == LTU))\n+\n+      /* unsigned x > 0   --> x != 0\n+\t unsigned x <= 0  --> x == 0  */\n+      else if (val == 0 && (cmp == GTU || cmp == LEU))\n+\tcmp = cmp == GTU ? NE : EQ;\n+\n+      /* unsigned x > 0x7FFFFFFF   --> signed x < 0\n+\t unsigned x <= 0x7FFFFFFF  --> signed x >= 0  */\n+      else if (mode == SImode && (cmp == GTU || cmp == LEU)\n+\t       && val == 0x7FFFFFFF)\n \t{\n-\t  comparison = (comparison == GEU) ? GTU : LEU;\n-\t  operands[2] = gen_int_mode (val - 1, mode);\n+\t  cmp = cmp == GTU ? LT : GE;\n+\t  op1 = const0_rtx;\n \t}\n-      else if (val == 0 && (comparison == GTU || comparison == LEU))\n-\tcomparison = (comparison == GTU) ? NE : EQ;\n-      else if (mode == SImode\n-\t       && ((val == 0x7fffffff\n-\t\t    && (comparison == GTU || comparison == LEU))\n-\t\t   || ((unsigned HOST_WIDE_INT) val\n-\t\t\t== (unsigned HOST_WIDE_INT) 0x7fffffff + 1\n-\t\t       && (comparison == GEU || comparison == LTU))))\n+\n+      /* unsigned x >= 0x80000000  --> signed x < 0\n+\t unsigned x < 0x80000000   --> signed x >= 0  */\n+      else if (mode == SImode && (cmp == GEU || cmp == LTU)\n+\t       && (unsigned HOST_WIDE_INT)val\n+\t\t   == ((unsigned HOST_WIDE_INT)0x7FFFFFFF + 1))\n \t{\n-\t  comparison = (comparison == GTU || comparison == GEU) ? LT : GE;\n-\t  operands[2] = CONST0_RTX (mode);\n+\t  cmp = cmp == GEU ? LT : GE;\n+\t  op1 = const0_rtx;\n \t}\n     }\n-  op1 = operands[1];\n+}\n+\n+enum rtx_code\n+prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n+\t\t\t  enum rtx_code comparison)\n+{\n+  /* The scratch reg is only available when this is invoked from within\n+     the cbranchdi4_i splitter, through expand_cbranchdi4.  */\n+  rtx scratch = NULL_RTX;\n+\n+  if (comparison == LAST_AND_UNUSED_RTX_CODE)\n+    comparison = GET_CODE (operands[0]);\n+  else\n+    scratch = operands[4];\n+\n+  sh_canonicalize_comparison (comparison, operands[1], operands[2], mode);\n+\n+  /* Notice that this function is also invoked after reload by\n+     the cbranchdi4_i pattern, through expand_cbranchdi4.  */\n+  rtx op1 = operands[1];\n+\n   if (can_create_pseudo_p ())\n     operands[1] = force_reg (mode, op1);\n   /* When we are handling DImode comparisons, we want to keep constants so\n@@ -1883,8 +1949,6 @@ void\n expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n {\n   rtx (*branch_expander) (rtx, rtx) = gen_branch_true;\n-  rtx jump;\n-\n   comparison = prepare_cbranch_operands (operands, SImode, comparison);\n   switch (comparison)\n     {\n@@ -1896,10 +1960,9 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n   emit_insn (gen_rtx_SET (VOIDmode, get_t_reg_rtx (),\n                           gen_rtx_fmt_ee (comparison, SImode,\n                                           operands[1], operands[2])));\n-  jump = emit_jump_insn (branch_expander (operands[3], get_t_reg_rtx ()));\n+  rtx jump = emit_jump_insn (branch_expander (operands[3], get_t_reg_rtx ()));\n   if (probability >= 0)\n     add_reg_note (jump, REG_BR_PROB, GEN_INT (probability));\n-\n }\n \n /* ??? How should we distribute probabilities when more than one branch\n@@ -1956,8 +2019,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n       lsw_taken = EQ;\n       if (prob >= 0)\n \t{\n-\t  /* If we had more precision, we'd use rev_prob - (rev_prob >> 32) .\n-\t   */\n+\t  // If we had more precision, we'd use rev_prob - (rev_prob >> 32) .\n \t  msw_skip_prob = rev_prob;\n \t  if (REG_BR_PROB_BASE <= 65535)\n \t    lsw_taken_prob = prob ? REG_BR_PROB_BASE : 0;"}, {"sha": "b36287276aa55043684d196b3cb9bc207b5da3c8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ff596ca15ca105fc571e95cdf35c074cb4f011d4", "patch": "@@ -1946,6 +1946,10 @@ struct sh_args {\n    leave this zero for correct SH3 code.  */\n #define SHIFT_COUNT_TRUNCATED (! TARGET_SH3 && ! TARGET_SH2A)\n \n+/* CANONICALIZE_COMPARISON macro for the combine pass.  */\n+#define CANONICALIZE_COMPARISON(CODE, OP0, OP1) \\\n+  sh_canonicalize_comparison ((CODE), (OP0), (OP1))\n+\n /* All integers have the same format so truncation is easy.  */\n /* But SHmedia must sign-extend DImode when truncating to SImode.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC) \\"}, {"sha": "8b44fbda49655447ed82f695e0249bfe97f7dda2", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff596ca15ca105fc571e95cdf35c074cb4f011d4/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ff596ca15ca105fc571e95cdf35c074cb4f011d4", "patch": "@@ -881,10 +881,9 @@\n   if (TARGET_SHMEDIA)\n     emit_jump_insn (gen_cbranchint4_media (operands[0], operands[1],\n \t\t\t\t\t   operands[2], operands[3]));\n-  else if (TARGET_CBRANCHDI4)\n-    expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1);\n   else\n-    sh_emit_compare_and_branch (operands, SImode);\n+    expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1);\n+\n   DONE;\n })\n "}]}