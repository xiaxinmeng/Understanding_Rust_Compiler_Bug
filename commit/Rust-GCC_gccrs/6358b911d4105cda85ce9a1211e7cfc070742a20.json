{"sha": "6358b911d4105cda85ce9a1211e7cfc070742a20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1OGI5MTFkNDEwNWNkYTg1Y2U5YTEyMTFlN2NmYzA3MDc0MmEyMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-10-18T01:40:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-10-18T01:40:57Z"}, "message": "pa.md (indexing loads and stores): Provide variants which avoid reload problems with shift-add operations.\n\n\t* pa.md (indexing loads and stores): Provide variants which avoid\n\treload problems with shift-add operations.\n\nFrom-SVN: r5793", "tree": {"sha": "95508181a611d153518545cbd264228cbf8f8a98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95508181a611d153518545cbd264228cbf8f8a98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6358b911d4105cda85ce9a1211e7cfc070742a20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6358b911d4105cda85ce9a1211e7cfc070742a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6358b911d4105cda85ce9a1211e7cfc070742a20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6358b911d4105cda85ce9a1211e7cfc070742a20/comments", "author": null, "committer": null, "parents": [{"sha": "51b8cba1261d04a4104d0a09e6b7d59c5eb5fea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b8cba1261d04a4104d0a09e6b7d59c5eb5fea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b8cba1261d04a4104d0a09e6b7d59c5eb5fea5"}], "stats": {"total": 140, "additions": 139, "deletions": 1}, "files": [{"sha": "e3bdef34d9d597de3bb3901a451c1ce3062fd969", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 139, "deletions": 1, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6358b911d4105cda85ce9a1211e7cfc070742a20/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6358b911d4105cda85ce9a1211e7cfc070742a20/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=6358b911d4105cda85ce9a1211e7cfc070742a20", "patch": "@@ -979,6 +979,27 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"&=r\")\n+\t(mem:SI (plus:SI (plus:SI \n+\t\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 4))\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\"))))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh2add %1,%2,%0\\;ldw %3(0,%0),%0\\\";\n+  else\n+    return \\\"sh2add %1,%2,%0\\;ldwx %3(0,%0),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; Load or store with base-register modification.\n \n (define_insn \"pre_ldwm\"\n@@ -1186,6 +1207,27 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(mem:HI (plus:SI (plus:SI \n+\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 2))\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\"))))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh1add %2,%1,%0\\;ldh %3(0,%0),%0\\\";\n+  else\n+    return \\\"sh1add %2,%1,%0\\;ldhx %3(0,%0),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 3 \"register_operand\" \"=r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n@@ -1380,6 +1422,30 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])\n \n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+;; Ugh. Output is a FP register; so we need to earlyclobber something\n+;; else as a temporary. \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n+\t(mem:DF (plus:SI \n+\t\t  (plus:SI \n+\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n+\t\t\t     (const_int 8))\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\"))))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh3add %1,%2,%1\\;fldds %3(0,%1),%0\\\";\n+  else\n+    return \\\"sh3add %1,%2,%1\\;flddx %3(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (mem:DF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t  (const_int 8))\n@@ -1390,6 +1456,30 @@\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"4\")])\n \n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+;; Ugh. Output is a FP register; so we need to earlyclobber something\n+;; else as a temporary. \n+(define_insn \"\"\n+  [(set (mem:DF (plus:SI \n+\t\t  (plus:SI \n+\t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n+\t\t\t      (const_int 8))\n+\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\")))\n+\t(match_operand:DF 0 \"register_operand\" \"=fx\"))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh3add %1,%2,%1\\;fstds %3(0,%1),%0\\\";\n+  else\n+    return \\\"sh3add %1,%2,%1\\;fstdx %3(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n@@ -1562,6 +1652,30 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])\n \n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+;; Ugh. Output is a FP register; so we need to earlyclobber something\n+;; else as a temporary. \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n+\t(mem:SF (plus:SI \n+\t\t  (plus:SI \n+\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n+\t\t\t     (const_int 4))\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\"))))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh2add %1,%2,%1\\;fldws %3(0,%1),%0\\\";\n+  else\n+    return \\\"sh2add %1,%2,%1\\;fldwx %3(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (mem:SF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t  (const_int 4))\n@@ -1571,6 +1685,30 @@\n   \"fstwx,s %0,%1(0,%2)\"\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"4\")])\n+\n+;; This variant of the above insn can occur if the second operand\n+;; is the frame pointer.  This is a kludge, but there doesn't\n+;; seem to be a way around it.  Only recognize it while reloading.\n+;; Ugh. Output is a FP register; so we need to earlyclobber something\n+;; else as a temporary. \n+(define_insn \"\"\n+  [(set (mem:SF (plus:SI \n+\t\t  (plus:SI \n+\t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n+\t\t\t      (const_int 4))\n+\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\")))\n+\t(match_operand:SF 0 \"register_operand\" \"=fx\"))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh2add %1,%2,%1\\;fstds %3(0,%1),%0\\\";\n+  else\n+    return \\\"sh2add %1,%2,%1\\;fstdx %3(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"8\")])\n \f\n ;;- zero extension instructions\n \n@@ -2392,7 +2530,7 @@\n \n ;; This variant of the above insn can occur if the first operand\n ;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize them while reloading.\n+;; seem to be a way around it.  Only recognize it while reloading.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")"}]}