{"sha": "9ccce9982b37580c6d1232cb6224b44c1f46a978", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNjY2U5OTgyYjM3NTgwYzZkMTIzMmNiNjIyNGI0NGMxZjQ2YTk3OA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-27T14:57:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T14:57:04Z"}, "message": "Fixed data structure for storing target data", "tree": {"sha": "b5c46f0a6d43ce5b63453488606334ee85ff1d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c46f0a6d43ce5b63453488606334ee85ff1d56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ccce9982b37580c6d1232cb6224b44c1f46a978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccce9982b37580c6d1232cb6224b44c1f46a978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccce9982b37580c6d1232cb6224b44c1f46a978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccce9982b37580c6d1232cb6224b44c1f46a978/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4080fb5dafbc26e9a5d8e924608d8a8969e33a"}], "stats": {"total": 31990, "additions": 25009, "deletions": 6981}, "files": [{"sha": "551eb63aff6058b0fa86af0dc397ddf4b1dbfb39", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -22,6 +22,9 @@\n \n # Installation name.\n \n+RSFLEXFLAGS=\n+RSBISONFLAGS=-v --debug\n+\n GCCRUST_INSTALL_NAME := $(shell echo gccrust|sed '$(program_transform_name)')\n GCCRUST_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccrust|sed '$(program_transform_name)')\n \n@@ -53,7 +56,11 @@ RUST_OBJS = \\\n \trust/rust-backend.o \\\n \trust/rust-linemap.o \\\n \trust/rust-gcc-diagnostics.o \\\n-\trust/main.o\n+\trust/rust-gcc.o \\\n+\trust/node.o \\\n+\trust/rs-parser.o \\\n+\trust/rs-lexer.o \\\n+\trust/rustly.o\n \n rust_OBJS = $(RUST_OBJS) rust/rustspec.o\n \n@@ -89,10 +96,10 @@ $(build_htmldir)/rust/index.html: $(RUST_TEXI_FILES)\n \t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n \t\t-I $(srcdir)/rust -o $(@D) $<\n \n-.INTERMEDIATE: gccrust.pod\n+# .INTERMEDIATE: gccrust.pod\n \n-gccrust.pod: rust/gccrust.texi\n-\t-$(TEXI2POD) -D gccrust < $< > $@\n+# gccrust.pod: rust/gccrust.texi\n+# \t-$(TEXI2POD) -D gccrust < $< > $@\n \n # Build hooks.\n \n@@ -110,9 +117,10 @@ rust.tags: force\n \tcd $(srcdir)/rust; \\\n \tetags -o TAGS.sub *.c *.h rustfrontend/*.h rustfrontend/*.cc; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n-rust.man: doc/gccrust.1\n-rust.srcman: doc/gccrust.1\n-\t-cp -p $^ $(srcdir)/doc\n+rust.man:\n+# rust.man: doc/gccrust.1\n+# rust.srcman: doc/gccrust.1\n+# \t-cp -p $^ $(srcdir)/doc\n \n lang_checks += check-rust\n lang_checks_parallelized += check-rust\n@@ -123,10 +131,6 @@ selftest-rust:\n \n # Install hooks.\n \n-# Install hooks.\n-\n-# Install everything that is part of the front end, apart from the compiler executables listed in \n-# compilers in config-lang.in. \n rust.install-common: installdirs\n \t-rm -f $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n \t$(INSTALL_PROGRAM) gccrust$(exeext) $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n@@ -140,44 +144,46 @@ rust.install-common: installdirs\n \t  fi; \\\n \tfi\n \n-# Install headers needed for plugins. \n rust.install-plugin:\n \n-rust.install-info: $(DESTDIR)$(infodir)/gccrust.info\n-\n-rust.install-pdf: doc/gccrust.pdf\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n-\t@for p in doc/gccrust.pdf; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=$(pdf__strip_dir) \\\n-\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n-\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n-\tdone\n-\n-rust.install-html: $(build_htmldir)/rust\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n-\t@for p in $(build_htmldir)/rust; do \\\n-\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=$(html__strip_dir) \\\n-\t  if test -d \"$$d$$p\"; then \\\n-\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  else \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  fi; \\\n-\tdone\n-\n-rust.install-man: $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n-\n-$(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext): doc/gccrust.1 installdirs\n-\t-rm -f $@\n-\t-$(INSTALL_DATA) $< $@\n-\t-chmod a-x $@\n+# rust.install-info: $(DESTDIR)$(infodir)/gccrust.info\n+rust.install-info:\n+\n+# rust.install-pdf: doc/gccrust.pdf\n+# \t@$(NORMAL_INSTALL)\n+# \ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+# \t@for p in doc/gccrust.pdf; do \\\n+# \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+# \t  f=$(pdf__strip_dir) \\\n+# \t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+# \t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+# \tdone\n+rust.install-pdf:\n+\n+# rust.install-html: $(build_htmldir)/rust\n+# \t@$(NORMAL_INSTALL)\n+# \ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n+# \t@for p in $(build_htmldir)/rust; do \\\n+# \t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n+# \t  f=$(html__strip_dir) \\\n+# \t  if test -d \"$$d$$p\"; then \\\n+# \t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+# \t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+# \t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+# \t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+# \t  else \\\n+# \t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+# \t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+# \t  fi; \\\n+# \tdone\n+\n+# rust.install-man: $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n+rust.install-man:\n+\n+# $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext): doc/gccrust.1 installdirs\n+# \t-rm -f $@\n+# \t-$(INSTALL_DATA) $< $@\n+# \t-chmod a-x $@\n \n rust.uninstall:\n \trm -rf $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n@@ -218,10 +224,23 @@ RUSTINCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/rustfrontend\n \n CFLAGS-rust/rust-gcc.o += $(RUSTINCLUDES)\n CFLAGS-rust/rust-linemap.o += $(RUSTINCLUDES)\n-CFLAGS-rust/rust-sha1.o += $(RUSTINCLUDES)\n CFLAGS-rust/rust-gcc-diagnostics.o += $(RUSTINCLUDES)\n CFLAGS-rust/rust-encode-id.o += $(RUSTINCLUDES)\n \n+rust/rs-parser.cc: rust/rustfrontend/rs-parser.y\n+\t$(BISON) $(RSBISONFLAGS) --defines=rust/rs-parser.h -o $@ $<\n+\n+rust/rs-lexer.cc: rust/rustfrontend/rs-lexer.l\n+\t$(FLEX) $(RSFLEXFLAGS) -o $@ $<\n+\n+rust/rs-parser.o: rust/rs-parser.cc\n+\t$(COMPILE) $(RUSTINCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+rust/rs-lexer.o: rust/rs-lexer.cc\n+\t$(COMPILE) $(RUSTINCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n rust/%.o: rust/rustfrontend/%.cc\n \t$(COMPILE) $(RUSTINCLUDES) $<\n \t$(POSTCOMPILE)"}, {"sha": "0fd71092fecc6a316f2288a80c1f2d6b572bebb0", "filename": "gcc/rust/config-lang.in", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fconfig-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -23,26 +23,12 @@\n #\n # language\t- name of language as it would appear in $(LANGUAGES)\n # compilers\t- value to add to $(COMPILERS)\n-# diff_excludes\t- files to ignore when building diffs between two versions.\n \n language=\"rust\"\n-\n-# Space-separated list of compiler executables that will be run by the driver. The names here will \n-# each end with \u2018\\$(exeext)\u2019. \n compilers=\"rust1\\$(exeext)\"\n \n-# Do not build by default.\n build_by_default=\"no\"\n \n-# Lists (space-separated) language front ends other than C that this front end requires to be\n-# enabled (with the names given being their language settings). \n-#lang_requires_boot_languages=c++\n-\n-# Lists (space-separated) targets in the top level Makefile to build the runtime libraries \n-# for this language, such as target-libobjc. \n target_libs=\"target-libffi target-libbacktrace\"\n \n-# Space-separated list of files that should be scanned by gengtype.c to generate the garbage \n-# collection tables and routines for this language. This excludes the files that are common to all \n-# front ends. \n gtfiles=\"\\$(srcdir)/rust/rust-lang.c \\$(srcdir)/rust/rust-c.h\""}, {"sha": "513e951f2b34cdd4d0cce83fb7fead33a0dcca63", "filename": "gcc/rust/lang-specs.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang-specs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -17,15 +17,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-// describes Rust front-end to GCC driver\n-\n-/* tells GCC to invoke Rust frontend on .rs files, gives instructions on \n-   other programs to be run, such as assembler, etc. \n-   In this, it has grs1 as the actual compiler and whatever */\n /* This is the contribution to the `default_compilers' array in gcc.c\n    for the Rust language.  */\n+\n {\".rs\",  \"@rs\", 0, 1, 0},\n {\"@rs\",  \"rust1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\",\n     0, 1, 0},\n-\n-// \"May take a while\" to write this file - refer to other language lang-specs.h\n\\ No newline at end of file"}, {"sha": "42c60933a84ea2c6025dedf532897a5b8c83ec16", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -22,8 +22,6 @@\n \n ; Please try to keep this file in ASCII collating order.\n \n-; Describes command-line options used by this frontend\n-\n Language\n Rust\n "}, {"sha": "f63afb8e707e605e441b67b4977f29afe5e051e9", "filename": "gcc/rust/old/rdot-dataflow.cc", "status": "modified", "additions": 774, "deletions": 664, "changes": 1438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-dataflow.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -16,122 +16,147 @@\n \n #include \"rust.h\"\n \n-static std::vector<std::map<std::string, rdot>*> context;\n-static rdot dot_pass_typeifyExprNode(rdot);\n-static bool dot_pass_typeCompare(const rdot, const rdot);\n+static std::vector<std::map<std::string, rdot> *> context;\n+static rdot dot_pass_typeifyExprNode (rdot);\n+static bool dot_pass_typeCompare (const rdot, const rdot);\n static rdot impl_master = NULL_DOT;\n \n-// Seems to push a new empty map onto the \"context\" vector\n-static void dot_pass_dataFlow_pushCtx(void) {\n-    std::map<std::string, rdot>* ctx = new std::map<std::string, rdot>;\n-    context.push_back(ctx);\n+static\n+void dot_pass_dataFlow_pushCtx (void)\n+{\n+  std::map<std::string, rdot> * ctx = new std::map<std::string, rdot>;\n+  context.push_back (ctx);\n }\n \n-// Seems to pop the map off of the end of the \"context\" vector (i.e. deletes it)\n-static void dot_pass_dataFlow_popCtx(void) {\n-    std::map<std::string, rdot>* ctx = context.back();\n-    context.pop_back();\n-    delete ctx;\n+static\n+void dot_pass_dataFlow_popCtx (void)\n+{\n+  std::map<std::string, rdot> * ctx = context.back ();\n+  context.pop_back ();\n+  delete ctx;\n }\n \n-// Presumably looks up id in the context map somehow, and returns the value\n-static rdot dot_pass_dataFlow_lookup(const char* id) {\n-    rdot retval = NULL_DOT;\n-    std::vector<std::map<std::string, rdot>*>::reverse_iterator it;\n-    for (it = context.rbegin(); it != context.rend(); ++it) {\n-        std::map<std::string, rdot>* ctx = *it;\n-        if (ctx->count(std::string(id))) {\n-            retval = (*ctx)[std::string(id)];\n-            break;\n+static\n+rdot dot_pass_dataFlow_lookup (const char * id)\n+{\n+  rdot retval = NULL_DOT;\n+  std::vector<std::map<std::string, rdot> *>::reverse_iterator it;\n+  for (it = context.rbegin (); it != context.rend (); ++it)\n+    {\n+      std::map<std::string, rdot> * ctx = *it;\n+      if (ctx->count (std::string (id)))\n+        {\n+          retval = (*ctx)[std::string (id)];\n+          break;\n         }\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Appends node to the back of context? Or replaces final context with node?\n-static bool dot_pass_dataFlow_pushDecl(rdot node, const char* id) {\n-    rdot check = dot_pass_dataFlow_lookup(id);\n-    if (check != NULL_DOT) {\n-        error(\"DataFlow duplicate declaration [%s]\\n\", id);\n-        return true;\n+static\n+bool dot_pass_dataFlow_pushDecl (rdot node, const char * id)\n+{\n+  rdot check = dot_pass_dataFlow_lookup (id);\n+  if (check != NULL_DOT)\n+    {\n+      error (\"DataFlow duplicate declaration [%s]\\n\", id);\n+      return true;\n     }\n \n-    bool retval = false;\n-    if ((RDOT_TYPE(node) == D_VAR_DECL) || (RDOT_TYPE(node) == D_STRUCT_METHOD) \n-      || (RDOT_TYPE(node) == D_STRUCT_TYPE)) {\n-        std::map<std::string, rdot>* ctx = context.back();\n-        (*ctx)[std::string(id)] = node;\n-    } else {\n-        error(\"Invalid dataflow declaration pushing to context [%s]\\n\",\n-              RDOT_OPCODE_STR(node));\n-        retval = true;\n+  bool retval = false;\n+  if ((RDOT_TYPE (node) == D_VAR_DECL)\n+      || (RDOT_TYPE (node) == D_STRUCT_METHOD)\n+      || (RDOT_TYPE (node) == D_STRUCT_TYPE))\n+    {\n+      std::map<std::string, rdot> * ctx = context.back ();\n+      (*ctx) [std::string (id)] = node;\n+    }\n+  else\n+    {\n+      error (\"Invalid dataflow declaration pushing to context [%s]\\n\",\n+             RDOT_OPCODE_STR (node));\n+      retval = true;\n     }\n-    return retval;\n+  return retval;\n }\n \n-static void dot_pass_dataFlowToplevel(rdot);\n-static void dot_pass_dataFlowFunction(rdot);\n-static void dot_pass_dataFlowBlock(rdot);\n-\n-// Only returns true if node's type is boolean, int, float, or unsigned int\n-static bool verifyType(rdot node) {\n-    bool retval = false;\n-    switch (RDOT_TYPE(node)) {\n-        case RTYPE_BOOL:\n-        case RTYPE_INT:\n-        case RTYPE_FLOAT:\n-        case RTYPE_UINT:\n-            retval = true;\n-            break;\n-\n-        default:\n-            break;\n+static void dot_pass_dataFlowToplevel (rdot);\n+static void dot_pass_dataFlowFunction (rdot);\n+static void dot_pass_dataFlowBlock (rdot);\n+\n+static\n+bool verifyType (rdot node)\n+{\n+  bool retval = false;\n+  switch (RDOT_TYPE (node))\n+    {\n+    case RTYPE_BOOL:\n+    case RTYPE_INT:\n+    case RTYPE_FLOAT:\n+    case RTYPE_UINT:\n+      retval = true;\n+      break;\n+        \n+    default:\n+      break;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Presumably returns the variable declaration contained in the node \n-static rdot dot_pass_dataFlow_getDecl(rdot node) {\n-    rdot retval = NULL_DOT;\n-    if (RDOT_T_FIELD(node) == D_D_EXPR) {\n-        // only if its a modify expr\n-        if (RDOT_TYPE(node) == D_MODIFY_EXPR) {\n-            rdot decl = RDOT_lhs_TT(node);\n-            if (RDOT_TYPE(decl) == D_VAR_DECL)\n-                retval = decl;\n-        } else if (RDOT_TYPE(node) == D_VAR_DECL)\n-            retval = node;\n+static\n+rdot dot_pass_dataFlow_getDecl (rdot node)\n+{\n+  rdot retval = NULL_DOT;\n+  if (RDOT_T_FIELD (node) == D_D_EXPR)\n+    {\n+      // only if its a modify expr\n+      if (RDOT_TYPE (node) == D_MODIFY_EXPR)\n+        {\n+          rdot decl = RDOT_lhs_TT (node);\n+          if (RDOT_TYPE (decl) == D_VAR_DECL)\n+            retval = decl;\n+        }\n+      else if (RDOT_TYPE (node) == D_VAR_DECL)\n+        retval = node;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to add return values to retval vector? Finds return values?\n-static void dot_pass_dataFlowBlock_retvals(rdot suite, std::vector<rdot>* retval) {\n-    rdot next;\n-    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        if (RDOT_T_FIELD(next) == D_D_EXPR) {\n-            if (DOT_RETVAL(next))\n-                retval->push_back(next);\n-        } else {\n-            switch (RDOT_TYPE(next)) {\n-                case D_STRUCT_WHILE:\n-                    dot_pass_dataFlowBlock_retvals(RDOT_rhs_TT(next), retval);\n-                    break;\n-\n-                case D_STRUCT_IF: {\n-                    rdot ifblock = RDOT_lhs_TT(next);\n-                    rdot elseblock = RDOT_rhs_TT(next);\n-                    dot_pass_dataFlowBlock_retvals(RDOT_rhs_TT(ifblock), retval);\n-                    if (elseblock != NULL_DOT)\n-                        dot_pass_dataFlowBlock_retvals(RDOT_lhs_TT(elseblock), retval);\n-                } break;\n-\n-                default:\n-                    error(\"unable to figure out what to do with [%s]\",\n-                          RDOT_OPCODE_STR(next));\n-                    break;\n-            }\n-        }\n+static\n+void dot_pass_dataFlowBlock_retvals (rdot suite, std::vector<rdot> * retval)\n+{\n+  rdot next;\n+  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      if (RDOT_T_FIELD (next) == D_D_EXPR)\n+\t{\n+\t  if (DOT_RETVAL (next))\n+\t    retval->push_back (next);\n+\t}\n+      else\n+\t{\n+\t  switch (RDOT_TYPE (next))\n+\t    {\n+\t    case D_STRUCT_WHILE:\n+\t      dot_pass_dataFlowBlock_retvals (RDOT_rhs_TT (next), retval);\n+\t      break;\n+\n+\t    case D_STRUCT_IF:\n+\t      {\n+\t\trdot ifblock = RDOT_lhs_TT (next);\n+\t\trdot elseblock = RDOT_rhs_TT (next);\n+\t\tdot_pass_dataFlowBlock_retvals (RDOT_rhs_TT (ifblock), retval);\n+\t\tif (elseblock != NULL_DOT)\n+\t\t  dot_pass_dataFlowBlock_retvals (RDOT_lhs_TT (elseblock), retval);\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      error (\"unable to figure out what to do with [%s]\",\n+\t\t     RDOT_OPCODE_STR (next));\n+\t      break;\n+\t    }\n+\t}\n     }\n }\n \n@@ -146,132 +171,155 @@ static void dot_pass_dataFlowBlock_retvals(rdot suite, std::vector<rdot>* retval\n   let x = 1;\n   ruturns RDOT (1)\n */\n-static rdot dot_pass_dataFlow_getRef(rdot decl, rdot var_decl) {\n-    rdot retval = NULL_DOT;\n-    if (RDOT_TYPE(decl) == D_MODIFY_EXPR) {\n-        rdot lhs = RDOT_lhs_TT(decl);\n-        rdot rhs = RDOT_rhs_TT(decl);\n-\n-        switch (RDOT_TYPE(lhs)) {\n-            case D_VAR_DECL: {\n-                if (var_decl == lhs)\n-                    retval = rhs;\n-            } break;\n-\n-            case D_IDENTIFIER: {\n-                const char* vid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(var_decl));\n-                const char* cid = RDOT_IDENTIFIER_POINTER(lhs);\n-                // we found a reference assignment...\n-                if (strcmp(vid, cid) == 0)\n-                    retval = rhs;\n-            } break;\n-\n-            default:\n-                break;\n+static\n+rdot dot_pass_dataFlow_getRef (rdot decl, rdot var_decl)\n+{\n+  rdot retval = NULL_DOT;\n+  if (RDOT_TYPE (decl) == D_MODIFY_EXPR)\n+    {\n+      rdot lhs = RDOT_lhs_TT (decl);\n+      rdot rhs = RDOT_rhs_TT (decl);\n+\n+      switch (RDOT_TYPE (lhs))\n+        {\n+        case D_VAR_DECL:\n+          {\n+            if (var_decl == lhs)\n+              retval = rhs;\n+          }\n+          break;\n+\n+        case D_IDENTIFIER:\n+          {\n+            const char * vid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (var_decl));\n+            const char * cid = RDOT_IDENTIFIER_POINTER (lhs);\n+            // we found a reference assignment...\n+            if (strcmp (vid, cid) == 0)\n+              retval = rhs;\n+          }\n+          break;\n+\n+        default:\n+          break;\n         }\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to be a more complicated version of getRef that can also get references in other places\n-static std::vector<rdot>* dot_pass_getReferences(rdot vDecl, rdot suite) {\n-    std::vector<rdot>* retval = new std::vector<rdot>;\n-    rdot node;\n-    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n-        switch (RDOT_TYPE(node)) {\n-            case D_PRIMITIVE:\n-            case D_CALL_EXPR:\n-            case D_ATTRIB_REF:\n-                break;\n-\n-            case D_MODIFY_EXPR: {\n-                rdot ref = dot_pass_dataFlow_getRef(node, vDecl);\n-                if (ref != NULL_DOT)\n-                    retval->push_back(ref);\n-            } break;\n-\n-            case D_STRUCT_WHILE: {\n-                rdot wsuite = RDOT_rhs_TT(node);\n-                std::vector<rdot>* refs = dot_pass_getReferences(vDecl, wsuite);\n-                // append to the list\n-                std::vector<rdot>::iterator it;\n-                for (it = refs->begin(); it != refs->end(); ++it)\n-                    retval->push_back(*it);\n-                delete refs;\n-            } break;\n-\n-            case D_STRUCT_IF: {\n-                rdot ifb = RDOT_lhs_TT(node);\n-                rdot elb = RDOT_rhs_TT(node);\n-\n-                rdot ifsuite = RDOT_rhs_TT(ifb);\n-                std::vector<rdot>* refs = dot_pass_getReferences(vDecl, ifsuite);\n-\n-                // append to the list\n-                std::vector<rdot>::iterator it;\n-                for (it = refs->begin(); it != refs->end(); ++it)\n-                    retval->push_back(*it);\n-                delete refs;\n-\n-                if (elb != NULL_DOT) {\n-                    refs = dot_pass_getReferences(vDecl, RDOT_lhs_TT(elb));\n-                    for (it = refs->begin(); it != refs->end(); ++it)\n-                        retval->push_back(*it);\n-                    delete refs;\n-                }\n-            }\n-\n-            default:\n-                break;\n-        }\n+static\n+std::vector<rdot> * dot_pass_getReferences (rdot vDecl, rdot suite)\n+{\n+  std::vector<rdot> * retval = new std::vector<rdot>;\n+  rdot node;\n+  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n+    {\n+      switch (RDOT_TYPE (node))\n+\t{\n+\tcase D_PRIMITIVE:\n+\tcase D_CALL_EXPR:\n+\tcase D_ATTRIB_REF:\n+\t  break;\n+\n+\tcase D_MODIFY_EXPR:\n+\t  {\n+\t    rdot ref = dot_pass_dataFlow_getRef (node, vDecl);\n+\t    if (ref != NULL_DOT)\n+\t      retval->push_back (ref);\n+\t  }\n+\t  break;\n+\n+\tcase D_STRUCT_WHILE:\n+\t  {\n+\t    rdot wsuite = RDOT_rhs_TT (node);\n+\t    std::vector<rdot> * refs = dot_pass_getReferences (vDecl, wsuite);\n+            // append to the list\n+\t    std::vector<rdot>::iterator it;\n+\t    for (it = refs->begin (); it != refs->end (); ++it)\n+              retval->push_back (*it);\n+\t    delete refs;\n+\t  }\n+\t  break;\n+\n+\tcase D_STRUCT_IF:\n+\t  {\n+\t    rdot ifb = RDOT_lhs_TT (node);\n+\t    rdot elb = RDOT_rhs_TT (node);\n+\n+\t    rdot ifsuite = RDOT_rhs_TT (ifb);\n+\t    std::vector<rdot> * refs = dot_pass_getReferences (vDecl, ifsuite);\n+\n+\t    // append to the list\n+\t    std::vector<rdot>::iterator it;\n+\t    for (it = refs->begin (); it != refs->end (); ++it)\n+              retval->push_back (*it);\n+\t    delete refs;\n+\n+\t    if (elb != NULL_DOT)\n+\t      {\n+\t\trefs = dot_pass_getReferences (vDecl, RDOT_lhs_TT (elb));\n+\t\tfor (it = refs->begin (); it != refs->end (); ++it)\n+\t\t  retval->push_back (*it);\n+\t\tdelete refs;\n+\t      }\n+\t  }\n+\n+\tdefault:\n+\t  break;\n+\t}\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to compare types of x and y\n-static bool dot_pass_typeCompare(const rdot x, const rdot y) {\n-    bool retval = false;\n-    if (RDOT_TYPE(x) == RDOT_TYPE(y))\n-        if (RDOT_MEM_MODIFIER(x)->size() == RDOT_MEM_MODIFIER(y)->size()) {\n-            retval = true;\n-            std::vector<ALLOCA_>::iterator xit;\n-            std::vector<ALLOCA_>::iterator yit;\n-            for (xit = RDOT_MEM_MODIFIER(x)->begin(),\n-                yit = RDOT_MEM_MODIFIER(y)->begin();\n-                 xit != RDOT_MEM_MODIFIER(x)->end();\n-                 ++xit, ++yit) {\n-                if (*xit != *yit) {\n-                    retval = false;\n-                    break;\n-                }\n-            }\n-        }\n-    return retval;\n+static bool\n+dot_pass_typeCompare (const rdot x, const rdot y)\n+{\n+  bool retval = false;\n+  if (RDOT_TYPE (x) == RDOT_TYPE (y))\n+    if (RDOT_MEM_MODIFIER (x)->size () == RDOT_MEM_MODIFIER (y)->size ())\n+      {\n+        retval = true;\n+        std::vector<ALLOCA_>::iterator xit;\n+        std::vector<ALLOCA_>::iterator yit;\n+        for (xit = RDOT_MEM_MODIFIER (x)->begin (),\n+               yit = RDOT_MEM_MODIFIER (y)->begin ();\n+             xit != RDOT_MEM_MODIFIER (x)->end ();\n+             ++xit, ++yit)\n+          {\n+            if (*xit != *yit)\n+              {\n+                retval = false;\n+                break;\n+              }\n+          }\n+      }\n+  return retval;\n }\n \n-// Seems to return a string created from allocations (dereference and reference)\n-static char* dot_pass_typeString(const rdot node) {\n-    char buffer[128];\n-    size_t offset = 0;\n-\n-    std::vector<ALLOCA_>::iterator it;\n-    for (it = RDOT_MEM_MODIFIER(node)->begin();\n-         it != RDOT_MEM_MODIFIER(node)->end();\n-         ++it) {\n-        switch (*it) {\n-            case ALLOC_DEREF:\n-                buffer[offset++] = '*';\n-                break;\n-            case ALLOC_HEAP:\n-                buffer[offset++] = '~';\n-                break;\n-            case ALLOC_REF:\n-                buffer[offset++] = '&';\n-                break;\n-        }\n+static char *\n+dot_pass_typeString (const rdot node)\n+{\n+  char buffer [128];\n+  size_t offset = 0;\n+\n+  std::vector<ALLOCA_>::iterator it;\n+  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+       it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n+    {\n+      switch (*it)\n+\t{\n+\tcase ALLOC_DEREF:\n+\t  buffer [offset++] = '*';\n+\t  break;\n+\tcase ALLOC_HEAP:\n+\t  buffer [offset++] = '~';\n+\t  break;\n+\tcase ALLOC_REF:\n+\t  buffer [offset++] = '&';\n+\t  break;\n+\t}\n     }\n-    strcpy(buffer + offset, RDOT_OPCODE_STR(node));\n-    return xstrdup(buffer);\n+  strcpy (buffer+offset, RDOT_OPCODE_STR (node));\n+  return xstrdup (buffer);\n }\n \n /**\n@@ -280,494 +328,556 @@ static char* dot_pass_typeString(const rdot node) {\n  *   infer, int, string\n  *   infer, int, infer. Does it mean its an int probably.\n  *   Currently it drops any possible type to be an int\n- * \n- * Presumably infers type of refs\n  **/\n-static rdot dot_pass_inferTheType(std::vector<rdot>* refs, const char* id) {\n-    rdot retval = NULL_DOT;\n-    rdot _retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n-    gcc_assert(refs->size() > 0);\n-\n-    std::vector<rdot> possible_types;\n-    std::vector<rdot>::iterator it;\n-    for (it = refs->begin(); it != refs->end(); ++it) {\n-        rdot pos = dot_pass_typeifyExprNode(*it);\n-        if (RDOT_TYPE(pos) != RTYPE_INFER)\n-            possible_types.push_back(pos);\n+static\n+rdot dot_pass_inferTheType (std::vector<rdot> * refs, const char * id)\n+{\n+  rdot retval = NULL_DOT;\n+  rdot _retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n+  gcc_assert (refs->size () > 0);\n+\n+  std::vector<rdot> possible_types;\n+  std::vector<rdot>::iterator it;\n+  for (it = refs->begin (); it != refs->end (); ++it)\n+    {\n+      rdot pos = dot_pass_typeifyExprNode (*it);\n+      if (RDOT_TYPE (pos) != RTYPE_INFER)\n+\tpossible_types.push_back (pos);\n     }\n \n-    if (possible_types.size() == 0)\n-        retval = _retval;\n-    else {\n-        bool first = true;\n-        std::vector<rdot>::iterator pit;\n-        for (pit = possible_types.begin(); pit != possible_types.end(); ++pit) {\n-            if (first == true) {\n-                retval = *pit;\n-                first = false;\n-            }\n-            if (!dot_pass_typeCompare(retval, *pit)) {\n-                char* t1 = dot_pass_typeString(retval);\n-                char* t2 = dot_pass_typeString(*pit);\n-                error(\"Ambigious types found for [%s] -> [%s] OR [%s]\", id, t1, t2);\n-                retval = _retval;\n-                free(t1);\n-                free(t2);\n-                break;\n-            }\n-        }\n+  if (possible_types.size () == 0)\n+    retval = _retval;\n+  else\n+    {\n+      bool first = true;\n+      std::vector<rdot>::iterator pit;\n+      for (pit = possible_types.begin (); pit != possible_types.end (); ++pit)\n+\t{\n+\t  if (first == true)\n+\t    {\n+\t      retval = *pit;\n+\t      first = false;\n+\t    }          \n+\t  if (!dot_pass_typeCompare (retval, *pit))\n+\t    {\n+              char * t1 = dot_pass_typeString (retval);\n+              char * t2 = dot_pass_typeString (*pit);\n+              error (\"Ambigious types found for [%s] -> [%s] OR [%s]\", id, t1, t2);\n+\t      retval = _retval;\n+              free (t1);\n+              free (t2);\n+\t      break;\n+\t    }\n+\t}\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to determine the type of a primitive (and apply it)?\n-static rdot dot_pass_typeifyPrimitive(rdot node) {\n-    rdot retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n-    gcc_assert(RDOT_TYPE(node) == D_PRIMITIVE);\n-\n-    switch (node->opa.tc.T == D_T_INTEGER) {\n-        case D_T_INTEGER:\n-            RDOT_TYPE(retval) = RTYPE_INT;\n-            break;\n-\n-        default:\n-            error(\"Unable to figure out type for this primitive [%s]!\",\n-                  RDOT_CODE_STR(node->opa.tc.T));\n-            break;\n+static\n+rdot dot_pass_typeifyPrimitive (rdot node)\n+{\n+  rdot retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n+  gcc_assert (RDOT_TYPE (node) == D_PRIMITIVE);\n+\n+  switch (node->opa.tc.T == D_T_INTEGER)\n+    {\n+    case D_T_INTEGER:\n+      RDOT_TYPE (retval) = RTYPE_INT;\n+      break;\n+\n+    default:\n+      error (\"Unable to figure out type for this primitive [%s]!\",\n+             RDOT_CODE_STR (node->opa.tc.T));\n+      break;\n     }\n-    std::vector<ALLOCA_>::iterator it;\n-    for (it = RDOT_MEM_MODIFIER(node)->begin();\n-         it != RDOT_MEM_MODIFIER(node)->end();\n-         ++it)\n-        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-    return retval;\n+  std::vector<ALLOCA_>::iterator it;\n+  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+       it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n+    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+  return retval;\n }\n \n-/* FIXME maybe i feel this isn't done very well at all here \n- *\n- * Seems to determine type of an expression node and return something idk, very complicated */\n-static rdot dot_pass_typeifyExprNode(rdot node) {\n-    rdot retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n-    switch (RDOT_TYPE(node)) {\n-        case D_PRIMITIVE:\n-            retval = dot_pass_typeifyPrimitive(node);\n-            break;\n-\n-        case D_IDENTIFIER: {\n-            rdot lookup = dot_pass_dataFlow_lookup(RDOT_IDENTIFIER_POINTER(node));\n-            if (lookup == NULL_DOT)\n-                error(\"unable to find declaration of [%s] in current scope\",\n-                      RDOT_IDENTIFIER_POINTER(node));\n-            else {\n-                gcc_assert(RDOT_TYPE(lookup) == D_VAR_DECL);\n-                RDOT_TYPE(retval) = RDOT_TYPE(RDOT_rhs_TT(lookup));\n-                if (RDOT_TYPE(retval) == RTYPE_USER_STRUCT) {\n-                    RDOT_lhs_TT(retval) = RDOT_lhs_TT(RDOT_rhs_TT(lookup));\n-                    RDOT_rhs_TT(retval) = RDOT_rhs_TT(RDOT_rhs_TT(lookup));\n-                }\n-                std::vector<ALLOCA_>::iterator it;\n-                if (RDOT_MEM_MODIFIER(node))\n-                    for (it = RDOT_MEM_MODIFIER(node)->begin();\n-                         it != RDOT_MEM_MODIFIER(node)->end();\n-                         ++it)\n-                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-                if (RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup)))\n-                    for (it = RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup))->begin();\n-                         it != RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup))->end();\n-                         ++it)\n-                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-            }\n-        } break;\n-\n-        case D_STRUCT_INIT: {\n-            const char* slookup = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-            rdot lookup = dot_pass_dataFlow_lookup(slookup);\n-            if (lookup != NULL_DOT) {\n-                if (RDOT_TYPE(lookup) == D_STRUCT_TYPE) {\n-                    RDOT_TYPE(retval) = RTYPE_USER_STRUCT;\n-                    RDOT_lhs_TT(retval) = RDOT_lhs_TT(lookup); // identifier node\n-                    RDOT_rhs_TT(retval) = RDOT_rhs_TT(lookup); // struct layout\n-                    std::vector<ALLOCA_>::iterator it;\n-                    if (RDOT_MEM_MODIFIER(node))\n-                        for (it = RDOT_MEM_MODIFIER(node)->begin();\n-                             it != RDOT_MEM_MODIFIER(node)->end();\n-                             ++it)\n-                            RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-                    if (RDOT_MEM_MODIFIER(lookup))\n-                        for (it = RDOT_MEM_MODIFIER(lookup)->begin();\n-                             it != RDOT_MEM_MODIFIER(lookup)->end();\n-                             ++it)\n-                            RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-                } else\n-                    error(\"unable to determine type of [%s] struct initilization, \"\n-                          \"[%s] was found in this scope\",\n-                          slookup,\n-                          RDOT_OPCODE_STR(lookup));\n-            } else\n-                error(\"[%s] does not name a type in scope\", slookup);\n-        } break;\n-\n-        case D_CALL_EXPR: {\n-            const char* callid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-            rdot lookup = dot_pass_dataFlow_lookup(callid);\n-            if (lookup != NULL_DOT) {\n-                gcc_assert(RDOT_TYPE(lookup) == D_STRUCT_METHOD);\n-                RDOT_TYPE(retval) = RDOT_TYPE(RDOT_FIELD2(lookup));\n-                std::vector<ALLOCA_>* mods = RDOT_MEM_MODIFIER(RDOT_FIELD2(lookup));\n+/* FIXME maybe i feel this isn't done very well at all here */\n+static\n+rdot dot_pass_typeifyExprNode (rdot node)\n+{\n+  rdot retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n+  switch (RDOT_TYPE (node))\n+    {\n+    case D_PRIMITIVE:\n+      retval = dot_pass_typeifyPrimitive (node);\n+      break;\n+\n+    case D_IDENTIFIER:\n+      {\n+        rdot lookup = dot_pass_dataFlow_lookup (RDOT_IDENTIFIER_POINTER (node));\n+        if (lookup == NULL_DOT)\n+          error (\"unable to find declaration of [%s] in current scope\",\n+                 RDOT_IDENTIFIER_POINTER (node));\n+        else\n+          {\n+            gcc_assert (RDOT_TYPE (lookup) == D_VAR_DECL);\n+            RDOT_TYPE (retval) = RDOT_TYPE (RDOT_rhs_TT (lookup));\n+            if (RDOT_TYPE (retval) == RTYPE_USER_STRUCT)\n+              {\n+                RDOT_lhs_TT (retval) = RDOT_lhs_TT (RDOT_rhs_TT (lookup));\n+                RDOT_rhs_TT (retval) = RDOT_rhs_TT (RDOT_rhs_TT (lookup));\n+              }\n+            std::vector<ALLOCA_>::iterator it;\n+            if (RDOT_MEM_MODIFIER (node))\n+              for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+                   it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n+                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+            if (RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup)))\n+              for (it = RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup))->begin ();\n+                   it != RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup))->end (); ++it)\n+                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+          }\n+      }\n+      break;\n+\n+    case D_STRUCT_INIT:\n+      {\n+\tconst char * slookup = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+\trdot lookup = dot_pass_dataFlow_lookup (slookup);\n+\tif (lookup != NULL_DOT)\n+\t  {\n+\t    if (RDOT_TYPE (lookup) == D_STRUCT_TYPE)\n+\t      {\n+                RDOT_TYPE (retval) = RTYPE_USER_STRUCT;\n+                RDOT_lhs_TT (retval) = RDOT_lhs_TT (lookup); // identifier node\n+                RDOT_rhs_TT (retval) = RDOT_rhs_TT (lookup); // struct layout\n                 std::vector<ALLOCA_>::iterator it;\n-                if (RDOT_MEM_MODIFIER(node))\n-                    for (it = RDOT_MEM_MODIFIER(node)->begin();\n-                         it != RDOT_MEM_MODIFIER(node)->end();\n-                         ++it)\n-                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-                if (mods)\n-                    for (it = mods->begin(); it != mods->end(); ++it)\n-                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n-            } else\n-                error(\"unable to find declaration of [%s] in current scope\",\n-                      callid);\n-        } break;\n-\n-        case D_ATTRIB_REF: {\n-            rdot lhs = RDOT_lhs_TT(node);\n-            rdot base_type = dot_pass_typeifyExprNode(lhs);\n-            gcc_assert(RDOT_TYPE(base_type) == RTYPE_USER_STRUCT);\n-        } break;\n-\n-        case D_ACC_EXPR: {\n-            rdot impl = RDOT_lhs_TT(node);\n-            char* implid = RDOT_IDENTIFIER_POINTER(impl);\n-            rdot lookup = dot_pass_dataFlow_lookup(implid);\n-\n-            bool found = false;\n-            rdot next;\n-            for (next = RDOT_rhs_TT(RDOT_FIELD(lookup));\n-                 next != NULL_DOT;\n-                 next = RDOT_CHAIN(next)) {\n-                switch (RDOT_TYPE(next)) {\n-                    case D_STRUCT_METHOD:\n-                        RDOT_TYPE(retval) = RDOT_TYPE(RDOT_FIELD2(next));\n-                        break;\n-\n-                    default:\n-                        error_at(RDOT_LOCATION(next), \"unable to identify [%s] for type inferance\", \n-                          RDOT_OPCODE_STR(next));\n-                        break;\n-                }\n-            }\n-            if (!found)\n-                break;\n-        } break;\n-\n-        case D_ADD_EXPR:\n-        case D_MINUS_EXPR:\n-        case D_MULT_EXPR:\n-        case D_DIVD_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(node);\n-            rdot rhs = RDOT_rhs_TT(node);\n-\n-            rdot lt = dot_pass_typeifyExprNode(lhs);\n-            rdot rt = dot_pass_typeifyExprNode(rhs);\n-\n-            if (RDOT_TYPE(lt) != RTYPE_INFER || RDOT_TYPE(rt) != RTYPE_INFER) {\n-                if (RDOT_TYPE(lt) == RDOT_TYPE(rt))\n-                    retval = lt;\n-                else {\n-                    if (RDOT_TYPE(lt) == RTYPE_INFER || RDOT_TYPE(rt) == RTYPE_INFER)\n-                        retval = RDOT_TYPE(lt) == RTYPE_INFER ? rt : lt;\n-                    else\n-                        error(\"unable to coerce types [%s] and [%s]\",\n-                              RDOT_OPCODE_STR(lt),\n-                              RDOT_OPCODE_STR(rt));\n-                }\n-            }\n-        } break;\n-\n-        default:\n-            error(\"Unable to figure out the type of this [%s]\",\n-                  RDOT_OPCODE_STR(node));\n-            break;\n+                if (RDOT_MEM_MODIFIER (node))\n+                  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+                       it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n+                    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+                if (RDOT_MEM_MODIFIER (lookup))\n+                  for (it = RDOT_MEM_MODIFIER (lookup)->begin ();\n+                       it != RDOT_MEM_MODIFIER (lookup)->end (); ++it)\n+                    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+\t      }\n+\t    else\n+\t      error (\"unable to determine type of [%s] struct initilization, \"\n+\t\t     \"[%s] was found in this scope\",\n+\t\t     slookup, RDOT_OPCODE_STR (lookup));\n+\t  }\n+\telse\n+\t  error (\"[%s] does not name a type in scope\", slookup);\n+      }\n+      break;\n+\n+    case D_CALL_EXPR:\n+      {\n+        const char * callid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+        rdot lookup = dot_pass_dataFlow_lookup (callid);\n+        if (lookup != NULL_DOT)\n+          {\n+            gcc_assert (RDOT_TYPE (lookup) == D_STRUCT_METHOD);\n+            RDOT_TYPE (retval) = RDOT_TYPE (RDOT_FIELD2 (lookup));\n+            std::vector<ALLOCA_> * mods = RDOT_MEM_MODIFIER (RDOT_FIELD2 (lookup));\n+            std::vector<ALLOCA_>::iterator it;\n+            if (RDOT_MEM_MODIFIER (node))\n+              for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+                   it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n+                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+            if (mods)\n+              for (it = mods->begin (); it != mods->end (); ++it)\n+                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n+          }\n+        else\n+          error (\"unable to find declaration of [%s] in current scope\",\n+                 callid);\n+      }\n+      break;\n+\n+    case D_ATTRIB_REF:\n+      {\n+        rdot lhs = RDOT_lhs_TT (node);\n+        rdot base_type = dot_pass_typeifyExprNode (lhs);\n+        gcc_assert (RDOT_TYPE (base_type) == RTYPE_USER_STRUCT);\n+      }\n+      break;\n+\n+    case D_ACC_EXPR:\n+      {\n+\trdot impl = RDOT_lhs_TT (node);\n+\tchar * implid = RDOT_IDENTIFIER_POINTER (impl);\n+\trdot lookup = dot_pass_dataFlow_lookup (implid);\n+\n+\tbool found = false;\n+\trdot next;\n+\tfor (next = RDOT_rhs_TT (RDOT_FIELD (lookup));\n+\t     next != NULL_DOT; next = RDOT_CHAIN (next))\n+\t  {\n+\t    switch (RDOT_TYPE (next))\n+\t      {\n+\t      case D_STRUCT_METHOD:\n+\t\tRDOT_TYPE (retval) = RDOT_TYPE (RDOT_FIELD2 (next));\n+\t\tbreak;\n+\n+\t      default:\n+\t\terror_at (RDOT_LOCATION (next), \"unable to identify [%s] for type inferance\",\n+\t\t\t  RDOT_OPCODE_STR (next));\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif (!found)\n+\t  break;\n+      }\n+      break;\n+\n+    case D_ADD_EXPR:\n+    case D_MINUS_EXPR:\n+    case D_MULT_EXPR:\n+    case D_DIVD_EXPR:\n+      {\n+        rdot lhs = RDOT_lhs_TT (node);\n+        rdot rhs = RDOT_rhs_TT (node);\n+\n+\trdot lt = dot_pass_typeifyExprNode (lhs);\n+\trdot rt = dot_pass_typeifyExprNode (rhs);\n+\n+\tif (RDOT_TYPE (lt) != RTYPE_INFER\n+\t    || RDOT_TYPE (rt) != RTYPE_INFER)\n+\t  {\n+            if (RDOT_TYPE (lt) == RDOT_TYPE (rt))\n+              retval = lt;\n+            else\n+              {\n+                if (RDOT_TYPE (lt) == RTYPE_INFER || RDOT_TYPE (rt) == RTYPE_INFER)\n+                  retval = RDOT_TYPE (lt) == RTYPE_INFER ? rt : lt;\n+                else\n+                  error (\"unable to coerce types [%s] and [%s]\",\n+                         RDOT_OPCODE_STR (lt), RDOT_OPCODE_STR (rt));\n+              }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      error (\"Unable to figure out the type of this [%s]\",\n+\t     RDOT_OPCODE_STR (node));\n+      break;\n     }\n \n-    bool skip_next = false;\n-    std::vector<ALLOCA_> nmods;\n-    std::vector<ALLOCA_>* pmods = RDOT_MEM_MODIFIER(retval);\n-\n-    std::vector<ALLOCA_>::iterator it;\n-    for (it = pmods->begin(); it != pmods->end(); ++it) {\n-        switch (*it) {\n-            case ALLOC_DEREF:\n-                skip_next = true;\n-                break;\n-\n-            default: {\n-                if (!skip_next) {\n-                    nmods.push_back(*it);\n-                    skip_next = false;\n-                }\n-            } break;\n-        }\n+  bool skip_next = false;\n+  std::vector<ALLOCA_> nmods;\n+  std::vector<ALLOCA_> * pmods = RDOT_MEM_MODIFIER (retval);\n+  \n+  std::vector<ALLOCA_>::iterator it;\n+  for (it = pmods->begin (); it != pmods->end (); ++it)\n+    {\n+      switch (*it)\n+\t{\n+\tcase ALLOC_DEREF:\n+\t  skip_next = true;\n+\t  break;\n+              \n+\tdefault:\n+\t  {\n+\t    if (!skip_next)\n+\t      {\n+\t\tnmods.push_back (*it);\n+\t\tskip_next = false;\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n     }\n-    RDOT_MMEM_COPY((&nmods), RDOT_MEM_MODIFIER(retval));\n-    return retval;\n+  RDOT_MMEM_COPY ((&nmods), RDOT_MEM_MODIFIER (retval));\n+  return retval;\n }\n \n-// Seems to check for mutability of node (mut check) and creates error if it is violated\n-static void dot_pass_mutability(const rdot node) {\n-    rdot lhs = RDOT_lhs_TT(node);\n-    if (RDOT_TYPE(lhs) != D_VAR_DECL) {\n-        // check the nodes mutability\n-        switch (RDOT_TYPE(lhs)) {\n-            case D_IDENTIFIER: {\n-                const char* ident = RDOT_IDENTIFIER_POINTER(lhs);\n-                const rdot node = dot_pass_dataFlow_lookup(ident);\n-                if (node == NULL_DOT)\n-                    error_at(RDOT_LOCATION(node), \"Unable to find decl [%s] in current scope\", ident);\n-                else if (RDOT_qual(node) == true)\n-                    error_at(RDOT_LOCATION(node), \"Unable to modify [%s] it is immutable\", ident);\n-            } break;\n-\n-            default: {\n-                const char* nstr = RDOT_OPCODE_STR(lhs);\n-                warning_at(RDOT_LOCATION(node), 0, \"TODO unable to verify assignment\"\n-                                                   \"mutability for [%s]\",\n-                           nstr);\n-            } break;\n-        }\n+static\n+void dot_pass_mutability (const rdot node)\n+{\n+  rdot lhs = RDOT_lhs_TT (node);\n+  if (RDOT_TYPE (lhs) != D_VAR_DECL)\n+    {\n+      // check the nodes mutability\n+      switch (RDOT_TYPE (lhs))\n+\t{\n+\tcase D_IDENTIFIER:\n+\t  {\n+\t    const char * ident = RDOT_IDENTIFIER_POINTER (lhs);\n+\t    const rdot node = dot_pass_dataFlow_lookup (ident);\n+\t    if (node == NULL_DOT)\n+\t      error_at (RDOT_LOCATION (node), \"Unable to find decl [%s] in current scope\", ident);\n+\t    else if (RDOT_qual (node) == true)\n+\t      error_at (RDOT_LOCATION (node), \"Unable to modify [%s] it is immutable\", ident);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  {\n+\t    const char * nstr = RDOT_OPCODE_STR (lhs);\n+\t    warning_at (RDOT_LOCATION (node), 0, \"TODO unable to verify assignment\"\n+\t\t\t\"mutability for [%s]\", nstr);\n+\t  }\n+\t  break;\n+\t}\n     }\n }\n \n-/* Seems to check for various stuff - top level for checking a full block?\n- * \n- * Potentially defines block declarations and adds them to decls? (pass by reference) */\n-static void dot_pass_dataFlowBlock_(rdot suite, std::vector<rdot>* decls) {\n-    rdot node;\n-    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n-        if (RDOT_T_FIELD(node) == D_D_EXPR) {\n-            if (RDOT_TYPE(node) == D_MODIFY_EXPR)\n-                dot_pass_mutability(node);\n-\n-            const char* id = NULL;\n-            rdot decl = dot_pass_dataFlow_getDecl(node);\n-            if (decl != NULL_DOT) {\n-                gcc_assert(RDOT_TYPE(decl) == D_VAR_DECL);\n-                id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(decl));\n-                decls->push_back(decl);\n-\n-                // push it into the current context...\n-                rdot lookup = dot_pass_dataFlow_lookup(id);\n-                if (lookup != NULL_DOT)\n-                    error(\"Duplicate declaration of [%s] to [%s]\",\n-                          id,\n-                          RDOT_OPCODE_STR(lookup));\n-                else\n-                    gcc_assert(!dot_pass_dataFlow_pushDecl(decl, id));\n-            }\n-        } else {\n-            switch (RDOT_TYPE(node)) {\n-                case D_STRUCT_IF: {\n-                    rdot sif = RDOT_lhs_TT(node);\n-                    rdot ses = RDOT_rhs_TT(node);\n-\n-                    dot_pass_dataFlowBlock_(RDOT_rhs_TT(sif), decls);\n-                    if (ses != NULL_DOT)\n-                        dot_pass_dataFlowBlock_(RDOT_lhs_TT(ses), decls);\n-                } break;\n-\n-                case D_STRUCT_WHILE:\n-                    dot_pass_dataFlowBlock_(RDOT_rhs_TT(node), decls);\n-                    break;\n-\n-                case D_STRUCT_LOOP:\n-                    dot_pass_dataFlowBlock_(RDOT_lhs_TT(node), decls);\n-                    break;\n-\n-                case C_BREAK_STMT:\n-                case C_CONT_STMT:\n-                    break;\n-\n-                default:\n-                    error(\"Unhandled data flow in block on [%s]\\n\", RDOT_OPCODE_STR(node));\n-                    break;\n+static\n+void dot_pass_dataFlowBlock_ (rdot suite, std::vector<rdot> * decls)\n+{\n+  rdot node;\n+  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n+    {\n+      if (RDOT_T_FIELD (node) == D_D_EXPR)\n+        {\n+\t  if (RDOT_TYPE (node) == D_MODIFY_EXPR)\n+\t    dot_pass_mutability (node);\n+\n+          const char * id = NULL;\n+          rdot decl = dot_pass_dataFlow_getDecl (node);\n+          if (decl != NULL_DOT)\n+            {\n+\t      gcc_assert (RDOT_TYPE (decl) == D_VAR_DECL);\n+\t      id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (decl));\n+\t      decls->push_back (decl);\n+\n+              // push it into the current context...\n+              rdot lookup = dot_pass_dataFlow_lookup (id);\n+              if (lookup != NULL_DOT)\n+                error (\"Duplicate declaration of [%s] to [%s]\",\n+                       id, RDOT_OPCODE_STR (lookup));\n+              else\n+                gcc_assert (!dot_pass_dataFlow_pushDecl (decl, id));\n             }\n         }\n+      else\n+\t{\n+\t  switch (RDOT_TYPE (node))\n+\t    {\n+\t    case D_STRUCT_IF:\n+\t      {\n+\t\trdot sif = RDOT_lhs_TT (node);\n+\t\trdot ses = RDOT_rhs_TT (node);\n+\n+\t\tdot_pass_dataFlowBlock_ (RDOT_rhs_TT (sif), decls);\n+\t\tif (ses != NULL_DOT)\n+\t\t  dot_pass_dataFlowBlock_ (RDOT_lhs_TT (ses), decls);\n+\t      }\n+\t      break;\n+\n+\t    case D_STRUCT_WHILE:\n+\t      dot_pass_dataFlowBlock_ (RDOT_rhs_TT (node), decls);\n+\t      break;\n+\n+            case D_STRUCT_LOOP:\n+              dot_pass_dataFlowBlock_ (RDOT_lhs_TT (node), decls);\n+              break;\n+\n+            case C_BREAK_STMT:\n+            case C_CONT_STMT:\n+              break;\n+\n+\t    default:\n+\t      error (\"Unhandled data flow in block on [%s]\\n\", RDOT_OPCODE_STR (node));\n+\t      break;\n+\t    }\n+\t}\n     }\n }\n \n-// Seems to get all references for usage of all defined block declarations for type inference reasons\n-static void dot_pass_dataFlowBlock(rdot suite) {\n-    std::vector<rdot> block_decls;\n-    dot_pass_dataFlowBlock_(suite, &block_decls);\n-\n-    // now we have all defined block declarations now need to get all\n-    // references in their use if they have an undefined type.\n-    std::vector<rdot>::iterator it;\n-    for (it = block_decls.begin(); it != block_decls.end(); ++it) {\n-        rdot decl = *it;\n-        gcc_assert(RDOT_TYPE(decl) == D_VAR_DECL);\n-        rdot idecl = RDOT_lhs_TT(decl);\n-        const char* ident = RDOT_IDENTIFIER_POINTER(idecl);\n-        if (RDOT_TYPE(RDOT_rhs_TT(decl)) == RTYPE_INFER) {\n-            std::vector<rdot>* refs = dot_pass_getReferences(decl, suite);\n-            if (refs->size() == 0) {\n-                error(\"Unable to infer type of [%s] it looks to \"\n-                      \"be unused in this scope\",\n-                      ident);\n-                continue;\n-            }\n-            RDOT_rhs_TT(decl) = dot_pass_inferTheType(refs, ident);\n-            if (RDOT_TYPE(RDOT_rhs_TT(decl)) == RTYPE_INFER)\n-                error(\"Compiler was unable to infer the type for [%s]\", ident);\n-            delete refs;\n-        }\n+static\n+void dot_pass_dataFlowBlock (rdot suite)\n+{\n+  std::vector<rdot> block_decls;\n+  dot_pass_dataFlowBlock_ (suite, &block_decls);\n+\n+  // now we have all defined block declarations now need to get all\n+  // references in their use if they have an undefined type.\n+  std::vector<rdot>::iterator it;\n+  for (it = block_decls.begin (); it != block_decls.end (); ++it)\n+    {\n+      rdot decl = *it;\n+      gcc_assert (RDOT_TYPE (decl) == D_VAR_DECL);\n+      rdot idecl = RDOT_lhs_TT (decl);\n+      const char * ident = RDOT_IDENTIFIER_POINTER (idecl);\n+      if (RDOT_TYPE (RDOT_rhs_TT (decl)) == RTYPE_INFER)\n+\t{\n+\t  std::vector<rdot> * refs = dot_pass_getReferences (decl, suite);\n+\t  if (refs->size () == 0)\n+\t    {\n+\t      error (\"Unable to infer type of [%s] it looks to \"\n+\t\t     \"be unused in this scope\", ident);\n+\t      continue;\n+\t    }\n+\t  RDOT_rhs_TT (decl) = dot_pass_inferTheType (refs, ident);\n+\t  if (RDOT_TYPE (RDOT_rhs_TT (decl)) == RTYPE_INFER)\n+\t    error (\"Compiler was unable to infer the type for [%s]\", ident);\n+\t  delete refs;\n+\t}\n     }\n }\n \n-// Checks data flow for entire function - calls stuff leading to type inference, return values, etc.\n-static void dot_pass_dataFlowFunction(rdot node) {\n-    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-    rdot type = RDOT_FIELD2(node);\n-\n-    // rust does not infer function types empty types are default void\n-    // and parameters are synatically required to be typed\n-    dot_pass_dataFlow_pushCtx();\n-\n-    // fill up the parameters here\n-    rdot params;\n-    for (params = RDOT_lhs_TT(node); params != NULL_DOT;\n-         params = RDOT_CHAIN(params)) {\n-        rdot pident = RDOT_lhs_TT(params);\n-        rdot ptype = RDOT_rhs_TT(params);\n-\n-        const char* cpid = RDOT_IDENTIFIER_POINTER(pident);\n-        if (strcmp(cpid, \"self\") == 0) {\n-            gcc_assert(impl_master != NULL_DOT);\n-            rdot stid = RDOT_lhs_TT(impl_master);\n-            ptype = rdot_build_decl1(RTYPE_USER_STRUCT, stid);\n-        }\n-        rdot vpdecl = rdot_build_varDecl(ptype, RDOT_qual(params), pident);\n-        bool chk = dot_pass_dataFlow_pushDecl(vpdecl,\n-                                              RDOT_IDENTIFIER_POINTER(pident));\n-        gcc_assert(chk == false);\n+static\n+void dot_pass_dataFlowFunction (rdot node)\n+{\n+  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+  rdot type = RDOT_FIELD2 (node);\n+\n+  // rust does not infer function types empty types are default void\n+  // and parameters are synatically required to be typed\n+  dot_pass_dataFlow_pushCtx ();\n+\n+  // fill up the parameters here\n+  rdot params;\n+  for (params = RDOT_lhs_TT (node); params != NULL_DOT;\n+       params = RDOT_CHAIN (params))\n+    {\n+      rdot pident = RDOT_lhs_TT (params);\n+      rdot ptype = RDOT_rhs_TT (params);\n+\n+      const char * cpid = RDOT_IDENTIFIER_POINTER (pident);\n+      if (strcmp (cpid, \"self\") == 0)\n+\t{\n+\t  gcc_assert (impl_master != NULL_DOT);\n+\t  rdot stid = RDOT_lhs_TT (impl_master);\n+\t  ptype = rdot_build_decl1 (RTYPE_USER_STRUCT, stid);\n+\t}\n+      rdot vpdecl = rdot_build_varDecl (ptype, RDOT_qual (params), pident);\n+      bool chk = dot_pass_dataFlow_pushDecl (vpdecl,\n+\t\t\t\t\t     RDOT_IDENTIFIER_POINTER (pident));\n+      gcc_assert (chk == false);\n     }\n \n-    rdot suite = RDOT_rhs_TT(node);\n-    dot_pass_dataFlowBlock(suite);\n-\n-    // now check the return type is correct\n-    /* make sure its a valid type! */\n-    if (type != NULL) {\n-        bool verify = verifyType(type);\n-        if (verify == false)\n-            error(\"unable to verify return type of %s [%s]\\n\",\n-                  method_id,\n-                  RDOT_OPCODE_STR(type));\n-        else {\n-            std::vector<rdot> retvals;\n-            dot_pass_dataFlowBlock_retvals(suite, &retvals);\n-\n-            if (retvals.size() == 0)\n-                error(\"Function [%s] does not seem to return anything!\", method_id);\n-            else {\n-                rdot retype = dot_pass_inferTheType(&retvals, method_id);\n-                if (RDOT_TYPE(retype) == RTYPE_INFER)\n-                    error(\"gcc rust was unable to verify the return type of [%s]\",\n-                          method_id);\n-            }\n-        }\n+  rdot suite = RDOT_rhs_TT (node);\n+  dot_pass_dataFlowBlock (suite);\n+\n+  // now check the return type is correct\n+  /* make sure its a valid type! */\n+  if (type != NULL)\n+    {\n+      bool verify = verifyType (type);\n+      if (verify == false)\n+        error (\"unable to verify return type of %s [%s]\\n\",\n+               method_id, RDOT_OPCODE_STR (type));\n+      else\n+\t{\n+\t  std::vector<rdot> retvals;\n+\t  dot_pass_dataFlowBlock_retvals (suite, &retvals);\n+\n+\t  if (retvals.size () == 0)\n+\t    error (\"Function [%s] does not seem to return anything!\", method_id);\n+\t  else\n+\t    {\n+\t      rdot retype = dot_pass_inferTheType (&retvals, method_id);\n+\t      if (RDOT_TYPE (retype) == RTYPE_INFER)\n+\t\terror (\"gcc rust was unable to verify the return type of [%s]\",\n+\t\t       method_id);\n+\t    }\n+\t}\n     }\n-    dot_pass_dataFlow_popCtx();\n+  dot_pass_dataFlow_popCtx ();\n }\n \n-// Presumably top level entry for checking data flow - switches to method (function), struct, struct impl\n-static void dot_pass_dataFlowToplevel(rdot node) {\n-    switch (RDOT_TYPE(node)) {\n-        case D_STRUCT_METHOD:\n-            dot_pass_dataFlowFunction(node);\n-            break;\n-\n-            /* need to dataflow the layout to check the types eventually */\n-        case D_STRUCT_TYPE:\n-            break;\n-\n-        case D_STRUCT_IMPL: {\n-            // look up to make sure the impl name is available...\n-            const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-            rdot lookup = dot_pass_dataFlow_lookup(implid);\n-            if (lookup == NULL_DOT)\n-                error(\"impl [%s] does not reference a type in scope\", implid);\n-            else {\n-                if (RDOT_TYPE(lookup) != D_STRUCT_TYPE)\n-                    error(\"impl [%s] does not reference a struct points to [%s]\",\n-                          implid,\n-                          RDOT_OPCODE_STR(lookup));\n-                else {\n-                    RDOT_FIELD(lookup) = node;\n-                    impl_master = lookup;\n-                    rdot next;\n-                    for (next = RDOT_rhs_TT(node); next != NULL_DOT;\n-                         next = RDOT_CHAIN(next))\n-                        dot_pass_dataFlowFunction(next);\n-                    impl_master = NULL_DOT;\n-                }\n-            }\n-        } break;\n-\n-        default:\n-            error(\"Unable to dataflow %s\\n\", RDOT_OPCODE_STR(node));\n-            break;\n+static\n+void dot_pass_dataFlowToplevel (rdot node)\n+{\n+  switch (RDOT_TYPE (node))\n+    {\n+    case D_STRUCT_METHOD:\n+      dot_pass_dataFlowFunction (node);\n+      break;\n+\n+      /* need to dataflow the layout to check the types eventually */\n+    case D_STRUCT_TYPE:\n+      break;\n+\n+    case D_STRUCT_IMPL:\n+      {\n+\t// look up to make sure the impl name is available...\n+\tconst char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+\trdot lookup = dot_pass_dataFlow_lookup (implid);\n+\tif (lookup == NULL_DOT)\n+\t  error (\"impl [%s] does not reference a type in scope\", implid);\n+\telse\n+\t  {\n+\t    if (RDOT_TYPE (lookup) != D_STRUCT_TYPE)\n+\t      error (\"impl [%s] does not reference a struct points to [%s]\",\n+\t\t     implid, RDOT_OPCODE_STR (lookup));\n+\t    else\n+\t      {\n+\t\tRDOT_FIELD (lookup) = node;\n+\t\timpl_master = lookup;\n+\t\trdot next;\n+\t\tfor (next = RDOT_rhs_TT (node); next != NULL_DOT;\n+\t\t     next = RDOT_CHAIN (next))\n+                  dot_pass_dataFlowFunction (next);\n+\t\timpl_master = NULL_DOT;\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      error (\"Unable to dataflow %s\\n\", RDOT_OPCODE_STR (node));\n+      break;\n     }\n }\n \n-// may be true top-level entry for checking data flow and inferring types - seems to call even top level function\n-vec<rdot, va_gc>* dot_pass_inferTypes(vec<rdot, va_gc>* decls) {\n-    dot_pass_dataFlow_pushCtx();\n-\n-    rdot idtx = NULL_DOT;\n-    size_t i;\n-    for (i = 0; decls->iterate(i, &idtx); ++i) {\n-        rdot node = idtx;\n-        switch (RDOT_TYPE(node)) {\n-            case D_STRUCT_METHOD: {\n-                const char* id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-                if (dot_pass_dataFlow_lookup(id))\n-                    error(\"Duplicate declaration against this function [%s]\\n\", id);\n-                else\n-                    dot_pass_dataFlow_pushDecl(node, id);\n-            } break;\n-\n-            case D_STRUCT_TYPE: {\n-                const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-                if (dot_pass_dataFlow_lookup(id))\n-                    error(\"Duplicate declaration against this type [%s]\\n\", id);\n-                else\n-                    dot_pass_dataFlow_pushDecl(node, id);\n-            } break;\n-\n-            case D_STRUCT_IMPL: {\n-                // look up to make sure the impl name is available...\n-                const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-                rdot lookup = dot_pass_dataFlow_lookup(implid);\n-                if (lookup == NULL_DOT)\n-                    error(\"impl [%s] does not reference a type in scope\", implid);\n-                else {\n-                    if (RDOT_TYPE(lookup) != D_STRUCT_TYPE)\n-                        error(\"impl [%s] does not reference a struct points to [%s]\",\n-                              implid,\n-                              RDOT_OPCODE_STR(lookup));\n-                    else\n-                        RDOT_FIELD(lookup) = node;\n-                }\n-            } break;\n-\n-            default:\n-                break;\n-        }\n+vec<rdot,va_gc> * dot_pass_inferTypes (vec<rdot,va_gc> * decls)\n+{\n+  dot_pass_dataFlow_pushCtx ();\n+\n+  rdot idtx = NULL_DOT;\n+  size_t i;\n+  for (i = 0; decls->iterate (i, &idtx); ++i)\n+    {\n+      rdot node = idtx;\n+      switch (RDOT_TYPE (node))\n+\t{\n+\tcase D_STRUCT_METHOD:\n+\t  {\n+\t    const char * id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+\t    if (dot_pass_dataFlow_lookup (id))\n+\t      error (\"Duplicate declaration against this function [%s]\\n\", id);\n+\t    else\n+\t      dot_pass_dataFlow_pushDecl (node, id);\n+\t  }\n+\t  break;\n+\n+\tcase D_STRUCT_TYPE:\n+\t  {\n+\t    const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+\t    if (dot_pass_dataFlow_lookup (id))\n+\t      error (\"Duplicate declaration against this type [%s]\\n\", id);\n+\t    else\n+\t      dot_pass_dataFlow_pushDecl (node, id);\n+\t  }\n+\t  break;\n+\n+\tcase D_STRUCT_IMPL:\n+\t  {\n+\t    // look up to make sure the impl name is available...\n+\t    const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+\t    rdot lookup = dot_pass_dataFlow_lookup (implid);\n+\t    if (lookup == NULL_DOT)\n+\t      error (\"impl [%s] does not reference a type in scope\", implid);\n+\t    else\n+\t      {\n+\t\tif (RDOT_TYPE (lookup) != D_STRUCT_TYPE)\n+\t\t  error (\"impl [%s] does not reference a struct points to [%s]\",\n+\t\t\t implid, RDOT_OPCODE_STR (lookup));\n+\t\telse\n+\t\t  RDOT_FIELD (lookup) = node;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n-    for (i = 0; decls->iterate(i, &idtx); ++i)\n-        dot_pass_dataFlowToplevel(idtx);\n+  for (i = 0; decls->iterate (i, &idtx); ++i)\n+    dot_pass_dataFlowToplevel (idtx);\n \n-    dot_pass_dataFlow_popCtx();\n-    return decls;\n+  dot_pass_dataFlow_popCtx ();\n+  return decls;\n }"}, {"sha": "13b09a480d87b1fc3436ce88ff8247d724d671fe", "filename": "gcc/rust/old/rdot-generic-compiler.cc", "status": "modified", "additions": 1056, "deletions": 883, "changes": 1939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,4 +1,3 @@\n-// rdot-generic-compiler.cc - seems to convert rdot AST representation to GENERIC representation\n /* This file is part of GCC.\n \n    GCC is free software; you can redistribute it and/or modify\n@@ -19,296 +18,337 @@\n \n #define RUST_TMP \"RUST_TMP\"\n \n-static std::vector<std::map<std::string, tree>*> context;\n-\n-static tree dot_pass_genFndecl_Basic(location_t, const char*, tree);\n-static tree dot_pass_lookupCTU(const char*);\n-static std::vector<tree>* dot_pass_popContext(void);\n-static void dot_pass_pushContext(void);\n-static void dot_pass_genMethodProto(rdot);\n-static void dot_pass_compileSuite(rdot, tree*);\n-\n-#define RDOT_ALLOCA_MODIFIERS_DO(_X, _Y)                                                         \\\n-    if (RDOT_MEM_MODIFIER(_Y))                                                                   \\\n-        do {                                                                                     \\\n-            gcc_assert(_X != error_mark_node);                                                   \\\n-            std::vector<ALLOCA_>::reverse_iterator __rit;                                        \\\n-            for (__rit = RDOT_MEM_MODIFIER(_Y)->rbegin();                                        \\\n-                 __rit != RDOT_MEM_MODIFIER(_Y)->rend();                                         \\\n-                 ++__rit) {                                                                      \\\n-                switch (*__rit) {                                                                \\\n-                    case ALLOC_HEAP:                                                             \\\n-                        _X = dot_pass_heapify(_X, TREE_TYPE(_X), TYPE_SIZE_UNIT(TREE_TYPE(_X))); \\\n-                        break;                                                                   \\\n-                    case ALLOC_REF:                                                              \\\n-                        _X = build_fold_addr_expr(_X);                                           \\\n-                        break;                                                                   \\\n-                    case ALLOC_DEREF: {                                                          \\\n-                        _X = build_fold_indirect_ref_loc(RDOT_LOCATION(_Y),                      \\\n-                                                         _X);                                    \\\n-                        TREE_THIS_NOTRAP(_X) = 1;                                                \\\n-                    } break;                                                                     \\\n-                }                                                                                \\\n-            }                                                                                    \\\n+static std::vector<std::map<std::string, tree> *> context;\n+\n+static tree dot_pass_genFndecl_Basic (location_t, const char *, tree);\n+static tree dot_pass_lookupCTU (const char *);\n+static std::vector<tree> * dot_pass_popContext (void);\n+static void dot_pass_pushContext (void);\n+static void dot_pass_genMethodProto (rdot);\n+static void dot_pass_compileSuite (rdot, tree *);\n+\n+#define RDOT_ALLOCA_MODIFIERS_DO(_X, _Y)                                \\\n+  if (RDOT_MEM_MODIFIER (_Y))\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      gcc_assert (_X != error_mark_node);\t\t\t\t\\\n+      std::vector<ALLOCA_>::reverse_iterator __rit;\t\t\t\\\n+      for (__rit = RDOT_MEM_MODIFIER (_Y)->rbegin ();\t\t\t\\\n+\t   __rit != RDOT_MEM_MODIFIER (_Y)->rend (); ++__rit)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  switch (*__rit)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case ALLOC_HEAP:\t\t\t\t\t\t\\\n+\t      _X = dot_pass_heapify (_X, TREE_TYPE (_X),\t\t\\\n+\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (_X)));\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case ALLOC_REF:\t\t\t\t\t\t\\\n+\t      _X = build_fold_addr_expr (_X);\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case ALLOC_DEREF:\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\t_X = build_fold_indirect_ref_loc (RDOT_LOCATION (_Y),\t\\\n+\t\t\t\t\t\t  _X);\t\t\t\\\n+\t\tTREE_THIS_NOTRAP (_X) = 1;\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     } while (0)\n \n /* NOTE: this isn't global in the sense of the generated code,\n    This just makes it easier for expression compilation to access\n    the return decl */\n static tree global_retDecl;\n-static tree* current_function_block;\n+static tree * current_function_block;\n static bool global_retDecl_;\n static tree __impl_type_decl = error_mark_node;\n static std::vector<tree> __loopContexts;\n-#define dot_pass_rustToGccType(_x, _y) dot_pass_rustToGccType__(_x, _y, false, NULL)\n-\n-// seems to return only the end of a string val by removing everything before the final dot\n-static char* dot_pass_demangleImpl(const char* val) {\n-    // has form of type.method_name\n-    size_t i;\n-    size_t last_dot = 0;\n-    for (i = 0; i < strlen(val); ++i) {\n-        if (val[i] == '.')\n-            last_dot = i;\n+#define dot_pass_rustToGccType(_x, _y) dot_pass_rustToGccType__ (_x, _y, false, NULL)\n+\n+static\n+char * dot_pass_demangleImpl (const char * val)\n+{\n+  // has form of type.method_name\n+  size_t i;\n+  size_t last_dot = 0;\n+  for (i = 0; i < strlen (val); ++i)\n+    {\n+      if (val [i] == '.')\n+\tlast_dot = i;\n     }\n-    size_t bsize = (strlen(val) - last_dot) * sizeof(char);\n-    char* buffer = (char*)xmalloc(bsize);\n-    memset(buffer, 0, bsize);\n-    strncpy(buffer, val + last_dot + 1, strlen(val) - last_dot);\n+  size_t bsize = (strlen (val) - last_dot) * sizeof (char);\n+  char * buffer = (char *) xmalloc (bsize);\n+  memset (buffer, 0, bsize);\n+  strncpy (buffer, val + last_dot + 1, strlen (val) - last_dot);\n \n-    return buffer;\n+  return buffer;\n }\n \n-// Seems to \"mangle\" val (a string parameter) by prepending \"__rust_\" to it\n-static char* dot_pass_mangle(const char* val) {\n-    // just for now pre-append __rust_[id] will do ok for now\n-    const char* stuff = \"__rust_\";\n-    size_t blen = (strlen(stuff) + strlen(val) + 1) * sizeof(char);\n-    char* retval = (char*)xmalloc(blen);\n-    memset(retval, 0, blen);\n-    snprintf(retval, blen, \"%s%s\", stuff, val);\n-    return retval;\n+static\n+char * dot_pass_mangle (const char * val)\n+{\n+  // just for now pre-append __rust_[id] will do ok for now\n+  const char * stuff = \"__rust_\";\n+  size_t blen = (strlen (stuff) + strlen (val) + 1) * sizeof (char);\n+  char * retval = (char *) xmalloc (blen);\n+  memset (retval, 0, blen);\n+  snprintf (retval, blen, \"%s%s\", stuff, val);\n+  return retval;\n }\n \n-// Seems to convert \"Rust type\" (rdot type) to GCC GENERIC type\n-static tree dot_pass_rustToGccType__(rdot type, bool consty, bool rset, tree* record) {\n-    tree retval = error_mark_node;\n-    switch (RDOT_TYPE(type)) {\n-        case RTYPE_INT:\n-            retval = integer_type_node;\n-            break;\n-\n-        case D_STRUCT_TYPE:\n-        case D_STRUCT_INIT:\n-        case RTYPE_USER_STRUCT: {\n-            const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(type));\n-            retval = dot_pass_lookupCTU(id);\n-            if (rset)\n-                *record = retval;\n-\n-            if (retval == error_mark_node)\n-                error(\"Unable to find struct type [%s]\\n\", id);\n-        } break;\n-\n-        default:\n-            error(\"Unable to figure out gcc type for [%s]\\n\",\n-                  RDOT_OPCODE_STR(type));\n-            break;\n+static\n+tree dot_pass_rustToGccType__ (rdot type, bool consty, bool rset, tree * record)\n+{\n+  tree retval = error_mark_node;\n+  switch (RDOT_TYPE (type))\n+    {\n+    case RTYPE_INT:\n+      retval = integer_type_node;\n+      break;\n+\n+    case D_STRUCT_TYPE:\n+    case D_STRUCT_INIT:\n+    case RTYPE_USER_STRUCT:\n+      {\n+\tconst char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (type));\n+\tretval = dot_pass_lookupCTU (id);\n+        if (rset)\n+          *record = retval;\n+        \n+\tif (retval == error_mark_node)\n+\t  error (\"Unable to find struct type [%s]\\n\", id);\n+      }\n+      break;\n+\n+    default:\n+      error (\"Unable to figure out gcc type for [%s]\\n\",\n+             RDOT_OPCODE_STR (type));\n+      break;\n     }\n-    if (RDOT_MEM_MODIFIER(type)) {\n-        std::vector<ALLOCA_>::reverse_iterator rit;\n-        for (rit = RDOT_MEM_MODIFIER(type)->rbegin();\n-             rit != RDOT_MEM_MODIFIER(type)->rend();\n-             ++rit) {\n-            switch (*rit) {\n-                case ALLOC_REF:\n-                case ALLOC_HEAP:\n-                    retval = build_pointer_type(retval);\n-                    break;\n-                default:\n-                    fatal_error(\"cannot figure out modifier applied to type [%i]\", *rit);\n-                    break;\n-            }\n-        }\n+  if (RDOT_MEM_MODIFIER (type))\n+    {\n+      std::vector<ALLOCA_>::reverse_iterator rit;\n+      for (rit = RDOT_MEM_MODIFIER (type)->rbegin ();\n+\t   rit != RDOT_MEM_MODIFIER (type)->rend (); ++rit)\n+\t{\n+\t  switch (*rit)\n+\t    {\n+\t    case ALLOC_REF:\n+\t    case ALLOC_HEAP:\n+\t      retval = build_pointer_type (retval);\n+\t      break;\n+\t    default:\n+\t      fatal_error (\"cannot figure out modifier applied to type [%i]\", *rit);\n+\t      break;\n+\t    }\n+\t}\n     }\n-    if (consty)\n-        retval = build_qualified_type(retval, TYPE_QUAL_CONST);\n-    return retval;\n+  if (consty)\n+    retval = build_qualified_type (retval, TYPE_QUAL_CONST);\n+  return retval;\n }\n \n-// May build a function declaration? Add one to tree? Seems to have something to do with \"struct functions\"\n-static tree dot_pass_genFndecl_Basic(location_t loc, const char* ident, tree fntype) {\n-    tree fndecl = build_decl(loc, FUNCTION_DECL, get_identifier(ident), fntype);\n-    TREE_STATIC(fndecl) = 0;\n-    TREE_USED(fndecl) = 1;\n-    TREE_PUBLIC(fndecl) = 1;\n-\n-    tree argslist = NULL_TREE;\n-    DECL_ARGUMENTS(fndecl) = argslist;\n-\n-    tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, TREE_TYPE(fntype));\n-    DECL_CONTEXT(resdecl) = fndecl;\n-    DECL_ARTIFICIAL(resdecl) = true;\n-    DECL_IGNORED_P(resdecl) = true;\n-    DECL_RESULT(fndecl) = resdecl;\n-\n-    if (DECL_STRUCT_FUNCTION(fndecl) == NULL)\n-        push_struct_function(fndecl);\n-    else\n-        push_cfun(DECL_STRUCT_FUNCTION(fndecl));\n-    return fndecl;\n+static\n+tree dot_pass_genFndecl_Basic (location_t loc, const char * ident, tree fntype)\n+{\n+  tree fndecl = build_decl (loc, FUNCTION_DECL,\n+                            get_identifier (ident), fntype);\n+  TREE_STATIC (fndecl) = 0;\n+  TREE_USED (fndecl) = 1;\n+  TREE_PUBLIC (fndecl) = 1;\n+\n+  tree argslist = NULL_TREE;\n+  DECL_ARGUMENTS (fndecl) = argslist;\n+\n+  tree resdecl = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n+                             NULL_TREE, TREE_TYPE (fntype));\n+  DECL_CONTEXT (resdecl) = fndecl;\n+  DECL_ARTIFICIAL (resdecl) = true;\n+  DECL_IGNORED_P (resdecl) = true;\n+  DECL_RESULT (fndecl) = resdecl;\n+\n+  if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n+    push_struct_function (fndecl);\n+  else\n+    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n+  return fndecl;\n }\n \n-// Creates a \"tree\" string from an inputted string\n-static tree dot_pass_generateCString(const char* str) {\n-    tree index_type = build_index_type(size_int(strlen(str)));\n-    tree const_char_type = build_qualified_type(char_type_node, TYPE_QUAL_CONST);\n-    tree string_type = build_array_type(const_char_type, index_type);\n-    string_type = build_variant_type_copy(string_type);\n+static\n+tree dot_pass_generateCString (const char * str)\n+{\n+  tree index_type = build_index_type (size_int (strlen (str)));\n+  tree const_char_type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n+  tree string_type = build_array_type (const_char_type, index_type);\n+  string_type = build_variant_type_copy (string_type);\n \n-    TYPE_STRING_FLAG(string_type) = 1;\n-    tree string_val = build_string(strlen(str), str);\n-    TREE_TYPE(string_val) = string_type;\n+  TYPE_STRING_FLAG (string_type) = 1;\n+  tree string_val = build_string (strlen (str), str);\n+  TREE_TYPE (string_val) = string_type;\n \n-    return string_val;\n+  return string_val;\n }\n \n-// Seems to lookup struct (by name id) in context map thing, and returns the corresponding tree\n-static tree dot_pass_lookupCTU(const char* id) {\n-    tree retval = error_mark_node;\n-\n-    std::vector<std::map<std::string, tree>*>::reverse_iterator it;\n-    for (it = context.rbegin(); it != context.rend(); ++it) {\n-        std::map<std::string, tree>* ctx = *it;\n-        if (ctx->count(std::string(id)) > 0) {\n-            retval = ctx->at(std::string(id));\n-            break;\n+static\n+tree dot_pass_lookupCTU (const char * id)\n+{\n+  tree retval = error_mark_node;\n+\n+  std::vector<std::map<std::string, tree> *>::reverse_iterator it;\n+  for (it = context.rbegin (); it != context.rend (); ++it)\n+    {\n+      std::map<std::string, tree> * ctx = *it;\n+      if (ctx->count (std::string (id)) > 0)\n+\t{\n+          retval = ctx->at (std::string (id));\n+          break;\n         }\n     }\n \n-    return retval;\n+  return retval;\n }\n \n-// seems to add a declaration tree thing to a map\n-static void dot_pass_pushDecl(const char* id, tree decl) {\n-    tree test = dot_pass_lookupCTU(id);\n-    if (test == error_mark_node) {\n-        std::map<std::string, tree>* ctx = context.back();\n-        (*ctx)[std::string(id)] = decl;\n-    } else\n-        error(\"duplicate declaration of [%s]\\n\", id);\n+static\n+void dot_pass_pushDecl (const char * id, tree decl)\n+{\n+  tree test = dot_pass_lookupCTU (id);\n+  if (test == error_mark_node)\n+    {\n+      std::map<std::string, tree> * ctx = context.back ();\n+      (*ctx) [std::string (id)] = decl;\n+    }\n+  else\n+    error (\"duplicate declaration of [%s]\\n\", id);\n }\n \n-// Seems to build a heap allocation expression of size size\n static tree\n-dot_pass_rust_RR_alloc(tree size) {\n-    tree fntype = build_function_type_list(ptr_type_node,\n-                                           size_type_node,\n-                                           NULL_TREE);\n-    tree fndecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, get_identifier(\"__rust_heap_alloc\"), fntype);\n-    tree restype = TREE_TYPE(fndecl);\n-    tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, restype);\n-    DECL_CONTEXT(resdecl) = fndecl;\n-    DECL_RESULT(fndecl) = resdecl;\n-    DECL_EXTERNAL(fndecl) = 1;\n-    TREE_PUBLIC(fndecl) = 1;\n-    return build_call_expr(fndecl, 1, size);\n+dot_pass_rust_RR_alloc (tree size)\n+{\n+  tree fntype = build_function_type_list (ptr_type_node,\n+                                          size_type_node,\n+                                          NULL_TREE);\n+  tree fndecl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+                            get_identifier (\"__rust_heap_alloc\"),\n+                            fntype);\n+  tree restype = TREE_TYPE (fndecl);\n+  tree resdecl = build_decl (BUILTINS_LOCATION, RESULT_DECL, NULL_TREE,\n+                             restype);\n+  DECL_CONTEXT (resdecl) = fndecl;\n+  DECL_RESULT (fndecl) = resdecl;\n+  DECL_EXTERNAL (fndecl) = 1;\n+  TREE_PUBLIC (fndecl) = 1;\n+  return build_call_expr (fndecl, 1, size);\n }\n \n-// Appears to return a tree/declaration that heap allocation has occurred (or should occur?)\n static tree\n-dot_pass_heap_alloc(tree size, tree type) {\n-    tree ptype = build_pointer_type(type);\n-    tree heap_tmp = build_decl(UNKNOWN_LOCATION, VAR_DECL, create_tmp_var_name(RUST_TMP), ptype);\n-    dot_pass_pushDecl(IDENTIFIER_POINTER(DECL_NAME(heap_tmp)), heap_tmp);\n-    append_to_statement_list(fold_build2(MODIFY_EXPR, ptype, heap_tmp, dot_pass_rust_RR_alloc(size)),\n-                             current_function_block);\n-    return heap_tmp;\n+dot_pass_heap_alloc (tree size, tree type)\n+{\n+  tree ptype = build_pointer_type (type);\n+  tree heap_tmp = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+                              create_tmp_var_name (RUST_TMP),\n+                              ptype);\n+  dot_pass_pushDecl (IDENTIFIER_POINTER (DECL_NAME (heap_tmp)), heap_tmp);\n+  append_to_statement_list (fold_build2 (MODIFY_EXPR, ptype, heap_tmp,\n+                                         dot_pass_rust_RR_alloc (size)),\n+                            current_function_block);\n+  return heap_tmp;\n }\n \n-// Seems to do something related to heap allocation\n static tree\n-dot_pass_heapify(tree value, tree type, tree size) {\n-    tree alloc = dot_pass_heap_alloc(size, type);\n-    tree gmemcpy = builtin_decl_implicit(BUILT_IN_MEMCPY);\n-    vec<tree, va_gc>* args;\n-    vec_alloc(args, 0);\n-    vec_safe_push(args, alloc);\n-    vec_safe_push(args, build_fold_addr_expr(value));\n-    vec_safe_push(args, size);\n-    append_to_statement_list(build_call_expr_loc_vec(UNKNOWN_LOCATION, gmemcpy, args),\n-                             current_function_block);\n-    return alloc;\n+dot_pass_heapify (tree value, tree type, tree size)\n+{\n+  tree alloc = dot_pass_heap_alloc (size, type);\n+  tree gmemcpy = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+  vec<tree,va_gc> * args;\n+  vec_alloc (args, 0);\n+  vec_safe_push (args, alloc);\n+  vec_safe_push (args, build_fold_addr_expr (value));\n+  vec_safe_push (args, size);\n+  append_to_statement_list (build_call_expr_loc_vec (UNKNOWN_LOCATION, gmemcpy, args),\n+                            current_function_block);\n+  return alloc;\n }\n \n-// Seems to build an integer tree node from rdot decl\n-static tree dot_pass_genScalar(rdot decl) {\n-    tree retval = error_mark_node;\n-    gcc_assert(RDOT_TYPE(decl) == D_PRIMITIVE);\n-    gcc_assert(RDOT_lhs_T(decl) == D_TD_COM);\n-\n-    switch (RDOT_lhs_TC(decl).T) {\n-        case D_T_INTEGER:\n-            retval = build_int_cst(integer_type_node, RDOT_lhs_TC(decl).o.integer);\n-            break;\n-\n-        default:\n-            fatal_error(\"invalid scalar type %s!\\n\", RDOT_CODE_STR(RDOT_lhs_TC(decl).T));\n-            break;\n+static\n+tree dot_pass_genScalar (rdot decl)\n+{\n+  tree retval = error_mark_node;\n+  gcc_assert (RDOT_TYPE (decl) == D_PRIMITIVE);\n+  gcc_assert (RDOT_lhs_T (decl) == D_TD_COM);\n+\n+  switch (RDOT_lhs_TC (decl).T)\n+    {\n+    case D_T_INTEGER:\n+      retval = build_int_cst (integer_type_node, RDOT_lhs_TC (decl).o.integer);\n+      break;\n+      \n+    default:\n+      fatal_error (\"invalid scalar type %s!\\n\", RDOT_CODE_STR (RDOT_lhs_TC (decl).T));\n+      break;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Presumably turns a function calls into tree nodes\n-static tree dot_pass_genifyCall(tree mfndecl, vec<tree, va_gc>* arguments) {\n-    tree retval = error_mark_node;\n-    if (TREE_CODE(mfndecl) == FUNCTION_DECL) {\n-        // size_t len = arguments->length ();\n-        // size_t lparms = 0;\n-        // tree types = TYPE_ARG_TYPES (mfndecl);\n-\n-        /* really need to check the calling types and number of arguments */\n-        retval = build_call_expr_loc_vec(UNKNOWN_LOCATION, mfndecl, arguments);\n-    } else\n-        error(\"trying to call a function which isn't callable [%s]\",\n-              IDENTIFIER_POINTER(mfndecl));\n-    return retval;\n+static\n+tree dot_pass_genifyCall (tree mfndecl, vec<tree,va_gc> * arguments)\n+{\n+  tree retval = error_mark_node;\n+  if (TREE_CODE (mfndecl) == FUNCTION_DECL)\n+    {\n+      // size_t len = arguments->length ();\n+      // size_t lparms = 0;\n+      // tree types = TYPE_ARG_TYPES (mfndecl);\n+\n+      /* really need to check the calling types and number of arguments */\n+      retval = build_call_expr_loc_vec (UNKNOWN_LOCATION, mfndecl, arguments);\n+    }\n+  else\n+    error (\"trying to call a function which isn't callable [%s]\",\n+\t   IDENTIFIER_POINTER (mfndecl));\n+  return retval;\n }\n \n-// Seems to be an entry point for lowering an rdot dot expression - switches between their types and stuff\n-static tree dot_pass_lowerExpr(rdot dot, tree* block) {\n-    tree retval = error_mark_node;\n-    switch (RDOT_TYPE(dot)) {\n-        case D_PRIMITIVE: {\n-            retval = dot_pass_genScalar(dot);\n-            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n-        } break;\n-\n-        case D_IDENTIFIER: {\n-            const char* id = RDOT_IDENTIFIER_POINTER(dot);\n-            retval = dot_pass_lookupCTU(id);\n-            if (retval == error_mark_node)\n-                fatal_error(\"no such id [%s] in scope\", id);\n-            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n-        } break;\n-\n-        case D_STRUCT_INIT: {\n-            // need to go fetch the type and build the constructor...\n-            size_t count = 0;\n-            tree root_type = error_mark_node;\n-            dot_pass_rustToGccType__(dot, false, true, &root_type);\n-            gcc_assert(root_type != error_mark_node);\n-            tree fields = TYPE_FIELDS(root_type);\n-\n-            tree fnext;\n-            for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN(fnext))\n-                count++;\n-            fnext = error_mark_node;\n-\n-            vec<constructor_elt, va_gc>* init;\n-            vec_alloc(init, count + 1);\n-\n-            /*\n+static\n+tree dot_pass_lowerExpr (rdot dot, tree * block)\n+{\n+  tree retval = error_mark_node;\n+  switch (RDOT_TYPE (dot))\n+    {\n+    case D_PRIMITIVE:\n+      {\n+        retval = dot_pass_genScalar (dot);\n+        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n+      }\n+      break;\n+\n+    case D_IDENTIFIER:\n+      {\n+\tconst char * id = RDOT_IDENTIFIER_POINTER (dot);\n+\tretval = dot_pass_lookupCTU (id);\n+\tif (retval == error_mark_node)\n+\t  fatal_error (\"no such id [%s] in scope\", id);\n+        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n+      }\n+      break;\n+\n+    case D_STRUCT_INIT:\n+      {\n+\t// need to go fetch the type and build the constructor...\n+\tsize_t count = 0;\n+        tree root_type = error_mark_node;\n+\tdot_pass_rustToGccType__ (dot, false, true, &root_type);\n+        gcc_assert (root_type != error_mark_node);\n+\ttree fields = TYPE_FIELDS (root_type);\n+\n+\ttree fnext;\n+\tfor (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN (fnext))\n+\t  count++;\n+\tfnext = error_mark_node;\n+        \n+        vec<constructor_elt, va_gc> *init;\n+\tvec_alloc (init, count + 1);\n+\n+\t/*\n \t  FIXME this is all very buggy:\n \t  eg:\n \t  struct test {\n@@ -319,711 +359,844 @@ static tree dot_pass_lowerExpr(rdot dot, tree* block) {\n \t  initilize with test { x: 1, x: 1} will pass but it should fail\n \t  needs more validation at dataflow level and here\n \t */\n-            tree rid = create_tmp_var_name(RUST_TMP);\n-            retval = build_decl(RDOT_LOCATION(dot), VAR_DECL, rid, root_type);\n-            dot_pass_pushDecl(IDENTIFIER_POINTER(rid), retval);\n-\n-            constructor_elt empty = { NULL, NULL };\n-            rdot next;\n-            size_t valid = 0;\n-            for (next = RDOT_rhs_TT(dot); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-                constructor_elt* elt = init->quick_push(empty);\n-                gcc_assert(RDOT_TYPE(next) == D_STRUCT_PARAM);\n-                bool found = false;\n-                for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN(fnext)) {\n-                    const char* pid = IDENTIFIER_POINTER(DECL_NAME(fnext));\n-                    const char* sid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-                    if (strcmp(pid, sid) == 0) {\n-                        found = true;\n-                        break;\n-                    }\n-                }\n-                if (!found) {\n-                    error(\"Unable to find field [%s] in struct [%s]\",\n-                          IDENTIFIER_POINTER(TYPE_NAME(root_type)),\n-                          RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next)));\n-                    break;\n-                }\n-\n-                elt->index = fnext;\n-                elt->value = fold_convert(TREE_TYPE(fnext),\n-                                          dot_pass_lowerExpr(RDOT_rhs_TT(next),\n-                                                             block));\n-                valid++;\n-            }\n-            if (valid == count) {\n-                tree cons = build_constructor(root_type, init);\n-                append_to_statement_list(fold_build2_loc(RDOT_LOCATION(dot), INIT_EXPR, root_type, retval, cons), block);\n-            } else {\n-                fatal_error(\"Cannot initilize struct required [%lu] fields got [%lu]\",\n-                            valid,\n-                            count);\n-                // TODO better diagnostic make a map of the initilized so\n-                // we can display the un initilized to the user\n-            }\n-            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n-        } break;\n-\n-        case D_CALL_EXPR: {\n-            const char* fnid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(dot));\n-            rdot ptr;\n-            vec<tree, va_gc>* arguments;\n-            vec_alloc(arguments, 0);\n-            for (ptr = RDOT_rhs_TT(dot); ptr != NULL_DOT;\n-                 ptr = RDOT_CHAIN(ptr))\n-                vec_safe_push(arguments, dot_pass_lowerExpr(ptr, block));\n-            /* lookup the function prototype */\n-            tree lookup = dot_pass_lookupCTU(fnid);\n-            if (lookup != error_mark_node)\n-                retval = dot_pass_genifyCall(lookup, arguments);\n-            else {\n-                fatal_error(\"Unable to find callable %s\\n\", fnid);\n-                retval = error_mark_node;\n-            }\n-            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n-        } break;\n-\n-        case D_ATTRIB_REF: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree lookup = dot_pass_lowerExpr(lhs, block);\n-            switch (RDOT_TYPE(rhs)) {\n-                case D_CALL_EXPR: {\n-                    rdot crid = RDOT_lhs_TT(rhs);\n-                    const char* rlookup = RDOT_IDENTIFIER_POINTER(crid);\n-                    tree tid = TYPE_NAME(TREE_TYPE(lookup));\n-                    const char* ctid = IDENTIFIER_POINTER(tid);\n-\n-                    tree type_decl = dot_pass_lookupCTU(ctid);\n-                    // just to be sure but we will have already error'd at this point..\n-                    gcc_assert(type_decl != error_mark_node);\n-\n-                    tree mths = TYPE_METHODS(type_decl);\n-                    tree next;\n-                    for (next = mths; next != NULL_TREE; next = DECL_CHAIN(next)) {\n-                        const char* mid = IDENTIFIER_POINTER(DECL_NAME(next));\n-                        char* demangle = dot_pass_demangleImpl(mid);\n-                        if (strcmp(rlookup, demangle) == 0) {\n-                            vec<tree, va_gc>* cargs;\n-                            vec_alloc(cargs, 0);\n-                            vec_safe_push(cargs, lookup);\n-\n-                            rdot pnext;\n-                            for (pnext = RDOT_rhs_TT(rhs); pnext != NULL_DOT;\n-                                 pnext = RDOT_CHAIN(pnext))\n-                                vec_safe_push(cargs, dot_pass_lowerExpr(pnext, block));\n-\n-                            retval = dot_pass_genifyCall(next, cargs);\n-                            break;\n-                        }\n-                    }\n-                } break;\n-\n-                case D_IDENTIFIER: {\n-                    const char* rlookup = RDOT_IDENTIFIER_POINTER(rhs);\n-                    tree fields = TYPE_FIELDS(TREE_TYPE(lookup));\n-                    tree next;\n-                    for (next = fields; next != NULL_TREE; next = DECL_CHAIN(next)) {\n-                        const char* fid = IDENTIFIER_POINTER(DECL_NAME(next));\n-                        if (strcmp(rlookup, fid) == 0) {\n-                            /* no idea why we need build3 here but build2 fails... */\n-                            retval = build3(COMPONENT_REF, TREE_TYPE(next), lookup, next, NULL_TREE);\n-                            break;\n-                        }\n-                    }\n-                } break;\n-\n-                default:\n-                    fatal_error(\"Really don't know what happened here!\\n\");\n-                    break;\n-            }\n-        } break;\n-\n-        case D_MODIFY_EXPR: {\n-            tree assignment = dot_pass_lowerExpr(RDOT_rhs_TT(dot), block);\n-            tree decl = dot_pass_lowerExpr(RDOT_lhs_TT(dot), block);\n-            retval = build2(MODIFY_EXPR, TREE_TYPE(decl), decl, assignment);\n-        } break;\n-\n-        case D_ADD_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree xlhs = dot_pass_lowerExpr(lhs, block);\n-            tree xrhs = dot_pass_lowerExpr(rhs, block);\n-\n-            retval = build2(PLUS_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n-        } break;\n-\n-        case D_MINUS_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree xlhs = dot_pass_lowerExpr(lhs, block);\n-            tree xrhs = dot_pass_lowerExpr(rhs, block);\n-\n-            retval = build2(MINUS_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n-        } break;\n-\n-        case D_MULT_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree xlhs = dot_pass_lowerExpr(lhs, block);\n-            tree xrhs = dot_pass_lowerExpr(rhs, block);\n-\n-            retval = build2(MULT_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n-        } break;\n-\n-        case D_LESS_EQ_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree xlhs = dot_pass_lowerExpr(lhs, block);\n-            tree xrhs = dot_pass_lowerExpr(rhs, block);\n-\n-            retval = build2(LE_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n-        } break;\n-\n-        case D_EQ_EQ_EXPR: {\n-            rdot lhs = RDOT_lhs_TT(dot);\n-            rdot rhs = RDOT_rhs_TT(dot);\n-\n-            tree xlhs = dot_pass_lowerExpr(lhs, block);\n-            tree xrhs = dot_pass_lowerExpr(rhs, block);\n-\n-            retval = build2(EQ_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n-        } break;\n-\n-        case D_VAR_DECL: {\n-            const char* varID = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(dot));\n-            bool consty = RDOT_qual(dot);\n-            tree gcc_type = dot_pass_rustToGccType(RDOT_rhs_TT(dot), consty);\n-            tree decl = build_decl(RDOT_LOCATION(dot),\n-                                   VAR_DECL,\n-                                   get_identifier(varID),\n-                                   gcc_type);\n-            if (dot_pass_lookupCTU(varID) == error_mark_node)\n-                dot_pass_pushDecl(varID, decl);\n-            retval = decl;\n-        } break;\n-\n-        case D_ACC_EXPR: {\n-            rdot impl = RDOT_lhs_TT(dot);\n-            char* implid = RDOT_IDENTIFIER_POINTER(impl);\n-            printf(\"implid = %s\\n\", implid);\n-        } break;\n-\n-        default:\n-            error(\"unhandled binary operation type [%s]!\\n\", RDOT_OPCODE_STR(dot));\n-            break;\n+        tree rid = create_tmp_var_name (RUST_TMP);\n+        retval = build_decl (RDOT_LOCATION (dot), VAR_DECL, rid, root_type);\n+        dot_pass_pushDecl (IDENTIFIER_POINTER (rid), retval);\n+\n+        constructor_elt empty = {NULL, NULL};\n+\trdot next;\n+\tsize_t valid = 0;\n+\tfor (next = RDOT_rhs_TT (dot); next != NULL_DOT; next = RDOT_CHAIN (next))\n+\t  {\n+            constructor_elt* elt = init->quick_push (empty);\n+            gcc_assert (RDOT_TYPE (next) == D_STRUCT_PARAM);\n+\t    bool found = false;\n+\t    for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN (fnext))\n+\t      {\n+\t\tconst char * pid = IDENTIFIER_POINTER (DECL_NAME (fnext));\n+\t\tconst char * sid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+\t\tif (strcmp (pid, sid) == 0)\n+\t\t  {\n+\t\t    found = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if (!found)\n+\t      {\n+\t\terror (\"Unable to find field [%s] in struct [%s]\",\n+\t\t       IDENTIFIER_POINTER (TYPE_NAME (root_type)),\n+\t\t       RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next)));\n+\t\tbreak;\n+\t      }\n+\n+            elt->index = fnext;\n+            elt->value = fold_convert (TREE_TYPE (fnext),\n+                                       dot_pass_lowerExpr (RDOT_rhs_TT (next),\n+                                                           block));\n+\t    valid++;\n+\t  }\n+\tif (valid == count)\n+          {\n+            tree cons = build_constructor (root_type, init);\n+            append_to_statement_list (fold_build2_loc (RDOT_LOCATION (dot), INIT_EXPR,\n+                                                       root_type, retval, cons), block);\n+          }\n+        else\n+          {\n+            fatal_error (\"Cannot initilize struct required [%lu] fields got [%lu]\",\n+                         valid, count);\n+\t    // TODO better diagnostic make a map of the initilized so\n+\t    // we can display the un initilized to the user\n+\t  }\n+\tRDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n+      }\n+      break;\n+\n+    case D_CALL_EXPR:\n+      {\n+        const char * fnid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (dot));\n+        rdot ptr;\n+        vec<tree,va_gc> * arguments;\n+        vec_alloc (arguments, 0);\n+        for (ptr = RDOT_rhs_TT (dot); ptr != NULL_DOT;\n+             ptr = RDOT_CHAIN (ptr))\n+          vec_safe_push (arguments, dot_pass_lowerExpr (ptr, block));\n+        /* lookup the function prototype */\n+        tree lookup = dot_pass_lookupCTU (fnid);\n+        if (lookup != error_mark_node)\n+          retval = dot_pass_genifyCall (lookup, arguments);\n+        else\n+          {\n+            fatal_error (\"Unable to find callable %s\\n\", fnid);\n+            retval = error_mark_node;\n+          }\n+        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n+      }\n+      break;\n+\n+    case D_ATTRIB_REF:\n+      {\n+\trdot lhs = RDOT_lhs_TT (dot);\n+\trdot rhs = RDOT_rhs_TT (dot);\n+\n+\ttree lookup = dot_pass_lowerExpr (lhs, block);\n+\tswitch (RDOT_TYPE (rhs))\n+\t  {\n+\t  case D_CALL_EXPR:\n+\t    {\n+\t      rdot crid = RDOT_lhs_TT (rhs);\n+\t      const char * rlookup = RDOT_IDENTIFIER_POINTER (crid);\n+\t      tree tid = TYPE_NAME (TREE_TYPE (lookup));\n+\t      const char * ctid = IDENTIFIER_POINTER (tid);\n+\n+\t      tree type_decl = dot_pass_lookupCTU (ctid);\n+\t      // just to be sure but we will have already error'd at this point..\n+\t      gcc_assert (type_decl != error_mark_node);\n+\n+\t      tree mths = TYPE_METHODS (type_decl);\n+\t      tree next;\n+\t      for (next = mths; next != NULL_TREE; next = DECL_CHAIN (next))\n+\t\t{\n+\t\t  const char * mid = IDENTIFIER_POINTER (DECL_NAME (next));\n+\t\t  char * demangle = dot_pass_demangleImpl (mid);\n+\t\t  if (strcmp (rlookup, demangle) == 0)\n+\t\t    {\n+\t\t      vec<tree,va_gc> * cargs;\n+\t\t      vec_alloc (cargs, 0);\n+\t\t      vec_safe_push (cargs, lookup);\n+\n+\t\t      rdot pnext;\n+\t\t      for (pnext = RDOT_rhs_TT (rhs); pnext != NULL_DOT;\n+\t\t\t   pnext = RDOT_CHAIN (pnext))\n+\t\t\tvec_safe_push (cargs, dot_pass_lowerExpr (pnext, block));\n+\n+\t\t      retval = dot_pass_genifyCall (next, cargs);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case D_IDENTIFIER:\n+\t    {\n+\t      const char * rlookup = RDOT_IDENTIFIER_POINTER (rhs);\n+\t      tree fields = TYPE_FIELDS (TREE_TYPE (lookup));\n+\t      tree next;\n+\t      for (next = fields; next != NULL_TREE; next = DECL_CHAIN (next))\n+\t\t{\n+\t\t  const char * fid = IDENTIFIER_POINTER (DECL_NAME (next));\n+\t\t  if (strcmp (rlookup, fid) == 0)\n+\t\t    {\n+\t\t      /* no idea why we need build3 here but build2 fails... */\n+\t\t      retval = build3 (COMPONENT_REF, TREE_TYPE (next),\n+\t\t\t\t       lookup, next, NULL_TREE);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  default:\n+\t    fatal_error (\"Really don't know what happened here!\\n\");\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+    case D_MODIFY_EXPR:\n+      {\n+\ttree assignment = dot_pass_lowerExpr (RDOT_rhs_TT (dot), block);\n+\ttree decl = dot_pass_lowerExpr (RDOT_lhs_TT (dot), block);\n+        retval = build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, assignment);\n+      }\n+      break;\n+\n+    case D_ADD_EXPR:\n+      {\n+\trdot lhs = RDOT_lhs_TT (dot);\n+        rdot rhs = RDOT_rhs_TT (dot);\n+\n+        tree xlhs = dot_pass_lowerExpr (lhs, block);\n+        tree xrhs = dot_pass_lowerExpr (rhs, block);\n+\n+\tretval = build2 (PLUS_EXPR, TREE_TYPE (xlhs),\n+\t\t\t xlhs, xrhs);\n+      }\n+      break;\n+\n+    case D_MINUS_EXPR:\n+      {\n+\trdot lhs = RDOT_lhs_TT (dot);\n+        rdot rhs = RDOT_rhs_TT (dot);\n+\n+        tree xlhs = dot_pass_lowerExpr (lhs, block);\n+        tree xrhs = dot_pass_lowerExpr (rhs, block);\n+\n+\tretval = build2 (MINUS_EXPR, TREE_TYPE (xlhs),\n+\t\t\t xlhs, xrhs);\n+      }\n+      break;\n+\n+      case D_MULT_EXPR:\n+      {\n+\trdot lhs = RDOT_lhs_TT (dot);\n+        rdot rhs = RDOT_rhs_TT (dot);\n+\n+        tree xlhs = dot_pass_lowerExpr (lhs, block);\n+        tree xrhs = dot_pass_lowerExpr (rhs, block);\n+\n+\tretval = build2 (MULT_EXPR, TREE_TYPE (xlhs),\n+\t\t\t xlhs, xrhs);\n+      }\n+      break;\n+\n+      case D_LESS_EQ_EXPR:\n+      {\n+\trdot lhs = RDOT_lhs_TT (dot);\n+        rdot rhs = RDOT_rhs_TT (dot);\n+\n+        tree xlhs = dot_pass_lowerExpr (lhs, block);\n+        tree xrhs = dot_pass_lowerExpr (rhs, block);\n+\n+\tretval = build2 (LE_EXPR, TREE_TYPE (xlhs),\n+\t\t\t xlhs, xrhs);\n+      }\n+      break;\n+\n+    case D_EQ_EQ_EXPR:\n+      {\n+        rdot lhs = RDOT_lhs_TT (dot);\n+        rdot rhs = RDOT_rhs_TT (dot);\n+\n+        tree xlhs = dot_pass_lowerExpr (lhs, block);\n+        tree xrhs = dot_pass_lowerExpr (rhs, block);\n+\n+\tretval = build2 (EQ_EXPR, TREE_TYPE (xlhs),\n+\t\t\t xlhs, xrhs);\n+      }\n+      break;\n+\n+    case D_VAR_DECL:\n+        {\n+          const char * varID = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (dot));\n+          bool consty = RDOT_qual (dot);\n+          tree gcc_type = dot_pass_rustToGccType (RDOT_rhs_TT (dot), consty);\n+          tree decl = build_decl (RDOT_LOCATION (dot),\n+                                  VAR_DECL, get_identifier (varID),\n+                                  gcc_type);\n+          if (dot_pass_lookupCTU (varID) == error_mark_node)\n+            dot_pass_pushDecl (varID, decl);\n+          retval = decl;\n+        }\n+      break;\n+\n+    case D_ACC_EXPR:\n+      {\n+\trdot impl = RDOT_lhs_TT (dot);\n+\tchar * implid = RDOT_IDENTIFIER_POINTER (impl);\n+\tprintf (\"implid = %s\\n\", implid);\n+      }\n+      break;\n+\n+    default:\n+      error (\"unhandled binary operation type [%s]!\\n\", RDOT_OPCODE_STR (dot));\n+      break;\n     }\n \n-    if (DOT_RETVAL(dot)) {\n-        if (global_retDecl != error_mark_node) {\n-            tree retass = fold_build2_loc(RDOT_LOCATION(dot),\n-                                          MODIFY_EXPR,\n-                                          TREE_TYPE(global_retDecl),\n-                                          global_retDecl,\n-                                          retval);\n-            append_to_statement_list(retass, block);\n-            global_retDecl_ = true;\n-            retval = global_retDecl;\n+  if (DOT_RETVAL (dot))\n+    {\n+      if (global_retDecl != error_mark_node)\n+        {\n+          tree retass = fold_build2_loc (RDOT_LOCATION (dot),\n+                                         MODIFY_EXPR, TREE_TYPE (global_retDecl),\n+                                         global_retDecl, retval);\n+          append_to_statement_list (retass, block);\n+          global_retDecl_ = true;\n+          retval = global_retDecl;\n         }\n     }\n \n-    return retval;\n+  return retval;\n }\n \n-// Seems to be an entry point for lowering conditionals (if stmnts) and adding them to the statement list\n-static void dot_pass_compileCond(rdot node, tree* block) {\n-    rdot ifblock = RDOT_lhs_TT(node);\n-    rdot elseblock = RDOT_rhs_TT(node);\n-\n-    tree endif_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"ENDIF\"), void_type_node);\n-    tree endif_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, endif_label_decl);\n-    DECL_CONTEXT(endif_label_decl) = current_function_decl;\n-\n-    tree else_label_expr = error_mark_node;\n-    tree else_label_decl = error_mark_node;\n-    if (elseblock != NULL_DOT) {\n-        else_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"ELSE\"), void_type_node);\n-        else_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, else_label_decl);\n-        DECL_CONTEXT(else_label_decl) = current_function_decl;\n-    } else {\n-        else_label_expr = endif_label_expr;\n-        else_label_decl = endif_label_decl;\n+static\n+void dot_pass_compileCond (rdot node, tree * block)\n+{\n+  rdot ifblock = RDOT_lhs_TT (node);\n+  rdot elseblock = RDOT_rhs_TT (node);\n+\n+  tree endif_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t      create_tmp_var_name (\"ENDIF\"),\n+\t\t\t\t      void_type_node);\n+  tree endif_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t   void_type_node, endif_label_decl);\n+  DECL_CONTEXT (endif_label_decl) = current_function_decl;\n+\n+  tree else_label_expr = error_mark_node;\n+  tree else_label_decl = error_mark_node;\n+  if (elseblock != NULL_DOT)\n+    {\n+      else_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t    create_tmp_var_name (\"ELSE\"),\n+\t\t\t\t    void_type_node);\n+      else_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t void_type_node, else_label_decl);\n+      DECL_CONTEXT (else_label_decl) = current_function_decl;\n+    }\n+  else\n+    {\n+      else_label_expr = endif_label_expr;\n+      else_label_decl = endif_label_decl;\n     }\n \n-    tree cond = dot_pass_lowerExpr(RDOT_lhs_TT(ifblock), block);\n-    tree conditional = build3_loc(RDOT_LOCATION(node), COND_EXPR, void_type_node, cond, NULL_TREE, build1(GOTO_EXPR, void_type_node, else_label_decl));\n-\n-    append_to_statement_list(conditional, block);\n-    dot_pass_compileSuite(RDOT_rhs_TT(ifblock), block);\n-    append_to_statement_list(build1(GOTO_EXPR, void_type_node, endif_label_decl),\n-                             block);\n-    if (elseblock) {\n-        append_to_statement_list(else_label_expr, block);\n-        dot_pass_compileSuite(RDOT_lhs_TT(elseblock), block);\n-        append_to_statement_list(endif_label_expr, block);\n-    } else\n-        append_to_statement_list(endif_label_expr, block);\n+  tree cond = dot_pass_lowerExpr (RDOT_lhs_TT (ifblock), block);\n+  tree conditional = build3_loc (RDOT_LOCATION (node), COND_EXPR, void_type_node,\n+\t\t\t\t cond,\n+\t\t\t\t NULL_TREE,\n+\t\t\t\t build1 (GOTO_EXPR, void_type_node, else_label_decl));\n+\n+  append_to_statement_list (conditional, block);\n+  dot_pass_compileSuite (RDOT_rhs_TT (ifblock), block);\n+  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, endif_label_decl),\n+\t\t\t    block);\n+  if (elseblock)\n+    {\n+      append_to_statement_list (else_label_expr, block);\n+      dot_pass_compileSuite (RDOT_lhs_TT (elseblock), block);\n+      append_to_statement_list (endif_label_expr, block);\n+    }\n+  else\n+    append_to_statement_list (endif_label_expr, block);\n }\n \n-// Seems to be an entry point for lowering breaks (as in loops) and adding them to a statement list\n-static void dot_pass_compileBreak(rdot node, tree* block) {\n-    size_t lts = __loopContexts.size();\n-    if (lts > 0)\n-        append_to_statement_list(fold_build1_loc(RDOT_LOCATION(node), GOTO_EXPR, void_type_node, __loopContexts.back()),\n-                                 block);\n-    else\n-        error(\"break outside of loop context\");\n+static\n+void dot_pass_compileBreak (rdot node, tree * block)\n+{\n+  size_t lts = __loopContexts.size ();\n+  if (lts > 0)\n+    append_to_statement_list (fold_build1_loc (RDOT_LOCATION (node), GOTO_EXPR,\n+                                               void_type_node,\n+                                               __loopContexts.back ()),\n+                              block);\n+  else\n+    error (\"break outside of loop context\");\n }\n \n-// Seems to be an entry point for lowering loops and appending them to statement list - possibly Rust type loop?\n-static void dot_pass_compileLoop(rdot node, tree* block) {\n-    tree start_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"START\"), void_type_node);\n-    tree start_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, start_label_decl);\n-    DECL_CONTEXT(start_label_decl) = current_function_decl;\n-\n-    tree end_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"END\"), void_type_node);\n-    tree end_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, end_label_decl);\n-    DECL_CONTEXT(end_label_decl) = current_function_decl;\n-    __loopContexts.push_back(end_label_decl);\n-\n-    /* -- -- -- */\n-    append_to_statement_list(start_label_expr, block);\n-\n-    dot_pass_compileSuite(RDOT_lhs_TT(node), block);\n-    append_to_statement_list(build1(GOTO_EXPR, void_type_node, start_label_decl), block);\n-    append_to_statement_list(end_label_expr, block);\n-\n-    __loopContexts.pop_back();\n+static\n+void dot_pass_compileLoop (rdot node, tree * block)\n+{\n+  tree start_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t      create_tmp_var_name (\"START\"),\n+\t\t\t\t      void_type_node);\n+  tree start_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t   void_type_node, start_label_decl);\n+  DECL_CONTEXT (start_label_decl) = current_function_decl;\n+\n+  tree end_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t    create_tmp_var_name (\"END\"),\n+\t\t\t\t    void_type_node);\n+  tree end_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t void_type_node, end_label_decl);\n+  DECL_CONTEXT (end_label_decl) = current_function_decl;\n+  __loopContexts.push_back (end_label_decl);\n+\n+  /* -- -- -- */\n+  append_to_statement_list (start_label_expr, block);\n+\n+  dot_pass_compileSuite (RDOT_lhs_TT (node), block);\n+  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, start_label_decl), block);\n+  append_to_statement_list (end_label_expr, block);\n+  \n+  __loopContexts.pop_back ();\n+  \n }\n \n-// Seems to be an entry point for lowering while loops and adding them to statement list\n-static void dot_pass_compileWhile(rdot node, tree* block) {\n-    rdot condition = RDOT_lhs_TT(node);\n-    rdot suite = RDOT_rhs_TT(node);\n-\n-    tree start_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"START\"), void_type_node);\n-    tree start_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, start_label_decl);\n-    DECL_CONTEXT(start_label_decl) = current_function_decl;\n-\n-    tree end_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"END\"), void_type_node);\n-    tree end_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, end_label_decl);\n-    DECL_CONTEXT(end_label_decl) = current_function_decl;\n-    __loopContexts.push_back(end_label_decl);\n-\n-    /* -- -- -- */\n-    append_to_statement_list(start_label_expr, block);\n-\n-    tree cond = dot_pass_lowerExpr(condition, block);\n-    tree conditional = build3_loc(RDOT_LOCATION(node), COND_EXPR, void_type_node, cond, NULL_TREE, build1(GOTO_EXPR, void_type_node, end_label_decl));\n-    append_to_statement_list(conditional, block);\n-    dot_pass_compileSuite(suite, block);\n-    append_to_statement_list(build1(GOTO_EXPR, void_type_node, start_label_decl), block);\n-    append_to_statement_list(end_label_expr, block);\n-\n-    __loopContexts.pop_back();\n+static\n+void dot_pass_compileWhile (rdot node, tree * block)\n+{\n+  rdot condition = RDOT_lhs_TT (node);\n+  rdot suite = RDOT_rhs_TT (node);\n+\n+  tree start_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t      create_tmp_var_name (\"START\"),\n+\t\t\t\t      void_type_node);\n+  tree start_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t   void_type_node, start_label_decl);\n+  DECL_CONTEXT (start_label_decl) = current_function_decl;\n+\n+  tree end_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n+\t\t\t\t    create_tmp_var_name (\"END\"),\n+\t\t\t\t    void_type_node);\n+  tree end_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n+\t\t\t\t\t void_type_node, end_label_decl);\n+  DECL_CONTEXT (end_label_decl) = current_function_decl;\n+  __loopContexts.push_back (end_label_decl);\n+\n+  /* -- -- -- */\n+  append_to_statement_list (start_label_expr, block);\n+\n+  tree cond = dot_pass_lowerExpr (condition, block);\n+  tree conditional = build3_loc (RDOT_LOCATION (node), COND_EXPR, void_type_node,\n+\t\t\t\t cond, NULL_TREE,\n+\t\t\t\t build1 (GOTO_EXPR, void_type_node, end_label_decl));\n+  append_to_statement_list (conditional, block);\n+  dot_pass_compileSuite (suite, block);\n+  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, start_label_decl), block);\n+  append_to_statement_list (end_label_expr, block);\n+  \n+  __loopContexts.pop_back ();\n }\n \n-// Seems to be an entry point for lowering a series (suite?) of control statements and fields - usage suggests possibly lowering a block\n-static void dot_pass_compileSuite(rdot suite, tree* block) {\n-    rdot node;\n-    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n-        if (RDOT_T_FIELD(node) == D_D_EXPR)\n-            append_to_statement_list(dot_pass_lowerExpr(node, block), block);\n-        else {\n-            switch (RDOT_TYPE(node)) {\n-                case D_STRUCT_IF:\n-                    dot_pass_compileCond(node, block);\n-                    break;\n-\n-                case D_STRUCT_WHILE:\n-                    dot_pass_compileWhile(node, block);\n-                    break;\n-\n-                case D_STRUCT_LOOP:\n-                    dot_pass_compileLoop(node, block);\n-                    break;\n-\n-                case C_BREAK_STMT:\n-                    dot_pass_compileBreak(node, block);\n-                    break;\n-\n-                default:\n-                    error(\"Unhandled statement [%s]\\n\", RDOT_OPCODE_STR(node));\n-                    break;\n+static\n+void dot_pass_compileSuite (rdot suite, tree * block)\n+{\n+  rdot node;\n+  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n+    {\n+      if (RDOT_T_FIELD (node) ==  D_D_EXPR)\n+\tappend_to_statement_list (dot_pass_lowerExpr (node, block), block);\n+      else\n+        {\n+          switch (RDOT_TYPE (node))\n+            {\n+            case D_STRUCT_IF:\n+              dot_pass_compileCond (node, block);\n+              break;\n+              \n+\t    case D_STRUCT_WHILE:\n+\t      dot_pass_compileWhile (node, block);\n+\t      break;\n+              \n+            case D_STRUCT_LOOP:\n+              dot_pass_compileLoop (node, block);\n+              break;\n+\n+            case C_BREAK_STMT:\n+              dot_pass_compileBreak (node, block);\n+              break;\n+\n+            default:\n+              error (\"Unhandled statement [%s]\\n\", RDOT_OPCODE_STR (node));\n+              break;\n             }\n         }\n     }\n }\n \n-// Seems to be an entry point for generating method prototypes from an rdot node and adding them to list\n-static void dot_pass_genMethodProto(rdot node) {\n-    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-    if (dot_pass_lookupCTU(method_id) != error_mark_node) {\n-        error(\"Duplicate declaration of function [%s]\\n\", method_id);\n-        return;\n+static\n+void dot_pass_genMethodProto (rdot node)\n+{\n+  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+  if (dot_pass_lookupCTU (method_id) != error_mark_node)\n+    {\n+      error (\"Duplicate declaration of function [%s]\\n\", method_id);\n+      return;\n     }\n-    tree rtype = void_type_node;\n-    if (RDOT_FIELD2(node))\n-        rtype = dot_pass_rustToGccType(RDOT_FIELD2(node), false);\n-\n-    rdot parameters = RDOT_lhs_TT(node);\n-    tree fntype = error_mark_node;\n-    if (parameters != NULL_DOT) {\n-        size_t nparams = 0;\n-        rdot prm;\n-        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm))\n-            nparams++;\n-\n-        tree* gccparams = XALLOCAVEC(tree, nparams);\n-        size_t i = 0;\n-        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm)) {\n-            bool mut = false;\n-            if (RDOT_qual(prm))\n-                mut = true;\n-            gccparams[i] = dot_pass_rustToGccType(RDOT_rhs_TT(prm), mut);\n-            i++;\n-        }\n-        fntype = build_function_type_array(rtype, nparams, gccparams);\n-    } else\n-        fntype = build_function_type_list(rtype, NULL_TREE);\n+  tree rtype = void_type_node;\n+  if (RDOT_FIELD2 (node))\n+    rtype = dot_pass_rustToGccType (RDOT_FIELD2 (node), false);\n+\n+  rdot parameters = RDOT_lhs_TT (node);\n+  tree fntype = error_mark_node;\n+  if (parameters != NULL_DOT)\n+    {\n+      size_t nparams = 0;\n+      rdot prm;\n+      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n+\tnparams++;\n+\n+      tree * gccparams = XALLOCAVEC (tree, nparams);\n+      size_t i = 0;\n+      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n+\t{\n+\t  bool mut = false;\n+\t  if (RDOT_qual (prm))\n+\t    mut = true;\n+\t  gccparams [i] = dot_pass_rustToGccType (RDOT_rhs_TT (prm), mut);\n+\t  i++;\n+\t}\n+      fntype = build_function_type_array (rtype, nparams, gccparams);\n+    }\n+  else\n+    fntype = build_function_type_list (rtype, NULL_TREE);\n \n-    tree fndecl = dot_pass_genFndecl_Basic(RDOT_LOCATION(node), method_id, fntype);\n-    SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier(dot_pass_mangle(method_id)));\n-    dot_pass_pushDecl(method_id, fndecl);\n+  tree fndecl = dot_pass_genFndecl_Basic (RDOT_LOCATION (node), method_id, fntype);\n+  SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier (dot_pass_mangle (method_id)));\n+  dot_pass_pushDecl (method_id, fndecl);\n }\n \n-// Seems to parse and then gimplify an rdot node corresponding to a function tree? - potentially the main entry point, as gcc docs indicate compilation is done on a function-level\n-static tree dot_pass_genifyTopFndecl(rdot node) {\n-    const char* method_id;\n-    if (__impl_type_decl != error_mark_node) {\n-        char* mid = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-        tree spfx = TYPE_NAME(__impl_type_decl);\n-        const char* pfx = IDENTIFIER_POINTER(spfx);\n-\n-        size_t len = strlen(mid) + strlen(pfx) + 2;\n-        size_t bsize = len * sizeof(char);\n-        char* buffer = (char*)alloca(bsize);\n-        gcc_assert(buffer);\n-        memset(buffer, 0, bsize);\n-\n-        snprintf(buffer, bsize, \"%s.%s\", pfx, mid);\n-        method_id = buffer;\n-    } else\n-        method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-\n-    tree rtype = void_type_node;\n-    if (RDOT_FIELD2(node))\n-        rtype = dot_pass_rustToGccType(RDOT_FIELD2(node), false);\n-\n-    rdot parameters = RDOT_lhs_TT(node);\n-    tree fntype = error_mark_node;\n-    if (parameters != NULL_DOT) {\n-        size_t nparams = 0;\n-        rdot prm;\n-        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm))\n-            nparams++;\n-\n-        tree* gccparams = XALLOCAVEC(tree, nparams);\n-        size_t i = 0;\n-        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm)) {\n-            bool mut = false;\n-            if (RDOT_qual(prm))\n-                mut = true;\n-\n-            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(prm));\n-            if (strcmp(pid, \"self\") == 0) {\n-                fatal_error(\"unhandled self argument!\");\n-            } else\n-                gccparams[i] = dot_pass_rustToGccType(RDOT_rhs_TT(prm), mut);\n-            i++;\n-        }\n-        fntype = build_function_type_array(rtype, nparams, gccparams);\n-    } else\n-        fntype = build_function_type_list(rtype, NULL_TREE);\n-\n-    tree fndecl = dot_pass_genFndecl_Basic(RDOT_LOCATION(node), method_id, fntype);\n-    SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier(dot_pass_mangle(method_id)));\n-    dot_pass_pushContext();\n-\n-    rdot rdot_params = RDOT_lhs_TT(node);\n-    if (rdot_params != NULL_DOT) {\n-        tree argslist = NULL_TREE;\n-        rdot next;\n-        for (next = rdot_params; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-            if (dot_pass_lookupCTU(pid) != error_mark_node)\n-                error(\"paramater [%s] is already declared\", pid);\n-\n-            tree ptype = error_mark_node;\n-            if (strcmp(pid, \"self\") == 0) {\n-                fatal_error(\"unhandled self param!\");\n-            } else\n-                ptype = dot_pass_rustToGccType(RDOT_rhs_TT(next), false);\n-\n-            tree param = build_decl(RDOT_LOCATION(node), PARM_DECL, get_identifier(pid), ptype);\n-            DECL_CONTEXT(param) = fndecl;\n-            DECL_ARG_TYPE(param) = ptype;\n-            TREE_READONLY(param) = true;\n-            TREE_USED(param) = true;\n-            argslist = chainon(argslist, param);\n-\n-            dot_pass_pushDecl(pid, param);\n-        }\n-        DECL_ARGUMENTS(fndecl) = argslist;\n+static\n+tree dot_pass_genifyTopFndecl (rdot node)\n+{\n+  const char * method_id;\n+  if (__impl_type_decl != error_mark_node)\n+    {\n+      char * mid = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+      tree spfx = TYPE_NAME (__impl_type_decl);\n+      const char *pfx = IDENTIFIER_POINTER (spfx);\n+\n+      size_t len = strlen (mid) + strlen (pfx) + 2;\n+      size_t bsize = len * sizeof (char);\n+      char * buffer = (char *) alloca (bsize);\n+      gcc_assert (buffer);\n+      memset (buffer, 0, bsize);\n+\n+      snprintf (buffer, bsize, \"%s.%s\", pfx, mid);\n+      method_id = buffer;\n+    }\n+  else\n+    method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+\n+  tree rtype = void_type_node;\n+  if (RDOT_FIELD2 (node))\n+    rtype = dot_pass_rustToGccType (RDOT_FIELD2 (node), false);\n+\n+  rdot parameters = RDOT_lhs_TT (node);\n+  tree fntype = error_mark_node;\n+  if (parameters != NULL_DOT)\n+    {\n+      size_t nparams = 0;\n+      rdot prm;\n+      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n+\tnparams++;\n+\n+      tree * gccparams = XALLOCAVEC (tree, nparams);\n+      size_t i = 0;\n+      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n+\t{\n+\t  bool mut = false;\n+\t  if (RDOT_qual (prm))\n+\t    mut = true;\n+\n+\t  const char * pid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (prm));\n+\t  if (strcmp (pid, \"self\") == 0)\n+\t    {\n+              fatal_error (\"unhandled self argument!\");\n+\t    }\n+\t  else\n+\t    gccparams [i] = dot_pass_rustToGccType (RDOT_rhs_TT (prm), mut);\n+\t  i++;\n+\t}\n+      fntype = build_function_type_array (rtype, nparams, gccparams);\n+    }\n+  else\n+    fntype = build_function_type_list (rtype, NULL_TREE);\n+\n+  tree fndecl = dot_pass_genFndecl_Basic (RDOT_LOCATION (node), method_id, fntype);\n+  SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier (dot_pass_mangle (method_id)));\n+  dot_pass_pushContext ();\n+  \n+  rdot rdot_params = RDOT_lhs_TT (node);\n+  if (rdot_params != NULL_DOT)\n+    {\n+      tree argslist = NULL_TREE;\n+      rdot next;\n+      for (next = rdot_params; next != NULL_DOT; next = RDOT_CHAIN (next))\n+\t{\n+\t  const char * pid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+\t  if (dot_pass_lookupCTU (pid) != error_mark_node)\n+\t    error (\"paramater [%s] is already declared\", pid);\n+\n+\t  tree ptype = error_mark_node;\n+\t  if (strcmp (pid, \"self\") == 0)\n+\t    {\n+              fatal_error (\"unhandled self param!\");\n+\t    }\n+\t  else\n+\t    ptype = dot_pass_rustToGccType (RDOT_rhs_TT (next), false);\n+\n+\t  tree param = build_decl (RDOT_LOCATION (node), PARM_DECL,\n+\t\t\t\t   get_identifier (pid), ptype);\n+\t  DECL_CONTEXT (param) = fndecl;\n+\t  DECL_ARG_TYPE (param) = ptype;\n+\t  TREE_READONLY (param) = true;\n+\t  TREE_USED (param) = true;\n+\t  argslist = chainon (argslist, param);\n+\n+\t  dot_pass_pushDecl (pid, param);\n+\t}\n+      DECL_ARGUMENTS (fndecl) = argslist;\n     }\n \n-    current_function_decl = fndecl;\n-    tree block = alloc_stmt_list();\n-    current_function_block = &block;\n-\n-    global_retDecl_ = false;\n-    if (rtype == void_type_node)\n-        global_retDecl = error_mark_node;\n-    else\n-        global_retDecl = DECL_RESULT(fndecl);\n-\n-    // compile the block...\n-    dot_pass_compileSuite(RDOT_rhs_TT(node), &block);\n+  current_function_decl = fndecl;\n+  tree block = alloc_stmt_list ();\n+  current_function_block = &block;\n \n-    // make sure it returns something!!!\n-    if (rtype != void_type_node) {\n-        if (global_retDecl_ == false) {\n-            error(\"Function [%s] doesn't seem to return anything!!\\n\", method_id);\n-            return error_mark_node;\n+  global_retDecl_ = false;\n+  if (rtype == void_type_node)\n+    global_retDecl = error_mark_node;\n+  else\n+    global_retDecl = DECL_RESULT (fndecl);\n+\n+  // compile the block...\n+  dot_pass_compileSuite (RDOT_rhs_TT (node), &block);\n+\n+  // make sure it returns something!!!\n+  if (rtype != void_type_node)\n+    {\n+      if (global_retDecl_ == false)\n+        {\n+          error (\"Function [%s] doesn't seem to return anything!!\\n\", method_id);\n+          return error_mark_node;\n         }\n-        tree returnVal = build1(RETURN_EXPR, rtype, global_retDecl);\n-        append_to_statement_list(returnVal, &block);\n+      tree returnVal = build1 (RETURN_EXPR, rtype, global_retDecl);\n+      append_to_statement_list (returnVal, &block);\n     }\n \n-    tree bind = NULL_TREE;\n-    tree declare_vars = DECL_RESULT(fndecl);\n-\n-    tree head = declare_vars;\n-    std::vector<tree>* decl_vars = dot_pass_popContext();\n-    std::vector<tree>::iterator it;\n-    for (it = decl_vars->begin(); it != decl_vars->end(); ++it) {\n-        if (TREE_CODE(*it) != PARM_DECL) {\n-            DECL_CHAIN(head) = *it;\n-            head = *it;\n-        }\n+  tree bind = NULL_TREE;\n+  tree declare_vars = DECL_RESULT (fndecl);\n+\n+  tree head = declare_vars;\n+  std::vector<tree> * decl_vars = dot_pass_popContext ();\n+  std::vector<tree>::iterator it;\n+  for (it = decl_vars->begin (); it != decl_vars->end (); ++it)\n+    {\n+      if (TREE_CODE (*it) != PARM_DECL)\n+\t{\n+\t  DECL_CHAIN (head) = *it;\n+\t  head = *it;\n+\t}\n     }\n-    delete decl_vars;\n+  delete decl_vars;\n \n-    tree bl = make_node(BLOCK);\n-    BLOCK_SUPERCONTEXT(bl) = fndecl;\n-    DECL_INITIAL(fndecl) = bl;\n-    BLOCK_VARS(bl) = declare_vars;\n-    TREE_USED(bl) = true;\n+  tree bl = make_node (BLOCK);\n+  BLOCK_SUPERCONTEXT (bl) = fndecl;\n+  DECL_INITIAL (fndecl) = bl;\n+  BLOCK_VARS(bl) = declare_vars;\n+  TREE_USED (bl) = true;\n \n-    bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(bl), NULL_TREE, bl);\n-    TREE_SIDE_EFFECTS(bind) = 1;\n-    /* Finalize the main function */\n-    BIND_EXPR_BODY(bind) = block;\n-    block = bind;\n-    DECL_SAVED_TREE(fndecl) = block;\n+  bind = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (bl),\n+                 NULL_TREE, bl);\n+  TREE_SIDE_EFFECTS (bind) = 1;\n+  /* Finalize the main function */\n+  BIND_EXPR_BODY (bind) = block;\n+  block = bind;\n+  DECL_SAVED_TREE (fndecl) = block;\n \n-    gimplify_function_tree(fndecl);\n-    cgraph_finalize_function(fndecl, false);\n+  gimplify_function_tree (fndecl);\n+  cgraph_finalize_function (fndecl, false);\n \n-    pop_cfun();\n+  pop_cfun ();\n \n-    // reset them\n-    global_retDecl = error_mark_node;\n-    global_retDecl_ = false;\n+  // reset them\n+  global_retDecl = error_mark_node;\n+  global_retDecl_ = false;\n \n-    return fndecl;\n+  return fndecl;\n }\n \n-// Seems to lower a struct and add it to somewhere, and returns a tree declaration of it?\n-static tree dot_pass_genifyStruct(rdot node) {\n-    rdot layout = RDOT_rhs_TT(node);\n-    tree userStruct = make_node(RECORD_TYPE);\n-\n-    bool first = true;\n-    tree head_chain = NULL_TREE;\n-    tree curr = head_chain;\n-\n-    rdot next;\n-    for (next = layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        gcc_assert(RDOT_TYPE(next) == D_PARAMETER);\n-        tree name = get_identifier(RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next)));\n-        tree type = dot_pass_rustToGccType(RDOT_rhs_TT(next), false);\n-        tree field = build_decl(RDOT_LOCATION(node),\n-                                FIELD_DECL,\n-                                name,\n-                                type);\n-        DECL_CONTEXT(field) = userStruct;\n-        if (first == true) {\n-            head_chain = curr = field;\n-            first = false;\n-        } else {\n-            DECL_CHAIN(curr) = field;\n-            curr = field;\n+static\n+tree dot_pass_genifyStruct (rdot node)\n+{\n+  rdot layout = RDOT_rhs_TT (node);\n+  tree userStruct = make_node (RECORD_TYPE);\n+\n+  bool first = true;\n+  tree head_chain = NULL_TREE;\n+  tree curr = head_chain;\n+\n+  rdot next;\n+  for (next = layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      gcc_assert (RDOT_TYPE (next) == D_PARAMETER);\n+      tree name = get_identifier (RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next)));\n+      tree type = dot_pass_rustToGccType (RDOT_rhs_TT (next), false);\n+      tree field = build_decl (RDOT_LOCATION (node),\n+\t\t\t       FIELD_DECL, name, type);\n+      DECL_CONTEXT (field) = userStruct;\n+      if (first == true)\n+\t{\n+\t  head_chain = curr = field;\n+\t  first = false;\n+\t}\n+      else\n+        {\n+          DECL_CHAIN (curr) = field;\n+          curr = field;\n         }\n     }\n \n-    TYPE_FIELDS(userStruct) = head_chain;\n-    layout_type(userStruct);\n-\n-    const char* struct_id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-    tree type_decl = build_decl(RDOT_LOCATION(node), TYPE_DECL, get_identifier(struct_id), userStruct);\n-    TYPE_NAME(userStruct) = get_identifier(struct_id);\n-    grs_preserve_from_gc(type_decl);\n-    rest_of_decl_compilation(type_decl, 1, 0);\n-    dot_pass_pushDecl(struct_id, userStruct);\n-    return type_decl;\n+  TYPE_FIELDS (userStruct) = head_chain;\n+  layout_type (userStruct);\n+\n+  const char * struct_id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+  tree type_decl = build_decl (RDOT_LOCATION (node), TYPE_DECL,\n+\t\t\t       get_identifier (struct_id), userStruct);\n+  TYPE_NAME (userStruct) = get_identifier (struct_id);\n+  grs_preserve_from_gc (type_decl);\n+  rest_of_decl_compilation (type_decl, 1, 0);\n+  dot_pass_pushDecl (struct_id, userStruct);\n+  return type_decl;\n }\n \n-// Seems to lower a struct impl block, returning a pointer to a vector of trees containing various statements from it, e.g. function declarations\n-static std::vector<tree>* dot_pass_genifyImplBlock(rdot node) {\n-    std::vector<tree>* retval = new std::vector<tree>;\n-    // look up the struct type to set TYPE_METHODS on it...\n-    const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-    tree type_decl = dot_pass_lookupCTU(implid);\n-    if (type_decl == error_mark_node)\n-        error(\"type [%s] does not exist for impl block\", implid);\n-    else {\n-        __impl_type_decl = type_decl;\n-        rdot decl;\n-        tree fndecl_chain = error_mark_node, curr = error_mark_node;\n-        bool first = true;\n-        for (decl = RDOT_rhs_TT(node); decl != NULL_DOT; decl = RDOT_CHAIN(decl)) {\n-            tree fndecl = dot_pass_genifyTopFndecl(decl);\n-            retval->push_back(fndecl);\n-            if (first == true) {\n-                fndecl_chain = fndecl;\n-                curr = fndecl_chain;\n-                first = false;\n-            } else {\n-                DECL_CHAIN(curr) = fndecl;\n-                curr = fndecl;\n-            }\n-        }\n-        TYPE_METHODS(__impl_type_decl) = fndecl_chain;\n-        __impl_type_decl = error_mark_node;\n+static\n+std::vector<tree> * dot_pass_genifyImplBlock (rdot node)\n+{\n+  std::vector<tree> * retval = new std::vector<tree>;\n+  // look up the struct type to set TYPE_METHODS on it...\n+  const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+  tree type_decl = dot_pass_lookupCTU (implid);\n+  if (type_decl == error_mark_node)\n+    error (\"type [%s] does not exist for impl block\", implid);\n+  else\n+    {\n+      __impl_type_decl = type_decl;\n+      rdot decl;\n+      tree fndecl_chain = error_mark_node, curr = error_mark_node;\n+      bool first = true;\n+      for (decl = RDOT_rhs_TT (node); decl != NULL_DOT; decl = RDOT_CHAIN (decl))\n+\t{\n+\t  tree fndecl = dot_pass_genifyTopFndecl (decl);\n+\t  retval->push_back (fndecl);\n+\t  if (first == true)\n+\t    {\n+\t      fndecl_chain = fndecl;\n+\t      curr = fndecl_chain;\n+\t      first = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_CHAIN (curr) = fndecl;\n+\t      curr = fndecl;\n+\t    }\n+\t}\n+      TYPE_METHODS (__impl_type_decl) = fndecl_chain;\n+      __impl_type_decl = error_mark_node;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to be an entry point for lowering a top level declaration - handles struct methods?\n-static std::vector<tree>* dot_pass_genifyTopNode(rdot node) {\n-    std::vector<tree>* retval = NULL;\n-    switch (RDOT_TYPE(node)) {\n-        case D_STRUCT_METHOD: {\n-            retval = new std::vector<tree>;\n-            retval->push_back(dot_pass_genifyTopFndecl(node));\n-        } break;\n-\n-            // nothing to do here...\n-        case D_STRUCT_TYPE:\n-        case D_STRUCT_IMPL:\n-            break;\n-\n-        default:\n-            error(\"Unhandled Toplevel declaration [%s]\\n\", RDOT_OPCODE_STR(node));\n-            break;\n+static\n+std::vector<tree> * dot_pass_genifyTopNode (rdot node)\n+{\n+  std::vector<tree> * retval = NULL;\n+  switch (RDOT_TYPE (node))\n+    {\n+    case D_STRUCT_METHOD:\n+      {\n+\tretval = new std::vector<tree>;\n+\tretval->push_back (dot_pass_genifyTopFndecl (node));\n+      }\n+      break;\n+\n+      // nothing to do here...\n+    case D_STRUCT_TYPE:\n+    case D_STRUCT_IMPL:\n+      break;\n+\n+    default:\n+      error (\"Unhandled Toplevel declaration [%s]\\n\", RDOT_OPCODE_STR (node));\n+      break;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Appends runtime decls to context\n-static void dot_pass_setupContext(void) {\n-    std::map<std::string, tree>* lgrs = new std::map<std::string, tree>();\n-    rs_fill_runtime_decls(lgrs);\n-    context.push_back(lgrs);\n+static\n+void dot_pass_setupContext (void)\n+{\n+  std::map<std::string, tree> * lgrs = new std::map<std::string, tree>();\n+  rs_fill_runtime_decls (lgrs);\n+  context.push_back (lgrs);\n }\n \n-// Appends an empty map to context\n-static void dot_pass_pushContext(void) {\n-    std::map<std::string, tree>* nctx = new std::map<std::string, tree>;\n-    context.push_back(nctx);\n+static\n+void dot_pass_pushContext (void)\n+{\n+  std::map<std::string, tree> * nctx = new std::map<std::string, tree>;\n+  context.push_back (nctx);\n }\n \n-// Removes last element in vector, seems to move stuff in vector around too?\n-static std::vector<tree>* dot_pass_popContext(void) {\n-    std::vector<tree>* retval = new std::vector<tree>;\n-    if (context.size() > 0) {\n-        std::map<std::string, tree>* popd = context.back();\n-        context.pop_back();\n+static\n+std::vector<tree> * dot_pass_popContext (void)\n+{\n+  std::vector<tree> * retval = new std::vector<tree>;\n+  if (context.size () > 0)\n+    {\n+      std::map<std::string, tree> * popd = context.back ();\n+      context.pop_back ();\n \n-        std::map<std::string, tree>::iterator it;\n-        for (it = popd->begin(); it != popd->end(); ++it)\n-            retval->push_back(it->second);\n+      std::map<std::string, tree>::iterator it;\n+      for (it = popd->begin (); it != popd->end (); ++it)\n+        retval->push_back (it->second);\n \n-        delete popd;\n+      delete popd;\n     }\n-    return retval;\n+  return retval;\n }\n \n-// Seems to be the actual entry point of the entire logical unit - creates \"context\" and iterates through decls, lowering stuff\n-vec<tree, va_gc>* dot_pass_Genericify(vec<rdot, va_gc>* decls) {\n-    vec<tree, va_gc>* retval;\n-    vec_alloc(retval, 0);\n-\n-    dot_pass_setupContext();\n-    dot_pass_pushContext();\n-\n-    size_t i;\n-    rdot idtx = NULL_DOT;\n-\n-    /* fill up the prototypes now ... */\n-    for (i = 0; decls->iterate(i, &idtx); ++i) {\n-        rdot node = idtx;\n-        switch (RDOT_TYPE(node)) {\n-            case D_STRUCT_METHOD:\n-                dot_pass_genMethodProto(node);\n-                break;\n-\n-            case D_STRUCT_TYPE: {\n-                tree gen = dot_pass_genifyStruct(node);\n-                vec_safe_push(retval, gen);\n-            } break;\n+vec<tree,va_gc> * dot_pass_Genericify (vec<rdot,va_gc> * decls)\n+{\n+  vec<tree,va_gc> * retval;\n+  vec_alloc (retval, 0);\n+\n+  dot_pass_setupContext ();\n+  dot_pass_pushContext ();\n+\n+  size_t i;\n+  rdot idtx = NULL_DOT;\n+\n+  /* fill up the prototypes now ... */\n+  for (i = 0; decls->iterate (i, &idtx); ++i)\n+    {\n+      rdot node = idtx;\n+      switch (RDOT_TYPE (node))\n+\t{\n+\tcase D_STRUCT_METHOD:\n+\t  dot_pass_genMethodProto (node);\n+\t  break;\n+\n+\tcase D_STRUCT_TYPE:\n+\t  {\n+\t    tree gen = dot_pass_genifyStruct (node);\n+\t    vec_safe_push (retval, gen);\n+\t  }\n+\t  break;\n \n-            default:\n-                break;\n-        }\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n-    if (seen_error())\n-        goto exit;\n-\n-    for (i = 0; decls->iterate(i, &idtx); ++i) {\n-        rdot node = idtx;\n-        switch (RDOT_TYPE(node)) {\n-            case D_STRUCT_IMPL: {\n-                std::vector<tree>* gdecls = dot_pass_genifyImplBlock(node);\n-                std::vector<tree>::iterator it;\n-                for (it = gdecls->begin(); it != gdecls->end(); ++it)\n-                    vec_safe_push(retval, *it);\n-                delete gdecls;\n-            } break;\n+  if (seen_error ())\n+    goto exit;\n+\n+  for (i = 0; decls->iterate (i, &idtx); ++i)\n+    {\n+      rdot node = idtx;\n+      switch (RDOT_TYPE (node))\n+\t{\n+\tcase D_STRUCT_IMPL:\n+\t  {\n+\t    std::vector<tree> * gdecls = dot_pass_genifyImplBlock (node);\n+\t    std::vector<tree>::iterator it;\n+\t    for (it = gdecls->begin (); it != gdecls->end (); ++it)\n+\t      vec_safe_push (retval, *it);\n+\t    delete gdecls;\n+\t  }\n+\t  break;\n \n-            default:\n-                break;\n-        }\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n-    if (seen_error())\n-        goto exit;\n-\n-    __impl_type_decl = error_mark_node;\n-    for (i = 0; decls->iterate(i, &idtx); ++i) {\n-        std::vector<tree>* gdecls = dot_pass_genifyTopNode(idtx);\n-        if (gdecls != NULL) {\n-            std::vector<tree>::iterator it;\n-            for (it = gdecls->begin(); it != gdecls->end(); ++it)\n-                vec_safe_push(retval, *it);\n-            delete gdecls;\n-        }\n+  if (seen_error ())\n+    goto exit;\n+\n+  __impl_type_decl = error_mark_node;\n+  for (i = 0; decls->iterate (i, &idtx); ++i)\n+    {\n+      std::vector<tree> * gdecls = dot_pass_genifyTopNode (idtx);\n+      if (gdecls != NULL)\n+\t{\n+\t  std::vector<tree>::iterator it;\n+\t  for (it = gdecls->begin (); it != gdecls->end (); ++it)\n+\t    vec_safe_push (retval, *it);\n+\t  delete gdecls;\n+\t}\n     }\n \n-exit:\n-    dot_pass_popContext();\n-    return retval;\n+ exit:\n+  dot_pass_popContext ();\n+  return retval;\n }"}, {"sha": "be4421b52a1b36aa7e993bddd6df77b9c76bdac9", "filename": "gcc/rust/old/rdot-impl.cc", "status": "modified", "additions": 188, "deletions": 174, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -18,236 +18,250 @@\n \n static bool initilized = false;\n \n-static const char* opcodeStrings[] = {\n-    /* [D_IDENTIFIER] */ \"identifier\",\n-    /* [D_T_INTEGER] */ \"literal_integer\",\n-    /* [D_T_FLOAT] */ \"literal_float\",\n-    /* [D_T_STRING] */ \"literal_string\",\n-    /* [D_T_LIST] */ \"liteal_list\",\n-    /* [D_VAR_DECL] */ \"var_decl\",\n-    /* [D_MODIFY_EXPR] */ \"modify_expr\",\n-    /* [D_MULT_EXPR] */ \"multiply_expr\",\n-    /* [D_DIVD_EXPR] */ \"divide_expr\",\n-    /* [D_ADD_EXPR] */ \"plus_expr\",\n-    /* [D_MINUS_EXPR] */ \"minus_expr\",\n-    /* [D_EQ_EQ_EXPR] */ \"equivilant_expr\",\n-    /* [D_LESS_EXPR] */ \"less_than_expr\",\n-    /* [D_LESS_EQ_EXPR] */ \"less_eq_expr\",\n-    /* [D_GREATER_EXPR] */ \"greater_expr\",\n-    /* [D_GREATER_EQ_EXPR] */ \"greater_eq_expr\",\n-    /* [D_NOT_EQ_EXPR] */ \"not_equal_expr\",\n-    /* [D_CALL_EXPR] */ \"call_expr\",\n-    /* [D_ATTRIB_EXPR] */ \"attribute_reference\",\n-    /* [D_ACC_EXPR] */ \"accessor_reference\",\n-    /* [D_STRUCT_METHOD] */ \"struct_method\",\n-    /* [D_STRUCT_WHILE] */ \"struct_while\",\n-    /* [D_STRUCT_LOOP] */ \"struct_loop\",\n-    /* [D_D_EXPR] */ \"enc_expression\",\n-    /* [D_TD_COM] */ \"TD_COM\",\n-    /* [D_TD_DOT] */ \"TD_DOT\",\n-    /* [D_TD_NULL] */ \"TD_NULL\",\n-    /* [D_PRIMITIVE] */ \"primitive\",\n-    /* [D_STRUCT_IF] */ \"struct_if\",\n-    /* [D_STRUCT_ELIF] */ \"struct_elif\",\n-    /* [D_STRUCT_ELSE] */ \"struct_else\",\n-    /* [D_STRUCT_CONDITIONAL] */ \"struct_conditional\",\n-    /* [RTYPE_BOOL] */ \"type_bool\",\n-    /* [RTYPE_INT] */ \"type_int\",\n-    /* [RTYPE_FLOAT] */ \"type_float\",\n-    /* [RTYPE_UINT] */ \"type_uint\",\n-    /* [RTYPE_INFER] */ \"type_infer\",\n-    /* [D_PARAMETER] */ \"parameter\",\n-    /* [D_STRUCT_TYPE] */ \"struct_definition\",\n-    /* [D_STRUCT_PARAM] */ \"struct_init_param\",\n-    /* [D_STRUCT_INIT] */ \"struct_initilization\",\n-    /* [RTYPE_USER_STRUCT] */ \"user_struct_type\",\n-    /* [D_STRUCT_ENUM] */ \"struct_enum\",\n-    /* [D_STRUCT_IMPL] */ \"impl_block\",\n-    /* [D_BOOLEAN] */ \"d_boolean\",\n-    /* [D_T_BOOL] */ \"d_t_bool\",\n-    /* [C_BREAK_STMT] */ \"break_stmt\",\n-    /* [C_CONT_STMT] */ \"continue_stmt\",\n-    /* [C_RETURN_STMT] */ \"return_stmt\",\n+static const char * opcodeStrings [] = {\n+  /* [D_IDENTIFIER] */         \"identifier\",\n+  /* [D_T_INTEGER] */          \"literal_integer\",\n+  /* [D_T_FLOAT] */            \"literal_float\",\n+  /* [D_T_STRING] */           \"literal_string\",\n+  /* [D_T_LIST] */             \"liteal_list\",\n+  /* [D_VAR_DECL] */           \"var_decl\",\n+  /* [D_MODIFY_EXPR] */        \"modify_expr\",\n+  /* [D_MULT_EXPR] */          \"multiply_expr\",\n+  /* [D_DIVD_EXPR] */          \"divide_expr\",\n+  /* [D_ADD_EXPR] */           \"plus_expr\",\n+  /* [D_MINUS_EXPR] */         \"minus_expr\",\n+  /* [D_EQ_EQ_EXPR] */         \"equivilant_expr\",\n+  /* [D_LESS_EXPR] */          \"less_than_expr\",\n+  /* [D_LESS_EQ_EXPR] */       \"less_eq_expr\",\n+  /* [D_GREATER_EXPR] */       \"greater_expr\",\n+  /* [D_GREATER_EQ_EXPR] */    \"greater_eq_expr\",\n+  /* [D_NOT_EQ_EXPR] */        \"not_equal_expr\",\n+  /* [D_CALL_EXPR] */          \"call_expr\",\n+  /* [D_ATTRIB_EXPR] */        \"attribute_reference\",\n+  /* [D_ACC_EXPR] */           \"accessor_reference\",\n+  /* [D_STRUCT_METHOD] */      \"struct_method\",\n+  /* [D_STRUCT_WHILE] */       \"struct_while\",\n+  /* [D_STRUCT_LOOP] */        \"struct_loop\",\n+  /* [D_D_EXPR] */             \"enc_expression\",\n+  /* [D_TD_COM] */             \"TD_COM\",\n+  /* [D_TD_DOT] */             \"TD_DOT\",\n+  /* [D_TD_NULL] */            \"TD_NULL\",\n+  /* [D_PRIMITIVE] */          \"primitive\",\n+  /* [D_STRUCT_IF] */          \"struct_if\",\n+  /* [D_STRUCT_ELIF] */        \"struct_elif\",\n+  /* [D_STRUCT_ELSE] */        \"struct_else\",\n+  /* [D_STRUCT_CONDITIONAL] */ \"struct_conditional\",\n+  /* [RTYPE_BOOL] */           \"type_bool\",\n+  /* [RTYPE_INT] */            \"type_int\",\n+  /* [RTYPE_FLOAT] */          \"type_float\",\n+  /* [RTYPE_UINT] */           \"type_uint\",\n+  /* [RTYPE_INFER] */          \"type_infer\",\n+  /* [D_PARAMETER] */          \"parameter\",\n+  /* [D_STRUCT_TYPE] */        \"struct_definition\",\n+  /* [D_STRUCT_PARAM] */       \"struct_init_param\",\n+  /* [D_STRUCT_INIT] */        \"struct_initilization\",\n+  /* [RTYPE_USER_STRUCT] */    \"user_struct_type\",\n+  /* [D_STRUCT_ENUM] */        \"struct_enum\",\n+  /* [D_STRUCT_IMPL] */        \"impl_block\",\n+  /* [D_BOOLEAN] */            \"d_boolean\",\n+  /* [D_T_BOOL] */             \"d_t_bool\",\n+  /* [C_BREAK_STMT] */         \"break_stmt\",\n+  /* [C_CONT_STMT] */          \"continue_stmt\",\n+  /* [C_RETURN_STMT] */        \"return_stmt\",\n };\n \n-// Gets string representation of opcode_t instance (which defines possible types in a less strict sense that usual)\n-const char* rdot_getOpString_T(const opcode_t o) {\n-    return opcodeStrings[o];\n+const char *\n+rdot_getOpString_T (const opcode_t o)\n+{\n+  return opcodeStrings [o];\n }\n \n-// Gets string representation of rdot's type\n-const char* rdot_getOpString(const rdot dot) {\n-    return rdot_getOpString_T(RDOT_TYPE(dot));\n+const char *\n+rdot_getOpString (const rdot dot)\n+{\n+  return rdot_getOpString_T (RDOT_TYPE (dot));\n }\n \n-// Ensures \"initilized\" is true\n-void rdot_init(void) {\n-    if (initilized)\n-        return;\n-    //... probably should get rid of this function ...\n-    initilized = true;\n+void rdot_init (void)\n+{\n+  if (initilized)\n+    return;\n+  //... probably should get rid of this function ...\n+  initilized = true;\n }\n \n-// Presumably parses a variable declaration\n-rdot rdot_build_varDecl(rdot type, bool final, rdot id) {\n-    rdot decl = rdot_build_decl2(D_VAR_DECL, id, type);\n-    RDOT_qual(decl) = final;\n-    return decl;\n+rdot rdot_build_varDecl (rdot type, bool final, rdot id)\n+{\n+  rdot decl = rdot_build_decl2 (D_VAR_DECL, id, type);\n+  RDOT_qual (decl) = final;\n+  return decl;\n }\n \n-// Presumably allocates a new grs_tree_dot instance\n-rdot rdot_alloc(void) {\n-    rdot retval = (struct grs_tree_dot*)\n-      xmalloc(sizeof(struct grs_tree_dot));\n-    gcc_assert(retval);\n-    memset(retval, 0, sizeof(struct grs_tree_dot));\n-    RDOT_LOCATION(retval) = UNKNOWN_LOCATION;\n-    return retval;\n+rdot rdot_alloc (void)\n+{\n+  rdot retval = (struct grs_tree_dot *)\n+    xmalloc (sizeof (struct grs_tree_dot));\n+  gcc_assert (retval);\n+  memset (retval, 0, sizeof (struct grs_tree_dot));\n+  RDOT_LOCATION (retval) = UNKNOWN_LOCATION;\n+  return retval;\n }\n \n-// Seems to parse a unary? declaration?\n-rdot rdot_build_decl1(opcode_t o, rdot t1) {\n-    rdot decl = RDOT_alloc;\n+rdot rdot_build_decl1 (opcode_t o, rdot t1)\n+{\n+  rdot decl = RDOT_alloc;\n \n-    RDOT_TYPE(decl) = o;\n-    RDOT_T_FIELD(decl) = D_TD_NULL;\n-    RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_TYPE(decl) = o;\n+  RDOT_T_FIELD(decl) = D_TD_NULL;\n+  RDOT_FIELD(decl) = NULL_DOT;\n \n-    decl->opaT = D_TD_DOT;\n-    decl->opa.t = t1;\n-    decl->opbT = D_TD_NULL;\n+  decl->opaT = D_TD_DOT;\n+  decl->opa.t = t1;\n+  decl->opbT = D_TD_NULL;\n \n-    RDOT_CHAIN(decl) = NULL_DOT;\n+  RDOT_CHAIN(decl) = NULL_DOT;\n \n-    return decl;\n+  return decl;\n }\n \n-// Seems to parse a binary? expression? (misleading name, amirite?)\n-rdot rdot_build_decl2(opcode_t o, rdot t1, rdot t2) {\n-    rdot decl = RDOT_alloc;\n-\n-    RDOT_TYPE(decl) = o;\n-    if ((o == D_VAR_DECL) || (o == D_MODIFY_EXPR) || (o == D_ADD_EXPR) || (o == D_MINUS_EXPR) \n-      || (o == D_MULT_EXPR) || (o == D_DIVD_EXPR) || (o == D_CALL_EXPR) || (o == D_EQ_EQ_EXPR) \n-      || (o == D_LESS_EXPR) || (o == D_LESS_EQ_EXPR) || (o == D_GREATER_EXPR) \n-      || (o == D_GREATER_EQ_EXPR) || (o == D_NOT_EQ_EXPR) || (o == D_ATTRIB_REF) || (o == D_ACC_EXPR) \n-      || (o == D_STRUCT_INIT))\n-        RDOT_T_FIELD(decl) = D_D_EXPR;\n-    else\n-        RDOT_T_FIELD(decl) = D_TD_NULL;\n+rdot rdot_build_decl2 (opcode_t o, rdot t1, rdot t2)\n+{\n+  rdot decl = RDOT_alloc;\n+\n+  RDOT_TYPE (decl) = o;\n+  if ((o == D_VAR_DECL)\n+      || (o == D_MODIFY_EXPR)\n+      || (o == D_ADD_EXPR)\n+      || (o == D_MINUS_EXPR)\n+      || (o == D_MULT_EXPR)\n+      || (o == D_DIVD_EXPR)\n+      || (o == D_CALL_EXPR)\n+      || (o == D_EQ_EQ_EXPR)\n+      || (o == D_LESS_EXPR)\n+      || (o == D_LESS_EQ_EXPR)\n+      || (o == D_GREATER_EXPR)\n+      || (o == D_GREATER_EQ_EXPR)\n+      || (o == D_NOT_EQ_EXPR)\n+      || (o == D_ATTRIB_REF)\n+      || (o == D_ACC_EXPR)\n+      || (o == D_STRUCT_INIT)\n+      )\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  else\n+    RDOT_T_FIELD(decl) = D_TD_NULL;\n \n-    RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_FIELD (decl) = NULL_DOT;\n \n-    decl->opaT = D_TD_DOT;\n-    decl->opa.t = t1;\n-    decl->opbT = D_TD_DOT;\n-    decl->opb.t = t2;\n+  decl->opaT = D_TD_DOT;\n+  decl->opa.t = t1;\n+  decl->opbT = D_TD_DOT;\n+  decl->opb.t = t2;\n \n-    RDOT_CHAIN(decl) = NULL_DOT;\n+  RDOT_CHAIN(decl) = NULL_DOT;\n \n-    return decl;\n+  return decl;\n }\n \n-// parse in function declaration?\n-rdot rdot_build_fndecl(rdot ident, bool pub, rdot params, rdot rtype, rdot suite) {\n-    rdot decl = RDOT_alloc;\n+rdot rdot_build_fndecl (rdot ident, bool pub, rdot params, rdot rtype, rdot suite)\n+{\n+  rdot decl = RDOT_alloc;\n \n-    RDOT_TYPE(decl) = D_STRUCT_METHOD;\n-    RDOT_T_FIELD(decl) = D_TD_NULL;\n+  RDOT_TYPE (decl) = D_STRUCT_METHOD;\n+  RDOT_T_FIELD (decl) = D_TD_NULL;\n \n-    RDOT_FIELD(decl) = ident;\n-    RDOT_FIELD2(decl) = rtype;\n-    DOT_RETVAL(decl) = pub;\n+  RDOT_FIELD (decl) = ident;\n+  RDOT_FIELD2 (decl) = rtype;\n+  DOT_RETVAL (decl) = pub;\n \n-    decl->opaT = D_TD_DOT;\n-    decl->opa.t = params;\n-    decl->opbT = D_TD_DOT;\n-    decl->opb.t = suite;\n+  decl->opaT = D_TD_DOT;\n+  decl->opa.t = params;\n+  decl->opbT = D_TD_DOT;\n+  decl->opb.t = suite;\n \n-    RDOT_CHAIN(decl) = NULL_DOT;\n+  RDOT_CHAIN(decl) = NULL_DOT;\n \n-    return decl;\n+  return decl;\n }\n \n-// parse in int literal?\n-rdot rdot_build_integer(const int i) {\n-    rdot decl = RDOT_alloc;\n-    RDOT_TYPE(decl) = D_PRIMITIVE;\n+rdot rdot_build_integer (const int i)\n+{\n+  rdot decl = RDOT_alloc;\n+  RDOT_TYPE(decl) = D_PRIMITIVE;\n \n-    RDOT_FIELD(decl) = NULL_DOT;\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_T_FIELD(decl) = D_D_EXPR;\n \n-    decl->opaT = D_TD_COM;\n-    decl->opa.tc.T = D_T_INTEGER;\n-    decl->opa.tc.o.integer = i;\n+  decl->opaT = D_TD_COM;\n+  decl->opa.tc.T = D_T_INTEGER;\n+  decl->opa.tc.o.integer = i;\n \n-    return decl;\n+  return decl;\n }\n \n-// parse in float literal?\n-rdot rdot_build_float(const float f) {\n-    rdot decl = RDOT_alloc;\n-    RDOT_TYPE(decl) = D_PRIMITIVE;\n+rdot rdot_build_float (const float f)\n+{\n+  rdot decl = RDOT_alloc;\n+  RDOT_TYPE(decl) = D_PRIMITIVE;\n \n-    RDOT_FIELD(decl) = NULL_DOT;\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_T_FIELD(decl) = D_D_EXPR;\n \n-    decl->opaT = D_TD_COM;\n-    decl->opa.tc.T = D_T_FLOAT;\n-    decl->opa.tc.o.ffloat = f;\n+  decl->opaT = D_TD_COM;\n+  decl->opa.tc.T = D_T_FLOAT;\n+  decl->opa.tc.o.ffloat = f;\n \n-    return decl;\n+  return decl;\n }\n \n-// parse in string literal?\n-rdot rdot_build_string(const char* s) {\n-    rdot decl = RDOT_alloc;\n-    RDOT_TYPE(decl) = D_PRIMITIVE;\n+rdot rdot_build_string (const char * s)\n+{\n+  rdot decl = RDOT_alloc;\n+  RDOT_TYPE (decl) = D_PRIMITIVE;\n \n-    RDOT_FIELD(decl) = NULL_DOT;\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  RDOT_FIELD (decl) = NULL_DOT;\n+  RDOT_T_FIELD (decl) = D_D_EXPR;\n \n-    decl->opaT = D_TD_COM;\n-    decl->opa.tc.T = D_T_STRING;\n-    decl->opa.tc.o.string = xstrdup(s);\n+  decl->opaT = D_TD_COM;\n+  decl->opa.tc.T = D_T_STRING;\n+  decl->opa.tc.o.string = xstrdup (s);\n \n-    return decl;\n+  return decl;\n }\n \n-// May parse in identifier\n-rdot rdot_build_identifier(const char* s) {\n-    rdot decl = RDOT_alloc;\n+rdot rdot_build_identifier (const char * s)\n+{\n+  rdot decl = RDOT_alloc;\n \n-    RDOT_TYPE(decl) = D_IDENTIFIER;\n-    RDOT_FIELD(decl) = NULL_DOT;\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  RDOT_TYPE(decl) = D_IDENTIFIER;\n+  RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_T_FIELD(decl) = D_D_EXPR;\n \n-    decl->opaT = D_TD_COM;\n-    decl->opa.tc.T = D_T_STRING;\n-    decl->opa.tc.o.string = xstrdup(s);\n+  decl->opaT = D_TD_COM;\n+  decl->opa.tc.T = D_T_STRING;\n+  decl->opa.tc.o.string = xstrdup (s);\n \n-    decl->opbT = D_TD_NULL;\n+  decl->opbT = D_TD_NULL;\n \n-    RDOT_CHAIN(decl) = NULL_DOT;\n+  RDOT_CHAIN(decl) = NULL_DOT;\n \n-    return decl;\n+  return decl;\n }\n \n-// parse in boolean literal?\n-rdot rdot_build_bool(bool val) {\n-    rdot decl = RDOT_alloc;\n+rdot rdot_build_bool (bool val)\n+{\n+  rdot decl = RDOT_alloc;\n \n-    RDOT_TYPE(decl) = D_BOOLEAN;\n-    RDOT_FIELD(decl) = NULL_DOT;\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n+  RDOT_TYPE(decl) = D_BOOLEAN;\n+  RDOT_FIELD(decl) = NULL_DOT;\n+  RDOT_T_FIELD(decl) = D_D_EXPR;\n \n-    decl->opaT = D_TD_COM;\n-    decl->opa.tc.T = D_T_BOOL;\n-    decl->opa.tc.o.boolean = val;\n+  decl->opaT = D_TD_COM;\n+  decl->opa.tc.T = D_T_BOOL;\n+  decl->opa.tc.o.boolean = val;\n \n-    decl->opbT = D_TD_NULL;\n+  decl->opbT = D_TD_NULL;\n \n-    RDOT_CHAIN(decl) = NULL_DOT;\n+  RDOT_CHAIN(decl) = NULL_DOT;\n \n-    return decl;\n+  return decl;\n }"}, {"sha": "8f7d71d1ec9101bc198bb55b71ece7e13fd4843d", "filename": "gcc/rust/old/rdot-impl.h", "status": "modified", "additions": 132, "deletions": 138, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -18,155 +18,149 @@\n #define __GCC_RDOT_IMPL_H__\n \n typedef enum {\n-    D_IDENTIFIER = 0,\n-    D_T_INTEGER,\n-    D_T_FLOAT,\n-    D_T_STRING,\n-    D_T_LIST,\n-\n-    D_VAR_DECL,\n-    D_MODIFY_EXPR,\n-    D_MULT_EXPR,\n-    D_DIVD_EXPR,\n-    D_ADD_EXPR,\n-    D_MINUS_EXPR,\n-\n-    D_EQ_EQ_EXPR,\n-    D_LESS_EXPR,\n-    D_LESS_EQ_EXPR,\n-    D_GREATER_EXPR,\n-    D_GREATER_EQ_EXPR,\n-    D_NOT_EQ_EXPR,\n-\n-    D_CALL_EXPR,\n-    D_ATTRIB_REF,\n-    D_ACC_EXPR,\n-\n-    D_STRUCT_METHOD,\n-    D_STRUCT_WHILE,\n-    D_STRUCT_LOOP,\n-\n-    D_D_EXPR,\n-    D_TD_COM,\n-    D_TD_DOT,\n-    D_TD_NULL,\n-\n-    D_PRIMITIVE,\n-\n-    D_STRUCT_IF,\n-    D_STRUCT_ELIF,\n-    D_STRUCT_ELSE,\n-    D_STRUCT_CONDITIONAL,\n-\n-    RTYPE_BOOL,\n-    RTYPE_INT,\n-    RTYPE_FLOAT,\n-    RTYPE_UINT,\n-    RTYPE_INFER,\n-\n-    D_PARAMETER,\n-    D_STRUCT_TYPE,\n-    D_STRUCT_PARAM,\n-    D_STRUCT_INIT,\n-\n-    RTYPE_USER_STRUCT,\n-\n-    D_STRUCT_ENUM,\n-    D_STRUCT_IMPL,\n-\n-    D_BOOLEAN,\n-    D_T_BOOL,\n-\n-    C_BREAK_STMT,\n-    C_CONT_STMT,\n-    C_RETURN_STMT\n-} opcode_t;\n+  D_IDENTIFIER = 0,\n+  D_T_INTEGER,\n+  D_T_FLOAT,\n+  D_T_STRING,\n+  D_T_LIST,\n+\n+  D_VAR_DECL,\n+  D_MODIFY_EXPR,\n+  D_MULT_EXPR,\n+  D_DIVD_EXPR,\n+  D_ADD_EXPR,\n+  D_MINUS_EXPR,\n+\n+  D_EQ_EQ_EXPR,\n+  D_LESS_EXPR,\n+  D_LESS_EQ_EXPR,\n+  D_GREATER_EXPR,\n+  D_GREATER_EQ_EXPR,\n+  D_NOT_EQ_EXPR,\n+\n+  D_CALL_EXPR,\n+  D_ATTRIB_REF,\n+  D_ACC_EXPR,\n+    \n+  D_STRUCT_METHOD,\n+  D_STRUCT_WHILE,\n+  D_STRUCT_LOOP,\n+\n+  D_D_EXPR,\n+  D_TD_COM,\n+  D_TD_DOT,\n+  D_TD_NULL,\n+\n+  D_PRIMITIVE,\n+\n+  D_STRUCT_IF,\n+  D_STRUCT_ELIF,\n+  D_STRUCT_ELSE,\n+  D_STRUCT_CONDITIONAL,\n+\n+  RTYPE_BOOL,\n+  RTYPE_INT,\n+  RTYPE_FLOAT,\n+  RTYPE_UINT,\n+  RTYPE_INFER,\n+\n+  D_PARAMETER,\n+  D_STRUCT_TYPE,\n+  D_STRUCT_PARAM,\n+  D_STRUCT_INIT,\n+\n+  RTYPE_USER_STRUCT,\n+\n+  D_STRUCT_ENUM,\n+  D_STRUCT_IMPL,\n+\n+  D_BOOLEAN,\n+  D_T_BOOL,\n+\n+  C_BREAK_STMT,\n+  C_CONT_STMT,\n+  C_RETURN_STMT\n+} opcode_t ;\n \n typedef enum {\n-    ALLOC_HEAP,\n-    ALLOC_REF,\n-    ALLOC_DEREF\n+  ALLOC_HEAP,\n+  ALLOC_REF,\n+  ALLOC_DEREF\n } ALLOCA_;\n \n-// Seems to be primitive literals\n typedef struct grs_rdot_tree_common {\n-    // probably actual type used (tag for tagged union)\n-    opcode_t T;\n-    // possible values\n-    union {\n-        int integer;\n-        float ffloat;\n-        unsigned char c;\n-        char* string;\n-        bool boolean;\n-    } o;\n-} rdot_tree_common;\n+  opcode_t T;\n+  union {\n+    int integer;\n+    float ffloat;\n+    unsigned char c;\n+    char * string;\n+    bool boolean;\n+  } o;\n+} rdot_tree_common ;\n \n typedef struct GTY(()) grs_tree_dot {\n-    opcode_t T, FT, opaT, opbT;\n-    bool retval, qual;\n-    std::vector<ALLOCA_> alloca_modifier;\n-    location_t loc;\n-    struct grs_tree_dot* field1;\n-    struct grs_tree_dot* field2;\n-    union {\n-        rdot_tree_common tc;\n-        struct grs_tree_dot* t;\n-    } opa;\n-    union {\n-        rdot_tree_common tc;\n-        struct grs_tree_dot* t;\n-    } opb;\n-    struct grs_tree_dot* next;\n+  opcode_t T, FT, opaT, opbT;\n+  bool retval, qual;\n+  std::vector<ALLOCA_> alloca_modifier;\n+  location_t loc;\n+  struct grs_tree_dot * field1;\n+  struct grs_tree_dot * field2;\n+  union {\n+    rdot_tree_common tc;\n+    struct grs_tree_dot * t;\n+  } opa;\n+  union {\n+    rdot_tree_common tc;\n+    struct grs_tree_dot * t;\n+  } opb;\n+  struct grs_tree_dot * next;\n } * rdot;\n \n-// A null rdot instance\n-#define NULL_DOT ((rdot)0)\n-#define RDOT_alloc rdot_alloc()\n-// Gets type of rdot instance\n-#define RDOT_TYPE(x_) x_->T\n-// Seems to get location_t for rdot\n-#define RDOT_LOCATION(x_) x_->loc\n-#define RDOT_T_FIELD(x_) x_->FT\n-#define RDOT_CHAIN(x_) x_->next\n-#define RDOT_FIELD(x_) x_->field1\n-#define RDOT_FIELD2(x_) x_->field2\n-#define RDOT_lhs_T(x_) x_->opaT\n-#define RDOT_rhs_T(x_) x_->opbT\n-#define RDOT_lhs_TT(x_) x_->opa.t\n-#define RDOT_rhs_TT(x_) x_->opb.t\n-#define RDOT_lhs_TC(x_) x_->opa.tc\n-#define RDOT_rhs_TC(x_) x_->opb.tc\n-#define RDOT_qual(x_) x_->qual\n-#define DOT_RETVAL(x_) x_->retval\n-#define RDOT_MEM_MODIFIER(x_) (&(x_->alloca_modifier))\n-#define RDOT_IDENTIFIER_POINTER(x_) RDOT_lhs_TC(x_).o.string\n-#define RDOT_BOOLEAN_VAL(x_) RDOT_lhs_TC(x_).o.boolean\n-#define RDOT_CODE_STR(x_) rdot_getOpString_T(x_)\n-#define RDOT_OPCODE_STR(x_) rdot_getOpString(x_)\n+#define NULL_DOT                     ((rdot) 0)\n+#define RDOT_alloc                   rdot_alloc ()\n+#define RDOT_TYPE(x_)                x_->T\n+#define RDOT_LOCATION(x_)            x_->loc\n+#define RDOT_T_FIELD(x_)             x_->FT\n+#define RDOT_CHAIN(x_)               x_->next\n+#define RDOT_FIELD(x_)               x_->field1\n+#define RDOT_FIELD2(x_)              x_->field2\n+#define RDOT_lhs_T(x_)               x_->opaT\n+#define RDOT_rhs_T(x_)               x_->opbT\n+#define RDOT_lhs_TT(x_)              x_->opa.t\n+#define RDOT_rhs_TT(x_)              x_->opb.t\n+#define RDOT_lhs_TC(x_)              x_->opa.tc\n+#define RDOT_rhs_TC(x_)              x_->opb.tc\n+#define RDOT_qual(x_)                x_->qual\n+#define DOT_RETVAL(x_)               x_->retval\n+#define RDOT_MEM_MODIFIER(x_)        (&(x_->alloca_modifier))\n+#define RDOT_IDENTIFIER_POINTER(x_)  RDOT_lhs_TC (x_).o.string\n+#define RDOT_BOOLEAN_VAL(x_)         RDOT_lhs_TC (x_).o.boolean\n+#define RDOT_CODE_STR(x_)            rdot_getOpString_T (x_)\n+#define RDOT_OPCODE_STR(x_)          rdot_getOpString (x_)\n \n // destination is cleared before copy\n // copy a vector (source, destination)\n-#define RDOT_MMEM_COPY(x_, y_)                              \\\n-    do {                                                    \\\n-        y_->clear();                                        \\\n-        std::vector<ALLOCA_>::iterator __it;                \\\n-        for (__it = x_->begin(); __it != x_->end(); ++__it) \\\n-            y_->push_back(*__it);                           \\\n-    } while (0)\n-\n-extern rdot rdot_alloc(void);\n-extern void rdot_init(void);\n-extern rdot rdot_build_decl1(opcode_t, rdot);\n-extern rdot rdot_build_decl2(opcode_t, rdot, rdot);\n-extern rdot rdot_build_fndecl(rdot, bool, rdot, rdot, rdot);\n-extern rdot rdot_build_float(const float);\n-extern rdot rdot_build_integer(const int);\n-extern rdot rdot_build_string(const char*);\n-extern rdot rdot_build_identifier(const char*);\n-extern rdot rdot_build_bool(bool);\n-extern rdot rdot_build_varDecl(rdot, bool, rdot);\n-extern const char* rdot_getOpString(const rdot);\n-extern const char* rdot_getOpString_T(const opcode_t);\n+#define RDOT_MMEM_COPY(x_, y_)\t\t\t\t  \\\n+  do {\t\t\t\t\t\t\t  \\\n+    y_->clear ();\t\t\t\t\t  \\\n+    std::vector<ALLOCA_>::iterator __it;\t\t  \\\n+    for (__it = x_->begin (); __it != x_->end (); ++__it) \\\n+      y_->push_back (*__it);\t\t\t\t  \\\n+  } while (0)\n+\n+extern rdot rdot_alloc (void);\n+extern void rdot_init (void);\n+extern rdot rdot_build_decl1 (opcode_t, rdot);\n+extern rdot rdot_build_decl2 (opcode_t, rdot, rdot);\n+extern rdot rdot_build_fndecl (rdot, bool, rdot, rdot, rdot);\n+extern rdot rdot_build_float (const float);\n+extern rdot rdot_build_integer (const int);\n+extern rdot rdot_build_string (const char *);\n+extern rdot rdot_build_identifier (const char *);\n+extern rdot rdot_build_bool (bool);\n+extern rdot rdot_build_varDecl (rdot, bool, rdot);\n+extern const char * rdot_getOpString (const rdot);\n+extern const char * rdot_getOpString_T (const opcode_t);\n \n #endif //__GCC_RDOT_IMPL_H__"}, {"sha": "51330e318abd958b5f85650d9187e844135950d5", "filename": "gcc/rust/old/rdot-pretty-print.cc", "status": "modified", "additions": 568, "deletions": 503, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-pretty-print.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -19,581 +19,646 @@\n static bool _no_infer = false;\n static bool first = true;\n \n-#define RDOT_PREFIX_PRE \".pre-rdot\"\n-#define RDOT_PREFIX_POST \".pst-rdot\"\n-\n-// Array of type strings? Seems incomplete if it is. Perhaps just parser \"primitives\"?\n-static const char* typeStrings[] = {\n-    \"bool\",\n-    \"int\",\n-    \"float\",\n-    \"unsigned_int\",\n-    \"__infer_me\",\n-    \"__user_struct\",\n-    \"void\"\n+#define RDOT_PREFIX_PRE      \".pre-rdot\"\n+#define RDOT_PREFIX_POST     \".pst-rdot\"\n+\n+static const char * typeStrings [] = {\n+  \"bool\",\n+  \"int\",\n+  \"float\",\n+  \"unsigned_int\",\n+  \"__infer_me\",\n+  \"__user_struct\",\n+  \"void\"\n };\n \n-// Seems to determine type of node as per typeStrings array\n-static char* typeStringNode(const rdot node) {\n-    char buffer[128];\n-    size_t offset = 0;\n-    if (RDOT_MEM_MODIFIER(node)) {\n-        std::vector<ALLOCA_>::iterator it;\n-        for (it = RDOT_MEM_MODIFIER(node)->begin();\n-             it != RDOT_MEM_MODIFIER(node)->end();\n-             ++it) {\n-            switch (*it) {\n-                case ALLOC_HEAP: {\n-                    buffer[offset] = '~';\n-                    offset++;\n-                } break;\n-                case ALLOC_REF: {\n-                    buffer[offset] = '&';\n-                    offset++;\n-                } break;\n-                case ALLOC_DEREF: {\n-                    buffer[offset] = '*';\n-                    offset++;\n-                } break;\n+static char *\n+typeStringNode (const rdot node)\n+{\n+  char buffer [128];\n+  size_t offset = 0;\n+  if (RDOT_MEM_MODIFIER (node))\n+    {\n+      std::vector<ALLOCA_>::iterator it;\n+      for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+           it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n+        {\n+          switch (*it)\n+            {\n+            case ALLOC_HEAP:\n+              {\n+                buffer [offset] = '~';\n+                offset++;\n+              }\n+              break;\n+            case ALLOC_REF:\n+              {\n+                buffer [offset] = '&';\n+                offset++;\n+              }\n+              break;\n+            case ALLOC_DEREF:\n+              {\n+                buffer [offset] = '*';\n+                offset++;\n+              }\n+              break;\n             }\n         }\n     }\n-    if (node != NULL_DOT) {\n-        switch (RDOT_TYPE(node)) {\n-            case RTYPE_BOOL:\n-                strcpy(buffer + offset, typeStrings[0]);\n-                break;\n-\n-            case RTYPE_INT:\n-                strcpy(buffer + offset, typeStrings[1]);\n-                break;\n-\n-            case RTYPE_FLOAT:\n-                strcpy(buffer + offset, typeStrings[2]);\n-                break;\n-\n-            case RTYPE_UINT:\n-                strcpy(buffer + offset, typeStrings[3]);\n-                break;\n-\n-            case RTYPE_INFER: {\n-                if (_no_infer)\n-                    fatal_error(\"gcc-rust has failed to infer a type and cannot continue\");\n-                else\n-                    strcpy(buffer + offset, typeStrings[4]);\n-            } break;\n-\n-            case RTYPE_USER_STRUCT:\n-                strcpy(buffer + offset, RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node)));\n-                break;\n-\n-            default:\n-                fatal_error(\"unhandled type [%s]\", RDOT_OPCODE_STR(node));\n-                break;\n+  if (node != NULL_DOT)\n+    {\n+      switch (RDOT_TYPE (node))\n+        {\n+        case RTYPE_BOOL:\n+          strcpy (buffer+offset, typeStrings [0]);\n+          break;\n+\n+        case RTYPE_INT:\n+          strcpy (buffer+offset, typeStrings [1]);\n+          break;\n+\n+        case RTYPE_FLOAT:\n+          strcpy (buffer+offset, typeStrings [2]);\n+          break;\n+\n+        case RTYPE_UINT:\n+          strcpy (buffer+offset, typeStrings [3]);\n+          break;\n+          \n+        case RTYPE_INFER:\n+          {\n+            if (_no_infer)\n+              fatal_error (\"gcc-rust has failed to infer a type and cannot continue\");\n+            else\n+              strcpy (buffer+offset, typeStrings [4]);\n+          }\n+          break;\n+\n+        case RTYPE_USER_STRUCT:\n+          strcpy (buffer+offset, RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node)));\n+          break;\n+\n+        default:\n+          fatal_error (\"unhandled type [%s]\", RDOT_OPCODE_STR (node));\n+          break;\n         }\n     }\n-    return xstrdup(buffer);\n+  return xstrdup (buffer);\n }\n \n-static void dot_pass_dump_node(FILE*, rdot, size_t);\n-static void dot_pass_dump_method(FILE*, rdot, size_t);\n-static void dot_pass_dump_struct(FILE*, rdot, size_t);\n-\n-static void dot_pass_dumpPrimitive(FILE*, rdot);\n-static void dot_pass_dumpExprNode(FILE*, rdot);\n-static void dot_pass_dump_expr(FILE*, rdot);\n-\n-// Seems to dump struct at node to file fd\n-static void dot_pass_dump_struct(FILE* fd, rdot node, size_t indents) {\n-    size_t i;\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"  \");\n-\n-    rdot ident = RDOT_lhs_TT(node);\n-    rdot layout = RDOT_rhs_TT(node);\n-\n-    fprintf(fd, \"struct %s {\\n\", RDOT_IDENTIFIER_POINTER(ident));\n-    rdot next;\n-    for (next = layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        gcc_assert(RDOT_TYPE(next) = D_PARAMETER);\n-        const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-        const char* typestr = typeStringNode(RDOT_rhs_TT(next));\n-\n-        for (i = 0; i < (indents + 1); ++i)\n-            fprintf(fd, \"  \");\n-        fprintf(fd, \"%s %s;\\n\", typestr, id);\n+static void dot_pass_dump_node (FILE *, rdot, size_t);\n+static void dot_pass_dump_method (FILE *, rdot, size_t);\n+static void dot_pass_dump_struct (FILE *, rdot, size_t);\n+\n+static void dot_pass_dumpPrimitive (FILE *, rdot);\n+static void dot_pass_dumpExprNode (FILE *, rdot);\n+static void dot_pass_dump_expr (FILE *, rdot);\n+\n+static\n+void dot_pass_dump_struct (FILE * fd, rdot node, size_t indents)\n+{\n+  size_t i;\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"  \");\n+\n+  rdot ident = RDOT_lhs_TT (node);\n+  rdot layout = RDOT_rhs_TT (node);\n+\n+  fprintf (fd, \"struct %s {\\n\", RDOT_IDENTIFIER_POINTER (ident));\n+  rdot next;\n+  for (next = layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      gcc_assert (RDOT_TYPE (next) = D_PARAMETER);\n+      const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+      const char * typestr = typeStringNode (RDOT_rhs_TT (next));\n+\n+      for (i = 0; i < (indents + 1); ++i)\n+\tfprintf (fd, \"  \");\n+      fprintf (fd, \"%s %s;\\n\", typestr, id);\n     }\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"  \");\n-    fprintf(fd, \"}\\n\");\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"  \");\n+  fprintf (fd, \"}\\n\");\n }\n \n-// Seems to dump method at node to file fd\n-static void dot_pass_dump_method(FILE* fd, rdot node, size_t indents) {\n-    size_t i;\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"  \");\n-\n-    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n-    char* rtype = NULL;\n-    if (RDOT_FIELD2(node))\n-        rtype = typeStringNode(RDOT_FIELD2(node));\n-    else\n-        rtype = xstrdup(\"void\");\n-    rdot parameters = RDOT_lhs_TT(node);\n-\n-    if (DOT_RETVAL(node))\n-        fprintf(fd, \"pub fn %s ( \", method_id);\n-    else\n-        fprintf(fd, \"fn %s ( \", method_id);\n-\n-    if (parameters == NULL_DOT)\n-        fprintf(fd, \"void\");\n-    else {\n-        rdot next;\n-        for (next = parameters; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-            gcc_assert(RDOT_TYPE(next) = D_PARAMETER);\n-            bool iself = false;\n-            bool muta = RDOT_qual(next);\n-            const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-\n-            if (strcmp(id, \"self\") == 0)\n-                iself = true;\n-\n-            const char* smuta;\n-            if (muta) {\n-                smuta = \"mut\";\n-            } else {\n-                smuta = \"final\";\n-            }\n-\n-            if (iself)\n-                fprintf(fd, \"[%s] _self_\", smuta);\n-            else {\n-                const char* typestr = typeStringNode(RDOT_rhs_TT(next));\n-                fprintf(fd, \"[%s] %s:%s\", smuta, typestr, id);\n-            }\n-            if (RDOT_CHAIN(next) != NULL_DOT)\n-                fprintf(fd, \", \");\n+static\n+void dot_pass_dump_method (FILE * fd, rdot node, size_t indents)\n+{\n+  size_t i;\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"  \");\n+\n+  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n+  char * rtype = NULL;\n+  if (RDOT_FIELD2 (node))\n+    rtype = typeStringNode (RDOT_FIELD2 (node));\n+  else\n+    rtype = xstrdup (\"void\");\n+  rdot parameters = RDOT_lhs_TT (node);\n+\n+  if (DOT_RETVAL (node))\n+    fprintf (fd, \"pub fn %s ( \", method_id);\n+  else\n+    fprintf (fd, \"fn %s ( \", method_id);\n+  \n+  if (parameters == NULL_DOT)\n+    fprintf (fd, \"void\");\n+  else\n+    {\n+      rdot next;\n+      for (next = parameters; next != NULL_DOT; next = RDOT_CHAIN (next))\n+        {\n+          gcc_assert (RDOT_TYPE (next) = D_PARAMETER);\n+\t  bool iself = false;\n+\t  bool muta = RDOT_qual (next);\n+          const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+\n+\t  if (strcmp (id, \"self\") == 0)\n+\t    iself = true;\n+\n+\t  const char *smuta;\n+\t  if (muta) {\n+\t    smuta = \"mut\";\n+\t  }\n+\t  else {\n+\t    smuta = \"final\";\n+\t  }\n+\n+\t  if (iself)\n+\t    fprintf (fd, \"[%s] _self_\", smuta);\n+\t  else\n+\t    {\n+\t      const char * typestr = typeStringNode (RDOT_rhs_TT (next));\n+\t      fprintf (fd, \"[%s] %s:%s\", smuta, typestr, id);\n+\t    }\n+          if (RDOT_CHAIN (next) != NULL_DOT)\n+            fprintf (fd, \", \");\n         }\n     }\n-    fprintf(fd, \" ) -> %s {\\n\", rtype);\n-    free(rtype);\n-\n-    rdot suite;\n-    for (suite = RDOT_rhs_TT(node); suite != NULL_DOT; suite = RDOT_CHAIN(suite)) {\n-        dot_pass_dump_node(fd, suite, indents + 1);\n-        fprintf(fd, \"\\n\");\n+  fprintf (fd, \" ) -> %s {\\n\", rtype);\n+  free (rtype);\n+\n+  rdot suite;\n+  for (suite = RDOT_rhs_TT (node); suite != NULL_DOT; suite = RDOT_CHAIN (suite))\n+    {\n+      dot_pass_dump_node (fd, suite, indents + 1);\n+      fprintf (fd, \"\\n\");\n     }\n \n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"  \");\n-    fprintf(fd, \"}\\n\");\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"  \");\n+  fprintf (fd, \"}\\n\");\n }\n \n-// Dumps primitive at RDOT_lhs_TC(node) to inputted file\n-static void dot_pass_dumpPrimitive(FILE* fd, rdot node) {\n-    /* Handle other primitive literal types here ... */\n-    switch (RDOT_lhs_TC(node).T) {\n-        case D_T_INTEGER:\n-            fprintf(fd, \"%i\", RDOT_lhs_TC(node).o.integer);\n-            break;\n-\n-        case D_T_FLOAT:\n-            fprintf(fd, \"%f\", RDOT_lhs_TC(node).o.ffloat);\n-            break;\n-\n-        case D_T_STRING:\n-            fprintf(fd, \"\\\"%s\\\"\", RDOT_lhs_TC(node).o.string);\n-            break;\n-\n-        default:\n-            fatal_error(\"Unable to dump primitive [%s]\",\n-                        rdot_getOpString_T(RDOT_lhs_TC(node).T));\n-            break;\n+static\n+void dot_pass_dumpPrimitive (FILE * fd, rdot node)\n+{\n+  /* Handle other primitive literal types here ... */\n+  switch (RDOT_lhs_TC (node).T)\n+    {\n+    case D_T_INTEGER:\n+      fprintf (fd, \"%i\", RDOT_lhs_TC (node).o.integer);\n+      break;\n+\n+    case D_T_FLOAT:\n+      fprintf (fd, \"%f\", RDOT_lhs_TC (node).o.ffloat);\n+      break;\n+\n+    case D_T_STRING:\n+      fprintf (fd, \"\\\"%s\\\"\", RDOT_lhs_TC (node).o.string);\n+      break;\n+\n+    default:\n+      fatal_error (\"Unable to dump primitive [%s]\",\n+\t\t   rdot_getOpString_T (RDOT_lhs_TC (node).T));\n+      break;\n     }\n }\n \n-// Dumps expression node to file fd. (this includes a lot of stuff, such as dumping expression itself)\n-static void dot_pass_dumpExprNode(FILE* fd, rdot node) {\n-    if (RDOT_MEM_MODIFIER(node)) {\n-        std::vector<ALLOCA_>::iterator it;\n-        for (it = RDOT_MEM_MODIFIER(node)->begin();\n-             it != RDOT_MEM_MODIFIER(node)->end();\n-             ++it) {\n-            switch (*it) {\n-                case ALLOC_DEREF:\n-                    fprintf(fd, \"*\");\n-                    break;\n-                case ALLOC_HEAP:\n-                    fprintf(fd, \"~\");\n-                    break;\n-                case ALLOC_REF:\n-                    fprintf(fd, \"&\");\n-                    break;\n+static\n+void dot_pass_dumpExprNode (FILE * fd, rdot node)\n+{\n+  if (RDOT_MEM_MODIFIER (node))\n+    {\n+      std::vector<ALLOCA_>::iterator it;\n+      for (it = RDOT_MEM_MODIFIER (node)->begin ();\n+           it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n+        {\n+          switch (*it)\n+            {\n+            case ALLOC_DEREF:\n+              fprintf (fd, \"*\");\n+              break;\n+            case ALLOC_HEAP:\n+              fprintf (fd, \"~\");\n+              break;\n+            case ALLOC_REF:\n+              fprintf (fd, \"&\");\n+              break;\n             }\n         }\n     }\n-    switch (RDOT_TYPE(node)) {\n-        case D_PRIMITIVE:\n-            dot_pass_dumpPrimitive(fd, node);\n-            break;\n-\n-        case D_IDENTIFIER:\n-            fprintf(fd, \"%s\", RDOT_IDENTIFIER_POINTER(node));\n-            break;\n-\n-        case D_BOOLEAN: {\n-            bool val = RDOT_BOOLEAN_VAL(node);\n-            if (val)\n-                fprintf(fd, \"true\");\n-            else\n-                fprintf(fd, \"false\");\n-        } break;\n-\n-        case D_CALL_EXPR: {\n-            rdot id = RDOT_lhs_TT(node);\n-            dot_pass_dump_expr(fd, id);\n-            fprintf(fd, \" (\");\n-\n-            rdot p;\n-            for (p = RDOT_rhs_TT(node); p != NULL_DOT; p = RDOT_CHAIN(p)) {\n-                dot_pass_dump_expr(fd, p);\n-                if (RDOT_CHAIN(p) != NULL_DOT)\n-                    fprintf(fd, \", \");\n-            }\n-            fprintf(fd, \")\");\n-        } break;\n-\n-        case D_VAR_DECL: {\n-            const char* mut;\n-            if (RDOT_qual(node))\n-                mut = \"_final_\";\n-            else\n-                mut = \"_mut_\";\n-\n-            fprintf(fd, \"let [%s] \", mut);\n-            dot_pass_dumpExprNode(fd, RDOT_lhs_TT(node));\n-            fprintf(fd, \" -> [%s]\", typeStringNode(RDOT_rhs_TT(node)));\n-        } break;\n-\n-        case D_STRUCT_INIT: {\n-            rdot ident = RDOT_lhs_TT(node);\n-            rdot init = RDOT_rhs_TT(node);\n-\n-            fprintf(fd, \"%s { \", RDOT_IDENTIFIER_POINTER(ident));\n-            rdot next;\n-            for (next = init; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-                gcc_assert(RDOT_TYPE(next) == D_STRUCT_PARAM);\n-                const char* name = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-\n-                fprintf(fd, \"%s:(\", name);\n-                dot_pass_dump_expr(fd, RDOT_rhs_TT(next));\n-                fprintf(fd, \")\");\n-                if (RDOT_CHAIN(next) != NULL_DOT)\n-                    fprintf(fd, \", \");\n-            }\n-            fprintf(fd, \" }\");\n-        } break;\n-\n-        default:\n-            error(\"unhandled dumpExprNode [%s]\\n\", RDOT_OPCODE_STR(node));\n-            break;\n+  switch (RDOT_TYPE (node))\n+    {\n+    case D_PRIMITIVE:\n+      dot_pass_dumpPrimitive (fd, node);\n+      break;\n+\n+    case D_IDENTIFIER:\n+      fprintf (fd, \"%s\", RDOT_IDENTIFIER_POINTER (node));\n+      break;\n+\n+    case D_BOOLEAN:\n+      {\n+\tbool val = RDOT_BOOLEAN_VAL (node);\n+\tif (val)\n+\t  fprintf (fd, \"true\");\n+\telse\n+\t  fprintf (fd, \"false\");\n+      }\n+      break;\n+\n+    case D_CALL_EXPR:\n+      {\n+        rdot id = RDOT_lhs_TT (node);\n+        dot_pass_dump_expr (fd, id);\n+        fprintf (fd, \" (\");\n+\n+        rdot p;\n+        for (p = RDOT_rhs_TT (node); p != NULL_DOT; p = RDOT_CHAIN (p))\n+\t  {\n+\t    dot_pass_dump_expr (fd, p);\n+\t    if (RDOT_CHAIN (p) != NULL_DOT)\n+\t      fprintf (fd, \", \");\n+\t  }\n+        fprintf (fd, \")\");\n+      }\n+      break;\n+\n+    case D_VAR_DECL:\n+      {\n+        const char * mut;\n+        if (RDOT_qual (node))\n+          mut = \"_final_\";\n+        else\n+          mut = \"_mut_\";\n+\n+        fprintf (fd, \"let [%s] \", mut);\n+        dot_pass_dumpExprNode (fd, RDOT_lhs_TT (node));\n+        fprintf (fd, \" -> [%s]\", typeStringNode (RDOT_rhs_TT (node)));\n+      }\n+      break;\n+\n+    case D_STRUCT_INIT:\n+      {\n+\trdot ident = RDOT_lhs_TT (node);\n+\trdot init = RDOT_rhs_TT (node);\n+\n+\tfprintf (fd, \"%s { \", RDOT_IDENTIFIER_POINTER (ident));\n+\trdot next;\n+\tfor (next = init; next != NULL_DOT; next = RDOT_CHAIN (next))\n+\t  {\n+\t    gcc_assert (RDOT_TYPE (next) == D_STRUCT_PARAM);\n+\t    const char * name = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+\t    \n+\t    fprintf (fd, \"%s:(\", name);\n+\t    dot_pass_dump_expr (fd, RDOT_rhs_TT (next));\n+\t    fprintf (fd, \")\");\n+\t    if (RDOT_CHAIN (next) != NULL_DOT)\n+\t      fprintf (fd, \", \");\n+\t  }\n+\tfprintf (fd, \" }\");\n+      }\n+      break;\n+\n+    default:\n+      error (\"unhandled dumpExprNode [%s]\\n\", RDOT_OPCODE_STR (node));\n+      break;\n     }\n }\n \n-// Seems to dump expression to file fd\n-static void dot_pass_dump_expr(FILE* fd, rdot node) {\n-    if (DOT_RETVAL(node)) {\n-        fprintf(fd, \"[_rust_retval]: \");\n-    }\n-\n-    switch (RDOT_TYPE(node)) {\n-        case D_PRIMITIVE:\n-        case D_IDENTIFIER:\n-        case D_CALL_EXPR:\n-        case D_BOOLEAN:\n-        case D_VAR_DECL:\n-        case D_STRUCT_INIT:\n-            dot_pass_dumpExprNode(fd, node);\n+static\n+void dot_pass_dump_expr (FILE * fd, rdot node)\n+{\n+  if (DOT_RETVAL (node)) {\n+    fprintf (fd, \"[_rust_retval]: \");\n+  }\n+\n+  switch (RDOT_TYPE (node))\n+    {\n+    case D_PRIMITIVE:\n+    case D_IDENTIFIER:\n+    case D_CALL_EXPR:\n+    case D_BOOLEAN:\n+    case D_VAR_DECL:\n+    case D_STRUCT_INIT:\n+      dot_pass_dumpExprNode (fd, node);\n+      break;\n+        \n+    default:\n+      {\n+        /* print expr tree ... */\n+        rdot lhs = RDOT_lhs_TT (node);\n+        rdot rhs = RDOT_rhs_TT (node);\n+        \n+        dot_pass_dump_expr (fd, lhs);\n+        switch (RDOT_TYPE (node))\n+          {\n+          case D_MODIFY_EXPR:\n+            fprintf (fd, \" = \");\n             break;\n \n-        default: {\n-            /* print expr tree ... */\n-            rdot lhs = RDOT_lhs_TT(node);\n-            rdot rhs = RDOT_rhs_TT(node);\n-\n-            dot_pass_dump_expr(fd, lhs);\n-            switch (RDOT_TYPE(node)) {\n-                case D_MODIFY_EXPR:\n-                    fprintf(fd, \" = \");\n-                    break;\n-\n-                case D_ADD_EXPR:\n-                    fprintf(fd, \" + \");\n-                    break;\n-\n-                case D_MINUS_EXPR:\n-                    fprintf(fd, \" - \");\n-                    break;\n-\n-                case D_MULT_EXPR:\n-                    fprintf(fd, \" * \");\n-                    break;\n+          case D_ADD_EXPR:\n+            fprintf (fd, \" + \");\n+            break;\n \n-                case D_LESS_EXPR:\n-                    fprintf(fd, \" < \");\n-                    break;\n+          case D_MINUS_EXPR:\n+            fprintf (fd, \" - \");\n+            break;\n \n-                case D_LESS_EQ_EXPR:\n-                    fprintf(fd, \" <= \");\n-                    break;\n+          case D_MULT_EXPR:\n+            fprintf (fd, \" * \");\n+            break;\n \n-                case D_GREATER_EXPR:\n-                    fprintf(fd, \" > \");\n-                    break;\n+          case D_LESS_EXPR:\n+            fprintf (fd, \" < \");\n+            break;\n \n-                case D_GREATER_EQ_EXPR:\n-                    fprintf(fd, \" >= \");\n-                    break;\n+\t  case D_LESS_EQ_EXPR:\n+\t    fprintf (fd, \" <= \");\n+\t    break;\n+            \n+          case D_GREATER_EXPR:\n+            fprintf (fd, \" > \");\n+            break;\n \n-                case D_EQ_EQ_EXPR:\n-                    fprintf(fd, \" == \");\n-                    break;\n+\t  case D_GREATER_EQ_EXPR:\n+\t    fprintf (fd, \" >= \");\n+\t    break;\n \n-                case D_NOT_EQ_EXPR:\n-                    fprintf(fd, \" != \");\n-                    break;\n+          case D_EQ_EQ_EXPR:\n+            fprintf (fd, \" == \");\n+            break;\n \n-                case D_ATTRIB_REF:\n-                    fprintf(fd, \".\");\n-                    break;\n+          case D_NOT_EQ_EXPR:\n+            fprintf (fd, \" != \");\n+            break;\n+\t    \n+\t  case D_ATTRIB_REF:\n+\t    fprintf (fd, \".\");\n+\t    break;\n \n-                case D_ACC_EXPR:\n-                    fprintf(fd, \"::\");\n-                    break;\n+\t  case D_ACC_EXPR:\n+\t    fprintf (fd, \"::\");\n+\t    break;\n \n-                default:\n-                    fatal_error(\"unhandled dump [%s]!\\n\", RDOT_OPCODE_STR(node));\n-                    break;\n-            }\n-            dot_pass_dump_expr(fd, rhs);\n-        } break;\n+          default:\n+            fatal_error (\"unhandled dump [%s]!\\n\", RDOT_OPCODE_STR (node));\n+            break;\n+          }\n+        dot_pass_dump_expr (fd, rhs);\n+      }\n+      break;\n     }\n }\n \n-// Seems to dump rust \"enum\" to file fd\n-static void dot_pass_dump_enum(FILE* fd, rdot node, size_t indents) {\n-    rdot enum_id = RDOT_lhs_TT(node);\n-    rdot enum_layout = RDOT_rhs_TT(node);\n-\n-    size_t i;\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    const char* id = RDOT_IDENTIFIER_POINTER(enum_id);\n-    fprintf(fd, \"enum %s {\\n\", id);\n-\n-    indents++;\n-    rdot next;\n-    for (next = enum_layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        for (i = 0; i < indents; ++i)\n-            fprintf(fd, \"    \");\n-        const char* enumit = RDOT_IDENTIFIER_POINTER(next);\n-        fprintf(fd, \"[%s],\\n\", enumit);\n+static\n+void dot_pass_dump_enum (FILE * fd, rdot node, size_t indents)\n+{\n+  rdot enum_id = RDOT_lhs_TT (node);\n+  rdot enum_layout = RDOT_rhs_TT (node);\n+\n+  size_t i;\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  const char * id = RDOT_IDENTIFIER_POINTER (enum_id);\n+  fprintf (fd, \"enum %s {\\n\", id);\n+\n+  indents++;\n+  rdot next;\n+  for (next = enum_layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      for (i = 0; i < indents; ++i)\n+\tfprintf (fd, \"    \");\n+      const char *enumit = RDOT_IDENTIFIER_POINTER (next);\n+      fprintf (fd, \"[%s],\\n\", enumit);\n     }\n-    indents--;\n+  indents--;\n \n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"}\\n\");\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"}\\n\");\n }\n \n-// Seems to dump conditional to file fd\n-static void dot_pass_dump_cond(FILE* fd, rdot node, size_t indents) {\n-    size_t i;\n-    rdot ifb = RDOT_lhs_TT(node);\n-    rdot elb = RDOT_rhs_TT(node);\n-\n-    gcc_assert(RDOT_TYPE(ifb) == D_STRUCT_IF);\n-\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-\n-    fprintf(fd, \"if (\");\n-    dot_pass_dump_expr(fd, RDOT_lhs_TT(ifb));\n-    fprintf(fd, \") {\\n\");\n-\n-    rdot next;\n-    for (next = RDOT_rhs_TT(ifb); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        dot_pass_dump_node(fd, next, indents + 1);\n-        fprintf(fd, \"\\n\");\n+static\n+void dot_pass_dump_cond (FILE * fd, rdot node, size_t indents)\n+{\n+  size_t i;\n+  rdot ifb = RDOT_lhs_TT (node);\n+  rdot elb = RDOT_rhs_TT (node);\n+\n+  gcc_assert (RDOT_TYPE (ifb) == D_STRUCT_IF);\n+\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+\n+  fprintf (fd, \"if (\");\n+  dot_pass_dump_expr (fd, RDOT_lhs_TT (ifb));\n+  fprintf (fd, \") {\\n\");\n+  \n+  rdot next;\n+  for (next = RDOT_rhs_TT (ifb) ; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      dot_pass_dump_node (fd, next, indents + 1);\n+      fprintf (fd, \"\\n\");\n     }\n \n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"}\");\n-\n-    if (elb != NULL_DOT) {\n-        fprintf(fd, \" else {\\n\");\n-        for (next = RDOT_lhs_TT(elb); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-            dot_pass_dump_node(fd, next, indents + 1);\n-            fprintf(fd, \"\\n\");\n-        }\n-        for (i = 0; i < indents; ++i)\n-            fprintf(fd, \"    \");\n-        fprintf(fd, \"}\\n\");\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"}\");\n+\n+  if (elb != NULL_DOT)\n+    {\n+      fprintf (fd, \" else {\\n\");\n+      for (next = RDOT_lhs_TT (elb); next != NULL_DOT; next = RDOT_CHAIN (next))\n+\t{\n+\t  dot_pass_dump_node (fd, next, indents + 1);\n+\t  fprintf (fd, \"\\n\");\n+\t} \n+      for (i = 0; i < indents; ++i)\n+\tfprintf (fd, \"    \");\n+      fprintf (fd, \"}\\n\");\n     }\n }\n \n-// Seems to dump break to file fd\n-static void dot_pass_dump_break(FILE* fd, const rdot node, size_t indents) {\n-    size_t i;\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"break;\");\n+static\n+void dot_pass_dump_break (FILE * fd, const rdot node, size_t indents)\n+{\n+  size_t i;\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"break;\");\n }\n \n-// Seems to dump loop construct to file fd\n-static void dot_pass_dump_loop(FILE* fd, const rdot node, size_t indents) {\n-    const rdot suite = RDOT_lhs_TT(node);\n-    size_t i;\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"loop {\\n\");\n-\n-    rdot next;\n-    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        dot_pass_dump_node(fd, next, indents + 1);\n-        fprintf(fd, \"\\n\");\n+static\n+void dot_pass_dump_loop (FILE * fd, const rdot node, size_t indents)\n+{\n+  const rdot suite = RDOT_lhs_TT (node);\n+  size_t i;\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"loop {\\n\");\n+  \n+  rdot next;\n+  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      dot_pass_dump_node (fd, next, indents + 1);\n+      fprintf (fd, \"\\n\");\n     }\n-\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"}\\n\");\n+  \n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"}\\n\");\n }\n \n-// Seems to dump while to file fd\n-static void dot_pass_dump_while(FILE* fd, const rdot node, size_t indents) {\n-    size_t i;\n-    rdot expr = RDOT_lhs_TT(node);\n-    rdot suite = RDOT_rhs_TT(node);\n-\n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"while (\");\n-    dot_pass_dump_expr(fd, expr);\n-    fprintf(fd, \") {\\n\");\n-\n-    rdot next;\n-    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        dot_pass_dump_node(fd, next, indents + 1);\n-        fprintf(fd, \"\\n\");\n+static\n+void dot_pass_dump_while (FILE * fd, const rdot node, size_t indents)\n+{\n+  size_t i;\n+  rdot expr = RDOT_lhs_TT (node);\n+  rdot suite = RDOT_rhs_TT (node);\n+\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"while (\");\n+  dot_pass_dump_expr (fd, expr);\n+  fprintf (fd, \") {\\n\");\n+\n+  rdot next;\n+  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      dot_pass_dump_node (fd, next, indents + 1);\n+      fprintf (fd, \"\\n\");\n     }\n \n-    for (i = 0; i < indents; ++i)\n-        fprintf(fd, \"    \");\n-    fprintf(fd, \"}\");\n+  for (i = 0; i < indents; ++i)\n+    fprintf (fd, \"    \");\n+  fprintf (fd, \"}\");\n }\n \n-// Seems to dump impl block to file fd\n-static void dot_pass_dump_impl(FILE* fd, rdot node, size_t indents) {\n-    const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n-    fprintf(fd, \"impl %s {\\n\", implid);\n-\n-    rdot next;\n-    for (next = RDOT_rhs_TT(node); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n-        dot_pass_dump_node(fd, next, indents + 1);\n-        fprintf(fd, \"\\n\");\n+static\n+void dot_pass_dump_impl (FILE * fd, rdot node, size_t indents)\n+{\n+  const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n+  fprintf (fd, \"impl %s {\\n\", implid);\n+\n+  rdot next;\n+  for (next = RDOT_rhs_TT (node); next != NULL_DOT; next = RDOT_CHAIN (next))\n+    {\n+      dot_pass_dump_node (fd, next, indents + 1);\n+      fprintf (fd, \"\\n\");\n     }\n \n-    fprintf(fd, \"}\\n\");\n+  fprintf (fd, \"}\\n\");\n }\n \n-// Seems to be a selector that dumps a node of a given type to file fd - switches between them\n-static void dot_pass_dump_node(FILE* fd, rdot node, size_t indents) {\n-    if (RDOT_T_FIELD(node) == D_D_EXPR) {\n-        size_t i;\n-        for (i = 0; i < indents; ++i)\n-            fprintf(fd, \"    \");\n-        dot_pass_dump_expr(fd, node);\n-        fprintf(fd, \";\");\n-    } else {\n-        switch (RDOT_TYPE(node)) {\n-            case D_PRIMITIVE:\n-                dot_pass_dump_expr(fd, node);\n-                break;\n-\n-            case D_STRUCT_IMPL:\n-                dot_pass_dump_impl(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_METHOD:\n-                dot_pass_dump_method(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_TYPE:\n-                dot_pass_dump_struct(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_ENUM:\n-                dot_pass_dump_enum(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_IF:\n-                dot_pass_dump_cond(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_WHILE:\n-                dot_pass_dump_while(fd, node, indents);\n-                break;\n-\n-            case D_STRUCT_LOOP:\n-                dot_pass_dump_loop(fd, node, indents);\n-                break;\n-\n-            case C_BREAK_STMT:\n-                dot_pass_dump_break(fd, node, indents);\n-                break;\n-\n-            default:\n-                error(\"unhandled node [%s]\\n\", RDOT_OPCODE_STR(node));\n-                break;\n+static\n+void dot_pass_dump_node (FILE * fd, rdot node, size_t indents)\n+{\n+  if (RDOT_T_FIELD (node) ==  D_D_EXPR)\n+    {\n+      size_t i;\n+      for (i = 0; i < indents; ++i)\n+        fprintf (fd, \"    \");\n+      dot_pass_dump_expr (fd, node);\n+      fprintf (fd, \";\");\n+    }\n+  else\n+    {\n+      switch (RDOT_TYPE (node))\n+        {\n+        case D_PRIMITIVE:\n+          dot_pass_dump_expr (fd, node);\n+          break;\n+\n+\tcase D_STRUCT_IMPL:\n+\t  dot_pass_dump_impl (fd, node, indents);\n+\t  break;\n+\n+        case D_STRUCT_METHOD:\n+          dot_pass_dump_method (fd, node, indents);\n+          break;\n+        \n+\tcase D_STRUCT_TYPE:\n+\t  dot_pass_dump_struct (fd, node, indents);\n+\t  break;\n+     \n+\tcase D_STRUCT_ENUM:\n+\t  dot_pass_dump_enum (fd, node, indents);\n+\t  break;\n+\n+\tcase D_STRUCT_IF:\n+\t  dot_pass_dump_cond (fd, node, indents);\n+\t  break;\n+\n+\tcase D_STRUCT_WHILE:\n+\t  dot_pass_dump_while (fd, node, indents);\n+\t  break;\n+\n+        case D_STRUCT_LOOP:\n+          dot_pass_dump_loop (fd, node, indents);\n+          break;\n+\n+        case C_BREAK_STMT:\n+          dot_pass_dump_break (fd, node, indents);\n+          break;\n+\n+        default:\n+\t  error (\"unhandled node [%s]\\n\", RDOT_OPCODE_STR (node));\n+          break;\n         }\n     }\n }\n \n-// Seems to be main entry point into dumping - dumps all decls to file\n-vec<rdot, va_gc>* dot_pass_PrettyPrint(vec<rdot, va_gc>* decls) {\n-    if (GRS_OPT_dump_dot) {\n-        size_t bsize = 128;\n-        char* outfile = (char*)alloca(bsize);\n-        gcc_assert(outfile);\n-        memset(outfile, 0, bsize);\n-\n-        strncpy(outfile, GRS_current_infile, strlen(GRS_current_infile));\n-        if (first == true) {\n-            strncat(outfile, RDOT_PREFIX_PRE, sizeof(RDOT_PREFIX_PRE));\n-            first = false;\n-        } else {\n-            strncat(outfile, RDOT_PREFIX_POST, sizeof(RDOT_PREFIX_POST));\n-            _no_infer = true;\n+vec<rdot,va_gc> * dot_pass_PrettyPrint (vec<rdot,va_gc> * decls)\n+{\n+  if (GRS_OPT_dump_dot)\n+    {\n+      size_t bsize = 128;\n+      char * outfile =  (char *) alloca (bsize);\n+      gcc_assert (outfile);\n+      memset (outfile, 0, bsize);\n+\n+      strncpy (outfile, GRS_current_infile, strlen (GRS_current_infile));\n+      if (first == true)\n+        {\n+          strncat (outfile, RDOT_PREFIX_PRE, sizeof (RDOT_PREFIX_PRE));\n+          first = false;\n+        }\n+      else\n+        {\n+          strncat (outfile, RDOT_PREFIX_POST, sizeof (RDOT_PREFIX_POST));\n+          _no_infer = true;\n         }\n \n-        FILE* fd = fopen(outfile, \"w\");\n-        if (!fd) {\n-            error(\"Unable to open %s for write\\n\", outfile);\n-            goto exit;\n+      FILE * fd = fopen (outfile, \"w\");\n+      if (!fd)\n+        {\n+          error (\"Unable to open %s for write\\n\", outfile);\n+          goto exit;\n         }\n \n-        rdot idtx = NULL_DOT;\n-        size_t i;\n-        for (i = 0; decls->iterate(i, &idtx); ++i) {\n-            dot_pass_dump_node(fd, idtx, 0);\n-            fprintf(fd, \"\\n\");\n+      rdot idtx = NULL_DOT;\n+      size_t i;\n+      for (i = 0; decls->iterate (i, &idtx); ++i)\n+        {\n+          dot_pass_dump_node (fd, idtx, 0);\n+          fprintf (fd, \"\\n\");\n         }\n \n-        fclose(fd);\n+      fclose (fd);\n     }\n-exit:\n-    return decls;\n+ exit:\n+  return decls;\n }"}, {"sha": "b45f9317476b5a40aeae96c13e3a001920409736", "filename": "gcc/rust/old/rs-lexer.l", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-lexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -137,24 +137,25 @@ for                     {  return FOR; }\n \n %%\n \n-bool grs_do_compile(const char * in) {\n+bool grs_do_compile (const char * in)\n+{\n     bool retval = true;\n-    FILE * fd = fopen(in, \"rb\");\n-    \n-    if (fd) {\n-\t      yyin = fd;\n-        \n+    FILE * fd = fopen (in, \"rb\");\n+    if (fd)\n+    {\n+\tyyin = fd;\n         // yydebug = 1;\n-        linemap_add(line_table, LC_ENTER, 0, in, 0);\n-\t      retval = yyparse();\n-\t      fclose (fd);\n-        linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n-\t      yylex_destroy();\n-    } else {\n-\t      fprintf(stderr, \"error opening file %s\\n\", in);\n-\t      retval = false;\n+        linemap_add (line_table, LC_ENTER, 0, in, 0);\n+\tretval = yyparse ();\n+\tfclose (fd);\n+        linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n+\tyylex_destroy ();\n+    }\n+    else\n+    {\n+\tfprintf (stderr, \"error opening file %s\\n\", in);\n+\tretval = false;\n     }\n-    \n     return retval;\n }\n "}, {"sha": "c3c8c2cea35a5bbb7b96f003a5ef189cc16e89af", "filename": "gcc/rust/old/rs-parser.cc", "status": "modified", "additions": 789, "deletions": 707, "changes": 1496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-parser.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -6,751 +6,833 @@ static int sym;\n static int __yyerror;\n extern int yylineno;\n \n-static void yyerror(const char*, ...);\n-extern int yylex(void);\n-static bool __yyaccept__(int, bool);\n-static bool yyexpect(int);\n+static void yyerror (const char *, ...);\n+extern int yylex (void);\n+static bool __yyaccept__ (int, bool);\n+static bool yyexpect (int);\n \n #ifdef _DEBUG\n-#define yylex_()                             \\\n-    yylex();                                 \\\n-    do {                                     \\\n-        char* __token = yytoken_string(sym); \\\n-        printf(\"[%i:%s]\\n\", sym, __token);   \\\n-        free(__token);                       \\\n-    } while (0)\n+# define yylex_()                                               \\\n+  yylex ();                                                     \\\n+  do {                                                          \\\n+    char *__token = yytoken_string (sym);                       \\\n+    printf (\"[%i:%s]\\n\", sym, __token);                         \\\n+    free (__token);                                             \\\n+  } while (0)\n #else\n-#define yylex_() yylex()\n+# define yylex_()  yylex ()\n #endif\n \n-static std::vector<ALLOCA_>* alloca_modifiers(void);\n-\n-static rdot type(void);\n-static rdot target(void);\n-static rdot suite(void);\n-static rdot else_block(void);\n-static rdot elif_block(void);\n-static rdot if_block(void);\n-static rdot struct_conditional(void);\n-static rdot primary(void);\n-static rdot factor1(void);\n-static rdot factor2(void);\n-static rdot expression(void);\n-\n-static vec<rdot, va_gc>* symStack;\n-static const char* token_strings[] = {\n-    \"impl\",\n-    \"as\",\n-    \"break\",\n-    \"continue\",\n-    \"do\",\n-    \"fn\",\n-    \"let\",\n-    \"mut\",\n-    \"loop\",\n-    \"static\",\n-    \"->\",\n-    \"bool\",\n-    \"int\",\n-    \"uint\",\n-    \"float\",\n-    \"::\",\n-    \"enum\",\n-    \"==\",\n-    \"!=\",\n-    \"<\",\n-    \">\",\n-    \"<=\",\n-    \">=\",\n-    \"struct\",\n-    \"while\",\n-    \"if\",\n-    \"else\",\n-    \"self\",\n-    \"match\",\n-    \"=>\",\n-    \"true\",\n-    \"false\",\n-    \"string_literal\",\n-    \"identifier\",\n-    \"integer\",\n-    \"pub\",\n-    \"for\",\n-    \"trait\",\n-    \"else if\",\n-    \"float\",\n-    \"unknown\"\n+static std::vector<ALLOCA_> * alloca_modifiers (void);\n+\n+static rdot type (void);\n+static rdot target (void);\n+static rdot suite (void);\n+static rdot else_block (void);\n+static rdot elif_block (void);\n+static rdot if_block (void);\n+static rdot struct_conditional (void);\n+static rdot primary (void);\n+static rdot factor1 (void);\n+static rdot factor2 (void);\n+static rdot expression (void);\n+\n+static vec<rdot, va_gc> * symStack;\n+static const char * token_strings [] = {\n+  \"impl\",\n+  \"as\",\n+  \"break\",\n+  \"continue\",\n+  \"do\",\n+  \"fn\",\n+  \"let\",\n+  \"mut\",\n+  \"loop\",\n+  \"static\",\n+  \"->\",\n+  \"bool\",\n+  \"int\",\n+  \"uint\",\n+  \"float\",\n+  \"::\",\n+  \"enum\",\n+  \"==\",\n+  \"!=\",\n+  \"<\",\n+  \">\",\n+  \"<=\",\n+  \">=\",\n+  \"struct\",\n+  \"while\",\n+  \"if\",\n+  \"else\",\n+  \"self\",\n+  \"match\",\n+  \"=>\",\n+  \"true\",\n+  \"false\",\n+  \"string_literal\",\n+  \"identifier\",\n+  \"integer\",\n+  \"pub\",\n+  \"for\",\n+  \"trait\",\n+  \"else if\",\n+  \"float\",\n+  \"unknown\"\n };\n \n-static char*\n-yytoken_string(int token) {\n-    char retval[128];\n-    memset(retval, 0, 128);\n-    if (token >= 258 && token <= 298)\n-        strncpy(retval, token_strings[token - 258 - 1], 128);\n-    else\n-        retval[0] = (char)token;\n-    return xstrdup(retval);\n-}\n-\n-#define yyaccept(_X) __yyaccept__(_X, true)\n-#define yyaccept_(_X) __yyaccept__(_X, false)\n-static bool __yyaccept__(int s, bool forward) {\n-    if (sym == s) {\n-        if (forward) {\n-            sym = yylex_();\n+static char *\n+yytoken_string (int token)\n+{\n+  char retval [128];\n+  memset (retval, 0, 128);\n+  if (token >= 258 && token <= 298)\n+    strncpy (retval, token_strings [token-258-1], 128);\n+  else\n+    retval [0] = (char) token;\n+  return xstrdup (retval);\n+}\n+\n+#define yyaccept(_X)   __yyaccept__ (_X, true)\n+#define yyaccept_(_X)  __yyaccept__ (_X, false)\n+static\n+bool __yyaccept__ (int s, bool forward)\n+{\n+  if (sym == s)\n+    {\n+      if (forward)\n+        {\n+          sym = yylex_ ();\n         }\n-        return true;\n+      return true;\n     }\n-    return false;\n-}\n-\n-static bool yyexpect(int s) {\n-    bool retval = false;\n-    if (yyaccept(s) == true)\n-        retval = true;\n-    else {\n-        char* e1 = yytoken_string(s);\n-        char* e2 = yytoken_string(sym);\n-        yyerror(\"expected [%s] got [%s]\", e1, e2);\n-        free(e1);\n-        free(e2);\n+  return false;\n+}\n+\n+static\n+bool yyexpect (int s)\n+{\n+  bool retval = false;\n+  if (yyaccept (s) == true)\n+    retval = true;\n+  else\n+    {\n+      char * e1 = yytoken_string (s);\n+      char * e2 = yytoken_string (sym);\n+      yyerror (\"expected [%s] got [%s]\", e1, e2);\n+      free (e1);\n+      free (e2);\n     }\n-    return retval;\n+  return retval;\n }\n \n /* Also realy need to make use of location_t and gcc diagnostics .. */\n /* this is really hacky but its ok for now really need to fix this though */\n-static void __attribute__((format(printf, 1, 2)))\n-yyerror(const char* fmt, ...) {\n-    __yyerror += 1;\n-    char* buffer = (char*)alloca(512);\n-    memset(buffer, 0, 512);\n-\n-    va_list vl;\n-    va_start(vl, fmt);\n-    vsprintf(buffer, fmt, vl);\n-    va_end(vl);\n-\n-    char* buffer_message = (char*)alloca(512);\n-    memset(buffer_message, 0, 512);\n-    snprintf(buffer_message, 512, \"syntax error at %i: [%s]\", yylineno, buffer);\n-\n-    fatal_error(\"%s\", buffer_message);\n-}\n-\n-std::vector<ALLOCA_>* alloca_modifiers(void) {\n-    std::vector<ALLOCA_>* allocas = new std::vector<ALLOCA_>;\n-    while (sym == '~' || sym == '&' || sym == '*') {\n-        ALLOCA_ mod;\n-        switch (sym) {\n-            case '~':\n-                mod = ALLOC_HEAP;\n-                break;\n-            case '&':\n-                mod = ALLOC_REF;\n-                break;\n-            case '*':\n-                mod = ALLOC_DEREF;\n-                break;\n-            default:\n-                break;\n+static void __attribute__ ((format (printf, 1, 2)))\n+yyerror (const char * fmt, ...)\n+{\n+  __yyerror += 1;\n+  char * buffer = (char *) alloca (512);\n+  memset (buffer, 0, 512);\n+  \n+  va_list vl;\n+  va_start (vl, fmt);\n+  vsprintf (buffer, fmt, vl);\n+  va_end (vl);\n+\n+  char * buffer_message = (char *) alloca (512);\n+  memset (buffer_message, 0, 512);\n+  snprintf (buffer_message, 512, \"syntax error at %i: [%s]\", yylineno, buffer);\n+    \n+  fatal_error (\"%s\", buffer_message);\n+}\n+\n+std::vector<ALLOCA_> * alloca_modifiers (void)\n+{\n+  std::vector<ALLOCA_> * allocas = new std::vector<ALLOCA_>;\n+  while (sym == '~' || sym == '&' || sym == '*')\n+    {\n+      ALLOCA_ mod;\n+      switch (sym)\n+        {\n+        case '~':\n+          mod = ALLOC_HEAP;\n+          break;\n+        case '&':\n+          mod = ALLOC_REF;\n+          break;\n+        case '*':\n+          mod = ALLOC_DEREF;\n+          break;\n+        default:\n+          break;\n+        }\n+      yyexpect (sym);\n+      allocas->push_back (mod);\n+    }\n+  return allocas;\n+}\n+\n+rdot type (void)\n+{\n+  std::vector<ALLOCA_> * mem = alloca_modifiers ();\n+  rdot retval = NULL_DOT;\n+  if (yyaccept (TYPE_INT))\n+    retval = rdot_build_decl1 (RTYPE_INT, NULL_DOT);\n+  else if (yyaccept (TYPE_UINT))\n+    retval = rdot_build_decl1 (RTYPE_UINT, NULL_DOT);\n+  else if (yyaccept (TYPE_FLOAT))\n+    retval = rdot_build_decl1 (RTYPE_FLOAT, NULL_DOT);\n+  else if (yyaccept (TYPE_BOOL))\n+    retval = rdot_build_decl1 (RTYPE_BOOL, NULL_DOT);\n+  else if (yyaccept (IDENTIFIER))\n+    {\n+      char * sid = yylval.string;\n+      retval = rdot_build_decl1 (RTYPE_USER_STRUCT,\n+                                 rdot_build_identifier (sid));\n+      free (sid);\n+    }\n+  else\n+    yyerror (\"expected a type got [%s]\", yytoken_string (sym));\n+\n+  RDOT_MMEM_COPY (mem, RDOT_MEM_MODIFIER (retval));\n+  delete mem;\n+\n+  return retval;\n+}\n+\n+rdot target (void)\n+{\n+  yyexpect (LET);\n+  bool qual = true;\n+  if (yyaccept (MUT))\n+    qual = false;\n+  \n+  yyexpect (IDENTIFIER);\n+  char * tid = yylval.string;\n+  \n+  rdot ltype = NULL_DOT;\n+  if (yyaccept (':'))\n+    ltype = type ();\n+  if (ltype == NULL_DOT)\n+      ltype = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n+  \n+  rdot retval = rdot_build_varDecl (ltype, qual,\n+                                    rdot_build_identifier (tid));\n+  free (tid);\n+  return retval;\n+}\n+\n+void argument_list_ (rdot head)\n+{\n+  if (yyaccept_ (')'))\n+    return;\n+\n+  rdot p = expression ();\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, p);\n+  else\n+    RDOT_CHAIN (head) = p;\n+  \n+  if (yyaccept (','))\n+    argument_list_ (p);\n+}\n+\n+rdot argument_list ()\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  argument_list_ (NULL_DOT);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n+}\n+\n+rdot struct_elem ()\n+{\n+  yyexpect (IDENTIFIER);\n+  char * selem = yylval.string;\n+  yyexpect (':');\n+  rdot expr = expression ();\n+  rdot retval = rdot_build_decl2 (D_STRUCT_PARAM,\n+                                  rdot_build_identifier (selem),\n+                                  expr);\n+  free (selem);\n+  return retval;\n+}\n+\n+void struct_init_list_ (rdot head)\n+{\n+  if (yyaccept_ ('}'))\n+    return;\n+  rdot e = struct_elem ();\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, e);\n+  else\n+    RDOT_CHAIN (head) = e;\n+  if (yyaccept (','))\n+    struct_init_list_ (e);\n+}\n+\n+rdot struct_init_list (void)\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  struct_init_list_ (NULL_DOT);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n+}\n+\n+rdot primary (void)\n+{\n+  rdot retval = NULL_DOT;\n+  std::vector<ALLOCA_> * mem = alloca_modifiers ();\n+  if (yyaccept (IDENTIFIER))\n+    {\n+      // maybe call...\n+      char * pid = yylval.string;\n+      if (yyaccept_ ('('))\n+        {\n+          yyexpect ('(');\n+          rdot alist = argument_list ();\n+          yyexpect (')');\n+          retval = rdot_build_decl2 (D_CALL_EXPR,\n+                                     rdot_build_identifier (pid),\n+                                     alist);\n         }\n-        yyexpect(sym);\n-        allocas->push_back(mod);\n+      // struct init\n+      else if (yyaccept_ ('{'))\n+        {\n+          yyexpect ('{');\n+          rdot sls = struct_init_list ();\n+          yyexpect ('}');\n+          retval = rdot_build_decl2 (D_STRUCT_INIT,\n+                                     rdot_build_identifier (pid),\n+                                     sls);\n+        }\n+      // just a simple identifier...\n+      else\n+        retval = rdot_build_identifier (pid);\n+      free (pid);\n     }\n-    return allocas;\n-}\n-\n-rdot type(void) {\n-    std::vector<ALLOCA_>* mem = alloca_modifiers();\n-    rdot retval = NULL_DOT;\n-    if (yyaccept(TYPE_INT))\n-        retval = rdot_build_decl1(RTYPE_INT, NULL_DOT);\n-    else if (yyaccept(TYPE_UINT))\n-        retval = rdot_build_decl1(RTYPE_UINT, NULL_DOT);\n-    else if (yyaccept(TYPE_FLOAT))\n-        retval = rdot_build_decl1(RTYPE_FLOAT, NULL_DOT);\n-    else if (yyaccept(TYPE_BOOL))\n-        retval = rdot_build_decl1(RTYPE_BOOL, NULL_DOT);\n-    else if (yyaccept(IDENTIFIER)) {\n-        char* sid = yylval.string;\n-        retval = rdot_build_decl1(RTYPE_USER_STRUCT,\n-                                  rdot_build_identifier(sid));\n-        free(sid);\n-    } else\n-        yyerror(\"expected a type got [%s]\", yytoken_string(sym));\n-\n-    RDOT_MMEM_COPY(mem, RDOT_MEM_MODIFIER(retval));\n-    delete mem;\n-\n-    return retval;\n-}\n-\n-rdot target(void) {\n-    yyexpect(LET);\n-    bool qual = true;\n-    if (yyaccept(MUT))\n-        qual = false;\n-\n-    yyexpect(IDENTIFIER);\n-    char* tid = yylval.string;\n-\n-    rdot ltype = NULL_DOT;\n-    if (yyaccept(':'))\n-        ltype = type();\n-    if (ltype == NULL_DOT)\n-        ltype = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n-\n-    rdot retval = rdot_build_varDecl(ltype, qual, rdot_build_identifier(tid));\n-    free(tid);\n-    return retval;\n-}\n-\n-void argument_list_(rdot head) {\n-    if (yyaccept_(')'))\n-        return;\n-\n-    rdot p = expression();\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, p);\n-    else\n-        RDOT_CHAIN(head) = p;\n-\n-    if (yyaccept(','))\n-        argument_list_(p);\n-}\n-\n-rdot argument_list() {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    argument_list_(NULL_DOT);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n-}\n-\n-rdot struct_elem() {\n-    yyexpect(IDENTIFIER);\n-    char* selem = yylval.string;\n-    yyexpect(':');\n-    rdot expr = expression();\n-    rdot retval = rdot_build_decl2(D_STRUCT_PARAM,\n-                                   rdot_build_identifier(selem),\n-                                   expr);\n-    free(selem);\n-    return retval;\n-}\n-\n-void struct_init_list_(rdot head) {\n-    if (yyaccept_('}'))\n-        return;\n-    rdot e = struct_elem();\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, e);\n-    else\n-        RDOT_CHAIN(head) = e;\n-    if (yyaccept(','))\n-        struct_init_list_(e);\n-}\n-\n-rdot struct_init_list(void) {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    struct_init_list_(NULL_DOT);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n-}\n-\n-rdot primary(void) {\n-    rdot retval = NULL_DOT;\n-    std::vector<ALLOCA_>* mem = alloca_modifiers();\n-    if (yyaccept(IDENTIFIER)) {\n-        // maybe call...\n-        char* pid = yylval.string;\n-        if (yyaccept_('(')) {\n-            yyexpect('(');\n-            rdot alist = argument_list();\n-            yyexpect(')');\n-            retval = rdot_build_decl2(D_CALL_EXPR,\n-                                      rdot_build_identifier(pid),\n-                                      alist);\n+  else if (yyaccept (INTEGER))\n+    retval = rdot_build_integer (yylval.integer);\n+  else if (yyaccept (FLOAT))\n+    retval = rdot_build_float (yylval.ffloat);\n+  else if (yyaccept (STRING))\n+    retval = rdot_build_string (yylval.string);\n+  else if (yyaccept (XFALSE))\n+    retval = rdot_build_bool (false);\n+  else if (yyaccept (XTRUE))\n+    retval = rdot_build_bool (true);\n+  else\n+    yyerror (\"expected a primary got [%s]\", yytoken_string (sym));\n+\n+  RDOT_MMEM_COPY (mem, RDOT_MEM_MODIFIER (retval));\n+  delete mem;\n+  return retval;\n+}\n+\n+rdot factor1 (void)\n+{\n+  rdot retval = NULL_DOT;\n+  if (yyaccept (IDENTIFIER))\n+    {\n+      char * pid = yylval.string;\n+      if (yyaccept ('='))\n+        {\n+          rdot rhs = expression ();\n+          retval = rdot_build_decl2 (D_MODIFY_EXPR, rdot_build_identifier (pid), rhs);\n         }\n-        // struct init\n-        else if (yyaccept_('{')) {\n-            yyexpect('{');\n-            rdot sls = struct_init_list();\n-            yyexpect('}');\n-            retval = rdot_build_decl2(D_STRUCT_INIT,\n-                                      rdot_build_identifier(pid),\n-                                      sls);\n+      else if (yyaccept_ ('('))\n+        {\n+          yyexpect ('(');\n+          rdot alist = argument_list ();\n+          yyexpect (')');\n+          retval = rdot_build_decl2 (D_CALL_EXPR,\n+                                     rdot_build_identifier (pid),\n+                                     alist);\n         }\n-        // just a simple identifier...\n-        else\n-            retval = rdot_build_identifier(pid);\n-        free(pid);\n-    } else if (yyaccept(INTEGER))\n-        retval = rdot_build_integer(yylval.integer);\n-    else if (yyaccept(FLOAT))\n-        retval = rdot_build_float(yylval.ffloat);\n-    else if (yyaccept(STRING))\n-        retval = rdot_build_string(yylval.string);\n-    else if (yyaccept(XFALSE))\n-        retval = rdot_build_bool(false);\n-    else if (yyaccept(XTRUE))\n-        retval = rdot_build_bool(true);\n-    else\n-        yyerror(\"expected a primary got [%s]\", yytoken_string(sym));\n-\n-    RDOT_MMEM_COPY(mem, RDOT_MEM_MODIFIER(retval));\n-    delete mem;\n-    return retval;\n-}\n-\n-rdot factor1(void) {\n-    rdot retval = NULL_DOT;\n-    if (yyaccept(IDENTIFIER)) {\n-        char* pid = yylval.string;\n-        if (yyaccept('=')) {\n-            rdot rhs = expression();\n-            retval = rdot_build_decl2(D_MODIFY_EXPR, rdot_build_identifier(pid), rhs);\n-        } else if (yyaccept_('(')) {\n-            yyexpect('(');\n-            rdot alist = argument_list();\n-            yyexpect(')');\n-            retval = rdot_build_decl2(D_CALL_EXPR,\n-                                      rdot_build_identifier(pid),\n-                                      alist);\n+      // struct init\n+      else if (yyaccept_ ('{'))\n+        {\n+          yyexpect ('{');\n+          rdot sls = struct_init_list ();\n+          yyexpect ('}');\n+          retval = rdot_build_decl2 (D_STRUCT_INIT,\n+                                     rdot_build_identifier (pid),\n+                                     sls);\n         }\n-        // struct init\n-        else if (yyaccept_('{')) {\n-            yyexpect('{');\n-            rdot sls = struct_init_list();\n-            yyexpect('}');\n-            retval = rdot_build_decl2(D_STRUCT_INIT,\n-                                      rdot_build_identifier(pid),\n-                                      sls);\n-        } else if (yyaccept_(ACC)) {\n-            yyexpect(ACC);\n-            rdot node = factor1();\n-            retval = rdot_build_decl2(D_ACC_EXPR, rdot_build_identifier(pid), node);\n-        } else {\n-            retval = rdot_build_identifier(yylval.string);\n-            if (yyaccept('.')) {\n-                rdot rhs = factor2();\n-                retval = rdot_build_decl2(D_ATTRIB_REF, retval, rhs);\n+      else if (yyaccept_ (ACC))\n+\t{\n+\t  yyexpect (ACC);\n+\t  rdot node = factor1 ();\n+\t  retval = rdot_build_decl2 (D_ACC_EXPR, rdot_build_identifier (pid), node);\n+\t}\n+      else\n+        {\n+          retval = rdot_build_identifier (yylval.string);\n+          if (yyaccept ('.'))\n+            {\n+              rdot rhs = factor2 ();\n+              retval = rdot_build_decl2 (D_ATTRIB_REF, retval, rhs);\n             }\n         }\n-        free(pid);\n-    } else\n-        retval = factor2();\n-    return retval;\n-}\n-\n-rdot factor2(void) {\n-    rdot retval = NULL_DOT;\n-    if (yyaccept('(')) {\n-        retval = expression();\n-        yyexpect(')');\n-    } else {\n-        retval = primary();\n-        if (RDOT_TYPE(retval) == D_IDENTIFIER || RDOT_TYPE(retval) == D_CALL_EXPR) {\n-            if (yyaccept('.')) {\n-                rdot rhs = factor2();\n-                retval = rdot_build_decl2(D_ATTRIB_REF, retval, rhs);\n+      free (pid);\n+    }\n+  else\n+    retval = factor2 ();\n+  return retval;\n+}\n+\n+rdot factor2 (void)\n+{\n+  rdot retval = NULL_DOT;\n+  if (yyaccept ('('))\n+    {\n+      retval = expression ();\n+      yyexpect (')');\n+    }\n+  else\n+    {\n+      retval = primary ();\n+      if (RDOT_TYPE (retval) == D_IDENTIFIER\n+          || RDOT_TYPE (retval) == D_CALL_EXPR)\n+        {\n+          if (yyaccept ('.'))\n+            {\n+              rdot rhs = factor2 ();\n+              retval = rdot_build_decl2 (D_ATTRIB_REF, retval, rhs);\n             }\n         }\n     }\n-    return retval;\n+  return retval;\n+}\n+\n+opcode_t symToDeclType (int sym)\n+{\n+  opcode_t retval = D_D_EXPR;\n+  switch (sym)\n+    {\n+    case '=':\n+      retval = D_MODIFY_EXPR;\n+      break;\n+      \n+    case '+':\n+      retval = D_ADD_EXPR;\n+      break;\n+\n+    case '-':\n+      retval = D_MINUS_EXPR;\n+      break;\n+\n+    case '*':\n+      retval = D_MULT_EXPR;\n+      break;\n+\n+    case '/':\n+      retval = D_DIVD_EXPR;\n+      break;\n+\n+    case '.':\n+      retval = D_ATTRIB_REF;\n+      break;\n+\n+    case EQUAL_EQUAL:\n+      retval = D_EQ_EQ_EXPR;\n+      break;\n+\n+    case NOT_EQUAL:\n+      retval = D_NOT_EQ_EXPR;\n+      break;\n+\n+    case '<':\n+      retval = D_LESS_EXPR;\n+      break;\n+      \n+    case LESS_EQUAL:\n+      retval = D_LESS_EQ_EXPR;\n+      break;\n+\n+    case '>':\n+      retval = D_GREATER_EXPR;\n+      break;\n+\n+    case GREATER_EQUAL:\n+      retval = D_GREATER_EQ_EXPR;\n+      break;\n+      \n+    default:\n+      yyerror (\"invalid symbol [%i:%s]\",\n+               sym, yytoken_string (sym));\n+      break;\n+    }\n+  return retval;\n+}\n+\n+rdot expression (void)\n+{\n+  bool head = false;\n+  rdot retval = factor1 ();\n+  rdot next = NULL_DOT;\n+  while (sym == '+' || sym == '-' ||\n+         sym == '*' || sym == '/' ||\n+         sym == '<' || sym == '>' ||\n+         sym == EQUAL_EQUAL || sym == NOT_EQUAL ||\n+         sym == LESS_EQUAL || sym == GREATER_EQUAL)\n+    {\n+      opcode_t o = symToDeclType (sym);\n+      yyexpect (sym);\n+      rdot rhs = factor2 ();\n+      if (head == false)\n+        {\n+          retval = next = rdot_build_decl2 (o, retval, rhs);\n+          head = true;\n+        }\n+      else\n+        {\n+          rdot prev = RDOT_rhs_TT (next);\n+          rdot rhs_expr = rdot_build_decl2 (o, prev, rhs);\n+          RDOT_rhs_TT (next) = rhs_expr;\n+          next = rhs_expr;\n+        }\n+    }\n+  return retval;\n }\n \n-opcode_t symToDeclType(int sym) {\n-    opcode_t retval = D_D_EXPR;\n-    switch (sym) {\n-        case '=':\n-            retval = D_MODIFY_EXPR;\n-            break;\n-\n-        case '+':\n-            retval = D_ADD_EXPR;\n-            break;\n-\n-        case '-':\n-            retval = D_MINUS_EXPR;\n-            break;\n-\n-        case '*':\n-            retval = D_MULT_EXPR;\n-            break;\n-\n-        case '/':\n-            retval = D_DIVD_EXPR;\n-            break;\n-\n-        case '.':\n-            retval = D_ATTRIB_REF;\n-            break;\n-\n-        case EQUAL_EQUAL:\n-            retval = D_EQ_EQ_EXPR;\n-            break;\n-\n-        case NOT_EQUAL:\n-            retval = D_NOT_EQ_EXPR;\n-            break;\n-\n-        case '<':\n-            retval = D_LESS_EXPR;\n-            break;\n-\n-        case LESS_EQUAL:\n-            retval = D_LESS_EQ_EXPR;\n-            break;\n-\n-        case '>':\n-            retval = D_GREATER_EXPR;\n-            break;\n-\n-        case GREATER_EQUAL:\n-            retval = D_GREATER_EQ_EXPR;\n-            break;\n-\n-        default:\n-            yyerror(\"invalid symbol [%i:%s]\",\n-                    sym,\n-                    yytoken_string(sym));\n-            break;\n+rdot statement ()\n+{\n+  rdot retval = NULL_DOT;\n+  if (yyaccept_ (BREAK))\n+    {\n+      yyexpect (BREAK);\n+      retval = rdot_build_decl1 (C_BREAK_STMT, NULL_DOT);\n+    }\n+  else if (yyaccept_ (CONTINUE))\n+    {\n+      yyexpect (CONTINUE);\n+      retval = rdot_build_decl1 (C_CONT_STMT, NULL_DOT);\n+    }\n+  else if (yyaccept_ (RETURN))\n+    {\n+      yyexpect (RETURN);\n+      retval = rdot_build_decl1 (C_RETURN_STMT, expression ());\n     }\n-    return retval;\n-}\n-\n-rdot expression(void) {\n-    bool head = false;\n-    rdot retval = factor1();\n-    rdot next = NULL_DOT;\n-    while (sym == '+' || sym == '-' ||\n-           sym == '*' || sym == '/' ||\n-           sym == '<' || sym == '>' ||\n-           sym == EQUAL_EQUAL || sym == NOT_EQUAL ||\n-           sym == LESS_EQUAL || sym == GREATER_EQUAL) {\n-        opcode_t o = symToDeclType(sym);\n-        yyexpect(sym);\n-        rdot rhs = factor2();\n-        if (head == false) {\n-            retval = next = rdot_build_decl2(o, retval, rhs);\n-            head = true;\n-        } else {\n-            rdot prev = RDOT_rhs_TT(next);\n-            rdot rhs_expr = rdot_build_decl2(o, prev, rhs);\n-            RDOT_rhs_TT(next) = rhs_expr;\n-            next = rhs_expr;\n+  else if (yyaccept_ (LET))\n+    {\n+      // simple vardecl [let x;]\n+      rdot tg = target ();\n+      if (yyaccept ('='))\n+        {\n+          retval = rdot_build_decl2 (D_MODIFY_EXPR,\n+                                     tg, expression ());\n         }\n+      else\n+        retval = tg;\n     }\n-    return retval;\n-}\n-\n-rdot statement() {\n-    rdot retval = NULL_DOT;\n-    if (yyaccept_(BREAK)) {\n-        yyexpect(BREAK);\n-        retval = rdot_build_decl1(C_BREAK_STMT, NULL_DOT);\n-    } else if (yyaccept_(CONTINUE)) {\n-        yyexpect(CONTINUE);\n-        retval = rdot_build_decl1(C_CONT_STMT, NULL_DOT);\n-    } else if (yyaccept_(RETURN)) {\n-        yyexpect(RETURN);\n-        retval = rdot_build_decl1(C_RETURN_STMT, expression());\n-    } else if (yyaccept_(LET)) {\n-        // simple vardecl [let x;]\n-        rdot tg = target();\n-        if (yyaccept('=')) {\n-            retval = rdot_build_decl2(D_MODIFY_EXPR,\n-                                      tg,\n-                                      expression());\n-        } else\n-            retval = tg;\n-    } else\n-        retval = expression();\n-    return retval;\n-}\n-\n-rdot struct_while_loop() {\n-    yyexpect(WHILE);\n-    rdot expr = expression();\n-    yyexpect('{');\n-    rdot sb = suite();\n-    yyexpect('}');\n-    return rdot_build_decl2(D_STRUCT_WHILE, expr, sb);\n-}\n-\n-rdot struct_loop() {\n-    yyexpect(LOOP);\n-    yyexpect('{');\n-    rdot sb = suite();\n-    yyexpect('}');\n-    return rdot_build_decl1(D_STRUCT_LOOP, sb);\n-}\n-\n-rdot if_block(void) {\n-    yyexpect(IF);\n-    rdot expr = expression();\n-    yyexpect('{');\n-    rdot sb = suite();\n-    yyexpect('}');\n-    return rdot_build_decl2(D_STRUCT_IF, expr, sb);\n-}\n-\n-rdot elif_block(void) {\n-    yyexpect(ELIF);\n-    rdot expr = expression();\n-    yyexpect('{');\n-    rdot sb = suite();\n-    yyexpect('}');\n-    return rdot_build_decl2(D_STRUCT_IF, expr, sb);\n-}\n-\n-rdot else_block(void) {\n-    yyexpect(ELSE);\n-    yyexpect('{');\n-    rdot block = suite();\n-    yyexpect('}');\n-    return rdot_build_decl1(D_STRUCT_ELSE, block);\n-}\n-\n-rdot struct_conditional() {\n-    rdot iblock = if_block();\n-    rdot eblock = NULL_DOT;\n-    rdot elblock = NULL_DOT;\n-    rdot curr = NULL_DOT;\n-    rdot prev = NULL_DOT;\n-    while (yyaccept_(ELIF)) {\n-        curr = elif_block();\n-        if (elblock == NULL_DOT)\n-            elblock = prev = curr;\n-        else {\n-            RDOT_CHAIN(prev) = curr;\n-            prev = curr;\n+  else\n+      retval = expression ();\n+  return retval;\n+}\n+\n+rdot struct_while_loop ()\n+{\n+  yyexpect (WHILE);\n+  rdot expr = expression ();\n+  yyexpect ('{');\n+  rdot sb = suite ();\n+  yyexpect ('}');\n+  return rdot_build_decl2 (D_STRUCT_WHILE, expr, sb);\n+}\n+\n+rdot struct_loop ()\n+{\n+  yyexpect (LOOP);\n+  yyexpect ('{');\n+  rdot sb = suite ();\n+  yyexpect ('}');\n+  return rdot_build_decl1 (D_STRUCT_LOOP, sb);\n+}\n+\n+rdot if_block (void)\n+{\n+  yyexpect (IF);\n+  rdot expr = expression ();\n+  yyexpect ('{');\n+  rdot sb = suite ();\n+  yyexpect ('}');\n+  return rdot_build_decl2 (D_STRUCT_IF, expr, sb);\n+}\n+\n+rdot elif_block (void)\n+{\n+  yyexpect (ELIF);\n+  rdot expr = expression ();\n+  yyexpect ('{');\n+  rdot sb = suite ();\n+  yyexpect ('}');\n+  return rdot_build_decl2 (D_STRUCT_IF, expr, sb);\n+}\n+\n+rdot else_block (void)\n+{\n+  yyexpect (ELSE);\n+  yyexpect ('{');\n+  rdot block = suite ();\n+  yyexpect ('}');\n+  return rdot_build_decl1 (D_STRUCT_ELSE, block);\n+}\n+\n+rdot struct_conditional ()\n+{\n+  rdot iblock = if_block ();\n+  rdot eblock = NULL_DOT;\n+  rdot elblock = NULL_DOT;\n+  rdot curr = NULL_DOT;\n+  rdot prev = NULL_DOT;\n+  while (yyaccept_ (ELIF))\n+    {\n+      curr = elif_block ();\n+      if (elblock == NULL_DOT)\n+        elblock = prev = curr;\n+      else\n+        {\n+          RDOT_CHAIN (prev) = curr;\n+          prev = curr;\n         }\n     }\n-    if (yyaccept_(ELSE))\n-        eblock = else_block();\n-    rdot retval = rdot_build_decl2(D_STRUCT_IF, iblock, eblock);\n-    RDOT_FIELD(retval) = elblock;\n-    return retval;\n-}\n-\n-void statement_list(rdot head) {\n-    if (yyaccept_('}'))\n-        return;\n-\n-    rdot st = NULL_DOT;\n-    if (yyaccept_(LOOP))\n-        st = struct_loop();\n-    else if (yyaccept_(WHILE))\n-        st = struct_while_loop();\n-    else if (yyaccept_(IF))\n-        st = struct_conditional();\n-    else {\n-        st = statement();\n-        if (!yyaccept(';'))\n-            DOT_RETVAL(st) = true;\n+  if (yyaccept_ (ELSE))\n+    eblock = else_block ();\n+  rdot retval = rdot_build_decl2 (D_STRUCT_IF, iblock, eblock);\n+  RDOT_FIELD (retval)= elblock;\n+  return retval;\n+}\n+\n+void statement_list (rdot head)\n+{\n+  if (yyaccept_ ('}'))\n+    return;\n+\n+  rdot st = NULL_DOT;\n+  if (yyaccept_ (LOOP))\n+    st = struct_loop ();\n+  else if (yyaccept_ (WHILE))\n+    st = struct_while_loop ();\n+  else if (yyaccept_ (IF))\n+    st = struct_conditional (); \n+ else\n+    {\n+      st = statement ();\n+      if (!yyaccept (';'))\n+        DOT_RETVAL (st) = true;\n     }\n-    gcc_assert(st != NULL_DOT);\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, st);\n-    else\n-        RDOT_CHAIN(head) = st;\n-    statement_list(st);\n-}\n-\n-rdot suite() {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    statement_list(NULL);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n-}\n-\n-rdot param(void) {\n-    yyexpect(IDENTIFIER);\n-    char* pid = yylval.string;\n-    yyexpect(':');\n-    rdot pit = type();\n-    rdot retval = rdot_build_decl2(D_PARAMETER,\n-                                   rdot_build_identifier(pid),\n-                                   pit);\n-    free(pid);\n-    return retval;\n-}\n-\n-void param_list_(rdot head) {\n-    if (yyaccept_(')'))\n-        return;\n-\n-    rdot p = param();\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, p);\n-    else\n-        RDOT_CHAIN(head) = p;\n-\n-    if (yyaccept(','))\n-        param_list_(p);\n-}\n-\n-rdot param_list() {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    param_list_(NULL_DOT);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n+  gcc_assert (st != NULL_DOT);\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, st);\n+  else\n+    RDOT_CHAIN (head) = st;\n+  statement_list (st);\n+}\n+\n+rdot suite ()\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  statement_list (NULL);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n+}\n+\n+rdot param (void)\n+{\n+  yyexpect (IDENTIFIER);\n+  char * pid = yylval.string;\n+  yyexpect (':');\n+  rdot pit = type ();\n+  rdot retval = rdot_build_decl2 (D_PARAMETER,\n+                                  rdot_build_identifier (pid),\n+                                  pit);\n+  free (pid);\n+  return retval;\n+}\n+\n+void param_list_ (rdot head)\n+{\n+  if (yyaccept_ (')'))\n+    return;\n+\n+  rdot p = param ();\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, p);\n+  else\n+    RDOT_CHAIN (head) = p;\n+  \n+  if (yyaccept (','))\n+    param_list_ (p);\n+}\n+\n+rdot param_list ()\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  param_list_ (NULL_DOT);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n }\n \n /* fndecl := [pub] fn IDENTIFIER ([param_list]) [-> type] { stmt_list } */\n-rdot fndecl() {\n-    bool pub = false;\n-    if (yyaccept(PUB))\n-        pub = true;\n-    yyexpect(DEFUN);\n-    yyexpect(IDENTIFIER);\n-    char* fid = yylval.string;\n-    yyexpect('(');\n-    rdot plist = param_list();\n-    yyexpect(')');\n-    rdot rtype = NULL_DOT;\n-    if (yyaccept(RTYPE))\n-        rtype = type();\n-    yyexpect('{');\n-    rdot block = suite();\n-    yyexpect('}');\n-    rdot retval = rdot_build_fndecl(rdot_build_identifier(fid),\n-                                    pub,\n-                                    plist,\n-                                    rtype,\n-                                    block);\n-    free(fid);\n-    return retval;\n-}\n-\n-void struct_layout_(rdot head) {\n-    if (yyaccept_('}'))\n-        return;\n-\n-    rdot p = param();\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, p);\n-    else\n-        RDOT_CHAIN(head) = p;\n-\n-    if (yyaccept(','))\n-        struct_layout_(p);\n-}\n-\n-rdot struct_layout() {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    struct_layout_(NULL_DOT);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n-}\n-\n-rdot struct_decl() {\n-    yyexpect(STRUCT);\n-    yyexpect(IDENTIFIER);\n-    char* sid = yylval.string;\n-\n-    yyexpect('{');\n-    rdot layout = struct_layout();\n-    yyexpect('}');\n-    rdot retval = rdot_build_decl2(D_STRUCT_TYPE,\n-                                   rdot_build_identifier(sid),\n-                                   layout);\n-    free(sid);\n-    return retval;\n-}\n-\n-void fndecl_block_(rdot head) {\n-    if (yyaccept_('}'))\n-        return;\n-\n-    rdot f = fndecl();\n-    if (head == NULL_DOT)\n-        vec_safe_push(symStack, f);\n-    else\n-        RDOT_CHAIN(head) = f;\n-\n-    fndecl_block_(f);\n-}\n-\n-rdot fndecl_block(void) {\n-    rdot retval = NULL_DOT;\n-    size_t prev = symStack->length();\n-    fndecl_block_(NULL_DOT);\n-    size_t next = symStack->length();\n-\n-    if (next > prev)\n-        retval = symStack->pop();\n-    return retval;\n-}\n-\n-rdot impl_block() {\n-    rdot retval = NULL_DOT;\n-    yyexpect(IMPL);\n-    yyexpect(IDENTIFIER);\n-    char* iid = yylval.string;\n-    rdot rid = rdot_build_identifier(iid);\n-    free(iid);\n-    if (yyaccept(FOR))\n-        yyexpect(IDENTIFIER);\n-    yyexpect('{');\n-    rdot fb = fndecl_block();\n-    yyexpect('}');\n-    retval = rdot_build_decl2(D_STRUCT_IMPL, rid, fb);\n-    return retval;\n+rdot fndecl ()\n+{\n+  bool pub = false;\n+  if (yyaccept (PUB))\n+    pub = true;\n+  yyexpect (DEFUN);\n+  yyexpect (IDENTIFIER);\n+  char * fid = yylval.string;\n+  yyexpect ('(');\n+  rdot plist = param_list ();\n+  yyexpect (')');\n+  rdot rtype = NULL_DOT;\n+  if (yyaccept (RTYPE))\n+    rtype = type ();\n+  yyexpect ('{');\n+  rdot block = suite ();\n+  yyexpect ('}');\n+  rdot retval =  rdot_build_fndecl (rdot_build_identifier (fid),\n+                                    pub, plist, rtype, block);\n+  free (fid);\n+  return retval;\n+}\n+\n+void struct_layout_ (rdot head)\n+{\n+  if (yyaccept_ ('}'))\n+    return;\n+   \n+  rdot p = param ();\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, p);\n+  else\n+    RDOT_CHAIN (head) = p;\n+  \n+  if (yyaccept (','))\n+    struct_layout_ (p);\n+}\n+\n+rdot struct_layout ()\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  struct_layout_ (NULL_DOT);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n+}\n+\n+rdot struct_decl ()\n+{\n+  yyexpect (STRUCT);\n+  yyexpect (IDENTIFIER);\n+  char * sid = yylval.string;\n+  \n+  yyexpect ('{');\n+  rdot layout = struct_layout ();\n+  yyexpect ('}');\n+  rdot retval = rdot_build_decl2 (D_STRUCT_TYPE,\n+                                  rdot_build_identifier (sid),\n+                                  layout);\n+  free (sid);\n+  return retval;\n+}\n+\n+void fndecl_block_ (rdot head)\n+{\n+  if (yyaccept_ ('}'))\n+    return;\n+  \n+  rdot f = fndecl ();\n+  if (head == NULL_DOT)\n+    vec_safe_push (symStack, f);\n+  else\n+    RDOT_CHAIN (head) = f;\n+\n+  fndecl_block_ (f);\n+}\n+\n+rdot fndecl_block (void)\n+{\n+  rdot retval = NULL_DOT;\n+  size_t prev = symStack->length ();\n+  fndecl_block_ (NULL_DOT);\n+  size_t next = symStack->length ();\n+  \n+  if (next > prev)\n+    retval = symStack->pop ();\n+  return retval;\n+}\n+\n+rdot impl_block ()\n+{\n+  rdot retval = NULL_DOT;\n+  yyexpect (IMPL);\n+  yyexpect (IDENTIFIER);\n+  char * iid = yylval.string;\n+  rdot rid = rdot_build_identifier (iid);\n+  free (iid);\n+  if (yyaccept (FOR))\n+    yyexpect (IDENTIFIER);\n+  yyexpect ('{');\n+  rdot fb = fndecl_block ();\n+  yyexpect ('}');\n+  retval = rdot_build_decl2 (D_STRUCT_IMPL, rid, fb);\n+  return retval;\n }\n \n /*\n   decl := fndecl | structdecl | impldecl | enumdecl\n */\n-void decl(void) {\n-    rdot rdecl = NULL_DOT;\n-    if (yyaccept_(STRUCT))\n-        rdecl = struct_decl();\n-    else if (yyaccept_(IMPL))\n-        rdecl = impl_block();\n-    else\n-        rdecl = fndecl();\n-    if (rdecl != NULL_DOT)\n-        dot_pass_pushDecl(rdecl);\n-}\n-\n-int yyparse(void) {\n-    // kick things off with the first token\n-    __yyerror = 0;\n-    sym = yylex_();\n-\n-    vec_alloc(symStack, 0);\n-    vec_safe_push(symStack, NULL_DOT);\n-\n-    while (sym != 0)\n-        decl();\n-\n-    if (symStack->length() > 1)\n-        yyerror(\"some unpoped symbols on the parse stack!\");\n-\n-    vec_free(symStack);\n-    return __yyerror;\n+void decl (void)\n+{\n+  rdot rdecl = NULL_DOT;\n+  if (yyaccept_ (STRUCT))\n+    rdecl = struct_decl ();\n+  else if (yyaccept_ (IMPL))\n+    rdecl = impl_block ();\n+  else\n+    rdecl = fndecl ();\n+  if (rdecl != NULL_DOT)\n+    dot_pass_pushDecl (rdecl);\n+}\n+\n+int yyparse (void)\n+{\n+  // kick things off with the first token\n+  __yyerror = 0;\n+  sym = yylex_ ();\n+  \n+  vec_alloc (symStack, 0);\n+  vec_safe_push (symStack, NULL_DOT);\n+  \n+  while (sym != 0)\n+    decl ();\n+  \n+  if (symStack->length() > 1)\n+    yyerror (\"some unpoped symbols on the parse stack!\");\n+    \n+  vec_free (symStack);\n+  return __yyerror;\n }"}, {"sha": "9ffac6e5b6bcb2052de3f1a6ea90beb94072abb7", "filename": "gcc/rust/old/rs-pass-manager.cc", "status": "modified", "additions": 79, "deletions": 75, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-pass-manager.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -18,97 +18,101 @@\n \n tree cstring_type_node;\n static bool empty = true;\n-#define MAYBE_BOMB_OUT    \\\n-    do                    \\\n-        if (seen_error()) \\\n-            return;       \\\n-    while (0);\n-\n-static vec<rdot, va_gc>* rust_decls;\n-typedef vec<rdot, va_gc>* (*dot_pass)(vec<rdot, va_gc>*);\n-static dot_pass dot_pass_mngr[] = {\n-    &dot_pass_PrettyPrint, // pretty print if -fdump-dot pre and post infereance */\n-    &dot_pass_inferTypes,  // This ensures there are no longer any D_MAYBE_TYPES */\n+#define MAYBE_BOMB_OUT                          \\\n+  do                                            \\\n+    if (seen_error ()) return;                  \\\n+  while (0);\n+\n+static vec<rdot,va_gc> * rust_decls;\n+typedef vec<rdot,va_gc> * (*dot_pass)(vec<rdot,va_gc> *);\n+static dot_pass dot_pass_mngr[] =\n+  {\n+    &dot_pass_PrettyPrint,  /* pretty print if -fdump-dot pre and post infereance */\n+    &dot_pass_inferTypes,   /* This ensures there are no longer any D_MAYBE_TYPES */\n     &dot_pass_PrettyPrint,\n-    NULL // sentinal */\n-};\n-\n-// Pushes each decl from the parser onto the current translation unit\n-void dot_pass_pushDecl(rdot decl) {\n-    if (empty)\n-        empty = false;\n-\n-    if (RDOT_TYPE(decl) == D_STRUCT_TYPE) {\n-        // look for duplicate fields\n-        std::map<std::string, bool> layout;\n-        rdot next;\n-        for (next = RDOT_rhs_TT(decl); next != NULL_DOT;\n-             next = RDOT_CHAIN(next)) {\n-            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n-            if (layout.count(pid) > 0)\n-                error(\"structure [%s] already contains element [%s]\",\n-                      RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(decl)),\n-                      pid);\n-            else\n-                layout[pid] = true;\n+    NULL                         /* sentinal */\n+  };\n+\n+/* Pushes each decl from the parser onto the current translation unit */\n+void dot_pass_pushDecl (rdot decl)\n+{\n+  if (empty)\n+    empty = false;\n+\n+  if (RDOT_TYPE (decl) == D_STRUCT_TYPE)\n+    {\n+      // look for duplicate fields\n+      std::map<std::string, bool> layout;\n+      rdot next;\n+      for (next = RDOT_rhs_TT (decl); next != NULL_DOT;\n+           next = RDOT_CHAIN (next))\n+        {\n+          const char * pid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n+          if (layout.count (pid) > 0)\n+              error (\"structure [%s] already contains element [%s]\",\n+                     RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (decl)), pid);\n+          else\n+            layout [pid] = true;\n         }\n     }\n-    vec_safe_push(rust_decls, decl);\n+  vec_safe_push (rust_decls, decl);\n }\n \n /* Function to run over the pass manager hooks and\n    generate the generic code to pass to gcc middle-end\n */\n-void dot_pass_WriteGlobals(void) {\n-    // if the rdot translation unit is empty there is nothing to compile..\n-    if (empty == true)\n-        return;\n-\n-    tree cptr = build_pointer_type(char_type_node);\n-    cstring_type_node = build_qualified_type(cptr, TYPE_QUAL_CONST);\n-\n-    dot_pass* p = NULL;\n-    vec<rdot, va_gc>* dot_decls = rust_decls;\n-\n-    /* walk the passes */\n-    for (p = dot_pass_mngr; *p != NULL; ++p) {\n-        MAYBE_BOMB_OUT;\n-        dot_decls = (*p)(dot_decls);\n+void dot_pass_WriteGlobals (void)\n+{\n+  // if the rdot translation unit is empty there is nothing to compile..\n+  if (empty == true)\n+    return;\n+\n+  tree cptr = build_pointer_type (char_type_node);\n+  cstring_type_node = build_qualified_type (cptr, TYPE_QUAL_CONST);\n+\n+  dot_pass *p = NULL;\n+  vec<rdot,va_gc> * dot_decls = rust_decls;\n+\n+  /* walk the passes */\n+  for (p = dot_pass_mngr; *p != NULL; ++p)\n+    {\n+      MAYBE_BOMB_OUT;\n+      dot_decls = (*p)(dot_decls);\n     }\n+    \n+  /* check errors */\n+  MAYBE_BOMB_OUT;\n \n-    /* check errors */\n-    MAYBE_BOMB_OUT;\n-\n-    /* lower the decls from DOT -> GENERIC */\n-    vec<tree, va_gc>* globals = dot_pass_Genericify(dot_decls);\n+  /* lower the decls from DOT -> GENERIC */\n+  vec<tree,va_gc> * globals = dot_pass_Genericify (dot_decls);\n \n-    int global_vec_len = vec_safe_length(globals);\n-    tree* global_vec = new tree[global_vec_len];\n-    tree itx = NULL_TREE;\n-    int idx, idy = 0;\n-    /*\n+  int global_vec_len = vec_safe_length (globals);\n+  tree * global_vec = new tree[global_vec_len];\n+  tree itx = NULL_TREE;\n+  int idx, idy = 0;\n+  /*\n     Lets make sure to dump the Translation Unit this isn't that\n     useful to read over but can help to make sure certain tree's\n     are being generated...\n       \n     We also fill up the vector of tree's to be passed to the middle-end\n   */\n-    FILE* tu_stream = dump_begin(TDI_tu, NULL);\n-    for (idx = 0; vec_safe_iterate(globals, idx, &itx); ++idx) {\n-        if (tu_stream)\n-            dump_node(itx, 0, tu_stream);\n-        global_vec[idy] = itx;\n-        idy++;\n+  FILE * tu_stream = dump_begin (TDI_tu, NULL);\n+  for (idx = 0; vec_safe_iterate (globals, idx, &itx); ++idx)\n+    {\n+      if (tu_stream)\n+        dump_node (itx, 0, tu_stream);\n+      global_vec [idy] = itx;\n+      idy++;\n     }\n-    \n-    if (tu_stream)\n-        dump_end(TDI_tu, tu_stream);\n-\n-    /* Passing control to GCC middle-end */\n-    wrapup_global_declarations(global_vec, global_vec_len);\n-    finalize_compilation_unit();\n-    check_global_declarations(global_vec, global_vec_len);\n-    emit_debug_global_declarations(global_vec, global_vec_len);\n-\n-    delete[] global_vec;\n+  if (tu_stream)\n+    dump_end(TDI_tu, tu_stream);\n+  \n+  /* Passing control to GCC middle-end */\n+  wrapup_global_declarations (global_vec, global_vec_len);\n+  finalize_compilation_unit ();\n+  check_global_declarations (global_vec, global_vec_len);\n+  emit_debug_global_declarations (global_vec, global_vec_len);\n+\n+  delete [] global_vec;\n }"}, {"sha": "7e7c868bab3843dff3fd0430063fb79ce168950b", "filename": "gcc/rust/old/rs-runtime-hooks.cc", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -16,46 +16,42 @@\n \n #include \"rust.h\"\n \n-#define nitems(_a) (sizeof(_a)) / sizeof((_a)[0])\n-#define LANG_HOOK(name_) \"__GRUST_\" name_, name_\n+#define nitems(_a) (sizeof (_a)) / sizeof ((_a)[0])\n+#define LANG_HOOK(name_) \"__GRUST_\"name_, name_\n \n-// Seems to be a way of storing info about a runtime hook function\n struct rust_runtime {\n-    const char* mangled_name;\n-    const char* rust_symbol;\n+    const char * mangled_name;\n+    const char * rust_symbol;\n     const size_t nargs;\n-    const tree** paramater_types;\n+    const tree ** paramater_types;\n };\n \n-// Maybe an array of hooks? Doesn't have anything useful in it right now.\n-static struct rust_runtime hooks[] = {\n-    /* sentinel (meaning \"dummy data\", basically) */\n+static struct rust_runtime hooks [] =  {\n+    /* sentinal */\n     { NULL, NULL, 0, NULL }\n };\n \n-/* Seems to build functions, results, and their return types into some tree, which is put into dict\n- *\n- * Presumably actually does something if hooks is changed to something other than default values. */ \n-void rs_fill_runtime_decls(std::map<std::string, tree>* dict) {\n-    struct rust_runtime* hk;\n-    \n-    for (hk = hooks; hk->mangled_name != NULL; ++hk) {\n-        tree* args = XALLOCAVEC(tree, hk->nargs);\n-        size_t i;\n-        \n-        for (i = 0; i < hk->nargs; ++i)\n-            args[i] = *(hk->paramater_types[i]);\n-\n-        tree fntype = build_function_type_array(void_type_node, hk->nargs, args);\n-        tree fndecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, get_identifier(hk->mangled_name), \n-            fntype);\n-        tree restype = TREE_TYPE(fndecl);\n-        tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, restype);\n-        DECL_CONTEXT(resdecl) = fndecl;\n-        DECL_RESULT(fndecl) = resdecl;\n-        DECL_EXTERNAL(fndecl) = 1;\n-        TREE_PUBLIC(fndecl) = 1;\n-\n-        (*dict)[std::string(hk->rust_symbol)] = fndecl;\n+void rs_fill_runtime_decls (std::map<std::string, tree> * dict)\n+{\n+    struct rust_runtime * hk;\n+    for (hk = hooks; hk->mangled_name != NULL; ++hk)\n+    {\n+\ttree * args = XALLOCAVEC (tree, hk->nargs);\n+\tsize_t i;\n+\tfor (i = 0; i < hk->nargs; ++i)\n+\t    args[i] = *(hk->paramater_types [i]);\n+\n+\ttree fntype = build_function_type_array (void_type_node, hk->nargs, args);\n+\ttree fndecl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t\t\t  get_identifier (hk->mangled_name), fntype);\n+\ttree restype = TREE_TYPE (fndecl);\n+\ttree resdecl = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n+\t\t\t\t   NULL_TREE, restype);\n+\tDECL_CONTEXT (resdecl) = fndecl;\n+\tDECL_RESULT (fndecl) = resdecl;\n+\tDECL_EXTERNAL (fndecl) = 1;\n+\tTREE_PUBLIC (fndecl) = 1;\n+\n+\t(*dict)[std::string (hk->rust_symbol)] = fndecl;\n     }\n }"}, {"sha": "c5dde9bc71a04a09ae107f4fa8b3730c804876e8", "filename": "gcc/rust/old/rsspec.cc", "status": "modified", "additions": 288, "deletions": 238, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frsspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,4 +1,3 @@\n-// rsspec.cc - File used for compiler driver creation or something related to that.\n /* This file is part of GCC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -16,336 +15,387 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#include \"system.h\"\n #include \"coretypes.h\"\n #include \"gcc.h\"\n #include \"opts.h\"\n-#include \"system.h\"\n \n-#include \"intl.h\"\n #include \"tm.h\"\n+#include \"intl.h\"\n \n #ifndef MATH_LIBRARY\n-#define MATH_LIBRARY \"m\"\n+# define MATH_LIBRARY \"m\"\n #endif\n \n #ifndef RUST_LIBRARY\n-#define RUST_LIBRARY \"grust\"\n+# define RUST_LIBRARY \"grust\"\n #endif\n \n /* The original argument list and related info is copied here.  */\n static unsigned int grs_xargc;\n-static const struct cl_decoded_option* grs_x_decoded_options;\n-static void append_arg(const struct cl_decoded_option*);\n+static const struct cl_decoded_option *grs_x_decoded_options;\n+static void append_arg (const struct cl_decoded_option *);\n \n /* The new argument list will be built here.  */\n static unsigned int grs_newargc;\n-static struct cl_decoded_option* grs_new_decoded_options;\n+static struct cl_decoded_option *grs_new_decoded_options;\n \n /* Return whether strings S1 and S2 are both NULL or both the same\n- * string.  \n- * */\n-static bool strings_same(const char* s1, const char* s2) {\n-    return s1 == s2 || (s1 != NULL && s2 != NULL && strcmp(s1, s2) == 0);\n+   string.  */\n+\n+static bool\n+strings_same (const char *s1, const char *s2)\n+{\n+  return s1 == s2 || (s1 != NULL && s2 != NULL && strcmp (s1, s2) == 0);\n }\n \n /* Return whether decoded option structures OPT1 and OPT2 are the\n- * same.  \n- * */\n-static bool options_same(const struct cl_decoded_option* opt1, const struct cl_decoded_option* opt2) {\n-    return (opt1->opt_index == opt2->opt_index && strings_same(opt1->arg, opt2->arg) && strings_same(opt1->orig_option_with_args_text, opt2->orig_option_with_args_text) && strings_same(opt1->canonical_option[0], opt2->canonical_option[0]) && strings_same(opt1->canonical_option[1], opt2->canonical_option[1]) && strings_same(opt1->canonical_option[2], opt2->canonical_option[2]) && strings_same(opt1->canonical_option[3], opt2->canonical_option[3]) && (opt1->canonical_option_num_elements == opt2->canonical_option_num_elements) && opt1->value == opt2->value && opt1->errors == opt2->errors);\n+   same.  */\n+\n+static bool\n+options_same (const struct cl_decoded_option *opt1,\n+\t      const struct cl_decoded_option *opt2)\n+{\n+  return (opt1->opt_index == opt2->opt_index\n+\t  && strings_same (opt1->arg, opt2->arg)\n+\t  && strings_same (opt1->orig_option_with_args_text,\n+\t\t\t   opt2->orig_option_with_args_text)\n+\t  && strings_same (opt1->canonical_option[0],\n+\t\t\t   opt2->canonical_option[0])\n+\t  && strings_same (opt1->canonical_option[1],\n+\t\t\t   opt2->canonical_option[1])\n+\t  && strings_same (opt1->canonical_option[2],\n+\t\t\t   opt2->canonical_option[2])\n+\t  && strings_same (opt1->canonical_option[3],\n+\t\t\t   opt2->canonical_option[3])\n+\t  && (opt1->canonical_option_num_elements\n+\t      == opt2->canonical_option_num_elements)\n+\t  && opt1->value == opt2->value\n+\t  && opt1->errors == opt2->errors);\n }\n \n /* Append another argument to the list being built.  As long as it is\n- * identical to the corresponding arg in the original list, just increment\n- * the new arg count.  Otherwise allocate a new list, etc.  \n- * */\n-static void append_arg(const struct cl_decoded_option* arg) {\n-    static unsigned int newargsize;\n+   identical to the corresponding arg in the original list, just increment\n+   the new arg count.  Otherwise allocate a new list, etc.  */\n+\n+static void\n+append_arg (const struct cl_decoded_option *arg)\n+{\n+  static unsigned int newargsize;\n \n #if 0\n-  \tfprintf (stderr, \"`%s'\\n\", arg);\n+  fprintf (stderr, \"`%s'\\n\", arg);\n #endif\n \n-    if (grs_new_decoded_options == grs_x_decoded_options && grs_newargc < grs_xargc && options_same(arg, &grs_x_decoded_options[grs_newargc])) {\n-        ++grs_newargc;\n-        return; /* Nothing new here.  */\n+  if (grs_new_decoded_options == grs_x_decoded_options\n+      && grs_newargc < grs_xargc\n+      && options_same (arg, &grs_x_decoded_options[grs_newargc]))\n+    {\n+      ++grs_newargc;\n+      return;\t\t\t/* Nothing new here.  */\n     }\n \n-    if (grs_new_decoded_options == grs_x_decoded_options) { /* Make new arglist.  */\n-        unsigned int i;\n+  if (grs_new_decoded_options == grs_x_decoded_options)\n+    {\t\t\t\t/* Make new arglist.  */\n+      unsigned int i;\n \n-        newargsize = (grs_xargc << 2) + 20; /* This should handle all.  */\n-        grs_new_decoded_options = XNEWVEC(struct cl_decoded_option, newargsize);\n+      newargsize = (grs_xargc << 2) + 20;\t/* This should handle all.  */\n+      grs_new_decoded_options = XNEWVEC (struct cl_decoded_option, newargsize);\n \n-        /* Copy what has been done so far.  */\n-        for (i = 0; i < grs_newargc; ++i)\n-            grs_new_decoded_options[i] = grs_x_decoded_options[i];\n+      /* Copy what has been done so far.  */\n+      for (i = 0; i < grs_newargc; ++i)\n+\tgrs_new_decoded_options[i] = grs_x_decoded_options[i];\n     }\n \n-    if (grs_newargc == newargsize)\n-        fatal_error(\"overflowed output arg list for %qs\",\n-                    arg->orig_option_with_args_text);\n+  if (grs_newargc == newargsize)\n+    fatal_error (\"overflowed output arg list for %qs\",\n+\t\t arg->orig_option_with_args_text);\n \n-    grs_new_decoded_options[grs_newargc++] = *arg;\n+  grs_new_decoded_options[grs_newargc++] = *arg;\n }\n \n /* Append an option described by OPT_INDEX, ARG and VALUE to the list\n- * being built.  \n- * */\n-static void append_option(size_t opt_index, const char* arg, int value) {\n-    struct cl_decoded_option decoded;\n-\n-    generate_option(opt_index, arg, value, CL_DRIVER, &decoded);\n-    append_arg(&decoded);\n+   being built.  */\n+static void\n+append_option (size_t opt_index, const char *arg, int value)\n+{\n+  struct cl_decoded_option decoded;\n+\n+  generate_option (opt_index, arg, value, CL_DRIVER, &decoded);\n+  append_arg (&decoded);\n }\n \n /* Append a librust argument to the list being built.  If\n- * FORCE_STATIC, ensure the library is linked statically.  \n- * */\n-static void add_arg_libgrust(bool force_static ATTRIBUTE_UNUSED) {\n+   FORCE_STATIC, ensure the library is linked statically.  */\n+\n+static void\n+add_arg_libgrust (bool force_static ATTRIBUTE_UNUSED)\n+{\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-    if (force_static)\n-        append_option(OPT_Wl_, \"-Bstatic\", 1);\n+  if (force_static)\n+    append_option (OPT_Wl_, \"-Bstatic\", 1);\n #endif\n-    append_option(OPT_l, RUST_LIBRARY, 1);\n+  append_option (OPT_l, RUST_LIBRARY, 1);\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-    if (force_static)\n-        append_option(OPT_Wl_, \"-Bdynamic\", 1);\n+  if (force_static)\n+    append_option (OPT_Wl_, \"-Bdynamic\", 1);\n #endif\n }\n \n-/* Modeled closely of gcc/fortran/gfortranspec.c \n- * Called before processing to change/add/remove arguments. \n- * */\n-void lang_specific_driver(struct cl_decoded_option** in_decoded_options,\n-                          unsigned int* in_decoded_options_count,\n-                          int* in_added_libraries ATTRIBUTE_UNUSED) {\n-    unsigned int i = 0;\n-    unsigned int argc = *in_decoded_options_count;\n-    // Argument list\n-    struct cl_decoded_option* decoded_options = *in_decoded_options;\n+/* Modeled closely of gcc/fortran/gfortranspec.c */\n+\n+void lang_specific_driver( struct cl_decoded_option **in_decoded_options,\n+\t\t\t   unsigned int *in_decoded_options_count,\n+\t\t\t   int *in_added_libraries ATTRIBUTE_UNUSED )\n+{\n+  unsigned int i = 0;\n+  unsigned int argc = *in_decoded_options_count;\n+  struct cl_decoded_option *decoded_options = *in_decoded_options;\n \n-    int verbose = 0;\n+  int verbose = 0;\n \n-    /* This will be NULL if we encounter a situation where we should not\n-     * link in libf2c.  \n-\t * */\n-    const char* library = RUST_LIBRARY;\n+  /* This will be NULL if we encounter a situation where we should not\n+     link in libf2c.  */\n+  const char *library = RUST_LIBRARY;\n \n-    /* 0 => -xnone in effect.\n-     * 1 => -xfoo in effect.  \n-\t * */\n-    int saw_speclang = 0;\n+  /* 0 => -xnone in effect.\n+     1 => -xfoo in effect.  */\n+  int saw_speclang = 0;\n \n-    /* 0 => initial/reset state\n-     * 1 => last arg was -l<library>\n-     * 2 => last two args were -l<library> -lm.  \n-\t * */\n-    int saw_library = 0;\n+  /* 0 => initial/reset state\n+     1 => last arg was -l<library>\n+     2 => last two args were -l<library> -lm.  */\n+  int saw_library = 0;\n \n-    /* By default, we throw on the math library if we have one.  */\n-    int need_math = (MATH_LIBRARY[0] != '\\0');\n+  /* By default, we throw on the math library if we have one.  */\n+  int need_math = (MATH_LIBRARY[0] != '\\0');\n \n-    /* Whether we should link a static libgrsthon. */\n-    int static_lib = 0;\n+  /* Whether we should link a static libgrsthon. */\n+  int static_lib = 0; \n \n-    /* Whether we need to link statically.  */\n-    int static_linking = 0;\n+  /* Whether we need to link statically.  */\n+  int static_linking = 0;\n \n-    /* The number of input and output files in the incoming arg list.  */\n-    int n_infiles = 0;\n-    int n_outfiles = 0;\n+  /* The number of input and output files in the incoming arg list.  */\n+  int n_infiles = 0;\n+  int n_outfiles = 0;\n \n #if 0\n-  \tfprintf (stderr, \"Incoming:\");\n-  \tfor( i=0; i<argc; ++i )\n-    \tfprintf (stderr, \" %s\", decoded_options[i].orig_option_with_args_text);\n-  \tfprintf (stderr, \"\\n\");\n+  fprintf (stderr, \"Incoming:\");\n+  for( i=0; i<argc; ++i )\n+    fprintf (stderr, \" %s\", decoded_options[i].orig_option_with_args_text);\n+  fprintf (stderr, \"\\n\");\n #endif\n \n-    grs_xargc = argc;\n-    grs_x_decoded_options = decoded_options;\n-    grs_newargc = 0;\n-    grs_new_decoded_options = decoded_options;\n-\n-    for (i = 1; i < argc; ++i) {\n-        switch (decoded_options[i].opt_index) {\n-            case OPT_SPECIAL_input_file:\n-                ++n_infiles;\n-                continue;\n-\n-            case OPT_nostdlib:\n-            case OPT_nodefaultlibs:\n-            case OPT_c:\n-            case OPT_S:\n-            case OPT_fsyntax_only:\n-            case OPT_E:\n-                /* These options disable linking entirely or linking of the\n-\t     \t\t * standard libraries.  \n-\t\t\t\t * */\n-                library = 0;\n-                break;\n-\n-                /*\n-\t\t\tcase OPT_static_librust:\n+  grs_xargc = argc;\n+  grs_x_decoded_options = decoded_options;\n+  grs_newargc = 0;\n+  grs_new_decoded_options = decoded_options;\n+\n+  for( i=1; i<argc; ++i )\n+    {\n+      switch( decoded_options[i].opt_index )\n+\t{\n+\tcase OPT_SPECIAL_input_file:\n+\t  ++n_infiles;\n+\t  continue;\n+\n+\tcase OPT_nostdlib:\n+\tcase OPT_nodefaultlibs:\n+\tcase OPT_c:\n+\tcase OPT_S:\n+\tcase OPT_fsyntax_only:\n+\tcase OPT_E:\n+\t  /* These options disable linking entirely or linking of the\n+\t     standard libraries.  */\n+\t  library = 0;\n+\t  break;\n+\n+/*\n+\tcase OPT_static_librust:\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-\t    \t\tstatic_lib = 1;\n+\t    static_lib = 1;\n #endif\n-\t  \t\t\tbreak;\n+\t  break;\n */\n \n-            case OPT_static:\n+\tcase OPT_static:\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-                static_linking = 1;\n+\t  static_linking = 1;\n #endif\n-                break;\n+\t  break;\n \n-            case OPT_l:\n-                ++n_infiles;\n-                break;\n+\tcase OPT_l:\n+\t  ++n_infiles;\n+\t  break;\n \n-            case OPT_o:\n-                ++n_outfiles;\n-                break;\n+\tcase OPT_o:\n+\t  ++n_outfiles;\n+\t  break;\n \n-            case OPT_v:\n-                verbose = 1;\n-                break;\n+\tcase OPT_v:\n+\t  verbose = 1;\n+\t  break;\n \n-            case OPT_version:\n-                printf(\"GNU Rust %s%s\\n\", pkgversion_string, version_string);\n-                printf(\"Copyright %s 2013 Free Software Foundation, Inc.\\n\\n\",\n-                       _(\"(C)\"));\n-                printf(_(\"GNU Rust comes with NO WARRANTY, to the extent permitted by law.\\n\\\n+\tcase OPT_version:\n+\t  printf (\"GNU Rust %s%s\\n\", pkgversion_string, version_string);\n+\t  printf (\"Copyright %s 2013 Free Software Foundation, Inc.\\n\\n\",\n+\t\t  _(\"(C)\"));\n+\t  printf (_(\"GNU Rust comes with NO WARRANTY, to the extent permitted by law.\\n\\\n You may redistribute copies of GNU Rust\\n\\\n under the terms of the GNU General Public License.\\n\\\n For more information about these matters, see the file named COPYING\\n\\n\"));\n-                exit(0);\n-                break;\n-\n-            case OPT__help:\n-                /* Let gcc.c handle this, as it has a really\n-\t     \t\t * cool facility for handling --help and --verbose --help.  \n-\t\t\t\t * */\n-                return;\n-\n-            default:\n-                break;\n-        }\n+\t  exit (0);\n+\t  break;\n+\n+\tcase OPT__help:\n+\t  /* Let gcc.c handle this, as it has a really\n+\t     cool facility for handling --help and --verbose --help.  */\n+\t  return;\n+\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n-    if ((n_outfiles != 0) && (n_infiles == 0))\n-        fatal_error(\"no input files; unwilling to write output files\");\n+  if( (n_outfiles != 0) && (n_infiles == 0) )\n+    fatal_error (\"no input files; unwilling to write output files\");\n \n     /* If there are no input files, no need for the library.  */\n-    if (n_infiles == 0)\n-        library = 0;\n-\n-    /* Second pass through arglist, transforming arguments as appropriate.  */\n-    append_arg(&decoded_options[0]); /* Start with command name, of course.  */\n-\n-    for (i = 1; i < argc; ++i) {\n-        if (decoded_options[i].errors & CL_ERR_MISSING_ARG) {\n-            append_arg(&decoded_options[i]);\n-            continue;\n-        }\n-\n-        if (decoded_options[i].opt_index == OPT_SPECIAL_input_file && decoded_options[i].arg[0] == '\\0') {\n-            /* Interesting.  Just append as is.  */\n-            append_arg(&decoded_options[i]);\n-            continue;\n-        }\n-\n-        if (decoded_options[i].opt_index != OPT_l && (decoded_options[i].opt_index != OPT_SPECIAL_input_file || strcmp(decoded_options[i].arg, \"-\") == 0)) {\n-            /* Not a filename or library.  */\n-\n-            if (saw_library == 1 && need_math) /* -l<library>.  */\n-                append_option(OPT_l, MATH_LIBRARY, 1);\n-\n-            saw_library = 0;\n-\n-            if (decoded_options[i].opt_index == OPT_SPECIAL_input_file) {\n-                append_arg(&decoded_options[i]); /* \"-\" == Standard input.  */\n-                continue;\n-            }\n-\n-            if (decoded_options[i].opt_index == OPT_x) {\n-                /* Track input language.  */\n-                const char* lang = decoded_options[i].arg;\n-                saw_speclang = (strcmp(lang, \"none\") != 0);\n-            }\n-            append_arg(&decoded_options[i]);\n-            continue;\n-        }\n-\n-        /* A filename/library, not an option.  */\n-        if (saw_speclang)\n-            saw_library = 0; /* -xfoo currently active.  */\n-        else {               /* -lfoo or filename.  */\n-            if (decoded_options[i].opt_index == OPT_l && strcmp(decoded_options[i].arg, MATH_LIBRARY) == 0) {\n-                if (saw_library == 1)\n-                    saw_library = 2; /* -l<library> -lm.  */\n-                else\n-                    add_arg_libgrust(static_lib && !static_linking);\n-            } else if (decoded_options[i].opt_index == OPT_l && strcmp(decoded_options[i].arg, RUST_LIBRARY) == 0) {\n-                saw_library = 1; /* -l<library>.  */\n-                add_arg_libgrust(static_lib && !static_linking);\n-                continue;\n-            } else { /* Other library, or filename.  */\n-                if (saw_library == 1 && need_math)\n-                    append_option(OPT_l, MATH_LIBRARY, 1);\n-                saw_library = 0;\n-            }\n-        }\n-        append_arg(&decoded_options[i]);\n+  if (n_infiles == 0)\n+    library = 0;\n+\n+ /* Second pass through arglist, transforming arguments as appropriate.  */\n+  append_arg (&decoded_options[0]); /* Start with command name, of course.  */\n+\n+  for (i = 1; i < argc; ++i)\n+    {\n+      if (decoded_options[i].errors & CL_ERR_MISSING_ARG)\n+\t{\n+\t  append_arg (&decoded_options[i]);\n+\t  continue;\n+\t}\n+\n+      if (decoded_options[i].opt_index == OPT_SPECIAL_input_file\n+\t  && decoded_options[i].arg[0] == '\\0')\n+\t{\n+\t  /* Interesting.  Just append as is.  */\n+\t  append_arg (&decoded_options[i]);\n+\t  continue;\n+\t}\n+\n+      if (decoded_options[i].opt_index != OPT_l\n+\t  && (decoded_options[i].opt_index != OPT_SPECIAL_input_file\n+\t      || strcmp (decoded_options[i].arg, \"-\") == 0))\n+\t{\n+\t  /* Not a filename or library.  */\n+\n+\t  if (saw_library == 1 && need_math)\t/* -l<library>.  */\n+\t    append_option (OPT_l, MATH_LIBRARY, 1);\n+\n+\t  saw_library = 0;\n+\n+\t  if (decoded_options[i].opt_index == OPT_SPECIAL_input_file)\n+\t    {\n+\t      append_arg (&decoded_options[i]);\t/* \"-\" == Standard input.  */\n+\t      continue;\n+\t    }\n+\n+\t  if (decoded_options[i].opt_index == OPT_x)\n+\t    {\n+\t      /* Track input language.  */\n+\t      const char *lang = decoded_options[i].arg;\n+\t      saw_speclang = (strcmp (lang, \"none\") != 0);\n+\t    }\n+\t  append_arg (&decoded_options[i]);\n+\t  continue;\n+\t}\n+\n+      /* A filename/library, not an option.  */\n+\n+      if (saw_speclang)\n+\tsaw_library = 0;\t/* -xfoo currently active.  */\n+      else\n+\t{\t\t\t/* -lfoo or filename.  */\n+\t  if (decoded_options[i].opt_index == OPT_l\n+\t      && strcmp (decoded_options[i].arg, MATH_LIBRARY) == 0)\n+\t  {\n+\t      if (saw_library == 1)\n+\t\t  saw_library = 2;\t/* -l<library> -lm.  */\n+\t      else\n+\t\t  add_arg_libgrust (static_lib && !static_linking);\n+\t  }\n+\t  else if (decoded_options[i].opt_index == OPT_l\n+\t\t   && strcmp (decoded_options[i].arg, RUST_LIBRARY) == 0)\n+\t  {\n+\t      saw_library = 1;\t/* -l<library>.  */\n+\t      add_arg_libgrust (static_lib && !static_linking);\n+\t      continue;\n+\t  }\n+\t  else\n+\t    {\t\t\t/* Other library, or filename.  */\n+\t      if (saw_library == 1 && need_math)\n+\t\tappend_option (OPT_l, MATH_LIBRARY, 1);\n+\t      saw_library = 0;\n+\t    }\n+\t}\n+      append_arg (&decoded_options[i]);\n     }\n \n-    /* Append `-lrust -lm' as necessary.  */\n-    if (library) { /* Doing a link and no -nostdlib.  */\n-        if (saw_speclang)\n-            append_option(OPT_x, \"none\", 1);\n-\n-        switch (saw_library) {\n-            case 0:\n-                add_arg_libgrust(static_lib && !static_linking);\n-                /* Fall through.  */\n-            case 1:\n-                if (need_math)\n-                    append_option(OPT_l, MATH_LIBRARY, 1);\n-            default:\n-                break;\n-        }\n+  /* Append `-lrust -lm' as necessary.  */\n+\n+  if (library)\n+    {\t\t\t\t/* Doing a link and no -nostdlib.  */\n+      if (saw_speclang)\n+\tappend_option (OPT_x, \"none\", 1);\n+\n+      switch (saw_library)\n+\t{\n+\tcase 0:\n+\t  add_arg_libgrust (static_lib && !static_linking);\n+\t  /* Fall through.  */\n+\tcase 1:\n+\t  if (need_math)\n+\t    append_option (OPT_l, MATH_LIBRARY, 1);\n+\tdefault:\n+\t  break;\n+\t}\n     }\n \n #ifdef ENABLE_SHARED_LIBGCC\n-    if (library) {\n-        unsigned int i;\n+  if (library)\n+    {\n+      unsigned int i;\n \n-        for (i = 1; i < grs_newargc; i++)\n-            if (grs_new_decoded_options[i].opt_index == OPT_static_libgcc || grs_new_decoded_options[i].opt_index == OPT_static)\n-                break;\n+      for (i = 1; i < grs_newargc; i++)\n+\tif (grs_new_decoded_options[i].opt_index == OPT_static_libgcc\n+\t    || grs_new_decoded_options[i].opt_index == OPT_static)\n+\t  break;\n \n-        if (i == grs_newargc)\n-            append_option(OPT_shared_libgcc, NULL, 1);\n+      if (i == grs_newargc)\n+\tappend_option (OPT_shared_libgcc, NULL, 1);\n     }\n \n #endif\n \n-    if (verbose && grs_new_decoded_options != grs_x_decoded_options) {\n-        fprintf(stderr, _(\"Driving:\"));\n-        for (i = 0; i < grs_newargc; i++)\n-            fprintf(stderr, \" %s\", grs_new_decoded_options[i].orig_option_with_args_text);\n-        fprintf(stderr, \"\\n\");\n+  if (verbose && grs_new_decoded_options != grs_x_decoded_options)\n+    {\n+      fprintf (stderr, _(\"Driving:\"));\n+      for (i = 0; i < grs_newargc; i++)\n+\tfprintf (stderr, \" %s\",\n+\t\t grs_new_decoded_options[i].orig_option_with_args_text);\n+      fprintf (stderr, \"\\n\");\n     }\n \n-    *in_decoded_options_count = grs_newargc;\n-    *in_decoded_options = grs_new_decoded_options;\n+  *in_decoded_options_count = grs_newargc;\n+  *in_decoded_options = grs_new_decoded_options;\n }\n \n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n-int lang_specific_pre_link(void) { // Not used\n-    return 0;\n+int lang_specific_pre_link (void)\n+{\n+  return 0;\n }\n \n /* Number of extra output files that lang_specific_pre_link may generate.  */\n-int lang_specific_extra_outfiles = 0; // Not used\n+int lang_specific_extra_outfiles = 0;\t"}, {"sha": "4a1a6d1b901c6b5954a14b6d7f94b6c9fa5d6026", "filename": "gcc/rust/old/rust.h", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frust.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frust.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frust.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -21,82 +21,79 @@ along with GCC; see the file COPYING3.  If not see\n \n // These must be included before the #poison declarations in system.h.\n #include <algorithm>\n+#include <string>\n #include <list>\n #include <map>\n #include <set>\n-#include <string>\n #include <vector>\n \n+#include \"system.h\"\n #include \"ansidecl.h\"\n-#include \"basic-block.h\"\n-#include \"cgraph.h\"\n-#include \"common/common-target.h\"\n-#include \"convert.h\"\n #include \"coretypes.h\"\n-#include \"debug.h\"\n-#include \"diagnostic-core.h\"\n-#include \"diagnostic.h\"\n-#include \"flags.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"basic-block.h\"\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n-#include \"input.h\"\n-#include \"langhooks-def.h\"\n-#include \"langhooks.h\"\n-#include \"options.h\"\n-#include \"opts.h\"\n-#include \"print-tree.h\"\n #include \"stor-layout.h\"\n-#include \"stringpool.h\"\n-#include \"system.h\"\n-#include \"target.h\"\n #include \"toplev.h\"\n-#include \"tree-iterator.h\"\n-#include \"tree-pass.h\"\n-#include \"tree.h\"\n+#include \"debug.h\"\n+#include \"options.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"target.h\"\n+#include \"common/common-target.h\"\n+#include \"diagnostic-core.h\"\n+#include \"cgraph.h\"\n #include \"varasm.h\"\n-#include <hashtab.h>\n+#include \"stringpool.h\"\n+#include \"print-tree.h\"\n #include <vec.h>\n+#include <hashtab.h>\n+#include \"input.h\"\n \n #include <gmp.h>\n #include <mpfr.h>\n /* rust include */\n #include \"rdot-impl.h\"\n \n #if !defined(YYLTYPE)\n-// Location as used in grs - line and column numbers\n typedef struct grs_location {\n-    int line;\n-    int column;\n+  int line;\n+  int column;\n } grs_location_t;\n-// The location of a type?\n typedef grs_location_t YYLTYPE;\n-// The location of a type?\n #define YYLTYPE YYLTYPE\n #endif\n \n-extern char* GRS_current_infile;\n-extern char* GRS_current_infname;\n+extern char * GRS_current_infile;\n+extern char * GRS_current_infname;\n \n /* important langhook prototypes */\n-extern void grs_set_prefix(const char*);\n-extern void grs_preserve_from_gc(tree);\n-extern void grs_add_search_path(const char*);\n-extern void grs_parse_input_files(const char**, unsigned int);\n-extern tree grs_type_for_size(unsigned int, int);\n-extern tree grs_type_for_mode(enum machine_mode, int);\n+extern void grs_set_prefix (const char *);\n+extern void grs_preserve_from_gc (tree);\n+extern void grs_add_search_path (const char *);\n+extern void grs_parse_input_files (const char **, unsigned int);\n+extern tree grs_type_for_size (unsigned int, int);\n+extern tree grs_type_for_mode (enum machine_mode, int);\n \n-extern bool grs_do_compile(const char*);\n+extern bool grs_do_compile (const char *);\n \n /* rdot pass manager */\n extern tree cstring_type_node;\n \n-extern vec<rdot, va_gc>* dot_pass_inferTypes(vec<rdot, va_gc>*);\n-extern vec<rdot, va_gc>* dot_pass_PrettyPrint(vec<rdot, va_gc>*);\n-extern vec<tree, va_gc>* dot_pass_Genericify(vec<rdot, va_gc>*);\n-extern void dot_pass_pushDecl(rdot);\n-extern void dot_pass_WriteGlobals(void);\n+extern vec<rdot,va_gc> * dot_pass_inferTypes (vec<rdot,va_gc> *);\n+extern vec<rdot,va_gc> * dot_pass_PrettyPrint (vec<rdot,va_gc> *);\n+extern vec<tree,va_gc> * dot_pass_Genericify (vec<rdot,va_gc> *);\n+extern void dot_pass_pushDecl (rdot);\n+extern void dot_pass_WriteGlobals (void);\n \n /* hooks */\n-extern void rs_fill_runtime_decls(std::map<std::string, tree>*);\n+extern void rs_fill_runtime_decls (std::map<std::string, tree> *);\n \n #endif //__GCC_RUST_H__"}, {"sha": "d0246a27de435ad51fee166601f9e01ed14f0d5a", "filename": "gcc/rust/old/y.rs.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Fy.rs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Fy.rs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Fy.rs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,7 +1,6 @@\n #ifndef __Y_RS_H__\n #define __Y_RS_H__\n \n-// Enum containing tokens for lexer\n enum yytokentype {\n     IMPL = 258,\n     AS = 259,\n@@ -46,16 +45,14 @@ enum yytokentype {\n     FLOAT = 298\n };\n \n-// Maybe type of character or whatever comes out of the lexer?\n union yystype {\n   rdot symbol;\n   char * string;\n   int integer;\n   float ffloat;\n   bool boolean;\n-};\n+} ;\n \n-// L-val of whatever comes out of lexer?\n extern yystype yylval;\n \n #endif //__Y_RS_H__"}, {"sha": "d75d9e7a26bd2ffcea1099ce3f5ad767a14c7bf6", "filename": "gcc/rust/rust-c.h", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-c.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -22,27 +22,24 @@ along with GCC; see the file COPYING3.  If not see\n \n #define RUST_EXTERN_C\n \n-/* Functions defined in the Rust frontend proper called by the GCC\n-   interface.  */\n-extern void rust_add_search_path (const char*);\n+class Linemap;\n \n-extern void rust_parse_input_files (const char**, unsigned int,\n-                                    bool only_check_syntax);\n-extern void rust_write_globals (void);\n+extern Linemap* rust_get_linemap();\n+\n+extern void rust_create_rustly(bool only_check_syntax, Linemap* linemap);\n+\n+extern void rust_parse_input_files (const char**, unsigned int);\n+\n+extern unsigned int rust_field_alignment (tree);\n \n-/* Functions defined in the GCC interface called by the Rust frontend\n-   proper.  */\n+extern void rust_write_globals (void);\n \n extern void rust_preserve_from_gc (tree);\n \n extern bool saw_errors (void);\n \n-extern const char *rust_localize_identifier (const char*);\n-\n extern unsigned int rust_field_alignment (tree);\n \n-extern void rust_imported_unsafe (void);\n-\n-extern GTY(()) tree rust_non_zero_struct;\n+extern void rust_write_export_data (const char *, unsigned int);\n \n #endif /* !defined(RUST_RUST_C_H) */"}, {"sha": "fd9c63d9906bbc4dc9fb799ed7878fc58b1aa337", "filename": "gcc/rust/rust-gcc-diagnostics.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc-diagnostics.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -10,26 +10,25 @@ rust_be_error_at(const Location location, const std::string& errmsg)\n   error_at(gcc_loc, \"%s\", errmsg.c_str());\n }\n \n-\n void\n rust_be_warning_at(const Location location,\n-                 int opt, const std::string& warningmsg)\n+                   int opt, const std::string& warningmsg)\n {\n   location_t gcc_loc = location.gcc_location();\n   warning_at(gcc_loc, opt, \"%s\", warningmsg.c_str());\n }\n \n void\n rust_be_fatal_error(const Location location,\n-                  const std::string& fatalmsg)\n+                    const std::string& fatalmsg)\n {\n   location_t gcc_loc = location.gcc_location();\n   fatal_error(gcc_loc, \"%s\", fatalmsg.c_str());\n }\n \n void\n rust_be_inform(const Location location,\n-             const std::string& infomsg)\n+               const std::string& infomsg)\n {\n   location_t gcc_loc = location.gcc_location();\n   inform(gcc_loc, \"%s\", infomsg.c_str());"}, {"sha": "8580f09dff7bce9dc21f336c2275904a7feb5e17", "filename": "gcc/rust/rust-gcc.cc", "status": "added", "additions": 3513, "deletions": 0, "changes": 3513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6e1be89e2befc3efc039c5742673f484040e16b0", "filename": "gcc/rust/rust-lang.c", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -181,47 +181,47 @@ rust_langhook_handle_option (\n \n   switch (code)\n     {\n-    case OPT_I:\n+\t/*case OPT_I:\n       rust_add_search_path (arg);\n-      break;\n-\n-    case OPT_L:\n-      /* A -L option is assumed to come from the compiler driver.\n-\t This is a system directory.  We search the following\n-\t directories, if they exist, before this one:\n-\t   dir/go/VERSION\n-\t   dir/go/VERSION/MACHINE\n-\t This is like include/c++.  */\n-      {\n-\tstatic const char dir_separator_str[] = { DIR_SEPARATOR, 0 };\n-\tsize_t len;\n-\tchar *p;\n-\tstruct stat st;\n-\n-\tlen = strlen (arg);\n-\tp = XALLOCAVEC (char,\n-\t\t\t(len + sizeof \"rust\" + sizeof DEFAULT_TARGET_VERSION\n-\t\t\t + sizeof DEFAULT_TARGET_MACHINE + 3));\n-\tstrcpy (p, arg);\n-\tif (len > 0 && !IS_DIR_SEPARATOR (p[len - 1]))\n-\t  strcat (p, dir_separator_str);\n-\tstrcat (p, \"rust\");\n-\tstrcat (p, dir_separator_str);\n-\tstrcat (p, DEFAULT_TARGET_VERSION);\n-\tif (stat (p, &st) == 0 && S_ISDIR (st.st_mode))\n-\t  {\n-\t    rust_add_search_path (p);\n-\t    strcat (p, dir_separator_str);\n-\t    strcat (p, DEFAULT_TARGET_MACHINE);\n-\t    if (stat (p, &st) == 0 && S_ISDIR (st.st_mode))\n-\t      rust_add_search_path (p);\n-\t  }\n-\n-\t/* Search ARG too, but only after we've searched to Rust\n-\t   specific directories for all -L arguments.  */\n-\trust_search_dirs.safe_push (arg);\n-      }\n-      break;\n+      break;*/\n+\n+    /* case OPT_L: */\n+    /*   /\\* A -L option is assumed to come from the compiler driver. */\n+    /* \t This is a system directory.  We search the following */\n+    /* \t directories, if they exist, before this one: */\n+    /* \t   dir/go/VERSION */\n+    /* \t   dir/go/VERSION/MACHINE */\n+    /* \t This is like include/c++.  *\\/ */\n+    /*   { */\n+    /* \tstatic const char dir_separator_str[] = { DIR_SEPARATOR, 0 }; */\n+    /* \tsize_t len; */\n+    /* \tchar *p; */\n+    /* \tstruct stat st; */\n+\n+    /* \tlen = strlen (arg); */\n+    /* \tp = XALLOCAVEC (char, */\n+    /* \t\t\t(len + sizeof \"rust\" + sizeof DEFAULT_TARGET_VERSION */\n+    /* \t\t\t + sizeof DEFAULT_TARGET_MACHINE + 3)); */\n+    /* \tstrcpy (p, arg); */\n+    /* \tif (len > 0 && !IS_DIR_SEPARATOR (p[len - 1])) */\n+    /* \t  strcat (p, dir_separator_str); */\n+    /* \tstrcat (p, \"rust\"); */\n+    /* \tstrcat (p, dir_separator_str); */\n+    /* \tstrcat (p, DEFAULT_TARGET_VERSION); */\n+    /* \tif (stat (p, &st) == 0 && S_ISDIR (st.st_mode)) */\n+    /* \t  { */\n+    /* \t    rust_add_search_path (p); */\n+    /* \t    strcat (p, dir_separator_str); */\n+    /* \t    strcat (p, DEFAULT_TARGET_MACHINE); */\n+    /* \t    if (stat (p, &st) == 0 && S_ISDIR (st.st_mode)) */\n+    /* \t      rust_add_search_path (p); */\n+    /* \t  } */\n+\n+    /* \t/\\* Search ARG too, but only after we've searched to Rust */\n+    /* \t   specific directories for all -L arguments.  *\\/ */\n+    /* \trust_search_dirs.safe_push (arg); */\n+    /*   } */\n+    /*   break; */\n \n     default:\n       /* Just return 1 to indicate that the option is valid.  */\n@@ -241,12 +241,13 @@ rust_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n \n   gcc_assert (num_in_fnames > 0);\n \n-  FOR_EACH_VEC_ELT (rust_search_dirs, ix, dir)\n-    rust_add_search_path (dir);\n-  rust_search_dirs.release ();\n+  // FIXME\n+  /* FOR_EACH_VEC_ELT (rust_search_dirs, ix, dir) */\n+  /*   rust_add_search_path (dir); */\n+  /* rust_search_dirs.release (); */\n \n-  if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n-    flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+  /* if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT) */\n+  /*   flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD; */\n \n   /* Tail call optimizations can confuse uses of runtime.Callers.  */\n   if (!global_options_set.x_flag_optimize_sibling_calls)\n@@ -279,10 +280,16 @@ rust_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n static void\n rust_langhook_parse_file (void)\n {\n-  rust_parse_input_files (in_fnames, num_in_fnames, flag_syntax_only);\n+    // RUSTLY MAIN\n+    \n+    // TODO\n+    // rust_parse_input_files (in_fnames, num_in_fnames, flag_syntax_only);\n+\n+    /* Final processing of globals and early debug info generation.  */\n+    // rust_write_globals ();\n \n-  /* Final processing of globals and early debug info generation.  */\n-  // rust_write_globals ();\n+    rust_create_rustly(flag_syntax_only, rust_get_linemap());\n+    rust_parse_input_files(in_fnames, num_in_fnames);\n }\n \n static tree"}, {"sha": "d4c0ac1254063994796f1f7d90f6bd4d76016f7f", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -37,6 +37,11 @@\n #include <set>\n #include <vector>\n #include <sstream>\n+<<<<<<< HEAD\n+=======\n+#include <string>\n+#include <deque>\n+>>>>>>> c611d209696bd5983b4b777be0beea80351dee46\n \n #if defined(HAVE_UNORDERED_MAP)\n "}, {"sha": "d69ad91baa9c3d19b3f910af97f00c154302a2d2", "filename": "gcc/rust/rustfrontend/backend.h", "status": "added", "additions": 778, "deletions": 0, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fbackend.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,778 @@\n+#pragma once\n+\n+#include <gmp.h>\n+#include <mpfr.h>\n+#include <mpc.h>\n+\n+#include \"operator.h\"\n+\n+// Pointers to these types are created by the backend, passed to the\n+// frontend, and passed back to the backend.  The types must be\n+// defined by the backend using these names.\n+\n+// The backend representation of a type.\n+class Btype;\n+\n+// The backend represention of an expression.\n+class Bexpression;\n+\n+// The backend representation of a statement.\n+class Bstatement;\n+\n+// The backend representation of a function definition or declaration.\n+class Bfunction;\n+\n+// The backend representation of a block.\n+class Bblock;\n+\n+// The backend representation of a variable.\n+class Bvariable;\n+\n+// The backend representation of a label.\n+class Blabel;\n+\n+\n+// The backend interface.  This is a pure abstract class that a\n+// specific backend will implement.\n+\n+class Backend\n+{\n+ public:\n+  virtual ~Backend() { }\n+\n+  // Name/type/location.  Used for function parameters, struct fields,\n+  // interface methods.\n+  struct Btyped_identifier\n+  {\n+    std::string name;\n+    Btype* btype;\n+    Location location;\n+\n+    Btyped_identifier()\n+        : name(), btype(NULL), location(Linemap::unknown_location())\n+    { }\n+\n+    Btyped_identifier(const std::string& a_name, Btype* a_btype,\n+\t\t     Location a_location)\n+      : name(a_name), btype(a_btype), location(a_location)\n+    { }\n+  };\n+\n+  // Types.\n+\n+  // Produce an error type.  Actually the backend could probably just\n+  // crash if this is called.\n+  virtual Btype*\n+  error_type() = 0;\n+\n+  // Get a void type.  This is used in (at least) two ways: 1) as the\n+  // return type of a function with no result parameters; 2)\n+  // unsafe.Pointer is represented as *void.\n+  virtual Btype*\n+  void_type() = 0;\n+\n+  // Get the unnamed boolean type.\n+  virtual Btype*\n+  bool_type() = 0;\n+\n+  // Get an unnamed integer type with the given signedness and number\n+  // of bits.\n+  virtual Btype*\n+  integer_type(bool is_unsigned, int bits) = 0;\n+\n+  // Get an unnamed floating point type with the given number of bits\n+  // (32 or 64).\n+  virtual Btype*\n+  float_type(int bits) = 0;\n+\n+  // Get an unnamed complex type with the given number of bits (64 or 128).\n+  virtual Btype*\n+  complex_type(int bits) = 0;\n+\n+  // Get a pointer type.\n+  virtual Btype*\n+  pointer_type(Btype* to_type) = 0;\n+\n+  // Get a function type.  The receiver, parameter, and results are\n+  // generated from the types in the Function_type.  The Function_type\n+  // is provided so that the names are available.  This should return\n+  // not the type of a Go function (which is a pointer to a struct)\n+  // but the type of a C function pointer (which will be used as the\n+  // type of the first field of the struct).  If there is more than\n+  // one result, RESULT_STRUCT is a struct type to hold the results,\n+  // and RESULTS may be ignored; if there are zero or one results,\n+  // RESULT_STRUCT is NULL.\n+  virtual Btype*\n+  function_type(const Btyped_identifier& receiver,\n+\t\tconst std::vector<Btyped_identifier>& parameters,\n+\t\tconst std::vector<Btyped_identifier>& results,\n+\t\tBtype* result_struct,\n+\t\tLocation location) = 0;\n+\n+  // Get a struct type.\n+  virtual Btype*\n+  struct_type(const std::vector<Btyped_identifier>& fields) = 0;\n+\n+  // Get an array type.\n+  virtual Btype*\n+  array_type(Btype* element_type, Bexpression* length) = 0;\n+\n+  // Create a placeholder pointer type.  This is used for a named\n+  // pointer type, since in Go a pointer type may refer to itself.\n+  // NAME is the name of the type, and the location is where the named\n+  // type is defined.  This function is also used for unnamed function\n+  // types with multiple results, in which case the type has no name\n+  // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n+  // pointer to function type.  A Go func type is represented as a\n+  // pointer to a struct, and the first field of the struct is a C\n+  // pointer to function.  The return value will later be passed as\n+  // the first parameter to set_placeholder_pointer_type or\n+  // set_placeholder_function_type.\n+  virtual Btype*\n+  placeholder_pointer_type(const std::string& name, Location,\n+\t\t\t   bool for_function) = 0;\n+\n+  // Fill in a placeholder pointer type as a pointer.  This takes a\n+  // type returned by placeholder_pointer_type and arranges for it to\n+  // point to the type that TO_TYPE points to (that is, PLACEHOLDER\n+  // becomes the same type as TO_TYPE).  Returns true on success,\n+  // false on failure.\n+  virtual bool\n+  set_placeholder_pointer_type(Btype* placeholder, Btype* to_type) = 0;\n+\n+  // Fill in a placeholder pointer type as a function.  This takes a\n+  // type returned by placeholder_pointer_type and arranges for it to\n+  // become a real Go function type (which corresponds to a C/C++\n+  // pointer to function type).  FT will be something returned by the\n+  // function_type method.  Returns true on success, false on failure.\n+  virtual bool\n+  set_placeholder_function_type(Btype* placeholder, Btype* ft) = 0;\n+\n+  // Create a placeholder struct type.  This is used for a named\n+  // struct type, as with placeholder_pointer_type.  It is also used\n+  // for interface types, in which case NAME will be the empty string.\n+  virtual Btype*\n+  placeholder_struct_type(const std::string& name, Location) = 0;\n+\n+  // Fill in a placeholder struct type.  This takes a type returned by\n+  // placeholder_struct_type and arranges for it to become a real\n+  // struct type.  The parameter is as for struct_type.  Returns true\n+  // on success, false on failure.\n+  virtual bool\n+  set_placeholder_struct_type(Btype* placeholder,\n+\t\t\t      const std::vector<Btyped_identifier>& fields)\n+  \t\t\t= 0;\n+\n+  // Create a placeholder array type.  This is used for a named array\n+  // type, as with placeholder_pointer_type, to handle cases like\n+  // type A []*A.\n+  virtual Btype*\n+  placeholder_array_type(const std::string& name, Location) = 0;\n+\n+  // Fill in a placeholder array type.  This takes a type returned by\n+  // placeholder_array_type and arranges for it to become a real array\n+  // type.  The parameters are as for array_type.  Returns true on\n+  // success, false on failure.\n+  virtual bool\n+  set_placeholder_array_type(Btype* placeholder, Btype* element_type,\n+\t\t\t     Bexpression* length) = 0;\n+\n+  // Return a named version of a type.  The location is the location\n+  // of the type definition.  This will not be called for a type\n+  // created via placeholder_pointer_type, placeholder_struct_type, or\n+  // placeholder_array_type..  (It may be called for a pointer,\n+  // struct, or array type in a case like \"type P *byte; type Q P\".)\n+  virtual Btype*\n+  named_type(const std::string& name, Btype*, Location) = 0;\n+\n+  // Create a marker for a circular pointer type.  Go pointer and\n+  // function types can refer to themselves in ways that are not\n+  // permitted in C/C++.  When a circular type is found, this function\n+  // is called for the circular reference.  This permits the backend\n+  // to decide how to handle such a type.  PLACEHOLDER is the\n+  // placeholder type which has already been created; if the backend\n+  // is prepared to handle a circular pointer type, it may simply\n+  // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a\n+  // function type.\n+  //\n+  // For \"type P *P\" the sequence of calls will be\n+  //   bt1 = placeholder_pointer_type();\n+  //   bt2 = circular_pointer_type(bt1, false);\n+  //   set_placeholder_pointer_type(bt1, bt2);\n+  virtual Btype*\n+  circular_pointer_type(Btype* placeholder, bool for_function) = 0;\n+\n+  // Return whether the argument could be a special type created by\n+  // circular_pointer_type.  This is used to introduce explicit type\n+  // conversions where needed.  If circular_pointer_type returns its\n+  // PLACEHOLDER parameter, this may safely always return false.\n+  virtual bool\n+  is_circular_pointer_type(Btype*) = 0;\n+\n+  // Return the size of a type.\n+  virtual int64_t\n+  type_size(Btype*) = 0;\n+\n+  // Return the alignment of a type.\n+  virtual int64_t\n+  type_alignment(Btype*) = 0;\n+\n+  // Return the alignment of a struct field of this type.  This is\n+  // normally the same as type_alignment, but not always.\n+  virtual int64_t\n+  type_field_alignment(Btype*) = 0;\n+\n+  // Return the offset of field INDEX in a struct type.  INDEX is the\n+  // entry in the FIELDS std::vector parameter of struct_type or\n+  // set_placeholder_struct_type.\n+  virtual int64_t\n+  type_field_offset(Btype*, size_t index) = 0;\n+\n+  // Expressions.\n+\n+  // Return an expression for a zero value of the given type.  This is\n+  // used for cases such as local variable initialization and\n+  // converting nil to other types.\n+  virtual Bexpression*\n+  zero_expression(Btype*) = 0;\n+\n+  // Create an error expression. This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bexpression*\n+  error_expression() = 0;\n+\n+  // Create a nil pointer expression.\n+  virtual Bexpression*\n+  nil_pointer_expression() = 0;\n+\n+  // Create a reference to a variable.\n+  virtual Bexpression*\n+  var_expression(Bvariable* var, Location) = 0;\n+\n+  // Create an expression that indirects through the pointer expression EXPR\n+  // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n+  // is known to point to a valid memory location.  BTYPE is the expected type\n+  // of the indirected EXPR.\n+  virtual Bexpression*\n+  indirect_expression(Btype* btype, Bexpression* expr, bool known_valid,\n+\t\t      Location) = 0;\n+\n+  // Return an expression that declares a constant named NAME with the\n+  // constant value VAL in BTYPE.\n+  virtual Bexpression*\n+  named_constant_expression(Btype* btype, const std::string& name,\n+                             Bexpression* val, Location) = 0;\n+\n+  // Return an expression for the multi-precision integer VAL in BTYPE.\n+  virtual Bexpression*\n+  integer_constant_expression(Btype* btype, mpz_t val) = 0;\n+\n+  // Return an expression for the floating point value VAL in BTYPE.\n+  virtual Bexpression*\n+  float_constant_expression(Btype* btype, mpfr_t val) = 0;\n+\n+  // Return an expression for the complex value VAL in BTYPE.\n+  virtual Bexpression*\n+  complex_constant_expression(Btype* btype, mpc_t val) = 0;\n+\n+  // Return an expression for the string value VAL.\n+  virtual Bexpression*\n+  string_constant_expression(const std::string& val) = 0;\n+\n+  // Return an expression for the boolean value VAL.\n+  virtual Bexpression*\n+  boolean_constant_expression(bool val) = 0;\n+\n+  // Return an expression for the real part of BCOMPLEX.\n+  virtual Bexpression*\n+  real_part_expression(Bexpression* bcomplex, Location) = 0;\n+\n+  // Return an expression for the imaginary part of BCOMPLEX.\n+  virtual Bexpression*\n+  imag_part_expression(Bexpression* bcomplex, Location) = 0;\n+\n+  // Return an expression for the complex number (BREAL, BIMAG).\n+  virtual Bexpression*\n+  complex_expression(Bexpression* breal, Bexpression* bimag, Location) = 0;\n+\n+  // Return an expression that converts EXPR to TYPE.\n+  virtual Bexpression*\n+  convert_expression(Btype* type, Bexpression* expr, Location) = 0;\n+\n+  // Create an expression for the address of a function.  This is used to\n+  // get the address of the code for a function.\n+  virtual Bexpression*\n+  function_code_expression(Bfunction*, Location) = 0;\n+\n+  // Create an expression that takes the address of an expression.\n+  virtual Bexpression*\n+  address_expression(Bexpression*, Location) = 0;\n+\n+  // Return an expression for the field at INDEX in BSTRUCT.\n+  virtual Bexpression*\n+  struct_field_expression(Bexpression* bstruct, size_t index, Location) = 0;\n+\n+  // Create an expression that executes BSTAT before BEXPR.\n+  virtual Bexpression*\n+  compound_expression(Bstatement* bstat, Bexpression* bexpr, Location) = 0;\n+\n+  // Return an expression that executes THEN_EXPR if CONDITION is true, or\n+  // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n+  // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n+  virtual Bexpression*\n+  conditional_expression(Bfunction* function, Btype* btype,\n+                         Bexpression* condition, Bexpression* then_expr,\n+                         Bexpression* else_expr, Location) = 0;\n+\n+  // Return an expression for the unary operation OP EXPR.\n+  // Supported values of OP are (from operators.h):\n+  //    MINUS, NOT, XOR.\n+  virtual Bexpression*\n+  unary_expression(Operator op, Bexpression* expr, Location) = 0;\n+\n+  // Return an expression for the binary operation LEFT OP RIGHT.\n+  // Supported values of OP are (from operators.h):\n+  //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,\n+  //    LSHIFT, RSHIFT, AND, NOT.\n+  virtual Bexpression*\n+  binary_expression(Operator op, Bexpression* left, Bexpression* right,\n+                    Location) = 0;\n+\n+  // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n+  // backend representation a of struct.  VALS must be in the same order as the\n+  // corresponding fields in BTYPE.\n+  virtual Bexpression*\n+  constructor_expression(Btype* btype, const std::vector<Bexpression*>& vals,\n+                         Location) = 0;\n+\n+  // Return an expression that constructs an array of BTYPE with INDEXES and\n+  // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n+  // in INDEXES must be in the same order as the corresponding value in VALS.\n+  virtual Bexpression*\n+  array_constructor_expression(Btype* btype,\n+                               const std::vector<unsigned long>& indexes,\n+                               const std::vector<Bexpression*>& vals,\n+                               Location) = 0;\n+\n+  // Return an expression for the address of BASE[INDEX].\n+  // BASE has a pointer type.  This is used for slice indexing.\n+  virtual Bexpression*\n+  pointer_offset_expression(Bexpression* base, Bexpression* index,\n+                            Location) = 0;\n+\n+  // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n+  // fixed-length array, not a slice.\n+  virtual Bexpression*\n+  array_index_expression(Bexpression* array, Bexpression* index, Location) = 0;\n+\n+  // Create an expression for a call to FN with ARGS, taking place within\n+  // caller CALLER.\n+  virtual Bexpression*\n+  call_expression(Bfunction *caller, Bexpression* fn,\n+                  const std::vector<Bexpression*>& args,\n+\t\t  Bexpression* static_chain, Location) = 0;\n+\n+  // Statements.\n+\n+  // Create an error statement.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bstatement*\n+  error_statement() = 0;\n+\n+  // Create an expression statement within the specified function.\n+  virtual Bstatement*\n+  expression_statement(Bfunction*, Bexpression*) = 0;\n+\n+  // Create a variable initialization statement in the specified\n+  // function.  This initializes a local variable at the point in the\n+  // program flow where it is declared.\n+  virtual Bstatement*\n+  init_statement(Bfunction*, Bvariable* var, Bexpression* init) = 0;\n+\n+  // Create an assignment statement within the specified function.\n+  virtual Bstatement*\n+  assignment_statement(Bfunction*, Bexpression* lhs, Bexpression* rhs,\n+\t\t       Location) = 0;\n+\n+  // Create a return statement, passing the representation of the\n+  // function and the list of values to return.\n+  virtual Bstatement*\n+  return_statement(Bfunction*, const std::vector<Bexpression*>&,\n+\t\t   Location) = 0;\n+\n+  // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n+  virtual Bstatement*\n+  if_statement(Bfunction*, Bexpression* condition,\n+               Bblock* then_block, Bblock* else_block,\n+\t       Location) = 0;\n+\n+  // Create a switch statement where the case values are constants.\n+  // CASES and STATEMENTS must have the same number of entries.  If\n+  // VALUE matches any of the list in CASES[i], which will all be\n+  // integers, then STATEMENTS[i] is executed.  STATEMENTS[i] will\n+  // either end with a goto statement or will fall through into\n+  // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n+  // which need not be last.  FUNCTION is the current function.\n+  virtual Bstatement*\n+  switch_statement(Bfunction* function, Bexpression* value,\n+\t\t   const std::vector<std::vector<Bexpression*> >& cases,\n+\t\t   const std::vector<Bstatement*>& statements,\n+\t\t   Location) = 0;\n+\n+  // Create a single statement from two statements.\n+  virtual Bstatement*\n+  compound_statement(Bstatement*, Bstatement*) = 0;\n+\n+  // Create a single statement from a list of statements.\n+  virtual Bstatement*\n+  statement_list(const std::vector<Bstatement*>&) = 0;\n+\n+  // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n+  // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n+  // if not NULL, it will always be executed.  This is used for handling defers\n+  // in Go functions.  In C++, the resulting code is of this form:\n+  //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n+  virtual Bstatement*\n+  exception_handler_statement(Bstatement* bstat, Bstatement* except_stmt,\n+                              Bstatement* finally_stmt, Location) = 0;\n+\n+  // Blocks.\n+\n+  // Create a block.  The frontend will call this function when it\n+  // starts converting a block within a function.  FUNCTION is the\n+  // current function.  ENCLOSING is the enclosing block; it will be\n+  // NULL for the top-level block in a function.  VARS is the list of\n+  // local variables defined within this block; each entry will be\n+  // created by the local_variable function.  START_LOCATION is the\n+  // location of the start of the block, more or less the location of\n+  // the initial curly brace.  END_LOCATION is the location of the end\n+  // of the block, more or less the location of the final curly brace.\n+  // The statements will be added after the block is created.\n+  virtual Bblock*\n+  block(Bfunction* function, Bblock* enclosing,\n+\tconst std::vector<Bvariable*>& vars,\n+\tLocation start_location, Location end_location) = 0;\n+\n+  // Add the statements to a block.  The block is created first.  Then\n+  // the statements are created.  Then the statements are added to the\n+  // block.  This will called exactly once per block.  The vector may\n+  // be empty if there are no statements.\n+  virtual void\n+  block_add_statements(Bblock*, const std::vector<Bstatement*>&) = 0;\n+\n+  // Return the block as a statement.  This is used to include a block\n+  // in a list of statements.\n+  virtual Bstatement*\n+  block_statement(Bblock*) = 0;\n+\n+  // Variables.\n+\n+  // Create an error variable.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bvariable*\n+  error_variable() = 0;\n+\n+  // Create a global variable. NAME is the package-qualified name of\n+  // the variable.  ASM_NAME is the encoded identifier for the\n+  // variable, incorporating the package, and made safe for the\n+  // assembler.  BTYPE is the type of the variable.  IS_EXTERNAL is\n+  // true if the variable is defined in some other package.  IS_HIDDEN\n+  // is true if the variable is not exported (name begins with a lower\n+  // case letter).  IN_UNIQUE_SECTION is true if the variable should\n+  // be put into a unique section if possible; this is intended to\n+  // permit the linker to garbage collect the variable if it is not\n+  // referenced.  LOCATION is where the variable was defined.\n+  virtual Bvariable*\n+  global_variable(const std::string& name,\n+                  const std::string& asm_name,\n+\t\t  Btype* btype,\n+\t\t  bool is_external,\n+\t\t  bool is_hidden,\n+\t\t  bool in_unique_section,\n+\t\t  Location location) = 0;\n+\n+  // A global variable will 1) be initialized to zero, or 2) be\n+  // initialized to a constant value, or 3) be initialized in the init\n+  // function.  In case 2, the frontend will call\n+  // global_variable_set_init to set the initial value.  If this is\n+  // not called, the backend should initialize a global variable to 0.\n+  // The init function may then assign a value to it.\n+  virtual void\n+  global_variable_set_init(Bvariable*, Bexpression*) = 0;\n+\n+  // Create a local variable.  The frontend will create the local\n+  // variables first, and then create the block which contains them.\n+  // FUNCTION is the function in which the variable is defined.  NAME\n+  // is the name of the variable.  TYPE is the type.  DECL_VAR, if not\n+  // null, gives the location at which the value of this variable may\n+  // be found, typically used to create an inner-scope reference to an\n+  // outer-scope variable, to extend the lifetime of the variable beyond\n+  // the inner scope.  IS_ADDRESS_TAKEN is true if the address of this\n+  // variable is taken (this implies that the address does not escape\n+  // the function, as otherwise the variable would be on the heap).\n+  // LOCATION is where the variable is defined.  For each local variable\n+  // the frontend will call init_statement to set the initial value.\n+  virtual Bvariable*\n+  local_variable(Bfunction* function, const std::string& name, Btype* type,\n+\t\t Bvariable* decl_var, bool is_address_taken, Location location) = 0;\n+\n+  // Create a function parameter.  This is an incoming parameter, not\n+  // a result parameter (result parameters are treated as local\n+  // variables).  The arguments are as for local_variable.\n+  virtual Bvariable*\n+  parameter_variable(Bfunction* function, const std::string& name,\n+\t\t     Btype* type, bool is_address_taken,\n+\t\t     Location location) = 0;\n+\n+  // Create a static chain parameter.  This is the closure parameter.\n+  virtual Bvariable*\n+  static_chain_variable(Bfunction* function, const std::string& name,\n+\t\t        Btype* type, Location location) = 0;\n+\n+  // Create a temporary variable.  A temporary variable has no name,\n+  // just a type.  We pass in FUNCTION and BLOCK in case they are\n+  // needed.  If INIT is not NULL, the variable should be initialized\n+  // to that value.  Otherwise the initial value is irrelevant--the\n+  // backend does not have to explicitly initialize it to zero.\n+  // ADDRESS_IS_TAKEN is true if the programs needs to take the\n+  // address of this temporary variable.  LOCATION is the location of\n+  // the statement or expression which requires creating the temporary\n+  // variable, and may not be very useful.  This function should\n+  // return a variable which can be referenced later and should set\n+  // *PSTATEMENT to a statement which initializes the variable.\n+  virtual Bvariable*\n+  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,\n+\t\t     bool address_is_taken, Location location,\n+\t\t     Bstatement** pstatement) = 0;\n+\n+  // Create an implicit variable that is compiler-defined.  This is\n+  // used when generating GC data and roots, when storing the values\n+  // of a slice constructor, and for the zero value of types.  This returns a\n+  // Bvariable because it corresponds to an initialized variable in C.\n+  //\n+  // NAME is the name to use for the initialized variable this will create.\n+  //\n+  // ASM_NAME is encoded assembler-friendly version of the name, or the\n+  // empty string if no encoding is needed.\n+  //\n+  // TYPE is the type of the implicit variable.\n+  //\n+  // IS_HIDDEN will be true if the descriptor should only be visible\n+  // within the current object.\n+  //\n+  // IS_CONSTANT is true if the implicit variable should be treated like it is\n+  // immutable.  For slice initializers, if the values must be copied to the\n+  // heap, the variable IS_CONSTANT.\n+  //\n+  // IS_COMMON is true if the implicit variable should\n+  // be treated as a common variable (multiple definitions with\n+  // different sizes permitted in different object files, all merged\n+  // into the largest definition at link time); this will be true for\n+  // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n+  //\n+  // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n+  virtual Bvariable*\n+  implicit_variable(const std::string& name, const std::string& asm_name,\n+                    Btype* type, bool is_hidden, bool is_constant,\n+                    bool is_common, int64_t alignment) = 0;\n+\n+\n+  // Set the initial value of a variable created by implicit_variable.\n+  // This must be called even if there is no initializer, i.e., INIT is NULL.\n+  // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are\n+  // the same ones passed to implicit_variable.  INIT will be a composite\n+  // literal of type TYPE.  It will not contain any function calls or anything\n+  // else that can not be put into a read-only data section.\n+  // It may contain the address of variables created by implicit_variable.\n+  //\n+  // If IS_COMMON is true, INIT will be NULL, and the\n+  // variable should be initialized to all zeros.\n+  virtual void\n+  implicit_variable_set_init(Bvariable*, const std::string& name, Btype* type,\n+\t\t\t     bool is_hidden, bool is_constant, bool is_common,\n+\t\t\t     Bexpression* init) = 0;\n+\n+  // Create a reference to a named implicit variable defined in some\n+  // other package.  This will be a variable created by a call to\n+  // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n+  // IS_COMMON passed as false.  This corresponds to an extern global\n+  // variable in C.\n+  virtual Bvariable*\n+  implicit_variable_reference(const std::string& name,\n+                              const std::string& asm_name,\n+                              Btype* type) = 0;\n+\n+  // Create a named immutable initialized data structure.  This is\n+  // used for type descriptors, map descriptors, and function\n+  // descriptors.  This returns a Bvariable because it corresponds to\n+  // an initialized const variable in C.\n+  //\n+  // NAME is the name to use for the initialized global variable which\n+  // this call will create.\n+  //\n+  // ASM_NAME is the encoded, assembler-friendly version of NAME, or\n+  // the empty string if no encoding is needed.\n+  //\n+  // IS_HIDDEN will be true if the descriptor should only be visible\n+  // within the current object.\n+  //\n+  // IS_COMMON is true if NAME may be defined by several packages, and\n+  // the linker should merge all such definitions.  If IS_COMMON is\n+  // false, NAME should be defined in only one file.  In general\n+  // IS_COMMON will be true for the type descriptor of an unnamed type\n+  // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be\n+  // true.\n+  //\n+  // TYPE will be a struct type; the type of the returned expression\n+  // must be a pointer to this struct type.\n+  //\n+  // We must create the named structure before we know its\n+  // initializer, because the initializer may refer to its own\n+  // address.  After calling this the frontend will call\n+  // immutable_struct_set_init.\n+  virtual Bvariable*\n+  immutable_struct(const std::string& name,\n+                   const std::string& asm_name,\n+                   bool is_hidden, bool is_common,\n+\t\t   Btype* type, Location) = 0;\n+\n+  // Set the initial value of a variable created by immutable_struct.\n+  // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n+  // the same ones passed to immutable_struct.  INITIALIZER will be a\n+  // composite literal of type TYPE.  It will not contain any function\n+  // calls or anything else that can not be put into a read-only data\n+  // section.  It may contain the address of variables created by\n+  // immutable_struct.\n+  virtual void\n+  immutable_struct_set_init(Bvariable*, const std::string& name,\n+\t\t\t    bool is_hidden, bool is_common, Btype* type,\n+\t\t\t    Location, Bexpression* initializer) = 0;\n+\n+  // Create a reference to a named immutable initialized data\n+  // structure defined in some other package.  This will be a\n+  // structure created by a call to immutable_struct with the same\n+  // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n+  // corresponds to an extern const global variable in C.\n+  virtual Bvariable*\n+  immutable_struct_reference(const std::string& name,\n+                             const std::string& asm_name,\n+                             Btype* type, Location) = 0;\n+\n+  // Labels.\n+\n+  // Create a new label.  NAME will be empty if this is a label\n+  // created by the frontend for a loop construct.  The location is\n+  // where the label is defined.\n+  virtual Blabel*\n+  label(Bfunction*, const std::string& name, Location) = 0;\n+\n+  // Create a statement which defines a label.  This statement will be\n+  // put into the codestream at the point where the label should be\n+  // defined.\n+  virtual Bstatement*\n+  label_definition_statement(Blabel*) = 0;\n+\n+  // Create a goto statement to a label.\n+  virtual Bstatement*\n+  goto_statement(Blabel*, Location) = 0;\n+\n+  // Create an expression for the address of a label.  This is used to\n+  // get the return address of a deferred function which may call\n+  // recover.\n+  virtual Bexpression*\n+  label_address(Blabel*, Location) = 0;\n+\n+  // Functions.\n+\n+  // Create an error function.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bfunction*\n+  error_function() = 0;\n+\n+  // Bit flags to pass to the function method.\n+\n+  // Set if the function should be visible outside of the current\n+  // compilation unit.\n+  static const unsigned int function_is_visible = 1 << 0;\n+\n+  // Set if this is a function declaration rather than a definition;\n+  // the definition will be in another compilation unit.\n+  static const unsigned int function_is_declaration = 1 << 1;\n+\n+  // Set if the function can be inlined.  This is normally set, but is\n+  // false for functions that may not be inlined because they call\n+  // recover and must be visible for correct panic recovery.\n+  static const unsigned int function_is_inlinable = 1 << 2;\n+\n+  // Set if the function may not split the stack.  This is set for the\n+  // implementation of recover itself, among other things.\n+  static const unsigned int function_no_split_stack = 1 << 3;\n+\n+  // Set if the function does not return.  This is set for the\n+  // implementation of panic.\n+  static const unsigned int function_does_not_return = 1 << 4;\n+\n+  // Set if the function should be put in a unique section if\n+  // possible.  This is used for field tracking.\n+  static const unsigned int function_in_unique_section = 1 << 5;\n+\n+  // Set if the function should be available for inlining in the\n+  // backend, but should not be emitted as a standalone function.  Any\n+  // call to the function that is not inlined should be treated as a\n+  // call to a function defined in a different compilation unit.  This\n+  // is like a C99 function marked inline but not extern.\n+  static const unsigned int function_only_inline = 1 << 6;\n+\n+  // Declare or define a function of FNTYPE.\n+  // NAME is the Go name of the function.  ASM_NAME, if not the empty\n+  // string, is the name that should be used in the symbol table; this\n+  // will be non-empty if a magic extern comment is used.  FLAGS is\n+  // bit flags described above.\n+  virtual Bfunction*\n+  function(Btype* fntype, const std::string& name, const std::string& asm_name,\n+\t   unsigned int flags, Location) = 0;\n+\n+  // Create a statement that runs all deferred calls for FUNCTION.  This should\n+  // be a statement that looks like this in C++:\n+  //   finish:\n+  //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n+  virtual Bstatement*\n+  function_defer_statement(Bfunction* function, Bexpression* undefer,\n+                           Bexpression* check_defer, Location) = 0;\n+\n+  // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n+  // This will only be called for a function definition.  Returns true on\n+  // success, false on failure.\n+  virtual bool\n+  function_set_parameters(Bfunction* function,\n+                         const std::vector<Bvariable*>& param_vars) = 0;\n+\n+  // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n+  // true on success, false on failure.\n+  virtual bool\n+  function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;\n+\n+  // Look up a named built-in function in the current backend implementation.\n+  // Returns NULL if no built-in function by that name exists.\n+  virtual Bfunction*\n+  lookup_builtin(const std::string&) = 0;\n+\n+  // Utility.\n+\n+  // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n+  // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n+  virtual void\n+  write_global_definitions(const std::vector<Btype*>& type_decls,\n+                           const std::vector<Bexpression*>& constant_decls,\n+                           const std::vector<Bfunction*>& function_decls,\n+                           const std::vector<Bvariable*>& variable_decls) = 0;\n+\n+  // Write SIZE bytes of export data from BYTES to the proper\n+  // section in the output object file.\n+  virtual void\n+  write_export_data(const char* bytes, unsigned int size) = 0;\n+};"}, {"sha": "24393a5d60de111956f9589a3b15e1903b0d70e1", "filename": "gcc/rust/rustfrontend/node.cc", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fnode.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,862 @@\n+#include \"rust-system.h\"\n+#include \"node.h\"\n+\n+\n+static int const indent_step = 4;\n+\n+void print_indent(int depth);\n+\n+#define PUSHBACK_LEN 4\t\n+\n+static char pushback[PUSHBACK_LEN];\t\n+static int verbose;\n+struct node* nodes = NULL;\n+int n_nodes;\n+\n+void\n+parser_init(int v)\n+{\n+    verbose = v;\n+    n_nodes = 0;\n+    memset(pushback, '\\0', PUSHBACK_LEN);\n+}\n+\n+// Note: this does nothing if the pushback queue is full. As long as\t\n+// there aren't more than PUSHBACK_LEN consecutive calls to push_back\t\n+// in an action, this shouldn't be a problem.\t\n+void push_back(char c)\n+{\t\n+    for (int i = 0; i < PUSHBACK_LEN; ++i) {\t\n+        if (pushback[i] == '\\0') {\t\n+            pushback[i] = c;\t\n+            break;\t\n+        }\t\n+    }\t\n+}\n+\n+Node\n+mk_node(ast_opcode_t op, int n, ...)\n+{\n+    unsigned sz = sizeof(struct node);\n+    struct node* nd = (struct node *)xmalloc(sz);\n+    nd->elems = (struct node **)xcalloc(n, sizeof(struct node*));\n+\n+    nd->prev = NULL;\t\n+    nd->next = nodes;\t\n+    if (nodes) {\n+        nodes->prev = nd;\n+    }\t\n+    nodes = nd;\t\n+\n+    nd->op = op;\n+    nd->value = NULL;\n+    nd->n_elems = n;\n+    \n+    va_list ap;\t\n+    va_start(ap, n);\n+    for (int i = 0; i < n; ++i)\n+    {\n+        struct node *nn = va_arg(ap, struct node *);\t\n+        nd->elems[i] = nn;\n+    }\n+    va_end(ap);\n+    \n+    n_nodes++;\t\n+    return nd;\t\n+}\n+\n+Node\n+mk_node_value(ast_opcode_t op, char* value, int n, ...)\n+{\n+    unsigned sz = sizeof(struct node);\n+    struct node* nd = (struct node *)xmalloc(sz);\n+    nd->elems = (struct node **)xcalloc(n, sizeof(struct node*));\n+\n+    nd->prev = NULL;\t\n+    nd->next = nodes;\t\n+    if (nodes) {\n+        nodes->prev = nd;\n+    }\t\n+    nodes = nd;\t\n+\n+    nd->op = op;\n+    nd->value = value;\n+    nd->n_elems = n;\n+    \n+    va_list ap;\t\n+    va_start(ap, n);\n+    for (int i = 0; i < n; ++i)\n+    {\n+        struct node *nn = va_arg(ap, struct node *);\t\n+        nd->elems[i] = nn;\n+    }\n+    va_end(ap);\n+    \n+    n_nodes++;\t\n+    return nd;\t\n+}\t\n+\n+Node\n+mk_atom(ast_opcode_t op, const char *value)\n+{\n+    return value == NULL ?\n+        mk_empty_atom(op) :\n+        mk_node_value(op, xstrdup(value), 0);\n+}\n+\n+Node\n+mk_empty_atom(ast_opcode_t op)\n+{\n+    return mk_node_value(op, NULL, 0);\n+}\n+\n+Node\n+mk_none()\n+{\n+    return mk_atom(NN_NONE, NULL);\n+}\t\n+\n+Node\n+ext_node(Node nd, int n, ...)\n+{\n+    int c = nd->n_elems + n;\t\n+    unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\t\n+\n+    if (nd->next) {\t\n+        nd->next->prev = nd->prev;\t\n+    }\t\n+    if (nd->prev) {\t\n+        nd->prev->next = nd->next;\t\n+    }\t\n+    nd = (struct node*)xrealloc(nd, sz);\n+    nd->prev = NULL;\t\n+    nd->next = nodes;\t\n+    nodes->prev = nd;\t\n+    nodes = nd;\n+\n+    va_list ap;\n+    va_start(ap, n);\n+    for (int i = 0; i < n; ++i) {\n+        struct node* nn = va_arg(ap, struct node *);\n+        nd->elems[nd->n_elems++] = nn;\t\n+    }\n+    va_end(ap);\n+    \n+    return nd;\t\n+}\t\n+\n+\n+void\n+print_indent(int depth) {\n+    while (depth) {\t\n+        if (depth-- % indent_step == 0) {\t\n+            printf(\"|\");\t\n+        } else {\t\n+            printf(\" \");\t\n+        }\t\n+    }\t\n+}\t\n+\n+void\n+print_node(Node n, int depth)\n+{\n+    print_indent(depth);\n+    \n+    if (n->n_elems == 0) {\n+        printf(\"%s -> %s\\n\", NODE_TYPE_STR(n), NODE_TYPE_VALUE_STR(n));\n+        return;\n+    }\n+    \n+    printf(\"(%s\\n\", NODE_TYPE_STR(n));\t\n+    for (int i = 0; i < n->n_elems; ++i) {\n+        print_node(n->elems[i], depth + indent_step);\n+    }\n+    print_indent(depth);\n+    printf(\")\\n\");\n+}\n+\n+const char*\n+get_ast_op_string(ast_opcode_t op)\n+{\n+    switch (op) {\n+    case NN_ViewItemExternFn:\n+\treturn \"NN_ViewItemExternFn\";\n+    case NN_TyParam:\n+\treturn \"NN_TyParam\";\n+    case NN_DeclLocal:\n+\treturn \"NN_DeclLocal\";\n+    case NN_DocComment:\n+\treturn \"NN_DocComment\";\n+    case NN_WherePredicate:\n+\treturn \"NN_WherePredicate\";\n+    case NN_ExprAddrOf:\n+\treturn \"NN_ExprAddrOf\";\n+    case NN_TypeMethod:\n+\treturn \"NN_TypeMethod\";\n+    case NN_crate:\n+\treturn \"NN_crate\";\n+    case NN_DefaultFieldInit:\n+\treturn \"NN_DefaultFieldInit\";\n+    case NN_ExprBinary:\n+\treturn \"NN_ExprBinary\";\n+    case NN_ExprAssignBitAnd:\n+\treturn \"NN_ExprAssignBitAnd\";\n+    case NN_TyFnDecl:\n+\treturn \"NN_TyFnDecl\";\n+    case NN_Public:\n+\treturn \"NN_Public\";\n+    case NN_Pats:\n+\treturn \"NN_Pats\";\n+    case NN_ViewPathSimple:\n+\treturn \"NN_ViewPathSimple\";\n+    case NN_TyParams:\n+\treturn \"NN_TyParams\";\n+    case NN_ExprIf:\n+\treturn \"NN_ExprIf\";\n+    case NN_Args:\n+\treturn \"NN_Args\";\n+    case NN_MetaItems:\n+\treturn \"NN_MetaItems\";\n+    case NN_AttrsAndVis:\n+\treturn \"NN_AttrsAndVis\";\n+    case NN_LitInteger:\n+\treturn \"NN_LitInteger\";\n+    case NN_ExprPath:\n+\treturn \"NN_ExprPath\";\n+    case NN_ExprField:\n+\treturn \"NN_ExprField\";\n+    case NN_TyDefault:\n+\treturn \"NN_TyDefault\";\n+    case NN_ExprAssignAdd:\n+\treturn \"NN_ExprAssignAdd\";\n+    case NN_ExprYield:\n+\treturn \"NN_ExprYield\";\n+    case NN_ImplItems:\n+\treturn \"NN_ImplItems\";\n+    case NN_TyRptr:\n+\treturn \"NN_TyRptr\";\n+    case NN_TySum:\n+\treturn \"NN_TySum\";\n+    case NN_ExprAssignDiv:\n+\treturn \"NN_ExprAssignDiv\";\n+    case NN_PatTup:\n+\treturn \"NN_PatTup\";\n+    case NN_ViewPath:\n+\treturn \"NN_ViewPath\";\n+    case NN_ItemImplNeg:\n+\treturn \"NN_ItemImplNeg\";\n+    case NN_ExprWhile:\n+\treturn \"NN_ExprWhile\";\n+    case NN_WherePredicates:\n+\treturn \"NN_WherePredicates\";\n+    case NN_FieldInits:\n+\treturn \"NN_FieldInits\";\n+    case NN_PatQualifiedPath:\n+\treturn \"NN_PatQualifiedPath\";\n+    case NN_ExprMatch:\n+\treturn \"NN_ExprMatch\";\n+    case NN_Binding:\n+\treturn \"NN_Binding\";\n+    case NN_ExprAssignBitOr:\n+\treturn \"NN_ExprAssignBitOr\";\n+    case NN_ItemImpl:\n+\treturn \"NN_ItemImpl\";\n+    case NN_ForeignItem:\n+\treturn \"NN_ForeignItem\";\n+    case NN_Arg:\n+\treturn \"NN_Arg\";\n+    case NN_Bindings:\n+\treturn \"NN_Bindings\";\n+    case NN_PatWild:\n+\treturn \"NN_PatWild\";\n+    case NN_ExprTypeAscr:\n+\treturn \"NN_ExprTypeAscr\";\n+    case NN_ExprBreak:\n+\treturn \"NN_ExprBreak\";\n+    case NN_ExprIfLet:\n+\treturn \"NN_ExprIfLet\";\n+    case NN_Inherited:\n+\treturn \"NN_Inherited\";\n+    case NN_TyPtr:\n+\treturn \"NN_TyPtr\";\n+    case NN_Arms:\n+\treturn \"NN_Arms\";\n+    case NN_LitByteStr:\n+\treturn \"NN_LitByteStr\";\n+    case NN_ItemConst:\n+\treturn \"NN_ItemConst\";\n+    case NN_ItemImplDefault:\n+\treturn \"NN_ItemImplDefault\";\n+    case NN_VecRepeat:\n+\treturn \"NN_VecRepeat\";\n+    case NN_TTTok:\n+\treturn \"NN_TTTok\";\n+    case NN_RetTy:\n+\treturn \"NN_RetTy\";\n+    case NN_TySumsAndBindings:\n+\treturn \"NN_TySumsAndBindings\";\n+    case NN_MetaList:\n+\treturn \"NN_MetaList\";\n+    case NN_ExprQualifiedPath:\n+\treturn \"NN_ExprQualifiedPath\";\n+    case NN_ExprAssignBitXor:\n+\treturn \"NN_ExprAssignBitXor\";\n+    case NN_Macro:\n+\treturn \"NN_Macro\";\n+    case NN_Super:\n+\treturn \"NN_Super\";\n+    case NN_ForeignFn:\n+\treturn \"NN_ForeignFn\";\n+    case NN_SelfLower:\n+\treturn \"NN_SelfLower\";\n+    case NN_ExprAssign:\n+\treturn \"NN_ExprAssign\";\n+    case NN_OuterAttrs:\n+\treturn \"NN_OuterAttrs\";\n+    case NN_ItemMacro:\n+\treturn \"NN_ItemMacro\";\n+    case NN_ForeignItems:\n+\treturn \"NN_ForeignItems\";\n+    case NN_Items:\n+\treturn \"NN_Items\";\n+    case NN_TraitMacroItem:\n+\treturn \"NN_TraitMacroItem\";\n+    case NN_ExprWhileLet:\n+\treturn \"NN_ExprWhileLet\";\n+    case NN_BindByRef:\n+\treturn \"NN_BindByRef\";\n+    case NN_ImplType:\n+\treturn \"NN_ImplType\";\n+    case NN_ExprLoop:\n+\treturn \"NN_ExprLoop\";\n+    case NN_SelfRegion:\n+\treturn \"NN_SelfRegion\";\n+    case NN_TyTup:\n+\treturn \"NN_TyTup\";\n+    case NN_PatUnit:\n+\treturn \"NN_PatUnit\";\n+    case NN_ForInType:\n+\treturn \"NN_ForInType\";\n+    case NN_FnDecl:\n+\treturn \"NN_FnDecl\";\n+    case NN_PatUniq:\n+\treturn \"NN_PatUniq\";\n+    case NN_UnsafeBlock:\n+\treturn \"NN_UnsafeBlock\";\n+    case NN_TyQualifiedPath:\n+\treturn \"NN_TyQualifiedPath\";\n+    case NN_TyBox:\n+\treturn \"NN_TyBox\";\n+    case NN_PatEnum:\n+\treturn \"NN_PatEnum\";\n+    case NN_TyClosure:\n+\treturn \"NN_TyClosure\";\n+    case NN_ForSized:\n+\treturn \"NN_ForSized\";\n+    case NN_ExprAssignSub:\n+\treturn \"NN_ExprAssignSub\";\n+    case NN_GenericValues:\n+\treturn \"NN_GenericValues\";\n+    case NN_TyPath:\n+\treturn \"NN_TyPath\";\n+    case NN_PatIdent:\n+\treturn \"NN_PatIdent\";\n+    case NN_ConstDefault:\n+\treturn \"NN_ConstDefault\";\n+    case NN_WhereClause:\n+\treturn \"NN_WhereClause\";\n+    case NN_MutImmutable:\n+\treturn \"NN_MutImmutable\";\n+    case NN_TyMacro:\n+\treturn \"NN_TyMacro\";\n+    case NN_ExprTupleIndex:\n+\treturn \"NN_ExprTupleIndex\";\n+    case NN_ImplMacroItem:\n+\treturn \"NN_ImplMacroItem\";\n+    case NN_ExprTry:\n+\treturn \"NN_ExprTry\";\n+    case NN_ExprCast:\n+\treturn \"NN_ExprCast\";\n+    case NN_Provided:\n+\treturn \"NN_Provided\";\n+    case NN_PatRegion:\n+\treturn \"NN_PatRegion\";\n+    case NN_ExprAssignShl:\n+\treturn \"NN_ExprAssignShl\";\n+    case NN_static_lifetime:\n+\treturn \"NN_static_lifetime\";\n+    case NN_MetaNameValue:\n+\treturn \"NN_MetaNameValue\";\n+    case NN_ExprStruct:\n+\treturn \"NN_ExprStruct\";\n+    case NN_ExprAssignShr:\n+\treturn \"NN_ExprAssignShr\";\n+    case NN_FieldInit:\n+\treturn \"NN_FieldInit\";\n+    case NN_Generics:\n+\treturn \"NN_Generics\";\n+    case NN_ExprForLoop:\n+\treturn \"NN_ExprForLoop\";\n+    case NN_Method:\n+\treturn \"NN_Method\";\n+    case NN_TySums:\n+\treturn \"NN_TySums\";\n+    case NN_ExprVec:\n+\treturn \"NN_ExprVec\";\n+    case NN_LitChar:\n+\treturn \"NN_LitChar\";\n+    case NN_PatFields:\n+\treturn \"NN_PatFields\";\n+    case NN_PatMac:\n+\treturn \"NN_PatMac\";\n+    case NN_InnerAttr:\n+\treturn \"NN_InnerAttr\";\n+    case NN_ViewPathGlob:\n+\treturn \"NN_ViewPathGlob\";\n+    case NN_ItemStatic:\n+\treturn \"NN_ItemStatic\";\n+    case NN_PatRange:\n+\treturn \"NN_PatRange\";\n+    case NN_LitBool:\n+\treturn \"NN_LitBool\";\n+    case NN_IdentsOrSelf:\n+\treturn \"NN_IdentsOrSelf\";\n+    case NN_ItemFn:\n+\treturn \"NN_ItemFn\";\n+    case NN_ExprCall:\n+\treturn \"NN_ExprCall\";\n+    case NN_Default:\n+\treturn \"NN_Default\";\n+    case NN_trait:\n+\treturn \"NN_trait\";\n+    case NN_Required:\n+\treturn \"NN_Required\";\n+    case NN_TyInfer:\n+\treturn \"NN_TyInfer\";\n+    case NN_ConstTraitItem:\n+\treturn \"NN_ConstTraitItem\";\n+    case NN_SelfStatic:\n+\treturn \"NN_SelfStatic\";\n+    case NN_ExprAssignRem:\n+\treturn \"NN_ExprAssignRem\";\n+    case NN_PatLit:\n+\treturn \"NN_PatLit\";\n+    case NN_PatField:\n+\treturn \"NN_PatField\";\n+    case NN_TyNil:\n+\treturn \"NN_TyNil\";\n+    case NN_EnumDef:\n+\treturn \"NN_EnumDef\";\n+    case NN_TypeTraitItem:\n+\treturn \"NN_TypeTraitItem\";\n+    case NN_PatVec:\n+\treturn \"NN_PatVec\";\n+    case NN_ident:\n+\treturn \"NN_ident\";\n+    case NN_MetaWord:\n+\treturn \"NN_MetaWord\";\n+    case NN_Lifetimes:\n+\treturn \"NN_Lifetimes\";\n+    case NN_LitStr:\n+\treturn \"NN_LitStr\";\n+    case NN_SelfPath:\n+\treturn \"NN_SelfPath\";\n+    case NN_bounds:\n+\treturn \"NN_bounds\";\n+    case NN_EnumDefs:\n+\treturn \"NN_EnumDefs\";\n+    case NN_ltbounds:\n+\treturn \"NN_ltbounds\";\n+    case NN_ViewItemUse:\n+\treturn \"NN_ViewItemUse\";\n+    case NN_ItemImplDefaultNeg:\n+\treturn \"NN_ItemImplDefaultNeg\";\n+    case NN_PatVecElts:\n+\treturn \"NN_PatVecElts\";\n+    case NN_TokenTrees:\n+\treturn \"NN_TokenTrees\";\n+    case NN_semicolon:\n+\treturn \"NN_semicolon\";\n+    case NN_ItemMod:\n+\treturn \"NN_ItemMod\";\n+    case NN_ExprUnary:\n+\treturn \"NN_ExprUnary\";\n+    case NN_ExprBlock:\n+\treturn \"NN_ExprBlock\";\n+    case NN_ItemUnsafeFn:\n+\treturn \"NN_ItemUnsafeFn\";\n+    case NN_EnumArgs:\n+\treturn \"NN_EnumArgs\";\n+    case NN_ViewItemExternCrate:\n+\treturn \"NN_ViewItemExternCrate\";\n+    case NN_lifetime:\n+\treturn \"NN_lifetime\";\n+    case NN_StructFields:\n+\treturn \"NN_StructFields\";\n+    case NN_ExprRet:\n+\treturn \"NN_ExprRet\";\n+    case NN_ExprAssignMul:\n+\treturn \"NN_ExprAssignMul\";\n+    case NN_ItemStruct:\n+\treturn \"NN_ItemStruct\";\n+    case NN_LitFloat:\n+\treturn \"NN_LitFloat\";\n+    case NN_TyTypeof:\n+\treturn \"NN_TyTypeof\";\n+    case NN_exprs:\n+\treturn \"NN_exprs\";\n+    case NN_InnerAttrs:\n+\treturn \"NN_InnerAttrs\";\n+    case NN_PolyBound:\n+\treturn \"NN_PolyBound\";\n+    case NN_TyVec:\n+\treturn \"NN_TyVec\";\n+    case NN_ArmNonblock:\n+\treturn \"NN_ArmNonblock\";\n+    case NN_ViewPathList:\n+\treturn \"NN_ViewPathList\";\n+    case NN_TTDelim:\n+\treturn \"NN_TTDelim\";\n+    case NN_ItemForeignMod:\n+\treturn \"NN_ItemForeignMod\";\n+    case NN_PatTupElts:\n+\treturn \"NN_PatTupElts\";\n+    case NN_ExprMac:\n+\treturn \"NN_ExprMac\";\n+    case NN_ExprParen:\n+\treturn \"NN_ExprParen\";\n+    case NN_StaticItem:\n+\treturn \"NN_StaticItem\";\n+    case NN_ItemTrait:\n+\treturn \"NN_ItemTrait\";\n+    case NN_ExprRange:\n+\treturn \"NN_ExprRange\";\n+    case NN_ItemUnion:\n+\treturn \"NN_ItemUnion\";\n+    case NN_ExprIndex:\n+\treturn \"NN_ExprIndex\";\n+    case NN_ArmBlock:\n+\treturn \"NN_ArmBlock\";\n+    case NN_DefaultUnsafe:\n+\treturn \"NN_DefaultUnsafe\";\n+    case NN_PatStruct:\n+\treturn \"NN_PatStruct\";\n+    case NN_MutMutable:\n+\treturn \"NN_MutMutable\";\n+    case NN_ExprLit:\n+\treturn \"NN_ExprLit\";\n+    case NN_TyFixedLengthVec:\n+\treturn \"NN_TyFixedLengthVec\";\n+    case NN_ImplConst:\n+\treturn \"NN_ImplConst\";\n+    case NN_InferrableParams:\n+\treturn \"NN_InferrableParams\";\n+    case NN_Item:\n+\treturn \"NN_Item\";\n+    case NN_TraitItems:\n+\treturn \"NN_TraitItems\";\n+    case NN_MacroExpr:\n+\treturn \"NN_MacroExpr\";\n+    case NN_LitByte:\n+\treturn \"NN_LitByte\";\n+    case NN_InferrableParam:\n+\treturn \"NN_InferrableParam\";\n+    case NN_BindByValue:\n+\treturn \"NN_BindByValue\";\n+    case NN_StructField:\n+\treturn \"NN_StructField\";\n+    case NN_Unsafe:\n+\treturn \"NN_Unsafe\";\n+    case NN_ViewPathListEmpty:\n+\treturn \"NN_ViewPathListEmpty\";\n+    case NN_ExprFnBlock:\n+\treturn \"NN_ExprFnBlock\";\n+    case NN_ExprAgain:\n+\treturn \"NN_ExprAgain\";\n+    case NN_components:\n+\treturn \"NN_components\";\n+    case NN_ItemEnum:\n+\treturn \"NN_ItemEnum\";\n+    case NN_ExprBox:\n+\treturn \"NN_ExprBox\";\n+    case NN_ItemTy:\n+\treturn \"NN_ItemTy\";\n+    case NN_NONE:\n+\treturn \"NN_NONE\";\n+    case NN_SHL:\n+\treturn \"NN_SHL\";\n+    case NN_SHR:\n+\treturn \"NN_SHR\";\n+    case NN_LE:\n+\treturn \"NN_LE\";\n+    case NN_EQEQ:\n+\treturn \"NN_EQEQ\";\n+    case NN_NE:\n+\treturn \"NN_NE\";\n+    case NN_GE:\n+\treturn \"NN_GE\";\n+    case NN_ANDAND:\n+\treturn \"NN_ANDAND\";\n+    case NN_OROR:\n+\treturn \"NN_OROR\";\n+    case NN_LARROW:\n+\treturn \"NN_LARROW\";\n+    case NN_SHLEQ:\n+\treturn \"NN_SHLEQ\";\n+    case NN_SHREQ:\n+\treturn \"NN_SHREQ\";\n+    case NN_MINUSEQ:\n+\treturn \"NN_MINUSEQ\";\n+    case NN_ANDEQ:\n+\treturn \"NN_ANDEQ\";\n+    case NN_OREQ:\n+\treturn \"NN_OREQ\";\n+    case NN_PLUSEQ:\n+\treturn \"NN_PLUSEQ\";\n+    case NN_STAREQ:\n+\treturn \"NN_STAREQ\";\n+    case NN_SLASHEQ:\n+\treturn \"NN_SLASHEQ\";\n+    case NN_CARETEQ:\n+\treturn \"NN_CARETEQ\";\n+    case NN_PERCENTEQ:\n+\treturn \"NN_PERCENTEQ\";\n+    case NN_DOTDOT:\n+\treturn \"NN_DOTDOT\";\n+    case NN_DOTDOTDOT:\n+\treturn \"NN_DOTDOTDOT\";\n+    case NN_MOD_SEP:\n+\treturn \"NN_MOD_SEP\";\n+    case NN_RARROW:\n+\treturn \"NN_RARROW\";\n+    case NN_FAT_ARROW:\n+\treturn \"NN_FAT_ARROW\";\n+    case NN_LIT_BYTE:\n+\treturn \"NN_LIT_BYTE\";\n+    case NN_LIT_CHAR:\n+\treturn \"NN_LIT_CHAR\";\n+    case NN_LIT_INTEGER:\n+\treturn \"NN_LIT_INTEGER\";\n+    case NN_LIT_FLOAT:\n+\treturn \"NN_LIT_FLOAT\";\n+    case NN_LIT_STR:\n+\treturn \"NN_LIT_STR\";\n+    case NN_LIT_STR_RAW:\n+\treturn \"NN_LIT_STR_RAW\";\n+    case NN_LIT_BYTE_STR:\n+\treturn \"NN_LIT_BYTE_STR\";\n+    case NN_LIT_BYTE_STR_RAW:\n+\treturn \"NN_LIT_BYTE_STR_RAW\";\n+    case NN_IDENT:\n+\treturn \"NN_IDENT\";\n+    case NN_UNDERSCORE:\n+\treturn \"NN_UNDERSCORE\";\n+    case NN_LIFETIME:\n+\treturn \"NN_LIFETIME\";\n+    case NN_SELF:\n+\treturn \"NN_SELF\";\n+    case NN_STATIC:\n+\treturn \"NN_STATIC\";\n+    case NN_ABSTRACT:\n+\treturn \"NN_ABSTRACT\";\n+    case NN_ALIGNOF:\n+\treturn \"NN_ALIGNOF\";\n+    case NN_AS:\n+\treturn \"NN_AS\";\n+    case NN_BECOME:\n+\treturn \"NN_BECOME\";\n+    case NN_BREAK:\n+\treturn \"NN_BREAK\";\n+    case NN_CATCH:\n+\treturn \"NN_CATCH\";\n+    case NN_CRATE:\n+\treturn \"NN_CRATE\";\n+    case NN_DEFAULT:\n+\treturn \"NN_DEFAULT\";\n+    case NN_DO:\n+\treturn \"NN_DO\";\n+    case NN_ELSE:\n+\treturn \"NN_ELSE\";\n+    case NN_ENUM:\n+\treturn \"NN_ENUM\";\n+    case NN_EXTERN:\n+\treturn \"NN_EXTERN\";\n+    case NN_XFALSE:\n+\treturn \"NN_XFALSE\";\n+    case NN_FINAL:\n+\treturn \"NN_FINAL\";\n+    case NN_FN:\n+\treturn \"NN_FN\";\n+    case NN_FOR:\n+\treturn \"NN_FOR\";\n+    case NN_IF:\n+\treturn \"NN_IF\";\n+    case NN_IMPL:\n+\treturn \"NN_IMPL\";\n+    case NN_IN:\n+\treturn \"NN_IN\";\n+    case NN_LET:\n+\treturn \"NN_LET\";\n+    case NN_LOOP:\n+\treturn \"NN_LOOP\";\n+    case NN_MACRO:\n+\treturn \"NN_MACRO\";\n+    case NN_MATCH:\n+\treturn \"NN_MATCH\";\n+    case NN_MOD:\n+\treturn \"NN_MOD\";\n+    case NN_MOVE:\n+\treturn \"NN_MOVE\";\n+    case NN_MUT:\n+\treturn \"NN_MUT\";\n+    case NN_OFFSETOF:\n+\treturn \"NN_OFFSETOF\";\n+    case NN_OVERRIDE:\n+\treturn \"NN_OVERRIDE\";\n+    case NN_PRIV:\n+\treturn \"NN_PRIV\";\n+    case NN_PUB:\n+\treturn \"NN_PUB\";\n+    case NN_PURE:\n+\treturn \"NN_PURE\";\n+    case NN_REF:\n+\treturn \"NN_REF\";\n+    case NN_RETURN:\n+\treturn \"NN_RETURN\";\n+    case NN_STRUCT:\n+\treturn \"NN_STRUCT\";\n+    case NN_SIZEOF:\n+\treturn \"NN_SIZEOF\";\n+    case NN_SUPER:\n+\treturn \"NN_SUPER\";\n+    case NN_XTRUE:\n+\treturn \"NN_XTRUE\";\n+    case NN_TRAIT:\n+\treturn \"NN_TRAIT\";\n+    case NN_TYPE:\n+\treturn \"NN_TYPE\";\n+    case NN_UNION:\n+\treturn \"NN_UNION\";\n+    case NN_UNSAFE:\n+\treturn \"NN_UNSAFE\";\n+    case NN_UNSIZED:\n+\treturn \"NN_UNSIZED\";\n+    case NN_USE:\n+\treturn \"NN_USE\";\n+    case NN_VIRTUAL:\n+\treturn \"NN_VIRTUAL\";\n+    case NN_WHILE:\n+\treturn \"NN_WHILE\";\n+    case NN_YIELD:\n+\treturn \"NN_YIELD\";\n+    case NN_CONTINUE:\n+\treturn \"NN_CONTINUE\";\n+    case NN_PROC:\n+\treturn \"NN_PROC\";\n+    case NN_BOX:\n+\treturn \"NN_BOX\";\n+    case NN_CONST:\n+\treturn \"NN_CONST\";\n+    case NN_WHERE:\n+\treturn \"NN_WHERE\";\n+    case NN_TYPEOF:\n+\treturn \"NN_TYPEOF\";\n+    case NN_INNER_DOC_COMMENT:\n+\treturn \"NN_INNER_DOC_COMMENT\";\n+    case NN_OUTER_DOC_COMMENT:\n+\treturn \"NN_OUTER_DOC_COMMENT\";\n+    case NN_SHEBANG:\n+\treturn \"NN_SHEBANG\";\n+    case NN_STATIC_LIFETIME:\n+\treturn \"NN_STATIC_LIFETIME\";\n+    case NN_SEMI_COLON:\n+\treturn \"NN_SEMI_COLON\";\n+    case NN_COMMA:\n+\treturn \"NN_COMMA\";\n+    case NN_SINGLE_DOT:\n+\treturn \"NN_SINGLE_DOT\";\n+    case NN_AT:\n+\treturn \"NN_AT\";\n+    case NN_HASH:\n+\treturn \"NN_HASH\";\n+    case NN_TILDA:\n+\treturn \"NN_TILDA\";\n+    case NN_COLON:\n+\treturn \"NN_COLON\";\n+    case NN_DOLLAR:\n+\treturn \"NN_DOLLAR\";\n+    case NN_EQUALS:\n+\treturn \"NN_EQUALS\";\n+    case NN_QUESTION:\n+\treturn \"NN_QUESTION\";\n+    case NN_EXCLAIM:\n+\treturn \"NN_EXCLAIM\";\n+    case NN_LESS_THAN:\n+\treturn \"NN_LESS_THAN\";\n+    case NN_GREATER_THAN:\n+\treturn \"NN_GREATER_THAN\";\n+    case NN_MINUS:\n+\treturn \"NN_MINUS\";\n+    case NN_AMPERSAND:\n+\treturn \"NN_AMPERSAND\";\n+    case NN_PIPE:\n+\treturn \"NN_PIPE\";\n+    case NN_PLUS:\n+\treturn \"NN_PLUS\";\n+    case NN_MULT:\n+\treturn \"NN_MULT\";\n+    case NN_DIVIDE:\n+\treturn \"NN_DIVIDE\";\n+    case NN_HAT:\n+\treturn \"NN_HAT\";\n+    case NN_PERCENTAGE:\n+\treturn \"NN_PERCENTAGE\";\n+    case NN_GLOBAL:\n+        return \"NN_GLOBAL\";\n+    case NN_stmts:\n+        return \"NN_stmts\";\n+    case NN_BiOr:\n+        return \"NN_BiOr\";\n+    case NN_BiAnd:\n+        return \"NN_BiAnd\";\n+    case NN_BiEq:\n+        return \"NN_BiEq\";\n+    case NN_BiNe:\n+        return \"NN_BiNe\";\n+    case NN_BiLt:\n+        return \"NN_BiLt\";\n+    case NN_BiGt:\n+        return \"NN_BiGt\";\n+    case NN_BiLe:\n+        return \"NN_BiLe\";\n+    case NN_BiGe:\n+        return \"NN_BiGe\";\n+    case NN_BiBitOr:\n+        return \"NN_BiBitOr\";\n+    case NN_BiBitXor:\n+        return \"NN_BiBitXor\";\n+    case NN_BiBitAnd:\n+        return \"NN_BiBitAnd\";\n+    case NN_BiShl:\n+        return \"NN_BiShl\";\n+    case NN_BiShr:\n+        return \"NN_BiShr\";\n+    case NN_BiAdd:\n+        return \"NN_BiAdd\";\n+    case NN_BiSub:\n+        return \"NN_BiSub\";\n+    case NN_BiMul:\n+        return \"NN_BiMul\";\n+    case NN_BiDiv:\n+        return \"NN_BiDiv\";\n+    case NN_BiRem:\n+        return \"NN_BiRem\";\n+    case NN_UnNeg:\n+        return \"NN_UnNeg\";\n+    case NN_UnNot:\n+        return \"NN_UnNot\";\n+    case NN_UnDeref:\n+        return \"NN_UnDeref\";\n+    }\n+    return NULL;\n+}"}, {"sha": "7d83c2d9d7bcf4d47266c6d08be2d362b9d4d092", "filename": "gcc/rust/rustfrontend/node.h", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fnode.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,378 @@\n+#pragma once\n+\n+#include <string>\n+\n+typedef enum {\n+    NN_ViewItemExternFn,\n+    NN_TyParam,\n+    NN_DeclLocal,\n+    NN_DocComment,\n+    NN_WherePredicate,\n+    NN_ExprAddrOf,\n+    NN_TypeMethod,\n+    NN_crate,\n+    NN_DefaultFieldInit,\n+    NN_ExprBinary,\n+    NN_ExprAssignBitAnd,\n+    NN_TyFnDecl,\n+    NN_Public,\n+    NN_Pats,\n+    NN_ViewPathSimple,\n+    NN_TyParams,\n+    NN_ExprIf,\n+    NN_Args,\n+    NN_MetaItems,\n+    NN_AttrsAndVis,\n+    NN_LitInteger,\n+    NN_ExprPath,\n+    NN_ExprField,\n+    NN_TyDefault,\n+    NN_ExprAssignAdd,\n+    NN_ExprYield,\n+    NN_ImplItems,\n+    NN_TyRptr,\n+    NN_TySum,\n+    NN_ExprAssignDiv,\n+    NN_PatTup,\n+    NN_ViewPath,\n+    NN_ItemImplNeg,\n+    NN_ExprWhile,\n+    NN_WherePredicates,\n+    NN_FieldInits,\n+    NN_PatQualifiedPath,\n+    NN_ExprMatch,\n+    NN_Binding,\n+    NN_ExprAssignBitOr,\n+    NN_ItemImpl,\n+    NN_ForeignItem,\n+    NN_Arg,\n+    NN_Bindings,\n+    NN_PatWild,\n+    NN_ExprTypeAscr,\n+    NN_ExprBreak,\n+    NN_ExprIfLet,\n+    NN_Inherited,\n+    NN_TyPtr,\n+    NN_Arms,\n+    NN_LitByteStr,\n+    NN_ItemConst,\n+    NN_ItemImplDefault,\n+    NN_VecRepeat,\n+    NN_TTTok,\n+    NN_RetTy,\n+    NN_TySumsAndBindings,\n+    NN_MetaList,\n+    NN_ExprQualifiedPath,\n+    NN_ExprAssignBitXor,\n+    NN_Macro,\n+    NN_Super,\n+    NN_ForeignFn,\n+    NN_SelfLower,\n+    NN_ExprAssign,\n+    NN_OuterAttrs,\n+    NN_ItemMacro,\n+    NN_ForeignItems,\n+    NN_Items,\n+    NN_TraitMacroItem,\n+    NN_ExprWhileLet,\n+    NN_BindByRef,\n+    NN_ImplType,\n+    NN_ExprLoop,\n+    NN_SelfRegion,\n+    NN_TyTup,\n+    NN_PatUnit,\n+    NN_ForInType,\n+    NN_FnDecl,\n+    NN_PatUniq,\n+    NN_UnsafeBlock,\n+    NN_TyQualifiedPath,\n+    NN_TyBox,\n+    NN_PatEnum,\n+    NN_TyClosure,\n+    NN_ForSized,\n+    NN_ExprAssignSub,\n+    NN_GenericValues,\n+    NN_TyPath,\n+    NN_PatIdent,\n+    NN_ConstDefault,\n+    NN_WhereClause,\n+    NN_MutImmutable,\n+    NN_TyMacro,\n+    NN_ExprTupleIndex,\n+    NN_ImplMacroItem,\n+    NN_ExprTry,\n+    NN_ExprCast,\n+    NN_Provided,\n+    NN_PatRegion,\n+    NN_ExprAssignShl,\n+    NN_static_lifetime,\n+    NN_MetaNameValue,\n+    NN_ExprStruct,\n+    NN_ExprAssignShr,\n+    NN_FieldInit,\n+    NN_Generics,\n+    NN_ExprForLoop,\n+    NN_Method,\n+    NN_TySums,\n+    NN_ExprVec,\n+    NN_LitChar,\n+    NN_PatFields,\n+    NN_PatMac,\n+    NN_InnerAttr,\n+    NN_ViewPathGlob,\n+    NN_ItemStatic,\n+    NN_PatRange,\n+    NN_LitBool,\n+    NN_IdentsOrSelf,\n+    NN_ItemFn,\n+    NN_ExprCall,\n+    NN_Default,\n+    NN_trait,\n+    NN_Required,\n+    NN_TyInfer,\n+    NN_ConstTraitItem,\n+    NN_SelfStatic,\n+    NN_ExprAssignRem,\n+    NN_PatLit,\n+    NN_PatField,\n+    NN_TyNil,\n+    NN_EnumDef,\n+    NN_TypeTraitItem,\n+    NN_PatVec,\n+    NN_ident,\n+    NN_MetaWord,\n+    NN_Lifetimes,\n+    NN_LitStr,\n+    NN_SelfPath,\n+    NN_bounds,\n+    NN_EnumDefs,\n+    NN_ltbounds,\n+    NN_ViewItemUse,\n+    NN_ItemImplDefaultNeg,\n+    NN_PatVecElts,\n+    NN_TokenTrees,\n+    NN_semicolon,\n+    NN_ItemMod,\n+    NN_ExprUnary,\n+    NN_ExprBlock,\n+    NN_ItemUnsafeFn,\n+    NN_EnumArgs,\n+    NN_ViewItemExternCrate,\n+    NN_lifetime,\n+    NN_StructFields,\n+    NN_ExprRet,\n+    NN_ExprAssignMul,\n+    NN_ItemStruct,\n+    NN_LitFloat,\n+    NN_TyTypeof,\n+    NN_exprs,\n+    NN_InnerAttrs,\n+    NN_PolyBound,\n+    NN_TyVec,\n+    NN_ArmNonblock,\n+    NN_ViewPathList,\n+    NN_TTDelim,\n+    NN_ItemForeignMod,\n+    NN_PatTupElts,\n+    NN_ExprMac,\n+    NN_ExprParen,\n+    NN_StaticItem,\n+    NN_ItemTrait,\n+    NN_ExprRange,\n+    NN_ItemUnion,\n+    NN_ExprIndex,\n+    NN_ArmBlock,\n+    NN_DefaultUnsafe,\n+    NN_PatStruct,\n+    NN_MutMutable,\n+    NN_ExprLit,\n+    NN_TyFixedLengthVec,\n+    NN_ImplConst,\n+    NN_InferrableParams,\n+    NN_Item,\n+    NN_TraitItems,\n+    NN_MacroExpr,\n+    NN_LitByte,\n+    NN_InferrableParam,\n+    NN_BindByValue,\n+    NN_StructField,\n+    NN_Unsafe,\n+    NN_ViewPathListEmpty,\n+    NN_ExprFnBlock,\n+    NN_ExprAgain,\n+    NN_components,\n+    NN_ItemEnum,\n+    NN_ExprBox,\n+    NN_ItemTy,\n+    NN_NONE,\n+    NN_SHL,\n+    NN_SHR,\n+    NN_LE,\n+    NN_EQEQ,\n+    NN_NE,\n+    NN_GE,\n+    NN_ANDAND,\n+    NN_OROR,\n+    NN_LARROW,\n+    NN_SHLEQ,\n+    NN_SHREQ,\n+    NN_MINUSEQ,\n+    NN_ANDEQ,\n+    NN_OREQ,\n+    NN_PLUSEQ,\n+    NN_STAREQ,\n+    NN_SLASHEQ,\n+    NN_CARETEQ,\n+    NN_PERCENTEQ,\n+    NN_DOTDOT,\n+    NN_DOTDOTDOT,\n+    NN_MOD_SEP,\n+    NN_RARROW,\n+    NN_FAT_ARROW,\n+    NN_LIT_BYTE,\n+    NN_LIT_CHAR,\n+    NN_LIT_INTEGER,\n+    NN_LIT_FLOAT,\n+    NN_LIT_STR,\n+    NN_LIT_STR_RAW,\n+    NN_LIT_BYTE_STR,\n+    NN_LIT_BYTE_STR_RAW,\n+    NN_IDENT,\n+    NN_UNDERSCORE,\n+    NN_LIFETIME,\n+    NN_SELF,\n+    NN_STATIC,\n+    NN_ABSTRACT,\n+    NN_ALIGNOF,\n+    NN_AS,\n+    NN_BECOME,\n+    NN_BREAK,\n+    NN_CATCH,\n+    NN_CRATE,\n+    NN_DEFAULT,\n+    NN_DO,\n+    NN_ELSE,\n+    NN_ENUM,\n+    NN_EXTERN,\n+    NN_XFALSE,\n+    NN_FINAL,\n+    NN_FN,\n+    NN_FOR,\n+    NN_IF,\n+    NN_IMPL,\n+    NN_IN,\n+    NN_LET,\n+    NN_LOOP,\n+    NN_MACRO,\n+    NN_MATCH,\n+    NN_MOD,\n+    NN_MOVE,\n+    NN_MUT,\n+    NN_OFFSETOF,\n+    NN_OVERRIDE,\n+    NN_PRIV,\n+    NN_PUB,\n+    NN_PURE,\n+    NN_REF,\n+    NN_RETURN,\n+    NN_STRUCT,\n+    NN_SIZEOF,\n+    NN_SUPER,\n+    NN_XTRUE,\n+    NN_TRAIT,\n+    NN_TYPE,\n+    NN_UNION,\n+    NN_UNSAFE,\n+    NN_UNSIZED,\n+    NN_USE,\n+    NN_VIRTUAL,\n+    NN_WHILE,\n+    NN_YIELD,\n+    NN_CONTINUE,\n+    NN_PROC,\n+    NN_BOX,\n+    NN_CONST,\n+    NN_WHERE,\n+    NN_TYPEOF,\n+    NN_INNER_DOC_COMMENT,\n+    NN_OUTER_DOC_COMMENT,\n+    NN_SHEBANG,\n+    NN_STATIC_LIFETIME,\n+    NN_SEMI_COLON,\n+    NN_COMMA,\n+    NN_SINGLE_DOT,\n+    NN_AT,\n+    NN_HASH,\n+    NN_TILDA,\n+    NN_COLON,\n+    NN_DOLLAR,\n+    NN_EQUALS,\n+    NN_QUESTION,\n+    NN_EXCLAIM,\n+    NN_LESS_THAN,\n+    NN_GREATER_THAN,\n+    NN_MINUS,\n+    NN_AMPERSAND,\n+    NN_PIPE,\n+    NN_PLUS,\n+    NN_MULT,\n+    NN_DIVIDE,\n+    NN_HAT,\n+    NN_PERCENTAGE,\n+    NN_GLOBAL,\n+    NN_stmts,\n+\n+    NN_BiOr,\n+    NN_BiAnd,\n+    NN_BiEq,\n+    NN_BiNe,\n+    NN_BiLt,\n+    NN_BiGt,\n+    NN_BiLe,\n+    NN_BiGe,\n+    NN_BiBitOr,\n+    NN_BiBitXor,\n+    NN_BiBitAnd,\n+    NN_BiShl,\n+    NN_BiShr,\n+    NN_BiAdd,\n+    NN_BiSub,\n+    NN_BiMul,\n+    NN_BiDiv,\n+    NN_BiRem,\n+    NN_UnNeg,\n+    NN_UnNot,\n+    NN_UnDeref\n+} ast_opcode_t;\n+\n+typedef struct node {\n+    ast_opcode_t op;\n+    char* value;\n+    \n+    struct node* next;\n+    struct node* prev;\n+    \n+    int n_elems;\n+    struct node** elems;\n+} *Node;\n+\n+#define NODE_TYPE(x_)               x_->op\n+#define NODE_TYPE_STR(x_)           get_ast_op_string(x_->op)\n+#define NODE_TYPE_VALUE_STR(x_)     (n->value == NULL ? \"NULL\" : n->value)\n+#define NODE_CHAIN(x_)              (x_->next)\n+#define NODE_RCHAIN(x_)             (x_->prev)\n+\n+extern Node mk_node(ast_opcode_t, int n, ...);\n+extern Node mk_node_value(ast_opcode_t, char*, int n, ...);\n+extern Node mk_atom(ast_opcode_t, const char *value);\n+extern Node mk_empty_atom(ast_opcode_t);\n+extern Node mk_none();\n+extern Node ext_node(struct node *nd, int n, ...);\n+extern void print_node(Node n, int depth);\n+extern const char* get_ast_op_string(ast_opcode_t);\n+\n+extern void push_back(char);\n+extern void parser_init(int verbose);\n+\n+extern int n_nodes;\n+extern node* nodes;"}, {"sha": "2ada147b4ad9f79832f23a06ab4f15e22ffc9fbd", "filename": "gcc/rust/rustfrontend/operator.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Foperator.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,55 @@\n+#pragma once\n+\n+enum Operator\n+{\n+  OPERATOR_INVALID,\n+  OPERATOR_OROR,\t// ||\n+  OPERATOR_ANDAND,\t// &&\n+  OPERATOR_EQEQ,\t// ==\n+  OPERATOR_NOTEQ,\t// !=\n+  OPERATOR_LT,\t\t// <\n+  OPERATOR_LE,\t\t// <=\n+  OPERATOR_GT,\t\t// >\n+  OPERATOR_GE,\t\t// >=\n+  OPERATOR_PLUS,\t// +\n+  OPERATOR_MINUS,\t// -\n+  OPERATOR_OR,\t\t// |\n+  OPERATOR_XOR,\t\t// ^\n+  OPERATOR_MULT,\t// *\n+  OPERATOR_DIV,\t\t// /\n+  OPERATOR_MOD,\t\t// %\n+  OPERATOR_LSHIFT,\t// <<\n+  OPERATOR_RSHIFT,\t// >>\n+  OPERATOR_AND,\t\t// &\n+  OPERATOR_NOT,\t\t// !\n+  OPERATOR_BITCLEAR,\t// &^\n+  OPERATOR_CHANOP,\t// <-\n+\n+  OPERATOR_EQ,\t\t// =\n+  OPERATOR_PLUSEQ,\t// +=\n+  OPERATOR_MINUSEQ,\t// -=\n+  OPERATOR_OREQ,\t// |=\n+  OPERATOR_XOREQ,\t// ^=\n+  OPERATOR_MULTEQ,\t// *=\n+  OPERATOR_DIVEQ,\t// /=\n+  OPERATOR_MODEQ,\t// %=\n+  OPERATOR_LSHIFTEQ,\t// <<=\n+  OPERATOR_RSHIFTEQ,\t// >>=\n+  OPERATOR_ANDEQ,\t// &=\n+  OPERATOR_BITCLEAREQ,\t// &^=\n+  OPERATOR_PLUSPLUS,\t// ++\n+  OPERATOR_MINUSMINUS,\t// --\n+\n+  OPERATOR_COLON,\t// :\n+  OPERATOR_COLONEQ,\t// :=\n+  OPERATOR_SEMICOLON,\t// ;\n+  OPERATOR_DOT,\t\t// .\n+  OPERATOR_ELLIPSIS,\t// ...\n+  OPERATOR_COMMA,\t// ,\n+  OPERATOR_LPAREN,\t// (\n+  OPERATOR_RPAREN,\t// )\n+  OPERATOR_LCURLY,\t// {\n+  OPERATOR_RCURLY,\t// }\n+  OPERATOR_LSQUARE,\t// [\n+  OPERATOR_RSQUARE\t// ]\n+};"}, {"sha": "76bbed3c5fc510bd6c62813947d58b28a4ea345a", "filename": "gcc/rust/rustfrontend/rs-lexer.l", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-lexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-lexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frs-lexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,350 @@\n+%{\n+#include \"rs-parser.h\"\n+\n+static int num_hashes;\t\n+static int end_hashes;\t\n+static int saw_non_hash;\n+%}\n+\n+%option noyywrap\n+%option stack\t\n+%option yylineno\t\n+\n+%x str\t\n+%x rawstr\t\n+%x rawstr_esc_begin\t\n+%x rawstr_esc_body\t\n+%x rawstr_esc_end\t\n+%x byte\t\n+%x bytestr\t\n+%x rawbytestr\t\n+%x rawbytestr_nohash\t\n+%x pound\t\n+%x shebang_or_attr\t\n+%x ltorchar\t\n+%x linecomment\t\n+%x doc_line\t\n+%x blockcomment\t\n+%x doc_block\t\n+%x suffix\t\n+\n+ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n+\n+%%\n+\n+<suffix>{ident}            { BEGIN(INITIAL); }\t\n+<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\t\n+\n+[ \\n\\t\\r]             { }\t\n+\n+\\xef\\xbb\\xbf {\t\n+  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\t\n+  if (yyget_lineno() != 1) {\t\n+    return -1;\t\n+  }\t\n+}\t\n+\n+\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\t\n+<doc_line>\\n          { BEGIN(INITIAL);\t\n+                        yyleng--;\t\n+                        yytext[yyleng] = 0;\t\n+                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\t\n+                      }\t\n+<doc_line>[^\\n]*      { yymore(); }\t\n+\n+\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\t\n+<linecomment>\\n       { BEGIN(INITIAL); }\t\n+<linecomment>[^\\n]*   { }\t\n+\n+\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\t\n+<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\t\n+<doc_block>\\*\\/       {\t\n+    yy_pop_state();\t\n+    if (yy_top_state() == doc_block) {\t\n+        yymore();\t\n+    } else {\t\n+        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\t\n+    }\t\n+}\t\n+<doc_block>(.|\\n)     { yymore(); }\t\n+\n+\\/\\*                  { yy_push_state(blockcomment); }\t\n+<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\t\n+<blockcomment>\\*\\/    { yy_pop_state(); }\t\n+<blockcomment>(.|\\n)   { }\t\n+\n+_        { return UNDERSCORE; }\t\n+abstract { return ABSTRACT; }\t\n+alignof  { return ALIGNOF; }\t\n+as       { return AS; }\t\n+become   { return BECOME; }\t\n+box      { return BOX; }\t\n+break    { return BREAK; }\t\n+catch    { return CATCH; }\t\n+const    { return CONST; }\t\n+continue { return CONTINUE; }\t\n+crate    { return CRATE; }\t\n+default  { return DEFAULT; }\t\n+do       { return DO; }\t\n+else     { return ELSE; }\t\n+enum     { return ENUM; }\t\n+extern   { return EXTERN; }\t\n+false    { return XFALSE; }\t\n+final    { return FINAL; }\t\n+fn       { return FN; }\t\n+for      { return FOR; }\t\n+if       { return IF; }\t\n+impl     { return IMPL; }\t\n+in       { return IN; }\t\n+let      { return LET; }\t\n+loop     { return LOOP; }\t\n+macro    { return MACRO; }\t\n+match    { return MATCH; }\t\n+mod      { return MOD; }\t\n+move     { return MOVE; }\t\n+mut      { return MUT; }\t\n+offsetof { return OFFSETOF; }\t\n+override { return OVERRIDE; }\t\n+priv     { return PRIV; }\t\n+proc     { return PROC; }\t\n+pure     { return PURE; }\t\n+pub      { return PUB; }\t\n+ref      { return REF; }\t\n+return   { return RETURN; }\t\n+self     { return SELF; }\t\n+sizeof   { return SIZEOF; }\t\n+static   { return STATIC; }\t\n+struct   { return STRUCT; }\t\n+super    { return SUPER; }\n+trait    { return TRAIT; }\n+true     { return XTRUE; }\n+type     { return TYPE; }\t\n+typeof   { return TYPEOF; }\t\n+union    { return UNION; }\t\n+unsafe   { return UNSAFE; }\t\n+unsized  { return UNSIZED; }\t\n+use      { return USE; }\t\n+virtual  { return VIRTUAL; }\t\n+where    { return WHERE; }\t\n+while    { return WHILE; }\t\n+yield    { return YIELD; }\t\n+\n+{ident}  { return IDENT; }\t\n+\n+0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\t\n+0o[0-7_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\t\n+0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\t\n+[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\t\n+[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\t\n+\n+[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\t\n+[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\t\n+\n+;      { return ';'; }\t\n+,      { return ','; }\t\n+\\.\\.\\. { return DOTDOTDOT; }\t\n+\\.\\.   { return DOTDOT; }\t\n+\\.     { return '.'; }\t\n+\\(     { return '('; }\t\n+\\)     { return ')'; }\t\n+\\{     { return '{'; }\t\n+\\}     { return '}'; }\t\n+\\[     { return '['; }\t\n+\\]     { return ']'; }\t\n+@      { return '@'; }\t\n+#      { BEGIN(pound); yymore(); }\t\n+<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\t\n+<shebang_or_attr>\\[ {\t\n+  BEGIN(INITIAL);\t\n+  yyless(2);\t\n+  return SHEBANG;\t\n+}\t\n+<shebang_or_attr>[^\\[\\n]*\\n {\t\n+  // Since the \\n was eaten as part of the token, yylineno will have\t\n+  // been incremented to the value 2 if the shebang was on the first\t\n+  // line. This yyless undoes that, setting yylineno back to 1.\t\n+  yyless(yyleng - 1);\t\n+  if (yyget_lineno() == 1) {\t\n+    BEGIN(INITIAL);\t\n+    return SHEBANG_LINE;\t\n+  } else {\t\n+    BEGIN(INITIAL);\t\n+    yyless(2);\t\n+    return SHEBANG;\t\n+  }\t\n+}\t\n+<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\t\n+\n+\\~     { return '~'; }\t\n+::     { return MOD_SEP; }\t\n+:      { return ':'; }\t\n+\\$     { return '$'; }\t\n+\\?     { return '?'; }\t\n+\n+==    { return EQEQ; }\t\n+=>    { return FAT_ARROW; }\t\n+=     { return '='; }\t\n+\\!=   { return NE; }\t\n+\\!    { return '!'; }\t\n+\\<=   { return LE; }\t\n+\\<\\<  { return SHL; }\t\n+\\<\\<= { return SHLEQ; }\t\n+\\<    { return '<'; }\t\n+\\>=   { return GE; }\t\n+\\>\\>  { return SHR; }\t\n+\\>\\>= { return SHREQ; }\t\n+\\>    { return '>'; }\t\n+\n+\\x27                                      { BEGIN(ltorchar); yymore(); }\t\n+<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\t\n+<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\t\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\t\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\t\n+<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\t\n+<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\t\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\t\n+<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\t\n+\n+b\\x22              { BEGIN(bytestr); yymore(); }\t\n+<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\t\n+\n+<bytestr><<EOF>>                     { return -1; }\t\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\t\n+<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\t\n+<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\t\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\t\n+<bytestr>(.|\\n)                      { yymore(); }\t\n+\n+br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\t\n+<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\t\n+<rawbytestr_nohash>(.|\\n)   { yymore(); }\t\n+<rawbytestr_nohash><<EOF>>  { return -1; }\t\n+\n+br/# {\t\n+    BEGIN(rawbytestr);\t\n+    yymore();\t\n+    num_hashes = 0;\t\n+    saw_non_hash = 0;\t\n+    end_hashes = 0;\t\n+}\t\n+<rawbytestr># {\t\n+    if (!saw_non_hash) {\t\n+        num_hashes++;\t\n+    } else if (end_hashes != 0) {\t\n+        end_hashes++;\t\n+        if (end_hashes == num_hashes) {\t\n+            BEGIN(INITIAL);\t\n+            return LIT_BYTE_STR_RAW;\t\n+        }\t\n+    }\t\n+    yymore();\t\n+}\t\n+<rawbytestr>\\x22# {\t\n+    end_hashes = 1;\t\n+    if (end_hashes == num_hashes) {\t\n+        BEGIN(INITIAL);\t\n+        return LIT_BYTE_STR_RAW;\t\n+    }\t\n+    yymore();\t\n+}\t\n+<rawbytestr>(.|\\n) {\t\n+    if (!saw_non_hash) {\t\n+        saw_non_hash = 1;\t\n+    }\t\n+    if (end_hashes != 0) {\t\n+        end_hashes = 0;\t\n+    }\t\n+    yymore();\t\n+}\t\n+<rawbytestr><<EOF>> { return -1; }\t\n+\n+b\\x27                           { BEGIN(byte); yymore(); }\t\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\t\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\t\n+<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\t\n+<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\t\n+<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\t\n+<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\t\n+\n+r\\x22           { BEGIN(rawstr); yymore(); }\t\n+<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\t\n+<rawstr>(.|\\n)  { yymore(); }\t\n+<rawstr><<EOF>> { return -1; }\t\n+\n+r/#             {\t\n+    BEGIN(rawstr_esc_begin);\t\n+    yymore();\t\n+    num_hashes = 0;\t\n+    saw_non_hash = 0;\t\n+    end_hashes = 0;\t\n+}\t\n+\n+<rawstr_esc_begin># {\t\n+    num_hashes++;\t\n+    yymore();\t\n+}\t\n+<rawstr_esc_begin>\\x22 {\t\n+    BEGIN(rawstr_esc_body);\t\n+    yymore();\t\n+}\t\n+<rawstr_esc_begin>(.|\\n) { return -1; }\t\n+\n+<rawstr_esc_body>\\x22/# {\t\n+  BEGIN(rawstr_esc_end);\t\n+  yymore();\t\n+ }\t\n+<rawstr_esc_body>(.|\\n) {\t\n+  yymore();\t\n+ }\t\n+\n+<rawstr_esc_end># {\t\n+  end_hashes++;\t\n+  if (end_hashes == num_hashes) {\t\n+    BEGIN(INITIAL);\t\n+    return LIT_STR_RAW;\t\n+  }\t\n+  yymore();\t\n+ }\t\n+<rawstr_esc_end>[^#] {\t\n+  end_hashes = 0;\t\n+  BEGIN(rawstr_esc_body);\t\n+  yymore();\t\n+ }\t\n+\n+<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\t\n+\n+\\x22                     { BEGIN(str); yymore(); }\t\n+<str>\\x22                { BEGIN(suffix); return LIT_STR; }\t\n+\n+<str><<EOF>>                     { return -1; }\t\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\t\n+<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\t\n+<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\t\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\t\n+<str>(.|\\n)                      { yymore(); }\t\n+\n+\\<-  { return LARROW; }\t\n+-\\>  { return RARROW; }\t\n+-    { return '-'; }\t\n+-=   { return MINUSEQ; }\t\n+&&   { return ANDAND; }\t\n+&    { return '&'; }\t\n+&=   { return ANDEQ; }\t\n+\\|\\| { return OROR; }\t\n+\\|   { return '|'; }\t\n+\\|=  { return OREQ; }\t\n+\\+   { return '+'; }\t\n+\\+=  { return PLUSEQ; }\t\n+\\*   { return '*'; }\t\n+\\*=  { return STAREQ; }\t\n+\\/   { return '/'; }\t\n+\\/=  { return SLASHEQ; }\t\n+\\^   { return '^'; }\t\n+\\^=  { return CARETEQ; }\t\n+%    { return '%'; }\t\n+%=   { return PERCENTEQ; }\t\n+\n+<<EOF>> { return 0; }\n+\n+%%\n+"}, {"sha": "17fff376834480be3735f5270022607a07dc4466", "filename": "gcc/rust/rustfrontend/rs-parser.y", "status": "added", "additions": 1977, "deletions": 0, "changes": 1977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-parser.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-parser.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frs-parser.y?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,1977 @@\n+%{\n+#include \"rust-system.h\"\n+#include \"node.h\"\n+\n+#define YYERROR_VERBOSE\t\n+#define YYSTYPE Node\n+\n+extern int yylineno;\n+extern char *yytext;\n+extern int yylex (void);\n+extern void yyerror (const char *);\n+%}\n+\n+// borrowed/stolen from rust-lang repo since removed in PR:\n+// https://github.com/rust-lang/rust/pull/64896/commits/96c8049b201fa0b87b8074e139921fbc33a2db1d\n+\n+%debug\n+\n+%token SHL\t\n+%token SHR\t\n+%token LE\t\n+%token EQEQ\t\n+%token NE\t\n+%token GE\t\n+%token ANDAND\t\n+%token OROR\t\n+%token SHLEQ\t\n+%token SHREQ\t\n+%token MINUSEQ\t\n+%token ANDEQ\t\n+%token OREQ\t\n+%token PLUSEQ\t\n+%token STAREQ\t\n+%token SLASHEQ\t\n+%token CARETEQ\t\n+%token PERCENTEQ\t\n+%token DOTDOT\t\n+%token DOTDOTDOT\t\n+%token MOD_SEP\t\n+%token RARROW\t\n+%token LARROW\t\n+%token FAT_ARROW\t\n+%token LIT_BYTE\t\n+%token LIT_CHAR\t\n+%token LIT_INTEGER\t\n+%token LIT_FLOAT\t\n+%token LIT_STR\t\n+%token LIT_STR_RAW\t\n+%token LIT_BYTE_STR\t\n+%token LIT_BYTE_STR_RAW\t\n+%token IDENT\t\n+%token UNDERSCORE\t\n+%token LIFETIME\t\n+\n+// keywords\t\n+%token SELF\t\n+%token STATIC\t\n+%token ABSTRACT\t\n+%token ALIGNOF\t\n+%token AS\t\n+%token BECOME\t\n+%token BREAK\t\n+%token CATCH\t\n+%token CRATE\t\n+%token DO\t\n+%token ELSE\t\n+%token ENUM\t\n+%token EXTERN\t\n+%token XFALSE\t\n+%token FINAL\t\n+%token FN\t\n+%token FOR\t\n+%token IF\t\n+%token IMPL\t\n+%token IN\t\n+%token LET\t\n+%token LOOP\t\n+%token MACRO\t\n+%token MATCH\t\n+%token MOD\t\n+%token MOVE\t\n+%token MUT\t\n+%token OFFSETOF\t\n+%token OVERRIDE\t\n+%token PRIV\t\n+%token PUB\t\n+%token PURE\t\n+%token REF\t\n+%token RETURN\t\n+%token SIZEOF\t\n+%token STRUCT\t\n+%token SUPER\t\n+%token UNION\t\n+%token UNSIZED\t\n+%token XTRUE\n+%token TRAIT\t\n+%token TYPE\t\n+%token UNSAFE\t\n+%token VIRTUAL\t\n+%token YIELD\t\n+%token DEFAULT\t\n+%token USE\t\n+%token WHILE\t\n+%token CONTINUE\t\n+%token PROC\t\n+%token BOX\t\n+%token CONST\t\n+%token WHERE\t\n+%token TYPEOF\t\n+%token INNER_DOC_COMMENT\t\n+%token OUTER_DOC_COMMENT\t\n+\n+%token SHEBANG\t\n+%token SHEBANG_LINE\t\n+%token STATIC_LIFETIME\t\n+\n+ /*\t\n+   Quoting from the Bison manual:\t\n+   \"Finally, the resolution of conflicts works by comparing the precedence\t\n+   of the rule being considered with that of the lookahead token. If the\t\n+   token's precedence is higher, the choice is to shift. If the rule's\t\n+   precedence is higher, the choice is to reduce. If they have equal\t\n+   precedence, the choice is made based on the associativity of that\t\n+   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\t\n+   Bison) says how each conflict was resolved\"\t\n+ */\t\n+\n+// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\t\n+// all potential ambiguities are scrutinized and eliminated manually.\t\n+%expect 0\t\n+\n+// fake-precedence symbol to cause '|' bars in lambda context to parse\t\n+// at low precedence, permit things like |x| foo = bar, where '=' is\t\n+// otherwise lower-precedence than '|'. Also used for proc() to cause\t\n+// things like proc() a + b to parse as proc() { a + b }.\t\n+%precedence LAMBDA\t\n+\n+%precedence SELF\t\n+\n+// MUT should be lower precedence than IDENT so that in the pat rule,\t\n+// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\t\n+%precedence MUT\t\n+\n+// IDENT needs to be lower than '{' so that 'foo {' is shifted when\t\n+// trying to decide if we've got a struct-construction expr (esp. in\t\n+// contexts like 'if foo { .')\t\n+//\t\n+// IDENT also needs to be lower precedence than '<' so that '<' in\t\n+// 'foo:bar . <' is shifted (in a trait reference occurring in a\t\n+// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\t\n+%precedence IDENT\t\n+ // Put the weak keywords that can be used as idents here as well\t\n+%precedence CATCH\t\n+%precedence DEFAULT\t\n+%precedence UNION\t\n+\n+// A couple fake-precedence symbols to use in rules associated with +\t\n+// and < in trailing type contexts. These come up when you have a type\t\n+// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\t\n+// has to be shifted so the parser keeps trying to parse a type, even\t\n+// though it might well consider reducing the type \"bar\" and then\t\n+// going on to \"<\" as a subsequent binop. The \"+\" case is with\t\n+// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\t\n+%precedence SHIFTPLUS\t\n+%precedence MOD_SEP\t\n+%precedence RARROW ':'\t\n+// In where clauses, \"for\" should have greater precedence when used as\t\n+// a higher ranked constraint than when used as the beginning of a\t\n+// for_in_type (which is a ty)\t\n+%precedence FORTYPE\t\n+%precedence FOR\t\n+// Binops & unops, and their precedences\t\n+%precedence '?'\t\n+%precedence BOX\t\n+%nonassoc DOTDOT\t\n+// RETURN needs to be lower-precedence than tokens that start\t\n+// prefix_exprs\t\n+%precedence RETURN YIELD\t\n+%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\t\n+%right LARROW\t\n+%left OROR\t\n+%left ANDAND\t\n+%left EQEQ NE\t\n+%left '<' '>' LE GE\t\n+%left '|'\t\n+%left '^'\t\n+%left '&'\t\n+%left SHL SHR\t\n+%left '+' '-'\t\n+%precedence AS\t\n+%left '*' '/' '%'\t\n+%precedence '!'\t\n+\n+%precedence '{' '[' '(' '.'\t\n+\n+%precedence RANGE\t\n+\n+%start crate\n+\n+%%\n+\n+///////////////////////////////////////////////////////////////////////\t\n+// Part 1: Items and attributes\t\n+////////////////////////////////////////////////////////////////////////\t\n+\n+crate\t\n+: maybe_shebang inner_attrs maybe_mod_items  { mk_node(NN_crate, 2, $2, $3); }\t\n+| maybe_shebang maybe_mod_items  { mk_node(NN_crate, 1, $2); }\n+;\t\n+\n+maybe_shebang\t\n+: SHEBANG_LINE\t\n+| %empty\t\n+;\t\n+\n+maybe_inner_attrs\t\n+: inner_attrs\t\n+| %empty                   { $$ = mk_none(); }\t\n+;\t\n+\n+inner_attrs\t\n+: inner_attr               { $$ = mk_node(NN_InnerAttrs, 1, $1); }\t\n+| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+inner_attr\t\n+: SHEBANG '[' meta_item ']'   { $$ = mk_node(NN_InnerAttr, 1, $3); }\t\n+| INNER_DOC_COMMENT           { $$ = mk_node(NN_InnerAttr, 1, mk_atom(NN_INNER_DOC_COMMENT, yytext)); }\n+;\t\n+\n+maybe_outer_attrs\t\n+: outer_attrs\t\n+| %empty                   { $$ = mk_none(); }\t\n+;\t\n+\n+outer_attrs\t\n+: outer_attr               { $$ = mk_node(NN_OuterAttrs, 1, $1); }\t\n+| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+outer_attr\t\n+: '#' '[' meta_item ']'    { $$ = $3; }\t\n+| OUTER_DOC_COMMENT        { $$ = mk_atom(NN_OUTER_DOC_COMMENT, yytext); }\n+;\t\n+\n+meta_item\t\n+: ident                      { $$ = mk_node(NN_MetaWord, 1, $1); }\t\n+| ident '=' lit              { $$ = mk_node(NN_MetaNameValue, 2, $1, $3); }\t\n+| ident '(' meta_seq ')'     { $$ = mk_node(NN_MetaList, 2, $1, $3); }\t\n+| ident '(' meta_seq ',' ')' { $$ = mk_node(NN_MetaList, 2, $1, $3); }\t\n+;\t\n+\n+meta_seq\t\n+: %empty                   { $$ = mk_none(); }\t\n+| meta_item                { $$ = mk_node(NN_MetaItems, 1, $1); }\n+| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+maybe_mod_items\t\n+: mod_items\t\n+| %empty             { $$ = mk_none(); }\t\n+;\t\n+\n+mod_items\t\n+: mod_item                               { $$ = mk_node(NN_Items, 1, $1); }\t\n+| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+attrs_and_vis\t\n+: maybe_outer_attrs visibility           { $$ = mk_node(NN_AttrsAndVis, 2, $1, $2); }\t\n+;\t\n+\n+mod_item\t\n+: attrs_and_vis item    { $$ = mk_node(NN_Item, 2, $1, $2); }\t\n+;\t\n+\n+// items that can appear outside of a fn block\t\n+item\t\n+: stmt_item\n+| item_macro\n+;\n+\n+// items that can appear in \"stmts\"\t\n+stmt_item\t\n+: item_static\t\n+| item_const\t\n+| item_type\t\n+| block_item\t\n+| view_item\t\n+;\t\n+\n+item_static\t\n+: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(NN_ItemStatic, 3, $2, $4, $6); }\t\n+| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(NN_ItemStatic, 3, $3, $5, $7); }\t\n+;\t\n+\n+item_const\t\n+: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(NN_ItemConst, 3, $2, $4, $6); }\t\n+;\t\n+\n+item_macro\t\n+: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(NN_ItemMacro, 3, $1, $3, $4); }\t\n+| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(NN_ItemMacro, 3, $1, $3, $4); }\t\n+| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(NN_ItemMacro, 3, $1, $3, $4); }\t\n+;\t\n+\n+view_item\t\n+: use_item\t\n+| extern_fn_item\t\n+| EXTERN CRATE ident ';'                      { $$ = mk_node(NN_ViewItemExternCrate, 1, $3); }\t\n+| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(NN_ViewItemExternCrate, 2, $3, $5); }\n+;\t\n+\n+extern_fn_item\t\n+: EXTERN maybe_abi item_fn                    { $$ = mk_node(NN_ViewItemExternFn, 2, $2, $3); }\t\n+;\t\n+\n+use_item\t\n+: USE view_path ';'                           { $$ = mk_node(NN_ViewItemUse, 1, $2); }\t\n+;\t\n+\n+view_path\t\n+: path_no_types_allowed                                    { $$ = mk_node(NN_ViewPathSimple, 1, $1); }\t\n+| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(NN_ViewPathList, 2, $1, mk_empty_atom(NN_ViewPathListEmpty)); }\n+|                       MOD_SEP '{'                '}'     { $$ = mk_node(NN_ViewPathList, 1, mk_empty_atom(NN_ViewPathListEmpty)); }\t\n+| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(NN_ViewPathList, 2, $1, $4); }\t\n+|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(NN_ViewPathList, 1, $3); }\t\n+| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(NN_ViewPathList, 2, $1, $4); }\t\n+|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(NN_ViewPathList, 1, $3); }\t\n+| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(NN_ViewPathGlob, 1, $1); }\t\n+|                       MOD_SEP '*'                        { $$ = mk_empty_atom(NN_ViewPathGlob); }\n+|                               '*'                        { $$ = mk_empty_atom(NN_ViewPathGlob); }\t\n+|                               '{'                '}'     { $$ = mk_empty_atom(NN_ViewPathListEmpty); }\n+|                               '{' idents_or_self '}'     { $$ = mk_node(NN_ViewPathList, 1, $2); }\t\n+|                               '{' idents_or_self ',' '}' { $$ = mk_node(NN_ViewPathList, 1, $2); }\t\n+| path_no_types_allowed AS ident                           { $$ = mk_node(NN_ViewPathSimple, 2, $1, $3); }\t\n+;\t\n+\n+block_item\t\n+: item_fn\t\n+| item_unsafe_fn\t\n+| item_mod\t\n+| item_foreign_mod          { $$ = mk_node(NN_ItemForeignMod, 1, $1); }\t\n+| item_struct\t\n+| item_enum\t\n+| item_union\t\n+| item_trait\t\n+| item_impl\t\n+;\t\n+\n+maybe_ty_ascription\t\n+: ':' ty_sum { $$ = $2; }\n+| %empty { $$ = mk_none(); }\n+;\t\n+\n+maybe_init_expr\t\n+: '=' expr { $$ = $2; }\t\n+| %empty   { $$ = mk_none(); }\t\n+;\t\n+\n+// structs\t\n+item_struct\t\n+: STRUCT ident generic_params maybe_where_clause struct_decl_args\t\n+{\t\n+  $$ = mk_node(NN_ItemStruct, 4, $2, $3, $4, $5);\t\n+}\t\n+| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\t\n+{\t\n+  $$ = mk_node(NN_ItemStruct, 4, $2, $3, $4, $5);\t\n+}\t\n+| STRUCT ident generic_params maybe_where_clause ';'\t\n+{\t\n+  $$ = mk_node(NN_ItemStruct, 3, $2, $3, $4);\t\n+}\t\n+;\t\n+\n+struct_decl_args\t\n+: '{' struct_decl_fields '}'                  { $$ = $2; }\t\n+| '{' struct_decl_fields ',' '}'              { $$ = $2; }\t\n+;\t\n+\n+struct_tuple_args\t\n+: '(' struct_tuple_fields ')'                 { $$ = $2; }\t\n+| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\t\n+;\t\n+\n+struct_decl_fields\t\n+: struct_decl_field                           { $$ = mk_node(NN_StructFields, 1, $1); }\t\n+| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\t\n+| %empty                                      { $$ = mk_none(); }\t\n+;\t\n+\n+struct_decl_field\t\n+: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(NN_StructField, 3, $1, $2, $4); }\t\n+;\t\n+\n+struct_tuple_fields\n+: struct_tuple_field                          { $$ = mk_node(NN_StructFields, 1, $1); }\t\n+| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\t\n+| %empty                                      { $$ = mk_none(); }\t\n+;\t\n+\n+struct_tuple_field\t\n+: attrs_and_vis ty_sum                    { $$ = mk_node(NN_StructField, 2, $1, $2); }\t\n+;\t\n+\n+// enums\t\n+item_enum\t\n+: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(NN_ItemEnum, 0); }\t\n+| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(NN_ItemEnum, 0); }\t\n+;\t\n+\n+enum_defs\t\n+: enum_def               { $$ = mk_node(NN_EnumDefs, 1, $1); }\t\n+| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\t\n+| %empty                 { $$ = mk_none(); }\t\n+;\t\n+\n+enum_def\t\n+: attrs_and_vis ident enum_args { $$ = mk_node(NN_EnumDef, 3, $1, $2, $3); }\t\n+;\t\n+\n+enum_args\t\n+: '{' struct_decl_fields '}'     { $$ = mk_node(NN_EnumArgs, 1, $2); }\n+| '{' struct_decl_fields ',' '}' { $$ = mk_node(NN_EnumArgs, 1, $2); }\n+| '(' maybe_ty_sums ')'          { $$ = mk_node(NN_EnumArgs, 1, $2); }\n+| '=' expr                       { $$ = mk_node(NN_EnumArgs, 1, $2); }\n+| %empty                         { $$ = mk_none(); }\n+;\t\n+\n+// unions\t\n+item_union\t\n+: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(NN_ItemUnion, 0); }\t\n+| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(NN_ItemUnion, 0); }\t\n+\n+item_mod\t\n+: MOD ident ';'                                 { $$ = mk_node(NN_ItemMod, 1, $2); }\t\n+| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(NN_ItemMod, 2, $2, $4); }\t\n+| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(NN_ItemMod, 3, $2, $4, $5); }\t\n+;\t\n+\n+item_foreign_mod\t\n+: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(NN_ItemForeignMod, 1, $4); }\t\n+| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(NN_ItemForeignMod, 2, $4, $5); }\t\n+;\t\n+\n+maybe_abi\t\n+: str\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_foreign_items\t\n+: foreign_items\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+foreign_items\t\n+: foreign_item               { $$ = mk_node(NN_ForeignItems, 1, $1); }\t\n+| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+foreign_item\t\n+: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(NN_ForeignItem, 2, $1, $3); }\n+| attrs_and_vis item_foreign_fn            { $$ = mk_node(NN_ForeignItem, 2, $1, $2); }\n+| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(NN_ForeignItem, 2, $1, $3); }\n+;\t\n+\n+item_foreign_static\t\n+: maybe_mut ident ':' ty ';'               { $$ = mk_node(NN_StaticItem, 3, $1, $2, $4); }\t\n+;\t\n+\n+item_foreign_fn\t\n+: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(NN_ForeignFn, 4, $2, $3, $4, $5); }\t\n+;\t\n+\n+fn_decl_allow_variadic\t\n+: fn_params_allow_variadic ret_ty { $$ = mk_node(NN_FnDecl, 2, $1, $2); }\t\n+;\t\n+\n+fn_params_allow_variadic\t\n+: '(' ')'                      { $$ = mk_none(); }\t\n+| '(' params ')'               { $$ = $2; }\t\n+| '(' params ',' ')'           { $$ = $2; }\t\n+| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\t\n+;\t\n+\n+visibility\t\n+: PUB      { $$ = mk_empty_atom(NN_Public); }\n+| %empty   { $$ = mk_empty_atom(NN_Inherited); }\n+;\t\n+\n+idents_or_self\t\n+: ident_or_self                    { $$ = mk_node(NN_IdentsOrSelf, 1, $1); }\n+| idents_or_self AS ident          { $$ = mk_node(NN_IdentsOrSelf, 2, $1, $3); }\n+| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n+;\t\n+\n+ident_or_self\n+: ident\t\n+| SELF  { $$ = mk_empty_atom(NN_SELF); }\n+;\t\n+\n+item_type\t\n+: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(NN_ItemTy, 4, $2, $3, $4, $6); }\t\n+;\t\n+\n+for_sized\t\n+: FOR '?' ident { $$ = mk_node(NN_ForSized, 1, $3); }\t\n+| FOR ident '?' { $$ = mk_node(NN_ForSized, 1, $2); }\t\n+| %empty        { $$ = mk_none(); }\t\n+;\t\n+\n+item_trait\t\n+: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemTrait, 7, $1, $3, $4, $5, $6, $7, $9);\t\n+}\t\n+;\t\n+\n+maybe_trait_items\t\n+: trait_items\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+trait_items\t\n+: trait_item               { $$ = mk_node(NN_TraitItems, 1, $1); }\t\n+| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+trait_item\t\n+: trait_const\t\n+| trait_type\t\n+| trait_method\t\n+| maybe_outer_attrs item_macro { $$ = mk_node(NN_TraitMacroItem, 2, $1, $2); }\t\n+;\t\n+\n+trait_const\t\n+: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(NN_ConstTraitItem, 4, $1, $3, $4, $5); }\t\n+;\t\n+\n+maybe_const_default\t\n+: '=' expr { $$ = mk_node(NN_ConstDefault, 1, $2); }\t\n+| %empty   { $$ = mk_none(); }\t\n+;\t\n+\n+trait_type\t\n+: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(NN_TypeTraitItem, 2, $1, $3); }\t\n+;\t\n+\n+maybe_unsafe\t\n+: UNSAFE { $$ = mk_empty_atom(NN_Unsafe); }\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_default_maybe_unsafe\t\n+: DEFAULT UNSAFE { $$ = mk_empty_atom(NN_DefaultUnsafe); }\t\n+| DEFAULT        { $$ = mk_empty_atom(NN_Default); }\t\n+|         UNSAFE { $$ = mk_empty_atom(NN_Unsafe); }\t\n+| %empty { $$ = mk_none(); }\t\n+\n+trait_method\t\n+: type_method { $$ = mk_node(NN_Required, 1, $1); }\t\n+| method      { $$ = mk_node(NN_Provided, 1, $1); }\t\n+;\t\n+\n+type_method\t\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\t\n+{\t\n+  $$ = mk_node(NN_TypeMethod, 6, $1, $2, $4, $5, $6, $7);\t\n+}\t\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\t\n+{\t\n+  $$ = mk_node(NN_TypeMethod, 6, $1, $3, $5, $6, $7, $8);\t\n+}\t\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\t\n+{\t\n+  $$ = mk_node(NN_TypeMethod, 7, $1, $2, $4, $6, $7, $8, $9);\t\n+}\t\n+;\t\n+\n+method\t\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 7, $1, $2, $4, $5, $6, $7, $8);\t\n+}\t\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 7, $1, $3, $5, $6, $7, $8, $9);\t\n+}\t\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 8, $1, $2, $4, $6, $7, $8, $9, $10);\t\n+}\t\n+;\t\n+\n+impl_method\t\n+: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 8, $1, $2, $3, $5, $6, $7, $8, $9);\t\n+}\t\n+| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 8, $1, $2, $4, $6, $7, $8, $9, $10);\t\n+}\t\n+| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_Method, 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\t\n+}\t\n+;\t\n+\n+// There are two forms of impl:\t\n+//\t\n+// impl (<...>)? TY { ... }\t\n+// impl (<...>)? TRAIT for TY { ... }\t\n+//\t\n+// Unfortunately since TY can begin with '<' itself -- as part of a\t\n+// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\t\n+// should we reduce one of the early rules of TY (such as maybe_once)\t\n+// or shall we continue shifting into the generic_params list for the\t\n+// impl?\t\n+//\t\n+// The production parser disambiguates a different case here by\t\n+// permitting / requiring the user to provide parens around types when\t\n+// they are ambiguous with traits. We do the same here, regrettably,\t\n+// by splitting ty into ty and ty_prim.\t\n+item_impl\t\n+: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImpl, 6, $1, $3, $4, $5, $7, $8);\t\n+}\t\n+| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImpl, 6, $1, $3, 5, $6, $9, $10);\n+}\t\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImpl, 6, $3, $4, $6, $7, $9, $10);\t\n+}\t\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImplNeg, 7, $1, $3, $5, $7, $8, $10, $11);\t\n+}\t\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImplDefault, 3, $1, $3, $4);\t\n+}\t\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\t\n+{\t\n+  $$ = mk_node(NN_ItemImplDefaultNeg, 3, $1, $3, $4);\t\n+}\t\n+;\t\n+\n+maybe_impl_items\t\n+: impl_items\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+impl_items\t\n+: impl_item               { $$ = mk_node(NN_ImplItems, 1, $1); }\t\n+| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+impl_item\t\n+: impl_method\t\n+| attrs_and_vis item_macro { $$ = mk_node(NN_ImplMacroItem, 2, $1, $2); }\t\n+| impl_const\t\n+| impl_type\t\n+;\t\n+\n+maybe_default\t\n+: DEFAULT { $$ = mk_empty_atom(NN_Default); }\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+impl_const\t\n+: attrs_and_vis maybe_default item_const { $$ = mk_node(NN_ImplConst, 3, $1, $2, $3); }\t\n+;\t\n+\n+impl_type\t\n+: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(NN_ImplType, 5, $1, $2, $4, $5, $7); }\t\n+;\t\n+\n+item_fn\t\n+: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_ItemFn, 5, $2, $3, $4, $5, $6);\t\n+}\t\n+| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_ItemFn, 5, $3, $4, $5, $6, $7);\t\n+}\t\n+;\t\n+\n+item_unsafe_fn\t\n+: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_ItemUnsafeFn, 5, $3, $4, $5, $6, $7);\t\n+}\t\n+| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_ItemUnsafeFn, 5, $4, $5, $6, $7, $8);\t\n+}\t\n+| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\t\n+{\t\n+  $$ = mk_node(NN_ItemUnsafeFn, 6, $3, $5, $6, $7, $8, $9);\t\n+}\t\n+;\t\n+\n+fn_decl\t\n+: fn_params ret_ty   { $$ = mk_node(NN_FnDecl, 2, $1, $2); }\t\n+;\t\n+\n+fn_decl_with_self\t\n+: fn_params_with_self ret_ty   { $$ = mk_node(NN_FnDecl, 2, $1, $2); }\t\n+;\t\n+\n+fn_decl_with_self_allow_anon_params\t\n+: fn_anon_params_with_self ret_ty   { $$ = mk_node(NN_FnDecl, 2, $1, $2); }\t\n+;\t\n+\n+fn_params\t\n+: '(' maybe_params ')'  { $$ = $2; }\t\n+;\t\n+\n+fn_anon_params\t\n+: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\t\n+| '(' ')'                                            { $$ = mk_none(); }\t\n+;\t\n+\n+fn_params_with_self\t\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(NN_SelfLower, 3, $2, $4, $5); }\t\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(NN_SelfRegion, 3, $3, $5, $6); }\t\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(NN_SelfRegion, 4, $3, $4, $6, $7); }\t\n+| '(' maybe_params ')'                                                       { $$ = mk_node(NN_SelfStatic, 1, $2); }\t\n+;\t\n+\n+fn_anon_params_with_self\t\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(NN_SelfLower, 3, $2, $4, $5); }\t\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(NN_SelfRegion, 3, $3, $5, $6); }\t\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(NN_SelfRegion, 4, $3, $4, $6, $7); }\t\n+| '(' maybe_anon_params ')'                                                       { $$ = mk_node(NN_SelfStatic, 1, $2); }\t\n+;\t\n+\n+maybe_params\t\n+: params\t\n+| params ','\t\n+| %empty  { $$ = mk_none(); }\t\n+;\t\n+\n+params\t\n+: param                { $$ = mk_node(NN_Args, 1, $1); }\t\n+| params ',' param     { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+param\t\n+: pat ':' ty_sum   { $$ = mk_node(NN_Arg, 2, $1, $3); }\t\n+;\t\n+\n+inferrable_params\t\n+: inferrable_param                       { $$ = mk_node(NN_InferrableParams, 1, $1); }\t\n+| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+inferrable_param\t\n+: pat maybe_ty_ascription { $$ = mk_node(NN_InferrableParam, 2, $1, $2); }\t\n+;\t\n+\n+maybe_comma_params\t\n+: ','            { $$ = mk_none(); }\n+| ',' params     { $$ = $2; }\t\n+| ',' params ',' { $$ = $2; }\t\n+| %empty         { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_comma_anon_params\t\n+: ','                 { $$ = mk_none(); }\t\n+| ',' anon_params     { $$ = $2; }\t\n+| ',' anon_params ',' { $$ = $2; }\t\n+| %empty              { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_anon_params\t\n+: anon_params\t\n+| anon_params ','\t\n+| %empty      { $$ = mk_none(); }\t\n+;\t\n+\n+anon_params\t\n+: anon_param                 { $$ = mk_node(NN_Args, 1, $1); }\t\n+| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+// anon means it's allowed to be anonymous (type-only), but it can\t\n+// still have a name\t\n+anon_param\t\n+: named_arg ':' ty   { $$ = mk_node(NN_Arg, 2, $1, $3); }\t\n+| ty\t\n+;\t\n+\n+anon_params_allow_variadic_tail\t\n+: ',' DOTDOTDOT                                  { $$ = mk_none(); }\t\n+| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(NN_Args, 2, $2, $3); }\t\n+| %empty                                         { $$ = mk_none(); }\t\n+;\t\n+\n+named_arg\t\n+: ident\t\n+| UNDERSCORE        { $$ = mk_empty_atom(NN_PatWild); }\t\n+| '&' ident         { $$ = $2; }\t\n+| '&' UNDERSCORE    { $$ = mk_empty_atom(NN_PatWild); }\t\n+| ANDAND ident      { $$ = $2; }\t\n+| ANDAND UNDERSCORE { $$ = mk_empty_atom(NN_PatWild); }\t\n+| MUT ident         { $$ = $2; }\t\n+;\t\n+\n+ret_ty\t\n+: RARROW '!'         { $$ = mk_none(); }\t\n+| RARROW ty          { $$ = mk_node(NN_RetTy, 1, $2); }\n+| %prec IDENT %empty { $$ = mk_none(); }\t\n+;\t\n+\n+generic_params\t\n+: '<' '>'                             { $$ = mk_node(NN_Generics, 2, mk_none(), mk_none()); }\t\n+| '<' lifetimes '>'                   { $$ = mk_node(NN_Generics, 2, $2, mk_none()); }\t\n+| '<' lifetimes ',' '>'               { $$ = mk_node(NN_Generics, 2, $2, mk_none()); }\t\n+| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(NN_Generics, 2, $2, mk_none()); }\t\n+| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(NN_Generics, 2, $2, mk_none()); }\t\n+| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(NN_Generics, 2, $2, $4); }\t\n+| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(NN_Generics, 2, $2, $4); }\t\n+| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(NN_Generics, 2, $2, $4); }\t\n+| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(NN_Generics, 2, $2, $4); }\t\n+| '<' ty_params '>'                   { $$ = mk_node(NN_Generics, 2, mk_none(), $2); }\t\n+| '<' ty_params ',' '>'               { $$ = mk_node(NN_Generics, 2, mk_none(), $2); }\t\n+| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(NN_Generics, 2, mk_none(), $2); }\t\n+| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(NN_Generics, 2, mk_none(), $2); }\t\n+| %empty                              { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_where_clause\t\n+: %empty                              { $$ = mk_none(); }\n+| where_clause\t\n+;\t\n+\n+where_clause\t\n+: WHERE where_predicates              { $$ = mk_node(NN_WhereClause, 1, $2); }\n+| WHERE where_predicates ','          { $$ = mk_node(NN_WhereClause, 1, $2); }\n+;\t\n+\n+where_predicates\t\n+: where_predicate                      { $$ = mk_node(NN_WherePredicates, 1, $1); }\t\n+| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+where_predicate\t\n+: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(NN_WherePredicate, 3, $1, $2, $4); }\t\n+| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(NN_WherePredicate, 3, $1, $2, $4); }\t\n+;\t\n+\n+maybe_for_lifetimes\t\n+: FOR '<' lifetimes '>' { $$ = mk_none(); }\t\n+| %prec FORTYPE %empty  { $$ = mk_none(); }\t\n+\n+ty_params\t\n+: ty_param               { $$ = mk_node(NN_TyParams, 1, $1); }\t\n+| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+// A path with no type parameters; e.g. `foo::bar::Baz`\t\n+//\t\n+// These show up in 'use' view-items, because these are processed\t\n+// without respect to types.\t\n+path_no_types_allowed\t\n+: ident                               { $$ = mk_node(NN_ViewPath, 1, $1); }\t\n+| MOD_SEP ident                       { $$ = mk_node(NN_ViewPath, 1, $2); }\t\n+| SELF                                { $$ = mk_node(NN_ViewPath, 1, mk_empty_atom(NN_SELF)); }\t\n+| MOD_SEP SELF                        { $$ = mk_node(NN_ViewPath, 1, mk_empty_atom(NN_SELF)); }\t\n+| SUPER                               { $$ = mk_node(NN_ViewPath, 1, mk_empty_atom(NN_SUPER)); }\t\n+| MOD_SEP SUPER                       { $$ = mk_node(NN_ViewPath, 1, mk_empty_atom(NN_SUPER)); }\n+| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+// A path with a lifetime and type parameters, with no double colons\t\n+// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\t\n+//\t\n+// These show up in \"trait references\", the components of\t\n+// type-parameter bounds lists, as well as in the prefix of the\t\n+// path_generic_args_and_bounds rule, which is the full form of a\t\n+// named typed expression.\t\n+//\t\n+// They do not have (nor need) an extra '::' before '<' because\t\n+// unlike in expr context, there are no \"less-than\" type exprs to\t\n+// be ambiguous with.\t\n+path_generic_args_without_colons\t\n+: %prec IDENT\t\n+  ident                                                                       { $$ = mk_node(NN_components, 1, $1); }\t\n+| %prec IDENT\t\n+  ident generic_args                                                          { $$ = mk_node(NN_components, 2, $1, $2); }\t\n+| %prec IDENT\t\n+  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(NN_components, 2, $1, $3); }\t\n+| %prec IDENT\t\n+  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\t\n+| %prec IDENT\t\n+  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\t\n+| %prec IDENT\t\n+  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\t\n+;\t\n+\n+generic_args\t\n+: '<' generic_values '>'   { $$ = $2; }\t\n+| '<' generic_values SHR   { push_back('>'); $$ = $2; }\t\n+| '<' generic_values GE    { push_back('='); $$ = $2; }\t\n+| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\t\n+// If generic_args starts with \"<<\", the first arg must be a\t\n+// TyQualifiedPath because that's the only type that can start with a\t\n+// '<'. This rule parses that as the first ty_sum and then continues\t\n+// with the rest of generic_values.\t\n+| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\t\n+| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\t\n+| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\t\n+| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\t\n+;\t\n+\n+generic_values\t\n+: maybe_ty_sums_and_or_bindings { $$ = mk_node(NN_GenericValues, 1, $1); }\t\n+;\t\n+\n+maybe_ty_sums_and_or_bindings\t\n+: ty_sums\t\n+| ty_sums ','\t\n+| ty_sums ',' bindings { $$ = mk_node(NN_TySumsAndBindings, 2, $1, $3); }\t\n+| bindings\t\n+| bindings ','\t\n+| %empty               { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_bindings\t\n+: ',' bindings { $$ = $2; }\t\n+| %empty       { $$ = mk_none(); }\t\n+;\t\n+\n+////////////////////////////////////////////////////////////////////////\t\n+// Part 2: Patterns\t\n+////////////////////////////////////////////////////////////////////////\t\n+\n+pat\t\n+: UNDERSCORE                                      { $$ = mk_empty_atom(NN_PatWild); }\t\n+| '&' pat                                         { $$ = mk_node(NN_PatRegion, 1, $2); }\t\n+| '&' MUT pat                                     { $$ = mk_node(NN_PatRegion, 1, $3); }\t\n+| ANDAND pat                                      { $$ = mk_node(NN_PatRegion, 1, mk_node(NN_PatRegion, 1, $2)); }\t\n+| '(' ')'                                         { $$ = mk_empty_atom(NN_PatUnit); }\t\n+| '(' pat_tup ')'                                 { $$ = mk_node(NN_PatTup, 1, $2); }\t\n+| '[' pat_vec ']'                                 { $$ = mk_node(NN_PatVec, 1, $2); }\t\n+| lit_or_path\t\n+| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(NN_PatRange, 2, $1, $3); }\t\n+| path_expr '{' pat_struct '}'                    { $$ = mk_node(NN_PatStruct, 2, $1, $3); }\t\n+| path_expr '(' ')'                               { $$ = mk_node(NN_PatEnum, 2, $1, mk_none()); }\t\n+| path_expr '(' pat_tup ')'                       { $$ = mk_node(NN_PatEnum, 2, $1, $3); }\t\n+| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(NN_PatMac, 3, $1, $3, $4); }\t\n+| binding_mode ident                              { $$ = mk_node(NN_PatIdent, 2, $1, $2); }\t\n+|              ident '@' pat                      { $$ = mk_node(NN_PatIdent, 3, mk_node(NN_BindByValue, 1, mk_empty_atom(NN_MutImmutable)), $1, $3); }\t\n+| binding_mode ident '@' pat                      { $$ = mk_node(NN_PatIdent, 3, $1, $2, $4); }\t\n+| BOX pat                                         { $$ = mk_node(NN_PatUniq, 1, $2); }\t\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(NN_PatQualifiedPath, 3, $2, $3, $6); }\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\t\n+{\t\n+  $$ = mk_node(NN_PatQualifiedPath, 3, mk_node(NN_PatQualifiedPath, 3, $2, $3, $6), $7, $10);\t\n+}\t\n+;\t\n+\n+pats_or\t\n+: pat              { $$ = mk_node(NN_Pats, 1, $1); }\t\n+| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+binding_mode\t\n+: REF         { $$ = mk_node(NN_BindByRef, 1, mk_empty_atom(NN_MutImmutable)); }\n+| REF MUT     { $$ = mk_node(NN_BindByRef, 1, mk_empty_atom(NN_MutMutable)); }\n+| MUT         { $$ = mk_node(NN_BindByValue, 1, mk_empty_atom(NN_MutMutable)); }\n+;\t\n+\n+lit_or_path\t\n+: path_expr    { $$ = mk_node(NN_PatLit, 1, $1); }\t\n+| lit          { $$ = mk_node(NN_PatLit, 1, $1); }\t\n+| '-' lit      { $$ = mk_node(NN_PatLit, 1, $2); }\t\n+;\t\n+\n+pat_field\t\n+:                  ident        { $$ = mk_node(NN_PatField, 1, $1); }\t\n+|     binding_mode ident        { $$ = mk_node(NN_PatField, 2, $1, $2); }\t\n+| BOX              ident        { $$ = mk_node(NN_PatField, 2, mk_empty_atom(NN_BOX), $2); }\t\n+| BOX binding_mode ident        { $$ = mk_node(NN_PatField, 3, mk_empty_atom(NN_BOX), $2, $3); }\n+|              ident ':' pat    { $$ = mk_node(NN_PatField, 2, $1, $3); }\t\n+| binding_mode ident ':' pat    { $$ = mk_node(NN_PatField, 3, $1, $2, $4); }\t\n+|        LIT_INTEGER ':' pat    { $$ = mk_node(NN_PatField, 2, mk_atom(NN_LitInteger, yytext), $3); }\n+;\t\n+\n+pat_fields\t\n+: pat_field                  { $$ = mk_node(NN_PatFields, 1, $1); }\t\n+| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+pat_struct\t\n+: pat_fields                 { $$ = mk_node(NN_PatStruct, 2, $1, mk_atom(NN_LitBool, \"false\")); }\n+| pat_fields ','             { $$ = mk_node(NN_PatStruct, 2, $1, mk_atom(NN_LitBool, \"false\")); }\n+| pat_fields ',' DOTDOT      { $$ = mk_node(NN_PatStruct, 2, $1, mk_atom(NN_LitBool, \"true\")); }\n+| DOTDOT                     { $$ = mk_node(NN_PatStruct, 1, mk_atom(NN_LitBool, \"true\")); }\n+| %empty                     { $$ = mk_node(NN_PatStruct, 1, mk_none()); }\n+;\n+\n+pat_tup\t\n+: pat_tup_elts                                  { $$ = mk_node(NN_PatTup, 2, $1, mk_none()); }\t\n+| pat_tup_elts                             ','  { $$ = mk_node(NN_PatTup, 2, $1, mk_none()); }\t\n+| pat_tup_elts     DOTDOT                       { $$ = mk_node(NN_PatTup, 2, $1, mk_none()); }\t\n+| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(NN_PatTup, 2, $1, mk_none()); }\t\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(NN_PatTup, 2, $1, $4); }\t\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(NN_PatTup, 2, $1, $4); }\t\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(NN_PatTup, 2, $1, $5); }\t\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(NN_PatTup, 2, $1, $5); }\t\n+|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(NN_PatTup, 2, mk_none(), $3); }\t\n+|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(NN_PatTup, 2, mk_none(), $3); }\t\n+|                  DOTDOT                       { $$ = mk_node(NN_PatTup, 2, mk_none(), mk_none()); }\t\n+;\t\n+\n+pat_tup_elts\t\n+: pat                    { $$ = mk_node(NN_PatTupElts, 1, $1); }\t\n+| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+pat_vec\t\n+: pat_vec_elts                                  { $$ = mk_node(NN_PatVec, 2, $1, mk_none()); }\t\n+| pat_vec_elts                             ','  { $$ = mk_node(NN_PatVec, 2, $1, mk_none()); }\t\n+| pat_vec_elts     DOTDOT                       { $$ = mk_node(NN_PatVec, 2, $1, mk_none()); }\t\n+| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(NN_PatVec, 2, $1, mk_none()); }\t\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(NN_PatVec, 2, $1, $4); }\t\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(NN_PatVec, 2, $1, $4); }\t\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(NN_PatVec, 2, $1, $5); }\t\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(NN_PatVec, 2, $1, $5); }\t\n+|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(NN_PatVec, 2, mk_none(), $3); }\t\n+|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(NN_PatVec, 2, mk_none(), $3); }\t\n+|                  DOTDOT                       { $$ = mk_node(NN_PatVec, 2, mk_none(), mk_none()); }\t\n+| %empty                                        { $$ = mk_node(NN_PatVec, 2, mk_none(), mk_none()); }\t\n+;\t\n+\n+pat_vec_elts\t\n+: pat                    { $$ = mk_node(NN_PatVecElts, 1, $1); }\t\n+| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+////////////////////////////////////////////////////////////////////////\t\n+// Part 3: Types\t\n+////////////////////////////////////////////////////////////////////////\t\n+\n+ty\t\n+: ty_prim\t\n+| ty_closure\t\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(NN_TyQualifiedPath, 3, $2, $3, $6); }\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(NN_TyQualifiedPath, 3, mk_node(NN_TyQualifiedPath, 3, $2, $3, $6), $7, $10); }\t\n+| '(' ty_sums ')'                                                                      { $$ = mk_node(NN_TyTup, 1, $2); }\t\n+| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(NN_TyTup, 1, $2); }\t\n+| '(' ')'                                                                              { $$ = mk_empty_atom(NN_TyNil); }\n+;\t\n+\n+ty_prim\t\n+: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(NN_TyPath, 2, mk_node(NN_GLOBAL, 1, mk_atom(NN_LitBool, \"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(NN_TyPath, 2, mk_node(NN_GLOBAL, 1, mk_atom(NN_LitBool, \"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(NN_TyPath, 2, mk_node(NN_SELF, 1, mk_atom(NN_LitBool, \"true\")), $3); }\n+| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(NN_TyMacro, 3, $1, $3, $4); }\t\n+| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(NN_TyMacro, 3, $2, $4, $5); }\t\n+| BOX ty                                                                                     { $$ = mk_node(NN_TyBox, 1, $2); }\t\n+| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(NN_TyPtr, 2, $2, $3); }\t\n+| '&' ty                                                                                     { $$ = mk_node(NN_TyRptr, 2, mk_empty_atom(NN_MutImmutable), $2); }\t\n+| '&' MUT ty                                                                                 { $$ = mk_node(NN_TyRptr, 2, mk_empty_atom(NN_MutMutable), $3); }\t\n+| ANDAND ty                                                                                  { $$ = mk_node(NN_TyRptr, 1, mk_node(NN_TyRptr, 2, mk_empty_atom(NN_MutImmutable), $2)); }\t\n+| ANDAND MUT ty                                                                              { $$ = mk_node(NN_TyRptr, 1, mk_node(NN_TyRptr, 2, mk_empty_atom(NN_MutMutable), $3)); }\n+| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(NN_TyRptr, 3, $2, $3, $4); }\t\n+| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(NN_TyRptr, 1, mk_node(NN_TyRptr, 3, $2, $3, $4)); }\t\n+| '[' ty ']'                                                                                 { $$ = mk_node(NN_TyVec, 1, $2); }\t\n+| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(NN_TyFixedLengthVec, 2, $2, $5); }\t\n+| '[' ty ';' expr ']'                                                                        { $$ = mk_node(NN_TyFixedLengthVec, 2, $2, $4); }\t\n+| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(NN_TyTypeof, 1, $3); }\t\n+| UNDERSCORE                                                                                 { $$ = mk_empty_atom(NN_TyInfer); }\n+| ty_bare_fn\t\n+| for_in_type\t\n+;\t\n+\n+ty_bare_fn\t\n+:                         FN ty_fn_decl { $$ = $2; }\t\n+| UNSAFE                  FN ty_fn_decl { $$ = $3; }\t\n+|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\t\n+| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\t\n+;\t\n+\n+ty_fn_decl\t\n+: generic_params fn_anon_params ret_ty { $$ = mk_node(NN_TyFnDecl, 3, $1, $2, $3); }\t\n+;\t\n+\n+ty_closure\t\n+: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(NN_TyClosure, 3, $3, $5, $6); }\t\n+|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(NN_TyClosure, 3, $2, $4, $5); }\t\n+| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(NN_TyClosure, 2, $3, $4); }\t\n+|        OROR maybe_bounds ret_ty                { $$ = mk_node(NN_TyClosure, 2, $2, $3); }\t\n+;\t\n+\n+for_in_type\t\n+: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(NN_ForInType, 2, $3, $5); }\t\n+;\t\n+\n+for_in_type_suffix\t\n+: ty_bare_fn\t\n+| trait_ref\t\n+| ty_closure\t\n+;\t\n+\n+maybe_mut\t\n+: MUT              { $$ = mk_empty_atom(NN_MutMutable); }\t\n+| %prec MUT %empty { $$ = mk_empty_atom(NN_MutImmutable); }\t\n+;\t\n+\n+maybe_mut_or_const\t\n+: MUT    { $$ = mk_empty_atom(NN_MutMutable); }\n+| CONST  { $$ = mk_empty_atom(NN_MutImmutable); }\t\n+| %empty { $$ = mk_empty_atom(NN_MutImmutable); }\t\n+;\t\n+\n+ty_qualified_path_and_generic_values\t\n+: ty_qualified_path maybe_bindings\t\n+{\t\n+  $$ = mk_node(NN_GenericValues, 3, mk_none(), mk_node(NN_TySums, 1, mk_node(NN_TySum, 1, $1)), $2);\t\n+}\t\n+| ty_qualified_path ',' ty_sums maybe_bindings\t\n+{\t\n+  $$ = mk_node(NN_GenericValues, 3, mk_none(), mk_node(NN_TySums, 2, $1, $3), $4);\n+}\t\n+;\t\n+\n+ty_qualified_path\t\n+: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(NN_TyQualifiedPath, 3, $1, $3, $6); }\t\n+| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(NN_TyQualifiedPath, 3, $1, $3, $6); }\t\n+;\t\n+\n+maybe_ty_sums\t\n+: ty_sums\t\n+| ty_sums ','\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+ty_sums\t\n+: ty_sum             { $$ = mk_node(NN_TySums, 1, $1); }\t\n+| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+ty_sum\t\n+: ty_sum_elt            { $$ = mk_node(NN_TySum, 1, $1); }\t\n+| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+ty_sum_elt\t\n+: ty\t\n+| lifetime\t\n+;\t\n+\n+ty_prim_sum\t\n+: ty_prim_sum_elt                 { $$ = mk_node(NN_TySum, 1, $1); }\n+| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+ty_prim_sum_elt\t\n+: ty_prim\t\n+| lifetime\t\n+;\t\n+\n+maybe_ty_param_bounds\t\n+: ':' ty_param_bounds { $$ = $2; }\t\n+| %empty              { $$ = mk_none(); }\t\n+;\t\n+\n+ty_param_bounds\t\n+: boundseq\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+boundseq\t\n+: polybound\t\n+| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+polybound\t\n+: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(NN_PolyBound, 2, $3, $5); }\n+| bound\t\n+| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(NN_PolyBound, 2, $4, $6); }\t\n+| '?' bound { $$ = $2; }\t\n+;\t\n+\n+bindings\t\n+: binding              { $$ = mk_node(NN_Binding, 1, $1); }\t\n+| bindings ',' binding { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+binding\t\n+: ident '=' ty { mk_node(NN_Binding, 2, $1, $3); }\t\n+;\t\n+\n+ty_param\t\n+: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(NN_TyParam, 3, $1, $2, $3); }\t\n+| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(NN_TyParam, 4, $1, $3, $4, $5); }\n+;\t\n+\n+maybe_bounds\t\n+: %prec SHIFTPLUS\t\n+  ':' bounds             { $$ = $2; }\t\n+| %prec SHIFTPLUS %empty { $$ = mk_none(); }\t\n+;\t\n+\n+bounds\t\n+: bound            { $$ = mk_node(NN_bounds, 1, $1); }\t\n+| bounds '+' bound { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+bound\t\n+: lifetime\t\n+| trait_ref\t\n+;\t\n+\n+maybe_ltbounds\t\n+: %prec SHIFTPLUS\t\n+  ':' ltbounds       { $$ = $2; }\t\n+| %empty             { $$ = mk_none(); }\t\n+;\t\n+\n+ltbounds\t\n+: lifetime              { $$ = mk_node(NN_ltbounds, 1, $1); }\t\n+| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+maybe_ty_default\t\n+: '=' ty_sum { $$ = mk_node(NN_TyDefault, 1, $2); }\t\n+| %empty     { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_lifetimes\t\n+: lifetimes\t\n+| lifetimes ','\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+lifetimes\t\n+: lifetime_and_bounds               { $$ = mk_node(NN_Lifetimes, 1, $1); }\t\n+| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+lifetime_and_bounds\t\n+: LIFETIME maybe_ltbounds         { $$ = mk_node(NN_lifetime, 2, mk_atom(NN_lifetime, yytext), $2); }\n+| STATIC_LIFETIME                 { $$ = mk_empty_atom(NN_static_lifetime); }\n+;\t\n+\n+lifetime\t\n+: LIFETIME         { $$ = mk_atom(NN_lifetime, yytext); }\n+| STATIC_LIFETIME  { $$ = mk_empty_atom(NN_static_lifetime); }\n+;\t\n+\n+trait_ref\t\n+: %prec IDENT path_generic_args_without_colons\n+| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\t\n+;\t\n+\n+////////////////////////////////////////////////////////////////////////\t\n+// Part 4: Blocks, statements, and expressions\t\n+////////////////////////////////////////////////////////////////////////\t\n+\n+inner_attrs_and_block\t\n+: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(NN_ExprBlock, 2, $2, $3); }\t\n+;\t\n+\n+block\t\n+: '{' maybe_stmts '}'                          { $$ = mk_node(NN_ExprBlock, 1, $2); }\t\n+;\t\n+\n+maybe_stmts\t\n+: stmts\t\n+| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\t\n+| nonblock_expr\t\n+| %empty              { $$ = mk_none(); }\t\n+;\t\n+\n+// There are two sub-grammars within a \"stmts: exprs\" derivation\t\n+// depending on whether each stmt-expr is a block-expr form; this is to\t\n+// handle the \"semicolon rule\" for stmt sequencing that permits\t\n+// writing\t\n+//\t\n+//     if foo { bar } 10\t\n+//\t\n+// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\t\n+// stmt). Unfortunately by permitting juxtaposition of exprs in\t\n+// sequence like that, the non-block expr grammar has to have a\t\n+// second limited sub-grammar that excludes the prefix exprs that\t\n+// are ambiguous with binops. That is to say:\t\n+//\t\n+//     {10} - 1\t\n+//\t\n+// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\t\n+// is to say, two statements rather than one, at least according to\t\n+// the mainline rust parser.\t\n+//\t\n+// So we wind up with a 3-way split in exprs that occur in stmt lists:\t\n+// block, nonblock-prefix, and nonblock-nonprefix.\t\n+//\t\n+// In non-stmts contexts, expr can relax this trichotomy.\t\n+\n+stmts\t\n+: stmt           { $$ = mk_node(NN_stmts, 1, $1); }\t\n+| stmts stmt     { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+stmt\t\n+: maybe_outer_attrs let     { $$ = $2; }\t\n+|                 stmt_item\t\n+|             PUB stmt_item { $$ = $2; }\t\n+| outer_attrs     stmt_item { $$ = $2; }\t\n+| outer_attrs PUB stmt_item { $$ = $3; }\t\n+| full_block_expr\t\n+| maybe_outer_attrs block   { $$ = $2; }\t\n+|             nonblock_expr ';'\t\n+| outer_attrs nonblock_expr ';' { $$ = $2; }\t\n+| ';'                   { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_exprs\t\n+: exprs\t\n+| exprs ','\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_expr\t\n+: expr\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+exprs\t\n+: expr                                                        { $$ = mk_node(NN_exprs, 1, $1); }\t\n+| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+path_expr\t\n+: path_generic_args_with_colons\t\n+| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\t\n+| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(NN_SelfPath, 1, $3); }\t\n+;\t\n+\n+// A path with a lifetime and type parameters with double colons before\t\n+// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\t\n+//\t\n+// These show up in expr context, in order to disambiguate from \"less-than\"\t\n+// expressions.\t\n+path_generic_args_with_colons\t\n+: ident                                              { $$ = mk_node(NN_components, 1, $1); }\t\n+| SUPER                                              { $$ = mk_empty_atom(NN_Super); }\n+| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\t\n+| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_empty_atom(NN_Super)); }\n+| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+// the braces-delimited macro is a block_expr so it doesn't appear here\t\n+macro_expr\t\n+: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(NN_MacroExpr, 3, $1, $3, $4); }\t\n+| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(NN_MacroExpr, 3, $1, $3, $4); }\t\n+;\t\n+\n+nonblock_expr\t\n+: lit                                                           { $$ = mk_node(NN_ExprLit, 1, $1); }\n+| %prec IDENT\t\n+  path_expr                                                     { $$ = mk_node(NN_ExprPath, 1, $1); }\t\n+| SELF                                                          { $$ = mk_node(NN_ExprPath, 1, mk_empty_atom(NN_SELF)); }\n+| macro_expr                                                    { $$ = mk_node(NN_ExprMac, 1, $1); }\t\n+| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(NN_ExprStruct, 2, $1, $3); }\t\n+| nonblock_expr '?'                                             { $$ = mk_node(NN_ExprTry, 1, $1); }\t\n+| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(NN_ExprField, 2, $1, $3); }\t\n+| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(NN_ExprTupleIndex, 1, $1); }\t\n+| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(NN_ExprIndex, 2, $1, $3); }\t\n+| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(NN_ExprCall, 2, $1, $3); }\t\n+| '[' vec_expr ']'                                              { $$ = mk_node(NN_ExprVec, 1, $2); }\t\n+| '(' maybe_exprs ')'                                           { $$ = mk_node(NN_ExprParen, 1, $2); }\t\n+| CONTINUE                                                      { $$ = mk_node(NN_ExprAgain, 0); }\t\n+| CONTINUE lifetime                                             { $$ = mk_node(NN_ExprAgain, 1, $2); }\t\n+| RETURN                                                        { $$ = mk_node(NN_ExprRet, 0); }\t\n+| RETURN expr                                                   { $$ = mk_node(NN_ExprRet, 1, $2); }\t\n+| BREAK                                                         { $$ = mk_node(NN_ExprBreak, 0); }\t\n+| BREAK lifetime                                                { $$ = mk_node(NN_ExprBreak, 1, $2); }\t\n+| YIELD                                                         { $$ = mk_node(NN_ExprYield, 0); }\t\n+| YIELD expr                                                    { $$ = mk_node(NN_ExprYield, 1, $2); }\t\n+| nonblock_expr '=' expr                                        { $$ = mk_node(NN_ExprAssign, 2, $1, $3); }\t\n+| nonblock_expr SHLEQ expr                                      { $$ = mk_node(NN_ExprAssignShl, 2, $1, $3); }\t\n+| nonblock_expr SHREQ expr                                      { $$ = mk_node(NN_ExprAssignShr, 2, $1, $3); }\t\n+| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(NN_ExprAssignSub, 2, $1, $3); }\t\n+| nonblock_expr ANDEQ expr                                      { $$ = mk_node(NN_ExprAssignBitAnd, 2, $1, $3); }\t\n+| nonblock_expr OREQ expr                                       { $$ = mk_node(NN_ExprAssignBitOr, 2, $1, $3); }\t\n+| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(NN_ExprAssignAdd, 2, $1, $3); }\t\n+| nonblock_expr STAREQ expr                                     { $$ = mk_node(NN_ExprAssignMul, 2, $1, $3); }\t\n+| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(NN_ExprAssignDiv, 2, $1, $3); }\t\n+| nonblock_expr CARETEQ expr                                    { $$ = mk_node(NN_ExprAssignBitXor, 2, $1, $3); }\t\n+| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(NN_ExprAssignRem, 2, $1, $3); }\t\n+| nonblock_expr OROR expr                                       { $$ = mk_node(NN_BiOr, 2,$1, $3); }\t\n+| nonblock_expr ANDAND expr                                     { $$ = mk_node(NN_BiAnd, 2,$1, $3); }\t\n+| nonblock_expr EQEQ expr                                       { $$ = mk_node(NN_BiEq, 2,$1, $3); }\t\n+| nonblock_expr NE expr                                         { $$ = mk_node(NN_BiNe, 2,$1, $3); }\t\n+| nonblock_expr '<' expr                                        { $$ = mk_node(NN_BiLt, 2,$1, $3); }\t\n+| nonblock_expr '>' expr                                        { $$ = mk_node(NN_BiGt, 2,$1, $3); }\t\n+| nonblock_expr LE expr                                         { $$ = mk_node(NN_BiLe, 2,$1, $3); }\t\n+| nonblock_expr GE expr                                         { $$ = mk_node(NN_BiGe, 2,$1, $3); }\t\n+| nonblock_expr '|' expr                                        { $$ = mk_node(NN_BiBitOr, 2,$1, $3); }\t\n+| nonblock_expr '^' expr                                        { $$ = mk_node(NN_BiBitXor, 2,$1, $3); }\t\n+| nonblock_expr '&' expr                                        { $$ = mk_node(NN_BiBitAnd, 2,$1, $3); }\t\n+| nonblock_expr SHL expr                                        { $$ = mk_node(NN_BiShl, 2,$1, $3); }\t\n+| nonblock_expr SHR expr                                        { $$ = mk_node(NN_BiShr, 2,$1, $3); }\t\n+| nonblock_expr '+' expr                                        { $$ = mk_node(NN_BiAdd, 2,$1, $3); }\t\n+| nonblock_expr '-' expr                                        { $$ = mk_node(NN_BiSub, 2,$1, $3); }\t\n+| nonblock_expr '*' expr                                        { $$ = mk_node(NN_BiMul, 2,$1, $3); }\t\n+| nonblock_expr '/' expr                                        { $$ = mk_node(NN_BiDiv, 2,$1, $3); }\t\n+| nonblock_expr '%' expr                                        { $$ = mk_node(NN_BiRem, 2,$1, $3); }\t\n+| nonblock_expr DOTDOT                                          { $$ = mk_node(NN_ExprRange, 2, $1, mk_none()); }\t\n+| nonblock_expr DOTDOT expr                                     { $$ = mk_node(NN_ExprRange, 2, $1, $3); }\t\n+|               DOTDOT expr                                     { $$ = mk_node(NN_ExprRange, 2, mk_none(), $2); }\t\n+|               DOTDOT                                          { $$ = mk_node(NN_ExprRange, 2, mk_none(), mk_none()); }\t\n+| nonblock_expr AS ty                                           { $$ = mk_node(NN_ExprCast, 2, $1, $3); }\t\n+| nonblock_expr ':' ty                                          { $$ = mk_node(NN_ExprTypeAscr, 2, $1, $3); }\t\n+| BOX expr                                                      { $$ = mk_node(NN_ExprBox, 1, $2); }\t\n+| expr_qualified_path\t\n+| nonblock_prefix_expr\t\n+;\t\n+\n+expr\t\n+: lit                                                 { $$ = mk_node(NN_ExprLit, 1, $1); }\t\n+| %prec IDENT\t\n+  path_expr                                           { $$ = mk_node(NN_ExprPath, 1, $1); }\t\n+| SELF                                                { $$ = mk_node(NN_ExprPath, 1, mk_empty_atom(NN_SELF)); }\n+| macro_expr                                          { $$ = mk_node(NN_ExprMac, 1, $1); }\t\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(NN_ExprStruct, 2, $1, $3); }\t\n+| expr '?'                                            { $$ = mk_node(NN_ExprTry, 1, $1); }\t\n+| expr '.' path_generic_args_with_colons              { $$ = mk_node(NN_ExprField, 2, $1, $3); }\t\n+| expr '.' LIT_INTEGER                                { $$ = mk_node(NN_ExprTupleIndex, 1, $1); }\t\n+| expr '[' maybe_expr ']'                             { $$ = mk_node(NN_ExprIndex, 2, $1, $3); }\t\n+| expr '(' maybe_exprs ')'                            { $$ = mk_node(NN_ExprCall, 2, $1, $3); }\t\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(NN_ExprParen, 1, $2); }\t\n+| '[' vec_expr ']'                                    { $$ = mk_node(NN_ExprVec, 1, $2); }\t\n+| CONTINUE                                            { $$ = mk_node(NN_ExprAgain, 0); }\t\n+| CONTINUE ident                                      { $$ = mk_node(NN_ExprAgain, 1, $2); }\t\n+| RETURN                                              { $$ = mk_node(NN_ExprRet, 0); }\t\n+| RETURN expr                                         { $$ = mk_node(NN_ExprRet, 1, $2); }\t\n+| BREAK                                               { $$ = mk_node(NN_ExprBreak, 0); }\t\n+| BREAK ident                                         { $$ = mk_node(NN_ExprBreak, 1, $2); }\t\n+| YIELD                                               { $$ = mk_node(NN_ExprYield, 0); }\t\n+| YIELD expr                                          { $$ = mk_node(NN_ExprYield, 1, $2); }\t\n+| expr '=' expr                                       { $$ = mk_node(NN_ExprAssign, 2, $1, $3); }\t\n+| expr SHLEQ expr                                     { $$ = mk_node(NN_ExprAssignShl, 2, $1, $3); }\t\n+| expr SHREQ expr                                     { $$ = mk_node(NN_ExprAssignShr, 2, $1, $3); }\t\n+| expr MINUSEQ expr                                   { $$ = mk_node(NN_ExprAssignSub, 2, $1, $3); }\t\n+| expr ANDEQ expr                                     { $$ = mk_node(NN_ExprAssignBitAnd, 2, $1, $3); }\t\n+| expr OREQ expr                                      { $$ = mk_node(NN_ExprAssignBitOr, 2, $1, $3); }\t\n+| expr PLUSEQ expr                                    { $$ = mk_node(NN_ExprAssignAdd, 2, $1, $3); }\t\n+| expr STAREQ expr                                    { $$ = mk_node(NN_ExprAssignMul, 2, $1, $3); }\t\n+| expr SLASHEQ expr                                   { $$ = mk_node(NN_ExprAssignDiv, 2, $1, $3); }\t\n+| expr CARETEQ expr                                   { $$ = mk_node(NN_ExprAssignBitXor, 2, $1, $3); }\t\n+| expr PERCENTEQ expr                                 { $$ = mk_node(NN_ExprAssignRem, 2, $1, $3); }\t\n+| expr OROR expr                                      { $$ = mk_node(NN_BiOr, 2,$1, $3); }\t\n+| expr ANDAND expr                                    { $$ = mk_node(NN_BiAnd, 2,$1, $3); }\t\n+| expr EQEQ expr                                      { $$ = mk_node(NN_BiEq, 2,$1, $3); }\t\n+| expr NE expr                                        { $$ = mk_node(NN_BiNe, 2,$1, $3); }\t\n+| expr '<' expr                                       { $$ = mk_node(NN_BiLt, 2,$1, $3); }\t\n+| expr '>' expr                                       { $$ = mk_node(NN_BiGt, 2,$1, $3); }\t\n+| expr LE expr                                        { $$ = mk_node(NN_BiLe, 2,$1, $3); }\t\n+| expr GE expr                                        { $$ = mk_node(NN_BiGe, 2,$1, $3); }\t\n+| expr '|' expr                                       { $$ = mk_node(NN_BiBitOr, 2,$1, $3); }\t\n+| expr '^' expr                                       { $$ = mk_node(NN_BiBitXor, 2,$1, $3); }\t\n+| expr '&' expr                                       { $$ = mk_node(NN_BiBitAnd, 2,$1, $3); }\t\n+| expr SHL expr                                       { $$ = mk_node(NN_BiShl, 2,$1, $3); }\t\n+| expr SHR expr                                       { $$ = mk_node(NN_BiShr, 2,$1, $3); }\t\n+| expr '+' expr                                       { $$ = mk_node(NN_BiAdd, 2,$1, $3); }\t\n+| expr '-' expr                                       { $$ = mk_node(NN_BiSub, 2,$1, $3); }\t\n+| expr '*' expr                                       { $$ = mk_node(NN_BiMul, 2,$1, $3); }\t\n+| expr '/' expr                                       { $$ = mk_node(NN_BiDiv, 2,$1, $3); }\t\n+| expr '%' expr                                       { $$ = mk_node(NN_BiRem, 2,$1, $3); }\t\n+| expr DOTDOT                                         { $$ = mk_node(NN_ExprRange, 2, $1, mk_none()); }\t\n+| expr DOTDOT expr                                    { $$ = mk_node(NN_ExprRange, 2, $1, $3); }\t\n+|      DOTDOT expr                                    { $$ = mk_node(NN_ExprRange, 2, mk_none(), $2); }\t\n+|      DOTDOT                                         { $$ = mk_node(NN_ExprRange, 2, mk_none(), mk_none()); }\t\n+| expr AS ty                                          { $$ = mk_node(NN_ExprCast, 2, $1, $3); }\t\n+| expr ':' ty                                         { $$ = mk_node(NN_ExprTypeAscr, 2, $1, $3); }\t\n+| BOX expr                                            { $$ = mk_node(NN_ExprBox, 1, $2); }\t\n+| expr_qualified_path\t\n+| block_expr\t\n+| block\t\n+| nonblock_prefix_expr\t\n+;\t\n+\n+expr_nostruct\t\n+: lit                                                 { $$ = mk_node(NN_ExprLit, 1, $1); }\t\n+| %prec IDENT\t\n+  path_expr                                           { $$ = mk_node(NN_ExprPath, 1, $1); }\t\n+| SELF                                                { $$ = mk_node(NN_ExprPath, 1, mk_empty_atom(NN_SELF)); }\n+| macro_expr                                          { $$ = mk_node(NN_ExprMac, 1, $1); }\t\n+| expr_nostruct '?'                                   { $$ = mk_node(NN_ExprTry, 1, $1); }\t\n+| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(NN_ExprField, 2, $1, $3); }\t\n+| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(NN_ExprTupleIndex, 1, $1); }\t\n+| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(NN_ExprIndex, 2, $1, $3); }\t\n+| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(NN_ExprCall, 2, $1, $3); }\t\n+| '[' vec_expr ']'                                    { $$ = mk_node(NN_ExprVec, 1, $2); }\t\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(NN_ExprParen, 1, $2); }\t\n+| CONTINUE                                            { $$ = mk_node(NN_ExprAgain, 0); }\t\n+| CONTINUE ident                                      { $$ = mk_node(NN_ExprAgain, 1, $2); }\t\n+| RETURN                                              { $$ = mk_node(NN_ExprRet, 0); }\t\n+| RETURN expr                                         { $$ = mk_node(NN_ExprRet, 1, $2); }\t\n+| BREAK                                               { $$ = mk_node(NN_ExprBreak, 0); }\t\n+| BREAK ident                                         { $$ = mk_node(NN_ExprBreak, 1, $2); }\t\n+| YIELD                                               { $$ = mk_node(NN_ExprYield, 0); }\t\n+| YIELD expr                                          { $$ = mk_node(NN_ExprYield, 1, $2); }\t\n+| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(NN_ExprAssign, 2, $1, $3); }\t\n+| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(NN_ExprAssignShl, 2, $1, $3); }\t\n+| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(NN_ExprAssignShr, 2, $1, $3); }\t\n+| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(NN_ExprAssignSub, 2, $1, $3); }\t\n+| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(NN_ExprAssignBitAnd, 2, $1, $3); }\t\n+| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(NN_ExprAssignBitOr, 2, $1, $3); }\t\n+| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(NN_ExprAssignAdd, 2, $1, $3); }\t\n+| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(NN_ExprAssignMul, 2, $1, $3); }\t\n+| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(NN_ExprAssignDiv, 2, $1, $3); }\t\n+| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(NN_ExprAssignBitXor, 2, $1, $3); }\t\n+| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(NN_ExprAssignRem, 2, $1, $3); }\t\n+| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiOr), $1, $3); }\t\n+| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiAnd), $1, $3); }\t\n+| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiEq), $1, $3); }\t\n+| expr_nostruct NE expr_nostruct                      { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiNe), $1, $3); }\t\n+| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiLt), $1, $3); }\t\n+| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiGt), $1, $3); }\t\n+| expr_nostruct LE expr_nostruct                      { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiLe), $1, $3); }\t\n+| expr_nostruct GE expr_nostruct                      { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiGe), $1, $3); }\t\n+| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiBitOr), $1, $3); }\t\n+| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiBitXor), $1, $3); }\t\n+| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiBitAnd), $1, $3); }\t\n+| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiShl), $1, $3); }\t\n+| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiShr), $1, $3); }\t\n+| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiAdd), $1, $3); }\t\n+| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiSub), $1, $3); }\t\n+| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiMul), $1, $3); }\t\n+| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiDiv), $1, $3); }\t\n+| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(NN_ExprBinary, 3, mk_empty_atom(NN_BiRem), $1, $3); }\t\n+| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(NN_ExprRange, 2, $1, mk_none()); }\t\n+| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(NN_ExprRange, 2, $1, $3); }\t\n+|               DOTDOT expr_nostruct                  { $$ = mk_node(NN_ExprRange, 2, mk_none(), $2); }\t\n+|               DOTDOT                                { $$ = mk_node(NN_ExprRange, 2, mk_none(), mk_none()); }\t\n+| expr_nostruct AS ty                                 { $$ = mk_node(NN_ExprCast, 2, $1, $3); }\t\n+| expr_nostruct ':' ty                                { $$ = mk_node(NN_ExprTypeAscr, 2, $1, $3); }\t\n+| BOX expr                                            { $$ = mk_node(NN_ExprBox, 1, $2); }\t\n+| expr_qualified_path\t\n+| block_expr\t\n+| block\t\n+| nonblock_prefix_expr_nostruct\t\n+;\t\n+\n+nonblock_prefix_expr_nostruct\t\n+: '-' expr_nostruct                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnNeg), $2); }\t\n+| '!' expr_nostruct                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnNot), $2); }\t\n+| '*' expr_nostruct                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnDeref), $2); }\t\n+| '&' maybe_mut expr_nostruct               { $$ = mk_node(NN_ExprAddrOf, 2, $2, $3); }\t\n+| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(NN_ExprAddrOf, 1, mk_node(NN_ExprAddrOf, 2, $2, $3)); }\t\n+| lambda_expr_nostruct\t\n+| MOVE lambda_expr_nostruct                 { $$ = $2; }\t\n+;\t\n+\n+nonblock_prefix_expr\t\n+: '-' expr                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnNeg), $2); }\t\n+| '!' expr                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnNot), $2); }\t\n+| '*' expr                         { $$ = mk_node(NN_ExprUnary, 2, mk_empty_atom(NN_UnDeref), $2); }\t\n+| '&' maybe_mut expr               { $$ = mk_node(NN_ExprAddrOf, 2, $2, $3); }\t\n+| ANDAND maybe_mut expr            { $$ = mk_node(NN_ExprAddrOf, 1, mk_node(NN_ExprAddrOf, 2, $2, $3)); }\t\n+| lambda_expr\t\n+| MOVE lambda_expr                 { $$ = $2; }\t\n+;\t\n+\n+expr_qualified_path\t\n+: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\t\n+{\t\n+  $$ = mk_node(NN_ExprQualifiedPath, 4, $2, $3, $6, $7);\t\n+}\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\t\n+{\t\n+  $$ = mk_node(NN_ExprQualifiedPath, 3, mk_node(NN_ExprQualifiedPath, 3, $2, $3, $6), $7, $10);\t\n+}\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\t\n+{\t\n+  $$ = mk_node(NN_ExprQualifiedPath, 3, mk_node(NN_ExprQualifiedPath, 4, $2, $3, $6, $7), $8, $11);\t\n+}\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\t\n+{\t\n+  $$ = mk_node(NN_ExprQualifiedPath, 4, mk_node(NN_ExprQualifiedPath, 3, $2, $3, $6), $7, $10, $11);\t\n+}\t\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\t\n+{\t\n+  $$ = mk_node(NN_ExprQualifiedPath, 4, mk_node(NN_ExprQualifiedPath, 4, $2, $3, $6, $7), $8, $11, $12);\t\n+}\t\n+\n+maybe_qpath_params\t\n+: MOD_SEP generic_args { $$ = $2; }\t\n+| %empty               { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_as_trait_ref\t\n+: AS trait_ref { $$ = $2; }\t\n+| %empty       { $$ = mk_none(); }\t\n+;\t\n+\n+lambda_expr\t\n+: %prec LAMBDA\t\n+  OROR ret_ty expr                                    { $$ = mk_node(NN_ExprFnBlock, 3, mk_none(), $2, $3); }\t\n+| %prec LAMBDA\t\n+  '|' '|' ret_ty expr                                 { $$ = mk_node(NN_ExprFnBlock, 3, mk_none(), $3, $4); }\t\n+| %prec LAMBDA\t\n+  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(NN_ExprFnBlock, 3, $2, $4, $5); }\t\n+| %prec LAMBDA\t\n+  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(NN_ExprFnBlock, 3, $2, mk_none(), $4); }\t\n+;\t\n+\n+lambda_expr_no_first_bar\t\n+: %prec LAMBDA\t\n+  '|' ret_ty expr                                 { $$ = mk_node(NN_ExprFnBlock, 3, mk_none(), $2, $3); }\t\n+| %prec LAMBDA\t\n+  inferrable_params '|' ret_ty expr               { $$ = mk_node(NN_ExprFnBlock, 3, $1, $3, $4); }\t\n+| %prec LAMBDA\t\n+  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(NN_ExprFnBlock, 3, $1, mk_none(), $3); }\t\n+;\t\n+\n+lambda_expr_nostruct\t\n+: %prec LAMBDA\t\n+  OROR expr_nostruct                                           { $$ = mk_node(NN_ExprFnBlock, 2, mk_none(), $2); }\t\n+| %prec LAMBDA\t\n+  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(NN_ExprFnBlock, 3, mk_none(), $3, $4); }\t\n+| %prec LAMBDA\t\n+  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(NN_ExprFnBlock, 2, $2, $4); }\t\n+| %prec LAMBDA\t\n+  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(NN_ExprFnBlock, 3, $2, mk_none(), $4); }\t\n+;\t\n+\n+lambda_expr_nostruct_no_first_bar\t\n+: %prec LAMBDA\t\n+  '|' ret_ty expr_nostruct                                 { $$ = mk_node(NN_ExprFnBlock, 3, mk_none(), $2, $3); }\t\n+| %prec LAMBDA\t\n+  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(NN_ExprFnBlock, 3, $1, $3, $4); }\t\n+| %prec LAMBDA\t\n+  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(NN_ExprFnBlock, 3, $1, mk_none(), $3); }\t\n+;\t\n+\n+vec_expr\t\n+: maybe_exprs\t\n+| exprs ';' expr { $$ = mk_node(NN_VecRepeat, 2, $1, $3); }\t\n+;\t\n+\n+struct_expr_fields\t\n+: field_inits\t\n+| field_inits ','\t\n+| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\t\n+| %empty                               { $$ = mk_none(); }\t\n+;\t\n+\n+maybe_field_inits\t\n+: field_inits\t\n+| field_inits ','\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+field_inits\t\n+: field_init                 { $$ = mk_node(NN_FieldInits, 1, $1); }\t\n+| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\t\n+;\t\n+\n+field_init\t\n+: ident                { $$ = mk_node(NN_FieldInit, 1, $1); }\t\n+| ident ':' expr       { $$ = mk_node(NN_FieldInit, 2, $1, $3); }\t\n+| LIT_INTEGER ':' expr { $$ = mk_node(NN_FieldInit, 2, mk_atom(NN_LitInteger, yytext), $3); }\n+;\t\n+\n+default_field_init\t\n+: DOTDOT expr   { $$ = mk_node(NN_DefaultFieldInit, 1, $2); }\t\n+;\t\n+\n+block_expr\t\n+: expr_match\t\n+| expr_if\t\n+| expr_if_let\t\n+| expr_while\t\n+| expr_while_let\t\n+| expr_loop\t\n+| expr_for\t\n+| UNSAFE block                                           { $$ = mk_node(NN_UnsafeBlock, 1, $2); }\t\n+| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(NN_Macro, 3, $1, $3, $4); }\t\n+;\t\n+\n+full_block_expr\t\n+: block_expr\t\n+| block_expr_dot\t\n+;\t\n+\n+block_expr_dot\t\n+: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(NN_ExprField, 2, $1, $3); }\t\n+| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(NN_ExprField, 2, $1, $3); }\t\n+| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(NN_ExprIndex, 3, $1, $3, $5); }\t\n+| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(NN_ExprIndex, 3, $1, $3, $5); }\t\n+| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(NN_ExprCall, 3, $1, $3, $5); }\t\n+| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(NN_ExprCall, 3, $1, $3, $5); }\t\n+| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(NN_ExprTupleIndex, 1, $1); }\t\n+| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(NN_ExprTupleIndex, 1, $1); }\t\n+;\t\n+\n+expr_match\t\n+: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(NN_ExprMatch, 1, $2); }\t\n+| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(NN_ExprMatch, 2, $2, $4); }\t\n+| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(NN_ExprMatch, 2, $2, ext_node($4, 1, $5)); }\t\n+| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(NN_ExprMatch, 2, $2, mk_node(NN_Arms, 1, $4)); }\t\n+;\t\n+\n+match_clauses\n+: match_clause               { $$ = mk_node(NN_Arms, 1, $1); }\t\n+| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+match_clause\t\n+: nonblock_match_clause ','\t\n+| block_match_clause\t\n+| block_match_clause ','\t\n+;\t\n+\n+nonblock_match_clause\t\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(NN_ArmNonblock, 4, $1, $2, $3, $5); }\t\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(NN_ArmNonblock, 4, $1, $2, $3, $5); }\t\n+;\t\n+\n+block_match_clause\t\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(NN_ArmBlock, 4, $1, $2, $3, $5); }\t\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(NN_ArmBlock, 4, $1, $2, $3, $5); }\t\n+;\t\n+\n+maybe_guard\t\n+: IF expr_nostruct           { $$ = $2; }\t\n+| %empty                     { $$ = mk_none(); }\t\n+;\t\n+\n+expr_if\t\n+: IF expr_nostruct block                              { $$ = mk_node(NN_ExprIf, 2, $2, $3); }\t\n+| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(NN_ExprIf, 3, $2, $3, $5); }\t\n+;\t\n+\n+expr_if_let\t\n+: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(NN_ExprIfLet, 3, $3, $5, $6); }\t\n+| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(NN_ExprIfLet, 4, $3, $5, $6, $8); }\t\n+;\t\n+\n+block_or_if\t\n+: block\t\n+| expr_if\t\n+| expr_if_let\t\n+;\t\n+\n+expr_while\t\n+: maybe_label WHILE expr_nostruct block               { $$ = mk_node(NN_ExprWhile, 3, $1, $3, $4); }\t\n+;\t\n+\n+expr_while_let\t\n+: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(NN_ExprWhileLet, 4, $1, $4, $6, $7); }\t\n+;\t\n+\n+expr_loop\t\n+: maybe_label LOOP block                              { $$ = mk_node(NN_ExprLoop, 2, $1, $3); }\t\n+;\t\n+\n+expr_for\t\n+: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(NN_ExprForLoop, 4, $1, $3, $5, $6); }\t\n+;\t\n+\n+maybe_label\t\n+: lifetime ':'\t\n+| %empty { $$ = mk_none(); }\t\n+;\t\n+\n+let\t\n+: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(NN_DeclLocal, 3, $2, $3, $4); }\t\n+;\t\n+\n+////////////////////////////////////////////////////////////////////////\t\n+// Part 5: Macros and misc. rules\t\n+////////////////////////////////////////////////////////////////////////\t\n+\n+lit\t\n+: LIT_BYTE                   { $$ = mk_atom(NN_LitByte, yytext); }\n+| LIT_CHAR                   { $$ = mk_atom(NN_LitChar, yytext); }\n+| LIT_INTEGER                { $$ = mk_atom(NN_LitInteger, yytext); }\n+| LIT_FLOAT                  { $$ = mk_atom(NN_LitFloat, yytext); }\n+| XTRUE                       { $$ = mk_atom(NN_LitBool, yytext); }\n+| XFALSE                      { $$ = mk_atom(NN_LitBool, yytext); }\n+| str\t\n+;\t\n+\n+str\t\n+: LIT_STR                    { $$ = mk_atom(NN_LIT_STR, yytext); }\n+| LIT_STR_RAW                { $$ = mk_atom(NN_LIT_STR_RAW, yytext); }\n+| LIT_BYTE_STR               { $$ = mk_atom(NN_LIT_BYTE_STR, yytext); }\n+| LIT_BYTE_STR_RAW           { $$ = mk_atom(NN_LIT_BYTE_STR_RAW, yytext); }\n+;\t\n+\n+maybe_ident\t\n+: %empty { $$ = mk_none(); }\t\n+| ident\t\n+;\t\n+\n+ident\t\n+: IDENT                      { $$ = mk_node(NN_ident, 1, mk_atom(NN_IDENT, yytext)); }\t\n+// Weak keywords that can be used as identifiers\t\n+| CATCH                      { $$ = mk_node(NN_ident, 1, mk_atom(NN_CATCH, yytext)); }\t\n+| DEFAULT                    { $$ = mk_node(NN_ident, 1, mk_atom(NN_DEFAULT, yytext)); }\t\n+| UNION                      { $$ = mk_node(NN_ident, 1, mk_atom(NN_UNION, yytext)); }\t\n+;\t\n+\n+unpaired_token\t\n+: SHL                        { $$ = mk_empty_atom(NN_SHL); }\t\n+| SHR                        { $$ = mk_empty_atom(NN_SHR); }\t\n+| LE                         { $$ = mk_empty_atom(NN_LE); }\t\n+| EQEQ                       { $$ = mk_empty_atom(NN_EQEQ); }\t\n+| NE                         { $$ = mk_empty_atom(NN_NE); }\t\n+| GE                         { $$ = mk_empty_atom(NN_GE); }\t\n+| ANDAND                     { $$ = mk_empty_atom(NN_ANDAND); }\n+| OROR                       { $$ = mk_empty_atom(NN_OROR); }\n+| LARROW                     { $$ = mk_empty_atom(NN_LARROW); }\n+| SHLEQ                      { $$ = mk_empty_atom(NN_SHLEQ); }\n+| SHREQ                      { $$ = mk_empty_atom(NN_SHREQ); }\n+| MINUSEQ                    { $$ = mk_empty_atom(NN_MINUSEQ); }\n+| ANDEQ                      { $$ = mk_empty_atom(NN_ANDEQ); }\n+| OREQ                       { $$ = mk_empty_atom(NN_OREQ); }\n+| PLUSEQ                     { $$ = mk_empty_atom(NN_PLUSEQ); }\n+| STAREQ                     { $$ = mk_empty_atom(NN_STAREQ); }\n+| SLASHEQ                    { $$ = mk_empty_atom(NN_SLASHEQ); }\n+| CARETEQ                    { $$ = mk_empty_atom(NN_CARETEQ); }\n+| PERCENTEQ                  { $$ = mk_empty_atom(NN_PERCENTEQ); }\n+| DOTDOT                     { $$ = mk_empty_atom(NN_DOTDOT); }\n+| DOTDOTDOT                  { $$ = mk_empty_atom(NN_DOTDOTDOT); }\n+| MOD_SEP                    { $$ = mk_empty_atom(NN_MOD_SEP); }\n+| RARROW                     { $$ = mk_empty_atom(NN_RARROW); }\n+| FAT_ARROW                  { $$ = mk_empty_atom(NN_FAT_ARROW); }\n+| LIT_BYTE                   { $$ = mk_atom(NN_LIT_BYTE, yytext); }\n+| LIT_CHAR                   { $$ = mk_atom(NN_LIT_CHAR, yytext); }\n+| LIT_INTEGER                { $$ = mk_atom(NN_LIT_INTEGER, yytext); }\n+| LIT_FLOAT                  { $$ = mk_atom(NN_LIT_FLOAT, yytext); }\n+| LIT_STR                    { $$ = mk_atom(NN_LIT_STR, yytext); }\n+| LIT_STR_RAW                { $$ = mk_atom(NN_LIT_STR_RAW, yytext); }\n+| LIT_BYTE_STR               { $$ = mk_atom(NN_LIT_BYTE_STR, yytext); }\n+| LIT_BYTE_STR_RAW           { $$ = mk_atom(NN_LIT_BYTE_STR_RAW, yytext); }\n+| IDENT                      { $$ = mk_atom(NN_IDENT, yytext); }\n+| UNDERSCORE                 { $$ = mk_empty_atom(NN_UNDERSCORE); }\n+| LIFETIME                   { $$ = mk_empty_atom(NN_LIFETIME); }\t\n+| SELF                       { $$ = mk_empty_atom(NN_SELF); }\t\n+| STATIC                     { $$ = mk_empty_atom(NN_STATIC); }\t\n+| ABSTRACT                   { $$ = mk_empty_atom(NN_ABSTRACT); }\t\n+| ALIGNOF                    { $$ = mk_empty_atom(NN_ALIGNOF); }\t\n+| AS                         { $$ = mk_empty_atom(NN_AS); }\t\n+| BECOME                     { $$ = mk_empty_atom(NN_BECOME); }\t\n+| BREAK                      { $$ = mk_empty_atom(NN_BREAK); }\t\n+| CATCH                      { $$ = mk_empty_atom(NN_CATCH); }\t\n+| CRATE                      { $$ = mk_empty_atom(NN_CRATE); }\t\n+| DEFAULT                    { $$ = mk_empty_atom(NN_DEFAULT); }\t\n+| DO                         { $$ = mk_empty_atom(NN_DO); }\t\n+| ELSE                       { $$ = mk_empty_atom(NN_ELSE); }\t\n+| ENUM                       { $$ = mk_empty_atom(NN_ENUM); }\t\n+| EXTERN                     { $$ = mk_empty_atom(NN_EXTERN); }\t\n+| XFALSE                     { $$ = mk_empty_atom(NN_XFALSE); }\t\n+| FINAL                      { $$ = mk_empty_atom(NN_FINAL); }\t\n+| FN                         { $$ = mk_empty_atom(NN_FN); }\t\n+| FOR                        { $$ = mk_empty_atom(NN_FOR); }\t\n+| IF                         { $$ = mk_empty_atom(NN_IF); }\t\n+| IMPL                       { $$ = mk_empty_atom(NN_IMPL); }\t\n+| IN                         { $$ = mk_empty_atom(NN_IN); }\t\n+| LET                        { $$ = mk_empty_atom(NN_LET); }\t\n+| LOOP                       { $$ = mk_empty_atom(NN_LOOP); }\t\n+| MACRO                      { $$ = mk_empty_atom(NN_MACRO); }\t\n+| MATCH                      { $$ = mk_empty_atom(NN_MATCH); }\t\n+| MOD                        { $$ = mk_empty_atom(NN_MOD); }\t\n+| MOVE                       { $$ = mk_empty_atom(NN_MOVE); }\t\n+| MUT                        { $$ = mk_empty_atom(NN_MUT); }\t\n+| OFFSETOF                   { $$ = mk_empty_atom(NN_OFFSETOF); }\t\n+| OVERRIDE                   { $$ = mk_empty_atom(NN_OVERRIDE); }\t\n+| PRIV                       { $$ = mk_empty_atom(NN_PRIV); }\t\n+| PUB                        { $$ = mk_empty_atom(NN_PUB); }\t\n+| PURE                       { $$ = mk_empty_atom(NN_PURE); }\t\n+| REF                        { $$ = mk_empty_atom(NN_REF); }\t\n+| RETURN                     { $$ = mk_empty_atom(NN_RETURN); }\t\n+| STRUCT                     { $$ = mk_empty_atom(NN_STRUCT); }\t\n+| SIZEOF                     { $$ = mk_empty_atom(NN_SIZEOF); }\t\n+| SUPER                      { $$ = mk_empty_atom(NN_SUPER); }\t\n+| XTRUE                      { $$ = mk_empty_atom(NN_XTRUE); }\t\n+| TRAIT                      { $$ = mk_empty_atom(NN_TRAIT); }\t\n+| TYPE                       { $$ = mk_empty_atom(NN_TYPE); }\t\n+| UNION                      { $$ = mk_empty_atom(NN_UNION); }\t\n+| UNSAFE                     { $$ = mk_empty_atom(NN_UNSAFE); }\t\n+| UNSIZED                    { $$ = mk_empty_atom(NN_UNSIZED); }\t\n+| USE                        { $$ = mk_empty_atom(NN_USE); }\t\n+| VIRTUAL                    { $$ = mk_empty_atom(NN_VIRTUAL); }\t\n+| WHILE                      { $$ = mk_empty_atom(NN_WHILE); }\t\n+| YIELD                      { $$ = mk_empty_atom(NN_YIELD); }\t\n+| CONTINUE                   { $$ = mk_empty_atom(NN_CONTINUE); }\t\n+| PROC                       { $$ = mk_empty_atom(NN_PROC); }\t\n+| BOX                        { $$ = mk_empty_atom(NN_BOX); }\t\n+| CONST                      { $$ = mk_empty_atom(NN_CONST); }\t\n+| WHERE                      { $$ = mk_empty_atom(NN_WHERE); }\t\n+| TYPEOF                     { $$ = mk_empty_atom(NN_TYPEOF); }\t\n+| INNER_DOC_COMMENT          { $$ = mk_empty_atom(NN_INNER_DOC_COMMENT); }\t\n+| OUTER_DOC_COMMENT          { $$ = mk_empty_atom(NN_OUTER_DOC_COMMENT); }\t\n+| SHEBANG                    { $$ = mk_empty_atom(NN_SHEBANG); }\t\n+| STATIC_LIFETIME            { $$ = mk_empty_atom(NN_STATIC_LIFETIME); }\t\n+| ';'                        { $$ = mk_empty_atom(NN_SEMI_COLON); }\n+| ','                        { $$ = mk_empty_atom(NN_COMMA); }\n+| '.'                        { $$ = mk_empty_atom(NN_SINGLE_DOT); }\n+| '@'                        { $$ = mk_empty_atom(NN_AT); }\n+| '#'                        { $$ = mk_empty_atom(NN_HASH); }\n+| '~'                        { $$ = mk_empty_atom(NN_TILDA); }\t\n+| ':'                        { $$ = mk_empty_atom(NN_COLON); }\t\n+| '$'                        { $$ = mk_empty_atom(NN_DOLLAR); }\t\n+| '='                        { $$ = mk_empty_atom(NN_EQUALS); }\t\n+| '?'                        { $$ = mk_empty_atom(NN_QUESTION); }\t\n+| '!'                        { $$ = mk_empty_atom(NN_EXCLAIM); }\t\n+| '<'                        { $$ = mk_empty_atom(NN_LESS_THAN); }\t\n+| '>'                        { $$ = mk_empty_atom(NN_GREATER_THAN); }\t\n+| '-'                        { $$ = mk_empty_atom(NN_MINUS); }\t\n+| '&'                        { $$ = mk_empty_atom(NN_AMPERSAND); }\t\n+| '|'                        { $$ = mk_empty_atom(NN_PIPE); }\t\n+| '+'                        { $$ = mk_empty_atom(NN_PLUS); }\t\n+| '*'                        { $$ = mk_empty_atom(NN_MULT); }\t\n+| '/'                        { $$ = mk_empty_atom(NN_DIVIDE); }\t\n+| '^'                        { $$ = mk_empty_atom(NN_HAT); }\t\n+| '%'                        { $$ = mk_empty_atom(NN_PERCENTAGE); }\t\n+;\t\n+\n+token_trees\t\n+: %empty                     { $$ = mk_node(NN_TokenTrees, 0); }\t\n+| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\t\n+;\t\n+\n+token_tree\t\n+: delimited_token_trees\t\n+| unpaired_token         { $$ = mk_node(NN_TTTok, 1, $1); }\t\n+;\t\n+\n+delimited_token_trees\t\n+: parens_delimited_token_trees\t\n+| braces_delimited_token_trees\t\n+| brackets_delimited_token_trees\t\n+;\t\n+\n+parens_delimited_token_trees\t\n+: '(' token_trees ')'\t\n+{\t\n+  $$ = mk_node(NN_TTDelim, 1, $2);\n+}\t\n+;\t\n+\n+braces_delimited_token_trees\t\n+: '{' token_trees '}'\t\n+{\t\n+  $$ = mk_node(NN_TTDelim, 1, $2);\n+}\t\n+;\t\n+\n+brackets_delimited_token_trees\t\n+: '[' token_trees ']'\t\n+{\t\n+    $$ = mk_node(NN_TTDelim, 1, $2);\n+}\t\n+;\n+\n+%%\n+\n+void yyerror (const char* msg)\n+{\n+    fatal_error (UNKNOWN_LOCATION, \"%s at line %i\\n\", msg, yylineno);\n+}"}, {"sha": "eb14194bec42a0d8b0651ae5102ce00170da4525", "filename": "gcc/rust/rustfrontend/rustly.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frustly.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,83 @@\n+#include \"rustly.h\"\n+#include \"node.h\"\n+\n+extern FILE* yyin;\n+static Rustly* rustly;\n+\n+\n+Rustly::Rustly (bool only_check_syntax, Linemap* linemap)\n+    : mSyntaxOnly(only_check_syntax),\n+      mLinemap(linemap)\n+{\n+    \n+}\n+\n+Rustly::~Rustly ()\n+{\n+    \n+}\n+\n+void Rustly::parse_input_files (size_t n, const char** in)\n+{\n+    int verbose = 1;\n+    parser_init(verbose);\n+\n+    int ret = 0;\n+    \n+    size_t i;\n+    for (i = 0; i < n; ++i)\n+    {\n+        yyin = fopen(in[i], \"rb\");\n+        if (yyin == NULL) {\n+            fatal_error(UNKNOWN_LOCATION, \"FAILED TO OPEN %s\", in[i]);\n+            return;\n+        }\n+\n+        ret = yyparse();        \n+    }\n+\n+\n+    printf(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n+    if (nodes) {\t\n+        print_node(nodes, 0);\t\n+    }\n+\n+    // FIXME double-free exists here\n+    // struct node *tmp;\n+    // while (nodes) {\t\n+    //     tmp = nodes;\n+    //     nodes = tmp->next;\t\n+    //     if (tmp->own_string) {\t\n+    //         free((void*)tmp->name);\n+    //     }\n+    //     free(tmp);\t\n+    // }\n+\n+    if (mSyntaxOnly)\n+        return;\n+\n+\n+    // do type inferance\n+\n+    // convert to GENERIC tree's\n+}\n+\n+\n+void Rustly::do_compile()\n+{\n+    // TODO\n+}\n+\n+// C INTERFACE THIS NEEDS CLEANUP AT SOMEPOINT\n+\n+void\n+rust_create_rustly(bool only_check_syntax, Linemap* linemap)\n+{\n+    rustly = new Rustly(only_check_syntax, linemap);\n+}\n+\n+void\n+rust_parse_input_files (const char** in, unsigned int n)\n+{\n+    rustly->parse_input_files(n, in);\n+}"}, {"sha": "db7455f5ae3f266d6300fde287a02fc6ff96bee7", "filename": "gcc/rust/rustfrontend/rustly.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frustly.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,26 @@\n+#pragma once\n+\n+#include \"rust-linemap.h\"\n+#include \"rust-system.h\"\n+#include \"rust-c.h\"\n+\n+#include \"rs-parser.h\"\n+#include \"node.h\"\n+\n+class Rustly\n+{\n+public:\n+    Rustly(bool only_check_syntax, Linemap* mLinemap);\n+    \n+    ~Rustly();\n+\n+    void parse_input_files (size_t n, const char** in);\n+\n+    void do_compile();\n+\n+private:\n+    bool     mSyntaxOnly;\n+    Linemap* mLinemap;\n+};\n+\n+"}, {"sha": "101237d0bda56f6ea5598b51fefc08383080c810", "filename": "gcc/rust/rustspec.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -44,7 +44,10 @@ along with GCC; see the file COPYING3.  If not see\n #define THREAD_LIBRARY \"pthread\"\n #define THREAD_LIBRARY_PROFILE THREAD_LIBRARY\n \n+<<<<<<< HEAD\n // Refers to compiler driver: handles calling the compiler (i.e. options, libraries to use)\n+=======\n+>>>>>>> c611d209696bd5983b4b777be0beea80351dee46\n void\n lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t\t      unsigned int *in_decoded_options_count,"}, {"sha": "32e351ad53b451472e89a28f5427d39869c0a97c", "filename": "gcc/rust/test/test1..s", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1..s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1..s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1..s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1 @@\n+\t.file\t\"test1.\""}, {"sha": "e6cfaaea5bd46f52ea998b02a4d673816dab7838", "filename": "gcc/rust/test/test1.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = 1;\n+    let y = x;\n+}"}, {"sha": "d3126f9e76835aaa3ceb001b627c382899492354", "filename": "gcc/rust/test/test1.s", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1.s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,17 @@\n+\t.file\t\"test1.rs\"\n+\t.text\n+.Ltext0:\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.text\n+.Letext0:\n+\t.section\t.debug_line,\"\",@progbits\n+.Ldebug_line0:\n+\t.section\t.debug_str,\"MS\",@progbits,1\n+.LASF0:\n+\t.string\t\"../gccrs/gcc/rust/test/test1.rs\"\n+.LASF1:\n+\t.string\t\"/home/redbrain/workspace/gccrs-build\"\n+.LASF2:\n+\t.string\t\"GNU Rust 10.0.0 20191127 (experimental) -O0\"\n+\t.ident\t\"GCC: (GNU) 10.0.0 20191127 (experimental)\"\n+\t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "3999215544e80487651da99a199a1d29e570218b", "filename": "gcc/rust/test/test2-minimal.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2-minimal.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2-minimal.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2-minimal.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,25 @@\n+macro_rules! println {\n+    () => { ... };\n+    ($($arg:tt)*) => { ... };\n+}\n+\n+// if macro stuff is commented out, parses fine.\n+// if everything but macro stuff is commented out, segfault. so segfault occurs due to macro stuff\n+\n+// Function that returns a boolean value\n+/*fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n+    // Corner case, early return\n+    if rhs == 0 {\n+        return false;\n+    }\n+\n+    // This is an expression, the `return` keyword is not necessary here\n+    lhs % rhs == 0\n+}\n+\n+\n+\n+fn main() {\n+    let mut x = is_divisible(3, 12);\n+}*/\n+"}, {"sha": "976f1f37c3e83eb523e46b24bab07e836c0a2da2", "filename": "gcc/rust/test/test2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,18 @@\n+\n+// Function that returns a boolean value\n+fn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n+    // Corner case, early return\n+    if rhs == 0 {\n+        return false;\n+    }\n+\n+    // This is an expression, the `return` keyword is not necessary here\n+    lhs % rhs == 0\n+}\n+\n+\n+\n+fn main() {\n+    let mut x:i32 = is_divisible(3, 12);\n+}\n+"}, {"sha": "75ff5c45494014a52826d50907712745ebe4bc29", "filename": "gcc/rust/test/test2.s", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2.s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,17 @@\n+\t.file\t\"test2.rs\"\n+\t.text\n+.Ltext0:\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.text\n+.Letext0:\n+\t.section\t.debug_line,\"\",@progbits\n+.Ldebug_line0:\n+\t.section\t.debug_str,\"MS\",@progbits,1\n+.LASF0:\n+\t.string\t\"/home/redbrain/workspace/gccrs-build\"\n+.LASF1:\n+\t.string\t\"../gccrs/gcc/rust/test/test2.rs\"\n+.LASF2:\n+\t.string\t\"GNU Rust 10.0.0 20191127 (experimental)\"\n+\t.ident\t\"GCC: (GNU) 10.0.0 20191127 (experimental)\"\n+\t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "36d908ccb3aaf6f56185ac1f7c0b615b798d5387", "filename": "gcc/rust/test3/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2FMake-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -77,6 +77,7 @@ GRS_OBJS = \\\n     rust/rust-scope.o \\\n     rust/rust-misc-convert.o \\\n \trust/rust-ast-full-test.o \\\n+\trust/rust-session-manager.o \\\n     $(END)\n # removed object files from here \n \n@@ -219,6 +220,7 @@ RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n CFLAGS-rust/rust-lex.o += $(RUST_INCLUDES)\n CFLAGS-rust/rust-parse.o += $(RUST_INCLUDES)\n+CFLAGS-rust/rust-session-manager.o += $(RUST_INCLUDES)\n \n # TODO: possibly find a way to ensure C++11 compilation level here?\n "}, {"sha": "a76a59938f63304d5ead3e4598e31ee10268fb27", "filename": "gcc/rust/test3/ast/rust-ast-full-decls.h", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-decls.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,265 @@\n+#ifndef RUST_AST_FULL_DECLS_H\n+#define RUST_AST_FULL_DECLS_H\n+// Forward declarations for all AST classes. Useful for not having to include all definitions.\n+\n+namespace Rust {\n+    namespace AST {\n+        // rust-ast.h\n+        class AttrInput;\n+        class TokenTree;\n+        class MacroMatch;\n+        class Token;\n+        struct Literal;\n+        class DelimTokenTree;\n+        class PathSegment;\n+        class SimplePathSegment;\n+        class SimplePath;\n+        struct Attribute;\n+        class MetaItemInner;\n+        class AttrInputMetaItemContainer;\n+        class MetaItem;\n+        class Stmt;\n+        class Item;\n+        class Expr;\n+        class ExprWithoutBlock;\n+        class IdentifierExpr;\n+        class Pattern;\n+        class Type;\n+        class TypeNoBounds;\n+        class TypeParamBound;\n+        class Lifetime;\n+        class GenericParam;\n+        class LifetimeParam;\n+        class MacroItem;\n+        class TraitItem;\n+        class InherentImplItem;\n+        class TraitImplItem;\n+        class MacroInvocationSemi;\n+        struct Crate;\n+        class PathExpr;\n+\n+        // rust-path.h\n+        class PathIdentSegment;\n+        struct GenericArgsBinding;\n+        struct GenericArgs;\n+        class PathExprSegment;\n+        class PathPattern;\n+        class PathInExpression;\n+        class TypePathSegment;\n+        class TypePathSegmentGeneric;\n+        struct TypePathFunction;\n+        class TypePathSegmentFunction;\n+        class TypePath;\n+        struct QualifiedPathType;\n+        class QualifiedPathInExpression;\n+        class QualifiedPathInType;\n+\n+        // rust-expr.h\n+        class ExprWithBlock;\n+        class LiteralExpr;\n+        class AttrInputLiteral;\n+        class MetaItemLitExpr;\n+        class MetaItemPathLit;\n+        class OperatorExpr;\n+        class BorrowExpr;\n+        class DereferenceExpr;\n+        class ErrorPropagationExpr;\n+        class NegationExpr;\n+        class ArithmeticOrLogicalExpr;\n+        class ComparisonExpr;\n+        class LazyBooleanExpr;\n+        class TypeCastExpr;\n+        class AssignmentExpr;\n+        class CompoundAssignmentExpr;\n+        class GroupedExpr;\n+        class ArrayElems;\n+        class ArrayElemsValues;\n+        class ArrayElemsCopied;\n+        class ArrayExpr;\n+        class ArrayIndexExpr;\n+        class TupleExpr;\n+        class TupleIndexExpr;\n+        class StructExpr;\n+        class StructExprStruct;\n+        struct StructBase;\n+        class StructExprField;\n+        class StructExprFieldIdentifier;\n+        class StructExprFieldWithVal;\n+        class StructExprFieldIdentifierValue;\n+        class StructExprFieldIndexValue;\n+        class StructExprStructFields;\n+        class StructExprStructBase;\n+        class StructExprTuple;\n+        class StructExprUnit;\n+        class EnumVariantExpr;\n+        class EnumExprField;\n+        class EnumExprFieldIdentifier;\n+        class EnumExprFieldWithVal;\n+        class EnumExprFieldIdentifierValue;\n+        class EnumExprFieldIndexValue;\n+        class EnumExprStruct;\n+        class EnumExprTuple;\n+        class EnumExprFieldless;\n+        class CallExpr;\n+        class MethodCallExpr;\n+        class FieldAccessExpr;\n+        struct ClosureParam;\n+        class ClosureExpr;\n+        class ClosureExprInner;\n+        class BlockExpr;\n+        class ClosureExprInnerTyped;\n+        class ContinueExpr;\n+        class BreakExpr;\n+        class RangeExpr;\n+        class RangeFromToExpr;\n+        class RangeFromExpr;\n+        class RangeToExpr;\n+        class RangeFullExpr;\n+        class RangeFromToInclExpr;\n+        class RangeToInclExpr;\n+        class ReturnExpr;\n+        class UnsafeBlockExpr;\n+        class LoopLabel;\n+        class BaseLoopExpr;\n+        class LoopExpr;\n+        class WhileLoopExpr;\n+        class WhileLetLoopExpr;\n+        class ForLoopExpr;\n+        class IfExpr;\n+        class IfExprConseqElse;\n+        class IfExprConseqIf;\n+        class IfLetExpr;\n+        class IfExprConseqIfLet;\n+        class IfLetExprConseqElse;\n+        class IfLetExprConseqIf;\n+        class IfLetExprConseqIfLet;\n+        struct MatchArm;\n+        class MatchCase;\n+        class MatchCaseBlockExpr;\n+        class MatchCaseExpr;\n+        class MatchExpr;\n+        class AwaitExpr;\n+        class AsyncBlockExpr;\n+\n+        // rust-stmt.h\n+        class EmptyStmt;\n+        class LetStmt;\n+        class ExprStmt;\n+        class ExprStmtWithoutBlock;\n+        class ExprStmtWithBlock;\n+\n+        // rust-item.h\n+        class TypeParam;\n+        class WhereClauseItem;\n+        class LifetimeWhereClauseItem;\n+        class TypeBoundWhereClauseItem;\n+        struct WhereClause;\n+        struct SelfParam;\n+        struct FunctionQualifiers;\n+        struct FunctionParam;\n+        struct Visibility;\n+        class Method;\n+        class VisItem;\n+        class Module;\n+        class ModuleBodied;\n+        class ModuleNoBody;\n+        class ExternCrate;\n+        class UseTree;\n+        class UseTreeGlob;\n+        class UseTreeList;\n+        class UseTreeRebind;\n+        class UseDeclaration;\n+        class Function;\n+        class TypeAlias;\n+        class Struct;\n+        struct StructField;\n+        class StructStruct;\n+        struct TupleField;\n+        class TupleStruct;\n+        class EnumItem;\n+        class EnumItemTuple;\n+        class EnumItemStruct;\n+        class EnumItemDiscriminant;\n+        class Enum;\n+        class Union;\n+        class ConstantItem;\n+        class StaticItem;\n+        struct TraitFunctionDecl;\n+        class TraitItemFunc;\n+        struct TraitMethodDecl;\n+        class TraitItemMethod;\n+        class TraitItemConst;\n+        class TraitItemType;\n+        class Trait;\n+        class Impl;\n+        class InherentImpl;\n+        class TraitImpl;\n+        class ExternalItem;\n+        class ExternalStaticItem;\n+        struct NamedFunctionParam;\n+        class ExternalFunctionItem;\n+        class ExternBlock;\n+\n+        // rust-macro.h\n+        class MacroMatchFragment;\n+        class MacroMatchRepetition;\n+        class MacroMatcher;\n+        struct MacroTranscriber;\n+        struct MacroRule;\n+        class MacroRulesDefinition;\n+        class MacroInvocation;\n+        class MetaItemPath;\n+        class MetaItemSeq;\n+        class MetaWord;\n+        class MetaNameValueStr;\n+        class MetaListPaths;\n+        class MetaListNameValueStr;\n+\n+        // rust-pattern.h\n+        class LiteralPattern;\n+        class IdentifierPattern;\n+        class WildcardPattern;\n+        class RangePatternBound;\n+        class RangePatternBoundLiteral;\n+        class RangePatternBoundPath;\n+        class RangePatternBoundQualPath;\n+        class RangePattern;\n+        class ReferencePattern;\n+        struct StructPatternEtc;\n+        class StructPatternField;\n+        class StructPatternFieldTuplePat;\n+        class StructPatternFieldIdentPat;\n+        class StructPatternFieldIdent;\n+        struct StructPatternElements;\n+        class StructPattern;\n+        class TupleStructItems;\n+        class TupleStructItemsNoRange;\n+        class TupleStructItemsRange;\n+        class TupleStructPattern;\n+        class TuplePatternItems;\n+        class TuplePatternItemsMultiple;\n+        class TuplePatternItemsRanged;\n+        class TuplePattern;\n+        class GroupedPattern;\n+        class SlicePattern;\n+\n+        // rust-type.h\n+        class TraitBound;\n+        class ImplTraitType;\n+        class TraitObjectType;\n+        class ParenthesisedType;\n+        class ImplTraitTypeOneBound;\n+        class TraitObjectTypeOneBound;\n+        class TupleType;\n+        class NeverType;\n+        class RawPointerType;\n+        class ReferenceType;\n+        class ArrayType;\n+        class SliceType;\n+        class InferredType;\n+        struct MaybeNamedParam;\n+        class BareFunctionType;\n+    }\n+}\n+\n+#endif\n\\ No newline at end of file"}, {"sha": "6eb48cc896cff9fb2e46818bddf65bd994b140de", "filename": "gcc/rust/test3/ast/rust-ast-full-test.cc", "status": "modified", "additions": 4104, "deletions": 322, "changes": 4426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b8e92c208e1447d074624160d736e5768862cb63", "filename": "gcc/rust/test3/ast/rust-ast-visitor.h", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-visitor.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,224 @@\n+#ifndef RUST_AST_VISITOR_H\n+#define RUST_AST_VISITOR_H\n+// Visitor base for AST \n+\n+// full include not required - only forward decls\n+#include \"rust-ast-full-decls.h\"\n+\n+namespace Rust {\n+    namespace AST {\n+        // Pure abstract class that provides an interface for accessing different classes of the AST. \n+        class ASTVisitor {\n+          public:\n+            // only concrete class overloads are required\n+\n+            // rust-ast.h\n+            //virtual void visit(AttrInput& attr_input) = 0;\n+            //virtual void visit(TokenTree& token_tree) = 0;\n+            //virtual void visit(MacroMatch& macro_match) = 0;\n+            virtual void visit(Token& tok) = 0;\n+            virtual void visit(DelimTokenTree& delim_tok_tree) = 0;\n+            virtual void visit(AttrInputMetaItemContainer& input) = 0;\n+            //virtual void visit(MetaItem& meta_item) = 0;\n+            //virtual void visit(Stmt& stmt) = 0;\n+            //virtual void visit(Expr& expr) = 0;\n+            virtual void visit(IdentifierExpr& ident_expr) = 0;\n+            //virtual void visit(Pattern& pattern) = 0;\n+            //virtual void visit(Type& type) = 0;\n+            //virtual void visit(TypeParamBound& type_param_bound) = 0;\n+            virtual void visit(Lifetime& lifetime) = 0;\n+            //virtual void visit(GenericParam& generic_param) = 0;\n+            virtual void visit(LifetimeParam& lifetime_param) = 0;\n+            //virtual void visit(TraitItem& trait_item) = 0;\n+            //virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n+            //virtual void visit(TraitImplItem& trait_impl_item) = 0;\n+            virtual void visit(MacroInvocationSemi& macro) = 0;\n+            \n+            // rust-path.h\n+            virtual void visit(PathInExpression& path) = 0;\n+            virtual void visit(TypePathSegment& segment) = 0;\n+            virtual void visit(TypePathSegmentGeneric& segment) = 0;\n+            virtual void visit(TypePathSegmentFunction& segment) = 0;\n+            virtual void visit(TypePath& path) = 0;\n+            virtual void visit(QualifiedPathInExpression& path) = 0;\n+            virtual void visit(QualifiedPathInType& path) = 0;\n+\n+            // rust-expr.h\n+            virtual void visit(LiteralExpr& expr) = 0;\n+            virtual void visit(AttrInputLiteral& attr_input) = 0;\n+            virtual void visit(MetaItemLitExpr& meta_item) = 0;\n+            virtual void visit(MetaItemPathLit& meta_item) = 0;\n+            virtual void visit(BorrowExpr& expr) = 0;\n+            virtual void visit(DereferenceExpr& expr) = 0;\n+            virtual void visit(ErrorPropagationExpr& expr) = 0;\n+            virtual void visit(NegationExpr& expr) = 0;\n+            virtual void visit(ArithmeticOrLogicalExpr& expr) = 0;\n+            virtual void visit(ComparisonExpr& expr) = 0;\n+            virtual void visit(LazyBooleanExpr& expr) = 0;\n+            virtual void visit(TypeCastExpr& expr) = 0;\n+            virtual void visit(AssignmentExpr& expr) = 0;\n+            virtual void visit(CompoundAssignmentExpr& expr) = 0;\n+            virtual void visit(GroupedExpr& expr) = 0;\n+            //virtual void visit(ArrayElems& elems) = 0;\n+            virtual void visit(ArrayElemsValues& elems) = 0;\n+            virtual void visit(ArrayElemsCopied& elems) = 0;\n+            virtual void visit(ArrayExpr& expr) = 0;\n+            virtual void visit(ArrayIndexExpr& expr) = 0;\n+            virtual void visit(TupleExpr& expr) = 0;\n+            virtual void visit(TupleIndexExpr& expr) = 0;\n+            virtual void visit(StructExprStruct& expr) = 0;\n+            //virtual void visit(StructExprField& field) = 0;\n+            virtual void visit(StructExprFieldIdentifier& field) = 0;\n+            virtual void visit(StructExprFieldIdentifierValue& field) = 0;\n+            virtual void visit(StructExprFieldIndexValue& field) = 0;\n+            virtual void visit(StructExprStructFields& expr) = 0;\n+            virtual void visit(StructExprStructBase& expr) = 0;\n+            virtual void visit(StructExprTuple& expr) = 0;\n+            virtual void visit(StructExprUnit& expr) = 0;\n+            //virtual void visit(EnumExprField& field) = 0;\n+            virtual void visit(EnumExprFieldIdentifier& field) = 0;\n+            virtual void visit(EnumExprFieldIdentifierValue& field) = 0;\n+            virtual void visit(EnumExprFieldIndexValue& field) = 0;\n+            virtual void visit(EnumExprStruct& expr) = 0;\n+            virtual void visit(EnumExprTuple& expr) = 0;\n+            virtual void visit(EnumExprFieldless& expr) = 0;\n+            virtual void visit(CallExpr& expr) = 0;\n+            virtual void visit(MethodCallExpr& expr) = 0;\n+            virtual void visit(FieldAccessExpr& expr) = 0;\n+            virtual void visit(ClosureExprInner& expr) = 0;\n+            virtual void visit(BlockExpr& expr) = 0;\n+            virtual void visit(ClosureExprInnerTyped& expr) = 0;\n+            virtual void visit(ContinueExpr& expr) = 0;\n+            virtual void visit(BreakExpr& expr) = 0;\n+            virtual void visit(RangeFromToExpr& expr) = 0;\n+            virtual void visit(RangeFromExpr& expr) = 0;\n+            virtual void visit(RangeToExpr& expr) = 0;\n+            virtual void visit(RangeFullExpr& expr) = 0;\n+            virtual void visit(RangeFromToInclExpr& expr) = 0;\n+            virtual void visit(RangeToInclExpr& expr) = 0;\n+            virtual void visit(ReturnExpr& expr) = 0;\n+            virtual void visit(UnsafeBlockExpr& expr) = 0;\n+            virtual void visit(LoopExpr& expr) = 0;\n+            virtual void visit(WhileLoopExpr& expr) = 0;\n+            virtual void visit(WhileLetLoopExpr& expr) = 0;\n+            virtual void visit(ForLoopExpr& expr) = 0;\n+            virtual void visit(IfExpr& expr) = 0;\n+            virtual void visit(IfExprConseqElse& expr) = 0;\n+            virtual void visit(IfExprConseqIf& expr) = 0;\n+            virtual void visit(IfExprConseqIfLet& expr) = 0;\n+            virtual void visit(IfLetExpr& expr) = 0;\n+            virtual void visit(IfLetExprConseqElse& expr) = 0;\n+            virtual void visit(IfLetExprConseqIf& expr) = 0;\n+            virtual void visit(IfLetExprConseqIfLet& expr) = 0;\n+            //virtual void visit(MatchCase& match_case) = 0;\n+            virtual void visit(MatchCaseBlockExpr& match_case) = 0;\n+            virtual void visit(MatchCaseExpr& match_case) = 0;\n+            virtual void visit(MatchExpr& expr) = 0;\n+            virtual void visit(AwaitExpr& expr) = 0;\n+            virtual void visit(AsyncBlockExpr& expr) = 0;\n+\n+            // rust-item.h\n+            virtual void visit(TypeParam& param) = 0;\n+            //virtual void visit(WhereClauseItem& item) = 0;\n+            virtual void visit(LifetimeWhereClauseItem& item) = 0;\n+            virtual void visit(TypeBoundWhereClauseItem& item) = 0;\n+            virtual void visit(Method& method) = 0;\n+            virtual void visit(ModuleBodied& module) = 0;\n+            virtual void visit(ModuleNoBody& module) = 0;\n+            virtual void visit(ExternCrate& crate) = 0;\n+            //virtual void visit(UseTree& use_tree) = 0;\n+            virtual void visit(UseTreeGlob& use_tree) = 0;\n+            virtual void visit(UseTreeList& use_tree) = 0;\n+            virtual void visit(UseTreeRebind& use_tree) = 0;\n+            virtual void visit(UseDeclaration& use_decl) = 0;\n+            virtual void visit(Function& function) = 0;\n+            virtual void visit(TypeAlias& type_alias) = 0;\n+            virtual void visit(StructStruct& struct_item) = 0;\n+            virtual void visit(TupleStruct& tuple_struct) = 0;\n+            virtual void visit(EnumItem& item) = 0;\n+            virtual void visit(EnumItemTuple& item) = 0;\n+            virtual void visit(EnumItemStruct& item) = 0;\n+            virtual void visit(EnumItemDiscriminant& item) = 0;\n+            virtual void visit(Enum& enum_item) = 0;\n+            virtual void visit(Union& union_item) = 0;\n+            virtual void visit(ConstantItem& const_item) = 0;\n+            virtual void visit(StaticItem& static_item) = 0;\n+            virtual void visit(TraitItemFunc& item) = 0;\n+            virtual void visit(TraitItemMethod& item) = 0;\n+            virtual void visit(TraitItemConst& item) = 0;\n+            virtual void visit(TraitItemType& item) = 0;\n+            virtual void visit(Trait& trait) = 0;\n+            virtual void visit(InherentImpl& impl) = 0;\n+            virtual void visit(TraitImpl& impl) = 0;\n+            //virtual void visit(ExternalItem& item) = 0;\n+            virtual void visit(ExternalStaticItem& item) = 0;\n+            virtual void visit(ExternalFunctionItem& item) = 0;\n+            virtual void visit(ExternBlock& block) = 0;\n+\n+            // rust-macro.h\n+            virtual void visit(MacroMatchFragment& match) = 0;\n+            virtual void visit(MacroMatchRepetition& match) = 0;\n+            virtual void visit(MacroMatcher& matcher) = 0;\n+            virtual void visit(MacroRulesDefinition& rules_def) = 0;\n+            virtual void visit(MacroInvocation& macro_invoc) = 0;\n+            virtual void visit(MetaItemPath& meta_item) = 0;\n+            virtual void visit(MetaItemSeq& meta_item) = 0;\n+            virtual void visit(MetaWord& meta_item) = 0;\n+            virtual void visit(MetaNameValueStr& meta_item) = 0;\n+            virtual void visit(MetaListPaths& meta_item) = 0;\n+            virtual void visit(MetaListNameValueStr& meta_item) = 0;\n+\n+            // rust-pattern.h\n+            virtual void visit(LiteralPattern& pattern) = 0;\n+            virtual void visit(IdentifierPattern& pattern) = 0;\n+            virtual void visit(WildcardPattern& pattern) = 0;\n+            //virtual void visit(RangePatternBound& bound) = 0;\n+            virtual void visit(RangePatternBoundLiteral& bound) = 0;\n+            virtual void visit(RangePatternBoundPath& bound) = 0;\n+            virtual void visit(RangePatternBoundQualPath& bound) = 0;\n+            virtual void visit(RangePattern& pattern) = 0;\n+            virtual void visit(ReferencePattern& pattern) = 0;\n+            //virtual void visit(StructPatternField& field) = 0;\n+            virtual void visit(StructPatternFieldTuplePat& field) = 0;\n+            virtual void visit(StructPatternFieldIdentPat& field) = 0;\n+            virtual void visit(StructPatternFieldIdent& field) = 0;\n+            virtual void visit(StructPattern& pattern) = 0;\n+            //virtual void visit(TupleStructItems& tuple_items) = 0;\n+            virtual void visit(TupleStructItemsNoRange& tuple_items) = 0;\n+            virtual void visit(TupleStructItemsRange& tuple_items) = 0;\n+            virtual void visit(TupleStructPattern& pattern) = 0;\n+            //virtual void visit(TuplePatternItems& tuple_items) = 0;\n+            virtual void visit(TuplePatternItemsMultiple& tuple_items) = 0;\n+            virtual void visit(TuplePatternItemsRanged& tuple_items) = 0;\n+            virtual void visit(TuplePattern& pattern) = 0;\n+            virtual void visit(GroupedPattern& pattern) = 0;\n+            virtual void visit(SlicePattern& pattern) = 0;\n+\n+            // rust-stmt.h\n+            virtual void visit(EmptyStmt& stmt) = 0;\n+            virtual void visit(LetStmt& stmt) = 0;\n+            virtual void visit(ExprStmtWithoutBlock& stmt) = 0;\n+            virtual void visit(ExprStmtWithBlock& stmt) = 0;\n+            \n+            // rust-type.h\n+            virtual void visit(TraitBound& bound) = 0;\n+            virtual void visit(ImplTraitType& type) = 0;\n+            virtual void visit(TraitObjectType& type) = 0;\n+            virtual void visit(ParenthesisedType& type) = 0;\n+            virtual void visit(ImplTraitTypeOneBound& type) = 0;\n+            virtual void visit(TraitObjectTypeOneBound& type) = 0;\n+            virtual void visit(TupleType& type) = 0;\n+            virtual void visit(NeverType& type) = 0;\n+            virtual void visit(RawPointerType& type) = 0;\n+            virtual void visit(ReferenceType& type) = 0;\n+            virtual void visit(ArrayType& type) = 0;\n+            virtual void visit(SliceType& type) = 0;\n+            virtual void visit(InferredType& type) = 0;\n+            virtual void visit(BareFunctionType& type) = 0;\n+\n+            // TODO: rust-cond-compilation.h visiting? not currently used\n+        };\n+    }\n+}\n+\n+#endif\n\\ No newline at end of file"}, {"sha": "fb0cd2340fc3ca17ef0a0fa94ffbb491d1ef423a", "filename": "gcc/rust/test3/ast/rust-ast.h", "status": "modified", "additions": 469, "deletions": 78, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -26,12 +26,17 @@ namespace Rust {\n     typedef ::std::string Identifier;\n     typedef int TupleIndex;\n \n+    struct Session;\n+\n     namespace AST {\n+        // foward decl: ast visitor\n+        class ASTVisitor;\n+\n         // Delimiter types - used in macros and whatever.\n         enum DelimType { PARENS, SQUARE, CURLY };\n \n         // Base AST node object - TODO is this really required or useful? Where to draw line?\n-        class Node {\n+        /*class Node {\n           public:\n             // Gets node's location_t.\n             location_t get_locus() const {\n@@ -48,10 +53,13 @@ namespace Rust {\n \n             virtual ~Node() {}\n \n+            // TODO: constructor including location_t? Make all derived classes have location_t?\n+\n           private:\n             // The node's location.\n             location_t loc;\n-        };\n+        };*/\n+        // decided to not have node as a \"node\" would never need to be stored\n \n         // Attribute body - abstract base class\n         class AttrInput {\n@@ -65,11 +73,23 @@ namespace Rust {\n \n             virtual ::std::string as_string() const = 0;\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const = 0;\n+\n+            // Parse attribute input to meta item, if possible\n+            virtual AttrInput* parse_to_meta_item() const {\n+                return NULL;\n+            }\n+\n           protected:\n             // pure virtual clone implementation\n             virtual AttrInput* clone_attr_input_impl() const = 0;\n         };\n \n+        // forward decl for use in token tree method\n+        class Token;\n+\n         // A tree of tokens (or a single token) - abstract base class\n         class TokenTree {\n           public:\n@@ -82,6 +102,12 @@ namespace Rust {\n \n             virtual ::std::string as_string() const = 0;\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n+            /* Converts token tree to a flat token stream. Tokens must be pointer to avoid mutual\n+             * dependency with Token. */\n+            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const = 0;\n+\n           protected:\n             // pure virtual clone implementation\n             virtual TokenTree* clone_token_tree_impl() const = 0;\n@@ -99,6 +125,8 @@ namespace Rust {\n                 return ::std::unique_ptr<MacroMatch>(clone_macro_match_impl());\n             }\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // pure virtual clone implementation\n             virtual MacroMatch* clone_macro_match_impl() const = 0;\n@@ -126,6 +154,12 @@ namespace Rust {\n                 return ::std::unique_ptr<Token>(clone_token_impl());\n             }\n \n+            // constructor from general text - avoid using if lexer const_TokenPtr is available\n+            Token(\n+              TokenId token_id, location_t locus, ::std::string str, PrimitiveCoreType type_hint) :\n+              token_id(token_id),\n+              locus(locus), str(::std::move(str)), type_hint(type_hint) {}\n+\n             // Constructor from lexer const_TokenPtr\n             /* TODO: find workaround for std::string being NULL - probably have to introduce new\n              * method in lexer Token, or maybe make conversion method there*/\n@@ -155,6 +189,19 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            // Return copy of itself but in token stream form.\n+            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const OVERRIDE;\n+\n+            TokenId get_id() const {\n+                return token_id;\n+            }\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n           protected:\n             // No virtual for now as not polymorphic but can be in future\n             /*virtual*/ Token* clone_token_impl() const {\n@@ -204,6 +251,15 @@ namespace Rust {\n \n             Literal(::std::string value_as_string, LitType type) :\n               value_as_string(::std::move(value_as_string)), type(type) {}\n+\n+            static Literal create_error() {\n+                return Literal(\"\", CHAR);\n+            }\n+\n+            // Returns whether literal is in an invalid state.\n+            bool is_error() const {\n+                return value_as_string == \"\";\n+            }\n         };\n \n         // A token tree with delimiters\n@@ -213,6 +269,24 @@ namespace Rust {\n             DelimType delim_type;\n             ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n \n+            location_t locus;\n+\n+            // TODO: move all the \"parse\" functions into a separate class that has the token stream\n+            // reference - will be cleaner Parse a meta item inner.\n+            //::std::unique_ptr<MetaItemInner> parse_meta_item_inner(const ::std::vector<\n+            //::std::unique_ptr<Token> >& token_stream, int& i) const; SimplePath\n+            // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i)\n+            // const; SimplePathSegment parse_simple_path_segment(const ::std::vector<\n+            // ::std::unique_ptr<Token> >& token_stream, int& i) const;\n+            //::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit(const ::std::unique_ptr<Token>&\n+            //tok) const;\n+            //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n+            //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const; Literal\n+            // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n+            //::std::unique_ptr<MetaItem> parse_path_meta_item(const ::std::vector<\n+            //::std::unique_ptr<Token> >& token_stream, int& i) const; bool\n+            // is_end_meta_item_tok(TokenId tok) const;\n+\n           protected:\n             // Use covariance to implement clone function as returning a DelimTokenTree object\n             virtual DelimTokenTree* clone_attr_input_impl() const OVERRIDE {\n@@ -225,14 +299,16 @@ namespace Rust {\n             }\n \n           public:\n-            DelimTokenTree(\n-              DelimType delim_type, ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n-                                    = ::std::vector< ::std::unique_ptr<TokenTree> >()) :\n+            DelimTokenTree(DelimType delim_type,\n+              ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n+              = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n+              location_t locus = UNKNOWN_LOCATION) :\n               delim_type(delim_type),\n-              token_trees(::std::move(token_trees)) {}\n+              token_trees(::std::move(token_trees)), locus(locus) {}\n \n             // Copy constructor with vector clone\n-            DelimTokenTree(DelimTokenTree const& other) : delim_type(other.delim_type) {\n+            DelimTokenTree(DelimTokenTree const& other) :\n+              delim_type(other.delim_type), locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 token_trees.reserve(other.token_trees.size());\n \n@@ -244,6 +320,7 @@ namespace Rust {\n             // overloaded assignment operator with vector clone\n             DelimTokenTree& operator=(DelimTokenTree const& other) {\n                 delim_type = other.delim_type;\n+                locus = other.locus;\n \n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 token_trees.reserve(other.token_trees.size());\n@@ -264,28 +341,43 @@ namespace Rust {\n             }\n \n             ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session ATTRIBUTE_UNUSED) const OVERRIDE {\n+                // this should never be called - should be converted first\n+                return false;\n+            }\n+\n+            virtual AttrInput* parse_to_meta_item() const OVERRIDE;\n+\n+            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const OVERRIDE;\n         };\n \n         // Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to be defined\n         class AttrInputLiteral;\n \n-        // TODO: move applicable stuff into here\n+        // TODO: move applicable stuff into here or just don't include it because nothing uses it\n         // A segment of a path (maybe)\n         class PathSegment {\n           public:\n             virtual ~PathSegment() {}\n \n             virtual ::std::string as_string() const = 0;\n+\n+            // TODO: add visitor here?\n         };\n \n         // A segment of a simple path without generic or type arguments\n         class SimplePathSegment : public PathSegment {\n             ::std::string segment_name;\n+            location_t locus;\n \n             // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n           public:\n             // TODO: put checks in constructor to enforce this rule?\n-            SimplePathSegment(::std::string segment_name) : segment_name(::std::move(segment_name)) {}\n+            SimplePathSegment(::std::string segment_name, location_t locus = UNKNOWN_LOCATION) :\n+              segment_name(::std::move(segment_name)), locus(locus) {}\n \n             // Returns whether simple path segment is in an invalid state (currently, if empty).\n             inline bool is_error() const {\n@@ -298,19 +390,26 @@ namespace Rust {\n             }\n \n             ::std::string as_string() const;\n+\n+            inline location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            // TODO: visitor pattern?\n         };\n \n         // A simple path without generic or type arguments\n         class SimplePath {\n             bool has_opening_scope_resolution;\n             ::std::vector<SimplePathSegment> segments;\n+            location_t locus;\n \n           public:\n             // Constructor\n             SimplePath(::std::vector<SimplePathSegment> path_segments,\n-              bool has_opening_scope_resolution = false) :\n+              bool has_opening_scope_resolution = false, location_t locus = UNKNOWN_LOCATION) :\n               has_opening_scope_resolution(has_opening_scope_resolution),\n-              segments(::std::move(path_segments)) {}\n+              segments(::std::move(path_segments)), locus(locus) {}\n \n             // Creates an empty SimplePath.\n             static SimplePath create_empty() {\n@@ -323,6 +422,28 @@ namespace Rust {\n             }\n \n             ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            // does this need visitor if not polymorphic? probably not\n+\n+            // path-to-string comparison operator\n+            bool operator==(const ::std::string& rhs) {\n+                return !has_opening_scope_resolution && segments.size() == 1\n+                       && segments[0].as_string() == rhs;\n+            }\n+\n+            /* Creates a single-segment SimplePath from a string. This will not check to ensure that\n+             * this is a valid identifier in path, so be careful. Also, this will have no location\n+             * data.\n+             * TODO have checks? */\n+            static SimplePath from_str(::std::string str) {\n+                ::std::vector<AST::SimplePathSegment> single_segments\n+                  = { AST::SimplePathSegment(::std::move(str)) };\n+                return SimplePath(::std::move(single_segments));\n+            }\n         };\n \n         // aka Attr\n@@ -335,27 +456,41 @@ namespace Rust {\n             // AttrInput* attr_input;\n             ::std::unique_ptr<AttrInput> attr_input;\n \n+            location_t locus;\n+\n+            // TODO: maybe a variable storing whether attr input is parsed or not\n+\n           public:\n             // Returns whether Attribute has AttrInput\n             inline bool has_attr_input() const {\n                 return attr_input != NULL;\n             }\n \n             // Constructor has pointer AttrInput for polymorphism reasons\n-            Attribute(SimplePath path, AttrInput* input) :\n-              path(::std::move(path)), attr_input(input) {}\n+            Attribute(SimplePath path, ::std::unique_ptr<AttrInput> input,\n+              location_t locus = UNKNOWN_LOCATION) :\n+              path(::std::move(path)),\n+              attr_input(::std::move(input)), locus(locus) {}\n \n             // Copy constructor must deep copy attr_input as unique pointer\n-            Attribute(Attribute const& other) :\n-              path(other.path), attr_input(other.attr_input->clone_attr_input()) {}\n+            Attribute(Attribute const& other) : path(other.path), locus(other.locus) {\n+                // guard to protect from null pointer dereference\n+                if (other.attr_input != NULL) {\n+                    attr_input = other.attr_input->clone_attr_input();\n+                }\n+            }\n \n             // default destructor\n             ~Attribute() = default;\n \n             // overload assignment operator to use custom clone method\n             Attribute& operator=(Attribute const& other) {\n                 path = other.path;\n-                attr_input = other.attr_input->clone_attr_input();\n+                locus = other.locus;\n+                // guard to protect from null pointer dereference\n+                if (other.attr_input != NULL) {\n+                    attr_input = other.attr_input->clone_attr_input();\n+                }\n \n                 return *this;\n             }\n@@ -437,67 +572,163 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            // TODO: does this require visitor pattern as not polymorphic?\n+\n+            // Maybe change to const-reference in future\n+            SimplePath get_path() const {\n+                return path;\n+            }\n+\n+            // Call to parse attribute body to meta item syntax.\n+            void parse_attr_to_meta_item();\n+\n+            // Determines whether cfg predicate is true and item with attribute should not be\n+            // stripped.\n+            bool check_cfg_predicate(const Session& session) {\n+                // assume that cfg predicate actually can exist, i.e. attribute has cfg or cfg_attr\n+                // path\n+\n+                if (!has_attr_input()) {\n+                    return false;\n+                }\n+\n+                // TODO: maybe replace with storing a \"has been parsed\" variable?\n+                parse_attr_to_meta_item();\n+                // can't be const because of this anyway\n+\n+                return attr_input->check_cfg_predicate(session);\n+            }\n+\n           protected:\n             // not virtual as currently no subclasses of Attribute, but could be in future\n             /*virtual*/ Attribute* clone_attribute_impl() const {\n                 return new Attribute(*this);\n             }\n         };\n \n-        // Syntax used for Attribute by most built-in attributes and the meta fragment spec\n-        class MetaItem {\n-            SimplePath path;\n+        // Forward decl - defined in rust-macro.h\n+        class MetaNameValueStr;\n \n+        // abstract base meta item inner class\n+        class MetaItemInner {\n           protected:\n-            MetaItem(SimplePath path) : path(::std::move(path)) {}\n-\n-            // pure virtual as MetaItem is abstract?\n-            virtual MetaItem* clone_meta_item_impl() const = 0;\n+            // pure virtual as MetaItemInner\n+            virtual MetaItemInner* clone_meta_item_inner_impl() const = 0;\n \n           public:\n             // Unique pointer custom clone function\n-            ::std::unique_ptr<MetaItem> clone_meta_item() const {\n-                return ::std::unique_ptr<MetaItem>(clone_meta_item_impl());\n+            ::std::unique_ptr<MetaItemInner> clone_meta_item_inner() const {\n+                return ::std::unique_ptr<MetaItemInner>(clone_meta_item_inner_impl());\n             }\n \n-            virtual ~MetaItem() {}\n+            virtual ~MetaItemInner() {}\n \n             virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n+            // HACK: used to simplify parsing - creates a copy of that type, or returns null\n+            virtual MetaNameValueStr* to_meta_name_value_str() const {\n+                return NULL;\n+            }\n+\n+            // HACK: used to simplify parsing - same thing\n+            virtual SimplePath to_path_item() const {\n+                return SimplePath::create_empty();\n+            }\n+\n+            virtual bool check_cfg_predicate(const Session& session) const = 0;\n         };\n \n-        // Forward decl - defined in rust-expr.h\n-        class MetaItemLit;\n+        // Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n+        class AttrInputMetaItemContainer : public AttrInput {\n+            ::std::vector< ::std::unique_ptr<MetaItemInner> > items;\n \n-        // Forward decl - defined in rust-expr.h\n-        struct MetaItemInner;\n+          public:\n+            AttrInputMetaItemContainer(::std::vector< ::std::unique_ptr<MetaItemInner> > items) :\n+              items(::std::move(items)) {}\n \n-        // Forward decl - defined in rust-expr.h\n-        class MetaItemSeq;\n+            // copy constructor with vector clone\n+            AttrInputMetaItemContainer(const AttrInputMetaItemContainer& other) {\n+                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n+                items.reserve(other.items.size());\n \n-        // Forward decl - defined in rust-expr.h\n-        struct MetaWord;\n+                for (const auto& e : other.items) {\n+                    items.push_back(e->clone_meta_item_inner());\n+                }\n+            }\n \n-        // Forward decl - defined in rust-expr.h\n-        struct MetaNameValueStr;\n+            // no destructor definition required\n \n-        // Forward decl - defined in rust-expr.h\n-        struct MetaListPaths;\n+            // copy assignment operator with vector clone\n+            AttrInputMetaItemContainer& operator=(const AttrInputMetaItemContainer& other) {\n+                AttrInput::operator=(other);\n+                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n+                items.reserve(other.items.size());\n+\n+                for (const auto& e : other.items) {\n+                    items.push_back(e->clone_meta_item_inner());\n+                }\n+\n+                return *this;\n+            }\n+\n+            // default move constructors\n+            AttrInputMetaItemContainer(AttrInputMetaItemContainer&& other) = default;\n+            AttrInputMetaItemContainer& operator=(AttrInputMetaItemContainer&& other) = default;\n+\n+            ::std::string as_string() const OVERRIDE;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual AttrInputMetaItemContainer* clone_attr_input_impl() const OVERRIDE {\n+                return new AttrInputMetaItemContainer(*this);\n+            }\n+        };\n+\n+        // abstract base meta item class\n+        class MetaItem : public MetaItemInner {};\n \n         // Forward decl - defined in rust-expr.h\n-        struct MetaListIdents;\n+        class MetaItemLitExpr;\n \n         // Forward decl - defined in rust-expr.h\n+        class MetaItemPathLit;\n+\n+        // Forward decl - defined in rust-macro.h\n+        class MetaItemPath;\n+\n+        // Forward decl - defined in rust-macro.h\n+        class MetaItemSeq;\n+\n+        // Forward decl - defined in rust-macro.h\n+        class MetaWord;\n+\n+        // Forward decl - defined in rust-macro.h\n+        class MetaListPaths;\n+\n+        // Forward decl - defined in rust-macro.h\n         struct MetaListNameValueStr;\n \n         /* Base statement abstract class. Note that most \"statements\" are not allowed in top-level\n          * module scope - only a subclass of statements called \"items\" are. */\n-        class Stmt : public Node {\n+        class Stmt {\n           public:\n             // Unique pointer custom clone function\n             ::std::unique_ptr<Stmt> clone_stmt() const {\n                 return ::std::unique_ptr<Stmt>(clone_stmt_impl());\n             }\n \n+            virtual ~Stmt() {}\n+\n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone function implementation as pure virtual method\n             virtual Stmt* clone_stmt_impl() const = 0;\n@@ -507,6 +738,8 @@ namespace Rust {\n         class Item : public Stmt {\n             ::std::vector<Attribute> outer_attrs;\n \n+            // TODO: should outer attrs be defined here or in each derived class?\n+\n           public:\n             // Unique pointer custom clone function\n             ::std::unique_ptr<Item> clone_item() const {\n@@ -515,6 +748,10 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            // Adds crate names to the vector passed by reference, if it can (polymorphism).\n+            virtual void add_crate_name(::std::vector< ::std::string>& names ATTRIBUTE_UNUSED) const {\n+            }\n+\n           protected:\n             // Constructor\n             Item(::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n@@ -530,8 +767,12 @@ namespace Rust {\n             }\n         };\n \n+        // forward decl of ExprWithoutBlock\n+        class ExprWithoutBlock;\n+\n         // Base expression AST node - abstract\n-        class Expr : public Node {\n+        class Expr {\n+            // TODO: move outer attribute data to derived classes?\n             ::std::vector<Attribute> outer_attrs;\n \n           public:\n@@ -548,7 +789,26 @@ namespace Rust {\n              *  - get_type() - returns type of expression. set_type() may also be useful for some?\n              *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n \n-            ::std::string as_string() const;\n+            // HACK: downcasting without dynamic_cast (if possible) via polymorphism - overrided in\n+            // subclasses of ExprWithoutBlock\n+            virtual ExprWithoutBlock* as_expr_without_block() const {\n+                // DEBUG\n+                fprintf(stderr, \"clone expr without block returns null and has not been overriden\\n\");\n+\n+                return NULL;\n+            }\n+\n+            // TODO: make pure virtual if move out outer attributes to derived classes\n+            virtual ::std::string as_string() const;\n+\n+            virtual ~Expr() {}\n+\n+            // HACK: slow way of getting location from base expression through virtual methods.\n+            virtual location_t get_locus_slow() const {\n+                return UNKNOWN_LOCATION;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n \n           protected:\n             // Constructor\n@@ -557,26 +817,11 @@ namespace Rust {\n \n             // Clone function implementation as pure virtual method\n             virtual Expr* clone_expr_impl() const = 0;\n-        };\n \n-        // HACK: IdentifierExpr, delete when figure out identifier vs expr problem in Pratt parser\n-        class IdentifierExpr : public Expr {\n-            Identifier ident;\n-\n-          public:\n-            IdentifierExpr(\n-              Identifier ident, ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              Expr(::std::move(outer_attrs)),\n-              ident(::std::move(ident)) {}\n-\n-            ::std::string as_string() const {\n-                return \"not implemented as a HACK\";\n-            }\n-\n-          protected:\n-            // Clone method implementation\n-            virtual IdentifierExpr* clone_expr_impl() const OVERRIDE {\n-                return new IdentifierExpr(*this);\n+            // TODO: think of less hacky way to implement this kind of thing\n+            // Sets outer attributes.\n+            void set_outer_attrs(::std::vector<Attribute> outer_attrs_to_set) {\n+                outer_attrs = ::std::move(outer_attrs_to_set);\n             }\n         };\n \n@@ -601,10 +846,52 @@ namespace Rust {\n             ::std::unique_ptr<ExprWithoutBlock> clone_expr_without_block() const {\n                 return ::std::unique_ptr<ExprWithoutBlock>(clone_expr_without_block_impl());\n             }\n+\n+            // downcasting hack from expr to use pratt parsing with parse_expr_without_block\n+            virtual ExprWithoutBlock* as_expr_without_block() const OVERRIDE {\n+                // DEBUG\n+                fprintf(stderr, \"about to call the impl for clone expr without block\\n\");\n+\n+                return clone_expr_without_block_impl();\n+            }\n+        };\n+\n+        // HACK: IdentifierExpr, delete when figure out identifier vs expr problem in Pratt parser\n+        // Alternatively, identifiers could just be represented as single-segment paths\n+        class IdentifierExpr : public ExprWithoutBlock {\n+            Identifier ident;\n+\n+            location_t locus;\n+\n+          public:\n+            IdentifierExpr(Identifier ident, location_t locus = UNKNOWN_LOCATION,\n+              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n+              ExprWithoutBlock(::std::move(outer_attrs)),\n+              ident(::std::move(ident)), locus(locus) {}\n+\n+            ::std::string as_string() const OVERRIDE {\n+                return ident;\n+            }\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            location_t get_locus_slow() const OVERRIDE {\n+                return get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+          protected:\n+            // Clone method implementation\n+            virtual IdentifierExpr* clone_expr_without_block_impl() const OVERRIDE {\n+                return new IdentifierExpr(*this);\n+            }\n         };\n \n         // Pattern base AST node\n-        class Pattern : public Node {\n+        class Pattern {\n           public:\n             // Unique pointer custom clone function\n             ::std::unique_ptr<Pattern> clone_pattern() const {\n@@ -613,6 +900,12 @@ namespace Rust {\n \n             // possible virtual methods: is_refutable()\n \n+            virtual ~Pattern() {}\n+\n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone pattern implementation as pure virtual method\n             virtual Pattern* clone_pattern_impl() const = 0;\n@@ -635,11 +928,13 @@ namespace Rust {\n             virtual ::std::string as_string() const = 0;\n \n             // HACK: convert to trait bound. Virtual method overriden by classes that enable this.\n-            virtual TraitBound* to_trait_bound(bool in_parens) const {\n+            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const {\n                 return NULL;\n             }\n             // as pointer, shouldn't require definition beforehand, only forward declaration.\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone function implementation as pure virtual method\n             virtual Type* clone_type_impl() const = 0;\n@@ -676,6 +971,8 @@ namespace Rust {\n \n             virtual ::std::string as_string() const = 0;\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone function implementation as pure virtual method\n             virtual TypeParamBound* clone_type_param_bound_impl() const = 0;\n@@ -698,10 +995,14 @@ namespace Rust {\n             ::std::string lifetime_name;\n             // only applies for NAMED lifetime_type\n \n+            location_t locus;\n+\n           public:\n             // Constructor\n-            Lifetime(LifetimeType type, ::std::string name = ::std::string()) :\n-              lifetime_type(type), lifetime_name(::std::move(name)) {}\n+            Lifetime(LifetimeType type, ::std::string name = ::std::string(),\n+              location_t locus = UNKNOWN_LOCATION) :\n+              lifetime_type(type),\n+              lifetime_name(::std::move(name)), locus(locus) {}\n \n             // Creates an \"error\" lifetime.\n             static Lifetime error() {\n@@ -715,6 +1016,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual Lifetime* clone_type_param_bound_impl() const OVERRIDE {\n@@ -734,6 +1037,8 @@ namespace Rust {\n \n             virtual ::std::string as_string() const = 0;\n \n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone function implementation as pure virtual method\n             virtual GenericParam* clone_generic_param_impl() const = 0;\n@@ -751,6 +1056,8 @@ namespace Rust {\n             //::std::unique_ptr<Attribute> outer_attr;\n             Attribute outer_attr;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether the lifetime param has any lifetime bounds.\n             inline bool has_lifetime_bounds() const {\n@@ -773,16 +1080,19 @@ namespace Rust {\n             }\n \n             // Constructor\n-            LifetimeParam(Lifetime lifetime,\n+            LifetimeParam(Lifetime lifetime, location_t locus = UNKNOWN_LOCATION,\n               ::std::vector<Lifetime> lifetime_bounds = ::std::vector<Lifetime>(),\n               Attribute outer_attr = Attribute::create_empty()) :\n               lifetime(::std::move(lifetime)),\n-              lifetime_bounds(::std::move(lifetime_bounds)), outer_attr(::std::move(outer_attr)) {}\n+              lifetime_bounds(::std::move(lifetime_bounds)), outer_attr(::std::move(outer_attr)),\n+              locus(locus) {}\n+\n+            // TODO: remove copy and assignment operator definitions - not required\n \n             // Copy constructor with clone\n             LifetimeParam(LifetimeParam const& other) :\n               lifetime(other.lifetime), lifetime_bounds(other.lifetime_bounds),\n-              outer_attr(other.outer_attr) {}\n+              outer_attr(other.outer_attr), locus(other.locus) {}\n \n             // Destructor - define here if required\n \n@@ -791,6 +1101,7 @@ namespace Rust {\n                 lifetime = other.lifetime;\n                 lifetime_bounds = other.lifetime_bounds;\n                 outer_attr = other.outer_attr;\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -801,6 +1112,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual LifetimeParam* clone_generic_param_impl() const OVERRIDE {\n@@ -820,12 +1133,14 @@ namespace Rust {\n         class TraitItem {\n             // bool has_outer_attrs;\n             // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-            ::std::vector<Attribute> outer_attrs;\n+            //::std::vector<Attribute> outer_attrs;\n+\n+            // NOTE: all children should have outer attributes\n \n           protected:\n             // Constructor\n-            TraitItem(::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              outer_attrs(::std::move(outer_attrs)) {}\n+            /*TraitItem(::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n+              outer_attrs(::std::move(outer_attrs)) {}*/\n \n             // Clone function implementation as pure virtual method\n             virtual TraitItem* clone_trait_item_impl() const = 0;\n@@ -834,20 +1149,63 @@ namespace Rust {\n             virtual ~TraitItem() {}\n \n             // Returns whether TraitItem has outer attributes.\n-            inline bool has_outer_attrs() const {\n+            /*inline bool has_outer_attrs() const {\n                 return !outer_attrs.empty();\n-            }\n+            }*/\n \n             // Unique pointer custom clone function\n             ::std::unique_ptr<TraitItem> clone_trait_item() const {\n                 return ::std::unique_ptr<TraitItem>(clone_trait_item_impl());\n             }\n+\n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+        };\n+\n+        // Abstract base class for items used within an inherent impl block (the impl name {} one)\n+        class InherentImplItem {\n+          protected:\n+            // Clone function implementation as pure virtual method\n+            virtual InherentImplItem* clone_inherent_impl_item_impl() const = 0;\n+\n+          public:\n+            virtual ~InherentImplItem() {}\n+\n+            // Unique pointer custom clone function\n+            ::std::unique_ptr<InherentImplItem> clone_inherent_impl_item() const {\n+                return ::std::unique_ptr<InherentImplItem>(clone_inherent_impl_item_impl());\n+            }\n+\n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+        };\n+\n+        // Abstract base class for items used in a trait impl\n+        class TraitImplItem {\n+          protected:\n+            virtual TraitImplItem* clone_trait_impl_item_impl() const = 0;\n+\n+          public:\n+            virtual ~TraitImplItem(){};\n+\n+            // Unique pointer custom clone function\n+            ::std::unique_ptr<TraitImplItem> clone_trait_impl_item() const {\n+                return ::std::unique_ptr<TraitImplItem>(clone_trait_impl_item_impl());\n+            }\n+\n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n         };\n \n         // A macro invocation item (or statement) AST node (i.e. semi-coloned macro invocation)\n         class MacroInvocationSemi\n           : public MacroItem\n           , public TraitItem\n+          , public InherentImplItem\n+          , public TraitImplItem\n         /*, public Statement*/ {\n             // already inherits from statement indirectly via item as item is a subclass of statement\n             SimplePath path;\n@@ -856,15 +1214,17 @@ namespace Rust {\n             //::std::vector<TokenTree> token_trees;\n             ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n             MacroInvocationSemi(SimplePath macro_path, DelimType delim_type,\n               ::std::vector< ::std::unique_ptr<TokenTree> > token_trees,\n-              ::std::vector<Attribute> outer_attribs) :\n-              MacroItem(outer_attribs),\n-              TraitItem(outer_attribs), path(::std::move(macro_path)), delim_type(delim_type),\n-              token_trees(::std::move(token_trees)) {}\n+              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              MacroItem(::std::move(outer_attribs)),\n+              path(::std::move(macro_path)), delim_type(delim_type),\n+              token_trees(::std::move(token_trees)), locus(locus) {}\n             /* TODO: possible issue with Item and TraitItem hierarchies both having outer attributes\n              * - storage inefficiency at least.\n              * Best current idea is to make Item preferred and have TraitItem get virtual functions\n@@ -874,7 +1234,8 @@ namespace Rust {\n \n             // Copy constructor with vector clone\n             MacroInvocationSemi(MacroInvocationSemi const& other) :\n-              MacroItem(other), TraitItem(other), path(other.path), delim_type(other.delim_type) {\n+              MacroItem(other), TraitItem(other), InherentImplItem(other), TraitImplItem(other),\n+              path(other.path), delim_type(other.delim_type), locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 token_trees.reserve(other.token_trees.size());\n \n@@ -887,8 +1248,11 @@ namespace Rust {\n             MacroInvocationSemi& operator=(MacroInvocationSemi const& other) {\n                 MacroItem::operator=(other);\n                 TraitItem::operator=(other);\n+                InherentImplItem::operator=(other);\n+                TraitImplItem::operator=(other);\n                 path = other.path;\n                 delim_type = other.delim_type;\n+                locus = other.locus;\n \n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 token_trees.reserve(other.token_trees.size());\n@@ -904,12 +1268,24 @@ namespace Rust {\n             MacroInvocationSemi(MacroInvocationSemi&& other) = default;\n             MacroInvocationSemi& operator=(MacroInvocationSemi&& other) = default;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual MacroInvocationSemi* clone_item_impl() const OVERRIDE {\n                 return new MacroInvocationSemi(*this);\n             }\n \n+            // Use covariance to implement clone function as returning this object rather than base\n+            virtual MacroInvocationSemi* clone_inherent_impl_item_impl() const OVERRIDE {\n+                return new MacroInvocationSemi(*this);\n+            }\n+\n+            // Use covariance to implement clone function as returning this object rather than base\n+            virtual MacroInvocationSemi* clone_trait_impl_item_impl() const OVERRIDE {\n+                return new MacroInvocationSemi(*this);\n+            }\n+\n             // FIXME: remove if item impl virtual override works properly\n             // Use covariance to implement clone function as returning this object rather than base\n             /*virtual MacroInvocationSemi* clone_statement_impl() const OVERRIDE {\n@@ -979,6 +1355,21 @@ namespace Rust {\n             // Get crate representation as string (e.g. for debugging).\n             ::std::string as_string() const;\n         };\n+\n+        // Base path expression AST node - abstract\n+        class PathExpr : public ExprWithoutBlock {\n+          protected:\n+            PathExpr(::std::vector<Attribute> outer_attribs) :\n+              ExprWithoutBlock(::std::move(outer_attribs)) {}\n+\n+          public:\n+            // TODO: think of a better and less hacky way to allow this\n+\n+            // Replaces the outer attributes of this path expression with the given outer attributes.\n+            void replace_outer_attrs(::std::vector<Attribute> outer_attrs) {\n+                set_outer_attrs(::std::move(outer_attrs));\n+            }\n+        };\n     }\n }\n "}, {"sha": "4fa6a0bde4ece23672137ffd24362452c878c29c", "filename": "gcc/rust/test3/ast/rust-cond-compilation.h", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -17,6 +17,9 @@ namespace Rust {\n                   clone_configuration_predicate_impl());\n             }\n \n+            // not sure if I'll use this but here anyway\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // Clone function impl to be overriden in base classes\n             virtual ConfigurationPredicate* clone_configuration_predicate_impl() const = 0;\n@@ -42,6 +45,8 @@ namespace Rust {\n             // Name-only constructor\n             ConfigurationOption(Identifier option_name) : option_name(option_name) {}\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ConfigurationOption* clone_configuration_predicate_impl() const OVERRIDE {\n@@ -63,6 +68,8 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list) :\n               predicate_list(predicate_list) {}\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ConfigurationAll* clone_configuration_predicate_impl() const OVERRIDE {\n@@ -79,6 +86,8 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list) :\n               predicate_list(predicate_list) {}\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ConfigurationAny* clone_configuration_predicate_impl() const OVERRIDE {\n@@ -107,9 +116,11 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // no move constructors as not supported in c++03\n-            /*ConfigurationNot(ConfigurationNot&& other) = default;\n-            ConfigurationNot& operator=(ConfigurationNot&& other) = default;*/\n+            // move constructors \n+            ConfigurationNot(ConfigurationNot&& other) = default;\n+            ConfigurationNot& operator=(ConfigurationNot&& other) = default;\n+\n+          virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -139,10 +150,13 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // no move constructors as not supported in c++03\n-            /*CfgAttrAttribute(CfgAttrAttribute&& other) = default;\n-            CfgAttrAttribute& operator=(CfgAttrAttribute&& other) = default;*/\n+            // move constructors \n+            CfgAttribute(CfgAttribute&& other) = default;\n+            CfgAttribute& operator=(CfgAttribute&& other) = default;\n         };\n+        /* TODO: ok, best thing to do would be eliminating this class, making Attribute has a \"is_cfg()\"\n+         * method, and having attribute path as \"cfg\" and AttrInput as ConfigurationPredicate (so make\n+         * ConfigurationPredicate a subclass of AttrInput?). Would need special handling in parser, however. */\n \n         // TODO: inline\n         struct CfgAttrs {\n@@ -175,9 +189,9 @@ namespace Rust {\n                 return *this;\n             }\n \n-            // no move constructors as not supported in c++03\n-            /*CfgAttrAttribute(CfgAttrAttribute&& other) = default;\n-            CfgAttrAttribute& operator=(CfgAttrAttribute&& other) = default;*/\n+            // move constructors \n+            CfgAttrAttribute(CfgAttrAttribute&& other) = default;\n+            CfgAttrAttribute& operator=(CfgAttrAttribute&& other) = default;\n         };\n     }\n }"}, {"sha": "1842da927910f4f882c3fcfe434ab1353d508267", "filename": "gcc/rust/test3/ast/rust-expr.h", "status": "modified", "additions": 1044, "deletions": 373, "changes": 1417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c5154f530a6f88598222499864264e17f56cc442", "filename": "gcc/rust/test3/ast/rust-item.h", "status": "modified", "additions": 688, "deletions": 690, "changes": 1378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4c8237e6efc53bcba3f21e055e89031d5a746929", "filename": "gcc/rust/test3/ast/rust-macro.h", "status": "modified", "additions": 291, "deletions": 26, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -27,35 +27,35 @@ namespace Rust {\n         };\n \n         inline MacroFragSpec get_frag_spec_from_str(::std::string str) {\n-            if (str == \"block\") \n-              return BLOCK;\n+            if (str == \"block\")\n+                return BLOCK;\n             else if (str == \"expr\")\n-              return EXPR;\n+                return EXPR;\n             else if (str == \"ident\")\n-              return IDENT;\n+                return IDENT;\n             else if (str == \"item\")\n-              return ITEM;\n+                return ITEM;\n             else if (str == \"lifetime\")\n-              return LIFETIME;\n+                return LIFETIME;\n             else if (str == \"literal\")\n-              return LITERAL;\n+                return LITERAL;\n             else if (str == \"meta\")\n-              return META;\n+                return META;\n             else if (str == \"pat\")\n-              return PAT;\n+                return PAT;\n             else if (str == \"path\")\n-              return PATH;\n+                return PATH;\n             else if (str == \"stmt\")\n-              return STMT;\n+                return STMT;\n             else if (str == \"tt\")\n-              return TT;\n+                return TT;\n             else if (str == \"ty\")\n-              return TY;\n+                return TY;\n             else if (str == \"vis\")\n-              return VIS;\n+                return VIS;\n             else {\n-              //error_at(\"invalid string '%s' used as fragment specifier\", str->c_str());\n-              return INVALID;\n+                // error_at(\"invalid string '%s' used as fragment specifier\", str->c_str());\n+                return INVALID;\n             }\n         }\n \n@@ -64,6 +64,8 @@ namespace Rust {\n             Identifier ident;\n             MacroFragSpec frag_spec;\n \n+            // TODO: should store location information?\n+\n           public:\n             MacroMatchFragment(Identifier ident, MacroFragSpec frag_spec) :\n               ident(::std::move(ident)), frag_spec(frag_spec) {}\n@@ -80,6 +82,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual MacroMatchFragment* clone_macro_match_impl() const OVERRIDE {\n@@ -102,16 +106,18 @@ namespace Rust {\n             // any token except delimiters and repetition operators\n             ::std::unique_ptr<MacroRepSep> sep;\n \n+            // TODO: should store location information?\n+\n           public:\n             // Returns whether macro match repetition has separator token.\n             inline bool has_sep() const {\n                 return sep != NULL;\n             }\n \n-            MacroMatchRepetition(::std::vector< ::std::unique_ptr<MacroMatch> > matches, MacroRepOp op,\n-              MacroRepSep* sep) :\n+            MacroMatchRepetition(::std::vector< ::std::unique_ptr<MacroMatch> > matches,\n+              MacroRepOp op, ::std::unique_ptr<MacroRepSep> sep) :\n               matches(::std::move(matches)),\n-              op(op), sep(sep) {}\n+              op(op), sep(::std::move(sep)) {}\n \n             // Copy constructor with clone\n             MacroMatchRepetition(MacroMatchRepetition const& other) :\n@@ -148,6 +154,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual MacroMatchRepetition* clone_macro_match_impl() const OVERRIDE {\n@@ -164,6 +172,8 @@ namespace Rust {\n             // TODO: think of way to mark invalid that doesn't take up more space\n             bool is_invalid;\n \n+            // TODO: should store location information?\n+\n           public:\n             MacroMatcher(\n               DelimType delim_type, ::std::vector< ::std::unique_ptr<MacroMatch> > matches) :\n@@ -210,6 +220,8 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual MacroMatcher* clone_macro_match_impl() const OVERRIDE {\n@@ -225,8 +237,14 @@ namespace Rust {\n           private:\n             DelimTokenTree token_tree;\n \n+            // TODO: should store location information?\n+\n           public:\n             MacroTranscriber(DelimTokenTree token_tree) : token_tree(::std::move(token_tree)) {}\n+\n+            ::std::string as_string() const {\n+                return token_tree.as_string();\n+            }\n         };\n \n         // A macro rule? Matcher and transcriber pair?\n@@ -235,6 +253,8 @@ namespace Rust {\n             MacroMatcher matcher;\n             MacroTranscriber transcriber;\n \n+            // TODO: should store location information?\n+\n           public:\n             MacroRule(MacroMatcher matcher, MacroTranscriber transcriber) :\n               matcher(::std::move(matcher)), transcriber(::std::move(transcriber)) {}\n@@ -249,6 +269,8 @@ namespace Rust {\n                 return MacroRule(\n                   MacroMatcher::create_error(), MacroTranscriber(DelimTokenTree::create_empty()));\n             }\n+\n+            ::std::string as_string() const;\n         };\n \n         // A macro rules definition item AST node\n@@ -260,13 +282,19 @@ namespace Rust {\n             // MacroRules rules;\n             ::std::vector<MacroRule> rules; // inlined form\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n             MacroRulesDefinition(Identifier rule_name, DelimType delim_type,\n-              ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs) :\n-              MacroItem(::std::move(outer_attrs)), rule_name(::std::move(rule_name)),\n-              delim_type(delim_type), rules(::std::move(rules)) {}\n+              ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs,\n+              location_t locus) :\n+              MacroItem(::std::move(outer_attrs)),\n+              rule_name(::std::move(rule_name)), delim_type(delim_type), rules(::std::move(rules)),\n+              locus(locus) {}\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -283,13 +311,25 @@ namespace Rust {\n             SimplePath path;\n             DelimTokenTree token_tree;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n-            MacroInvocation(\n-              SimplePath path, DelimTokenTree token_tree, ::std::vector<Attribute> outer_attrs) :\n-              ExprWithoutBlock(::std::move(outer_attrs)), path(::std::move(path)),\n-              token_tree(::std::move(token_tree)) {}\n+            MacroInvocation(SimplePath path, DelimTokenTree token_tree,\n+              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ExprWithoutBlock(::std::move(outer_attrs)),\n+              path(::std::move(path)), token_tree(::std::move(token_tree)), locus(locus) {}\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            location_t get_locus_slow() const OVERRIDE {\n+                return get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -317,6 +357,231 @@ namespace Rust {\n                 return new MacroInvocation(*this);\n             }\n         };\n+\n+        // more generic meta item path-only form\n+        class MetaItemPath : public MetaItem {\n+            SimplePath path;\n+\n+          public:\n+            MetaItemPath(SimplePath path) : path(::std::move(path)) {}\n+\n+            ::std::string as_string() const OVERRIDE {\n+                return path.as_string();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            // HACK: used to simplify parsing - returns non-empty only in this case\n+            virtual SimplePath to_path_item() const OVERRIDE {\n+                // this should copy construct - TODO ensure it does\n+                return path;\n+            }\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaItemPath* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaItemPath(*this);\n+            }\n+        };\n+\n+        // more generic meta item sequence form\n+        class MetaItemSeq : public MetaItem {\n+            SimplePath path;\n+            ::std::vector< ::std::unique_ptr<MetaItemInner> > seq;\n+\n+          public:\n+            MetaItemSeq(SimplePath path, ::std::vector< ::std::unique_ptr<MetaItemInner> > seq) :\n+              path(::std::move(path)), seq(::std::move(seq)) {}\n+\n+            // copy constructor with vector clone\n+            MetaItemSeq(const MetaItemSeq& other) : path(other.path) {\n+                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n+                seq.reserve(other.seq.size());\n+\n+                for (const auto& e : other.seq) {\n+                    seq.push_back(e->clone_meta_item_inner());\n+                }\n+            }\n+\n+            // destructor definition not required\n+\n+            // overloaded assignment operator with vector clone\n+            MetaItemSeq& operator=(const MetaItemSeq& other) {\n+                MetaItem::operator=(other);\n+                path = other.path;\n+                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n+                seq.reserve(other.seq.size());\n+\n+                for (const auto& e : other.seq) {\n+                    seq.push_back(e->clone_meta_item_inner());\n+                }\n+\n+                return *this;\n+            }\n+\n+            // default move constructors\n+            MetaItemSeq(MetaItemSeq&& other) = default;\n+            MetaItemSeq& operator=(MetaItemSeq&& other) = default;\n+\n+            ::std::string as_string() const OVERRIDE;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaItemSeq* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaItemSeq(*this);\n+            }\n+        };\n+\n+        // Preferred specialisation for single-identifier meta items.\n+        class MetaWord : public MetaItem {\n+            Identifier ident;\n+\n+          public:\n+            MetaWord(Identifier ident) : ident(::std::move(ident)) {}\n+\n+            ::std::string as_string() const OVERRIDE {\n+                return ident;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaWord* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaWord(*this);\n+            }\n+        };\n+\n+        // Preferred specialisation for \"identifier '=' string literal\" meta items.\n+        class MetaNameValueStr : public MetaItem {\n+            Identifier ident;\n+            ::std::string str;\n+\n+          public:\n+            MetaNameValueStr(Identifier ident, ::std::string str) :\n+              ident(::std::move(ident)), str(::std::move(str)) {}\n+\n+            ::std::string as_string() const OVERRIDE {\n+                return ident + \" = \" + str;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            // HACK: used to simplify parsing - creates a copy of this\n+            virtual MetaNameValueStr* to_meta_name_value_str() const OVERRIDE {\n+                return clone_meta_item_inner_impl();\n+            }\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE; \n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaNameValueStr* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaNameValueStr(*this);\n+            }\n+        };\n+\n+        // doubles up as MetaListIdents - determine via iterating through each path?\n+        // Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n+        class MetaListPaths : public MetaItem {\n+            Identifier ident;\n+            ::std::vector<SimplePath> paths;\n+\n+          public:\n+            MetaListPaths(Identifier ident, ::std::vector<SimplePath> paths) :\n+              ident(::std::move(ident)), paths(::std::move(paths)) {}\n+\n+            ::std::string as_string() const OVERRIDE;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n+\n+          private:\n+            bool check_path_exists_in_cfg(const Session& session, const SimplePath& path) const;\n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaListPaths* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaListPaths(*this);\n+            }\n+        };\n+\n+        // Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n+        class MetaListNameValueStr : public MetaItem {\n+            Identifier ident;\n+            ::std::vector<MetaNameValueStr> strs;\n+\n+          public:\n+            MetaListNameValueStr(Identifier ident, ::std::vector<MetaNameValueStr> strs) :\n+              ident(::std::move(ident)), strs(::std::move(strs)) {}\n+\n+            ::std::string as_string() const OVERRIDE;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n+            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n+\n+          protected:\n+            // Use covariance to implement clone function as returning this type\n+            virtual MetaListNameValueStr* clone_meta_item_inner_impl() const OVERRIDE {\n+                return new MetaListNameValueStr(*this);\n+            }\n+        };\n+\n+        // Object that parses macros from a token stream.\n+        struct MacroParser {\n+          private:\n+            ::std::vector< ::std::unique_ptr<Token> > token_stream;\n+            // probably have to make this mutable (mutable int stream_pos) otherwise const has to be\n+            // removed up to DelimTokenTree or further ok since this changing would have an effect on\n+            // the results of the methods run (i.e. not logically const), the parsing methods\n+            // shouldn't be const\n+            int stream_pos;\n+\n+          public:\n+            MacroParser(\n+              ::std::vector< ::std::unique_ptr<Token> > token_stream, int stream_start_pos = 0) :\n+              token_stream(::std::move(token_stream)),\n+              stream_pos(stream_start_pos) {}\n+\n+            ~MacroParser() = default;\n+\n+            ::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq();\n+\n+          private:\n+            // Parses a MetaItemInner.\n+            ::std::unique_ptr<MetaItemInner> parse_meta_item_inner();\n+            // Returns whether token can end a meta item.\n+            bool is_end_meta_item_tok(TokenId id) const;\n+            // Parses a simple path.\n+            SimplePath parse_simple_path();\n+            // Parses a segment of a simple path (but not scope resolution operator).\n+            SimplePathSegment parse_simple_path_segment();\n+            // Parses a MetaItemLitExpr.\n+            ::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit();\n+            // Parses a literal.\n+            Literal parse_literal();\n+            // Parses a meta item that begins with a simple path.\n+            ::std::unique_ptr<MetaItem> parse_path_meta_item();\n+\n+            // TODO: should this be const?\n+            ::std::unique_ptr<Token>& peek_token(int i = 0) {\n+                return token_stream[stream_pos + i];\n+            }\n+\n+            void skip_token(int i = 0) {\n+                stream_pos += 1 + i;\n+            }\n+        };\n     }\n }\n "}, {"sha": "cddd06290ae1173f96cc43150069781805f51b49", "filename": "gcc/rust/test3/ast/rust-path.h", "status": "modified", "additions": 166, "deletions": 42, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -20,13 +20,17 @@ namespace Rust {\n         class PathIdentSegment {\n             ::std::string segment_name;\n \n+            // TODO: should this have location info stored?\n+\n             // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n           public:\n             PathIdentSegment(::std::string segment_name) : segment_name(::std::move(segment_name)) {}\n \n             /* TODO: insert check in constructor for this? Or is this a semantic error best handled\n              * then? */\n \n+            // TODO: does this require visitor. pretty sure this isn't polymorphic, but not entirely sure\n+\n             // Creates an error PathIdentSegment.\n             static PathIdentSegment create_error() {\n                 return PathIdentSegment(\"\");\n@@ -49,6 +53,8 @@ namespace Rust {\n             // Type type;\n             ::std::unique_ptr<Type> type;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether binding is in an error state.\n             inline bool is_error() const {\n@@ -61,12 +67,14 @@ namespace Rust {\n             }\n \n             // Pointer type for type in constructor to enable polymorphism\n-            GenericArgsBinding(Identifier ident, Type* type_ptr) :\n-              identifier(::std::move(ident)), type(type_ptr) {}\n+            GenericArgsBinding(Identifier ident, ::std::unique_ptr<Type> type_ptr,\n+              location_t locus = UNKNOWN_LOCATION) :\n+              identifier(::std::move(ident)),\n+              type(::std::move(type_ptr)), locus(locus) {}\n \n             // Copy constructor has to deep copy the type as it is a unique pointer\n             GenericArgsBinding(GenericArgsBinding const& other) :\n-              identifier(other.identifier), type(other.type->clone_type()) {}\n+              identifier(other.identifier), type(other.type->clone_type()), locus(other.locus) {}\n \n             // default destructor\n             ~GenericArgsBinding() = default;\n@@ -75,12 +83,15 @@ namespace Rust {\n             GenericArgsBinding& operator=(GenericArgsBinding const& other) {\n                 identifier = other.identifier;\n                 type = other.type->clone_type();\n+                locus = other.locus;\n                 return *this;\n             }\n \n             // move constructors\n             GenericArgsBinding(GenericArgsBinding&& other) = default;\n             GenericArgsBinding& operator=(GenericArgsBinding&& other) = default;\n+\n+            ::std::string as_string() const;\n         };\n \n         // Generic arguments allowed in each path expression segment - inline?\n@@ -90,6 +101,8 @@ namespace Rust {\n             ::std::vector< ::std::unique_ptr<Type> > type_args;\n             ::std::vector<GenericArgsBinding> binding_args;\n \n+            location_t locus;\n+\n           public:\n             // Returns true if there are any generic arguments\n             inline bool has_generic_args() const {\n@@ -98,13 +111,15 @@ namespace Rust {\n \n             GenericArgs(::std::vector<Lifetime> lifetime_args,\n               ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args) :\n+              ::std::vector<GenericArgsBinding> binding_args, location_t locus = UNKNOWN_LOCATION) :\n               lifetime_args(::std::move(lifetime_args)),\n-              type_args(::std::move(type_args)), binding_args(::std::move(binding_args)) {}\n+              type_args(::std::move(type_args)), binding_args(::std::move(binding_args)),\n+              locus(locus) {}\n \n             // copy constructor with vector clone\n             GenericArgs(GenericArgs const& other) :\n-              lifetime_args(other.lifetime_args), binding_args(other.binding_args) {\n+              lifetime_args(other.lifetime_args), binding_args(other.binding_args),\n+              locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_args.reserve(other.type_args.size());\n \n@@ -119,6 +134,7 @@ namespace Rust {\n             GenericArgs& operator=(GenericArgs const& other) {\n                 lifetime_args = other.lifetime_args;\n                 binding_args = other.binding_args;\n+                locus = other.locus;\n \n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_args.reserve(other.type_args.size());\n@@ -151,27 +167,32 @@ namespace Rust {\n             // bool has_generic_args;\n             GenericArgs generic_args;\n \n+            location_t locus;\n+\n+            // TODO: does this require visitor? pretty sure not polymorphic\n+\n           public:\n             // Returns true if there are any generic arguments\n             inline bool has_generic_args() const {\n                 return generic_args.has_generic_args();\n             }\n \n             // Constructor for segment (from IdentSegment and GenericArgs)\n-            PathExprSegment(\n-              PathIdentSegment segment_name, GenericArgs generic_args = GenericArgs::create_empty()) :\n+            PathExprSegment(PathIdentSegment segment_name, location_t locus = UNKNOWN_LOCATION,\n+              GenericArgs generic_args = GenericArgs::create_empty()) :\n               segment_name(::std::move(segment_name)),\n-              generic_args(::std::move(generic_args)) {}\n+              generic_args(::std::move(generic_args)), locus(locus) {}\n \n             // Constructor for segment with generic arguments (from segment name and all args)\n-            PathExprSegment(::std::string segment_name,\n+            PathExprSegment(::std::string segment_name, location_t locus,\n               ::std::vector<Lifetime> lifetime_args = ::std::vector<Lifetime>(),\n               ::std::vector< ::std::unique_ptr<Type> > type_args\n               = ::std::vector< ::std::unique_ptr<Type> >(),\n               ::std::vector<GenericArgsBinding> binding_args = ::std::vector<GenericArgsBinding>()) :\n               segment_name(PathIdentSegment(::std::move(segment_name))),\n               generic_args(GenericArgs(\n-                ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))) {}\n+                ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))),\n+              locus(locus) {}\n \n             // Returns whether path expression segment is in an error state.\n             inline bool is_error() const {\n@@ -184,6 +205,10 @@ namespace Rust {\n             }\n \n             ::std::string as_string() const;\n+\n+            inline location_t get_locus() const {\n+                return locus;\n+            }\n         };\n \n         // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -208,20 +233,28 @@ namespace Rust {\n             inline bool is_single_segment() const {\n                 return segments.size() == 1;\n             }\n+\n+            virtual ::std::string as_string() const;\n         };\n \n         // AST node representing a path-in-expression pattern (path that allows generic arguments)\n-        class PathInExpression : public PathPattern {\n+        class PathInExpression\n+          : public PathPattern\n+          , public PathExpr {\n             bool has_opening_scope_resolution;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n             // Constructor\n             PathInExpression(::std::vector<PathExprSegment> path_segments,\n-              bool has_opening_scope_resolution = false) :\n+              location_t locus = UNKNOWN_LOCATION, bool has_opening_scope_resolution = false,\n+              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               PathPattern(::std::move(path_segments)),\n-              has_opening_scope_resolution(has_opening_scope_resolution) {}\n+              PathExpr(::std::move(outer_attrs)),\n+              has_opening_scope_resolution(has_opening_scope_resolution), locus(locus) {}\n \n             // Creates an error state path in expression.\n             static PathInExpression create_error() {\n@@ -243,11 +276,26 @@ namespace Rust {\n                 return convert_to_simple_path(has_opening_scope_resolution);\n             }\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            location_t get_locus_slow() const OVERRIDE {\n+                return get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual PathInExpression* clone_pattern_impl() const OVERRIDE {\n                 return new PathInExpression(*this);\n             }\n+\n+            // Use covariance to implement clone function as returning this object rather than base\n+            virtual PathInExpression* clone_expr_without_block_impl() const OVERRIDE {\n+                return new PathInExpression(*this);\n+            }\n         };\n \n         // Base class for segments used in type paths - not abstract (represents an ident-only\n@@ -259,6 +307,8 @@ namespace Rust {\n              * so could disallow that in constructor, which won't give that much size overhead. */\n             PathIdentSegment ident_segment;\n \n+            location_t locus;\n+\n           protected:\n             // This is protected because it is only really used by derived classes, not the base.\n             bool has_separating_scope_resolution;\n@@ -276,13 +326,15 @@ namespace Rust {\n                 return ::std::unique_ptr<TypePathSegment>(clone_type_path_segment_impl());\n             }\n \n-            TypePathSegment(PathIdentSegment ident_segment, bool has_separating_scope_resolution) :\n+            TypePathSegment(PathIdentSegment ident_segment, bool has_separating_scope_resolution,\n+              location_t locus) :\n               ident_segment(::std::move(ident_segment)),\n-              has_separating_scope_resolution(has_separating_scope_resolution) {}\n+              locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n \n-            TypePathSegment(::std::string segment_name, bool has_separating_scope_resolution) :\n+            TypePathSegment(\n+              ::std::string segment_name, bool has_separating_scope_resolution, location_t locus) :\n               ident_segment(PathIdentSegment(::std::move(segment_name))),\n-              has_separating_scope_resolution(has_separating_scope_resolution) {}\n+              locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n \n             virtual ::std::string as_string() const {\n                 return ident_segment.as_string();\n@@ -293,11 +345,18 @@ namespace Rust {\n                 return ident_segment.is_error();\n             }\n \n-            /* Returns whether segment is identifier only (as opposed to generic args or function). \n+            /* Returns whether segment is identifier only (as opposed to generic args or function).\n             Overriden in derived classes with other segments. */\n             virtual bool is_ident_only() const {\n                 return true;\n             }\n+\n+            inline bool get_locus() const {\n+                return locus;\n+            }\n+\n+            // not pure virtual as class not abstract\n+            virtual void accept_vis(ASTVisitor& vis);\n         };\n \n         // Segment used in type path with generic args\n@@ -315,21 +374,23 @@ namespace Rust {\n \n             // Constructor with PathIdentSegment and GenericArgs\n             TypePathSegmentGeneric(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, GenericArgs generic_args) :\n-              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution),\n+              bool has_separating_scope_resolution, GenericArgs generic_args, location_t locus) :\n+              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n               generic_args(::std::move(generic_args)) {}\n \n             // Constructor from segment name and all args\n             TypePathSegmentGeneric(::std::string segment_name, bool has_separating_scope_resolution,\n               ::std::vector<Lifetime> lifetime_args,\n               ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args) :\n-              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution),\n+              ::std::vector<GenericArgsBinding> binding_args, location_t locus) :\n+              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n               generic_args(GenericArgs(\n                 ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))) {}\n \n             ::std::string as_string() const;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to override base class method\n             virtual TypePathSegmentGeneric* clone_type_path_segment_impl() const OVERRIDE {\n@@ -353,6 +414,8 @@ namespace Rust {\n             // FIXME: think of better way to mark as invalid than taking up storage\n             bool is_invalid;\n \n+            // TODO: should this have location info?\n+\n           protected:\n             // Constructor only used to create invalid type path functions.\n             TypePathFunction(bool is_invalid) : is_invalid(is_invalid) {}\n@@ -381,6 +444,13 @@ namespace Rust {\n             // Constructor\n             TypePathFunction(::std::vector< ::std::unique_ptr<Type> > inputs, Type* type = NULL) :\n               inputs(::std::move(inputs)), return_type(type), is_invalid(false) {}\n+            // FIXME: deprecated\n+\n+            // Constructor\n+            TypePathFunction(\n+              ::std::vector< ::std::unique_ptr<Type> > inputs, ::std::unique_ptr<Type> type = NULL) :\n+              inputs(::std::move(inputs)),\n+              return_type(::std::move(type)), is_invalid(false) {}\n \n             // Copy constructor with clone\n             TypePathFunction(TypePathFunction const& other) :\n@@ -415,6 +485,8 @@ namespace Rust {\n             // move constructors\n             TypePathFunction(TypePathFunction&& other) = default;\n             TypePathFunction& operator=(TypePathFunction&& other) = default;\n+\n+            ::std::string as_string() const;\n         };\n \n         // Segment used in type path with a function argument\n@@ -424,14 +496,15 @@ namespace Rust {\n           public:\n             // Constructor with PathIdentSegment and TypePathFn\n             TypePathSegmentFunction(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, TypePathFunction function_path) :\n-              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution),\n+              bool has_separating_scope_resolution, TypePathFunction function_path,\n+              location_t locus) :\n+              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n               function_path(::std::move(function_path)) {}\n \n             // Constructor with segment name and TypePathFn\n             TypePathSegmentFunction(::std::string segment_name, bool has_separating_scope_resolution,\n-              TypePathFunction function_path) :\n-              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution),\n+              TypePathFunction function_path, location_t locus) :\n+              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n               function_path(::std::move(function_path)) {}\n \n             ::std::string as_string() const;\n@@ -440,6 +513,8 @@ namespace Rust {\n                 return false;\n             }\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to override base class method\n             virtual TypePathSegmentFunction* clone_type_path_segment_impl() const OVERRIDE {\n@@ -452,6 +527,8 @@ namespace Rust {\n             bool has_opening_scope_resolution;\n             ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TypePath* clone_type_impl() const OVERRIDE {\n@@ -482,13 +559,13 @@ namespace Rust {\n \n             // Constructor\n             TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> > segments,\n-              bool has_opening_scope_resolution = false) :\n+              location_t locus = UNKNOWN_LOCATION, bool has_opening_scope_resolution = false) :\n               has_opening_scope_resolution(has_opening_scope_resolution),\n-              segments(::std::move(segments)) {}\n+              segments(::std::move(segments)), locus(locus) {}\n \n             // Copy constructor with vector clone\n             TypePath(TypePath const& other) :\n-              has_opening_scope_resolution(other.has_opening_scope_resolution) {\n+              has_opening_scope_resolution(other.has_opening_scope_resolution), locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 segments.reserve(other.segments.size());\n \n@@ -500,6 +577,7 @@ namespace Rust {\n             // Overloaded assignment operator with clone\n             TypePath& operator=(TypePath const& other) {\n                 has_opening_scope_resolution = other.has_opening_scope_resolution;\n+                locus = other.locus;\n \n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 segments.reserve(other.segments.size());\n@@ -521,8 +599,14 @@ namespace Rust {\n              * Otherwise returns an empty SimplePath. */\n             SimplePath as_simple_path() const;\n \n-            // Creates a trait bound with a clone of this type path as its only element. \n+            // Creates a trait bound with a clone of this type path as its only element.\n             virtual TraitBound* to_trait_bound(bool in_parens) const OVERRIDE;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         struct QualifiedPathType {\n@@ -533,15 +617,19 @@ namespace Rust {\n             // bool has_as_clause;\n             TypePath trait_path;\n \n+            location_t locus;\n+\n           public:\n             // Constructor\n-            QualifiedPathType(Type* invoke_on_type, TypePath trait_path = TypePath::create_error()) :\n-              type_to_invoke_on(invoke_on_type), trait_path(::std::move(trait_path)) {}\n+            QualifiedPathType(::std::unique_ptr<Type> invoke_on_type,\n+              location_t locus = UNKNOWN_LOCATION, TypePath trait_path = TypePath::create_error()) :\n+              type_to_invoke_on(::std::move(invoke_on_type)),\n+              trait_path(::std::move(trait_path)), locus(locus) {}\n \n             // Copy constructor uses custom deep copy for Type to preserve polymorphism\n             QualifiedPathType(QualifiedPathType const& other) :\n-              type_to_invoke_on(other.type_to_invoke_on->clone_type()), trait_path(other.trait_path) {\n-            }\n+              type_to_invoke_on(other.type_to_invoke_on->clone_type()), trait_path(other.trait_path),\n+              locus(other.locus) {}\n \n             // default destructor\n             ~QualifiedPathType() = default;\n@@ -550,6 +638,7 @@ namespace Rust {\n             QualifiedPathType& operator=(QualifiedPathType const& other) {\n                 type_to_invoke_on = other.type_to_invoke_on->clone_type();\n                 trait_path = other.trait_path;\n+                locus = other.locus;\n                 return *this;\n             }\n \n@@ -571,19 +660,32 @@ namespace Rust {\n             static QualifiedPathType create_error() {\n                 return QualifiedPathType(NULL);\n             }\n+\n+            ::std::string as_string() const;\n+\n+            inline location_t get_locus() const {\n+                return locus;\n+            }\n         };\n \n         /* AST node representing a qualified path-in-expression pattern (path that allows specifying\n          * trait functions) */\n-        class QualifiedPathInExpression : public PathPattern {\n+        class QualifiedPathInExpression\n+          : public PathPattern\n+          , public PathExpr {\n             QualifiedPathType path_type;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n-            QualifiedPathInExpression(\n-              QualifiedPathType qual_path_type, ::std::vector<PathExprSegment> path_segments) :\n-              PathPattern(::std::move(path_segments)), path_type(::std::move(qual_path_type)) {}\n+            QualifiedPathInExpression(QualifiedPathType qual_path_type,\n+              ::std::vector<PathExprSegment> path_segments, location_t locus = UNKNOWN_LOCATION,\n+              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n+              PathPattern(::std::move(path_segments)),\n+              PathExpr(::std::move(outer_attrs)), path_type(::std::move(qual_path_type)),\n+              locus(locus) {}\n \n             // TODO: maybe make a shortcut constructor that has QualifiedPathType elements as params\n \n@@ -600,11 +702,26 @@ namespace Rust {\n                   QualifiedPathType::create_error(), ::std::vector<PathExprSegment>());\n             }\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            location_t get_locus_slow() const OVERRIDE {\n+                return get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual QualifiedPathInExpression* clone_pattern_impl() const OVERRIDE {\n                 return new QualifiedPathInExpression(*this);\n             }\n+\n+            // Use covariance to implement clone function as returning this object rather than base\n+            virtual QualifiedPathInExpression* clone_expr_without_block_impl() const OVERRIDE {\n+                return new QualifiedPathInExpression(*this);\n+            }\n         };\n \n         // Represents a qualified path in a type; used for disambiguating trait function calls\n@@ -613,6 +730,8 @@ namespace Rust {\n             // ::std::vector<TypePathSegment> segments;\n             ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual QualifiedPathInType* clone_type_impl() const OVERRIDE {\n@@ -626,14 +745,16 @@ namespace Rust {\n \n           public:\n             QualifiedPathInType(QualifiedPathType qual_path_type,\n-              ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments) :\n+              ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments,\n+              location_t locus = UNKNOWN_LOCATION) :\n               path_type(::std::move(qual_path_type)),\n-              segments(::std::move(path_segments)) {}\n+              segments(::std::move(path_segments)), locus(locus) {}\n \n             // TODO: maybe make a shortcut constructor that has QualifiedPathType elements as params\n \n             // Copy constructor with vector clone\n-            QualifiedPathInType(QualifiedPathInType const& other) : path_type(other.path_type) {\n+            QualifiedPathInType(QualifiedPathInType const& other) :\n+              path_type(other.path_type), locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 segments.reserve(other.segments.size());\n \n@@ -645,6 +766,7 @@ namespace Rust {\n             // Overloaded assignment operator with vector clone\n             QualifiedPathInType& operator=(QualifiedPathInType const& other) {\n                 path_type = other.path_type;\n+                locus = other.locus;\n \n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 segments.reserve(other.segments.size());\n@@ -672,6 +794,8 @@ namespace Rust {\n             }\n \n             ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n     }\n }"}, {"sha": "f0cabee1b220c7a68ab2a288626bbad4732188ab", "filename": "gcc/rust/test3/ast/rust-pattern.h", "status": "modified", "additions": 251, "deletions": 44, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -15,15 +15,25 @@ namespace Rust {\n             bool has_minus;\n             // Actually, this might be a good place to use a template.\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n             // Constructor for a literal pattern\n-            LiteralPattern(Literal lit, bool has_minus = false) :\n-              lit(::std::move(lit)), has_minus(has_minus) {}\n+            LiteralPattern(Literal lit, location_t locus, bool has_minus = false) :\n+              lit(::std::move(lit)), has_minus(has_minus), locus(locus) {}\n+\n+            LiteralPattern(\n+              ::std::string val, Literal::LitType type, location_t locus, bool has_minus = false) :\n+              lit(Literal(::std::move(val), type)),\n+              has_minus(has_minus), locus(locus) {}\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n \n-            LiteralPattern(::std::string val, Literal::LitType type, bool has_minus = false) :\n-              lit(Literal(::std::move(val), type)), has_minus(has_minus) {}\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -42,6 +52,8 @@ namespace Rust {\n             // Pattern* to_bind;\n             ::std::unique_ptr<Pattern> to_bind;\n \n+            location_t locus;\n+\n           public:\n             /*~IdentifierPattern() {\n                 delete to_bind;\n@@ -55,15 +67,20 @@ namespace Rust {\n             }\n \n             // Constructor\n-            IdentifierPattern(\n-              Identifier ident, bool is_ref = false, bool is_mut = false, Pattern* to_bind = NULL) :\n+            IdentifierPattern(Identifier ident, location_t locus, bool is_ref = false,\n+              bool is_mut = false, ::std::unique_ptr<Pattern> to_bind = NULL) :\n               variable_ident(::std::move(ident)),\n-              is_ref(is_ref), is_mut(is_mut), to_bind(to_bind) {}\n+              is_ref(is_ref), is_mut(is_mut), to_bind(::std::move(to_bind)), locus(locus) {}\n \n             // Copy constructor with clone\n             IdentifierPattern(IdentifierPattern const& other) :\n               variable_ident(other.variable_ident), is_ref(other.is_ref), is_mut(other.is_mut),\n-              to_bind(other.to_bind->clone_pattern()) {}\n+              locus(other.locus) {\n+                // fix to get prevent null pointer dereference\n+                if (other.to_bind != NULL) {\n+                    to_bind = other.to_bind->clone_pattern();\n+                }\n+            }\n \n             // Destructor - define here if required\n \n@@ -72,7 +89,11 @@ namespace Rust {\n                 variable_ident = other.variable_ident;\n                 is_ref = other.is_ref;\n                 is_mut = other.is_mut;\n-                to_bind = other.to_bind->clone_pattern();\n+                locus = other.locus;\n+                // fix to get prevent null pointer dereference\n+                if (other.to_bind != NULL) {\n+                    to_bind = other.to_bind->clone_pattern();\n+                }\n \n                 return *this;\n             }\n@@ -81,6 +102,12 @@ namespace Rust {\n             IdentifierPattern(IdentifierPattern&& other) = default;\n             IdentifierPattern& operator=(IdentifierPattern&& other) = default;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual IdentifierPattern* clone_pattern_impl() const OVERRIDE {\n@@ -90,12 +117,20 @@ namespace Rust {\n \n         // AST node for using the '_' wildcard \"match any value\" pattern\n         class WildcardPattern : public Pattern {\n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const {\n                 return ::std::string(1, '_');\n             }\n \n-            WildcardPattern() {}\n+            WildcardPattern(location_t locus) : locus(locus) {}\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -122,6 +157,10 @@ namespace Rust {\n                 return ::std::unique_ptr<RangePatternBound>(clone_range_pattern_bound_impl());\n             }\n \n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // pure virtual as RangePatternBound is abstract\n             virtual RangePatternBound* clone_range_pattern_bound_impl() const = 0;\n@@ -135,10 +174,20 @@ namespace Rust {\n             // Minus prefixed to literal (if integer or floating-point)\n             bool has_minus;\n \n+            location_t locus;\n+\n           public:\n             // Constructor\n-            RangePatternBoundLiteral(Literal literal, bool has_minus = false) :\n-              literal(literal), has_minus(has_minus) {}\n+            RangePatternBoundLiteral(Literal literal, location_t locus, bool has_minus = false) :\n+              literal(literal), has_minus(has_minus), locus(locus) {}\n+\n+            ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -151,9 +200,22 @@ namespace Rust {\n         class RangePatternBoundPath : public RangePatternBound {\n             PathInExpression path;\n \n+            // TODO: should this be refactored so that PathInExpression is a subclass of\n+            // RangePatternBound?\n+\n           public:\n             RangePatternBoundPath(PathInExpression path) : path(::std::move(path)) {}\n \n+            ::std::string as_string() const {\n+                return path.as_string();\n+            }\n+\n+            location_t get_locus() const {\n+                return path.get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual RangePatternBoundPath* clone_range_pattern_bound_impl() const OVERRIDE {\n@@ -165,9 +227,22 @@ namespace Rust {\n         class RangePatternBoundQualPath : public RangePatternBound {\n             QualifiedPathInExpression path;\n \n+            /* TODO: should this be refactored so that QualifiedPathInExpression is a subclass of\n+             * RangePatternBound? */\n+\n           public:\n             RangePatternBoundQualPath(QualifiedPathInExpression path) : path(::std::move(path)) {}\n \n+            ::std::string as_string() const {\n+                return path.as_string();\n+            }\n+\n+            location_t get_locus() const {\n+                return path.get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual RangePatternBoundQualPath* clone_range_pattern_bound_impl() const OVERRIDE {\n@@ -184,20 +259,25 @@ namespace Rust {\n \n             bool has_ellipsis_syntax;\n \n+            // location only stored to avoid a dereference - lower pattern should give correct\n+            // location so maybe change in future\n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n             // Constructor\n-            RangePattern(\n-              RangePatternBound* lower, RangePatternBound* upper, bool has_ellipsis_syntax = false) :\n-              lower(lower),\n-              upper(upper), has_ellipsis_syntax(has_ellipsis_syntax) {}\n+            RangePattern(::std::unique_ptr<RangePatternBound> lower,\n+              ::std::unique_ptr<RangePatternBound> upper, location_t locus,\n+              bool has_ellipsis_syntax = false) :\n+              lower(::std::move(lower)),\n+              upper(::std::move(upper)), has_ellipsis_syntax(has_ellipsis_syntax), locus(locus) {}\n \n             // Copy constructor with clone\n             RangePattern(RangePattern const& other) :\n               lower(other.lower->clone_range_pattern_bound()),\n               upper(other.upper->clone_range_pattern_bound()),\n-              has_ellipsis_syntax(other.has_ellipsis_syntax) {}\n+              has_ellipsis_syntax(other.has_ellipsis_syntax), locus(other.locus) {}\n \n             // Destructor - define here if required\n \n@@ -206,6 +286,7 @@ namespace Rust {\n                 lower = other.lower->clone_range_pattern_bound();\n                 upper = other.upper->clone_range_pattern_bound();\n                 has_ellipsis_syntax = other.has_ellipsis_syntax;\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -214,6 +295,12 @@ namespace Rust {\n             RangePattern(RangePattern&& other) = default;\n             RangePattern& operator=(RangePattern&& other) = default;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual RangePattern* clone_pattern_impl() const OVERRIDE {\n@@ -228,20 +315,24 @@ namespace Rust {\n             // Pattern* pattern;\n             ::std::unique_ptr<Pattern> pattern;\n \n+            location_t locus;\n+\n           public:\n             /*~ReferencePattern() {\n                 delete pattern;\n             }*/\n \n             ::std::string as_string() const;\n \n-            ReferencePattern(Pattern* pattern, bool is_mut_reference, bool ref_has_two_amps) :\n-              has_two_amps(ref_has_two_amps), is_mut(is_mut_reference), pattern(pattern) {}\n+            ReferencePattern(::std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+              bool ref_has_two_amps, location_t locus) :\n+              has_two_amps(ref_has_two_amps),\n+              is_mut(is_mut_reference), pattern(::std::move(pattern)), locus(locus) {}\n \n             // Copy constructor requires clone\n             ReferencePattern(ReferencePattern const& other) :\n               has_two_amps(other.has_two_amps), is_mut(other.is_mut),\n-              pattern(other.pattern->clone_pattern()) {}\n+              pattern(other.pattern->clone_pattern()), locus(other.locus) {}\n \n             // Destructor - define here if required\n \n@@ -250,6 +341,7 @@ namespace Rust {\n                 pattern = other.pattern->clone_pattern();\n                 is_mut = other.is_mut;\n                 has_two_amps = other.has_two_amps;\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -258,6 +350,8 @@ namespace Rust {\n             ReferencePattern(ReferencePattern&& other) = default;\n             ReferencePattern& operator=(ReferencePattern&& other) = default;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ReferencePattern* clone_pattern_impl() const OVERRIDE {\n@@ -270,6 +364,8 @@ namespace Rust {\n           private:\n             ::std::vector<Attribute> outer_attrs;\n \n+            // should this store location data?\n+\n           public:\n             StructPatternEtc(::std::vector<Attribute> outer_attribs) :\n               outer_attrs(::std::move(outer_attribs)) {}\n@@ -299,6 +395,8 @@ namespace Rust {\n                 } ident;\n             } pattern;*/\n \n+            location_t locus;\n+\n           public:\n             virtual ~StructPatternField() {}\n \n@@ -307,9 +405,17 @@ namespace Rust {\n                 return ::std::unique_ptr<StructPatternField>(clone_struct_pattern_field_impl());\n             }\n \n+            virtual ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n-            StructPatternField(::std::vector<Attribute> outer_attribs) :\n-              outer_attrs(::std::move(outer_attribs)) {}\n+            StructPatternField(::std::vector<Attribute> outer_attribs, location_t locus) :\n+              outer_attrs(::std::move(outer_attribs)), locus(locus) {}\n \n             // Clone function implementation as pure virtual method\n             virtual StructPatternField* clone_struct_pattern_field_impl() const = 0;\n@@ -326,10 +432,10 @@ namespace Rust {\n                 delete tuple_pattern;\n             }*/\n \n-            StructPatternFieldTuplePat(\n-              TupleIndex index, Pattern* tuple_pattern, ::std::vector<Attribute> outer_attribs) :\n-              StructPatternField(::std::move(outer_attribs)),\n-              index(index), tuple_pattern(tuple_pattern) {}\n+            StructPatternFieldTuplePat(TupleIndex index, ::std::unique_ptr<Pattern> tuple_pattern,\n+              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              StructPatternField(::std::move(outer_attribs), locus),\n+              index(index), tuple_pattern(::std::move(tuple_pattern)) {}\n \n             // Copy constructor requires clone\n             StructPatternFieldTuplePat(StructPatternFieldTuplePat const& other) :\n@@ -352,6 +458,10 @@ namespace Rust {\n             StructPatternFieldTuplePat(StructPatternFieldTuplePat&& other) = default;\n             StructPatternFieldTuplePat& operator=(StructPatternFieldTuplePat&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual StructPatternFieldTuplePat* clone_struct_pattern_field_impl() const OVERRIDE {\n@@ -370,10 +480,10 @@ namespace Rust {\n                 delete ident_pattern;\n             }*/\n \n-            StructPatternFieldIdentPat(\n-              Identifier ident, Pattern* ident_pattern, ::std::vector<Attribute> outer_attrs) :\n-              StructPatternField(::std::move(outer_attrs)),\n-              ident(::std::move(ident)), ident_pattern(ident_pattern) {}\n+            StructPatternFieldIdentPat(Identifier ident, ::std::unique_ptr<Pattern> ident_pattern,\n+              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              StructPatternField(::std::move(outer_attrs), locus),\n+              ident(::std::move(ident)), ident_pattern(::std::move(ident_pattern)) {}\n \n             // Copy constructor requires clone\n             StructPatternFieldIdentPat(StructPatternFieldIdentPat const& other) :\n@@ -396,6 +506,10 @@ namespace Rust {\n             StructPatternFieldIdentPat(StructPatternFieldIdentPat&& other) = default;\n             StructPatternFieldIdentPat& operator=(StructPatternFieldIdentPat&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual StructPatternFieldIdentPat* clone_struct_pattern_field_impl() const OVERRIDE {\n@@ -411,11 +525,15 @@ namespace Rust {\n             Identifier ident;\n \n           public:\n-            StructPatternFieldIdent(\n-              Identifier ident, bool is_ref, bool is_mut, ::std::vector<Attribute> outer_attrs) :\n-              StructPatternField(::std::move(outer_attrs)),\n+            StructPatternFieldIdent(Identifier ident, bool is_ref, bool is_mut,\n+              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              StructPatternField(::std::move(outer_attrs), locus),\n               has_ref(is_ref), has_mut(is_mut), ident(::std::move(ident)) {}\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual StructPatternFieldIdent* clone_struct_pattern_field_impl() const OVERRIDE {\n@@ -435,12 +553,19 @@ namespace Rust {\n \n             // must have at least one of the two and maybe both\n \n+            // should this store location data?\n+\n           public:\n             // Returns whether there are any struct pattern fields\n             inline bool has_struct_pattern_fields() const {\n                 return !fields.empty();\n             }\n \n+            // Returns whether the struct pattern elements is entirely empty (no fields, no etc).\n+            inline bool is_empty() const {\n+                return !has_struct_pattern_fields() && !has_struct_pattern_etc;\n+            }\n+\n             // Constructor for StructPatternElements with both (potentially)\n             StructPatternElements(\n               ::std::vector< ::std::unique_ptr<StructPatternField> > fields, StructPatternEtc etc) :\n@@ -487,26 +612,41 @@ namespace Rust {\n                 return StructPatternElements(\n                   ::std::vector< ::std::unique_ptr<StructPatternField> >());\n             }\n+\n+            ::std::string as_string() const;\n         };\n \n         // Struct pattern AST node representation\n         class StructPattern : public Pattern {\n             PathInExpression path;\n \n-            bool has_struct_pattern_elements;\n+            // bool has_struct_pattern_elements;\n             StructPatternElements elems;\n \n+            // TODO: should this store location data? Accessor uses path location data.\n+\n           public:\n             ::std::string as_string() const;\n \n             // Constructs a struct pattern from specified StructPatternElements\n             StructPattern(PathInExpression struct_path,\n               StructPatternElements elems = StructPatternElements::create_empty()) :\n               path(::std::move(struct_path)),\n-              has_struct_pattern_elements(true), elems(::std::move(elems)) {}\n+              elems(::std::move(elems)) {}\n \n             // TODO: constructor to construct via elements included in StructPatternElements\n \n+            // Returns whether struct pattern has any struct pattern elements (if not, it is empty).\n+            inline bool has_struct_pattern_elems() const {\n+                return !elems.is_empty();\n+            }\n+\n+            location_t get_locus() const {\n+                return path.get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual StructPattern* clone_pattern_impl() const OVERRIDE {\n@@ -519,11 +659,17 @@ namespace Rust {\n           public:\n             virtual ~TupleStructItems() {}\n \n+            // TODO: should this store location data?\n+\n             // Unique pointer custom clone function\n             ::std::unique_ptr<TupleStructItems> clone_tuple_struct_items() const {\n                 return ::std::unique_ptr<TupleStructItems>(clone_tuple_struct_items_impl());\n             }\n \n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // pure virtual clone implementation\n             virtual TupleStructItems* clone_tuple_struct_items_impl() const = 0;\n@@ -564,6 +710,10 @@ namespace Rust {\n             TupleStructItemsNoRange(TupleStructItemsNoRange&& other) = default;\n             TupleStructItemsNoRange& operator=(TupleStructItemsNoRange&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TupleStructItemsNoRange* clone_tuple_struct_items_impl() const OVERRIDE {\n@@ -624,6 +774,10 @@ namespace Rust {\n             TupleStructItemsRange(TupleStructItemsRange&& other) = default;\n             TupleStructItemsRange& operator=(TupleStructItemsRange&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TupleStructItemsRange* clone_tuple_struct_items_impl() const OVERRIDE {\n@@ -637,11 +791,15 @@ namespace Rust {\n             // TupleStructItems items;\n             ::std::unique_ptr<TupleStructItems> items;\n \n+            // TOOD: should this store location data? current accessor uses path location data\n+\n           public:\n             ::std::string as_string() const;\n \n-            TupleStructPattern(PathInExpression tuple_struct_path, TupleStructItems* items) :\n-              path(::std::move(tuple_struct_path)), items(items) {}\n+            TupleStructPattern(\n+              PathInExpression tuple_struct_path, ::std::unique_ptr<TupleStructItems> items) :\n+              path(::std::move(tuple_struct_path)),\n+              items(::std::move(items)) {}\n \n             // Copy constructor required to clone\n             TupleStructPattern(TupleStructPattern const& other) :\n@@ -661,6 +819,12 @@ namespace Rust {\n             TupleStructPattern(TupleStructPattern&& other) = default;\n             TupleStructPattern& operator=(TupleStructPattern&& other) = default;\n \n+            location_t get_locus() const {\n+                return path.get_locus();\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TupleStructPattern* clone_pattern_impl() const OVERRIDE {\n@@ -673,11 +837,17 @@ namespace Rust {\n           public:\n             virtual ~TuplePatternItems() {}\n \n+            // TODO: should this store location data?\n+\n             // Unique pointer custom clone function\n             ::std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items() const {\n                 return ::std::unique_ptr<TuplePatternItems>(clone_tuple_pattern_items_impl());\n             }\n \n+            virtual ::std::string as_string() const = 0;\n+\n+            virtual void accept_vis(ASTVisitor& vis) = 0;\n+\n           protected:\n             // pure virtual clone implementation\n             virtual TuplePatternItems* clone_tuple_pattern_items_impl() const = 0;\n@@ -751,6 +921,10 @@ namespace Rust {\n             TuplePatternItemsMultiple(TuplePatternItemsMultiple&& other) = default;\n             TuplePatternItemsMultiple& operator=(TuplePatternItemsMultiple&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TuplePatternItemsMultiple* clone_tuple_pattern_items_impl() const OVERRIDE {\n@@ -811,6 +985,10 @@ namespace Rust {\n             TuplePatternItemsRanged(TuplePatternItemsRanged&& other) = default;\n             TuplePatternItemsRanged& operator=(TuplePatternItemsRanged&& other) = default;\n \n+            ::std::string as_string() const;\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TuplePatternItemsRanged* clone_tuple_pattern_items_impl() const OVERRIDE {\n@@ -824,6 +1002,8 @@ namespace Rust {\n             // TuplePatternItems items;\n             ::std::unique_ptr<TuplePatternItems> items;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n@@ -832,21 +1012,29 @@ namespace Rust {\n                 return items != NULL;\n             }\n \n-            TuplePattern(TuplePatternItems* items) : items(items) {}\n+            TuplePattern(::std::unique_ptr<TuplePatternItems> items, location_t locus) :\n+              items(::std::move(items)), locus(locus) {}\n \n             // Copy constructor requires clone\n             TuplePattern(TuplePattern const& other) :\n-              items(other.items->clone_tuple_pattern_items()) {}\n+              items(other.items->clone_tuple_pattern_items()), locus(other.locus) {}\n \n             // Destructor - define here if required\n \n             // Overload assignment operator to clone\n             TuplePattern& operator=(TuplePattern const& other) {\n                 items = other.items->clone_tuple_pattern_items();\n+                locus = other.locus;\n \n                 return *this;\n             }\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TuplePattern* clone_pattern_impl() const OVERRIDE {\n@@ -859,22 +1047,26 @@ namespace Rust {\n             // Pattern pattern_in_parens;\n             ::std::unique_ptr<Pattern> pattern_in_parens;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const {\n                 return \"(\" + pattern_in_parens->as_string() + \")\";\n             }\n \n-            GroupedPattern(Pattern* pattern_in_parens) : pattern_in_parens(pattern_in_parens) {}\n+            GroupedPattern(::std::unique_ptr<Pattern> pattern_in_parens, location_t locus) :\n+              pattern_in_parens(::std::move(pattern_in_parens)), locus(locus) {}\n \n             // Copy constructor uses clone\n             GroupedPattern(GroupedPattern const& other) :\n-              pattern_in_parens(other.pattern_in_parens->clone_pattern()) {}\n+              pattern_in_parens(other.pattern_in_parens->clone_pattern()), locus(other.locus) {}\n \n             // Destructor - define here if required\n \n             // Overload assignment operator to clone\n             GroupedPattern& operator=(GroupedPattern const& other) {\n                 pattern_in_parens = other.pattern_in_parens->clone_pattern();\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -883,6 +1075,12 @@ namespace Rust {\n             GroupedPattern(GroupedPattern&& other) = default;\n             GroupedPattern& operator=(GroupedPattern&& other) = default;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual GroupedPattern* clone_pattern_impl() const OVERRIDE {\n@@ -895,14 +1093,16 @@ namespace Rust {\n             //::std::vector<Pattern> items;\n             ::std::vector< ::std::unique_ptr<Pattern> > items;\n \n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const;\n \n-            SlicePattern(::std::vector< ::std::unique_ptr<Pattern> > items) :\n-              items(::std::move(items)) {}\n+            SlicePattern(::std::vector< ::std::unique_ptr<Pattern> > items, location_t locus) :\n+              items(::std::move(items)), locus(locus) {}\n \n             // Copy constructor with vector clone\n-            SlicePattern(SlicePattern const& other) {\n+            SlicePattern(SlicePattern const& other) : locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 items.reserve(other.items.size());\n \n@@ -913,6 +1113,7 @@ namespace Rust {\n \n             // Overloaded assignment operator to vector clone\n             SlicePattern& operator=(SlicePattern const& other) {\n+                locus = other.locus;\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 items.reserve(other.items.size());\n \n@@ -927,6 +1128,12 @@ namespace Rust {\n             SlicePattern(SlicePattern&& other) = default;\n             SlicePattern& operator=(SlicePattern&& other) = default;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual SlicePattern* clone_pattern_impl() const OVERRIDE {"}, {"sha": "ece0801b8e686783c58bb1b55925cb91f7e24875", "filename": "gcc/rust/test3/ast/rust-stmt.h", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -9,12 +9,20 @@ namespace Rust {\n     namespace AST {\n         // Just a semi-colon, which apparently is a statement.\n         class EmptyStmt : public Stmt {\n+            location_t locus;\n+\n           public:\n             ::std::string as_string() const {\n                 return ::std::string(1, ';');\n             }\n \n-            EmptyStmt() {}\n+            EmptyStmt(location_t locus) : locus(locus) {}\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -51,6 +59,8 @@ namespace Rust {\n             // Expr* init_expr;\n             ::std::unique_ptr<Expr> init_expr;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether let statement has outer attributes.\n             inline bool has_outer_attrs() const {\n@@ -75,16 +85,18 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            LetStmt(Pattern* variables_pattern, Expr* init_expr, Type* type,\n-              ::std::vector<Attribute> outer_attrs) :\n+            LetStmt(::std::unique_ptr<Pattern> variables_pattern, ::std::unique_ptr<Expr> init_expr,\n+              ::std::unique_ptr<Type> type, ::std::vector<Attribute> outer_attrs, location_t locus) :\n               outer_attrs(::std::move(outer_attrs)),\n-              variables_pattern(variables_pattern), type(type), init_expr(init_expr) {}\n+              variables_pattern(::std::move(variables_pattern)), type(::std::move(type)),\n+              init_expr(::std::move(init_expr)), locus(locus) {}\n \n             // Copy constructor with clone\n             LetStmt(LetStmt const& other) :\n               outer_attrs(other.outer_attrs),\n               variables_pattern(other.variables_pattern->clone_pattern()),\n-              type(other.type->clone_type()), init_expr(other.init_expr->clone_expr()) {}\n+              type(other.type->clone_type()), init_expr(other.init_expr->clone_expr()),\n+              locus(other.locus) {}\n \n             // Destructor - define here if required\n \n@@ -94,6 +106,7 @@ namespace Rust {\n                 init_expr = other.init_expr->clone_expr();\n                 type = other.type->clone_type();\n                 outer_attrs = other.outer_attrs;\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -102,6 +115,12 @@ namespace Rust {\n             LetStmt(LetStmt&& other) = default;\n             LetStmt& operator=(LetStmt&& other) = default;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual LetStmt* clone_stmt_impl() const OVERRIDE {\n@@ -112,6 +131,16 @@ namespace Rust {\n         // Abstract base class for expression statements (statements containing an expression)\n         class ExprStmt : public Stmt {\n             // TODO: add any useful virtual functions\n+\n+            location_t locus;\n+\n+          public:\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+          protected:\n+            ExprStmt(location_t locus) : locus(locus) {}\n         };\n \n         /* Statement containing an expression without a block (or, due to technical difficulties, can\n@@ -130,17 +159,20 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            // ExprStmtWithoutBlock(ExprWithoutBlock* expr) : expr(expr) {}\n-            ExprStmtWithoutBlock(Expr* expr) : expr(expr) {}\n+            // ExprStmtWithoutBlock(::std::unique_ptr<ExprWithoutBlock> expr) :\n+            // expr(::std::move(expr)) {}\n+            ExprStmtWithoutBlock(::std::unique_ptr<Expr> expr, location_t locus) :\n+              ExprStmt(locus), expr(::std::move(expr)) {}\n \n             // Copy constructor with clone\n             ExprStmtWithoutBlock(ExprStmtWithoutBlock const& other) :\n-              expr(other.expr->clone_expr /*_without_block*/ ()) {}\n+              ExprStmt(other), expr(other.expr->clone_expr /*_without_block*/ ()) {}\n \n             // Destructor - define here if required\n \n             // Overloaded assignment operator to clone\n             ExprStmtWithoutBlock& operator=(ExprStmtWithoutBlock const& other) {\n+                ExprStmt::operator=(other);\n                 expr = other.expr->clone_expr /*_without_block*/ ();\n \n                 return *this;\n@@ -150,6 +182,8 @@ namespace Rust {\n             ExprStmtWithoutBlock(ExprStmtWithoutBlock&& other) = default;\n             ExprStmtWithoutBlock& operator=(ExprStmtWithoutBlock&& other) = default;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ExprStmtWithoutBlock* clone_stmt_impl() const OVERRIDE {\n@@ -169,16 +203,18 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            ExprStmtWithBlock(ExprWithBlock* expr) : expr(expr) {}\n+            ExprStmtWithBlock(::std::unique_ptr<ExprWithBlock> expr, location_t locus) :\n+              ExprStmt(locus), expr(::std::move(expr)) {}\n \n             // Copy constructor with clone\n             ExprStmtWithBlock(ExprStmtWithBlock const& other) :\n-              expr(other.expr->clone_expr_with_block()) {}\n+              ExprStmt(other), expr(other.expr->clone_expr_with_block()) {}\n \n             // Destructor - define here if required\n \n             // Overloaded assignment operator to clone\n             ExprStmtWithBlock& operator=(ExprStmtWithBlock const& other) {\n+                ExprStmt::operator=(other);\n                 expr = other.expr->clone_expr_with_block();\n \n                 return *this;\n@@ -188,6 +224,8 @@ namespace Rust {\n             ExprStmtWithBlock(ExprStmtWithBlock&& other) = default;\n             ExprStmtWithBlock& operator=(ExprStmtWithBlock&& other) = default;\n \n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ExprStmtWithBlock* clone_stmt_impl() const OVERRIDE {"}, {"sha": "4ca408d9e4993c32489d61409e86549961cc4c02", "filename": "gcc/rust/test3/ast/rust-type.h", "status": "modified", "additions": 196, "deletions": 53, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -21,20 +21,29 @@ namespace Rust {\n \n             TypePath type_path;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether trait bound has \"for\" lifetimes\n             inline bool has_for_lifetimes() const {\n                 return !for_lifetimes.empty();\n             }\n \n-            TraitBound(TypePath type_path, bool in_parens = false, bool opening_question_mark = false,\n+            TraitBound(TypePath type_path, location_t locus, bool in_parens = false,\n+              bool opening_question_mark = false,\n               ::std::vector<LifetimeParam> for_lifetimes = ::std::vector<LifetimeParam>()) :\n               in_parens(in_parens),\n               opening_question_mark(opening_question_mark), for_lifetimes(::std::move(for_lifetimes)),\n-              type_path(::std::move(type_path)) {}\n+              type_path(::std::move(type_path)), locus(locus) {}\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Clone function implementation as (not pure) virtual method\n             virtual TraitBound* clone_type_param_bound_impl() const {\n@@ -50,18 +59,22 @@ namespace Rust {\n             // TypeParamBounds type_param_bounds;\n             ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ImplTraitType* clone_type_impl() const OVERRIDE {\n                 return new ImplTraitType(*this);\n             }\n \n           public:\n-            ImplTraitType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds) :\n-              type_param_bounds(::std::move(type_param_bounds)) {}\n+            ImplTraitType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n+              location_t locus) :\n+              type_param_bounds(::std::move(type_param_bounds)),\n+              locus(locus) {}\n \n             // copy constructor with vector clone\n-            ImplTraitType(ImplTraitType const& other) {\n+            ImplTraitType(ImplTraitType const& other) : locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_param_bounds.reserve(other.type_param_bounds.size());\n \n@@ -72,6 +85,7 @@ namespace Rust {\n \n             // overloaded assignment operator to clone\n             ImplTraitType& operator=(ImplTraitType const& other) {\n+                locus = other.locus;\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_param_bounds.reserve(other.type_param_bounds.size());\n \n@@ -87,6 +101,12 @@ namespace Rust {\n             ImplTraitType& operator=(ImplTraitType&& other) = default;\n \n             ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         // An opaque value of another type that implements a set of traits\n@@ -95,6 +115,8 @@ namespace Rust {\n             // TypeParamBounds type_param_bounds;\n             ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TraitObjectType* clone_type_impl() const OVERRIDE {\n@@ -103,12 +125,13 @@ namespace Rust {\n \n           public:\n             TraitObjectType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              bool is_dyn_dispatch = false) :\n+              location_t locus, bool is_dyn_dispatch = false) :\n               has_dyn(is_dyn_dispatch),\n-              type_param_bounds(::std::move(type_param_bounds)) {}\n+              type_param_bounds(::std::move(type_param_bounds)), locus(locus) {}\n \n             // copy constructor with vector clone\n-            TraitObjectType(TraitObjectType const& other) : has_dyn(other.has_dyn) {\n+            TraitObjectType(TraitObjectType const& other) :\n+              has_dyn(other.has_dyn), locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_param_bounds.reserve(other.type_param_bounds.size());\n \n@@ -120,6 +143,7 @@ namespace Rust {\n             // overloaded assignment operator to clone\n             TraitObjectType& operator=(TraitObjectType const& other) {\n                 has_dyn = other.has_dyn;\n+                locus = other.locus;\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 type_param_bounds.reserve(other.type_param_bounds.size());\n \n@@ -135,13 +159,21 @@ namespace Rust {\n             TraitObjectType& operator=(TraitObjectType&& other) = default;\n \n             ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         // A type with parentheses around it, used to avoid ambiguity.\n         class ParenthesisedType : public TypeNoBounds {\n             // Type type_in_parens;\n             ::std::unique_ptr<Type> type_in_parens;\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ParenthesisedType* clone_type_impl() const OVERRIDE {\n@@ -155,17 +187,19 @@ namespace Rust {\n \n           public:\n             // Constructor uses Type pointer for polymorphism\n-            ParenthesisedType(Type* type_inside_parens) : type_in_parens(type_inside_parens) {}\n+            ParenthesisedType(::std::unique_ptr<Type> type_inside_parens, location_t locus) :\n+              type_in_parens(::std::move(type_inside_parens)), locus(locus) {}\n \n             // Copy constructor uses custom deep copy method for type to preserve polymorphism\n             ParenthesisedType(ParenthesisedType const& other) :\n-              type_in_parens(other.type_in_parens->clone_type()) {}\n+              type_in_parens(other.type_in_parens->clone_type()), locus(other.locus) {}\n \n             // define destructor here if required\n \n             // overload assignment operator to use custom clone method\n             ParenthesisedType& operator=(ParenthesisedType const& other) {\n                 type_in_parens = other.type_in_parens->clone_type();\n+                locus = other.locus;\n                 return *this;\n             }\n \n@@ -177,19 +211,27 @@ namespace Rust {\n                 return \"(\" + type_in_parens->as_string() + \")\";\n             }\n \n-            // Creates a trait bound (clone of this one's trait bound) - HACK \n-            virtual TraitBound* to_trait_bound(bool in_parens) const OVERRIDE {\n-                /* NOTE: obviously it is unknown whether the internal type is a trait bound due to \n+            // Creates a trait bound (clone of this one's trait bound) - HACK\n+            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE {\n+                /* NOTE: obviously it is unknown whether the internal type is a trait bound due to\n                  * polymorphism, so just let the internal type handle it. As parenthesised type, it\n                  * must be in parentheses. */\n                 return type_in_parens->to_trait_bound(true);\n             }\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         // Impl trait with a single bound? Poor reference material here.\n         class ImplTraitTypeOneBound : public TypeNoBounds {\n             TraitBound trait_bound;\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ImplTraitTypeOneBound* clone_type_impl() const OVERRIDE {\n@@ -202,17 +244,26 @@ namespace Rust {\n             }\n \n           public:\n-            ImplTraitTypeOneBound(TraitBound trait_bound) : trait_bound(::std::move(trait_bound)) {}\n+            ImplTraitTypeOneBound(TraitBound trait_bound, location_t locus) :\n+              trait_bound(::std::move(trait_bound)), locus(locus) {}\n \n             ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n-        /* A trait object with a single trait bound. The \"trait bound\" is really just the trait. \n+        /* A trait object with a single trait bound. The \"trait bound\" is really just the trait.\n          * Basically like using an interface as a type in an OOP language. */\n         class TraitObjectTypeOneBound : public TypeNoBounds {\n             bool has_dyn;\n             TraitBound trait_bound;\n \n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TraitObjectTypeOneBound* clone_type_impl() const OVERRIDE {\n@@ -225,17 +276,25 @@ namespace Rust {\n             }\n \n           public:\n-            TraitObjectTypeOneBound(TraitBound trait_bound, bool is_dyn_dispatch = false) :\n-              has_dyn(is_dyn_dispatch), trait_bound(::std::move(trait_bound)) {}\n+            TraitObjectTypeOneBound(\n+              TraitBound trait_bound, location_t locus, bool is_dyn_dispatch = false) :\n+              has_dyn(is_dyn_dispatch),\n+              trait_bound(::std::move(trait_bound)), locus(locus) {}\n \n             ::std::string as_string() const;\n \n-            // Creates a trait bound (clone of this one's trait bound) - HACK \n-            virtual TraitBound* to_trait_bound(bool in_parens) const OVERRIDE {\n-                /* NOTE: this assumes there is no dynamic dispatch specified- if there was, this \n+            // Creates a trait bound (clone of this one's trait bound) - HACK\n+            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE {\n+                /* NOTE: this assumes there is no dynamic dispatch specified- if there was, this\n                  * cloning would not be required as parsing is unambiguous. */\n                 return new AST::TraitBound(trait_bound);\n             }\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         class TypePath; // definition moved to \"rust-path.h\"\n@@ -245,16 +304,19 @@ namespace Rust {\n             //::std::vector<Type> elems;\n             ::std::vector< ::std::unique_ptr<Type> > elems;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether the tuple type is the unit type, i.e. has no elements.\n             inline bool is_unit_type() const {\n                 return elems.empty();\n             }\n \n-            TupleType(::std::vector< ::std::unique_ptr<Type> > elems) : elems(::std::move(elems)) {}\n+            TupleType(::std::vector< ::std::unique_ptr<Type> > elems, location_t locus) :\n+              elems(::std::move(elems)), locus(locus) {}\n \n             // copy constructor with vector clone\n-            TupleType(TupleType const& other) {\n+            TupleType(TupleType const& other) : locus(other.locus) {\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 elems.reserve(other.elems.size());\n \n@@ -265,6 +327,7 @@ namespace Rust {\n \n             // overloaded assignment operator to clone\n             TupleType& operator=(TupleType const& other) {\n+                locus = other.locus;\n                 // crappy vector unique pointer clone - TODO is there a better way of doing this?\n                 elems.reserve(other.elems.size());\n \n@@ -281,6 +344,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual TupleType* clone_type_impl() const OVERRIDE {\n@@ -296,6 +365,8 @@ namespace Rust {\n         /* A type with no values, representing the result of computations that never complete.\n          * Expressions of NeverType can be coerced into any other types. Represented as \"!\". */\n         class NeverType : public TypeNoBounds {\n+            location_t locus;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual NeverType* clone_type_impl() const OVERRIDE {\n@@ -308,11 +379,17 @@ namespace Rust {\n             }\n \n           public:\n-            NeverType() {}\n+            NeverType(location_t locus) : locus(locus) {}\n \n             ::std::string as_string() const {\n                 return \"! (never type)\";\n             }\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         // A type consisting of a pointer without safety or liveness guarantees\n@@ -326,27 +403,32 @@ namespace Rust {\n             // TypeNoBounds type;\n             ::std::unique_ptr<TypeNoBounds> type;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether the pointer is mutable or constant.\n             inline PointerType get_pointer_type() const {\n                 return pointer_type;\n             }\n \n             // Constructor requires pointer for polymorphism reasons\n-            RawPointerType(PointerType pointer_type, TypeNoBounds* type_no_bounds) :\n-              pointer_type(pointer_type), type(type_no_bounds) {}\n+            RawPointerType(PointerType pointer_type, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n+              location_t locus) :\n+              pointer_type(pointer_type),\n+              type(::std::move(type_no_bounds)), locus(locus) {}\n \n             // Copy constructor calls custom polymorphic clone function\n             RawPointerType(RawPointerType const& other) :\n-              pointer_type(other.pointer_type), type(other.type->clone_type_no_bounds()) {}\n+              pointer_type(other.pointer_type), type(other.type->clone_type_no_bounds()),\n+              locus(other.locus) {}\n \n-            // default destructor\n-            ~RawPointerType() = default;\n+            // no destructor required?\n \n             // overload assignment operator to use custom clone method\n             RawPointerType& operator=(RawPointerType const& other) {\n                 pointer_type = other.pointer_type;\n                 type = other.type->clone_type_no_bounds();\n+                locus = other.locus;\n                 return *this;\n             }\n \n@@ -356,6 +438,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual RawPointerType* clone_type_impl() const OVERRIDE {\n@@ -378,6 +466,8 @@ namespace Rust {\n             // TypeNoBounds type;\n             ::std::unique_ptr<TypeNoBounds> type;\n \n+            location_t locus;\n+\n           public:\n             // Returns whether the reference is mutable or immutable.\n             inline bool is_mut() const {\n@@ -390,24 +480,24 @@ namespace Rust {\n             }\n \n             // Constructor\n-            ReferenceType(\n-              bool is_mut, TypeNoBounds* type_no_bounds, Lifetime lifetime = Lifetime::error()) :\n+            ReferenceType(bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n+              location_t locus, Lifetime lifetime = Lifetime::error()) :\n               lifetime(::std::move(lifetime)),\n-              has_mut(is_mut), type(type_no_bounds) {}\n+              has_mut(is_mut), type(::std::move(type_no_bounds)), locus(locus) {}\n \n             // Copy constructor with custom clone method\n             ReferenceType(ReferenceType const& other) :\n               lifetime(other.lifetime), has_mut(other.has_mut),\n-              type(other.type->clone_type_no_bounds()) {}\n+              type(other.type->clone_type_no_bounds()), locus(other.locus) {}\n \n-            // Default destructor\n-            ~ReferenceType() = default;\n+            // Destructor not required?\n \n             // Operator overload assignment operator to custom clone the unique pointer\n             ReferenceType& operator=(ReferenceType const& other) {\n                 lifetime = other.lifetime;\n                 has_mut = other.has_mut;\n                 type = other.type->clone_type_no_bounds();\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -418,6 +508,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual ReferenceType* clone_type_impl() const OVERRIDE {\n@@ -437,21 +533,27 @@ namespace Rust {\n             // Expr* size;\n             ::std::unique_ptr<Expr> size;\n \n+            location_t locus;\n+\n           public:\n             // Constructor requires pointers for polymorphism\n-            ArrayType(Type* type, Expr* array_size) : elem_type(type), size(array_size) {}\n+            ArrayType(\n+              ::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size, location_t locus) :\n+              elem_type(::std::move(type)),\n+              size(::std::move(array_size)), locus(locus) {}\n \n             // Copy constructor requires deep copies of both unique pointers\n             ArrayType(ArrayType const& other) :\n-              elem_type(other.elem_type->clone_type()), size(other.size->clone_expr()) {}\n+              elem_type(other.elem_type->clone_type()), size(other.size->clone_expr()),\n+              locus(other.locus) {}\n \n-            // default destructor\n-            ~ArrayType() = default;\n+            // destructor not required?\n \n             // Overload assignment operator to deep copy pointers\n             ArrayType& operator=(ArrayType const& other) {\n                 elem_type = other.elem_type->clone_type();\n                 size = other.size->clone_expr();\n+                locus = other.locus;\n                 return *this;\n             }\n \n@@ -461,6 +563,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n             /*~ArrayType() {\n                 delete size;\n             }*/\n@@ -481,19 +589,23 @@ namespace Rust {\n             // Type elem_type;\n             ::std::unique_ptr<Type> elem_type;\n \n+            location_t locus;\n+\n           public:\n             // Constructor requires pointer for polymorphism\n-            SliceType(Type* type) : elem_type(type) {}\n+            SliceType(::std::unique_ptr<Type> type, location_t locus) :\n+              elem_type(::std::move(type)), locus(locus) {}\n \n             // Copy constructor requires deep copy of Type smart pointer\n-            SliceType(SliceType const& other) : elem_type(other.elem_type->clone_type()) {}\n+            SliceType(SliceType const& other) :\n+              elem_type(other.elem_type->clone_type()), locus(other.locus) {}\n \n-            // default destructor\n-            ~SliceType() = default;\n+            // destructor not required?\n \n             // Overload assignment operator to deep copy\n             SliceType& operator=(SliceType const& other) {\n                 elem_type = other.elem_type->clone_type();\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -504,6 +616,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual SliceType* clone_type_impl() const OVERRIDE {\n@@ -518,6 +636,8 @@ namespace Rust {\n \n         // Type used in generic arguments to explicitly request type inference (wildcard pattern)\n         class InferredType : public TypeNoBounds {\n+            location_t locus;\n+\n             // e.g. Vec<_> = whatever\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -531,9 +651,15 @@ namespace Rust {\n             }\n \n           public:\n-            InferredType() {}\n+            InferredType(location_t locus) : locus(locus) {}\n \n             ::std::string as_string() const;\n+\n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n         };\n \n         class QualifiedPathInType; // definition moved to \"rust-path.h\"\n@@ -550,14 +676,18 @@ namespace Rust {\n             ParamKind param_kind;\n             Identifier name; // technically, can be an identifier or '_'\n \n+            location_t locus;\n+\n           public:\n-            MaybeNamedParam(Identifier name, ParamKind param_kind, Type* param_type) :\n-              param_type(param_type), param_kind(param_kind), name(::std::move(name)) {}\n+            MaybeNamedParam(Identifier name, ParamKind param_kind, ::std::unique_ptr<Type> param_type,\n+              location_t locus) :\n+              param_type(::std::move(param_type)),\n+              param_kind(param_kind), name(::std::move(name)), locus(locus) {}\n \n             // Copy constructor with clone\n             MaybeNamedParam(MaybeNamedParam const& other) :\n               param_type(other.param_type->clone_type()), param_kind(other.param_kind),\n-              name(other.name) {}\n+              name(other.name), locus(other.locus) {}\n \n             ~MaybeNamedParam() = default;\n \n@@ -566,6 +696,7 @@ namespace Rust {\n                 name = other.name;\n                 param_kind = other.param_kind;\n                 param_type = other.param_type->clone_type();\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -583,7 +714,11 @@ namespace Rust {\n \n             // Creates an error state param.\n             static MaybeNamedParam create_error() {\n-                return MaybeNamedParam(\"\", UNNAMED, NULL);\n+                return MaybeNamedParam(\"\", UNNAMED, NULL, UNKNOWN_LOCATION);\n+            }\n+\n+            location_t get_locus() const {\n+                return locus;\n             }\n         };\n \n@@ -602,6 +737,8 @@ namespace Rust {\n             // BareFunctionReturnType return_type;\n             ::std::unique_ptr<TypeNoBounds> return_type; // inlined version\n \n+            location_t locus;\n+\n           public:\n             // Whether a return type is defined with the function.\n             inline bool has_return_type() const {\n@@ -615,19 +752,18 @@ namespace Rust {\n \n             BareFunctionType(::std::vector<LifetimeParam> lifetime_params,\n               FunctionQualifiers qualifiers, ::std::vector<MaybeNamedParam> named_params,\n-              bool is_variadic, TypeNoBounds* type) :\n+              bool is_variadic, ::std::unique_ptr<TypeNoBounds> type, location_t locus) :\n               for_lifetimes(::std::move(lifetime_params)),\n               function_qualifiers(::std::move(qualifiers)), params(::std::move(named_params)),\n-              is_variadic(is_variadic), return_type(type) {}\n+              is_variadic(is_variadic), return_type(::std::move(type)), locus(locus) {}\n \n             // Copy constructor with clone\n             BareFunctionType(BareFunctionType const& other) :\n               for_lifetimes(other.for_lifetimes), function_qualifiers(other.function_qualifiers),\n               params(other.params), is_variadic(other.is_variadic),\n-              return_type(other.return_type->clone_type_no_bounds()) {}\n+              return_type(other.return_type->clone_type_no_bounds()), locus(other.locus) {}\n \n-            // default destructor\n-            ~BareFunctionType() = default;\n+            // destructor - define here if required\n \n             // Overload assignment operator to deep copy\n             BareFunctionType& operator=(BareFunctionType const& other) {\n@@ -636,6 +772,7 @@ namespace Rust {\n                 params = other.params;\n                 is_variadic = other.is_variadic;\n                 return_type = other.return_type->clone_type_no_bounds();\n+                locus = other.locus;\n \n                 return *this;\n             }\n@@ -646,6 +783,12 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n+            location_t get_locus() const {\n+                return locus;\n+            }\n+\n+            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n+\n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n             virtual BareFunctionType* clone_type_impl() const OVERRIDE {\n@@ -673,7 +816,7 @@ namespace Rust {\n          * C-like union type?\n          * function item type?\n          * closure expression types?\n-         * primitive types (bool, int, float, char, str (the slice)) \n+         * primitive types (bool, int, float, char, str (the slice))\n          * Although supposedly TypePaths are used to reference these types (including primitives) */\n \n         /* FIXME: Incomplete spec references:"}, {"sha": "55913405597efd6f43950f3aa91a87166d9f7052", "filename": "gcc/rust/test3/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fconfig-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -40,7 +40,7 @@ lang_requires_boot_languages=c++\n \n # Lists (space-separated) targets in the top level Makefile to build the runtime libraries \n # for this language, such as target-libobjc. \n-target_libs=\"\"\n+target_libs=\"target-libbacktrace\"\n \n # Space-separated list of files that should be scanned by gengtype.c to generate the garbage \n # collection tables and routines for this language. This excludes the files that are common to all "}, {"sha": "613d94f18f21e2d3b9648c1c7497cdcad9334961", "filename": "gcc/rust/test3/expand/rust-macro-expand.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,69 @@\n+#include \"rust-macro-expand.h\"\n+#include \"rust-ast-full.h\"\n+// is full really required?\n+\n+namespace Rust {\n+    void MacroExpander::expand_invoc(::std::unique_ptr<AST::MacroInvocation>& invoc) {\n+        // if current expansion depth > recursion limit, create an error (maybe fatal error) and return\n+\n+        /* switch on type of macro: \n+            - '!' syntax macro (inner switch)\n+                - procedural macro - \"A token-based function-like macro\"\n+                - 'macro_rules' (by example/pattern-match) macro? or not? \"an AST-based function-like macro\"\n+                - else is unreachable\n+            - attribute syntax macro (inner switch)\n+                - procedural macro attribute syntax - \"A token-based attribute macro\"\n+                - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+                - non-macro attribute: mark known \n+                - else is unreachable\n+            - derive macro (inner switch)\n+                - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+                - else is unreachable\n+            - derive container macro - unreachable*/\n+\n+    }\n+\n+    // Determines whether cfg predicate is true and item with attribute should not be stripped.\n+    bool check_cfg_predicate() {}\n+\n+    // Determines whether cfg predicate is true and item with attribute should not be stripped.\n+    bool check_cfg(AST::Attribute& attr) {\n+\n+    }\n+\n+    // Expands cfg_attr attributes.\n+    void expand_attrs_cfgattr(::std::vector<AST::Attribute>& attrs) {\n+        for (auto it = attrs.begin(); it != attrs.end(); ) {\n+            auto& attr = *it;\n+            if (attr.get_path() == \"cfg_attr\") {\n+                if (check_cfg(attr)) {}\n+\n+                /* do something - if feature (first token in tree) is in fact enabled, make tokens listed\n+                 * afterwards into attributes. \n+                 * i.e.: for [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add attributes\n+                 * [wow1] and [wow2] to attribute list. \n+                 * This can also be recursive, so check for expanded attributes being recursive and \n+                 * possibly recursively call the expand_attrs? */\n+            } else {\n+                ++it;\n+            }\n+        } \n+    }\n+\n+    void MacroExpander::expand_crate(AST::Crate& crate) {\n+        // fill macro/decorator map from init list? not sure where init list comes from?\n+\n+        // expand crate attributes\n+        expand_attrs_cfgattr(crate.inner_attrs);\n+\n+        // expand module attributes?\n+\n+        // expand module tree recursively\n+\n+        // post-process\n+\n+        // extract exported macros?\n+\n+\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a252a4197c23c11e9464061ced423eac059775e8", "filename": "gcc/rust/test3/expand/rust-macro-expand.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fexpand%2Frust-macro-expand.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,47 @@\n+#ifndef RUST_MACRO_EXPAND_H\n+#define RUST_MACRO_EXPAND_H\n+\n+#include \"rust-ast.h\"\n+\n+// Provides objects and method prototypes for macro expansion\n+\n+namespace Rust {\n+    // forward decls for AST\n+    namespace AST {\n+        class MacroInvocation;\n+    }\n+\n+    // Object used to store configuration data for macro expansion.\n+    struct ExpansionCfg {\n+        // features?\n+        unsigned int recursion_limit; // TODO: determine default recursion limit\n+        // trace macros?\n+        // should test?\n+        // more default stuff?\n+    };\n+\n+    // Object used to store shared data (between functions) for macro expansion.\n+    struct MacroExpander {\n+        ExpansionCfg cfg;\n+        unsigned int expansion_depth = 0;\n+\n+        MacroExpander(AST::Crate& crate, ExpansionCfg cfg) : cfg(cfg), crate(crate) {}\n+\n+        ~MacroExpander() = default;\n+\n+        // Expands all macros in the crate passed in.\n+        void expand_crate(AST::Crate& crate);\n+\n+        /* Expands a macro invocation (not macro invocation semi) - possibly make both have similar \n+         * duck-typed interface and use templates?*/\n+        // should this be public or private?\n+        void expand_invoc(::std::unique_ptr<AST::MacroInvocation>& invoc);\n+\n+        // TODO: make it extend ASTVisitor so that individual items can be accessed properly?\n+\n+      private:\n+        AST::Crate& crate;\n+    };\n+}\n+\n+#endif\n\\ No newline at end of file"}, {"sha": "4757dfbba2df0c21efc5e52e36b73ba6debe396f", "filename": "gcc/rust/test3/lang.opt", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flang.opt?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,46 @@\n+; Options for the Rust front end.\n+; Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013\n+; Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+; Describes command-line options used by this frontend\n+\n+Language\n+Rust\n+\n+I\n+Rust Joined Separate\n+; Documented in c.opt\n+\n+L\n+Rust Joined Separate\n+; Not documented\n+\n+frust-dump-\n+Rust Joined RejectNegative\n+-frust-dump-<type>\tDump Rust frontend internal information.\n+\n+o\n+Rust Joined Separate\n+; Documented in common.opt\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "5a7b0cb402d35166c2aca0a46571683000f047c7", "filename": "gcc/rust/test3/lex/rust-lex.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -134,6 +134,10 @@ namespace Rust {\n         skip_token(0);\n     }\n \n+    void Lexer::replace_current_token(TokenPtr replacement) {\n+        token_queue.replace_current_value(replacement);\n+    }\n+\n     /* shitty anonymous namespace that can only be accessed inside the compilation unit - used for\n      * classify_keyword\n      * Binary search in sorted array of keywords created with x-macros. */"}, {"sha": "b16cfeb6dec5e2bef2258e7b6a053f8614ccef74", "filename": "gcc/rust/test3/lex/rust-lex.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -60,6 +60,9 @@ namespace Rust {\n         // Skips the current token.\n         void skip_token();\n \n+        // Replaces the current token with a specified token.\n+        void replace_current_token(TokenPtr replacement);\n+\n       private:\n         // File for use as input.\n         FILE* input;"}, {"sha": "1eac8a17696cf455a109e1fbe3808e1610e2df35", "filename": "gcc/rust/test3/parse/rust-parse.cc", "status": "modified", "additions": 3564, "deletions": 1461, "changes": 5025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "94d1eabbd8cda31ad781f0ad8fb5fe07e90620d4", "filename": "gcc/rust/test3/parse/rust-parse.h", "status": "modified", "additions": 322, "deletions": 180, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -10,17 +10,73 @@\n #include \"rust-ast-full.h\"\n \n namespace Rust {\n+    /* HACK: used to resolve the expression-or-statement problem at the end of a block by allowing\n+     * either to be returned (technically). Tagged union would probably take up the same amount of\n+     * space. */\n+    struct ExprOrStmt {\n+        ::std::unique_ptr<AST::ExprWithoutBlock> expr;\n+        ::std::unique_ptr<AST::Stmt> stmt;\n+\n+        /* I was going to resist the urge to make this a real class and make it POD, but construction\n+         * in steps is too difficult. So it'll just also have a constructor. */\n+\n+        // expression constructor\n+        ExprOrStmt(::std::unique_ptr<AST::ExprWithoutBlock> expr) : expr(::std::move(expr)) {}\n+\n+        // statement constructor\n+        ExprOrStmt(::std::unique_ptr<AST::Stmt> stmt) : stmt(::std::move(stmt)) {}\n+\n+        // Returns whether this object is in an error state.\n+        inline bool is_error() const {\n+            return (expr == NULL && stmt == NULL) || (expr != NULL && stmt != NULL);\n+        }\n+\n+        // Returns an error state object.\n+        static ExprOrStmt create_error() {\n+            return ExprOrStmt(NULL, NULL);\n+        }\n+\n+        ~ExprOrStmt() = default;\n+\n+        // no copy constructors/assignment copy as simple object like this shouldn't require it\n+\n+        // move constructors\n+        ExprOrStmt(ExprOrStmt&& other) = default;\n+        ExprOrStmt& operator=(ExprOrStmt&& other) = default;\n+\n+      private:\n+        // private constructor only used for creating error state expr or stmt objects\n+        ExprOrStmt(AST::ExprWithoutBlock* expr, AST::Stmt* stmt) : expr(expr), stmt(stmt) {}\n+\n+        // make this work: have a disambiguation specifically for known statements (i.e. ';' and\n+        // 'let'). then, have a special \"parse expr or stmt\" function that returns this type. inside\n+        // it, it parses an expression, and then determines whether to return expr or stmt via whether\n+        // the next token is a semicolon. should be able to disambiguate inside that function between\n+        // stmts with blocks and without blocks.\n+    };\n+\n+    /* Restrictions on parsing used to signal that certain ambiguous grammar features should be parsed\n+     * in a certain way.*/\n+    struct ParseRestrictions {\n+        bool can_be_struct_expr = true;\n+        /* Whether the expression was entered from a unary expression - prevents stuff like struct\n+         * exprs being parsed from a dereference. */\n+        bool entered_from_unary = false;\n+    };\n+\n     // Parser implementation for gccrs.\n     class Parser {\n       private:\n         void skip_after_semicolon();\n         void skip_after_end();\n         void skip_after_end_block();\n+        void skip_after_next_block();\n         void skip_after_end_attribute();\n \n         bool skip_token(TokenId t);\n         const_TokenPtr expect_token(TokenId t);\n         void unexpected_token(const_TokenPtr t);\n+        bool skip_generics_right_angle();\n \n         // expression parsing\n         int left_binding_power(const_TokenPtr tok);\n@@ -63,279 +119,362 @@ namespace Rust {\n         void parse_statement_seq(bool (Parser::*done)());\n \n         // AST-related stuff - maybe move or something?\n-        AST::Crate parse_crate();\n         ::std::vector<AST::Attribute> parse_inner_attributes();\n         AST::Attribute parse_inner_attribute();\n         ::std::vector<AST::Attribute> parse_outer_attributes();\n         AST::Attribute parse_outer_attribute();\n         AST::Attribute parse_attribute_body();\n-        AST::AttrInput* parse_attr_input();\n+        ::std::unique_ptr<AST::AttrInput> parse_attr_input();\n \n         // Path-related\n         AST::SimplePath parse_simple_path();\n         AST::SimplePathSegment parse_simple_path_segment();\n         AST::TypePath parse_type_path();\n-        AST::TypePathSegment* parse_type_path_segment();\n+        ::std::unique_ptr<AST::TypePathSegment> parse_type_path_segment();\n         AST::PathIdentSegment parse_path_ident_segment();\n         AST::GenericArgs parse_path_generic_args();\n         AST::GenericArgsBinding parse_generic_args_binding();\n         AST::TypePathFunction parse_type_path_function();\n         AST::PathInExpression parse_path_in_expression();\n         AST::PathExprSegment parse_path_expr_segment();\n-        AST::QualifiedPathInExpression parse_qualified_path_in_expression();\n-        AST::QualifiedPathType parse_qualified_path_type();\n+        AST::QualifiedPathInExpression parse_qualified_path_in_expression(bool pratt_parse = false);\n+        AST::QualifiedPathType parse_qualified_path_type(bool pratt_parse = false);\n         AST::QualifiedPathInType parse_qualified_path_in_type();\n \n         // Token tree or macro related\n         AST::DelimTokenTree parse_delim_token_tree();\n-        AST::TokenTree* parse_token_tree();\n-        AST::MacroRulesDefinition* parse_macro_rules_def(::std::vector<AST::Attribute> outer_attrs);\n-        AST::MacroInvocationSemi* parse_macro_invocation_semi(\n+        ::std::unique_ptr<AST::TokenTree> parse_token_tree();\n+        ::std::unique_ptr<AST::MacroRulesDefinition> parse_macro_rules_def(\n+          ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::MacroInvocationSemi> parse_macro_invocation_semi(\n+          ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::MacroInvocation> parse_macro_invocation(\n           ::std::vector<AST::Attribute> outer_attrs);\n-        AST::MacroInvocation* parse_macro_invocation(::std::vector<AST::Attribute> outer_attrs);\n         AST::MacroRule parse_macro_rule();\n         AST::MacroMatcher parse_macro_matcher();\n-        AST::MacroMatch* parse_macro_match();\n-        AST::MacroMatchFragment* parse_macro_match_fragment();\n-        AST::MacroMatchRepetition* parse_macro_match_repetition();\n+        ::std::unique_ptr<AST::MacroMatch> parse_macro_match();\n+        ::std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment();\n+        ::std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition();\n \n         // Top-level item-related\n         ::std::vector< ::std::unique_ptr<AST::Item> > parse_items();\n-        AST::Item* parse_item(bool called_from_statement);\n-        AST::VisItem* parse_vis_item(::std::vector<AST::Attribute> outer_attrs);\n-        AST::MacroItem* parse_macro_item(::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::Item> parse_item(bool called_from_statement);\n+        ::std::unique_ptr<AST::VisItem> parse_vis_item(::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::MacroItem> parse_macro_item(::std::vector<AST::Attribute> outer_attrs);\n         AST::Visibility parse_visibility();\n \n         // VisItem subclass-related\n-        AST::Module* parse_module(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExternCrate* parse_extern_crate(\n+        ::std::unique_ptr<AST::Module> parse_module(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::ExternCrate> parse_extern_crate(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::UseDeclaration* parse_use_decl(\n+        ::std::unique_ptr<AST::UseDeclaration> parse_use_decl(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::UseTree> parse_use_tree();\n+        ::std::unique_ptr<AST::Function> parse_function(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::UseTree* parse_use_tree();\n-        AST::Function* parse_function(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n         AST::FunctionQualifiers parse_function_qualifiers();\n         ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params_in_angles();\n         ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params();\n         ::std::vector< ::std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params();\n         ::std::vector<AST::LifetimeParam> parse_lifetime_params_objs();\n         AST::LifetimeParam parse_lifetime_param();\n         ::std::vector< ::std::unique_ptr<AST::TypeParam> > parse_type_params();\n-        AST::TypeParam* parse_type_param();\n+        ::std::unique_ptr<AST::TypeParam> parse_type_param();\n         ::std::vector<AST::FunctionParam> parse_function_params();\n         AST::FunctionParam parse_function_param();\n-        AST::Type* parse_function_return_type();\n+        ::std::unique_ptr<AST::Type> parse_function_return_type();\n         AST::WhereClause parse_where_clause();\n-        AST::WhereClauseItem* parse_where_clause_item();\n-        AST::LifetimeWhereClauseItem* parse_lifetime_where_clause_item();\n-        AST::TypeBoundWhereClauseItem* parse_type_bound_where_clause_item();\n+        ::std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item();\n+        ::std::unique_ptr<AST::LifetimeWhereClauseItem> parse_lifetime_where_clause_item();\n+        ::std::unique_ptr<AST::TypeBoundWhereClauseItem> parse_type_bound_where_clause_item();\n         ::std::vector<AST::LifetimeParam> parse_for_lifetimes();\n         ::std::vector< ::std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds();\n-        AST::TypeParamBound* parse_type_param_bound();\n-        AST::TraitBound* parse_trait_bound();\n+        ::std::unique_ptr<AST::TypeParamBound> parse_type_param_bound();\n+        ::std::unique_ptr<AST::TraitBound> parse_trait_bound();\n         ::std::vector<AST::Lifetime> parse_lifetime_bounds();\n         AST::Lifetime parse_lifetime();\n-        AST::TypeAlias* parse_type_alias(\n+        ::std::unique_ptr<AST::TypeAlias> parse_type_alias(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::Struct> parse_struct(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::Struct* parse_struct(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n         ::std::vector<AST::StructField> parse_struct_fields();\n         AST::StructField parse_struct_field();\n         ::std::vector<AST::TupleField> parse_tuple_fields();\n         AST::TupleField parse_tuple_field();\n-        AST::Enum* parse_enum(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::Enum> parse_enum(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n         ::std::vector< ::std::unique_ptr<AST::EnumItem> > parse_enum_items();\n-        AST::EnumItem* parse_enum_item();\n-        AST::Union* parse_union(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ConstantItem* parse_const_item(\n+        ::std::unique_ptr<AST::EnumItem> parse_enum_item();\n+        ::std::unique_ptr<AST::Union> parse_union(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::StaticItem* parse_static_item(\n+        ::std::unique_ptr<AST::ConstantItem> parse_const_item(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::Trait* parse_trait(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::TraitItem* parse_trait_item();\n-        AST::TraitItemType* parse_trait_type(::std::vector<AST::Attribute> outer_attrs);\n-        AST::TraitItemConst* parse_trait_const(::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::StaticItem> parse_static_item(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::Trait> parse_trait(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::TraitItem> parse_trait_item();\n+        ::std::unique_ptr<AST::TraitItemType> parse_trait_type(\n+          ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::TraitItemConst> parse_trait_const(\n+          ::std::vector<AST::Attribute> outer_attrs);\n         AST::SelfParam parse_self_param();\n-        AST::Impl* parse_impl(AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::InherentImplItem* parse_inherent_impl_item();\n-        AST::InherentImplItem* parse_inherent_impl_function_or_method(\n+        ::std::unique_ptr<AST::Impl> parse_impl(\n+          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item();\n+        ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_function_or_method(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::TraitImplItem* parse_trait_impl_item();\n-        AST::TraitImplItem* parse_trait_impl_function_or_method(\n+        ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item();\n+        ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExternBlock* parse_extern_block(\n+        ::std::unique_ptr<AST::ExternBlock> parse_extern_block(\n           AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExternalItem* parse_external_item();\n+        ::std::unique_ptr<AST::ExternalItem> parse_external_item();\n         AST::NamedFunctionParam parse_named_function_param();\n         AST::Method parse_method();\n \n         // Expression-related (Pratt parsed)\n-        AST::Expr* parse_expr(::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::Expr* parse_expr(int right_binding_power, ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::Expr* null_denotation_NEW(const_TokenPtr t, ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::Expr* left_denotation(const_TokenPtr t, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ArithmeticOrLogicalExpr* parse_binary_plus_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_binary_minus_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_binary_mult_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_binary_div_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_binary_mod_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_bitwise_and_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_bitwise_or_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_bitwise_xor_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_left_shift_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArithmeticOrLogicalExpr* parse_right_shift_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_equal_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_not_equal_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_greater_than_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_less_than_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_greater_equal_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ComparisonExpr* parse_binary_less_equal_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::LazyBooleanExpr* parse_lazy_or_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::LazyBooleanExpr* parse_lazy_and_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::TypeCastExpr* parse_type_cast_expr(\n-          const_TokenPtr tok, AST::Expr* expr_to_cast, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::AssignmentExpr* parse_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_plus_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_minus_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_mult_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_div_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_mod_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_and_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_or_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_xor_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_left_shift_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CompoundAssignmentExpr* parse_right_shift_assig_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::AwaitExpr* parse_await_expr(\n-          const_TokenPtr tok, AST::Expr* expr_to_await, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::MethodCallExpr* parse_method_call_expr(\n-          const_TokenPtr tok, AST::Expr* receiver_expr, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::CallExpr* parse_function_call_expr(\n-          const_TokenPtr tok, AST::Expr* function_expr, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::RangeExpr* parse_led_range_exclusive_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::RangeExpr* parse_nud_range_exclusive_expr(\n+        ::std::unique_ptr<AST::Expr> parse_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::Expr> parse_expr(int right_binding_power,\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::Expr> null_denotation_NEW(const_TokenPtr t,\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::Expr> left_denotation(const_TokenPtr t,\n+          ::std::unique_ptr<AST::Expr> left,\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_plus_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_mult_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_div_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_mod_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_and_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_or_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_xor_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_left_shift_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_right_shift_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::LazyBooleanExpr> parse_lazy_or_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::LazyBooleanExpr> parse_lazy_and_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::TypeCastExpr> parse_type_cast_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> expr_to_cast, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::AssignmentExpr> parse_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_plus_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_minus_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_mult_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_div_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_mod_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_and_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_or_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_xor_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr(\n+          const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+          ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::AwaitExpr> parse_await_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> expr_to_await, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> receiver_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::CallExpr> parse_function_call_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> function_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::RangeExpr> parse_nud_range_exclusive_expr(\n           const_TokenPtr tok, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::RangeFromToInclExpr* parse_range_inclusive_expr(\n-          const_TokenPtr tok, AST::Expr* left, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::RangeToInclExpr* parse_range_to_inclusive_expr(\n+        ::std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::RangeToInclExpr> parse_range_to_inclusive_expr(\n           const_TokenPtr tok, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::TupleIndexExpr* parse_tuple_index_expr(\n-          const_TokenPtr tok, AST::Expr* tuple_expr, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::FieldAccessExpr* parse_field_access_expr(\n-          const_TokenPtr tok, AST::Expr* struct_expr, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::ArrayIndexExpr* parse_index_expr(\n-          const_TokenPtr tok, AST::Expr* array_expr, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> tuple_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> struct_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::ArrayIndexExpr> parse_index_expr(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> array_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n+        ::std::unique_ptr<AST::MacroInvocation> parse_macro_invocation_partial(\n+          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::StructExprStruct> parse_struct_expr_struct_partial(\n+          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::StructExprTuple> parse_struct_expr_tuple_partial(\n+          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n+        AST::PathInExpression parse_path_in_expression_pratt(const_TokenPtr tok);\n+        ::std::unique_ptr<AST::ClosureExpr> parse_closure_expr_pratt(const_TokenPtr tok,\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n+        ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float(const_TokenPtr tok,\n+          ::std::unique_ptr<AST::Expr> tuple_expr, ::std::vector<AST::Attribute> outer_attrs,\n+          ParseRestrictions restrictions = ParseRestrictions());\n \n         // Expression-related (non-Pratt parsed)\n-        AST::ExprWithoutBlock* parse_expr_without_block(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::BlockExpr* parse_block_expr(\n+        ::std::unique_ptr<AST::ExprWithoutBlock> parse_expr_without_block(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::IfExpr* parse_if_expr(\n+        ::std::unique_ptr<AST::BlockExpr> parse_block_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::IfExpr> parse_if_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::IfLetExpr* parse_if_let_expr(\n+        ::std::unique_ptr<AST::IfLetExpr> parse_if_let_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::LoopExpr* parse_loop_expr(\n+        ::std::unique_ptr<AST::LoopExpr> parse_loop_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n           AST::LoopLabel label = AST::LoopLabel::error());\n-        AST::WhileLoopExpr* parse_while_loop_expr(\n+        ::std::unique_ptr<AST::WhileLoopExpr> parse_while_loop_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n           AST::LoopLabel label = AST::LoopLabel::error());\n-        AST::WhileLetLoopExpr* parse_while_let_loop_expr(\n+        ::std::unique_ptr<AST::WhileLetLoopExpr> parse_while_let_loop_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n           AST::LoopLabel label = AST::LoopLabel::error());\n-        AST::ForLoopExpr* parse_for_loop_expr(\n+        ::std::unique_ptr<AST::ForLoopExpr> parse_for_loop_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n           AST::LoopLabel label = AST::LoopLabel::error());\n-        AST::MatchExpr* parse_match_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n+        ::std::unique_ptr<AST::MatchExpr> parse_match_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n         AST::MatchArm parse_match_arm();\n-        ::std::vector< ::std::unique_ptr<AST::Pattern> > parse_match_arm_patterns();\n-        AST::BaseLoopExpr* parse_labelled_loop_expr(\n+        ::std::vector< ::std::unique_ptr<AST::Pattern> > parse_match_arm_patterns(\n+          TokenId end_token_id);\n+        ::std::unique_ptr<AST::BaseLoopExpr> parse_labelled_loop_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n         AST::LoopLabel parse_loop_label();\n-        AST::AsyncBlockExpr* parse_async_block_expr(\n+        ::std::unique_ptr<AST::AsyncBlockExpr> parse_async_block_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::UnsafeBlockExpr* parse_unsafe_block_expr(\n+        ::std::unique_ptr<AST::UnsafeBlockExpr> parse_unsafe_block_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::GroupedExpr* parse_grouped_expr(\n+        ::std::unique_ptr<AST::GroupedExpr> parse_grouped_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ClosureExpr* parse_closure_expr(\n+        ::std::unique_ptr<AST::ClosureExpr> parse_closure_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n         AST::ClosureParam parse_closure_param();\n-        AST::LiteralExpr* parse_literal_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ReturnExpr* parse_return_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(), bool pratt_parse = false);\n-        AST::BreakExpr* parse_break_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(), bool pratt_parse = false);\n-        AST::ContinueExpr* parse_continue_expr(\n+        ::std::unique_ptr<AST::LiteralExpr> parse_literal_expr(\n           ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ArrayExpr* parse_array_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ExprWithoutBlock* parse_grouped_or_tuple_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(), bool pratt_parse = false);\n+        ::std::unique_ptr<AST::ReturnExpr> parse_return_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::BreakExpr> parse_break_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::ContinueExpr> parse_continue_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::ArrayExpr> parse_array_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::ExprWithoutBlock> parse_grouped_or_tuple_expr(\n+          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n+          bool pratt_parse = false);\n+        ::std::unique_ptr<AST::StructExprField> parse_struct_expr_field();\n \n         // Type-related\n-        AST::Type* parse_type();\n-        AST::TypeNoBounds* parse_type_no_bounds();\n-        AST::TypeNoBounds* parse_slice_or_array_type();\n-        AST::RawPointerType* parse_raw_pointer_type();\n-        AST::ReferenceType* parse_reference_type();\n-        AST::BareFunctionType* parse_bare_function_type(::std::vector<AST::LifetimeParam> for_lifetimes);\n-        AST::Type* parse_paren_prefixed_type();\n-        AST::TypeNoBounds* parse_paren_prefixed_type_no_bounds();\n-        AST::Type* parse_for_prefixed_type();\n+        ::std::unique_ptr<AST::Type> parse_type();\n+        ::std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds();\n+        ::std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type();\n+        ::std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type();\n+        ::std::unique_ptr<AST::ReferenceType> parse_reference_type();\n+        ::std::unique_ptr<AST::BareFunctionType> parse_bare_function_type(\n+          ::std::vector<AST::LifetimeParam> for_lifetimes);\n+        ::std::unique_ptr<AST::Type> parse_paren_prefixed_type();\n+        ::std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds();\n+        ::std::unique_ptr<AST::Type> parse_for_prefixed_type();\n         AST::MaybeNamedParam parse_maybe_named_param();\n \n         // Statement-related\n-        AST::Stmt* parse_stmt();\n-        AST::LetStmt* parse_let_stmt(::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExprStmt* parse_expr_stmt(::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExprStmtWithBlock* parse_expr_stmt_with_block(::std::vector<AST::Attribute> outer_attrs);\n-        AST::ExprStmtWithoutBlock* parse_expr_stmt_without_block(\n+        ::std::unique_ptr<AST::Stmt> parse_stmt();\n+        ::std::unique_ptr<AST::LetStmt> parse_let_stmt(::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::ExprStmt> parse_expr_stmt(::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::ExprStmtWithBlock> parse_expr_stmt_with_block(\n           ::std::vector<AST::Attribute> outer_attrs);\n+        ::std::unique_ptr<AST::ExprStmtWithoutBlock> parse_expr_stmt_without_block(\n+          ::std::vector<AST::Attribute> outer_attrs);\n+        ExprOrStmt parse_stmt_or_expr_without_block();\n+        ExprOrStmt parse_macro_invocation_maybe_semi(::std::vector<AST::Attribute> outer_attrs);\n+        ExprOrStmt parse_path_based_stmt_or_expr(::std::vector<AST::Attribute> outer_attrs);\n \n         // Pattern-related\n-        AST::Pattern* parse_pattern();\n-        AST::Pattern* parse_literal_or_range_pattern();\n-        AST::RangePatternBound* parse_range_pattern_bound();\n-        AST::ReferencePattern* parse_reference_pattern();\n-        AST::Pattern* parse_grouped_or_tuple_pattern();\n-        AST::SlicePattern* parse_slice_pattern();\n-        AST::IdentifierPattern* parse_identifier_pattern();\n-        AST::Pattern* parse_ident_leading_pattern();\n-        AST::TupleStructItems* parse_tuple_struct_items();\n+        ::std::unique_ptr<AST::Pattern> parse_pattern();\n+        ::std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern();\n+        ::std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound();\n+        ::std::unique_ptr<AST::ReferencePattern> parse_reference_pattern();\n+        ::std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern();\n+        ::std::unique_ptr<AST::SlicePattern> parse_slice_pattern();\n+        ::std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern();\n+        ::std::unique_ptr<AST::Pattern> parse_ident_leading_pattern();\n+        ::std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items();\n         AST::StructPatternElements parse_struct_pattern_elems();\n-        AST::StructPatternField* parse_struct_pattern_field();\n+        ::std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field();\n \n         // void parse_crate();\n         // AST::Module parse_module();\n@@ -353,9 +492,12 @@ namespace Rust {\n         // Construct parser with specified lexer reference.\n         Parser(Lexer& parLexer) : lexer(parLexer), printf_fn(), puts_fn(), scanf_fn() {}\n \n-        // Main entry point for parser.\n+        // (old) Main entry point for parser.\n         void parse_program();\n \n+        // Main entry point for parser.\n+        AST::Crate parse_crate();\n+\n         Tree parse_statement();\n \n         Tree parse_variable_declaration();"}, {"sha": "8f16e6c052eed185896f73fdb96a3f6dc286e7c5", "filename": "gcc/rust/test3/rsspec.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frsspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -16,16 +16,18 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* #include \"config.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n #include \"coretypes.h\"\n-#include \"gcc.h\"\n+//#include \"gcc.h\"\n #include \"opts.h\"\n-#include \"system.h\"\n \n-#include \"intl.h\"\n #include \"tm.h\"\n+//#include \"intl.h\"\n \n-#ifndef MATH_LIBRARY\n+// are gcc and intl includes required?\n+\n+/*#ifndef MATH_LIBRARY\n #define MATH_LIBRARY \"m\"\n #endif\n \n@@ -117,8 +119,10 @@ static struct cl_decoded_option* grs_new_decoded_options;*/\n // Presumably this is the \"compiler driver\", which runs the compiler\n // Handle calling the compiler (i.e. options, libraries to use)\n // Used to change flags before passing them to the driver\n-void lang_specific_driver(struct cl_decoded_option** /* in_decoded_options*/,\n-  unsigned int* /* in_decoded_options_count*/, int* /* in_added_libraries*/) {\n+void lang_specific_driver(struct cl_decoded_option** in_decoded_options ATTRIBUTE_UNUSED,\n+  unsigned int* in_decoded_options_count ATTRIBUTE_UNUSED, int* in_added_libraries ATTRIBUTE_UNUSED) {\n+      // as of now, no options need changing, but they may in the future\n+\n     /* unsigned int i = 0;\n     unsigned int argc = *in_decoded_options_count;                   // argument list count\n     struct cl_decoded_option* decoded_options = *in_decoded_options; // argument list"}, {"sha": "ac0ea1ac0025d6a44154911cd3b85db00f3186b6", "filename": "gcc/rust/test3/rust-buffered-queue.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -103,6 +103,16 @@ namespace Rust {\n             end++;\n         }\n \n+        // Replaces the current value in the buffer. Total HACK.\n+        void replace_current_value(T replacement) {\n+            // call peek to ensure value exists\n+            peek(0);\n+\n+            buffer[start] = replacement;\n+\n+            // don't move start or end\n+        }\n+\n       private:\n         // Source of tokens for queue.\n         Source& source;"}, {"sha": "5c4787877bd22e6e141c375019671542efb5d9d7", "filename": "gcc/rust/test3/rust-lang.cc", "status": "modified", "additions": 120, "deletions": 73, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-lang.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -16,23 +16,28 @@\n #include \"common/common-target.h\"\n // note: header files must be in this order or else forward declarations don't work properly. Kinda\n // dumb system, but have to live with it. clang-format seems to mess it up\n-/* Order: config, system, coretypes, target, tree, gimple-expr, diagnostic, opts, fold-const, \n+/* Order: config, system, coretypes, target, tree, gimple-expr, diagnostic, opts, fold-const,\n  * gimplify, stor-layout, debug, convert, langhooks, langhooks-def, common-target */\n \n+// FIXME: test saving intellisense\n+#include \"options.h\"\n+\n // version check to stop compiling if c++ isn't c++11 or higher\n #if __cplusplus < 201103\n-# error \"GCC Rust frontend requires C++11 or higher. You can compile the g++ frontend first and then compile the Rust frontend using that.\"\n+#error \\\n+  \"GCC Rust frontend requires C++11 or higher. You can compile the g++ frontend first and then compile the Rust frontend using that.\"\n #endif\n // TODO: is this best way to do it? Is it allowed? (should be)\n \n /* General TODOs:\n- *  - maybe convert all raw pointer-returning/passing functions that conceptually return a unique \n+ *  - maybe convert all raw pointer-returning/passing functions that conceptually return a unique\n  *    pointer actually return a unique pointer. i.e. parse methods and constructors for AST objects.\n- *    make_unique should probably be avoided to keep C++11 compatibility. \n+ *    make_unique should probably be avoided to keep C++11 compatibility.\n  *  - convert all copies of expensive-to-copy (deep copy) AST objects into moves, if possible. Don't\n  *    remove clone functionality - it may be required for e.g. HIR conversion. */\n \n #include \"rust-parse.h\"\n+#include \"rust-session-manager.h\"\n \n // Language-dependent contents of a type. GTY() mark used for garbage collector.\n struct GTY(()) lang_type {\n@@ -63,11 +68,15 @@ struct GTY(()) language_function {\n     int dummy;\n };\n \n+// Kinda HACK-ish - store parsing session as static variable\n+static Rust::Session session;\n+\n /* Language hooks.  */\n \n /* Initial lang hook called (possibly), used for initialisation.\n  * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2, and\n- * build_common_builtin_nodes, as well as set global variable void_list_node. */\n+ * build_common_builtin_nodes, as well as set global variable void_list_node. \n+ * Apparently called after option handling? */\n static bool grs_langhook_init(void) {\n     /* Something to do with this:\n      This allows the code in d-builtins.cc to not have to worry about\n@@ -86,61 +95,24 @@ static bool grs_langhook_init(void) {\n     // using_eh_for_cleanups();\n \n     // rdot_init();\n-    return true;\n-}\n \n-// Parses a single file with filename filename.\n-static void grs_parse_file(const char* filename) {\n-    FILE* file = fopen(filename, \"r\");\n+    // initialise compiler session\n+    session.init();\n \n-    if (file == NULL) {\n-        fatal_error(UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n-    }\n-\n-    // parse file here\n-    // create lexer and parser\n-    Rust::Lexer lex(filename, file);\n-    Rust::Parser parser(lex);\n-\n-    //parser.parse_program();\n     \n-    // lexer debug\n-    //parser.debug_dump_lex_output();\n-\n-    // parser debug\n-    parser.debug_dump_ast_output();\n-\n-    // semantic analyser debug\n \n-    /* Rust::const_TokenPtr tok = lex.peek_token();\n-    // do shit until EOF\n-    while (true) {\n-        bool has_text = tok->get_id() == Rust::IDENTIFIER || tok->get_id() == Rust::INT_LITERAL\n-                        || tok->get_id() == Rust::FLOAT_LITERAL\n-                        || tok->get_id() == Rust::STRING_LITERAL;\n-\n-        location_t loc = tok->get_locus();\n-\n-        fprintf(stderr, \"<id=%s%s, %s, line=%d, col=%d>\\n\", tok->token_id_to_str(),\n-          has_text ? (std::string(\", text=\") + tok->get_str()).c_str() : \"\", LOCATION_FILE(loc),\n-          LOCATION_LINE(loc), LOCATION_COLUMN(loc));\n-\n-        if (tok->get_id() == Rust::END_OF_FILE)\n-            break;\n-\n-        lex.skip_token();\n-        tok = lex.peek_token();\n-    }*/\n+    return true;\n+}\n \n-    fclose(file);\n+/* The option mask (something to do with options for specific frontends or something). */\n+static unsigned int grs_langhook_option_lang_mask(void) {\n+    return CL_Rust;\n }\n \n-/* Actual main entry point for front-end. Called by langhook to parse files.\n- * May move to a different compilation unit if frontend gets too big. */\n-static void grs_parse_files(int num_files, const char** files) {\n-    for (int i = 0; i < num_files; i++) {\n-        grs_parse_file(files[i]);\n-    }\n+/* Initialize the options structure. */\n+static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n+    // nothing yet - used by frontends to change specific options for the language\n+    session.init_options();\n }\n \n /* Main entry point for front-end, apparently. Finds input file names in global vars in_fnames and\n@@ -151,26 +123,30 @@ static void grs_parse_files(int num_files, const char** files) {\n static void grs_langhook_parse_file(void) {\n     fprintf(stderr, \"Preparing to parse files. \\n\");\n \n-    grs_parse_files(num_in_fnames, in_fnames);\n+    // grs_parse_files(num_in_fnames, in_fnames);\n+    session.parse_files(num_in_fnames, in_fnames);\n }\n \n+/* Seems to get the exact type for a specific type - e.g. for scalar float with 32-bit bitsize, it\n+ * returns float, and for 64-bit bitsize, it returns double. Used to map RTL nodes to machine modes or\n+ * something like that. */\n static tree grs_langhook_type_for_mode(machine_mode mode, int unsignedp) {\n+    // TODO: change all this later to match rustc types\n     if (mode == TYPE_MODE(float_type_node))\n         return float_type_node;\n \n     if (mode == TYPE_MODE(double_type_node))\n         return double_type_node;\n \n-    // don't know what this means but assume it has something to do with weird precisions\n-    if (mode == TYPE_MODE(intQI_type_node)) // quarter precision?\n+    if (mode == TYPE_MODE(intQI_type_node)) // quarter integer mode - single byte treated as integer\n         return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n-    if (mode == TYPE_MODE(intHI_type_node)) // half precision?\n+    if (mode == TYPE_MODE(intHI_type_node)) // half integer mode - two-byte integer\n         return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-    if (mode == TYPE_MODE(intSI_type_node)) // single precision?\n+    if (mode == TYPE_MODE(intSI_type_node)) // single integer mode - four-byte integer\n         return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-    if (mode == TYPE_MODE(intDI_type_node)) // double precision?\n+    if (mode == TYPE_MODE(intDI_type_node)) // double integer mode - eight-byte integer\n         return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-    if (mode == TYPE_MODE(intTI_type_node)) // triple precision?\n+    if (mode == TYPE_MODE(intTI_type_node)) // tetra integer mode - 16-byte integer\n         return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n \n     if (mode == TYPE_MODE(integer_type_node))\n@@ -196,34 +172,105 @@ static tree grs_langhook_type_for_mode(machine_mode mode, int unsignedp) {\n     return NULL;\n }\n \n+/* This appears to be used for creating different types for different bit sizes (e.g. int and long).\n+ * Also, the Go frontend calls this from type_for_mode to determine the type from a specific bitsize\n+ * for integer types.\n+ * FIXME: change this when working on AST-GENERIC conversion to allow the full range of Rust type\n+ * sizes. */\n static tree grs_langhook_type_for_size(\n   unsigned int bits ATTRIBUTE_UNUSED, int unsignedp ATTRIBUTE_UNUSED) {\n     gcc_unreachable();\n     return NULL_TREE;\n+    // nothing at the moment, but change later\n }\n \n-// Record a builtin function.  We just ignore builtin functions.\n+// Record a builtin function. We just ignore builtin functions.\n static tree grs_langhook_builtin_function(tree decl ATTRIBUTE_UNUSED) {\n     return decl;\n }\n \n+/* Return true if we are in the global binding level (which is never, apparently). */\n static bool grs_langhook_global_bindings_p(void) {\n     // return current_function_decl == NULL_TREE;\n-    //gcc_unreachable();\n-    //return true;\n+    // gcc_unreachable();\n+    // return true;\n     return false;\n }\n \n+/* Push a declaration into the current binding level.  We can't\n+   usefully implement this since we don't want to convert from tree\n+   back to one of our internal data structures.  I think the only way\n+   this is used is to record a decl which is to be returned by\n+   getdecls, and we could implement it for that purpose if\n+   necessary.  */\n static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n     gcc_unreachable();\n     return NULL;\n }\n \n+/* This hook is used to get the current list of declarations as trees.\n+   We don't support that; instead we use the write_globals hook.  This\n+   can't simply crash because it is called by -gstabs.  */\n static tree grs_langhook_getdecls(void) {\n     // gcc_unreachable();\n     return NULL;\n }\n \n+// Handle Rust-specific options. Return false if nothing happened.\n+static bool grs_langhook_handle_option(size_t scode, const char* arg, HOST_WIDE_INT value,\n+  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n+    // Convert integer code to lang.opt enum codes with names.\n+    enum opt_code code = (enum opt_code)scode;\n+    // used to store whether results of various stuff are successful\n+    // bool ret = true;\n+\n+    // delegate to session manager\n+    return session.handle_option(code, arg, value, kind, loc, handlers);\n+\n+    // Handles options as listed in lang.opt.\n+    /*switch (code) {\n+        case OPT_I:\n+            // TODO: add search path\n+            break;\n+        case OPT_L:\n+            // TODO: add library link path or something\n+            break;\n+        case OPT_frust_dump:\n+            // enable dump and return whether this was successful\n+            ret = rust_enable_dump(arg) ? true : false;\n+            break;\n+        // no option handling for -o\n+        default:\n+            // return 1 to indicate option is valid\n+            break;\n+    }\n+\n+    return ret;*/\n+}\n+\n+/* Run after parsing options.  */\n+static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n+    // can be used to override other options if required\n+\n+    // satisfies an assert in init_excess_precision in toplev.c\n+    if (flag_excess_precision/*_cmdline*/ == EXCESS_PRECISION_DEFAULT)\n+        flag_excess_precision/*_cmdline*/ = EXCESS_PRECISION_STANDARD;\n+\n+    /* Returning false means that the backend should be used.  */\n+    return false;\n+}\n+\n+/* Rust-specific gimplification. May need to gimplify e.g. CALL_EXPR_STATIC_CHAIN */\n+static int grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED,\n+  gimple_seq* pre_p ATTRIBUTE_UNUSED, gimple_seq* post_p ATTRIBUTE_UNUSED) {\n+    /*if (TREE_CODE (*expr_p) == CALL_EXPR\n+        && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n+      gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n+                     is_gimple_val, fb_rvalue);*/\n+    return GS_UNHANDLED;\n+}\n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n@@ -240,10 +287,10 @@ static tree grs_langhook_getdecls(void) {\n  */\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n-//#undef LANG_HOOKS_OPTION_LANG_MASK\n-//#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n-//#undef LANG_HOOKS_HANDLE_OPTION\n-//#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n #undef LANG_HOOKS_PARSE_FILE\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n@@ -252,15 +299,15 @@ static tree grs_langhook_getdecls(void) {\n #undef LANG_HOOKS_PUSHDECL\n #undef LANG_HOOKS_GETDECLS\n //#undef LANG_HOOKS_WRITE_GLOBALS\n-//#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n //#undef LANG_HOOKS_EH_PERSONALITY\n \n #define LANG_HOOKS_NAME \"GNU Rust\"\n #define LANG_HOOKS_INIT grs_langhook_init\n-//#define LANG_HOOKS_OPTION_LANG_MASK grs_langhook_option_lang_mask\n-//#define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n-//#define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n-//#define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n+#define LANG_HOOKS_OPTION_LANG_MASK grs_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n /* Main lang-hook, apparently. Finds input file names in global vars in_fnames and num_in_fnames\n  * From this, frontend can take over and do actual parsing and initial compilation.\n  * This hook must create a complete parse tree in a global var, and then return. */\n@@ -272,7 +319,7 @@ static tree grs_langhook_getdecls(void) {\n #define LANG_HOOKS_PUSHDECL grs_langhook_pushdecl\n #define LANG_HOOKS_GETDECLS grs_langhook_getdecls\n //#define LANG_HOOKS_WRITE_GLOBALS grs_langhook_write_globals\n-//#define LANG_HOOKS_GIMPLIFY_EXPR grs_langhook_gimplify_expr\n+#define LANG_HOOKS_GIMPLIFY_EXPR grs_langhook_gimplify_expr\n //#define LANG_HOOKS_EH_PERSONALITY grs_langhook_eh_personality\n \n // Expands all LANG_HOOKS_x of GCC"}, {"sha": "443818c18463c6a95924570aa07580d1104dd4c5", "filename": "gcc/rust/test3/rust-session-manager.cc", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-session-manager.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,654 @@\n+#include \"rust-session-manager.h\"\n+\n+#include \"diagnostic.h\"\n+#include \"input.h\"\n+\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+\n+#include <algorithm>\n+\n+namespace Rust {\n+    // Simple wrapper for FILE* that simplifies destruction.\n+    struct RAIIFile {\n+        FILE* file;\n+\n+        RAIIFile(const char* filename) : file(fopen(filename, \"r\")) {}\n+\n+        ~RAIIFile() {\n+            fclose(file);\n+        }\n+    };\n+\n+    // Implicitly enable a target_feature (and recursively enable dependencies).\n+    void Session::implicitly_enable_feature(::std::string feature_name) {\n+        // TODO: is this really required since features added would be complete via target spec?\n+\n+        if (!options.target_data.has_key_value_pair(\"target_data\", feature_name)) {\n+            // if feature has dependencies, enable them\n+            if (feature_name == \"aes\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"avx\") {\n+                implicitly_enable_feature(\"sse4.2\");\n+            } else if (feature_name == \"avx2\") {\n+                implicitly_enable_feature(\"avx\");\n+            } else if (feature_name == \"fma\") {\n+                implicitly_enable_feature(\"avx\");\n+            } else if (feature_name == \"pclmulqdq\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sha\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sse2\") {\n+                implicitly_enable_feature(\"sse\");\n+            } else if (feature_name == \"sse3\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sse4.1\") {\n+                implicitly_enable_feature(\"sse3\");\n+            } else if (feature_name == \"sse4.2\") {\n+                implicitly_enable_feature(\"sse4.1\");\n+            } else if (feature_name == \"ssse3\") {\n+                implicitly_enable_feature(\"sse3\");\n+            }\n+\n+            options.target_data.insert_key_value_pair(\"target_feature\", ::std::move(feature_name));\n+        }\n+    }\n+\n+    // Meant to enable all target features. As this will be done by target hook, this method's\n+    // deprecated.\n+    void Session::enable_features() {\n+        bool has_target_crt_static = false;\n+        const char* target = \"PLACEHOLDER\";\n+\n+        fprintf(stderr, \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n+\n+        if (has_target_crt_static) {\n+            // enable \"crt-static\" attribute\n+        }\n+\n+        /* TODO: do this via target hook. have one for each target that implicitly enables the\n+         * features for that platform. Would probably have to make custom target hook. */\n+\n+        /*\n+        if (target == \"x86\" || target == \"x86_64\") {\n+            if (TARGET_ISA_AES) {\n+                // enable aes, implicitly enable sse2\n+                implicitly_enable_feature(\"aes\");\n+            }\n+\n+            if (TARGET_ISA_AVX) {\n+                // enable avx, implicitly enable sse4.2\n+                implicitly_enable_feature(\"sse4.2\");\n+            }\n+\n+            if (TARGET_ISA_AVX2) {\n+                // enable avx2, implicitly enable avx\n+                implicitly_enable_feature(\"avx\");\n+            }\n+\n+            if (TARGET_ISA_BMI) {\n+                // enable bmi1\n+                implicitly_enable_feature(\"bmi1\");\n+            }\n+\n+            if (TARGET_ISA_BMI2) {\n+                // enable bmi2\n+                implicitly_enable_feature(\"bmi2\");\n+            }\n+\n+            if (TARGET_ISA_FMA) {\n+                // enable fma, implicitly enable avx\n+                implicitly_enable_feature(\"fma\");\n+            }\n+\n+            if (TARGET_ISA_FXSR) {\n+                // enable fxsr\n+                implicitly_enable_feature(\"fxsr\");\n+            }\n+\n+            if (TARGET_ISA_LZCNT) {\n+                // enable lzcnt\n+                implicitly_enable_feature(\"lzcnt\");\n+            }\n+\n+            if (TARGET_ISA_VPCLMULQDQ) {\n+                // enable pclmulqdq, implicitly enable sse2\n+                implicitly_enable_feature(\"pclmulqdq\");\n+            }\n+\n+            if (TARGET_ISA_POPCNT) {\n+                // enable popcnt\n+                implicitly_enable_feature(\"popcnt\");\n+            }\n+\n+            if (TARGET_ISA_RDRND) {\n+                // enable rdrand\n+                implicitly_enable_feature(\"rdrand\");\n+            }\n+\n+            if (TARGET_ISA_RDSEED) {\n+                // enable rdseed\n+                implicitly_enable_feature(\"rdseed\");\n+            }\n+\n+            if (TARGET_ISA_SHA) {\n+                // enable sha, implicitly enable sse2\n+                implicitly_enable_feature(\"sha\");\n+            }\n+\n+            if (TARGET_ISA_SSE) {\n+                // enable sse\n+                implicitly_enable_feature(\"sse\");\n+            }\n+\n+            if (TARGET_ISA_SSE2) {\n+                // enable sse2, implicitly enable sse\n+                implicitly_enable_feature(\"sse2\");\n+            }\n+\n+            if (TARGET_ISA_SSE3) {\n+                // enable sse3, implicitly enable sse2\n+                implicitly_enable_feature(\"sse3\");\n+            }\n+\n+            if (TARGET_ISA_SSE4_1) {\n+                // enable sse4.1, implicitly enable sse3\n+                implicitly_enable_feature(\"sse4.1\");\n+            }\n+\n+            if (TARGET_ISA_SSE4_2) {\n+                // enable sse4.2, implicitly enable sse4.1\n+                implicitly_enable_feature(\"sse4.2\");\n+            }\n+\n+            if (TARGET_ISA_SSSE3) {\n+                // enable ssse3, implicitly enable sse3\n+                implicitly_enable_feature(\"ssse3\");\n+            }\n+\n+            if (TARGET_ISA_XSAVE) {\n+                // enable xsave\n+                implicitly_enable_feature(\"xsave\");\n+            }\n+\n+            if (TARGET_ISA_XSAVEC) {\n+                // enable xsavec\n+                implicitly_enable_feature(\"xsavec\");\n+            }\n+\n+            if (TARGET_ISA_XSAVEOPT) {\n+                // enable xsaveopt\n+                implicitly_enable_feature(\"xsaveopt\");\n+            }\n+\n+            if (TARGET_ISA_XSAVES) {\n+                // enable xsaves\n+                implicitly_enable_feature(\"xsaves\");\n+            }\n+        }\n+        options.target_data.features.shrink_to_fit();\n+        ::std::sort(options.target_data.features.begin(), options.target_data.features.end());*/\n+    }\n+\n+    void Session::init() {\n+        // nothing yet\n+    }\n+\n+    // Initialise default options. Actually called before handle_option, unlike init itself.\n+    void Session::init_options() {\n+        options.dump_option = CompileOptions::NO_DUMP;\n+    }\n+\n+    // Handle option selection.\n+    bool Session::handle_option(enum opt_code code, const char* arg,\n+      HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+      location_t loc ATTRIBUTE_UNUSED, const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n+        // used to store whether results of various stuff are successful\n+        bool ret = true;\n+\n+        // Handles options as listed in lang.opt.\n+        switch (code) {\n+            case OPT_I:\n+                // TODO: add search path\n+                break;\n+            case OPT_L:\n+                // TODO: add library link path or something\n+                break;\n+            case OPT_frust_dump_:\n+                // enable dump and return whether this was successful\n+                if (arg != NULL) {\n+                    ret = enable_dump(::std::string(arg));\n+                } else {\n+                    ret = false;\n+                }\n+                break;\n+            // no option handling for -o\n+            default:\n+                // return 1 to indicate option is valid\n+                break;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /* Enables a certain dump depending on the name passed in. Returns true if name is valid, false\n+     * otherwise. */\n+    bool Session::enable_dump(::std::string arg) {\n+        // FIXME: change dumping algorithm when new non-inhibiting dump system is created\n+        if (arg == \"all\") {\n+            error_at(\n+              UNKNOWN_LOCATION, \"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n+            return false;\n+        } else if (arg == \"lex\") {\n+            options.dump_option = CompileOptions::LEXER_DUMP;\n+        } else if (arg == \"parse\") {\n+            options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+        } else if (arg == \"register_plugins\") {\n+            options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+        } else if (arg == \"injection\") {\n+            options.dump_option = CompileOptions::INJECTION_DUMP;\n+        } else if (arg == \"expansion\") {\n+            options.dump_option = CompileOptions::EXPANSION_DUMP;\n+        } else if (arg == \"name_resolution\") {\n+            options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n+        } else if (arg == \"\") {\n+            error_at(UNKNOWN_LOCATION, \"dump option was not given a name. choose 'lex' or 'parse'\");\n+            return false;\n+        } else {\n+            error_at(UNKNOWN_LOCATION, \"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n+              arg.c_str());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /* Actual main entry point for front-end. Called from langhook to parse files. */\n+    void Session::parse_files(int num_files, const char** files) {\n+        for (int i = 0; i < num_files; i++) {\n+            parse_file(files[i]);\n+        }\n+        // TODO: should semantic analysis be dealed with here? or per file? for now, per-file.\n+    }\n+\n+    // Parses a single file with filename filename.\n+    void Session::parse_file(const char* filename) {\n+        RAIIFile file_wrap(filename);\n+\n+        if (file_wrap.file == NULL) {\n+            fatal_error(UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n+        }\n+\n+        // parse file here\n+        // create lexer and parser - these are file-specific and so aren't instance variables\n+        Rust::Lexer lex(filename, file_wrap.file);\n+        Rust::Parser parser(lex);\n+\n+        // determine parsing method from options\n+        /* FIXME: currently, the dump means that full compilation will not occur as of present. In\n+         * future, dumps should not inhibit full compilation. */\n+        switch (options.dump_option) {\n+            case CompileOptions::NO_DUMP:\n+                fatal_error(UNKNOWN_LOCATION, \"no-dump parsing has not been enabled yet\");\n+                return;\n+            case CompileOptions::LEXER_DUMP:\n+                parser.debug_dump_lex_output();\n+                return;\n+            case CompileOptions::PARSER_AST_DUMP:\n+                parser.debug_dump_ast_output();\n+                return;\n+            case CompileOptions::REGISTER_PLUGINS_DUMP:\n+            case CompileOptions::INJECTION_DUMP:\n+            case CompileOptions::EXPANSION_DUMP:\n+            case CompileOptions::NAME_RESOLUTION_DUMP:\n+                // will break later after more stages\n+                break;\n+            // semantic analysis when completed\n+            default:\n+                fatal_error(UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\", options.dump_option);\n+                return;\n+        }\n+\n+        /* basic pipeline:\n+         *  - lex\n+         *  - parse\n+         *  - register plugins (dummy stage for now) - attribute injection? what is this?\n+         *    (attribute injection is injecting attributes specified in command line into crate root)\n+         *  - injection (some lint checks or dummy, register builtin macros, crate injection)\n+         *  - expansion (expands all macros, maybe build test harness, AST validation, maybe macro\n+         * crate)\n+         *  - name resolution (name resolution, maybe feature checking, maybe buffered lints)\n+         *  TODO not done */\n+\n+        // generate crate from parser\n+        AST::Crate parsed_crate = parser.parse_crate();\n+\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n+\n+        // register plugins pipeline stage\n+        register_plugins(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP) {\n+            // TODO: what do I dump here?\n+            return;\n+        }\n+\n+        // injection pipeline stage\n+        injection(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::INJECTION_DUMP) {\n+            // TODO: what do I dump here? injected crate names?\n+            return;\n+        }\n+\n+        // expansion pipeline stage\n+        expansion(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::EXPANSION_DUMP) {\n+            // TODO: what do I dump here? expanded macros? AST with expanded macros?\n+            return;\n+        }\n+\n+        // name resolution pipeline stage\n+        name_resolution(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP) {\n+            // TODO: what do I dump here? resolved names? AST with resolved names?\n+            return;\n+        }\n+    }\n+\n+    // Checks whether 'cfg' attribute prevents compilation.\n+    bool check_cfg(const AST::Attribute& attr ATTRIBUTE_UNUSED) {\n+        // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+\n+        // TODO: actually implement. assume true for now\n+\n+        return true;\n+    }\n+    // TODO: deprecated - don't use\n+\n+    // Checks whether any 'cfg' attribute on the item prevents compilation of that item.\n+    bool check_item_cfg(::std::vector<AST::Attribute> attrs) {\n+        for (const auto& attr : attrs) {\n+            if (attr.get_path() == \"cfg\" && !check_cfg(attr)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+    // TODO: deprecated - don't use\n+\n+    // TODO: actually implement method\n+    void load_extern_crate(::std::string crate_name ATTRIBUTE_UNUSED) {}\n+    // TODO: deprecated - don't use\n+\n+    // Parses up to the \"load (external) crates\" part of the frontend.\n+    // TODO: lots of this code is probably actually useful outside of dumping, so maybe split off\n+    // function\n+    void Session::debug_dump_load_crates(Parser& parser) {\n+        // parse crate as AST\n+        AST::Crate crate = parser.parse_crate();\n+\n+        /* TODO: search through inner attrs and see whether any of those attr paths contain \"no_core\",\n+         * \"no_std\", \"compiler_builtins\". If so/not, save certain crate names. In these names, insert\n+         * items at beginning of crate items. This is crate injection. Also, inject prelude use decl\n+         * at beginning (first name is assumed to be prelude - prelude is a use decl automatically\n+         * generated to enable using Option and Copy without qualifying it or importing it via 'use'\n+         * manually) */\n+\n+        ::std::vector< ::std::string> crate_names;\n+        for (const auto& item : crate.items) {\n+            // if item is extern crate, add name? to list of stuff ONLY IF config is checked\n+            // if item is module, iterate this loop inside it as well (recursive?) ONLY IF config is\n+            // checked\n+\n+            // TODO: actually do the checks somewhere - probably in the items\n+\n+            item->add_crate_name(crate_names);\n+        }\n+\n+        /* loop through list of crate names/paths/whatever, attempting to load each one. save loaded\n+         * crates to a Session variable? Or save to current AST::Crate? */\n+        for (const auto& name : crate_names) {\n+            load_extern_crate(name /*, basename = \"\"?*/);\n+        }\n+        //  for each loaded crate, load dependencies of it as well\n+    }\n+    // TODO: deprecated - don't use\n+\n+    void Session::register_plugins(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"ran register_plugins (with no body)\\n\");\n+    }\n+\n+    // TODO: move somewhere else\n+    bool contains_name(::std::vector<AST::Attribute> attrs, ::std::string name) {\n+        for (const auto& attr : attrs) {\n+            if (attr.get_path() == name) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    void Session::injection(AST::Crate& crate) {\n+        fprintf(stderr, \"started injection\\n\");\n+\n+        // lint checks in future maybe?\n+\n+        // register builtin macros\n+        /* In rustc, builtin macros are divided into 3 categories depending on use - \"bang\" macros,\n+         * \"attr\" macros, and \"derive\" macros. I think the meanings of these categories should be\n+         * fairly obvious to anyone who has used rust. Builtin macro list by category: Bang\n+         *      - asm\n+         *      - assert\n+         *      - cfg\n+         *      - column\n+         *      - compile_error\n+         *      - concat_idents\n+         *      - concat\n+         *      - env\n+         *      - file\n+         *      - format_args_nl\n+         *      - format_args\n+         *      - global_asm\n+         *      - include_bytes\n+         *      - include_str\n+         *      - include\n+         *      - line\n+         *      - log_syntax\n+         *      - module_path\n+         *      - option_env\n+         *      - stringify\n+         *      - trace_macros\n+         *  Attr\n+         *      - bench\n+         *      - global_allocator\n+         *      - test\n+         *      - test_case\n+         *  Derive\n+         *      - Clone\n+         *      - Copy\n+         *      - Debug\n+         *      - Default\n+         *      - Eq\n+         *      - Hash\n+         *      - Ord\n+         *      - PartialEq\n+         *      - PartialOrd\n+         *      - RustcDecodable\n+         *      - RustcEncodable\n+         * rustc also has a \"quote\" macro that is defined differently and is supposedly not stable so\n+         * eh. */\n+        /* TODO: actually implement injection of these macros. In particular, derive macros, cfg, and\n+         * test should be prioritised since they seem to be used the most. */\n+\n+        // crate injection\n+        ::std::vector< ::std::string> names;\n+        if (contains_name(crate.inner_attrs, \"no_core\")) {\n+            // no prelude\n+            injected_crate_name = \"\";\n+        } else if (contains_name(crate.inner_attrs, \"no_std\")) {\n+            names.push_back(\"core\");\n+\n+            if (!contains_name(crate.inner_attrs, \"compiler_builtins\")) {\n+                names.push_back(\"compiler_builtins\");\n+            }\n+\n+            injected_crate_name = \"core\";\n+        } else {\n+            names.push_back(\"std\");\n+\n+            injected_crate_name = \"std\";\n+        }\n+\n+        // reverse iterate through names to insert crate items in \"forward\" order at beginning of\n+        // crate\n+        for (auto it = names.rbegin(); it != names.rend(); ++it) {\n+            // create \"macro use\" attribute for use on extern crate item to enable loading macros from\n+            // it\n+            AST::Attribute attr(AST::SimplePath::from_str(\"macro_use\"), NULL);\n+\n+            // create \"extern crate\" item with the name\n+            ::std::unique_ptr<AST::ExternCrate> extern_crate(new AST::ExternCrate(\n+              *it, AST::Visibility::create_error(), { ::std::move(attr) }, UNKNOWN_LOCATION));\n+\n+            // insert at beginning\n+            crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n+        }\n+\n+        // create use tree path\n+        // prelude is injected_crate_name\n+        ::std::vector<AST::SimplePathSegment> segments\n+          = { AST::SimplePathSegment(injected_crate_name), AST::SimplePathSegment(\"prelude\"),\n+                AST::SimplePathSegment(\"v1\") };\n+        // create use tree and decl\n+        ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n+          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), UNKNOWN_LOCATION));\n+        AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n+        ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n+          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, UNKNOWN_LOCATION));\n+\n+        crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n+\n+        /* TODO: potentially add checking attribute crate type? I can't figure out what this does\n+         * currently comment says \"Unconditionally collect crate types from attributes to make them\n+         * used\", which presumably refers to checking the linkage info by \"crate_type\". It also seems\n+         * to ensure that an invalid crate type is not specified, so maybe just do that. Valid crate\n+         * types: bin lib dylib staticlib cdylib rlib proc-macro */\n+\n+        fprintf(stderr, \"finished injection\\n\");\n+    }\n+\n+    void Session::expansion(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"started expansion\\n\");\n+\n+        // rustc has a modification to windows PATH temporarily here, which may end up being required\n+\n+        // create macro expansion config?\n+        // if not, would at least have to configure recursion_limit\n+\n+        // create extctxt? from parse session, cfg, and resolver?\n+        // expand by calling cxtctxt object's monotonic_expander's expand_crate method.\n+\n+        // error reporting - check unused macros, get missing fragment specifiers\n+\n+        // build test harness\n+\n+        // ast validation (also with proc macro decls)\n+\n+        // maybe create macro crate if not rustdoc\n+\n+        fprintf(stderr, \"finished expansion\\n\");\n+    }\n+\n+    void Session::name_resolution(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"started name resolution\\n\");\n+\n+        fprintf(stderr, \"finished name resolution\\n\");\n+    }\n+\n+    // NOTEs:\n+    /* mrustc compile pipeline:\n+     *  - target load (pass target spec to parser?)\n+     *  - parse (convert source to AST)\n+     *  - load crates (load any explicitly mentioned extern crates [not all of them])\n+     *  - expand (AST transformations from attributes and macros, loads remaining extern crates\n+     * [std/core and any triggered by macro expansion])\n+     *  - implicit crates (test harness, allocator crate, panic crate)\n+     *  - resolve use (annotate every 'use' item with source [supposedly handles nasty recursion])\n+     *  - resolve index (generate index of visible items for every module [avoids recursion in next\n+     * pass])\n+     *  - resolve absolute (resolve all paths into either variable names [types/values] or absolute\n+     * paths)\n+     *  - HIR lower (convert modified AST to simpler HIR [both expressions and module tree])\n+     *  - resolve type aliases (replace any usages of type aliases with actual type [except associated\n+     *    types])\n+     *  - resolve bind (iterate HIR tree and set binding annotations on all concrete types [avoids\n+     * path lookups later])\n+     *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...] for all types\n+     *  - sort impls (small pass - sort impls into groups)\n+     *  - resolve UFCS outer (determine source trait for all top-level <T>::Type [qualified] paths)\n+     *  - resolve UFCS paths (do the same, but include for exprs this time. also normalises results of\n+     *    previous pass [expanding known associated types])\n+     *  - constant evaluate (evaluate all constants)\n+     *  - typecheck outer (checks impls are sane)\n+     *  - typecheck expressions (resolve and check types for all exprs)\n+     *  - expand HIR annotate (annotate how exprs are used - used for closure extractions and\n+     * reborrows)\n+     *  - expand HIR closures (extract closures into structs implementing Fn* traits)\n+     *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n+     *  - expand HIR calls (converts method and callable calls into explicit function calls)\n+     *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of 'v'])\n+     *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true type)\n+     *  - typecheck expressions (validate - double check that previous passes haven't broke type\n+     * system rules)\n+     *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n+     *  - MIR validate (check that the generated MIR is consistent)\n+     *  - MIR cleanup (perform various transformations on MIR - replace reads of const items with the\n+     * item itself; convert casts to unsized types into 'MakeDst' operations)\n+     *  - MIR optimise (perform various simple optimisations on the MIR - constant propagation, dead\n+     * code elimination, borrow elimination, some inlining)\n+     *  - MIR validate PO (re-validate the MIR)\n+     *  - MIR validate full (optionally: perform expensive state-tracking validation on MIR)\n+     *  - trans enumerate (enumerate all items needed for code generation, primarily types used for\n+     * generics)\n+     *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n+     *  - trans monomorph (generate monomorphised copies of all functions [with generics replaced with\n+     * real types])\n+     *  - MIR optimise inline (run optimisation again, this time with full type info [primarily for\n+     * inlining])\n+     *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n+     *  - trans codegen (generate final output file: emit C source file and call C compiler) */\n+\n+    /* rustc compile pipeline (basic, in way less detail):\n+     *  - parse input (parse .rs to AST)\n+     *  - name resolution, macro expansion, and configuration (process AST recursively, resolving\n+     * paths, expanding macros, processing #[cfg] nodes [i.e. maybe stripping stuff from AST])\n+     *  - lower to HIR\n+     *  - type check and other analyses (e.g. privacy checking)\n+     *  - lower to MIR and post-processing (and do stuff like borrow checking)\n+     *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n+     *  - linking (link together .o files) */\n+\n+    /* Pierced-together rustc compile pipeline (from source):\n+     *  - parse input (parse file to crate)\n+     *  - register plugins (attributes injection, set various options, register lints, load plugins)\n+     *  - expansion/configure and expand (initial 'cfg' processing, 'loading compiler plugins',\n+     *    syntax expansion, secondary 'cfg' expansion, synthesis of a test harness if required,\n+     * injection of any std lib dependency and prelude, and name resolution) - actually documented\n+     * inline\n+     *      - seeming pierced-together order: pre-AST expansion lint checks, registering builtin\n+     * macros, crate injection, then expand all macros, then maybe build test harness, AST validation,\n+     *        maybe create a macro crate (if not rustdoc), name resolution, complete gated feature\n+     * checking, add all buffered lints\n+     *  - create global context (lower to HIR)\n+     *  - analysis on global context (HIR optimisations? create MIR?)\n+     *  - code generation\n+     *  - link */\n+}\n\\ No newline at end of file"}, {"sha": "c268453e175849cea2496eda3e197708a8998733", "filename": "gcc/rust/test3/rust-session-manager.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-session-manager.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -0,0 +1,180 @@\n+#ifndef RUST_SESSION_MANAGER_H\n+#define RUST_SESSION_MANAGER_H\n+// Session manager - controls compiler session.\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"options.h\"\n+// order: config, system, coretypes, options\n+\n+#include <string>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+#include <utility>\n+\n+namespace Rust {\n+    // parser forward decl\n+    class Parser;\n+    // crate forward decl\n+    namespace AST {\n+        struct Crate;\n+    }\n+\n+    // Data related to target, most useful for conditional compilation and whatever.\n+    struct TargetOptions {\n+        // TODO: maybe make private and access through helpers to allow changes to impl\n+        std::unordered_map<std::string, std::unordered_set<std::string>> features;\n+\n+      public:\n+        // Returns whether a key is defined in the feature set.\n+        bool has_key(std::string key) const {\n+            return features.find(key) != features.end();\n+        }\n+\n+        // Returns whether a key exists with the given value in the feature set.\n+        bool has_key_value_pair(std::string key, std::string value) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                auto set = it->second;\n+                auto it2 = set.find(value);\n+                if (it2 != set.end())\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        // Returns the singular value from the key, or if the key has multiple, an empty string.\n+        std::string get_singular_value(std::string key) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                auto set = it->second;\n+                if (set.size() == 1)\n+                    return *set.begin();\n+            }\n+            return \"\";\n+        }\n+\n+        // Returns all values associated with a key (including none), or an empty set if no key is found.\n+        std::unordered_set< ::std::string> get_values_for_key(std::string key) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                return it->second;\n+            }\n+            return {};\n+        }\n+\n+        /* Inserts a key (no value) into the feature set. This will do nothing if the key already exists. \n+         * This returns whether the insertion was successful (i.e. whether key already existed). */\n+        bool insert_key(std::string key) {\n+            return features.insert(std::make_pair(key, std::unordered_set<std::string>())).second;\n+        }\n+\n+        // Inserts a key-value pair into the feature set. \n+        void insert_key_value_pair(std::string key, std::string value) {\n+            auto existing_set = get_values_for_key(key);\n+            existing_set.insert(std::move(value));\n+            features[std::move(key)] = std::move(existing_set);\n+        }\n+\n+        /* According to reference, Rust uses either multi-map key-values or just values (although\n+         * values may be aliases for a key-value value). This seems like overkill. Thus, depending on\n+         * whether the attributes used in cfg are fixed or not, I think I'll either put each\n+         * non-multimap \"key-value\" as a separate field and have the multimap \"key-values\" in a\n+         * regular map for that one key, or actually use a multimap.\n+         *\n+         * rustc itself uses a set of key-value tuples where the second tuple element is optional.\n+         * This gets rid of the requirement to make a multi-map, I guess, but seems like it might make\n+         * search slow (unless all \"is defined\"-only ones have empty string as second element). */\n+        /* cfg attributes:\n+         * - target_arch: single value\n+         * - target_feature: multiple values possible\n+         * - target_os: single value\n+         * - target_family: single value (or no value?)\n+         * - unix: set when target_family = \"unix\"\n+         * - windows: set when target_family = \"windows\"\n+         *  - if these are just syntactic sugar, then maybe have a separate set or map for this kind\n+         * of stuff\n+         * - target_env: set when needed for disambiguation about ABI - usually empty string for GNU,\n+         * complicated\n+         *  - seems to be a single value (if any)\n+         * - target_endian: single value; \"little\" or \"big\"\n+         * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n+         * - target_vendor, single value\n+         * - test: set when testing is being done\n+         *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like unix\n+         * - debug_assertions: seems to \"is defined\"\n+         * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\" */\n+    };\n+\n+    // Defines compiler options (e.g. dump, etc.).\n+    struct CompileOptions {\n+        // TODO: use bitfield for smaller memory requirements?\n+\n+        // FIXME: this is set up for \"instead of\" dumping - in future, dumps should not inhibit\n+        // compilation\n+        enum DumpOptions {\n+            NO_DUMP,\n+            LEXER_DUMP,\n+            PARSER_AST_DUMP,\n+            REGISTER_PLUGINS_DUMP,\n+            INJECTION_DUMP,\n+            EXPANSION_DUMP,\n+            NAME_RESOLUTION_DUMP,\n+            // TODO: add more?\n+        } dump_option;\n+\n+        // configuration options - actually useful for conditional compilation and whatever\n+        // data related to target arch, features, os, family, env, endian, pointer width, vendor\n+        TargetOptions target_data;\n+        bool enable_test = false;\n+        bool debug_assertions = false;\n+        bool proc_macro = false;\n+    };\n+\n+    /* Defines a compiler session. This is for a single compiler invocation, so potentially includes\n+     * parsing multiple crates. */\n+    struct Session {\n+        CompileOptions options;\n+        // This should really be in a per-crate storage area but it is wiped with every file so eh.\n+        ::std::string injected_crate_name;\n+\n+      public:\n+        /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n+         * called after option handling. */\n+        void init();\n+        bool handle_option(enum opt_code code, const char* arg, HOST_WIDE_INT value, int kind,\n+          location_t loc, const struct cl_option_handlers* handlers);\n+        void parse_files(int num_files, const char** files);\n+        void init_options();\n+\n+      private:\n+        // TODO: should this be private or public?\n+        void parse_file(const char* filename);\n+        bool enable_dump(::std::string arg);\n+\n+        void debug_dump_load_crates(Parser& parser);\n+\n+        void implicitly_enable_feature(::std::string feature_name);\n+        void enable_features();\n+\n+        // pipeline stages - TODO maybe move?\n+        /* Register plugins pipeline stage. TODO maybe move to another object? Currently dummy stage.\n+         * In future will handle attribute injection (top-level inner attribute creation from command\n+         * line arguments), setting options maybe, registering lints maybe, loading plugins maybe. */\n+        void register_plugins(AST::Crate& crate);\n+        /* Injection pipeline stage. TODO maybe move to another object? Maybe have some lint checks\n+         * (in future, obviously), register builtin macros, crate injection. */\n+        void injection(AST::Crate& crate);\n+        /* Expansion pipeline stage. TODO maybe move to another object? Expands all macros, maybe\n+         * build test harness in future, AST validation, maybe create macro crate (if not rustdoc).*/\n+        void expansion(AST::Crate& crate);\n+        /* Name resolution pipeline stage. TODO maybe move to another object. Performs name\n+         * resolution, maybe complete gated feature checking, maybe create buffered lints in future.\n+         */\n+        void name_resolution(AST::Crate& crate);\n+    };\n+}\n+\n+#endif\n\\ No newline at end of file"}]}