{"sha": "62cf637a773d68c24552ffc91a977b5adb55c2cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjZjYzN2E3NzNkNjhjMjQ1NTJmZmM5MWE5NzdiNWFkYjU1YzJjYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-03T05:00:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-03T05:00:24Z"}, "message": "Initial revision\n\nFrom-SVN: r274", "tree": {"sha": "65a9f0c4f24d7950b904d4f1ce3194939c93d18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65a9f0c4f24d7950b904d4f1ce3194939c93d18b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62cf637a773d68c24552ffc91a977b5adb55c2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cf637a773d68c24552ffc91a977b5adb55c2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62cf637a773d68c24552ffc91a977b5adb55c2cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cf637a773d68c24552ffc91a977b5adb55c2cb/comments", "author": null, "committer": null, "parents": [{"sha": "161ca48c6991ebe9fcd0dc45e3a80a98bd11a259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161ca48c6991ebe9fcd0dc45e3a80a98bd11a259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161ca48c6991ebe9fcd0dc45e3a80a98bd11a259"}], "stats": {"total": 430, "additions": 430, "deletions": 0}, "files": [{"sha": "579e2d0b1e775344f859c45d0bde2e7afcf18674", "filename": "gcc/config/m68k/next.h", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cf637a773d68c24552ffc91a977b5adb55c2cb/gcc%2Fconfig%2Fm68k%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cf637a773d68c24552ffc91a977b5adb55c2cb/gcc%2Fconfig%2Fm68k%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnext.h?ref=62cf637a773d68c24552ffc91a977b5adb55c2cb", "patch": "@@ -0,0 +1,430 @@\n+/* next.h:  definitions for NeXT.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"m68k.h\"\n+\n+#define EXTRA_FORMAT_FUNCTIONS \\\n+      \"NXPrintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"NXScanf\",\tTRUE,\t2,\tFALSE,\t\\\n+      \"NXVPrintf\",\tFALSE,\t2,\tTRUE,\t\\\n+      \"NXVScanf\",\tTRUE,\t2,\tTRUE,\t\\\n+      \"DPSPrintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"bsd_sprintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"bsd_vsprintf\",\tFALSE,\t2,\tTRUE,\n+\n+/* Use NeXT's special calling convention for sending an Objc message.  */\n+#define NEXT_OBJC_RUNTIME\n+\n+/* We have atexit.  */\n+#define HAVE_ATEXIT\n+\n+/* Enable recent gcc to compile under the old gcc in Next release 1.0.  */\n+#define __inline inline\n+\n+/* See m68k.h.  0407 means 68040 (or 68030 or 68020, with 68881/2).  */\n+\n+#define TARGET_DEFAULT 0407\n+\n+/* wchar_t is unsigned short */\n+\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE (BITS_PER_WORD / 2)\n+\n+/* Give methods pretty symbol names on NeXT. */\n+\n+#define OBJC_GEN_METHOD_LABEL(BUF,IS_INST,CLASS_NAME,CAT_NAME,SEL_NAME)\t\\\n+  do { if (CAT_NAME)\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s(%s) %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (CAT_NAME), (SEL_NAME));\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (SEL_NAME));\t\t\t\t\\\n+     } while (0)\n+\n+/* Wrap new method names in quotes so the assembler doesn't gag.\n+   Make Objective-C internal symbols local. */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  do { if (NAME[0] == '+' || NAME[0] == '-') fprintf (FILE, \"\\\"%s\\\"\", NAME); \\\n+       else if (!strncmp (NAME, \"_OBJC_\", 6)) fprintf (FILE, \"L%s\", NAME);   \\\n+       else fprintf (FILE, \"_%s\", NAME); } while (0)\n+\n+#undef STACK_BOUNDARY\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* These compiler options take n arguments.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t \t\\\n+  (!strcmp (STR, \"Ttext\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"Tdata\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"include\") ? 1 :\t\t\\\n+   !strcmp (STR, \"imacros\") ? 1 :\t\t\\\n+   !strcmp (STR, \"segalign\") ? 1 :\t\t\\\n+   !strcmp (STR, \"seg1addr\") ? 1 :\t\t\\\n+   !strcmp (STR, \"segaddr\") ? 2 :\t\t\\\n+   !strcmp (STR, \"sectobjectsymbols\") ? 2 :\t\\\n+   !strcmp (STR, \"segprot\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectcreate\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectalign\") ? 3 :\t\t\\\n+   !strcmp (STR, \"segcreate\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectorder\") ? 3 :\t\t\\\n+   0)\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dmc68000 -Dm68k -DNeXT -Dunix -D__MACH__\"\n+\n+/* Machine dependent ccp options.  */\n+\n+#define CPP_SPEC \"%{bsd:-D__STRICT_BSD__}\"\n+\n+/* Machine dependent ld options.  */\n+\n+#define LINK_SPEC \"%{Z} %{M} \\\n+%{execute*} %{object*} %{preload*} %{fvmlib*} \\\n+%{segalign*} %{seg1addr*} %{segaddr*} %{segprot*} \\\n+%{seglinkedit*} %{noseglinkedit*} \\\n+%{sectcreate*} %{sectalign*} %{sectobjectsymbols}\\\n+%{segcreate*} %{Mach*} %{whyload} %{w} \\\n+%{sectorder*} %{whatsloaded}\"\n+\n+/* Machine dependent libraries.  */\n+\n+#define LIB_SPEC \"%{!p:%{!pg:-lsys_s}} %{pg:-lsys_p}\"\n+ \n+/* We specify crt0.o as -lcrt0.o so that ld will search the library path. */\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:-lgcrt0.o}%{!pg: \\\n+     %{p:%e-p profiling is no longer supported.  Use -pg instead.} \\\n+     %{!p:-lcrt0.o}}\"\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.\n+   (Why isn't this in m68k.h?)  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* Why not? */\n+\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* Allow #sscs (but don't do anything). */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* We use Dbx symbol format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* This saves a fair amount of space. */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* These screw up NeXT's gdb at the moment, so don't use them. */\n+\n+#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE, FILENAME)\n+\n+/* gdb needs a null N_SO at the end of each file for scattered loading. */\n+\n+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   \"\\t.text\\n\\t.stabs \\\"%s\\\",%d,0,0,Letext\\nLetext:\\n\",\t\t\\\n+\t   \"\" , N_SO)\n+\n+/* Don't use .gcc_compiled symbols to communicate with GDB;\n+   They interfere with numerically sorted symbol lists. */\n+\n+#define ASM_IDENTIFY_GCC(asm_out_file)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.double 0r%s99e999\\n\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : fprintf (FILE, \"\\t.double 0r%.20e\\n\", (VALUE)))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.single 0r%s99e999\\n\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : fprintf (FILE, \"\\t.single 0r%.20e\\n\", (VALUE)))\n+\n+#undef ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : fprintf (FILE, \"#0r%.9g\", (VALUE)))\n+\n+#undef ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : fprintf (FILE, \"#0r%.20g\", (VALUE)))\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+  do { constructor_section ();\t\t\t\\\n+       ASM_OUTPUT_ALIGN (FILE, 1);\t\t\\\n+       fprintf (FILE, \"\\t.long \");\t\t\\\n+       assemble_name (FILE, NAME);\t\t\\\n+       fprintf (FILE, \"\\n\"); } while (0)\n+\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n+  do { destructor_section ();\t\t\t\\\n+       ASM_OUTPUT_ALIGN (FILE, 1);\t\t\\\n+       fprintf (FILE, \"\\t.long \");\t\t\\\n+       assemble_name (FILE, NAME);\t\t\\\n+       fprintf (FILE, \"\\n\"); } while (0)\n+\n+/* How to parse #pragma's */\n+\n+#define HANDLE_PRAGMA(finput) handle_pragma (finput)\n+\n+/* Create new Mach-O sections. */\n+\n+#define SECTION_FUNCTION(FUNCTION, SECTION, DIRECTIVE, WAS_TEXT)\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+FUNCTION ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section ();\t\t\t\t\t \t\\\n+  extern int flag_no_mach_text_sections;\t\t \t      \t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  if (WAS_TEXT && flag_no_mach_text_sections)       \t\t\t\\\n+    text_section ();\t\t\t\t\t\t\t\\\n+  else if (in_section != SECTION)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DIRECTIVE);\t\t\t\\\n+      in_section = SECTION;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\n+#define EXTRA_SECTIONS\t\t\t\t\t\\\n+  in_const, in_cstring, in_literal4, in_literal8,\t\\\n+  in_constructor, in_destructor,\t\t\t\\\n+  in_objc_class, in_objc_meta_class, in_objc_category,\t\\\n+  in_objc_class_vars, in_objc_instance_vars,\t\t\\\n+  in_objc_cls_meth, in_objc_inst_meth,\t\t\t\\\n+  in_objc_cat_cls_meth, in_objc_cat_inst_meth,\t\t\\\n+  in_objc_selector_strs, in_objc_selector_refs,\t\t\\\n+  in_objc_symbols, in_objc_module_info\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\\\n+SECTION_FUNCTION (const_section,\t\t\\\n+\t\t  in_const,\t\t\t\\\n+\t\t  \".const\", 1)\t\t\t\\\n+SECTION_FUNCTION (cstring_section,\t\t\\\n+\t\t  in_cstring,\t\t\t\\\n+\t\t  \".cstring\", 1)\t\t\\\n+SECTION_FUNCTION (literal4_section,\t\t\\\n+\t\t  in_literal4,\t\t\t\\\n+\t\t  \".literal4\", 1)\t\t\\\n+SECTION_FUNCTION (literal8_section,\t\t\\\n+\t\t  in_literal8,\t\t\t\\\n+\t\t  \".literal8\", 1)\t\t\\\n+SECTION_FUNCTION (constructor_section,\t\t\\\n+\t\t  in_constructor,\t\t\\\n+\t\t  \".constructor\", 0)\t\t\\\n+SECTION_FUNCTION (destructor_section,\t\t\\\n+\t\t  in_destructor,\t\t\\\n+\t\t  \".destructor\", 0)\t\t\\\n+SECTION_FUNCTION (objc_class_section,\t\t\\\n+\t\t  in_objc_class,\t\t\\\n+\t\t  \".objc_class\", 0)\t\t\\\n+SECTION_FUNCTION (objc_meta_class_section,\t\\\n+\t\t  in_objc_meta_class,\t\t\\\n+\t\t  \".objc_meta_class\", 0)\t\\\n+SECTION_FUNCTION (objc_category_section,\t\\\n+\t\t  in_objc_category,\t\t\\\n+\t\t\".objc_category\", 0)\t\t\\\n+SECTION_FUNCTION (objc_class_vars_section,\t\\\n+\t\t  in_objc_class_vars,\t\t\\\n+\t\t  \".objc_class_vars\", 0)\t\\\n+SECTION_FUNCTION (objc_instance_vars_section,\t\\\n+\t\t  in_objc_instance_vars,\t\\\n+\t\t  \".objc_instance_vars\", 0)\t\\\n+SECTION_FUNCTION (objc_cls_meth_section,\t\\\n+\t\t  in_objc_cls_meth,\t\t\\\n+\t\t  \".objc_cls_meth\", 0)\t\t\\\n+SECTION_FUNCTION (objc_inst_meth_section,\t\\\n+\t\t  in_objc_inst_meth,\t\t\\\n+\t\t  \".objc_inst_meth\", 0)\t\t\\\n+SECTION_FUNCTION (objc_cat_cls_meth_section,\t\\\n+\t\t  in_objc_cat_cls_meth,\t\t\\\n+\t\t  \".objc_cat_cls_meth\", 0)\t\\\n+SECTION_FUNCTION (objc_cat_inst_meth_section,\t\\\n+\t\t  in_objc_cat_inst_meth,\t\\\n+\t\t  \".objc_cat_inst_meth\", 0)\t\\\n+SECTION_FUNCTION (objc_selector_strs_section,\t\\\n+\t\t  in_objc_selector_strs,\t\\\n+\t\t  \".objc_selector_strs\", 0)\t\\\n+SECTION_FUNCTION (objc_selector_refs_section,\t\\\n+\t\t  in_objc_selector_refs,\t\\\n+\t\t  \".objc_selector_refs\", 0)\t\\\n+SECTION_FUNCTION (objc_symbols_section,\t\t\\\n+\t\t  in_objc_symbols,\t\t\\\n+\t\t  \".objc_symbols\", 0)\t\t\\\n+SECTION_FUNCTION (objc_module_info_section,\t\\\n+\t\t  in_objc_module_info,\t\t\\\n+\t\t  \".objc_module_info\", 0)\n+\n+#define READONLY_DATA_SECTION const_section\n+\n+#define SELECT_SECTION(exp,reloc)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TREE_CODE (exp) == STRING_CST)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (flag_writable_strings)\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\\\n+\t  else if (TREE_STRING_LENGTH (exp) !=\t\t\t\\\n+\t\t   strlen (TREE_STRING_POINTER (exp)) + 1)\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    cstring_section ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == INTEGER_CST\t\t\t\\\n+\t       || TREE_CODE (exp) == REAL_CST)\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+\t  tree size = TYPE_SIZE (TREE_TYPE (exp));\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 4 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal4_section ();\t\t\t\t\\\n+\t  else if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 8 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal8_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if ((TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\\\n+\t       && !TREE_SIDE_EFFECTS (exp))\t\t\t\t\\\n+\treadonly_data_section ();\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == VAR_DECL &&\t\t\t\t\\\n+\t       DECL_NAME (exp) &&\t\t\t\t\t\\\n+\t       TREE_CODE (DECL_NAME (exp)) == IDENTIFIER_NODE &&\t\\\n+\t       IDENTIFIER_POINTER (DECL_NAME (exp)) &&\t\t\t\\\n+\t       !strncmp (IDENTIFIER_POINTER (DECL_NAME (exp)), \"_OBJC_\", 6)) \\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  const char *name = IDENTIFIER_POINTER (DECL_NAME (exp));\t\\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\t\t\\\n+\t    objc_cls_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\t\\\n+\t    objc_inst_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_CLASS_METHODS_\", 20)) \\\n+\t    objc_cat_cls_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_INSTANCE_METHODS_\", 23)) \\\n+\t    objc_cat_inst_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_VARIABLES_\", 22))\t\\\n+\t    objc_class_vars_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_VARIABLES_\", 25))\t\\\n+\t    objc_instance_vars_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_\", 12))\t\t\t\\\n+\t    objc_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METACLASS_\", 16))\t\t\\\n+\t    objc_meta_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_\", 15))\t\t\\\n+\t    objc_category_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_STRINGS\", 13))\t\t\\\n+\t    objc_selector_strs_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SELECTOR_REFERENCES\", 25))\t\\\n+\t    objc_selector_refs_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SYMBOLS\", 13))\t\t\\\n+\t    objc_symbols_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_MODULES\", 13))\t\t\\\n+\t    objc_module_info_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        data_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Force the assembler to create all the Objective-C sections,\n+    so that their order is guaranteed. */\n+  \n+#define OBJC_PROLOGUE\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+\textern void objc_class_section ();\t\t\\\n+\textern void objc_meta_class_section ();\t\t\\\n+\textern void objc_cat_cls_meth_section ();\t\\\n+\textern void objc_cat_inst_meth_section ();\t\\\n+\textern void objc_cls_meth_section ();\t\t\\\n+\textern void objc_inst_meth_section ();\t\t\\\n+\textern void objc_selector_refs_section ();\t\\\n+\textern void objc_symbols_section ();\t\t\\\n+\textern void objc_category_section ();\t\t\\\n+\textern void objc_class_vars_section ();\t\t\\\n+\textern void objc_instance_vars_section ();\t\\\n+\textern void objc_module_info_section ();\t\\\n+\textern void objc_selector_strs_section ();\t\\\n+\t\t\t\t\t\t\t\\\n+\tobjc_class_section ();\t\t\\\n+\tobjc_meta_class_section ();\t\\\n+\tobjc_cat_cls_meth_section ();\t\\\n+\tobjc_cat_inst_meth_section ();\t\\\n+\tobjc_cls_meth_section ();\t\\\n+\tobjc_inst_meth_section ();\t\\\n+\tobjc_selector_refs_section ();\t\\\n+\tobjc_symbols_section ();\t\\\n+\tobjc_category_section ();\t\\\n+\tobjc_class_vars_section ();\t\\\n+\tobjc_instance_vars_section ();\t\\\n+\tobjc_module_info_section ();\t\\\n+\tobjc_selector_strs_section ();\t\\\n+     } while (0)\n+\n+/* We do not define JUMP_TABLES_IN_TEXT_SECTION, since we wish to keep\n+   the text section pure.  There is no point in addressing the jump\n+   tables using pc relative addressing, since they are not in the text\n+   section, so we undefine CASE_VECTOR_PC_RELATIVE.  This also\n+   causes the compiler to use absolute addresses in the jump table,\n+   so we redefine CASE_VECTOR_MODE to be SImode. */\n+\n+#undef CASE_VECTOR_MODE\n+#define CASE_VECTOR_MODE SImode\n+\n+#undef CASE_VECTOR_PC_RELATIVE\n+\n+/* Don't treat addresses involving labels differently from symbol names.\n+   Previsouly, references to labels generated pc-relative addressing modes\n+   while references to symbol names generated absolute addressing modes.  */\n+\n+#undef GO_IF_INDEXABLE_BASE(X, ADDR)\n+#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\\\n+{ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR; }\n+\n+#define ALIGN_ASM_OP\t\t\"\\t.align\"\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"%s %d\\n\", ALIGN_ASM_OP, (LOG))\n+\n+/* The maximum alignment which the object file format can support.\n+   For NeXT's Mach-O format, this is 2^15.  */\n+\n+#define MAX_OFILE_ALIGNMENT 0x8000"}]}