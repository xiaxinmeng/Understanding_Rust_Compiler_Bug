{"sha": "0310af44bbc4c372246641d891de639f96c15971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMxMGFmNDRiYmM0YzM3MjI0NjY0MWQ4OTFkZTYzOWY5NmMxNTk3MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T10:25:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T10:25:59Z"}, "message": "[multiple changes]\n\n2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb: Code cleanup.\n\t* sem_ch6.adb: Code cleanup.\n\t(Is_Matching_Limited_View): New routine.\n\t(Matches_Limited_With_View): Reimplemented.\n\t* sem_ch10.adb (Decorate_Type): Code cleanup.\n\n2016-04-21  Doug Rupp  <rupp@adacore.com>\n\n\t* tracebak.c (PPC ELF): Add macro defs for lynxos178e.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing): If there are overloaded\n\tindexing functions, collect all overloadings of the call firts,\n\tand then transfer them to indexing node, to prevent interleaving\n\tof the set of interpretations of the nodes involved.\n\t* sem_res.adb (Resolve): Suppress cascaded errors that report\n\tambiguities when one of the actuals in an overloaded generatlized\n\tindexing operation is illegal and has type Any_Type, as is done\n\tfor similar cascaded errors in subprogram calls.\n\t(Valid_Tagged_Conversion): Cleanup conversion checks when one\n\tof the types involved is a class-wide subtype.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Load_Parent_Of_Generic): When looking for the\n\tsubprogram declaration within a wrapper package, skip pragmas\n\tthat may have been generated by aspect specifications on the\n\tgeneric instance.\n\n2016-04-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Component_Not_OK_For_Backend): Generating C\n\tcode return True for array identifiers since the backend needs\n\tto initialize such component by means of memcpy().\n\nFrom-SVN: r235330", "tree": {"sha": "68509cb2929b2c9f2bd7f6f5b3cdfe4fb462ba06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68509cb2929b2c9f2bd7f6f5b3cdfe4fb462ba06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0310af44bbc4c372246641d891de639f96c15971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0310af44bbc4c372246641d891de639f96c15971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0310af44bbc4c372246641d891de639f96c15971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0310af44bbc4c372246641d891de639f96c15971/comments", "author": null, "committer": null, "parents": [{"sha": "150346bd8db28a59bbdc4bd3dee291875e6886fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150346bd8db28a59bbdc4bd3dee291875e6886fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150346bd8db28a59bbdc4bd3dee291875e6886fc"}], "stats": {"total": 350, "additions": 261, "deletions": 89}, "files": [{"sha": "05f1f2bb55919cffcbd706b894950b552850cb63", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -1,3 +1,41 @@\n+2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb: Code cleanup.\n+\t* sem_ch6.adb: Code cleanup.\n+\t(Is_Matching_Limited_View): New routine.\n+\t(Matches_Limited_With_View): Reimplemented.\n+\t* sem_ch10.adb (Decorate_Type): Code cleanup.\n+\n+2016-04-21  Doug Rupp  <rupp@adacore.com>\n+\n+\t* tracebak.c (PPC ELF): Add macro defs for lynxos178e.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing): If there are overloaded\n+\tindexing functions, collect all overloadings of the call firts,\n+\tand then transfer them to indexing node, to prevent interleaving\n+\tof the set of interpretations of the nodes involved.\n+\t* sem_res.adb (Resolve): Suppress cascaded errors that report\n+\tambiguities when one of the actuals in an overloaded generatlized\n+\tindexing operation is illegal and has type Any_Type, as is done\n+\tfor similar cascaded errors in subprogram calls.\n+\t(Valid_Tagged_Conversion): Cleanup conversion checks when one\n+\tof the types involved is a class-wide subtype.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Load_Parent_Of_Generic): When looking for the\n+\tsubprogram declaration within a wrapper package, skip pragmas\n+\tthat may have been generated by aspect specifications on the\n+\tgeneric instance.\n+\n+2016-04-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Component_Not_OK_For_Backend): Generating C\n+\tcode return True for array identifiers since the backend needs\n+\tto initialize such component by means of memcpy().\n+\n 2016-04-21  Arnaud Charlet  <charlet@adacore.com>\n \n \t* a-tasatt.adb, a-tasatt.ads (Fast_Path): Rewritten to avoid reading"}, {"sha": "19ecdad97453dd99ab8276ee99b2c325b5fe4559", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -6061,6 +6061,13 @@ package body Exp_Aggr is\n             then\n                Static_Components := False;\n                return True;\n+\n+            elsif Modify_Tree_For_C\n+              and then Nkind (Expr_Q) = N_Identifier\n+              and then Is_Array_Type (Etype (Expr_Q))\n+            then\n+               Static_Components := False;\n+               return True;\n             end if;\n \n             if Is_Elementary_Type (Etype (Expr_Q)) then"}, {"sha": "c872abed6aec85ba5f608ad4b7cf816ecae828e1", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -5637,10 +5637,10 @@ package body Sem_Ch10 is\n \n          Set_Ekind             (Ent, E_Incomplete_Type);\n          Set_Etype             (Ent, Ent);\n-         Set_Scope             (Ent, Scop);\n+         Set_Full_View         (Ent, Empty);\n          Set_Is_First_Subtype  (Ent);\n+         Set_Scope             (Ent, Scop);\n          Set_Stored_Constraint (Ent, No_Elist);\n-         Set_Full_View         (Ent, Empty);\n          Init_Size_Align       (Ent);\n \n          --  A tagged type and its corresponding shadow entity share one common\n@@ -5668,16 +5668,16 @@ package body Sem_Ch10 is\n             Set_Parent (CW_Typ, Parent (Ent));\n \n             Set_Ekind                     (CW_Typ, E_Class_Wide_Type);\n-            Set_Etype                     (CW_Typ, Ent);\n-            Set_Scope                     (CW_Typ, Scop);\n-            Set_Is_Tagged_Type            (CW_Typ);\n-            Set_Is_First_Subtype          (CW_Typ);\n-            Init_Size_Align               (CW_Typ);\n-            Set_Has_Unknown_Discriminants (CW_Typ);\n             Set_Class_Wide_Type           (CW_Typ, CW_Typ);\n+            Set_Etype                     (CW_Typ, Ent);\n             Set_Equivalent_Type           (CW_Typ, Empty);\n             Set_From_Limited_With         (CW_Typ, From_Limited_With (Ent));\n+            Set_Has_Unknown_Discriminants (CW_Typ);\n+            Set_Is_First_Subtype          (CW_Typ);\n+            Set_Is_Tagged_Type            (CW_Typ);\n             Set_Materialize_Entity        (CW_Typ, Materialize);\n+            Set_Scope                     (CW_Typ, Scop);\n+            Init_Size_Align               (CW_Typ);\n          end if;\n       end Decorate_Type;\n "}, {"sha": "699ad690892a28e1f1034d79be2c9a6603fa9fdc", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -13105,18 +13105,23 @@ package body Sem_Ch12 is\n                               --  The instance_spec is in the wrapper package,\n                               --  usually followed by its local renaming\n                               --  declaration. See Build_Subprogram_Renaming\n-                              --  for details.\n+                              --  for details. If the instance carries aspects,\n+                              --  these result in the corresponding pragmas,\n+                              --  inserted after the subprogram declaration.\n+                              --  They must be skipped as well when retrieving\n+                              --  the desired spec. A direct link would be\n+                              --  more robust ???\n \n                               declare\n                                  Decl : Node_Id :=\n                                           (Last (Visible_Declarations\n                                             (Specification (Info.Act_Decl))));\n                               begin\n-                                 if Nkind (Decl) =\n-                                      N_Subprogram_Renaming_Declaration\n-                                 then\n+                                 while Nkind_In (Decl,\n+                                   N_Subprogram_Renaming_Declaration, N_Pragma)\n+                                 loop\n                                     Decl := Prev (Decl);\n-                                 end if;\n+                                 end loop;\n \n                                  Info.Act_Decl := Decl;\n                               end;"}, {"sha": "bbb10ac4edffb401a3155786fb947a419f7d3de0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -5074,7 +5074,7 @@ package body Sem_Ch3 is\n       --  inherit static and dynamic predicates if any.\n \n       --  If declaration has no aspect specifications, inherit predicate\n-      --  info as well.  Unclear how to handle the case of both specified\n+      --  info as well. Unclear how to handle the case of both specified\n       --  and inherited predicates ??? Other inherited aspects, such as\n       --  invariants, should be OK, but the combination with later pragmas\n       --  may also require special merging."}, {"sha": "5b463cbd29a9e3aa5920e89c7da1b1b69ef5df02", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -7537,27 +7537,54 @@ package body Sem_Ch4 is\n             Get_First_Interp (Func_Name, I, It);\n             Set_Etype (Indexing, Any_Type);\n \n+            --  Analyze eacn candidae function with the given actuals\n+\n             while Present (It.Nam) loop\n                Analyze_One_Call (Indexing, It.Nam, False, Success);\n+               Get_Next_Interp (I, It);\n+            end loop;\n \n-               if Success then\n+            --  If there are several successful candidates, resolution will\n+            --  be by result. Mark the interpretations of the function name\n+            --  itself.\n \n-                  --  Function in current interpretation is a valid candidate.\n-                  --  Its result type is also a potential type for the\n-                  --  original Indexed_Component node.\n+            if Is_Overloaded (Indexing) then\n+               Get_First_Interp (Indexing, I, It);\n \n+               while Present (It.Nam) loop\n                   Add_One_Interp (Name (Indexing), It.Nam, It.Typ);\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+\n+            else\n+               Set_Etype (Name (Indexing), Etype (Indexing));\n+            end if;\n+\n+            --  Now add the candidate interpretations to the indexing node\n+            --  itself, to be replaced later by the function call.\n+\n+            if Is_Overloaded (Name (Indexing)) then\n+               Get_First_Interp (Name (Indexing), I, It);\n+\n+               while Present (It.Nam) loop\n                   Add_One_Interp (N, It.Nam, It.Typ);\n \n-                  --  Add implicit dereference interpretation to original node\n+                  --  Add dereference interpretation if the result type type\n+                  --  has implicit reference discriminants.\n \n                   if Has_Discriminants (Etype (It.Nam)) then\n                      Check_Implicit_Dereference (N, Etype (It.Nam));\n                   end if;\n-               end if;\n \n-               Get_Next_Interp (I, It);\n-            end loop;\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+\n+            else\n+               Set_Etype (N, Etype (Name (Indexing)));\n+               if Has_Discriminants (Etype (N)) then\n+                  Check_Implicit_Dereference (N, Etype (N));\n+               end if;\n+            end if;\n          end;\n       end if;\n "}, {"sha": "6c5e56a666c051fd61a87b23513eaae597c44581", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 135, "deletions": 51, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -6482,45 +6482,48 @@ package body Sem_Ch6 is\n       Ctype    : Conformance_Type;\n       Get_Inst : Boolean := False) return Boolean\n    is\n-      Type_1 : Entity_Id := T1;\n-      Type_2 : Entity_Id := T2;\n-      Are_Anonymous_Access_To_Subprogram_Types : Boolean := False;\n-\n-      function Base_Types_Match (T1, T2 : Entity_Id) return Boolean;\n-      --  If neither T1 nor T2 are generic actual types, or if they are in\n-      --  different scopes (e.g. parent and child instances), then verify that\n-      --  the base types are equal. Otherwise T1 and T2 must be on the same\n-      --  subtype chain. The whole purpose of this procedure is to prevent\n-      --  spurious ambiguities in an instantiation that may arise if two\n-      --  distinct generic types are instantiated with the same actual.\n-\n-      function Find_Designated_Type (T : Entity_Id) return Entity_Id;\n+      function Base_Types_Match\n+        (Typ_1 : Entity_Id;\n+         Typ_2 : Entity_Id) return Boolean;\n+      --  If neither Typ_1 nor Typ_2 are generic actual types, or if they are\n+      --  in different scopes (e.g. parent and child instances), then verify\n+      --  that the base types are equal. Otherwise Typ_1 and Typ_2 must be on\n+      --  the same subtype chain. The whole purpose of this procedure is to\n+      --  prevent spurious ambiguities in an instantiation that may arise if\n+      --  two distinct generic types are instantiated with the same actual.\n+\n+      function Find_Designated_Type (Typ : Entity_Id) return Entity_Id;\n       --  An access parameter can designate an incomplete type. If the\n       --  incomplete type is the limited view of a type from a limited_\n-      --  with_clause, check whether the non-limited view is available. If\n-      --  it is a (non-limited) incomplete type, get the full view.\n-\n-      function Matches_Limited_With_View (T1, T2 : Entity_Id) return Boolean;\n-      --  Returns True if and only if either T1 denotes a limited view of T2\n-      --  or T2 denotes a limited view of T1. This can arise when the limited\n-      --  with view of a type is used in a subprogram declaration and the\n-      --  subprogram body is in the scope of a regular with clause for the\n-      --  same unit. In such a case, the two type entities can be considered\n+      --  with_clause, check whether the non-limited view is available.\n+      --  If it is a (non-limited) incomplete type, get the full view.\n+\n+      function Matches_Limited_With_View\n+        (Typ_1 : Entity_Id;\n+         Typ_2 : Entity_Id) return Boolean;\n+      --  Returns True if and only if either Typ_1 denotes a limited view of\n+      --  Typ_2 or Typ_2 denotes a limited view of Typ_1. This can arise when\n+      --  the limited with view of a type is used in a subprogram declaration\n+      --  and the subprogram body is in the scope of a regular with clause for\n+      --  the same unit. In such a case, the two type entities are considered\n       --  identical for purposes of conformance checking.\n \n       ----------------------\n       -- Base_Types_Match --\n       ----------------------\n \n-      function Base_Types_Match (T1, T2 : Entity_Id) return Boolean is\n-         BT1 : constant Entity_Id := Base_Type (T1);\n-         BT2 : constant Entity_Id := Base_Type (T2);\n+      function Base_Types_Match\n+        (Typ_1 : Entity_Id;\n+         Typ_2 : Entity_Id) return Boolean\n+      is\n+         Base_1 : constant Entity_Id := Base_Type (Typ_1);\n+         Base_2 : constant Entity_Id := Base_Type (Typ_2);\n \n       begin\n-         if T1 = T2 then\n+         if Typ_1 = Typ_2 then\n             return True;\n \n-         elsif BT1 = BT2 then\n+         elsif Base_1 = Base_2 then\n \n             --  The following is too permissive. A more precise test should\n             --  check that the generic actual is an ancestor subtype of the\n@@ -6529,18 +6532,23 @@ package body Sem_Ch6 is\n             --  See code in Find_Corresponding_Spec that applies an additional\n             --  filter to handle accidental amiguities in instances.\n \n-            return not Is_Generic_Actual_Type (T1)\n-              or else not Is_Generic_Actual_Type (T2)\n-              or else Scope (T1) /= Scope (T2);\n+            return\n+              not Is_Generic_Actual_Type (Typ_1)\n+                or else not Is_Generic_Actual_Type (Typ_2)\n+                or else Scope (Typ_1) /= Scope (Typ_2);\n \n-         --  If T2 is a generic actual type it is declared as the subtype of\n+         --  If Typ_2 is a generic actual type it is declared as the subtype of\n          --  the actual. If that actual is itself a subtype we need to use its\n          --  own base type to check for compatibility.\n \n-         elsif Ekind (BT2) = Ekind (T2) and then BT1 = Base_Type (BT2) then\n+         elsif Ekind (Base_2) = Ekind (Typ_2)\n+           and then Base_1 = Base_Type (Base_2)\n+         then\n             return True;\n \n-         elsif Ekind (BT1) = Ekind (T1) and then BT2 = Base_Type (BT1) then\n+         elsif Ekind (Base_1) = Ekind (Typ_1)\n+           and then Base_2 = Base_Type (Base_1)\n+         then\n             return True;\n \n          else\n@@ -6552,11 +6560,11 @@ package body Sem_Ch6 is\n       -- Find_Designated_Type --\n       --------------------------\n \n-      function Find_Designated_Type (T : Entity_Id) return Entity_Id is\n+      function Find_Designated_Type (Typ : Entity_Id) return Entity_Id is\n          Desig : Entity_Id;\n \n       begin\n-         Desig := Directly_Designated_Type (T);\n+         Desig := Directly_Designated_Type (Typ);\n \n          if Ekind (Desig) = E_Incomplete_Type then\n \n@@ -6580,39 +6588,115 @@ package body Sem_Ch6 is\n       -- Matches_Limited_With_View --\n       -------------------------------\n \n-      function Matches_Limited_With_View (T1, T2 : Entity_Id) return Boolean is\n+      function Matches_Limited_With_View\n+        (Typ_1 : Entity_Id;\n+         Typ_2 : Entity_Id) return Boolean\n+      is\n+         function Is_Matching_Limited_View\n+           (Typ  : Entity_Id;\n+            View : Entity_Id) return Boolean;\n+         --  Determine whether non-limited view View denotes type Typ in some\n+         --  conformant fashion.\n+\n+         ------------------------------\n+         -- Is_Matching_Limited_View --\n+         ------------------------------\n+\n+         function Is_Matching_Limited_View\n+           (Typ  : Entity_Id;\n+            View : Entity_Id) return Boolean\n+         is\n+            Root_Typ  : Entity_Id;\n+            Root_View : Entity_Id;\n+\n+         begin\n+            --  The non-limited view directly denotes the type\n+\n+            if Typ = View then\n+               return True;\n+\n+            --  The type is a subtype of the non-limited view\n+\n+            elsif Is_Subtype_Of (Typ, View) then\n+               return True;\n+\n+            --  Both the non-limited view and the type denote class-wide types\n+\n+            elsif Is_Class_Wide_Type (Typ)\n+              and then Is_Class_Wide_Type (View)\n+            then\n+               Root_Typ  := Root_Type (Typ);\n+               Root_View := Root_Type (View);\n+\n+               if Root_Typ = Root_View then\n+                  return True;\n+\n+               --  An incomplete tagged type and its full view may receive two\n+               --  distinct class-wide types when the related package has not\n+               --  been analyzed yet.\n+\n+               --    package Pack is\n+               --       type T is tagged;              --  CW_1\n+               --       type T is tagged null record;  --  CW_2\n+               --    end Pack;\n+\n+               --  This is because the package lacks any semantic information\n+               --  that may eventually link both views of T. As a consequence,\n+               --  a client of the limited view of Pack will see CW_2 while a\n+               --  client of the non-limited view of Pack will see CW_1.\n+\n+               elsif Is_Incomplete_Type (Root_Typ)\n+                 and then Present (Full_View (Root_Typ))\n+                 and then Full_View (Root_Typ) = Root_View\n+               then\n+                  return True;\n+\n+               elsif Is_Incomplete_Type (Root_View)\n+                 and then Present (Full_View (Root_View))\n+                 and then Full_View (Root_View) = Root_Typ\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            return False;\n+         end Is_Matching_Limited_View;\n+\n+      --  Start of processing for Matches_Limited_With_View\n+\n       begin\n          --  In some cases a type imported through a limited_with clause, and\n-         --  its nonlimited view are both visible, for example in an anonymous\n+         --  its non-limited view are both visible, for example in an anonymous\n          --  access-to-class-wide type in a formal, or when building the body\n          --  for a subprogram renaming after the subprogram has been frozen.\n-         --  In these cases Both entities designate the same type. In addition,\n+         --  In these cases both entities designate the same type. In addition,\n          --  if one of them is an actual in an instance, it may be a subtype of\n          --  the non-limited view of the other.\n \n-         if From_Limited_With (T1)\n-           and then (T2 = Available_View (T1)\n-                      or else Is_Subtype_Of (T2, Available_View (T1)))\n+         if From_Limited_With (Typ_1)\n+           and then From_Limited_With (Typ_2)\n+           and then Available_View (Typ_1) = Available_View (Typ_2)\n          then\n             return True;\n \n-         elsif From_Limited_With (T2)\n-           and then (T1 = Available_View (T2)\n-                      or else Is_Subtype_Of (T1, Available_View (T2)))\n-         then\n-            return True;\n+         elsif From_Limited_With (Typ_1) then\n+            return Is_Matching_Limited_View (Typ_2, Available_View (Typ_1));\n \n-         elsif From_Limited_With (T1)\n-           and then From_Limited_With (T2)\n-           and then Available_View (T1) = Available_View (T2)\n-         then\n-            return True;\n+         elsif From_Limited_With (Typ_2) then\n+            return Is_Matching_Limited_View (Typ_1, Available_View (Typ_2));\n \n          else\n             return False;\n          end if;\n       end Matches_Limited_With_View;\n \n+      --  Local variables\n+\n+      Are_Anonymous_Access_To_Subprogram_Types : Boolean := False;\n+\n+      Type_1 : Entity_Id := T1;\n+      Type_2 : Entity_Id := T2;\n+\n    --  Start of processing for Conforming_Types\n \n    begin"}, {"sha": "c6effa379dee13b501d4d6e2e90b64f2bedc5b31", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2248,17 +2248,25 @@ package body Sem_Res is\n                      end loop;\n \n                   else\n-                     --  Before we issue an ambiguity complaint, check for\n-                     --  the case of a subprogram call where at least one\n-                     --  of the arguments is Any_Type, and if so, suppress\n-                     --  the message, since it is a cascaded error.\n-\n-                     if Nkind (N) in N_Subprogram_Call then\n+                     --  Before we issue an ambiguity complaint, check for the\n+                     --  case of a subprogram call where at least one of the\n+                     --  arguments is Any_Type, and if so suppress the message,\n+                     --  since it is a cascaded error. This can also happen for\n+                     --  a generalized indexing operation.\n+\n+                     if Nkind (N) in N_Subprogram_Call\n+                       or else (Nkind (N) = N_Indexed_Component\n+                                 and then Present (Generalized_Indexing (N)))\n+                     then\n                         declare\n                            A : Node_Id;\n                            E : Node_Id;\n \n                         begin\n+                           if Nkind (N) = N_Indexed_Component then\n+                              Rewrite (N, Generalized_Indexing (N));\n+                           end if;\n+\n                            A := First_Actual (N);\n                            while Present (A) loop\n                               E := A;\n@@ -2292,17 +2300,17 @@ package body Sem_Res is\n                         exit Interp_Loop;\n                      end if;\n \n-                     --  Not that special case, so issue message using the\n-                     --  flag Ambiguous to control printing of the header\n-                     --  message only at the start of an ambiguous set.\n+                     --  Not that special case, so issue message using the flag\n+                     --  Ambiguous to control printing of the header message\n+                     --  only at the start of an ambiguous set.\n \n                      if not Ambiguous then\n                         if Nkind (N) = N_Function_Call\n                           and then Nkind (Name (N)) = N_Explicit_Dereference\n                         then\n                            Error_Msg_N\n-                             (\"ambiguous expression \"\n-                               & \"(cannot resolve indirect call)!\", N);\n+                             (\"ambiguous expression (cannot resolve indirect \"\n+                              & \"call)!\", N);\n                         else\n                            Error_Msg_NE -- CODEFIX\n                              (\"ambiguous expression (cannot resolve&)!\",\n@@ -11836,9 +11844,11 @@ package body Sem_Res is\n                 \"downward conversion of tagged objects not allowed\");\n \n          --  Ada 2005 (AI-251): The conversion to/from interface types is\n-         --  always valid\n+         --  always valid. The types involved may be class-wide (sub)types.\n \n-         elsif Is_Interface (Target_Type) or else Is_Interface (Opnd_Type) then\n+         elsif Is_Interface (Etype (Base_Type (Target_Type)))\n+           or else Is_Interface (Etype (Base_Type (Opnd_Type)))\n+         then\n             return True;\n \n          --  If the operand is a class-wide type obtained through a limited_"}, {"sha": "7b1849bdf03eef343507a38970e849a200d93a2b", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310af44bbc4c372246641d891de639f96c15971/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=0310af44bbc4c372246641d891de639f96c15971", "patch": "@@ -354,9 +354,10 @@ extern void __runnit(); /* thread entry point.  */\n \n #define BASE_SKIP 1\n \n-/*-------------------- PPC ELF (GNU/Linux & VxWorks) ---------------------*/\n+/*----------- PPC ELF (GNU/Linux & VxWorks & Lynx178e) -------------------*/\n \n #elif (defined (_ARCH_PPC) && defined (__vxworks)) ||  \\\n+  (defined (__powerpc__) && defined (__Lynx__) && defined(__ELF__)) || \\\n   (defined (__linux__) && defined (__powerpc__))\n \n #define USE_GENERIC_UNWINDER"}]}