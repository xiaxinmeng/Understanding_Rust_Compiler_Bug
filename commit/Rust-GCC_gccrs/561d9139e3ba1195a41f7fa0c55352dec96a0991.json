{"sha": "561d9139e3ba1195a41f7fa0c55352dec96a0991", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxZDkxMzllM2JhMTE5NWE0MWY3ZmEwYzU1MzUyZGVjOTZhMDk5MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2006-02-15T09:44:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:44:09Z"}, "message": "sem_ch10.adb (Check_Redundant_Withs): New procedure in Analyze_Compilation_Unit.\n\n2006-02-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch10.adb (Check_Redundant_Withs): New procedure in\n\tAnalyze_Compilation_Unit.\n\tDetect and warn on redundant with clauses detected in a package spec\n\tand/or body when -gnatwr is used.\n\t(Analyze_Context): Analyze config pragmas before other items\n\t(Install_Context_Items): Don't analyze config pragmas here\n\t(Install_Limited_Withed_Unit): Set limited entity of package in\n\twith_clause so that cross-reference information or warning messages on\n\tunused packages can be properly generated\n\t(Is_Visible_Through_Renamings): Return false if the limited_with_clause\n\thas Error_Posted set. Prevent infinite loops in illegal programs.\n\t(Check_Private_Child_Unit): Move test for a nonprivate with clause down\n\tto the point of the error test requiring the current unit to be private.\n\tThis ensures that private with clauses are not exempted from the basic\n\tchecking for being a descendant of the same library unit parent as a\n\twithed private descendant unit.\n\t(Check_Private_Limited_Withed_Unit): Revise the checking algorithm to\n\thandle private with clauses properly, as well as to account for cases\n\twhere the withed unit is a public descendant of a private ancestor\n\t(in which case the current unit must be a descendant of the private\n\tancestor's parent). The spec comments were updated accordingly. Also,\n\tthe old error message in this subprogram was replaced with error\n\tmessages that mirror the errors tested and reported by\n\tCheck_Private_Child_Unit.\n\tParameter and variable names improved for readability.\n\t(Install_Limited_Context_Clauses): Remove test for a withed unit being\n\tprivate as the precondition for calling\n\tCheck_Private_Limited_Withed_Unit since that subprogram has been\n\trevised to test public units as well as private units.\n\nFrom-SVN: r111090", "tree": {"sha": "31e96b20adcc6c35c222fe86b650ca0862a63abc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e96b20adcc6c35c222fe86b650ca0862a63abc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561d9139e3ba1195a41f7fa0c55352dec96a0991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561d9139e3ba1195a41f7fa0c55352dec96a0991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561d9139e3ba1195a41f7fa0c55352dec96a0991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561d9139e3ba1195a41f7fa0c55352dec96a0991/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8dc622e9fc08c74a749eb81503f795363625d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8dc622e9fc08c74a749eb81503f795363625d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8dc622e9fc08c74a749eb81503f795363625d12"}], "stats": {"total": 509, "additions": 457, "deletions": 52}, "files": [{"sha": "00df65bb0dcb18eba8152a270800b1b6ee5ade61", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 457, "deletions": 52, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561d9139e3ba1195a41f7fa0c55352dec96a0991/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561d9139e3ba1195a41f7fa0c55352dec96a0991/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=561d9139e3ba1195a41f7fa0c55352dec96a0991", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -239,10 +239,305 @@ package body Sem_Ch10 is\n       Par_Spec_Name : Unit_Name_Type;\n       Unum          : Unit_Number_Type;\n \n+      procedure Check_Redundant_Withs\n+        (Context_Items      : List_Id;\n+         Spec_Context_Items : List_Id := No_List);\n+      --  Determine whether the context list of a compilation unit contains\n+      --  redundant with clauses. When checking body clauses against spec\n+      --  clauses, set Context_Items to the context list of the body and\n+      --  Spec_Context_Items to that of the spec. Parent packages are not\n+      --  examined for documentation purposes.\n+\n       procedure Generate_Parent_References (N : Node_Id; P_Id : Entity_Id);\n       --  Generate cross-reference information for the parents of child units.\n       --  N is a defining_program_unit_name, and P_Id is the immediate parent.\n \n+      ---------------------------\n+      -- Check_Redundant_Withs --\n+      ---------------------------\n+\n+      procedure Check_Redundant_Withs\n+        (Context_Items      : List_Id;\n+         Spec_Context_Items : List_Id := No_List)\n+      is\n+         Clause : Node_Id;\n+\n+         procedure Process_Body_Clauses\n+          (Context_List      : List_Id;\n+           Clause            : Node_Id;\n+           Used              : in out Boolean;\n+           Used_Type_Or_Elab : in out Boolean);\n+         --  Examine the context clauses of a package body, trying to match\n+         --  the name entity of Clause with any list element. If the match\n+         --  occurs on a use package clause, set Used to True, for a use\n+         --  type clause, pragma Elaborate or pragma Elaborate_All, set\n+         --  Used_Type_Or_Elab to True.\n+\n+         procedure Process_Spec_Clauses\n+          (Context_List : List_Id;\n+           Clause       : Node_Id;\n+           Used         : in out Boolean;\n+           Withed       : in out Boolean;\n+           Exit_On_Self : Boolean := False);\n+         --  Examine the context clauses of a package spec, trying to match\n+         --  the name entity of Clause with any list element. If the match\n+         --  occurs on a use package clause, set Used to True, for a with\n+         --  package clause other than Clause, set Withed to True. Limited\n+         --  with clauses, implicitly generated with clauses and withs\n+         --  having pragmas Elaborate or Elaborate_All applied to them are\n+         --  skipped. Exit_On_Self is used to control the search loop and\n+         --  force an exit whenever Clause sees itself in the search.\n+\n+         --------------------------\n+         -- Process_Body_Clauses --\n+         --------------------------\n+\n+         procedure Process_Body_Clauses\n+          (Context_List      : List_Id;\n+           Clause            : Node_Id;\n+           Used              : in out Boolean;\n+           Used_Type_Or_Elab : in out Boolean)\n+         is\n+            Nam_Ent   : constant Entity_Id := Entity (Name (Clause));\n+            Cont_Item : Node_Id;\n+            Prag_Unit : Node_Id;\n+            Subt_Mark : Node_Id;\n+            Use_Item  : Node_Id;\n+\n+         begin\n+            Used := False;\n+            Used_Type_Or_Elab := False;\n+\n+            Cont_Item := First (Context_List);\n+            while Present (Cont_Item) loop\n+\n+               --  Package use clause\n+\n+               if Nkind (Cont_Item) = N_Use_Package_Clause\n+                 and then not Used\n+               then\n+                  Use_Item := First (Names (Cont_Item));\n+                  while Present (Use_Item) and then not Used loop\n+                     if Entity (Use_Item) = Nam_Ent then\n+                        Used := True;\n+                     end if;\n+\n+                     Next (Use_Item);\n+                  end loop;\n+\n+               --  Type use clause\n+\n+               elsif Nkind (Cont_Item) = N_Use_Type_Clause\n+                 and then not Used_Type_Or_Elab\n+               then\n+                  Subt_Mark := First (Subtype_Marks (Cont_Item));\n+                  while Present (Subt_Mark)\n+                    and then not Used_Type_Or_Elab\n+                  loop\n+                     if Entity (Prefix (Subt_Mark)) = Nam_Ent then\n+                        Used_Type_Or_Elab := True;\n+                     end if;\n+\n+                     Next (Subt_Mark);\n+                  end loop;\n+\n+               --  Pragma Elaborate or Elaborate_All\n+\n+               elsif Nkind (Cont_Item) = N_Pragma\n+                 and then\n+                   (Chars (Cont_Item) = Name_Elaborate\n+                      or else\n+                    Chars (Cont_Item) = Name_Elaborate_All)\n+                 and then not Used_Type_Or_Elab\n+               then\n+                  Prag_Unit :=\n+                    First (Pragma_Argument_Associations (Cont_Item));\n+                  while Present (Prag_Unit)\n+                    and then not Used_Type_Or_Elab\n+                  loop\n+                     if Entity (Expression (Prag_Unit)) = Nam_Ent then\n+                        Used_Type_Or_Elab := True;\n+                     end if;\n+\n+                     Next (Prag_Unit);\n+                  end loop;\n+               end if;\n+\n+               Next (Cont_Item);\n+            end loop;\n+         end Process_Body_Clauses;\n+\n+         --------------------------\n+         -- Process_Spec_Clauses --\n+         --------------------------\n+\n+         procedure Process_Spec_Clauses\n+          (Context_List : List_Id;\n+           Clause       : Node_Id;\n+           Used         : in out Boolean;\n+           Withed       : in out Boolean;\n+           Exit_On_Self : Boolean := False)\n+         is\n+            Nam_Ent   : constant Entity_Id := Entity (Name (Clause));\n+            Cont_Item : Node_Id;\n+            Use_Item  : Node_Id;\n+\n+         begin\n+            Used := False;\n+            Withed := False;\n+\n+            Cont_Item := First (Context_List);\n+            while Present (Cont_Item) loop\n+\n+               --  Stop the search since the context items after Cont_Item\n+               --  have already been examined in a previous iteration of\n+               --  the reverse loop in Check_Redundant_Withs.\n+\n+               if Exit_On_Self\n+                 and Cont_Item = Clause\n+               then\n+                  exit;\n+               end if;\n+\n+               --  Package use clause\n+\n+               if Nkind (Cont_Item) = N_Use_Package_Clause\n+                 and then not Used\n+               then\n+                  Use_Item := First (Names (Cont_Item));\n+                  while Present (Use_Item) and then not Used loop\n+                     if Entity (Use_Item) = Nam_Ent then\n+                        Used := True;\n+                     end if;\n+\n+                     Next (Use_Item);\n+                  end loop;\n+\n+               --  Package with clause. Avoid processing self, implicitly\n+               --  generated with clauses or limited with clauses. Note\n+               --  that we examine with clauses having pragmas Elaborate\n+               --  or Elaborate_All applied to them due to cases such as:\n+               --\n+               --     with Pack;\n+               --     with Pack;\n+               --     pragma Elaborate (Pack);\n+               --\n+               --  In this case, the second with clause is redundant since\n+               --  the pragma applies only to the first \"with Pack;\".\n+\n+               elsif Nkind (Cont_Item) = N_With_Clause\n+                 and then not Implicit_With (Cont_Item)\n+                 and then not Limited_Present (Cont_Item)\n+                 and then Cont_Item /= Clause\n+                 and then Entity (Name (Cont_Item)) = Nam_Ent\n+               then\n+                  Withed := True;\n+               end if;\n+\n+               Next (Cont_Item);\n+            end loop;\n+         end Process_Spec_Clauses;\n+\n+      --  Start of processing for Check_Redundant_Withs\n+\n+      begin\n+         Clause := Last (Context_Items);\n+         while Present (Clause) loop\n+\n+            --  Avoid checking implicitly generated with clauses, limited\n+            --  with clauses or withs that have pragma Elaborate or\n+            --  Elaborate_All apllied.\n+\n+            if Nkind (Clause) = N_With_Clause\n+              and then not Implicit_With (Clause)\n+              and then not Limited_Present (Clause)\n+              and then not Elaborate_Present (Clause)\n+            then\n+               --  Package body-to-spec check\n+\n+               if Present (Spec_Context_Items) then\n+                  declare\n+                     Used_In_Body      : Boolean := False;\n+                     Used_In_Spec      : Boolean := False;\n+                     Used_Type_Or_Elab : Boolean := False;\n+                     Withed_In_Spec    : Boolean := False;\n+\n+                  begin\n+                     Process_Spec_Clauses\n+                      (Context_List => Spec_Context_Items,\n+                       Clause       => Clause,\n+                       Used         => Used_In_Spec,\n+                       Withed       => Withed_In_Spec);\n+\n+                     Process_Body_Clauses\n+                      (Context_List      => Context_Items,\n+                       Clause            => Clause,\n+                       Used              => Used_In_Body,\n+                       Used_Type_Or_Elab => Used_Type_Or_Elab);\n+\n+                     --  \"Type Elab\" refers to the presence of either a use\n+                     --  type clause, pragmas Elaborate or Elaborate_All.\n+\n+                     --  +---------------+---------------------------+------+\n+                     --  | Spec          | Body                      | Warn |\n+                     --  +--------+------+--------+------+-----------+------+\n+                     --  | Withed | Used | Withed | Used | Type Elab |      |\n+                     --  |   X    |      |   X    |      |           |  X   |\n+                     --  |   X    |      |   X    |  X   |           |      |\n+                     --  |   X    |      |   X    |      |     X     |      |\n+                     --  |   X    |      |   X    |  X   |     X     |      |\n+                     --  |   X    |  X   |   X    |      |           |  X   |\n+                     --  |   X    |  X   |   X    |      |     X     |      |\n+                     --  |   X    |  X   |   X    |  X   |           |  X   |\n+                     --  |   X    |  X   |   X    |  X   |     X     |      |\n+                     --  +--------+------+--------+------+-----------+------+\n+\n+                     if (Withed_In_Spec\n+                           and then not Used_Type_Or_Elab)\n+                             and then\n+                               ((not Used_In_Spec\n+                                   and then not Used_In_Body)\n+                                     or else\n+                                       Used_In_Spec)\n+                     then\n+                        Error_Msg_N (\"?redundant with clause in body\", Clause);\n+                     end if;\n+\n+                     Used_In_Body := False;\n+                     Used_In_Spec := False;\n+                     Used_Type_Or_Elab := False;\n+                     Withed_In_Spec := False;\n+                  end;\n+\n+               --  Standalone package spec or body check\n+\n+               else\n+                  declare\n+                     Dont_Care : Boolean := False;\n+                     Withed    : Boolean := False;\n+\n+                  begin\n+                     --  The mechanism for examining the context clauses of a\n+                     --  package spec can be applied to package body clauses.\n+\n+                     Process_Spec_Clauses\n+                      (Context_List => Context_Items,\n+                       Clause       => Clause,\n+                       Used         => Dont_Care,\n+                       Withed       => Withed,\n+                       Exit_On_Self => True);\n+\n+                     if Withed then\n+                        Error_Msg_N (\"?redundant with clause\", Clause);\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+\n+            Prev (Clause);\n+         end loop;\n+      end Check_Redundant_Withs;\n+\n       --------------------------------\n       -- Generate_Parent_References --\n       --------------------------------\n@@ -483,6 +778,16 @@ package body Sem_Ch10 is\n \n       Analyze (Unit_Node);\n \n+      if Warn_On_Redundant_Constructs then\n+         Check_Redundant_Withs (Context_Items (N));\n+\n+         if Nkind (Unit_Node) = N_Package_Body then\n+            Check_Redundant_Withs\n+              (Context_Items      => Context_Items (N),\n+               Spec_Context_Items => Context_Items (Lib_Unit));\n+         end if;\n+      end if;\n+\n       --  The above call might have made Unit_Node an N_Subprogram_Body\n       --  from something else, so propagate any Acts_As_Spec flag.\n \n@@ -802,11 +1107,30 @@ package body Sem_Ch10 is\n       Item  : Node_Id;\n \n    begin\n-      --  Loop through context items. This is done in two:\n-      --  a) The first  pass analyzes non-limited with-clauses\n-      --  b) The second pass analyzes limited_with clauses (Ada 2005: AI-50217)\n+      --  First process all configuration pragmas at the start of the context\n+      --  items. Strictly these are not part of the context clause, but that\n+      --  is where the parser puts them. In any case for sure we must analyze\n+      --  these before analyzing the actual context items, since they can have\n+      --  an effect on that analysis (e.g. pragma Ada_2005 may allow a unit to\n+      --  be with'ed as a result of changing categorizations in Ada 2005).\n \n       Item := First (Context_Items (N));\n+      while Present (Item)\n+        and then Nkind (Item) = N_Pragma\n+        and then Chars (Item) in Configuration_Pragma_Names\n+      loop\n+         Analyze (Item);\n+         Next (Item);\n+      end loop;\n+\n+      --  Loop through actual context items. This is done in two passes:\n+\n+      --  a) The first pass analyzes non-limited with-clauses and also any\n+      --     configuration pragmas (we need to get the latter analyzed right\n+      --     away, since they can affect processing of subsequent items.\n+\n+      --  b) The second pass analyzes limited_with clauses (Ada 2005: AI-50217)\n+\n       while Present (Item) loop\n \n          --  For with clause, analyze the with clause, and then update\n@@ -826,12 +1150,16 @@ package body Sem_Ch10 is\n                Version_Update (N, Library_Unit (Item));\n             end if;\n \n-         --  But skip use clauses at this stage, since we don't want to do\n-         --  any installing of potentially use visible entities until we\n-         --  we actually install the complete context (in Install_Context).\n+         --  Skip pragmas. Configuration pragmas at the start were handled in\n+         --  the loop above, and remaining pragmas are not processed until we\n+         --  actually install the context (see Install_Context). We delay the\n+         --  analysis of these pragmas to make sure that we have installed all\n+         --  the implicit with's on parent units.\n+\n+         --  Skip use clauses at this stage, since we don't want to do any\n+         --  installing of potentially use visible entities until we we\n+         --  actually install the complete context (in Install_Context).\n          --  Otherwise things can get installed in the wrong context.\n-         --  Similarly, pragmas are analyzed in Install_Context, after all\n-         --  the implicit with's on parent units are generated.\n \n          else\n             null;\n@@ -840,7 +1168,8 @@ package body Sem_Ch10 is\n          Next (Item);\n       end loop;\n \n-      --  Second pass: examine all limited_with clauses\n+      --  Second pass: examine all limited_with clauses. All other context\n+      --  items are ignored in this pass.\n \n       Item := First (Context_Items (N));\n       while Present (Item) loop\n@@ -978,6 +1307,12 @@ package body Sem_Ch10 is\n             if not Implicit_With (Item) then\n                Version_Update (N, Library_Unit (Item));\n             end if;\n+\n+            --  Pragmas and use clauses and with clauses other than limited\n+            --  with's are ignored in this pass through the context items.\n+\n+         else\n+            null;\n          end if;\n \n          Next (Item);\n@@ -1215,7 +1550,7 @@ package body Sem_Ch10 is\n                Error_Msg_Name_2 :=\n                  Get_File_Name (Subunit_Name, Subunit => True);\n                Error_Msg_N\n-                 (\"subunit% in file{ not found!?\", N);\n+                 (\"subunit% in file{ not found?\", N);\n                Subunits_Missing := True;\n             end if;\n \n@@ -2377,7 +2712,6 @@ package body Sem_Ch10 is\n \n          if Nkind (Item) = N_With_Clause\n             and then not Implicit_With (Item)\n-            and then not Private_Present (Item)\n             and then Is_Private_Descendant (Entity (Name (Item)))\n          then\n             Priv_Child := Entity (Name (Item));\n@@ -2414,12 +2748,11 @@ package body Sem_Ch10 is\n                   Curr_Parent := Scope (Curr_Parent);\n                end loop;\n \n-               if not Present (Curr_Parent) then\n+               if No (Curr_Parent) then\n                   Curr_Parent := Standard_Standard;\n                end if;\n \n                if Curr_Parent /= Child_Parent then\n-\n                   if Ekind (Priv_Child) = E_Generic_Package\n                     and then Chars (Priv_Child) in Text_IO_Package_Name\n                     and then Chars (Scope (Scope (Priv_Child))) = Name_Ada\n@@ -2437,6 +2770,7 @@ package body Sem_Ch10 is\n                   end if;\n \n                elsif not Curr_Private\n+                 and then not Private_Present (Item)\n                  and then Nkind (Lib_Unit) /= N_Package_Body\n                  and then Nkind (Lib_Unit) /= N_Subprogram_Body\n                  and then Nkind (Lib_Unit) /= N_Subunit\n@@ -2739,11 +3073,22 @@ package body Sem_Ch10 is\n       Lib_Parent    : Entity_Id;\n \n    begin\n-      --  Loop through context clauses to find the with/use clauses.\n-      --  This is done twice, first for everything except limited_with\n-      --  clauses, and then for those, if any are present.\n+      --  First skip configuration pragmas at the start of the context. They\n+      --  are not technically part of the context clause, but that's where the\n+      --  parser puts them. Note they were analyzed in Analyze_Context.\n \n       Item := First (Context_Items (N));\n+      while Present (Item)\n+        and then Nkind (Item) = N_Pragma\n+        and then Chars (Item) in Configuration_Pragma_Names\n+      loop\n+         Next (Item);\n+      end loop;\n+\n+      --  Loop through the actual context clause items. We process everything\n+      --  except Limited_With clauses in this routine. Limited_With clauses\n+      --  are separately installed (see Install_Limited_Context_Clauses).\n+\n       while Present (Item) loop\n \n          --  Case of explicit WITH clause\n@@ -2993,11 +3338,11 @@ package body Sem_Ch10 is\n       --  Check that the unlimited view of a given compilation_unit is not\n       --  already visible through \"use + renamings\".\n \n-      procedure Check_Private_Limited_Withed_Unit (N : Node_Id);\n+      procedure Check_Private_Limited_Withed_Unit (Item : Node_Id);\n       --  Check that if a limited_with clause of a given compilation_unit\n-      --  mentions a private child of some library unit, then the given\n-      --  compilation_unit shall be the declaration of a private descendant\n-      --  of that library unit.\n+      --  mentions a descendant of a private child of some library unit,\n+      --  then the given compilation_unit shall be the declaration of a\n+      --  private descendant of that library unit.\n \n       procedure Expand_Limited_With_Clause\n         (Comp_Unit : Node_Id; Nam : Node_Id; N : Node_Id);\n@@ -3098,40 +3443,60 @@ package body Sem_Ch10 is\n       -- Check_Private_Limited_Withed_Unit --\n       ---------------------------------------\n \n-      procedure Check_Private_Limited_Withed_Unit (N : Node_Id) is\n-         C     : Node_Id;\n-         P     : Node_Id;\n-         Found : Boolean := False;\n+      procedure Check_Private_Limited_Withed_Unit (Item : Node_Id) is\n+         Curr_Parent  : Node_Id;\n+         Child_Parent : Node_Id;\n \n       begin\n-         --  If the current compilation unit is not private we don't\n-         --  need to check anything else.\n-\n-         if not Private_Present (Parent (N)) then\n-            Found := False;\n+         --  Compilation unit of the parent of the withed library unit\n \n-         else\n-            --  Compilation unit of the parent of the withed library unit\n+         Child_Parent := Parent_Spec (Unit (Library_Unit (Item)));\n \n-            P := Parent_Spec (Unit (Library_Unit (N)));\n+         --  If the child unit is a public child, then locate its nearest\n+         --  private ancestor, if any; Child_Parent will then be set to\n+         --  the parent of that ancestor.\n \n-            --  Traverse all the ancestors of the current compilation\n-            --  unit to check if it is a descendant of named library unit.\n+         if not Private_Present (Library_Unit (Item)) then\n+            while Present (Child_Parent)\n+              and then not Private_Present (Child_Parent)\n+            loop\n+               Child_Parent := Parent_Spec (Unit (Child_Parent));\n+            end loop;\n \n-            C := Parent (N);\n-            while Present (Parent_Spec (Unit (C))) loop\n-               C := Parent_Spec (Unit (C));\n+            if No (Child_Parent) then\n+               return;\n+            end if;\n \n-               if C = P then\n-                  Found := True;\n-                  exit;\n-               end if;\n-            end loop;\n+            Child_Parent := Parent_Spec (Unit (Child_Parent));\n          end if;\n \n-         if not Found then\n-            Error_Msg_N (\"current unit is not a private descendant\"\n-                         & \" of the withed unit ('R'M 10.1.2(8)\", N);\n+         --  Traverse all the ancestors of the current compilation\n+         --  unit to check if it is a descendant of named library unit.\n+\n+         Curr_Parent := Parent (Item);\n+\n+         while Present (Parent_Spec (Unit (Curr_Parent)))\n+           and then Curr_Parent /= Child_Parent\n+         loop\n+            Curr_Parent := Parent_Spec (Unit (Curr_Parent));\n+         end loop;\n+\n+         if Curr_Parent /= Child_Parent then\n+            Error_Msg_N\n+              (\"unit in with clause is private child unit!\", Item);\n+            Error_Msg_NE\n+              (\"current unit must also have parent&!\",\n+               Item, Defining_Unit_Name (Specification (Unit (Child_Parent))));\n+\n+         elsif not Private_Present (Parent (Item))\n+           and then not Private_Present (Item)\n+           and then Nkind (Unit (Parent (Item))) /= N_Package_Body\n+           and then Nkind (Unit (Parent (Item))) /= N_Subprogram_Body\n+           and then Nkind (Unit (Parent (Item))) /= N_Subunit\n+         then\n+            Error_Msg_NE\n+              (\"current unit must also be private descendant of&\",\n+               Item, Defining_Unit_Name (Specification (Unit (Child_Parent))));\n          end if;\n       end Check_Private_Limited_Withed_Unit;\n \n@@ -3194,7 +3559,7 @@ package body Sem_Ch10 is\n             Withn :=\n               Make_With_Clause (Loc,\n                 Name => Make_Selected_Component (Loc,\n-                  Prefix        => Prefix (Nam),\n+                  Prefix        => New_Copy_Tree (Prefix (Nam)),\n                   Selector_Name => Selector_Name (Nam)));\n             Set_Parent (Withn, Parent (N));\n          end if;\n@@ -3256,9 +3621,7 @@ package body Sem_Ch10 is\n                  (Comp_Unit => N, Nam => Prefix (Name (Item)), N => Item);\n             end if;\n \n-            if Private_Present (Library_Unit (Item)) then\n-               Check_Private_Limited_Withed_Unit (Item);\n-            end if;\n+            Check_Private_Limited_Withed_Unit (Item);\n \n             if not Implicit_With (Item)\n               and then Is_Child_Spec (Unit (N))\n@@ -3276,6 +3639,12 @@ package body Sem_Ch10 is\n             then\n                Install_Limited_Withed_Unit (Item);\n             end if;\n+\n+         --  All items other than Limited_With clauses are ignored (they were\n+         --  installed separately early on by Install_Context_Clause).\n+\n+         else\n+            null;\n          end if;\n \n          Next (Item);\n@@ -3350,6 +3719,7 @@ package body Sem_Ch10 is\n       --  Now we can install the context for this parent\n \n       Install_Context_Clauses (Parent_Spec (Lib_Unit));\n+      Install_Limited_Context_Clauses (Parent_Spec (Lib_Unit));\n       Install_Siblings (P_Name, Parent (Lib_Unit));\n \n       --  The child unit is in the declarative region of the parent. The\n@@ -3556,6 +3926,7 @@ package body Sem_Ch10 is\n          --  package R.C is ...\n \n          Aux_Unit := Cunit (Current_Sem_Unit);\n+\n          loop\n             Item := First (Context_Items (Aux_Unit));\n             while Present (Item) loop\n@@ -3604,12 +3975,21 @@ package body Sem_Ch10 is\n             end loop;\n \n             if Present (Library_Unit (Aux_Unit)) then\n-               Aux_Unit := Library_Unit (Aux_Unit);\n+               if Aux_Unit = Library_Unit (Aux_Unit) then\n+\n+                  --  Aux_Unit is a body that acts as a spec. Clause has\n+                  --  already been flagged as illegal.\n+\n+                  return False;\n+\n+               else\n+                  Aux_Unit := Library_Unit (Aux_Unit);\n+               end if;\n             else\n                Aux_Unit := Parent_Spec (Unit (Aux_Unit));\n             end if;\n \n-            exit when not Present (Aux_Unit);\n+            exit when No (Aux_Unit);\n          end loop;\n \n          return False;\n@@ -3839,6 +4219,30 @@ package body Sem_Ch10 is\n \n       Set_Is_Immediately_Visible (P);\n       Set_Limited_View_Installed (N);\n+\n+      --  If the package in the limited_with clause is a child unit, the\n+      --  clause is unanalyzed and appears as a selected component. Recast\n+      --  it as an expanded name so that the entity can be properly set. Use\n+      --  entity of parent, if available, for higher ancestors in the name.\n+\n+      if Nkind (Name (N)) = N_Selected_Component then\n+         declare\n+            Nam : Node_Id;\n+            Ent : Entity_Id;\n+         begin\n+            Nam := Name (N);\n+            Ent := P;\n+            while Nkind (Nam) = N_Selected_Component\n+              and then Present (Ent)\n+            loop\n+               Change_Selected_Component_To_Expanded_Name (Nam);\n+               Nam := Prefix (Nam);\n+               Ent := Scope (Ent);\n+            end loop;\n+         end;\n+      end if;\n+\n+      Set_Entity (Name (N), P);\n       Set_From_With_Type (P);\n    end Install_Limited_Withed_Unit;\n \n@@ -5003,4 +5407,5 @@ package body Sem_Ch10 is\n       end if;\n \n    end Unchain;\n+\n end Sem_Ch10;"}]}