{"sha": "ec53454bff00bb25f035e7cd2b96f934af1530ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1MzQ1NGJmZjAwYmIyNWYwMzVlN2NkMmI5NmY5MzRhZjE1MzBmZg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-19T16:45:21Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-19T16:45:21Z"}, "message": "re PR fortran/14976 (.space is wrong)\n\n\tPR fortran/14976\n\tPR fortran/16228\n\t* data.c (assign_substring_data_value): Remove.\n\t(create_character_intializer): New function.\n\t(gfc_assign_data_value): Track the typespec for the current\n\tsubobject.  Use create_character_intializer.\ntestsuite/\n\t* gfortran.dg/data_char_1.f90: New test.\n\nFrom-SVN: r86256", "tree": {"sha": "d3b469a74caf35dfd59435d9082d0b8d2be4d0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b469a74caf35dfd59435d9082d0b8d2be4d0be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec53454bff00bb25f035e7cd2b96f934af1530ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec53454bff00bb25f035e7cd2b96f934af1530ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec53454bff00bb25f035e7cd2b96f934af1530ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec53454bff00bb25f035e7cd2b96f934af1530ff/comments", "author": null, "committer": null, "parents": [{"sha": "7551270e1b6232a38f772eb9298ddbe0aa970918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551270e1b6232a38f772eb9298ddbe0aa970918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551270e1b6232a38f772eb9298ddbe0aa970918"}], "stats": {"total": 196, "additions": 106, "deletions": 90}, "files": [{"sha": "29f672137ef4c917f36d7d13e25868bb390fa622", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ec53454bff00bb25f035e7cd2b96f934af1530ff", "patch": "@@ -1,3 +1,12 @@\n+2004-08-19  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/14976\n+\tPR fortran/16228 \n+\t* data.c (assign_substring_data_value): Remove.\n+\t(create_character_intializer): New function.\n+\t(gfc_assign_data_value): Track the typespec for the current\n+\tsubobject.  Use create_character_intializer.\n+\n 2004-08-18  Paul Brook  <paul@codesourcery.com>\n \n \t* trans-types.c (gfc_sym_type): Use pointer types for optional args."}, {"sha": "4ebacd345789481873107298f69934c9e3fa652d", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 79, "deletions": 90, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=ec53454bff00bb25f035e7cd2b96f934af1530ff", "patch": "@@ -104,81 +104,68 @@ find_con_by_component (gfc_component *com, gfc_constructor *con)\n   return NULL;\n }\n \n-/* Assign RVALUE to LVALUE where we assume that LVALUE is a substring\n-   reference. We do a little more than that: if LVALUE already has an\n-   initialization, we put RVALUE into the existing initialization as\n-   per the rules of assignment to a substring. If LVALUE has no\n-   initialization yet, we initialize it to all blanks, then filling in\n-   the RVALUE.  */\n \n-static void\n-assign_substring_data_value (gfc_expr * lvalue, gfc_expr * rvalue)\n+/* Create a character type intialization expression from RVALUE.\n+   TS [and REF] describe [the substring of] the variable being initialized.\n+   INIT is thh existing initializer, not NULL.  Initialization is performed\n+   according to normal assignment rules.  */\n+\n+static gfc_expr *\n+create_character_intializer (gfc_expr * init, gfc_typespec * ts,\n+\t\t\t     gfc_ref * ref, gfc_expr * rvalue)\n {\n-  gfc_symbol *symbol;\n-  gfc_expr *expr, *init;\n-  gfc_ref *ref;\n-  int len, i;\n-  int start, end;\n-  char *c, *d;\n+  int len;\n+  int start;\n+  int end;\n+  char *dest;\n \t    \n-  symbol = lvalue->symtree->n.sym;\n-  ref = lvalue->ref;\n-  init = symbol->value;\n+  gfc_extract_int (ts->cl->length, &len);\n \n-  assert (symbol->ts.type == BT_CHARACTER);\n-  assert (symbol->ts.cl->length->expr_type == EXPR_CONSTANT);\n-  assert (symbol->ts.cl->length->ts.type == BT_INTEGER);\n-  assert (symbol->ts.kind == 1);\n-\n-  gfc_extract_int (symbol->ts.cl->length, &len);\n-\t    \n   if (init == NULL)\n     {\n-      /* Setup the expression to hold the constructor.  */\n-      expr = gfc_get_expr ();\n-      expr->expr_type = EXPR_CONSTANT;\n-      expr->ts.type = BT_CHARACTER;\n-      expr->ts.kind = 1;\n-\t      \n-      expr->value.character.length = len;\n-      expr->value.character.string = gfc_getmem (len);\n-      memset (expr->value.character.string, ' ', len);\n-\n-      symbol->value = expr;\n+      /* Create a new initializer.  */\n+      init = gfc_get_expr ();\n+      init->expr_type = EXPR_CONSTANT;\n+      init->ts = *ts;\n+      \n+      dest = gfc_getmem (len);\n+      init->value.character.length = len;\n+      init->value.character.string = dest;\n+      /* Blank the string if we're only setting a substring.  */\n+      if (ref != NULL)\n+\tmemset (dest, ' ', len);\n     }\n   else\n-    expr = init;\n-\t  \n-  /* Now that we have allocated the memory for the string,\n-     fill in the initialized places, truncating the\n-     intialization string if necessary, i.e.\n-     DATA a(1:2) /'123'/\n-     doesn't initialize a(3:3).  */\n-\n-  gfc_extract_int (ref->u.ss.start, &start);\n-  gfc_extract_int (ref->u.ss.end, &end);\n-\t    \n-  assert (start >= 1);\n-  assert (end <= len);\n+    dest = init->value.character.string;\n \n-  len = rvalue->value.character.length;\n-  c = rvalue->value.character.string;\n-  d = &expr->value.character.string[start - 1];\n+  if (ref)\n+    {\n+      assert (ref->type == REF_SUBSTRING);\n \n-  for (i = 0; i <= end - start && i < len; i++)\n-    d[i] = c[i];\n+      /* Only set a substring of the destination.  Fortran substring bounds\n+         are one-based [start, end], we want zero based [start, end).  */\n+      gfc_extract_int (ref->u.ss.start, &start);\n+      start--;\n+      gfc_extract_int (ref->u.ss.end, &end);\n+    }\n+  else\n+    {\n+      /* Set the whole string.  */\n+      start = 0;\n+      end = len;\n+    }\n \n-  /* Pad with spaces. I.e. \n-     DATA a(1:2) /'a'/\n-     intializes a(1:2) to 'a ' per the rules for assignment.  \n-     If init == NULL we don't need to do this, as we have\n-     intialized the whole string to blanks above.  */\n+  /* Copy the initial value.  */\n+  len = rvalue->value.character.length;\n+  if (len > end - start)\n+    len = end - start;\n+  memcpy (&dest[start], rvalue->value.character.string, len);\n \n-  if (init != NULL)\n-    for (; i <= end - start; i++)\n-      d[i] = ' ';\n+  /* Pad with spaces.  Substrings will already be blanked.  */\n+  if (len < end - start && ref == NULL)\n+    memset (&dest[start + len], ' ', end - (start + len));\n \n-  return;\n+  return init;\n }\n \n /* Assign the initial value RVALUE to  LVALUE's symbol->value. If the\n@@ -194,26 +181,26 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n   gfc_constructor *con;\n   gfc_constructor *last_con;\n   gfc_symbol *symbol;\n+  gfc_typespec *last_ts;\n   mpz_t offset;\n \n-  ref = lvalue->ref;\n-  if (ref != NULL && ref->type == REF_SUBSTRING)\n-    {\n-      /* No need to go through the for (; ref; ref->next) loop, since\n-\t a single substring lvalue will only refer to a single\n-\t substring, and therefore ref->next == NULL.  */\n-      assert (ref->next == NULL);      \n-      assign_substring_data_value (lvalue, rvalue);\n-      return;\n-    }\n-\n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n+  last_ts = &symbol->ts;\n   last_con = NULL;\n   mpz_init_set_si (offset, 0);\n \n-  for (; ref; ref = ref->next)\n+  /* Find/create the parent expressions for subobject references.  */\n+  for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n+      /* Break out of the loop if we find a substring.  */\n+      if (ref->type == REF_SUBSTRING)\n+\t{\n+\t  /* A substring should always br the last subobject reference.  */\n+\t  assert (ref->next == NULL);\n+\t  break;\n+\t}\n+\n       /* Use the existing initializer expression if it exists.  Otherwise\n          create a new one.  */\n       if (init == NULL)\n@@ -227,15 +214,11 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \tcase REF_ARRAY:\n \t  if (init == NULL)\n \t    {\n+\t      /* The element typespec will be the same as the array\n+\t\t typespec.  */\n+\t      expr->ts = *last_ts;\n \t      /* Setup the expression to hold the constructor.  */\n \t      expr->expr_type = EXPR_ARRAY;\n-\t      if (ref->next)\n-\t\t{\n-\t\t  assert (ref->next->type == REF_COMPONENT);\n-\t\t  expr->ts.type = BT_DERIVED;\n-\t\t}\n-\t      else\n-\t\texpr->ts = rvalue->ts;\n \t      expr->rank = ref->u.ar.as->rank;\n \t    }\n \t  else\n@@ -269,6 +252,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t    }\n \t  else\n \t    assert (expr->expr_type == EXPR_STRUCTURE);\n+\t  last_ts = &ref->u.c.component->ts;\n \n \t  /* Find the same element in the existing constructor.  */\n \t  con = expr->value.constructor;\n@@ -284,12 +268,11 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t    }\n \t  break;\n \n-       /* case REF_SUBSTRING: dealt with separately above. */\n-\t\n \tdefault:\n \t  abort ();\n \t}\n \n+      \n       if (init == NULL)\n \t{\n \t  /* Point the container at the new expression.  */\n@@ -302,17 +285,23 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n       last_con = con;\n     }\n \n-  expr = gfc_copy_expr (rvalue);\n-  if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n-    gfc_convert_type (expr, &lvalue->ts, 0);\n+  if (ref || last_ts->type == BT_CHARACTER)\n+    expr = create_character_intializer (init, last_ts, ref, rvalue);\n+  else\n+    {\n+      /* We should never be overwriting an existing initializer.  */\n+      assert (!init);\n+\n+      expr = gfc_copy_expr (rvalue);\n+      if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n+\tgfc_convert_type (expr, &lvalue->ts, 0);\n+\n+    }\n \n   if (last_con == NULL)\n     symbol->value = expr;\n   else\n-    {\n-      assert (!last_con->expr);\n-      last_con->expr = expr;\n-    }\n+    last_con->expr = expr;\n }\n \n "}, {"sha": "f4acb9313e3ce568909a95a47b130d4e94d2652b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec53454bff00bb25f035e7cd2b96f934af1530ff", "patch": "@@ -1,3 +1,9 @@\n+2004-08-19  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/14976\n+\tPR fortran/16228 \n+\t* gfortran.dg/data_char_1.f90: New test.\n+\n 2004-08-19  Erik Schnetter  <schnetter@aei.mpg.de>\n \n \tPR fortran/16946"}, {"sha": "a2acf1ed16574a8335211efdda6dfb15c00720bf", "filename": "gcc/testsuite/gfortran.dg/data_char_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec53454bff00bb25f035e7cd2b96f934af1530ff/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_char_1.f90?ref=ec53454bff00bb25f035e7cd2b96f934af1530ff", "patch": "@@ -0,0 +1,12 @@\n+! Test character variables in data statements\n+! Also substrings of cahracter variables.\n+! PR14976 PR16228 \n+program data_char_1\n+  character(len=5) :: a(2)\n+  character(len=5) :: b(2)\n+  data a /'Hellow', 'orld'/\n+  data b(:)(1:4), b(1)(5:5), b(2)(5:5) /'abcdefg', 'hi', 'j', 'k'/\n+  \n+  if ((a(1) .ne. 'Hello') .or. (a(2) .ne. 'orld ')) call abort\n+  if ((b(1) .ne. 'adcdl') .or. (b(2) .ne. 'hi  l')) call abort\n+end program"}]}