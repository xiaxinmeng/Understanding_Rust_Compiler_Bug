{"sha": "55e79aef81371abf4c07885fbbd748078d695209", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlNzlhZWY4MTM3MWFiZjRjMDc4ODVmYmJkNzQ4MDc4ZDY5NTIwOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-26T20:29:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-26T20:29:25Z"}, "message": "re PR middle-end/18008 (Duplicate mask on bitfield insertion)\n\n        PR middle-end/18008\n        * combine.c (make_field_assignment): Simplify store to zero_extract\n        from a source with an overlapping mask.\n\nFrom-SVN: r94282", "tree": {"sha": "dd7963208fe0488ccef8028ff03580720a645475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd7963208fe0488ccef8028ff03580720a645475"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55e79aef81371abf4c07885fbbd748078d695209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e79aef81371abf4c07885fbbd748078d695209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e79aef81371abf4c07885fbbd748078d695209", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e79aef81371abf4c07885fbbd748078d695209/comments", "author": null, "committer": null, "parents": [{"sha": "d951ae1e66fabf7dc1eedc2b3bb5c047fa968fb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d951ae1e66fabf7dc1eedc2b3bb5c047fa968fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d951ae1e66fabf7dc1eedc2b3bb5c047fa968fb0"}], "stats": {"total": 59, "additions": 48, "deletions": 11}, "files": [{"sha": "630dfac2abe6a1195435fd55d678ebd97abbb3a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e79aef81371abf4c07885fbbd748078d695209/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e79aef81371abf4c07885fbbd748078d695209/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55e79aef81371abf4c07885fbbd748078d695209", "patch": "@@ -1,3 +1,9 @@\n+2005-01-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/18008\n+\t* combine.c (make_field_assignment): Simplify store to zero_extract\n+\tfrom a source with an overlapping mask.\n+\n 2005-01-26  Aldy Hernandez  <aldyh@redhat.com>\n \n \t2004-11-11  Eric Christopher  <echristo@redhat.com>"}, {"sha": "7fe0a5f702e34039ede2dd30f49e28a6855e909a", "filename": "gcc/combine.c", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e79aef81371abf4c07885fbbd748078d695209/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e79aef81371abf4c07885fbbd748078d695209/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=55e79aef81371abf4c07885fbbd748078d695209", "patch": "@@ -7815,14 +7815,14 @@ make_field_assignment (rtx x)\n       return x;\n     }\n \n-  else if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == SUBREG\n-\t   && subreg_lowpart_p (XEXP (src, 0))\n-\t   && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n-\t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n-\t   && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n-\t   && GET_CODE (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == CONST_INT\n-\t   && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n-\t   && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n+  if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == SUBREG\n+      && subreg_lowpart_p (XEXP (src, 0))\n+      && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n+\t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n+      && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n+      && GET_CODE (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == CONST_INT\n+      && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n+      && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n       assign = make_extraction (VOIDmode, dest, 0,\n \t\t\t\tXEXP (SUBREG_REG (XEXP (src, 0)), 1),\n@@ -7834,9 +7834,9 @@ make_field_assignment (rtx x)\n \n   /* If SRC is (ior (ashift (const_int 1) POS) DEST), this is a set of a\n      one-bit field.  */\n-  else if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == ASHIFT\n-\t   && XEXP (XEXP (src, 0), 0) == const1_rtx\n-\t   && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n+  if (GET_CODE (src) == IOR && GET_CODE (XEXP (src, 0)) == ASHIFT\n+      && XEXP (XEXP (src, 0), 0) == const1_rtx\n+      && rtx_equal_for_field_assignment_p (dest, XEXP (src, 1)))\n     {\n       assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n@@ -7845,6 +7845,37 @@ make_field_assignment (rtx x)\n       return x;\n     }\n \n+  /* If DEST is already a field assignment, i.e. ZERO_EXTRACT, and the\n+     SRC is an AND with all bits of that field set, then we can discard\n+     the AND.  */\n+  if (GET_CODE (dest) == ZERO_EXTRACT\n+      && GET_CODE (XEXP (dest, 1)) == CONST_INT\n+      && GET_CODE (src) == AND\n+      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT width = INTVAL (XEXP (dest, 1));\n+      unsigned HOST_WIDE_INT and_mask = INTVAL (XEXP (src, 1));\n+      unsigned HOST_WIDE_INT ze_mask;\n+\n+      if (width >= HOST_BITS_PER_WIDE_INT)\n+\tze_mask = -1;\n+      else\n+\tze_mask = ((unsigned HOST_WIDE_INT)1 << width) - 1;\n+\n+      /* Complete overlap.  We can remove the source AND.  */\n+      if ((and_mask & ze_mask) == ze_mask)\n+\treturn gen_rtx_SET (VOIDmode, dest, XEXP (src, 0));\n+\n+      /* Partial overlap.  We can reduce the source AND.  */\n+      if ((and_mask & ze_mask) != and_mask)\n+\t{\n+\t  mode = GET_MODE (src);\n+\t  src = gen_rtx_AND (mode, XEXP (src, 0),\n+\t\t\t     gen_int_mode (mode, and_mask & ze_mask));\n+\t  return gen_rtx_SET (VOIDmode, dest, src);\n+\t}\n+    }\n+\n   /* The other case we handle is assignments into a constant-position\n      field.  They look like (ior/xor (and DEST C1) OTHER).  If C1 represents\n      a mask that has all one bits except for a group of zero bits and"}]}