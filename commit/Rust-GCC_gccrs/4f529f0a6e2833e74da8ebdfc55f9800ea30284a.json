{"sha": "4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY1MjlmMGE2ZTI4MzNlNzRkYThlYmRmYzU1Zjk4MDBlYTMwMjg0YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-28T18:41:59Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-28T18:41:59Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1112", "tree": {"sha": "3965d9ceff64f615cd6143bc0be77cb179f4040d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3965d9ceff64f615cd6143bc0be77cb179f4040d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f529f0a6e2833e74da8ebdfc55f9800ea30284a/comments", "author": null, "committer": null, "parents": [{"sha": "d7cedf4b468aa06cf1b7d30fc4fad2ee64f40b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cedf4b468aa06cf1b7d30fc4fad2ee64f40b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cedf4b468aa06cf1b7d30fc4fad2ee64f40b5b"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "5992413a3fc8a0a5e447d3244bfb89d64d64b708", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f529f0a6e2833e74da8ebdfc55f9800ea30284a/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f529f0a6e2833e74da8ebdfc55f9800ea30284a/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "patch": "@@ -22,6 +22,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"i386.h\"\t/* Base i386 target machine definitions */\n #include \"att386.h\"\t/* Use the i386 AT&T assembler syntax */\n #include \"svr4.h\"\t/* Definitions common to all SVR4 targets */\n+#include \"real.h\"\n \n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (i386 System V Release 4)\");\n@@ -57,6 +58,36 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define CPP_PREDEFINES \\\n   \"-Di386 -Dunix -D__svr4__ -Asystem(unix) -Acpu(i386) -Amachine(i386)\"\n \n+/* If the host and target formats match, output the floats as hex.  */\n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n+/* This is how to output assembly code to define a `float' constant.\n+   We always have to use a .long pseudo-op to do this because the native\n+   SVR4 ELF assembler is buggy and it generates incorrect values when we\n+   try to use the .float pseudo-op instead.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+do { long value;\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE ((VALUE), value);\t\t\t\\\n+     fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value);\t\t\t\\\n+   } while (0)\n+\n+/* This is how to output assembly code to define a `double' constant.\n+   We always have to use a pair of .long pseudo-ops to do this because\n+   the native SVR4 ELF assembler is buggy and it generates incorrect\n+   values when we try to use the the .double pseudo-op instead.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+do { long value[2];\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), value);\t\t\t\\\n+     fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[0]);\t\t\t\\\n+     fprintf((FILE), \"%s\\t0x%x\\n\", ASM_LONG, value[1]);\t\t\t\\\n+   } while (0)\n+#endif /* word order matches */\n+#endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n+\n /* Output at beginning of assembler file.  */\n /* The .file command should always begin the output.  */\n "}, {"sha": "9c208197cad9fb5bbd8bfbf8e4ba8b41c36f4f3f", "filename": "gcc/config/i860/sysv4.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f529f0a6e2833e74da8ebdfc55f9800ea30284a/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f529f0a6e2833e74da8ebdfc55f9800ea30284a/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=4f529f0a6e2833e74da8ebdfc55f9800ea30284a", "patch": "@@ -60,6 +60,55 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \tfprintf (FILE, \"]@%s\", PART_CODE);\t\t\t\t\\\n   } while (0)\n \n+/* If the host and target formats match, output the floats as hex.  */\n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   Note that the native i860/svr4 ELF assembler can't properly handle\n+   infinity.  It generates an incorrect (non-infinity) value when given\n+   `.double 99e9999' and it doesn't grok `inf' at all.  It also mishandles\n+   NaNs and -0.0.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t[2];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.word 0x%lx\\n\\t.word 0x%lx\\n\", t[0], t[1]);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%.17g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `float' constant.\n+   Note that the native i860/svr4 ELF assembler can't properly handle\n+   infinity.  It actually generates an assembly time error when given\n+   `.float 99e9999' and it doesn't grok `inf' at all.  It also mishandles\n+   NaNs and -0.0.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t;\t\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.word 0x%lx\\n\", t);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%.9g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+#endif /* word order matches */\n+#endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n+\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n   do {\toutput_file_directive (FILE, main_input_filename);\t\t\\"}]}