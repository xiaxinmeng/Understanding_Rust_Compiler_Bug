{"sha": "d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3OWQzN2Y1ZWQzYzY3YWNlZGJmMDVkYmY1OWVkOWQ2YWMyMjU2Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-05-01T16:13:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-05-01T16:13:36Z"}, "message": "input.h (lineno): Rename to ...\n\n\t* input.h (lineno): Rename to ...\n\t(input_line): ... here.\n\t* tree.h (lineno): Rename to ...\n\t(input_line): ... here.\n\t* scan.h (lineno): Rename to ...\n\t(input_line): ... here.\n\t* toplev.c (lineno): Rename to ...\n\t(input_line): ... here.\n\t(push_srcloc, pop_srcloc):  Rename lineno to input_line.\n\t* c-common.c (c_expand_start_cond, fname_decl): Likewise.\n\t* c-decl.c (poplevel, pop_label_level, lookup_label, lookup_tag,\n\tstore_parm_decls, c_expand_body_1): Likewise.\n\t* c-errors.c (pedwarn_c99): Likewise.\n\t* c-format.c (status_warning): Likewise.\n\t* c-lex.c (fe_file_change, cb_def_pragma, c_lex): Likewise.\n\t* c-opts.c (c_common_post_options, c_common_parse_file): Likewise.\n\t* c-parse.in (save_filename, maybe_type_qual, ifc): Likwise.\n\t* c-semantics.c (finish_stmt_tree, build_stmt, emit_local_var,\n\tgentrtl_goto_stmt, genrtl_expr_stmt_value, genrtl_decl_stmt,\n\tgenrtl_if_stmt, genrtl_while_stmt, genrtl_do_stmt,\n\tgenrtl_return_stmt, genrtl_for_stmt, build_break_stmt,\n\tbuild_continue_stmt, genrtl_switch_stmt, genrtl_asm_stmt,\n\tprep_stmt, find_reachable_label, expand_unreachable_stmt): Likewise.\n\t* coverage.c (create_coverage): Likewise.\n\t* diagnostic.c (pedwarn, sorry, error, fatal_error,\n\tinternal_error, warning, diagnostic_report_current_module,\n\tinform): Likewise.\n\t* expr.c (expand_expr): Likewise.\n\t* integrate.c (expand_inline_function,\n\toutput_inline_function): Likewise.\n\t* rtl-error.c (file_and_line_for_asm): Likewise.\n\t* tree-inline.c (find_alloca_call, find_builtin_longjmp_call,\n\twalk_tree): Likewise.\n\t* tree.c (make_node): Likewise.\n\t* ada, cp, f, java, objc, treelang: Likewise.\n\n\tada\n\t* trans.c (build_unit_elab, set_lineno): Rename lineno to\n\tinput_line.\n\t* utils.c (pushdecl, create_label_decl, begin_subprog_body,\n\tend_subprog_body): Likewise.\n\t* utils2.c (build_call_raise): Likewise.\n\n\tcp\n\t* class.c (finish_struct): Rename lineno to input_line.\n\t* decl.c (push_binding_level, pop_binding_level,\n\tsuspend_binding_level, resume_binding_level, make_label_decl,\n\tuse_label, start_function): Likewise.\n\t* decl2.c (warn_if_unknown_interface,\n\tstart_static_initialization_or_destruction,\n\tgenerate_ctor_or_dtor_function, finish_file): Likewise.\n\t* error.c (cp_line_of, print_instantiation_full_context,\n\tprint_instantiation_context): Likewise.\n\t* except.c (check_handlers_1, check_handlers): Likewise.\n\t* init.c (create_temporary_var): Likewise.\n\t* method.c (use_thunk, synthesize_method): Likewise.\n\t* parser.c (cp_lexer_set_source_position_from_token,\n\tcp_lexer_get_preprocessor_token): Likewise.\n\t* pt.c (push_tinst_level, pop_tinst_level,\n\ttsubst_friend_function, instantiate_class_template, tsubst_decl,\n\ttsubst, tsubst_expr, instantiate_decl): Likewise.\n\t* semantics.c (genrtl_try_block, finish_label_stmt,\n\tbegin_class_definition, expand_body,\n\tgenrtl_finish_function): Likewise.\n\t* tree.c (build_min_nt, build_min): Likewise.\n\n\tf\n\t* ansify.c (die_unless): Rename lineno to input_line.\n\t* com.c (ffecom_subscript_check_, ffecom_do_entry_,\n\tffecom_gen_sfuncdef_, ffecom_start_progunit_,\n\tffecom_sym_transform_, ffecom_sym_transform_assign_,\n\tbison_rule_pushlevel_, bison_rule_compstmt_, finish_function,\n\tstore_parm_decls): Likewise.\n\t* intrin.c (ffeintrin_fulfill_generic): Likewise.\n\t* lex.c (ffelex_hash_, ffelex_include_, ffelex_next_line_,\n\tffelex_file_fixed, ffelex_file_free): Likewise.\n\t* std.c (ffestd_exec_end): Likewise.\n\t* ste.c (ffeste_emit_line_note_, ffeste_start_block_,\n\tffeste_start_stmt_): Likewise.\n\t* ste.h (ffeste_filelinenum, ffeste_set_line): Likewise.\n\n\tjava\n\t* lex.h (lineno): Rename to ...\n\t(input_line): ... here\n\t* parse-scan.y (lineno): Rename to ...\n\t(input_line): ... here.\n\t(reset_report): Rename lineno to input_line.\n\t* check-init.c (check_init): Likewise.\n\t* class.c (push_class): Likewise.\n\t* decl.c (complete_start_java_method, end_java_method): Likewise.\n\t* expr.c (expand_byte_code): Likewise.\n\t* jcf-parse.c (give_name_to_class, parse_class_file): Likewise.\n\t* jcf-write.c (generate_bytecode_insns): Likewise.\n\t* lex.c (java_init_lex, java_allocate_new_line,\n\tdo_java_lex): Likewise.\n\t* parse.h (YYNOT_TWICE): Likewise.\n\t* parse.y (empty_statement, expression_statement,\n\tjava_pop_parser_context, java_parser_context_save_global,\n\tyyerror, register_fields, method_header, safe_layout_class,\n\tfind_in_imports_on_demand, create_artificial_method,\n\tsource_end_java_method, start_complete_expand_method,\n\tbuild_thisn_assign, java_complete_lhs,\n\tmaybe_absorb_scoping_block): Likewise.\n\n\tobjc\n\t* objc-act.c (objc_init): Rename lineno to input_line.\n\t(build_module_descriptor, build_selector_translation_table,\n\tbuild_protocol_template, build_method_prototype_list_template,\n\tbuild_category_template, build_selector_table,\n\tbuild_class_template, build_super_template, build_ivar_template,\n\tbuild_ivar_list_template, build_method_list_template,\n\tbuild_method_template, add_instance_variable): Likewise.\n\n\ttreelang\n\t* tree1.c (treelang_init): Rename lineno to input_line.\n\nFrom-SVN: r66333", "tree": {"sha": "86bc2770fce43ac5337df72ade116d11a32734e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86bc2770fce43ac5337df72ade116d11a32734e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/comments", "author": null, "committer": null, "parents": [{"sha": "49bf4577455b0bb2413fe317c0424aba6f53616d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49bf4577455b0bb2413fe317c0424aba6f53616d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49bf4577455b0bb2413fe317c0424aba6f53616d"}], "stats": {"total": 829, "additions": 450, "deletions": 379}, "files": [{"sha": "e2148345cd2dfb9ced15a5f56d3f516f6560ae91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,48 @@\n 2003-05-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* input.h (lineno): Rename to ...\n+\t(input_line): ... here.\n+\t* tree.h (lineno): Rename to ...\n+\t(input_line): ... here.\n+\t* scan.h (lineno): Rename to ...\n+\t(input_line): ... here.\n+\t* toplev.c (lineno): Rename to ...\n+\t(input_line): ... here.\n+\t(push_srcloc, pop_srcloc):  Rename lineno to input_line.\n+\t* c-common.c (c_expand_start_cond, fname_decl): Likewise.\n+\t* c-decl.c (poplevel, pop_label_level, lookup_label, lookup_tag,\n+\tstore_parm_decls, c_expand_body_1): Likewise.\n+\t* c-errors.c (pedwarn_c99): Likewise.\n+\t* c-format.c (status_warning): Likewise.\n+\t* c-lex.c (fe_file_change, cb_def_pragma, c_lex): Likewise.\n+\t* c-opts.c (c_common_post_options, c_common_parse_file): Likewise.\n+\t* c-parse.in (save_filename, maybe_type_qual, ifc): Likwise.\n+\t* c-semantics.c (finish_stmt_tree, build_stmt, emit_local_var,\n+\tgentrtl_goto_stmt, genrtl_expr_stmt_value, genrtl_decl_stmt,\n+\tgenrtl_if_stmt, genrtl_while_stmt, genrtl_do_stmt,\n+\tgenrtl_return_stmt, genrtl_for_stmt, build_break_stmt,\n+\tbuild_continue_stmt, genrtl_switch_stmt, genrtl_asm_stmt,\n+\tprep_stmt, find_reachable_label, expand_unreachable_stmt): Likewise.\n+\t* coverage.c (create_coverage): Likewise.\n+\t* diagnostic.c (pedwarn, sorry, error, fatal_error,\n+\tinternal_error, warning, diagnostic_report_current_module,\n+\tinform): Likewise.\n+\t* expr.c (expand_expr): Likewise.\n+\t* integrate.c (expand_inline_function,\n+\toutput_inline_function): Likewise.\n+\t* rtl-error.c (file_and_line_for_asm): Likewise.\n+\t* tree-inline.c (find_alloca_call, find_builtin_longjmp_call,\n+\twalk_tree): Likewise.\n+\t* tree.c (make_node): Likewise.\n+\t* ada, cp, f, java, objc, treelang: Likewise.\n+\t* objc/objc-act.c (objc_init): Rename lineno to input_line.\n+\t(build_module_descriptor, build_selector_translation_table,\n+\tbuild_protocol_template, build_method_prototype_list_template,\n+\tbuild_category_template, build_selector_table,\n+\tbuild_class_template, build_super_template, build_ivar_template,\n+\tbuild_ivar_list_template, build_method_list_template,\n+\tbuild_method_template, add_instance_variable): Likewise.\n+\n \t* dwarf2out.c (dwarf2out_init, dwarf2out_finish): Change parameter\n \tname from input_filename.\n "}, {"sha": "31971529fef3365f8e8132721dc896c131163a65", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,3 +1,11 @@\n+2003-05-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* trans.c (build_unit_elab, set_lineno): Rename lineno to\n+\tinput_line. \n+\t* utils.c (pushdecl, create_label_decl, begin_subprog_body,\n+\tend_subprog_body): Likewise.\n+\t* utils2.c (build_call_raise): Likewise.\n+\n 2003-05-01  Laurent Guerby <guerby@acm.org>\n \n         PR ada/10546 "}, {"sha": "8ad8a2a26fd9ed8a7ed43194d369d6e20ec7d4df", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -7,7 +7,7 @@\n  *                              C Header File                               *\n  *                                                                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2002 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -192,9 +192,9 @@ extern tree gnat_to_gnu\t\tPARAMS ((Node_Id));\n \n extern void process_type\tPARAMS ((Entity_Id));\n \n-/* Determine the input_filename and the lineno from the source location\n+/* Determine the input_filename and the input_line from the source location\n    (Sloc) of GNAT_NODE node.  Set the global variable input_filename and\n-   lineno.  If WRITE_NOTE_P is true, emit a line number note. */\n+   input_line.  If WRITE_NOTE_P is true, emit a line number note. */\n extern void set_lineno\t\tPARAMS ((Node_Id, int));\n \n /* Post an error message.  MSG is the error message, properly annotated."}, {"sha": "be5c656127a022dc01551389c5bf53cd24efebd5", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -7,7 +7,7 @@\n  *                          C Implementation File                           *\n  *                                                                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2002, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -5343,7 +5343,7 @@ build_unit_elab (gnat_unit, body_p, gnu_elab_list)\n \ttree lhs = TREE_PURPOSE (gnu_elab_list);\n \n \tinput_filename = DECL_SOURCE_FILE (lhs);\n-\tlineno = DECL_SOURCE_LINE (lhs);\n+\tinput_line = DECL_SOURCE_LINE (lhs);\n \n \t/* If LHS has a padded type, convert it to the unpadded type\n \t   so the assignment is done properly.  */\n@@ -5414,7 +5414,7 @@ set_lineno (gnat_node, write_note_p)\n       (get_identifier\n        (Get_Name_String\n \t(Reference_Name (Get_Source_File_Index (source_location)))));;\n-  lineno = Get_Logical_Line_Number (source_location);\n+  input_line = Get_Logical_Line_Number (source_location);\n \n   if (write_note_p)\n     emit_line_note (input_filename, lineno);"}, {"sha": "e74d5a20439279104538c380405a41569d359b97", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -7,7 +7,7 @@\n  *                          C Implementation File                           *\n  *                                                                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2002, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -479,7 +479,7 @@ pushdecl (decl)\n void\n gnat_init_decl_processing ()\n {\n-  lineno = 0;\n+  input_line = 0;\n \n   /* Make the binding_level structure for global names.  */\n   current_function_decl = 0;\n@@ -1663,7 +1663,7 @@ create_label_decl (label_name)\n \n   DECL_CONTEXT (label_decl)     = current_function_decl;\n   DECL_MODE (label_decl)        = VOIDmode;\n-  DECL_SOURCE_LINE (label_decl) = lineno;\n+  DECL_SOURCE_LINE (label_decl) = input_line;\n   DECL_SOURCE_FILE (label_decl) = input_filename;\n \n   return label_decl;\n@@ -1781,7 +1781,7 @@ begin_subprog_body (subprog_decl)\n   /* Store back the PARM_DECL nodes. They appear in the right order. */\n   DECL_ARGUMENTS (subprog_decl) = getdecls ();\n \n-  init_function_start (subprog_decl, input_filename, lineno);\n+  init_function_start (subprog_decl, input_filename, input_line);\n   expand_function_start (subprog_decl, 0);\n \n   /* If this function is `main', emit a call to `__main'\n@@ -1808,7 +1808,7 @@ end_subprog_body ()\n   /* Mark the RESULT_DECL as being in this subprogram. */\n   DECL_CONTEXT (DECL_RESULT (current_function_decl)) = current_function_decl;\n \n-  expand_function_end (input_filename, lineno, 0);\n+  expand_function_end (input_filename, input_line, 0);\n \n   /* If this is a nested function, push a new GC context.  That will keep\n      local variables on the stack from being collected while we're doing"}, {"sha": "1964be12276950728a27930434ff247153457b14", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -7,7 +7,7 @@\n  *                          C Implementation File                           *\n  *                                                                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2002, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1508,7 +1508,7 @@ build_call_raise (msg)\n     build_call_2_expr (fndecl,\n \t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_2 (lineno, 0));\n+\t\t       build_int_2 (input_line, 0));\n }\n \f\n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  */"}, {"sha": "c7e1cb03f88e88898c487ccf2ab0ce011202cd78", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -919,7 +919,7 @@ c_expand_start_cond (cond, compstmt_count, if_stmt)\n   /* Record this if statement.  */\n   if_stack[if_stack_pointer].compstmt_count = compstmt_count;\n   if_stack[if_stack_pointer].locus.file = input_filename;\n-  if_stack[if_stack_pointer].locus.line = lineno;\n+  if_stack[if_stack_pointer].locus.line = input_line;\n   if_stack[if_stack_pointer].needs_warning = 0;\n   if_stack[if_stack_pointer].if_stmt = if_stmt;\n   if_stack_pointer++;\n@@ -1158,8 +1158,8 @@ fname_decl (rid, id)\n \t beginning of the function and this line number will be wrong.\n \t To avoid this problem set the lineno to 0 here; that prevents\n \t it from appearing in the RTL.  */\n-      int saved_lineno = lineno;\n-      lineno = 0;\n+      int saved_lineno = input_line;\n+      input_line = 0;\n       \n       decl = (*make_fname_decl) (id, fname_vars[ix].pretty);\n       if (last_tree != saved_last_tree)\n@@ -1175,7 +1175,7 @@ fname_decl (rid, id)\n \t\t\t\t\t\t saved_function_name_decls);\n \t}\n       *fname_vars[ix].decl = decl;\n-      lineno = saved_lineno;\n+      input_line = saved_lineno;\n     }\n   if (!ix && !current_function_decl)\n     pedwarn_with_decl (decl, \"`%s' is not defined outside of function scope\");"}, {"sha": "e35944e79179454f4a53d123792f9c3473ac0a76", "filename": "gcc/c-decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -617,7 +617,7 @@ poplevel (keep, reverse, functionbody)\n \t    {\n \t      error_with_decl (label, \"label `%s' used but not defined\");\n \t      /* Avoid crashing later.  */\n-\t      define_label (input_filename, lineno,\n+\t      define_label (input_filename, input_line,\n \t\t\t    DECL_NAME (label));\n \t    }\n \t  else if (warn_unused_label && !TREE_USED (label))\n@@ -711,7 +711,7 @@ pop_label_level ()\n \t      error_with_decl (TREE_VALUE (link),\n \t\t\t       \"label `%s' used but not defined\");\n \t      /* Avoid crashing later.  */\n-\t      define_label (input_filename, lineno,\n+\t      define_label (input_filename, input_line,\n \t\t\t    DECL_NAME (TREE_VALUE (link)));\n \t    }\n \t  else if (warn_unused_label && !TREE_USED (TREE_VALUE (link)))\n@@ -2019,7 +2019,7 @@ lookup_label (id)\n \n   /* Say where one reference is to the label,\n      for the sake of the error if it is not defined.  */\n-  DECL_SOURCE_LINE (decl) = lineno;\n+  DECL_SOURCE_LINE (decl) = input_line;\n   DECL_SOURCE_FILE (decl) = input_filename;\n \n   IDENTIFIER_LABEL_VALUE (id) = decl;\n@@ -2184,7 +2184,7 @@ lookup_tag (code, name, thislevel_only)\n       /* Definition isn't the kind we were looking for.  */\n       pending_invalid_xref = name;\n       pending_invalid_xref_file = input_filename;\n-      pending_invalid_xref_line = lineno;\n+      pending_invalid_xref_line = input_line;\n \n       /* If in the same binding level as a declaration as a tag\n \t of a different type, this must not be allowed to\n@@ -6079,7 +6079,7 @@ store_parm_decls ()\n   gen_aux_info_record (fndecl, 1, 0, prototype);\n \n   /* Initialize the RTL code for the function.  */\n-  init_function_start (fndecl, input_filename, lineno);\n+  init_function_start (fndecl, input_filename, input_line);\n \n   /* Begin the statement tree for this function.  */\n   begin_stmt_tree (&DECL_SAVED_TREE (current_function_decl));\n@@ -6339,7 +6339,7 @@ c_expand_body_1 (fndecl, nested_p)\n   current_function_decl = fndecl;\n   input_filename = DECL_SOURCE_FILE (fndecl);\n   init_function_start (fndecl, input_filename, DECL_SOURCE_LINE (fndecl));\n-  lineno = DECL_SOURCE_LINE (fndecl);\n+  input_line = DECL_SOURCE_LINE (fndecl);\n \n   /* This function is being processed in whole-function mode.  */\n   cfun->x_whole_function_mode_p = 1;\n@@ -6384,7 +6384,7 @@ c_expand_body_1 (fndecl, nested_p)\n     (*lang_expand_function_end) ();\n \n   /* Generate rtl for function exit.  */\n-  expand_function_end (input_filename, lineno, 0);\n+  expand_function_end (input_filename, input_line, 0);\n \n   /* If this is a nested function, protect the local variables in the stack\n      above us from being collected while we're compiling this function.  */"}, {"sha": "3f3f69039de27264676622558348e15739c3f99e", "filename": "gcc/c-errors.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-errors.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* Various diagnostic subroutines for the GNU C language.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GCC.\n@@ -38,7 +38,7 @@ pedwarn_c99 VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        flag_isoc99 ? pedantic_error_kind () : DK_WARNING);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);"}, {"sha": "bf50c8636223798bd39c523a7591e44c5b737662", "filename": "gcc/c-format.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,6 +1,6 @@\n /* Check calls to formatted I/O functions (-Wformat).\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002 Free Software Foundation, Inc.\n+   2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1009,8 +1009,8 @@ status_warning VPARAMS ((int *status, const char *msgid, ...))\n   else\n     {\n       /* This duplicates the warning function behavior.  */\n-      diagnostic_set_info (&diagnostic, _(msgid), &ap, input_filename, lineno,\n-                           DK_WARNING);\n+      diagnostic_set_info (&diagnostic, _(msgid), &ap,\n+\t\t\t   input_filename, input_line, DK_WARNING);\n       report_diagnostic (&diagnostic);\n     }\n "}, {"sha": "ea0f80c7b83263987807a4b4d9e7852d3db771b9", "filename": "gcc/c-lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -228,7 +228,7 @@ fe_file_change (new_map)\n \t{\n           int included_at = SOURCE_LINE (new_map - 1, new_map->from_line - 1);\n \n-\t  lineno = included_at;\n+\t  input_line = included_at;\n \t  push_srcloc (new_map->to_file, 1);\n \t  (*debug_hooks->start_source_file) (included_at, new_map->to_file);\n #ifndef NO_IMPLICIT_EXTERN_C\n@@ -260,7 +260,7 @@ fe_file_change (new_map)\n   update_header_times (new_map->to_file);\n   in_system_header = new_map->sysp != 0;\n   input_filename = new_map->to_file;\n-  lineno = to_line;\n+  input_line = to_line;\n   map = new_map;\n \n   /* Hook for C++.  */\n@@ -290,7 +290,7 @@ cb_def_pragma (pfile, line)\n \t    name = cpp_token_as_text (pfile, s);\n \t}\n \n-      lineno = SOURCE_LINE (map, line);\n+      input_line = SOURCE_LINE (map, line);\n       warning (\"ignoring #pragma %s %s\", space, name);\n     }\n }\n@@ -333,7 +333,7 @@ c_lex (value)\n   /* The C++ front end does horrible things with the current line\n      number.  To ensure an accurate line number, we must reset it\n      every time we return a token.  */\n-  lineno = src_lineno;\n+  input_line = src_lineno;\n \n   *value = NULL_TREE;\n   switch (tok->type)"}, {"sha": "ee7be16ce1c8d6b4c343fe396cda74f25639c218", "filename": "gcc/c-opts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1564,16 +1564,16 @@ c_common_post_options (pfilename)\n       init_c_lex ();\n \n       /* Yuk.  WTF is this?  I do know ObjC relies on it somewhere.  */\n-      lineno = 0;\n+      input_line = 0;\n     }\n \n   cpp_get_callbacks (parse_in)->file_change = cb_file_change;\n \n   /* NOTE: we use in_fname here, not the one supplied.  */\n   *pfilename = cpp_read_main_file (parse_in, in_fname);\n \n-  saved_lineno = lineno;\n-  lineno = 0;\n+  saved_lineno = input_line;\n+  input_line = 0;\n \n   /* If an error has occurred in cpplib, note it so we fail\n      immediately.  */\n@@ -1586,7 +1586,7 @@ c_common_post_options (pfilename)\n bool\n c_common_init ()\n {\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n \n   /* Set up preprocessor arithmetic.  Must be done after call to\n      c_common_nodes_and_builtins for type nodes to be good.  */\n@@ -1624,7 +1624,7 @@ c_common_parse_file (set_yydebug)\n   warning (\"YYDEBUG not defined\");\n #endif\n \n-  (*debug_hooks->start_source_file) (lineno, input_filename);\n+  (*debug_hooks->start_source_file) (input_line, input_filename);\n   finish_options();\n   pch_init();\n   yyparse ();"}, {"sha": "807f90a9048918dd5383420e0ccffa3d42e6e061", "filename": "gcc/c-parse.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,6 +1,6 @@\n-/* YACC parser for C syntax and for Objective C.  -*-c-*-\n+ /* YACC parser for C syntax and for Objective C.  -*-c-*-\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996,\n-   1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -138,6 +138,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* String constants in raw form.\n    yylval is a STRING_CST node.  */\n+\n %token STRING\n \n /* \"...\", used for functions with variable arglists.  */\n@@ -2250,7 +2251,7 @@ save_filename:\n save_lineno:\n \t\t{ if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n-\t\t  $$ = lineno; }\n+\t\t  $$ = input_line; }\n \t;\n \n lineno_labeled_stmt:\n@@ -2455,10 +2456,10 @@ label:\t  CASE expr_no_commas ':'\n \n maybe_type_qual:\n \t/* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n+\t\t{ emit_line_note (input_filename, input_line);\n \t\t  $$ = NULL_TREE; }\n \t| TYPE_QUAL\n-\t\t{ emit_line_note (input_filename, lineno); }\n+\t\t{ emit_line_note (input_filename, input_line); }\n \t;\n \n xexpr:\n@@ -3690,11 +3691,11 @@ ifc\n       static int last_lineno = 0;\n       static const char *last_input_filename = 0;\n       if (warn_traditional && !in_system_header\n-\t  && (lineno != last_lineno || !last_input_filename ||\n+\t  && (input_line != last_lineno || !last_input_filename ||\n \t      strcmp (last_input_filename, input_filename)))\n \t{\n \t  warning (\"traditional C rejects string concatenation\");\n-\t  last_lineno = lineno;\n+\t  last_lineno = input_line;\n \t  last_input_filename = input_filename;\n \t}\n end ifc"}, {"sha": "19ea48ebd12d0160b99c3fc7567ceea9ca7e4e2f", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -181,7 +181,7 @@ finish_stmt_tree (t)\n     {\n       /* The line-number recorded in the outermost statement in a function\n \t is the line number of the end of the function.  */\n-      STMT_LINENO (stmt) = lineno;\n+      STMT_LINENO (stmt) = input_line;\n       STMT_LINENO_FOR_FN_P (stmt) = 1;\n     }\n }\n@@ -204,7 +204,7 @@ build_stmt VPARAMS ((enum tree_code code, ...))\n \n   t = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n-  STMT_LINENO (t) = lineno;\n+  STMT_LINENO (t) = input_line;\n \n   for (i = 0; i < length; i++)\n     TREE_OPERAND (t, i) = va_arg (p, tree);\n@@ -301,7 +301,7 @@ emit_local_var (decl)\n void\n genrtl_do_pushlevel ()\n {\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   clear_last_expr ();\n }\n \n@@ -319,7 +319,7 @@ genrtl_goto_stmt (destination)\n   if (TREE_CODE (destination) == LABEL_DECL)\n     TREE_USED (destination) = 1;\n   \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   \n   if (TREE_CODE (destination) == LABEL_DECL)\n     {\n@@ -355,7 +355,7 @@ genrtl_expr_stmt_value (expr, want_value, maybe_last)\n {\n   if (expr != NULL_TREE)\n     {\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       \n       if (stmts_are_full_exprs_p ())\n \texpand_start_target_temps ();\n@@ -375,7 +375,7 @@ genrtl_decl_stmt (t)\n      tree t;\n {\n   tree decl;\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   decl = DECL_STMT_DECL (t);\n   /* If this is a declaration for an automatic local\n      variable, initialize it.  Note that we might also see a\n@@ -412,7 +412,7 @@ genrtl_if_stmt (t)\n   tree cond;\n   genrtl_do_pushlevel ();\n   cond = expand_cond (IF_COND (t));\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   expand_start_cond (cond, 0);\n   if (THEN_CLAUSE (t))\n     {\n@@ -442,14 +442,14 @@ genrtl_while_stmt (t)\n   tree cond = WHILE_COND (t);\n \n   emit_nop ();\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   expand_start_loop (1); \n   genrtl_do_pushlevel ();\n \n   if (cond && !integer_nonzerop (cond))\n     {\n       cond = expand_cond (cond);\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_exit_loop_top_cond (0, cond);\n       genrtl_do_pushlevel ();\n     }\n@@ -481,25 +481,25 @@ genrtl_do_stmt (t)\n   else if (integer_nonzerop (cond))\n     {\n       emit_nop ();\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_start_loop (1);\n \n       expand_stmt (DO_BODY (t));\n \n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_end_loop ();\n     }\n   else\n     {\n       emit_nop ();\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_start_loop_continue_elsewhere (1);\n \n       expand_stmt (DO_BODY (t));\n \n       expand_loop_continue_here ();\n       cond = expand_cond (cond);\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_exit_loop_if_false (0, cond);\n       expand_end_loop ();\n     }\n@@ -524,7 +524,7 @@ genrtl_return_stmt (stmt)\n \n   expr = RETURN_STMT_EXPR (stmt);\n \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   if (!expr)\n     expand_null_return ();\n   else\n@@ -552,7 +552,7 @@ genrtl_for_stmt (t)\n \n   /* Expand the initialization.  */\n   emit_nop ();\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   if (FOR_EXPR (t))\n     expand_start_loop_continue_elsewhere (1); \n   else\n@@ -562,13 +562,13 @@ genrtl_for_stmt (t)\n   /* Save the filename and line number so that we expand the FOR_EXPR\n      we can reset them back to the saved values.  */\n   saved_filename = input_filename;\n-  saved_lineno = lineno;\n+  saved_lineno = input_line;\n \n   /* Expand the condition.  */\n   if (cond && !integer_nonzerop (cond))\n     {\n       cond = expand_cond (cond);\n-      emit_line_note (input_filename, lineno);\n+      emit_line_note (input_filename, input_line);\n       expand_exit_loop_top_cond (0, cond);\n       genrtl_do_pushlevel ();\n     }\n@@ -578,8 +578,8 @@ genrtl_for_stmt (t)\n \n   /* Expand the increment expression.  */\n   input_filename = saved_filename;\n-  lineno = saved_lineno;\n-  emit_line_note (input_filename, lineno);\n+  input_line = saved_lineno;\n+  emit_line_note (input_filename, input_line);\n   if (FOR_EXPR (t))\n     {\n       expand_loop_continue_here ();\n@@ -601,7 +601,7 @@ build_break_stmt ()\n void\n genrtl_break_stmt ()\n {\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   if ( ! expand_exit_something ())\n     error (\"break statement not within loop or switch\");\n }\n@@ -619,7 +619,7 @@ build_continue_stmt ()\n void\n genrtl_continue_stmt ()\n {\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   if (! expand_continue_loop (0))\n     error (\"continue statement not within a loop\");   \n }\n@@ -685,7 +685,7 @@ genrtl_switch_stmt (t)\n        crash.  */\n     cond = boolean_false_node;\n \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   expand_start_case (1, cond, TREE_TYPE (cond), \"switch statement\");\n   expand_unreachable_stmt (SWITCH_BODY (t), warn_notreached);\n   expand_end_case_type (cond, SWITCH_TYPE (t));\n@@ -768,13 +768,13 @@ genrtl_asm_stmt (cv_qualifier, string, output_operands,\n       cv_qualifier = NULL_TREE;\n     }\n \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   if (asm_input_p)\n     expand_asm (string, cv_qualifier != NULL_TREE);\n   else\n     c_expand_asm_operands (string, output_operands, input_operands, \n \t\t\t   clobbers, cv_qualifier != NULL_TREE,\n-\t\t\t   input_filename, lineno);\n+\t\t\t   input_filename, input_line);\n }\n \n /* Generate the RTL for a CLEANUP_STMT.  */\n@@ -796,7 +796,7 @@ prep_stmt (t)\n      tree t;\n {\n   if (!STMT_LINENO_FOR_FN_P (t))\n-    lineno = STMT_LINENO (t);\n+    input_line = STMT_LINENO (t);\n   current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n }\n \n@@ -951,11 +951,11 @@ static tree\n find_reachable_label (exp)\n      tree exp;\n {\n-  int line = lineno;\n+  int line = input_line;\n   const char *file = input_filename;\n   tree ret = walk_tree (&exp, find_reachable_label_1, NULL, NULL);\n   input_filename = file;\n-  lineno = line;\n+  input_line = line;\n   return ret;\n }\n \n@@ -1025,7 +1025,7 @@ expand_unreachable_stmt (t, warn)\n \t  case IF_STMT:\n \t  case RETURN_STMT:\n \t    if (!STMT_LINENO_FOR_FN_P (t))\n-\t      lineno = STMT_LINENO (t);\n+\t      input_line = STMT_LINENO (t);\n \t    warning(\"will never be executed\");\n \t    warn = false;\n \t    break;"}, {"sha": "6d8ae9a55fba15dbe1462422931d014eb616df19", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -800,7 +800,7 @@ create_coverage ()\n   current_function_decl = ctor;\n   DECL_INITIAL (ctor) = error_mark_node;\n   make_decl_rtl (ctor, NULL);\n-  init_function_start (ctor, input_filename, lineno);\n+  init_function_start (ctor, input_filename, input_line);\n   (*lang_hooks.decls.pushlevel) (0);\n   expand_function_start (ctor, 0);\n   cfun->arc_profile = 0;\n@@ -810,7 +810,7 @@ create_coverage ()\n   emit_library_call (gcov_init_libfunc, LCT_NORMAL, VOIDmode, 1,\n \t\t     gcov_info_address, Pmode);\n \n-  expand_function_end (input_filename, lineno, 0);\n+  expand_function_end (input_filename, input_line, 0);\n   (*lang_hooks.decls.poplevel) (1, 0, 1);\n \n   /* Since ctor isn't in the list of globals, it would never be emitted"}, {"sha": "e45781eda57e596e6f934c327fe7c35f3fd2677e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -5252,7 +5252,7 @@ tree\n finish_struct (tree t, tree attributes)\n {\n   const char *saved_filename = input_filename;\n-  int saved_lineno = lineno;\n+  int saved_lineno = input_line;\n \n   /* Now that we've got all the field declarations, reverse everything\n      as necessary.  */\n@@ -5263,7 +5263,7 @@ finish_struct (tree t, tree attributes)\n   /* Nadger the current location so that diagnostics point to the start of\n      the struct, not the end.  */\n   input_filename = DECL_SOURCE_FILE (TYPE_NAME (t));\n-  lineno = DECL_SOURCE_LINE (TYPE_NAME (t));\n+  input_line = DECL_SOURCE_LINE (TYPE_NAME (t));\n \n   if (processing_template_decl)\n     {\n@@ -5274,7 +5274,7 @@ finish_struct (tree t, tree attributes)\n     finish_struct_1 (t);\n \n   input_filename = saved_filename;\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n \n   TYPE_BEING_DEFINED (t) = 0;\n "}, {"sha": "6e04cef2e19af3d2de84b08df2daef5f02acf1b1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -495,7 +495,7 @@ push_binding_level (struct cp_binding_level *newlevel,\n   newlevel->binding_depth = binding_depth;\n   indent ();\n   fprintf (stderr, \"push %s level 0x%08x line %d\\n\",\n-\t   (is_class_level) ? \"class\" : \"block\", newlevel, lineno);\n+\t   (is_class_level) ? \"class\" : \"block\", newlevel, input_line);\n   is_class_level = 0;\n   binding_depth++;\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n@@ -532,7 +532,7 @@ pop_binding_level (void)\n   indent ();\n   fprintf (stderr, \"pop  %s level 0x%08x line %d\\n\",\n \t  (is_class_level) ? \"class\" : \"block\",\n-\t  current_binding_level, lineno);\n+\t  current_binding_level, input_line);\n   if (is_class_level != (current_binding_level == class_binding_level))\n     {\n       indent ();\n@@ -571,7 +571,7 @@ suspend_binding_level (void)\n   indent ();\n   fprintf (stderr, \"suspend  %s level 0x%08x line %d\\n\",\n \t  (is_class_level) ? \"class\" : \"block\",\n-\t  current_binding_level, lineno);\n+\t  current_binding_level, input_line);\n   if (is_class_level != (current_binding_level == class_binding_level))\n     {\n       indent ();\n@@ -596,7 +596,7 @@ resume_binding_level (struct cp_binding_level* b)\n   b->binding_depth = binding_depth;\n   indent ();\n   fprintf (stderr, \"resume %s level 0x%08x line %d\\n\",\n-\t   (is_class_level) ? \"class\" : \"block\", b, lineno);\n+\t   (is_class_level) ? \"class\" : \"block\", b, input_line);\n   is_class_level = 0;\n   binding_depth++;\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n@@ -4598,7 +4598,7 @@ make_label_decl (tree id, int local_p)\n \n   /* Say where one reference is to the label, for the sake of the\n      error if it is not defined.  */\n-  DECL_SOURCE_LINE (decl) = lineno;\n+  DECL_SOURCE_LINE (decl) = input_line;\n   DECL_SOURCE_FILE (decl) = input_filename;\n \n   /* Record the fact that this identifier is bound to this label.  */\n@@ -4625,7 +4625,7 @@ use_label (tree decl)\n       new_ent->label_decl = decl;\n       new_ent->names_in_scope = current_binding_level->names;\n       new_ent->binding_level = current_binding_level;\n-      new_ent->o_goto_locus.line = lineno;\n+      new_ent->o_goto_locus.line = input_line;\n       new_ent->o_goto_locus.file = input_filename;\n       new_ent->next = named_label_uses;\n       named_label_uses = new_ent;\n@@ -13486,7 +13486,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n      CFUN set up, and our per-function variables initialized.\n      FIXME factor out the non-RTL stuff.  */\n   bl = current_binding_level;\n-  init_function_start (decl1, input_filename, lineno);\n+  init_function_start (decl1, input_filename, input_line);\n   current_binding_level = bl;\n \n   /* Even though we're inside a function body, we still don't want to"}, {"sha": "71192ef7892794b2f1d8e67b51e7591ad1c6a71d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -178,17 +178,17 @@ warn_if_unknown_interface (tree decl)\n   if (flag_alt_external_templates)\n     {\n       tree til = tinst_for_decl ();\n-      int sl = lineno;\n+      int sl = input_line;\n       const char *sf = input_filename;\n \n       if (til)\n \t{\n-\t  lineno = TINST_LINE (til);\n+\t  input_line = TINST_LINE (til);\n \t  input_filename = TINST_FILE (til);\n \t}\n       warning (\"template `%#D' instantiated in file without #pragma interface\",\n \t\t  decl);\n-      lineno = sl;\n+      input_line = sl;\n       input_filename = sf;\n     }\n   else\n@@ -2234,7 +2234,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n      that the debugger will show somewhat sensible file and line\n      information.  */\n   input_filename = DECL_SOURCE_FILE (decl);\n-  lineno = DECL_SOURCE_LINE (decl);\n+  input_line = DECL_SOURCE_LINE (decl);\n \n   /* Because of:\n \n@@ -2475,7 +2475,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n   size_t i;\n \n   input_filename = locus->file;\n-  lineno = locus->line++;\n+  input_line = locus->line++;\n   \n   /* We use `I' to indicate initialization and `D' to indicate\n      destruction.  */\n@@ -2555,7 +2555,7 @@ finish_file ()\n   unsigned ssdf_count = 0;\n \n   locus.file = input_filename;\n-  locus.line = lineno;\n+  locus.line = input_line;\n   at_eof = 1;\n \n   /* Bad parse errors.  Just forget about it.  */\n@@ -2567,7 +2567,7 @@ finish_file ()\n \n   /* Otherwise, GDB can get confused, because in only knows\n      about source for LINENO-1 lines.  */\n-  lineno -= 1;\n+  input_line -= 1;\n \n   interface_unknown = 1;\n   interface_only = 0;\n@@ -2687,7 +2687,7 @@ finish_file ()\n \t  /* Set the line and file, so that it is obviously not from\n \t     the source file.  */\n \t  input_filename = locus.file;\n-\t  lineno = locus.line;\n+\t  input_line = locus.line;\n \t  ssdf_body = start_static_storage_duration_function (ssdf_count);\n \n \t  /* Make sure the back end knows about all the variables.  */\n@@ -2716,7 +2716,7 @@ finish_file ()\n \t  /* Finish up the static storage duration function for this\n \t     round.  */\n \t  input_filename = locus.file;\n-\t  lineno = locus.line;\n+\t  input_line = locus.line;\n \t  finish_static_storage_duration_function (ssdf_body);\n \n \t  /* All those initializations and finalizations might cause\n@@ -2906,7 +2906,7 @@ finish_file ()\n       dump_time_statistics ();\n     }\n   input_filename = locus.file;\n-  lineno = locus.line;\n+  input_line = locus.line;\n }\n \n /* T is the parse tree for an expression.  Return the expression after"}, {"sha": "ee92aa842d982da97c9a97121e263657e34548ad", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,7 +1,7 @@\n /* Call-backs for C++ error reporting.\n    This code is non-reentrant.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,\n+   2003 Free Software Foundation, Inc.\n    This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify\n@@ -2159,7 +2159,7 @@ cp_line_of (tree t)\n     line = DECL_SOURCE_LINE (t);\n \n   if (line == 0)\n-    return lineno;\n+    return input_line;\n \n   return line;\n }\n@@ -2406,7 +2406,7 @@ static void\n print_instantiation_full_context (diagnostic_context *context)\n {\n   tree p = current_instantiation ();\n-  int line = lineno;\n+  int line = input_line;\n   const char *file = input_filename;\n \n   if (p)\n@@ -2468,7 +2468,7 @@ void\n print_instantiation_context (void)\n {\n   print_instantiation_partial_context\n-    (global_dc, current_instantiation (), input_filename, lineno);\n+    (global_dc, current_instantiation (), input_filename, input_line);\n   diagnostic_flush_buffer (global_dc);\n }\n \f"}, {"sha": "b8576be061a827d94116b8ff8dafab283eeaae70", "filename": "gcc/cp/except.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -915,10 +915,10 @@ check_handlers_1 (tree master, tree handlers)\n     if (TREE_TYPE (handler)\n \t&& can_convert_eh (type, TREE_TYPE (handler)))\n       {\n-\tlineno = STMT_LINENO (handler);\n+\tinput_line = STMT_LINENO (handler);\n \twarning (\"exception of type `%T' will be caught\",\n \t\t    TREE_TYPE (handler));\n-\tlineno = STMT_LINENO (master);\n+\tinput_line = STMT_LINENO (master);\n \twarning (\"   by earlier handler for `%T'\", type);\n \tbreak;\n       }\n@@ -930,19 +930,20 @@ void\n check_handlers (tree handlers)\n {\n   tree handler;\n-  int save_line = lineno;\n+  int save_line = input_line;\n+  \n   for (handler = handlers; handler; handler = TREE_CHAIN (handler))\n     {\n       if (TREE_CHAIN (handler) == NULL_TREE)\n \t/* No more handlers; nothing to shadow.  */;\n       else if (TREE_TYPE (handler) == NULL_TREE)\n \t{\n-\t  lineno = STMT_LINENO (handler);\n+\t  input_line = STMT_LINENO (handler);\n \t  pedwarn\n \t    (\"`...' handler must be the last handler for its try block\");\n \t}\n       else\n \tcheck_handlers_1 (handler, TREE_CHAIN (handler));\n     }\n-  lineno = save_line;\n+  input_line = save_line;\n }"}, {"sha": "96f7e77e7d03444681799e01b37ca63cbd0aac86", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -2676,7 +2676,7 @@ create_temporary_var (type)\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_SOURCE_FILE (decl) = input_filename;\n-  DECL_SOURCE_LINE (decl) = lineno;\n+  DECL_SOURCE_LINE (decl) = input_line;\n   DECL_IGNORED_P (decl) = 1;\n   DECL_CONTEXT (decl) = current_function_decl;\n "}, {"sha": "fd61d20cb511d73c4672b06f220aec7961bbdffd", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,7 +1,7 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -429,7 +429,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       DECL_RESULT (thunk_fndecl)\n \t= build_decl (RESULT_DECL, 0, integer_type_node);\n       fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n-      init_function_start (thunk_fndecl, input_filename, lineno);\n+      init_function_start (thunk_fndecl, input_filename, input_line);\n       current_function_is_thunk = 1;\n       assemble_start_function (thunk_fndecl, fnname);\n \n@@ -754,7 +754,7 @@ synthesize_method (tree fndecl)\n      where the attempt to generate the function occurs, giving the\n      user a hint as to why we are attempting to generate the\n      function.  */\n-  DECL_SOURCE_LINE (fndecl) = lineno;\n+  DECL_SOURCE_LINE (fndecl) = input_line;\n   DECL_SOURCE_FILE (fndecl) = input_filename;\n \n   interface_unknown = 1;"}, {"sha": "3664302b83b75c4507af2e46452acd1710614c87", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -407,7 +407,7 @@ cp_lexer_set_source_position_from_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n   /* Update the line number.  */\n   if (token->type != CPP_EOF)\n     {\n-      lineno = token->line_number;\n+      input_line = token->line_number;\n       input_filename = token->file_name;\n     }\n }\n@@ -651,7 +651,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \t}\n     }\n   /* Now we've got our token.  */\n-  token->line_number = lineno;\n+  token->line_number = input_line;\n   token->file_name = input_filename;\n \n   /* Check to see if this token is a keyword.  */"}, {"sha": "45c99f9c5f1a36de91487a8fcd644c7fb8436486", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -4785,7 +4785,7 @@ push_tinst_level (d)\n       return 0;\n     }\n \n-  new = build_expr_wfl (d, input_filename, lineno, 0);\n+  new = build_expr_wfl (d, input_filename, input_line, 0);\n   TREE_CHAIN (new) = current_tinst_level;\n   current_tinst_level = new;\n \n@@ -4809,7 +4809,7 @@ pop_tinst_level ()\n \n   /* Restore the filename and line number stashed away when we started\n      this instantiation.  */\n-  lineno = TINST_LINE (old);\n+  input_line = TINST_LINE (old);\n   input_filename = TINST_FILE (old);\n   extract_interface_info ();\n   \n@@ -4861,10 +4861,10 @@ tsubst_friend_function (decl, args)\n      tree args;\n {\n   tree new_friend;\n-  int line = lineno;\n+  int line = input_line;\n   const char *file = input_filename;\n \n-  lineno = DECL_SOURCE_LINE (decl);\n+  input_line = DECL_SOURCE_LINE (decl);\n   input_filename = DECL_SOURCE_FILE (decl);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL \n@@ -5072,7 +5072,7 @@ tsubst_friend_function (decl, args)\n     }\n \n  done:\n-  lineno = line;\n+  input_line = line;\n   input_filename = file;\n   return new_friend;\n }\n@@ -5432,10 +5432,11 @@ instantiate_class_template (type)\n \t\t{\n \t\t  tree r;\n \n-\t\t  /* The the file and line for this declaration, to assist\n-\t\t     in error message reporting.  Since we called \n-\t\t     push_tinst_level above, we don't need to restore these.  */\n-\t\t  lineno = DECL_SOURCE_LINE (t);\n+\t\t  /* The the file and line for this declaration, to\n+\t\t     assist in error message reporting.  Since we\n+\t\t     called push_tinst_level above, we don't need to\n+\t\t     restore these.  */\n+\t\t  input_line = DECL_SOURCE_LINE (t);\n \t\t  input_filename = DECL_SOURCE_FILE (t);\n \n \t\t  r = tsubst (t, args, tf_error | tf_warning, NULL_TREE);\n@@ -5538,7 +5539,7 @@ instantiate_class_template (type)\n      implicit functions at a predictable point, and the same point\n      that would be used for non-template classes.  */\n   typedecl = TYPE_MAIN_DECL (type);\n-  lineno = DECL_SOURCE_LINE (typedecl);\n+  input_line = DECL_SOURCE_LINE (typedecl);\n   input_filename = DECL_SOURCE_FILE (typedecl);\n \n   unreverse_member_declarations (type);\n@@ -5883,9 +5884,9 @@ tsubst_decl (t, args, type, complain)\n   tree in_decl = t;\n \n   /* Set the filename and linenumber to improve error-reporting.  */\n-  saved_lineno = lineno;\n+  saved_lineno = input_line;\n   saved_filename = input_filename;\n-  lineno = DECL_SOURCE_LINE (t);\n+  input_line = DECL_SOURCE_LINE (t);\n   input_filename = DECL_SOURCE_FILE (t);\n \n   switch (TREE_CODE (t))\n@@ -6352,7 +6353,7 @@ tsubst_decl (t, args, type, complain)\n     } \n \n   /* Restore the file and line information.  */\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n   input_filename = saved_filename;\n \n   return r;\n@@ -6875,15 +6876,15 @@ tsubst (t, args, complain, in_decl)\n \t       message to avoid spewing a ton of messages during a\n \t       single bad template instantiation.  */\n \t    if (complain & tf_error\n-\t\t&& (last_line != lineno || last_file != input_filename))\n+\t\t&& (last_line != input_line || last_file != input_filename))\n \t      {\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n \t\t  error (\"forming reference to void\");\n \t\telse\n \t\t  error (\"forming %s to reference type `%T'\",\n \t\t\t    (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n \t\t\t    type);\n-\t\tlast_line = lineno;\n+\t\tlast_line = input_line;\n \t\tlast_file = input_filename;\n \t      }\n \n@@ -7779,7 +7780,7 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case LABEL_STMT:\n-      lineno = STMT_LINENO (t);\n+      input_line = STMT_LINENO (t);\n       finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n       break;\n \n@@ -10758,7 +10759,7 @@ instantiate_decl (d, defer_ok)\n   tree spec;\n   tree gen_tmpl;\n   int pattern_defined;\n-  int line = lineno;\n+  int line = input_line;\n   int need_push;\n   const char *file = input_filename;\n \n@@ -10824,7 +10825,7 @@ instantiate_decl (d, defer_ok)\n   else\n     pattern_defined = ! DECL_IN_AGGR_P (code_pattern);\n \n-  lineno = DECL_SOURCE_LINE (d);\n+  input_line = DECL_SOURCE_LINE (d);\n   input_filename = DECL_SOURCE_FILE (d);\n \n   if (pattern_defined)\n@@ -10912,7 +10913,7 @@ instantiate_decl (d, defer_ok)\n      because it's used by add_pending_template.  */\n   else if (! pattern_defined || defer_ok)\n     {\n-      lineno = line;\n+      input_line = line;\n       input_filename = file;\n \n       if (at_eof && !pattern_defined \n@@ -10941,7 +10942,7 @@ instantiate_decl (d, defer_ok)\n   \n   /* We already set the file and line above.  Reset them now in case\n      they changed as a result of calling regenerate_decl_from_template.  */\n-  lineno = DECL_SOURCE_LINE (d);\n+  input_line = DECL_SOURCE_LINE (d);\n   input_filename = DECL_SOURCE_FILE (d);\n \n   if (TREE_CODE (d) == VAR_DECL)\n@@ -11047,7 +11048,7 @@ instantiate_decl (d, defer_ok)\n     pop_from_top_level ();\n \n out:\n-  lineno = line;\n+  input_line = line;\n   input_filename = file;\n \n   pop_tinst_level ();"}, {"sha": "a527abbef6456601feeefa58d60688e66bbd02c9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -745,7 +745,7 @@ genrtl_try_block (t)\n   else\n     {\n       if (!FN_TRY_BLOCK_P (t)) \n-\temit_line_note (input_filename, lineno);\n+\temit_line_note (input_filename, input_line);\n \n       expand_eh_region_start ();\n       expand_stmt (TRY_STMTS (t));\n@@ -1105,7 +1105,7 @@ tree\n finish_label_stmt (name)\n      tree name;\n {\n-  tree decl = define_label (input_filename, lineno, name);\n+  tree decl = define_label (input_filename, input_line, name);\n   return add_stmt (build_stmt (LABEL_STMT, decl));\n }\n \n@@ -1805,7 +1805,7 @@ begin_class_definition (t)\n \n   /* Update the location of the decl.  */\n   DECL_SOURCE_FILE (TYPE_NAME (t)) = input_filename;\n-  DECL_SOURCE_LINE (TYPE_NAME (t)) = lineno;\n+  DECL_SOURCE_LINE (TYPE_NAME (t)) = input_line;\n   \n   if (TYPE_BEING_DEFINED (t))\n     {\n@@ -2386,10 +2386,10 @@ expand_body (fn)\n   /* Save the current file name and line number.  When we expand the\n      body of the function, we'll set LINENO and INPUT_FILENAME so that\n      error-mesages come out in the right places.  */\n-  saved_lineno = lineno;\n+  saved_lineno = input_line;\n   saved_input_filename = input_filename;\n   saved_function = current_function_decl;\n-  lineno = DECL_SOURCE_LINE (fn);\n+  input_line = DECL_SOURCE_LINE (fn);\n   input_filename = DECL_SOURCE_FILE (fn);\n   current_function_decl = fn;\n \n@@ -2413,7 +2413,7 @@ expand_body (fn)\n \n   /* The outermost statement for a function contains the line number\n      recorded when we finished processing the function.  */\n-  lineno = STMT_LINENO (DECL_SAVED_TREE (fn));\n+  input_line = STMT_LINENO (DECL_SAVED_TREE (fn));\n \n   /* Generate code for the function.  */\n   genrtl_finish_function (fn);\n@@ -2433,7 +2433,7 @@ expand_body (fn)\n \n   /* And restore the current source position.  */\n   current_function_decl = saved_function;\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n   input_filename = saved_input_filename;\n   extract_interface_info ();\n \n@@ -2577,7 +2577,7 @@ genrtl_finish_function (fn)\n   immediate_size_expand = 1;\n \n   /* Generate rtl for function exit.  */\n-  expand_function_end (input_filename, lineno, 0);\n+  expand_function_end (input_filename, input_line, 0);\n \n   /* If this is a nested function (like a template instantiation that\n      we're compiling in the midst of compiling something else), push a"}, {"sha": "0566a09d5c88885d7eb578773469480f22f6bb87", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1512,7 +1512,7 @@ build_min_nt VPARAMS ((enum tree_code code, ...))\n \n   t = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n-  TREE_COMPLEXITY (t) = lineno;\n+  TREE_COMPLEXITY (t) = input_line;\n \n   for (i = 0; i < length; i++)\n     {\n@@ -1541,7 +1541,7 @@ build_min VPARAMS ((enum tree_code code, tree tt, ...))\n   t = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n   TREE_TYPE (t) = tt;\n-  TREE_COMPLEXITY (t) = lineno;\n+  TREE_COMPLEXITY (t) = input_line;\n \n   for (i = 0; i < length; i++)\n     {"}, {"sha": "565e073c5738041931f864074ea9e85e7dee020f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* Language-independent diagnostic subroutines for the GNU Compiler Collection\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GCC.\n@@ -961,7 +961,7 @@ pedwarn VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, _(msgid), &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, _(msgid), &ap, input_filename, input_line,\n                        pedantic_error_kind ());\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n@@ -1019,7 +1019,7 @@ sorry VPARAMS ((const char *msgid, ...))\n \n   ++sorrycount;\n   diagnostic_set_info (&diagnostic, _(msgid), &ap,\n-                       input_filename, lineno, DK_SORRY);\n+                       input_filename, input_line, DK_SORRY);\n \n   output_set_prefix\n     (&global_dc->buffer, diagnostic_build_prefix (&diagnostic));\n@@ -1136,7 +1136,7 @@ error VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        DK_ERROR);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n@@ -1153,7 +1153,7 @@ fatal_error VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        DK_FATAL);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n@@ -1177,15 +1177,15 @@ internal_error VPARAMS ((const char *msgid, ...))\n   if (errorcount > 0 || sorrycount > 0)\n     {\n       fnotice (stderr, \"%s:%d: confused by earlier errors, bailing out\\n\",\n-\t       input_filename, lineno);\n+\t       input_filename, input_line);\n       exit (FATAL_EXIT_CODE);\n     }\n #endif\n \n   if (global_dc->internal_error != 0)\n     (*global_dc->internal_error) (_(msgid), &ap);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        DK_ICE);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n@@ -1236,7 +1236,7 @@ warning VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        DK_WARNING);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n@@ -1382,10 +1382,12 @@ diagnostic_report_current_module (context)\n       for (p = input_file_stack->next; p; p = p->next)\n \tif (p == input_file_stack->next)\n \t  output_verbatim (&context->buffer,\n-                           \"In file included from %s:%d\", p->name, p->line);\n+                           \"In file included from %s:%d\",\n+\t\t\t   p->name, p->line);\n \telse\n \t  output_verbatim (&context->buffer,\n-                           \",\\n                 from %s:%d\", p->name, p->line);\n+                           \",\\n                 from %s:%d\",\n+\t\t\t   p->name, p->line);\n       output_verbatim (&context->buffer, \":\\n\");\n       diagnostic_set_last_module (context);\n     }\n@@ -1416,7 +1418,7 @@ inform VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, input_line,\n                        DK_NOTE);\n   report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);"}, {"sha": "cbd481175020cc980522f8a0821aab4406879488", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -6933,15 +6933,15 @@ expand_expr (exp, target, tmode, modifier)\n       {\n \trtx to_return;\n \tconst char *saved_input_filename = input_filename;\n-\tint saved_lineno = lineno;\n+\tint saved_lineno = input_line;\n \tinput_filename = EXPR_WFL_FILENAME (exp);\n-\tlineno = EXPR_WFL_LINENO (exp);\n+\tinput_line = EXPR_WFL_LINENO (exp);\n \tif (EXPR_WFL_EMIT_LINE_NOTE (exp))\n-\t  emit_line_note (input_filename, lineno);\n+\t  emit_line_note (input_filename, input_line);\n \t/* Possibly avoid switching back and forth here.  */\n \tto_return = expand_expr (EXPR_WFL_NODE (exp), target, tmode, modifier);\n \tinput_filename = saved_input_filename;\n-\tlineno = saved_lineno;\n+\tinput_line = saved_lineno;\n \treturn to_return;\n       }\n "}, {"sha": "a1c16a51d2e7021498cd212db7ae344188677f42", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,19 @@\n 2003-05-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* ansify.c (die_unless): Rename lineno to input_line.\n+\t* com.c (ffecom_subscript_check_, ffecom_do_entry_,\n+\tffecom_gen_sfuncdef_, ffecom_start_progunit_,\n+\tffecom_sym_transform_, ffecom_sym_transform_assign_,\n+\tbison_rule_pushlevel_, bison_rule_compstmt_, finish_function,\n+\tstore_parm_decls): Likewise.\n+\t* intrin.c (ffeintrin_fulfill_generic): Likewise.\n+\t* lex.c (ffelex_hash_, ffelex_include_, ffelex_next_line_,\n+\tffelex_file_fixed, ffelex_file_free): Likewise.\n+\t* std.c (ffestd_exec_end): Likewise.\n+\t* ste.c (ffeste_emit_line_note_, ffeste_start_block_,\n+\tffeste_start_stmt_): Likewise.\n+\t* ste.h (ffeste_filelinenum, ffeste_set_line): Likewise.\n+\n \t* lex.c (ffelex_file_pop_): Rename parameter from input_filename.\n \t(ffelex_file_push_): Likewise.\n \t"}, {"sha": "fa29dfc674fb052035d7c72833e26156255645ad", "filename": "gcc/f/ansify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fansify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fansify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fansify.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* ansify.c\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 2003 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -27,7 +27,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define die_unless(c) \\\n   do if (!(c)) \\\n     { \\\n-      fprintf (stderr, \"%s:%lu: %s\\n\", argv[1], lineno, #c); \\\n+      fprintf (stderr, \"%s:%lu: %s\\n\", argv[1], input_line, #c); \\\n       die (); \\\n     } \\\n   while(0)"}, {"sha": "a84f8076032d1d0def09e6507b20dd228ab1a4a6", "filename": "gcc/f/com.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -791,7 +791,7 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n \t\t     arg3);\n \n     arg4 = convert (ffecom_f2c_ftnint_type_node,\n-\t\t    build_int_2 (lineno, 0));\n+\t\t    build_int_2 (input_line, 0));\n \n     arg1 = build_tree_list (NULL_TREE, arg1);\n     arg2 = build_tree_list (NULL_TREE, arg2);\n@@ -2583,11 +2583,11 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n   bool cmplxfunc;\t\t/* Use f2c way of returning COMPLEX. */\n   bool multi;\t\t\t/* Master fn has multiple return types. */\n   bool altreturning = FALSE;\t/* This entry point has alternate returns. */\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   input_filename = ffesymbol_where_filename (fn);\n-  lineno = ffesymbol_where_filelinenum (fn);\n+  input_line = ffesymbol_where_filelinenum (fn);\n \n   ffecom_doing_entry_ = TRUE;\t/* Don't bother with array dimensions. */\n \n@@ -2917,7 +2917,7 @@ ffecom_do_entry_ (ffesymbol fn, int entrynum)\n \n   finish_function (0);\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n \n   ffecom_doing_entry_ = FALSE;\n@@ -6110,7 +6110,7 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n   tree result;\n   bool charfunc = (bt == FFEINFO_basictypeCHARACTER);\n   static bool recurse = FALSE;\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   ffecom_nested_entry_ = s;\n@@ -6124,7 +6124,7 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n      see how it works at this point.  */\n \n   input_filename = ffesymbol_where_filename (s);\n-  lineno = ffesymbol_where_filelinenum (s);\n+  input_line = ffesymbol_where_filelinenum (s);\n \n   /* Pretransform the expression so any newly discovered things belong to the\n      outer program unit, not to the statement function. */\n@@ -6221,7 +6221,7 @@ ffecom_gen_sfuncdef_ (ffesymbol s, ffeinfoBasictype bt, ffeinfoKindtype kt)\n \n   recurse = FALSE;\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n \n   ffecom_nested_entry_ = NULL;\n@@ -7080,14 +7080,14 @@ ffecom_start_progunit_ ()\n   && (ffecom_primary_entry_kind_ == FFEINFO_kindFUNCTION)\n   && (ffecom_master_bt_ == FFEINFO_basictypeNONE);\n   bool main_program = FALSE;\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   assert (fn != NULL);\n   assert (ffesymbol_hook (fn).decl_tree == NULL_TREE);\n \n   input_filename = ffesymbol_where_filename (fn);\n-  lineno = ffesymbol_where_filelinenum (fn);\n+  input_line = ffesymbol_where_filelinenum (fn);\n \n   switch (ffecom_primary_entry_kind_)\n     {\n@@ -7269,7 +7269,7 @@ ffecom_start_progunit_ ()\n   /* Disallow temp vars at this level.  */\n   current_binding_level->prep_state = 2;\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n \n   /* This handles any symbols still untransformed, in case -g specified.\n@@ -7298,7 +7298,7 @@ ffecom_sym_transform_ (ffesymbol s)\n   ffeinfoBasictype bt;\n   ffeinfoKindtype kt;\n   ffeglobal g;\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   /* Must ensure special ASSIGN variables are declared at top of outermost\n@@ -7318,14 +7318,14 @@ ffecom_sym_transform_ (ffesymbol s)\n   if (ffesymbol_sfdummyparent (s) == NULL)\n     {\n       input_filename = ffesymbol_where_filename (s);\n-      lineno = ffesymbol_where_filelinenum (s);\n+      input_line = ffesymbol_where_filelinenum (s);\n     }\n   else\n     {\n       ffesymbol sf = ffesymbol_sfdummyparent (s);\n \n       input_filename = ffesymbol_where_filename (sf);\n-      lineno = ffesymbol_where_filelinenum (sf);\n+      input_line = ffesymbol_where_filelinenum (sf);\n     }\n \n   bt = ffeinfo_basictype (ffebld_info (s));\n@@ -8294,7 +8294,7 @@ ffecom_sym_transform_ (ffesymbol s)\n   ffesymbol_hook (s).length_tree = tlen;\n   ffesymbol_hook (s).addr = addr;\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n \n   return s;\n@@ -8312,20 +8312,20 @@ static ffesymbol\n ffecom_sym_transform_assign_ (ffesymbol s)\n {\n   tree t;\t\t\t/* Transformed thingy. */\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   if (ffesymbol_sfdummyparent (s) == NULL)\n     {\n       input_filename = ffesymbol_where_filename (s);\n-      lineno = ffesymbol_where_filelinenum (s);\n+      input_line = ffesymbol_where_filelinenum (s);\n     }\n   else\n     {\n       ffesymbol sf = ffesymbol_sfdummyparent (s);\n \n       input_filename = ffesymbol_where_filename (sf);\n-      lineno = ffesymbol_where_filelinenum (sf);\n+      input_line = ffesymbol_where_filelinenum (sf);\n     }\n \n   assert (!ffecom_transform_only_dummies_);\n@@ -8375,7 +8375,7 @@ ffecom_sym_transform_assign_ (ffesymbol s)\n \n   ffesymbol_hook (s).assign_tree = t;\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n \n   return s;\n@@ -13115,7 +13115,7 @@ ffecom_which_entrypoint_decl ()\n static void\n bison_rule_pushlevel_ ()\n {\n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   pushlevel (0);\n   clear_last_expr ();\n   expand_start_bindings (0);\n@@ -13131,7 +13131,7 @@ bison_rule_compstmt_ ()\n   if (! keep)\n     current_binding_level->names = NULL_TREE;\n \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n   expand_end_bindings (getdecls (), keep, 0);\n   t = poplevel (keep, 1, 0);\n \n@@ -13585,7 +13585,7 @@ finish_function (int nested)\n \n       /* Obey `register' declarations if `setjmp' is called in this fn.  */\n       /* Generate rtl for function exit.  */\n-      expand_function_end (input_filename, lineno, 0);\n+      expand_function_end (input_filename, input_line, 0);\n \n       /* If this is a nested function, protect the local variables in the stack\n \t above us from being collected while we're compiling this function.  */\n@@ -13866,7 +13866,7 @@ store_parm_decls (int is_main_program UNUSED)\n \n   /* Initialize the RTL code for the function.  */\n \n-  init_function_start (fndecl, input_filename, lineno);\n+  init_function_start (fndecl, input_filename, input_line);\n \n   /* Set up parameters and prepare for return, for the function.  */\n "}, {"sha": "cc100bf9e51fb4951e48c05b69ac2afbc68abd69", "filename": "gcc/f/intrin.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fintrin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fintrin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,6 @@\n /* intrin.c -- Recognize references to intrinsics\n-   Copyright (C) 1995, 1996, 1997, 1998, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 2002,\n+   2003 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -1389,7 +1390,7 @@ ffeintrin_fulfill_generic (ffebld *expr, ffeinfo *info, ffelexToken t)\n       if (!highly_specific && (nimp != FFEINTRIN_impNONE))\n \t{\n \t  fprintf (stderr, \"lineno=%ld, gen=%s, imp=%s, timp=%s\\n\",\n-\t\t   (long) lineno,\n+\t\t   (long) input_line,\n \t\t   ffeintrin_gens_[gen].name,\n \t\t   ffeintrin_imps_[imp].name,\n \t\t   ffeintrin_imps_[nimp].name);"}, {"sha": "f1e2e97cd55a40287b3c8fda8a69ff0ee7cb52db", "filename": "gcc/f/lex.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of Fortran lexer\n-   Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002\n+   Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n@@ -1096,7 +1096,7 @@ ffelex_hash_ (FILE *finput)\n \t      c = ffelex_get_directive_line_ (&text, finput);\n \n \t      if (debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t(*debug_hooks->define) (lineno, text);\n+\t\t(*debug_hooks->define) (input_line, text);\n \n \t      goto skipline;\n \t    }\n@@ -1115,7 +1115,7 @@ ffelex_hash_ (FILE *finput)\n \t      c = ffelex_get_directive_line_ (&text, finput);\n \n \t      if (debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t(*debug_hooks->undef) (lineno, text);\n+\t\t(*debug_hooks->undef) (input_line, text);\n \n \t      goto skipline;\n \t    }\n@@ -1193,7 +1193,7 @@ ffelex_hash_ (FILE *finput)\n   if ((token != NULL)\n       && (ffelex_token_type (token) == FFELEX_typeNUMBER))\n     {\n-      int old_lineno = lineno;\n+      int old_lineno = input_line;\n       const char *old_input_filename = input_filename;\n       ffewhereFile wf;\n \n@@ -1207,7 +1207,7 @@ ffelex_hash_ (FILE *finput)\n       if (c == '\\n' || c == EOF)\n \t{\n \t  /* No more: store the line number and check following line.  */\n-\t  lineno = l;\n+\t  input_line = l;\n \t  if (!ffelex_kludge_flag_)\n \t    {\n \t      ffewhere_file_set (NULL, TRUE, (ffewhereLineNumber) l);\n@@ -1230,7 +1230,7 @@ ffelex_hash_ (FILE *finput)\n \t  goto skipline;\n \t}\n \n-      lineno = l;\n+      input_line = l;\n \n       if (ffelex_kludge_flag_)\n \tinput_filename = ggc_strdup (ffelex_token_text (token));\n@@ -1280,7 +1280,7 @@ ffelex_hash_ (FILE *finput)\n \n \t  if (ffelex_kludge_flag_)\n \t    {\n-\t      lineno = 1;\n+\t      input_line = 1;\n \t      input_filename = old_input_filename;\n \t      error (\"use `#line ...' instead of `# ...' in first line\");\n \t    }\n@@ -1324,7 +1324,7 @@ ffelex_hash_ (FILE *finput)\n \t   || (c != '\\n' && c != EOF))\n \t  && ffelex_kludge_flag_)\n \t{\n-\t  lineno = 1;\n+\t  input_line = 1;\n \t  input_filename = old_input_filename;\n \t  error (\"use `#line ...' instead of `# ...' in first line\");\n \t}\n@@ -1470,7 +1470,7 @@ ffelex_include_ ()\n   ffewhereLineNumber linecount_current = ffelex_linecount_current_;\n   ffewhereLineNumber linecount_offset\n     = ffewhere_line_filelinenum (current_wl);\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   if (card_length != 0)\n@@ -1513,7 +1513,7 @@ ffelex_include_ ()\n   ffelex_card_image_[card_length] = '\\0';\n \n   input_filename = old_input_filename;\n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   ffelex_linecount_current_ = linecount_current;\n   ffelex_current_wf_ = current_wf;\n   ffelex_final_nontab_column_ = final_nontab_column;\n@@ -1571,7 +1571,7 @@ ffelex_next_line_ ()\n {\n   ffelex_linecount_current_ = ffelex_linecount_next_;\n   ++ffelex_linecount_next_;\n-  ++lineno;\n+  ++input_line;\n }\n \n static void\n@@ -1787,7 +1787,7 @@ ffelex_file_fixed (ffewhereFile wf, FILE *f)\n \n   assert (ffelex_handler_ != NULL);\n \n-  lineno = 0;\n+  input_line = 0;\n   input_filename = ffewhere_file_name (wf);\n   ffelex_current_wf_ = wf;\n   disallow_continuation_line = TRUE;\n@@ -2977,7 +2977,7 @@ ffelex_file_free (ffewhereFile wf, FILE *f)\n \n   assert (ffelex_handler_ != NULL);\n \n-  lineno = 0;\n+  input_line = 0;\n   input_filename = ffewhere_file_name (wf);\n   ffelex_current_wf_ = wf;\n   continuation_line = FALSE;"}, {"sha": "439ae887c3871ea833b29b810224d8977ccb6367", "filename": "gcc/f/std.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fstd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fstd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* std.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -1423,7 +1423,7 @@ ffestd_exec_begin ()\n void\n ffestd_exec_end ()\n {\n-  int old_lineno = lineno;\n+  int old_lineno = input_line;\n   const char *old_input_filename = input_filename;\n \n   ffecom_end_transition ();\n@@ -1456,7 +1456,7 @@ ffestd_exec_end ()\n   ffestd_stmt_list_.last = NULL;\n   ffestd_2pass_entrypoints_ = 0;\n \n-  lineno = old_lineno;\n+  input_line = old_lineno;\n   input_filename = old_input_filename;\n }\n "}, {"sha": "1648d8fef9b2813d434a4d623c51743623953ae3", "filename": "gcc/f/ste.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -141,7 +141,7 @@ static void ffeste_subr_beru_ (ffestpBeruStmt *info, ffecomGfrt rt);\n /* Internal macros. */\n \n #define ffeste_emit_line_note_() \\\n-  emit_line_note (input_filename, lineno)\n+  emit_line_note (input_filename, input_line)\n #define ffeste_check_simple_() \\\n   assert(ffeste_statelet_ == FFESTE_stateletSIMPLE_)\n #define ffeste_check_start_() \\\n@@ -401,7 +401,7 @@ ffeste_start_block_ (ffestw block)\n \n   b->outer = ffeste_top_block_;\n   b->block = block;\n-  b->lineno = lineno;\n+  b->lineno = input_line;\n   b->filename = input_filename;\n   b->is_stmt = FALSE;\n \n@@ -443,7 +443,7 @@ ffeste_start_stmt_(void)\n \n   b->outer = ffeste_top_block_;\n   b->block = NULL;\n-  b->lineno = lineno;\n+  b->lineno = input_line;\n   b->filename = input_filename;\n   b->is_stmt = TRUE;\n "}, {"sha": "d911105559d9dbcecec85bd78937e707bf569903", "filename": "gcc/f/ste.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fste.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ff%2Fste.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* ste.h -- Private #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 2003 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -148,9 +148,9 @@ void ffeste_V026 (ffestpFindStmt *info);\n #define ffeste_init_3()\n #define ffeste_init_4()\n #define ffeste_filename() input_filename\n-#define ffeste_filelinenum() lineno\n+#define ffeste_filelinenum() input_line\n #define ffeste_set_line(name,num) \\\n-  (input_filename = (name), lineno = (num))\n+  (input_filename = (name), input_line = (num))\n #define ffeste_terminate_0()\n #define ffeste_terminate_1()\n #ifdef ENABLE_CHECKING"}, {"sha": "0bc15dea45fbdfe40d01be2c462e7cd5f6f26073", "filename": "gcc/input.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for variables relating to reading the source file.\n    Used by parsers, lexical analyzers, and error message routines.\n-   Copyright (C) 1993, 1997, 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1997, 1998, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,7 +26,7 @@ extern const char *input_filename;\n extern const char *main_input_filename;\n \n /* Line number in current source file.  */\n-extern int lineno;\n+extern int input_line;\n \n /* Stream for reading from input file.  */\n extern FILE *finput;"}, {"sha": "3e7f94b4691c16a843eb8e71624a919b4c40cde3", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1307,7 +1307,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (flag_test_coverage)\n     emit_note (0, NOTE_INSN_REPEATED_LINE_NUMBER);\n \n-  emit_line_note (input_filename, lineno);\n+  emit_line_note (input_filename, input_line);\n \n   /* If the function returns a BLKmode object in a register, copy it\n      out of the temp register into a BLKmode memory object.  */\n@@ -3041,7 +3041,7 @@ output_inline_function (fndecl)\n   /* Make sure warnings emitted by the optimizers (e.g. control reaches\n      end of non-void function) is not wildly incorrect.  */\n   input_filename = DECL_SOURCE_FILE (fndecl);\n-  lineno = DECL_SOURCE_LINE (fndecl);\n+  input_line = DECL_SOURCE_LINE (fndecl);\n \n   /* Compile this function all the way down to assembly code.  As a\n      side effect this destroys the saved RTL representation, but"}, {"sha": "82b14b57cfc86c164ff4ddc15864ebbe8e532eb1", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -890,15 +890,15 @@ check_init (tree exp, words before)\n \tconst char *saved_input_filename = input_filename;\n \ttree saved_wfl = wfl;\n \ttree body = EXPR_WFL_NODE (exp);\n-\tint saved_lineno = lineno;\n+\tint saved_lineno = input_line;\n \tif (body == empty_stmt_node)\n \t  break;\n \twfl = exp;\n \tinput_filename = EXPR_WFL_FILENAME (exp);\n-\tlineno = EXPR_WFL_LINENO (exp);\n+\tinput_line = EXPR_WFL_LINENO (exp);\n \tcheck_init (body, before);\n \tinput_filename = saved_input_filename;\n-\tlineno = saved_lineno;\n+\tinput_line = saved_lineno;\n \twfl = saved_wfl;\n       }\n       break;"}, {"sha": "e51e79996c3109331191a933ec687caf3563fcb5", "filename": "gcc/java/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -309,18 +309,18 @@ push_class (tree class_type, tree class_name)\n {\n   tree decl, signature;\n   const char *save_input_filename = input_filename;\n-  int save_lineno = lineno;\n+  int save_lineno = input_line;\n   tree source_name = identifier_subst (class_name, \"\", '.', '/', \".java\");\n   CLASS_P (class_type) = 1;\n   input_filename = IDENTIFIER_POINTER (source_name);\n-  lineno = 0;\n+  input_line = 0;\n   decl = build_decl (TYPE_DECL, class_name, class_type);\n \n   /* dbxout needs a DECL_SIZE if in gstabs mode */\n   DECL_SIZE (decl) = integer_zero_node;\n \n   input_filename = save_input_filename;\n-  lineno = save_lineno;\n+  input_line = save_lineno;\n   signature = identifier_subst (class_name, \"L\", '.', '/', \";\");\n   IDENTIFIER_SIGNATURE_TYPE (signature) = build_pointer_type (class_type);\n "}, {"sha": "a4b1c43fd609edca5ed1a169dba743e5c4a49f11", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1670,7 +1670,7 @@ complete_start_java_method (tree fndecl)\n   if (! flag_emit_class_files)\n     {\n       /* Initialize the RTL code for the function.  */\n-      init_function_start (fndecl, input_filename, lineno);\n+      init_function_start (fndecl, input_filename, input_line);\n \n       /* Set up parameters and prepare for return, for the function.  */\n       expand_function_start (fndecl, 0);\n@@ -1810,7 +1810,7 @@ end_java_method (void)\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   /* Generate rtl for function exit.  */\n-  expand_function_end (input_filename, lineno, 0);\n+  expand_function_end (input_filename, input_line, 0);\n \n   /* Run the optimizers and output assembler code for this function. */\n   rest_of_compilation (fndecl);"}, {"sha": "6cbfbc9f19f8f541deb64dd462d0f9ec85e364cb", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -2827,8 +2827,8 @@ expand_byte_code (JCF *jcf, tree method)\n \t      linenumber_pointer += 4;\n \t      if (pc == PC)\n \t\t{\n-\t\t  lineno = GET_u2 (linenumber_pointer - 2);\n-\t\t  emit_line_note (input_filename, lineno);\n+\t\t  input_line = GET_u2 (linenumber_pointer - 2);\n+\t\t  emit_line_note (input_filename, input_line);\n \t\t  if (!(instruction_bits[PC] & BCODE_HAS_MULTI_LINENUMBERS))\n \t\t    break;\n \t\t}"}, {"sha": "d642bdccb752ebe7e6e0f131ec475dfb1fe1aa0b", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -418,7 +418,7 @@ give_name_to_class (JCF *jcf, int i)\n \t\t\t\t\t    JPOOL_UTF_LENGTH (jcf, j));\n       this_class = lookup_class (class_name);\n       input_filename = DECL_SOURCE_FILE (TYPE_NAME (this_class));\n-      lineno = 0;\n+      input_line = 0;\n       if (main_input_filename == NULL && jcf == main_jcf)\n \tmain_input_filename = input_filename;\n \n@@ -703,13 +703,13 @@ parse_class_file (void)\n {\n   tree method, field;\n   const char *save_input_filename = input_filename;\n-  int save_lineno = lineno;\n+  int save_lineno = input_line;\n \n   java_layout_seen_class_methods ();\n \n   input_filename = DECL_SOURCE_FILE (TYPE_NAME (current_class));\n-  lineno = 0;\n-  (*debug_hooks->start_source_file) (lineno, input_filename);\n+  input_line = 0;\n+  (*debug_hooks->start_source_file) (input_line, input_filename);\n   init_outgoing_cpool ();\n \n   /* Currently we always have to emit calls to _Jv_InitClass when\n@@ -760,7 +760,7 @@ parse_class_file (void)\n \t  continue;\n \t}\n \n-      lineno = 0;\n+      input_line = 0;\n       if (DECL_LINENUMBERS_OFFSET (method))\n \t{\n \t  register int i;\n@@ -774,8 +774,8 @@ parse_class_file (void)\n \t      int line = GET_u2 (ptr);\n \t      /* Set initial lineno lineno to smallest linenumber.\n \t       * Needs to be set before init_function_start. */\n-\t      if (lineno == 0 || line < lineno)\n-\t\tlineno = line;\n+\t      if (input_line == 0 || line < input_line)\n+\t\tinput_line = line;\n \t    }  \n \t}\n       else\n@@ -803,7 +803,7 @@ parse_class_file (void)\n \n   (*debug_hooks->end_source_file) (save_lineno);\n   input_filename = save_input_filename;\n-  lineno = save_lineno;\n+  input_line = save_lineno;\n }\n \n /* Parse a source file, as pointed by the current value of INPUT_FILENAME. */"}, {"sha": "59ef514edb41af3311fdc2c1ba566c293ee25d5a", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1425,17 +1425,17 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       {\n \tconst char *saved_input_filename = input_filename;\n \ttree body = EXPR_WFL_NODE (exp);\n-\tint saved_lineno = lineno;\n+\tint saved_lineno = input_line;\n \tif (body == empty_stmt_node)\n \t  break;\n \tinput_filename = EXPR_WFL_FILENAME (exp);\n-\tlineno = EXPR_WFL_LINENO (exp);\n-\tif (EXPR_WFL_EMIT_LINE_NOTE (exp) && lineno > 0\n+\tinput_line = EXPR_WFL_LINENO (exp);\n+\tif (EXPR_WFL_EMIT_LINE_NOTE (exp) && input_line > 0\n \t    && debug_info_level > DINFO_LEVEL_NONE)\n-\t  put_linenumber (lineno, state);\n+\t  put_linenumber (input_line, state);\n \tgenerate_bytecode_insns (body, target, state);\n \tinput_filename = saved_input_filename;\n-\tlineno = saved_lineno;\n+\tinput_line = saved_lineno;\n       }\n       break;\n     case INTEGER_CST:"}, {"sha": "e21bfd649af9ccc83dd3bc01962847b5525b159c", "filename": "gcc/java/lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -135,7 +135,7 @@ java_init_lex (FILE *finput, const char *encoding)\n #endif\n \n   ctxp->filename = input_filename;\n-  ctxp->lineno = lineno = 0;\n+  ctxp->lineno = input_line = 0;\n   ctxp->p_line = NULL;\n   ctxp->c_line = NULL;\n   ctxp->java_error_flag = 0;\n@@ -212,7 +212,7 @@ java_allocate_new_line (void)\n     }\n   ctxp->c_line->ahead [0] = 0;\n   ctxp->c_line->unicode_escape_ahead_p = 0;\n-  ctxp->c_line->lineno = ++lineno;\n+  ctxp->c_line->lineno = ++input_line;\n   ctxp->c_line->white_space_only = 1;\n }\n \n@@ -1351,9 +1351,9 @@ do_java_lex (YYSTYPE *java_lval)\n \t}\n       if (c == '\\n' || c == UEOF) /* ULT.  */\n \t{\n-\t  lineno--;\t/* Refer to the line where the terminator was seen.  */\n+\t  input_line--;\t/* Refer to the line where the terminator was seen.  */\n \t  java_lex_error (\"String not terminated at end of line\", 0);\n-\t  lineno++;\n+\t  input_line++;\n \t}\n \n       obstack_1grow (&temporary_obstack, '\\0');\n@@ -1381,14 +1381,14 @@ do_java_lex (YYSTYPE *java_lval)\n     case '{':\n       JAVA_LEX_SEP (c);\n       if (ctxp->ccb_indent == 1)\n-\tctxp->first_ccb_indent1 = lineno;\n+\tctxp->first_ccb_indent1 = input_line;\n       ctxp->ccb_indent++;\n       BUILD_OPERATOR (OCB_TK);\n     case '}':\n       JAVA_LEX_SEP (c);\n       ctxp->ccb_indent--;\n       if (ctxp->ccb_indent == 1)\n-        ctxp->last_ccb_indent1 = lineno;\n+        ctxp->last_ccb_indent1 = input_line;\n       BUILD_OPERATOR (CCB_TK);\n     case '[':\n       JAVA_LEX_SEP (c);"}, {"sha": "3c924e4e4a5ca34a4ec8cf68dfe1f77ec299201e", "filename": "gcc/java/lex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -29,7 +29,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n /* Extern global variables declarations  */\n extern FILE *finput;\n-extern int   lineno;\n+extern int   input_lineno;\n \n /* A Unicode character, as read from the input file  */\n typedef unsigned short unicode_t;"}, {"sha": "233a98707c4f8843087fd70f7b6dbe29d4fa937a", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -58,7 +58,7 @@ static struct parser_ctxt *ctxp;\n    elsewhere  */\n int java_error_count;\n int java_warning_count;\n-int lineno;\n+int input_line;\n \n /* Tweak default rules when necessary.  */\n static int absorber;\n@@ -1354,6 +1354,6 @@ void reset_report (void)\n void\n yyerror (const char *msg ATTRIBUTE_UNUSED)\n {\n-  fprintf (stderr, \"%s: %d: %s\\n\", input_filename, lineno, msg);\n+  fprintf (stderr, \"%s: %d: %s\\n\", input_filename, input_line, msg);\n   exit (1);\n }"}, {"sha": "207bb8d8bf3c4e6457d0637eb401963537857de4", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -70,7 +70,7 @@ extern tree stabilize_reference (tree);\n #define RECOVER     {yyerrok; RECOVERED;}\n \n #define YYERROR_NOW ctxp->java_error_flag = 1\n-#define YYNOT_TWICE if (ctxp->prevent_ese != lineno)\n+#define YYNOT_TWICE if (ctxp->prevent_ese != input_line)\n \n /* Accepted modifiers */\n #define CLASS_MODIFIERS ACC_PUBLIC|ACC_ABSTRACT|ACC_FINAL|ACC_STRICT"}, {"sha": "c35d4e504aaa66bc7ad2549ee5d449b1e3efaaf7", "filename": "gcc/java/parse.y", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1452,7 +1452,7 @@ empty_statement:\n \t\t\t   (DECL_CONTEXT (current_function_decl)))))\n \n \t\t    {\n-\t\t      EXPR_WFL_SET_LINECOL (wfl_operator, lineno, -1);\n+\t\t      EXPR_WFL_SET_LINECOL (wfl_operator, input_line, -1);\n \t\t      parse_warning_context (wfl_operator, \"An empty declaration is a deprecated feature that should not be used\");\n \t\t    }\n \t\t  $$ = empty_stmt_node;\n@@ -1489,7 +1489,7 @@ expression_statement:\n \t\t{\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n-\t\t  $$ = build_expr_wfl ($1, input_filename, lineno, 0);\n+\t\t  $$ = build_expr_wfl ($1, input_filename, input_line, 0);\n \t\t  /* We know we have a statement, so set the debug\n                      info to be eventually generate here. */\n \t\t  $$ = JAVA_MAYBE_GENERATE_DEBUG_INFO ($$);\n@@ -2692,7 +2692,7 @@ java_pop_parser_context (int generate)\n   next = ctxp->next;\n   if (next)\n     {\n-      lineno = ctxp->lineno;\n+      input_line = ctxp->lineno;\n       current_class = ctxp->class_type;\n     }\n \n@@ -2737,7 +2737,7 @@ java_parser_context_save_global (void)\n   else if (ctxp->saved_data)\n     create_new_parser_context (1);\n \n-  ctxp->lineno = lineno;\n+  ctxp->lineno = input_line;\n   ctxp->class_type = current_class;\n   ctxp->filename = input_filename;\n   ctxp->function_decl = current_function_decl;\n@@ -2750,7 +2750,7 @@ java_parser_context_save_global (void)\n void\n java_parser_context_restore_global (void)\n {\n-  lineno = ctxp->lineno;\n+  input_line = ctxp->lineno;\n   current_class = ctxp->class_type;\n   input_filename = ctxp->filename;\n   if (wfl_operator)\n@@ -2989,7 +2989,7 @@ yyerror (const char *msg)\n   int save_lineno;\n   char *remainder, *code_from_source;\n \n-  if (!force_error && prev_lineno == lineno)\n+  if (!force_error && prev_lineno == input_line)\n     return;\n \n   /* Save current error location but report latter, when the context is\n@@ -3022,8 +3022,8 @@ yyerror (const char *msg)\n       elc.line = ctxp->p_line->lineno;\n     }\n \n-  save_lineno = lineno;\n-  prev_lineno = lineno = elc.line;\n+  save_lineno = input_line;\n+  prev_lineno = input_line = elc.line;\n   prev_msg = msg;\n \n   code_from_source = java_get_line_col (ctxp->filename, elc.line, elc.col);\n@@ -3040,7 +3040,7 @@ yyerror (const char *msg)\n      the same line. This occurs when we report an error but don't have\n      a synchronization point other than ';', which\n      expression_statement is the only one to take care of.  */\n-  ctxp->prevent_ese = lineno = save_lineno;\n+  ctxp->prevent_ese = input_line = save_lineno;\n }\n \n static void\n@@ -4225,7 +4225,7 @@ register_fields (int flags, tree type, tree variable_list)\n {\n   tree current, saved_type;\n   tree class_type = NULL_TREE;\n-  int saved_lineno = lineno;\n+  int saved_lineno = input_line;\n   int must_chain = 0;\n   tree wfl = NULL_TREE;\n \n@@ -4295,9 +4295,9 @@ register_fields (int flags, tree type, tree variable_list)\n       /* Set lineno to the line the field was found and create a\n          declaration for it. Eventually sets the @deprecated tag flag. */\n       if (flag_emit_xref)\n-\tlineno = EXPR_WFL_LINECOL (cl);\n+\tinput_line = EXPR_WFL_LINECOL (cl);\n       else\n-\tlineno = EXPR_WFL_LINENO (cl);\n+\tinput_line = EXPR_WFL_LINENO (cl);\n       field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED_NO_RESET (field_decl);\n \n@@ -4359,7 +4359,7 @@ register_fields (int flags, tree type, tree variable_list)\n     }\n \n   CLEAR_DEPRECATED;\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n }\n \n /* Generate finit$, using the list of initialized fields to populate\n@@ -4611,11 +4611,11 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   else\n     TREE_TYPE (meth) = type;\n \n-  saved_lineno = lineno;\n+  saved_lineno = input_line;\n   /* When defining an abstract or interface method, the curly\n      bracket at level 1 doesn't exist because there is no function\n      body */\n-  lineno = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 :\n+  input_line = (ctxp->first_ccb_indent1 ? ctxp->first_ccb_indent1 :\n \t    EXPR_WFL_LINENO (id));\n \n   /* Remember the original argument list */\n@@ -4649,7 +4649,7 @@ method_header (int flags, tree type, tree mdecl, tree throws)\n   /* Register the parameter number and re-install the current line\n      number */\n   DECL_MAX_LOCALS (meth) = ctxp->formal_parameter_number+1;\n-  lineno = saved_lineno;\n+  input_line = saved_lineno;\n \n   /* Register exception specified by the `throws' keyword for\n      resolution and set the method decl appropriate field to the list.\n@@ -5451,13 +5451,13 @@ safe_layout_class (tree class)\n {\n   tree save_current_class = current_class;\n   const char *save_input_filename = input_filename;\n-  int save_lineno = lineno;\n+  int save_lineno = input_line;\n \n   layout_class (class);\n \n   current_class = save_current_class;\n   input_filename = save_input_filename;\n-  lineno = save_lineno;\n+  input_line = save_lineno;\n }\n \n static tree\n@@ -6867,7 +6867,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \n   for (; import; import = TREE_CHAIN (import))\n     {\n-      int saved_lineno = lineno;\n+      int saved_lineno = input_line;\n       int access_check;\n       const char *id_name;\n       tree decl, type_name_copy;\n@@ -6886,7 +6886,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \n       /* Setup lineno so that it refers to the line of the import (in\n \t case we parse a class file and encounter errors */\n-      lineno = EXPR_WFL_LINENO (TREE_PURPOSE (import));\n+      input_line = EXPR_WFL_LINENO (TREE_PURPOSE (import));\n \n       type_name_copy = TYPE_NAME (class_type);\n       TYPE_NAME (class_type) = node;\n@@ -6908,7 +6908,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n \t/* 6.6.1: Inner classes are subject to member access rules. */\n \taccess_check = 0;\n \n-      lineno = saved_lineno;\n+      input_line = saved_lineno;\n \n       /* If the loaded class is not accessible or couldn't be loaded,\n \t we restore the original TYPE_NAME and process the next\n@@ -7297,7 +7297,7 @@ create_artificial_method (tree class, int flags, tree type,\n   tree mdecl;\n \n   java_parser_context_save_global ();\n-  lineno = 0;\n+  input_line = 0;\n   mdecl = make_node (FUNCTION_TYPE);\n   TREE_TYPE (mdecl) = type;\n   TYPE_ARG_TYPES (mdecl) = args;\n@@ -7357,7 +7357,7 @@ source_end_java_method (void)\n     return;\n \n   java_parser_context_save_global ();\n-  lineno = ctxp->last_ccb_indent1;\n+  input_line = ctxp->last_ccb_indent1;\n \n   /* Turn function bodies with only a NOP expr null, so they don't get\n      generated at all and we won't get warnings when using the -W\n@@ -7385,8 +7385,8 @@ source_end_java_method (void)\n   /* Generate rtl for function exit.  */\n   if (! flag_emit_class_files && ! flag_emit_xref)\n     {\n-      lineno = DECL_SOURCE_LINE_LAST (fndecl);\n-      expand_function_end (input_filename, lineno, 0);\n+      input_line = DECL_SOURCE_LINE_LAST (fndecl);\n+      expand_function_end (input_filename, input_line, 0);\n \n       DECL_SOURCE_LINE (fndecl) = DECL_SOURCE_LINE_FIRST (fndecl);\n \n@@ -7894,7 +7894,7 @@ start_complete_expand_method (tree mdecl)\n       TREE_CHAIN (tem) = next;\n     }\n   pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n-  lineno = DECL_SOURCE_LINE_FIRST (mdecl);\n+  input_line = DECL_SOURCE_LINE_FIRST (mdecl);\n   build_result_decl (mdecl);\n }\n \n@@ -8572,7 +8572,7 @@ build_thisn_assign (void)\n       tree lhs = make_qualified_primary (build_wfl_node (this_identifier_node),\n \t\t\t\t\t build_wfl_node (thisn), 0);\n       tree rhs = build_wfl_node (thisn);\n-      EXPR_WFL_SET_LINECOL (lhs, lineno, 0);\n+      EXPR_WFL_SET_LINECOL (lhs, input_line, 0);\n       return build_assignment (ASSIGN_TK, EXPR_WFL_LINECOL (lhs), lhs, rhs);\n     }\n   return NULL_TREE;\n@@ -11824,10 +11824,10 @@ java_complete_lhs (tree node)\n       else\n \t{\n \t  tree body;\n-\t  int save_lineno = lineno;\n-\t  lineno = EXPR_WFL_LINENO (node);\n+\t  int save_lineno = input_line;\n+\t  input_line = EXPR_WFL_LINENO (node);\n \t  body = java_complete_tree (EXPR_WFL_NODE (node));\n-\t  lineno = save_lineno;\n+\t  input_line = save_lineno;\n \t  EXPR_WFL_NODE (node) = body;\n \t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n@@ -12375,7 +12375,7 @@ maybe_absorb_scoping_blocks (void)\n     {\n       tree b = exit_block ();\n       java_method_add_stmt (current_function_decl, b);\n-      SOURCE_FRONTEND_DEBUG ((\"Absorbing scoping block at line %d\", lineno));\n+      SOURCE_FRONTEND_DEBUG ((\"Absorbing scoping block at line %d\", input_line));\n     }\n }\n "}, {"sha": "6ba51df47ed5c10b77182e8c10099e8386b6265e", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 83, "deletions": 86, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -441,7 +441,7 @@ objc_init ()\n   /* Force the line number back to 0; check_newline will have\n      raised it to 1, which will make the builtin functions appear\n      not to be built in.  */\n-  lineno = 0;\n+  input_line = 0;\n \n   /* If gen_declaration desired, open the output file.  */\n   if (flag_gen_declaration)\n@@ -1697,33 +1697,33 @@ build_module_descriptor ()\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_LONG]);\n   field_decl = get_identifier (\"version\");\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* long  size; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_LONG]);\n   field_decl = get_identifier (\"size\");\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* char  *name; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"name\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_symtab *symtab; */\n \n   decl_specs = get_identifier (UTAG_SYMTAB);\n   decl_specs = build_tree_list (NULL_TREE, xref_tag (RECORD_TYPE, decl_specs));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"symtab\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_module_template, field_decl_chain, NULL_TREE);\n@@ -2049,12 +2049,12 @@ build_selector_translation_table ()\n         if (!found)\n           {\n             /* Adjust line number for warning message.  */\n-            int save_lineno = lineno;\n+            int save_lineno = input_line;\n             if (flag_next_runtime && TREE_PURPOSE (chain))\n-              lineno = DECL_SOURCE_LINE (TREE_PURPOSE (chain));\n+              input_line = DECL_SOURCE_LINE (TREE_PURPOSE (chain));\n             warning (\"creating selector for non existant method %s\",\n                      IDENTIFIER_POINTER (TREE_VALUE (chain)));\n-            lineno = save_lineno;\n+            input_line = save_lineno;\n           }\n       }\n \n@@ -2565,17 +2565,17 @@ build_protocol_template ()\n   decl_specs = build_tree_list (NULL_TREE, xref_tag (RECORD_TYPE,\n \t\t\t\t\tget_identifier (UTAG_CLASS)));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"isa\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* char *protocol_name; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"protocol_name\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_protocol **protocol_list; */\n@@ -2584,8 +2584,8 @@ build_protocol_template ()\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"protocol_list\"));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, field_decl);\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_method_list *instance_methods; */\n@@ -2596,8 +2596,8 @@ build_protocol_template ()\n \t\t\t\t get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"instance_methods\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_method_list *class_methods; */\n@@ -2608,8 +2608,8 @@ build_protocol_template ()\n \t\t\t\t get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"class_methods\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   return finish_struct (template, field_decl_chain, NULL_TREE);\n@@ -2672,19 +2672,17 @@ build_method_prototype_list_template (list_type, size)\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_INT]);\n   field_decl = get_identifier (\"method_count\");\n-\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* struct objc_method method_list[]; */\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n \t\t\t build_int_2 (size, 0));\n-\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_ivar_list_record, field_decl_chain, NULL_TREE);\n@@ -2705,16 +2703,15 @@ build_method_prototype_template ()\n   decl_specs = tree_cons (NULL_TREE, xref_tag (RECORD_TYPE,\n \t\t          get_identifier (TAG_SELECTOR)), NULL_TREE);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"_cmd\"));\n-\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_CHAR], NULL_TREE);\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"method_types\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (proto_record, field_decl_chain, NULL_TREE);\n@@ -3249,16 +3246,16 @@ build_category_template ()\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"category_name\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* char *class_name; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"class_name\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_method_list *instance_methods; */\n@@ -3268,8 +3265,8 @@ build_category_template ()\n \t\t\t\t\t  get_identifier (UTAG_METHOD_LIST)));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"instance_methods\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_method_list *class_methods; */\n@@ -3279,8 +3276,8 @@ build_category_template ()\n \t\t\t\t\t  get_identifier (UTAG_METHOD_LIST)));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"class_methods\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_protocol **protocol_list; */\n@@ -3291,8 +3288,8 @@ build_category_template ()\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"protocol_list\"));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, field_decl);\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_category_template, field_decl_chain, NULL_TREE);\n@@ -3316,16 +3313,16 @@ build_selector_template ()\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_VOID]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"sel_id\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* char *sel_type; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"sel_type\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_selector_template, field_decl_chain, NULL_TREE);\n@@ -3363,49 +3360,49 @@ build_class_template ()\n \n   decl_specs = build_tree_list (NULL_TREE, objc_class_template);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"isa\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   /* struct objc_class *super_class; */\n \n   decl_specs = build_tree_list (NULL_TREE, objc_class_template);\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"super_class\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* char *name; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"name\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* long version; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_LONG]);\n   field_decl = get_identifier (\"version\");\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* long info; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_LONG]);\n   field_decl = get_identifier (\"info\");\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* long instance_size; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_LONG]);\n   field_decl = get_identifier (\"instance_size\");\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_ivar_list *ivars; */\n@@ -3414,8 +3411,8 @@ build_class_template ()\n \t\t\t\txref_tag (RECORD_TYPE,\n \t\t\t\t\t  get_identifier (UTAG_IVAR_LIST)));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"ivars\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* struct objc_method_list *methods; */\n@@ -3424,8 +3421,8 @@ build_class_template ()\n \t\t\t\txref_tag (RECORD_TYPE,\n \t\t\t\t\t  get_identifier (UTAG_METHOD_LIST)));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"methods\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   if (flag_next_runtime)\n@@ -3436,7 +3433,7 @@ build_class_template ()\n \t\t\t\t    xref_tag (RECORD_TYPE,\n \t\t\t\t\t      get_identifier (\"objc_cache\")));\n       field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"cache\"));\n-      field_decl = grokfield (input_filename, lineno, field_decl,\n+      field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t      decl_specs, NULL_TREE);\n       chainon (field_decl_chain, field_decl);\n     }\n@@ -3448,7 +3445,7 @@ build_class_template ()\n \t\t\t\t    xref_tag (RECORD_TYPE,\n \t\t\t\t\t      get_identifier (\"sarray\")));\n       field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"dtable\"));\n-      field_decl = grokfield (input_filename, lineno, field_decl,\n+      field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t      decl_specs, NULL_TREE);\n       chainon (field_decl_chain, field_decl);\n \n@@ -3457,7 +3454,7 @@ build_class_template ()\n       decl_specs = build_tree_list (NULL_TREE, objc_class_template);\n       field_decl\n \t= build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"subclass_list\"));\n-      field_decl = grokfield (input_filename, lineno, field_decl,\n+      field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t      decl_specs, NULL_TREE);\n       chainon (field_decl_chain, field_decl);\n \n@@ -3466,7 +3463,7 @@ build_class_template ()\n       decl_specs = build_tree_list (NULL_TREE, objc_class_template);\n       field_decl\n \t= build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"sibling_class\"));\n-      field_decl = grokfield (input_filename, lineno, field_decl,\n+      field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t      decl_specs, NULL_TREE);\n       chainon (field_decl_chain, field_decl);\n     }\n@@ -3480,24 +3477,24 @@ build_class_template ()\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"protocol_list\"));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, field_decl);\n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* void *sel_id; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_VOID]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"sel_id\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* void *gc_object_type; */\n \n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_VOID]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"gc_object_type\"));\n-  field_decl\n-    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  field_decl = grokfield (input_filename, input_line,\n+\t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_class_template, field_decl_chain, NULL_TREE);\n@@ -3624,7 +3621,7 @@ build_super_template ()\n   decl_specs = build_tree_list (NULL_TREE, objc_object_reference);\n   field_decl = get_identifier (\"self\");\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, field_decl);\n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  field_decl, decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n@@ -3634,7 +3631,7 @@ build_super_template ()\n   decl_specs = build_tree_list (NULL_TREE, xref_tag (RECORD_TYPE, decl_specs));\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"class\"));\n \n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3668,7 +3665,7 @@ build_ivar_template ()\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"ivar_name\"));\n \n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n@@ -3677,7 +3674,7 @@ build_ivar_template ()\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_CHAR]);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"ivar_type\"));\n \n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3686,7 +3683,7 @@ build_ivar_template ()\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_INT]);\n   field_decl = get_identifier (\"ivar_offset\");\n \n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3715,7 +3712,7 @@ build_ivar_list_template (list_type, size)\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_INT]);\n   field_decl = get_identifier (\"ivar_count\");\n \n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n@@ -3725,7 +3722,7 @@ build_ivar_list_template (list_type, size)\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"ivar_list\"),\n \t\t\t build_int_2 (size, 0));\n \n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3759,7 +3756,7 @@ build_method_list_template (list_type, size)\n \t\t get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n   field_decl\n     = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"method_next\"));\n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n@@ -3768,7 +3765,7 @@ build_method_list_template (list_type, size)\n   decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_INT]);\n   field_decl = get_identifier (\"method_count\");\n \n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3778,7 +3775,7 @@ build_method_list_template (list_type, size)\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n \t\t\t build_int_2 (size, 0));\n \n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3983,22 +3980,22 @@ build_method_template ()\n \t\t\t  NULL_TREE);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"_cmd\"));\n \n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   field_decl_chain = field_decl;\n \n   decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_CHAR], NULL_TREE);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE,\n \t\t       get_identifier (\"method_types\"));\n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n   /* void *_imp; */\n \n   decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_VOID], NULL_TREE);\n   field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"_imp\"));\n-  field_decl = grokfield (input_filename, lineno, field_decl,\n+  field_decl = grokfield (input_filename, input_line, field_decl,\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -5828,7 +5825,7 @@ add_instance_variable (class, public, declarator, declspecs, width)\n   else\n     CLASS_RAW_IVARS (class) = raw_decl;\n \n-  field_decl = grokfield (input_filename, lineno,\n+  field_decl = grokfield (input_filename, input_line,\n \t\t\t  declarator, declspecs, width);\n \n   /* Overload the public attribute, it is not used for FIELD_DECLs.  */"}, {"sha": "7526125f9a57425af49c65b597e3688980c79559", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* RTL specific diagnostic subroutines for the GNU C compiler\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GCC.\n@@ -69,7 +69,7 @@ file_and_line_for_asm (insn, pfile, pline)\n   else\n     {\n       *pfile = input_filename;\n-      *pline = lineno;\n+      *pline = input_line;\n     }\n }\n "}, {"sha": "d29f38a977a5a161a3e85a0ca705b2e915a07762", "filename": "gcc/scan.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* scan.h - Utility declarations for scan-decls and fix-header programs.\n-   Copyright (C) 1993, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1998, 1999, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -52,7 +52,6 @@ struct fn_decl\n \n struct cpp_token;\n \n-extern int lineno;\n extern void sstring_append _PARAMS((sstring *, sstring *));\n extern void make_sstring_space _PARAMS((sstring *, int));\n extern int skip_spaces _PARAMS((FILE *, int));\n@@ -78,4 +77,4 @@ extern int get_token _PARAMS ((FILE *, sstring *));\n extern int source_lineno;\n extern sstring source_filename;\n /* Current physical line number */\n-extern int lineno;\n+extern int input_line;"}, {"sha": "0aee80f308aa98e2f0ccc607d64d773599952f47", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -162,7 +162,7 @@ const char *main_input_filename;\n \n /* Current line number in real source file.  */\n \n-int lineno;\n+int input_line;\n \n /* Nonzero if it is unsafe to create any new pseudo registers.  */\n int no_new_pseudos;\n@@ -2149,12 +2149,12 @@ push_srcloc (file, line)\n   if (input_file_stack)\n     {\n       input_file_stack->name = input_filename;\n-      input_file_stack->line = lineno;\n+      input_file_stack->line = input_line;\n     }\n \n   fs = (struct file_stack *) xmalloc (sizeof (struct file_stack));\n   fs->name = input_filename = file;\n-  fs->line = lineno = line;\n+  fs->line = input_line = line;\n   fs->next = input_file_stack;\n   input_file_stack = fs;\n   input_file_stack_tick++;\n@@ -2177,12 +2177,12 @@ pop_srcloc ()\n   if (input_file_stack)\n     {\n       input_filename = input_file_stack->name;\n-      lineno = input_file_stack->line;\n+      input_line = input_file_stack->line;\n     }\n   else\n     {\n       input_filename = NULL;\n-      lineno = 0;\n+      input_line = 0;\n     }\n }\n "}, {"sha": "cb6b0c49b8e51ce314819d37b1404270160af1aa", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,5 +1,5 @@\n /* Control and data flow functions for trees.\n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -900,10 +900,10 @@ static tree\n find_alloca_call (exp)\n      tree exp;\n {\n-  int line = lineno;\n+  int line = input_line;\n   const char *file = input_filename;\n   tree ret = walk_tree (&exp, find_alloca_call_1, NULL, NULL);\n-  lineno = line;\n+  input_line = line;\n   input_filename = file;\n   return ret;\n }\n@@ -931,10 +931,10 @@ static tree\n find_builtin_longjmp_call (exp)\n      tree exp;\n {\n-  int line = lineno;\n+  int line = input_line;\n   const char *file = input_filename;\n   tree ret = walk_tree (&exp, find_builtin_longjmp_call_1, NULL, NULL);\n-  lineno = line;\n+  input_line = line;\n   input_filename = file;\n   return ret;\n }\n@@ -1639,7 +1639,7 @@ walk_tree (tp, func, data, htab_)\n       /* Set lineno here so we get the right instantiation context\n \t if we call instantiate_decl from inlinable_function_p.  */\n       if (STATEMENT_CODE_P (code) && !STMT_LINENO_FOR_FN_P (*tp))\n-\tlineno = STMT_LINENO (*tp);\n+\tinput_line = STMT_LINENO (*tp);\n #endif /* not INLINER_FOR_JAVA */\n \n       /* Walk over all the sub-trees of this operand.  */"}, {"sha": "8cff4ce0e2fc14e6eecdd28b23ecf02cade785e0", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,6 +1,6 @@\n /* Language-independent node constructors for parse phase of GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -308,7 +308,7 @@ make_node (code)\n \tDECL_ALIGN (t) = 1;\n       DECL_USER_ALIGN (t) = 0;\n       DECL_IN_SYSTEM_HEADER (t) = in_system_header;\n-      DECL_SOURCE_LINE (t) = lineno;\n+      DECL_SOURCE_LINE (t) = input_line;\n       DECL_SOURCE_FILE (t) =\n \t(input_filename) ? input_filename : \"<built-in>\";\n       DECL_UID (t) = next_decl_uid++;"}, {"sha": "791be350da7cb4f6ea340ecbd332a2dea52576cc", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -2783,7 +2783,7 @@ extern int real_zerop PARAMS ((tree));\n extern const char *input_filename;\n \n /* Current line number in input file.  */\n-extern int lineno;\n+extern int input_line;\n \n /* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n    Zero means allow extended lvalues.  */"}, {"sha": "0c30bdba7e64a90555b36cee717f951e02307f99", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -1,3 +1,7 @@\n+2003-05-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree1.c (treelang_init): Rename lineno to input_line.\n+\n 2003-04-30  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* parse.y (make_plus_expression): New function."}, {"sha": "ad5622a7ddd39f9837c4a585983c9e177c707ec6", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d479d37f5ed3c67acedbf05dbf59ed9d6ac22567/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=d479d37f5ed3c67acedbf05dbf59ed9d6ac22567", "patch": "@@ -190,7 +190,7 @@ treelang_init ()\n   in_fname = main_input_filename;\n \n   /* Set up the declarations needed for this front end.  */\n-  lineno = 0;\n+  input_line = 0;\n \n   /* Init decls etc.  */\n "}]}