{"sha": "bd1cd0d0e0fecc6ac8632c266591767392480746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQxY2QwZDBlMGZlY2M2YWM4NjMyYzI2NjU5MTc2NzM5MjQ4MDc0Ng==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2021-04-23T19:59:00Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2021-05-04T13:53:50Z"}, "message": "Remove CC0\n\nThis removes CC0 and all directly related infrastructure.\n\nCC_STATUS, CC_STATUS_MDEP, CC_STATUS_MDEP_INIT, and NOTICE_UPDATE_CC\nare deleted and poisoned.  CC0 is only deleted (some targets use that\nname for something else).  HAVE_cc0 is automatically generated, and we\nno longer will do that after this patch.\n\nCC_STATUS_INIT is suggested in final.c to also be useful for ports that\nare not CC0, and at least arm seems to use it for something.  So I am\nleaving that alone, but most targets that have it could remove it.\n\n2021-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* caller-save.c: Remove CC0.\n\t* cfgcleanup.c: Remove CC0.\n\t* cfgrtl.c: Remove CC0.\n\t* combine.c: Remove CC0.\n\t* compare-elim.c: Remove CC0.\n\t* conditions.h: Remove CC0.\n\t* config/h8300/h8300.h: Remove CC0.\n\t* config/h8300/h8300-protos.h: Remove CC0.\n\t* config/h8300/peepholes.md: Remove CC0.\n\t* config/i386/x86-tune-sched.c: Remove CC0.\n\t* config/m68k/m68k.c: Remove CC0.\n\t* config/rl78/rl78.c: Remove CC0.\n\t* config/sparc/sparc.c: Remove CC0.\n\t* config/xtensa/xtensa.c: Remove CC0.\n\t(gen_conditional_move):  Use pc_rtx instead of cc0_rtx in a piece of\n\tRTL where that is used as a placeholder only.\n\t* cprop.c: Remove CC0.\n\t* cse.c: Remove CC0.\n\t* cselib.c: Remove CC0.\n\t* df-problems.c: Remove CC0.\n\t* df-scan.c: Remove CC0.\n\t* doc/md.texi: Remove CC0.  Adjust an example.\n\t* doc/rtl.texi: Remove CC0.  Adjust an example.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in: Remove CC0.\n\t* emit-rtl.c: Remove CC0.\n\t* final.c: Remove CC0.\n\t* fwprop.c: Remove CC0.\n\t* gcse-common.c: Remove CC0.\n\t* gcse.c: Remove CC0.\n\t* genattrtab.c: Remove CC0.\n\t* genconfig.c: Remove CC0.\n\t* genemit.c: Remove CC0.\n\t* genextract.c: Remove CC0.\n\t* gengenrtl.c: Remove CC0.\n\t* genrecog.c: Remove CC0.\n\t* haifa-sched.c: Remove CC0.\n\t* ifcvt.c: Remove CC0.\n\t* ira-costs.c: Remove CC0.\n\t* ira.c: Remove CC0.\n\t* jump.c: Remove CC0.\n\t* loop-invariant.c: Remove CC0.\n\t* lra-constraints.c: Remove CC0.\n\t* lra-eliminations.c: Remove CC0.\n\t* optabs.c: Remove CC0.\n\t* postreload-gcse.c: Remove CC0.\n\t* postreload.c: Remove CC0.\n\t* print-rtl.c: Remove CC0.\n\t* read-rtl-function.c: Remove CC0.\n\t* reg-notes.def: Remove CC0.\n\t* reg-stack.c: Remove CC0.\n\t* reginfo.c: Remove CC0.\n\t* regrename.c: Remove CC0.\n\t* reload.c: Remove CC0.\n\t* reload1.c: Remove CC0.\n\t* reorg.c: Remove CC0.\n\t* resource.c: Remove CC0.\n\t* rtl.c: Remove CC0.\n\t* rtl.def: Remove CC0.\n\t* rtl.h: Remove CC0.\n\t* rtlanal.c: Remove CC0.\n\t* sched-deps.c: Remove CC0.\n\t* sched-rgn.c: Remove CC0.\n\t* shrink-wrap.c: Remove CC0.\n\t* simplify-rtx.c: Remove CC0.\n\t* system.h: Remove CC0.  Poison NOTICE_UPDATE_CC, CC_STATUS_MDEP_INIT,\n\tCC_STATUS_MDEP, and CC_STATUS.\n\t* target.def: Remove CC0.\n\t* valtrack.c: Remove CC0.\n\t* var-tracking.c: Remove CC0.", "tree": {"sha": "8159e6c3badfa65e1d4462c94ac7285a572ba6ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8159e6c3badfa65e1d4462c94ac7285a572ba6ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd1cd0d0e0fecc6ac8632c266591767392480746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd1cd0d0e0fecc6ac8632c266591767392480746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd1cd0d0e0fecc6ac8632c266591767392480746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd1cd0d0e0fecc6ac8632c266591767392480746/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3897661151cf8cc77d11f7a98fc64259210748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a3897661151cf8cc77d11f7a98fc64259210748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a3897661151cf8cc77d11f7a98fc64259210748"}], "stats": {"total": 2857, "additions": 155, "deletions": 2702}, "files": [{"sha": "b02d6ea8245397952db2399cb905c3bcc03a0ac2", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1012,7 +1012,7 @@ mark_referenced_regs (rtx *loc, refmarker_fn *mark, void *arg)\n       loc = &SET_DEST (*loc);\n       code = GET_CODE (*loc);\n       if ((code == REG && REGNO (*loc) < FIRST_PSEUDO_REGISTER)\n-\t  || code == PC || code == CC0\n+\t  || code == PC\n \t  || (code == SUBREG && REG_P (SUBREG_REG (*loc))\n \t      && REGNO (SUBREG_REG (*loc)) < FIRST_PSEUDO_REGISTER\n \t      /* If we're setting only part of a multi-word register,\n@@ -1340,17 +1340,6 @@ insert_one_insn (class insn_chain *chain, int before_p, int code, rtx pat)\n   rtx_insn *insn = chain->insn;\n   class insn_chain *new_chain;\n \n-  /* If INSN references CC0, put our insns in front of the insn that sets\n-     CC0.  This is always safe, since the only way we could be passed an\n-     insn that references CC0 is for a restore, and doing a restore earlier\n-     isn't a problem.  We do, however, assume here that CALL_INSNs don't\n-     reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n-\n-  if (HAVE_cc0 && (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n-      && before_p\n-      && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    chain = chain->prev, insn = chain->insn;\n-\n   new_chain = new_insn_chain ();\n   if (before_p)\n     {"}, {"sha": "f05cb6136c7a6daa7a011bde4f821556f4ce31a8", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1449,12 +1449,6 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx_insn **f1,\n       i2 = PREV_INSN (i2);\n     }\n \n-  /* Don't allow the insn after a compare to be shared by\n-     cross-jumping unless the compare is also shared.  */\n-  if (HAVE_cc0 && ninsns && reg_mentioned_p (cc0_rtx, last1)\n-      && ! sets_cc0_p (last1))\n-    last1 = afterlast1, last2 = afterlast2, last_dir = afterlast_dir, ninsns--;\n-\n   /* Include preceding notes and labels in the cross-jump.  One,\n      this may bring us to the head of the blocks as requested above.\n      Two, it keeps line number notes as matched as may be.  */\n@@ -1571,12 +1565,6 @@ flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx_insn **f\n       i2 = NEXT_INSN (i2);\n     }\n \n-  /* Don't allow a compare to be shared by cross-jumping unless the insn\n-     after the compare is also shared.  */\n-  if (HAVE_cc0 && ninsns && reg_mentioned_p (cc0_rtx, last1)\n-      && sets_cc0_p (last1))\n-    last1 = beforelast1, last2 = beforelast2, ninsns--;\n-\n   if (ninsns)\n     {\n       *f1 = last1;\n@@ -2340,12 +2328,7 @@ try_head_merge_bb (basic_block bb)\n \n   cond = get_condition (jump, &move_before, true, false);\n   if (cond == NULL_RTX)\n-    {\n-      if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n-\tmove_before = prev_nonnote_nondebug_insn (jump);\n-      else\n-\tmove_before = jump;\n-    }\n+    move_before = jump;\n \n   for (ix = 0; ix < nedges; ix++)\n     if (EDGE_SUCC (bb, ix)->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -2505,12 +2488,7 @@ try_head_merge_bb (basic_block bb)\n       jump = BB_END (final_dest_bb);\n       cond = get_condition (jump, &move_before, true, false);\n       if (cond == NULL_RTX)\n-\t{\n-\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n-\t    move_before = prev_nonnote_nondebug_insn (jump);\n-\t  else\n-\t    move_before = jump;\n-\t}\n+\tmove_before = jump;\n     }\n \n   do\n@@ -2527,11 +2505,6 @@ try_head_merge_bb (basic_block bb)\n \t  /* Try again, using a different insertion point.  */\n \t  move_before = jump;\n \n-\t  /* Don't try moving before a cc0 user, as that may invalidate\n-\t     the cc0.  */\n-\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n-\t    break;\n-\n \t  continue;\n \t}\n \n@@ -2585,11 +2558,6 @@ try_head_merge_bb (basic_block bb)\n \t  /* For the unmerged insns, try a different insertion point.  */\n \t  move_before = jump;\n \n-\t  /* Don't try moving before a cc0 user, as that may invalidate\n-\t     the cc0.  */\n-\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, jump))\n-\t    break;\n-\n \t  for (ix = 0; ix < nedges; ix++)\n \t    currptr[ix] = headptr[ix] = nextptr[ix];\n \t}"}, {"sha": "4f3b1e8f3dc6fdea3da38821c3b7918f86546303", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -887,18 +887,6 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n       del_first = a_end;\n \n-      /* If this was a conditional jump, we need to also delete\n-\t the insn that set cc0.  */\n-      if (HAVE_cc0 && only_sets_cc0_p (prev))\n-\t{\n-\t  rtx_insn *tmp = prev;\n-\n-\t  prev = prev_nonnote_insn (prev);\n-\t  if (!prev)\n-\t    prev = BB_HEAD (a);\n-\t  del_first = tmp;\n-\t}\n-\n       a_end = PREV_INSN (del_first);\n     }\n   else if (BARRIER_P (NEXT_INSN (a_end)))\n@@ -1041,7 +1029,7 @@ edge\n try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n-  rtx_insn *insn = BB_END (src), *kill_from;\n+  rtx_insn *insn = BB_END (src);\n   rtx set;\n   int fallthru = 0;\n \n@@ -1078,13 +1066,6 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   if (!set || side_effects_p (set))\n     return NULL;\n \n-  /* In case we zap a conditional jump, we'll need to kill\n-     the cc0 setter too.  */\n-  kill_from = insn;\n-  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, PATTERN (insn))\n-      && only_sets_cc0_p (PREV_INSN (insn)))\n-    kill_from = PREV_INSN (insn);\n-\n   /* See if we can create the fallthru edge.  */\n   if (in_cfglayout || can_fallthru (src, target))\n     {\n@@ -1095,12 +1076,11 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       /* Selectively unlink whole insn chain.  */\n       if (in_cfglayout)\n \t{\n-\t  delete_insn_chain (kill_from, BB_END (src), false);\n+\t  delete_insn_chain (insn, BB_END (src), false);\n \t  remove_barriers_from_footer (src);\n \t}\n       else\n-\tdelete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)),\n-\t\t\t   false);\n+\tdelete_insn_chain (insn, PREV_INSN (BB_HEAD (target)), false);\n     }\n \n   /* If this already is simplejump, redirect it.  */\n@@ -1139,7 +1119,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t INSN_UID (insn), INSN_UID (BB_END (src)));\n \n \n-      delete_insn_chain (kill_from, insn, false);\n+      delete_insn_chain (insn, insn, false);\n \n       /* Recognize a tablejump that we are converting to a\n \t simple jump and remove its associated CODE_LABEL\n@@ -1806,11 +1786,6 @@ rtl_tidy_fallthru_edge (edge e)\n \t  delete_insn (table);\n \t}\n \n-      /* If this was a conditional jump, we need to also delete\n-\t the insn that set cc0.  */\n-      if (HAVE_cc0 && any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))\n-\tq = PREV_INSN (q);\n-\n       q = PREV_INSN (q);\n     }\n   /* Unconditional jumps with side-effects (i.e. which we can't just delete"}, {"sha": "6476812a21268e28219d1e302ee1c979d528a6ca", "filename": "gcc/combine.c", "status": "modified", "additions": 30, "deletions": 234, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -33,12 +33,6 @@ along with GCC; see the file COPYING3.  If not see\n    small number of quadruplets of insns A, B, C and D for which\n    there's high likelihood of success.\n \n-   LOG_LINKS does not have links for use of the CC0.  They don't\n-   need to, because the insn that sets the CC0 is always immediately\n-   before the insn that tests it.  So we always regard a branch\n-   insn as having a logical link to the preceding insn.  The same is true\n-   for an insn explicitly using CC0.\n-\n    We check (with modified_between_p) to avoid combining in such a way\n    as to move a computation to a place where its value would be different.\n \n@@ -64,16 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    To simplify substitution, we combine only when the earlier insn(s)\n    consist of only a single assignment.  To simplify updating afterward,\n-   we never combine when a subroutine call appears in the middle.\n-\n-   Since we do not represent assignments to CC0 explicitly except when that\n-   is all an insn does, there is no LOG_LINKS entry in an insn that uses\n-   the condition code for the insn that set the condition code.\n-   Fortunately, these two insns must be consecutive.\n-   Therefore, every JUMP_INSN is taken to have an implicit logical link\n-   to the preceding insn.  This is not quite right, since non-jumps can\n-   also use the condition code; but in practice such insns would not\n-   combine anyway.  */\n+   we never combine when a subroutine call appears in the middle.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -549,8 +534,8 @@ combine_split_insns (rtx pattern, rtx_insn *insn)\n }\n \n /* This is used by find_single_use to locate an rtx in LOC that\n-   contains exactly one use of DEST, which is typically either a REG\n-   or CC0.  It returns a pointer to the innermost rtx expression\n+   contains exactly one use of DEST, which is typically a REG.\n+   It returns a pointer to the innermost rtx expression\n    containing DEST.  Appearances of DEST that are being used to\n    totally replace it are not counted.  */\n \n@@ -574,12 +559,11 @@ find_single_use_1 (rtx dest, rtx *loc)\n       return 0;\n \n     case SET:\n-      /* If the destination is anything other than CC0, PC, a REG or a SUBREG\n+      /* If the destination is anything other than PC, a REG or a SUBREG\n \t of a REG that occupies all of the REG, the insn uses DEST if\n \t it is mentioned in the destination or the source.  Otherwise, we\n \t need just check the source.  */\n-      if (GET_CODE (SET_DEST (x)) != CC0\n-\t  && GET_CODE (SET_DEST (x)) != PC\n+      if (GET_CODE (SET_DEST (x)) != PC\n \t  && !REG_P (SET_DEST (x))\n \t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n \t\t&& REG_P (SUBREG_REG (SET_DEST (x)))\n@@ -649,9 +633,6 @@ find_single_use_1 (rtx dest, rtx *loc)\n \n    If PLOC is nonzero, *PLOC is set to the insn containing the single use.\n \n-   If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't\n-   care about REG_DEAD notes or LOG_LINKS.\n-\n    Otherwise, we find the single use by finding an insn that has a\n    LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is\n    only referenced once in that insn, we know that it must be the first\n@@ -665,19 +646,6 @@ find_single_use (rtx dest, rtx_insn *insn, rtx_insn **ploc)\n   rtx *result;\n   struct insn_link *link;\n \n-  if (dest == cc0_rtx)\n-    {\n-      next = NEXT_INSN (insn);\n-      if (next == 0\n-\t  || (!NONJUMP_INSN_P (next) && !JUMP_P (next)))\n-\treturn 0;\n-\n-      result = find_single_use_1 (dest, &PATTERN (next));\n-      if (result && ploc)\n-\t*ploc = next;\n-      return result;\n-    }\n-\n   if (!REG_P (dest))\n     return 0;\n \n@@ -1128,9 +1096,7 @@ create_log_links (void)\n /* Walk the LOG_LINKS of insn B to see if we find a reference to A.  Return\n    true if we found a LOG_LINK that proves that A feeds B.  This only works\n    if there are no instructions between A and B which could have a link\n-   depending on A, since in that case we would not record a link for B.\n-   We also check the implicit dependency created by a cc0 setter/user\n-   pair.  */\n+   depending on A, since in that case we would not record a link for B.  */\n \n static bool\n insn_a_feeds_b (rtx_insn *a, rtx_insn *b)\n@@ -1139,8 +1105,6 @@ insn_a_feeds_b (rtx_insn *a, rtx_insn *b)\n   FOR_EACH_LOG_LINK (links, b)\n     if (links->insn == a)\n       return true;\n-  if (HAVE_cc0 && sets_cc0_p (a))\n-    return true;\n   return false;\n }\n \f\n@@ -1153,7 +1117,6 @@ static int\n combine_instructions (rtx_insn *f, unsigned int nregs)\n {\n   rtx_insn *insn, *next;\n-  rtx_insn *prev;\n   struct insn_link *links, *nextlinks;\n   rtx_insn *first;\n   basic_block last_bb;\n@@ -1330,69 +1293,6 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t\t    }\n \t      }\n \n-\t  /* Try to combine a jump insn that uses CC0\n-\t     with a preceding insn that sets CC0, and maybe with its\n-\t     logical predecessor as well.\n-\t     This is how we make decrement-and-branch insns.\n-\t     We need this special code because data flow connections\n-\t     via CC0 do not get entered in LOG_LINKS.  */\n-\n-\t  if (HAVE_cc0\n-\t      && JUMP_P (insn)\n-\t      && (prev = prev_nonnote_insn (insn)) != 0\n-\t      && NONJUMP_INSN_P (prev)\n-\t      && sets_cc0_p (PATTERN (prev)))\n-\t    {\n-\t      if ((next = try_combine (insn, prev, NULL, NULL,\n-\t\t\t\t       &new_direct_jump_p,\n-\t\t\t\t       last_combined_insn)) != 0)\n-\t\tgoto retry;\n-\n-\t      FOR_EACH_LOG_LINK (nextlinks, prev)\n-\t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t   NULL, &new_direct_jump_p,\n-\t\t\t\t\t   last_combined_insn)) != 0)\n-\t\t    goto retry;\n-\t    }\n-\n-\t  /* Do the same for an insn that explicitly references CC0.  */\n-\t  if (HAVE_cc0 && NONJUMP_INSN_P (insn)\n-\t      && (prev = prev_nonnote_insn (insn)) != 0\n-\t      && NONJUMP_INSN_P (prev)\n-\t      && sets_cc0_p (PATTERN (prev))\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n-\t    {\n-\t      if ((next = try_combine (insn, prev, NULL, NULL,\n-\t\t\t\t       &new_direct_jump_p,\n-\t\t\t\t       last_combined_insn)) != 0)\n-\t\tgoto retry;\n-\n-\t      FOR_EACH_LOG_LINK (nextlinks, prev)\n-\t\t  if ((next = try_combine (insn, prev, nextlinks->insn,\n-\t\t\t\t\t   NULL, &new_direct_jump_p,\n-\t\t\t\t\t   last_combined_insn)) != 0)\n-\t\t    goto retry;\n-\t    }\n-\n-\t  /* Finally, see if any of the insns that this insn links to\n-\t     explicitly references CC0.  If so, try this insn, that insn,\n-\t     and its predecessor if it sets CC0.  */\n-\t  if (HAVE_cc0)\n-\t    {\n-\t      FOR_EACH_LOG_LINK (links, insn)\n-\t\tif (NONJUMP_INSN_P (links->insn)\n-\t\t    && GET_CODE (PATTERN (links->insn)) == SET\n-\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n-\t\t    && (prev = prev_nonnote_insn (links->insn)) != 0\n-\t\t    && NONJUMP_INSN_P (prev)\n-\t\t    && sets_cc0_p (PATTERN (prev))\n-\t\t    && (next = try_combine (insn, links->insn,\n-\t\t\t\t\t    prev, NULL, &new_direct_jump_p,\n-\t\t\t\t\t    last_combined_insn)) != 0)\n-\t\t  goto retry;\n-\t    }\n-\n \t  /* Try combining an insn with two different insns whose results it\n \t     uses.  */\n \t  if (max_combine >= 3)\n@@ -1853,7 +1753,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n   else if (next_active_insn (insn) != i3)\n     all_adjacent = false;\n     \n-  /* Can combine only if previous insn is a SET of a REG, a SUBREG or CC0.\n+  /* Can combine only if previous insn is a SET of a REG or a SUBREG,\n      or a PARALLEL consisting of such a SET and CLOBBERs.\n \n      If INSN has CLOBBER parallel parts, ignore them for our processing.\n@@ -2032,7 +1932,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n       || (DF_INSN_LUID (insn) < last_call_luid && ! CONSTANT_P (src)))\n     return 0;\n \n-  /* DEST must either be a REG or CC0.  */\n+  /* DEST must be a REG.  */\n   if (REG_P (dest))\n     {\n       /* If register alignment is being enforced for multi-word items in all\n@@ -2059,7 +1959,7 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  GET_MODE (src)))))\n \treturn 0;\n     }\n-  else if (GET_CODE (dest) != CC0)\n+  else\n     return 0;\n \n \n@@ -2139,23 +2039,6 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \t      || reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i3))))\n \treturn 0;\n \n-  /* Don't combine an insn that follows a CC0-setting insn.\n-     An insn that uses CC0 must not be separated from the one that sets it.\n-     We do, however, allow I2 to follow a CC0-setting insn if that insn\n-     is passed as I1; in that case it will be deleted also.\n-     We also allow combining in this case if all the insns are adjacent\n-     because that would leave the two CC0 insns adjacent as well.\n-     It would be more logical to test whether CC0 occurs inside I1 or I2,\n-     but that would be much slower, and this ought to be equivalent.  */\n-\n-  if (HAVE_cc0)\n-    {\n-      p = prev_nonnote_insn (insn);\n-      if (p && p != pred && NONJUMP_INSN_P (p) && sets_cc0_p (PATTERN (p))\n-\t  && ! all_adjacent)\n-\treturn 0;\n-    }\n-\n   /* If we get here, we have passed all the tests and the combination is\n      to be allowed.  */\n \n@@ -2988,7 +2871,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      This undoes a previous combination and allows us to match a branch-and-\n      decrement insn.  */\n \n-  if (!HAVE_cc0 && i1 == 0\n+  if (i1 == 0\n       && is_parallel_of_n_reg_sets (PATTERN (i2), 2)\n       && (GET_MODE_CLASS (GET_MODE (SET_DEST (XVECEXP (PATTERN (i2), 0, 0))))\n \t  == MODE_CC)\n@@ -3020,7 +2903,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   /* If I2 is a PARALLEL of two SETs of REGs (and perhaps some CLOBBERs),\n      make those two SETs separate I1 and I2 insns, and make an I0 that is\n      the original I1.  */\n-  if (!HAVE_cc0 && i0 == 0\n+  if (i0 == 0\n       && is_parallel_of_n_reg_sets (PATTERN (i2), 2)\n       && can_split_parallel_of_n_reg_sets (i2, 2)\n       && !reg_used_between_p (SET_DEST (XVECEXP (PATTERN (i2), 0, 0)), i2, i3)\n@@ -3228,7 +3111,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n   subst_insn = i3;\n \n-  /* Many machines that don't use CC0 have insns that can both perform an\n+  /* Many machines have insns that can both perform an\n      arithmetic operation and set the condition code.  These operations will\n      be represented as a PARALLEL with the first element of the vector\n      being a COMPARE of an arithmetic operation with the constant zero.\n@@ -3239,7 +3122,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      needed, and make the PARALLEL by just replacing I2DEST in I3SRC with\n      I2SRC.  Later we will make the PARALLEL that contains I2.  */\n \n-  if (!HAVE_cc0 && i1 == 0 && added_sets_2 && GET_CODE (PATTERN (i3)) == SET\n+  if (i1 == 0 && added_sets_2 && GET_CODE (PATTERN (i3)) == SET\n       && GET_CODE (SET_SRC (PATTERN (i3))) == COMPARE\n       && CONST_INT_P (XEXP (SET_SRC (PATTERN (i3)), 1))\n       && rtx_equal_p (XEXP (SET_SRC (PATTERN (i3)), 0), i2dest))\n@@ -3779,7 +3662,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t are set between I2 and I3.  */\n       if (insn_code_number < 0\n           && (split = find_split_point (&newpat, i3, false)) != 0\n-\t  && (!HAVE_cc0 || REG_P (i2dest))\n \t  /* We need I2DEST in the proper mode.  If it is a hard register\n \t     or the only use of a pseudo, we can change its mode.\n \t     Make sure we don't change a hard register to have a mode that\n@@ -3966,7 +3848,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      eliminate the copy.\n \n      We cannot do this if the destination of the first assignment is a\n-     condition code register or cc0.  We eliminate this case by making sure\n+     condition code register.  We eliminate this case by making sure\n      the SET_DEST and SET_SRC have the same mode.\n \n      We cannot do this if the destination of the second assignment is\n@@ -4060,8 +3942,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       rtx set0 = XVECEXP (newpat, 0, 0);\n       rtx set1 = XVECEXP (newpat, 0, 1);\n \n-      /* Normally, it doesn't matter which of the two is done first,\n-\t but the one that references cc0 can't be the second, and\n+      /* Normally, it doesn't matter which of the two is done first, but\n \t one which uses any regs/memory set in between i2 and i3 can't\n \t be first.  The PARALLEL might also have been pre-existing in i3,\n \t so we need to make sure that we won't wrongly hoist a SET to i2\n@@ -4074,7 +3955,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t       && find_reg_note (i2, REG_DEAD,\n \t\t\t\t SUBREG_REG (SET_DEST (set1))))\n \t  && !modified_between_p (SET_DEST (set1), i2, i3)\n-\t  && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set0))\n \t  /* If I3 is a jump, ensure that set0 is a jump so that\n \t     we do not create invalid RTL.  */\n \t  && (!JUMP_P (i3) || SET_DEST (set0) == pc_rtx)\n@@ -4090,7 +3970,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t    && find_reg_note (i2, REG_DEAD,\n \t\t\t\t      SUBREG_REG (SET_DEST (set0))))\n \t       && !modified_between_p (SET_DEST (set0), i2, i3)\n-\t       && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set1))\n \t       /* If I3 is a jump, ensure that set1 is a jump so that\n \t\t  we do not create invalid RTL.  */\n \t       && (!JUMP_P (i3) || SET_DEST (set1) == pc_rtx)\n@@ -4158,19 +4037,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t}\n     }\n \n-  /* If I2 is the CC0 setter and I3 is the CC0 user then check whether\n-     they are adjacent to each other or not.  */\n-  if (HAVE_cc0)\n-    {\n-      rtx_insn *p = prev_nonnote_insn (i3);\n-      if (p && p != i2 && NONJUMP_INSN_P (p) && newi2pat\n-\t  && sets_cc0_p (newi2pat))\n-\t{\n-\t  undo_all ();\n-\t  return 0;\n-\t}\n-    }\n-\n   /* Only allow this combination if insn_cost reports that the\n      replacement instructions are cheaper than the originals.  */\n   if (!combine_validate_cost (i0, i1, i2, i3, newpat, newi2pat, other_pat))\n@@ -5061,19 +4927,6 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n       break;\n \n     case SET:\n-      /* If SET_DEST is CC0 and SET_SRC is not an operand, a COMPARE, or a\n-\t ZERO_EXTRACT, the most likely reason why this doesn't match is that\n-\t we need to put the operand into a register.  So split at that\n-\t point.  */\n-\n-      if (SET_DEST (x) == cc0_rtx\n-\t  && GET_CODE (SET_SRC (x)) != COMPARE\n-\t  && GET_CODE (SET_SRC (x)) != ZERO_EXTRACT\n-\t  && !OBJECT_P (SET_SRC (x))\n-\t  && ! (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t&& OBJECT_P (SUBREG_REG (SET_SRC (x)))))\n-\treturn &SET_SRC (x);\n-\n       /* See if we can split SET_SRC as it stands.  */\n       split = find_split_point (&SET_SRC (x), insn, true);\n       if (split && split != &SET_SRC (x))\n@@ -5485,9 +5338,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \t{\n \t  rtx dest = SET_DEST (XVECEXP (x, 0, i));\n \n-\t  if (!REG_P (dest)\n-\t      && GET_CODE (dest) != CC0\n-\t      && GET_CODE (dest) != PC)\n+\t  if (!REG_P (dest) && GET_CODE (dest) != PC)\n \t    {\n \t      new_rtx = subst (dest, from, to, 0, 0, unique_copy);\n \n@@ -5505,13 +5356,12 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n       len = GET_RTX_LENGTH (code);\n       fmt = GET_RTX_FORMAT (code);\n \n-      /* We don't need to process a SET_DEST that is a register, CC0,\n-\t or PC, so set up to skip this common case.  All other cases\n-\t where we want to suppress replacing something inside a\n-\t SET_SRC are handled via the IN_DEST operand.  */\n+      /* We don't need to process a SET_DEST that is a register or PC, so\n+\t set up to skip this common case.  All other cases where we want\n+\t to suppress replacing something inside a SET_SRC are handled via\n+\t the IN_DEST operand.  */\n       if (code == SET\n \t  && (REG_P (SET_DEST (x))\n-\t      || GET_CODE (SET_DEST (x)) == CC0\n \t      || GET_CODE (SET_DEST (x)) == PC))\n \tfmt = \"ie\";\n \n@@ -5581,22 +5431,17 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \t\t     from in the outside mode, and that may be invalid\n \t\t     if it is an fp reg copied in integer mode.\n \n-\t\t     We allow two exceptions to this: It is valid if\n+\t\t     We allow an exception to this: It is valid if\n \t\t     it is inside another SUBREG and the mode of that\n \t\t     SUBREG and the mode of the inside of TO is\n-\t\t     tieable and it is valid if X is a SET that copies\n-\t\t     FROM to CC0.  */\n+\t\t     tieable.  */\n \n \t\t  if (GET_CODE (to) == SUBREG\n \t\t      && !targetm.modes_tieable_p (GET_MODE (to),\n \t\t\t\t\t\t   GET_MODE (SUBREG_REG (to)))\n \t\t      && ! (code == SUBREG\n \t\t\t    && (targetm.modes_tieable_p\n-\t\t\t\t(GET_MODE (x), GET_MODE (SUBREG_REG (to)))))\n-\t\t      && (!HAVE_cc0\n-\t\t\t  || (! (code == SET\n-\t\t\t\t && i == 1\n-\t\t\t\t && XEXP (x, 0) == cc0_rtx))))\n+\t\t\t\t(GET_MODE (x), GET_MODE (SUBREG_REG (to))))))\n \t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \n \t\t  if (code == SUBREG\n@@ -6219,8 +6064,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n       /* If the first operand is a condition code, we can't do anything\n \t with it.  */\n       if (GET_CODE (XEXP (x, 0)) == COMPARE\n-\t  || (GET_MODE_CLASS (GET_MODE (XEXP (x, 0))) != MODE_CC\n-\t      && ! CC0_P (XEXP (x, 0))))\n+\t  || GET_MODE_CLASS (GET_MODE (XEXP (x, 0))) != MODE_CC)\n \t{\n \t  rtx op0 = XEXP (x, 0);\n \t  rtx op1 = XEXP (x, 1);\n@@ -6833,12 +6677,9 @@ simplify_set (rtx x)\n       SUBST (SET_SRC (x), src);\n     }\n \n-  /* If we are setting CC0 or if the source is a COMPARE, look for the use of\n-     the comparison result and try to simplify it unless we already have used\n-     undobuf.other_insn.  */\n-  if ((GET_MODE_CLASS (mode) == MODE_CC\n-       || GET_CODE (src) == COMPARE\n-       || CC0_P (dest))\n+  /* If the source is a COMPARE, look for the use of the comparison result\n+     and try to simplify it unless we already have used undobuf.other_insn.  */\n+  if ((GET_MODE_CLASS (mode) == MODE_CC || GET_CODE (src) == COMPARE)\n       && (cc_use = find_single_use (dest, subst_insn, &other_insn)) != 0\n       && (undobuf.other_insn == 0 || other_insn == undobuf.other_insn)\n       && COMPARISON_P (*cc_use)\n@@ -6915,7 +6756,7 @@ simplify_set (rtx x)\n \t a hard register, just build new versions with the proper mode.  If it\n \t is a pseudo, we lose unless it is only time we set the pseudo, in\n \t which case we can safely change its mode.  */\n-      if (!HAVE_cc0 && compare_mode != GET_MODE (dest))\n+      if (compare_mode != GET_MODE (dest))\n \t{\n \t  if (can_change_dest_mode (dest, 0, compare_mode))\n \t    {\n@@ -7039,24 +6880,6 @@ simplify_set (rtx x)\n       src = SET_SRC (x), dest = SET_DEST (x);\n     }\n \n-  /* If we have (set (cc0) (subreg ...)), we try to remove the subreg\n-     in SRC.  */\n-  if (dest == cc0_rtx\n-      && partial_subreg_p (src)\n-      && subreg_lowpart_p (src))\n-    {\n-      rtx inner = SUBREG_REG (src);\n-      machine_mode inner_mode = GET_MODE (inner);\n-\n-      /* Here we make sure that we don't have a sign bit on.  */\n-      if (val_signbit_known_clear_p (GET_MODE (src),\n-\t\t\t\t     nonzero_bits (inner, inner_mode)))\n-\t{\n-\t  SUBST (SET_SRC (x), inner);\n-\t  src = SET_SRC (x);\n-\t}\n-    }\n-\n   /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with M wider than N, this\n      would require a paradoxical subreg.  Replace the subreg with a\n      zero_extend to avoid the reload that would otherwise be required.\n@@ -12250,7 +12073,6 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* We can't do anything if OP0 is a condition code value, rather\n \t     than an actual data value.  */\n \t  if (const_op != 0\n-\t      || CC0_P (XEXP (op0, 0))\n \t      || GET_MODE_CLASS (GET_MODE (XEXP (op0, 0))) == MODE_CC)\n \t    break;\n \n@@ -13935,9 +13757,6 @@ mark_used_regs_combine (rtx x)\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n     case ASM_INPUT:\n-    /* CC0 must die in the insn after it is set, so we don't need to take\n-       special note of it here.  */\n-    case CC0:\n       return;\n \n     case CLOBBER:\n@@ -14615,7 +14434,6 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t    {\n \t\t      rtx set = single_set (tem_insn);\n \t\t      rtx inner_dest = 0;\n-\t\t      rtx_insn *cc0_setter = NULL;\n \n \t\t      if (set != 0)\n \t\t\tfor (inner_dest = SET_DEST (set);\n@@ -14628,17 +14446,12 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t      /* Verify that it was the set, and not a clobber that\n \t\t\t modified the register.\n \n-\t\t\t CC0 targets must be careful to maintain setter/user\n-\t\t\t pairs.  If we cannot delete the setter due to side\n+\t\t\t If we cannot delete the setter due to side\n \t\t\t effects, mark the user with an UNUSED note instead\n \t\t\t of deleting it.  */\n \n \t\t      if (set != 0 && ! side_effects_p (SET_SRC (set))\n-\t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest)\n-\t\t\t  && (!HAVE_cc0\n-\t\t\t      || (! reg_mentioned_p (cc0_rtx, SET_SRC (set))\n-\t\t\t\t  || ((cc0_setter = prev_cc0_setter (tem_insn)) != NULL\n-\t\t\t\t      && sets_cc0_p (PATTERN (cc0_setter)) > 0))))\n+\t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest))\n \t\t\t{\n \t\t\t  /* Move the notes and links of TEM_INSN elsewhere.\n \t\t\t     This might delete other dead insns recursively.\n@@ -14661,23 +14474,6 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t\t  SET_INSN_DELETED (tem_insn);\n \t\t\t  if (tem_insn == i2)\n \t\t\t    i2 = NULL;\n-\n-\t\t\t  /* Delete the setter too.  */\n-\t\t\t  if (cc0_setter)\n-\t\t\t    {\n-\t\t\t      PATTERN (cc0_setter) = pc_rtx;\n-\t\t\t      old_notes = REG_NOTES (cc0_setter);\n-\t\t\t      REG_NOTES (cc0_setter) = NULL;\n-\n-\t\t\t      distribute_notes (old_notes, cc0_setter,\n-\t\t\t\t\t\tcc0_setter, NULL,\n-\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n-\t\t\t      distribute_links (LOG_LINKS (cc0_setter));\n-\n-\t\t\t      SET_INSN_DELETED (cc0_setter);\n-\t\t\t      if (cc0_setter == i2)\n-\t\t\t\ti2 = NULL;\n-\t\t\t    }\n \t\t\t}\n \t\t      else\n \t\t\t{"}, {"sha": "85085cd69735bdcdac697bebbe1450299bd0466a", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -25,9 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n    cannot make use of the comparison elimination offered by the combine pass.\n \n    This is a small pass intended to provide comparison elimination similar to\n-   what is available via NOTICE_UPDATE_CC for cc0 targets.  This should help\n-   encourage cc0 targets to convert to an explicit post-reload representation\n-   of the flags.\n+   what was available via NOTICE_UPDATE_CC for cc0 targets.\n \n    This pass assumes:\n "}, {"sha": "d9ca51ad926a64ed5d8d1507837cdd8c34e904a1", "filename": "gcc/conditions.h", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconditions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconditions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconditions.h?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -20,46 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CONDITIONS_H\n #define GCC_CONDITIONS_H\n \n-/* The variable cc_status says how to interpret the condition code.\n-   It is set by output routines for an instruction that sets the cc's\n-   and examined by output routines for jump instructions.\n-\n-   cc_status contains two components named `value1' and `value2'\n-   that record two equivalent expressions for the values that the\n-   condition codes were set from.  (Either or both may be null if\n-   there is no useful expression to record.)  These fields are\n-   used for eliminating redundant test and compare instructions\n-   in the cases where the condition codes were already set by the\n-   previous instruction.\n-\n-   cc_status.flags contains flags which say that the condition codes\n-   were set in a nonstandard manner.  The output of jump instructions\n-   uses these flags to compensate and produce the standard result\n-   with the nonstandard condition codes.  Standard flags are defined here.\n-   The tm.h file can also define other machine-dependent flags.\n-\n-   cc_status also contains a machine-dependent component `mdep'\n-   whose type, `CC_STATUS_MDEP', may be defined as a macro in the\n-   tm.h file.  */\n-\n-#ifndef CC_STATUS_MDEP\n-#define CC_STATUS_MDEP int\n-#endif\n-\n-#ifndef CC_STATUS_MDEP_INIT\n-#define CC_STATUS_MDEP_INIT 0\n-#endif\n-\n-struct CC_STATUS {int flags; rtx value1, value2; CC_STATUS_MDEP mdep;};\n-\n-/* While outputting an insn as assembler code,\n-   this is the status BEFORE that insn.  */\n-extern CC_STATUS cc_prev_status;\n-\n-/* While outputting an insn as assembler code,\n-   this is being altered to the status AFTER that insn.  */\n-extern CC_STATUS cc_status;\n-\n /* These are the machine-independent flags:  */\n \n /* Set if the sign of the cc value is inverted:\n@@ -106,13 +66,4 @@ extern CC_STATUS cc_status;\n    This is only used by machine description files.  */\n #define CC_NOT_SIGNED 0200\n \n-/* This is how to initialize the variable cc_status.\n-   final does this at appropriate moments.  */\n-\n-/* FIXME: We want to get rid of these ifndefs.  */\n-#ifndef CC_STATUS_INIT\n-#define CC_STATUS_INIT  \\\n- (cc_status.flags = 0, cc_status.value1 = 0, cc_status.value2 = 0,  \\\n-  CC_STATUS_MDEP_INIT)\n-#endif\n #endif /* GCC_CONDITIONS_H */"}, {"sha": "45e7dec3c7dc7ea8f29eb0923910ab7850d7721b", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -36,7 +36,6 @@ extern const char *output_simode_bld (int, rtx[]);\n extern void final_prescan_insn (rtx_insn *, rtx *, int);\n extern int h8300_expand_movsi (rtx[]);\n extern machine_mode  h8300_select_cc_mode (RTX_CODE, rtx, rtx);\n-extern void notice_update_cc (rtx, rtx_insn *);\n extern const char *output_logical_op (machine_mode, rtx *);\n extern unsigned int compute_logical_op_length (machine_mode,\n \t\t\t\t\t       rtx *);"}, {"sha": "ea600212ea50357ae9de1b3f52647e37a9d6d166", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -569,13 +569,6 @@ struct cum_arg\n /* Here we define machine-dependent flags and fields in cc_status\n    (see `conditions.h').  No extra ones are needed for the h8300.  */\n \n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc (EXP, INSN)\n-\n /* The add insns don't set overflow in a usable way.  */\n #define CC_OVERFLOW_UNUSABLE 01000\n /* The mov,and,or,xor insns don't set carry.  That's OK though as the"}, {"sha": "a836d7dbb13ec81ca1b13928a980e6557cf2fa0a", "filename": "gcc/config/h8300/peepholes.md", "status": "modified", "additions": 0, "deletions": 947, "changes": 947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fpeepholes.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fh8300%2Fpeepholes.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpeepholes.md?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -349,90 +349,6 @@\n \t\t (match_dup 1)))]\n   \"\")\n \n-;; Turn\n-;;\n-;;   subs   #1,er4\n-;;   mov.w  r4,r4\n-;;   bne    .L2028\n-;;\n-;; into\n-;;\n-;;   dec.w  #1,r4\n-;;   bne    .L2028\n-\n-(define_peephole2\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(unspec:HI [(match_dup 0)\n-\t\t    (match_dup 1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))])\n-\n-;; The SImode version of the previous pattern.\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (match_dup 1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))])\n-\n-(define_peephole2\n-  [(parallel [(set (cc0)\n-\t\t   (compare (zero_extract:SI (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t\t\t\t     (const_int 1)\n-\t\t\t\t\t     (const_int 7))\n-\t\t\t    (const_int 0)))\n-\t      (clobber (scratch:QI))])\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[4] = ((GET_CODE (operands[4]) == EQ)\n-\t\t   ? gen_rtx_GE (VOIDmode, cc0_rtx, const0_rtx)\n-\t\t   : gen_rtx_LT (VOIDmode, cc0_rtx, const0_rtx));\n-  })\n-\n ;; If a load of mem:SI is followed by an AND that turns off the upper\n ;; half, then we can load mem:HI instead.\n \n@@ -456,829 +372,6 @@\n     operands[4] = gen_lowpart (HImode, operands[1]);\n   })\n \n-;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve\n-;; the equivalent with shorter sequences.  Here is the summary.  Cases\n-;; are grouped for each define_peephole2.\n-;;\n-;; reg  const_int                   use     insn\n-;; --------------------------------------------------------\n-;; dead    -2                       eq/ne   inc.l\n-;; dead    -1                       eq/ne   inc.l\n-;; dead     1                       eq/ne   dec.l\n-;; dead     2                       eq/ne   dec.l\n-;;\n-;; dead     1                       ge/lt shar.l\n-;; dead     3 (H8S)                 ge/lt shar.l\n-;;\n-;; dead     1                       geu/ltu shar.l\n-;; dead     3 (H8S)                 geu/ltu shar.l\n-;;\n-;; ----   255                       ge/lt mov.b\n-;;\n-;; ----   255                       geu/ltu mov.b\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbne\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.w\t#1,r0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n-  [(set (match_dup 0)\n-\t(unspec:HI [(match_dup 0)\n-\t\t    (match_dup 5)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.w\tr0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:HI (match_dup 0)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.w\tr0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:HI (match_dup 0)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 6)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#255,r0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.b\tr0h,r0h\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (const_int 255)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (compare (and:HI (match_dup 0)\n-\t\t\t       (const_int -256))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))])\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#255,r0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.b\tr0h,r0h\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (const_int 255)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (compare (and:HI (match_dup 0)\n-\t\t\t       (const_int -256))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve\n-;; the equivalent with shorter sequences.  Here is the summary.  Cases\n-;; are grouped for each define_peephole2.\n-;;\n-;; reg  const_int                   use     insn\n-;; --------------------------------------------------------\n-;; live    -2                       eq/ne   copy and inc.l\n-;; live    -1                       eq/ne   copy and inc.l\n-;; live     1                       eq/ne   copy and dec.l\n-;; live     2                       eq/ne   copy and dec.l\n-;;\n-;; dead    -2                       eq/ne   inc.l\n-;; dead    -1                       eq/ne   inc.l\n-;; dead     1                       eq/ne   dec.l\n-;; dead     2                       eq/ne   dec.l\n-;;\n-;; dead -131072                     eq/ne   inc.w and test\n-;; dead  -65536                     eq/ne   inc.w and test\n-;; dead   65536                     eq/ne   dec.w and test\n-;; dead  131072                     eq/ne   dec.w and test\n-;;\n-;; dead 0x000000?? except 1 and 2   eq/ne   xor.b and test\n-;; dead 0x0000??00                  eq/ne   xor.b and test\n-;; dead 0x0000ffff                  eq/ne   not.w and test\n-;;\n-;; dead 0xffffff?? except -1 and -2 eq/ne   xor.b and not.l\n-;; dead 0xffff??ff                  eq/ne   xor.b and not.l\n-;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l\n-;; dead 0x80000000                  eq/ne   rotl.l and dec.l\n-;;\n-;; live     1                       ge/lt copy and shar.l\n-;; live     3 (H8S)                 ge/lt copy and shar.l\n-;;\n-;; live     1                       geu/ltu copy and shar.l\n-;; live     3 (H8S)                 geu/ltu copy and shar.l\n-;;\n-;; dead     1                       ge/lt shar.l\n-;; dead     3 (H8S)                 ge/lt shar.l\n-;;\n-;; dead     1                       geu/ltu shar.l\n-;; dead     3 (H8S)                 geu/ltu shar.l\n-;;\n-;; dead     3 (H8/300H)             ge/lt and.b and test\n-;; dead     7                       ge/lt and.b and test\n-;; dead    15                       ge/lt and.b and test\n-;; dead    31                       ge/lt and.b and test\n-;; dead    63                       ge/lt and.b and test\n-;; dead   127                       ge/lt and.b and test\n-;; dead   255                       ge/lt and.b and test\n-;;\n-;; dead     3 (H8/300H)             geu/ltu and.b and test\n-;; dead     7                       geu/ltu and.b and test\n-;; dead    15                       geu/ltu and.b and test\n-;; dead    31                       geu/ltu and.b and test\n-;; dead    63                       geu/ltu and.b and test\n-;; dead   127                       geu/ltu and.b and test\n-;; dead   255                       geu/ltu and.b and test\n-;;\n-;; ---- 65535                       ge/lt mov.w\n-;;\n-;; ---- 65535                       geu/ltu mov.w\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.l\t#1,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n-  [(set (match_dup 0)\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (match_dup 5)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65536,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.l\t#1,e0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == -131072\n-       || INTVAL (operands[1]) == -65536\n-       || INTVAL (operands[1]) == 65536\n-       || INTVAL (operands[1]) == 131072)\"\n-  [(set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 5)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#100,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\txor.b\t#100,er0\n-;;\tmov.l\ter0,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n-       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n-       || INTVAL (operands[1]) == 0x0000ffff)\n-   && INTVAL (operands[1]) != 0\n-   && INTVAL (operands[1]) != 1\n-   && INTVAL (operands[1]) != 2\"\n-  [(set (match_dup 0)\n-\t(xor:SI (match_dup 0)\n-\t\t(match_dup 1)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))])\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#-100,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\txor.b\t#99,er0\n-;;\tnot.l\ter0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((INTVAL (operands[1]) | 0x00ff) == -1\n-       || (INTVAL (operands[1]) | 0xff00) == -1)\n-   && INTVAL (operands[1]) != -1\n-   && INTVAL (operands[1]) != -2\"\n-  [(set (match_dup 0)\n-\t(xor:SI (match_dup 0)\n-\t\t(match_dup 5)))\n-   (set (match_dup 0)\n-\t(not:SI (match_dup 0)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (INTVAL (operands[1]) ^ -1);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#-2147483648,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\trotl.l\ter0\n-;;\tdec.l\t#1,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == -2147483647 - 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))\"\n-  [(set (match_dup 0)\n-\t(rotate:SI (match_dup 0)\n-\t\t   (match_dup 5)))\n-   (set (match_dup 0)\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (const_int -1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (INTVAL (operands[1]) == -2147483647 - 1 ? 1 : 2);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tshar.l\ter1\n-;;\tbgt\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn immediately before this one.\n-\n-(define_peephole2\n-  [(match_scratch:SI 5 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"!peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-   && !same_cmp_preceding_p (insn)\"\n-  [(set (match_dup 5)\n-\t(match_dup 0))\n-   (parallel [(set (match_dup 5)\n-\t\t   (ashiftrt:SI (match_dup 5)\n-\t\t\t\t(match_dup 6)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 5)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[6] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tshar.l\ter1\n-;;\tbne\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn immediately before this one.\n-\n-(define_peephole2\n-  [(match_scratch:SI 5 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtuleu_operator\"\n-\t\t         [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"!peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-   && !same_cmp_preceding_p (insn)\"\n-  [(set (match_dup 5)\n-\t(match_dup 0))\n-   (parallel [(set (match_dup 5)\n-\t\t   (ashiftrt:SI (match_dup 5)\n-\t\t\t\t(match_dup 6)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 5)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 7)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[6] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.l\ter0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:SI (match_dup 0)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.l\ter0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:SI (match_dup 0)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 6)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#15,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tand\t#240,r0l\n-;;\tmov.l\ter0,er0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 3\n-       || INTVAL (operands[1]) == 7\n-       || INTVAL (operands[1]) == 15\n-       || INTVAL (operands[1]) == 31\n-       || INTVAL (operands[1]) == 63\n-       || INTVAL (operands[1]) == 127\n-       || INTVAL (operands[1]) == 255)\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_dup 5)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (~INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#15,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tand\t#240,r0l\n-;;\tmov.l\ter0,er0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n-\t|| INTVAL (operands[1]) == 7\n-\t|| INTVAL (operands[1]) == 15\n-\t|| INTVAL (operands[1]) == 31\n-\t|| INTVAL (operands[1]) == 63\n-\t|| INTVAL (operands[1]) == 127\n-\t|| INTVAL (operands[1]) == 255)\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_dup 5)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 6)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[5] = GEN_INT (~INTVAL (operands[1]));\n-    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65535,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\te0,e0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (const_int 65535)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (compare (and:SI (match_dup 0)\n-\t\t\t       (const_int -65536))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))])\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65535,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\te0,e0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (const_int 65535)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"\"\n-  [(set (cc0) (compare (and:SI (match_dup 0)\n-\t\t\t       (const_int -65536))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 4)\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tdec.l\t#1,er1\n-;;\tbeq\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn.\n-\n-(define_peephole2\n-  [(match_scratch:SI 5 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"INTVAL (operands[1]) != 0\n-   && !peep2_reg_dead_p (1, operands[0])\n-   && !same_cmp_following_p (insn)\"\n-  [(set (match_dup 5)\n-\t(match_dup 0))\n-   (set (match_dup 5)\n-\t(unspec:SI [(match_dup 5)\n-\t\t    (match_dup 6)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 5)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    operands[6] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Narrow the mode of testing if possible.\n-\n-(define_peephole2\n-  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n-\t(and:HSI (match_dup 0)\n-\t\t (match_operand:HSI 1 \"const_int_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 4 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 3 \"pc_or_label_operand\" \"\")))]\n-  \"((const_int_qi_operand (operands[1], QImode)\n-     || (GET_MODE (operands[0]) == SImode\n-\t && const_int_hi_operand (operands[1], HImode)))\n-    && peep2_reg_dead_p (2, operands[0]))\"\n-  [(set (match_dup 5) (match_dup 7))\n-   (set (cc0) (compare (match_dup 5)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 4 [(cc0) (const_int 0)])\n-\t\t      (match_dup 2)\n-\t\t      (match_dup 3)))]\n-  {\n-    enum machine_mode mode;\n-\n-    mode = const_int_qi_operand (operands[1], QImode) ? QImode : HImode;\n-    operands[5] = gen_rtx_REG (mode, REGNO (operands[0]));\n-    operands[6] = gen_int_mode (INTVAL (operands[1]), mode);\n-    operands[7] = gen_rtx_AND (mode, operands[5], operands[6]);\n-  })\n-\n ;; These triggers right at the end of allocation of locals in the\n ;; prologue (and possibly at other places).\n \n@@ -1367,46 +460,6 @@\n     XEXP (operands[4], 0) = operands[1];\n   })\n \n-;; Transform\n-;;\n-;;\tmov\tsrc1,reg\n-;;\tcmp\treg,src2\n-;;\n-;; into\n-;;\n-;;\tcmp\tsrc1,src2\n-;;\n-;; if \"reg\" dies in the comparison.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_dst_operand\" \"\"))\n-   (set (cc0)\n-\t(compare (match_dup 0)\n-\t\t (match_operand 2 \"h8300_src_operand\" \"\")))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\n-   && operands[2] != const0_rtx\"\n-  [(set (cc0)\n-\t(compare (match_dup 1)\n-\t\t (match_dup 2)))])\n-\n-;; Likewise for the second operand.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_src_operand\" \"\"))\n-   (set (cc0)\n-\t(compare (match_operand 2 \"h8300_dst_operand\" \"\")\n-\t\t (match_dup 0)))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n-  [(set (cc0)\n-\t(compare (match_dup 2)\n-\t\t (match_dup 1)))])\n-\n ;; Combine two moves.\n \n (define_peephole2"}, {"sha": "2e5ee4e4444f1542f38cf20551b103a2eea87b63", "filename": "gcc/config/i386/x86-tune-sched.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-sched.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -181,7 +181,6 @@ exact_dependency_1 (rtx addr, rtx insn)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case EXPR_LIST:\n       return false;\n     default:"}, {"sha": "3f63c60fa92260b44791e7dda39a503bc6209157", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1993,8 +1993,6 @@ m68k_output_btst (rtx countop, rtx dataop, rtx_code code, int signpos)\n \t     count == 0 followed by bcc/bcs are also possible, but need\n \t     m68k-specific CC_Z_IN_NOT_V and CC_Z_IN_NOT_C flags. */\n \t}\n-\n-      cc_status.flags = CC_NOT_NEGATIVE;\n     }\n   output_asm_insn (\"btst %0,%1\", ops);\n   return code;"}, {"sha": "4c34949a97f1d9d2e4ad48ddfc582396b27bdd25", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3854,7 +3854,6 @@ rl78_note_reg_uses (char *dead, rtx s, rtx insn)\n       /* These codes have no constituent expressions\n \t and are unique.  */\n     case SCRATCH:\n-    case CC0:\n     case PC:\n       return;\n "}, {"sha": "b6e66dcc228a0c0bbb85df31181c9ceb21535584", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -8809,7 +8809,6 @@ epilogue_renumber (rtx *where, int test)\n \t*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));\n       /* fallthrough */\n     case SCRATCH:\n-    case CC0:\n     case PC:\n     case CONST_INT:\n     case CONST_WIDE_INT:"}, {"sha": "f4f8f1975c55a5bd20bb86e8d5590c8921ad21a9", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -898,7 +898,7 @@ gen_conditional_move (enum rtx_code code, machine_mode mode,\n \t  code = GE;\n \t  op1 = const0_rtx;\n \t}\n-      cmp = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n+      cmp = gen_rtx_fmt_ee (code, VOIDmode, pc_rtx, const0_rtx);\n \n       if (boolean_operator (cmp, VOIDmode))\n \t{"}, {"sha": "aca319aafa5396766a7dd11d37e95460cabe8549", "filename": "gcc/cprop.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -963,10 +963,6 @@ cprop_jump (basic_block bb, rtx_insn *setcc, rtx_insn *jump, rtx from, rtx src)\n \tremove_note (jump, note);\n      }\n \n-  /* Delete the cc0 setter.  */\n-  if (HAVE_cc0 && setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n-    delete_insn (setcc);\n-\n   global_const_prop_count++;\n   if (dump_file != NULL)\n     {\n@@ -1009,15 +1005,15 @@ constprop_register (rtx from, rtx src, rtx_insn *insn)\n   rtx sset;\n   rtx_insn *next_insn;\n \n-  /* Check for reg or cc0 setting instructions followed by\n-     conditional branch instructions first.  */\n+  /* Check for reg setting instructions followed by conditional branch\n+     instructions first.  */\n   if ((sset = single_set (insn)) != NULL\n       && (next_insn = next_nondebug_insn (insn)) != NULL\n       && any_condjump_p (next_insn)\n       && onlyjump_p (next_insn))\n     {\n       rtx dest = SET_DEST (sset);\n-      if ((REG_P (dest) || CC0_P (dest))\n+      if (REG_P (dest)\n \t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, next_insn,\n \t\t\t from, src))\n \treturn 1;\n@@ -1636,8 +1632,7 @@ bypass_block (basic_block bb, rtx_insn *setcc, rtx_insn *jump)\n \t  /* Avoid unification of the edge with other edges from original\n \t     branch.  We would end up emitting the instruction on \"both\"\n \t     edges.  */\n-\t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc)))\n-\t      && find_edge (e->src, dest))\n+\t  if (dest && setcc && find_edge (e->src, dest))\n \t    dest = NULL;\n \n \t  old_dest = e->dest;\n@@ -1647,13 +1642,11 @@ bypass_block (basic_block bb, rtx_insn *setcc, rtx_insn *jump)\n             {\n \t      redirect_edge_and_branch_force (e, dest);\n \n-\t      /* Copy the register setter to the redirected edge.\n-\t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n+\t      /* Copy the register setter to the redirected edge.  */\n \t      if (setcc)\n \t\t{\n \t\t  rtx pat = PATTERN (setcc);\n-\t\t  if (!CC0_P (SET_DEST (pat)))\n-\t\t    insert_insn_on_edge (copy_insn (pat), e);\n+\t\t  insert_insn_on_edge (copy_insn (pat), e);\n \t\t}\n \n \t      if (dump_file != NULL)\n@@ -1719,7 +1712,7 @@ bypass_conditional_jumps (void)\n \t\t  break;\n \n \t\tdest = SET_DEST (PATTERN (insn));\n-\t\tif (REG_P (dest) || CC0_P (dest))\n+\t\tif (REG_P (dest))\n \t\t  setcc = insn;\n \t\telse\n \t\t  break;"}, {"sha": "4b7cbdce600e9d0e1d4768c17a99381c76e1cef1", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 125, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -255,18 +255,6 @@ struct qty_table_elem\n /* The table of all qtys, indexed by qty number.  */\n static struct qty_table_elem *qty_table;\n \n-/* For machines that have a CC0, we do not record its value in the hash\n-   table since its use is guaranteed to be the insn immediately following\n-   its definition and any other insn is presumed to invalidate it.\n-\n-   Instead, we store below the current and last value assigned to CC0.\n-   If it should happen to be a constant, it is stored in preference\n-   to the actual assigned value.  In case it is a constant, we store\n-   the mode in which the constant should be interpreted.  */\n-\n-static rtx this_insn_cc0, prev_insn_cc0;\n-static machine_mode this_insn_cc0_mode, prev_insn_cc0_mode;\n-\n /* Insn being scanned.  */\n \n static rtx_insn *this_insn;\n@@ -348,9 +336,8 @@ static bool cse_jumps_altered;\n    to put in the note.  */\n static bool recorded_label_ref;\n \n-/* canon_hash stores 1 in do_not_record\n-   if it notices a reference to CC0, PC, or some other volatile\n-   subexpression.  */\n+/* canon_hash stores 1 in do_not_record if it notices a reference to PC or\n+   some other volatile subexpression.  */\n \n static int do_not_record;\n \n@@ -592,7 +579,7 @@ static struct cse_reg_info * get_cse_reg_info (unsigned int regno);\n \n static void flush_hash_table (void);\n static bool insn_live_p (rtx_insn *, int *);\n-static bool set_live_p (rtx, rtx_insn *, int *);\n+static bool set_live_p (rtx, int *);\n static void cse_change_cc_mode_insn (rtx_insn *, rtx);\n static void cse_change_cc_mode_insns (rtx_insn *, rtx_insn *, rtx);\n static machine_mode cse_cc_succs (basic_block, basic_block, rtx, rtx,\n@@ -854,8 +841,6 @@ new_basic_block (void)\n \t  free_element_chain = first;\n \t}\n     }\n-\n-  prev_insn_cc0 = 0;\n }\n \n /* Say that register REG contains a quantity in mode MODE not in any\n@@ -2448,7 +2433,6 @@ hash_rtx_cb (const_rtx x, machine_mode mode,\n     case PRE_MODIFY:\n     case POST_MODIFY:\n     case PC:\n-    case CC0:\n     case CALL:\n     case UNSPEC_VOLATILE:\n       if (do_not_record_p) {\n@@ -2633,7 +2617,6 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n   switch (code)\n     {\n     case PC:\n-    case CC0:\n     CASE_CONST_UNIQUE:\n       return x == y;\n \n@@ -2853,7 +2836,6 @@ canon_reg (rtx x, rtx_insn *insn)\n   switch (code)\n     {\n     case PC:\n-    case CC0:\n     case CONST:\n     CASE_CONST_ANY:\n     case SYMBOL_REF:\n@@ -2909,9 +2891,9 @@ canon_reg (rtx x, rtx_insn *insn)\n    what values are being compared.\n \n    *PARG1 and *PARG2 are updated to contain the rtx representing the values\n-   actually being compared.  For example, if *PARG1 was (cc0) and *PARG2\n-   was (const_int 0), *PARG1 and *PARG2 will be set to the objects that were\n-   compared to produce cc0.\n+   actually being compared.  For example, if *PARG1 was (reg:CC CC_REG) and\n+   *PARG2 was (const_int 0), *PARG1 and *PARG2 will be set to the objects that\n+   were compared to produce (reg:CC CC_REG).\n \n    The return value is the comparison operator and is either the code of\n    A or the code corresponding to the inverse of the comparison.  */\n@@ -2943,10 +2925,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t  x = 0;\n \t}\n \n-      /* If arg1 is a COMPARE, extract the comparison arguments from it.\n-\t On machines with CC0, this is the only case that can occur, since\n-\t fold_rtx will return the COMPARE or item being compared with zero\n-\t when given CC0.  */\n+      /* If arg1 is a COMPARE, extract the comparison arguments from it.  */\n \n       if (GET_CODE (arg1) == COMPARE && arg2 == const0_rtx)\n \tx = arg1;\n@@ -3179,9 +3158,6 @@ fold_rtx (rtx x, rtx_insn *insn)\n     case EXPR_LIST:\n       return x;\n \n-    case CC0:\n-      return prev_insn_cc0;\n-\n     case ASM_OPERANDS:\n       if (insn)\n \t{\n@@ -3232,30 +3208,6 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t    const_arg = folded_arg;\n \t    break;\n \n-\t  case CC0:\n-\t    /* The cc0-user and cc0-setter may be in different blocks if\n-\t       the cc0-setter potentially traps.  In that case PREV_INSN_CC0\n-\t       will have been cleared as we exited the block with the\n-\t       setter.\n-\n-\t       While we could potentially track cc0 in this case, it just\n-\t       doesn't seem to be worth it given that cc0 targets are not\n-\t       terribly common or important these days and trapping math\n-\t       is rarely used.  The combination of those two conditions\n-\t       necessary to trip this situation is exceedingly rare in the\n-\t       real world.  */\n-\t    if (!prev_insn_cc0)\n-\t      {\n-\t\tconst_arg = NULL_RTX;\n-\t      }\n-\t    else\n-\t      {\n-\t\tfolded_arg = prev_insn_cc0;\n-\t\tmode_arg = prev_insn_cc0_mode;\n-\t\tconst_arg = equiv_constant (folded_arg);\n-\t      }\n-\t    break;\n-\n \t  default:\n \t    folded_arg = fold_rtx (folded_arg, insn);\n \t    const_arg = equiv_constant (folded_arg);\n@@ -3910,10 +3862,7 @@ record_jump_equiv (rtx_insn *insn, bool taken)\n   op0 = fold_rtx (XEXP (XEXP (SET_SRC (set), 0), 0), insn);\n   op1 = fold_rtx (XEXP (XEXP (SET_SRC (set), 0), 1), insn);\n \n-  /* On a cc0 target the cc0-setter and cc0-user may end up in different\n-     blocks.  When that happens the tracking of the cc0-setter via\n-     PREV_INSN_CC0 is spoiled.  That means that fold_rtx may return\n-     NULL_RTX.  In those cases, there's nothing to record.  */\n+  /* If fold_rtx returns NULL_RTX, there's nothing to record.  */\n   if (op0 == NULL_RTX || op1 == NULL_RTX)\n     return;\n \n@@ -4555,9 +4504,6 @@ cse_insn (rtx_insn *insn)\n     sets = XALLOCAVEC (struct set, XVECLEN (x, 0));\n \n   this_insn = insn;\n-  /* Records what this insn does to set CC0.  */\n-  this_insn_cc0 = 0;\n-  this_insn_cc0_mode = VOIDmode;\n \n   /* Find all regs explicitly clobbered in this insn,\n      to ensure they are not replaced with any other regs\n@@ -5658,21 +5604,6 @@ cse_insn (rtx_insn *insn)\n \t      sets[i].rtl = 0;\n \t    }\n \t}\n-\n-      /* If setting CC0, record what it was set to, or a constant, if it\n-\t is equivalent to a constant.  If it is being set to a floating-point\n-\t value, make a COMPARE with the appropriate constant of 0.  If we\n-\t don't do this, later code can interpret this as a test against\n-\t const0_rtx, which can cause problems if we try to put it into an\n-\t insn as a floating-point operand.  */\n-      if (dest == cc0_rtx)\n-\t{\n-\t  this_insn_cc0 = src_const && mode != VOIDmode ? src_const : src;\n-\t  this_insn_cc0_mode = mode;\n-\t  if (FLOAT_MODE_P (mode))\n-\t    this_insn_cc0 = gen_rtx_COMPARE (VOIDmode, this_insn_cc0,\n-\t\t\t\t\t     CONST0_RTX (mode));\n-\t}\n     }\n \n   /* Now enter all non-volatile source expressions in the hash table\n@@ -6594,34 +6525,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t      if (INSN_P (insn) && !recorded_label_ref\n \t\t  && check_for_label_ref (insn))\n \t\trecorded_label_ref = true;\n-\n-\t      if (HAVE_cc0 && NONDEBUG_INSN_P (insn))\n-\t\t{\n-\t\t  /* If the previous insn sets CC0 and this insn no\n-\t\t     longer references CC0, delete the previous insn.\n-\t\t     Here we use fact that nothing expects CC0 to be\n-\t\t     valid over an insn, which is true until the final\n-\t\t     pass.  */\n-\t\t  rtx_insn *prev_insn;\n-\t\t  rtx tem;\n-\n-\t\t  prev_insn = prev_nonnote_nondebug_insn (insn);\n-\t\t  if (prev_insn && NONJUMP_INSN_P (prev_insn)\n-\t\t      && (tem = single_set (prev_insn)) != NULL_RTX\n-\t\t      && SET_DEST (tem) == cc0_rtx\n-\t\t      && ! reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-\t\t    delete_insn (prev_insn);\n-\n-\t\t  /* If this insn is not the last insn in the basic\n-\t\t     block, it will be PREV_INSN(insn) in the next\n-\t\t     iteration.  If we recorded any CC0-related\n-\t\t     information for this insn, remember it.  */\n-\t\t  if (insn != BB_END (bb))\n-\t\t    {\n-\t\t      prev_insn_cc0 = this_insn_cc0;\n-\t\t      prev_insn_cc0_mode = this_insn_cc0_mode;\n-\t\t    }\n-\t\t}\n \t    }\n \t}\n \n@@ -6670,10 +6573,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t  bool taken = (next_bb == BRANCH_EDGE (bb)->dest);\n \t  record_jump_equiv (insn, taken);\n \t}\n-\n-      /* Clear the CC0-tracking related insns, they can't provide\n-\t useful information across basic block boundaries.  */\n-      prev_insn_cc0 = 0;\n     }\n \n   gcc_assert (next_qty <= max_qty);\n@@ -6816,7 +6715,6 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n       return;\n \n     case PC:\n-    case CC0:\n     case CONST:\n     CASE_CONST_ANY:\n     case SYMBOL_REF:\n@@ -6925,23 +6823,15 @@ is_dead_reg (const_rtx x, int *counts)\n \n /* Return true if set is live.  */\n static bool\n-set_live_p (rtx set, rtx_insn *insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n-\t    int *counts)\n+set_live_p (rtx set, int *counts)\n {\n-  rtx_insn *tem;\n-\n   if (set_noop_p (set))\n-    ;\n-\n-  else if (GET_CODE (SET_DEST (set)) == CC0\n-\t   && !side_effects_p (SET_SRC (set))\n-\t   && ((tem = next_nonnote_nondebug_insn (insn)) == NULL_RTX\n-\t       || !INSN_P (tem)\n-\t       || !reg_referenced_p (cc0_rtx, PATTERN (tem))))\n     return false;\n-  else if (!is_dead_reg (SET_DEST (set), counts)\n-\t   || side_effects_p (SET_SRC (set)))\n+\n+  if (!is_dead_reg (SET_DEST (set), counts)\n+      || side_effects_p (SET_SRC (set)))\n     return true;\n+\n   return false;\n }\n \n@@ -6954,7 +6844,7 @@ insn_live_p (rtx_insn *insn, int *counts)\n   if (!cfun->can_delete_dead_exceptions && !insn_nothrow_p (insn))\n     return true;\n   else if (GET_CODE (PATTERN (insn)) == SET)\n-    return set_live_p (PATTERN (insn), insn, counts);\n+    return set_live_p (PATTERN (insn), counts);\n   else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n     {\n       for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n@@ -6963,7 +6853,7 @@ insn_live_p (rtx_insn *insn, int *counts)\n \n \t  if (GET_CODE (elt) == SET)\n \t    {\n-\t      if (set_live_p (elt, insn, counts))\n+\t      if (set_live_p (elt, counts))\n \t\treturn true;\n \t    }\n \t  else if (GET_CODE (elt) != CLOBBER && GET_CODE (elt) != USE)"}, {"sha": "f5c8cbb6eb1b2347df0af548f9d41144b693f4d9", "filename": "gcc/cselib.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1387,7 +1387,6 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n       return cselib_hash_rtx (XEXP (x, 0), create, memmode);\n \n     case PC:\n-    case CC0:\n     case CALL:\n     case UNSPEC_VOLATILE:\n       return 0;\n@@ -1827,7 +1826,6 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;"}, {"sha": "d7a4914a3afc87d8c88e35e06de1e5f584185b14", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -4255,8 +4255,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n \t  if (bitmap_intersect_p (merge_set, test_use)\n \t      || bitmap_intersect_p (merge_use, test_set))\n \t    break;\n-\t  if (!HAVE_cc0 || !sets_cc0_p (insn))\n-\t    max_to = insn;\n+\t  max_to = insn;\n \t}\n       next = NEXT_INSN (insn);\n       if (insn == to)\n@@ -4293,8 +4292,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n     {\n       if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  if (!bitmap_intersect_p (test_set, local_merge_live)\n-\t      && (!HAVE_cc0 || !sets_cc0_p (insn)))\n+\t  if (!bitmap_intersect_p (test_set, local_merge_live))\n \t    {\n \t      max_to = insn;\n \t      break;"}, {"sha": "6691c3e83575c2b9638c9877e91765da69a6f5da", "filename": "gcc/df-scan.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2816,7 +2816,6 @@ df_uses_record (class df_collection_rec *collection_rec,\n     case CONST:\n     CASE_CONST_ANY:\n     case PC:\n-    case CC0:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n       return;\n@@ -2902,7 +2901,6 @@ df_uses_record (class df_collection_rec *collection_rec,\n \t    case PARALLEL:\n \t    case SCRATCH:\n \t    case PC:\n-\t    case CC0:\n \t\tbreak;\n \t    case MEM:\n \t      df_uses_record (collection_rec, &XEXP (dst, 0),"}, {"sha": "0e65b3ae6633d0580beaefc70dc7361c5b37dabb", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -7071,7 +7071,7 @@ such as\n   [(set (pc)\n         (if_then_else (match_operator\n                          0 \"comparison_operator\"\n-                         [(cc0) (const_int 0)])\n+                         [(reg:CC CC_REG) (const_int 0)])\n                       (return)\n                       (pc)))]\n   \"@var{condition}\"\n@@ -7989,15 +7989,8 @@ works better when different sets of comparison operators are supported\n by different kinds of conditional branches (e.g.@: integer vs.@:\n floating-point), or by conditional branches with respect to conditional stores.\n \n-Two separate insns are always used if the machine description represents\n-a condition code register using the legacy RTL expression @code{(cc0)},\n-and on most machines that use a separate condition code register\n-(@pxref{Condition Code}).  For machines that use @code{(cc0)}, in\n-fact, the set and use of the condition code must be separate and\n-adjacent@footnote{@code{note} insns can separate them, though.}, thus\n-allowing flags in @code{cc_status} to be used (@pxref{Condition Code}) and\n-so that the comparison and branch insns could be located from each other\n-by using the functions @code{prev_cc0_setter} and @code{next_cc0_user}.\n+Two separate insns are always used on most machines that use a separate\n+condition code register (@pxref{Condition Code}).\n \n Even in this case having a single entry point for conditional branches\n is advantageous, because it handles equally well the case where a single\n@@ -8191,7 +8184,7 @@ the operations as far as possible.  For instance,\n @cindex @code{compare}, canonicalization of\n @item\n For the @code{compare} operator, a constant is always the second operand\n-if the first argument is a condition code register or @code{(cc0)}.\n+if the first argument is a condition code register.\n \n @item\n For instructions that inherently set a condition code register, the\n@@ -9330,8 +9323,7 @@ In addition to describing the instruction supported by the target machine,\n the @file{md} file also defines a group of @dfn{attributes} and a set of\n values for each.  Every generated insn is assigned a value for each attribute.\n One possible attribute would be the effect that the insn has on the machine's\n-condition code.  This attribute can then be used by @code{NOTICE_UPDATE_CC}\n-to track the condition codes.\n+condition code.\n \n @menu\n * Defining Attributes:: Specifying attributes and their values."}, {"sha": "5af71137a878b33a0331f9dcb74189215e26dbdf", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 21, "deletions": 131, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1271,8 +1271,7 @@ accumulator.  The default format is ``64.64''.\n ``Condition Code'' mode represents the value of a condition code, which\n is a machine-specific set of bits used to represent the result of a\n comparison operation.  Other machine-specific modes may also be used for\n-the condition code.  These modes are not used on machines that use\n-@code{cc0} (@pxref{Condition Code}).\n+the condition code.  (@pxref{Condition Code}).\n \n @findex BLKmode\n @item BLKmode\n@@ -2324,60 +2323,17 @@ the reload pass.\n @code{scratch} is usually present inside a @code{clobber} operation\n (@pxref{Side Effects}).\n \n-@findex cc0\n-@cindex condition code register\n-@item (cc0)\n-This refers to the machine's condition code register.  It has no\n-operands and may not have a machine mode.  There are two ways to use it:\n-\n-@itemize @bullet\n-@item\n-To stand for a complete set of condition code flags.  This is best on\n-most machines, where each comparison sets the entire series of flags.\n-\n-With this technique, @code{(cc0)} may be validly used in only two\n-contexts: as the destination of an assignment (in test and compare\n-instructions) and in comparison operators comparing against zero\n-(@code{const_int} with value zero; that is to say, @code{const0_rtx}).\n-\n-@item\n-To stand for a single flag that is the result of a single condition.\n-This is useful on machines that have only a single flag bit, and in\n-which comparison instructions must specify the condition to test.\n-\n-With this technique, @code{(cc0)} may be validly used in only two\n-contexts: as the destination of an assignment (in test and compare\n-instructions) where the source is a comparison operator, and as the\n-first operand of @code{if_then_else} (in a conditional branch).\n-@end itemize\n-\n-@findex cc0_rtx\n-There is only one expression object of code @code{cc0}; it is the\n-value of the variable @code{cc0_rtx}.  Any attempt to create an\n-expression of code @code{cc0} will return @code{cc0_rtx}.\n-\n-Instructions can set the condition code implicitly.  On many machines,\n-nearly all instructions set the condition code based on the value that\n-they compute or store.  It is not necessary to record these actions\n-explicitly in the RTL because the machine description includes a\n-prescription for recognizing the instructions that do so (by means of\n-the macro @code{NOTICE_UPDATE_CC}).  @xref{Condition Code}.  Only\n-instructions whose sole purpose is to set the condition code, and\n-instructions that use the condition code, need mention @code{(cc0)}.\n-\n On some machines, the condition code register is given a register number\n-and a @code{reg} is used instead of @code{(cc0)}.  This is usually the\n-preferable approach if only a small subset of instructions modify the\n-condition code.  Other machines store condition codes in general\n+and a @code{reg} is used.\n+Other machines store condition codes in general\n registers; in such cases a pseudo register should be used.\n \n Some machines, such as the SPARC and RS/6000, have two sets of\n arithmetic instructions, one that sets and one that does not set the\n condition code.  This is best handled by normally generating the\n instruction that does not set the condition code, and making a pattern\n-that both performs the arithmetic and sets the condition code register\n-(which would not be @code{(cc0)} in this case).  For examples, search\n-for @samp{addcc} and @samp{andcc} in @file{sparc.md}.\n+that both performs the arithmetic and sets the condition code register.\n+For examples, search for @samp{addcc} and @samp{andcc} in @file{sparc.md}.\n \n @findex pc\n @item (pc)\n@@ -2495,14 +2451,13 @@ Of course, machines cannot really subtract with infinite precision.\n However, they can pretend to do so when only the sign of the result will\n be used, which is the case when the result is stored in the condition\n code.  And that is the @emph{only} way this kind of expression may\n-validly be used: as a value to be stored in the condition codes, either\n-@code{(cc0)} or a register.  @xref{Comparisons}.\n+validly be used: as a value to be stored in the condition codes, in a\n+register.  @xref{Comparisons}.\n \n The mode @var{m} is not related to the modes of @var{x} and @var{y}, but\n-instead is the mode of the condition code value.  If @code{(cc0)} is\n-used, it is @code{VOIDmode}.  Otherwise it is some mode in class\n+instead is the mode of the condition code value.  It is some mode in class\n @code{MODE_CC}, often @code{CCmode}.  @xref{Condition Code}.  If @var{m}\n-is @code{VOIDmode} or @code{CCmode}, the operation returns sufficient\n+is @code{CCmode}, the operation returns sufficient\n information (in an unspecified format) so that any comparison operator\n can be applied to the result of the @code{COMPARE} operation.  For other\n modes in class @code{MODE_CC}, the operation only returns a subset of\n@@ -2797,26 +2752,17 @@ of the data being compared.  If the comparison operation is being tested\n @code{VOIDmode}.\n \n @cindex condition codes\n-There are two ways that comparison operations may be used.  The\n-comparison operators may be used to compare the condition codes\n-@code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such\n-a construct actually refers to the result of the preceding instruction\n-in which the condition codes were set.  The instruction setting the\n-condition code must be adjacent to the instruction using the condition\n-code; only @code{note} insns may separate them.\n-\n-Alternatively, a comparison operation may directly compare two data\n+A comparison operation compares two data\n objects.  The mode of the comparison is determined by the operands; they\n must both be valid for a common machine mode.  A comparison with both\n operands constant would be invalid as the machine mode could not be\n deduced from it, but such a comparison should never exist in RTL due to\n constant folding.\n \n-In the example above, if @code{(cc0)} were last set to\n-@code{(compare @var{x} @var{y})}, the comparison operation is\n-identical to @code{(eq @var{x} @var{y})}.  Usually only one style\n+Usually only one style\n of comparisons is supported on a particular machine, but the combine\n-pass will try to merge the operations to produce the @code{eq} shown\n+pass will try to merge operations to produce code like\n+@code{(eq @var{x} @var{y})},\n in case it exists in the context of the particular insn involved.\n \n Inequality comparisons come in two flavors, signed and unsigned.  Thus,\n@@ -3168,7 +3114,7 @@ Represents the action of storing the value of @var{x} into the place\n represented by @var{lval}.  @var{lval} must be an expression\n representing a place that can be stored in: @code{reg} (or @code{subreg},\n @code{strict_low_part} or @code{zero_extract}), @code{mem}, @code{pc},\n-@code{parallel}, or @code{cc0}.\n+or @code{parallel}.\n \n If @var{lval} is a @code{reg}, @code{subreg} or @code{mem}, it has a\n machine mode; then @var{x} must be valid for that mode.\n@@ -3191,13 +3137,6 @@ the bit-field (a memory or register reference) specified by the\n bit-field is not changed.  Note that @code{sign_extract} cannot\n appear in @var{lval}.\n \n-If @var{lval} is @code{(cc0)}, it has no machine mode, and @var{x} may\n-be either a @code{compare} expression or a value that may have any mode.\n-The latter case represents a ``test'' instruction.  The expression\n-@code{(set (cc0) (reg:@var{m} @var{n}))} is equivalent to\n-@code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))}.\n-Use the former expression to save space during the compilation.\n-\n If @var{lval} is a @code{parallel}, it is used to represent the case of\n a function returning a structure in multiple registers.  Each element\n of the @code{parallel} is an @code{expr_list} whose first operand is a\n@@ -3219,7 +3158,7 @@ does not jump) and the other of the two must be a @code{label_ref}\n @code{mem}; these unusual patterns are used to represent jumps through\n branch tables.\n \n-If @var{lval} is neither @code{(cc0)} nor @code{(pc)}, the mode of\n+If @var{lval} is not @code{(pc)}, the mode of\n @var{lval} must not be @code{VOIDmode} and the mode of @var{x} must be\n valid for the mode of @var{lval}.\n \n@@ -3402,9 +3341,9 @@ For example, people sometimes attempt to represent a jump-if-zero\n instruction this way:\n \n @smallexample\n-(parallel [(set (cc0) (reg:SI 34))\n+(parallel [(set (reg:CC CC_REG) (reg:SI 34))\n            (set (pc) (if_then_else\n-                        (eq (cc0) (const_int 0))\n+                        (eq (reg:CC CC_REG) (const_int 0))\n                         (label_ref @dots{})\n                         (pc)))])\n @end smallexample\n@@ -3421,8 +3360,6 @@ whose elements are the operands needed to output the resulting\n assembler code---often @code{reg}, @code{mem} or constant expressions.\n This would not be well-formed RTL at any other stage in compilation,\n but it is OK then because no further optimization remains to be done.\n-However, the definition of the macro @code{NOTICE_UPDATE_CC}, if\n-any, must deal with such insns if you define any peephole optimizations.\n \n @findex cond_exec\n @item (cond_exec [@var{cond} @var{expr}])\n@@ -4101,38 +4038,16 @@ In the debugging output, this field is printed as a number followed by\n a symbolic representation that locates the pattern in the @file{md}\n file as some small positive or negative offset from a named pattern.\n \n-@findex LOG_LINKS\n-@item LOG_LINKS (@var{i})\n-A list (chain of @code{insn_list} expressions) giving information about\n-dependencies between instructions within a basic block.  Neither a jump\n-nor a label may come between the related insns.  These are only used by\n-the schedulers and by combine.  This is a deprecated data structure.\n-Def-use and use-def chains are now preferred.\n-\n @findex REG_NOTES\n @item REG_NOTES (@var{i})\n A list (chain of @code{expr_list}, @code{insn_list} and @code{int_list}\n expressions) giving miscellaneous information about the insn.  It is often\n information pertaining to the registers used in this insn.\n @end table\n \n-The @code{LOG_LINKS} field of an insn is a chain of @code{insn_list}\n-expressions.  Each of these has two operands: the first is an insn,\n-and the second is another @code{insn_list} expression (the next one in\n-the chain).  The last @code{insn_list} in the chain has a null pointer\n-as second operand.  The significant thing about the chain is which\n-insns appear in it (as first operands of @code{insn_list}\n-expressions).  Their order is not significant.\n-\n-This list is originally set up by the flow analysis pass; it is a null\n-pointer until then.  Flow only adds links for those data dependencies\n-which can be used for instruction combination.  For each insn, the flow\n-analysis pass adds a link to insns which store into registers values\n-that are used for the first time in this insn.\n-\n-The @code{REG_NOTES} field of an insn is a chain similar to the\n-@code{LOG_LINKS} field but it includes @code{expr_list} and @code{int_list}\n-expressions in addition to @code{insn_list} expressions.  There are several\n+The @code{REG_NOTES} field of an insn is a chain that includes\n+@code{expr_list} and @code{int_list} expressions as well as @code{insn_list}\n+expressions.  There are several\n kinds of register notes, which are distinguished by the machine mode, which\n in a register note is really understood as being an @code{enum reg_note}.\n The first operand @var{op} of the note is data whose meaning depends on\n@@ -4147,8 +4062,7 @@ register note.  Its counterpart, the macro @code{PUT_REG_NOTE_KIND\n \n Register notes are of three classes: They may say something about an\n input to an insn, they may say something about an output of an insn, or\n-they may create a linkage between two insns.  There are also a set\n-of values that are only used in @code{LOG_LINKS}.\n+they may create a linkage between two insns.\n \n These register notes annotate inputs to an insn:\n \n@@ -4289,26 +4203,6 @@ These notes describe linkages between insns.  They occur in pairs: one\n insn has one of a pair of notes that points to a second insn, which has\n the inverse note pointing back to the first insn.\n \n-@table @code\n-@findex REG_CC_SETTER\n-@findex REG_CC_USER\n-@item REG_CC_SETTER\n-@itemx REG_CC_USER\n-On machines that use @code{cc0}, the insns which set and use @code{cc0}\n-set and use @code{cc0} are adjacent.  However, when branch delay slot\n-filling is done, this may no longer be true.  In this case a\n-@code{REG_CC_USER} note will be placed on the insn setting @code{cc0} to\n-point to the insn using @code{cc0} and a @code{REG_CC_SETTER} note will\n-be placed on the insn using @code{cc0} to point to the insn setting\n-@code{cc0}.\n-@end table\n-\n-These values are only used in the @code{LOG_LINKS} field, and indicate\n-the type of dependency that each link represents.  Links which indicate\n-a data dependence (a read after write dependence) do not use any code,\n-they simply have mode @code{VOIDmode}, and are printed without any\n-descriptive text.\n-\n @table @code\n @findex REG_DEP_TRUE\n @item REG_DEP_TRUE\n@@ -5272,10 +5166,6 @@ are shared.\n @item\n There is only one @code{pc} expression.\n \n-@cindex @code{cc0}, RTL sharing\n-@item\n-There is only one @code{cc0} expression.\n-\n @cindex @code{const_double}, RTL sharing\n @item\n There is only one @code{const_double} expression with value 0 for"}, {"sha": "5f2730971691dbbdc2cb5b74976733712b2ac6a4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 83, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -6310,21 +6310,16 @@ or target-specific sections.\n @section Condition Code Status\n @cindex condition code status\n \n-The macros in this section can be split in two families, according to the\n-two ways of representing condition codes in GCC.\n-\n-The first representation is the so called @code{(cc0)} representation\n-(@pxref{Jump Patterns}), where all instructions can have an implicit\n-clobber of the condition codes.  The second is the condition code\n-register representation, which provides better schedulability for\n+Condition codes in GCC are represented as registers,\n+which provides better schedulability for\n architectures that do have a condition code register, but on which\n most instructions do not affect it.  The latter category includes\n most RISC machines.\n \n-The implicit clobbering poses a strong restriction on the placement of\n+Implicit clobbering would pose a strong restriction on the placement of\n the definition and use of the condition code.  In the past the definition\n and use were always adjacent.  However, recent changes to support trapping\n-arithmatic may result in the definition and user being in different blocks.\n+arithmetic may result in the definition and user being in different blocks.\n Thus, there may be a @code{NOTE_INSN_BASIC_BLOCK} between them.  Additionally,\n the definition may be the source of exception handling edges.\n \n@@ -6335,8 +6330,7 @@ three instructions earlier than the conditional branch.  The instruction\n scheduler cannot perform this optimization if it is not permitted to\n separate the definition and use of the condition code register.\n \n-For this reason, it is possible and suggested to use a register to\n-represent the condition code for new ports.  If there is a specific\n+If there is a specific\n condition code register in the machine, use a hard register.  If the\n condition code or comparison result can be placed in any general register,\n or if there are multiple condition registers, use a pseudo register.\n@@ -6348,78 +6342,9 @@ specified already in the compare instruction.  In this case, you are not\n interested in most macros in this section.\n \n @menu\n-* CC0 Condition Codes::      Old style representation of condition codes.\n * MODE_CC Condition Codes::  Modern representation of condition codes.\n @end menu\n \n-@node CC0 Condition Codes\n-@subsection Representation of condition codes using @code{(cc0)}\n-@findex cc0\n-\n-@findex cc_status\n-The file @file{conditions.h} defines a variable @code{cc_status} to\n-describe how the condition code was computed (in case the interpretation of\n-the condition code depends on the instruction that it was set by).  This\n-variable contains the RTL expressions on which the condition code is\n-currently based, and several standard flags.\n-\n-Sometimes additional machine-specific flags must be defined in the machine\n-description header file.  It can also add additional machine-specific\n-information by defining @code{CC_STATUS_MDEP}.\n-\n-@defmac CC_STATUS_MDEP\n-C code for a data type which is used for declaring the @code{mdep}\n-component of @code{cc_status}.  It defaults to @code{int}.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-@end defmac\n-\n-@defmac CC_STATUS_MDEP_INIT\n-A C expression to initialize the @code{mdep} field to ``empty''.\n-The default definition does nothing, since most machines don't use\n-the field anyway.  If you want to use the field, you should probably\n-define this macro to initialize it.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-@end defmac\n-\n-@defmac NOTICE_UPDATE_CC (@var{exp}, @var{insn})\n-A C compound statement to set the components of @code{cc_status}\n-appropriately for an insn @var{insn} whose body is @var{exp}.  It is\n-this macro's responsibility to recognize insns that set the condition\n-code as a byproduct of other activity as well as those that explicitly\n-set @code{(cc0)}.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-\n-If there are insns that do not set the condition code but do alter\n-other machine registers, this macro must check to see whether they\n-invalidate the expressions that the condition code is recorded as\n-reflecting.  For example, on the 68000, insns that store in address\n-registers do not set the condition code, which means that usually\n-@code{NOTICE_UPDATE_CC} can leave @code{cc_status} unaltered for such\n-insns.  But suppose that the previous insn set the condition code\n-based on location @samp{a4@@(102)} and the current insn stores a new\n-value in @samp{a4}.  Although the condition code is not changed by\n-this, it will no longer be true that it reflects the contents of\n-@samp{a4@@(102)}.  Therefore, @code{NOTICE_UPDATE_CC} must alter\n-@code{cc_status} in this case to say that nothing is known about the\n-condition code value.\n-\n-The definition of @code{NOTICE_UPDATE_CC} must be prepared to deal\n-with the results of peephole optimization: insns whose patterns are\n-@code{parallel} RTXs containing various @code{reg}, @code{mem} or\n-constants which are just the operands.  The RTL structure of these\n-insns is not sufficient to indicate what the insns actually do.  What\n-@code{NOTICE_UPDATE_CC} should do when it sees one is just to run\n-@code{CC_STATUS_INIT}.\n-\n-A possible definition of @code{NOTICE_UPDATE_CC} is to call a function\n-that looks at an attribute (@pxref{Insn Attributes}) named, for example,\n-@samp{cc}.  This avoids having detailed information about patterns in\n-two places, the @file{md} file and in @code{NOTICE_UPDATE_CC}.\n-@end defmac\n-\n @node MODE_CC Condition Codes\n @subsection Representation of condition codes using registers\n @findex CCmode\n@@ -6534,7 +6459,7 @@ like:\n @end defmac\n \n @deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *@var{p1}, unsigned int *@var{p2})\n-On targets which do not use @code{(cc0)}, and which use a hard\n+On targets which use a hard\n register rather than a pseudo-register to hold condition codes, the\n regular CSE passes are often not able to identify cases in which the\n hard register is set to a common value.  Use this hook to enable a\n@@ -11578,8 +11503,7 @@ for cross-profiling.\n \n A C expression for the maximum number of instructions to execute via\n conditional execution instructions instead of a branch.  A value of\n-@code{BRANCH_COST}+1 is the default if the machine does not use cc0, and\n-1 if it does use cc0.\n+@code{BRANCH_COST}+1 is the default.\n @end defmac\n \n @defmac IFCVT_MODIFY_TESTS (@var{ce_info}, @var{true_expr}, @var{false_expr})"}, {"sha": "d8e3de14af1a9cd1ee5d42133ffa59b16894ffd6", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -4268,21 +4268,16 @@ or @code{TARGET_MAX_ANCHOR_OFFSET} is set to a nonzero value.\n @section Condition Code Status\n @cindex condition code status\n \n-The macros in this section can be split in two families, according to the\n-two ways of representing condition codes in GCC.\n-\n-The first representation is the so called @code{(cc0)} representation\n-(@pxref{Jump Patterns}), where all instructions can have an implicit\n-clobber of the condition codes.  The second is the condition code\n-register representation, which provides better schedulability for\n+Condition codes in GCC are represented as registers,\n+which provides better schedulability for\n architectures that do have a condition code register, but on which\n most instructions do not affect it.  The latter category includes\n most RISC machines.\n \n-The implicit clobbering poses a strong restriction on the placement of\n+Implicit clobbering would pose a strong restriction on the placement of\n the definition and use of the condition code.  In the past the definition\n and use were always adjacent.  However, recent changes to support trapping\n-arithmatic may result in the definition and user being in different blocks.\n+arithmetic may result in the definition and user being in different blocks.\n Thus, there may be a @code{NOTE_INSN_BASIC_BLOCK} between them.  Additionally,\n the definition may be the source of exception handling edges.\n \n@@ -4293,8 +4288,7 @@ three instructions earlier than the conditional branch.  The instruction\n scheduler cannot perform this optimization if it is not permitted to\n separate the definition and use of the condition code register.\n \n-For this reason, it is possible and suggested to use a register to\n-represent the condition code for new ports.  If there is a specific\n+If there is a specific\n condition code register in the machine, use a hard register.  If the\n condition code or comparison result can be placed in any general register,\n or if there are multiple condition registers, use a pseudo register.\n@@ -4306,78 +4300,9 @@ specified already in the compare instruction.  In this case, you are not\n interested in most macros in this section.\n \n @menu\n-* CC0 Condition Codes::      Old style representation of condition codes.\n * MODE_CC Condition Codes::  Modern representation of condition codes.\n @end menu\n \n-@node CC0 Condition Codes\n-@subsection Representation of condition codes using @code{(cc0)}\n-@findex cc0\n-\n-@findex cc_status\n-The file @file{conditions.h} defines a variable @code{cc_status} to\n-describe how the condition code was computed (in case the interpretation of\n-the condition code depends on the instruction that it was set by).  This\n-variable contains the RTL expressions on which the condition code is\n-currently based, and several standard flags.\n-\n-Sometimes additional machine-specific flags must be defined in the machine\n-description header file.  It can also add additional machine-specific\n-information by defining @code{CC_STATUS_MDEP}.\n-\n-@defmac CC_STATUS_MDEP\n-C code for a data type which is used for declaring the @code{mdep}\n-component of @code{cc_status}.  It defaults to @code{int}.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-@end defmac\n-\n-@defmac CC_STATUS_MDEP_INIT\n-A C expression to initialize the @code{mdep} field to ``empty''.\n-The default definition does nothing, since most machines don't use\n-the field anyway.  If you want to use the field, you should probably\n-define this macro to initialize it.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-@end defmac\n-\n-@defmac NOTICE_UPDATE_CC (@var{exp}, @var{insn})\n-A C compound statement to set the components of @code{cc_status}\n-appropriately for an insn @var{insn} whose body is @var{exp}.  It is\n-this macro's responsibility to recognize insns that set the condition\n-code as a byproduct of other activity as well as those that explicitly\n-set @code{(cc0)}.\n-\n-This macro is not used on machines that do not use @code{cc0}.\n-\n-If there are insns that do not set the condition code but do alter\n-other machine registers, this macro must check to see whether they\n-invalidate the expressions that the condition code is recorded as\n-reflecting.  For example, on the 68000, insns that store in address\n-registers do not set the condition code, which means that usually\n-@code{NOTICE_UPDATE_CC} can leave @code{cc_status} unaltered for such\n-insns.  But suppose that the previous insn set the condition code\n-based on location @samp{a4@@(102)} and the current insn stores a new\n-value in @samp{a4}.  Although the condition code is not changed by\n-this, it will no longer be true that it reflects the contents of\n-@samp{a4@@(102)}.  Therefore, @code{NOTICE_UPDATE_CC} must alter\n-@code{cc_status} in this case to say that nothing is known about the\n-condition code value.\n-\n-The definition of @code{NOTICE_UPDATE_CC} must be prepared to deal\n-with the results of peephole optimization: insns whose patterns are\n-@code{parallel} RTXs containing various @code{reg}, @code{mem} or\n-constants which are just the operands.  The RTL structure of these\n-insns is not sufficient to indicate what the insns actually do.  What\n-@code{NOTICE_UPDATE_CC} should do when it sees one is just to run\n-@code{CC_STATUS_INIT}.\n-\n-A possible definition of @code{NOTICE_UPDATE_CC} is to call a function\n-that looks at an attribute (@pxref{Insn Attributes}) named, for example,\n-@samp{cc}.  This avoids having detailed information about patterns in\n-two places, the @file{md} file and in @code{NOTICE_UPDATE_CC}.\n-@end defmac\n-\n @node MODE_CC Condition Codes\n @subsection Representation of condition codes using registers\n @findex CCmode\n@@ -7909,8 +7834,7 @@ for cross-profiling.\n \n A C expression for the maximum number of instructions to execute via\n conditional execution instructions instead of a branch.  A value of\n-@code{BRANCH_COST}+1 is the default if the machine does not use cc0, and\n-1 if it does use cc0.\n+@code{BRANCH_COST}+1 is the default.\n @end defmac\n \n @defmac IFCVT_MODIFY_TESTS (@var{ce_info}, @var{true_expr}, @var{false_expr})"}, {"sha": "ff3b4449b3758f6d2c6841c4dbba9903b97ac195", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -123,7 +123,6 @@ rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n rtx pc_rtx;\n rtx ret_rtx;\n rtx simple_return_rtx;\n-rtx cc0_rtx;\n \n /* Marker used for denoting an INSN, which should never be accessed (i.e.,\n    this pointer should normally never be dereferenced), but is required to be\n@@ -2847,14 +2846,13 @@ verify_rtx_sharing (rtx orig, rtx insn)\n     case LABEL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return;\n     case CLOBBER:\n-      /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n+      /* Share clobbers of hard registers, but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n       if (REG_P (XEXP (x, 0))\n@@ -3100,14 +3098,13 @@ copy_rtx_if_shared_1 (rtx *orig1)\n     case LABEL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return;\n     case CLOBBER:\n-      /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n+      /* Share clobbers of hard registers, but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n       if (REG_P (XEXP (x, 0))\n@@ -3223,7 +3220,6 @@ mark_used_flags (rtx x, int flag)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n       return;\n@@ -3717,50 +3713,6 @@ prev_active_insn (rtx_insn *insn)\n   return insn;\n }\n \f\n-/* Return the next insn that uses CC0 after INSN, which is assumed to\n-   set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter\n-   applied to the result of this function should yield INSN).\n-\n-   Normally, this is simply the next insn.  However, if a REG_CC_USER note\n-   is present, it contains the insn that uses CC0.\n-\n-   Return 0 if we can't find the insn.  */\n-\n-rtx_insn *\n-next_cc0_user (rtx_insn *insn)\n-{\n-  rtx note = find_reg_note (insn, REG_CC_USER, NULL_RTX);\n-\n-  if (note)\n-    return safe_as_a <rtx_insn *> (XEXP (note, 0));\n-\n-  insn = next_nonnote_insn (insn);\n-  if (insn && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-    insn = as_a <rtx_sequence *> (PATTERN (insn))->insn (0);\n-\n-  if (insn && INSN_P (insn) && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-    return insn;\n-\n-  return 0;\n-}\n-\n-/* Find the insn that set CC0 for INSN.  Unless INSN has a REG_CC_SETTER\n-   note, it is the previous insn.  */\n-\n-rtx_insn *\n-prev_cc0_setter (rtx_insn *insn)\n-{\n-  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n-\n-  if (note)\n-    return safe_as_a <rtx_insn *> (XEXP (note, 0));\n-\n-  insn = prev_nonnote_insn (insn);\n-  gcc_assert (sets_cc0_p (PATTERN (insn)));\n-\n-  return insn;\n-}\n-\n /* Find a RTX_AUTOINC class rtx which matches DATA.  */\n \n static int\n@@ -5687,12 +5639,11 @@ copy_insn_1 (rtx orig)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n       return orig;\n     case CLOBBER:\n-      /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n+      /* Share clobbers of hard registers, but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n       if (REG_P (XEXP (orig, 0))\n@@ -6413,7 +6364,6 @@ init_emit_once (void)\n   pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);\n   ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);\n   simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);\n-  cc0_rtx = gen_rtx_fmt_ (CC0, VOIDmode);\n   invalid_insn_rtx = gen_rtx_INSN (VOIDmode,\n \t\t\t\t   /*prev_insn=*/NULL,\n \t\t\t\t   /*next_insn=*/NULL,"}, {"sha": "ba4285ddf14dc922cabe10fc82e4778d3fe32dce", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 398, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -93,7 +93,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbxout.h\"\n #endif\n \n-/* Most ports that aren't using cc0 don't need to define CC_STATUS_INIT.\n+/* Most ports don't need to define CC_STATUS_INIT.\n    So define a null default for it to save conditionalization later.  */\n #ifndef CC_STATUS_INIT\n #define CC_STATUS_INIT\n@@ -175,17 +175,6 @@ static rtx last_ignored_compare = 0;\n \n static int insn_counter = 0;\n \n-/* This variable contains machine-dependent flags (defined in tm.h)\n-   set and examined by output routines\n-   that describe how to interpret the condition codes properly.  */\n-\n-CC_STATUS cc_status;\n-\n-/* During output of an insn, this contains a copy of cc_status\n-   from before the insn.  */\n-\n-CC_STATUS cc_prev_status;\n-\n /* Number of unmatched NOTE_INSN_BLOCK_BEG notes we have seen.  */\n \n static int block_depth;\n@@ -226,9 +215,6 @@ static void output_asm_operand_names (rtx *, int *, int);\n #ifdef LEAF_REGISTERS\n static void leaf_renumber_regs (rtx_insn *);\n #endif\n-#if HAVE_cc0\n-static int alter_cond (rtx);\n-#endif\n static int align_fuzz (rtx, rtx, int, unsigned);\n static void collect_fn_hard_reg_usage (void);\n \f\n@@ -1962,21 +1948,6 @@ final_1 (rtx_insn *first, FILE *file, int seen, int optimize_p)\n \n   last_ignored_compare = 0;\n \n-  if (HAVE_cc0)\n-    for (insn = first; insn; insn = NEXT_INSN (insn))\n-      {\n-\t/* If CC tracking across branches is enabled, record the insn which\n-\t   jumps to each branch only reached from one place.  */\n-\tif (optimize_p && JUMP_P (insn))\n-\t  {\n-\t    rtx lab = JUMP_LABEL (insn);\n-\t    if (lab && LABEL_P (lab) && LABEL_NUSES (lab) == 1)\n-\t      {\n-\t\tLABEL_REFS (lab) = insn;\n-\t      }\n-\t  }\n-      }\n-\n   init_recog ();\n \n   CC_STATUS_INIT;\n@@ -2187,9 +2158,6 @@ static rtx_insn *\n final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\t   int nopeepholes ATTRIBUTE_UNUSED, int *seen)\n {\n-#if HAVE_cc0\n-  rtx set;\n-#endif\n   rtx_insn *next;\n   rtx_jump_table_data *table;\n \n@@ -2562,23 +2530,6 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    || GET_CODE (body) == CLOBBER)\n \t  break;\n \n-#if HAVE_cc0\n-\t{\n-\t  /* If there is a REG_CC_SETTER note on this insn, it means that\n-\t     the setting of the condition code was done in the delay slot\n-\t     of the insn that branched here.  So recover the cc status\n-\t     from the insn that set it.  */\n-\n-\t  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n-\t  if (note)\n-\t    {\n-\t      rtx_insn *other = as_a <rtx_insn *> (XEXP (note, 0));\n-\t      NOTICE_UPDATE_CC (PATTERN (other), other);\n-\t      cc_prev_status = cc_status;\n-\t    }\n-\t}\n-#endif\n-\n \t/* Detect insns that are really jump-tables\n \t   and output them as such.  */\n \n@@ -2798,182 +2749,6 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \tbody = PATTERN (insn);\n \n-#if HAVE_cc0\n-\tset = single_set (insn);\n-\n-\t/* Check for redundant test and compare instructions\n-\t   (when the condition codes are already set up as desired).\n-\t   This is done only when optimizing; if not optimizing,\n-\t   it should be possible for the user to alter a variable\n-\t   with the debugger in between statements\n-\t   and the next statement should reexamine the variable\n-\t   to compute the condition codes.  */\n-\n-\tif (optimize_p)\n-\t  {\n-\t    if (set\n-\t\t&& GET_CODE (SET_DEST (set)) == CC0\n-\t\t&& insn != last_ignored_compare)\n-\t      {\n-\t\trtx src1, src2;\n-\t\tif (GET_CODE (SET_SRC (set)) == SUBREG)\n-\t\t  SET_SRC (set) = alter_subreg (&SET_SRC (set), true);\n-\n-\t\tsrc1 = SET_SRC (set);\n-\t\tsrc2 = NULL_RTX;\n-\t\tif (GET_CODE (SET_SRC (set)) == COMPARE)\n-\t\t  {\n-\t\t    if (GET_CODE (XEXP (SET_SRC (set), 0)) == SUBREG)\n-\t\t      XEXP (SET_SRC (set), 0)\n-\t\t\t= alter_subreg (&XEXP (SET_SRC (set), 0), true);\n-\t\t    if (GET_CODE (XEXP (SET_SRC (set), 1)) == SUBREG)\n-\t\t      XEXP (SET_SRC (set), 1)\n-\t\t\t= alter_subreg (&XEXP (SET_SRC (set), 1), true);\n-\t\t    if (XEXP (SET_SRC (set), 1)\n-\t\t\t== CONST0_RTX (GET_MODE (XEXP (SET_SRC (set), 0))))\n-\t\t      src2 = XEXP (SET_SRC (set), 0);\n-\t\t  }\n-\t\tif ((cc_status.value1 != 0\n-\t\t     && rtx_equal_p (src1, cc_status.value1))\n-\t\t    || (cc_status.value2 != 0\n-\t\t\t&& rtx_equal_p (src1, cc_status.value2))\n-\t\t    || (src2 != 0 && cc_status.value1 != 0\n-\t\t        && rtx_equal_p (src2, cc_status.value1))\n-\t\t    || (src2 != 0 && cc_status.value2 != 0\n-\t\t\t&& rtx_equal_p (src2, cc_status.value2)))\n-\t\t  {\n-\t\t    /* Don't delete insn if it has an addressing side-effect.  */\n-\t\t    if (! FIND_REG_INC_NOTE (insn, NULL_RTX)\n-\t\t\t/* or if anything in it is volatile.  */\n-\t\t\t&& ! volatile_refs_p (PATTERN (insn)))\n-\t\t      {\n-\t\t\t/* We don't really delete the insn; just ignore it.  */\n-\t\t\tlast_ignored_compare = insn;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\t/* If this is a conditional branch, maybe modify it\n-\t   if the cc's are in a nonstandard state\n-\t   so that it accomplishes the same thing that it would\n-\t   do straightforwardly if the cc's were set up normally.  */\n-\n-\tif (cc_status.flags != 0\n-\t    && JUMP_P (insn)\n-\t    && GET_CODE (body) == SET\n-\t    && SET_DEST (body) == pc_rtx\n-\t    && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n-\t    && COMPARISON_P (XEXP (SET_SRC (body), 0))\n-\t    && XEXP (XEXP (SET_SRC (body), 0), 0) == cc0_rtx)\n-\t  {\n-\t    /* This function may alter the contents of its argument\n-\t       and clear some of the cc_status.flags bits.\n-\t       It may also return 1 meaning condition now always true\n-\t       or -1 meaning condition now always false\n-\t       or 2 meaning condition nontrivial but altered.  */\n-\t    int result = alter_cond (XEXP (SET_SRC (body), 0));\n-\t    /* If condition now has fixed value, replace the IF_THEN_ELSE\n-\t       with its then-operand or its else-operand.  */\n-\t    if (result == 1)\n-\t      SET_SRC (body) = XEXP (SET_SRC (body), 1);\n-\t    if (result == -1)\n-\t      SET_SRC (body) = XEXP (SET_SRC (body), 2);\n-\n-\t    /* The jump is now either unconditional or a no-op.\n-\t       If it has become a no-op, don't try to output it.\n-\t       (It would not be recognized.)  */\n-\t    if (SET_SRC (body) == pc_rtx)\n-\t      {\n-\t        delete_insn (insn);\n-\t\tbreak;\n-\t      }\n-\t    else if (ANY_RETURN_P (SET_SRC (body)))\n-\t      /* Replace (set (pc) (return)) with (return).  */\n-\t      PATTERN (insn) = body = SET_SRC (body);\n-\n-\t    /* Rerecognize the instruction if it has changed.  */\n-\t    if (result != 0)\n-\t      INSN_CODE (insn) = -1;\n-\t  }\n-\n-\t/* If this is a conditional trap, maybe modify it if the cc's\n-\t   are in a nonstandard state so that it accomplishes the same\n-\t   thing that it would do straightforwardly if the cc's were\n-\t   set up normally.  */\n-\tif (cc_status.flags != 0\n-\t    && NONJUMP_INSN_P (insn)\n-\t    && GET_CODE (body) == TRAP_IF\n-\t    && COMPARISON_P (TRAP_CONDITION (body))\n-\t    && XEXP (TRAP_CONDITION (body), 0) == cc0_rtx)\n-\t  {\n-\t    /* This function may alter the contents of its argument\n-\t       and clear some of the cc_status.flags bits.\n-\t       It may also return 1 meaning condition now always true\n-\t       or -1 meaning condition now always false\n-\t       or 2 meaning condition nontrivial but altered.  */\n-\t    int result = alter_cond (TRAP_CONDITION (body));\n-\n-\t    /* If TRAP_CONDITION has become always false, delete the\n-\t       instruction.  */\n-\t    if (result == -1)\n-\t      {\n-\t\tdelete_insn (insn);\n-\t\tbreak;\n-\t      }\n-\n-\t    /* If TRAP_CONDITION has become always true, replace\n-\t       TRAP_CONDITION with const_true_rtx.  */\n-\t    if (result == 1)\n-\t      TRAP_CONDITION (body) = const_true_rtx;\n-\n-\t    /* Rerecognize the instruction if it has changed.  */\n-\t    if (result != 0)\n-\t      INSN_CODE (insn) = -1;\n-\t  }\n-\n-\t/* Make same adjustments to instructions that examine the\n-\t   condition codes without jumping and instructions that\n-\t   handle conditional moves (if this machine has either one).  */\n-\n-\tif (cc_status.flags != 0\n-\t    && set != 0)\n-\t  {\n-\t    rtx cond_rtx, then_rtx, else_rtx;\n-\n-\t    if (!JUMP_P (insn)\n-\t\t&& GET_CODE (SET_SRC (set)) == IF_THEN_ELSE)\n-\t      {\n-\t\tcond_rtx = XEXP (SET_SRC (set), 0);\n-\t\tthen_rtx = XEXP (SET_SRC (set), 1);\n-\t\telse_rtx = XEXP (SET_SRC (set), 2);\n-\t      }\n-\t    else\n-\t      {\n-\t\tcond_rtx = SET_SRC (set);\n-\t\tthen_rtx = const_true_rtx;\n-\t\telse_rtx = const0_rtx;\n-\t      }\n-\n-\t    if (COMPARISON_P (cond_rtx)\n-\t\t&& XEXP (cond_rtx, 0) == cc0_rtx)\n-\t      {\n-\t\tint result;\n-\t\tresult = alter_cond (cond_rtx);\n-\t\tif (result == 1)\n-\t\t  validate_change (insn, &SET_SRC (set), then_rtx, 0);\n-\t\telse if (result == -1)\n-\t\t  validate_change (insn, &SET_SRC (set), else_rtx, 0);\n-\t\telse if (result == 2)\n-\t\t  INSN_CODE (insn) = -1;\n-\t\tif (SET_DEST (set) == SET_SRC (set))\n-\t\t  delete_insn (insn);\n-\t      }\n-\t  }\n-\n-#endif\n-\n \t/* Do machine-specific peephole optimizations if desired.  */\n \n \tif (HAVE_peephole && optimize_p && !flag_no_peephole && !nopeepholes)\n@@ -3041,17 +2816,6 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    && GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t  current_insn_predicate = COND_EXEC_TEST (PATTERN (insn));\n \n-#if HAVE_cc0\n-\tcc_prev_status = cc_status;\n-\n-\t/* Update `cc_status' for this instruction.\n-\t   The instruction's output routine may change it further.\n-\t   If the output routine for a jump insn needs to depend\n-\t   on the cc status, it should look at cc_prev_status.  */\n-\n-\tNOTICE_UPDATE_CC (body, insn);\n-#endif\n-\n \tcurrent_output_insn = debug_insn = insn;\n \n \t/* Find the proper template for this insn.  */\n@@ -3443,167 +3207,6 @@ walk_alter_subreg (rtx *xp, bool *changed)\n   return *xp;\n }\n \f\n-#if HAVE_cc0\n-\n-/* Given BODY, the body of a jump instruction, alter the jump condition\n-   as required by the bits that are set in cc_status.flags.\n-   Not all of the bits there can be handled at this level in all cases.\n-\n-   The value is normally 0.\n-   1 means that the condition has become always true.\n-   -1 means that the condition has become always false.\n-   2 means that COND has been altered.  */\n-\n-static int\n-alter_cond (rtx cond)\n-{\n-  int value = 0;\n-\n-  if (cc_status.flags & CC_REVERSED)\n-    {\n-      value = 2;\n-      PUT_CODE (cond, swap_condition (GET_CODE (cond)));\n-    }\n-\n-  if (cc_status.flags & CC_INVERTED)\n-    {\n-      value = 2;\n-      PUT_CODE (cond, reverse_condition (GET_CODE (cond)));\n-    }\n-\n-  if (cc_status.flags & CC_NOT_POSITIVE)\n-    switch (GET_CODE (cond))\n-      {\n-      case LE:\n-      case LEU:\n-      case GEU:\n-\t/* Jump becomes unconditional.  */\n-\treturn 1;\n-\n-      case GT:\n-      case GTU:\n-      case LTU:\n-\t/* Jump becomes no-op.  */\n-\treturn -1;\n-\n-      case GE:\n-\tPUT_CODE (cond, EQ);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case LT:\n-\tPUT_CODE (cond, NE);\n-\tvalue = 2;\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (cc_status.flags & CC_NOT_NEGATIVE)\n-    switch (GET_CODE (cond))\n-      {\n-      case GE:\n-      case GEU:\n-\t/* Jump becomes unconditional.  */\n-\treturn 1;\n-\n-      case LT:\n-      case LTU:\n-\t/* Jump becomes no-op.  */\n-\treturn -1;\n-\n-      case LE:\n-      case LEU:\n-\tPUT_CODE (cond, EQ);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case GT:\n-      case GTU:\n-\tPUT_CODE (cond, NE);\n-\tvalue = 2;\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (cc_status.flags & CC_NO_OVERFLOW)\n-    switch (GET_CODE (cond))\n-      {\n-      case GEU:\n-\t/* Jump becomes unconditional.  */\n-\treturn 1;\n-\n-      case LEU:\n-\tPUT_CODE (cond, EQ);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case GTU:\n-\tPUT_CODE (cond, NE);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case LTU:\n-\t/* Jump becomes no-op.  */\n-\treturn -1;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (cc_status.flags & (CC_Z_IN_NOT_N | CC_Z_IN_N))\n-    switch (GET_CODE (cond))\n-      {\n-      default:\n-\tgcc_unreachable ();\n-\n-      case NE:\n-\tPUT_CODE (cond, cc_status.flags & CC_Z_IN_N ? GE : LT);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case EQ:\n-\tPUT_CODE (cond, cc_status.flags & CC_Z_IN_N ? LT : GE);\n-\tvalue = 2;\n-\tbreak;\n-      }\n-\n-  if (cc_status.flags & CC_NOT_SIGNED)\n-    /* The flags are valid if signed condition operators are converted\n-       to unsigned.  */\n-    switch (GET_CODE (cond))\n-      {\n-      case LE:\n-\tPUT_CODE (cond, LEU);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case LT:\n-\tPUT_CODE (cond, LTU);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case GT:\n-\tPUT_CODE (cond, GTU);\n-\tvalue = 2;\n-\tbreak;\n-\n-      case GE:\n-\tPUT_CODE (cond, GEU);\n-\tvalue = 2;\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  return value;\n-}\n-#endif\n-\f\n /* Report inconsistency between the assembler template and the operands.\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n "}, {"sha": "a142809ec86764c0fab8aa5bcd8d3010544f81d0", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -784,7 +784,7 @@ forward_propagate_and_simplify (use_info *use, set_info *def,\n   if (need_single_set && !use_set)\n     return false;\n \n-  /* Do not propagate into PC, CC0, etc.\n+  /* Do not propagate into PC etc.\n \n      ??? This too seems unnecessary.  The current code should work correctly\n      without it, including cases where jumps become unconditional.  */"}, {"sha": "ec399d47b9f1c2fc97946318fffe5355f85be855", "filename": "gcc/gcse-common.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgcse-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgcse-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse-common.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -186,7 +186,6 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap,\n       goto repeat;\n \n     case PC:\n-    case CC0: /*FIXME*/\n     case CONST:\n     CASE_CONST_ANY:\n     case SYMBOL_REF:"}, {"sha": "9114f30705e2840d3f9c0f38fb42664b4f83aabb", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -926,7 +926,6 @@ oprs_unchanged_p (const_rtx x, const rtx_insn *insn, int avail_p)\n       return 0;\n \n     case PC:\n-    case CC0: /*FIXME*/\n     case CONST:\n     CASE_CONST_ANY:\n     case SYMBOL_REF:\n@@ -2031,33 +2030,15 @@ insert_insn_end_basic_block (struct gcse_expr *expr, basic_block bb)\n   while (NEXT_INSN (pat_end) != NULL_RTX)\n     pat_end = NEXT_INSN (pat_end);\n \n-  /* If the last insn is a jump, insert EXPR in front [taking care to\n-     handle cc0, etc. properly].  Similarly we need to care trapping\n-     instructions in presence of non-call exceptions.  */\n+  /* If the last insn is a jump, insert EXPR in front.  Similarly we need to\n+     take care of trapping instructions in presence of non-call exceptions.  */\n \n   if (JUMP_P (insn)\n       || (NONJUMP_INSN_P (insn)\n \t  && (!single_succ_p (bb)\n \t      || single_succ_edge (bb)->flags & EDGE_ABNORMAL)))\n     {\n-      /* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts\n-\t if cc0 isn't set.  */\n-      if (HAVE_cc0)\n-\t{\n-\t  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n-\t  if (note)\n-\t    insn = safe_as_a <rtx_insn *> (XEXP (note, 0));\n-\t  else\n-\t    {\n-\t      rtx_insn *maybe_cc0_setter = prev_nonnote_insn (insn);\n-\t      if (maybe_cc0_setter\n-\t\t  && INSN_P (maybe_cc0_setter)\n-\t\t  && sets_cc0_p (PATTERN (maybe_cc0_setter)))\n-\t\tinsn = maybe_cc0_setter;\n-\t    }\n-\t}\n-\n-      /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n+      /* FIXME: What if something in jump uses value set in new insn?  */\n       new_insn = emit_insn_before_noloc (pat, insn, bb);\n     }\n "}, {"sha": "1e035ddc38047784d9e3ec9f0ce44e57bbf13730", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3011,7 +3011,6 @@ clear_struct_flag (rtx x)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case EQ_ATTR:\n     case ATTR_FLAG:\n       return;"}, {"sha": "30ad61ebde4b3e16186374796bfa3f95696ecc37", "filename": "gcc/genconfig.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n static int max_recog_operands;  /* Largest operand number seen.  */\n static int max_dup_operands;    /* Largest number of match_dup in any insn.  */\n static int max_clobbers_per_insn;\n-static int have_cc0_flag;\n static int have_cmove_flag;\n static int have_cond_exec_flag;\n static int have_lo_sum_flag;\n@@ -105,11 +104,6 @@ walk_insn_part (rtx part, int recog_p, int non_pc_set_src)\n \tmax_recog_operands = XINT (part, 0);\n       return;\n \n-    case CC0:\n-      if (recog_p)\n-\thave_cc0_flag = 1;\n-      return;\n-\n     case LO_SUM:\n       if (recog_p)\n \thave_lo_sum_flag = 1;\n@@ -329,19 +323,6 @@ main (int argc, const char **argv)\n   printf (\"#define MAX_INSNS_PER_SPLIT %d\\n\", max_insns_per_split);\n   printf (\"#endif\\n\");\n \n-  if (have_cc0_flag)\n-    {\n-      printf (\"#define HAVE_cc0 1\\n\");\n-      printf (\"#define CC0_P(X) ((X) == cc0_rtx)\\n\");\n-    }\n-  else\n-    {\n-      /* We output CC0_P this way to make sure that X is declared\n-\t somewhere.  */\n-      printf (\"#define HAVE_cc0 0\\n\");\n-      printf (\"#define CC0_P(X) ((X) ? 0 : 0)\\n\");\n-    }\n-\n   if (have_cmove_flag)\n     printf (\"#define HAVE_conditional_move 1\\n\");\n   else"}, {"sha": "cac0e26917971ccc6f3e43c87bc3761555789b15", "filename": "gcc/genemit.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -169,9 +169,6 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used, md_rtx_info *info)\n \t  return;\n \t}\n       break;\n-    case CC0:\n-      printf (\"cc0_rtx\");\n-      return;\n \n     case CONST_INT:\n       if (INTVAL (x) == 0)"}, {"sha": "6fe4a2524fc7c2a1635c669c0b0bb9d8fab08d53", "filename": "gcc/genextract.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -237,7 +237,6 @@ walk_rtx (md_rtx_info *info, rtx x, class accum_extract *acc)\n   switch (code)\n     {\n     case PC:\n-    case CC0:\n     case CONST_INT:\n     case SYMBOL_REF:\n       return;"}, {"sha": "0b3aba169b6f15879cd65e49f6e75f139ed648db", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -143,7 +143,6 @@ special_rtx (int idx)\n \t  || strcmp (defs[idx].enumname, \"SUBREG\") == 0\n \t  || strcmp (defs[idx].enumname, \"MEM\") == 0\n \t  || strcmp (defs[idx].enumname, \"PC\") == 0\n-\t  || strcmp (defs[idx].enumname, \"CC0\") == 0\n \t  || strcmp (defs[idx].enumname, \"RETURN\") == 0\n \t  || strcmp (defs[idx].enumname, \"SIMPLE_RETURN\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_VECTOR\") == 0);"}, {"sha": "835e22a9cf72e0918c6ee3593ec8597c39def4cc", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -694,13 +694,11 @@ validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n \t  error_at (info->loc, \"mode mismatch in set: %smode vs %smode\",\n \t\t    GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n \n-\t/* If only one of the operands is VOIDmode, and PC or CC0 is\n-\t   not involved, it's probably a mistake.  */\n+\t/* If only one of the operands is VOIDmode, and PC is not involved,\n+\t   it's probably a mistake.  */\n \telse if (dmode != smode\n \t\t && GET_CODE (dest) != PC\n-\t\t && GET_CODE (dest) != CC0\n \t\t && GET_CODE (src) != PC\n-\t\t && GET_CODE (src) != CC0\n \t\t && !CONST_INT_P (src)\n \t\t && !CONST_WIDE_INT_P (src)\n \t\t && GET_CODE (src) != CALL)"}, {"sha": "9c88765d1fb4c8940179350e2b3237692805e362", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -7255,10 +7255,6 @@ free_global_sched_pressure_data (void)\n void\n sched_init (void)\n {\n-  /* Disable speculative loads in their presence if cc0 defined.  */\n-  if (HAVE_cc0)\n-  flag_schedule_speculative_load = 0;\n-\n   if (targetm.sched.dispatch (NULL, IS_DISPATCH_ON))\n     targetm.sched.dispatch_do (NULL, DISPATCH_INIT);\n "}, {"sha": "6ee44cbada2051a01ac562eb3ab7f0960bd61606", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3458,7 +3458,6 @@ noce_process_if_block (struct noce_if_info *if_info)\n   /* First look for multiple SETS.  */\n   if (!else_bb\n       && HAVE_conditional_move\n-      && !HAVE_cc0\n       && bb_ok_for_noce_convert_multiple_sets (then_bb))\n     {\n       if (noce_convert_multiple_sets (if_info))"}, {"sha": "cb5ca8bc21b89630a4c86537a2e32f616a543533", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1105,7 +1105,6 @@ record_address_regs (machine_mode mode, addr_space_t as, rtx x,\n     {\n     case CONST_INT:\n     case CONST:\n-    case CC0:\n     case PC:\n     case SYMBOL_REF:\n     case LABEL_REF:"}, {"sha": "638ef4ea17ef38806b443a32efe965aa45e83d24", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3085,7 +3085,6 @@ equiv_init_movable_p (rtx x, int regno)\n     case SET:\n       return equiv_init_movable_p (SET_SRC (x), regno);\n \n-    case CC0:\n     case CLOBBER:\n       return 0;\n \n@@ -3170,7 +3169,6 @@ memref_referenced_p (rtx memref, rtx x, bool read_p)\n     case SYMBOL_REF:\n     CASE_CONST_ANY:\n     case PC:\n-    case CC0:\n     case HIGH:\n     case LO_SUM:\n       return false;\n@@ -4448,9 +4446,6 @@ rtx_moveable_p (rtx *loc, enum op_type type)\n     case PC:\n       return type == OP_IN;\n \n-    case CC0:\n-      return false;\n-\n     case REG:\n       if (x == frame_pointer_rtx)\n \treturn true;\n@@ -4741,13 +4736,6 @@ find_moveable_pseudos (void)\n \t\t\t   ? \" (no unique first use)\" : \"\");\n \t\tcontinue;\n \t      }\n-\t    if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (closest_use)))\n-\t      {\n-\t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Reg %d: closest user uses cc0\\n\",\n-\t\t\t   regno);\n-\t\tcontinue;\n-\t      }\n \n \t    bitmap_set_bit (interesting, regno);\n \t    /* If we get here, we know closest_use is a non-NULL insn\n@@ -4822,8 +4810,7 @@ find_moveable_pseudos (void)\n \t  if (!bitmap_bit_p (def_bb_transp, regno))\n \t    {\n \t      if (bitmap_bit_p (def_bb_moveable, regno)\n-\t\t  && !control_flow_insn_p (use_insn)\n-\t\t  && (!HAVE_cc0 || !sets_cc0_p (use_insn)))\n+\t\t  && !control_flow_insn_p (use_insn))\n \t\t{\n \t\t  if (modified_between_p (DF_REF_REG (use), def_insn, use_insn))\n \t\t    {"}, {"sha": "80ad69100416d9b2fa5d3ef68e8ae28c043d0c4e", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -400,7 +400,7 @@ reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n       break;\n     }\n \n-  if (GET_MODE_CLASS (mode) == MODE_CC || CC0_P (arg0))\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n     {\n       /* Try to search for the comparison to determine the real mode.\n          This code is expensive, but with sane machine description it\n@@ -1008,55 +1008,6 @@ jump_to_label_p (const rtx_insn *insn)\n   return (JUMP_P (insn)\n \t  && JUMP_LABEL (insn) != NULL && !ANY_RETURN_P (JUMP_LABEL (insn)));\n }\n-\n-/* Return nonzero if X is an RTX that only sets the condition codes\n-   and has no side effects.  */\n-\n-int\n-only_sets_cc0_p (const_rtx x)\n-{\n-  if (! x)\n-    return 0;\n-\n-  if (INSN_P (x))\n-    x = PATTERN (x);\n-\n-  return sets_cc0_p (x) == 1 && ! side_effects_p (x);\n-}\n-\n-/* Return 1 if X is an RTX that does nothing but set the condition codes\n-   and CLOBBER or USE registers.\n-   Return -1 if X does explicitly set the condition codes,\n-   but also does other things.  */\n-\n-int\n-sets_cc0_p (const_rtx x)\n-{\n-  if (! x)\n-    return 0;\n-\n-  if (INSN_P (x))\n-    x = PATTERN (x);\n-\n-  if (GET_CODE (x) == SET && SET_DEST (x) == cc0_rtx)\n-    return 1;\n-  if (GET_CODE (x) == PARALLEL)\n-    {\n-      int i;\n-      int sets_cc0 = 0;\n-      int other_things = 0;\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t{\n-\t  if (GET_CODE (XVECEXP (x, 0, i)) == SET\n-\t      && SET_DEST (XVECEXP (x, 0, i)) == cc0_rtx)\n-\t    sets_cc0 = 1;\n-\t  else if (GET_CODE (XVECEXP (x, 0, i)) == SET)\n-\t    other_things = 1;\n-\t}\n-      return ! sets_cc0 ? 0 : other_things ? -1 : 1;\n-    }\n-  return 0;\n-}\n \f\n /* Find all CODE_LABELs referred to in X, and increment their use\n    counts.  If INSN is a JUMP_INSN and there is at least one\n@@ -1101,7 +1052,6 @@ mark_jump_label_1 (rtx x, rtx_insn *insn, bool in_mem, bool is_target)\n   switch (code)\n     {\n     case PC:\n-    case CC0:\n     case REG:\n     case CLOBBER:\n     case CALL:\n@@ -1771,7 +1721,6 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n   switch (code)\n     {\n     case PC:\n-    case CC0:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n     CASE_CONST_UNIQUE:"}, {"sha": "bdc7b59dd5fe9819d50d1f9d58656daf22fa5e52", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -212,7 +212,6 @@ check_maybe_invariant (rtx x)\n       return true;\n \n     case PC:\n-    case CC0:\n     case UNSPEC_VOLATILE:\n     case CALL:\n       return false;\n@@ -1095,10 +1094,6 @@ find_invariant_insn (rtx_insn *insn, bool always_reached, bool always_executed)\n   bool simple = true;\n   struct invariant *inv;\n \n-  /* We can't move a CC0 setter without the user.  */\n-  if (HAVE_cc0 && sets_cc0_p (insn))\n-    return;\n-\n   /* Jumps have control flow side-effects.  */\n   if (JUMP_P (insn))\n     return;"}, {"sha": "a766f1fd7e81cb5a4549a987550821167da01a7a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3989,15 +3989,9 @@ curr_insn_transform (bool check_only_p)\n   no_input_reloads_p = no_output_reloads_p = false;\n   goal_alt_number = -1;\n   change_p = sec_mem_p = false;\n-  /* CALL_INSNs are not allowed to have any output reloads; neither\n-     are insns that SET cc0.  Insns that use CC0 are not allowed to\n-     have any input reloads.  */\n-  if (CALL_P (curr_insn))\n-    no_output_reloads_p = true;\n \n-  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (curr_insn)))\n-    no_input_reloads_p = true;\n-  if (HAVE_cc0 && reg_set_p (cc0_rtx, PATTERN (curr_insn)))\n+  /* CALL_INSNs are not allowed to have any output reloads.  */\n+  if (CALL_P (curr_insn))\n     no_output_reloads_p = true;\n \n   n_operands = curr_static_id->n_operands;"}, {"sha": "2dd3070b8b3129bc28e78e145d6fbc11d7290fd2", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -353,7 +353,6 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case ASM_INPUT:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:"}, {"sha": "62a6bdb4c59bf8263c499245795576199606d372", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -4294,13 +4294,6 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n           > COSTS_N_INSNS (1)))\n     y = force_reg (mode, y);\n \n-#if HAVE_cc0\n-  /* Make sure if we have a canonical comparison.  The RTL\n-     documentation states that canonical comparisons are required only\n-     for targets which have cc0.  */\n-  gcc_assert (!CONSTANT_P (x) || CONSTANT_P (y));\n-#endif\n-\n   /* Don't let both operands fail to indicate the mode.  */\n   if (GET_MODE (x) == VOIDmode && GET_MODE (y) == VOIDmode)\n     x = force_reg (mode, x);"}, {"sha": "0b28247e299eb25d7a272046f44666da41c48526", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -549,7 +549,6 @@ oprs_unchanged_p (rtx x, rtx_insn *insn, bool after_insn)\n \treturn oprs_unchanged_p (XEXP (x, 0), insn, after_insn);\n \n     case PC:\n-    case CC0: /*FIXME*/\n     case CONST:\n     CASE_CONST_ANY:\n     case SYMBOL_REF:"}, {"sha": "e4b2acb850cb3d74995fdf82d2a4c8b881a5555c", "filename": "gcc/postreload.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1013,10 +1013,6 @@ reload_combine_recognize_const_pattern (rtx_insn *insn)\n \t      && reg_state[clobbered_regno].real_store_ruid >= use_ruid)\n \t    break;\n \n-\t  /* Do not separate cc0 setter and cc0 user on HAVE_cc0 targets.  */\n-\t  if (HAVE_cc0 && must_move_add && sets_cc0_p (PATTERN (use_insn)))\n-\t    break;\n-\n \t  gcc_assert (reg_state[regno].store_ruid <= use_ruid);\n \t  /* Avoid moving a use of ADDREG past a point where it is stored.  */\n \t  if (reg_state[REGNO (addreg)].store_ruid > use_ruid)"}, {"sha": "567d2877b8ea83fe55dcd894ac75c1278a402b76", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1748,7 +1748,6 @@ print_value (pretty_printer *pp, const_rtx x, int verbose)\n       pp_wide_integer (pp, SUBREG_BYTE (x));\n       break;\n     case SCRATCH:\n-    case CC0:\n     case PC:\n       pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n       break;"}, {"sha": "a10d57fa03849ef1922c37b539074f950898eb18", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1491,7 +1491,6 @@ function_reader::consolidate_singletons (rtx x)\n     case PC: return pc_rtx;\n     case RETURN: return ret_rtx;\n     case SIMPLE_RETURN: return simple_return_rtx;\n-    case CC0: return cc0_rtx;\n \n     case REG:\n       return consolidate_reg (x);"}, {"sha": "dbe032c0b7fa4c902c69fb2fca225b4463773631", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -71,16 +71,6 @@ REG_NOTE (NONNEG)\n /* Identifies a register set in this insn and never used.  */\n REG_NOTE (UNUSED)\n \n-/* REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use\n-   CC0, respectively.  Normally, these are required to be consecutive\n-   insns, but we permit putting a cc0-setting insn in the delay slot\n-   of a branch as long as only one copy of the insn exists.  In that\n-   case, these notes point from one to the other to allow code\n-   generation to determine what any require information and to\n-   properly update CC_STATUS.  These notes are INSN_LISTs.  */\n-REG_NOTE (CC_SETTER)\n-REG_NOTE (CC_USER)\n-\n /* Points to a CODE_LABEL.  Used by JUMP_INSNs to say that the CODE_LABEL\n    contained in the REG_LABEL_TARGET note is a possible jump target of\n    this insn.  This note is an INSN_LIST.  */"}, {"sha": "25210f0c17f42a183af9e0f195495331332c8ace", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1251,7 +1251,7 @@ swap_rtx_condition (rtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n \n-  /* We're looking for a single set to cc0 or an HImode temporary.  */\n+  /* We're looking for a single set to an HImode temporary.  */\n \n   if (GET_CODE (pat) == SET\n       && REG_P (SET_DEST (pat))\n@@ -1298,7 +1298,7 @@ swap_rtx_condition (rtx_insn *insn)\n \t  || ! dead_or_set_p (insn, dest))\n \treturn 0;\n \n-      /* Now we are prepared to handle this as a normal cc0 setter.  */\n+      /* Now we are prepared to handle this.  */\n       insn = next_flags_user (insn);\n       if (insn == NULL_RTX)\n \treturn 0;\n@@ -1586,18 +1586,15 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \t    break;\n \n \t  case REG:\n-\t    /* This is a `tstM2' case.  */\n-\t    gcc_assert (*dest == cc0_rtx);\n-\t    src1 = src;\n+\t    gcc_unreachable ();\n \n \t    /* Fall through.  */\n \n \t  case FLOAT_TRUNCATE:\n \t  case SQRT:\n \t  case ABS:\n \t  case NEG:\n-\t    /* These insns only operate on the top of the stack. DEST might\n-\t       be cc0_rtx if we're processing a tstM pattern. Also, it's\n+\t    /* These insns only operate on the top of the stack.  It's\n \t       possible that the tstM case results in a REG_DEAD note on the\n \t       source.  */\n "}, {"sha": "95547a870871203d9ccfce5cb7b3c8b4fceccbfa", "filename": "gcc/reginfo.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1003,7 +1003,6 @@ reg_scan_mark_refs (rtx x, rtx_insn *insn)\n     {\n     case CONST:\n     CASE_CONST_ANY:\n-    case CC0:\n     case PC:\n     case SYMBOL_REF:\n     case LABEL_REF:"}, {"sha": "b8a9ca36f225cc9f74ea7c26964cdedfb1ab5948", "filename": "gcc/regrename.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1456,7 +1456,6 @@ scan_rtx (rtx_insn *insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n     CASE_CONST_ANY:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-    case CC0:\n     case PC:\n       return;\n "}, {"sha": "d21be917e5648fb5056dddb70e2eb21d6b163da9", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1500,27 +1500,6 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   if (in != 0 && in != *inloc)\n     rld[i].nocombine = 1;\n \n-#if 0\n-  /* This was replaced by changes in find_reloads_address_1 and the new\n-     function inc_for_reload, which go with a new meaning of reload_inc.  */\n-\n-  /* If this is an IN/OUT reload in an insn that sets the CC,\n-     it must be for an autoincrement.  It doesn't work to store\n-     the incremented value after the insn because that would clobber the CC.\n-     So we must do the increment of the value reloaded from,\n-     increment it, store it back, then decrement again.  */\n-  if (out != 0 && sets_cc0_p (PATTERN (this_insn)))\n-    {\n-      out = 0;\n-      rld[i].out = 0;\n-      rld[i].inc = find_inc_amount (PATTERN (this_insn), in);\n-      /* If we did not find a nonzero amount-to-increment-by,\n-\t that contradicts the belief that IN is being incremented\n-\t in an address in this insn.  */\n-      gcc_assert (rld[i].inc != 0);\n-    }\n-#endif\n-\n   /* If we will replace IN and OUT with the reload-reg,\n      record where they are located so that substitution need\n      not do a tree walk.  */\n@@ -2696,17 +2675,10 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t}\n     }\n \n-  /* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads;\n-     neither are insns that SET cc0.  Insns that use CC0 are not allowed\n-     to have any input reloads.  */\n+  /* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads.  */\n   if (JUMP_P (insn) || CALL_P (insn))\n     no_output_reloads = 1;\n \n-  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    no_input_reloads = 1;\n-  if (HAVE_cc0 && reg_set_p (cc0_rtx, PATTERN (insn)))\n-    no_output_reloads = 1;\n-\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n \n@@ -4585,15 +4557,6 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t    rld[j].in = 0;\n \t  }\n \n-  /* If we made any reloads for addresses, see if they violate a\n-     \"no input reloads\" requirement for this insn.  But loads that we\n-     do after the insn (such as for output addresses) are fine.  */\n-  if (HAVE_cc0 && no_input_reloads)\n-    for (i = 0; i < n_reloads; i++)\n-      gcc_assert (rld[i].in == 0\n-\t\t  || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS\n-\t\t  || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS);\n-\n   /* Compute reload_mode and reload_nregs.  */\n   for (i = 0; i < n_reloads; i++)\n     {\n@@ -5323,7 +5286,6 @@ subst_reg_equivs (rtx ad, rtx_insn *insn)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case PC:\n-    case CC0:\n       return ad;\n \n     case REG:\n@@ -5862,7 +5824,7 @@ find_reloads_address_1 (machine_mode mode, addr_space_t as,\n \t      /* If we can output the register afterwards, do so, this\n \t\t saves the extra update.\n \t\t We can do so if we have an INSN - i.e. no JUMP_INSN nor\n-\t\t CALL_INSN - and it does not set CC0.\n+\t\t CALL_INSN.\n \t\t But don't do this if we cannot directly address the\n \t\t memory location, since this will make it harder to\n \t\t reuse address reloads, and increases register pressure.\n@@ -5872,9 +5834,6 @@ find_reloads_address_1 (machine_mode mode, addr_space_t as,\n \t\t\t   : reg_equiv_mem (regno));\n \t      enum insn_code icode = optab_handler (add_optab, GET_MODE (x));\n \t      if (insn && NONJUMP_INSN_P (insn)\n-#if HAVE_cc0\n-\t\t  && ! sets_cc0_p (PATTERN (insn))\n-#endif\n \t\t  && (regno < FIRST_PSEUDO_REGISTER\n \t\t      || (equiv\n \t\t\t  && memory_operand (equiv, GET_MODE (equiv))\n@@ -6621,8 +6580,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n     }\n   else if (MEM_P (x))\n     return refers_to_mem_for_reload_p (in);\n-  else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n-\t   || GET_CODE (x) == CC0)\n+  else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC)\n     return reg_mentioned_p (x, in);\n   else\n     {"}, {"sha": "1e9f361fff4b9e789ca8f916464c2bd36c715ce3", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2539,7 +2539,6 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case ASM_INPUT:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n@@ -2962,7 +2961,6 @@ elimination_effects (rtx x, machine_mode mem_mode)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case ASM_INPUT:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n@@ -4341,7 +4339,6 @@ scan_paradoxical_subregs (rtx x)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     CASE_CONST_ANY:\n-    case CC0:\n     case PC:\n     case USE:\n     case CLOBBER:\n@@ -7852,7 +7849,7 @@ do_input_reload (class insn_chain *chain, struct reload *rl, int j)\n /* Do output reloading for reload RL, which is for the insn described by\n    CHAIN and has the number J.\n    ??? At some point we need to support handling output reloads of\n-   JUMP_INSNs or insns that set cc0.  */\n+   JUMP_INSNs.  */\n static void\n do_output_reload (class insn_chain *chain, struct reload *rl, int j)\n {"}, {"sha": "4595f9a541f004ed4a4ad243a342e3ee64e5c599", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 137, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -88,17 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n    making the various individual schedules work well together.  It is\n    especially tuned to handle the control flow interactions of branch\n    insns.  It does nothing for insns with delay slots that do not\n-   branch.\n-\n-   On machines that use CC0, we are very conservative.  We will not make\n-   a copy of an insn involving CC0 since we want to maintain a 1-1\n-   correspondence between the insn that sets and uses CC0.  The insns are\n-   allowed to be separated by placing an insn that sets CC0 (but not an insn\n-   that uses CC0; we could do this, but it doesn't seem worthwhile) in a\n-   delay slot.  In that case, we point each insn at the other with REG_CC_USER\n-   and REG_CC_SETTER notes.  Note that these restrictions affect very few\n-   machines because most RISC machines with delay slots will not use CC0\n-   (the RT is the only known exception at this point).  */\n+   branch.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -155,21 +145,6 @@ skip_consecutive_labels (rtx label_or_return)\n \n   return label;\n }\n-\n-/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER\n-   and REG_CC_USER notes so we can find it.  */\n-\n-static void\n-link_cc0_insns (rtx_insn *insn)\n-{\n-  rtx user = next_nonnote_insn (insn);\n-\n-  if (NONJUMP_INSN_P (user) && GET_CODE (PATTERN (user)) == SEQUENCE)\n-    user = XVECEXP (PATTERN (user), 0, 0);\n-\n-  add_reg_note (user, REG_CC_SETTER, insn);\n-  add_reg_note (insn, REG_CC_USER, user);\n-}\n \f\n /* Insns which have delay slots that have not yet been filled.  */\n \n@@ -345,8 +320,7 @@ insn_references_resource_p (rtx insn, struct resources *res,\n \n /* Return TRUE if INSN modifies resources that are marked in RES.\n    INCLUDE_DELAYED_EFFECTS is set if the actions of that routine should be\n-   included.   CC0 is only modified if it is explicitly set; see comments\n-   in front of mark_set_resources for details.  */\n+   included.   */\n \n static int\n insn_sets_resource_p (rtx insn, struct resources *res,\n@@ -640,49 +614,11 @@ delete_from_delay_slot (rtx_insn *insn)\n   return trial;\n }\n \f\n-/* Delete INSN, a JUMP_INSN.  If it is a conditional jump, we must track down\n-   the insn that sets CC0 for it and delete it too.  */\n+/* Delete INSN, a JUMP_INSN.  */\n \n static void\n delete_scheduled_jump (rtx_insn *insn)\n {\n-  /* Delete the insn that sets cc0 for us.  On machines without cc0, we could\n-     delete the insn that sets the condition code, but it is hard to find it.\n-     Since this case is rare anyway, don't bother trying; there would likely\n-     be other insns that became dead anyway, which we wouldn't know to\n-     delete.  */\n-\n-  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, insn))\n-    {\n-      rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n-\n-      /* If a reg-note was found, it points to an insn to set CC0.  This\n-\t insn is in the delay list of some other insn.  So delete it from\n-\t the delay list it was in.  */\n-      if (note)\n-\t{\n-\t  if (! FIND_REG_INC_NOTE (XEXP (note, 0), NULL_RTX)\n-\t      && sets_cc0_p (PATTERN (XEXP (note, 0))) == 1)\n-\t    delete_from_delay_slot (as_a <rtx_insn *> (XEXP (note, 0)));\n-\t}\n-      else\n-\t{\n-\t  /* The insn setting CC0 is our previous insn, but it may be in\n-\t     a delay slot.  It will be the last insn in the delay slot, if\n-\t     it is.  */\n-\t  rtx_insn *trial = previous_insn (insn);\n-\t  if (NOTE_P (trial))\n-\t    trial = prev_nonnote_insn (trial);\n-\t  if (sets_cc0_p (PATTERN (trial)) != 1\n-\t      || FIND_REG_INC_NOTE (trial, NULL_RTX))\n-\t    return;\n-\t  if (PREV_INSN (NEXT_INSN (trial)) == trial)\n-\t    delete_related_insns (trial);\n-\t  else\n-\t    delete_from_delay_slot (trial);\n-\t}\n-    }\n-\n   delete_related_insns (insn);\n }\n \f\n@@ -1112,9 +1048,6 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n \t  || insn_sets_resource_p (trial, sets, false)\n-\t  /* If TRIAL sets CC0, we can't copy it, so we can't steal this\n-\t     delay list.  */\n-\t  || (HAVE_cc0 && find_reg_note (trial, REG_CC_USER, NULL_RTX))\n \t  /* If TRIAL is from the fallthrough code of an annulled branch insn\n \t     in SEQ, we cannot use it.  */\n \t  || (INSN_ANNULLED_BRANCH_P (seq->insn (0))\n@@ -1219,13 +1152,9 @@ steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,\n       rtx_insn *trial = seq->insn (i);\n       rtx_insn *prior_insn;\n \n-      /* If TRIAL sets CC0, stealing it will move it too far from the use\n-\t of CC0.  */\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n-\t  || insn_sets_resource_p (trial, sets, false)\n-\t  || (HAVE_cc0 && sets_cc0_p (PATTERN (trial))))\n-\n+\t  || insn_sets_resource_p (trial, sets, false))\n \tbreak;\n \n       /* If this insn was already done, we don't need it.  */\n@@ -1314,8 +1243,6 @@ try_merge_delay_insns (rtx_insn *insn, rtx_insn *thread)\n \tcontinue;\n \n       if (GET_CODE (next_to_match) == GET_CODE (trial)\n-\t  /* We can't share an insn that sets cc0.  */\n-\t  && (!HAVE_cc0 || ! sets_cc0_p (pat))\n \t  && ! insn_references_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, &needed, true)\n@@ -1385,7 +1312,6 @@ try_merge_delay_insns (rtx_insn *insn, rtx_insn *thread)\n \t  if (! insn_references_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &needed, true)\n-\t      && (!HAVE_cc0 || ! sets_cc0_p (PATTERN (dtrial)))\n \t      && rtx_equal_p (PATTERN (next_to_match), PATTERN (dtrial))\n \t      /* Check that DTRIAL and NEXT_TO_MATCH does not reference a \n \t         resource modified between them (only dtrial is checked because\n@@ -1549,8 +1475,8 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n   if (trial == 0)\n     return 0;\n \n-  /* See what resources this insn sets and needs.  If they overlap, or\n-     if this insn references CC0, it can't be redundant.  */\n+  /* See what resources this insn sets and needs.  If they overlap, it\n+     can't be redundant.  */\n \n   CLEAR_RESOURCE (&needed);\n   CLEAR_RESOURCE (&set);\n@@ -1562,7 +1488,6 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n     target_main = XVECEXP (PATTERN (target), 0, 0);\n \n   if (resource_conflicts_p (&needed, &set)\n-      || (HAVE_cc0 && reg_mentioned_p (cc0_rtx, ipat))\n       /* The insn requiring the delay may not set anything needed or set by\n \t INSN.  */\n       || insn_sets_resource_p (target_main, &needed, true)\n@@ -2051,8 +1976,6 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t\t\t\t     filter_flags ? &fset : &set,\n \t\t\t\t\t     true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-\t\t  /* Can't separate set of cc0 from its use.  */\n-\t\t  && (!HAVE_cc0 || ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat)))\n \t\t  && ! can_throw_internal (trial))\n \t\t{\n \t\t  trial = try_split (pat, trial, 1);\n@@ -2186,16 +2109,13 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  && ! insn_references_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &set, true)\n \t\t  && ! insn_sets_resource_p (trial, &needed, true)\n-\t\t  && (!HAVE_cc0 && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat)))\n \t\t  && ! (maybe_never && may_trap_or_fault_p (pat))\n \t\t  && (trial = try_split (pat, trial, 0))\n \t\t  && eligible_for_delay (insn, slots_filled, trial, flags)\n \t\t  && ! can_throw_internal (trial))\n \t\t{\n \t\t  next_trial = next_nonnote_insn (trial);\n \t\t  add_to_delay_list (trial, &delay_list);\n-\t\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, pat))\n-\t\t    link_cc0_insns (trial);\n \n \t\t  delete_related_insns (trial);\n \t\t  if (slots_to_fill == ++slots_filled)\n@@ -2232,7 +2152,6 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      && ! insn_references_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &set, true)\n \t      && ! insn_sets_resource_p (next_trial, &needed, true)\n-\t      && (!HAVE_cc0 || ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial)))\n \t      && ! (maybe_never && may_trap_or_fault_p (PATTERN (next_trial)))\n \t      && (next_trial = try_split (PATTERN (next_trial), next_trial, 0))\n \t      && eligible_for_delay (insn, slots_filled, next_trial, flags)\n@@ -2452,23 +2371,10 @@ fill_slots_from_thread (rtx_jump_insn *insn, rtx condition,\n       if (GET_CODE (trial) == DEBUG_INSN)\n \tcontinue;\n \n-      /* If TRIAL conflicts with the insns ahead of it, we lose.  Also,\n-\t don't separate or copy insns that set and use CC0.  */\n+      /* If TRIAL conflicts with the insns ahead of it, we lose.  */\n       if (! insn_references_resource_p (trial, &set, true)\n \t  && ! insn_sets_resource_p (trial, filter_flags ? &fset : &set, true)\n \t  && ! insn_sets_resource_p (trial, &needed, true)\n-\t  /* If we're handling sets to the flags register specially, we\n-\t     only allow an insn into a delay-slot, if it either:\n-\t     - doesn't set the flags register,\n-\t     - the \"set\" of the flags register isn't used (clobbered),\n-\t     - insns between the delay-slot insn and the trial-insn\n-\t     as accounted in \"set\", have not affected the flags register.  */\n-\t  && (! filter_flags\n-\t      || ! insn_sets_resource_p (trial, &flags_res, true)\n-\t      || find_regno_note (trial, REG_UNUSED, targetm.flags_regnum)\n-\t      || ! TEST_HARD_REG_BIT (set.regs, targetm.flags_regnum))\n-\t  && (!HAVE_cc0 || (! (reg_mentioned_p (cc0_rtx, pat)\n-\t\t\t      && (! own_thread || ! sets_cc0_p (pat)))))\n \t  && ! can_throw_internal (trial))\n \t{\n \t  rtx_insn *prior_insn;\n@@ -2543,9 +2449,6 @@ fill_slots_from_thread (rtx_jump_insn *insn, rtx condition,\n \t\t  must_annul = 1;\n \t\twinner:\n \n-\t\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, pat))\n-\t\t    link_cc0_insns (trial);\n-\n \t\t  /* If we own this thread, delete the insn.  If this is the\n \t\t     destination of a branch, show that a basic block status\n \t\t     may have been updated.  In any case, mark the new\n@@ -3083,37 +2986,13 @@ delete_prior_computation (rtx note, rtx_insn *insn)\n \n    Look at all our REG_DEAD notes.  If a previous insn does nothing other\n    than set a register that dies in this insn, we can delete that insn\n-   as well.\n-\n-   On machines with CC0, if CC0 is used in this insn, we may be able to\n-   delete the insn that set it.  */\n+   as well.  */\n \n static void\n delete_computation (rtx_insn *insn)\n {\n   rtx note, next;\n \n-  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    {\n-      rtx_insn *prev = prev_nonnote_insn (insn);\n-      /* We assume that at this stage\n-\t CC's are always set explicitly\n-\t and always immediately before the jump that\n-\t will use them.  So if the previous insn\n-\t exists to set the CC's, delete it\n-\t (unless it performs auto-increments, etc.).  */\n-      if (prev && NONJUMP_INSN_P (prev)\n-\t  && sets_cc0_p (PATTERN (prev)))\n-\t{\n-\t  if (sets_cc0_p (PATTERN (prev)) > 0\n-\t      && ! side_effects_p (PATTERN (prev)))\n-\t    delete_computation (prev);\n-\t  else\n-\t    /* Otherwise, show that cc0 won't be used.  */\n-\t    add_reg_note (prev, REG_UNUSED, cc0_rtx);\n-\t}\n-    }\n-\n   for (note = REG_NOTES (insn); note; note = next)\n     {\n       next = XEXP (note, 1);\n@@ -3458,14 +3337,7 @@ relax_delay_slots (rtx_insn *first)\n \t  && !INSN_ANNULLED_BRANCH_P (delay_jump_insn)\n \t  && !condjump_in_parallel_p (delay_jump_insn)\n \t  && prev_active_insn (as_a<rtx_insn *> (target_label)) == insn\n-\t  && !BARRIER_P (prev_nonnote_insn (as_a<rtx_insn *> (target_label)))\n-\t  /* If the last insn in the delay slot sets CC0 for some insn,\n-\t     various code assumes that it is in a delay slot.  We could\n-\t     put it back where it belonged and delete the register notes,\n-\t     but it doesn't seem worthwhile in this uncommon case.  */\n-\t  && (!HAVE_cc0\n-\t      || ! find_reg_note (XVECEXP (pat, 0, XVECLEN (pat, 0) - 1),\n-\t\t\t\t  REG_CC_USER, NULL_RTX)))\n+\t  && !BARRIER_P (prev_nonnote_insn (as_a<rtx_insn *> (target_label))))\n \t{\n \t  rtx_insn *after;\n \t  int i;"}, {"sha": "61852036c5ff2067935b04aa7bfa797c6f755e64", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -246,10 +246,6 @@ mark_referenced_resources (rtx x, struct resources *res,\n       mark_referenced_resources (XEXP (x, 0), res, false);\n       return;\n \n-    case CC0:\n-      res->cc = 1;\n-      return;\n-\n     case UNSPEC_VOLATILE:\n     case TRAP_IF:\n     case ASM_INPUT:\n@@ -607,13 +603,7 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n    set by the called routine.\n \n    If IN_DEST is nonzero, it means we are inside a SET.  Otherwise,\n-   objects are being referenced instead of set.\n-\n-   We never mark the insn as modifying the condition code unless it explicitly\n-   SETs CC0 even though this is not totally correct.  The reason for this is\n-   that we require a SET of CC0 to immediately precede the reference to CC0.\n-   So if some other insn sets CC0 as a side-effect, we know it cannot affect\n-   our computation and thus may be placed in a delay slot.  */\n+   objects are being referenced instead of set.  */\n \n void\n mark_set_resources (rtx x, struct resources *res, int in_dest,\n@@ -643,11 +633,6 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n       /* These don't set any resources.  */\n       return;\n \n-    case CC0:\n-      if (in_dest)\n-\tres->cc = 1;\n-      return;\n-\n     case CALL_INSN:\n       /* Called routine modifies the condition code, memory, any registers\n \t that aren't saved across calls, global registers and anything"}, {"sha": "035eadc35143705fce88fd38fba92349ac4e12bc", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -295,14 +295,13 @@ copy_rtx (rtx orig)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;\n     case CLOBBER:\n-      /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n+      /* Share clobbers of hard registers, but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n       if (REG_P (XEXP (orig, 0)) && REGNO (XEXP (orig, 0)) < FIRST_PSEUDO_REGISTER\n@@ -388,7 +387,6 @@ shallow_copy_rtx (const_rtx orig MEM_STAT_DECL)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case RETURN:\n     case SIMPLE_RETURN:\n     case SCRATCH:"}, {"sha": "c80144b1132563b7b34c9ea4d3171357397e549d", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -287,7 +287,7 @@ DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", RTX_EXTRA)\n    ---------------------------------------------------------------------- */\n \n /* Assignment.\n-   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n+   Operand 1 is the location (REG, MEM, PC or whatever) assigned to.\n    Operand 2 is the value stored there.\n    ALL assignment must use SET.\n    Instructions that do multiple assignments must use multiple SET,\n@@ -436,13 +436,6 @@ DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u\", RTX_CONST_OBJ)\n    This is either a DECL node, or some kind of constant.  */\n DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s0\", RTX_CONST_OBJ)\n \n-/* The condition code register is represented, in our imagination,\n-   as a register holding a value that can be compared to zero.\n-   In fact, the machine has already compared them and recorded the\n-   results; but instructions that look at the condition code\n-   pretend to be looking at the entire value and comparing it.  */\n-DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n-\n /* ----------------------------------------------------------------------\n    Expressions for operators in an rtl pattern\n    ---------------------------------------------------------------------- */"}, {"sha": "c5f3d20fae40320ac5ef3996491e35af062bdb42", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3352,8 +3352,6 @@ extern rtx_insn *next_real_nondebug_insn (rtx);\n extern rtx_insn *prev_active_insn (rtx_insn *);\n extern rtx_insn *next_active_insn (rtx_insn *);\n extern int active_insn_p (const rtx_insn *);\n-extern rtx_insn *next_cc0_user (rtx_insn *);\n-extern rtx_insn *prev_cc0_setter (rtx_insn *);\n \n /* In emit-rtl.c  */\n extern int insn_line (const rtx_insn *);\n@@ -3790,7 +3788,6 @@ extern GTY(()) rtx const_tiny_rtx[4][(int) MAX_MACHINE_MODE];\n #define CONSTM1_RTX(MODE) (const_tiny_rtx[3][(int) (MODE)])\n \n extern GTY(()) rtx pc_rtx;\n-extern GTY(()) rtx cc0_rtx;\n extern GTY(()) rtx ret_rtx;\n extern GTY(()) rtx simple_return_rtx;\n extern GTY(()) rtx_insn *invalid_insn_rtx;\n@@ -4126,8 +4123,6 @@ extern int simplejump_p (const rtx_insn *);\n extern int returnjump_p (const rtx_insn *);\n extern int eh_returnjump_p (rtx_insn *);\n extern int onlyjump_p (const rtx_insn *);\n-extern int only_sets_cc0_p (const_rtx);\n-extern int sets_cc0_p (const_rtx);\n extern int invert_jump_1 (rtx_jump_insn *, rtx);\n extern int invert_jump (rtx_jump_insn *, rtx, int);\n extern int rtx_renumbered_equal_p (const_rtx, const_rtx);"}, {"sha": "712c2c28578f3fd83a1a2b48434660ceb582f89d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -996,7 +996,6 @@ count_occurrences (const_rtx x, const_rtx find, int count_dest)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n       return 0;\n \n     case EXPR_LIST:\n@@ -1090,7 +1089,6 @@ reg_mentioned_p (const_rtx reg, const_rtx in)\n       /* These codes have no constituent expressions\n \t and are unique.  */\n     case SCRATCH:\n-    case CC0:\n     case PC:\n       return 0;\n \n@@ -1173,11 +1171,10 @@ reg_referenced_p (const_rtx x, const_rtx body)\n       if (reg_overlap_mentioned_p (x, SET_SRC (body)))\n \treturn 1;\n \n-      /* If the destination is anything other than CC0, PC, a REG or a SUBREG\n+      /* If the destination is anything other than PC, a REG or a SUBREG\n \t of a REG that occupies all of the REG, the insn references X if\n \t it is mentioned in the destination.  */\n-      if (GET_CODE (SET_DEST (body)) != CC0\n-\t  && GET_CODE (SET_DEST (body)) != PC\n+      if (GET_CODE (SET_DEST (body)) != PC\n \t  && !REG_P (SET_DEST (body))\n \t  && ! (GET_CODE (SET_DEST (body)) == SUBREG\n \t\t&& REG_P (SUBREG_REG (SET_DEST (body)))\n@@ -1324,7 +1321,6 @@ modified_between_p (const_rtx x, const rtx_insn *start, const rtx_insn *end)\n       return 0;\n \n     case PC:\n-    case CC0:\n       return 1;\n \n     case MEM:\n@@ -1379,7 +1375,6 @@ modified_in_p (const_rtx x, const_rtx insn)\n       return 0;\n \n     case PC:\n-    case CC0:\n       return 1;\n \n     case MEM:\n@@ -1917,7 +1912,6 @@ reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n \n     case SCRATCH:\n     case PC:\n-    case CC0:\n       return reg_mentioned_p (x, in);\n \n     case PARALLEL:\n@@ -1943,7 +1937,7 @@ reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n    ignored by note_stores, but passed to FUN.\n \n    FUN receives three arguments:\n-   1. the REG, MEM, CC0 or PC being stored in or clobbered,\n+   1. the REG, MEM or PC being stored in or clobbered,\n    2. the SET or CLOBBER rtx that does the store,\n    3. the pointer DATA provided to note_stores.\n \n@@ -2392,8 +2386,8 @@ vec_rtx_properties_base::grow (ptrdiff_t start)\n }\n \f\n /* Return nonzero if X's old contents don't survive after INSN.\n-   This will be true if X is (cc0) or if X is a register and\n-   X dies in INSN or because INSN entirely sets X.\n+   This will be true if X is a register and X dies in INSN or because\n+   INSN entirely sets X.\n \n    \"Entirely set\" means set directly and not through a SUBREG, or\n    ZERO_EXTRACT, so no trace of the old contents remains.\n@@ -2414,10 +2408,6 @@ dead_or_set_p (const rtx_insn *insn, const_rtx x)\n   unsigned int regno, end_regno;\n   unsigned int i;\n \n-  /* Can't use cc0_rtx below since this file is used by genattrtab.c.  */\n-  if (GET_CODE (x) == CC0)\n-    return 1;\n-\n   gcc_assert (REG_P (x));\n \n   regno = REGNO (x);\n@@ -2717,8 +2707,6 @@ alloc_reg_note (enum reg_note kind, rtx datum, rtx list)\n   gcc_checking_assert (!int_reg_note_p (kind));\n   switch (kind)\n     {\n-    case REG_CC_SETTER:\n-    case REG_CC_USER:\n     case REG_LABEL_TARGET:\n     case REG_LABEL_OPERAND:\n     case REG_TM:\n@@ -2963,7 +2951,6 @@ volatile_insn_p (const_rtx x)\n     case SYMBOL_REF:\n     case CONST:\n     CASE_CONST_ANY:\n-    case CC0:\n     case PC:\n     case REG:\n     case SCRATCH:\n@@ -3024,7 +3011,6 @@ volatile_refs_p (const_rtx x)\n     case SYMBOL_REF:\n     case CONST:\n     CASE_CONST_ANY:\n-    case CC0:\n     case PC:\n     case REG:\n     case SCRATCH:\n@@ -3084,7 +3070,6 @@ side_effects_p (const_rtx x)\n     case SYMBOL_REF:\n     case CONST:\n     CASE_CONST_ANY:\n-    case CC0:\n     case PC:\n     case REG:\n     case SCRATCH:\n@@ -3172,7 +3157,6 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n     case LABEL_REF:\n     case CONST:\n     case PC:\n-    case CC0:\n     case REG:\n     case SCRATCH:\n       return 0;\n@@ -5828,7 +5812,7 @@ seq_cost (const rtx_insn *seq, bool speed)\n    canonical form to simplify testing by callers.  Specifically:\n \n    (1) The code will always be a comparison operation (EQ, NE, GT, etc.).\n-   (2) Both operands will be machine operands; (cc0) will have been replaced.\n+   (2) Both operands will be machine operands.\n    (3) If an operand is a constant, it will be the second operand.\n    (4) (LE x const) will be replaced with (LT x <const+1>) and similarly\n        for GE, GEU, and LEU.\n@@ -5891,22 +5875,6 @@ canonicalize_condition (rtx_insn *insn, rtx cond, int reverse,\n       /* Set nonzero when we find something of interest.  */\n       rtx x = 0;\n \n-      /* If comparison with cc0, import actual comparison from compare\n-\t insn.  */\n-      if (op0 == cc0_rtx)\n-\t{\n-\t  if ((prev = prev_nonnote_insn (prev)) == 0\n-\t      || !NONJUMP_INSN_P (prev)\n-\t      || (set = single_set (prev)) == 0\n-\t      || SET_DEST (set) != cc0_rtx)\n-\t    return 0;\n-\n-\t  op0 = SET_SRC (set);\n-\t  op1 = CONST0_RTX (GET_MODE (op0));\n-\t  if (earliest)\n-\t    *earliest = prev;\n-\t}\n-\n       /* If this is a COMPARE, pick up the two things being compared.  */\n       if (GET_CODE (op0) == COMPARE)\n \t{\n@@ -6095,10 +6063,6 @@ canonicalize_condition (rtx_insn *insn, rtx cond, int reverse,\n \t}\n     }\n \n-  /* Never return CC0; return zero instead.  */\n-  if (CC0_P (op0))\n-    return 0;\n-\n   /* We promised to return a comparison.  */\n   rtx ret = gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n   if (COMPARISON_P (ret))"}, {"sha": "5814204c681bc9d2336c4bcf29d2fcc7b4e6a68b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2579,21 +2579,6 @@ sched_analyze_2 (class deps_desc *deps, rtx x, rtx_insn *insn)\n \n       return;\n \n-    case CC0:\n-      if (!HAVE_cc0)\n-\tgcc_unreachable ();\n-\n-      /* User of CC0 depends on immediately preceding insn.  */\n-      SCHED_GROUP_P (insn) = 1;\n-       /* Don't move CC0 setter to another block (it can set up the\n-        same flag for previous CC0 users which is safe).  */\n-      CANT_MOVE (prev_nonnote_insn (insn)) = 1;\n-\n-      if (cslr_p && sched_deps_info->finish_rhs)\n-\tsched_deps_info->finish_rhs ();\n-\n-      return;\n-\n     case REG:\n       {\n \tint regno = REGNO (x);"}, {"sha": "d1ccec5a6c28e69360b2ea63d1854ee0a27fa088", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2442,7 +2442,7 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n {\n   rtx_insn *insn, *last;\n \n-  /* For all branches, calls, uses, clobbers, cc0 setters, and instructions\n+  /* For all branches, calls, uses, clobbers, and instructions\n      that can throw exceptions, force them to remain in order at the end of\n      the block by adding dependencies and giving the last a high priority.\n      There may be notes present, and prev_head may also be a note.\n@@ -2451,9 +2451,6 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n      end since moving them results in worse register allocation.  Uses remain\n      at the end to ensure proper register allocation.\n \n-     cc0 setters remain at the end because they can't be moved away from\n-     their cc0 user.\n-\n      Predecessors of SCHED_GROUP_P instructions at the end remain at the end.\n \n      COND_EXEC insns cannot be moved past a branch (see e.g. PR17808).\n@@ -2473,7 +2470,6 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t || can_throw_internal (insn)\n-\t\t || (HAVE_cc0 && sets_cc0_p (PATTERN (insn)))\n \t\t || (!reload_completed\n \t\t     && sets_likely_spilled (PATTERN (insn)))))\n \t || NOTE_P (insn)"}, {"sha": "ba7b5cd56fd6e003f6b7a08b12a8a84ab564c8c6", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1772,9 +1772,6 @@ insert_prologue_epilogue_for_components (sbitmap components)\n void\n try_shrink_wrapping_separate (basic_block first_bb)\n {\n-  if (HAVE_cc0)\n-    return;\n-\n   if (!(SHRINK_WRAPPING_ENABLED\n \t&& flag_shrink_wrap_separate\n \t&& optimize_function_for_speed_p (cfun)"}, {"sha": "04423bbd1952f9dfcac4323e08ca5330759c57e0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2713,15 +2713,12 @@ simplify_context::simplify_binary_operation_1 (rtx_code code,\n \t  rtx xop00 = XEXP (op0, 0);\n \t  rtx xop10 = XEXP (op1, 0);\n \n-\t  if (GET_CODE (xop00) == CC0 && GET_CODE (xop10) == CC0)\n-\t      return xop00;\n-\n-\t    if (REG_P (xop00) && REG_P (xop10)\n-\t\t&& REGNO (xop00) == REGNO (xop10)\n-\t\t&& GET_MODE (xop00) == mode\n-\t\t&& GET_MODE (xop10) == mode\n-\t\t&& GET_MODE_CLASS (mode) == MODE_CC)\n-\t      return xop00;\n+\t  if (REG_P (xop00) && REG_P (xop10)\n+\t      && REGNO (xop00) == REGNO (xop10)\n+\t      && GET_MODE (xop00) == mode\n+\t      && GET_MODE (xop10) == mode\n+\t      && GET_MODE_CLASS (mode) == MODE_CC)\n+\t    return xop00;\n \t}\n       break;\n \n@@ -5374,8 +5371,7 @@ simplify_context::simplify_relational_operation (rtx_code code,\n     return simplify_gen_relational (code, mode, VOIDmode,\n \t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n \n-  if (GET_MODE_CLASS (cmp_mode) == MODE_CC\n-      || CC0_P (op0))\n+  if (GET_MODE_CLASS (cmp_mode) == MODE_CC)\n     return NULL_RTX;\n \n   trueop0 = avoid_constant_pool_reference (op0);\n@@ -5742,7 +5738,7 @@ simplify_const_relational_operation (enum rtx_code code,\n \n   /* We can't simplify MODE_CC values since we don't know what the\n      actual comparison is.  */\n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC || CC0_P (op0))\n+  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n     return 0;\n \n   /* Make sure the constant is second.  */"}, {"sha": "95e5430ce450c5575c50fab8207f3e41ae77bba0", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -1069,7 +1069,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tLIBGCC2_LONG_DOUBLE_TYPE_SIZE STRUCT_VALUE\t\t\t   \\\n \tEH_FRAME_IN_DATA_SECTION TARGET_FLT_EVAL_METHOD_NON_DEFAULT\t   \\\n \tJCR_SECTION_NAME TARGET_USE_JCR_SECTION SDB_DEBUGGING_INFO\t   \\\n-\tSDB_DEBUG NO_IMPLICIT_EXTERN_C\n+\tSDB_DEBUG NO_IMPLICIT_EXTERN_C NOTICE_UPDATE_CC\t\t\t   \\\n+\tCC_STATUS_MDEP_INIT CC_STATUS_MDEP CC_STATUS\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "a902a50755b09422555693fd227f176fbf1054f4", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -3996,7 +3996,7 @@ filling in a single size corresponding to each hard register;\\n\\\n    at by the second argument should be set to -1.  */\n DEFHOOK\n (fixed_condition_code_regs,\n- \"On targets which do not use @code{(cc0)}, and which use a hard\\n\\\n+ \"On targets which use a hard\\n\\\n register rather than a pseudo-register to hold condition codes, the\\n\\\n regular CSE passes are often not able to identify cases in which the\\n\\\n hard register is set to a common value.  Use this hook to enable a\\n\\"}, {"sha": "027d883044a584a88fb3866666e3b999af956ea8", "filename": "gcc/valtrack.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -68,12 +68,11 @@ cleanup_auto_inc_dec (rtx src, machine_mode mem_mode ATTRIBUTE_UNUSED)\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n-    case CC0:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return x;\n     case CLOBBER:\n-      /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n+      /* Share clobbers of hard registers, but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n       if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER"}, {"sha": "26365a7e436d53df226b4ad0d164a666b6a86ca4", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd1cd0d0e0fecc6ac8632c266591767392480746/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=bd1cd0d0e0fecc6ac8632c266591767392480746", "patch": "@@ -2450,7 +2450,6 @@ unsuitable_loc (rtx loc)\n     {\n     case PC:\n     case SCRATCH:\n-    case CC0:\n     case ASM_INPUT:\n     case ASM_OPERANDS:\n       return true;\n@@ -5661,7 +5660,6 @@ non_suitable_const (const_rtx x)\n \tcase DEBUG_EXPR:\n \tcase PC:\n \tcase SCRATCH:\n-\tcase CC0:\n \tcase ASM_INPUT:\n \tcase ASM_OPERANDS:\n \t  return true;"}]}