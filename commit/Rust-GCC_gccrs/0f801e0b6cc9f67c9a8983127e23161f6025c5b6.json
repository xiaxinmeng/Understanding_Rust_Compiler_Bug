{"sha": "0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4MDFlMGI2Y2M5ZjY3YzlhODk4MzEyN2UyMzE2MWY2MDI1YzViNg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-10-27T16:30:31Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-10-27T16:59:12Z"}, "message": "AArch64: Fix overflow in memcopy expansion on aarch64.\n\nCurrently the inline memcpy expansion code for AArch64 is using a signed int\nto hold the number of elements to copy.  When you giver give it a value larger\nthan INT_MAX it will overflow.\n\nThe overflow causes the maximum number of instructions we want to expand to\ncheck to fail since this assumes an unsigned number.\n\nThis patch changes the maximum isns arithmetic to be unsigned HOST_WIDE_INT.\n\nnote that the calculation *must* remained signed as the memcopy issues\noverlapping unaligned copies.  This means the pointer must be moved back and\nso you need signed arithmetic.\n\ngcc/ChangeLog:\n\n\tPR target/97535\n\t* config/aarch64/aarch64.c (aarch64_expand_cpymem): Use unsigned\n\tarithmetic in check.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/97535\n\t* gcc.target/aarch64/pr97535.c: New test.", "tree": {"sha": "d2db0ba0a2b09c0067459200b9c9103e10dc964e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2db0ba0a2b09c0067459200b9c9103e10dc964e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f801e0b6cc9f67c9a8983127e23161f6025c5b6/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb8dcac6ed265d9da2d1971ff5a47e04fbf9fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eb8dcac6ed265d9da2d1971ff5a47e04fbf9fb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eb8dcac6ed265d9da2d1971ff5a47e04fbf9fb5"}], "stats": {"total": 29, "additions": 25, "deletions": 4}, "files": [{"sha": "35d6f2e2f017206eb73dc4091f1a15506d3563ab", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f801e0b6cc9f67c9a8983127e23161f6025c5b6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f801e0b6cc9f67c9a8983127e23161f6025c5b6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "patch": "@@ -21299,6 +21299,8 @@ aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,\n bool\n aarch64_expand_cpymem (rtx *operands)\n {\n+  /* These need to be signed as we need to perform arithmetic on n as\n+     signed operations.  */\n   int n, mode_bits;\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -21309,21 +21311,24 @@ aarch64_expand_cpymem (rtx *operands)\n   /* When optimizing for size, give a better estimate of the length of a\n      memcpy call, but use the default otherwise.  Moves larger than 8 bytes\n      will always require an even number of instructions to do now.  And each\n-     operation requires both a load+store, so devide the max number by 2.  */\n-  int max_num_moves = (speed_p ? 16 : AARCH64_CALL_RATIO) / 2;\n+     operation requires both a load+store, so divide the max number by 2.  */\n+  unsigned int max_num_moves = (speed_p ? 16 : AARCH64_CALL_RATIO) / 2;\n \n   /* We can't do anything smart if the amount to copy is not constant.  */\n   if (!CONST_INT_P (operands[2]))\n     return false;\n \n-  n = INTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT tmp = INTVAL (operands[2]);\n \n   /* Try to keep the number of instructions low.  For all cases we will do at\n      most two moves for the residual amount, since we'll always overlap the\n      remainder.  */\n-  if (((n / 16) + (n % 16 ? 2 : 0)) > max_num_moves)\n+  if (((tmp / 16) + (tmp % 16 ? 2 : 0)) > max_num_moves)\n     return false;\n \n+  /* At this point tmp is known to have to fit inside an int.  */\n+  n = tmp;\n+\n   base = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n "}, {"sha": "6f83b3f571413577180682c18400d913bb13124d", "filename": "gcc/testsuite/gcc.target/aarch64/pr97535.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f801e0b6cc9f67c9a8983127e23161f6025c5b6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr97535.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f801e0b6cc9f67c9a8983127e23161f6025c5b6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr97535.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr97535.c?ref=0f801e0b6cc9f67c9a8983127e23161f6025c5b6", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+\n+#include <string.h>\n+\n+#define SIZE 2181038080\n+\n+extern char raw_buffer[SIZE];\n+\n+void setRaw(const void *raw)\n+{\n+        memcpy(raw_buffer, raw, SIZE);\n+}\n+\n+/* At any optimization level this should be a function call\n+   and not inlined.  */\n+/* { dg-final { scan-assembler \"bl\\tmemcpy\" } } */"}]}