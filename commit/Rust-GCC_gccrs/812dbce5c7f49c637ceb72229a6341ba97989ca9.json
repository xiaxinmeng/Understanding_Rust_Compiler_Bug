{"sha": "812dbce5c7f49c637ceb72229a6341ba97989ca9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyZGJjZTVjN2Y0OWM2MzdjZWI3MjIyOWE2MzQxYmE5Nzk4OWNhOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-21T12:39:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-21T12:39:35Z"}, "message": "Backport from LTO branch:\n\n\t2008-05-05  Kenneth Zadeck <zadeck@naturalbridge.com>\n\t\t    Jan Hubicka  <jh@suse.cz>\n\t\n\t* ipa-pure-const.c\n\t(init_state, finish_state, set_function_state, generate_summary):\n\tNew functions.\n\t(scan_stmt): Renamed from scan_function.  Changed to keep state in\n\tlocal static vars rather than cgraph aux field.\n\t(propagate): Renamed from static_execute. Changed to keep state in\n\tlocal static vars rather than cgraph aux field.\n\t(pass_ipa_pure_const): Changed from SIMPLE_IPA_PASS to IPA_PASS.\n\t* tree-pass.h (pass_ipa_pure_const): Turn into IPA_PASS.\n\n\t2008-07-15  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* tree-pass.h (pass_ipa_reference): Make into ipa_opt_pass.\n\t* ipa-reference.c (init_function_info, generate_summary, \n\tpropagate): New functions.\n\t(analyze_function):  Call init_function_info.\n\t(static_execute): Stripped into generate_summary and propagate.\n\t(pass_ipa_reference): Made into ipa_opt_pass.\n\nFrom-SVN: r139378", "tree": {"sha": "1e0757ed3e2361b67a6c5193b290e905111f925c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e0757ed3e2361b67a6c5193b290e905111f925c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/812dbce5c7f49c637ceb72229a6341ba97989ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812dbce5c7f49c637ceb72229a6341ba97989ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812dbce5c7f49c637ceb72229a6341ba97989ca9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812dbce5c7f49c637ceb72229a6341ba97989ca9/comments", "author": null, "committer": null, "parents": [{"sha": "0ac7d78a68d44f35a8a8ffae506a87a9cfab3022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac7d78a68d44f35a8a8ffae506a87a9cfab3022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac7d78a68d44f35a8a8ffae506a87a9cfab3022"}], "stats": {"total": 475, "additions": 297, "deletions": 178}, "files": [{"sha": "d766455c9bdc24fb471c122019de13d5233025da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=812dbce5c7f49c637ceb72229a6341ba97989ca9", "patch": "@@ -1,3 +1,28 @@\n+2008-08-21  Jan Hubicka  <jh@suse.cz>\n+\tBackport from LTO branch:\n+\n+\t2008-05-05  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\t\t    Jan Hubicka  <jh@suse.cz>\n+\t\n+\t* ipa-pure-const.c\n+\t(init_state, finish_state, set_function_state, generate_summary):\n+\tNew functions.\n+\t(scan_stmt): Renamed from scan_function.  Changed to keep state in\n+\tlocal static vars rather than cgraph aux field.\n+\t(propagate): Renamed from static_execute. Changed to keep state in\n+\tlocal static vars rather than cgraph aux field.\n+\t(pass_ipa_pure_const): Changed from SIMPLE_IPA_PASS to IPA_PASS.\n+\t* tree-pass.h (pass_ipa_pure_const): Turn into IPA_PASS.\n+\n+\t2008-07-15  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* tree-pass.h (pass_ipa_reference): Make into ipa_opt_pass.\n+\t* ipa-reference.c (init_function_info, generate_summary, \n+\tpropagate): New functions.\n+\t(analyze_function):  Call init_function_info.\n+\t(static_execute): Stripped into generate_summary and propagate.\n+\t(pass_ipa_reference): Made into ipa_opt_pass.\n+\n 2008-08-21  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37181"}, {"sha": "6edd1657c67c5c6d91f424afadd4b6d338792d88", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 104, "deletions": 38, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=812dbce5c7f49c637ceb72229a6341ba97989ca9", "patch": "@@ -65,24 +65,70 @@ enum pure_const_state_e\n   IPA_NEITHER\n };\n \n-/* Holder inserted into the ipa_dfs_info aux field to hold the\n-   const_state.  */\n+/* Holder for the const_state.  There is one of these per function\n+   decl.  */\n struct funct_state_d \n {\n+  /* See above.  */\n   enum pure_const_state_e pure_const_state;\n+\n+  /* True if the function could possibly infinite loop.  There are a\n+     lot of ways that this could be determined.  We are pretty\n+     conservative here.  While it is possible to cse pure and const\n+     calls, it is not legal to have dce get rid of the call if there\n+     is a possibility that the call could infinite loop since this is\n+     a behavioral change.  */\n   bool looping;\n-  bool state_set_in_source;\n+\n+  /* If the state of the function was set in the source, then assume\n+     that it was done properly even if the analysis we do would be\n+     more pessimestic.  */\n+  bool state_set_in_source; \n };\n \n typedef struct funct_state_d * funct_state;\n \n+/* The storage of the funct_state is abstracted because there is the\n+   possibility that it may be desirable to move this to the cgraph\n+   local info.  */ \n+\n+/* Array, indexed by cgraph node uid, of function states.  */\n+\n+static funct_state *funct_state_vec;\n+\n+\n+/* Init the function state.  */\n+\n+static void \n+init_state (void)\n+{\n+  funct_state_vec = XCNEWVEC (funct_state, cgraph_max_uid);\n+}\n+\n+\n+/* Init the function state.  */\n+\n+static void\n+finish_state (void)\n+{\n+  free (funct_state_vec);\n+}\n+\n+\n /* Return the function state from NODE.  */ \n \n static inline funct_state\n get_function_state (struct cgraph_node *node)\n {\n-  struct ipa_dfs_info * info = (struct ipa_dfs_info *) node->aux;\n-  return (funct_state) info->aux;\n+  return funct_state_vec[node->uid];\n+}\n+\n+/* Set the function state S for NODE.  */\n+\n+static inline void\n+set_function_state (struct cgraph_node *node, funct_state s)\n+{\n+  funct_state_vec[node->uid] = s;\n }\n \n /* Check to see if the use (or definition when CHECKING_WRITE is true)\n@@ -527,17 +573,17 @@ scan_function_stmt (gimple_stmt_iterator *gsi_p,\n   return NULL;\n }\n \n+\n /* This is the main routine for finding the reference patterns for\n    global variables within a function FN.  */\n \n static void\n analyze_function (struct cgraph_node *fn)\n {\n-  funct_state l = XCNEW (struct funct_state_d);\n   tree decl = fn->decl;\n-  struct ipa_dfs_info * w_info = (struct ipa_dfs_info *) fn->aux;\n+  funct_state l = XCNEW (struct funct_state_d);\n \n-  w_info->aux = l;\n+  set_function_state (fn, l);\n \n   l->pure_const_state = IPA_CONST;\n   l->state_set_in_source = false;\n@@ -632,24 +678,15 @@ analyze_function (struct cgraph_node *fn)\n }\n \n \f\n-/* Produce the global information by preforming a transitive closure\n-   on the local information that was produced by ipa_analyze_function\n-   and ipa_analyze_variable.  */\n+/* Analyze each function in the cgraph to see if it is locally PURE or\n+   CONST.  */\n \n-static unsigned int\n-static_execute (void)\n+static void \n+generate_summary (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_node *w;\n-  struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int order_pos = ipa_utils_reduced_inorder (order, true, false);\n-  int i;\n-  struct ipa_dfs_info * w_info;\n-\n-  if (!memory_identifier_string)\n-    memory_identifier_string = build_string(7, \"memory\");\n \n+  init_state ();\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n@@ -670,6 +707,25 @@ static_execute (void)\n \n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n+}\n+\n+/* Produce the global information by preforming a transitive closure\n+   on the local information that was produced by generate_summary.\n+   Note that there is no function_transform pass since this only\n+   updates the function_decl.  */\n+\n+static unsigned int\n+propagate (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node *w;\n+  struct cgraph_node **order =\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  int order_pos;\n+  int i;\n+  struct ipa_dfs_info * w_info;\n+\n+  order_pos = ipa_utils_reduced_inorder (order, true, false);\n   if (dump_file)\n     {\n       dump_cgraph (dump_file);\n@@ -744,6 +800,8 @@ static_execute (void)\n \t  if (!w_l->state_set_in_source)\n \t    {\n \t      w_l->pure_const_state = pure_const_state;\n+\t      w_l->looping = looping;\n+\n \t      switch (pure_const_state)\n \t\t{\n \t\tcase IPA_CONST:\n@@ -775,17 +833,20 @@ static_execute (void)\n \n   /* Cleanup. */\n   for (node = cgraph_nodes; node; node = node->next)\n-    /* Get rid of the aux information.  */\n-    if (node->aux)\n-      {\n-\tw_info = (struct ipa_dfs_info *) node->aux;\n-\tif (w_info->aux)\n-\t  free (w_info->aux);\n-\tfree (node->aux);\n-\tnode->aux = NULL;\n-      }\n-\n+    {\n+      /* Get rid of the aux information.  */\n+      if (node->aux)\n+\t{\n+\t  w_info = (struct ipa_dfs_info *) node->aux;\n+\t  free (node->aux);\n+\t  node->aux = NULL;\n+\t}\n+      if (node->analyzed && cgraph_is_master_clone (node))\n+\tfree (get_function_state (node));\n+    }\n+  \n   free (order);\n+  finish_state ();\n   return 0;\n }\n \n@@ -797,13 +858,13 @@ gate_pure_const (void)\n \t  && !(errorcount || sorrycount));\n }\n \n-struct simple_ipa_opt_pass pass_ipa_pure_const =\n+struct ipa_opt_pass pass_ipa_pure_const =\n {\n  {\n-  SIMPLE_IPA_PASS,\n+  IPA_PASS,\n   \"pure-const\",\t\t                /* name */\n   gate_pure_const,\t\t\t/* gate */\n-  static_execute,\t\t\t/* execute */\n+  propagate,\t\t\t        /* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -813,7 +874,12 @@ struct simple_ipa_opt_pass pass_ipa_pure_const =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   0                                     /* todo_flags_finish */\n- }\n+ },\n+ generate_summary,\t\t        /* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n };\n-\n-"}, {"sha": "08bed82ec90eb448ebcd832a1ada5306a5039643", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 166, "deletions": 138, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=812dbce5c7f49c637ceb72229a6341ba97989ca9", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph based analysis of static variables.\n-   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -642,7 +642,8 @@ propagate_bits (struct cgraph_node *x)\n \t{\n \t  if (get_reference_vars_info_from_cgraph (y))\n \t    {\n-\t      ipa_reference_vars_info_t y_info = get_reference_vars_info_from_cgraph (y);\n+\t      ipa_reference_vars_info_t y_info \n+\t\t= get_reference_vars_info_from_cgraph (y);\n \t      ipa_reference_global_vars_info_t y_global = y_info->global;\n \t      \n \t      if (x_global->statics_read\n@@ -798,63 +799,71 @@ analyze_variable (struct varpool_node *vnode)\n              &wi, wi.pset);\n }\n \n-/* This is the main routine for finding the reference patterns for\n-   global variables within a function FN.  */\n+/* Set up the persistent info for FN.  */\n \n-static void\n-analyze_function (struct cgraph_node *fn)\n+static ipa_reference_local_vars_info_t\n+init_function_info (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info \n     = XCNEW (struct ipa_reference_vars_info_d);\n   ipa_reference_local_vars_info_t l\n     = XCNEW (struct ipa_reference_local_vars_info_d);\n   tree decl = fn->decl;\n-  struct walk_stmt_info wi;\n \n   /* Add the info to the tree's annotation.  */\n-  get_function_ann (fn->decl)->reference_vars_info = info;\n+  get_function_ann (decl)->reference_vars_info = info;\n \n   info->local = l;\n   l->statics_read = BITMAP_ALLOC (&ipa_obstack);\n   l->statics_written = BITMAP_ALLOC (&ipa_obstack);\n \n+  return l;\n+}\n+\n+/* This is the main routine for finding the reference patterns for\n+   global variables within a function FN.  */\n+  \n+static void\n+analyze_function (struct cgraph_node *fn)\n+{\n+  ipa_reference_local_vars_info_t l = init_function_info (fn);\n+  tree decl = fn->decl;\n+  struct walk_stmt_info wi;\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n+  basic_block this_block;\n+\n   if (dump_file)\n     fprintf (dump_file, \"\\n local analysis of %s\\n\", cgraph_node_name (fn));\n   \n-  {\n-    struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n-    basic_block this_block;\n-\n-    FOR_EACH_BB_FN (this_block, this_cfun)\n-      {\n-\tgimple_stmt_iterator gsi;\n-\tgimple phi;\n-\ttree op;\n-\tuse_operand_p use;\n-\tssa_op_iter iter;\n-\n-\t/* Find the addresses taken in phi node arguments.  */\n-\tfor (gsi = gsi_start_phis (this_block);\n-\t     !gsi_end_p (gsi);\n-\t     gsi_next (&gsi))\n-\t  {\n-\t    phi = gsi_stmt (gsi);\n-\t    FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n-\t      {\n-\t\top = USE_FROM_PTR (use);\n-\t\tif (TREE_CODE (op) == ADDR_EXPR)\n-\t\t  check_rhs_var (l, op);\n-\t      }\n-\t  }\n+  FOR_EACH_BB_FN (this_block, this_cfun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      gimple phi;\n+      tree op;\n+      use_operand_p use;\n+      ssa_op_iter iter;\n+\n+      /* Find the addresses taken in phi node arguments.  */\n+      for (gsi = gsi_start_phis (this_block);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  phi = gsi_stmt (gsi);\n+\t  FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n+\t    {\n+\t      op = USE_FROM_PTR (use);\n+\t      if (TREE_CODE (op) == ADDR_EXPR)\n+\t\tcheck_rhs_var (l, op);\n+\t    }\n+\t}\n \n-\tmemset (&wi, 0, sizeof (wi));\n-\twi.info = fn;\n-\twi.pset = visited_nodes;\n-\tfor (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  walk_gimple_stmt (&gsi, scan_stmt_for_static_refs,\n-\t\t\t    scan_op_for_static_refs, &wi);\n-      }\n-  }\n+      memset (&wi, 0, sizeof (wi));\n+      wi.info = fn;\n+      wi.pset = visited_nodes;\n+      for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n+\twalk_gimple_stmt (&gsi, scan_stmt_for_static_refs,\n+\t\t\t  scan_op_for_static_refs, &wi);\n+    }\n \n   /* There may be const decls with interesting right hand sides.  */\n   if (DECL_STRUCT_FUNCTION (decl))\n@@ -921,29 +930,28 @@ clean_function (struct cgraph_node *fn)\n \tBITMAP_FREE (g->statics_not_written);\n       free (g);\n     }\n-\n   \n   free (get_function_ann (fn->decl)->reference_vars_info);\n   get_function_ann (fn->decl)->reference_vars_info = NULL;\n }\n \n-\f\n-/* Produce the global information by preforming a transitive closure\n-   on the local information that was produced by ipa_analyze_function\n-   and ipa_analyze_variable.  */\n \n-static unsigned int\n-static_execute (void)\n+/* Analyze each function in the cgraph to see which global or statics\n+   are read or written.  */\n+\n+static void \n+generate_summary (void)\n {\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n-  struct cgraph_node *w;\n-  struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int order_pos = ipa_utils_reduced_inorder (order, false, true);\n-  int i;\n-\n+  unsigned int index;\n+  bitmap_iterator bi;\n+  bitmap module_statics_readonly;\n+  bitmap bm_temp;\n+  \n   ipa_init ();\n+  module_statics_readonly = BITMAP_ALLOC (&ipa_obstack);\n+  bm_temp = BITMAP_ALLOC (&ipa_obstack);\n \n   /* Process all of the variables first.  */\n   FOR_EACH_STATIC_INITIALIZER (vnode)\n@@ -969,105 +977,101 @@ static_execute (void)\n \n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n-  if (dump_file) \n-    dump_cgraph (dump_file);\n \n   /* Prune out the variables that were found to behave badly\n      (i.e. have their address taken).  */\n-  {\n-    unsigned int index;\n-    bitmap_iterator bi;\n-    bitmap module_statics_readonly = BITMAP_ALLOC (&ipa_obstack);\n-    bitmap bm_temp = BITMAP_ALLOC (&ipa_obstack);\n-\n-    EXECUTE_IF_SET_IN_BITMAP (module_statics_escape, 0, index, bi)\n-      {\n-\tsplay_tree_remove (reference_vars_to_consider, index);\n-      }\n-\n-    bitmap_and_compl_into (all_module_statics, \n-\t\t\t   module_statics_escape);\n-\n-    bitmap_and_compl (module_statics_readonly, all_module_statics,\n-\t\t      module_statics_written);\n-\n-    /* If the address is not taken, we can unset the addressable bit\n-       on this variable.  */\n+  EXECUTE_IF_SET_IN_BITMAP (module_statics_escape, 0, index, bi)\n+    {\n+      splay_tree_remove (reference_vars_to_consider, index);\n+    }\n+  \n+  bitmap_and_compl_into (all_module_statics, \n+\t\t\t module_statics_escape);\n+  \n+  bitmap_and_compl (module_statics_readonly, all_module_statics,\n+\t\t    module_statics_written);\n+  \n+  /* If the address is not taken, we can unset the addressable bit\n+     on this variable.  */\n+  EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n+    {\n+      tree var = get_static_decl (index);\n+      TREE_ADDRESSABLE (var) = 0;\n+      if (dump_file) \n+\tfprintf (dump_file, \"Not TREE_ADDRESSABLE var %s\\n\",\n+\t\t get_static_name (index));\n+    }\n+  \n+  /* If the variable is never written, we can set the TREE_READONLY\n+     flag.  Additionally if it has a DECL_INITIAL that is made up of\n+     constants we can treat the entire global as a constant.  */\n+  \n+  bitmap_and_compl (module_statics_readonly, all_module_statics,\n+\t\t    module_statics_written);\n+  EXECUTE_IF_SET_IN_BITMAP (module_statics_readonly, 0, index, bi)\n+    {\n+      tree var = get_static_decl (index);\n+      \n+      /* Readonly on a function decl is very different from the\n+\t variable.  */\n+      if (TREE_CODE (var) == FUNCTION_DECL)\n+\tcontinue;\n+      \n+      /* Ignore variables in named sections - changing TREE_READONLY\n+\t changes the section flags, potentially causing conflicts with\n+\t other variables in the same named section.  */\n+      if (DECL_SECTION_NAME (var) == NULL_TREE)\n+\t{\n+\t  TREE_READONLY (var) = 1;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"read-only var %s\\n\", \n+\t\t     get_static_name (index));\n+\t}\n+    }\n+  \n+  BITMAP_FREE(module_statics_escape);\n+  BITMAP_FREE(module_statics_written);\n+  \n+  if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n       {\n-\ttree var = get_static_decl (index);\n- \tTREE_ADDRESSABLE (var) = 0;\n-\tif (dump_file) \n-\t  fprintf (dump_file, \"Not TREE_ADDRESSABLE var %s\\n\",\n-\t\t   get_static_name (index));\n+\tfprintf (dump_file, \"\\nPromotable global:%s\",\n+\t\t get_static_name (index));\n       }\n-\n-    /* If the variable is never written, we can set the TREE_READONLY\n-       flag.  Additionally if it has a DECL_INITIAL that is made up of\n-       constants we can treat the entire global as a constant.  */\n-\n-    bitmap_and_compl (module_statics_readonly, all_module_statics,\n-\t\t      module_statics_written);\n-    EXECUTE_IF_SET_IN_BITMAP (module_statics_readonly, 0, index, bi)\n-      {\n-\ttree var = get_static_decl (index);\n-\n-\t/* Readonly on a function decl is very different from the\n-\t   variable.  */\n-\tif (TREE_CODE (var) == FUNCTION_DECL)\n-\t  continue;\n-\n-\t/* Ignore variables in named sections - changing TREE_READONLY\n-\t   changes the section flags, potentially causing conflicts with\n-\t   other variables in the same named section.  */\n-\tif (DECL_SECTION_NAME (var) == NULL_TREE)\n-\t  {\n-\t    TREE_READONLY (var) = 1;\n-\t    if (dump_file)\n-\t      fprintf (dump_file, \"read-only var %s\\n\", \n-\t\t       get_static_name (index));\n-\t  }\n-      }\n-\n-    BITMAP_FREE(module_statics_escape);\n-    BITMAP_FREE(module_statics_written);\n-\n-    if (dump_file)\n-      EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n-\t{\n-\t  fprintf (dump_file, \"\\nPromotable global:%s\",\n-\t\t   get_static_name (index));\n-\t}\n-\n-    for (i = 0; i < order_pos; i++ )\n+  \n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed \n+\t&& (cgraph_is_master_clone (node)\n+\t    || (cgraph_function_body_availability (node) \n+\t\t== AVAIL_OVERWRITABLE)))\n       {\n \tipa_reference_local_vars_info_t l;\n-\tnode = order[i];\n \tl = get_reference_vars_info_from_cgraph (node)->local;\n-\n+\t\n \t/* Any variables that are not in all_module_statics are\n \t   removed from the local maps.  This will include all of the\n \t   variables that were found to escape in the function\n \t   scanning.  */\n \tbitmap_and_into (l->statics_read, \n-\t\t         all_module_statics);\n+\t\t\t all_module_statics);\n \tbitmap_and_into (l->statics_written, \n-\t\t         all_module_statics);\n+\t\t\t all_module_statics);\n       }\n-\n-    BITMAP_FREE(module_statics_readonly);\n-    BITMAP_FREE(bm_temp);\n-  }\n-\n+  \n+  BITMAP_FREE(module_statics_readonly);\n+  BITMAP_FREE(bm_temp);\n+  \n   if (dump_file)\n-    {\n-      for (i = 0; i < order_pos; i++ )\n+    for (node = cgraph_nodes; node; node = node->next)\n+      if (node->analyzed \n+\t  && (cgraph_is_master_clone (node)\n+\t      || (cgraph_function_body_availability (node) \n+\t\t  == AVAIL_OVERWRITABLE)))\n \t{\n-\t  unsigned int index;\n \t  ipa_reference_local_vars_info_t l;\n+\t  unsigned int index;\n \t  bitmap_iterator bi;\n-\n-\t  node = order[i];\n+\t  \n \t  l = get_reference_vars_info_from_cgraph (node)->local;\n \t  fprintf (dump_file, \n \t\t   \"\\nFunction name:%s/%i:\", \n@@ -1087,7 +1091,24 @@ static_execute (void)\n \t\t      get_static_name (index));\n \t    }\n \t}\n-    }\n+}\n+\f\n+/* Produce the global information by preforming a transitive closure\n+   on the local information that was produced by ipa_analyze_function\n+   and ipa_analyze_variable.  */\n+\n+static unsigned int\n+propagate (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node *w;\n+  struct cgraph_node **order =\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  int order_pos = ipa_utils_reduced_inorder (order, false, true);\n+  int i;\n+\n+  if (dump_file) \n+    dump_cgraph (dump_file);\n \n   /* Propagate the local information thru the call graph to produce\n      the global information.  All the nodes within a cycle will have\n@@ -1348,13 +1369,13 @@ gate_reference (void)\n \t  && !(errorcount || sorrycount));\n }\n \n-struct simple_ipa_opt_pass pass_ipa_reference =\n+struct ipa_opt_pass pass_ipa_reference =\n {\n  {\n-  SIMPLE_IPA_PASS,\n+  IPA_PASS,\n   \"static-var\",\t\t\t\t/* name */\n   gate_reference,\t\t\t/* gate */\n-  static_execute,\t\t\t/* execute */\n+  propagate,\t\t\t        /* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1364,7 +1385,14 @@ struct simple_ipa_opt_pass pass_ipa_reference =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   0                                     /* todo_flags_finish */\n- }\n+ },\n+ generate_summary,\t\t        /* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t                /* function_transform */\n+ NULL\t\t\t\t\t/* variable_transform */\n };\n \n #include \"gt-ipa-reference.h\""}, {"sha": "b7cd0ee142e743f15492e5c02bc054af667b94b5", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812dbce5c7f49c637ceb72229a6341ba97989ca9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=812dbce5c7f49c637ceb72229a6341ba97989ca9", "patch": "@@ -390,12 +390,12 @@ extern struct gimple_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */\n extern struct ipa_opt_pass pass_ipa_inline;\n-extern struct simple_ipa_opt_pass pass_ipa_reference;\n+extern struct ipa_opt_pass pass_ipa_reference;\n+extern struct ipa_opt_pass pass_ipa_pure_const;\n \n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n extern struct simple_ipa_opt_pass pass_ipa_cp;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n-extern struct simple_ipa_opt_pass pass_ipa_pure_const;\n extern struct simple_ipa_opt_pass pass_ipa_type_escape;\n extern struct simple_ipa_opt_pass pass_ipa_pta;\n extern struct simple_ipa_opt_pass pass_ipa_struct_reorg;"}]}