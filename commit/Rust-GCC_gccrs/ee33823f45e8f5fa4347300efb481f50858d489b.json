{"sha": "ee33823f45e8f5fa4347300efb481f50858d489b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUzMzgyM2Y0NWU4ZjVmYTQzNDczMDBlZmI0ODFmNTA4NThkNDg5Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T23:09:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-25T23:09:01Z"}, "message": "(expand_builtin_apply_args): If STACK_REGS is defined...\n\n(expand_builtin_apply_args): If STACK_REGS is defined, generate USE\ninsns before the function body, thus showing which registers are\nfilled with parameters.\nReverse order of saving registers, more compact code for i387.\n(expand_builtin_apply): Likewise.\n\nFrom-SVN: r9462", "tree": {"sha": "63648aa101e5be14d9b572542cac6a2ceb7e306a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63648aa101e5be14d9b572542cac6a2ceb7e306a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee33823f45e8f5fa4347300efb481f50858d489b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee33823f45e8f5fa4347300efb481f50858d489b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee33823f45e8f5fa4347300efb481f50858d489b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee33823f45e8f5fa4347300efb481f50858d489b/comments", "author": null, "committer": null, "parents": [{"sha": "9dc0f531444e86626bd6ede1d14aa8d0131eca1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc0f531444e86626bd6ede1d14aa8d0131eca1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc0f531444e86626bd6ede1d14aa8d0131eca1c"}], "stats": {"total": 30, "additions": 25, "deletions": 5}, "files": [{"sha": "e9b20129cd0387b59962d3ba56ae7964e8c2f62a", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee33823f45e8f5fa4347300efb481f50858d489b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee33823f45e8f5fa4347300efb481f50858d489b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ee33823f45e8f5fa4347300efb481f50858d489b", "patch": "@@ -8117,17 +8117,35 @@ expand_builtin_apply_args ()\n   if (struct_value_rtx)\n     size += GET_MODE_SIZE (Pmode);\n \n-  /* Save each register used in calling a function to the block.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+  /* Save each register used in calling a function to the block.\n+     Doing this in reverse order makes for much more compact code\n+     for i386 and family.  If we do this in reverse order, a simple\n+     series of pops and stores will be generated.  If we do this\n+     in ascending order, the pops and stores will be littered with\n+     stack swaps as well.  Since the order is largely irrelevant for\n+     all other architectures, we use the optimal order for the i386.  */\n+  for (regno = FIRST_PSEUDO_REGISTER; regno--;)\n     if ((mode = apply_args_mode[regno]) != VOIDmode)\n       {\n+\trtx tem;\n+\n \talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n+\n+\ttem = gen_rtx (REG, mode, INCOMING_REGNO (regno));\n+\n+#ifdef STACK_REGS\n+        /* For reg-stack.c's stack register household.\n+\t   Compare with a similar piece of code in function.c.  */\n+\n+        emit_insn (gen_rtx (USE, mode, tem));\n+#endif\n+\n \temit_move_insn (change_address (registers, mode,\n \t\t\t\t\tplus_constant (XEXP (registers, 0),\n \t\t\t\t\t\t       size)),\n-\t\t\tgen_rtx (REG, mode, INCOMING_REGNO (regno)));\n+\t\t\ttem);\n \tsize += GET_MODE_SIZE (mode);\n       }\n \n@@ -8206,8 +8224,10 @@ expand_builtin_apply (function, arguments, argsize)\n     size += GET_MODE_SIZE (Pmode);\n \n   /* Restore each of the registers previously saved.  Make USE insns\n-     for each of these registers for use in making the call.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+     for each of these registers for use in making the call.\n+     Doing this in reverse order makes for much more compact code\n+     for i386 and family.  */\n+  for (regno = FIRST_PSEUDO_REGISTER; regno--; )\n     if ((mode = apply_args_mode[regno]) != VOIDmode)\n       {\n \talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;"}]}