{"sha": "1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxYmEwMDI4ODJmNDBkMmU4YmRjNmFlYmRhMzllMTUxODNlNGY5Mg==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-08-06T23:18:57Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-08-06T23:18:57Z"}, "message": "fixed-value.h: New file.\n\n\t* fixed-value.h: New file.\n\t* fixed-value.c: New file.\n\t* Makefile.in (OBJS-common): Add fixed-value.o.\n\t(fixed-value.o): New rule.\n\t(GTFILES): Add fixed-value.h.\n\t* double-int.c (double_int_scmp): We should use unsigned HOST_WIDE_INT\n\tto compare a.low and b.low.\n\t* gengtype.c (main): Handle FIXED_VALUE_TYPE type as scalar typedef.\n\nFrom-SVN: r127260", "tree": {"sha": "addc6eca4349b2f6c3297a7faaeaf123e6da7c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/addc6eca4349b2f6c3297a7faaeaf123e6da7c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/comments", "author": null, "committer": null, "parents": [{"sha": "19c222f890b08f00f999b2853b09a0152ac423fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c222f890b08f00f999b2853b09a0152ac423fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c222f890b08f00f999b2853b09a0152ac423fb"}], "stats": {"total": 1260, "additions": 1258, "deletions": 2}, "files": [{"sha": "73bf46a508f28cc62471df63b183f0eb7ad251bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -1,3 +1,14 @@\n+2007-08-06  Chao-ying Fu  <fu@mips.com>\n+\n+\t* fixed-value.h: New file.\n+\t* fixed-value.c: New file.\n+\t* Makefile.in (OBJS-common): Add fixed-value.o.\n+\t(fixed-value.o): New rule.\n+\t(GTFILES): Add fixed-value.h.\n+\t* double-int.c (double_int_scmp): We should use unsigned HOST_WIDE_INT\n+\tto compare a.low and b.low.\n+\t* gengtype.c (main): Handle FIXED_VALUE_TYPE type as scalar typedef.\n+\n 2007-08-06  H.J. Lu  <hongjiu.lu@intel.com>\n \t    Daniel Jacobowitz  <dan@codesourcery.com>\n "}, {"sha": "fe059d08fe5d8e0f08c601b2e23b9d2f9a8e0db4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -1028,6 +1028,7 @@ OBJS-common = \\\n \texpmed.o \\\n \texpr.o \\\n \tfinal.o \\\n+\tfixed-value.o \\\n \tfold-const.o \\\n \tfunction.o \\\n \tfwprop.o \\\n@@ -2413,6 +2414,8 @@ real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    toplev.h $(TM_P_H) $(REAL_H)\n dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n    toplev.h $(TM_P_H) $(REAL_H) $(DECNUM_H)\n+fixed-value.o: fixed-value.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) fixed-value.h $(REAL_H) toplev.h\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \\\n    $(EXPR_H) $(REAL_H) $(REGS_H) intl.h $(FUNCTION_H) output.h $(RECOG_H) \\\n@@ -3038,6 +3041,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/function.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n+  $(srcdir)/fixed-value.h \\\n   $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\"}, {"sha": "2ab505584f8cbf25ba95126b3cb2461396a4191a", "filename": "gcc/double-int.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -362,9 +362,9 @@ double_int_scmp (double_int a, double_int b)\n     return -1;\n   if (a.high > b.high)\n     return 1;\n-  if ((HOST_WIDE_INT) a.low < (HOST_WIDE_INT) b.low)\n+  if (a.low < b.low)\n     return -1;\n-  if ((HOST_WIDE_INT) a.low > (HOST_WIDE_INT) b.low)\n+  if (a.low > b.low)\n     return 1;\n \n   return 0;"}, {"sha": "705f4ca3de73262d0479f3f25c5de08dacef4fd9", "filename": "gcc/fixed-value.c", "status": "added", "additions": 1140, "deletions": 0, "changes": 1140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -0,0 +1,1140 @@\n+/* Fixed-point arithmetic support.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"toplev.h\"\n+#include \"fixed-value.h\"\n+\n+/* Compare two fixed objects for bitwise identity.  */\n+\n+bool\n+fixed_identical (const FIXED_VALUE_TYPE *a, const FIXED_VALUE_TYPE *b)\n+{\n+  return (a->mode == b->mode\n+\t  && a->data.high == b->data.high\n+\t  && a->data.low == b->data.low);\n+}\n+\n+/* Calculate a hash value.  */\n+\n+unsigned int\n+fixed_hash (const FIXED_VALUE_TYPE *f)\n+{\n+  return (unsigned int) (f->data.low ^ f->data.high);\n+}\n+\n+/* Define the enum code for the range of the fixed-point value.  */\n+enum fixed_value_range_code {\n+  FIXED_OK,\t\t/* The value is within the range.  */\n+  FIXED_UNDERFLOW,\t/* The value is less than the minimum.  */\n+  FIXED_GT_MAX_EPS,\t/* The value is greater than the maximum, but not equal\n+\t\t\t   to the maximum plus the epsilon.  */\n+  FIXED_MAX_EPS\t\t/* The value equals the maximum plus the epsilon.  */\n+};\n+\n+/* Check REAL_VALUE against the range of the fixed-point mode.\n+   Return FIXED_OK, if it is within the range.\n+          FIXED_UNDERFLOW, if it is less than the minimum.\n+          FIXED_GT_MAX_EPS, if it is greater than the maximum, but not equal to\n+\t    the maximum plus the epsilon.\n+          FIXED_MAX_EPS, if it is equal to the maximum plus the epsilon.  */\n+\n+static enum fixed_value_range_code\n+check_real_for_fixed_mode (REAL_VALUE_TYPE *real_value, enum machine_mode mode)\n+{\n+  REAL_VALUE_TYPE max_value, min_value, epsilon_value;\n+\n+  real_2expN (&max_value, GET_MODE_IBIT (mode));\n+  real_2expN (&epsilon_value, -GET_MODE_FBIT (mode));\n+\n+  if (SIGNED_FIXED_POINT_MODE_P (mode))\n+    min_value = REAL_VALUE_NEGATE (max_value);\n+  else\n+    real_from_string (&min_value, \"0.0\");\n+\n+  if (real_compare (LT_EXPR, real_value, &min_value))\n+    return FIXED_UNDERFLOW;\n+  if (real_compare (EQ_EXPR, real_value, &max_value))\n+    return FIXED_MAX_EPS;\n+  real_arithmetic (&max_value, MINUS_EXPR, &max_value, &epsilon_value);\n+  if (real_compare (GT_EXPR, real_value, &max_value))\n+    return FIXED_GT_MAX_EPS;\n+  return FIXED_OK;\n+}\n+\n+/* Initialize from a decimal or hexadecimal string.  */\n+\n+void\n+fixed_from_string (FIXED_VALUE_TYPE *f, const char *str, enum machine_mode mode)\n+{\n+  REAL_VALUE_TYPE real_value, fixed_value, base_value;\n+  unsigned int fbit;\n+  enum fixed_value_range_code temp;\n+\n+  f->mode = mode;\n+  fbit = GET_MODE_FBIT (mode);\n+\n+  real_from_string (&real_value, str);\n+  temp = check_real_for_fixed_mode (&real_value, f->mode);\n+  /* We don't want to warn the case when the _Fract value is 1.0.  */\n+  if (temp == FIXED_UNDERFLOW\n+      || temp == FIXED_GT_MAX_EPS\n+      || (temp == FIXED_MAX_EPS && ALL_ACCUM_MODE_P (f->mode)))\n+    warning (OPT_Woverflow,\n+\t     \"large fixed-point constant implicitly truncated to fixed-point type\");\n+  real_2expN (&base_value, fbit);\n+  real_arithmetic (&fixed_value, MULT_EXPR, &real_value, &base_value);\n+  real_to_integer2 ((HOST_WIDE_INT *)&f->data.low, &f->data.high,\n+\t\t    &fixed_value);\n+\n+  if (temp == FIXED_MAX_EPS && ALL_FRACT_MODE_P (f->mode))\n+    {\n+      /* From the spec, we need to evaluate 1 to the maximal value.  */\n+      f->data.low = -1;\n+      f->data.high = -1;\n+      f->data = double_int_ext (f->data,\n+\t\t\t\tGET_MODE_FBIT (f->mode)\n+\t\t\t\t+ GET_MODE_IBIT (f->mode), 1);\n+    }\n+  else\n+    f->data = double_int_ext (f->data,\n+\t\t\t      SIGNED_FIXED_POINT_MODE_P (f->mode)\n+\t\t\t      + GET_MODE_FBIT (f->mode)\n+\t\t\t      + GET_MODE_IBIT (f->mode),\n+\t\t\t      UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n+}\n+\n+/* Render F as a decimal floating point constant.  */\n+\n+void\n+fixed_to_decimal (char *str, const FIXED_VALUE_TYPE *f_orig,\n+\t\t  size_t buf_size)\n+{\n+  REAL_VALUE_TYPE real_value, base_value, fixed_value;\n+\n+  real_2expN (&base_value, GET_MODE_FBIT (f_orig->mode));\n+  real_from_integer (&real_value, VOIDmode, f_orig->data.low, f_orig->data.high,\n+\t\t     UNSIGNED_FIXED_POINT_MODE_P (f_orig->mode));\n+  real_arithmetic (&fixed_value, RDIV_EXPR, &real_value, &base_value);\n+  real_to_decimal (str, &fixed_value, buf_size, 0, 1);\n+}\n+\n+/* If SAT_P, saturate A to the maximum or the minimum, and save to *F based on\n+   the machine mode MODE.\n+   Do not modify *F otherwise.\n+   This function assumes the width of double_int is greater than the width\n+   of the fixed-point value (the sum of a possible sign bit, possible ibits,\n+   and fbits).\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+fixed_saturate1 (enum machine_mode mode, double_int a, double_int *f,\n+\t\t bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (mode);\n+  int i_f_bits = GET_MODE_IBIT (mode) + GET_MODE_FBIT (mode);\n+\n+  if (unsigned_p) /* Unsigned type.  */\n+    {\n+      double_int max;\n+      max.low = -1;\n+      max.high = -1;\n+      max = double_int_ext (max, i_f_bits, 1);\n+      if (double_int_cmp (a, max, 1) == 1)\n+\t{\n+\t  if (sat_p)\n+\t    *f = max;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  else /* Signed type.  */\n+    {\n+      double_int max, min;\n+      max.high = -1;\n+      max.low = -1;\n+      max = double_int_ext (max, i_f_bits, 1);\n+      min.high = 0;\n+      min.low = 1;\n+      lshift_double (min.low, min.high, i_f_bits,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &min.low, &min.high, 1);\n+      min = double_int_ext (min, 1 + i_f_bits, 0);\n+      if (double_int_cmp (a, max, 0) == 1)\n+\t{\n+\t  if (sat_p)\n+\t    *f = max;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+      else if (double_int_cmp (a, min, 0) == -1)\n+\t{\n+\t  if (sat_p)\n+\t    *f = min;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  return overflow_p;\n+}\n+\n+/* If SAT_P, saturate {A_HIGH, A_LOW} to the maximum or the minimum, and\n+   save to *F based on the machine mode MODE.\n+   Do not modify *F otherwise.\n+   This function assumes the width of two double_int is greater than the width\n+   of the fixed-point value (the sum of a possible sign bit, possible ibits,\n+   and fbits).\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+fixed_saturate2 (enum machine_mode mode, double_int a_high, double_int a_low,\n+\t\t double_int *f, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (mode);\n+  int i_f_bits = GET_MODE_IBIT (mode) + GET_MODE_FBIT (mode);\n+\n+  if (unsigned_p) /* Unsigned type.  */\n+    {\n+      double_int max_r, max_s;\n+      max_r.high = 0;\n+      max_r.low = 0;\n+      max_s.high = -1;\n+      max_s.low = -1;\n+      max_s = double_int_ext (max_s, i_f_bits, 1);\n+      if (double_int_cmp (a_high, max_r, 1) == 1\n+\t  || (double_int_equal_p (a_high, max_r) &&\n+\t      double_int_cmp (a_low, max_s, 1) == 1))\n+\t{\n+\t  if (sat_p)\n+\t    *f = max_s;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  else /* Signed type.  */\n+    {\n+      double_int max_r, max_s, min_r, min_s;\n+      max_r.high = 0;\n+      max_r.low = 0;\n+      max_s.high = -1;\n+      max_s.low = -1;\n+      max_s = double_int_ext (max_s, i_f_bits, 1);\n+      min_r.high = -1;\n+      min_r.low = -1;\n+      min_s.high = 0;\n+      min_s.low = 1;\n+      lshift_double (min_s.low, min_s.high, i_f_bits,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &min_s.low, &min_s.high, 1);\n+      min_s = double_int_ext (min_s, 1 + i_f_bits, 0);\n+      if (double_int_cmp (a_high, max_r, 0) == 1\n+\t  || (double_int_equal_p (a_high, max_r) &&\n+\t      double_int_cmp (a_low, max_s, 1) == 1))\n+\t{\n+\t  if (sat_p)\n+\t    *f = max_s;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+      else if (double_int_cmp (a_high, min_r, 0) == -1\n+\t       || (double_int_equal_p (a_high, min_r) &&\n+\t\t   double_int_cmp (a_low, min_s, 1) == -1))\n+\t{\n+\t  if (sat_p)\n+\t    *f = min_s;\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  return overflow_p;\n+}\n+\n+/* Return the sign bit based on I_F_BITS.  */\n+\n+static inline int\n+get_fixed_sign_bit (double_int a, int i_f_bits)\n+{\n+  if (i_f_bits < HOST_BITS_PER_WIDE_INT)\n+    return (a.low >> i_f_bits) & 1;\n+  else\n+    return (a.high >> (i_f_bits - HOST_BITS_PER_WIDE_INT)) & 1;\n+}\n+\n+/* Calculate F = A + (SUBTRACT_P ? -B : B).\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+do_fixed_add (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n+\t      const FIXED_VALUE_TYPE *b, bool subtract_p, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  double_int temp = subtract_p ? double_int_neg (b->data) : b->data;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n+  int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n+  f->mode = a->mode;\n+  f->data = double_int_add (a->data, temp);\n+  if (unsigned_p) /* Unsigned type.  */\n+    {\n+      if (subtract_p) /* Unsigned subtraction.  */\n+\t{\n+\t  if (double_int_cmp (a->data, b->data, 1) == -1)\n+\t    {\n+\t      if (sat_p)\n+\t\t{\n+\t\t  f->data.high = 0;\n+\t\t  f->data.low = 0;\n+\t\t }\n+\t      else\n+\t\toverflow_p = true;\n+\t    }\n+\t}\n+      else /* Unsigned addition.  */\n+\t{\n+\t  f->data = double_int_ext (f->data, i_f_bits, 1);\n+\t  if (double_int_cmp (f->data, a->data, 1) == -1\n+\t      || double_int_cmp (f->data, b->data, 1) == -1)\n+\t    {\n+\t      if (sat_p)\n+\t\t{\n+\t\t  f->data.high = -1;\n+\t\t  f->data.low = -1;\n+\t\t}\n+\t      else\n+\t\toverflow_p = true;\n+\t    }\n+\t}\n+    }\n+  else /* Signed type.  */\n+    {\n+      if ((!subtract_p\n+\t   && (get_fixed_sign_bit (a->data, i_f_bits)\n+\t       == get_fixed_sign_bit (b->data, i_f_bits))\n+\t   && (get_fixed_sign_bit (a->data, i_f_bits)\n+\t       != get_fixed_sign_bit (f->data, i_f_bits)))\n+\t  || (subtract_p\n+\t      && (get_fixed_sign_bit (a->data, i_f_bits)\n+\t\t  != get_fixed_sign_bit (b->data, i_f_bits))\n+\t      && (get_fixed_sign_bit (a->data, i_f_bits)\n+\t\t  != get_fixed_sign_bit (f->data, i_f_bits))))\n+\t{\n+\t  if (sat_p)\n+\t    {\n+\t      f->data.low = 1;\n+\t      f->data.high = 0;\n+\t      lshift_double (f->data.low, f->data.high, i_f_bits,\n+\t\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t     &f->data.low, &f->data.high, 1);\n+\t      if (get_fixed_sign_bit (a->data, i_f_bits) == 0)\n+\t\t{\n+\t\t  double_int one;\n+\t\t  one.low = 1;\n+\t\t  one.high = 0;\n+\t\t  f->data = double_int_add (f->data, double_int_neg (one));\n+\t\t}\n+\t    }\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  return overflow_p;\n+}\n+\n+/* Calculate F = A * B.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n+\t\t   const FIXED_VALUE_TYPE *b, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n+  int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n+  f->mode = a->mode;\n+  if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      f->data = double_int_mul (a->data, b->data);\n+      lshift_double (f->data.low, f->data.high,\n+\t\t     (-GET_MODE_FBIT (f->mode)),\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &f->data.low, &f->data.high, !unsigned_p);\n+      overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n+    }\n+  else\n+    {\n+      /* The result of multiplication expands to two double_int.  */\n+      double_int a_high, a_low, b_high, b_low;\n+      double_int high_high, high_low, low_high, low_low;\n+      double_int r, s, temp1, temp2;\n+      int carry = 0;\n+\n+      /* Decompose a and b to four double_int.  */\n+      a_high.low = a->data.high;\n+      a_high.high = 0;\n+      a_low.low = a->data.low;\n+      a_low.high = 0;\n+      b_high.low = b->data.high;\n+      b_high.high = 0;\n+      b_low.low = b->data.low;\n+      b_low.high = 0;\n+\n+      /* Perform four multiplications.  */\n+      low_low = double_int_mul (a_low, b_low);\n+      low_high = double_int_mul (a_low, b_high);\n+      high_low = double_int_mul (a_high, b_low);\n+      high_high = double_int_mul (a_high, b_high);\n+\n+      /* Accumulate four results to {r, s}.  */\n+      temp1.high = high_low.low;\n+      temp1.low = 0;\n+      s = double_int_add (low_low, temp1);\n+      if (double_int_cmp (s, low_low, 1) == -1\n+\t  || double_int_cmp (s, temp1, 1) == -1)\n+\tcarry ++; /* Carry */\n+      temp1.high = s.high;\n+      temp1.low = s.low;\n+      temp2.high = low_high.low;\n+      temp2.low = 0;\n+      s = double_int_add (temp1, temp2);\n+      if (double_int_cmp (s, temp1, 1) == -1\n+\t  || double_int_cmp (s, temp2, 1) == -1)\n+\tcarry ++; /* Carry */\n+\n+      temp1.low = high_low.high;\n+      temp1.high = 0;\n+      r = double_int_add (high_high, temp1);\n+      temp1.low = low_high.high;\n+      temp1.high = 0;\n+      r = double_int_add (r, temp1);\n+      temp1.low = carry;\n+      temp1.high = 0;\n+      r = double_int_add (r, temp1);\n+\n+      /* We need to add neg(b) to r, if a < 0.  */\n+      if (!unsigned_p && a->data.high < 0)\n+\tr = double_int_add (r, double_int_neg (b->data));\n+      /* We need to add neg(a) to r, if b < 0.  */\n+      if (!unsigned_p && b->data.high < 0)\n+\tr = double_int_add (r, double_int_neg (a->data));\n+\n+      /* Shift right the result by FBIT.  */\n+      if (GET_MODE_FBIT (f->mode) == 2 * HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  s.low = r.low;\n+\t  s.high = r.high;\n+\t  if (unsigned_p)\n+\t    {\n+\t      r.low = 0;\n+\t      r.high = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      r.low = -1;\n+\t      r.high = -1;\n+\t    }\n+\t  f->data.low = s.low;\n+\t  f->data.high = s.high;\n+\t}\n+      else\n+\t{\n+\t  lshift_double (s.low, s.high,\n+\t\t\t (-GET_MODE_FBIT (f->mode)),\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &s.low, &s.high, 0);\n+\t  lshift_double (r.low, r.high,\n+\t\t\t (2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t  - GET_MODE_FBIT (f->mode)),\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &f->data.low, &f->data.high, 0);\n+\t  f->data.low = f->data.low | s.low;\n+\t  f->data.high = f->data.high | s.high;\n+\t  s.low = f->data.low;\n+\t  s.high = f->data.high;\n+\t  lshift_double (r.low, r.high,\n+\t\t\t (-GET_MODE_FBIT (f->mode)),\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &r.low, &r.high, !unsigned_p);\n+\t}\n+\n+      overflow_p = fixed_saturate2 (f->mode, r, s, &f->data, sat_p);\n+    }\n+\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  return overflow_p;\n+}\n+\n+/* Calculate F = A / B.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n+\t\t const FIXED_VALUE_TYPE *b, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n+  int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n+  f->mode = a->mode;\n+  if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      lshift_double (a->data.low, a->data.high,\n+\t\t     GET_MODE_FBIT (f->mode),\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &f->data.low, &f->data.high, !unsigned_p);\n+      f->data = double_int_div (f->data, b->data, unsigned_p, TRUNC_DIV_EXPR);\n+      overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n+    }\n+  else\n+    {\n+      double_int pos_a, pos_b, r, s;\n+      double_int quo_r, quo_s, mod, temp;\n+      int num_of_neg = 0;\n+      int i;\n+\n+      /* If a < 0, negate a.  */\n+      if (!unsigned_p && a->data.high < 0)\n+\t{\n+\t  pos_a = double_int_neg (a->data);\n+\t  num_of_neg ++;\n+\t}\n+      else\n+\tpos_a = a->data;\n+\n+      /* If b < 0, negate b.  */\n+      if (!unsigned_p && b->data.high < 0)\n+\t{\n+\t  pos_b = double_int_neg (b->data);\n+\t  num_of_neg ++;\n+\t}\n+      else\n+\tpos_b = b->data;\n+\n+      /* Left shift pos_a to {r, s} by FBIT.  */\n+      if (GET_MODE_FBIT (f->mode) == 2 * HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  r = pos_a;\n+\t  s.high = 0;\n+\t  s.low = 0;\n+\t}\n+      else\n+ \t{\n+\t  lshift_double (pos_a.low, pos_a.high,\n+\t\t\t GET_MODE_FBIT (f->mode),\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &s.low, &s.high, 0);\n+\t  lshift_double (pos_a.low, pos_a.high,\n+\t\t\t - (2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t    - GET_MODE_FBIT (f->mode)),\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &r.low, &r.high, 0);\n+ \t}\n+\n+      /* Divide r by pos_b to quo_r.  The remanider is in mod.  */\n+      div_and_round_double (TRUNC_DIV_EXPR, 1, r.low, r.high, pos_b.low,\n+\t\t\t    pos_b.high, &quo_r.low, &quo_r.high, &mod.low,\n+\t\t\t    &mod.high);\n+\n+      quo_s.high = 0;\n+      quo_s.low = 0;\n+\n+      for (i = 0; i < 2 * HOST_BITS_PER_WIDE_INT; i++)\n+\t{\n+\t  /* Record the leftmost bit of mod.  */\n+\t  int leftmost_mod = (mod.high < 0);\n+\n+\t  /* Shift left mod by 1 bit.  */\n+\t  lshift_double (mod.low, mod.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &mod.low, &mod.high, 0);\n+\n+\t  /* Test the leftmost bit of s to add to mod.  */\n+\t  if (s.high < 0)\n+\t    mod.low += 1;\n+\n+\t  /* Shift left quo_s by 1 bit.  */\n+\t  lshift_double (quo_s.low, quo_s.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &quo_s.low, &quo_s.high, 0);\n+\n+\t  /* Try to calculate (mod - pos_b).  */\n+\t  temp = double_int_add (mod, double_int_neg (pos_b));\n+\n+\t  if (leftmost_mod == 1 || double_int_cmp (mod, pos_b, 1) != -1)\n+\t    {\n+\t      quo_s.low += 1;\n+\t      mod = temp;\n+\t    }\n+\n+\t  /* Shift left s by 1 bit.  */\n+\t  lshift_double (s.low, s.high, 1, 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &s.low, &s.high, 0);\n+\n+\t}\n+\n+      if (num_of_neg == 1)\n+\t{\n+\t  quo_s = double_int_neg (quo_s);\n+\t  if (quo_s.high == 0 && quo_s.low == 0)\n+\t    quo_r = double_int_neg (quo_r);\n+\t  else\n+\t    {\n+\t      quo_r.low = ~quo_r.low;\n+\t      quo_r.high = ~quo_r.high;\n+\t    }\n+\t}\n+\n+      f->data = quo_s;\n+      overflow_p = fixed_saturate2 (f->mode, quo_r, quo_s, &f->data, sat_p);\n+    }\n+\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  return overflow_p;\n+}\n+\n+/* Calculate F = A << B if LEFT_P.  Otherwies, F = A >> B.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+do_fixed_shift (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n+\t      const FIXED_VALUE_TYPE *b, bool left_p, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n+  int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n+  f->mode = a->mode;\n+\n+  if (b->data.low == 0)\n+    {\n+      f->data = a->data;\n+      return overflow_p;\n+    }\n+\n+  if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT || (!left_p))\n+    {\n+      lshift_double (a->data.low, a->data.high,\n+\t\t     left_p ? b->data.low : (-b->data.low),\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &f->data.low, &f->data.high, !unsigned_p);\n+      if (left_p) /* Only left shift saturates.  */\n+\toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n+    }\n+  else /* We need two double_int to store the left-shift result.  */\n+    {\n+      double_int temp_high, temp_low;\n+      if (b->data.low == 2 * HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  temp_high = a->data;\n+\t  temp_low.high = 0;\n+\t  temp_low.low = 0;\n+\t}\n+      else\n+\t{\n+\t  lshift_double (a->data.low, a->data.high,\n+\t\t\t b->data.low,\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &temp_low.low, &temp_low.high, !unsigned_p);\n+\t  /* Logical shift right to temp_high.  */\n+\t  lshift_double (a->data.low, a->data.high,\n+\t\t\t b->data.low - 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t &temp_high.low, &temp_high.high, 0);\n+\t}\n+      if (!unsigned_p && a->data.high < 0) /* Signed-extend temp_high.  */\n+\ttemp_high = double_int_ext (temp_high, b->data.low, unsigned_p);\n+      f->data = temp_low;\n+      overflow_p = fixed_saturate2 (f->mode, temp_high, temp_low, &f->data,\n+\t\t\t\t    sat_p);\n+    }\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  return overflow_p;\n+}\n+\n+/* Calculate F = -A.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+static bool\n+do_fixed_neg (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n+  int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n+  f->mode = a->mode;\n+  f->data = double_int_neg (a->data);\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+\n+  if (unsigned_p) /* Unsigned type.  */\n+    {\n+      if (f->data.low != 0 || f->data.high != 0)\n+\t{\n+\t  if (sat_p)\n+\t    {\n+\t      f->data.low = 0;\n+\t      f->data.high = 0;\n+\t    }\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  else /* Signed type.  */\n+    {\n+      if (!(f->data.high == 0 && f->data.low == 0)\n+\t  && f->data.high == a->data.high && f->data.low == a->data.low )\n+\t{\n+\t  if (sat_p)\n+\t    {\n+\t      /* Saturate to the maximum by subtracting f->data by one.  */\n+\t      f->data.low = -1;\n+\t      f->data.high = -1;\n+\t      f->data = double_int_ext (f->data, i_f_bits, 1);\n+\t    }\n+\t  else\n+\t    overflow_p = true;\n+\t}\n+    }\n+  return overflow_p;\n+}\n+\n+/* Perform the binary or unary operation described by CODE.\n+   Note that OP0 and OP1 must have the same mode for binary operators.\n+   For a unary operation, leave OP1 NULL.\n+   Return true, if !SAT_P and overflow.  */\n+\n+bool\n+fixed_arithmetic (FIXED_VALUE_TYPE *f, int icode, const FIXED_VALUE_TYPE *op0,\n+\t\t  const FIXED_VALUE_TYPE *op1, bool sat_p)\n+{\n+  switch (icode)\n+    {\n+    case NEGATE_EXPR:\n+      return do_fixed_neg (f, op0, sat_p);\n+      break;\n+\n+    case PLUS_EXPR:\n+      gcc_assert (op0->mode == op1->mode);\n+      return do_fixed_add (f, op0, op1, false, sat_p);\n+      break;\n+\n+    case MINUS_EXPR:\n+      gcc_assert (op0->mode == op1->mode);\n+      return do_fixed_add (f, op0, op1, true, sat_p);\n+      break;\n+\n+    case MULT_EXPR:\n+      gcc_assert (op0->mode == op1->mode);\n+      return do_fixed_multiply (f, op0, op1, sat_p);\n+      break;\n+\n+    case TRUNC_DIV_EXPR:\n+      gcc_assert (op0->mode == op1->mode);\n+      return do_fixed_divide (f, op0, op1, sat_p);\n+      break;\n+\n+    case LSHIFT_EXPR:\n+      return do_fixed_shift (f, op0, op1, true, sat_p);\n+      break;\n+\n+    case RSHIFT_EXPR:\n+      return do_fixed_shift (f, op0, op1, false, sat_p);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+/* Compare fixed-point values by tree_code.\n+   Note that OP0 and OP1 must have the same mode.  */\n+\n+bool\n+fixed_compare (int icode, const FIXED_VALUE_TYPE *op0,\n+\t       const FIXED_VALUE_TYPE *op1)\n+{\n+  enum tree_code code = icode;\n+  gcc_assert (op0->mode == op1->mode);\n+\n+  switch (code)\n+    {\n+    case NE_EXPR:\n+      return !double_int_equal_p (op0->data, op1->data);\n+\n+    case EQ_EXPR:\n+      return double_int_equal_p (op0->data, op1->data);\n+\n+    case LT_EXPR:\n+      return double_int_cmp (op0->data, op1->data,\n+\t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) == -1;\n+\n+    case LE_EXPR:\n+      return double_int_cmp (op0->data, op1->data,\n+\t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) != 1;\n+\n+    case GT_EXPR:\n+      return double_int_cmp (op0->data, op1->data,\n+\t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) == 1;\n+\n+    case GE_EXPR:\n+      return double_int_cmp (op0->data, op1->data,\n+\t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) != -1;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Extend or truncate to a new mode.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+bool\n+fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n+               const FIXED_VALUE_TYPE *a, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  if (mode == a->mode)\n+    {\n+      *f = *a;\n+      return overflow_p;\n+    }\n+\n+  if (GET_MODE_FBIT (mode) > GET_MODE_FBIT (a->mode))\n+    {\n+      /* Left shift a to temp_high, temp_low based on a->mode.  */\n+      double_int temp_high, temp_low;\n+      int amount = GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode);\n+      lshift_double (a->data.low, a->data.high,\n+\t\t     amount,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp_low.low, &temp_low.high,\n+\t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n+      /* Logical shift right to temp_high.  */\n+      lshift_double (a->data.low, a->data.high,\n+\t\t     amount - 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp_high.low, &temp_high.high, 0);\n+      if (SIGNED_FIXED_POINT_MODE_P (a->mode)\n+\t  && a->data.high < 0) /* Signed-extend temp_high.  */\n+\ttemp_high = double_int_ext (temp_high, amount, 0);\n+      f->mode = mode;\n+      f->data = temp_low;\n+      if (SIGNED_FIXED_POINT_MODE_P (a->mode) ==\n+\t  SIGNED_FIXED_POINT_MODE_P (f->mode))\n+\toverflow_p = fixed_saturate2 (f->mode, temp_high, temp_low, &f->data,\n+\t\t\t\t      sat_p);\n+      else\n+\t{\n+\t  /* Take care of the cases when converting between signed and\n+\t     unsigned.  */\n+\t  if (SIGNED_FIXED_POINT_MODE_P (a->mode))\n+\t    {\n+\t      /* Signed -> Unsigned.  */\n+\t      if (a->data.high < 0)\n+\t\t{\n+\t\t  if (sat_p)\n+\t\t    {\n+\t\t      f->data.low = 0;  /* Set to zero.  */\n+\t\t      f->data.high = 0;  /* Set to zero.  */\n+\t\t    }\n+\t\t  else\n+\t\t    overflow_p = true;\n+\t\t}\n+\t      else\n+\t\toverflow_p = fixed_saturate2 (f->mode, temp_high, temp_low,\n+\t\t\t\t\t      &f->data, sat_p);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Unsigned -> Signed.  */\n+\t      if (temp_high.high < 0)\n+\t\t{\n+\t\t  if (sat_p)\n+\t\t    {\n+\t\t      /* Set to maximum.  */\n+\t\t      f->data.low = -1;  /* Set to all ones.  */\n+\t\t      f->data.high = -1;  /* Set to all ones.  */\n+\t\t      f->data = double_int_ext (f->data,\n+\t\t\t\t\t\tGET_MODE_FBIT (f->mode)\n+\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode),\n+\t\t\t\t\t\t1); /* Clear the sign.  */\n+\t\t    }\n+\t\t  else\n+\t\t    overflow_p = true;\n+\t\t}\n+\t      else\n+\t\toverflow_p = fixed_saturate2 (f->mode, temp_high, temp_low,\n+\t\t\t\t\t      &f->data, sat_p);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Right shift a to temp based on a->mode.  */\n+      double_int temp;\n+      lshift_double (a->data.low, a->data.high,\n+\t\t     GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode),\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp.low, &temp.high,\n+\t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n+      f->mode = mode;\n+      f->data = temp;\n+      if (SIGNED_FIXED_POINT_MODE_P (a->mode) ==\n+\t  SIGNED_FIXED_POINT_MODE_P (f->mode))\n+\toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n+      else\n+\t{\n+\t  /* Take care of the cases when converting between signed and\n+\t     unsigned.  */\n+\t  if (SIGNED_FIXED_POINT_MODE_P (a->mode))\n+\t    {\n+\t      /* Signed -> Unsigned.  */\n+\t      if (a->data.high < 0)\n+\t\t{\n+\t\t  if (sat_p)\n+\t\t    {\n+\t\t      f->data.low = 0;  /* Set to zero.  */\n+\t\t      f->data.high = 0;  /* Set to zero.  */\n+\t\t    }\n+\t\t  else\n+\t\t    overflow_p = true;\n+\t\t}\n+\t      else\n+\t\toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data,\n+\t\t\t\t\t      sat_p);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Unsigned -> Signed.  */\n+\t      if (temp.high < 0)\n+\t\t{\n+\t\t  if (sat_p)\n+\t\t    {\n+\t\t      /* Set to maximum.  */\n+\t\t      f->data.low = -1;  /* Set to all ones.  */\n+\t\t      f->data.high = -1;  /* Set to all ones.  */\n+\t\t      f->data = double_int_ext (f->data,\n+\t\t\t\t\t\tGET_MODE_FBIT (f->mode)\n+\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode),\n+\t\t\t\t\t\t1); /* Clear the sign.  */\n+\t\t    }\n+\t\t  else\n+\t\t    overflow_p = true;\n+\t\t}\n+\t      else\n+\t\toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data,\n+\t\t\t\t\t      sat_p);\n+\t    }\n+\t}\n+    }\n+\n+  f->data = double_int_ext (f->data,\n+\t\t\t    SIGNED_FIXED_POINT_MODE_P (f->mode)\n+\t\t\t    + GET_MODE_FBIT (f->mode)\n+\t\t\t    + GET_MODE_IBIT (f->mode),\n+\t\t\t    UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n+  return overflow_p;\n+}\n+\n+/* Convert to a new fixed-point mode from an integer.\n+   If UNSIGNED_P, this integer is unsigned.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+bool\n+fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n+\t\t\tdouble_int a, bool unsigned_p, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  /* Left shift a to temp_high, temp_low.  */\n+  double_int temp_high, temp_low;\n+  int amount = GET_MODE_FBIT (mode);\n+  if (amount == 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+       temp_high = a;\n+       temp_low.low = 0;\n+       temp_low.high = 0;\n+    }\n+  else\n+    {\n+      lshift_double (a.low, a.high,\n+\t\t     amount,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp_low.low, &temp_low.high, 0);\n+\n+      /* Logical shift right to temp_high.  */\n+      lshift_double (a.low, a.high,\n+\t\t     amount - 2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t     &temp_high.low, &temp_high.high, 0);\n+    }\n+  if (!unsigned_p && a.high < 0) /* Signed-extend temp_high.  */\n+    temp_high = double_int_ext (temp_high, amount, 0);\n+\n+  f->mode = mode;\n+  f->data = temp_low;\n+\n+  if (unsigned_p == UNSIGNED_FIXED_POINT_MODE_P (f->mode))\n+    overflow_p = fixed_saturate2 (f->mode, temp_high, temp_low, &f->data,\n+\t\t\t\t  sat_p);\n+  else\n+    {\n+      /* Take care of the cases when converting between signed and unsigned.  */\n+      if (!unsigned_p)\n+\t{\n+\t  /* Signed -> Unsigned.  */\n+\t  if (a.high < 0)\n+\t    {\n+\t      if (sat_p)\n+\t\t{\n+\t\t  f->data.low = 0;  /* Set to zero.  */\n+\t\t  f->data.high = 0;  /* Set to zero.  */\n+\t\t}\n+\t      else\n+\t\toverflow_p = true;\n+\t    }\n+\t  else\n+\t    overflow_p = fixed_saturate2 (f->mode, temp_high, temp_low,\n+\t\t\t\t\t  &f->data, sat_p);\n+\t}\n+      else\n+\t{\n+\t  /* Unsigned -> Signed.  */\n+\t  if (temp_high.high < 0)\n+\t    {\n+\t      if (sat_p)\n+\t\t{\n+\t\t  /* Set to maximum.  */\n+\t\t  f->data.low = -1;  /* Set to all ones.  */\n+\t\t  f->data.high = -1;  /* Set to all ones.  */\n+\t\t  f->data = double_int_ext (f->data,\n+\t\t\t\t\t    GET_MODE_FBIT (f->mode)\n+\t\t\t\t\t    + GET_MODE_IBIT (f->mode),\n+\t\t\t\t\t    1); /* Clear the sign.  */\n+\t\t}\n+\t      else\n+\t\toverflow_p = true;\n+\t    }\n+\t  else\n+\t    overflow_p = fixed_saturate2 (f->mode, temp_high, temp_low,\n+\t\t\t\t\t  &f->data, sat_p);\n+\t}\n+    }\n+  f->data = double_int_ext (f->data,\n+\t\t\t    SIGNED_FIXED_POINT_MODE_P (f->mode)\n+\t\t\t    + GET_MODE_FBIT (f->mode)\n+\t\t\t    + GET_MODE_IBIT (f->mode),\n+\t\t\t    UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n+  return overflow_p;\n+}\n+\n+/* Convert to a new fixed-point mode from a real.\n+   If SAT_P, saturate the result to the max or the min.\n+   Return true, if !SAT_P and overflow.  */\n+\n+bool\n+fixed_convert_from_real (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n+\t\t\t const REAL_VALUE_TYPE *a, bool sat_p)\n+{\n+  bool overflow_p = false;\n+  REAL_VALUE_TYPE real_value, fixed_value, base_value;\n+  bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (mode);\n+  int i_f_bits = GET_MODE_IBIT (mode) + GET_MODE_FBIT (mode);\n+  unsigned int fbit = GET_MODE_FBIT (mode);\n+  enum fixed_value_range_code temp;\n+\n+  real_value = *a;\n+  f->mode = mode;\n+  real_2expN (&base_value, fbit);\n+  real_arithmetic (&fixed_value, MULT_EXPR, &real_value, &base_value);\n+  real_to_integer2 ((HOST_WIDE_INT *)&f->data.low, &f->data.high, &fixed_value);\n+  temp = check_real_for_fixed_mode (&real_value, mode);\n+  if (temp == FIXED_UNDERFLOW) /* Minimum.  */\n+    {\n+      if (sat_p)\n+\t{\n+\t  if (unsigned_p)\n+\t    {\n+\t      f->data.low = 0;\n+\t      f->data.high = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      f->data.low = 1;\n+\t      f->data.high = 0;\n+\t      lshift_double (f->data.low, f->data.high, i_f_bits,\n+\t\t\t     2 * HOST_BITS_PER_WIDE_INT,\n+\t\t\t     &f->data.low, &f->data.high, 1);\n+\t      f->data = double_int_ext (f->data, 1 + i_f_bits, 0);\n+\t    }\n+\t}\n+      else\n+\toverflow_p = true;\n+    }\n+  else if (temp == FIXED_GT_MAX_EPS || temp == FIXED_MAX_EPS) /* Maximum.  */\n+    {\n+      if (sat_p)\n+\t{\n+\t  f->data.low = -1;\n+\t  f->data.high = -1;\n+\t  f->data = double_int_ext (f->data, i_f_bits, 1);\n+\t}\n+      else\n+\toverflow_p = true;\n+    }\n+  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  return overflow_p;\n+}\n+\n+/* Convert to a new real mode from a fixed-point.  */\n+\n+void\n+real_convert_from_fixed (REAL_VALUE_TYPE *r, enum machine_mode mode,\n+\t\t\t const FIXED_VALUE_TYPE *f)\n+{\n+  REAL_VALUE_TYPE base_value, fixed_value, real_value;\n+\n+  real_2expN (&base_value, GET_MODE_FBIT (f->mode));\n+  real_from_integer (&fixed_value, VOIDmode, f->data.low, f->data.high,\n+\t\t     UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n+  real_arithmetic (&real_value, RDIV_EXPR, &fixed_value, &base_value);\n+  real_convert (r, mode, &real_value);\n+}\n+\n+/* Determine whether a fixed-point value F is negative.  */\n+\n+bool\n+fixed_isneg (const FIXED_VALUE_TYPE *f)\n+{\n+  if (SIGNED_FIXED_POINT_MODE_P (f->mode))\n+    {\n+      int i_f_bits = GET_MODE_IBIT (f->mode) + GET_MODE_FBIT (f->mode);\n+      int sign_bit = get_fixed_sign_bit (f->data, i_f_bits);\n+      if (sign_bit == 1)\n+\treturn true;\n+    }\n+\n+  return false;\n+}"}, {"sha": "69db190e8f19884a29bd70c8ca95cc5c9bc85c22", "filename": "gcc/fixed-value.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -0,0 +1,100 @@\n+/* Fixed-point arithmetic support.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_FIXED_VALUE_H\n+#define GCC_FIXED_VALUE_H\n+\n+#include \"machmode.h\"\n+#include \"real.h\"\n+#include \"double-int.h\"\n+\n+struct fixed_value GTY(())\n+{\n+  double_int data;\t/* Store data up to 2 wide integers.  */\n+  unsigned int mode;\t/* Use machine mode to know IBIT and FBIT.  */\n+};\n+\n+#define FIXED_VALUE_TYPE struct fixed_value\n+\n+#define MAX_FCONST0\t18\t/* For storing 18 fixed-point zeros per\n+\t\t\t\t   fract, ufract, accum, and uaccum modes .  */\n+#define MAX_FCONST1\t8\t/* For storing 8 fixed-point ones per accum\n+\t\t\t\t   and uaccum modes.  */\n+/* Constant fixed-point values 0 and 1.  */\n+extern FIXED_VALUE_TYPE fconst0[MAX_FCONST0];\n+extern FIXED_VALUE_TYPE fconst1[MAX_FCONST1];\n+\n+/* Macros to access fconst0 and fconst1 via machine modes.  */\n+#define FCONST0(mode)\tfconst0[mode - QQmode]\n+#define FCONST1(mode)\tfconst1[mode - HAmode]\n+\n+/* Return a CONST_FIXED with value R and mode M.  */\n+#define CONST_FIXED_FROM_FIXED_VALUE(r, m) \\\n+  const_fixed_from_fixed_value (r, m)\n+extern rtx const_fixed_from_fixed_value (FIXED_VALUE_TYPE, enum machine_mode);\n+\n+/* Initialize from a decimal or hexadecimal string.  */\n+extern void fixed_from_string (FIXED_VALUE_TYPE *, const char *,\n+\t\t\t       enum machine_mode);\n+\n+/* In tree.c: wrap up a FIXED_VALUE_TYPE in a tree node.  */\n+extern tree build_fixed (tree, FIXED_VALUE_TYPE);\n+\n+/* Extend or truncate to a new mode.  */\n+extern bool fixed_convert (FIXED_VALUE_TYPE *, enum machine_mode,\n+\t\t\t   const FIXED_VALUE_TYPE *, bool);\n+\n+/* Convert to a fixed-point mode from an integer.  */\n+extern bool fixed_convert_from_int (FIXED_VALUE_TYPE *, enum machine_mode,\n+\t\t\t\t    double_int, bool, bool);\n+\n+/* Convert to a fixed-point mode from a real.  */\n+extern bool fixed_convert_from_real (FIXED_VALUE_TYPE *, enum machine_mode,\n+\t\t\t\t     const REAL_VALUE_TYPE *, bool);\n+\n+/* Convert to a real mode from a fixed-point.  */\n+extern void real_convert_from_fixed (REAL_VALUE_TYPE *, enum machine_mode,\n+\t\t\t\t     const FIXED_VALUE_TYPE *);\n+\n+/* Compare two fixed-point objects for bitwise identity.  */\n+extern bool fixed_identical (const FIXED_VALUE_TYPE *, const FIXED_VALUE_TYPE *);\n+\n+/* Calculate a hash value.  */\n+extern unsigned int fixed_hash (const FIXED_VALUE_TYPE *);\n+\n+#define FIXED_VALUES_IDENTICAL(x, y)\tfixed_identical (&(x), &(y))\n+\n+/* Determine whether a fixed-point value X is negative.  */\n+#define FIXED_VALUE_NEGATIVE(x)\t\tfixed_isneg (&(x))\n+\n+/* Render F as a decimal floating point constant.  */\n+extern void fixed_to_decimal (char *str, const FIXED_VALUE_TYPE *, size_t);\n+\n+/* Binary or unary arithmetic on tree_code.  */\n+extern bool fixed_arithmetic (FIXED_VALUE_TYPE *, int, const FIXED_VALUE_TYPE *,\n+\t\t\t      const FIXED_VALUE_TYPE *, bool);\n+\n+/* Compare fixed-point values by tree_code.  */\n+extern bool fixed_compare (int, const FIXED_VALUE_TYPE *,\n+\t\t\t   const FIXED_VALUE_TYPE *);\n+\n+/* Determine whether a fixed-point value X is negative.  */\n+extern bool fixed_isneg (const FIXED_VALUE_TYPE *);\n+\n+#endif /* GCC_FIXED_VALUE_H */"}, {"sha": "80acba0c657897ec78d0fabf68c60860a7f5743e", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ba002882f40d2e8bdc6aebda39e15183e4f92/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=1e1ba002882f40d2e8bdc6aebda39e15183e4f92", "patch": "@@ -3533,6 +3533,7 @@ main (int argc, char **argv)\n   pos.line = __LINE__ + 1;\n   do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos); pos.line++;\n   do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos); pos.line++;\n+  do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos); pos.line++;\n   do_scalar_typedef (\"double_int\", &pos); pos.line++;\n   do_scalar_typedef (\"uint8\", &pos); pos.line++;\n   do_scalar_typedef (\"jword\", &pos); pos.line++;"}]}