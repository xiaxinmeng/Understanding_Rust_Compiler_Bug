{"sha": "88115c2a3945dd9eaf0807385e1cd27c298d3d08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxMTVjMmEzOTQ1ZGQ5ZWFmMDgwNzM4NWUxY2QyN2MyOThkM2QwOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T12:01:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T12:01:28Z"}, "message": "[multiple changes]\n\n2011-12-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch5.adb, sem_dim.adb, sem_dim.ads, sem_ch12.adb, prj-conf.adb:\n\tMinor reformatting.\n\n2011-12-21  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads (Constant_Indexing, Default_Iterator,\n\tIterator_Element): Added to type List.               \n\t(Not_No_Element, List_Iterator_Interfaces, Iterate,\n\tConstant_Reference_Type, Constant_Reference): New.\n\t* a-cfdlli.adb (type Iterator, Finalize, First, Last, Next,\n\tPrevious, Iterate, Not_No_Element, Constant_Reference): New.\n\nFrom-SVN: r182576", "tree": {"sha": "765ff5b796fde6843e06dc9b97e68453e35eb766", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/765ff5b796fde6843e06dc9b97e68453e35eb766"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88115c2a3945dd9eaf0807385e1cd27c298d3d08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88115c2a3945dd9eaf0807385e1cd27c298d3d08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88115c2a3945dd9eaf0807385e1cd27c298d3d08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88115c2a3945dd9eaf0807385e1cd27c298d3d08/comments", "author": null, "committer": null, "parents": [{"sha": "6c57023b0cdc7fccc7db3963f847dbef53d43de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c57023b0cdc7fccc7db3963f847dbef53d43de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c57023b0cdc7fccc7db3963f847dbef53d43de8"}], "stats": {"total": 595, "additions": 412, "deletions": 183}, "files": [{"sha": "a60b9e339570b9093979d6c33ef0fbe9afa16c01", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -1,3 +1,17 @@\n+2011-12-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch5.adb, sem_dim.adb, sem_dim.ads, sem_ch12.adb, prj-conf.adb:\n+\tMinor reformatting.\n+\n+2011-12-21  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads (Constant_Indexing, Default_Iterator,\n+\tIterator_Element): Added to type List.               \n+\t(Not_No_Element, List_Iterator_Interfaces, Iterate,\n+\tConstant_Reference_Type, Constant_Reference): New.\n+\t* a-cfdlli.adb (type Iterator, Finalize, First, Last, Next,\n+\tPrevious, Iterate, Not_No_Element, Constant_Reference): New.\n+\n 2011-12-21  Gary Dismukes  <dismukes@adacore.com>\n \n \t* gnat_ugn.texi: Minor reformatting."}, {"sha": "9c4ff1107577dc4a8d79dbf951397c392fbf1d2b", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -26,9 +26,30 @@\n ------------------------------------------------------------------------------\n \n with System;  use type System.Address;\n+with Ada.Finalization;\n \n package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n+   type Iterator is new Ada.Finalization.Limited_Controlled and\n+     List_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : List_Access;\n+      Node      : Count_Type;\n+   end record;\n+\n+   overriding procedure Finalize (Object : in out Iterator);\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Last  (Object : Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -423,6 +444,21 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return Container.Nodes (Position.Node).Element;\n    end Element;\n \n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Iterator) is\n+   begin\n+      if Object.Container /= null then\n+         declare\n+            B : Natural renames Object.Container.all.Busy;\n+         begin\n+            B := B - 1;\n+         end;\n+      end if;\n+   end Finalize;\n+\n    ----------\n    -- Find --\n    ----------\n@@ -474,6 +510,28 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.First);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return First (Object.Container.all);\n+      else\n+         return (Node => Object.Node);\n+      end if;\n+   end First;\n+\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -915,6 +973,71 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : List)\n+     return List_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+\n+   begin\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a\n+      --  complete iterator, meaning that the iteration starts from the\n+      --  (logical) beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return It : constant Iterator :=\n+                    Iterator'(Ada.Finalization.Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                                Node      => 0)\n+      do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n+   function Iterate (Container : List; Start : Cursor)\n+     return List_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n+\n+   begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if not Has_Element (Container, Start) then\n+         raise Constraint_Error with\n+           \"Start position for iterator is not a valid cursor\";\n+      end if;\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return It : constant Iterator :=\n+                    Iterator'(Ada.Finalization.Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                                Node      => Start.Node)\n+      do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n    ----------\n    -- Last --\n    ----------\n@@ -927,6 +1050,28 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Last);\n    end Last;\n \n+   function Last (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Last (Object.Container.all);\n+      else\n+         return (Node => Object.Node);\n+      end if;\n+   end Last;\n+\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -1085,6 +1230,24 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Nodes (Position.Node).Next);\n    end Next;\n \n+   function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+   begin\n+\n+      return Next (Object.Container.all, Position);\n+   end Next;\n+\n+   --------------------\n+   -- Not_No_Element --\n+   --------------------\n+\n+   function Not_No_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Not_No_Element;\n+\n    -------------\n    -- Prepend --\n    -------------\n@@ -1120,6 +1283,15 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return (Node => Container.Nodes (Position.Node).Prev);\n    end Previous;\n \n+   function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+   begin\n+\n+      return Previous (Object.Container.all, Position);\n+   end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1196,6 +1368,21 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       raise Program_Error with \"attempt to stream list cursor\";\n    end Read;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference (Container : List; Position : Cursor)\n+   return Constant_Reference_Type is\n+   begin\n+\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Element => Container.Nodes (Position.Node).Element'Access);\n+   end Constant_Reference;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------"}, {"sha": "c6deaf1669318b45f0802a2707b35a4cdb75acb4", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -53,6 +53,7 @@\n \n private with Ada.Streams;\n with Ada.Containers;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type is private;\n@@ -63,7 +64,10 @@ generic\n package Ada.Containers.Formal_Doubly_Linked_Lists is\n    pragma Pure;\n \n-   type List (Capacity : Count_Type) is tagged private;\n+   type List (Capacity : Count_Type) is tagged private with\n+      Constant_Indexing => Constant_Reference,\n+      Default_Iterator  => Iterate,\n+      Iterator_Element  => Element_Type;\n    --  pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;\n@@ -73,6 +77,17 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    No_Element : constant Cursor;\n \n+   function Not_No_Element (Position : Cursor) return Boolean;\n+\n+   package List_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor => Cursor, Has_Element => Not_No_Element);\n+\n+   function Iterate (Container : List; Start : Cursor)\n+      return List_Iterator_Interfaces.Reversible_Iterator'Class;\n+\n+   function Iterate (Container : List)\n+      return List_Iterator_Interfaces.Reversible_Iterator'Class;\n+\n    function \"=\" (Left, Right : List) return Boolean;\n \n    function Length (Container : List) return Count_Type;\n@@ -225,6 +240,15 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : List; Position : Cursor)    --  SHOULD BE ALIASED\n+   return Constant_Reference_Type;\n+\n    function Strict_Equal (Left, Right : List) return Boolean;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n@@ -244,8 +268,9 @@ private\n    type Node_Type is record\n       Prev    : Count_Type'Base := -1;\n       Next    : Count_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n+\n    function \"=\" (L, R : Node_Type) return Boolean is abstract;\n \n    type Node_Array is array (Count_Type range <>) of Node_Type;\n@@ -275,6 +300,9 @@ private\n \n    for List'Write use Write;\n \n+   type List_Access is access all List;\n+   for List_Access'Storage_Size use 0;\n+\n    type Cursor is record\n       Node : Count_Type := 0;\n    end record;\n@@ -295,4 +323,7 @@ private\n \n    No_Element : constant Cursor := (Node => 0);\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is null record;\n+\n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "34ff36a63b5a16ebcb043557d1524f46b4534159", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -3003,7 +3003,7 @@ package body Exp_Ch5 is\n          --    Cursor : Cursor_type := First (Iter);\n          --    while Has_Element (Iter) loop\n          --       declare\n-         --       --  the block is added when Element_Type is controlled\n+         --       --  The block is added when Element_Type is controlled\n \n          --          Obj : Pack.Element_Type := Element (Cursor);\n          --          --  for the \"of\" loop form\n@@ -3052,7 +3052,7 @@ package body Exp_Ch5 is\n             --  The \"of\" case uses an internally generated cursor whose type\n             --  is found in the container package. The domain of iteration\n             --  is expanded into a call to the default Iterator function, but\n-            --  this expansion does not take place in a quantifier expressions\n+            --  this expansion does not take place in quantified expressions\n             --  that are analyzed with expansion disabled, and in that case the\n             --  type of the iterator must be obtained from the aspect.\n \n@@ -3103,8 +3103,8 @@ package body Exp_Ch5 is\n                         New_List (Container_Arg)));\n                   Analyze_And_Resolve (Name (I_Spec));\n \n-                  --  Find cursor type in proper iterator package, which\n-                  --  is an instantiation of Iterator_Interfaces.\n+                  --  Find cursor type in proper iterator package, which is an\n+                  --  instantiation of Iterator_Interfaces.\n \n                   Ent := First_Entity (Pack);\n                   while Present (Ent) loop\n@@ -3218,7 +3218,7 @@ package body Exp_Ch5 is\n             --    while Iterator.Has_Element loop\n             --       <Stats>\n             --    end loop;\n-            --\n+\n             --   Has_Element is the second actual in the iterator package\n \n             New_Loop :=\n@@ -3236,12 +3236,8 @@ package body Exp_Ch5 is\n \n                 Statements => Stats,\n                 End_Label  => Empty);\n-            --                 Make_Selected_Component (Loc,\n-            --       Prefix => New_Reference_To (Cursor, Loc),\n-            --          Selector_Name =>\n-            --         Make_Identifier (Loc, Name_Has_Element))),\n \n-            --  Create the declarations for Iterator and cursor and insert then\n+            --  Create the declarations for Iterator and cursor and insert them\n             --  before the source loop. Given that the domain of iteration is\n             --  already an entity, the iterator is just a renaming of that\n             --  entity. Possible optimization ???"}, {"sha": "4283dfc140f6ea6bb579fe3e613e34591aa6314d", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -1157,8 +1157,8 @@ package body Prj.Conf is\n                      if Path_FD /= Invalid_FD then\n                         declare\n                            Temp_Dir : constant String :=\n-                             Containing_Directory\n-                               (Get_Name_String (Path_Name));\n+                                        Containing_Directory\n+                                          (Get_Name_String (Path_Name));\n                         begin\n                            GNAT.OS_Lib.Close (Path_FD);\n                            Args (3) :="}, {"sha": "3557ed813c37071e22cf385c08c12028704fce75", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -3795,10 +3795,10 @@ package body Sem_Ch12 is\n       then\n          declare\n             Assoc : constant Node_Id := First (Generic_Associations (N));\n-\n          begin\n             if not Has_Dimension_System\n-                     (Etype (Explicit_Generic_Actual_Parameter (Assoc))) then\n+                     (Etype (Explicit_Generic_Actual_Parameter (Assoc)))\n+            then\n                Error_Msg_N (\"type with a dimension system expected\", Assoc);\n             end if;\n          end;"}, {"sha": "f90fa0ad34103306081633b0ed3673c15ef60129", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 163, "deletions": 160, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -217,76 +217,72 @@ package body Sem_Dim is\n    -----------------------\n \n    procedure Analyze_Dimension_Assignment_Statement (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for assignment statement\n-   --  Check that the dimensions of the left-hand side and the right-hand side\n-   --  of N match.\n+   --  Subroutine of Analyze_Dimension for assignment statement. Check that the\n+   --  dimensions of the left-hand side and the right-hand side of N match.\n \n    procedure Analyze_Dimension_Binary_Op (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for binary operators\n-   --  Check the dimensions of the right and the left operand permit the\n-   --  operation. Then, evaluate the resulting dimensions for each binary\n-   --  operator.\n+   --  Subroutine of Analyze_Dimension for binary operators. Check the\n+   --  dimensions of the right and the left operand permit the operation.\n+   --  Then, evaluate the resulting dimensions for each binary operator.\n \n    procedure Analyze_Dimension_Component_Declaration (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for component declaration\n-   --  Check that the dimensions of the type of N and of the expression match.\n+   --  Subroutine of Analyze_Dimension for component declaration. Check that\n+   --  the dimensions of the type of N and of the expression match.\n \n    procedure Analyze_Dimension_Extended_Return_Statement (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for extended return statement\n-   --  Check that the dimensions of the returned type and of the returned\n-   --  object match.\n+   --  Subroutine of Analyze_Dimension for extended return statement. Check\n+   --  that the dimensions of the returned type and of the returned object\n+   --  match.\n \n    procedure Analyze_Dimension_Function_Call (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for function call\n-   --  General case: propagate the dimensions from the returned type to N.\n-   --  Elementary function case (Ada.Numerics.Generic_Elementary_Functions):\n-   --  If N is a Sqrt call, then evaluate the resulting dimensions as half the\n-   --  dimensions of the parameter. Otherwise, verify that each parameters are\n-   --  dimensionless.\n+   --  Subroutine of Analyze_Dimension for function call. General case:\n+   --  propagate the dimensions from the returned type to N. Elementary\n+   --  function case (Ada.Numerics.Generic_Elementary_Functions): If N\n+   --  is a Sqrt call, then evaluate the resulting dimensions as half the\n+   --  dimensions of the parameter. Otherwise, verify that each parameters\n+   --  are dimensionless.\n \n    procedure Analyze_Dimension_Has_Etype (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for a subset of N_Has_Etype denoted by\n    --  the list below:\n-   --  N_Attribute_Reference\n-   --  N_Identifier\n-   --  N_Indexed_Component\n-   --  N_Qualified_Expression\n-   --  N_Selected_Component\n-   --  N_Slice\n-   --  N_Type_Conversion\n-   --  N_Unchecked_Type_Conversion\n+   --    N_Attribute_Reference\n+   --    N_Identifier\n+   --    N_Indexed_Component\n+   --    N_Qualified_Expression\n+   --    N_Selected_Component\n+   --    N_Slice\n+   --    N_Type_Conversion\n+   --    N_Unchecked_Type_Conversion\n \n    procedure Analyze_Dimension_Object_Declaration (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for object declaration\n-   --  Check that the dimensions of the object type and the dimensions of the\n-   --  expression (if expression is present) match.\n-   --  Note that when the expression is a literal, no warning is returned.\n-   --  This special case allows object declaration such as:\n-   --  m : constant Length := 1.0;\n+   --  Subroutine of Analyze_Dimension for object declaration. Check that\n+   --  the dimensions of the object type and the dimensions of the expression\n+   --  (if expression is present) match. Note that when the expression is\n+   --  a literal, no warning is returned. This special case allows object\n+   --  declaration such as: m : constant Length := 1.0;\n \n    procedure Analyze_Dimension_Object_Renaming_Declaration (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for object renaming declaration\n-   --  Check the dimensions of the type and of the renamed object name of N\n-   --  match.\n+   --  Subroutine of Analyze_Dimension for object renaming declaration. Check\n+   --  the dimensions of the type and of the renamed object name of N match.\n \n    procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for simple return statement\n    --  Check that the dimensions of the returned type and of the returned\n    --  expression match.\n \n    procedure Analyze_Dimension_Subtype_Declaration (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for subtype declaration\n-   --  Propagate the dimensions from the parent type to the identifier of N.\n-   --  Note that if both the identifier and the parent type of N are not\n-   --  dimensionless, return an error message.\n+   --  Subroutine of Analyze_Dimension for subtype declaration. Propagate the\n+   --  dimensions from the parent type to the identifier of N. Note that if\n+   --  both the identifier and the parent type of N are not dimensionless,\n+   --  return an error message.\n \n    procedure Analyze_Dimension_Unary_Op (N : Node_Id);\n-   --  Subroutine of Analyze_Dimension for unary operators\n-   --  For Plus, Minus and Abs operators, propagate the dimensions from the\n-   --  operand to N.\n+   --  Subroutine of Analyze_Dimension for unary operators. For Plus, Minus and\n+   --  Abs operators, propagate the dimensions from the operand to N.\n \n-   function Create_Rational_From (Expr     : Node_Id;\n-                                  Complain : Boolean) return Rational;\n+   function Create_Rational_From\n+     (Expr     : Node_Id;\n+      Complain : Boolean) return Rational;\n    --  Given an arbitrary expression Expr, return a valid rational if Expr can\n    --  be interpreted as a rational. Otherwise return No_Rational and also an\n    --  error message if Complain is set to True.\n@@ -301,14 +297,13 @@ package body Sem_Dim is\n    procedure Eval_Op_Expon_With_Rational_Exponent\n      (N              : Node_Id;\n       Exponent_Value : Rational);\n-   --  Evaluate the Expon if the exponent is a rational and the operand has a\n-   --  dimension.\n+   --  Evaluate the exponent it is a rational and the operand has a dimension\n \n    function Exists (Dim : Dimension_Type) return Boolean;\n-   --  Determine whether Dim does not denote the null dimension\n+   --  Returns True iff Dim does not denote the null dimension\n \n    function Exists (Sys : System_Type) return Boolean;\n-   --  Determine whether Sys does not denote the null system\n+   --  Returns True iff Sys does not denote the null system\n \n    function From_Dimension_To_String_Of_Symbols\n      (Dims   : Dimension_Type;\n@@ -317,7 +312,7 @@ package body Sem_Dim is\n    --  string of symbols.\n \n    function Is_Invalid (Position : Dimension_Position) return Boolean;\n-   --  Determine whether Pos denotes the invalid position\n+   --  Return True if Pos denotes the invalid position\n \n    procedure Move_Dimensions (From : Node_Id; To : Node_Id);\n    --  Copy dimension vector of From to To, delete dimension vector of From\n@@ -385,7 +380,6 @@ package body Sem_Dim is\n       R : constant Rational :=\n             Rational'(Numerator =>   Left.Numerator * Right.Numerator,\n                       Denominator => Left.Denominator * Right.Denominator);\n-\n    begin\n       return Reduce (R);\n    end \"*\";\n@@ -558,14 +552,15 @@ package body Sem_Dim is\n       System         : System_Type;\n       Typ            : Entity_Id;\n \n-      Errors_Count   : Nat;\n+      Errors_Count : Nat;\n       --  Errors_Count is a count of errors detected by the compiler so far\n       --  just before the extraction of names and values in the aggregate\n       --  (Step 3).\n-      --  At the end of the analysis, there is a check to verify that\n-      --  this count equals to Serious_Errors_Detected i.e. no erros have been\n-      --  encountered during the process. Otherwise the Dimension_Table is not\n-      --  filled.\n+      --\n+      --  At the end of the analysis, there is a check to verify that this\n+      --  count equals to Serious_Errors_Detected i.e. no erros have been\n+      --  encountered during the process. Otherwise the Dimension_Table is\n+      --  not filled.\n \n    --  Start of processing for Analyze_Aspect_Dimension\n \n@@ -582,9 +577,8 @@ package body Sem_Dim is\n       System := System_Of (Typ);\n \n       if Nkind (Sub_Ind) = N_Subtype_Indication then\n-         Error_Msg_NE (\"constraint not allowed with aspect&\",\n-                       Constraint (Sub_Ind),\n-                       Id);\n+         Error_Msg_NE\n+           (\"constraint not allowed with aspect&\", Constraint (Sub_Ind), Id);\n          return;\n       end if;\n \n@@ -604,9 +598,8 @@ package body Sem_Dim is\n       --  declare a valid system.\n \n       if not Exists (System) then\n-         Error_Msg_NE (\"parent type of& lacks dimension system\",\n-                       Sub_Ind,\n-                       Def_Id);\n+         Error_Msg_NE\n+           (\"parent type of& lacks dimension system\", Sub_Ind, Def_Id);\n          return;\n       end if;\n \n@@ -656,7 +649,6 @@ package body Sem_Dim is\n       while Present (Assoc) loop\n          Expr   := Expression (Assoc);\n          Choice := First (Choices (Assoc));\n-\n          while Present (Choice) loop\n \n             --  Identifier case: NAME => EXPRESSION\n@@ -682,8 +674,10 @@ package body Sem_Dim is\n                begin\n                   if Nkind (Low) /= N_Identifier then\n                      Error_Msg_N (\"bound must denote a dimension name\", Low);\n+\n                   elsif Nkind (High) /= N_Identifier then\n                      Error_Msg_N (\"bound must denote a dimension name\", High);\n+\n                   else\n                      Low_Pos  := Position_In_System (Low, System);\n                      High_Pos := Position_In_System (High, System);\n@@ -743,12 +737,10 @@ package body Sem_Dim is\n             end if;\n \n             Num_Choices := Num_Choices + 1;\n-\n             Next (Choice);\n          end loop;\n \n          Num_Dimensions := Num_Dimensions + 1;\n-\n          Next (Assoc);\n       end loop;\n \n@@ -774,6 +766,7 @@ package body Sem_Dim is\n          Start_String;\n          Store_String_Char (UI_To_CC (Char_Literal_Value (Symbol_Decl)));\n          Symbol := End_String;\n+\n       else\n          Symbol := Strval (Symbol_Decl);\n       end if;\n@@ -836,7 +829,7 @@ package body Sem_Dim is\n                         (Entity (Subtype_Indication (Type_Definition (N))));\n       end Is_Derived_Numeric_Type;\n \n-   --  Local variables\n+      --  Local variables\n \n       Dim_Name     : Node_Id;\n       Dim_Pair     : Node_Id;\n@@ -850,10 +843,11 @@ package body Sem_Dim is\n       --  Errors_Count is a count of errors detected by the compiler so far\n       --  just before the extraction of names and symbols in the aggregate\n       --  (Step 3).\n-      --  At the end of the analysis, there is a check to verify that\n-      --  this count equals to Serious_Errors_Detected i.e. no erros have been\n-      --  encountered during the process. Otherwise the System_Table is not\n-      --  filled.\n+      --\n+      --  At the end of the analysis, there is a check to verify that this\n+      --  count equals Serious_Errors_Detected i.e. no errors have been\n+      --  encountered during the process. Otherwise the System_Table is\n+      --  not filled.\n \n    --  Start of processing for Analyze_Aspect_Dimension_System\n \n@@ -882,7 +876,6 @@ package body Sem_Dim is\n \n       Dim_Pair     := First (Expressions (Aggr));\n       Errors_Count := Serious_Errors_Detected;\n-\n       while Present (Dim_Pair) loop\n          Position := Position + 1;\n \n@@ -941,14 +934,14 @@ package body Sem_Dim is\n                      --  Verify that the string is not empty\n \n                      if String_Length (Symbols (Position)) = 0 then\n-                        Error_Msg_N (\"empty string not allowed here\",\n-                                     Dim_Symbol);\n+                        Error_Msg_N\n+                          (\"empty string not allowed here\", Dim_Symbol);\n                      end if;\n                   end if;\n \n                else\n-                  Error_Msg_N (\"two expressions expected in aggregate\",\n-                               Dim_Pair);\n+                  Error_Msg_N\n+                    (\"two expressions expected in aggregate\", Dim_Pair);\n                end if;\n             end if;\n          end if;\n@@ -1043,9 +1036,8 @@ package body Sem_Dim is\n       Dims_Of_Rhs : constant Dimension_Type := Dimensions_Of (Rhs);\n \n       procedure Error_Dim_For_Assignment_Statement (N, Lhs, Rhs : Node_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of left and right hand\n-      --  sides.\n+      --  Error using Error_Msg_N at node N. Output in the error message the\n+      --  dimensions of left and right hand sides.\n \n       ----------------------------------------\n       -- Error_Dim_For_Assignment_Statement --\n@@ -1102,24 +1094,26 @@ package body Sem_Dim is\n         or else N_Kind in N_Op_Compare\n       then\n          declare\n-            L                 : constant Node_Id := Left_Opnd (N);\n-            Dims_Of_L         : constant Dimension_Type := Dimensions_Of (L);\n-            L_Has_Dimensions  : constant Boolean := Exists (Dims_Of_L);\n-            R                 : constant Node_Id := Right_Opnd (N);\n-            Dims_Of_R         : constant Dimension_Type := Dimensions_Of (R);\n-            R_Has_Dimensions  : constant Boolean := Exists (Dims_Of_R);\n-            Dims_Of_N         : Dimension_Type := Null_Dimension;\n+            L                : constant Node_Id := Left_Opnd (N);\n+            Dims_Of_L        : constant Dimension_Type := Dimensions_Of (L);\n+            L_Has_Dimensions : constant Boolean := Exists (Dims_Of_L);\n+            R                : constant Node_Id := Right_Opnd (N);\n+            Dims_Of_R        : constant Dimension_Type := Dimensions_Of (R);\n+            R_Has_Dimensions : constant Boolean := Exists (Dims_Of_R);\n+            Dims_Of_N        : Dimension_Type := Null_Dimension;\n \n          begin\n             --  N_Op_Add, N_Op_Mod, N_Op_Rem or N_Op_Subtract case\n \n             if Nkind_In (N, N_Op_Add, N_Op_Mod, N_Op_Rem, N_Op_Subtract) then\n+\n                --  Check both operands have same dimension\n \n                if Dims_Of_L /= Dims_Of_R then\n                   Error_Dim_For_Binary_Op (N, L, R);\n                else\n                   --  Check both operands are not dimensionless\n+\n                   if Exists (Dims_Of_L) then\n                      Set_Dimensions (N, Dims_Of_L);\n                   end if;\n@@ -1128,11 +1122,13 @@ package body Sem_Dim is\n             --  N_Op_Multiply or N_Op_Divide case\n \n             elsif Nkind_In (N_Kind, N_Op_Multiply, N_Op_Divide) then\n+\n                --  Check at least one operand is not dimensionless\n \n                if L_Has_Dimensions or R_Has_Dimensions then\n \n                   --  Multiplication case\n+\n                   --  Get both operands dimensions and add them\n \n                   if N_Kind = N_Op_Multiply then\n@@ -1142,6 +1138,7 @@ package body Sem_Dim is\n                      end loop;\n \n                   --  Division case\n+\n                   --  Get both operands dimensions and subtract them\n \n                   else\n@@ -1156,14 +1153,15 @@ package body Sem_Dim is\n                   end if;\n                end if;\n \n-            --  N_Op_Expon case\n-            --  Note that rational exponent are allowed for dimensioned operand\n+            --  Exponentiation case\n+\n+            --  Note: a rational exponent is allowed for dimensioned operand\n \n             elsif N_Kind = N_Op_Expon then\n-               --  Check the left operand is not dimensionless\n-               --  Note that the value of the exponent must be known compile\n-               --  time. Otherwise, the exponentiation evaluation will return\n-               --  an error message.\n+\n+               --  Check the left operand is not dimensionless. Note that the\n+               --  value of the exponent must be known compile time. Otherwise,\n+               --  the exponentiation evaluation will return an error message.\n \n                if L_Has_Dimensions\n                  and then Compile_Time_Known_Value (R)\n@@ -1189,7 +1187,8 @@ package body Sem_Dim is\n                              +Whole (UI_To_Int (Expr_Value (R)));\n                         end if;\n \n-                     --  Integer operand case\n+                     --  Integer operand case.\n+\n                      --  For integer operand, the exponent cannot be\n                      --  interpreted as a rational.\n \n@@ -1208,13 +1207,14 @@ package body Sem_Dim is\n                   end;\n                end if;\n \n-            --  N_Op_Compare case\n-            --  For relational operations, only a dimension checking is\n+            --  Comparison cases\n+\n+            --  For relational operations, only dimension checking is\n             --  performed (no propagation).\n \n             elsif N_Kind in N_Op_Compare then\n                if (L_Has_Dimensions or R_Has_Dimensions)\n-                  and then Dims_Of_L /= Dims_Of_R\n+                 and then Dims_Of_L /= Dims_Of_R\n                then\n                   Error_Dim_For_Binary_Op (N, L, R);\n                end if;\n@@ -1233,19 +1233,18 @@ package body Sem_Dim is\n    ---------------------------------------------\n \n    procedure Analyze_Dimension_Component_Declaration (N : Node_Id) is\n-      Expr         : constant Node_Id    := Expression (N);\n-      Id           : constant Entity_Id  := Defining_Identifier (N);\n-      Etyp         : constant Entity_Id  := Etype (Id);\n+      Expr         : constant Node_Id        := Expression (N);\n+      Id           : constant Entity_Id      := Defining_Identifier (N);\n+      Etyp         : constant Entity_Id      := Etype (Id);\n       Dims_Of_Etyp : constant Dimension_Type := Dimensions_Of (Etyp);\n       Dims_Of_Expr : Dimension_Type;\n \n       procedure Error_Dim_For_Component_Declaration\n         (N    : Node_Id;\n          Etyp : Entity_Id;\n          Expr : Node_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of the type Etyp and the\n-      --  expression Expr of N.\n+      --  Error using Error_Msg_N at node N. Output in the error message the\n+      --  dimensions of the type Etyp and the expression Expr of N.\n \n       -----------------------------------------\n       -- Error_Dim_For_Component_Declaration --\n@@ -1257,8 +1256,8 @@ package body Sem_Dim is\n          Expr : Node_Id) is\n       begin\n          Error_Msg_N (\"?dimensions mismatch in component declaration\", N);\n-         Error_Msg_N (\"?component type \" & Dimensions_Msg_Of (Etyp), N);\n-         Error_Msg_N (\"?component expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\?component type \" & Dimensions_Msg_Of (Etyp), N);\n+         Error_Msg_N (\"\\?component expression \" & Dimensions_Msg_Of (Expr), N);\n       end Error_Dim_For_Component_Declaration;\n \n    --  Start of processing for Analyze_Dimension_Component_Declaration\n@@ -1301,9 +1300,9 @@ package body Sem_Dim is\n         (N             : Node_Id;\n          Return_Etyp   : Entity_Id;\n          Return_Obj_Id : Entity_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of the returned type\n-      --  Return_Etyp and the returned object Return_Obj_Id of N.\n+      --  Warning using Error_Msg_N at node N. Output in the error message the\n+      --  dimensions of the returned type Return_Etyp and the returned object\n+      --  Return_Obj_Id of N.\n \n       ---------------------------------------------\n       -- Error_Dim_For_Extended_Return_Statement --\n@@ -1325,7 +1324,6 @@ package body Sem_Dim is\n    begin\n       if Present (Return_Obj_Decls) then\n          Return_Obj_Decl := First (Return_Obj_Decls);\n-\n          while Present (Return_Obj_Decl) loop\n             if Nkind (Return_Obj_Decl) = N_Object_Declaration then\n                Return_Obj_Id := Defining_Identifier (Return_Obj_Decl);\n@@ -1369,7 +1367,7 @@ package body Sem_Dim is\n          Ent : Entity_Id;\n \n       begin\n-         --  Note that the node must come from source\n+         --  Note that the node must come from source (why not???)\n \n          if Comes_From_Source (N) and then Is_Entity_Name (Name_Call) then\n             Ent := Entity (Name_Call);\n@@ -1415,8 +1413,7 @@ package body Sem_Dim is\n             end if;\n \n          --  All other functions in Ada.Numerics.Generic_Elementary_Functions\n-         --  case.\n-         --  Note that all parameters here should be dimensionless\n+         --  case. Note that all parameters here should be dimensionless.\n \n          else\n             Actual := First (Actuals);\n@@ -1427,8 +1424,8 @@ package body Sem_Dim is\n                   Error_Msg_NE\n                     (\"?parameter should be dimensionless for elementary \"\n                      & \"function&\", Actual, Name_Call);\n-                  Error_Msg_N (\"?parameter \" & Dimensions_Msg_Of (Actual),\n-                               Actual);\n+                  Error_Msg_N\n+                    (\"?parameter \" & Dimensions_Msg_Of (Actual), Actual);\n                end if;\n \n                Next (Actual);\n@@ -1460,11 +1457,12 @@ package body Sem_Dim is\n \n       --  Removal of dimensions in expression\n \n+      --  Wouldn't a case statement be clearer here???\n+\n       if Nkind_In (N_Kind, N_Attribute_Reference, N_Indexed_Component) then\n          declare\n             Expr  : Node_Id;\n             Exprs : constant List_Id := Expressions (N);\n-\n          begin\n             if Present (Exprs) then\n                Expr := First (Exprs);\n@@ -1475,11 +1473,9 @@ package body Sem_Dim is\n             end if;\n          end;\n \n-      elsif Nkind_In\n-              (N_Kind,\n-                 N_Qualified_Expression,\n-                 N_Type_Conversion,\n-                 N_Unchecked_Type_Conversion)\n+      elsif Nkind_In (N_Kind, N_Qualified_Expression,\n+                              N_Type_Conversion,\n+                              N_Unchecked_Type_Conversion)\n       then\n          Remove_Dimensions (Expression (N));\n \n@@ -1503,9 +1499,8 @@ package body Sem_Dim is\n         (N    : Node_Id;\n          Etyp : Entity_Id;\n          Expr : Node_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of the type Etyp and the\n-      --  expression Expr of N.\n+      --  Warnings using Error_Msg_N at node N. Output in the error message the\n+      --  dimensions of the type Etyp and the ???\n \n       --------------------------------------\n       -- Error_Dim_For_Object_Declaration --\n@@ -1517,8 +1512,8 @@ package body Sem_Dim is\n          Expr : Node_Id) is\n       begin\n          Error_Msg_N (\"?dimensions mismatch in object declaration\", N);\n-         Error_Msg_N (\"?object type \" & Dimensions_Msg_Of (Etyp), N);\n-         Error_Msg_N (\"?object expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\?object type \" & Dimensions_Msg_Of (Etyp), N);\n+         Error_Msg_N (\"\\?object expression \" & Dimensions_Msg_Of (Expr), N);\n       end Error_Dim_For_Object_Declaration;\n \n    --  Start of processing for Analyze_Dimension_Object_Declaration\n@@ -1558,9 +1553,8 @@ package body Sem_Dim is\n         (N            : Node_Id;\n          Sub_Mark     : Node_Id;\n          Renamed_Name : Node_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of Sub_Mark and of\n-      --  Renamed_Name.\n+      --  Error using Error_Msg_N at node N. Output in the error message the\n+      --  dimensions of Sub_Mark and of Renamed_Name.\n \n       -----------------------------------------------\n       -- Error_Dim_For_Object_Renaming_Declaration --\n@@ -1604,9 +1598,9 @@ package body Sem_Dim is\n         (N           : Node_Id;\n          Return_Etyp : Entity_Id;\n          Expr        : Node_Id);\n-      --  Error using Error_Msg_N at node N\n-      --  Output in the error message the dimensions of the returned type\n-      --  Return_Etyp and the returned expression Expr of N.\n+      --  Error using Error_Msg_N at node N. Output in the error message\n+      --  the dimensions of the returned type Return_Etyp and the returned\n+      --  expression Expr of N.\n \n       -------------------------------------------\n       -- Error_Dim_For_Simple_Return_Statement --\n@@ -1619,8 +1613,8 @@ package body Sem_Dim is\n       is\n       begin\n          Error_Msg_N (\"?dimensions mismatch in return statement\", N);\n-         Error_Msg_N (\"?returned type \" & Dimensions_Msg_Of (Return_Etyp), N);\n-         Error_Msg_N (\"?returned expression \" & Dimensions_Msg_Of (Expr), N);\n+         Error_Msg_N (\"\\?returned type \" & Dimensions_Msg_Of (Return_Etyp), N);\n+         Error_Msg_N (\"\\?returned expression \" & Dimensions_Msg_Of (Expr), N);\n       end Error_Dim_For_Simple_Return_Statement;\n \n    --  Start of processing for Analyze_Dimension_Simple_Return_Statement\n@@ -1650,6 +1644,7 @@ package body Sem_Dim is\n          Dims_Of_Etyp := Dimensions_Of (Etyp);\n \n          if Exists (Dims_Of_Etyp) then\n+\n             --  If subtype already has a dimension (from Aspect_Dimension),\n             --  it cannot inherit a dimension from its subtype.\n \n@@ -1705,27 +1700,29 @@ package body Sem_Dim is\n    --  A rational number is a number that can be expressed as the quotient or\n    --  fraction a/b of two integers, where b is non-zero.\n \n-   function Create_Rational_From (Expr     : Node_Id;\n-                                  Complain : Boolean) return Rational is\n+   function Create_Rational_From\n+     (Expr     : Node_Id;\n+      Complain : Boolean) return Rational\n+   is\n       Or_Node_Of_Expr : constant Node_Id := Original_Node (Expr);\n       Result          : Rational := No_Rational;\n \n       function Process_Minus (N : Node_Id) return Rational;\n-      --  Create a rational from a N_Op_Minus\n+      --  Create a rational from a N_Op_Minus node\n \n       function Process_Divide (N : Node_Id) return Rational;\n-      --  Create a rational from a N_Op_Divide\n+      --  Create a rational from a N_Op_Divide node\n \n       function Process_Literal (N : Node_Id) return Rational;\n-      --  Create a rational from a N_Integer_Literal\n+      --  Create a rational from a N_Integer_Literal node\n \n       -------------------\n       -- Process_Minus --\n       -------------------\n \n       function Process_Minus (N : Node_Id) return Rational is\n          Right  : constant Node_Id := Original_Node (Right_Opnd (N));\n-         Result : Rational := No_Rational;\n+         Result : Rational;\n \n       begin\n          --  Operand is an integer literal\n@@ -1737,6 +1734,9 @@ package body Sem_Dim is\n \n          elsif Nkind (Right) = N_Op_Divide then\n             Result := -Process_Divide (Right);\n+\n+         else\n+            Result := No_Rational;\n          end if;\n \n          return Result;\n@@ -1780,9 +1780,8 @@ package body Sem_Dim is\n \n    begin\n       --  Check the expression is either a division of two integers or an\n-      --  integer itself.\n-      --  Note that the check applies to the original node since the node could\n-      --  have already been rewritten.\n+      --  integer itself. Note that the check applies to the original node\n+      --  since the node could have already been rewritten.\n \n       --  Integer literal case\n \n@@ -1801,7 +1800,7 @@ package body Sem_Dim is\n       end if;\n \n       --  When Expr cannot be interpreted as a rational and Complain is true,\n-      --  return an error message.\n+      --  generate an error message.\n \n       if Complain and then Result = No_Rational then\n          Error_Msg_N (\"must be a rational\", Expr);\n@@ -1915,8 +1914,8 @@ package body Sem_Dim is\n    -- Eval_Op_Expon_For_Dimensioned_Type --\n    ----------------------------------------\n \n-   --  Evaluate the expon operator for real dimensioned type\n-   --  Note that the node must come from source\n+   --  Evaluate the expon operator for real dimensioned type. Note that the\n+   --  node must come from source. Why???\n \n    --  Note that if the exponent is an integer (denominator = 1) the node is\n    --  evaluated by the regular Eval_Op_Expon routine (see Sem_Eval).\n@@ -1937,9 +1936,7 @@ package body Sem_Dim is\n \n       --  Check that the exponent is not an integer\n \n-      if R_Value /= No_Rational\n-        and then R_Value.Denominator /= 1\n-      then\n+      if R_Value /= No_Rational and then R_Value.Denominator /= 1 then\n          Eval_Op_Expon_With_Rational_Exponent (N, R_Value);\n       else\n          Eval_Op_Expon (N);\n@@ -2051,7 +2048,7 @@ package body Sem_Dim is\n \n          Analyze (New_Subtyp_Decl_For_L);\n \n-         --  Case where the operand is dimensionless\n+      --  Case where the operand is dimensionless\n \n       else\n          New_Id := Btyp_Of_L;\n@@ -2068,8 +2065,9 @@ package body Sem_Dim is\n \n       --  (T (Expon_LLF (Actual_1, Actual_2)));\n \n-      --  --  where T is the subtype declared in step 1\n-      --  -- The node is rewritten as a type conversion\n+      --  where T is the subtype declared in step 1\n+\n+      --  The node is rewritten as a type conversion\n \n       --  Step 1: Creation of the two parameters of Expon_LLF function call\n \n@@ -2098,7 +2096,7 @@ package body Sem_Dim is\n                Parameter_Associations => New_List (\n                  Actual_1, Actual_2)));\n \n-      --  Step 3: Rewitten of N\n+      --  Step 3: Rewrite N with the result\n \n       Rewrite (N, New_N);\n       Set_Etype (N, New_Id);\n@@ -2128,9 +2126,10 @@ package body Sem_Dim is\n    --  symbols in the output of a dimensioned object.\n \n    --  Case 1: the parameter is a variable\n+\n    --  The default string parameter is replaced by the symbol defined in the\n-   --  aspect Dimension of the subtype.\n-   --  For instance if the user wants to output a speed:\n+   --  aspect Dimension of the subtype. For instance to output a speed:\n+\n    --  subtype Force is Mks_Type\n    --    with\n    --      Dimension => (\"N\",\n@@ -2143,11 +2142,12 @@ package body Sem_Dim is\n    --  > 2.1 N\n \n    --  Case 2: the parameter is an expression\n-   --  then we call the procedure Expand_Put_Call_With_Dimension_Symbol that\n-   --  creates the string of symbols (for instance \"m.s**(-1)\") and rewrites\n-   --  the default string parameter of Put with the corresponding the\n-   --  String_Id.\n-   --  For instance:\n+\n+   --  In this case we call the procedure Expand_Put_Call_With_Dimension_Symbol\n+   --  that creates the string of symbols (for instance \"m.s**(-1)\") and\n+   --  rewrites the default string parameter of Put with the corresponding\n+   --  the String_Id. For instance:\n+\n    --  Put (2.1 * m * kg * s**(-2));\n    --  > 2.1 m.kg.s**(-2)\n \n@@ -2170,6 +2170,10 @@ package body Sem_Dim is\n       --  procedure Put defined in the package System.Dim_Float_IO and\n       --  System.Dim_Integer_IO.\n \n+      ---------------------------\n+      -- Is_Procedure_Put_Call --\n+      ---------------------------\n+\n       function Is_Procedure_Put_Call return Boolean is\n          Ent : Entity_Id;\n \n@@ -2307,9 +2311,9 @@ package body Sem_Dim is\n    -- From_Dimension_To_String_Of_Symbols --\n    -----------------------------------------\n \n-   --  Given a dimension vector and the corresponding dimension system, create\n-   --  a String_Id to output the dimension symbols corresponding to the\n-   --  dimensions Dims.\n+   --  Given a dimension vector and the corresponding dimension system,\n+   --  create a String_Id to output the dimension symbols corresponding to\n+   --  the dimensions Dims.\n \n    function From_Dimension_To_String_Of_Symbols\n      (Dims   : Dimension_Type;\n@@ -2492,7 +2496,6 @@ package body Sem_Dim is\n \n       declare\n          G : constant Int := GCD (X.Numerator, X.Denominator);\n-\n       begin\n          return Rational'(Numerator =>   Whole (Int (X.Numerator) / G),\n                           Denominator => Whole (Int (X.Denominator) / G));"}, {"sha": "2dce82b03b67fa3f5d2dfcb2981c3d0635ffef98", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88115c2a3945dd9eaf0807385e1cd27c298d3d08/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=88115c2a3945dd9eaf0807385e1cd27c298d3d08", "patch": "@@ -98,10 +98,9 @@ package Sem_Dim is\n       Id   : Entity_Id;\n       Aggr : Node_Id);\n    --  Analyze the contents of aspect Dimension. Associate the provided values\n-   --  and quantifiers with the related context N.\n-   --  Id is the corresponding Aspect_Id (Aspect_Dimension)\n-   --  Aggr is the corresponding expression for the aspect Dimension declared\n-   --  by the declaration of N.\n+   --  and quantifiers with the related context N. Id is the corresponding\n+   --  Aspect_Id (Aspect_Dimension) Aggr is the corresponding expression for\n+   --  the aspect Dimension declared by the declaration of N.\n \n    procedure Analyze_Aspect_Dimension_System\n      (N    : Node_Id;\n@@ -141,9 +140,8 @@ package Sem_Dim is\n       Btyp : Entity_Id);\n    --  Evaluate the Expon operator for dimensioned type with rational exponent.\n    --  Indeed the regular Eval_Op_Expon routine (see package Sem_Eval) is\n-   --  restricted to Integer exponent.\n-   --  This routine deals only with rational exponent which is not an integer\n-   --  if Btyp is a dimensioned type.\n+   --  restricted to Integer exponent. This routine deals only with rational\n+   --  exponent which is not an integer if Btyp is a dimensioned type.\n \n    procedure Expand_Put_Call_With_Dimension_Symbol (N : Node_Id);\n    --  Determine whether N denotes a subprogram call to one of the routines"}]}