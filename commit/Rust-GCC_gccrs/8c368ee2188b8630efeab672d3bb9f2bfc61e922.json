{"sha": "8c368ee2188b8630efeab672d3bb9f2bfc61e922", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzNjhlZTIxODhiODYzMGVmZWFiNjcyZDNiYjlmMmJmYzYxZTkyMg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1998-10-23T20:51:02Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-10-23T20:51:02Z"}, "message": "loop.c (loop_has_tablejump): New variable.\n\n        * loop.c (loop_has_tablejump): New variable.\n        (prescan_loop): Scan for it.\n        (insert_bct): Replace explicit scan with use of it.\n        * regclass.c (regclass): Restore loop variable j.\n        (record_reg_classes): Deterine op_types modifiers and initialize\n        classes[i] before matching constraints.  Handle matching\n        constraints 5-9.\n\nFrom-SVN: r23263", "tree": {"sha": "836799cb66662b6b74c81c8f75e3d8c1b3e41ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/836799cb66662b6b74c81c8f75e3d8c1b3e41ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c368ee2188b8630efeab672d3bb9f2bfc61e922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c368ee2188b8630efeab672d3bb9f2bfc61e922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c368ee2188b8630efeab672d3bb9f2bfc61e922", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c368ee2188b8630efeab672d3bb9f2bfc61e922/comments", "author": null, "committer": null, "parents": [{"sha": "b590bbfd110bc151f231c3a1ea80200f2b0bb60b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b590bbfd110bc151f231c3a1ea80200f2b0bb60b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b590bbfd110bc151f231c3a1ea80200f2b0bb60b"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "09616d2ba921b660f567dc2f93a81ba2fce1bc60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c368ee2188b8630efeab672d3bb9f2bfc61e922", "patch": "@@ -1,3 +1,13 @@\n+Fri Oct 23 23:42:03 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* loop.c (loop_has_tablejump): New variable.\n+\t(prescan_loop): Scan for it.\n+\t(insert_bct): Replace explicit scan with use of it.\n+\t* regclass.c (regclass): Restore loop variable j.\n+\t(record_reg_classes): Deterine op_types modifiers and initialize\n+\tclasses[i] before matching constraints.  Handle matching\n+\tconstraints 5-9.\n+\t\n Fri Oct 23 13:55:48 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* m32r/m32r.c (gen_split_move_double): Call alter_subreg.  Delete"}, {"sha": "befecf110d566ebd68bfc1d206b18bf140a2c95a", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8c368ee2188b8630efeab672d3bb9f2bfc61e922", "patch": "@@ -135,6 +135,10 @@ static int loop_has_call;\n \n static int loop_has_volatile;\n \n+/* Nonzero if there is a tablejump in the current loop.  */\n+\n+static int loop_has_tablejump;\n+\n /* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the\n    current loop.  A continue statement will generate a branch to\n    NEXT_INSN (loop_continue).  */\n@@ -2367,9 +2371,9 @@ constant_high_bytes (p, loop_start)\n #endif\n \f\n /* Scan a loop setting the variables `unknown_address_altered',\n-   `num_mem_sets', `loop_continue', loops_enclosed', `loop_has_call',\n-   and `loop_has_volatile'.  Also, fill in the arrays `loop_mems' and\n-   `loop_store_mems'.  */\n+   `num_mem_sets', `loop_continue', `loops_enclosed', `loop_has_call',\n+   `loop_has_volatile', and `loop_has_tablejump'.\n+   Also, fill in the arrays `loop_mems' and `loop_store_mems'.  */\n \n static void\n prescan_loop (start, end)\n@@ -2389,6 +2393,7 @@ prescan_loop (start, end)\n   unknown_address_altered = 0;\n   loop_has_call = 0;\n   loop_has_volatile = 0;\n+  loop_has_tablejump = 0;\n   loop_store_mems_idx = 0;\n   loop_mems_idx = 0;\n \n@@ -2435,10 +2440,15 @@ prescan_loop (start, end)\n \n \t  if (volatile_refs_p (PATTERN (insn)))\n \t    loop_has_volatile = 1;\n+\n+\t  if (GET_CODE (insn) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n+\t    loop_has_tablejump = 1;\n \t  \n \t  note_stores (PATTERN (insn), note_addr_stored);\n \n-\t  if (!loop_has_multiple_exit_targets\n+\t  if (! loop_has_multiple_exit_targets\n \t      && GET_CODE (insn) == JUMP_INSN\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n@@ -7948,7 +7958,6 @@ insert_bct (loop_start, loop_end)\n {\n   int i;\n   unsigned HOST_WIDE_INT n_iterations;\n-  rtx insn;\n \n   int increment_direction, compare_direction;\n \n@@ -8009,18 +8018,13 @@ insert_bct (loop_start, loop_end)\n \n   /* Make sure that the loop does not jump via a table.\n      (the count register might be used to perform the branch on table).  */\n-  for (insn = loop_start; insn && insn != loop_end; insn = NEXT_INSN (insn))\n+  if (loop_has_tablejump)\n     {\n-      if (GET_CODE (insn) == JUMP_INSN\n-\t  && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n-\t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t\t     \"insert_bct %d: BCT instrumentation failed: computed branch in the loop\\n\",\n-\t\t     loop_num);\n-\t  return;\n-\t}\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"insert_bct %d: BCT instrumentation failed: computed branch in the loop\\n\",\n+\t\t loop_num);\n+      return;\n     }\n \n   /* Account for loop unrolling in instrumented iteration count.  */\n@@ -8045,7 +8049,7 @@ insert_bct (loop_start, loop_end)\n   if (n_iterations > 0)\n     {\n       /* Mark all enclosing loops that they cannot use count register.  */\n-      for (i=loop_num; i != -1; i = loop_outer_loop[i])\n+      for (i = loop_num; i != -1; i = loop_outer_loop[i])\n \tloop_used_count_register[i] = 1;\n       instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));\n       return;"}, {"sha": "8d873f95f5e66e2f10e969480a5f356336dd2b29", "filename": "gcc/regclass.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c368ee2188b8630efeab672d3bb9f2bfc61e922/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=8c368ee2188b8630efeab672d3bb9f2bfc61e922", "patch": "@@ -998,6 +998,7 @@ regclass (f, nregs)\n     {\n       rtx r = gen_rtx_REG (VOIDmode, 0);\n       enum machine_mode m;\n+      register int j;\n \n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \tif (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n@@ -1210,8 +1211,19 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t      continue;\n \t    }\n \n-\t  if (*p == '%')\n-\t    p++;\n+\t  /* Ascertain modifiers for line and skip any modifiers that might\n+\t     occur before first constraint.  */\n+\t  while (*p == '%' || *p == '=' || *p == '+' || *p == '&')\n+\t    {\n+\t      if (*p == '=')\n+\t\top_types[i] = OP_WRITE;\n+\t      else if (*p == '+')\n+\t\top_types[i] = OP_READ_WRITE;\n+\n+\t      p++;\n+\t    }\n+\n+\t  classes[i] = NO_REGS;\n \n \t  /* If this alternative is only relevant when this operand\n \t     matches a previous operand, we do different things depending\n@@ -1281,29 +1293,19 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t     any of the constraints.  Collect the valid register classes\n \t     and see if this operand accepts memory.  */\n \n-\t  classes[i] = NO_REGS;\n \t  while (*p && (c = *p++) != ',')\n \t    switch (c)\n \t      {\n-\t      case '=':\n-\t\top_types[i] = OP_WRITE;\n-\t\tbreak;\n-\n-\t      case '+':\n-\t\top_types[i] = OP_READ_WRITE;\n-\t\tbreak;\n-\n \t      case '*':\n \t\t/* Ignore the next letter for this pass.  */\n \t\tp++;\n \t\tbreak;\n \n \t      case '?':\n \t\talt_cost += 2;\n-\t      case '%':\n-\t      case '!':  case '#':\n-\t      case '&':\n+\t      case '!':  case '#':  case '&':\n \t      case '0':  case '1':  case '2':  case '3':  case '4':\n+\t      case '5':  case '6':  case '7':  case '8':  case '9':\n \t      case 'p':\n \t\tbreak;\n "}]}