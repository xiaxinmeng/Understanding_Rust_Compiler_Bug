{"sha": "8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyOWI1ZWM3ZWJjMTJmOTRmMDNhNjBlY2IyZTAyNmJiMmViZTliZg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-11-15T15:38:07Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-11-15T15:38:07Z"}, "message": "(flow_delete_insn): New function.\n\n(find_basic_blocks): Call it to physically delete insns in\nunreachable blocks.  When scanning blocks after dead ones,\nstart scanning after the dead one (not at the dead one).\nIf there are lots of unreachable blocks, make another pass to squeeze\nthem out (this reduces memory usage in some pathalogical cases by a\nsignificant amount without resorting to sparse matrices).\n(propagate_block): Make code a bit more efficient (for example,\nno need to test `loop_depth' for each insn, just notes).\n\nFrom-SVN: r8440", "tree": {"sha": "9f9c9d4e8a3b5a8b4c1c31e68fe80189b9d14d75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9c9d4e8a3b5a8b4c1c31e68fe80189b9d14d75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf/comments", "author": null, "committer": null, "parents": [{"sha": "3c7d7a4a7dddd51c8349bfb9cc71e3db1a4deeee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c7d7a4a7dddd51c8349bfb9cc71e3db1a4deeee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c7d7a4a7dddd51c8349bfb9cc71e3db1a4deeee"}], "stats": {"total": 164, "additions": 119, "deletions": 45}, "files": [{"sha": "b15817c730cddb7c484f7939e3212f9c175d8ed6", "filename": "gcc/flow.c", "status": "modified", "additions": 119, "deletions": 45, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=8329b5ec7ebc12f94f03a60ecb2e026bb2ebe9bf", "patch": "@@ -293,6 +293,7 @@ void allocate_for_life_analysis\t\tPROTO((void));\n static void init_regset_vector\t\tPROTO((regset *, regset, int, int));\n static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n \t\t\t\t\t       regset, int));\n+static rtx flow_delete_insn\t\tPROTO((rtx));\n static int insn_dead_p\t\t\tPROTO((rtx, regset, int));\n static int libcall_dead_p\t\tPROTO((rtx, regset, rtx, rtx));\n static void mark_set_regs\t\tPROTO((regset, regset, rtx,\n@@ -407,11 +408,15 @@ find_basic_blocks (f, nonlocal_label_list)\n   register char *block_marked = (char *) alloca (n_basic_blocks);\n   /* List of label_refs to all labels whose addresses are taken\n      and used as data.  */\n-  rtx label_value_list = 0;\n+  rtx label_value_list;\n   rtx x, note;\n   enum rtx_code prev_code, code;\n-  int depth;\n+  int depth, pass;\n \n+  pass = 1;\n+ restart:\n+\n+  label_value_list = 0;\n   block_live_static = block_live;\n   bzero (block_live, n_basic_blocks);\n   bzero (block_marked, n_basic_blocks);\n@@ -512,6 +517,7 @@ find_basic_blocks (f, nonlocal_label_list)\n   if (n_basic_blocks > 0)\n     {\n       int something_marked = 1;\n+      int deleted;\n \n       /* Find all indirect jump insns and mark them as possibly jumping to all\n \t the labels whose addresses are explicitly used.  This is because,\n@@ -626,42 +632,72 @@ find_basic_blocks (f, nonlocal_label_list)\n \t They can occur because jump_optimize does not recognize\n \t unreachable loops as unreachable.  */\n \n+      deleted = 0;\n       for (i = 0; i < n_basic_blocks; i++)\n \tif (!block_live[i])\n \t  {\n+\t    deleted++;\n+\n+\t    /* Delete the insns in a (non-live) block.  We physically delete\n+\t       every non-note insn except the start and end (so\n+\t       basic_block_head/end needn't be updated), we turn the latter\n+\t       into NOTE_INSN_DELETED notes.\n+\t       We use to \"delete\" the insns by turning them into notes, but\n+\t       we may be deleting lots of insns that subsequent passes would\n+\t       otherwise have to process.  Secondly, lots of deleted blocks in\n+\t       a row can really slow down propagate_block since it will\n+\t       otherwise process insn-turned-notes multiple times when it\n+\t       looks for loop begin/end notes.  */\n+\t    if (basic_block_head[i] != basic_block_end[i])\n+\t      {\n+\t\tinsn = NEXT_INSN (basic_block_head[i]);\n+\t\twhile (insn != basic_block_end[i])\n+\t\t  {\n+\t\t    if (GET_CODE (insn) == BARRIER)\n+\t\t      abort ();\n+\t\t    else if (GET_CODE (insn) != NOTE)\n+\t\t      insn = flow_delete_insn (insn);\n+\t\t    else\n+\t\t      insn = NEXT_INSN (insn);\n+\t\t  }\n+\t      }\n \t    insn = basic_block_head[i];\n-\t    while (1)\n+\t    if (GET_CODE (insn) != NOTE)\n \t      {\n+\t\t/* Turn the head into a deleted insn note.  */\n \t\tif (GET_CODE (insn) == BARRIER)\n \t\t  abort ();\n-\t\tif (GET_CODE (insn) != NOTE)\n-\t\t  {\n-\t\t    PUT_CODE (insn, NOTE);\n-\t\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t    NOTE_SOURCE_FILE (insn) = 0;\n-\t\t  }\n-\t\tif (insn == basic_block_end[i])\n-\t\t  {\n-\t\t    /* BARRIERs are between basic blocks, not part of one.\n-\t\t       Delete a BARRIER if the preceding jump is deleted.\n-\t\t       We cannot alter a BARRIER into a NOTE\n-\t\t       because it is too short; but we can really delete\n-\t\t       it because it is not part of a basic block.  */\n-\t\t    if (NEXT_INSN (insn) != 0\n-\t\t\t&& GET_CODE (NEXT_INSN (insn)) == BARRIER)\n-\t\t      delete_insn (NEXT_INSN (insn));\n-\t\t    break;\n-\t\t  }\n-\t\tinsn = NEXT_INSN (insn);\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n \t      }\n+\t    insn = basic_block_end[i];\n+\t    if (GET_CODE (insn) != NOTE)\n+\t      {\n+\t\t/* Turn the tail into a deleted insn note.  */\n+\t\tif (GET_CODE (insn) == BARRIER)\n+\t\t  abort ();\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t      }\n+\t    /* BARRIERs are between basic blocks, not part of one.\n+\t       Delete a BARRIER if the preceding jump is deleted.\n+\t       We cannot alter a BARRIER into a NOTE\n+\t       because it is too short; but we can really delete\n+\t       it because it is not part of a basic block.  */\n+\t    if (NEXT_INSN (insn) != 0\n+\t\t&& GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+\t      delete_insn (NEXT_INSN (insn));\n+\n \t    /* Each time we delete some basic blocks,\n \t       see if there is a jump around them that is\n \t       being turned into a no-op.  If so, delete it.  */\n \n \t    if (block_live[i - 1])\n \t      {\n \t\tregister int j;\n-\t\tfor (j = i; j < n_basic_blocks; j++)\n+\t\tfor (j = i + 1; j < n_basic_blocks; j++)\n \t\t  if (block_live[j])\n \t\t    {\n \t\t      rtx label;\n@@ -686,9 +722,32 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t    }\n \t      }\n \t  }\n+\n+      /* There are pathalogical cases where one function calling hundreds of\n+\t nested inline functions can generate lots and lots of unreachable\n+\t blocks that jump can't delete.  Since we don't use sparse matrices\n+\t a lot of memory will be needed to compile such functions.\n+\t Implementing sparse matrices is a fair bit of work and it is not\n+\t clear that they win more than they lose (we don't want to\n+\t unnecessarily slow down compilation of normal code).  By making\n+\t another pass for the pathalogical case, we can greatly speed up\n+\t their compilation without hurting normal code.  This works because\n+\t all the insns in the unreachable blocks have either been deleted or\n+\t turned into notes.  */\n+      /* ??? The choice of when to make another pass is a bit arbitrary,\n+\t and was derived from empirical data.  */\n+      if (pass == 1\n+\t  && (deleted > n_basic_blocks / 2 || deleted > 1000))\n+\t{\n+\t  pass++;\n+\t  n_basic_blocks -= deleted;\n+\t  goto restart;\n+\t}\n     }\n }\n \f\n+/* Subroutines of find_basic_blocks.  */\n+\n /* Return 1 if X contain a REG or MEM that is not in the constant pool.  */\n \n static int\n@@ -720,7 +779,7 @@ uses_reg_or_mem (x)\n \n   return 0;\n }\n-\f\n+\n /* Check expression X for label references;\n    if one is found, add INSN to the label's chain of references.\n \n@@ -781,6 +840,20 @@ mark_label_ref (x, insn, checkdup)\n \t}\n     }\n }\n+\n+/* Delete INSN by patching it out.\n+   Return the next insn.  */\n+\n+static rtx\n+flow_delete_insn (insn)\n+     rtx insn;\n+{\n+  /* ??? For the moment we assume we don't have to watch for NULLs here\n+     since the start/end of basic blocks aren't deleted like this.  */\n+  NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n+  PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n+  return NEXT_INSN (insn);\n+}\n \f\n /* Determine which registers are live at the start of each\n    basic block of the function whose first insn is F.\n@@ -1355,28 +1428,29 @@ propagate_block (old, first, last, final, significant, bnum)\n     {\n       prev = PREV_INSN (insn);\n \n-      /* Look for loop boundaries, remembering that we are going backwards.  */\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\tloop_depth++;\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tloop_depth--;\n-\n-      /* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. \n-\t Abort now rather than setting register status incorrectly.  */\n-      if (loop_depth == 0)\n-\tabort ();\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  /* Look for loop boundaries, remembering that we are going\n+\t     backwards.  */\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    loop_depth++;\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    loop_depth--;\n+\n+\t  /* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. \n+\t     Abort now rather than setting register status incorrectly.  */\n+\t  if (loop_depth == 0)\n+\t    abort ();\n \n-      /* If this is a call to `setjmp' et al,\n-\t warn if any non-volatile datum is live.  */\n+\t  /* If this is a call to `setjmp' et al,\n+\t     warn if any non-volatile datum is live.  */\n \n-      if (final && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < regset_size; i++)\n-\t    regs_live_at_setjmp[i] |= old[i];\n+\t  if (final && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t    {\n+\t      int i;\n+\t      for (i = 0; i < regset_size; i++)\n+\t\tregs_live_at_setjmp[i] |= old[i];\n+\t    }\n \t}\n \n       /* Update the life-status of regs for this insn.\n@@ -1386,7 +1460,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t are those live after, with DEAD regs turned off,\n \t and then LIVE regs turned on.  */\n \n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  register int i;\n \t  rtx note = find_reg_note (insn, REG_RETVAL, NULL_RTX);"}]}