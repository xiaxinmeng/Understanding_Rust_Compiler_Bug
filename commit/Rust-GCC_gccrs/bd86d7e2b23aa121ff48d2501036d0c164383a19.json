{"sha": "bd86d7e2b23aa121ff48d2501036d0c164383a19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4NmQ3ZTJiMjNhYTEyMWZmNDhkMjUwMTAzNmQwYzE2NDM4M2ExOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-02-15T11:58:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-02-15T11:58:09Z"}, "message": "cccp.c: Don't define HOST_WIDE_INT.\n\n        * cccp.c: Don't define HOST_WIDE_INT.  Replace all occurrences of\n        WIDE_INT with WIDEST_INT.\n        * cexp.y: Likewise.\n        Don't define unsigned_HOST_WIDE_INT, CHAR_BIT or\n        HOST_BITS_PER_WIDE_INT.  Replace occurrences of PRINTF_PROTO_1()\n        style with PVPROTO() ATTRIBUTE_PRINTF_1 style macros.  Replace\n        occurrences of \"unsigned_HOST\" with \"unsigned HOST\".  Provide a\n        definition of variable `c89' when compiling a test binary and set it.\n        * system.h: Don't define the PRINTF_PROTO_* macros.\n\nFrom-SVN: r25217", "tree": {"sha": "e9939213b7dbe98be50feffc765b5e3e079c426f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9939213b7dbe98be50feffc765b5e3e079c426f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd86d7e2b23aa121ff48d2501036d0c164383a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd86d7e2b23aa121ff48d2501036d0c164383a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd86d7e2b23aa121ff48d2501036d0c164383a19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd86d7e2b23aa121ff48d2501036d0c164383a19/comments", "author": null, "committer": null, "parents": [{"sha": "c4ae272555de2b9872514f6f73e63ba6c51765eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ae272555de2b9872514f6f73e63ba6c51765eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ae272555de2b9872514f6f73e63ba6c51765eb"}], "stats": {"total": 445, "additions": 183, "deletions": 262}, "files": [{"sha": "6300fd65fe7b6353665d09cfd7c2906c74f9874a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd86d7e2b23aa121ff48d2501036d0c164383a19", "patch": "@@ -1,3 +1,17 @@\n+Mon Feb 15 14:44:53 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cccp.c: Don't define HOST_WIDE_INT.  Replace all occurrences of\n+\tWIDE_INT with WIDEST_INT.\n+\n+\t* cexp.y: Likewise.\n+\tDon't define unsigned_HOST_WIDE_INT, CHAR_BIT or\n+ \tHOST_BITS_PER_WIDE_INT.  Replace occurrences of PRINTF_PROTO_1()\n+ \tstyle with PVPROTO() ATTRIBUTE_PRINTF_1 style macros.  Replace\n+ \toccurrences of \"unsigned_HOST\" with \"unsigned HOST\".  Provide a\n+ \tdefinition of variable `c89' when compiling a test binary and set it.\n+\n+\t* system.h: Don't define the PRINTF_PROTO_* macros.\n+\n Mon Feb 15 11:33:51 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* loop.c (mark_loop_jump): Handle LO_SUM.  If we encounter something"}, {"sha": "7d39145ad858c80d3b57bb69f19a82db812c0b7d", "filename": "gcc/cccp.c", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=bd86d7e2b23aa121ff48d2501036d0c164383a19", "patch": "@@ -82,26 +82,6 @@ static int hack_vms_include_specification ();\n #define INO_T_EQ(a, b) 0\n #endif\n \n-/* Find the largest host integer type and set its size and type.\n-   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n-\n-#ifndef HOST_WIDE_INT\n-# if HAVE_INTTYPES_H\n-#  include <inttypes.h>\n-#  define HOST_WIDE_INT intmax_t\n-# else\n-#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n-#   define HOST_WIDE_INT int\n-#  else\n-#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n-#   define HOST_WIDE_INT long\n-#  else\n-#   define HOST_WIDE_INT long long\n-#  endif\n-#  endif\n-# endif\n-#endif\n-\n #ifndef INO_T_EQ\n #define INO_T_EQ(a, b) ((a) == (b))\n #endif\n@@ -117,8 +97,8 @@ static int hack_vms_include_specification ();\n /* External declarations.  */\n \n extern char *version_string;\n-HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));\n-HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n+HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \f\n /* Name under which this program was invoked.  */\n \n@@ -959,7 +939,7 @@ static void delete_assertion PROTO((ASSERTION_HASHNODE *));\n \n static void do_once PROTO((void));\n \n-static HOST_WIDE_INT eval_if_expression PROTO((U_CHAR *, int));\n+static HOST_WIDEST_INT eval_if_expression PROTO((U_CHAR *, int));\n static void conditional_skip PROTO((FILE_BUF *, int, enum node_type, U_CHAR *, FILE_BUF *));\n static void skip_if_group PROTO((FILE_BUF *, int, FILE_BUF *));\n static void validate_else PROTO((U_CHAR *, U_CHAR *));\n@@ -2563,7 +2543,7 @@ get_lintcmd (ibp, limit, argstart, arglen, cmdlen)\n      U_CHAR **argstart;\t\t/* point to command arg */\n      int *arglen, *cmdlen;\t/* how long they are */\n {\n-  HOST_WIDE_INT linsize;\n+  HOST_WIDEST_INT linsize;\n   register U_CHAR *numptr;\t/* temp for arg parsing */\n \n   *arglen = 0;\n@@ -6962,7 +6942,7 @@ do_line (buf, limit, op, keyword)\n \tif (! ignore_escape_flag)\n \t  {\n \t    char *bpc = (char *) bp;\n-\t    HOST_WIDE_INT c = parse_escape (&bpc, (HOST_WIDE_INT) (U_CHAR) (-1));\n+\t    HOST_WIDEST_INT c = parse_escape (&bpc, (HOST_WIDEST_INT) (U_CHAR) (-1));\n \t    bp = (U_CHAR *) bpc;\n \t    if (c < 0)\n \t      p--;\n@@ -7275,7 +7255,7 @@ do_if (buf, limit, op, keyword)\n      FILE_BUF *op;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  HOST_WIDE_INT value;\n+  HOST_WIDEST_INT value;\n   FILE_BUF *ip = &instack[indepth];\n \n   value = eval_if_expression (buf, limit - buf);\n@@ -7292,7 +7272,7 @@ do_elif (buf, limit, op, keyword)\n      FILE_BUF *op;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  HOST_WIDE_INT value;\n+  HOST_WIDEST_INT value;\n   FILE_BUF *ip = &instack[indepth];\n \n   if (if_stack == instack[indepth].if_stack) {\n@@ -7330,14 +7310,14 @@ do_elif (buf, limit, op, keyword)\n /* Evaluate a #if expression in BUF, of length LENGTH, then parse the\n    result as a C expression and return the value as an int.  */\n \n-static HOST_WIDE_INT\n+static HOST_WIDEST_INT\n eval_if_expression (buf, length)\n      U_CHAR *buf;\n      int length;\n {\n   FILE_BUF temp_obuf;\n   HASHNODE *save_defined;\n-  HOST_WIDE_INT value;\n+  HOST_WIDEST_INT value;\n \n   save_defined = install ((U_CHAR *) \"defined\", -1, T_SPEC_DEFINED,\n \t\t\t  NULL_PTR, -1);"}, {"sha": "9777678ddc57a74cc7008f713edc62ae1e2cfc3b", "filename": "gcc/cexp.c", "status": "modified", "additions": 104, "deletions": 135, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=bd86d7e2b23aa121ff48d2501036d0c164383a19", "patch": "@@ -43,44 +43,11 @@ struct arglist {\n   int argno;\n };\n \n-/* Find the largest host integer type and set its size and type.\n-   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n-\n-#ifndef HOST_WIDE_INT\n-# if HAVE_INTTYPES_H\n-#  include <inttypes.h>\n-#  define HOST_WIDE_INT intmax_t\n-#  define unsigned_HOST_WIDE_INT uintmax_t\n-# else\n-#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n-#   define HOST_WIDE_INT int\n-#  else\n-#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n-#   define HOST_WIDE_INT long\n-#  else\n-#   define HOST_WIDE_INT long long\n-#  endif\n-#  endif\n-# endif\n-#endif\n-\n-#ifndef unsigned_HOST_WIDE_INT\n-#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT\n-#endif\n-\n-#ifndef CHAR_BIT\n-#define CHAR_BIT 8\n-#endif\n-\n-#ifndef HOST_BITS_PER_WIDE_INT\n-#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))\n-#endif\n-\n-HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n-static HOST_WIDE_INT expression_value;\n+static void yyerror PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n #endif\n@@ -141,13 +108,13 @@ extern int c89;\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n-#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n-\t\t\t    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n-\t\t\t    : ~ (HOST_WIDE_INT) 0)\n+#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n+\t\t\t    ? (~ (~ (HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    : ~ (HOST_WIDEST_INT) 0)\n \n-#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n-\t\t\t     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n-\t\t\t     : ~ (HOST_WIDE_INT) 0)\n+#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n+\t\t\t     ? ~ (~ (HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     : ~ (HOST_WIDEST_INT) 0)\n \n /* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n@@ -161,25 +128,25 @@ extern int c89;\n \n struct constant;\n \n-HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));\n+HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PRINTF_PROTO_1((char *, ...));\n-void pedwarn PRINTF_PROTO_1((char *, ...));\n-void warning PRINTF_PROTO_1((char *, ...));\n+void error PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void pedwarn PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n \n static int parse_number PROTO((int));\n-static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n-static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n+static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n+static HOST_WIDEST_INT right_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n static void integer_overflow PROTO((void));\n \n /* `signedp' values */\n #define SIGNED (~0)\n #define UNSIGNED 0\n \n-#line 185 \"cexp.y\"\n+#line 152 \"cexp.y\"\n typedef union {\n-  struct constant {HOST_WIDE_INT value; int signedp;} integer;\n+  struct constant {HOST_WIDEST_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n   struct arglist *keywords;\n } YYSTYPE;\n@@ -258,10 +225,10 @@ static const short yyrhs[] = {    35,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   215,   225,   226,   233,   238,   241,   243,   246,   250,   252,\n-   257,   262,   275,   292,   305,   311,   317,   323,   329,   332,\n-   335,   342,   349,   356,   363,   366,   369,   372,   375,   378,\n-   381,   384,   386,   389,   392,   394,   396,   404,   406,   419\n+   182,   192,   193,   200,   205,   208,   210,   213,   217,   219,\n+   224,   229,   242,   259,   272,   278,   284,   290,   296,   299,\n+   302,   309,   316,   323,   330,   333,   336,   339,   342,   345,\n+   348,   351,   353,   356,   359,   361,   363,   371,   373,   386\n };\n #endif\n \n@@ -367,7 +334,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/r5900/share/bison.simple\"\n+#line 3 \"/usr/local/gnu/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -560,7 +527,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/r5900/share/bison.simple\"\n+#line 196 \"/usr/local/gnu/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -865,7 +832,7 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 216 \"cexp.y\"\n+#line 183 \"cexp.y\"\n {\n \t\t  expression_value = yyvsp[0].integer.value;\n #ifdef TEST_EXP_READER\n@@ -874,55 +841,55 @@ case 1:\n \t\t;\n     break;}\n case 3:\n-#line 227 \"cexp.y\"\n+#line 194 \"cexp.y\"\n { if (pedantic)\n \t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n \t\t\t  yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 4:\n-#line 234 \"cexp.y\"\n+#line 201 \"cexp.y\"\n { yyval.integer.value = - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp;\n \t\t\t  if ((yyval.integer.value & yyvsp[0].integer.value & yyval.integer.signedp) < 0)\n \t\t\t    integer_overflow (); ;\n     break;}\n case 5:\n-#line 239 \"cexp.y\"\n+#line 206 \"cexp.y\"\n { yyval.integer.value = ! yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 6:\n-#line 242 \"cexp.y\"\n+#line 209 \"cexp.y\"\n { yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 7:\n-#line 244 \"cexp.y\"\n+#line 211 \"cexp.y\"\n { yyval.integer.value = ~ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp; ;\n     break;}\n case 8:\n-#line 247 \"cexp.y\"\n+#line 214 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[0].name.address, yyvsp[0].name.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 9:\n-#line 251 \"cexp.y\"\n+#line 218 \"cexp.y\"\n { keyword_parsing = 1; ;\n     break;}\n case 10:\n-#line 253 \"cexp.y\"\n+#line 220 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[-4].name.address, yyvsp[-4].name.length,\n \t\t\t\t\t\t      1, yyvsp[-1].keywords);\n \t\t\t  keyword_parsing = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 11:\n-#line 258 \"cexp.y\"\n+#line 225 \"cexp.y\"\n { yyval.integer = yyvsp[-1].integer; ;\n     break;}\n case 12:\n-#line 263 \"cexp.y\"\n+#line 230 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    {\n@@ -933,11 +900,11 @@ case 12:\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t* yyvsp[0].integer.value); ;\n     break;}\n case 13:\n-#line 276 \"cexp.y\"\n+#line 243 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -952,11 +919,11 @@ case 13:\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t/ yyvsp[0].integer.value); ;\n     break;}\n case 14:\n-#line 293 \"cexp.y\"\n+#line 260 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -967,158 +934,158 @@ case 14:\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value % yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t% yyvsp[0].integer.value); ;\n     break;}\n case 15:\n-#line 306 \"cexp.y\"\n+#line 273 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyvsp[-2].integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyval.integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 16:\n-#line 312 \"cexp.y\"\n+#line 279 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyval.integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyvsp[-2].integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 17:\n-#line 318 \"cexp.y\"\n+#line 285 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 18:\n-#line 324 \"cexp.y\"\n+#line 291 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 19:\n-#line 330 \"cexp.y\"\n+#line 297 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 20:\n-#line 333 \"cexp.y\"\n+#line 300 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 21:\n-#line 336 \"cexp.y\"\n+#line 303 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t<= yyvsp[0].integer.value); ;\n     break;}\n case 22:\n-#line 343 \"cexp.y\"\n+#line 310 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t>= yyvsp[0].integer.value); ;\n     break;}\n case 23:\n-#line 350 \"cexp.y\"\n+#line 317 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t< yyvsp[0].integer.value); ;\n     break;}\n case 24:\n-#line 357 \"cexp.y\"\n+#line 324 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value;\n \t\t\t  else\n-\t\t\t    yyval.integer.value = ((unsigned_HOST_WIDE_INT) yyvsp[-2].integer.value\n+\t\t\t    yyval.integer.value = ((unsigned HOST_WIDEST_INT) yyvsp[-2].integer.value\n \t\t\t\t\t> yyvsp[0].integer.value); ;\n     break;}\n case 25:\n-#line 364 \"cexp.y\"\n+#line 331 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 26:\n-#line 367 \"cexp.y\"\n+#line 334 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 27:\n-#line 370 \"cexp.y\"\n+#line 337 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 28:\n-#line 373 \"cexp.y\"\n+#line 340 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 29:\n-#line 375 \"cexp.y\"\n+#line 342 \"cexp.y\"\n { skip_evaluation -= !yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value && yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 30:\n-#line 379 \"cexp.y\"\n+#line 346 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-1].integer.value; ;\n     break;}\n case 31:\n-#line 381 \"cexp.y\"\n+#line 348 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value || yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 32:\n-#line 385 \"cexp.y\"\n+#line 352 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 33:\n-#line 387 \"cexp.y\"\n+#line 354 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-4].integer.value - !yyvsp[-4].integer.value; ;\n     break;}\n case 34:\n-#line 389 \"cexp.y\"\n+#line 356 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-6].integer.value;\n \t\t\t  yyval.integer.value = yyvsp[-6].integer.value ? yyvsp[-3].integer.value : yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-3].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 35:\n-#line 393 \"cexp.y\"\n+#line 360 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 36:\n-#line 395 \"cexp.y\"\n+#line 362 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 37:\n-#line 397 \"cexp.y\"\n+#line 364 \"cexp.y\"\n { if (warn_undef && !skip_evaluation)\n \t\t\t    warning (\"`%.*s' is not defined\",\n \t\t\t\t     yyvsp[0].name.length, yyvsp[0].name.address);\n \t\t\t  yyval.integer.value = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 38:\n-#line 405 \"cexp.y\"\n+#line 372 \"cexp.y\"\n { yyval.keywords = 0; ;\n     break;}\n case 39:\n-#line 407 \"cexp.y\"\n+#line 374 \"cexp.y\"\n { struct arglist *temp;\n \t\t\t  yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->next = yyvsp[-2].keywords;\n@@ -1133,15 +1100,15 @@ case 39:\n \t\t\t  temp->next->length = 1; ;\n     break;}\n case 40:\n-#line 420 \"cexp.y\"\n+#line 387 \"cexp.y\"\n { yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->name = yyvsp[-1].name.address;\n \t\t\t  yyval.keywords->length = yyvsp[-1].name.length;\n \t\t\t  yyval.keywords->next = yyvsp[0].keywords; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/r5900/share/bison.simple\"\n+#line 498 \"/usr/local/gnu/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -1337,7 +1304,7 @@ case 40:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 425 \"cexp.y\"\n+#line 392 \"cexp.y\"\n \n \f\n /* During parsing of a C expression, the pointer to the next character\n@@ -1357,7 +1324,7 @@ parse_number (olen)\n {\n   register char *p = lexptr;\n   register int c;\n-  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;\n+  register unsigned HOST_WIDEST_INT n = 0, nd, max_over_base;\n   register int base = 10;\n   register int len = olen;\n   register int overflow = 0;\n@@ -1375,7 +1342,7 @@ parse_number (olen)\n     }\n   }\n \n-  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;\n+  max_over_base = (unsigned HOST_WIDEST_INT) -1 / base;\n \n   for (; len > 0; len--) {\n     c = *p++;\n@@ -1430,7 +1397,7 @@ parse_number (olen)\n     pedwarn (\"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n-  if (((HOST_WIDE_INT) n & yylval.integer.signedp) < 0)\n+  if (((HOST_WIDEST_INT) n & yylval.integer.signedp) < 0)\n     {\n       if (base == 10)\n \twarning (\"integer constant is so large that it is unsigned\");\n@@ -1471,7 +1438,7 @@ yylex ()\n   register unsigned char *tokstart;\n   register struct token *toktab;\n   int wide_flag;\n-  HOST_WIDE_INT mask;\n+  HOST_WIDEST_INT mask;\n \n  retry:\n \n@@ -1538,7 +1505,7 @@ yylex ()\n        handles multicharacter constants and wide characters.\n        It is mostly copied from c-lex.c.  */\n     {\n-      register HOST_WIDE_INT result = 0;\n+      register HOST_WIDEST_INT result = 0;\n       register int num_chars = 0;\n       int chars_seen = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n@@ -1653,12 +1620,12 @@ yylex ()\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & (~ (unsigned_HOST_WIDE_INT) 0\n-\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits));\n+\t      = result & (~ (unsigned HOST_WIDEST_INT) 0\n+\t\t\t  >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~(~ (unsigned_HOST_WIDE_INT) 0\n-\t\t\t   >> (HOST_BITS_PER_WIDE_INT - num_bits));\n+\t      = result | ~(~ (unsigned HOST_WIDEST_INT) 0\n+\t\t\t   >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n \t}\n       else\n \t{\n@@ -1784,10 +1751,10 @@ yylex ()\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-HOST_WIDE_INT\n+HOST_WIDEST_INT\n parse_escape (string_ptr, result_mask)\n      char **string_ptr;\n-     HOST_WIDE_INT result_mask;\n+     HOST_WIDEST_INT result_mask;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -1826,7 +1793,7 @@ parse_escape (string_ptr, result_mask)\n     case '6':\n     case '7':\n       {\n-\tregister HOST_WIDE_INT i = c - '0';\n+\tregister HOST_WIDEST_INT i = c - '0';\n \tregister int count = 0;\n \twhile (++count < 3)\n \t  {\n@@ -1848,7 +1815,7 @@ parse_escape (string_ptr, result_mask)\n       }\n     case 'x':\n       {\n-\tregister unsigned_HOST_WIDE_INT i = 0, overflow = 0;\n+\tregister unsigned HOST_WIDEST_INT i = 0, overflow = 0;\n \tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n@@ -1889,31 +1856,31 @@ integer_overflow ()\n     pedwarn (\"integer overflow in preprocessor expression\");\n }\n \n-static HOST_WIDE_INT\n+static HOST_WIDEST_INT\n left_shift (a, b)\n      struct constant *a;\n-     unsigned_HOST_WIDE_INT b;\n+     unsigned HOST_WIDEST_INT b;\n {\n    /* It's unclear from the C standard whether shifts can overflow.\n       The following code ignores overflow; perhaps a C standard\n       interpretation ruling is needed.  */\n-  if (b >= HOST_BITS_PER_WIDE_INT)\n+  if (b >= HOST_BITS_PER_WIDEST_INT)\n     return 0;\n   else\n-    return (unsigned_HOST_WIDE_INT) a->value << b;\n+    return (unsigned HOST_WIDEST_INT) a->value << b;\n }\n \n-static HOST_WIDE_INT\n+static HOST_WIDEST_INT\n right_shift (a, b)\n      struct constant *a;\n-     unsigned_HOST_WIDE_INT b;\n+     unsigned HOST_WIDEST_INT b;\n {\n-  if (b >= HOST_BITS_PER_WIDE_INT)\n-    return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;\n+  if (b >= HOST_BITS_PER_WIDEST_INT)\n+    return a->signedp ? a->value >> (HOST_BITS_PER_WIDEST_INT - 1) : 0;\n   else if (a->signedp)\n     return a->value >> b;\n   else\n-    return (unsigned_HOST_WIDE_INT) a->value >> b;\n+    return (unsigned HOST_WIDEST_INT) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */\n@@ -1926,7 +1893,7 @@ right_shift (a, b)\n    We do not support C comments.  They should be removed before\n    this function is called.  */\n \n-HOST_WIDE_INT\n+HOST_WIDEST_INT\n parse_c_expression (string, warn_undefined)\n      char *string;\n      int warn_undefined;\n@@ -1980,10 +1947,11 @@ extern int yydebug;\n \n int pedantic;\n int traditional;\n+int c89;\n \n int main PROTO((int, char **));\n static void initialize_random_junk PROTO((void));\n-static void print_unsigned_host_wide_int PROTO((unsigned_HOST_WIDE_INT));\n+static void print_unsigned_host_widest_int PROTO((unsigned HOST_WIDEST_INT));\n \n /* Main program for testing purposes.  */\n int\n@@ -1993,12 +1961,13 @@ main (argc, argv)\n {\n   int n, c;\n   char buf[1024];\n-  unsigned_HOST_WIDE_INT u;\n+  unsigned HOST_WIDEST_INT u;\n \n   pedantic = 1 < argc;\n   traditional = 2 < argc;\n+  c89 = 3 < argc;\n #if YYDEBUG\n-  yydebug = 3 < argc;\n+  yydebug = 4 < argc;\n #endif\n   initialize_random_junk ();\n \n@@ -2011,15 +1980,15 @@ main (argc, argv)\n       break;\n     parse_c_expression (buf, 1);\n     printf (\"parser returned \");\n-    u = (unsigned_HOST_WIDE_INT) expression_value;\n+    u = (unsigned HOST_WIDEST_INT) expression_value;\n     if (expression_value < 0 && expression_signedp) {\n       u = -u;\n       printf (\"-\");\n     }\n     if (u == 0)\n       printf (\"0\");\n     else\n-      print_unsigned_host_wide_int (u);\n+      print_unsigned_host_widest_int (u);\n     if (! expression_signedp)\n       printf(\"u\");\n     printf (\"\\n\");\n@@ -2029,11 +1998,11 @@ main (argc, argv)\n }\n \n static void\n-print_unsigned_host_wide_int (u)\n-     unsigned_HOST_WIDE_INT u;\n+print_unsigned_host_widest_int (u)\n+     unsigned HOST_WIDEST_INT u;\n {\n   if (u) {\n-    print_unsigned_host_wide_int (u / 10);\n+    print_unsigned_host_widest_int (u / 10);\n     putchar ('0' + (int) (u % 10));\n   }\n }"}, {"sha": "76818e8844ab958eaf8d5b04432cd66891e305f4", "filename": "gcc/cexp.y", "status": "modified", "additions": 56, "deletions": 87, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=bd86d7e2b23aa121ff48d2501036d0c164383a19", "patch": "@@ -47,44 +47,11 @@ struct arglist {\n   int argno;\n };\n \n-/* Find the largest host integer type and set its size and type.\n-   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n-\n-#ifndef HOST_WIDE_INT\n-# if HAVE_INTTYPES_H\n-#  include <inttypes.h>\n-#  define HOST_WIDE_INT intmax_t\n-#  define unsigned_HOST_WIDE_INT uintmax_t\n-# else\n-#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n-#   define HOST_WIDE_INT int\n-#  else\n-#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n-#   define HOST_WIDE_INT long\n-#  else\n-#   define HOST_WIDE_INT long long\n-#  endif\n-#  endif\n-# endif\n-#endif\n-\n-#ifndef unsigned_HOST_WIDE_INT\n-#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT\n-#endif\n-\n-#ifndef CHAR_BIT\n-#define CHAR_BIT 8\n-#endif\n-\n-#ifndef HOST_BITS_PER_WIDE_INT\n-#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))\n-#endif\n-\n-HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n-static HOST_WIDE_INT expression_value;\n+static void yyerror PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n #endif\n@@ -145,13 +112,13 @@ extern int c89;\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n-#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n-\t\t\t    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n-\t\t\t    : ~ (HOST_WIDE_INT) 0)\n+#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n+\t\t\t    ? (~ (~ (HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    : ~ (HOST_WIDEST_INT) 0)\n \n-#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n-\t\t\t     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n-\t\t\t     : ~ (HOST_WIDE_INT) 0)\n+#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n+\t\t\t     ? ~ (~ (HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     : ~ (HOST_WIDEST_INT) 0)\n \n /* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n@@ -165,16 +132,16 @@ extern int c89;\n \n struct constant;\n \n-HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));\n+HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PRINTF_PROTO_1((char *, ...));\n-void pedwarn PRINTF_PROTO_1((char *, ...));\n-void warning PRINTF_PROTO_1((char *, ...));\n+void error PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void pedwarn PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n \n static int parse_number PROTO((int));\n-static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n-static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n+static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n+static HOST_WIDEST_INT right_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n static void integer_overflow PROTO((void));\n \n /* `signedp' values */\n@@ -183,7 +150,7 @@ static void integer_overflow PROTO((void));\n %}\n \n %union {\n-  struct constant {HOST_WIDE_INT value; int signedp;} integer;\n+  struct constant {HOST_WIDEST_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n   struct arglist *keywords;\n }\n@@ -270,7 +237,7 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t* $3.value); }\n \t|\texp '/' exp\n \t\t\t{ if ($3.value == 0)\n@@ -287,7 +254,7 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t/ $3.value); }\n \t|\texp '%' exp\n \t\t\t{ if ($3.value == 0)\n@@ -300,7 +267,7 @@ exp\t:\texp '*' exp\n \t\t\t  if ($$.signedp)\n \t\t\t    $$.value = $1.value % $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t% $3.value); }\n \t|\texp '+' exp\n \t\t\t{ $$.value = $1.value + $3.value;\n@@ -337,28 +304,28 @@ exp\t:\texp '*' exp\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value <= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t<= $3.value); }\n \t|\texp GEQ exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value >= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t>= $3.value); }\n \t|\texp '<' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value < $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t< $3.value); }\n \t|\texp '>' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value > $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned HOST_WIDEST_INT) $1.value\n \t\t\t\t\t> $3.value); }\n \t|\texp '&' exp\n \t\t\t{ $$.value = $1.value & $3.value;\n@@ -441,7 +408,7 @@ parse_number (olen)\n {\n   register char *p = lexptr;\n   register int c;\n-  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;\n+  register unsigned HOST_WIDEST_INT n = 0, nd, max_over_base;\n   register int base = 10;\n   register int len = olen;\n   register int overflow = 0;\n@@ -459,7 +426,7 @@ parse_number (olen)\n     }\n   }\n \n-  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;\n+  max_over_base = (unsigned HOST_WIDEST_INT) -1 / base;\n \n   for (; len > 0; len--) {\n     c = *p++;\n@@ -514,7 +481,7 @@ parse_number (olen)\n     pedwarn (\"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n-  if (((HOST_WIDE_INT) n & yylval.integer.signedp) < 0)\n+  if (((HOST_WIDEST_INT) n & yylval.integer.signedp) < 0)\n     {\n       if (base == 10)\n \twarning (\"integer constant is so large that it is unsigned\");\n@@ -555,7 +522,7 @@ yylex ()\n   register unsigned char *tokstart;\n   register struct token *toktab;\n   int wide_flag;\n-  HOST_WIDE_INT mask;\n+  HOST_WIDEST_INT mask;\n \n  retry:\n \n@@ -622,7 +589,7 @@ yylex ()\n        handles multicharacter constants and wide characters.\n        It is mostly copied from c-lex.c.  */\n     {\n-      register HOST_WIDE_INT result = 0;\n+      register HOST_WIDEST_INT result = 0;\n       register int num_chars = 0;\n       int chars_seen = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n@@ -737,12 +704,12 @@ yylex ()\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & (~ (unsigned_HOST_WIDE_INT) 0\n-\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits));\n+\t      = result & (~ (unsigned HOST_WIDEST_INT) 0\n+\t\t\t  >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~(~ (unsigned_HOST_WIDE_INT) 0\n-\t\t\t   >> (HOST_BITS_PER_WIDE_INT - num_bits));\n+\t      = result | ~(~ (unsigned HOST_WIDEST_INT) 0\n+\t\t\t   >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n \t}\n       else\n \t{\n@@ -868,10 +835,10 @@ yylex ()\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-HOST_WIDE_INT\n+HOST_WIDEST_INT\n parse_escape (string_ptr, result_mask)\n      char **string_ptr;\n-     HOST_WIDE_INT result_mask;\n+     HOST_WIDEST_INT result_mask;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -910,7 +877,7 @@ parse_escape (string_ptr, result_mask)\n     case '6':\n     case '7':\n       {\n-\tregister HOST_WIDE_INT i = c - '0';\n+\tregister HOST_WIDEST_INT i = c - '0';\n \tregister int count = 0;\n \twhile (++count < 3)\n \t  {\n@@ -932,7 +899,7 @@ parse_escape (string_ptr, result_mask)\n       }\n     case 'x':\n       {\n-\tregister unsigned_HOST_WIDE_INT i = 0, overflow = 0;\n+\tregister unsigned HOST_WIDEST_INT i = 0, overflow = 0;\n \tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n@@ -973,31 +940,31 @@ integer_overflow ()\n     pedwarn (\"integer overflow in preprocessor expression\");\n }\n \n-static HOST_WIDE_INT\n+static HOST_WIDEST_INT\n left_shift (a, b)\n      struct constant *a;\n-     unsigned_HOST_WIDE_INT b;\n+     unsigned HOST_WIDEST_INT b;\n {\n    /* It's unclear from the C standard whether shifts can overflow.\n       The following code ignores overflow; perhaps a C standard\n       interpretation ruling is needed.  */\n-  if (b >= HOST_BITS_PER_WIDE_INT)\n+  if (b >= HOST_BITS_PER_WIDEST_INT)\n     return 0;\n   else\n-    return (unsigned_HOST_WIDE_INT) a->value << b;\n+    return (unsigned HOST_WIDEST_INT) a->value << b;\n }\n \n-static HOST_WIDE_INT\n+static HOST_WIDEST_INT\n right_shift (a, b)\n      struct constant *a;\n-     unsigned_HOST_WIDE_INT b;\n+     unsigned HOST_WIDEST_INT b;\n {\n-  if (b >= HOST_BITS_PER_WIDE_INT)\n-    return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;\n+  if (b >= HOST_BITS_PER_WIDEST_INT)\n+    return a->signedp ? a->value >> (HOST_BITS_PER_WIDEST_INT - 1) : 0;\n   else if (a->signedp)\n     return a->value >> b;\n   else\n-    return (unsigned_HOST_WIDE_INT) a->value >> b;\n+    return (unsigned HOST_WIDEST_INT) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */\n@@ -1010,7 +977,7 @@ right_shift (a, b)\n    We do not support C comments.  They should be removed before\n    this function is called.  */\n \n-HOST_WIDE_INT\n+HOST_WIDEST_INT\n parse_c_expression (string, warn_undefined)\n      char *string;\n      int warn_undefined;\n@@ -1064,10 +1031,11 @@ extern int yydebug;\n \n int pedantic;\n int traditional;\n+int c89;\n \n int main PROTO((int, char **));\n static void initialize_random_junk PROTO((void));\n-static void print_unsigned_host_wide_int PROTO((unsigned_HOST_WIDE_INT));\n+static void print_unsigned_host_widest_int PROTO((unsigned HOST_WIDEST_INT));\n \n /* Main program for testing purposes.  */\n int\n@@ -1077,12 +1045,13 @@ main (argc, argv)\n {\n   int n, c;\n   char buf[1024];\n-  unsigned_HOST_WIDE_INT u;\n+  unsigned HOST_WIDEST_INT u;\n \n   pedantic = 1 < argc;\n   traditional = 2 < argc;\n+  c89 = 3 < argc;\n #if YYDEBUG\n-  yydebug = 3 < argc;\n+  yydebug = 4 < argc;\n #endif\n   initialize_random_junk ();\n \n@@ -1095,15 +1064,15 @@ main (argc, argv)\n       break;\n     parse_c_expression (buf, 1);\n     printf (\"parser returned \");\n-    u = (unsigned_HOST_WIDE_INT) expression_value;\n+    u = (unsigned HOST_WIDEST_INT) expression_value;\n     if (expression_value < 0 && expression_signedp) {\n       u = -u;\n       printf (\"-\");\n     }\n     if (u == 0)\n       printf (\"0\");\n     else\n-      print_unsigned_host_wide_int (u);\n+      print_unsigned_host_widest_int (u);\n     if (! expression_signedp)\n       printf(\"u\");\n     printf (\"\\n\");\n@@ -1113,11 +1082,11 @@ main (argc, argv)\n }\n \n static void\n-print_unsigned_host_wide_int (u)\n-     unsigned_HOST_WIDE_INT u;\n+print_unsigned_host_widest_int (u)\n+     unsigned HOST_WIDEST_INT u;\n {\n   if (u) {\n-    print_unsigned_host_wide_int (u / 10);\n+    print_unsigned_host_widest_int (u / 10);\n     putchar ('0' + (int) (u % 10));\n   }\n }"}, {"sha": "6e549ca82a1520e2571f37a62a1c79a485041ae1", "filename": "gcc/system.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd86d7e2b23aa121ff48d2501036d0c164383a19/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=bd86d7e2b23aa121ff48d2501036d0c164383a19", "patch": "@@ -482,15 +482,4 @@ extern void abort ();\n /* Get libiberty declarations. */\n #include \"libiberty.h\"\n \n-#if defined (ANSI_PROTOTYPES)\n-# define PRINTF_PROTO(ARGS, m, n) PVPROTO (ARGS) ATTRIBUTE_PRINTF(m, n)\n-#else\n-# define PRINTF_PROTO(ARGS, m, n) () ATTRIBUTE_PRINTF(m, n)\n-#endif\n-#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n-#define PRINTF_PROTO_2(ARGS) PRINTF_PROTO(ARGS, 2, 3)\n-#define PRINTF_PROTO_3(ARGS) PRINTF_PROTO(ARGS, 3, 4)\n-#define PRINTF_PROTO_4(ARGS) PRINTF_PROTO(ARGS, 4, 5)\n-\n-\n #endif /* __GCC_SYSTEM_H__ */"}]}