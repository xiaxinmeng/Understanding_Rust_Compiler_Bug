{"sha": "05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "node_id": "C_kwDOANBUbNoAKDA1ZTkxYWMxZjg5ZGMwYjQ3NTdhYzdlOGZmYWFjZDY1YmNkYzQ3OTQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-07-03T16:41:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-13T10:01:15Z"}, "message": "[Ada] Plug legality loophole for equality operator of untagged record types\n\nIn Ada 2012, the RM 4.5.2(9.8) clause prevents an equality operator for an\nuntagged record type from being declared after the type is frozen.  While\nthe clause is implemented in GNAT, the implementation has a loophole which\nlets subprogram bodies that are not the completion of a declaration pass\nthe check without being flagged.\n\ngcc/ada/\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Set Acts_As_Spec\n\tearlier if the body is not the completion of a declaration.\n\t(Check_Untagged_Equality): Deal with subprogram bodies that are\n\tnot the completion of a declaration and make sure that they are\n\tnot flagged when they cause the freezing of the type themselves.\n\tGive a warning on the freezing point of the type in more cases.\n\t* sem_res.adb (Resolve_Equality_Op): Revert latest change.", "tree": {"sha": "1534578479d1206ee12400292edf6461383b417c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1534578479d1206ee12400292edf6461383b417c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b872d3fe67b54fef84ccafc7d39f1017a68332c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b872d3fe67b54fef84ccafc7d39f1017a68332c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b872d3fe67b54fef84ccafc7d39f1017a68332c2"}], "stats": {"total": 231, "additions": 162, "deletions": 69}, "files": [{"sha": "e4af71cef26fd0200b29aac898c95668420945fc", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 161, "deletions": 61, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "patch": "@@ -4743,6 +4743,12 @@ package body Sem_Ch6 is\n             Style.Body_With_No_Spec (N);\n          end if;\n \n+         --  First set Acts_As_Spec if appropriate\n+\n+         if Nkind (N) /= N_Subprogram_Body_Stub then\n+            Set_Acts_As_Spec (N);\n+         end if;\n+\n          New_Overloaded_Entity (Body_Id);\n \n          --  A subprogram body should cause freezing of its own declaration,\n@@ -4767,7 +4773,6 @@ package body Sem_Ch6 is\n          end if;\n \n          if Nkind (N) /= N_Subprogram_Body_Stub then\n-            Set_Acts_As_Spec (N);\n             Generate_Definition (Body_Id);\n             Generate_Reference\n               (Body_Id, Body_Id, 'b', Set_Ref => False, Force => True);\n@@ -9525,15 +9530,85 @@ package body Sem_Ch6 is\n    -----------------------------\n \n    procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n-      Typ      : constant Entity_Id := Etype (First_Formal (Eq_Op));\n-      Decl     : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n-      Obj_Decl : Node_Id;\n+      Eq_Decl : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n+      Typ     : constant Entity_Id := Etype (First_Formal (Eq_Op));\n+\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String);\n+      --  Output a warning about the freezing point N of Typ\n+\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean;\n+      --  Return True if E is an actual parameter of instantiation Inst\n+\n+      -----------------------------------\n+      -- Output_Freezing_Point_Warning --\n+      -----------------------------------\n+\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String) is\n+      begin\n+         Error_Msg_String (1 .. S'Length) := S;\n+         Error_Msg_Strlen := S'Length;\n+\n+         if Ada_Version >= Ada_2012 then\n+            Error_Msg_NE (\"type& is frozen by ~??\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point??\",\n+               N);\n+\n+         else\n+            Error_Msg_NE (\"type& is frozen by ~ (Ada 2012)?y?\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point\"\n+               & \" (Ada 2012)?y?\", N);\n+         end if;\n+      end Freezing_Point_Warning;\n+\n+      --------------------------------\n+      -- Is_Actual_Of_Instantiation --\n+      --------------------------------\n+\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean\n+      is\n+         Assoc : Node_Id;\n+\n+      begin\n+         if Present (Generic_Associations (Inst)) then\n+            Assoc := First (Generic_Associations (Inst));\n+\n+            while Present (Assoc) loop\n+               if Present (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Is_Entity_Name (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Entity (Explicit_Generic_Actual_Parameter (Assoc)) = E\n+               then\n+                  return True;\n+               end if;\n+\n+               Next (Assoc);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Is_Actual_Of_Instantiation;\n+\n+      --  Local variable\n+\n+      Decl : Node_Id;\n+\n+   --  Start of processing for Check_Untagged_Equality\n \n    begin\n-      --  This check applies only if we have a subprogram declaration with an\n-      --  untagged record type that is conformant to the predefined operator.\n+      --  This check applies only if we have a subprogram declaration or a\n+      --  subprogram body that is not a completion, for an untagged record\n+      --  type, and that is conformant with the predefined operator.\n \n-      if Nkind (Decl) /= N_Subprogram_Declaration\n+      if (Nkind (Eq_Decl) /= N_Subprogram_Declaration\n+           and then not (Nkind (Eq_Decl) = N_Subprogram_Body\n+                          and then Acts_As_Spec (Eq_Decl)))\n         or else not Is_Record_Type (Typ)\n         or else Is_Tagged_Type (Typ)\n         or else not Is_User_Defined_Equality (Eq_Op)\n@@ -9572,9 +9647,59 @@ package body Sem_Ch6 is\n          elsif Is_Generic_Actual_Type (Typ) then\n             return;\n \n-         --  Here we have a definite error of declaration after freezing\n+         --  Here we may have an error of declaration after freezing, but we\n+         --  must make sure not to flag the equality operator itself causing\n+         --  the freezing when it is a subprogram body.\n \n          else\n+            Decl := Next (Declaration_Node (Typ));\n+\n+            while Present (Decl) and then Decl /= Eq_Decl loop\n+\n+               --  The declaration of an object of the type\n+\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Etype (Defining_Identifier (Decl)) = Typ\n+               then\n+                  Freezing_Point_Warning (Decl, \"declaration\");\n+                  exit;\n+\n+               --  The instantiation of a generic on the type\n+\n+               elsif Nkind (Decl) in N_Generic_Instantiation\n+                 and then Is_Actual_Of_Instantiation (Typ, Decl)\n+               then\n+                  Freezing_Point_Warning (Decl, \"instantiation\");\n+                  exit;\n+\n+               --  A noninstance proper body, body stub or entry body\n+\n+               elsif Nkind (Decl) in N_Proper_Body\n+                                   | N_Body_Stub\n+                                   | N_Entry_Body\n+                 and then not Is_Generic_Instance (Defining_Entity (Decl))\n+               then\n+                  Freezing_Point_Warning (Decl, \"body\");\n+                  exit;\n+\n+               --  If we have reached the freeze node and immediately after we\n+               --  have the body or generated code for the body, then it is the\n+               --  body that caused the freezing and this is legal.\n+\n+               elsif Nkind (Decl) = N_Freeze_Entity\n+                 and then Entity (Decl) = Typ\n+                 and then (Next (Decl) = Eq_Decl\n+                            or else\n+                           Sloc (Next (Decl)) = Sloc (Eq_Decl))\n+               then\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Here we have a definite error of declaration after freezing\n+\n             if Ada_Version >= Ada_2012 then\n                Error_Msg_NE\n                  (\"equality operator must be declared before type & is \"\n@@ -9594,57 +9719,32 @@ package body Sem_Ch6 is\n                   & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)?y?\", Eq_Op, Typ);\n             end if;\n \n-            --  If we are in the package body, we could just move the\n-            --  declaration to the package spec, so add a message saying that.\n+            --  If we have found no freezing point and the declaration of the\n+            --  operator could not be reached from that of the type and we are\n+            --  in a package body, this must be because the type is declared\n+            --  in the spec of the package. Add a message tailored to this.\n \n-            if In_Package_Body (Scope (Typ)) then\n+            if No (Decl) and then In_Package_Body (Scope (Typ)) then\n                if Ada_Version >= Ada_2012 then\n-                  Error_Msg_N\n-                    (\"\\move declaration to package spec<<\", Eq_Op);\n-               else\n-                  Error_Msg_N\n-                    (\"\\move declaration to package spec (Ada 2012)?y?\", Eq_Op);\n-               end if;\n-\n-            --  Otherwise try to find the freezing point for better message.\n-\n-            else\n-               Obj_Decl := Next (Parent (Typ));\n-               while Present (Obj_Decl) and then Obj_Decl /= Decl loop\n-                  if Nkind (Obj_Decl) = N_Object_Declaration\n-                    and then Etype (Defining_Identifier (Obj_Decl)) = Typ\n-                  then\n-                     --  Freezing point, output warnings\n-\n-                     if Ada_Version >= Ada_2012 then\n-                        Error_Msg_NE\n-                          (\"type& is frozen by declaration??\", Obj_Decl, Typ);\n-                        Error_Msg_N\n-                          (\"\\an equality operator cannot be declared after \"\n-                           & \"this point??\",\n-                           Obj_Decl);\n-                     else\n-                        Error_Msg_NE\n-                          (\"type& is frozen by declaration (Ada 2012)?y?\",\n-                           Obj_Decl, Typ);\n-                        Error_Msg_N\n-                          (\"\\an equality operator cannot be declared after \"\n-                           & \"this point (Ada 2012)?y?\",\n-                           Obj_Decl);\n-                     end if;\n-\n-                     exit;\n-\n-                  --  If we reach generated code for subprogram declaration\n-                  --  or body, it is the body that froze the type and the\n-                  --  declaration is legal.\n-\n-                  elsif Sloc (Obj_Decl) = Sloc (Decl) then\n-                     return;\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec<<\", Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec<<\", Eq_Op);\n                   end if;\n \n-                  Next (Obj_Decl);\n-               end loop;\n+               else\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  end if;\n+               end if;\n             end if;\n          end if;\n \n@@ -9653,21 +9753,21 @@ package body Sem_Ch6 is\n       --  a type has been derived from T.\n \n       else\n-         Obj_Decl := Next (Parent (Typ));\n+         Decl := Next (Declaration_Node (Typ));\n \n-         while Present (Obj_Decl) and then Obj_Decl /= Decl loop\n-            if Nkind (Obj_Decl) = N_Full_Type_Declaration\n-              and then Etype (Defining_Identifier (Obj_Decl)) = Typ\n+         while Present (Decl) and then Decl /= Eq_Decl loop\n+            if Nkind (Decl) = N_Full_Type_Declaration\n+              and then Etype (Defining_Identifier (Decl)) = Typ\n             then\n                Error_Msg_N\n                  (\"equality operator cannot appear after derivation\", Eq_Op);\n                Error_Msg_NE\n                  (\"an equality operator for& cannot be declared after \"\n                   & \"this point??\",\n-                  Obj_Decl, Typ);\n+                  Decl, Typ);\n             end if;\n \n-            Next (Obj_Decl);\n+            Next (Decl);\n          end loop;\n       end if;\n    end Check_Untagged_Equality;"}, {"sha": "44fc955de74a5394ace16e149fcf998398faa110", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=05e91ac1f89dc0b4757ac7e8ffaacd65bcdc4794", "patch": "@@ -8967,14 +8967,7 @@ package body Sem_Res is\n                then\n                   Eq := Get_User_Defined_Equality (T);\n \n-                  --  We need to make sure that the instance is not within the\n-                  --  same declarative region as the type, or else that it lies\n-                  --  after the declaration of the user-defined \"=\" operator.\n-\n-                  if Present (Eq)\n-                    and then (not In_Same_Extended_Unit (Eq, N)\n-                               or else Earlier_In_Extended_Unit (Eq, N))\n-                  then\n+                  if Present (Eq) then\n                      if Is_Abstract_Subprogram (Eq) then\n                         Nondispatching_Call_To_Abstract_Operation (N, Eq);\n                      else"}]}