{"sha": "b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhNzg1ZmI1ZTVhZGE1ZmZiMDc2NDBiYjhmZTBkMTVmM2JkZGI2OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-11-20T10:03:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-20T10:03:11Z"}, "message": "decl.c (gnat_to_gnu_entity): Adjust call to components_to_record.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Adjust\n\tcall to components_to_record.\n\t(components_to_record): Add FIRST_FREE_POS parameter.  For the variant\n\tpart, reuse enclosing union even if there is a representation clause\n\ton the Unchecked_Union.  If there is a variant part, compute the new\n\tfirst free position, if any.  Adjust call to self.  Use a single field\n\tdirectly only if it hasn't got a representation clause or is placed at\n\toffset zero.  Create the variant part at offset 0 if all the fields\n\tdown to this level have a rep clause.  Do not chain the variant part\n\timmediately and adjust downstream.\n\tDo not test ALL_REP before moving the fields without rep clause to the\n\tprevious level.  Call create_rep_part to create the REP part and force\n\ta minimum size on it if necessary.  Do not chain it immediately.\n\tCreate a fake REP part if there are fields without rep clause that need\n\tto be laid out starting from FIRST_FREE_POS.\n\tAt the end, chain the REP part and then the variant part.\n\t(create_rep_part): New function.\n\t(get_rep_part): Minor tweak.\n\t* gcc-interface/utils.c (tree_code_for_record_type): Minor tweak.\n\nFrom-SVN: r181526", "tree": {"sha": "8c3bf3eed49ecfca419ebe789652ad0382b632ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c3bf3eed49ecfca419ebe789652ad0382b632ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/comments", "author": null, "committer": null, "parents": [{"sha": "4076011132f7483c1cceacb8bfb2d0536e1b980c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4076011132f7483c1cceacb8bfb2d0536e1b980c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4076011132f7483c1cceacb8bfb2d0536e1b980c"}], "stats": {"total": 267, "additions": 201, "deletions": 66}, "files": [{"sha": "3e9e7ea45cd6e8afeca5fb671fe883f3dd6ad1ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -1,3 +1,25 @@\n+2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Adjust\n+\tcall to components_to_record.\n+\t(components_to_record): Add FIRST_FREE_POS parameter.  For the variant\n+\tpart, reuse enclosing union even if there is a representation clause\n+\ton the Unchecked_Union.  If there is a variant part, compute the new\n+\tfirst free position, if any.  Adjust call to self.  Use a single field\n+\tdirectly only if it hasn't got a representation clause or is placed at\n+\toffset zero.  Create the variant part at offset 0 if all the fields\n+\tdown to this level have a rep clause.  Do not chain the variant part\n+\timmediately and adjust downstream.\n+\tDo not test ALL_REP before moving the fields without rep clause to the\n+\tprevious level.  Call create_rep_part to create the REP part and force\n+\ta minimum size on it if necessary.  Do not chain it immediately.\n+\tCreate a fake REP part if there are fields without rep clause that need\n+\tto be laid out starting from FIRST_FREE_POS.\n+\tAt the end, chain the REP part and then the variant part.\n+\t(create_rep_part): New function.\n+\t(get_rep_part): Minor tweak.\n+\t* gcc-interface/utils.c (tree_code_for_record_type): Minor tweak.\n+\n 2011-11-18  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR target/50678"}, {"sha": "12971a63038d357b9d473b423144497ed9b221d5", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 122, "deletions": 57, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -160,7 +160,7 @@ static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static bool constructor_address_p (tree);\n static void components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n-\t\t\t\t  bool, bool, bool, bool, tree *);\n+\t\t\t\t  bool, bool, bool, bool, tree, tree *);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n@@ -176,6 +176,7 @@ static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n \t\t\t\t    VEC(subst_pair,heap) *);\n+static tree create_rep_part (tree, tree, tree);\n static tree get_rep_part (tree);\n static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n \t\t\t\t      tree, VEC(subst_pair,heap) *);\n@@ -3048,7 +3049,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      gnu_field_list, packed, definition, false,\n \t\t\t      all_rep, is_unchecked_union, debug_info_p,\n \t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n-\t\t\t      NULL);\n+\t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n \n \t/* If it is passed by reference, force BLKmode to ensure that objects\n \t   of this type will always be put in memory.  */\n@@ -7096,6 +7097,10 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n \n    REORDER is true if we are permitted to reorder components of this type.\n \n+   FIRST_FREE_POS, if nonzero, is the first (lowest) free field position in\n+   the outer record type down to this variant level.  It is nonzero only if\n+   all the fields down to this level have a rep clause and ALL_REP is false.\n+\n    P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n    with a rep clause is to be added; in this case, that is all that should\n    be done with such fields.  */\n@@ -7106,12 +7111,13 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      bool cancel_alignment, bool all_rep,\n \t\t      bool unchecked_union, bool debug_info,\n \t\t      bool maybe_unused, bool reorder,\n-\t\t      tree *p_gnu_rep_list)\n+\t\t      tree first_free_pos, tree *p_gnu_rep_list)\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool layout_with_rep = false;\n   Node_Id component_decl, variant_part;\n   tree gnu_field, gnu_next, gnu_last;\n+  tree gnu_rep_part = NULL_TREE;\n   tree gnu_variant_part = NULL_TREE;\n   tree gnu_rep_list = NULL_TREE;\n   tree gnu_var_list = NULL_TREE;\n@@ -7185,20 +7191,18 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t= concat_name (get_identifier (Get_Name_String (Chars (gnat_discr))),\n \t\t       \"XVN\");\n       tree gnu_union_type, gnu_union_name;\n-      tree gnu_variant_list = NULL_TREE;\n+      tree this_first_free_pos, gnu_variant_list = NULL_TREE;\n \n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n \tgnu_name = DECL_NAME (gnu_name);\n \n       gnu_union_name\n \t= concat_name (gnu_name, IDENTIFIER_POINTER (gnu_var_name));\n \n-      /* Reuse an enclosing union if all fields are in the variant part\n-\t and there is no representation clause on the record, to match\n-\t the layout of C unions.  There is an associated check below.  */\n-      if (!gnu_field_list\n-\t  && TREE_CODE (gnu_record_type) == UNION_TYPE\n-\t  && !TYPE_PACKED (gnu_record_type))\n+      /* Reuse the enclosing union if this is an Unchecked_Union whose fields\n+\t are all in the variant part, to match the layout of C unions.  There\n+\t is an associated check below.  */\n+      if (TREE_CODE (gnu_record_type) == UNION_TYPE)\n \tgnu_union_type = gnu_record_type;\n       else\n \t{\n@@ -7210,6 +7214,29 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  TYPE_PACKED (gnu_union_type) = TYPE_PACKED (gnu_record_type);\n \t}\n \n+      /* If all the fields down to this level have a rep clause, find out\n+\t whether all the fields at this level also have one.  If so, then\n+\t compute the new first free position to be passed downward.  */\n+      this_first_free_pos = first_free_pos;\n+      if (this_first_free_pos)\n+\t{\n+\t  for (gnu_field = gnu_field_list;\n+\t       gnu_field;\n+\t       gnu_field = DECL_CHAIN (gnu_field))\n+\t    if (DECL_FIELD_OFFSET (gnu_field))\n+\t      {\n+\t\ttree pos = bit_position (gnu_field);\n+\t\tif (!tree_int_cst_lt (pos, this_first_free_pos))\n+\t\t  this_first_free_pos\n+\t\t    = size_binop (PLUS_EXPR, pos, DECL_SIZE (gnu_field));\n+\t      }\n+\t    else\n+\t      {\n+\t\tthis_first_free_pos = NULL_TREE;\n+\t\tbreak;\n+\t      }\n+\t}\n+\n       for (variant = First_Non_Pragma (Variants (variant_part));\n \t   Present (variant);\n \t   variant = Next_Non_Pragma (variant))\n@@ -7231,8 +7258,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  TYPE_PACKED (gnu_variant_type) = TYPE_PACKED (gnu_record_type);\n \n \t  /* Similarly, if the outer record has a size specified and all\n-\t     fields have record rep clauses, we can propagate the size\n-\t     into the variant part.  */\n+\t     the fields have a rep clause, we can propagate the size.  */\n \t  if (all_rep_and_size)\n \t    {\n \t      TYPE_SIZE (gnu_variant_type) = TYPE_SIZE (gnu_record_type);\n@@ -7244,20 +7270,24 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t     we aren't sure to really use it at this point, see below.  */\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n-\t\t\t\t!all_rep_and_size, all_rep,\n-\t\t\t\tunchecked_union, debug_info,\n-\t\t\t\ttrue, reorder, &gnu_rep_list);\n+\t\t\t\t!all_rep_and_size, all_rep, unchecked_union,\n+\t\t\t\tdebug_info, true, reorder, this_first_free_pos,\n+\t\t\t\tall_rep || this_first_free_pos\n+\t\t\t\t? NULL : &gnu_rep_list);\n \n \t  gnu_qual = choices_to_gnu (gnu_discr, Discrete_Choices (variant));\n-\n \t  Set_Present_Expr (variant, annotate_value (gnu_qual));\n \n-\t  /* If this is an Unchecked_Union and we have exactly one field,\n-\t     use this field directly to match the layout of C unions.  */\n-\t  if (unchecked_union\n-\t      && TYPE_FIELDS (gnu_variant_type)\n-\t      && !DECL_CHAIN (TYPE_FIELDS (gnu_variant_type)))\n-\t    gnu_field = TYPE_FIELDS (gnu_variant_type);\n+\t  /* If this is an Unchecked_Union whose fields are all in the variant\n+\t     part and we have a single field with no representation clause or\n+\t     placed at offset zero, use the field directly to match the layout\n+\t     of C unions.  */\n+\t  if (TREE_CODE (gnu_record_type) == UNION_TYPE\n+\t      && (gnu_field = TYPE_FIELDS (gnu_variant_type)) != NULL_TREE\n+\t      && !DECL_CHAIN (gnu_field)\n+\t      && (!DECL_FIELD_OFFSET (gnu_field)\n+\t\t  || integer_zerop (bit_position (gnu_field))))\n+\t    DECL_CONTEXT (gnu_field) = gnu_union_type;\n \t  else\n \t    {\n \t      /* Deal with packedness like in gnat_to_gnu_field.  */\n@@ -7328,15 +7358,18 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  gnu_variant_part\n \t    = create_field_decl (gnu_var_name, gnu_union_type, gnu_record_type,\n \t\t\t\t all_rep ? TYPE_SIZE (gnu_union_type) : 0,\n-\t\t\t\t all_rep ? bitsize_zero_node : 0,\n+\t\t\t\t all_rep || this_first_free_pos\n+\t\t\t\t ? bitsize_zero_node : 0,\n \t\t\t\t union_field_packed, 0);\n \n \t  DECL_INTERNAL_P (gnu_variant_part) = 1;\n-\t  DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n-\t  gnu_field_list = gnu_variant_part;\n \t}\n     }\n \n+  /* From now on, a zero FIRST_FREE_POS is totally useless.  */\n+  if (first_free_pos && integer_zerop (first_free_pos))\n+    first_free_pos = NULL_TREE;\n+\n   /* Scan GNU_FIELD_LIST and see if any fields have rep clauses and, if we are\n      permitted to reorder components, self-referential sizes or variable sizes.\n      If they do, pull them out and put them onto the appropriate list.  We have\n@@ -7368,33 +7401,24 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  continue;\n \t}\n \n-      if (reorder)\n+      /* Reorder non-internal fields with non-fixed size.  */\n+      if (reorder\n+\t  && !DECL_INTERNAL_P (gnu_field)\n+\t  && !(DECL_SIZE (gnu_field)\n+\t       && TREE_CODE (DECL_SIZE (gnu_field)) == INTEGER_CST))\n \t{\n-\t  /* Pull out the variant part and put it onto GNU_SELF_LIST.  */\n-\t  if (gnu_field == gnu_variant_part)\n+\t  tree type_size = TYPE_SIZE (TREE_TYPE (gnu_field));\n+\n+\t  if (CONTAINS_PLACEHOLDER_P (type_size))\n \t    {\n \t      MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n \t      continue;\n \t    }\n \n-\t  /* Skip internal fields and fields with fixed size.  */\n-\t  if (!DECL_INTERNAL_P (gnu_field)\n-\t      && !(DECL_SIZE (gnu_field)\n-\t\t   && TREE_CODE (DECL_SIZE (gnu_field)) == INTEGER_CST))\n+\t  if (TREE_CODE (type_size) != INTEGER_CST)\n \t    {\n-\t      tree type_size = TYPE_SIZE (TREE_TYPE (gnu_field));\n-\n-\t      if (CONTAINS_PLACEHOLDER_P (type_size))\n-\t\t{\n-\t\t  MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (TREE_CODE (type_size) != INTEGER_CST)\n-\t\t{\n-\t\t  MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n-\t\t  continue;\n-\t\t}\n+\t      MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n+\t      continue;\n \t    }\n \t}\n \n@@ -7416,14 +7440,14 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       = chainon (nreverse (gnu_self_list),\n \t\t chainon (nreverse (gnu_var_list), gnu_field_list));\n \n-  /* If we have any fields in our rep'ed field list and it is not the case that\n-     all the fields in the record have rep clauses and P_REP_LIST is nonzero,\n-     set it and ignore these fields.  */\n-  if (gnu_rep_list && p_gnu_rep_list && !all_rep)\n+  /* If P_REP_LIST is nonzero, this means that we are asked to move the fields\n+     in our REP list to the previous level because this level needs them in\n+     order to do a correct layout, i.e. avoid having overlapping fields.  */\n+  if (p_gnu_rep_list && gnu_rep_list)\n     *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_rep_list);\n \n   /* Otherwise, sort the fields by bit position and put them into their own\n-     record, before the others, if we also have fields without rep clauses.  */\n+     record, before the others, if we also have fields without rep clause.  */\n   else if (gnu_rep_list)\n     {\n       tree gnu_rep_type\n@@ -7451,11 +7475,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       if (gnu_field_list)\n \t{\n \t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);\n-\t  gnu_field\n-\t    = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n-\t\t\t\t gnu_record_type, NULL_TREE, NULL_TREE, 0, 1);\n-\t  DECL_INTERNAL_P (gnu_field) = 1;\n-\t  gnu_field_list = chainon (gnu_field_list, gnu_field);\n+\n+\t  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields\n+\t     without rep clause are laid out starting from this position.\n+\t     Therefore, we force it as a minimal size on the REP part.  */\n+\t  gnu_rep_part\n+\t    = create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);\n \t}\n       else\n \t{\n@@ -7464,6 +7489,28 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t}\n     }\n \n+  /* If FIRST_FREE_POS is nonzero, we need to ensure that the fields without\n+     rep clause are laid out starting from this position.  Therefore, if we\n+     have not already done so, we create a fake REP part with this size.  */\n+  if (first_free_pos && !layout_with_rep && !gnu_rep_part)\n+    {\n+      tree gnu_rep_type = make_node (RECORD_TYPE);\n+      finish_record_type (gnu_rep_type, NULL_TREE, 0, debug_info);\n+      gnu_rep_part\n+\t= create_rep_part (gnu_rep_type, gnu_record_type, first_free_pos);\n+    }\n+\n+  /* Now chain the REP part at the end of the reversed field list.  */\n+  if (gnu_rep_part)\n+    gnu_field_list = chainon (gnu_field_list, gnu_rep_part);\n+\n+  /* And the variant part at the beginning.  */\n+  if (gnu_variant_part)\n+    {\n+      DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n+      gnu_field_list = gnu_variant_part;\n+    }\n+\n   if (cancel_alignment)\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n@@ -8567,6 +8614,24 @@ create_field_decl_from (tree old_field, tree field_type, tree record_type,\n   return new_field;\n }\n \n+/* Create the REP part of RECORD_TYPE with REP_TYPE.  If MIN_SIZE is nonzero,\n+   it is the minimal size the REP_PART must have.  */\n+\n+static tree\n+create_rep_part (tree rep_type, tree record_type, tree min_size)\n+{\n+  tree field;\n+\n+  if (min_size && !tree_int_cst_lt (TYPE_SIZE (rep_type), min_size))\n+    min_size = NULL_TREE;\n+\n+  field = create_field_decl (get_identifier (\"REP\"), rep_type, record_type,\n+\t\t\t     min_size, bitsize_zero_node, 0, 1);\n+  DECL_INTERNAL_P (field) = 1;\n+\n+  return field;\n+}\n+\n /* Return the REP part of RECORD_TYPE, if any.  Otherwise return NULL.  */\n \n static tree\n@@ -8575,10 +8640,10 @@ get_rep_part (tree record_type)\n   tree field = TYPE_FIELDS (record_type);\n \n   /* The REP part is the first field, internal, another record, and its name\n-     doesn't start with an underscore (i.e. is not generated by the FE).  */\n+     starts with an 'R'.  */\n   if (DECL_INTERNAL_P (field)\n       && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-      && IDENTIFIER_POINTER (DECL_NAME (field)) [0] != '_')\n+      && IDENTIFIER_POINTER (DECL_NAME (field)) [0] == 'R')\n     return field;\n \n   return NULL_TREE;"}, {"sha": "a71a3d2887872309df4da0e146c84a66f5ae58a8", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -4744,19 +4744,17 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n enum tree_code\n tree_code_for_record_type (Entity_Id gnat_type)\n {\n-  Node_Id component_list\n-    = Component_List (Type_Definition\n-\t\t      (Declaration_Node\n-\t\t       (Implementation_Base_Type (gnat_type))));\n-  Node_Id component;\n-\n- /* Make this a UNION_TYPE unless it's either not an Unchecked_Union or\n-    we have a non-discriminant field outside a variant.  In either case,\n-    it's a RECORD_TYPE.  */\n+  Node_Id component_list, component;\n \n+  /* Return UNION_TYPE if it's an Unchecked_Union whose non-discriminant\n+     fields are all in the variant part.  Otherwise, return RECORD_TYPE.  */\n   if (!Is_Unchecked_Union (gnat_type))\n     return RECORD_TYPE;\n \n+  gnat_type = Implementation_Base_Type (gnat_type);\n+  component_list\n+    = Component_List (Type_Definition (Declaration_Node (gnat_type)));\n+\n   for (component = First_Non_Pragma (Component_Items (component_list));\n        Present (component);\n        component = Next_Non_Pragma (component))"}, {"sha": "6c85640c261939b26cbc90945286a848a466dfdd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -1,3 +1,8 @@\n+2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr32.adb: New test.\n+\t* gnat.dg/discr32_pkg.ads: New helper.\n+\n 2011-11-20  Nathan Sidwell  <nathan@acm.org>\n \n \tPR gcov-profile/51113"}, {"sha": "830a6dfd59a978eafc5360d386063d438d12f306", "filename": "gcc/testsuite/gnat.dg/discr32.adb", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32.adb?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -0,0 +1,21 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+with Discr32_Pkg; use Discr32_Pkg;\n+\n+procedure Discr32 is\n+begin\n+\n+  if R1'Object_Size /= 32 then\n+    raise Program_Error;\n+  end if;\n+\n+  if R2'Object_Size /= R'Object_Size then\n+    raise Program_Error;\n+  end if;\n+\n+  if R3'Object_Size /= 64 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "f1761e4b5e5ca6e27aad45a46b326069a072ba67", "filename": "gcc/testsuite/gnat.dg/discr32_pkg.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr32_pkg.ads?ref=b1a785fb5e5ada5ffb07640bb8fe0d15f3bddb68", "patch": "@@ -0,0 +1,24 @@\n+package Discr32_Pkg is\n+\n+  type Enum is (One, Two, Three);\n+\n+  type R (D : Enum) is record\n+    case D is\n+      when One   => B : Boolean;\n+      when Two   => I : Integer;\n+      when Three => F : Float;\n+    end case;\n+  end record;\n+\n+  for R use record\n+     D at 0 range 0 .. 1;\n+     B at 1 range 0 .. 0;\n+     I at 4 range 0 .. 31 + 128;\n+--     F at 4 range 0 .. 31;\n+  end record;\n+\n+  subtype R1 is R (One);\n+  subtype R2 is R (Two);\n+  subtype R3 is R (Three);\n+\n+end Discr32_Pkg;"}]}