{"sha": "81c411666a736dadfc8774ba1ce1823d69c55077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFjNDExNjY2YTczNmRhZGZjODc3NGJhMWNlMTgyM2Q2OWM1NTA3Nw==", "commit": {"author": {"name": "Revital Eres", "email": "revital.eres@linaro.org", "date": "2011-06-16T06:25:51Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2011-06-16T06:25:51Z"}, "message": "SMS: Fix calculation of row_rest_count\n\nFrom-SVN: r175091", "tree": {"sha": "711099892d5b9f63d4a3afe5186f493cbd13e01d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/711099892d5b9f63d4a3afe5186f493cbd13e01d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81c411666a736dadfc8774ba1ce1823d69c55077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c411666a736dadfc8774ba1ce1823d69c55077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81c411666a736dadfc8774ba1ce1823d69c55077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c411666a736dadfc8774ba1ce1823d69c55077/comments", "author": null, "committer": null, "parents": [{"sha": "d24dc7b33c9190f8c48cad5b53411c97956c3a59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d24dc7b33c9190f8c48cad5b53411c97956c3a59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d24dc7b33c9190f8c48cad5b53411c97956c3a59"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "eb447c306a1c2ddc97507fe040c3dd3b455e41e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c411666a736dadfc8774ba1ce1823d69c55077/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c411666a736dadfc8774ba1ce1823d69c55077/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81c411666a736dadfc8774ba1ce1823d69c55077", "patch": "@@ -1,3 +1,18 @@\n+2011-06-16  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* modulo-sched.c (struct ps_insn): Remove row_rest_count field.\n+\t(struct partial_schedule): Add rows_length field.\n+\t(verify_partial_schedule): Check rows_length.\n+\t(ps_insert_empty_row): Handle rows_length.\n+\t(create_partial_schedule): Likewise.\n+\t(free_partial_schedule): Likewise.\n+\t(reset_partial_schedule): Likewise.\n+\t(create_ps_insn): Remove rest_count argument.\n+\t(remove_node_from_ps): Update rows_length.\n+\t(add_node_to_ps): Update rows_length and call create_ps_insn\n+\twithout passing row_rest_count.\n+\t(rotate_partial_schedule): Update rows_length.\n+\n 2011-06-16  Revital Eres  <revital.eres@linaro.org>\n \n \t* ddg.c (add_intra_loop_mem_dep): New function."}, {"sha": "e9749b23a6fc1288c846ceaf3e5bac1c58b32230", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c411666a736dadfc8774ba1ce1823d69c55077/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c411666a736dadfc8774ba1ce1823d69c55077/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=81c411666a736dadfc8774ba1ce1823d69c55077", "patch": "@@ -134,8 +134,6 @@ struct ps_insn\n   ps_insn_ptr next_in_row,\n \t      prev_in_row;\n \n-  /* The number of nodes in the same row that come after this node.  */\n-  int row_rest_count;\n };\n \n /* Holds the partial schedule as an array of II rows.  Each entry of the\n@@ -149,6 +147,12 @@ struct partial_schedule\n   /* rows[i] points to linked list of insns scheduled in row i (0<=i<ii).  */\n   ps_insn_ptr *rows;\n \n+  /*  rows_length[i] holds the number of instructions in the row.\n+      It is used only (as an optimization) to back off quickly from\n+      trying to schedule a node in a full row; that is, to avoid running\n+      through futile DFA state transitions.  */\n+  int *rows_length;\n+  \n   /* The earliest absolute cycle of an insn in the partial schedule.  */\n   int min_cycle;\n \n@@ -1908,6 +1912,7 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n   int ii = ps->ii;\n   int new_ii = ii + 1;\n   int row;\n+  int *rows_length_new;\n \n   verify_partial_schedule (ps, sched_nodes);\n \n@@ -1922,9 +1927,11 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n   rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n \n   rows_new = (ps_insn_ptr *) xcalloc (new_ii, sizeof (ps_insn_ptr));\n+  rows_length_new = (int *) xcalloc (new_ii, sizeof (int));\n   for (row = 0; row < split_row; row++)\n     {\n       rows_new[row] = ps->rows[row];\n+      rows_length_new[row] = ps->rows_length[row];\n       ps->rows[row] = NULL;\n       for (crr_insn = rows_new[row];\n \t   crr_insn; crr_insn = crr_insn->next_in_row)\n@@ -1945,6 +1952,7 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n   for (row = split_row; row < ii; row++)\n     {\n       rows_new[row + 1] = ps->rows[row];\n+      rows_length_new[row + 1] = ps->rows_length[row];\n       ps->rows[row] = NULL;\n       for (crr_insn = rows_new[row + 1];\n \t   crr_insn; crr_insn = crr_insn->next_in_row)\n@@ -1966,6 +1974,8 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n     + (SMODULO (ps->max_cycle, ii) >= split_row ? 1 : 0);\n   free (ps->rows);\n   ps->rows = rows_new;\n+  free (ps->rows_length);\n+  ps->rows_length = rows_length_new;\n   ps->ii = new_ii;\n   gcc_assert (ps->min_cycle >= 0);\n \n@@ -2041,16 +2051,23 @@ verify_partial_schedule (partial_schedule_ptr ps, sbitmap sched_nodes)\n   ps_insn_ptr crr_insn;\n \n   for (row = 0; row < ps->ii; row++)\n-    for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n-      {\n-\tddg_node_ptr u = crr_insn->node;\n-\n-\tgcc_assert (TEST_BIT (sched_nodes, u->cuid));\n-\t/* ??? Test also that all nodes of sched_nodes are in ps, perhaps by\n-\t   popcount (sched_nodes) == number of insns in ps.  */\n-\tgcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n-\tgcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n-      }\n+    {\n+      int length = 0;\n+      \n+      for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n+\t{\n+\t  ddg_node_ptr u = crr_insn->node;\n+\t  \n+\t  length++;\n+\t  gcc_assert (TEST_BIT (sched_nodes, u->cuid));\n+\t  /* ??? Test also that all nodes of sched_nodes are in ps, perhaps by\n+\t     popcount (sched_nodes) == number of insns in ps.  */\n+\t  gcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n+\t  gcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n+\t}\n+      \n+      gcc_assert (ps->rows_length[row] == length);\n+    }\n }\n \n \f\n@@ -2456,6 +2473,7 @@ create_partial_schedule (int ii, ddg_ptr g, int history)\n {\n   partial_schedule_ptr ps = XNEW (struct partial_schedule);\n   ps->rows = (ps_insn_ptr *) xcalloc (ii, sizeof (ps_insn_ptr));\n+  ps->rows_length = (int *) xcalloc (ii, sizeof (int));\n   ps->ii = ii;\n   ps->history = history;\n   ps->min_cycle = INT_MAX;\n@@ -2494,6 +2512,7 @@ free_partial_schedule (partial_schedule_ptr ps)\n     return;\n   free_ps_insns (ps);\n   free (ps->rows);\n+  free (ps->rows_length);\n   free (ps);\n }\n \n@@ -2511,6 +2530,8 @@ reset_partial_schedule (partial_schedule_ptr ps, int new_ii)\n   ps->rows = (ps_insn_ptr *) xrealloc (ps->rows, new_ii\n \t\t\t\t\t\t * sizeof (ps_insn_ptr));\n   memset (ps->rows, 0, new_ii * sizeof (ps_insn_ptr));\n+  ps->rows_length = (int *) xrealloc (ps->rows_length, new_ii * sizeof (int));\n+  memset (ps->rows_length, 0, new_ii * sizeof (int));\n   ps->ii = new_ii;\n   ps->min_cycle = INT_MAX;\n   ps->max_cycle = INT_MIN;\n@@ -2539,14 +2560,13 @@ print_partial_schedule (partial_schedule_ptr ps, FILE *dump)\n \n /* Creates an object of PS_INSN and initializes it to the given parameters.  */\n static ps_insn_ptr\n-create_ps_insn (ddg_node_ptr node, int rest_count, int cycle)\n+create_ps_insn (ddg_node_ptr node, int cycle)\n {\n   ps_insn_ptr ps_i = XNEW (struct ps_insn);\n \n   ps_i->node = node;\n   ps_i->next_in_row = NULL;\n   ps_i->prev_in_row = NULL;\n-  ps_i->row_rest_count = rest_count;\n   ps_i->cycle = cycle;\n \n   return ps_i;\n@@ -2579,6 +2599,8 @@ remove_node_from_ps (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n       if (ps_i->next_in_row)\n \tps_i->next_in_row->prev_in_row = ps_i->prev_in_row;\n     }\n+   \n+  ps->rows_length[row] -= 1; \n   free (ps_i);\n   return true;\n }\n@@ -2735,17 +2757,12 @@ add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle,\n \t\tsbitmap must_precede, sbitmap must_follow)\n {\n   ps_insn_ptr ps_i;\n-  int rest_count = 1;\n   int row = SMODULO (cycle, ps->ii);\n \n-  if (ps->rows[row]\n-      && ps->rows[row]->row_rest_count >= issue_rate)\n+  if (ps->rows_length[row] >= issue_rate)\n     return NULL;\n \n-  if (ps->rows[row])\n-    rest_count += ps->rows[row]->row_rest_count;\n-\n-  ps_i = create_ps_insn (node, rest_count, cycle);\n+  ps_i = create_ps_insn (node, cycle);\n \n   /* Finds and inserts PS_I according to MUST_FOLLOW and\n      MUST_PRECEDE.  */\n@@ -2755,6 +2772,7 @@ add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle,\n       return NULL;\n     }\n \n+  ps->rows_length[row] += 1;\n   return ps_i;\n }\n \n@@ -2910,11 +2928,16 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n   for (i = 0; i < backward_rotates; i++)\n     {\n       ps_insn_ptr first_row = ps->rows[0];\n+      int first_row_length = ps->rows_length[0];\n \n       for (row = 0; row < last_row; row++)\n-\tps->rows[row] = ps->rows[row+1];\n+\t{\n+\t  ps->rows[row] = ps->rows[row + 1];\n+\t  ps->rows_length[row] = ps->rows_length[row + 1]; \n+\t}\n \n       ps->rows[last_row] = first_row;\n+      ps->rows_length[last_row] = first_row_length;\n     }\n \n   ps->max_cycle -= start_cycle;"}]}