{"sha": "80560f9521f81ae2c50b52b091b4caaf7d3d4397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA1NjBmOTUyMWY4MWFlMmM1MGI1MmIwOTFiNGNhYWY3ZDNkNDM5Nw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-01T15:46:53Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-01T15:46:53Z"}, "message": "tree-into-ssa.c (enum need_phi_state): Relocate from tree-flow.h.\n\n\n\n\t* tree-into-ssa.c (enum need_phi_state): Relocate from tree-flow.h.\n\t(dump_decl_set): Move to gimple.c.\n\t* gimple.h: Don't include tree-ssa-operands.h.\n\t(dump_decl_set): Add prototype.\n\t(gimple_vuse_op, gimple_vdef_op, update_stmt, update_stmt_if_modified):\n\tMove to gimple-ssa.h.\n\t(phi_ssa_name_p, phi_nodes, phi_nodes_ptr, gimple_phi_arg_def,\n\tgimple_phi_arg_def_ptr, gimple_phi_arg_edge, gimple_phi_arg_location,\n\tgimple_phi_arg_location_from_edge, gimple_phi_arg_set_location,\n\tgimple_phi_arg_has_location): Relocate from tree-flow-inline.h\n\t* gimple.c (walk_stmt_load_store_ops): Use gimple_phi_arg_def rather\n\tthan PHI_ARG_DEF.\n\t(dump_decl_set): Relocate here.\n\t* gimple-ssa.h: New file.\n\t(gimple_vuse_op, gimple_vdef_op, update_stmt, update_stmt_if_modified):\n\tRelocate from gimple.h.\n\t* tree-cfg.c (has_zero_uses_1, single_imm_use_1): Move to...\n\t* tree-ssa-operands.c (swap_ssa_operands): Rename from\n\tswap_tree_operands and remove non-ssa path.\n\t(has_zero_uses_1, single_imm_use_1): Relocate from tree-cfg.c.\n\t* tree-ssa-reassoc.c (linearize_expr_tree, repropagate_negates): Use\n\tswap_ssa_operands.\n\t* tree-vect-loop.c (destroy_loop_vec_info, vect_is_slp_reduction,\n\tvect_is_simple_reduction_1): Use swap_ssa_operands.\n\t* tree-flow.h: Move various prototypes to tree-phinodes.h.\n\t(enum need_phi_state): Move to tree-into-ssa.c.\n\t(struct immediate_use_iterator_d, FOR_EACH_IMM_*,\n\tBREAK_FROM_IMM_USE_STMT): Move to ssa-iterators.h.\n\t(swap_tree_operands): Rename and move prototype to tree-ssa-operands.h.\n\t* tree-flow-inline.h (delink_imm_use, link_imm_use_to_list,\n\tlink_imm_use, set_ssa_use_from_ptr, link_imm_use_stmt, relink_imm_use,\n\trelink_imm_use_stmt, end_readonly_imm_use_p, first_readonly_imm_use,\n\tnext_readonly_imm_use, has_zero_uses, has_single_use, single_imm_use,\n\tnum_imm_uses): Move to ssa-iterators.h.\n\t(get_use_from_ptr, get_def_from_ptr): Move to tree-ssa-operands.h\n\t(gimple_phi_arg_imm_use_ptr, phi_arg_index_from_use): Move to \n\ttree-phinodes.h.\n\t(op_iter_done, op_iter_next_def, op_iter_next_tree,\n\tclear_and_done_ssa_iter, op_iter_init, op_iter_init_use,\n\top_iter_init_def, op_iter_init_tree, single_ssa_tree_operand,\n\tsingle_ssa_use_operand, single_ssa_def_operand, zero_ssa_operands,\n\tnum_ssa_operands, delink_stmt_imm_use, single_phi_def,\n\top_iter_init_phiuse, op_iter_init_phidef, end_imm_use_stmt_p,\n\tend_imm_use_stmt_traverse, move_use_after_head, link_use_stmts_after,\n\tfirst_imm_use_stmt, next_imm_use_stmt, first_imm_use_on_stmt,\n\tend_imm_use_on_stmt_p, next_imm_use_on_stmt): Move to ssa-iterators.h.\n\t(gimple_phi_arg_def, gimple_phi_arg_def_ptr, gimple_phi_arg_edge,\n\tgimple_phi_arg_location, gimple_phi_arg_location_from_edge,\n\tgimple_phi_arg_set_location, gimple_phi_arg_has_location, phi_nodes,\n\tphi_nodes_ptr, phi_ssa_name_p): Move to gimple.h.\n\t(set_phi_nodes): Move to tree-phinodes.h.\n\t* tree-ssa-operands.h (enum ssa_op_iter_type,\n\tstruct ssa_operand_iterator_d, SSA_OP*, FOR_EACH_SSA*, SINGLE_SSA*,\n\tZERO_SSA_OPERANDS, NUM_SSA_OPERANDS): Move to ssa-iterators.h.\n\t(dump_decl_set): Remove prototype.\n\t(get_use_from_ptr, get_def_from_ptr): Relocate from tree-flow.h.\n\t* tree-phinodes.h: New file.  Move some prototypes from tree-flow.h.\n\t(set_phi_nodes): Relocate from tree-flow-inline.h.\n\t(gimple_phi_arg_imm_use_ptr, phi_arg_index_from_use): Relocate from\n\ttree-flow-inline.h\n\t* tree-ssa.h: Add tree-phinodes.h, gimple-ssa.h, ssa-iterators.h to\n\tinclude list.  Temporarily add gimple.h to include list.\n\t* ssa-iterators.h: New file.\n\t(struct immediate_use_iterator_d, FOR_EACH_IMM_*,\n\tBREAK_FROM_IMM_USE_STMT): Relocate from tree-flow.h.\n\t(enum ssa_op_iter_type, struct ssa_operand_iterator_d, SSA_OP*,\n\tFOR_EACH_SSA*, SINGLE_SSA*, ZERO_SSA_OPERANDS, NUM_SSA_OPERANDS):\n\tRelocate from tree-ssa-operands.h.\n\t(delink_imm_use, link_imm_use_to_list, link_imm_use,\n\tset_ssa_use_from_ptr, link_imm_use_stmt, relink_imm_use,\n\trelink_imm_use_stmt, end_readonly_imm_use_p, first_readonly_imm_use,\n\tnext_readonly_imm_use, has_zero_uses, has_single_use, single_imm_use,\n\tnum_imm_uses, get_use_from_ptr, get_def_from_ptr,\n\tphi_arg_index_from_use, op_iter_done, op_iter_next_def,\n\top_iter_next_tree, clear_and_done_ssa_iter, op_iter_init,\n\top_iter_init_use, op_iter_init_def, op_iter_init_tree,\n\tsingle_ssa_tree_operand, single_ssa_use_operand, single_ssa_def_operand,\n\tzero_ssa_operands, num_ssa_operands, delink_stmt_imm_use,\n\tsingle_phi_def, op_iter_init_phiuse, op_iter_init_phidef,\n\tend_imm_use_stmt_p, end_imm_use_stmt_traverse, move_use_after_head,\n\tlink_use_stmts_after, first_imm_use_stmt, next_imm_use_stmt,\n\tfirst_imm_use_on_stmt, end_imm_use_on_stmt_p, next_imm_use_on_stmt):\n\tRelocate from tree-flow-inline.h.\n\t* tree-outof-ssa.h: Change _SSAEXPAND_H macro to GCC_TREE_OUTOF_SSA_H.\n\nFrom-SVN: r203068", "tree": {"sha": "eaa52ec7e3d23ca35b23922da83d4e62a0837824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa52ec7e3d23ca35b23922da83d4e62a0837824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80560f9521f81ae2c50b52b091b4caaf7d3d4397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80560f9521f81ae2c50b52b091b4caaf7d3d4397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80560f9521f81ae2c50b52b091b4caaf7d3d4397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80560f9521f81ae2c50b52b091b4caaf7d3d4397/comments", "author": null, "committer": null, "parents": [{"sha": "70b50ed7b5730785d6a16d6f7faae180e58af06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b50ed7b5730785d6a16d6f7faae180e58af06b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b50ed7b5730785d6a16d6f7faae180e58af06b"}], "stats": {"total": 2797, "additions": 1476, "deletions": 1321}, "files": [{"sha": "8764f0dd2f39506c7fbf5ddda1e0569cb459ba6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -1,3 +1,90 @@\n+2013-10-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-into-ssa.c (enum need_phi_state): Relocate from tree-flow.h.\n+\t(dump_decl_set): Move to gimple.c.\n+\t* gimple.h: Don't include tree-ssa-operands.h.\n+\t(dump_decl_set): Add prototype.\n+\t(gimple_vuse_op, gimple_vdef_op, update_stmt, update_stmt_if_modified):\n+\tMove to gimple-ssa.h.\n+\t(phi_ssa_name_p, phi_nodes, phi_nodes_ptr, gimple_phi_arg_def,\n+\tgimple_phi_arg_def_ptr, gimple_phi_arg_edge, gimple_phi_arg_location,\n+\tgimple_phi_arg_location_from_edge, gimple_phi_arg_set_location,\n+\tgimple_phi_arg_has_location): Relocate from tree-flow-inline.h\n+\t* gimple.c (walk_stmt_load_store_ops): Use gimple_phi_arg_def rather\n+\tthan PHI_ARG_DEF.\n+\t(dump_decl_set): Relocate here.\n+\t* gimple-ssa.h: New file.\n+\t(gimple_vuse_op, gimple_vdef_op, update_stmt, update_stmt_if_modified):\n+\tRelocate from gimple.h.\n+\t* tree-cfg.c (has_zero_uses_1, single_imm_use_1): Move to...\n+\t* tree-ssa-operands.c (swap_ssa_operands): Rename from\n+\tswap_tree_operands and remove non-ssa path.\n+\t(has_zero_uses_1, single_imm_use_1): Relocate from tree-cfg.c.\n+\t* tree-ssa-reassoc.c (linearize_expr_tree, repropagate_negates): Use\n+\tswap_ssa_operands.\n+\t* tree-vect-loop.c (destroy_loop_vec_info, vect_is_slp_reduction,\n+\tvect_is_simple_reduction_1): Use swap_ssa_operands.\n+\t* tree-flow.h: Move various prototypes to tree-phinodes.h.\n+\t(enum need_phi_state): Move to tree-into-ssa.c.\n+\t(struct immediate_use_iterator_d, FOR_EACH_IMM_*,\n+\tBREAK_FROM_IMM_USE_STMT): Move to ssa-iterators.h.\n+\t(swap_tree_operands): Rename and move prototype to tree-ssa-operands.h.\n+\t* tree-flow-inline.h (delink_imm_use, link_imm_use_to_list,\n+\tlink_imm_use, set_ssa_use_from_ptr, link_imm_use_stmt, relink_imm_use,\n+\trelink_imm_use_stmt, end_readonly_imm_use_p, first_readonly_imm_use,\n+\tnext_readonly_imm_use, has_zero_uses, has_single_use, single_imm_use,\n+\tnum_imm_uses): Move to ssa-iterators.h.\n+\t(get_use_from_ptr, get_def_from_ptr): Move to tree-ssa-operands.h\n+\t(gimple_phi_arg_imm_use_ptr, phi_arg_index_from_use): Move to \n+\ttree-phinodes.h.\n+\t(op_iter_done, op_iter_next_def, op_iter_next_tree,\n+\tclear_and_done_ssa_iter, op_iter_init, op_iter_init_use,\n+\top_iter_init_def, op_iter_init_tree, single_ssa_tree_operand,\n+\tsingle_ssa_use_operand, single_ssa_def_operand, zero_ssa_operands,\n+\tnum_ssa_operands, delink_stmt_imm_use, single_phi_def,\n+\top_iter_init_phiuse, op_iter_init_phidef, end_imm_use_stmt_p,\n+\tend_imm_use_stmt_traverse, move_use_after_head, link_use_stmts_after,\n+\tfirst_imm_use_stmt, next_imm_use_stmt, first_imm_use_on_stmt,\n+\tend_imm_use_on_stmt_p, next_imm_use_on_stmt): Move to ssa-iterators.h.\n+\t(gimple_phi_arg_def, gimple_phi_arg_def_ptr, gimple_phi_arg_edge,\n+\tgimple_phi_arg_location, gimple_phi_arg_location_from_edge,\n+\tgimple_phi_arg_set_location, gimple_phi_arg_has_location, phi_nodes,\n+\tphi_nodes_ptr, phi_ssa_name_p): Move to gimple.h.\n+\t(set_phi_nodes): Move to tree-phinodes.h.\n+\t* tree-ssa-operands.h (enum ssa_op_iter_type,\n+\tstruct ssa_operand_iterator_d, SSA_OP*, FOR_EACH_SSA*, SINGLE_SSA*,\n+\tZERO_SSA_OPERANDS, NUM_SSA_OPERANDS): Move to ssa-iterators.h.\n+\t(dump_decl_set): Remove prototype.\n+\t(get_use_from_ptr, get_def_from_ptr): Relocate from tree-flow.h.\n+\t* tree-phinodes.h: New file.  Move some prototypes from tree-flow.h.\n+\t(set_phi_nodes): Relocate from tree-flow-inline.h.\n+\t(gimple_phi_arg_imm_use_ptr, phi_arg_index_from_use): Relocate from\n+\ttree-flow-inline.h\n+\t* tree-ssa.h: Add tree-phinodes.h, gimple-ssa.h, ssa-iterators.h to\n+\tinclude list.  Temporarily add gimple.h to include list.\n+\t* ssa-iterators.h: New file.\n+\t(struct immediate_use_iterator_d, FOR_EACH_IMM_*,\n+\tBREAK_FROM_IMM_USE_STMT): Relocate from tree-flow.h.\n+\t(enum ssa_op_iter_type, struct ssa_operand_iterator_d, SSA_OP*,\n+\tFOR_EACH_SSA*, SINGLE_SSA*, ZERO_SSA_OPERANDS, NUM_SSA_OPERANDS):\n+\tRelocate from tree-ssa-operands.h.\n+\t(delink_imm_use, link_imm_use_to_list, link_imm_use,\n+\tset_ssa_use_from_ptr, link_imm_use_stmt, relink_imm_use,\n+\trelink_imm_use_stmt, end_readonly_imm_use_p, first_readonly_imm_use,\n+\tnext_readonly_imm_use, has_zero_uses, has_single_use, single_imm_use,\n+\tnum_imm_uses, get_use_from_ptr, get_def_from_ptr,\n+\tphi_arg_index_from_use, op_iter_done, op_iter_next_def,\n+\top_iter_next_tree, clear_and_done_ssa_iter, op_iter_init,\n+\top_iter_init_use, op_iter_init_def, op_iter_init_tree,\n+\tsingle_ssa_tree_operand, single_ssa_use_operand, single_ssa_def_operand,\n+\tzero_ssa_operands, num_ssa_operands, delink_stmt_imm_use,\n+\tsingle_phi_def, op_iter_init_phiuse, op_iter_init_phidef,\n+\tend_imm_use_stmt_p, end_imm_use_stmt_traverse, move_use_after_head,\n+\tlink_use_stmts_after, first_imm_use_stmt, next_imm_use_stmt,\n+\tfirst_imm_use_on_stmt, end_imm_use_on_stmt_p, next_imm_use_on_stmt):\n+\tRelocate from tree-flow-inline.h.\n+\t* tree-outof-ssa.h: Change _SSAEXPAND_H macro to GCC_TREE_OUTOF_SSA_H.\n+\n 2013-10-01  Vidya Praveen  <vidyapraveen@arm.com>\n \n \t* aarch64-simd.md"}, {"sha": "0687847ff12ed9e735b3cf10bd8e2a5e6732f5f6", "filename": "gcc/gimple-ssa.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -0,0 +1,73 @@\n+/* Header file for routines that straddle the border between GIMPLE and\n+   SSA in gimple.\n+   Copyright (C) 2009-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_SSA_H\n+#define GCC_GIMPLE_SSA_H\n+\n+/* Return the set of VUSE operand for statement G.  */\n+\n+static inline use_operand_p\n+gimple_vuse_op (const_gimple g)\n+{\n+  struct use_optype_d *ops;\n+  if (!gimple_has_mem_ops (g))\n+    return NULL_USE_OPERAND_P;\n+  ops = g->gsops.opbase.use_ops;\n+  if (ops\n+      && USE_OP_PTR (ops)->use == &g->gsmembase.vuse)\n+    return USE_OP_PTR (ops);\n+  return NULL_USE_OPERAND_P;\n+}\n+\n+/* Return the set of VDEF operand for statement G.  */\n+\n+static inline def_operand_p\n+gimple_vdef_op (gimple g)\n+{\n+  if (!gimple_has_mem_ops (g))\n+    return NULL_DEF_OPERAND_P;\n+  if (g->gsmembase.vdef)\n+    return &g->gsmembase.vdef;\n+  return NULL_DEF_OPERAND_P;\n+}\n+\n+/* Mark statement S as modified, and update it.  */\n+\n+static inline void\n+update_stmt (gimple s)\n+{\n+  if (gimple_has_ops (s))\n+    {\n+      gimple_set_modified (s, true);\n+      update_stmt_operands (s);\n+    }\n+}\n+\n+/* Update statement S if it has been optimized.  */\n+\n+static inline void\n+update_stmt_if_modified (gimple s)\n+{\n+  if (gimple_modified_p (s))\n+    update_stmt_operands (s);\n+}\n+\n+\n+#endif /* GCC_GIMPLE_SSA_H */"}, {"sha": "a75604fdad4eb1e9f9f89cb7130b4acb27f8cfda", "filename": "gcc/gimple.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -3923,7 +3923,7 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n     {\n       for (i = 0; i < gimple_phi_num_args (stmt); ++i)\n \t{\n-\t  tree op = PHI_ARG_DEF (stmt, i);\n+\t  tree op = gimple_phi_arg_def (stmt, i);\n \t  if (TREE_CODE (op) == ADDR_EXPR)\n \t    ret |= visit_addr (stmt, TREE_OPERAND (op, 0), data);\n \t}\n@@ -4356,5 +4356,28 @@ types_compatible_p (tree type1, tree type2)\n \t      && useless_type_conversion_p (type2, type1)));\n }\n \n+/* Dump bitmap SET (assumed to contain VAR_DECLs) to FILE.  */\n+\n+void\n+dump_decl_set (FILE *file, bitmap set)\n+{\n+  if (set)\n+    {\n+      bitmap_iterator bi;\n+      unsigned i;\n+\n+      fprintf (file, \"{ \");\n+\n+      EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+\t{\n+\t  fprintf (file, \"D.%u\", i);\n+\t  fprintf (file, \" \");\n+\t}\n+\n+      fprintf (file, \"}\");\n+    }\n+  else\n+    fprintf (file, \"NIL\");\n+}\n \n #include \"gt-gimple.h\""}, {"sha": "2d324e6623b43d8760074e94d9f6106e8588657d", "filename": "gcc/gimple.h", "status": "modified", "additions": 91, "deletions": 50, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -28,7 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"basic-block.h\"\n #include \"tree.h\"\n-#include \"tree-ssa-operands.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n \n@@ -1055,6 +1054,7 @@ extern void omp_firstprivatize_variable (struct gimplify_omp_ctx *, tree);\n extern tree gimple_boolify (tree);\n extern gimple_predicate rhs_predicate_for (tree);\n extern tree canonicalize_cond_expr_cond (tree);\n+extern void dump_decl_set (FILE *, bitmap);\n \n /* In omp-low.c.  */\n extern tree omp_reduction_init (tree, tree);\n@@ -1462,34 +1462,6 @@ gimple_set_use_ops (gimple g, struct use_optype_d *use)\n }\n \n \n-/* Return the set of VUSE operand for statement G.  */\n-\n-static inline use_operand_p\n-gimple_vuse_op (const_gimple g)\n-{\n-  struct use_optype_d *ops;\n-  if (!gimple_has_mem_ops (g))\n-    return NULL_USE_OPERAND_P;\n-  ops = g->gsops.opbase.use_ops;\n-  if (ops\n-      && USE_OP_PTR (ops)->use == &g->gsmembase.vuse)\n-    return USE_OP_PTR (ops);\n-  return NULL_USE_OPERAND_P;\n-}\n-\n-/* Return the set of VDEF operand for statement G.  */\n-\n-static inline def_operand_p\n-gimple_vdef_op (gimple g)\n-{\n-  if (!gimple_has_mem_ops (g))\n-    return NULL_DEF_OPERAND_P;\n-  if (g->gsmembase.vdef)\n-    return &g->gsmembase.vdef;\n-  return NULL_DEF_OPERAND_P;\n-}\n-\n-\n /* Return the single VUSE operand of the statement G.  */\n \n static inline tree\n@@ -1590,27 +1562,6 @@ gimple_expr_code (const_gimple stmt)\n }\n \n \n-/* Mark statement S as modified, and update it.  */\n-\n-static inline void\n-update_stmt (gimple s)\n-{\n-  if (gimple_has_ops (s))\n-    {\n-      gimple_set_modified (s, true);\n-      update_stmt_operands (s);\n-    }\n-}\n-\n-/* Update statement S if it has been optimized.  */\n-\n-static inline void\n-update_stmt_if_modified (gimple s)\n-{\n-  if (gimple_modified_p (s))\n-    update_stmt_operands (s);\n-}\n-\n /* Return true if statement STMT contains volatile operands.  */\n \n static inline bool\n@@ -3572,6 +3523,96 @@ gimple_phi_set_arg (gimple gs, unsigned index, struct phi_arg_d * phiarg)\n   gs->gimple_phi.args[index] = *phiarg;\n }\n \n+/* PHI nodes should contain only ssa_names and invariants.  A test\n+   for ssa_name is definitely simpler; don't let invalid contents\n+   slip in in the meantime.  */\n+\n+static inline bool\n+phi_ssa_name_p (const_tree t)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    return true;\n+  gcc_checking_assert (is_gimple_min_invariant (t));\n+  return false;\n+}\n+\n+/* Return the PHI nodes for basic block BB, or NULL if there are no\n+   PHI nodes.  */\n+\n+static inline gimple_seq\n+phi_nodes (const_basic_block bb)\n+{\n+  gcc_checking_assert (!(bb->flags & BB_RTL));\n+  return bb->il.gimple.phi_nodes;\n+}\n+\n+/* Return a pointer to the PHI nodes for basic block BB.  */\n+\n+static inline gimple_seq *\n+phi_nodes_ptr (basic_block bb)\n+{\n+  gcc_checking_assert (!(bb->flags & BB_RTL));\n+  return &bb->il.gimple.phi_nodes;\n+}\n+\n+/* Return the tree operand for argument I of PHI node GS.  */\n+\n+static inline tree\n+gimple_phi_arg_def (gimple gs, size_t index)\n+{\n+  return gimple_phi_arg (gs, index)->def;\n+}\n+\n+\n+/* Return a pointer to the tree operand for argument I of PHI node GS.  */\n+\n+static inline tree *\n+gimple_phi_arg_def_ptr (gimple gs, size_t index)\n+{\n+  return &gimple_phi_arg (gs, index)->def;\n+}\n+\n+/* Return the edge associated with argument I of phi node GS.  */\n+\n+static inline edge\n+gimple_phi_arg_edge (gimple gs, size_t i)\n+{\n+  return EDGE_PRED (gimple_bb (gs), i);\n+}\n+\n+/* Return the source location of gimple argument I of phi node GS.  */\n+\n+static inline source_location\n+gimple_phi_arg_location (gimple gs, size_t i)\n+{\n+  return gimple_phi_arg (gs, i)->locus;\n+}\n+\n+/* Return the source location of the argument on edge E of phi node GS.  */\n+\n+static inline source_location\n+gimple_phi_arg_location_from_edge (gimple gs, edge e)\n+{\n+  return gimple_phi_arg (gs, e->dest_idx)->locus;\n+}\n+\n+/* Set the source location of gimple argument I of phi node GS to LOC.  */\n+\n+static inline void\n+gimple_phi_arg_set_location (gimple gs, size_t i, source_location loc)\n+{\n+  gimple_phi_arg (gs, i)->locus = loc;\n+}\n+\n+/* Return TRUE if argument I of phi node GS has a location record.  */\n+\n+static inline bool\n+gimple_phi_arg_has_location (gimple gs, size_t i)\n+{\n+  return gimple_phi_arg_location (gs, i) != UNKNOWN_LOCATION;\n+}\n+\n+\n /* Return the region number for GIMPLE_RESX GS.  */\n \n static inline int"}, {"sha": "af486b6118dd527188168c55abc102c7d3f46b16", "filename": "gcc/ssa-iterators.h", "status": "added", "additions": 996, "deletions": 0, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -0,0 +1,996 @@\n+/* Header file for SSA iterators.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SSA_ITERATORS_H\n+#define GCC_SSA_ITERATORS_H\n+\n+/* Immediate use lists are used to directly access all uses for an SSA\n+   name and get pointers to the statement for each use.\n+\n+   The structure ssa_use_operand_d consists of PREV and NEXT pointers\n+   to maintain the list.  A USE pointer, which points to address where\n+   the use is located and a LOC pointer which can point to the\n+   statement where the use is located, or, in the case of the root\n+   node, it points to the SSA name itself.\n+\n+   The list is anchored by an occurrence of ssa_operand_d *in* the\n+   ssa_name node itself (named 'imm_uses').  This node is uniquely\n+   identified by having a NULL USE pointer. and the LOC pointer\n+   pointing back to the ssa_name node itself.  This node forms the\n+   base for a circular list, and initially this is the only node in\n+   the list.\n+\n+   Fast iteration allows each use to be examined, but does not allow\n+   any modifications to the uses or stmts.\n+\n+   Normal iteration allows insertion, deletion, and modification. the\n+   iterator manages this by inserting a marker node into the list\n+   immediately before the node currently being examined in the list.\n+   this marker node is uniquely identified by having null stmt *and* a\n+   null use pointer.\n+\n+   When iterating to the next use, the iteration routines check to see\n+   if the node after the marker has changed. if it has, then the node\n+   following the marker is now the next one to be visited. if not, the\n+   marker node is moved past that node in the list (visualize it as\n+   bumping the marker node through the list).  this continues until\n+   the marker node is moved to the original anchor position. the\n+   marker node is then removed from the list.\n+\n+   If iteration is halted early, the marker node must be removed from\n+   the list before continuing.  */\n+typedef struct immediate_use_iterator_d\n+{\n+  /* This is the current use the iterator is processing.  */\n+  ssa_use_operand_t *imm_use;\n+  /* This marks the last use in the list (use node from SSA_NAME)  */\n+  ssa_use_operand_t *end_p;\n+  /* This node is inserted and used to mark the end of the uses for a stmt.  */\n+  ssa_use_operand_t iter_node;\n+  /* This is the next ssa_name to visit.  IMM_USE may get removed before\n+     the next one is traversed to, so it must be cached early.  */\n+  ssa_use_operand_t *next_imm_name;\n+} imm_use_iterator;\n+\n+\n+/* Use this iterator when simply looking at stmts.  Adding, deleting or\n+   modifying stmts will cause this iterator to malfunction.  */\n+\n+#define FOR_EACH_IMM_USE_FAST(DEST, ITER, SSAVAR)\t\t\\\n+  for ((DEST) = first_readonly_imm_use (&(ITER), (SSAVAR));\t\\\n+       !end_readonly_imm_use_p (&(ITER));\t\t\t\\\n+       (void) ((DEST) = next_readonly_imm_use (&(ITER))))\n+\n+/* Use this iterator to visit each stmt which has a use of SSAVAR.  */\n+\n+#define FOR_EACH_IMM_USE_STMT(STMT, ITER, SSAVAR)\t\t\\\n+  for ((STMT) = first_imm_use_stmt (&(ITER), (SSAVAR));\t\t\\\n+       !end_imm_use_stmt_p (&(ITER));\t\t\t\t\\\n+       (void) ((STMT) = next_imm_use_stmt (&(ITER))))\n+\n+/* Use this to terminate the FOR_EACH_IMM_USE_STMT loop early.  Failure to\n+   do so will result in leaving a iterator marker node in the immediate\n+   use list, and nothing good will come from that.   */\n+#define BREAK_FROM_IMM_USE_STMT(ITER)\t\t\t\t\\\n+   {\t\t\t\t\t\t\t\t\\\n+     end_imm_use_stmt_traverse (&(ITER));\t\t\t\\\n+     break;\t\t\t\t\t\t\t\\\n+   }\n+\n+\n+/* Use this iterator in combination with FOR_EACH_IMM_USE_STMT to\n+   get access to each occurrence of ssavar on the stmt returned by\n+   that iterator..  for instance:\n+\n+     FOR_EACH_IMM_USE_STMT (stmt, iter, var)\n+       {\n+         FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t   {\n+\t     SET_USE (use_p, blah);\n+\t   }\n+\t update_stmt (stmt);\n+       }\t\t\t\t\t\t\t */\n+\n+#define FOR_EACH_IMM_USE_ON_STMT(DEST, ITER)\t\t\t\\\n+  for ((DEST) = first_imm_use_on_stmt (&(ITER));\t\t\\\n+       !end_imm_use_on_stmt_p (&(ITER));\t\t\t\\\n+       (void) ((DEST) = next_imm_use_on_stmt (&(ITER))))\n+\n+\n+\n+extern bool has_zero_uses_1 (const ssa_use_operand_t *head);\n+extern bool single_imm_use_1 (const ssa_use_operand_t *head,\n+\t\t\t      use_operand_p *use_p, gimple *stmt);\n+\n+\n+enum ssa_op_iter_type {\n+  ssa_op_iter_none = 0,\n+  ssa_op_iter_tree,\n+  ssa_op_iter_use,\n+  ssa_op_iter_def\n+};\n+\n+/* This structure is used in the operand iterator loops.  It contains the\n+   items required to determine which operand is retrieved next.  During\n+   optimization, this structure is scalarized, and any unused fields are\n+   optimized away, resulting in little overhead.  */\n+\n+typedef struct ssa_operand_iterator_d\n+{\n+  enum ssa_op_iter_type iter_type;\n+  bool done;\n+  int flags;\n+  unsigned i;\n+  unsigned numops;\n+  use_optype_p uses;\n+  gimple stmt;\n+} ssa_op_iter;\n+\n+/* These flags are used to determine which operands are returned during\n+   execution of the loop.  */\n+#define SSA_OP_USE\t\t0x01\t/* Real USE operands.  */\n+#define SSA_OP_DEF\t\t0x02\t/* Real DEF operands.  */\n+#define SSA_OP_VUSE\t\t0x04\t/* VUSE operands.  */\n+#define SSA_OP_VDEF\t\t0x08\t/* VDEF operands.  */\n+\n+/* These are commonly grouped operand flags.  */\n+#define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE)\n+#define SSA_OP_VIRTUAL_DEFS\t(SSA_OP_VDEF)\n+#define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_DEFS)\n+#define SSA_OP_ALL_USES\t\t(SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n+#define SSA_OP_ALL_DEFS\t\t(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n+#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG,\n+   returning each operand as a 'tree' in the variable TREEVAR.  ITER is an\n+   ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_TREE_OPERAND(TREEVAR, STMT, ITER, FLAGS)\t\\\n+  for (TREEVAR = op_iter_init_tree (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (void) (TREEVAR = op_iter_next_tree (&(ITER))))\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG,\n+   returning each operand as a 'use_operand_p' in the variable USEVAR.\n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_USE_OPERAND(USEVAR, STMT, ITER, FLAGS)\t\\\n+  for (USEVAR = op_iter_init_use (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       USEVAR = op_iter_next_use (&(ITER)))\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG,\n+   returning each operand as a 'def_operand_p' in the variable DEFVAR.\n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_DEF_OPERAND(DEFVAR, STMT, ITER, FLAGS)\t\\\n+  for (DEFVAR = op_iter_init_def (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       DEFVAR = op_iter_next_def (&(ITER)))\n+\n+/* This macro will execute a loop over all the arguments of a PHI which\n+   match FLAGS.   A use_operand_p is always returned via USEVAR.  FLAGS\n+   can be either SSA_OP_USE or SSA_OP_VIRTUAL_USES or SSA_OP_ALL_USES.  */\n+#define FOR_EACH_PHI_ARG(USEVAR, STMT, ITER, FLAGS)\t\t\\\n+  for ((USEVAR) = op_iter_init_phiuse (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (USEVAR) = op_iter_next_use (&(ITER)))\n+\n+\n+/* This macro will execute a loop over a stmt, regardless of whether it is\n+   a real stmt or a PHI node, looking at the USE nodes matching FLAGS.  */\n+#define FOR_EACH_PHI_OR_STMT_USE(USEVAR, STMT, ITER, FLAGS)\t\\\n+  for ((USEVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n+\t\t   ? op_iter_init_phiuse (&(ITER), STMT, FLAGS)\t\\\n+\t\t   : op_iter_init_use (&(ITER), STMT, FLAGS));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (USEVAR) = op_iter_next_use (&(ITER)))\n+\n+/* This macro will execute a loop over a stmt, regardless of whether it is\n+   a real stmt or a PHI node, looking at the DEF nodes matching FLAGS.  */\n+#define FOR_EACH_PHI_OR_STMT_DEF(DEFVAR, STMT, ITER, FLAGS)\t\\\n+  for ((DEFVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n+\t\t   ? op_iter_init_phidef (&(ITER), STMT, FLAGS)\t\\\n+\t\t   : op_iter_init_def (&(ITER), STMT, FLAGS));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       (DEFVAR) = op_iter_next_def (&(ITER)))\n+\n+/* This macro returns an operand in STMT as a tree if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_TREE is returned.  */\n+#define SINGLE_SSA_TREE_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_tree_operand (STMT, FLAGS)\n+\n+/* This macro returns an operand in STMT as a use_operand_p if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_USE_OPERAND_P is returned.  */\n+#define SINGLE_SSA_USE_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_use_operand (STMT, FLAGS)\n+\n+/* This macro returns an operand in STMT as a def_operand_p if it is the ONLY\n+   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n+   FLAGS, then NULL_DEF_OPERAND_P is returned.  */\n+#define SINGLE_SSA_DEF_OPERAND(STMT, FLAGS)\t\t\t\\\n+  single_ssa_def_operand (STMT, FLAGS)\n+\n+/* This macro returns TRUE if there are no operands matching FLAGS in STMT.  */\n+#define ZERO_SSA_OPERANDS(STMT, FLAGS) \tzero_ssa_operands (STMT, FLAGS)\n+\n+/* This macro counts the number of operands in STMT matching FLAGS.  */\n+#define NUM_SSA_OPERANDS(STMT, FLAGS)\tnum_ssa_operands (STMT, FLAGS)\n+\n+\n+/* Delink an immediate_uses node from its chain.  */\n+static inline void\n+delink_imm_use (ssa_use_operand_t *linknode)\n+{\n+  /* Return if this node is not in a list.  */\n+  if (linknode->prev == NULL)\n+    return;\n+\n+  linknode->prev->next = linknode->next;\n+  linknode->next->prev = linknode->prev;\n+  linknode->prev = NULL;\n+  linknode->next = NULL;\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for LIST.  */\n+static inline void\n+link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list)\n+{\n+  /* Link the new node at the head of the list.  If we are in the process of\n+     traversing the list, we won't visit any new nodes added to it.  */\n+  linknode->prev = list;\n+  linknode->next = list->next;\n+  list->next->prev = linknode;\n+  list->next = linknode;\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for DEF.  */\n+static inline void\n+link_imm_use (ssa_use_operand_t *linknode, tree def)\n+{\n+  ssa_use_operand_t *root;\n+\n+  if (!def || TREE_CODE (def) != SSA_NAME)\n+    linknode->prev = NULL;\n+  else\n+    {\n+      root = &(SSA_NAME_IMM_USE_NODE (def));\n+      if (linknode->use)\n+        gcc_checking_assert (*(linknode->use) == def);\n+      link_imm_use_to_list (linknode, root);\n+    }\n+}\n+\n+/* Set the value of a use pointed to by USE to VAL.  */\n+static inline void\n+set_ssa_use_from_ptr (use_operand_p use, tree val)\n+{\n+  delink_imm_use (use);\n+  *(use->use) = val;\n+  link_imm_use (use, val);\n+}\n+\n+/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring\n+   in STMT.  */\n+static inline void\n+link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple stmt)\n+{\n+  if (stmt)\n+    link_imm_use (linknode, def);\n+  else\n+    link_imm_use (linknode, NULL);\n+  linknode->loc.stmt = stmt;\n+}\n+\n+/* Relink a new node in place of an old node in the list.  */\n+static inline void\n+relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n+{\n+  /* The node one had better be in the same list.  */\n+  gcc_checking_assert (*(old->use) == *(node->use));\n+  node->prev = old->prev;\n+  node->next = old->next;\n+  if (old->prev)\n+    {\n+      old->prev->next = node;\n+      old->next->prev = node;\n+      /* Remove the old node from the list.  */\n+      old->prev = NULL;\n+    }\n+}\n+\n+/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occurring\n+   in STMT.  */\n+static inline void\n+relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old,\n+\t\t     gimple stmt)\n+{\n+  if (stmt)\n+    relink_imm_use (linknode, old);\n+  else\n+    link_imm_use (linknode, NULL);\n+  linknode->loc.stmt = stmt;\n+}\n+\n+\n+/* Return true is IMM has reached the end of the immediate use list.  */\n+static inline bool\n+end_readonly_imm_use_p (const imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == imm->end_p);\n+}\n+\n+/* Initialize iterator IMM to process the list for VAR.  */\n+static inline use_operand_p\n+first_readonly_imm_use (imm_use_iterator *imm, tree var)\n+{\n+  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n+  imm->imm_use = imm->end_p->next;\n+#ifdef ENABLE_CHECKING\n+  imm->iter_node.next = imm->imm_use->next;\n+#endif\n+  if (end_readonly_imm_use_p (imm))\n+    return NULL_USE_OPERAND_P;\n+  return imm->imm_use;\n+}\n+\n+/* Bump IMM to the next use in the list.  */\n+static inline use_operand_p\n+next_readonly_imm_use (imm_use_iterator *imm)\n+{\n+  use_operand_p old = imm->imm_use;\n+\n+#ifdef ENABLE_CHECKING\n+  /* If this assertion fails, it indicates the 'next' pointer has changed\n+     since the last bump.  This indicates that the list is being modified\n+     via stmt changes, or SET_USE, or somesuch thing, and you need to be\n+     using the SAFE version of the iterator.  */\n+  gcc_assert (imm->iter_node.next == old->next);\n+  imm->iter_node.next = old->next->next;\n+#endif\n+\n+  imm->imm_use = old->next;\n+  if (end_readonly_imm_use_p (imm))\n+    return NULL_USE_OPERAND_P;\n+  return imm->imm_use;\n+}\n+\n+\n+/* Return true if VAR has no nondebug uses.  */\n+static inline bool\n+has_zero_uses (const_tree var)\n+{\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+\n+  /* A single use_operand means there is no items in the list.  */\n+  if (ptr == ptr->next)\n+    return true;\n+\n+  /* If there are debug stmts, we have to look at each use and see\n+     whether there are any nondebug uses.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return false;\n+\n+  return has_zero_uses_1 (ptr);\n+}\n+\n+/* Return true if VAR has a single nondebug use.  */\n+static inline bool\n+has_single_use (const_tree var)\n+{\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+\n+  /* If there aren't any uses whatsoever, we're done.  */\n+  if (ptr == ptr->next)\n+    return false;\n+\n+  /* If there's a single use, check that it's not a debug stmt.  */\n+  if (ptr == ptr->next->next)\n+    return !is_gimple_debug (USE_STMT (ptr->next));\n+\n+  /* If there are debug stmts, we have to look at each of them.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return false;\n+\n+  return single_imm_use_1 (ptr, NULL, NULL);\n+}\n+\n+\n+/* If VAR has only a single immediate nondebug use, return true, and\n+   set USE_P and STMT to the use pointer and stmt of occurrence.  */\n+static inline bool\n+single_imm_use (const_tree var, use_operand_p *use_p, gimple *stmt)\n+{\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+\n+  /* If there aren't any uses whatsoever, we're done.  */\n+  if (ptr == ptr->next)\n+    {\n+    return_false:\n+      *use_p = NULL_USE_OPERAND_P;\n+      *stmt = NULL;\n+      return false;\n+    }\n+\n+  /* If there's a single use, check that it's not a debug stmt.  */\n+  if (ptr == ptr->next->next)\n+    {\n+      if (!is_gimple_debug (USE_STMT (ptr->next)))\n+\t{\n+\t  *use_p = ptr->next;\n+\t  *stmt = ptr->next->loc.stmt;\n+\t  return true;\n+\t}\n+      else\n+\tgoto return_false;\n+    }\n+\n+  /* If there are debug stmts, we have to look at each of them.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    goto return_false;\n+\n+  return single_imm_use_1 (ptr, use_p, stmt);\n+}\n+\n+/* Return the number of nondebug immediate uses of VAR.  */\n+static inline unsigned int\n+num_imm_uses (const_tree var)\n+{\n+  const ssa_use_operand_t *const start = &(SSA_NAME_IMM_USE_NODE (var));\n+  const ssa_use_operand_t *ptr;\n+  unsigned int num = 0;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    for (ptr = start->next; ptr != start; ptr = ptr->next)\n+      num++;\n+  else\n+    for (ptr = start->next; ptr != start; ptr = ptr->next)\n+      if (!is_gimple_debug (USE_STMT (ptr)))\n+\tnum++;\n+\n+  return num;\n+}\n+\n+/*  -----------------------------------------------------------------------  */\n+\n+/* The following set of routines are used to iterator over various type of\n+   SSA operands.  */\n+\n+/* Return true if PTR is finished iterating.  */\n+static inline bool\n+op_iter_done (const ssa_op_iter *ptr)\n+{\n+  return ptr->done;\n+}\n+\n+/* Get the next iterator use value for PTR.  */\n+static inline use_operand_p\n+op_iter_next_use (ssa_op_iter *ptr)\n+{\n+  use_operand_p use_p;\n+  gcc_checking_assert (ptr->iter_type == ssa_op_iter_use);\n+  if (ptr->uses)\n+    {\n+      use_p = USE_OP_PTR (ptr->uses);\n+      ptr->uses = ptr->uses->next;\n+      return use_p;\n+    }\n+  if (ptr->i < ptr->numops)\n+    {\n+      return PHI_ARG_DEF_PTR (ptr->stmt, (ptr->i)++);\n+    }\n+  ptr->done = true;\n+  return NULL_USE_OPERAND_P;\n+}\n+\n+/* Get the next iterator def value for PTR.  */\n+static inline def_operand_p\n+op_iter_next_def (ssa_op_iter *ptr)\n+{\n+  gcc_checking_assert (ptr->iter_type == ssa_op_iter_def);\n+  if (ptr->flags & SSA_OP_VDEF)\n+    {\n+      tree *p;\n+      ptr->flags &= ~SSA_OP_VDEF;\n+      p = gimple_vdef_ptr (ptr->stmt);\n+      if (p && *p)\n+\treturn p;\n+    }\n+  if (ptr->flags & SSA_OP_DEF)\n+    {\n+      while (ptr->i < ptr->numops)\n+\t{\n+\t  tree *val = gimple_op_ptr (ptr->stmt, ptr->i);\n+\t  ptr->i++;\n+\t  if (*val)\n+\t    {\n+\t      if (TREE_CODE (*val) == TREE_LIST)\n+\t\tval = &TREE_VALUE (*val);\n+\t      if (TREE_CODE (*val) == SSA_NAME\n+\t\t  || is_gimple_reg (*val))\n+\t\treturn val;\n+\t    }\n+\t}\n+      ptr->flags &= ~SSA_OP_DEF;\n+    }\n+\n+  ptr->done = true;\n+  return NULL_DEF_OPERAND_P;\n+}\n+\n+/* Get the next iterator tree value for PTR.  */\n+static inline tree\n+op_iter_next_tree (ssa_op_iter *ptr)\n+{\n+  tree val;\n+  gcc_checking_assert (ptr->iter_type == ssa_op_iter_tree);\n+  if (ptr->uses)\n+    {\n+      val = USE_OP (ptr->uses);\n+      ptr->uses = ptr->uses->next;\n+      return val;\n+    }\n+  if (ptr->flags & SSA_OP_VDEF)\n+    {\n+      ptr->flags &= ~SSA_OP_VDEF;\n+      if ((val = gimple_vdef (ptr->stmt)))\n+\treturn val;\n+    }\n+  if (ptr->flags & SSA_OP_DEF)\n+    {\n+      while (ptr->i < ptr->numops)\n+\t{\n+\t  val = gimple_op (ptr->stmt, ptr->i);\n+\t  ptr->i++;\n+\t  if (val)\n+\t    {\n+\t      if (TREE_CODE (val) == TREE_LIST)\n+\t\tval = TREE_VALUE (val);\n+\t      if (TREE_CODE (val) == SSA_NAME\n+\t\t  || is_gimple_reg (val))\n+\t\treturn val;\n+\t    }\n+\t}\n+      ptr->flags &= ~SSA_OP_DEF;\n+    }\n+\n+  ptr->done = true;\n+  return NULL_TREE;\n+}\n+\n+\n+/* This functions clears the iterator PTR, and marks it done.  This is normally\n+   used to prevent warnings in the compile about might be uninitialized\n+   components.  */\n+\n+static inline void\n+clear_and_done_ssa_iter (ssa_op_iter *ptr)\n+{\n+  ptr->i = 0;\n+  ptr->numops = 0;\n+  ptr->uses = NULL;\n+  ptr->iter_type = ssa_op_iter_none;\n+  ptr->stmt = NULL;\n+  ptr->done = true;\n+  ptr->flags = 0;\n+}\n+\n+/* Initialize the iterator PTR to the virtual defs in STMT.  */\n+static inline void\n+op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n+{\n+  /* PHI nodes require a different iterator initialization path.  We\n+     do not support iterating over virtual defs or uses without\n+     iterating over defs or uses at the same time.  */\n+  gcc_checking_assert (gimple_code (stmt) != GIMPLE_PHI\n+\t\t       && (!(flags & SSA_OP_VDEF) || (flags & SSA_OP_DEF))\n+\t\t       && (!(flags & SSA_OP_VUSE) || (flags & SSA_OP_USE)));\n+  ptr->numops = 0;\n+  if (flags & (SSA_OP_DEF | SSA_OP_VDEF))\n+    {\n+      switch (gimple_code (stmt))\n+\t{\n+\t  case GIMPLE_ASSIGN:\n+\t  case GIMPLE_CALL:\n+\t    ptr->numops = 1;\n+\t    break;\n+\t  case GIMPLE_ASM:\n+\t    ptr->numops = gimple_asm_noutputs (stmt);\n+\t    break;\n+\t  default:\n+\t    ptr->numops = 0;\n+\t    flags &= ~(SSA_OP_DEF | SSA_OP_VDEF);\n+\t    break;\n+\t}\n+    }\n+  ptr->uses = (flags & (SSA_OP_USE|SSA_OP_VUSE)) ? gimple_use_ops (stmt) : NULL;\n+  if (!(flags & SSA_OP_VUSE)\n+      && ptr->uses\n+      && gimple_vuse (stmt) != NULL_TREE)\n+    ptr->uses = ptr->uses->next;\n+  ptr->done = false;\n+  ptr->i = 0;\n+\n+  ptr->stmt = stmt;\n+  ptr->flags = flags;\n+}\n+\n+/* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n+   the first use.  */\n+static inline use_operand_p\n+op_iter_init_use (ssa_op_iter *ptr, gimple stmt, int flags)\n+{\n+  gcc_checking_assert ((flags & SSA_OP_ALL_DEFS) == 0\n+\t\t       && (flags & SSA_OP_USE));\n+  op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_use;\n+  return op_iter_next_use (ptr);\n+}\n+\n+/* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return\n+   the first def.  */\n+static inline def_operand_p\n+op_iter_init_def (ssa_op_iter *ptr, gimple stmt, int flags)\n+{\n+  gcc_checking_assert ((flags & SSA_OP_ALL_USES) == 0\n+\t\t       && (flags & SSA_OP_DEF));\n+  op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_def;\n+  return op_iter_next_def (ptr);\n+}\n+\n+/* Initialize iterator PTR to the operands in STMT based on FLAGS. Return\n+   the first operand as a tree.  */\n+static inline tree\n+op_iter_init_tree (ssa_op_iter *ptr, gimple stmt, int flags)\n+{\n+  op_iter_init (ptr, stmt, flags);\n+  ptr->iter_type = ssa_op_iter_tree;\n+  return op_iter_next_tree (ptr);\n+}\n+\n+\n+/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  */\n+static inline tree\n+single_ssa_tree_operand (gimple stmt, int flags)\n+{\n+  tree var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_tree (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_TREE;\n+  op_iter_next_tree (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_TREE;\n+}\n+\n+\n+/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  */\n+static inline use_operand_p\n+single_ssa_use_operand (gimple stmt, int flags)\n+{\n+  use_operand_p var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_use (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_USE_OPERAND_P;\n+  op_iter_next_use (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_USE_OPERAND_P;\n+}\n+\n+\n+\n+/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n+   return NULL.  */\n+static inline def_operand_p\n+single_ssa_def_operand (gimple stmt, int flags)\n+{\n+  def_operand_p var;\n+  ssa_op_iter iter;\n+\n+  var = op_iter_init_def (&iter, stmt, flags);\n+  if (op_iter_done (&iter))\n+    return NULL_DEF_OPERAND_P;\n+  op_iter_next_def (&iter);\n+  if (op_iter_done (&iter))\n+    return var;\n+  return NULL_DEF_OPERAND_P;\n+}\n+\n+\n+/* Return true if there are zero operands in STMT matching the type\n+   given in FLAGS.  */\n+static inline bool\n+zero_ssa_operands (gimple stmt, int flags)\n+{\n+  ssa_op_iter iter;\n+\n+  op_iter_init_tree (&iter, stmt, flags);\n+  return op_iter_done (&iter);\n+}\n+\n+\n+/* Return the number of operands matching FLAGS in STMT.  */\n+static inline int\n+num_ssa_operands (gimple stmt, int flags)\n+{\n+  ssa_op_iter iter;\n+  tree t;\n+  int num = 0;\n+\n+  gcc_checking_assert (gimple_code (stmt) != GIMPLE_PHI);\n+  FOR_EACH_SSA_TREE_OPERAND (t, stmt, iter, flags)\n+    num++;\n+  return num;\n+}\n+\n+/* If there is a single DEF in the PHI node which matches FLAG, return it.\n+   Otherwise return NULL_DEF_OPERAND_P.  */\n+static inline tree\n+single_phi_def (gimple stmt, int flags)\n+{\n+  tree def = PHI_RESULT (stmt);\n+  if ((flags & SSA_OP_DEF) && is_gimple_reg (def))\n+    return def;\n+  if ((flags & SSA_OP_VIRTUAL_DEFS) && !is_gimple_reg (def))\n+    return def;\n+  return NULL_TREE;\n+}\n+\n+/* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should\n+   be either SSA_OP_USES or SSA_OP_VIRTUAL_USES.  */\n+static inline use_operand_p\n+op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags)\n+{\n+  tree phi_def = gimple_phi_result (phi);\n+  int comp;\n+\n+  clear_and_done_ssa_iter (ptr);\n+  ptr->done = false;\n+\n+  gcc_checking_assert ((flags & (SSA_OP_USE | SSA_OP_VIRTUAL_USES)) != 0);\n+\n+  comp = (is_gimple_reg (phi_def) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n+\n+  /* If the PHI node doesn't the operand type we care about, we're done.  */\n+  if ((flags & comp) == 0)\n+    {\n+      ptr->done = true;\n+      return NULL_USE_OPERAND_P;\n+    }\n+\n+  ptr->stmt = phi;\n+  ptr->numops = gimple_phi_num_args (phi);\n+  ptr->iter_type = ssa_op_iter_use;\n+  ptr->flags = flags;\n+  return op_iter_next_use (ptr);\n+}\n+\n+\n+/* Start an iterator for a PHI definition.  */\n+\n+static inline def_operand_p\n+op_iter_init_phidef (ssa_op_iter *ptr, gimple phi, int flags)\n+{\n+  tree phi_def = PHI_RESULT (phi);\n+  int comp;\n+\n+  clear_and_done_ssa_iter (ptr);\n+  ptr->done = false;\n+\n+  gcc_checking_assert ((flags & (SSA_OP_DEF | SSA_OP_VIRTUAL_DEFS)) != 0);\n+\n+  comp = (is_gimple_reg (phi_def) ? SSA_OP_DEF : SSA_OP_VIRTUAL_DEFS);\n+\n+  /* If the PHI node doesn't have the operand type we care about,\n+     we're done.  */\n+  if ((flags & comp) == 0)\n+    {\n+      ptr->done = true;\n+      return NULL_DEF_OPERAND_P;\n+    }\n+\n+  ptr->iter_type = ssa_op_iter_def;\n+  /* The first call to op_iter_next_def will terminate the iterator since\n+     all the fields are NULL.  Simply return the result here as the first and\n+     therefore only result.  */\n+  return PHI_RESULT_PTR (phi);\n+}\n+\n+/* Return true is IMM has reached the end of the immediate use stmt list.  */\n+\n+static inline bool\n+end_imm_use_stmt_p (const imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == imm->end_p);\n+}\n+\n+/* Finished the traverse of an immediate use stmt list IMM by removing the\n+   placeholder node from the list.  */\n+\n+static inline void\n+end_imm_use_stmt_traverse (imm_use_iterator *imm)\n+{\n+  delink_imm_use (&(imm->iter_node));\n+}\n+\n+/* Immediate use traversal of uses within a stmt require that all the\n+   uses on a stmt be sequentially listed.  This routine is used to build up\n+   this sequential list by adding USE_P to the end of the current list\n+   currently delimited by HEAD and LAST_P.  The new LAST_P value is\n+   returned.  */\n+\n+static inline use_operand_p\n+move_use_after_head (use_operand_p use_p, use_operand_p head,\n+\t\t      use_operand_p last_p)\n+{\n+  gcc_checking_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n+  /* Skip head when we find it.  */\n+  if (use_p != head)\n+    {\n+      /* If use_p is already linked in after last_p, continue.  */\n+      if (last_p->next == use_p)\n+\tlast_p = use_p;\n+      else\n+\t{\n+\t  /* Delink from current location, and link in at last_p.  */\n+\t  delink_imm_use (use_p);\n+\t  link_imm_use_to_list (use_p, last_p);\n+\t  last_p = use_p;\n+\t}\n+    }\n+  return last_p;\n+}\n+\n+\n+/* This routine will relink all uses with the same stmt as HEAD into the list\n+   immediately following HEAD for iterator IMM.  */\n+\n+static inline void\n+link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n+{\n+  use_operand_p use_p;\n+  use_operand_p last_p = head;\n+  gimple head_stmt = USE_STMT (head);\n+  tree use = USE_FROM_PTR (head);\n+  ssa_op_iter op_iter;\n+  int flag;\n+\n+  /* Only look at virtual or real uses, depending on the type of HEAD.  */\n+  flag = (is_gimple_reg (use) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n+\n+  if (gimple_code (head_stmt) == GIMPLE_PHI)\n+    {\n+      FOR_EACH_PHI_ARG (use_p, head_stmt, op_iter, flag)\n+\tif (USE_FROM_PTR (use_p) == use)\n+\t  last_p = move_use_after_head (use_p, head, last_p);\n+    }\n+  else\n+    {\n+      if (flag == SSA_OP_USE)\n+\t{\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, head_stmt, op_iter, flag)\n+\t    if (USE_FROM_PTR (use_p) == use)\n+\t      last_p = move_use_after_head (use_p, head, last_p);\n+\t}\n+      else if ((use_p = gimple_vuse_op (head_stmt)) != NULL_USE_OPERAND_P)\n+\t{\n+\t  if (USE_FROM_PTR (use_p) == use)\n+\t    last_p = move_use_after_head (use_p, head, last_p);\n+\t}\n+    }\n+  /* Link iter node in after last_p.  */\n+  if (imm->iter_node.prev != NULL)\n+    delink_imm_use (&imm->iter_node);\n+  link_imm_use_to_list (&(imm->iter_node), last_p);\n+}\n+\n+/* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */\n+static inline gimple\n+first_imm_use_stmt (imm_use_iterator *imm, tree var)\n+{\n+  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n+  imm->imm_use = imm->end_p->next;\n+  imm->next_imm_name = NULL_USE_OPERAND_P;\n+\n+  /* iter_node is used as a marker within the immediate use list to indicate\n+     where the end of the current stmt's uses are.  Initialize it to NULL\n+     stmt and use, which indicates a marker node.  */\n+  imm->iter_node.prev = NULL_USE_OPERAND_P;\n+  imm->iter_node.next = NULL_USE_OPERAND_P;\n+  imm->iter_node.loc.stmt = NULL;\n+  imm->iter_node.use = NULL;\n+\n+  if (end_imm_use_stmt_p (imm))\n+    return NULL;\n+\n+  link_use_stmts_after (imm->imm_use, imm);\n+\n+  return USE_STMT (imm->imm_use);\n+}\n+\n+/* Bump IMM to the next stmt which has a use of var.  */\n+\n+static inline gimple\n+next_imm_use_stmt (imm_use_iterator *imm)\n+{\n+  imm->imm_use = imm->iter_node.next;\n+  if (end_imm_use_stmt_p (imm))\n+    {\n+      if (imm->iter_node.prev != NULL)\n+\tdelink_imm_use (&imm->iter_node);\n+      return NULL;\n+    }\n+\n+  link_use_stmts_after (imm->imm_use, imm);\n+  return USE_STMT (imm->imm_use);\n+}\n+\n+/* This routine will return the first use on the stmt IMM currently refers\n+   to.  */\n+\n+static inline use_operand_p\n+first_imm_use_on_stmt (imm_use_iterator *imm)\n+{\n+  imm->next_imm_name = imm->imm_use->next;\n+  return imm->imm_use;\n+}\n+\n+/*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */\n+\n+static inline bool\n+end_imm_use_on_stmt_p (const imm_use_iterator *imm)\n+{\n+  return (imm->imm_use == &(imm->iter_node));\n+}\n+\n+/* Bump to the next use on the stmt IMM refers to, return NULL if done.  */\n+\n+static inline use_operand_p\n+next_imm_use_on_stmt (imm_use_iterator *imm)\n+{\n+  imm->imm_use = imm->next_imm_name;\n+  if (end_imm_use_on_stmt_p (imm))\n+    return NULL_USE_OPERAND_P;\n+  else\n+    {\n+      imm->next_imm_name = imm->imm_use->next;\n+      return imm->imm_use;\n+    }\n+}\n+\n+/* Delink all immediate_use information for STMT.  */\n+static inline void\n+delink_stmt_imm_use (gimple stmt)\n+{\n+   ssa_op_iter iter;\n+   use_operand_p use_p;\n+\n+   if (ssa_operands_active (cfun))\n+     FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_ALL_USES)\n+       delink_imm_use (use_p);\n+}\n+\n+#endif /* GCC_TREE_SSA_ITERATORS_H */"}, {"sha": "ed20d5772180209ec29a5fd603fd6f3c8f91e547", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -1516,49 +1516,6 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   return true;\n }\n \n-/* Return true if the var whose chain of uses starts at PTR has no\n-   nondebug uses.  */\n-bool\n-has_zero_uses_1 (const ssa_use_operand_t *head)\n-{\n-  const ssa_use_operand_t *ptr;\n-\n-  for (ptr = head->next; ptr != head; ptr = ptr->next)\n-    if (!is_gimple_debug (USE_STMT (ptr)))\n-      return false;\n-\n-  return true;\n-}\n-\n-/* Return true if the var whose chain of uses starts at PTR has a\n-   single nondebug use.  Set USE_P and STMT to that single nondebug\n-   use, if so, or to NULL otherwise.  */\n-bool\n-single_imm_use_1 (const ssa_use_operand_t *head,\n-\t\t  use_operand_p *use_p, gimple *stmt)\n-{\n-  ssa_use_operand_t *ptr, *single_use = 0;\n-\n-  for (ptr = head->next; ptr != head; ptr = ptr->next)\n-    if (!is_gimple_debug (USE_STMT (ptr)))\n-      {\n-\tif (single_use)\n-\t  {\n-\t    single_use = NULL;\n-\t    break;\n-\t  }\n-\tsingle_use = ptr;\n-      }\n-\n-  if (use_p)\n-    *use_p = single_use;\n-\n-  if (stmt)\n-    *stmt = single_use ? single_use->loc.stmt : NULL;\n-\n-  return !!single_use;\n-}\n-\n /* Replaces all uses of NAME by VAL.  */\n \n void"}, {"sha": "b3a6d4b45c1f15fcd0bd7bcc8075595dfe302c72", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 918, "changes": 918, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -126,380 +126,6 @@ get_lineno (const_gimple stmt)\n   return LOCATION_LINE (loc);\n }\n \n-/* Delink an immediate_uses node from its chain.  */\n-static inline void\n-delink_imm_use (ssa_use_operand_t *linknode)\n-{\n-  /* Return if this node is not in a list.  */\n-  if (linknode->prev == NULL)\n-    return;\n-\n-  linknode->prev->next = linknode->next;\n-  linknode->next->prev = linknode->prev;\n-  linknode->prev = NULL;\n-  linknode->next = NULL;\n-}\n-\n-/* Link ssa_imm_use node LINKNODE into the chain for LIST.  */\n-static inline void\n-link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list)\n-{\n-  /* Link the new node at the head of the list.  If we are in the process of\n-     traversing the list, we won't visit any new nodes added to it.  */\n-  linknode->prev = list;\n-  linknode->next = list->next;\n-  list->next->prev = linknode;\n-  list->next = linknode;\n-}\n-\n-/* Link ssa_imm_use node LINKNODE into the chain for DEF.  */\n-static inline void\n-link_imm_use (ssa_use_operand_t *linknode, tree def)\n-{\n-  ssa_use_operand_t *root;\n-\n-  if (!def || TREE_CODE (def) != SSA_NAME)\n-    linknode->prev = NULL;\n-  else\n-    {\n-      root = &(SSA_NAME_IMM_USE_NODE (def));\n-      if (linknode->use)\n-        gcc_checking_assert (*(linknode->use) == def);\n-      link_imm_use_to_list (linknode, root);\n-    }\n-}\n-\n-/* Set the value of a use pointed to by USE to VAL.  */\n-static inline void\n-set_ssa_use_from_ptr (use_operand_p use, tree val)\n-{\n-  delink_imm_use (use);\n-  *(use->use) = val;\n-  link_imm_use (use, val);\n-}\n-\n-/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring\n-   in STMT.  */\n-static inline void\n-link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple stmt)\n-{\n-  if (stmt)\n-    link_imm_use (linknode, def);\n-  else\n-    link_imm_use (linknode, NULL);\n-  linknode->loc.stmt = stmt;\n-}\n-\n-/* Relink a new node in place of an old node in the list.  */\n-static inline void\n-relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n-{\n-  /* The node one had better be in the same list.  */\n-  gcc_checking_assert (*(old->use) == *(node->use));\n-  node->prev = old->prev;\n-  node->next = old->next;\n-  if (old->prev)\n-    {\n-      old->prev->next = node;\n-      old->next->prev = node;\n-      /* Remove the old node from the list.  */\n-      old->prev = NULL;\n-    }\n-}\n-\n-/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occurring\n-   in STMT.  */\n-static inline void\n-relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old,\n-\t\t     gimple stmt)\n-{\n-  if (stmt)\n-    relink_imm_use (linknode, old);\n-  else\n-    link_imm_use (linknode, NULL);\n-  linknode->loc.stmt = stmt;\n-}\n-\n-\n-/* Return true is IMM has reached the end of the immediate use list.  */\n-static inline bool\n-end_readonly_imm_use_p (const imm_use_iterator *imm)\n-{\n-  return (imm->imm_use == imm->end_p);\n-}\n-\n-/* Initialize iterator IMM to process the list for VAR.  */\n-static inline use_operand_p\n-first_readonly_imm_use (imm_use_iterator *imm, tree var)\n-{\n-  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n-  imm->imm_use = imm->end_p->next;\n-#ifdef ENABLE_CHECKING\n-  imm->iter_node.next = imm->imm_use->next;\n-#endif\n-  if (end_readonly_imm_use_p (imm))\n-    return NULL_USE_OPERAND_P;\n-  return imm->imm_use;\n-}\n-\n-/* Bump IMM to the next use in the list.  */\n-static inline use_operand_p\n-next_readonly_imm_use (imm_use_iterator *imm)\n-{\n-  use_operand_p old = imm->imm_use;\n-\n-#ifdef ENABLE_CHECKING\n-  /* If this assertion fails, it indicates the 'next' pointer has changed\n-     since the last bump.  This indicates that the list is being modified\n-     via stmt changes, or SET_USE, or somesuch thing, and you need to be\n-     using the SAFE version of the iterator.  */\n-  gcc_assert (imm->iter_node.next == old->next);\n-  imm->iter_node.next = old->next->next;\n-#endif\n-\n-  imm->imm_use = old->next;\n-  if (end_readonly_imm_use_p (imm))\n-    return NULL_USE_OPERAND_P;\n-  return imm->imm_use;\n-}\n-\n-/* tree-cfg.c */\n-extern bool has_zero_uses_1 (const ssa_use_operand_t *head);\n-extern bool single_imm_use_1 (const ssa_use_operand_t *head,\n-\t\t\t      use_operand_p *use_p, gimple *stmt);\n-\n-/* Return true if VAR has no nondebug uses.  */\n-static inline bool\n-has_zero_uses (const_tree var)\n-{\n-  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-\n-  /* A single use_operand means there is no items in the list.  */\n-  if (ptr == ptr->next)\n-    return true;\n-\n-  /* If there are debug stmts, we have to look at each use and see\n-     whether there are any nondebug uses.  */\n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    return false;\n-\n-  return has_zero_uses_1 (ptr);\n-}\n-\n-/* Return true if VAR has a single nondebug use.  */\n-static inline bool\n-has_single_use (const_tree var)\n-{\n-  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-\n-  /* If there aren't any uses whatsoever, we're done.  */\n-  if (ptr == ptr->next)\n-    return false;\n-\n-  /* If there's a single use, check that it's not a debug stmt.  */\n-  if (ptr == ptr->next->next)\n-    return !is_gimple_debug (USE_STMT (ptr->next));\n-\n-  /* If there are debug stmts, we have to look at each of them.  */\n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    return false;\n-\n-  return single_imm_use_1 (ptr, NULL, NULL);\n-}\n-\n-\n-/* If VAR has only a single immediate nondebug use, return true, and\n-   set USE_P and STMT to the use pointer and stmt of occurrence.  */\n-static inline bool\n-single_imm_use (const_tree var, use_operand_p *use_p, gimple *stmt)\n-{\n-  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-\n-  /* If there aren't any uses whatsoever, we're done.  */\n-  if (ptr == ptr->next)\n-    {\n-    return_false:\n-      *use_p = NULL_USE_OPERAND_P;\n-      *stmt = NULL;\n-      return false;\n-    }\n-\n-  /* If there's a single use, check that it's not a debug stmt.  */\n-  if (ptr == ptr->next->next)\n-    {\n-      if (!is_gimple_debug (USE_STMT (ptr->next)))\n-\t{\n-\t  *use_p = ptr->next;\n-\t  *stmt = ptr->next->loc.stmt;\n-\t  return true;\n-\t}\n-      else\n-\tgoto return_false;\n-    }\n-\n-  /* If there are debug stmts, we have to look at each of them.  */\n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    goto return_false;\n-\n-  return single_imm_use_1 (ptr, use_p, stmt);\n-}\n-\n-/* Return the number of nondebug immediate uses of VAR.  */\n-static inline unsigned int\n-num_imm_uses (const_tree var)\n-{\n-  const ssa_use_operand_t *const start = &(SSA_NAME_IMM_USE_NODE (var));\n-  const ssa_use_operand_t *ptr;\n-  unsigned int num = 0;\n-\n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    for (ptr = start->next; ptr != start; ptr = ptr->next)\n-      num++;\n-  else\n-    for (ptr = start->next; ptr != start; ptr = ptr->next)\n-      if (!is_gimple_debug (USE_STMT (ptr)))\n-\tnum++;\n-\n-  return num;\n-}\n-\n-/* Return the tree pointed-to by USE.  */\n-static inline tree\n-get_use_from_ptr (use_operand_p use)\n-{\n-  return *(use->use);\n-}\n-\n-/* Return the tree pointed-to by DEF.  */\n-static inline tree\n-get_def_from_ptr (def_operand_p def)\n-{\n-  return *def;\n-}\n-\n-/* Return a use_operand_p pointer for argument I of PHI node GS.  */\n-\n-static inline use_operand_p\n-gimple_phi_arg_imm_use_ptr (gimple gs, int i)\n-{\n-  return &gimple_phi_arg (gs, i)->imm_use;\n-}\n-\n-/* Return the tree operand for argument I of PHI node GS.  */\n-\n-static inline tree\n-gimple_phi_arg_def (gimple gs, size_t index)\n-{\n-  struct phi_arg_d *pd = gimple_phi_arg (gs, index);\n-  return get_use_from_ptr (&pd->imm_use);\n-}\n-\n-/* Return a pointer to the tree operand for argument I of PHI node GS.  */\n-\n-static inline tree *\n-gimple_phi_arg_def_ptr (gimple gs, size_t index)\n-{\n-  return &gimple_phi_arg (gs, index)->def;\n-}\n-\n-/* Return the edge associated with argument I of phi node GS.  */\n-\n-static inline edge\n-gimple_phi_arg_edge (gimple gs, size_t i)\n-{\n-  return EDGE_PRED (gimple_bb (gs), i);\n-}\n-\n-/* Return the source location of gimple argument I of phi node GS.  */\n-\n-static inline source_location\n-gimple_phi_arg_location (gimple gs, size_t i)\n-{\n-  return gimple_phi_arg (gs, i)->locus;\n-}\n-\n-/* Return the source location of the argument on edge E of phi node GS.  */\n-\n-static inline source_location\n-gimple_phi_arg_location_from_edge (gimple gs, edge e)\n-{\n-  return gimple_phi_arg (gs, e->dest_idx)->locus;\n-}\n-\n-/* Set the source location of gimple argument I of phi node GS to LOC.  */\n-\n-static inline void\n-gimple_phi_arg_set_location (gimple gs, size_t i, source_location loc)\n-{\n-  gimple_phi_arg (gs, i)->locus = loc;\n-}\n-\n-/* Return TRUE if argument I of phi node GS has a location record.  */\n-\n-static inline bool\n-gimple_phi_arg_has_location (gimple gs, size_t i)\n-{\n-  return gimple_phi_arg_location (gs, i) != UNKNOWN_LOCATION;\n-}\n-\n-\n-/* Return the PHI nodes for basic block BB, or NULL if there are no\n-   PHI nodes.  */\n-static inline gimple_seq\n-phi_nodes (const_basic_block bb)\n-{\n-  gcc_checking_assert (!(bb->flags & BB_RTL));\n-  return bb->il.gimple.phi_nodes;\n-}\n-\n-static inline gimple_seq *\n-phi_nodes_ptr (basic_block bb)\n-{\n-  gcc_checking_assert (!(bb->flags & BB_RTL));\n-  return &bb->il.gimple.phi_nodes;\n-}\n-\n-/* Set PHI nodes of a basic block BB to SEQ.  */\n-\n-static inline void\n-set_phi_nodes (basic_block bb, gimple_seq seq)\n-{\n-  gimple_stmt_iterator i;\n-\n-  gcc_checking_assert (!(bb->flags & BB_RTL));\n-  bb->il.gimple.phi_nodes = seq;\n-  if (seq)\n-    for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n-      gimple_set_bb (gsi_stmt (i), bb);\n-}\n-\n-/* Return the phi argument which contains the specified use.  */\n-\n-static inline int\n-phi_arg_index_from_use (use_operand_p use)\n-{\n-  struct phi_arg_d *element, *root;\n-  size_t index;\n-  gimple phi;\n-\n-  /* Since the use is the first thing in a PHI argument element, we can\n-     calculate its index based on casting it to an argument, and performing\n-     pointer arithmetic.  */\n-\n-  phi = USE_STMT (use);\n-\n-  element = (struct phi_arg_d *)use;\n-  root = gimple_phi_arg (phi, 0);\n-  index = element - root;\n-\n-  /* Make sure the calculation doesn't have any leftover bytes.  If it does,\n-     then imm_use is likely not the first element in phi_arg_d.  */\n-  gcc_checking_assert ((((char *)element - (char *)root)\n-\t\t\t% sizeof (struct phi_arg_d)) == 0\n-\t\t       && index < gimple_phi_capacity (phi));\n-\n- return index;\n-}\n \n /* Return true if T (assumed to be a DECL) is a global variable.\n    A variable is considered global if its storage is not automatic.  */\n@@ -528,20 +154,6 @@ may_be_aliased (const_tree var)\n }\n \n \n-/* PHI nodes should contain only ssa_names and invariants.  A test\n-   for ssa_name is definitely simpler; don't let invalid contents\n-   slip in in the meantime.  */\n-\n-static inline bool\n-phi_ssa_name_p (const_tree t)\n-{\n-  if (TREE_CODE (t) == SSA_NAME)\n-    return true;\n-  gcc_checking_assert (is_gimple_min_invariant (t));\n-  return false;\n-}\n-\n-\n /* Returns the loop of the statement STMT.  */\n \n static inline struct loop *\n@@ -555,536 +167,6 @@ loop_containing_stmt (gimple stmt)\n }\n \n \n-/*  -----------------------------------------------------------------------  */\n-\n-/* The following set of routines are used to iterator over various type of\n-   SSA operands.  */\n-\n-/* Return true if PTR is finished iterating.  */\n-static inline bool\n-op_iter_done (const ssa_op_iter *ptr)\n-{\n-  return ptr->done;\n-}\n-\n-/* Get the next iterator use value for PTR.  */\n-static inline use_operand_p\n-op_iter_next_use (ssa_op_iter *ptr)\n-{\n-  use_operand_p use_p;\n-  gcc_checking_assert (ptr->iter_type == ssa_op_iter_use);\n-  if (ptr->uses)\n-    {\n-      use_p = USE_OP_PTR (ptr->uses);\n-      ptr->uses = ptr->uses->next;\n-      return use_p;\n-    }\n-  if (ptr->i < ptr->numops)\n-    {\n-      return PHI_ARG_DEF_PTR (ptr->stmt, (ptr->i)++);\n-    }\n-  ptr->done = true;\n-  return NULL_USE_OPERAND_P;\n-}\n-\n-/* Get the next iterator def value for PTR.  */\n-static inline def_operand_p\n-op_iter_next_def (ssa_op_iter *ptr)\n-{\n-  gcc_checking_assert (ptr->iter_type == ssa_op_iter_def);\n-  if (ptr->flags & SSA_OP_VDEF)\n-    {\n-      tree *p;\n-      ptr->flags &= ~SSA_OP_VDEF;\n-      p = gimple_vdef_ptr (ptr->stmt);\n-      if (p && *p)\n-\treturn p;\n-    }\n-  if (ptr->flags & SSA_OP_DEF)\n-    {\n-      while (ptr->i < ptr->numops)\n-\t{\n-\t  tree *val = gimple_op_ptr (ptr->stmt, ptr->i);\n-\t  ptr->i++;\n-\t  if (*val)\n-\t    {\n-\t      if (TREE_CODE (*val) == TREE_LIST)\n-\t\tval = &TREE_VALUE (*val);\n-\t      if (TREE_CODE (*val) == SSA_NAME\n-\t\t  || is_gimple_reg (*val))\n-\t\treturn val;\n-\t    }\n-\t}\n-      ptr->flags &= ~SSA_OP_DEF;\n-    }\n-\n-  ptr->done = true;\n-  return NULL_DEF_OPERAND_P;\n-}\n-\n-/* Get the next iterator tree value for PTR.  */\n-static inline tree\n-op_iter_next_tree (ssa_op_iter *ptr)\n-{\n-  tree val;\n-  gcc_checking_assert (ptr->iter_type == ssa_op_iter_tree);\n-  if (ptr->uses)\n-    {\n-      val = USE_OP (ptr->uses);\n-      ptr->uses = ptr->uses->next;\n-      return val;\n-    }\n-  if (ptr->flags & SSA_OP_VDEF)\n-    {\n-      ptr->flags &= ~SSA_OP_VDEF;\n-      if ((val = gimple_vdef (ptr->stmt)))\n-\treturn val;\n-    }\n-  if (ptr->flags & SSA_OP_DEF)\n-    {\n-      while (ptr->i < ptr->numops)\n-\t{\n-\t  val = gimple_op (ptr->stmt, ptr->i);\n-\t  ptr->i++;\n-\t  if (val)\n-\t    {\n-\t      if (TREE_CODE (val) == TREE_LIST)\n-\t\tval = TREE_VALUE (val);\n-\t      if (TREE_CODE (val) == SSA_NAME\n-\t\t  || is_gimple_reg (val))\n-\t\treturn val;\n-\t    }\n-\t}\n-      ptr->flags &= ~SSA_OP_DEF;\n-    }\n-\n-  ptr->done = true;\n-  return NULL_TREE;\n-}\n-\n-\n-/* This functions clears the iterator PTR, and marks it done.  This is normally\n-   used to prevent warnings in the compile about might be uninitialized\n-   components.  */\n-\n-static inline void\n-clear_and_done_ssa_iter (ssa_op_iter *ptr)\n-{\n-  ptr->i = 0;\n-  ptr->numops = 0;\n-  ptr->uses = NULL;\n-  ptr->iter_type = ssa_op_iter_none;\n-  ptr->stmt = NULL;\n-  ptr->done = true;\n-  ptr->flags = 0;\n-}\n-\n-/* Initialize the iterator PTR to the virtual defs in STMT.  */\n-static inline void\n-op_iter_init (ssa_op_iter *ptr, gimple stmt, int flags)\n-{\n-  /* PHI nodes require a different iterator initialization path.  We\n-     do not support iterating over virtual defs or uses without\n-     iterating over defs or uses at the same time.  */\n-  gcc_checking_assert (gimple_code (stmt) != GIMPLE_PHI\n-\t\t       && (!(flags & SSA_OP_VDEF) || (flags & SSA_OP_DEF))\n-\t\t       && (!(flags & SSA_OP_VUSE) || (flags & SSA_OP_USE)));\n-  ptr->numops = 0;\n-  if (flags & (SSA_OP_DEF | SSA_OP_VDEF))\n-    {\n-      switch (gimple_code (stmt))\n-\t{\n-\t  case GIMPLE_ASSIGN:\n-\t  case GIMPLE_CALL:\n-\t    ptr->numops = 1;\n-\t    break;\n-\t  case GIMPLE_ASM:\n-\t    ptr->numops = gimple_asm_noutputs (stmt);\n-\t    break;\n-\t  default:\n-\t    ptr->numops = 0;\n-\t    flags &= ~(SSA_OP_DEF | SSA_OP_VDEF);\n-\t    break;\n-\t}\n-    }\n-  ptr->uses = (flags & (SSA_OP_USE|SSA_OP_VUSE)) ? gimple_use_ops (stmt) : NULL;\n-  if (!(flags & SSA_OP_VUSE)\n-      && ptr->uses\n-      && gimple_vuse (stmt) != NULL_TREE)\n-    ptr->uses = ptr->uses->next;\n-  ptr->done = false;\n-  ptr->i = 0;\n-\n-  ptr->stmt = stmt;\n-  ptr->flags = flags;\n-}\n-\n-/* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n-   the first use.  */\n-static inline use_operand_p\n-op_iter_init_use (ssa_op_iter *ptr, gimple stmt, int flags)\n-{\n-  gcc_checking_assert ((flags & SSA_OP_ALL_DEFS) == 0\n-\t\t       && (flags & SSA_OP_USE));\n-  op_iter_init (ptr, stmt, flags);\n-  ptr->iter_type = ssa_op_iter_use;\n-  return op_iter_next_use (ptr);\n-}\n-\n-/* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return\n-   the first def.  */\n-static inline def_operand_p\n-op_iter_init_def (ssa_op_iter *ptr, gimple stmt, int flags)\n-{\n-  gcc_checking_assert ((flags & SSA_OP_ALL_USES) == 0\n-\t\t       && (flags & SSA_OP_DEF));\n-  op_iter_init (ptr, stmt, flags);\n-  ptr->iter_type = ssa_op_iter_def;\n-  return op_iter_next_def (ptr);\n-}\n-\n-/* Initialize iterator PTR to the operands in STMT based on FLAGS. Return\n-   the first operand as a tree.  */\n-static inline tree\n-op_iter_init_tree (ssa_op_iter *ptr, gimple stmt, int flags)\n-{\n-  op_iter_init (ptr, stmt, flags);\n-  ptr->iter_type = ssa_op_iter_tree;\n-  return op_iter_next_tree (ptr);\n-}\n-\n-\n-/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  */\n-static inline tree\n-single_ssa_tree_operand (gimple stmt, int flags)\n-{\n-  tree var;\n-  ssa_op_iter iter;\n-\n-  var = op_iter_init_tree (&iter, stmt, flags);\n-  if (op_iter_done (&iter))\n-    return NULL_TREE;\n-  op_iter_next_tree (&iter);\n-  if (op_iter_done (&iter))\n-    return var;\n-  return NULL_TREE;\n-}\n-\n-\n-/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  */\n-static inline use_operand_p\n-single_ssa_use_operand (gimple stmt, int flags)\n-{\n-  use_operand_p var;\n-  ssa_op_iter iter;\n-\n-  var = op_iter_init_use (&iter, stmt, flags);\n-  if (op_iter_done (&iter))\n-    return NULL_USE_OPERAND_P;\n-  op_iter_next_use (&iter);\n-  if (op_iter_done (&iter))\n-    return var;\n-  return NULL_USE_OPERAND_P;\n-}\n-\n-\n-\n-/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n-   return NULL.  */\n-static inline def_operand_p\n-single_ssa_def_operand (gimple stmt, int flags)\n-{\n-  def_operand_p var;\n-  ssa_op_iter iter;\n-\n-  var = op_iter_init_def (&iter, stmt, flags);\n-  if (op_iter_done (&iter))\n-    return NULL_DEF_OPERAND_P;\n-  op_iter_next_def (&iter);\n-  if (op_iter_done (&iter))\n-    return var;\n-  return NULL_DEF_OPERAND_P;\n-}\n-\n-\n-/* Return true if there are zero operands in STMT matching the type\n-   given in FLAGS.  */\n-static inline bool\n-zero_ssa_operands (gimple stmt, int flags)\n-{\n-  ssa_op_iter iter;\n-\n-  op_iter_init_tree (&iter, stmt, flags);\n-  return op_iter_done (&iter);\n-}\n-\n-\n-/* Return the number of operands matching FLAGS in STMT.  */\n-static inline int\n-num_ssa_operands (gimple stmt, int flags)\n-{\n-  ssa_op_iter iter;\n-  tree t;\n-  int num = 0;\n-\n-  gcc_checking_assert (gimple_code (stmt) != GIMPLE_PHI);\n-  FOR_EACH_SSA_TREE_OPERAND (t, stmt, iter, flags)\n-    num++;\n-  return num;\n-}\n-\n-static inline use_operand_p\n-op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags);\n-\n-/* Delink all immediate_use information for STMT.  */\n-static inline void\n-delink_stmt_imm_use (gimple stmt)\n-{\n-   ssa_op_iter iter;\n-   use_operand_p use_p;\n-\n-   if (ssa_operands_active (cfun))\n-     FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_ALL_USES)\n-       delink_imm_use (use_p);\n-}\n-\n-\n-/* If there is a single DEF in the PHI node which matches FLAG, return it.\n-   Otherwise return NULL_DEF_OPERAND_P.  */\n-static inline tree\n-single_phi_def (gimple stmt, int flags)\n-{\n-  tree def = PHI_RESULT (stmt);\n-  if ((flags & SSA_OP_DEF) && is_gimple_reg (def))\n-    return def;\n-  if ((flags & SSA_OP_VIRTUAL_DEFS) && !is_gimple_reg (def))\n-    return def;\n-  return NULL_TREE;\n-}\n-\n-/* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should\n-   be either SSA_OP_USES or SSA_OP_VIRTUAL_USES.  */\n-static inline use_operand_p\n-op_iter_init_phiuse (ssa_op_iter *ptr, gimple phi, int flags)\n-{\n-  tree phi_def = gimple_phi_result (phi);\n-  int comp;\n-\n-  clear_and_done_ssa_iter (ptr);\n-  ptr->done = false;\n-\n-  gcc_checking_assert ((flags & (SSA_OP_USE | SSA_OP_VIRTUAL_USES)) != 0);\n-\n-  comp = (is_gimple_reg (phi_def) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n-\n-  /* If the PHI node doesn't the operand type we care about, we're done.  */\n-  if ((flags & comp) == 0)\n-    {\n-      ptr->done = true;\n-      return NULL_USE_OPERAND_P;\n-    }\n-\n-  ptr->stmt = phi;\n-  ptr->numops = gimple_phi_num_args (phi);\n-  ptr->iter_type = ssa_op_iter_use;\n-  ptr->flags = flags;\n-  return op_iter_next_use (ptr);\n-}\n-\n-\n-/* Start an iterator for a PHI definition.  */\n-\n-static inline def_operand_p\n-op_iter_init_phidef (ssa_op_iter *ptr, gimple phi, int flags)\n-{\n-  tree phi_def = PHI_RESULT (phi);\n-  int comp;\n-\n-  clear_and_done_ssa_iter (ptr);\n-  ptr->done = false;\n-\n-  gcc_checking_assert ((flags & (SSA_OP_DEF | SSA_OP_VIRTUAL_DEFS)) != 0);\n-\n-  comp = (is_gimple_reg (phi_def) ? SSA_OP_DEF : SSA_OP_VIRTUAL_DEFS);\n-\n-  /* If the PHI node doesn't have the operand type we care about,\n-     we're done.  */\n-  if ((flags & comp) == 0)\n-    {\n-      ptr->done = true;\n-      return NULL_DEF_OPERAND_P;\n-    }\n-\n-  ptr->iter_type = ssa_op_iter_def;\n-  /* The first call to op_iter_next_def will terminate the iterator since\n-     all the fields are NULL.  Simply return the result here as the first and\n-     therefore only result.  */\n-  return PHI_RESULT_PTR (phi);\n-}\n-\n-/* Return true is IMM has reached the end of the immediate use stmt list.  */\n-\n-static inline bool\n-end_imm_use_stmt_p (const imm_use_iterator *imm)\n-{\n-  return (imm->imm_use == imm->end_p);\n-}\n-\n-/* Finished the traverse of an immediate use stmt list IMM by removing the\n-   placeholder node from the list.  */\n-\n-static inline void\n-end_imm_use_stmt_traverse (imm_use_iterator *imm)\n-{\n-  delink_imm_use (&(imm->iter_node));\n-}\n-\n-/* Immediate use traversal of uses within a stmt require that all the\n-   uses on a stmt be sequentially listed.  This routine is used to build up\n-   this sequential list by adding USE_P to the end of the current list\n-   currently delimited by HEAD and LAST_P.  The new LAST_P value is\n-   returned.  */\n-\n-static inline use_operand_p\n-move_use_after_head (use_operand_p use_p, use_operand_p head,\n-\t\t      use_operand_p last_p)\n-{\n-  gcc_checking_assert (USE_FROM_PTR (use_p) == USE_FROM_PTR (head));\n-  /* Skip head when we find it.  */\n-  if (use_p != head)\n-    {\n-      /* If use_p is already linked in after last_p, continue.  */\n-      if (last_p->next == use_p)\n-\tlast_p = use_p;\n-      else\n-\t{\n-\t  /* Delink from current location, and link in at last_p.  */\n-\t  delink_imm_use (use_p);\n-\t  link_imm_use_to_list (use_p, last_p);\n-\t  last_p = use_p;\n-\t}\n-    }\n-  return last_p;\n-}\n-\n-\n-/* This routine will relink all uses with the same stmt as HEAD into the list\n-   immediately following HEAD for iterator IMM.  */\n-\n-static inline void\n-link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n-{\n-  use_operand_p use_p;\n-  use_operand_p last_p = head;\n-  gimple head_stmt = USE_STMT (head);\n-  tree use = USE_FROM_PTR (head);\n-  ssa_op_iter op_iter;\n-  int flag;\n-\n-  /* Only look at virtual or real uses, depending on the type of HEAD.  */\n-  flag = (is_gimple_reg (use) ? SSA_OP_USE : SSA_OP_VIRTUAL_USES);\n-\n-  if (gimple_code (head_stmt) == GIMPLE_PHI)\n-    {\n-      FOR_EACH_PHI_ARG (use_p, head_stmt, op_iter, flag)\n-\tif (USE_FROM_PTR (use_p) == use)\n-\t  last_p = move_use_after_head (use_p, head, last_p);\n-    }\n-  else\n-    {\n-      if (flag == SSA_OP_USE)\n-\t{\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, head_stmt, op_iter, flag)\n-\t    if (USE_FROM_PTR (use_p) == use)\n-\t      last_p = move_use_after_head (use_p, head, last_p);\n-\t}\n-      else if ((use_p = gimple_vuse_op (head_stmt)) != NULL_USE_OPERAND_P)\n-\t{\n-\t  if (USE_FROM_PTR (use_p) == use)\n-\t    last_p = move_use_after_head (use_p, head, last_p);\n-\t}\n-    }\n-  /* Link iter node in after last_p.  */\n-  if (imm->iter_node.prev != NULL)\n-    delink_imm_use (&imm->iter_node);\n-  link_imm_use_to_list (&(imm->iter_node), last_p);\n-}\n-\n-/* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */\n-static inline gimple\n-first_imm_use_stmt (imm_use_iterator *imm, tree var)\n-{\n-  imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n-  imm->imm_use = imm->end_p->next;\n-  imm->next_imm_name = NULL_USE_OPERAND_P;\n-\n-  /* iter_node is used as a marker within the immediate use list to indicate\n-     where the end of the current stmt's uses are.  Initialize it to NULL\n-     stmt and use, which indicates a marker node.  */\n-  imm->iter_node.prev = NULL_USE_OPERAND_P;\n-  imm->iter_node.next = NULL_USE_OPERAND_P;\n-  imm->iter_node.loc.stmt = NULL;\n-  imm->iter_node.use = NULL;\n-\n-  if (end_imm_use_stmt_p (imm))\n-    return NULL;\n-\n-  link_use_stmts_after (imm->imm_use, imm);\n-\n-  return USE_STMT (imm->imm_use);\n-}\n-\n-/* Bump IMM to the next stmt which has a use of var.  */\n-\n-static inline gimple\n-next_imm_use_stmt (imm_use_iterator *imm)\n-{\n-  imm->imm_use = imm->iter_node.next;\n-  if (end_imm_use_stmt_p (imm))\n-    {\n-      if (imm->iter_node.prev != NULL)\n-\tdelink_imm_use (&imm->iter_node);\n-      return NULL;\n-    }\n-\n-  link_use_stmts_after (imm->imm_use, imm);\n-  return USE_STMT (imm->imm_use);\n-}\n-\n-/* This routine will return the first use on the stmt IMM currently refers\n-   to.  */\n-\n-static inline use_operand_p\n-first_imm_use_on_stmt (imm_use_iterator *imm)\n-{\n-  imm->next_imm_name = imm->imm_use->next;\n-  return imm->imm_use;\n-}\n-\n-/*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */\n-\n-static inline bool\n-end_imm_use_on_stmt_p (const imm_use_iterator *imm)\n-{\n-  return (imm->imm_use == &(imm->iter_node));\n-}\n-\n-/* Bump to the next use on the stmt IMM refers to, return NULL if done.  */\n-\n-static inline use_operand_p\n-next_imm_use_on_stmt (imm_use_iterator *imm)\n-{\n-  imm->imm_use = imm->next_imm_name;\n-  if (end_imm_use_on_stmt_p (imm))\n-    return NULL_USE_OPERAND_P;\n-  else\n-    {\n-      imm->next_imm_name = imm->imm_use->next;\n-      return imm->imm_use;\n-    }\n-}\n \n /* Return true if VAR cannot be modified by the program.  */\n "}, {"sha": "46082e298567511a0e01f3329a8a47374eefa8c6", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -107,132 +107,8 @@ typedef struct\n \t!end_htab_p (&(ITER)); \\\n \tRESULT = (TYPE) next_htab_element (&(ITER)))\n \n-/* It is advantageous to avoid things like life analysis for variables which\n-   do not need PHI nodes.  This enum describes whether or not a particular\n-   variable may need a PHI node.  */\n-\n-enum need_phi_state {\n-  /* This is the default.  If we are still in this state after finding\n-     all the definition and use sites, then we will assume the variable\n-     needs PHI nodes.  This is probably an overly conservative assumption.  */\n-  NEED_PHI_STATE_UNKNOWN,\n-\n-  /* This state indicates that we have seen one or more sets of the\n-     variable in a single basic block and that the sets dominate all\n-     uses seen so far.  If after finding all definition and use sites\n-     we are still in this state, then the variable does not need any\n-     PHI nodes.  */\n-  NEED_PHI_STATE_NO,\n-\n-  /* This state indicates that we have either seen multiple definitions of\n-     the variable in multiple blocks, or that we encountered a use in a\n-     block that was not dominated by the block containing the set(s) of\n-     this variable.  This variable is assumed to need PHI nodes.  */\n-  NEED_PHI_STATE_MAYBE\n-};\n-\n-\n-/* Immediate use lists are used to directly access all uses for an SSA\n-   name and get pointers to the statement for each use.\n-\n-   The structure ssa_use_operand_d consists of PREV and NEXT pointers\n-   to maintain the list.  A USE pointer, which points to address where\n-   the use is located and a LOC pointer which can point to the\n-   statement where the use is located, or, in the case of the root\n-   node, it points to the SSA name itself.\n-\n-   The list is anchored by an occurrence of ssa_operand_d *in* the\n-   ssa_name node itself (named 'imm_uses').  This node is uniquely\n-   identified by having a NULL USE pointer. and the LOC pointer\n-   pointing back to the ssa_name node itself.  This node forms the\n-   base for a circular list, and initially this is the only node in\n-   the list.\n-\n-   Fast iteration allows each use to be examined, but does not allow\n-   any modifications to the uses or stmts.\n-\n-   Normal iteration allows insertion, deletion, and modification. the\n-   iterator manages this by inserting a marker node into the list\n-   immediately before the node currently being examined in the list.\n-   this marker node is uniquely identified by having null stmt *and* a\n-   null use pointer.\n-\n-   When iterating to the next use, the iteration routines check to see\n-   if the node after the marker has changed. if it has, then the node\n-   following the marker is now the next one to be visited. if not, the\n-   marker node is moved past that node in the list (visualize it as\n-   bumping the marker node through the list).  this continues until\n-   the marker node is moved to the original anchor position. the\n-   marker node is then removed from the list.\n-\n-   If iteration is halted early, the marker node must be removed from\n-   the list before continuing.  */\n-typedef struct immediate_use_iterator_d\n-{\n-  /* This is the current use the iterator is processing.  */\n-  ssa_use_operand_t *imm_use;\n-  /* This marks the last use in the list (use node from SSA_NAME)  */\n-  ssa_use_operand_t *end_p;\n-  /* This node is inserted and used to mark the end of the uses for a stmt.  */\n-  ssa_use_operand_t iter_node;\n-  /* This is the next ssa_name to visit.  IMM_USE may get removed before\n-     the next one is traversed to, so it must be cached early.  */\n-  ssa_use_operand_t *next_imm_name;\n-} imm_use_iterator;\n-\n-\n-/* Use this iterator when simply looking at stmts.  Adding, deleting or\n-   modifying stmts will cause this iterator to malfunction.  */\n-\n-#define FOR_EACH_IMM_USE_FAST(DEST, ITER, SSAVAR)\t\t\\\n-  for ((DEST) = first_readonly_imm_use (&(ITER), (SSAVAR));\t\\\n-       !end_readonly_imm_use_p (&(ITER));\t\t\t\\\n-       (void) ((DEST) = next_readonly_imm_use (&(ITER))))\n-\n-/* Use this iterator to visit each stmt which has a use of SSAVAR.  */\n-\n-#define FOR_EACH_IMM_USE_STMT(STMT, ITER, SSAVAR)\t\t\\\n-  for ((STMT) = first_imm_use_stmt (&(ITER), (SSAVAR));\t\t\\\n-       !end_imm_use_stmt_p (&(ITER));\t\t\t\t\\\n-       (void) ((STMT) = next_imm_use_stmt (&(ITER))))\n-\n-/* Use this to terminate the FOR_EACH_IMM_USE_STMT loop early.  Failure to\n-   do so will result in leaving a iterator marker node in the immediate\n-   use list, and nothing good will come from that.   */\n-#define BREAK_FROM_IMM_USE_STMT(ITER)\t\t\t\t\\\n-   {\t\t\t\t\t\t\t\t\\\n-     end_imm_use_stmt_traverse (&(ITER));\t\t\t\\\n-     break;\t\t\t\t\t\t\t\\\n-   }\n-\n-\n-/* Use this iterator in combination with FOR_EACH_IMM_USE_STMT to\n-   get access to each occurrence of ssavar on the stmt returned by\n-   that iterator..  for instance:\n-\n-     FOR_EACH_IMM_USE_STMT (stmt, iter, var)\n-       {\n-         FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t   {\n-\t     SET_USE (use_p, blah);\n-\t   }\n-\t update_stmt (stmt);\n-       }\t\t\t\t\t\t\t */\n-\n-#define FOR_EACH_IMM_USE_ON_STMT(DEST, ITER)\t\t\t\\\n-  for ((DEST) = first_imm_use_on_stmt (&(ITER));\t\t\\\n-       !end_imm_use_on_stmt_p (&(ITER));\t\t\t\\\n-       (void) ((DEST) = next_imm_use_on_stmt (&(ITER))))\n-\n-\n-\n-static inline void update_stmt (gimple);\n static inline int get_lineno (const_gimple);\n \n-/* Accessors for basic block annotations.  */\n-static inline gimple_seq phi_nodes (const_basic_block);\n-static inline void set_phi_nodes (basic_block, gimple_seq);\n-\n /*---------------------------------------------------------------------------\n \t\t\t      Global declarations\n ---------------------------------------------------------------------------*/\n@@ -403,17 +279,6 @@ extern bool stmt_references_abnormal_ssa_name (gimple);\n extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n extern void dump_enumerated_decls (FILE *, int);\n \n-/* In tree-phinodes.c  */\n-extern void reserve_phi_args_for_new_edge (basic_block);\n-extern void add_phi_node_to_bb (gimple phi, basic_block bb);\n-extern gimple create_phi_node (tree, basic_block);\n-extern void add_phi_arg (gimple, tree, edge, source_location);\n-extern void remove_phi_args (edge);\n-extern void remove_phi_node (gimple_stmt_iterator *, bool);\n-extern void remove_phi_nodes (basic_block);\n-extern void release_phi_node (gimple);\n-extern void phinodes_print_statistics (void);\n-\n /* In gimple-low.c  */\n extern void record_vars_into (tree, tree);\n extern void record_vars (tree);\n@@ -684,6 +549,4 @@ bool parallelized_function_p (tree);\n \n #include \"tree-flow-inline.h\"\n \n-void swap_tree_operands (gimple, tree *, tree *);\n-\n #endif /* _TREE_FLOW_H  */"}, {"sha": "c1da5e4fcbba502e66dff9355e38d143c508ef1c", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -128,6 +128,30 @@ struct mark_def_sites_global_data\n   bitmap kills;\n };\n \n+/* It is advantageous to avoid things like life analysis for variables which\n+   do not need PHI nodes.  This enum describes whether or not a particular\n+   variable may need a PHI node.  */\n+\n+enum need_phi_state {\n+  /* This is the default.  If we are still in this state after finding\n+     all the definition and use sites, then we will assume the variable\n+     needs PHI nodes.  This is probably an overly conservative assumption.  */\n+  NEED_PHI_STATE_UNKNOWN,\n+\n+  /* This state indicates that we have seen one or more sets of the\n+     variable in a single basic block and that the sets dominate all\n+     uses seen so far.  If after finding all definition and use sites\n+     we are still in this state, then the variable does not need any\n+     PHI nodes.  */\n+  NEED_PHI_STATE_NO,\n+\n+  /* This state indicates that we have either seen multiple definitions of\n+     the variable in multiple blocks, or that we encountered a use in a\n+     block that was not dominated by the block containing the set(s) of\n+     this variable.  This variable is assumed to need PHI nodes.  */\n+  NEED_PHI_STATE_MAYBE\n+};\n+\n /* Information stored for both SSA names and decls.  */\n struct common_info_d\n {\n@@ -1492,31 +1516,6 @@ rewrite_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n }\n \n \n-/* Dump bitmap SET (assumed to contain VAR_DECLs) to FILE.  */\n-\n-void\n-dump_decl_set (FILE *file, bitmap set)\n-{\n-  if (set)\n-    {\n-      bitmap_iterator bi;\n-      unsigned i;\n-\n-      fprintf (file, \"{ \");\n-\n-      EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n-\t{\n-\t  fprintf (file, \"D.%u\", i);\n-\t  fprintf (file, \" \");\n-\t}\n-\n-      fprintf (file, \"}\");\n-    }\n-  else\n-    fprintf (file, \"NIL\");\n-}\n-\n-\n /* Dump bitmap SET (assumed to contain VAR_DECLs) to FILE.  */\n \n DEBUG_FUNCTION void"}, {"sha": "e44808e9f774e47f5a05e099a5007740c38eca34", "filename": "gcc/tree-outof-ssa.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-outof-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-outof-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -18,8 +18,8 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n \n-#ifndef _SSAEXPAND_H\n-#define _SSAEXPAND_H 1\n+#ifndef GCC_TREE_OUTOF_SSA_H\n+#define GCC_TREE_OUTOF_SSA_H\n \n #include \"tree-ssa-live.h\"\n #include \"tree-ssa-ter.h\"\n@@ -77,4 +77,4 @@ extern void finish_out_of_ssa (struct ssaexpand *sa);\n extern unsigned int rewrite_out_of_ssa (struct ssaexpand *sa);\n extern void expand_phi_nodes (struct ssaexpand *sa);\n \n-#endif\n+#endif /* GCC_TREE_OUTOF_SSA_H */"}, {"sha": "e36106922118ac41a28859a2b4abeb587c546813", "filename": "gcc/tree-phinodes.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-phinodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-phinodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -0,0 +1,83 @@\n+/* Header file for PHI node routines\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_PHINODES_H\n+#define GCC_TREE_PHINODES_H\n+\n+extern void phinodes_print_statistics (void);\n+extern void release_phi_node (gimple);\n+extern void reserve_phi_args_for_new_edge (basic_block);\n+extern void add_phi_node_to_bb (gimple phi, basic_block bb);\n+extern gimple create_phi_node (tree, basic_block);\n+extern void add_phi_arg (gimple, tree, edge, source_location);\n+extern void remove_phi_args (edge);\n+extern void remove_phi_node (gimple_stmt_iterator *, bool);\n+extern void remove_phi_nodes (basic_block);\n+/* Return a use_operand_p pointer for argument I of PHI node GS.  */\n+\n+/* Set PHI nodes of a basic block BB to SEQ.  */\n+\n+static inline void\n+set_phi_nodes (basic_block bb, gimple_seq seq)\n+{\n+  gimple_stmt_iterator i;\n+\n+  gcc_checking_assert (!(bb->flags & BB_RTL));\n+  bb->il.gimple.phi_nodes = seq;\n+  if (seq)\n+    for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n+      gimple_set_bb (gsi_stmt (i), bb);\n+}\n+\n+\n+static inline use_operand_p\n+gimple_phi_arg_imm_use_ptr (gimple gs, int i)\n+{\n+  return &gimple_phi_arg (gs, i)->imm_use;\n+}\n+\n+/* Return the phi argument which contains the specified use.  */\n+\n+static inline int\n+phi_arg_index_from_use (use_operand_p use)\n+{\n+  struct phi_arg_d *element, *root;\n+  size_t index;\n+  gimple phi;\n+\n+  /* Since the use is the first thing in a PHI argument element, we can\n+     calculate its index based on casting it to an argument, and performing\n+     pointer arithmetic.  */\n+\n+  phi = USE_STMT (use);\n+\n+  element = (struct phi_arg_d *)use;\n+  root = gimple_phi_arg (phi, 0);\n+  index = element - root;\n+\n+  /* Make sure the calculation doesn't have any leftover bytes.  If it does,\n+     then imm_use is likely not the first element in phi_arg_d.  */\n+  gcc_checking_assert ((((char *)element - (char *)root)\n+\t\t\t% sizeof (struct phi_arg_d)) == 0\n+\t\t       && index < gimple_phi_capacity (phi));\n+\n+ return index;\n+}\n+\n+#endif /* GCC_TREE_PHINODES_H */"}, {"sha": "22dee7f05338e7dd063889f7063be85a514d6892", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -1092,18 +1092,19 @@ update_stmt_operands (gimple stmt)\n    to test the validity of the swap operation.  */\n \n void\n-swap_tree_operands (gimple stmt, tree *exp0, tree *exp1)\n+swap_ssa_operands (gimple stmt, tree *exp0, tree *exp1)\n {\n   tree op0, op1;\n   op0 = *exp0;\n   op1 = *exp1;\n \n-  /* If the operand cache is active, attempt to preserve the relative\n-     positions of these two operands in their respective immediate use\n-     lists by adjusting their use pointer to point to the new\n-     operand position.  */\n-  if (ssa_operands_active (cfun) && op0 != op1)\n+  gcc_checking_assert (ssa_operands_active (cfun));\n+\n+  if (op0 != op1)\n     {\n+      /* Attempt to preserve the relative positions of these two operands in\n+\t their * respective immediate use lists by adjusting their use pointer\n+\t to point to the new operand position.  */\n       use_optype_p use0, use1, ptr;\n       use0 = use1 = NULL;\n \n@@ -1128,11 +1129,11 @@ swap_tree_operands (gimple stmt, tree *exp0, tree *exp1)\n \tUSE_OP_PTR (use0)->use = exp1;\n       if (use1)\n \tUSE_OP_PTR (use1)->use = exp0;\n-    }\n \n-  /* Now swap the data.  */\n-  *exp0 = op1;\n-  *exp1 = op0;\n+      /* Now swap the data.  */\n+      *exp0 = op1;\n+      *exp1 = op0;\n+    }\n }\n \n \n@@ -1322,3 +1323,47 @@ unlink_stmt_vdef (gimple stmt)\n     SSA_NAME_OCCURS_IN_ABNORMAL_PHI (vuse) = 1;\n }\n \n+\n+/* Return true if the var whose chain of uses starts at PTR has no\n+   nondebug uses.  */\n+bool\n+has_zero_uses_1 (const ssa_use_operand_t *head)\n+{\n+  const ssa_use_operand_t *ptr;\n+\n+  for (ptr = head->next; ptr != head; ptr = ptr->next)\n+    if (!is_gimple_debug (USE_STMT (ptr)))\n+      return false;\n+\n+  return true;\n+}\n+\n+\n+/* Return true if the var whose chain of uses starts at PTR has a\n+   single nondebug use.  Set USE_P and STMT to that single nondebug\n+   use, if so, or to NULL otherwise.  */\n+bool\n+single_imm_use_1 (const ssa_use_operand_t *head,\n+\t\t  use_operand_p *use_p, gimple *stmt)\n+{\n+  ssa_use_operand_t *ptr, *single_use = 0;\n+\n+  for (ptr = head->next; ptr != head; ptr = ptr->next)\n+    if (!is_gimple_debug (USE_STMT (ptr)))\n+      {\n+\tif (single_use)\n+\t  {\n+\t    single_use = NULL;\n+\t    break;\n+\t  }\n+\tsingle_use = ptr;\n+      }\n+\n+  if (use_p)\n+    *use_p = single_use;\n+\n+  if (stmt)\n+    *stmt = single_use ? single_use->loc.stmt : NULL;\n+\n+  return single_use;\n+}"}, {"sha": "b3a4a920e881512f787448d559e710ca32180150", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 20, "deletions": 119, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -75,9 +75,11 @@ struct GTY(()) ssa_operands {\n #define PHI_RESULT_PTR(PHI)\tgimple_phi_result_ptr (PHI)\n #define PHI_RESULT(PHI)\t\tDEF_FROM_PTR (PHI_RESULT_PTR (PHI))\n #define SET_PHI_RESULT(PHI, V)\tSET_DEF (PHI_RESULT_PTR (PHI), (V))\n-\n-#define PHI_ARG_DEF_PTR(PHI, I)\tgimple_phi_arg_imm_use_ptr ((PHI), (I))\n+/*\n #define PHI_ARG_DEF(PHI, I)\tUSE_FROM_PTR (PHI_ARG_DEF_PTR ((PHI), (I)))\n+*/\n+#define PHI_ARG_DEF_PTR(PHI, I)\tgimple_phi_arg_imm_use_ptr ((PHI), (I))\n+#define PHI_ARG_DEF(PHI, I)\tgimple_phi_arg_def ((PHI), (I))\n #define SET_PHI_ARG_DEF(PHI, I, V)\t\t\t\t\t\\\n \t\t\t\tSET_USE (PHI_ARG_DEF_PTR ((PHI), (I)), (V))\n #define PHI_ARG_DEF_FROM_EDGE(PHI, E)\t\t\t\t\t\\\n@@ -87,136 +89,35 @@ struct GTY(()) ssa_operands {\n #define PHI_ARG_INDEX_FROM_USE(USE)   phi_arg_index_from_use (USE)\n \n \n+extern bool ssa_operands_active (struct function *);\n extern void init_ssa_operands (struct function *fn);\n extern void fini_ssa_operands (void);\n-extern void update_stmt_operands (gimple);\n+extern bool verify_ssa_operands (gimple stmt);\n extern void free_stmt_operands (gimple);\n+extern void update_stmt_operands (gimple);\n+extern void swap_ssa_operands (gimple, tree *, tree *);\n extern bool verify_imm_links (FILE *f, tree var);\n-extern bool verify_ssa_operands (gimple stmt);\n \n-extern void dump_immediate_uses (FILE *file);\n extern void dump_immediate_uses_for (FILE *file, tree var);\n+extern void dump_immediate_uses (FILE *file);\n extern void debug_immediate_uses (void);\n extern void debug_immediate_uses_for (tree var);\n-extern void dump_decl_set (FILE *, bitmap);\n-extern void debug_decl_set (bitmap);\n-\n-extern bool ssa_operands_active (struct function *);\n \n extern bool virtual_operand_p (tree);\n extern void unlink_stmt_vdef (gimple);\n \n-enum ssa_op_iter_type {\n-  ssa_op_iter_none = 0,\n-  ssa_op_iter_tree,\n-  ssa_op_iter_use,\n-  ssa_op_iter_def\n-};\n-\n-/* This structure is used in the operand iterator loops.  It contains the\n-   items required to determine which operand is retrieved next.  During\n-   optimization, this structure is scalarized, and any unused fields are\n-   optimized away, resulting in little overhead.  */\n+/* Return the tree pointed-to by USE.  */\n+static inline tree\n+get_use_from_ptr (use_operand_p use)\n+{\n+  return *(use->use);\n+}\n \n-typedef struct ssa_operand_iterator_d\n+/* Return the tree pointed-to by DEF.  */\n+static inline tree\n+get_def_from_ptr (def_operand_p def)\n {\n-  enum ssa_op_iter_type iter_type;\n-  bool done;\n-  int flags;\n-  unsigned i;\n-  unsigned numops;\n-  use_optype_p uses;\n-  gimple stmt;\n-} ssa_op_iter;\n-\n-/* These flags are used to determine which operands are returned during\n-   execution of the loop.  */\n-#define SSA_OP_USE\t\t0x01\t/* Real USE operands.  */\n-#define SSA_OP_DEF\t\t0x02\t/* Real DEF operands.  */\n-#define SSA_OP_VUSE\t\t0x04\t/* VUSE operands.  */\n-#define SSA_OP_VDEF\t\t0x08\t/* VDEF operands.  */\n-\n-/* These are commonly grouped operand flags.  */\n-#define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE)\n-#define SSA_OP_VIRTUAL_DEFS\t(SSA_OP_VDEF)\n-#define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_DEFS)\n-#define SSA_OP_ALL_USES\t\t(SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n-#define SSA_OP_ALL_DEFS\t\t(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n-#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)\n-\n-/* This macro executes a loop over the operands of STMT specified in FLAG,\n-   returning each operand as a 'tree' in the variable TREEVAR.  ITER is an\n-   ssa_op_iter structure used to control the loop.  */\n-#define FOR_EACH_SSA_TREE_OPERAND(TREEVAR, STMT, ITER, FLAGS)\t\\\n-  for (TREEVAR = op_iter_init_tree (&(ITER), STMT, FLAGS);\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       (void) (TREEVAR = op_iter_next_tree (&(ITER))))\n-\n-/* This macro executes a loop over the operands of STMT specified in FLAG,\n-   returning each operand as a 'use_operand_p' in the variable USEVAR.\n-   ITER is an ssa_op_iter structure used to control the loop.  */\n-#define FOR_EACH_SSA_USE_OPERAND(USEVAR, STMT, ITER, FLAGS)\t\\\n-  for (USEVAR = op_iter_init_use (&(ITER), STMT, FLAGS);\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       USEVAR = op_iter_next_use (&(ITER)))\n-\n-/* This macro executes a loop over the operands of STMT specified in FLAG,\n-   returning each operand as a 'def_operand_p' in the variable DEFVAR.\n-   ITER is an ssa_op_iter structure used to control the loop.  */\n-#define FOR_EACH_SSA_DEF_OPERAND(DEFVAR, STMT, ITER, FLAGS)\t\\\n-  for (DEFVAR = op_iter_init_def (&(ITER), STMT, FLAGS);\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       DEFVAR = op_iter_next_def (&(ITER)))\n-\n-/* This macro will execute a loop over all the arguments of a PHI which\n-   match FLAGS.   A use_operand_p is always returned via USEVAR.  FLAGS\n-   can be either SSA_OP_USE or SSA_OP_VIRTUAL_USES or SSA_OP_ALL_USES.  */\n-#define FOR_EACH_PHI_ARG(USEVAR, STMT, ITER, FLAGS)\t\t\\\n-  for ((USEVAR) = op_iter_init_phiuse (&(ITER), STMT, FLAGS);\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       (USEVAR) = op_iter_next_use (&(ITER)))\n-\n-\n-/* This macro will execute a loop over a stmt, regardless of whether it is\n-   a real stmt or a PHI node, looking at the USE nodes matching FLAGS.  */\n-#define FOR_EACH_PHI_OR_STMT_USE(USEVAR, STMT, ITER, FLAGS)\t\\\n-  for ((USEVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n-\t\t   ? op_iter_init_phiuse (&(ITER), STMT, FLAGS)\t\\\n-\t\t   : op_iter_init_use (&(ITER), STMT, FLAGS));\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       (USEVAR) = op_iter_next_use (&(ITER)))\n-\n-/* This macro will execute a loop over a stmt, regardless of whether it is\n-   a real stmt or a PHI node, looking at the DEF nodes matching FLAGS.  */\n-#define FOR_EACH_PHI_OR_STMT_DEF(DEFVAR, STMT, ITER, FLAGS)\t\\\n-  for ((DEFVAR) = (gimple_code (STMT) == GIMPLE_PHI \t\t\\\n-\t\t   ? op_iter_init_phidef (&(ITER), STMT, FLAGS)\t\\\n-\t\t   : op_iter_init_def (&(ITER), STMT, FLAGS));\t\\\n-       !op_iter_done (&(ITER));\t\t\t\t\t\\\n-       (DEFVAR) = op_iter_next_def (&(ITER)))\n-\n-/* This macro returns an operand in STMT as a tree if it is the ONLY\n-   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n-   FLAGS, then NULL_TREE is returned.  */\n-#define SINGLE_SSA_TREE_OPERAND(STMT, FLAGS)\t\t\t\\\n-  single_ssa_tree_operand (STMT, FLAGS)\n-\n-/* This macro returns an operand in STMT as a use_operand_p if it is the ONLY\n-   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n-   FLAGS, then NULL_USE_OPERAND_P is returned.  */\n-#define SINGLE_SSA_USE_OPERAND(STMT, FLAGS)\t\t\t\\\n-  single_ssa_use_operand (STMT, FLAGS)\n-\n-/* This macro returns an operand in STMT as a def_operand_p if it is the ONLY\n-   operand matching FLAGS.  If there are 0 or more than 1 operand matching\n-   FLAGS, then NULL_DEF_OPERAND_P is returned.  */\n-#define SINGLE_SSA_DEF_OPERAND(STMT, FLAGS)\t\t\t\\\n-  single_ssa_def_operand (STMT, FLAGS)\n-\n-/* This macro returns TRUE if there are no operands matching FLAGS in STMT.  */\n-#define ZERO_SSA_OPERANDS(STMT, FLAGS) \tzero_ssa_operands (STMT, FLAGS)\n-\n-/* This macro counts the number of operands in STMT matching FLAGS.  */\n-#define NUM_SSA_OPERANDS(STMT, FLAGS)\tnum_ssa_operands (STMT, FLAGS)\n+  return *def;\n+}\n \n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "6859518811cef440c4feffd46f0429666be0fa02", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -3580,9 +3580,9 @@ linearize_expr_tree (vec<operand_entry_t> *ops, gimple stmt,\n \t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n \n-      swap_tree_operands (stmt,\n-\t\t\t  gimple_assign_rhs1_ptr (stmt),\n-\t\t\t  gimple_assign_rhs2_ptr (stmt));\n+      swap_ssa_operands (stmt,\n+\t\t\t gimple_assign_rhs1_ptr (stmt),\n+\t\t\t gimple_assign_rhs2_ptr (stmt));\n       update_stmt (stmt);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3649,9 +3649,9 @@ repropagate_negates (void)\n \t     to force the negated operand to the RHS of the PLUS_EXPR.  */\n \t  if (gimple_assign_rhs1 (user) == negate)\n \t    {\n-\t      swap_tree_operands (user,\n-\t\t\t\t  gimple_assign_rhs1_ptr (user),\n-\t\t\t\t  gimple_assign_rhs2_ptr (user));\n+\t      swap_ssa_operands (user,\n+\t\t\t\t gimple_assign_rhs1_ptr (user),\n+\t\t\t\t gimple_assign_rhs2_ptr (user));\n \t    }\n \n \t  /* Now transform the PLUS_EXPR into a MINUS_EXPR and replace"}, {"sha": "5ec7007ee926b0ec898e2c5aedbedaba94f7ceaf", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -20,8 +20,13 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_H\n #define GCC_TREE_SSA_H\n \n-#include \"tree-flow.h\"\n+#include \"gimple.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-phinodes.h\"\n+#include \"gimple-ssa.h\"\n+#include \"ssa-iterators.h\"\n #include \"tree-ssanames.h\"\n+#include \"tree-flow.h\"\n \n /* Mapping for redirected edges.  */\n struct _edge_var_map {"}, {"sha": "638b981d5e77d0f4e1748002dd73d30006d6d8ca", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80560f9521f81ae2c50b52b091b4caaf7d3d4397/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=80560f9521f81ae2c50b52b091b4caaf7d3d4397", "patch": "@@ -967,9 +967,9 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n \t\t   || code == POINTER_PLUS_EXPR\n \t\t   || code == MULT_EXPR)\n \t\t  && CONSTANT_CLASS_P (gimple_assign_rhs1 (stmt)))\n-\t\tswap_tree_operands (stmt,\n-\t\t\t\t    gimple_assign_rhs1_ptr (stmt),\n-\t\t\t\t    gimple_assign_rhs2_ptr (stmt));\n+\t\tswap_ssa_operands (stmt,\n+\t\t\t\t   gimple_assign_rhs1_ptr (stmt),\n+\t\t\t\t   gimple_assign_rhs2_ptr (stmt));\n \t    }\n \n \t  /* Free stmt_vec_info.  */\n@@ -2056,9 +2056,9 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple phi, gimple first_stmt)\n                   dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n-\t      swap_tree_operands (next_stmt,\n-\t \t\t          gimple_assign_rhs1_ptr (next_stmt),\n-                                  gimple_assign_rhs2_ptr (next_stmt));\n+\t      swap_ssa_operands (next_stmt,\n+\t \t\t         gimple_assign_rhs1_ptr (next_stmt),\n+                                 gimple_assign_rhs2_ptr (next_stmt));\n \t      update_stmt (next_stmt);\n \n \t      if (CONSTANT_CLASS_P (gimple_assign_rhs1 (next_stmt)))\n@@ -2488,8 +2488,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \t    report_vect_op (MSG_NOTE, def_stmt,\n \t  \t            \"detected reduction: need to swap operands: \");\n \n-          swap_tree_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n- \t\t\t      gimple_assign_rhs2_ptr (def_stmt));\n+          swap_ssa_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n+ \t\t\t     gimple_assign_rhs2_ptr (def_stmt));\n \n \t  if (CONSTANT_CLASS_P (gimple_assign_rhs1 (def_stmt)))\n \t    LOOP_VINFO_OPERANDS_SWAPPED (loop_info) = true;"}]}