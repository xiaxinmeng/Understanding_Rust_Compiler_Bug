{"sha": "57e563ac847e869fbe565e48c16183511a6c5863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlNTYzYWM4NDdlODY5ZmJlNTY1ZTQ4YzE2MTgzNTExYTZjNTg2Mw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-05-03T16:41:39Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-05-03T16:41:39Z"}, "message": "call_summary to keep info about cgraph_edges\n\n2017-05-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* symbol-summary.h (function_summary): New method exists.\n\t(function_summary::symtab_removal): Deallocate through release.\n\t(call_summary): New class.\n\t(gt_ggc_mx): New overload.\n\t(gt_pch_nx): Likewise.\n\t(gt_pch_nx): Likewise.\n\nFrom-SVN: r247557", "tree": {"sha": "28607745ca2eec66383087108228afea236347be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28607745ca2eec66383087108228afea236347be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57e563ac847e869fbe565e48c16183511a6c5863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e563ac847e869fbe565e48c16183511a6c5863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57e563ac847e869fbe565e48c16183511a6c5863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e563ac847e869fbe565e48c16183511a6c5863/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a26dfc815e601a6377fa17b82c37fe3dbc5cbb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a26dfc815e601a6377fa17b82c37fe3dbc5cbb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a26dfc815e601a6377fa17b82c37fe3dbc5cbb3"}], "stats": {"total": 223, "additions": 219, "deletions": 4}, "files": [{"sha": "1fac63cf0747df9719435aa5e3d8b4e035e889e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e563ac847e869fbe565e48c16183511a6c5863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e563ac847e869fbe565e48c16183511a6c5863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57e563ac847e869fbe565e48c16183511a6c5863", "patch": "@@ -1,3 +1,12 @@\n+2017-05-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* symbol-summary.h (function_summary): New method exists.\n+\t(function_summary::symtab_removal): Deallocate through release.\n+\t(call_summary): New class.\n+\t(gt_ggc_mx): New overload.\n+\t(gt_pch_nx): Likewise.\n+\t(gt_pch_nx): Likewise.\n+\n 2017-05-03  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/78496"}, {"sha": "e672c818b746a783f420c93f3c67fd9f9494a82b", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 210, "deletions": 4, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e563ac847e869fbe565e48c16183511a6c5863/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e563ac847e869fbe565e48c16183511a6c5863/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=57e563ac847e869fbe565e48c16183511a6c5863", "patch": "@@ -126,6 +126,12 @@ class GTY((user)) function_summary <T *>\n     return m_map.elements ();\n   }\n \n+  /* Return true if a summary for the given NODE already exists.  */\n+  bool exists (cgraph_node *node)\n+  {\n+    return m_map.get (node->summary_uid) != NULL;\n+  }\n+\n   /* Enable insertion hook invocation.  */\n   void enable_insertion_hook ()\n   {\n@@ -160,10 +166,7 @@ class GTY((user)) function_summary <T *>\n     if (v)\n       {\n \tsummary->remove (node, *v);\n-\n-\tif (!summary->m_ggc)\n-\t  delete (*v);\n-\n+\tsummary->release (*v);\n \tsummary->m_map.remove (summary_uid);\n       }\n   }\n@@ -251,4 +254,207 @@ gt_pch_nx(function_summary<T *>* const& summary, gt_pointer_operator op,\n   gt_pch_nx (&summary->m_map, op, cookie);\n }\n \n+/* An impossible class templated by non-pointers so, which makes sure that only\n+   summaries gathering pointers can be created.  */\n+\n+template <class T>\n+class call_summary\n+{\n+private:\n+  call_summary();\n+};\n+\n+/* Class to store auxiliary information about call graph edges.  */\n+\n+template <class T>\n+class GTY((user)) call_summary <T *>\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  call_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n+    m_map (13, ggc), m_released (false), m_symtab (symtab)\n+  {\n+    m_symtab_removal_hook =\n+      symtab->add_edge_removal_hook\n+      (call_summary::symtab_removal, this);\n+    m_symtab_duplication_hook =\n+      symtab->add_edge_duplication_hook\n+      (call_summary::symtab_duplication, this);\n+  }\n+\n+  /* Destructor.  */\n+  virtual ~call_summary ()\n+  {\n+    release ();\n+  }\n+\n+  /* Destruction method that can be called for GGT purpose.  */\n+  void release ()\n+  {\n+    if (m_released)\n+      return;\n+\n+    m_symtab->remove_edge_removal_hook (m_symtab_removal_hook);\n+    m_symtab->remove_edge_duplication_hook (m_symtab_duplication_hook);\n+\n+    /* Release all summaries.  */\n+    typedef typename hash_map <map_hash, T *>::iterator map_iterator;\n+    for (map_iterator it = m_map.begin (); it != m_map.end (); ++it)\n+      release ((*it).second);\n+\n+    m_released = true;\n+  }\n+\n+  /* Traverses all summarys with a function F called with\n+     ARG as argument.  */\n+  template<typename Arg, bool (*f)(const T &, Arg)>\n+  void traverse (Arg a) const\n+  {\n+    m_map.traverse <f> (a);\n+  }\n+\n+  /* Basic implementation of removal operation.  */\n+  virtual void remove (cgraph_edge *, T *) {}\n+\n+  /* Basic implementation of duplication operation.  */\n+  virtual void duplicate (cgraph_edge *, cgraph_edge *, T *, T *) {}\n+\n+  /* Allocates new data that are stored within map.  */\n+  T* allocate_new ()\n+  {\n+    /* Call gcc_internal_because we do not want to call finalizer for\n+       a type T.  We call dtor explicitly.  */\n+    return m_ggc ? new (ggc_internal_alloc (sizeof (T))) T () : new T () ;\n+  }\n+\n+  /* Release an item that is stored within map.  */\n+  void release (T *item)\n+  {\n+    if (m_ggc)\n+      {\n+\titem->~T ();\n+\tggc_free (item);\n+      }\n+    else\n+      delete item;\n+  }\n+\n+  /* Getter for summary callgraph edge pointer.  */\n+  T* get (cgraph_edge *edge)\n+  {\n+    return get (hashable_uid (edge));\n+  }\n+\n+  /* Return number of elements handled by data structure.  */\n+  size_t elements ()\n+  {\n+    return m_map.elements ();\n+  }\n+\n+  /* Return true if a summary for the given EDGE already exists.  */\n+  bool exists (cgraph_edge *edge)\n+  {\n+    return m_map.get (hashable_uid (edge)) != NULL;\n+  }\n+\n+  /* Symbol removal hook that is registered to symbol table.  */\n+  static void symtab_removal (cgraph_edge *edge, void *data)\n+  {\n+    call_summary *summary = (call_summary <T *> *) (data);\n+\n+    int h_uid = summary->hashable_uid (edge);\n+    T **v = summary->m_map.get (h_uid);\n+\n+    if (v)\n+      {\n+\tsummary->remove (edge, *v);\n+\tsummary->release (*v);\n+\tsummary->m_map.remove (h_uid);\n+      }\n+  }\n+\n+  /* Symbol duplication hook that is registered to symbol table.  */\n+  static void symtab_duplication (cgraph_edge *edge1, cgraph_edge *edge2,\n+\t\t\t\t  void *data)\n+  {\n+    call_summary *summary = (call_summary <T *> *) (data);\n+    T **v = summary->m_map.get (summary->hashable_uid (edge1));\n+\n+    if (v)\n+      {\n+\t/* This load is necessary, because we insert a new value!  */\n+\tT *data = *v;\n+\tT *duplicate = summary->allocate_new ();\n+\tsummary->m_map.put (summary->hashable_uid (edge2), duplicate);\n+\tsummary->duplicate (edge1, edge2, data, duplicate);\n+      }\n+  }\n+\n+protected:\n+  /* Indication if we use ggc summary.  */\n+  bool m_ggc;\n+\n+private:\n+  typedef int_hash <int, 0, -1> map_hash;\n+\n+  /* Getter for summary callgraph ID.  */\n+  T* get (int uid)\n+  {\n+    bool existed;\n+    T **v = &m_map.get_or_insert (uid, &existed);\n+    if (!existed)\n+      *v = allocate_new ();\n+\n+    return *v;\n+  }\n+\n+  /* Get a hashable uid of EDGE.  */\n+  int hashable_uid (cgraph_edge *edge)\n+  {\n+    /* Edge uids start at zero which our hash_map does not like.  */\n+    return edge->uid + 1;\n+  }\n+\n+  /* Main summary store, where summary ID is used as key.  */\n+  hash_map <map_hash, T *> m_map;\n+  /* Internal summary removal hook pointer.  */\n+  cgraph_edge_hook_list *m_symtab_removal_hook;\n+  /* Internal summary duplication hook pointer.  */\n+  cgraph_2edge_hook_list *m_symtab_duplication_hook;\n+  /* Indicates if the summary is released.  */\n+  bool m_released;\n+  /* Symbol table the summary is registered to.  */\n+  symbol_table *m_symtab;\n+\n+  template <typename U> friend void gt_ggc_mx (call_summary <U *> * const &);\n+  template <typename U> friend void gt_pch_nx (call_summary <U *> * const &);\n+  template <typename U> friend void gt_pch_nx (call_summary <U *> * const &,\n+      gt_pointer_operator, void *);\n+};\n+\n+template <typename T>\n+void\n+gt_ggc_mx(call_summary<T *>* const &summary)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_ggc_mx (&summary->m_map);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx(call_summary<T *>* const &summary)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_pch_nx (&summary->m_map);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx(call_summary<T *>* const& summary, gt_pointer_operator op,\n+\t  void *cookie)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_pch_nx (&summary->m_map, op, cookie);\n+}\n+\n #endif  /* GCC_SYMBOL_SUMMARY_H  */"}]}