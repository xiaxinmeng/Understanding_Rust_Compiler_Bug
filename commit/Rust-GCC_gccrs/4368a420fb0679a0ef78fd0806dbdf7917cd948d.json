{"sha": "4368a420fb0679a0ef78fd0806dbdf7917cd948d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2OGE0MjBmYjA2NzlhMGVmNzhmZDA4MDZkYmRmNzkxN2NkOTQ4ZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-07-11T19:41:17Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-07-11T19:41:17Z"}, "message": "predicates.md (x86_64_immediate_operand): Hoist common subexpressions.\n\n\t* config/i386/predicates.md (x86_64_immediate_operand) <case CONST>:\n\tHoist common subexpressions.\n\t(x86_64_zext_immediate_operand) <case CONST>: Ditto.\n\nFrom-SVN: r238224", "tree": {"sha": "a7d83f37b37fec412fab672c17d78e607013819e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7d83f37b37fec412fab672c17d78e607013819e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4368a420fb0679a0ef78fd0806dbdf7917cd948d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4368a420fb0679a0ef78fd0806dbdf7917cd948d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4368a420fb0679a0ef78fd0806dbdf7917cd948d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4368a420fb0679a0ef78fd0806dbdf7917cd948d/comments", "author": null, "committer": null, "parents": [{"sha": "7f0d7d6155b6ef87b9a8e404a556222d22f844f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0d7d6155b6ef87b9a8e404a556222d22f844f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f0d7d6155b6ef87b9a8e404a556222d22f844f8"}], "stats": {"total": 62, "additions": 35, "deletions": 27}, "files": [{"sha": "0f8fb53923529f34fc0c4c7f2b88fe3883c94839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4368a420fb0679a0ef78fd0806dbdf7917cd948d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4368a420fb0679a0ef78fd0806dbdf7917cd948d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4368a420fb0679a0ef78fd0806dbdf7917cd948d", "patch": "@@ -1,3 +1,9 @@\n+2016-07-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/predicates.md (x86_64_immediate_operand) <case CONST>:\n+\tHoist common subexpressions.\n+\t(x86_64_zext_immediate_operand) <case CONST>: Ditto.\n+\n 2016-07-11  Pat Haugen  <pthaugen@us.ibm.com>\n \n \tPR target/71800\n@@ -327,7 +333,7 @@\n \n 2016-07-06  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n-\tPR target/50739\t\n+\tPR target/50739\n \t* config/avr/avr.c (avr_asm_select_section): Strip off\n \tSECTION_DECLARED from flags when calling get_section.\n \n@@ -528,8 +534,9 @@\n \t(TARGET_SIMD_F16INST): New.\n \t* config/aarch64/aarch64-option-extensions.def (\"fp16\"): New entry.\n \t(\"fp\"): Disabling \"fp\" also disables \"fp16\".\n-\t* config/aarch64/aarch64-c.c (arch64_update_cpp_builtins): Conditionally define\n-\t__ARM_FEATURE_FP16_SCALAR_ARITHMETIC and __ARM_FEATURE_FP16_VECTOR_ARITHMETIC.\n+\t* config/aarch64/aarch64-c.c (arch64_update_cpp_builtins):\n+\tConditionally define __ARM_FEATURE_FP16_SCALAR_ARITHMETIC\n+\tand __ARM_FEATURE_FP16_VECTOR_ARITHMETIC.\n \t* doc/invoke.texi (AArch64 Options): Document \"armv8.2-a\" and \"fp16\".\n \n 2016-07-04  Jan Beulich  <jbeulich@suse.com>\n@@ -557,8 +564,8 @@\n 2016-07-01  Peter Bergner  <bergner@vnet.ibm.com>\n \n \tPR target/71698\n-\t* config/rs6000/rs6000.c (rs6000_secondary_reload_simple_move): Disallow\n-\tTDmode values.\n+\t* config/rs6000/rs6000.c (rs6000_secondary_reload_simple_move):\n+\tDisallow TDmode values.\n \n 2016-07-01  Alan Modra  <amodra@gmail.com>\n \n@@ -686,7 +693,7 @@\n \t(cortexa73_tunings): Use cortexa57_branch_cost.\n \n 2016-06-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n-            James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/arm_neon.h (vcopyq_lane_f32, vcopyq_lane_f64,\n \tvcopyq_lane_p8, vcopyq_lane_p16, vcopyq_lane_s8, vcopyq_lane_s16,\n@@ -704,7 +711,7 @@\n \tNew intrinsics.\n \n 2016-06-30  James Greenhalgh  <james.greenhalgh@arm.com>\n-            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (*aarch64_simd_vec_copy_lane<mode>):\n \tNew define_insn.\n@@ -735,8 +742,7 @@\n \t* params.c: Include spellcheck.h.\n \t(find_param_fuzzy): New function.\n \t* params.h (find_param_fuzzy): New prototype.\n-\t* spellcheck.c (struct edit_distance_traits<const char *>): Move\n-\tto...\n+\t* spellcheck.c (struct edit_distance_traits<const char *>): Move to...\n \t* spellcheck.h (struct edit_distance_traits<const char *>):\n \t...here.\n \n@@ -795,8 +801,7 @@\n 2016-06-29  Martin Liska  <mliska@suse.cz>\n \n \tPR middle-end/71585\n-\t* common.opt (flag_stack_protect): Mark the flag as optimization\n-\tflag.\n+\t* common.opt (flag_stack_protect): Mark the flag as optimization flag.\n \t* ipa-inline-transform.c (inline_call): Remove unnecessary call\n \tof build_optimization_node.\n "}, {"sha": "6854c37a74f70b697e00cf6dde01d268cf635554", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4368a420fb0679a0ef78fd0806dbdf7917cd948d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4368a420fb0679a0ef78fd0806dbdf7917cd948d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=4368a420fb0679a0ef78fd0806dbdf7917cd948d", "patch": "@@ -205,7 +205,11 @@\n \t    return false;\n \t  if (!CONST_INT_P (op2))\n \t    return false;\n+\n \t  offset = trunc_int_for_mode (INTVAL (op2), DImode);\n+\t  if (trunc_int_for_mode (offset, SImode) != offset)\n+\t    return false;\n+\n \t  switch (GET_CODE (op1))\n \t    {\n \t    case SYMBOL_REF:\n@@ -224,29 +228,25 @@\n \t      if ((ix86_cmodel == CM_SMALL\n \t\t   || (ix86_cmodel == CM_MEDIUM\n \t\t       && !SYMBOL_REF_FAR_ADDR_P (op1)))\n-\t\t  && offset < 16*1024*1024\n-\t\t  && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t  && offset < 16*1024*1024)\n \t\treturn true;\n \t      /* For CM_KERNEL we know that all object resist in the\n \t\t negative half of 32bits address space.  We may not\n \t\t accept negative offsets, since they may be just off\n \t\t and we may accept pretty large positive ones.  */\n \t      if (ix86_cmodel == CM_KERNEL\n-\t\t  && offset > 0\n-\t\t  && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t  && offset > 0)\n \t\treturn true;\n \t      break;\n \n \t    case LABEL_REF:\n \t      /* These conditions are similar to SYMBOL_REF ones, just the\n \t\t constraints for code models differ.  */\n \t      if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM)\n-\t\t  && offset < 16*1024*1024\n-\t\t  && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t  && offset < 16*1024*1024)\n \t\treturn true;\n \t      if (ix86_cmodel == CM_KERNEL\n-\t\t  && offset > 0\n-\t\t  && trunc_int_for_mode (offset, SImode) == offset)\n+\t\t  && offset > 0)\n \t\treturn true;\n \t      break;\n \n@@ -255,8 +255,7 @@\n \t\t{\n \t\tcase UNSPEC_DTPOFF:\n \t\tcase UNSPEC_NTPOFF:\n-\t\t  if (trunc_int_for_mode (offset, SImode) == offset)\n-\t\t    return true;\n+\t\t  return true;\n \t\t}\n \t      break;\n \n@@ -307,9 +306,17 @@\n \t{\n \t  rtx op1 = XEXP (XEXP (op, 0), 0);\n \t  rtx op2 = XEXP (XEXP (op, 0), 1);\n+\t  HOST_WIDE_INT offset;\n \n \t  if (ix86_cmodel == CM_LARGE)\n \t    return false;\n+\t  if (!CONST_INT_P (op2))\n+\t    return false;\n+\n+\t  offset = trunc_int_for_mode (INTVAL (op2), DImode);\n+\t  if (trunc_int_for_mode (offset, SImode) != offset)\n+\t    return false;\n+\n \t  switch (GET_CODE (op1))\n \t    {\n \t    case SYMBOL_REF:\n@@ -328,9 +335,7 @@\n \t      if ((ix86_cmodel == CM_SMALL\n \t\t   || (ix86_cmodel == CM_MEDIUM\n \t\t       && !SYMBOL_REF_FAR_ADDR_P (op1)))\n-\t\t  && CONST_INT_P (op2)\n-\t\t  && trunc_int_for_mode (INTVAL (op2), DImode) > -0x10000\n-\t\t  && trunc_int_for_mode (INTVAL (op2), SImode) == INTVAL (op2))\n+\t\t  && offset > -0x10000)\n \t\treturn true;\n \t      /* ??? For the kernel, we may accept adjustment of\n \t\t -0x10000000, since we know that it will just convert\n@@ -342,9 +347,7 @@\n \t      /* These conditions are similar to SYMBOL_REF ones, just the\n \t\t constraints for code models differ.  */\n \t      if ((ix86_cmodel == CM_SMALL || ix86_cmodel == CM_MEDIUM)\n-\t\t  && CONST_INT_P (op2)\n-\t\t  && trunc_int_for_mode (INTVAL (op2), DImode) > -0x10000\n-\t\t  && trunc_int_for_mode (INTVAL (op2), SImode) == INTVAL (op2))\n+\t\t  && offset > -0x10000)\n \t\treturn true;\n \t      break;\n "}]}