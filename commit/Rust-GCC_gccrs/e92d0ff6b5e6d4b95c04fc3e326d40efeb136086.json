{"sha": "e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkyZDBmZjZiNWU2ZDRiOTVjMDRmYzNlMzI2ZDQwZWZlYjEzNjA4Ng==", "commit": {"author": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-08-19T14:24:56Z"}, "committer": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-08-21T05:03:54Z"}, "message": "analyzer: Fix PR analyzer/101980\n\n2021-08-19  Ankur Saini  <arsenic@sourceware.org>\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/101980\n\t* diagnostic-manager.cc\n\t(diagnostic_manager::prune_for_sm_diagnostic)<case EK_CALL_EDGE>: Use\n\tcaller_model only when the supergraph_edge doesn't exixt.\n\t(diagnostic_manager::prune_for_sm_diagnostic)<case EK_RETURN_EDGE>:\n\tLikewise.\n\t* engine.cc (exploded_graph::create_dynamic_call): Rename to...\n\t(exploded_graph::maybe_create_dynamic_call): ...this, return call\n\tcreation status.\n\t(exploded_graph::process_node): Handle calls which were not dynamically\n\tdiscovered.\n\t* exploded-graph.h (exploded_graph::create_dynamic_call): Rename to...\n\t(exploded_graph::maybe_create_dynamic_call): ...this.\n\t* region-model.cc (region_model::update_for_gcall): New param, use it\n\tto push call to frame.\n\t(region_model::update_for_call_superedge): Pass callee function to\n\tupdate_for_gcall.\n\t* region-model.h (region_model::update_for_gcall): New param.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/101980\n\t* gcc.dg/analyzer/function-ptr-2.c : Add issue for double 'free'.\n\t* gcc.dg/analyzer/malloc-callbacks.c : Fix xfail testcase.", "tree": {"sha": "9e103620d3d1858499117a8e3b7126333f0f5f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e103620d3d1858499117a8e3b7126333f0f5f41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/comments", "author": null, "committer": null, "parents": [{"sha": "7c9e1645836d7746838acebb7018b1774490ab5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c9e1645836d7746838acebb7018b1774490ab5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c9e1645836d7746838acebb7018b1774490ab5c"}], "stats": {"total": 130, "additions": 85, "deletions": 45}, "files": [{"sha": "89b5d1e3c3c786527ab6c26cd8325d65037a7a48", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -2099,7 +2099,22 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t      = event->m_eedge.m_src->get_state ().m_region_model;\n \t    tree callee_var = callee_model->get_representative_tree (sval);\n \t    callsite_expr expr;\n-\t    tree caller_var = caller_model->get_representative_tree (sval);\n+\n+\t    tree caller_var;\n+            if(event->m_sedge)\n+              {\n+                const callgraph_superedge& cg_superedge\n+                  = event->get_callgraph_superedge ();\n+                if (cg_superedge.m_cedge)\n+\t          caller_var\n+\t            = cg_superedge.map_expr_from_callee_to_caller (callee_var,\n+                                                                   &expr);\n+                else\n+                  callee_var = callee_model->get_representative_tree (sval);\n+              }\n+            else\n+\t      caller_var = caller_model->get_representative_tree (sval);\n+\n \t    if (caller_var)\n \t      {\n \t\tif (get_logger ())\n@@ -2121,11 +2136,28 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t    if (sval)\n \t      {\n \t\treturn_event *event = (return_event *)base_event;\n+                const region_model *caller_model\n+                  = event->m_eedge.m_dest->get_state ().m_region_model;\n+                tree caller_var = caller_model->get_representative_tree (sval);\n+                const region_model *callee_model\n+                  = event->m_eedge.m_src->get_state ().m_region_model;\n \t\tcallsite_expr expr;\n \n-\t\tconst region_model *callee_model\n-\t      \t  = event->m_eedge.m_src->get_state ().m_region_model;\n-\t\ttree callee_var = callee_model->get_representative_tree (sval);\n+                tree callee_var;\n+                if (event->m_sedge)\n+                  {\n+                    const callgraph_superedge& cg_superedge\n+                      = event->get_callgraph_superedge ();\n+                    if (cg_superedge.m_cedge)\n+                      callee_var\n+                        = cg_superedge.map_expr_from_caller_to_callee (caller_var,\n+                                                                       &expr);\n+                    else\n+                      callee_var = callee_model->get_representative_tree (sval);\n+                  }\n+                else\n+                  callee_var = callee_model->get_representative_tree (sval);\n+\n \t\tif (callee_var)\n \t\t  {\n \t\t    if (get_logger ())"}, {"sha": "e66ca4e42fdeac3abe4a8db50160cbd3aba2ea22", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -3033,14 +3033,14 @@ state_change_requires_new_enode_p (const program_state &old_state,\n    Some example such calls are dynamically dispatched calls to virtual\n    functions or calls that happen via function pointer.  */\n \n-void\n-exploded_graph::create_dynamic_call (const gcall *call,\n-                                     tree fn_decl,\n-                                     exploded_node *node,\n-                                     program_state next_state,\n-                                     program_point &next_point,\n-                                     uncertainty_t *uncertainty,\n-                                     logger *logger)\n+bool\n+exploded_graph::maybe_create_dynamic_call (const gcall *call,\n+                                           tree fn_decl,\n+                                           exploded_node *node,\n+                                           program_state next_state,\n+                                           program_point &next_point,\n+                                           uncertainty_t *uncertainty,\n+                                           logger *logger)\n {\n   LOG_FUNC (logger);\n \n@@ -3049,8 +3049,8 @@ exploded_graph::create_dynamic_call (const gcall *call,\n   if (fun)\n     {\n       const supergraph &sg = this->get_supergraph ();\n-      supernode * sn_entry = sg.get_node_for_function_entry (fun);\n-      supernode * sn_exit = sg.get_node_for_function_exit (fun);\n+      supernode *sn_entry = sg.get_node_for_function_entry (fun);\n+      supernode *sn_exit = sg.get_node_for_function_exit (fun);\n \n       program_point new_point\n         = program_point::before_supernode (sn_entry,\n@@ -3075,8 +3075,10 @@ exploded_graph::create_dynamic_call (const gcall *call,\n           if (enode)\n             add_edge (node,enode, NULL,\n                       new dynamic_call_info_t (call));\n+          return true;\n         }\n-     }\n+    }\n+  return false;\n }\n \n /* The core of exploded_graph::process_worklist (the main analysis loop),\n@@ -3338,22 +3340,23 @@ exploded_graph::process_node (exploded_node *node)\n                                                 point.get_stmt());\n \n                 region_model *model = state.m_region_model;\n+                bool call_discovered = false;\n \n                 if (tree fn_decl = model->get_fndecl_for_call(call,&ctxt))\n-                  create_dynamic_call (call,\n-                                       fn_decl,\n-                                       node,\n-                                       next_state,\n-                                       next_point,\n-                                       &uncertainty,\n-                                       logger);\n-                else\n+                  call_discovered = maybe_create_dynamic_call (call,\n+                                                               fn_decl,\n+                                                               node,\n+                                                               next_state,\n+                                                               next_point,\n+                                                               &uncertainty,\n+                                                               logger);\n+                if (!call_discovered)\n                   {\n-                     /* An unknown function was called at this point, in such\n-                        case, don't terminate the analysis of the current\n-                        function.\n+                     /* An unknown function or a special function was called \n+                        at this point, in such case, don't terminate the \n+                        analysis of the current function.\n \n-                        The analyzer handles calls to unknown functions while\n+                        The analyzer handles calls to such functions while\n                         analysing the stmt itself, so the the function call\n                         must have been handled by the anlyzer till now.  */\n                      exploded_node *next"}, {"sha": "6890e84f9855158d19ed3a9289cd625103b88eb5", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -816,13 +816,13 @@ class exploded_graph : public digraph<eg_traits>\n   bool maybe_process_run_of_before_supernode_enodes (exploded_node *node);\n   void process_node (exploded_node *node);\n \n-  void create_dynamic_call (const gcall *call,\n-                            tree fn_decl,\n-                            exploded_node *node,\n-                            program_state next_state,\n-                            program_point &next_point,\n-                            uncertainty_t *uncertainty,\n-                            logger *logger);\n+  bool maybe_create_dynamic_call (const gcall *call,\n+                                  tree fn_decl,\n+                                  exploded_node *node,\n+                                  program_state next_state,\n+                                  program_point &next_point,\n+                                  uncertainty_t *uncertainty,\n+                                  logger *logger);\n \n   exploded_node *get_or_create_node (const program_point &point,\n \t\t\t\t     const program_state &state,"}, {"sha": "9870007e57e94e947c43a58b167e9472ccb558b3", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -3178,7 +3178,8 @@ region_model::maybe_update_for_edge (const superedge &edge,\n \n void\n region_model::update_for_gcall (const gcall *call_stmt,\n-\t\t\t\tregion_model_context *ctxt)\n+\t\t\t\tregion_model_context *ctxt,\n+\t\t\t\tfunction *callee)\n {\n   /* Build a vec of argument svalues, using the current top\n      frame for resolving tree expressions.  */\n@@ -3190,10 +3191,14 @@ region_model::update_for_gcall (const gcall *call_stmt,\n       arg_svals.quick_push (get_rvalue (arg, ctxt));\n     }\n \n-  /* Get the function * from the call.  */\n-  tree fn_decl = get_fndecl_for_call (call_stmt,ctxt);\n-  function *fun = DECL_STRUCT_FUNCTION (fn_decl);\n-  push_frame (fun, &arg_svals, ctxt);\n+  if(!callee)\n+  {\n+    /* Get the function * from the gcall.  */\n+    tree fn_decl = get_fndecl_for_call (call_stmt,ctxt);\n+    callee = DECL_STRUCT_FUNCTION (fn_decl);\n+  }\n+\n+  push_frame (callee, &arg_svals, ctxt);\n }\n \n /* Pop the top-most frame_region from the stack, and copy the return\n@@ -3228,7 +3233,7 @@ region_model::update_for_call_superedge (const call_superedge &call_edge,\n \t\t\t\t\t region_model_context *ctxt)\n {\n   const gcall *call_stmt = call_edge.get_call_stmt ();\n-  update_for_gcall (call_stmt,ctxt);\n+  update_for_gcall (call_stmt, ctxt, call_edge.get_callee_function ());\n }\n \n /* Extract calling information from the return superedge and update the model "}, {"sha": "a734f9f7315388e5846e96b8eb3dcaae1fca8308", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -609,7 +609,8 @@ class region_model\n \t\t\t      rejected_constraint **out);\n \n   void update_for_gcall (const gcall *call_stmt,\n-                         region_model_context *ctxt);\n+                         region_model_context *ctxt,\n+                         function *callee = NULL);\n   \n   void update_for_return_gcall (const gcall *call_stmt,\n                                 region_model_context *ctxt);"}, {"sha": "fd25e3be40bebd6c2ec8e85286353d4038e402d0", "filename": "gcc/testsuite/gcc.dg/analyzer/function-ptr-2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -6,9 +6,10 @@ typedef void (*fn_ptr_t) (void *);\n void\n calls_free (void *victim)\n {\n-  free (victim);\n+  free (victim); /* { dg-warning \"double-'free' of 'victim'\" } */\n }\n \n+\n void\n no_op (void *ptr)\n {\n@@ -25,7 +26,6 @@ void test_1 (void *ptr)\n   fn_ptr (ptr);\n   fn_ptr (ptr);\n }\n-// TODO: issue a double-'free' warning at 2nd call to fn_ptr.\n \n /* As above, but with an extra indirection to try to thwart\n    the optimizer.  */\n@@ -41,4 +41,3 @@ void test_2 (void *ptr, fn_ptr_t *fn_ptr)\n   (*fn_ptr) (ptr);\n   (*fn_ptr) (ptr);\n }\n-// TODO: issue a double-'free' warning at 2nd call to fn_ptr."}, {"sha": "53c75fddf849ba66b79686ca714b365d27b47979", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-callbacks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92d0ff6b5e6d4b95c04fc3e326d40efeb136086/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c?ref=e92d0ff6b5e6d4b95c04fc3e326d40efeb136086", "patch": "@@ -69,7 +69,7 @@ int *test_5 (void)\n static void __attribute__((noinline))\n called_by_test_6a (void *ptr)\n {\n-  free (ptr); /* { dg-warning \"double-'free'\" \"\" { xfail *-*-* } } */\n+  free (ptr); /* { dg-warning \"double-'free'\"} */\n }\n \n static deallocator_t __attribute__((noinline))"}]}