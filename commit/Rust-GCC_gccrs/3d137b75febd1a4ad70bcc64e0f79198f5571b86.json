{"sha": "3d137b75febd1a4ad70bcc64e0f79198f5571b86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QxMzdiNzVmZWJkMWE0YWQ3MGJjYzY0ZTBmNzkxOThmNTU3MWI4Ng==", "commit": {"author": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2020-06-01T07:15:31Z"}, "committer": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2020-09-01T09:57:05Z"}, "message": "Fortran  : ICE on invalid code PR95398\n\nThe CLASS_DATA macro is used to shorten the code accessing the derived\ncomponents of an expressions type specification.  If the type is not\nBT_CLASS the derived pointer is NULL resulting in an ICE.  To avoid\ndereferencing a NULL pointer the type should be BT_CLASS.\n\n2020-09-01  Steven G. Kargl  <kargl@gcc.gnu.org>\n\ngcc/fortran\n\n\tPR fortran/95398\n\t* resolve.c (resolve_select_type): Add check for BT_CLASS\n\ttype before using the CLASS_DATA macro which will have a\n\tNULL pointer to derive components if it isn't BT_CLASS.\n\n2020-09-01  Mark Eggleston  <markeggleston@gcc.gnu.org>\n\ngcc/testsuite\n\n\tPR fortran/95398\n\t* gfortran.dg/pr95398.f90: New test.", "tree": {"sha": "cc417a6b086517635abe9ee0a8373abf575b0c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc417a6b086517635abe9ee0a8373abf575b0c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d137b75febd1a4ad70bcc64e0f79198f5571b86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d137b75febd1a4ad70bcc64e0f79198f5571b86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d137b75febd1a4ad70bcc64e0f79198f5571b86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d137b75febd1a4ad70bcc64e0f79198f5571b86/comments", "author": null, "committer": null, "parents": [{"sha": "d6a05b494b4b714e996a5ca09c5a4a1c41dbd648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a05b494b4b714e996a5ca09c5a4a1c41dbd648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a05b494b4b714e996a5ca09c5a4a1c41dbd648"}], "stats": {"total": 57, "additions": 56, "deletions": 1}, "files": [{"sha": "e4232717e42c4ae3eea49adcdeb3edeb66d5184a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d137b75febd1a4ad70bcc64e0f79198f5571b86/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d137b75febd1a4ad70bcc64e0f79198f5571b86/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3d137b75febd1a4ad70bcc64e0f79198f5571b86", "patch": "@@ -9259,7 +9259,9 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t    ? CLASS_DATA (code->expr2)->ts.u.derived : code->expr2->ts.u.derived;\n \t}\n \n-      if (code->expr2->rank && CLASS_DATA (code->expr1)->as)\n+      if (code->expr2->rank\n+\t  && code->expr1->ts.type == BT_CLASS\n+\t  && CLASS_DATA (code->expr1)->as)\n \tCLASS_DATA (code->expr1)->as->rank = code->expr2->rank;\n \n       /* F2008: C803 The selector expression must not be coindexed.  */"}, {"sha": "81cc076c15c87edf50fc8cdcdae8dbca9dd19b24", "filename": "gcc/testsuite/gfortran.dg/pr95398.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d137b75febd1a4ad70bcc64e0f79198f5571b86/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95398.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d137b75febd1a4ad70bcc64e0f79198f5571b86/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95398.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr95398.f90?ref=3d137b75febd1a4ad70bcc64e0f79198f5571b86", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+\n+program test\n+   implicit none\n+\n+   type :: t1\n+     integer :: i\n+   end type\n+\n+   type, extends(t1) :: t2\n+   end type\n+\n+   class(t1), allocatable :: array1(:,:)\n+   class(t2), allocatable :: array2(:,:)\n+\n+   allocate(array1(3,3))\n+   allocate(array2(3,3))\n+\n+   select type(b => foo(1))\n+      type is (t1)\n+         b%i = 1\n+      type is (t2)\n+         call sub_with_in_and_inout_param(b,b)\n+   end select\n+\n+   contains\n+\n+     function foo(i)\n+       integer :: U(2)\n+       integer :: i\n+       class(t1), POINTER :: foo(:)\n+       ALLOCATE(foo(2))\n+       U = [ 1,2 ]\n+       if (i>0) then\n+         foo => array1(2,U)\n+       else\n+         foo => array2(2,U)\n+       end if\n+     end function\n+\n+     subroutine sub_with_in_and_inout_param(y, z)\n+        type(t2), INTENT(IN) :: y(:)\n+        class(t2), INTENT(INOUT) :: z(:)\n+        z%i = 10\n+     end subroutine\n+\n+end\n+\n+! { dg-error \"cannot be used in a variable definition context .assignment.\"  \" \" { target *-*-* } 21 }\n+! { dg-error \"cannot be used in a variable definition context .actual argument to INTENT = OUT.INOUT.\"  \" \" { target *-*-* } 23 }\n+! { dg-error \"Pointer assignment target is neither TARGET nor POINTER\" \" \" { target *-*-* } 35 }\n+! { dg-error \"Pointer assignment target is neither TARGET nor POINTER\" \" \" { target *-*-* } 37 }\n+"}]}