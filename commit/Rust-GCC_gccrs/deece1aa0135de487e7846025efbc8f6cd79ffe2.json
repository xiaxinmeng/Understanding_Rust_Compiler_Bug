{"sha": "deece1aa0135de487e7846025efbc8f6cd79ffe2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlY2UxYWEwMTM1ZGU0ODdlNzg0NjAyNWVmYmM4ZjZjZDc5ZmZlMg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-01-26T19:33:16Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2018-01-26T19:33:16Z"}, "message": "re PR fortran/83998 (ICE in gfc_conv_intrinsic_dot_product, at fortran/trans-intrinsic.c:4403)\n\n2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/83998\n\t* simplify.c (compute_dot_product):  Initialize result to INTEGER(1) 0\n\tor .false.  The summation does the correct type conversion.\n\t(gfc_simplify_dot_product): Special case zero-sized arrays.\n\n\n2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/83998\n\t* gfortran.dg/dot_product_4.f90\n\nFrom-SVN: r257104", "tree": {"sha": "a9c519ee43c035b61abb368af203c86e9ef79138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c519ee43c035b61abb368af203c86e9ef79138"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deece1aa0135de487e7846025efbc8f6cd79ffe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deece1aa0135de487e7846025efbc8f6cd79ffe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deece1aa0135de487e7846025efbc8f6cd79ffe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deece1aa0135de487e7846025efbc8f6cd79ffe2/comments", "author": null, "committer": null, "parents": [{"sha": "de47f61f5e441f6ce498af603cbe35d86b556262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de47f61f5e441f6ce498af603cbe35d86b556262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de47f61f5e441f6ce498af603cbe35d86b556262"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "659e8acfcc1a7c8da3c8c0a77205893c37f455ef", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=deece1aa0135de487e7846025efbc8f6cd79ffe2", "patch": "@@ -1,3 +1,10 @@\n+2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/83998\n+\t* simplify.c (compute_dot_product):  Initialize result to INTEGER(1) 0\n+\tor .false.  The summation does the correct type conversion.\n+\t(gfc_simplify_dot_product): Special case zero-sized arrays.\n+\n 2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/37577"}, {"sha": "1e5e4233a6d4807b8be2600fbc09da54a48696e0", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=deece1aa0135de487e7846025efbc8f6cd79ffe2", "patch": "@@ -354,9 +354,14 @@ compute_dot_product (gfc_expr *matrix_a, int stride_a, int offset_a,\n {\n   gfc_expr *result, *a, *b, *c;\n \n-  result = gfc_get_constant_expr (matrix_a->ts.type, matrix_a->ts.kind,\n-\t\t\t\t  &matrix_a->where);\n-  init_result_expr (result, 0, NULL);\n+  /* Set result to an INTEGER(1) 0 for numeric types and .false. for \n+     LOGICAL.  Mixed-mode math in the loop will promote result to the\n+     correct type and kind.  */\n+  if (matrix_a->ts.type == BT_LOGICAL)\n+    result = gfc_get_logical_expr (gfc_default_logical_kind, NULL, false);\n+  else\n+    result = gfc_get_int_expr (1, NULL, 0);\n+  result->where = matrix_a->where;\n \n   a = gfc_constructor_lookup_expr (matrix_a->value.constructor, offset_a);\n   b = gfc_constructor_lookup_expr (matrix_b->value.constructor, offset_b);\n@@ -2253,23 +2258,20 @@ gfc_simplify_dim (gfc_expr *x, gfc_expr *y)\n gfc_expr*\n gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n {\n-\n-  gfc_expr temp;\n+  /* If vector_a is a zero-sized array, the result is 0 for INTEGER, \n+     REAL, and COMPLEX types and .false. for LOGICAL.  */\n+  if (vector_a->shape && mpz_get_si (vector_a->shape[0]) == 0)\n+    {\n+      if (vector_a->ts.type == BT_LOGICAL)\n+\treturn gfc_get_logical_expr (gfc_default_logical_kind, NULL, false);\n+      else\n+\treturn gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+    }\n \n   if (!is_constant_array_expr (vector_a)\n       || !is_constant_array_expr (vector_b))\n     return NULL;\n \n-  gcc_assert (vector_a->rank == 1);\n-  gcc_assert (vector_b->rank == 1);\n-\n-  temp.expr_type = EXPR_OP;\n-  gfc_clear_ts (&temp.ts);\n-  temp.value.op.op = INTRINSIC_NONE;\n-  temp.value.op.op1 = vector_a;\n-  temp.value.op.op2 = vector_b;\n-  gfc_type_convert_binary (&temp, 1);\n-\n   return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0, true);\n }\n "}, {"sha": "317be5e9faefcd2f08e4c21c076541e83de615bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=deece1aa0135de487e7846025efbc8f6cd79ffe2", "patch": "@@ -1,3 +1,8 @@\n+2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/83998\n+\t* gfortran.dg/dot_product_4.f90\n+\n 2018-01-26  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/83896"}, {"sha": "fe632027389a2f4e63de94cd507a5527f2079faf", "filename": "gcc/testsuite/gfortran.dg/dot_product_4.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deece1aa0135de487e7846025efbc8f6cd79ffe2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_4.f90?ref=deece1aa0135de487e7846025efbc8f6cd79ffe2", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR fortran/83998\n+program p\n+   integer, parameter :: a(0) = 1\n+   real, parameter :: b(0) = 1\n+   complex, parameter :: c(0) = 1\n+   logical, parameter :: d(0) = .true.\n+   if (dot_product(a,a) /= 0) call abort\n+   if (dot_product(b,b) /= 0) call abort\n+   if (dot_product(c,c) /= 0) call abort\n+   if (dot_product(d,d) .neqv. .false.) call abort\n+end\n+"}]}