{"sha": "3e93d2926aeefcffc978005b7964481f351dd494", "node_id": "C_kwDOANBUbNoAKDNlOTNkMjkyNmFlZWZjZmZjOTc4MDA1Yjc5NjQ0ODFmMzUxZGQ0OTQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-04-20T07:54:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-30T08:29:01Z"}, "message": "[Ada] Do not freeze profiles for dispatch tables\n\nWhen static dispatch tables are built for library-level tagged types, the\nprimitives (the subprogram themselves) are frozen; that's necessary because\ntheir address is taken.  However, their profile, i.e. all the types present\ntherein, is also frozen, which is not necessary after AI05-019 and is also\ninconsistent with the handling of attribute references.\n\nThe change also removes a couple of pragma Inline on subprograms that are\ntoo large for inlining to bring any benefit.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Adjust call to Make_DT.\n\t* exp_disp.ads (Building_Static_DT): Remove pragma Inline.\n\t(Building_Static_Secondary_DT): Likewise.\n\t(Convert_Tag_To_Interface): Likewise.\n\t(Make_DT): Remove second parameter.\n\t* exp_disp.adb (Make_DT): Likewise.\n\t(Check_Premature_Freezing): Delete.\n\tPass Do_Freeze_Profile as False in call to Freeze_Entity.\n\t* freeze.ads (Freezing_Library_Level_Tagged_Type): Delete.\n\t* freeze.adb (Freeze_Profile): Remove obsolete code.\n\t(Freeze_Entity): Tweak comment.", "tree": {"sha": "cf09f68a5f04e970fda67498d91162d1c3aa09e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf09f68a5f04e970fda67498d91162d1c3aa09e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e93d2926aeefcffc978005b7964481f351dd494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e93d2926aeefcffc978005b7964481f351dd494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e93d2926aeefcffc978005b7964481f351dd494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e93d2926aeefcffc978005b7964481f351dd494/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ea22318caf52a98b32f8ef4e155376e7751db4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea22318caf52a98b32f8ef4e155376e7751db4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea22318caf52a98b32f8ef4e155376e7751db4b"}], "stats": {"total": 200, "additions": 19, "deletions": 181}, "files": [{"sha": "87a84b4d858648b9719903e41bae5128054ef61e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3e93d2926aeefcffc978005b7964481f351dd494", "patch": "@@ -6909,9 +6909,9 @@ package body Exp_Ch3 is\n \n          begin\n             if Is_Concurrent_Type (Base_Typ) then\n-               New_Nodes := Make_DT (Corresponding_Record_Type (Base_Typ), N);\n+               New_Nodes := Make_DT (Corresponding_Record_Type (Base_Typ));\n             else\n-               New_Nodes := Make_DT (Base_Typ, N);\n+               New_Nodes := Make_DT (Base_Typ);\n             end if;\n \n             Insert_List_Before (N, New_Nodes);"}, {"sha": "a0a344965412baff9ab611901e71f1e90c244217", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 11, "deletions": 149, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3e93d2926aeefcffc978005b7964481f351dd494", "patch": "@@ -3660,7 +3660,7 @@ package body Exp_Disp is\n    --  replaced by gotos which jump to the end of the routine and restore the\n    --  Ghost mode.\n \n-   function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id is\n+   function Make_DT (Typ : Entity_Id) return List_Id is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n       Max_Predef_Prims : constant Int :=\n@@ -3678,23 +3678,6 @@ package body Exp_Disp is\n       --  offset to the components that reference secondary dispatch tables.\n       --  Used to compute the offset of components located at fixed position.\n \n-      procedure Check_Premature_Freezing\n-        (Subp        : Entity_Id;\n-         Tagged_Type : Entity_Id;\n-         Typ         : Entity_Id);\n-      --  Verify that all untagged types in the profile of a subprogram are\n-      --  frozen at the point the subprogram is frozen. This enforces the rule\n-      --  on RM 13.14 (14) as modified by AI05-019. At the point a subprogram\n-      --  is frozen, enough must be known about it to build the activation\n-      --  record for it, which requires at least that the size of all\n-      --  parameters be known. Controlling arguments are by-reference,\n-      --  and therefore the rule only applies to untagged types. Typical\n-      --  violation of the rule involves an object declaration that freezes a\n-      --  tagged type, when one of its primitive operations has a type in its\n-      --  profile whose full view has not been analyzed yet. More complex cases\n-      --  involve composite types that have one private unfrozen subcomponent.\n-      --  Move this check to sem???\n-\n       procedure Export_DT (Typ : Entity_Id; DT : Entity_Id; Index : Nat := 0);\n       --  Export the dispatch table DT of tagged type Typ. Required to generate\n       --  forward references and statically allocate the table. For primary\n@@ -3733,103 +3716,6 @@ package body Exp_Disp is\n       function Number_Of_Predefined_Prims (Typ : Entity_Id) return Nat;\n       --  Returns the number of predefined primitives of Typ\n \n-      ------------------------------\n-      -- Check_Premature_Freezing --\n-      ------------------------------\n-\n-      procedure Check_Premature_Freezing\n-        (Subp        : Entity_Id;\n-         Tagged_Type : Entity_Id;\n-         Typ         : Entity_Id)\n-      is\n-         Comp : Entity_Id;\n-\n-         function Is_Actual_For_Formal_Incomplete_Type\n-           (T : Entity_Id) return Boolean;\n-         --  In Ada 2012, if a nested generic has an incomplete formal type,\n-         --  the actual may be (and usually is) a private type whose completion\n-         --  appears later. It is safe to build the dispatch table in this\n-         --  case, gigi will have full views available.\n-\n-         ------------------------------------------\n-         -- Is_Actual_For_Formal_Incomplete_Type --\n-         ------------------------------------------\n-\n-         function Is_Actual_For_Formal_Incomplete_Type\n-           (T : Entity_Id) return Boolean\n-         is\n-            Gen_Par : Entity_Id;\n-            F       : Node_Id;\n-\n-         begin\n-            if not Is_Generic_Instance (Current_Scope)\n-              or else not Used_As_Generic_Actual (T)\n-            then\n-               return False;\n-            else\n-               Gen_Par := Generic_Parent (Parent (Current_Scope));\n-            end if;\n-\n-            F :=\n-              First\n-                (Generic_Formal_Declarations\n-                   (Unit_Declaration_Node (Gen_Par)));\n-            while Present (F) loop\n-               if Ekind (Defining_Identifier (F)) = E_Incomplete_Type then\n-                  return True;\n-               end if;\n-\n-               Next (F);\n-            end loop;\n-\n-            return False;\n-         end Is_Actual_For_Formal_Incomplete_Type;\n-\n-      --  Start of processing for Check_Premature_Freezing\n-\n-      begin\n-         --  Note that if the type is a (subtype of) a generic actual, the\n-         --  actual will have been frozen by the instantiation.\n-\n-         if Present (N)\n-           and then Is_Private_Type (Typ)\n-           and then No (Full_View (Typ))\n-           and then not Has_Private_Declaration (Typ)\n-           and then not Is_Generic_Type (Typ)\n-           and then not Is_Tagged_Type (Typ)\n-           and then not Is_Frozen (Typ)\n-           and then not Is_Generic_Actual_Type (Typ)\n-         then\n-            Error_Msg_Sloc := Sloc (Subp);\n-            Error_Msg_NE\n-              (\"declaration must appear after completion of type &\", N, Typ);\n-            Error_Msg_NE\n-              (\"\\which is an untagged type in the profile of \"\n-               & \"primitive operation & declared#\", N, Subp);\n-\n-         else\n-            Comp := Private_Component (Typ);\n-\n-            if not Is_Tagged_Type (Typ)\n-              and then Present (Comp)\n-              and then not Is_Frozen (Comp)\n-              and then not Has_Private_Declaration (Comp)\n-              and then not Is_Actual_For_Formal_Incomplete_Type (Comp)\n-            then\n-               Error_Msg_Sloc := Sloc (Subp);\n-               Error_Msg_NE\n-                 (\"declaration must appear after completion of type &\",\n-                  N, Comp);\n-               Error_Msg_Node_2 := Subp;\n-               Error_Msg_Name_1 := Chars (Tagged_Type);\n-               Error_Msg_NE\n-                 (\"\\which is a component of untagged type& in the profile \"\n-                  & \"of primitive & of type % that is frozen by the \"\n-                  & \"declaration\", N, Typ);\n-            end if;\n-         end if;\n-      end Check_Premature_Freezing;\n-\n       ---------------\n       -- Export_DT --\n       ---------------\n@@ -4584,55 +4470,31 @@ package body Exp_Disp is\n       end if;\n \n       --  Ensure that all the primitives are frozen. This is only required when\n-      --  building static dispatch tables --- the primitives must be frozen to\n-      --  be referenced (otherwise we have problems with the backend). It is\n+      --  building static dispatch tables: the primitives must be frozen to be\n+      --  referenced, otherwise we have problems with the back end. But this is\n       --  not a requirement with nonstatic dispatch tables because in this case\n-      --  we generate now an empty dispatch table; the extra code required to\n-      --  register the primitives in the slots will be generated later --- when\n-      --  each primitive is frozen (see Freeze_Subprogram).\n+      --  we generate an empty dispatch table at this point and the extra code\n+      --  required to register the primitives in their slot will be generated\n+      --  later, when each primitive is frozen (see Freeze_Subprogram).\n \n       if Building_Static_DT (Typ) then\n          declare\n-            Saved_FLLTT : constant Boolean :=\n-                            Freezing_Library_Level_Tagged_Type;\n-\n-            Formal    : Entity_Id;\n-            Frnodes   : List_Id;\n+            F_List    : List_Id;\n             Prim      : Entity_Id;\n             Prim_Elmt : Elmt_Id;\n \n          begin\n-            Freezing_Library_Level_Tagged_Type := True;\n-\n             Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n             while Present (Prim_Elmt) loop\n-               Prim    := Node (Prim_Elmt);\n-               Frnodes := Freeze_Entity (Prim, Typ);\n-\n-               --  We disable this check for abstract subprograms, given that\n-               --  they cannot be called directly and thus the state of their\n-               --  untagged formals is of no concern. The RM is unclear in any\n-               --  case concerning the need for this check, and this topic may\n-               --  go back to the ARG.\n-\n-               if not Is_Abstract_Subprogram (Prim) then\n-                  Formal := First_Formal (Prim);\n-                  while Present (Formal) loop\n-                     Check_Premature_Freezing (Prim, Typ, Etype (Formal));\n-                     Next_Formal (Formal);\n-                  end loop;\n-\n-                  Check_Premature_Freezing (Prim, Typ, Etype (Prim));\n-               end if;\n+               Prim   := Node (Prim_Elmt);\n+               F_List := Freeze_Entity (Prim, Typ, Do_Freeze_Profile => False);\n \n-               if Present (Frnodes) then\n-                  Append_List_To (Result, Frnodes);\n+               if Present (F_List) then\n+                  Append_List_To (Result, F_List);\n                end if;\n \n                Next_Elmt (Prim_Elmt);\n             end loop;\n-\n-            Freezing_Library_Level_Tagged_Type := Saved_FLLTT;\n          end;\n       end if;\n "}, {"sha": "96eae30e0a92c6c0cd7659e5775db89732fd7c67", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=3e93d2926aeefcffc978005b7964481f351dd494", "patch": "@@ -168,11 +168,9 @@ package Exp_Disp is\n    --  Generate checks required on dispatching calls\n \n    function Building_Static_DT (Typ : Entity_Id) return Boolean;\n-   pragma Inline (Building_Static_DT);\n    --  Returns true when building statically allocated dispatch tables\n \n    function Building_Static_Secondary_DT (Typ : Entity_Id) return Boolean;\n-   pragma Inline (Building_Static_Secondary_DT);\n    --  Returns true when building statically allocated secondary dispatch\n    --  tables\n \n@@ -187,7 +185,6 @@ package Exp_Disp is\n \n    function Convert_Tag_To_Interface\n      (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n-   pragma Inline (Convert_Tag_To_Interface);\n    --  This function is used in class-wide interface conversions; the expanded\n    --  code generated to convert a tagged object to a class-wide interface type\n    --  involves referencing the tag component containing the secondary dispatch\n@@ -256,11 +253,8 @@ package Exp_Disp is\n    function Is_Expanded_Dispatching_Call (N : Node_Id) return Boolean;\n    --  Returns true if N is the expanded code of a dispatching call\n \n-   function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id;\n-   --  Expand the declarations for the Dispatch Table. The node N is the\n-   --  declaration that forces the generation of the table. It is used to place\n-   --  error messages when the declaration leads to the freezing of a given\n-   --  primitive operation that has an incomplete non- tagged formal.\n+   function Make_DT (Typ : Entity_Id) return List_Id;\n+   --  Expand the declarations for the Dispatch Table of Typ\n \n    function Make_Disp_Asynchronous_Select_Body\n      (Typ : Entity_Id) return Node_Id;"}, {"sha": "0301bf43b15aff74428ca73ce51677ad94472863", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3e93d2926aeefcffc978005b7964481f351dd494", "patch": "@@ -4631,9 +4631,7 @@ package body Freeze is\n                   Result := No_List;\n                   return False;\n \n-               elsif not After_Last_Declaration\n-                 and then not Freezing_Library_Level_Tagged_Type\n-               then\n+               elsif not After_Last_Declaration then\n                   Error_Msg_NE\n                     (\"type & must be fully defined before this point\",\n                      N,\n@@ -4751,17 +4749,6 @@ package body Freeze is\n                if Is_Access_Type (F_Type) then\n                   F_Type := Designated_Type (F_Type);\n                end if;\n-\n-               --  If the formal is an anonymous_access_to_subprogram\n-               --  freeze the  subprogram type as well, to prevent\n-               --  scope anomalies in gigi, because there is no other\n-               --  clear point at which it could be frozen.\n-\n-               if Is_Itype (Etype (Formal))\n-                 and then Ekind (F_Type) = E_Subprogram_Type\n-               then\n-                  Freeze_And_Append (F_Type, N, Result);\n-               end if;\n             end if;\n \n             Next_Formal (Formal);\n@@ -6490,9 +6477,10 @@ package body Freeze is\n \n             --  In Ada 2012, freezing a subprogram does not always freeze the\n             --  corresponding profile (see AI05-019). An attribute reference\n-            --  is not a freezing point of the profile. Flag Do_Freeze_Profile\n+            --  is not a freezing point of the profile. Similarly, we do not\n+            --  freeze the profile of primitives of a library-level tagged type\n+            --  when we are building its dispatch table. Flag Do_Freeze_Profile\n             --  indicates whether the profile should be frozen now.\n-            --  Other constructs that should not freeze ???\n \n             --  This processing doesn't apply to internal entities (see below)\n "}, {"sha": "bef4e14474b71b89284be88838530b9172765418", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e93d2926aeefcffc978005b7964481f351dd494/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=3e93d2926aeefcffc978005b7964481f351dd494", "patch": "@@ -120,12 +120,6 @@ package Freeze is\n    --  where the freeze node is preallocated at the point of declaration, so\n    --  that the First_Subtype_Link field can be set.\n \n-   Freezing_Library_Level_Tagged_Type : Boolean := False;\n-   --  Flag used to indicate that we are freezing the primitives of a library\n-   --  level tagged type. Used to disable checks on premature freezing.\n-   --  More documentation needed??? why is this flag needed? what are these\n-   --  checks? why do they need disabling in some cases?\n-\n    -----------------\n    -- Subprograms --\n    -----------------"}]}