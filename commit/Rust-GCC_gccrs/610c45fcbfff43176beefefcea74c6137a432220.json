{"sha": "610c45fcbfff43176beefefcea74c6137a432220", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwYzQ1ZmNiZmZmNDMxNzZiZWVmZWZjZWE3NGM2MTM3YTQzMjIyMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-13T09:23:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-13T09:23:54Z"}, "message": "Make more use of subreg_lowpart_offset\n\nThis patch uses subreg_lowpart_offset in places that open-coded\nthe calculation.  It also uses it in regcprop.c to test whether,\nafter a mode change, the first register in a multi-register group\nis still the right one.\n\n2017-10-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* calls.c (expand_call): Use subreg_lowpart_offset.\n\t* cse.c (cse_insn): Likewise.\n\t* regcprop.c (copy_value): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r253713", "tree": {"sha": "fc56c08135f71cfb00cb65322910c3e569682d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc56c08135f71cfb00cb65322910c3e569682d8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610c45fcbfff43176beefefcea74c6137a432220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c45fcbfff43176beefefcea74c6137a432220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c45fcbfff43176beefefcea74c6137a432220", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c45fcbfff43176beefefcea74c6137a432220/comments", "author": null, "committer": null, "parents": [{"sha": "5752d1f7943db65667edeaf8481dc10b60a23197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5752d1f7943db65667edeaf8481dc10b60a23197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5752d1f7943db65667edeaf8481dc10b60a23197"}], "stats": {"total": 40, "additions": 15, "deletions": 25}, "files": [{"sha": "dc2d911e2c5304ea16c0b9f36ef7eda8b8678c52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c45fcbfff43176beefefcea74c6137a432220/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c45fcbfff43176beefefcea74c6137a432220/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=610c45fcbfff43176beefefcea74c6137a432220", "patch": "@@ -1,3 +1,12 @@\n+2017-10-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* calls.c (expand_call): Use subreg_lowpart_offset.\n+\t* cse.c (cse_insn): Likewise.\n+\t* regcprop.c (copy_value): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\n 2017-10-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82524"}, {"sha": "7ed05d40d86b13fed4343715394b1693301e189a", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=610c45fcbfff43176beefefcea74c6137a432220", "patch": "@@ -4117,26 +4117,15 @@ expand_call (tree exp, rtx target, int ignore)\n \t{\n \t  tree type = rettype;\n \t  int unsignedp = TYPE_UNSIGNED (type);\n-\t  int offset = 0;\n \t  machine_mode pmode;\n \n \t  /* Ensure we promote as expected, and get the new unsignedness.  */\n \t  pmode = promote_function_mode (type, TYPE_MODE (type), &unsignedp,\n \t\t\t\t\t funtype, 1);\n \t  gcc_assert (GET_MODE (target) == pmode);\n \n-\t  if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-\t      && (GET_MODE_SIZE (GET_MODE (target))\n-\t\t  > GET_MODE_SIZE (TYPE_MODE (type))))\n-\t    {\n-\t      offset = GET_MODE_SIZE (GET_MODE (target))\n-\t        - GET_MODE_SIZE (TYPE_MODE (type));\n-\t      if (! BYTES_BIG_ENDIAN)\n-\t        offset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t      else if (! WORDS_BIG_ENDIAN)\n-\t        offset %= UNITS_PER_WORD;\n-\t    }\n-\n+\t  unsigned int offset = subreg_lowpart_offset (TYPE_MODE (type),\n+\t\t\t\t\t\t       GET_MODE (target));\n \t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n \t  SUBREG_PROMOTED_VAR_P (target) = 1;\n \t  SUBREG_PROMOTED_SET (target, unsignedp);"}, {"sha": "717aaf8779da00d7c5e15c22f162521457d2890b", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=610c45fcbfff43176beefefcea74c6137a432220", "patch": "@@ -5977,7 +5977,6 @@ cse_insn (rtx_insn *insn)\n \t\trtx new_src = 0;\n \t\tunsigned src_hash;\n \t\tstruct table_elt *src_elt;\n-\t\tint byte = 0;\n \n \t\t/* Ignore invalid entries.  */\n \t\tif (!REG_P (elt->exp)\n@@ -5990,13 +5989,8 @@ cse_insn (rtx_insn *insn)\n \t\t  new_src = elt->exp;\n \t\telse\n \t\t  {\n-\t\t    /* Calculate big endian correction for the SUBREG_BYTE.\n-\t\t       We have already checked that M1 (GET_MODE (dest))\n-\t\t       is not narrower than M2 (new_mode).  */\n-\t\t    if (BYTES_BIG_ENDIAN)\n-\t\t      byte = (GET_MODE_SIZE (GET_MODE (dest))\n-\t\t\t      - GET_MODE_SIZE (new_mode));\n-\n+\t\t    unsigned int byte\n+\t\t      = subreg_lowpart_offset (new_mode, GET_MODE (dest));\n \t\t    new_src = simplify_gen_subreg (new_mode, elt->exp,\n \t\t\t\t\t           GET_MODE (dest), byte);\n \t\t  }"}, {"sha": "5db5b5d9fdffae14c1ea7bd48cb1e0a7f4937947", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c45fcbfff43176beefefcea74c6137a432220/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=610c45fcbfff43176beefefcea74c6137a432220", "patch": "@@ -345,8 +345,7 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n      We can't properly represent the latter case in our tables, so don't\n      record anything then.  */\n   else if (sn < hard_regno_nregs (sr, vd->e[sr].mode)\n-\t   && (GET_MODE_SIZE (vd->e[sr].mode) > UNITS_PER_WORD\n-\t       ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n+\t   && subreg_lowpart_offset (GET_MODE (dest), vd->e[sr].mode) != 0)\n     return;\n \n   /* If SRC had been assigned a mode narrower than the copy, we can't\n@@ -871,8 +870,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t      /* And likewise, if we are narrowing on big endian the transformation\n \t\t is also invalid.  */\n \t      if (REG_NREGS (src) < hard_regno_nregs (regno, vd->e[regno].mode)\n-\t\t  && (GET_MODE_SIZE (vd->e[regno].mode) > UNITS_PER_WORD\n-\t\t      ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n+\t\t  && subreg_lowpart_offset (mode, vd->e[regno].mode) != 0)\n \t\tgoto no_move_special_case;\n \t    }\n "}]}