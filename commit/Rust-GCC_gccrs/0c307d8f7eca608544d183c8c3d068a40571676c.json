{"sha": "0c307d8f7eca608544d183c8c3d068a40571676c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzMDdkOGY3ZWNhNjA4NTQ0ZDE4M2M4YzNkMDY4YTQwNTcxNjc2Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-11-14T20:45:21Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-11-14T20:45:21Z"}, "message": "predicates.md (easy_fp_constant): Delete redunant tests for 0.0.\n\n[gcc]\n2014-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/predicates.md (easy_fp_constant): Delete redunant\n\ttests for 0.0.\n\n\t* config/rs6000/vector.md (VEC_R): Move secondary reload support\n\tinsns to rs6000.md from vector.md.\n\t(reload_<VEC_R:mode>_<P:mptrsize>_store): Likewise.\n\t(reload_<VEC_R:mode>_<P:mptrsize>_load): Likewise.\n\t(vec_reload_and_plus_<mptrsize>): Likewise.\n\n\t* config/rs6000/rs6000.md (Fa): New mode attribute to give\n\tconstraint for the Altivec registers for a type.\n\t(RELOAD): New mode iterator for all of the types that have\n\tsecondary reload address support to load up a base register.\n\t(extendsfdf2_fpr): Use correct constraint.\n\t(copysign<mode>3_fcpsgn): For SFmode, use correct xscpsgndp\n\tinstruction.\n\t(floatsi<mode>2_lfiwax): Add support for -mupper-regs-{sf,df}.\n\tGenerate the non-VSX instruction if all registers were FPRs.  Do\n\tnot use the patterns in vsx.md for scalar operations.\n\t(floatsi<mode>2_lfiwax_mem): Likewise.\n\t(floatunssi<mode>2_lfiwzx): Likewise.\n\t(floatunssi<mode>2_lfiwzx_mem): Likewise.\n\t(fix_trunc<mode>di2_fctidz): Likewise.\n\t(fixuns_trunc<mode>di2_fctiduz): Likewise.\n\t(fctiwz_<mode>): Likewise.\n\t(fctiwuz_<mode>): Likewise.\n\t(friz): Likewise.\n\t(floatdidf2_fpr): Likewise.\n\t(floatdidf2_mem): Likewise.\n\t(floatunsdidf2): Likewise.\n\t(floatunsdidf2_fcfidu): Likewise.\n\t(floatunsdidf2_mem): Likewise.\n\t(floatdisf2_fcfids): Likewise.\n\t(floatdisf2_mem): Likewise.\n\t(floatdisf2_internal1): Add explicit test for not FCFIDS to make\n\tit more obvious that the code is for pre-ISA 2.06 machines.\n\t(floatdisf2_internal2): Likewise.\n\t(floatunsdisf2_fcfidus): Add support for -mupper-regs-{sf,df}.\n\tGenerate the non-VSX instruction if all registers were FPRs.  Do\n\tnot use the patterns in vsx.md for scalar operations.\n\t(floatunsdisf2_mem): Likewise.\n\t(reload_<RELOAD:mode>_<P:mptrsize>_store): Move the reload\n\thandlers here from vector.md, and expand the types we generate\n\treload handlers for.\n\t(reload_<RELOAD:mode>_<P:mptrsize>_load): Likewise.\n\t(vec_reload_and_plus_<mptrsize>): Likewise.\n\n\t* config/rs6000/vsx.md (vsx_float<VSi><mode>2): Only provide the\n\tvector forms of the instructions.  Move VSX scalar forms to\n\trs6000.md, and add support for -mupper-regs-sf.\n\t(vsx_floatuns<VSi><mode>2): Likewise.\n\t(vsx_fix_trunc<mode><VSi>2): Likewise.\n\t(vsx_fixuns_trunc<mode><VSi>2): Likewise.\n\t(vsx_float_fix_<mode>2): Delete DF version, rename to\n\tvsx_float_fix_v2df2.\n\t(vsx_float_fix_v2df2): Likewise.\n\n[gcc/testsuite]\n2014-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/ppc-fpconv-1.c: Adjust for -mupper-regs-df\n\tchanges.\n\t* gcc.target/powerpc/ppc-fpconv-2.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-3.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-4.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-5.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-6.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-7.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-8.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-9.c: Likewise.\n\t* gcc.target/powerpc/ppc-fpconv-10.c: Likewise.\n\t* gcc.target/powerpc/ppc-round.c: Likewise.\n\nFrom-SVN: r217590", "tree": {"sha": "25552df7d6ad49ce847f0d04628eedfcd3a39e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25552df7d6ad49ce847f0d04628eedfcd3a39e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c307d8f7eca608544d183c8c3d068a40571676c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c307d8f7eca608544d183c8c3d068a40571676c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c307d8f7eca608544d183c8c3d068a40571676c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c307d8f7eca608544d183c8c3d068a40571676c/comments", "author": null, "committer": null, "parents": [{"sha": "3b97a5c7c6113f5a32bf4546c50056d108729bb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b97a5c7c6113f5a32bf4546c50056d108729bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b97a5c7c6113f5a32bf4546c50056d108729bb2"}], "stats": {"total": 442, "additions": 270, "deletions": 172}, "files": [{"sha": "f7587e1c38871fe40f481db0bae0e523d01b04d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -1,3 +1,62 @@\n+2014-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (easy_fp_constant): Delete redunant\n+\ttests for 0.0.\n+\n+\t* config/rs6000/vector.md (VEC_R): Move secondary reload support\n+\tinsns to rs6000.md from vector.md.\n+\t(reload_<VEC_R:mode>_<P:mptrsize>_store): Likewise.\n+\t(reload_<VEC_R:mode>_<P:mptrsize>_load): Likewise.\n+\t(vec_reload_and_plus_<mptrsize>): Likewise.\n+\n+\t* config/rs6000/rs6000.md (Fa): New mode attribute to give\n+\tconstraint for the Altivec registers for a type.\n+\t(RELOAD): New mode iterator for all of the types that have\n+\tsecondary reload address support to load up a base register.\n+\t(extendsfdf2_fpr): Use correct constraint.\n+\t(copysign<mode>3_fcpsgn): For SFmode, use correct xscpsgndp\n+\tinstruction.\n+\t(floatsi<mode>2_lfiwax): Add support for -mupper-regs-{sf,df}.\n+\tGenerate the non-VSX instruction if all registers were FPRs.  Do\n+\tnot use the patterns in vsx.md for scalar operations.\n+\t(floatsi<mode>2_lfiwax_mem): Likewise.\n+\t(floatunssi<mode>2_lfiwzx): Likewise.\n+\t(floatunssi<mode>2_lfiwzx_mem): Likewise.\n+\t(fix_trunc<mode>di2_fctidz): Likewise.\n+\t(fixuns_trunc<mode>di2_fctiduz): Likewise.\n+\t(fctiwz_<mode>): Likewise.\n+\t(fctiwuz_<mode>): Likewise.\n+\t(friz): Likewise.\n+\t(floatdidf2_fpr): Likewise.\n+\t(floatdidf2_mem): Likewise.\n+\t(floatunsdidf2): Likewise.\n+\t(floatunsdidf2_fcfidu): Likewise.\n+\t(floatunsdidf2_mem): Likewise.\n+\t(floatdisf2_fcfids): Likewise.\n+\t(floatdisf2_mem): Likewise.\n+\t(floatdisf2_internal1): Add explicit test for not FCFIDS to make\n+\tit more obvious that the code is for pre-ISA 2.06 machines.\n+\t(floatdisf2_internal2): Likewise.\n+\t(floatunsdisf2_fcfidus): Add support for -mupper-regs-{sf,df}.\n+\tGenerate the non-VSX instruction if all registers were FPRs.  Do\n+\tnot use the patterns in vsx.md for scalar operations.\n+\t(floatunsdisf2_mem): Likewise.\n+\t(reload_<RELOAD:mode>_<P:mptrsize>_store): Move the reload\n+\thandlers here from vector.md, and expand the types we generate\n+\treload handlers for.\n+\t(reload_<RELOAD:mode>_<P:mptrsize>_load): Likewise.\n+\t(vec_reload_and_plus_<mptrsize>): Likewise.\n+\n+\t* config/rs6000/vsx.md (vsx_float<VSi><mode>2): Only provide the\n+\tvector forms of the instructions.  Move VSX scalar forms to\n+\trs6000.md, and add support for -mupper-regs-sf.\n+\t(vsx_floatuns<VSi><mode>2): Likewise.\n+\t(vsx_fix_trunc<mode><VSi>2): Likewise.\n+\t(vsx_fixuns_trunc<mode><VSi>2): Likewise.\n+\t(vsx_float_fix_<mode>2): Delete DF version, rename to\n+\tvsx_float_fix_v2df2.\n+\t(vsx_float_fix_v2df2): Likewise.\n+\n 2014-11-14  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.h (jump_func_type): Removed value IPA_JF_KNOWN_TYPE."}, {"sha": "8abac7ee1289e5ccdae11f15da31dab3caf0f61b", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -479,10 +479,6 @@\n \t      && num_insns_constant_wide ((HOST_WIDE_INT) k[3]) == 1);\n \n     case DFmode:\n-      /* The constant 0.f is easy under VSX.  */\n-      if (op == CONST0_RTX (DFmode) && VECTOR_UNIT_VSX_P (DFmode))\n-\treturn 1;\n-\n       /* Force constants to memory before reload to utilize\n \t compress_float_constant.\n \t Avoid this when flag_unsafe_math_optimizations is enabled\n@@ -500,10 +496,6 @@\n \t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1);\n \n     case SFmode:\n-      /* The constant 0.f is easy.  */\n-      if (op == CONST0_RTX (SFmode))\n-\treturn 1;\n-\n       /* Force constants to memory before reload to utilize\n \t compress_float_constant.\n \t Avoid this when flag_unsafe_math_optimizations is enabled"}, {"sha": "4d58707fa269a33ec988b496208cb524c9aa0dd5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 128, "deletions": 57, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -442,6 +442,9 @@\n ; SF/DF constraint for arithmetic on VSX registers\n (define_mode_attr Fv\t\t[(SF \"wy\") (DF \"ws\")])\n \n+; SF/DF constraint for arithmetic on altivec registers\n+(define_mode_attr Fa\t\t[(SF \"wu\") (DF \"wv\")])\n+\n ; s/d suffix for things like fp_addsub_s/fp_addsub_d\n (define_mode_attr Fs\t\t[(SF \"s\")  (DF \"d\")])\n \n@@ -589,6 +592,12 @@\n \t\t\t\t\t (V2DI\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V2DF\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V1TI\t\"wa,v,r,0,0\")])\n+\n+;; Reload iterator for creating the function to allocate a base register to\n+;; supplement addressing modes.\n+(define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n+\t\t\t      SF SD SI DF DD DI TI PTI])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -4952,7 +4961,7 @@\n   \"\")\n \n (define_insn_and_split \"*extendsfdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wv\")\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wu\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wy,Z\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n   \"@\n@@ -5057,7 +5066,7 @@\n   \"TARGET_<MODE>_FPR && TARGET_CMPB\"\n   \"@\n    fcpsgn %0,%2,%1\n-   xscpsgn<Fvsx> %x0,%x2,%x1\"\n+   xscpsgndp %x0,%x2,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n@@ -5329,9 +5338,9 @@\n ; not be needed and also in case the insns are deleted as dead code.\n \n (define_insn_and_split \"floatsi<mode>2_lfiwax\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+   (clobber (match_scratch:DI 2 \"=wj\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP> && can_create_pseudo_p ()\"\n   \"#\"\n@@ -5370,7 +5379,7 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatsi<mode>2_lfiwax_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d,<rreg2>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fa>\")\n \t(float:SFDF\n \t (sign_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z,Z\"))))\n@@ -5404,9 +5413,9 @@\n   [(set_attr \"type\" \"fpload,fpload,mftgpr\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unsigned_float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+   (clobber (match_scratch:DI 2 \"=wj\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\n    && <SI_CONVERT_FP>\"\n   \"#\"\n@@ -5445,7 +5454,7 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn_and_split \"floatunssi<mode>2_lfiwzx_mem\"\n-  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=d,<rreg2>\")\n+  [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fa>\")\n \t(unsigned_float:SFDF\n \t (zero_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z,Z\"))))\n@@ -5758,11 +5767,13 @@\n   \"\")\n \n (define_insn \"*fix_trunc<mode>di2_fctidz\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n+\t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fa>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-    && TARGET_FCFID && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"fctidz %0,%1\"\n+    && TARGET_FCFID\"\n+  \"@\n+   fctidz %0,%1\n+   xscvdpsxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"fixuns_trunc<mode>si2\"\n@@ -5828,44 +5839,51 @@\n   \"\")\n \n (define_insn \"*fixuns_trunc<mode>di2_fctiduz\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n+\t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fa>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-    && TARGET_FCTIDUZ && !VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"fctiduz %0,%1\"\n+    && TARGET_FCTIDUZ\"\n+  \"@\n+   fctiduz %0,%1\n+   xscvdpuxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ; because the first makes it clear that operand 0 is not live\n ; before the instruction.\n (define_insn \"fctiwz_<mode>\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n-\t(unspec:DI [(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))]\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n+\t(unspec:DI [(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWZ))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n-  \"fctiwz %0,%1\"\n+  \"@\n+   fctiwz %0,%1\n+   xscvdpsxws %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"fctiwuz_<mode>\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n \t(unspec:DI [(unsigned_fix:SI\n-\t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\"))]\n+\t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWUZ))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\"\n-  \"fctiwuz %0,%1\"\n+  \"@\n+   fctiwuz %0,%1\n+   xscvdpuxws %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ;; Only optimize (float (fix x)) -> frz if we are in fast-math mode, since\n ;; since the friz instruction does not truncate the value if the floating\n ;; point value is < LONG_MIN or > LONG_MAX.\n (define_insn \"*friz\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(float:DF (fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d\"))))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n+\t(float:DF (fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d,ws\"))))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_FPRND\n-   && !VECTOR_UNIT_VSX_P (DFmode) && flag_unsafe_math_optimizations\n-   && !flag_trapping_math && TARGET_FRIZ\"\n-  \"friz %0,%1\"\n+   && flag_unsafe_math_optimizations && !flag_trapping_math && TARGET_FRIZ\"\n+  \"@\n+   friz %0,%1\n+   xsrdpiz %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ;; Since FCTIWZ doesn't sign extend the upper bits, we have to do a store and a\n@@ -6048,11 +6066,12 @@\n   \"\")\n \n (define_insn \"*floatdidf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\n-   && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fcfid %0,%1\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n+\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS\"\n+  \"@\n+   fcfid %0,%1\n+   xscvsxddp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n ; Allow the combiner to merge source memory operands to the conversion so that\n@@ -6061,9 +6080,9 @@\n ; hit.  We will split after reload to avoid the trip through the GPRs\n \n (define_insn_and_split \"*floatdidf2_mem\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(float:DF (match_operand:DI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n+\t(float:DF (match_operand:DI 1 \"memory_operand\" \"m,Z\")))\n+   (clobber (match_scratch:DI 2 \"=d,wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRS && TARGET_FCFID\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -6077,21 +6096,23 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_float:DF\n \t (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FCFIDU || VECTOR_UNIT_VSX_P (DFmode))\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDU\"\n   \"\")\n \n (define_insn \"*floatunsdidf2_fcfidu\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unsigned_float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_FCFIDU && !VECTOR_UNIT_VSX_P (DFmode)\"\n-  \"fcfidu %0,%1\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n+\t(unsigned_float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDU\"\n+  \"@\n+   fcfidu %0,%1\n+   xscvuxddp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn_and_split \"*floatunsdidf2_mem\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n-\t(unsigned_float:DF (match_operand:DI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:DI 2 \"=d\"))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n+\t(unsigned_float:DF (match_operand:DI 1 \"memory_operand\" \"m,Z\")))\n+   (clobber (match_scratch:DI 2 \"=d,wi\"))]\n   \"TARGET_HARD_FLOAT && (TARGET_FCFIDU || VECTOR_UNIT_VSX_P (DFmode))\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -6124,17 +6145,19 @@\n }\")\n \n (define_insn \"floatdisf2_fcfids\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n+\t(float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n-  \"fcfids %0,%1\"\n+  \"@\n+   fcfids %0,%1\n+   xscvsxdsp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn_and_split \"*floatdisf2_mem\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(float:SF (match_operand:DI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:DI 2 \"=f\"))]\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n+\t(float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n+   (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n   \"#\"\n@@ -6156,7 +6179,8 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && !TARGET_FCFIDS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -6191,7 +6215,8 @@\n \t\t\t   (label_ref (match_operand:DI 2 \"\" \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 0) (match_dup 1))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && !TARGET_FCFIDS\"\n   \"\n {\n   operands[3] = gen_reg_rtx (DImode);\n@@ -6206,17 +6231,19 @@\n   \"\")\n \n (define_insn \"floatunsdisf2_fcfidus\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-        (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))]\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wu\")\n+        (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n-  \"fcfidus %0,%1\"\n+  \"@\n+   fcfidus %0,%1\n+   xscvuxdsp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn_and_split \"*floatunsdisf2_mem\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unsigned_float:SF (match_operand:DI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:DI 2 \"=f\"))]\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n+\t(unsigned_float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n+   (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n    && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n   \"#\"\n@@ -8414,6 +8441,50 @@\n   DONE;\n })\n \n+\f\n+;; Reload patterns for various types using the vector registers.  We may need\n+;; an additional base register to convert the reg+offset addressing to reg+reg\n+;; for vector registers and reg+reg or (reg+reg)&(-16) addressing to just an\n+;; index register for gpr registers.\n+(define_expand \"reload_<RELOAD:mode>_<P:mptrsize>_store\"\n+  [(parallel [(match_operand:RELOAD 0 \"memory_operand\" \"m\")\n+              (match_operand:RELOAD 1 \"gpc_reg_operand\" \"wa\")\n+              (match_operand:P 2 \"register_operand\" \"=b\")])]\n+  \"<P:tptrsize>\"\n+{\n+  rs6000_secondary_reload_inner (operands[1], operands[0], operands[2], true);\n+  DONE;\n+})\n+\n+(define_expand \"reload_<RELOAD:mode>_<P:mptrsize>_load\"\n+  [(parallel [(match_operand:RELOAD 0 \"gpc_reg_operand\" \"wa\")\n+              (match_operand:RELOAD 1 \"memory_operand\" \"m\")\n+              (match_operand:P 2 \"register_operand\" \"=b\")])]\n+  \"<P:tptrsize>\"\n+{\n+  rs6000_secondary_reload_inner (operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n+\n+;; Reload sometimes tries to move the address to a GPR, and can generate\n+;; invalid RTL for addresses involving AND -16.  Allow addresses involving\n+;; reg+reg, reg+small constant, or just reg, all wrapped in an AND -16.\n+\n+(define_insn_and_split \"*vec_reload_and_plus_<mptrsize>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n+\t(and:P (plus:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t       (match_operand:P 2 \"reg_or_cint_operand\" \"rI\"))\n+\t       (const_int -16)))]\n+  \"TARGET_ALTIVEC && (reload_in_progress || reload_completed)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+\t(plus:P (match_dup 1)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(and:P (match_dup 0)\n+\t       (const_int -16)))])\n \f\n ;; Power8 merge instructions to allow direct move to/from floating point\n ;; registers in 32-bit mode.  We use TF mode to get two registers to move the"}, {"sha": "e2946bd6e312e909471253fc2d75a4b25e050f82", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -53,10 +53,6 @@\n ;; Vector modes for 64-bit base types\n (define_mode_iterator VEC_64 [V2DI V2DF])\n \n-;; Vector reload iterator\n-(define_mode_iterator VEC_R [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n-\t\t\t     SF SD SI DF DD DI TI])\n-\n ;; Base type from vector mode\n (define_mode_attr VEC_base [(V16QI \"QI\")\n \t\t\t    (V8HI  \"HI\")\n@@ -184,49 +180,6 @@\n }\")\n \n \n-\f\n-;; Reload patterns for vector operations.  We may need an additional base\n-;; register to convert the reg+offset addressing to reg+reg for vector\n-;; registers and reg+reg or (reg+reg)&(-16) addressing to just an index\n-;; register for gpr registers.\n-(define_expand \"reload_<VEC_R:mode>_<P:mptrsize>_store\"\n-  [(parallel [(match_operand:VEC_R 0 \"memory_operand\" \"m\")\n-              (match_operand:VEC_R 1 \"gpc_reg_operand\" \"r\")\n-              (match_operand:P 2 \"register_operand\" \"=&b\")])]\n-  \"<P:tptrsize>\"\n-{\n-  rs6000_secondary_reload_inner (operands[1], operands[0], operands[2], true);\n-  DONE;\n-})\n-\n-(define_expand \"reload_<VEC_R:mode>_<P:mptrsize>_load\"\n-  [(parallel [(match_operand:VEC_R 0 \"gpc_reg_operand\" \"=&r\")\n-              (match_operand:VEC_R 1 \"memory_operand\" \"m\")\n-              (match_operand:P 2 \"register_operand\" \"=&b\")])]\n-  \"<P:tptrsize>\"\n-{\n-  rs6000_secondary_reload_inner (operands[0], operands[1], operands[2], false);\n-  DONE;\n-})\n-\n-;; Reload sometimes tries to move the address to a GPR, and can generate\n-;; invalid RTL for addresses involving AND -16.  Allow addresses involving\n-;; reg+reg, reg+small constant, or just reg, all wrapped in an AND -16.\n-\n-(define_insn_and_split \"*vec_reload_and_plus_<mptrsize>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-\t(and:P (plus:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t       (match_operand:P 2 \"reg_or_cint_operand\" \"rI\"))\n-\t       (const_int -16)))]\n-  \"(TARGET_ALTIVEC || TARGET_VSX) && (reload_in_progress || reload_completed)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:P (match_dup 1)\n-\t\t(match_dup 2)))\n-   (set (match_dup 0)\n-\t(and:P (match_dup 0)\n-\t       (const_int -16)))])\n \f\n ;; Generic floating point vector arithmetic support\n (define_expand \"add<mode>3\""}, {"sha": "27d464e07f7b77166047dd9ba41966aef411c029", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -1198,32 +1198,32 @@\n ;; in rs6000.md so don't test VECTOR_UNIT_VSX_P, just test against VSX.\n ;; Don't use vsx_register_operand here, use gpc_reg_operand to match rs6000.md.\n (define_insn \"vsx_float<VSi><mode>2\"\n-  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n-\t(float:VSX_B (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n+  [(set (match_operand:VSX_F 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n+\t(float:VSX_F (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>cvsx<VSc><VSs> %x0,%x1\"\n+  \"xvcvsx<VSc><VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_floatuns<VSi><mode>2\"\n-  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n-\t(unsigned_float:VSX_B (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n+  [(set (match_operand:VSX_F 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n+\t(unsigned_float:VSX_F (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n-  \"x<VSv>cvux<VSc><VSs> %x0,%x1\"\n+  \"xvcvux<VSc><VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_fix_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n-\t(fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n+\t(fix:<VSI> (match_operand:VSX_F 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>sx<VSc>s %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_fixuns_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n-\t(unsigned_fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n+\t(unsigned_fix:<VSI> (match_operand:VSX_F 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>ux<VSc>s %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n@@ -1526,19 +1526,19 @@\n   [(set_attr \"type\" \"vecdouble\")])\n \n ;; Only optimize (float (fix x)) -> frz if we are in fast-math mode, since\n-;; since the xsrdpiz instruction does not truncate the value if the floating\n+;; since the xvrdpiz instruction does not truncate the value if the floating\n ;; point value is < LONG_MIN or > LONG_MAX.\n-(define_insn \"*vsx_float_fix_<mode>2\"\n-  [(set (match_operand:VSX_DF 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n-\t(float:VSX_DF\n-\t (fix:<VSI>\n-\t  (match_operand:VSX_DF 1 \"vsx_register_operand\" \"<VSr>,?<VSa>\"))))]\n+(define_insn \"*vsx_float_fix_v2df2\"\n+  [(set (match_operand:V2DF 0 \"vsx_register_operand\" \"=wd,?wa\")\n+\t(float:V2DF\n+\t (fix:V2DI\n+\t  (match_operand:V2DF 1 \"vsx_register_operand\" \"wd,?wa\"))))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-   && VECTOR_UNIT_VSX_P (<MODE>mode) && flag_unsafe_math_optimizations\n+   && VECTOR_UNIT_VSX_P (V2DFmode) && flag_unsafe_math_optimizations\n    && !flag_trapping_math && TARGET_FRIZ\"\n-  \"x<VSv>r<VSs>iz %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  \"xvrdpiz %x0,%x1\"\n+  [(set_attr \"type\" \"vecdouble\")\n+   (set_attr \"fp_type\" \"fp_addsub_d\")])\n \n \f\n ;; Permute operations"}, {"sha": "2829167e950556e1e0b45c06e39d7da05b67d9c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -1,3 +1,18 @@\n+2014-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc-fpconv-1.c: Adjust for -mupper-regs-df\n+\tchanges.\n+\t* gcc.target/powerpc/ppc-fpconv-2.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-3.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-4.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-5.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-6.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-7.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-8.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-9.c: Likewise.\n+\t* gcc.target/powerpc/ppc-fpconv-10.c: Likewise.\n+\t* gcc.target/powerpc/ppc-round.c: Likewise.\n+\n 2014-11-14  Martin Jambor  <mjambor@suse.cz>\n \n \t* g++.dg/ipa/devirt-11.C: Dont't run ipa-cp, remove times constraint"}, {"sha": "ea20f60e1a97890e5608f33c948ec69467b41e54", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-1.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-1.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -2,13 +2,15 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O2 -mcpu=power7 -ffast-math\" } */\n+/* { dg-options \"-O2 -mcpu=power7 -ffast-math -mno-upper-regs-df\" } */\n /* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n /* { dg-final { scan-assembler-times \"lfiwzx\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fcfids\" 3 } } */\n-/* { dg-final { scan-assembler-times \"fcfidus\" 1 } } */\n-/* { dg-final { scan-assembler-times \"xscvsxddp\" 3 } } */\n-/* { dg-final { scan-assembler-times \"xscvuxddp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fcfids \" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcfidus \" 1 } } */\n+/* { dg-final { scan-assembler-times \"fcfid \" 3 } } */\n+/* { dg-final { scan-assembler-times \"fcfidu \" 1 } } */\n+/* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n \n void int_to_float (float *dest, int *src)\n {"}, {"sha": "11628c91840e9469d2ee6c8d25ccb6f850cd66f1", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-10.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-10.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -2,9 +2,8 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O2 -mcpu=power7 -ffast-math\" } */\n-/* { dg-final { scan-assembler \"xsrdpiz\" } } */\n-/* { dg-final { scan-assembler-not \"friz\" } } */\n+/* { dg-options \"-O2 -mcpu=power7 -ffast-math -mno-upper-regs-df\" } */\n+/* { dg-final { scan-assembler \"friz\" } } */\n \n double round_double_llong (double a)\n {"}, {"sha": "572dec628d6e9bb7ffd8fb9d6e0137ca5c691dfe", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-2.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -6,8 +6,9 @@\n /* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n /* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n /* { dg-final { scan-assembler-times \"fcfid \" 10 } } */\n-/* { dg-final { scan-assembler-not \"fcfids\" } } */\n-/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n+/* { dg-final { scan-assembler-not \"fcfids \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidu \" } } */\n /* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n /* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n "}, {"sha": "984d3f3f07cd7138ce9ed5293b6bf674e3f7f1e0", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-3.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -7,10 +7,11 @@\n /* { dg-final { scan-assembler-not \"lfiwax\" } } */\n /* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n /* { dg-final { scan-assembler-times \"fcfid \" 10 } } */\n-/* { dg-final { scan-assembler-not \"fcfids\" } } */\n-/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n-/* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n-/* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n+/* { dg-final { scan-assembler-not \"fcfids \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidu \" } } */\n+/* { dg-final { scan-assembler-not \"xscvsxddp \" } } */\n+/* { dg-final { scan-assembler-not \"xscvuxddp \" } } */\n \n void int_to_float (float *dest, int *src)\n {"}, {"sha": "dc1f710321afbc9f23f73b2157af2887c58b32b6", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-4.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-4.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -6,10 +6,11 @@\n /* { dg-final { scan-assembler-not \"lfiwax\" } } */\n /* { dg-final { scan-assembler-not \"lfiwzx\" } } */\n /* { dg-final { scan-assembler-not \"fcfid \" } } */\n-/* { dg-final { scan-assembler-not \"fcfids\" } } */\n-/* { dg-final { scan-assembler-not \"fcfidus\" } } */\n-/* { dg-final { scan-assembler-not \"xscvsxddp\" } } */\n-/* { dg-final { scan-assembler-not \"xscvuxddp\" } } */\n+/* { dg-final { scan-assembler-not \"fcfids \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidus \" } } */\n+/* { dg-final { scan-assembler-not \"fcfidu \" } } */\n+/* { dg-final { scan-assembler-not \"xscvsxddp \" } } */\n+/* { dg-final { scan-assembler-not \"xscvuxddp \" } } */\n \n void int_to_float (float *dest, int *src)\n {"}, {"sha": "c44eb08231caa4453561525fd861c3f5b280e622", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-5.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-5.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -2,13 +2,13 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O3 -mcpu=power7 -ffast-math\" } */\n-/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fctiwuz\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fctidz\" 1 } } */\n-/* { dg-final { scan-assembler-times \"fctiduz\" 1 } } */\n-/* { dg-final { scan-assembler-times \"xscvdpsxds\" 1 } } */\n-/* { dg-final { scan-assembler-times \"xscvdpuxds\" 1 } } */\n+/* { dg-options \"-O3 -mcpu=power7 -ffast-math -mno-upper-regs-df\" } */\n+/* { dg-final { scan-assembler-times \"fctiwz \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwuz \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctidz \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiduz \" 2 } } */\n+/* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n+/* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n \n void float_to_int  (int *dest, float  src) { *dest = (int) src; }\n void double_to_int (int *dest, double src) { *dest = (int) src; }"}, {"sha": "5282a5a429379a7e4286854294462a7abb55afd8", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-6.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-6.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -3,10 +3,11 @@\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power6\" } } */\n /* { dg-options \"-O3 -mcpu=power6 -ffast-math\" } */\n-/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n-/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n-/* { dg-final { scan-assembler-times \"fctidz\" 8 } } */\n-/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-times \"fctiwz \" 2 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz \" } } */\n+/* { dg-final { scan-assembler-times \"fctidz \" 8 } } */\n+/* { dg-final { scan-assembler-not \"fctiduz \" } } */\n+/* { dg-final { scan-assembler-not \"fctidu \" } } */\n /* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n /* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n "}, {"sha": "fa0b50edb3081e9df5e07b2ca2ea4a9219d4f190", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-7.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -4,10 +4,11 @@\n /* { dg-require-effective-target powerpc_fprs } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power5\" } } */\n /* { dg-options \"-O3 -mcpu=power5 -ffast-math\" } */\n-/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n-/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n-/* { dg-final { scan-assembler-times \"fctidz\" 8 } } */\n-/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-times \"fctiwz \" 2 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz \" } } */\n+/* { dg-final { scan-assembler-times \"fctidz \" 8 } } */\n+/* { dg-final { scan-assembler-not \"fctiduz \" } } */\n+/* { dg-final { scan-assembler-not \"fctidu \" } } */\n /* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n /* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n "}, {"sha": "5f1bb23c50eec107006deb7703721ca158ac023c", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-8.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -4,10 +4,11 @@\n /* { dg-require-effective-target powerpc_fprs } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=750\" } } */\n /* { dg-options \"-O3 -mcpu=750 -ffast-math\" } */\n-/* { dg-final { scan-assembler-times \"fctiwz\" 6 } } */\n-/* { dg-final { scan-assembler-not \"fctiwuz\" } } */\n-/* { dg-final { scan-assembler-not \"fctidz\" } } */\n-/* { dg-final { scan-assembler-not \"fctiduz\" } } */\n+/* { dg-final { scan-assembler-times \"fctiwz \" 6 } } */\n+/* { dg-final { scan-assembler-not \"fctiwuz \" } } */\n+/* { dg-final { scan-assembler-not \"fctidz \" } } */\n+/* { dg-final { scan-assembler-not \"fctiduz \" } } */\n+/* { dg-final { scan-assembler-not \"fctidu \" } } */\n /* { dg-final { scan-assembler-not \"xscvdpsxds\" } } */\n /* { dg-final { scan-assembler-not \"xscvdpuxds\" } } */\n "}, {"sha": "62ead0a9e4f09a8cca6ba02dc9f7e1b7b38203b6", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-fpconv-9.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-fpconv-9.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -2,7 +2,8 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O3 -mcpu=power7 -ffast-math\" } */\n+/* { dg-options \"-O3 -mcpu=power7 -ffast-math -mno-upper-regs-df\" } */\n+/* { dg-final { scan-assembler-times \"fctidz\" 2 } } */\n /* { dg-final { scan-assembler-not \"lwz\" } } */\n /* { dg-final { scan-assembler-not \"stw\" } } */\n /* { dg-final { scan-assembler-not \"ld \" } } */"}, {"sha": "4fc1679622d2c8e9db416e94739d15d95c7f13ff", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-round.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c307d8f7eca608544d183c8c3d068a40571676c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round.c?ref=0c307d8f7eca608544d183c8c3d068a40571676c", "patch": "@@ -2,13 +2,13 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-options \"-O2 -mcpu=power7 -mno-upper-regs-df\" } */\n /* { dg-final { scan-assembler-times \"stfiwx\" 4 } } */\n /* { dg-final { scan-assembler-times \"lfiwax\" 2 } } */\n /* { dg-final { scan-assembler-times \"lfiwzx\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fctiwz\" 2 } } */\n-/* { dg-final { scan-assembler-times \"xscvsxddp\" 2 } } */\n-/* { dg-final { scan-assembler-times \"fcfids\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwz \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwuz \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fcfids \" 2 } } */\n /* { dg-final { scan-assembler-not \"lwz\" } } */\n /* { dg-final { scan-assembler-not \"stw\" } } */\n "}]}