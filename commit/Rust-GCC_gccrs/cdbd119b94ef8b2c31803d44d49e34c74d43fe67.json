{"sha": "cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiZDExOWI5NGVmOGIyYzMxODAzZDQ0ZDQ5ZTM0Yzc0ZDQzZmU2Nw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-03-25T16:29:15Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-03-25T16:29:15Z"}, "message": "functional: Formatting fixes.\n\n2007-03-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/functional: Formatting fixes.\n\nFrom-SVN: r123199", "tree": {"sha": "ebd9a35b58118c1bc8f5b7a0541240b540e1dc26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebd9a35b58118c1bc8f5b7a0541240b540e1dc26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbd119b94ef8b2c31803d44d49e34c74d43fe67/comments", "author": null, "committer": null, "parents": [{"sha": "a5ad201780aeaec0ef6698bb7fa2e6e8c4c7a4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ad201780aeaec0ef6698bb7fa2e6e8c4c7a4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5ad201780aeaec0ef6698bb7fa2e6e8c4c7a4e7"}], "stats": {"total": 1328, "additions": 687, "deletions": 641}, "files": [{"sha": "8a9ccd3e58079d034727e585118296f13dd6c2f6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbd119b94ef8b2c31803d44d49e34c74d43fe67/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbd119b94ef8b2c31803d44d49e34c74d43fe67/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "patch": "@@ -1,3 +1,7 @@\n+2007-03-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/functional: Formatting fixes.\n+\n 2007-03-23  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc:"}, {"sha": "7b269fa06cf3c1ac0d93a331c11f9c3c8a080e87", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 683, "deletions": 641, "changes": 1324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbd119b94ef8b2c31803d44d49e34c74d43fe67/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbd119b94ef8b2c31803d44d49e34c74d43fe67/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=cdbd119b94ef8b2c31803d44d49e34c74d43fe67", "patch": "@@ -63,8 +63,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     class _Has_result_type_helper : __sfinae_types\n     {\n       template<typename _Up>\n-      struct _Wrap_type\n-      { };\n+        struct _Wrap_type\n+\t{ };\n \n       template<typename _Up>\n         static __one __test(_Wrap_type<typename _Up::result_type>*);\n@@ -78,9 +78,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   template<typename _Tp>\n     struct _Has_result_type\n-       : integral_constant<\n-           bool,\n-           _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n+    : integral_constant<bool,\n+\t      _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>\n     { };\n \n   /**\n@@ -229,9 +228,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */ \n   template<typename _Functor, typename... _ArgTypes>\n     class result_of<_Functor(_ArgTypes...)>\n-      : public _Result_of_impl<\n-                 _Has_result_type<_Weak_result_type<_Functor> >::value,\n-                 _Functor(_ArgTypes...)>\n+    : public _Result_of_impl<\n+               _Has_result_type<_Weak_result_type<_Functor> >::value,\n+               _Functor(_ArgTypes...)>\n     {\n     };\n \n@@ -337,11 +336,11 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename __gnu_cxx::__enable_if<\n-               (!is_member_pointer<_Functor>::value\n-                && !is_function<_Functor>::value\n-                && !is_function<typename remove_pointer<_Functor>::type>::value),\n-               typename result_of<_Functor(_Args...)>::type\n-             >::__type\n+             (!is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n     __invoke(_Functor& __f, _Args&... __args)\n     {\n       return __f(__args...);\n@@ -350,11 +349,11 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename __gnu_cxx::__enable_if<\n-               (is_member_pointer<_Functor>::value\n-                && !is_function<_Functor>::value\n-                && !is_function<typename remove_pointer<_Functor>::type>::value),\n-               typename result_of<_Functor(_Args...)>::type\n-             >::__type\n+             (is_member_pointer<_Functor>::value\n+              && !is_function<_Functor>::value\n+              && !is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n     __invoke(_Functor& __f, _Args&... __args)\n     {\n       return mem_fn(__f)(__args...);\n@@ -364,10 +363,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename __gnu_cxx::__enable_if<\n-               (is_pointer<_Functor>::value\n-                && is_function<typename remove_pointer<_Functor>::type>::value),\n-               typename result_of<_Functor(_Args...)>::type\n-             >::__type\n+             (is_pointer<_Functor>::value\n+              && is_function<typename remove_pointer<_Functor>::type>::value),\n+             typename result_of<_Functor(_Args...)>::type\n+           >::__type\n     __invoke(_Functor __f, _Args&... __args)\n     {\n       return __f(__args...);\n@@ -507,7 +506,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   template<typename _Tp>\n     class reference_wrapper\n-      : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n+    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>\n     {\n       // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n       // so turn it into a function pointer type.\n@@ -517,7 +516,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       _Tp* _M_data;\n     public:\n       typedef _Tp type;\n-      explicit reference_wrapper(_Tp& __indata): _M_data(&__indata)\n+\n+      explicit\n+      reference_wrapper(_Tp& __indata): _M_data(&__indata)\n       { }\n \n       reference_wrapper(const reference_wrapper<_Tp>& __inref):\n@@ -539,11 +540,11 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       { return *_M_data; }\n \n       template<typename... _Args>\n-      typename result_of<_M_func_type(_Args...)>::type\n-      operator()(_Args&... __args) const\n-      {\n-        return __invoke(get(), __args...);\n-      }\n+        typename result_of<_M_func_type(_Args...)>::type\n+        operator()(_Args&... __args) const\n+        {\n+\t  return __invoke(get(), __args...);\n+\t}\n     };\n \n \n@@ -598,7 +599,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */ \n    template<typename _Res, typename _T1> \n      struct _Maybe_unary_or_binary_function<_Res, _T1>\n-      : std::unary_function<_T1, _Res> { };\n+     : std::unary_function<_T1, _Res> { };\n \n   /**\n    * @if maint\n@@ -607,7 +608,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */ \n    template<typename _Res, typename _T1, typename _T2> \n      struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n-      : std::binary_function<_T1, _T2, _Res> { };\n+     : std::binary_function<_T1, _T2, _Res> { };\n \n   /**\n    * @if maint\n@@ -616,7 +617,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n-      : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...);\n \n@@ -637,16 +638,19 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res operator()(_Class& __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(_Class& __object, _ArgTypes... __args) const\n       { return (__object.*__pmf)(__args...); }\n \n       // Handle pointers\n-      _Res operator()(_Class* __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(_Class* __object, _ArgTypes... __args) const\n       { return (__object->*__pmf)(__args...); }\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n         { return _M_call(__object, &__object, __args...); }\n \n     private:\n@@ -660,8 +664,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n-      : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n-                                               _ArgTypes...>\n+    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n \n@@ -682,11 +686,13 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res operator()(const _Class& __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(const _Class& __object, _ArgTypes... __args) const\n       { return (__object.*__pmf)(__args...); }\n \n       // Handle pointers\n-      _Res operator()(const _Class* __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(const _Class* __object, _ArgTypes... __args) const\n       { return (__object->*__pmf)(__args...); }\n \n       // Handle smart pointers, references and pointers to derived\n@@ -705,8 +711,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n-      : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n-                                               _ArgTypes...>\n+    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n \n@@ -727,16 +733,19 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res operator()(volatile _Class& __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(volatile _Class& __object, _ArgTypes... __args) const\n       { return (__object.*__pmf)(__args...); }\n \n       // Handle pointers\n-      _Res operator()(volatile _Class* __object, _ArgTypes... __args) const\n+      _Res\n+      operator()(volatile _Class* __object, _ArgTypes... __args) const\n       { return (__object->*__pmf)(__args...); }\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        _Res\n+\toperator()(_Tp& __object, _ArgTypes... __args) const\n         { return _M_call(__object, &__object, __args...); }\n \n     private:\n@@ -750,8 +759,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n-      : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n-                                               _ArgTypes...>\n+    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+\t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n \n@@ -792,94 +801,97 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n \n   template<typename _Res, typename _Class>\n-  class _Mem_fn<_Res _Class::*>\n-  {\n-    // This bit of genius is due to Peter Dimov, improved slightly by\n-    // Douglas Gregor.\n-    template<typename _Tp>\n-      _Res&\n-      _M_call(_Tp& __object, _Class *) const\n-      { return __object.*__pm; }\n+    class _Mem_fn<_Res _Class::*>\n+    {\n+      // This bit of genius is due to Peter Dimov, improved slightly by\n+      // Douglas Gregor.\n+      template<typename _Tp>\n+        _Res&\n+        _M_call(_Tp& __object, _Class *) const\n+        { return __object.*__pm; }\n \n-    template<typename _Tp, typename _Up>\n-      _Res&\n-      _M_call(_Tp& __object, _Up * const *) const\n-      { return (*__object).*__pm; }\n+      template<typename _Tp, typename _Up>\n+        _Res&\n+        _M_call(_Tp& __object, _Up * const *) const\n+        { return (*__object).*__pm; }\n \n-    template<typename _Tp, typename _Up>\n-      const _Res&\n-      _M_call(_Tp& __object, const _Up * const *) const\n-      { return (*__object).*__pm; }\n+      template<typename _Tp, typename _Up>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Up * const *) const\n+        { return (*__object).*__pm; }\n \n-    template<typename _Tp>\n-      const _Res&\n-      _M_call(_Tp& __object, const _Class *) const\n-      { return __object.*__pm; }\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __object, const _Class *) const\n+        { return __object.*__pm; }\n \n-    template<typename _Tp>\n-      const _Res&\n-      _M_call(_Tp& __ptr, const volatile void*) const\n-      { return (*__ptr).*__pm; }\n+      template<typename _Tp>\n+        const _Res&\n+        _M_call(_Tp& __ptr, const volatile void*) const\n+        { return (*__ptr).*__pm; }\n \n-    template<typename _Tp> static _Tp& __get_ref();\n+      template<typename _Tp> static _Tp& __get_ref();\n \n-    template<typename _Tp>\n-      static __sfinae_types::__one __check_const(_Tp&, _Class*);\n-    template<typename _Tp, typename _Up>\n-      static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n-    template<typename _Tp, typename _Up>\n-      static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n-    template<typename _Tp>\n-      static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n-    template<typename _Tp>\n-      static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+      template<typename _Tp>\n+        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+      template<typename _Tp, typename _Up>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+      template<typename _Tp>\n+        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n \n   public:\n-    template<typename _Tp>\n-      struct _Result_type\n-      : _Mem_fn_const_or_non<\n-        _Res,\n-        (sizeof(__sfinae_types::__two)\n-\t == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n-      { };\n+      template<typename _Tp>\n+        struct _Result_type\n+\t: _Mem_fn_const_or_non<_Res,\n+\t  (sizeof(__sfinae_types::__two)\n+\t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+        { };\n \n-    template<typename _Signature>\n-      struct result;\n+      template<typename _Signature>\n+        struct result;\n \n-    template<typename _CVMem, typename _Tp>\n-      struct result<_CVMem(_Tp)>\n-      : public _Result_type<_Tp> { };\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp)>\n+\t: public _Result_type<_Tp> { };\n \n-    template<typename _CVMem, typename _Tp>\n-      struct result<_CVMem(_Tp&)>\n-      : public _Result_type<_Tp> { };\n+      template<typename _CVMem, typename _Tp>\n+        struct result<_CVMem(_Tp&)>\n+\t: public _Result_type<_Tp> { };\n \n-    explicit _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n+      explicit\n+      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n \n-    // Handle objects\n-    _Res&       operator()(_Class& __object)       const\n-    { return __object.*__pm; }\n+      // Handle objects\n+      _Res&\n+      operator()(_Class& __object) const\n+      { return __object.*__pm; }\n \n-    const _Res& operator()(const _Class& __object) const\n-    { return __object.*__pm; }\n+      const _Res&\n+      operator()(const _Class& __object) const\n+      { return __object.*__pm; }\n \n-    // Handle pointers\n-    _Res&       operator()(_Class* __object)       const\n-    { return __object->*__pm; }\n+      // Handle pointers\n+      _Res&\n+      operator()(_Class* __object) const\n+      { return __object->*__pm; }\n \n-    const _Res&\n-    operator()(const _Class* __object) const\n-    { return __object->*__pm; }\n+      const _Res&\n+      operator()(const _Class* __object) const\n+      { return __object->*__pm; }\n \n-    // Handle smart pointers and derived\n-    template<typename _Tp>\n-      typename _Result_type<_Tp>::type\n-      operator()(_Tp& __unknown) const\n-      { return _M_call(__unknown, &__unknown); }\n+      // Handle smart pointers and derived\n+      template<typename _Tp>\n+        typename _Result_type<_Tp>::type\n+        operator()(_Tp& __unknown) const\n+        { return _M_call(__unknown, &__unknown); }\n \n-  private:\n-    _Res _Class::*__pm;\n-  };\n+    private:\n+      _Res _Class::*__pm;\n+    };\n \n   /**\n    *  @brief Returns a function object that forwards to the member\n@@ -985,20 +997,20 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    *  @endif\n    */\n   template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n-  struct _Build_index_tuple;\n+    struct _Build_index_tuple;\n  \n   template<std::size_t _Num, int... _Indexes> \n-  struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n+    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n     : _Build_index_tuple<_Num - 1, \n                          _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n-  {\n-  };\n+    {\n+    };\n \n   template<int... _Indexes>\n-  struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n-  {\n-    typedef _Index_tuple<_Indexes...> __type;\n-  };\n+    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n+    {\n+      typedef _Index_tuple<_Indexes...> __type;\n+    };\n \n   /** \n    * @if maint\n@@ -1017,7 +1029,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<int __i, typename _Tuple, bool _IsSafe>\n     struct _Safe_tuple_element_impl\n-      : tuple_element<__i, _Tuple> { };\n+    : tuple_element<__i, _Tuple> { };\n \n   /**\n    * @if maint\n@@ -1038,8 +1050,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n  template<int __i, typename _Tuple>\n    struct _Safe_tuple_element\n-     : _Safe_tuple_element_impl<__i, _Tuple, \n-                                (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   : _Safe_tuple_element_impl<__i, _Tuple, \n+                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n    {\n    };\n \n@@ -1078,9 +1090,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n        * but not volatile-qualified. This might be a defect in the TR.\n        */\n       template<typename _CVRef, typename _Tuple>\n-      result_type\n-      operator()(_CVRef& __arg, const _Tuple&) const volatile\n-      { return __arg.get(); }\n+        result_type\n+        operator()(_CVRef& __arg, const _Tuple&) const volatile\n+        { return __arg.get(); }\n     };\n \n   /**\n@@ -1100,29 +1112,30 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       // involves passing along the cv-qualifiers placed on _Mu and\n       // unwrapping the argument bundle.\n       template<typename _CVMu, typename _CVArg, typename... _Args>\n-      class result<_CVMu(_CVArg, tuple<_Args...>)>\n-        : public result_of<_CVArg(_Args...)> { };\n+        class result<_CVMu(_CVArg, tuple<_Args...>)>\n+\t: public result_of<_CVArg(_Args...)> { };\n \n       template<typename _CVArg, typename... _Args>\n-      typename result_of<_CVArg(_Args...)>::type\n-      operator()(_CVArg& __arg, const tuple<_Args...>& __tuple)\n-        const volatile\n-      {\n-        // Construct an index tuple and forward to __call\n-        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indexes;\n-        return this->__call(__arg, __tuple, _Indexes());\n-      }     \n+        typename result_of<_CVArg(_Args...)>::type\n+        operator()(_CVArg& __arg,\n+\t\t   const tuple<_Args...>& __tuple) const volatile\n+        {\n+\t  // Construct an index tuple and forward to __call\n+\t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n+\t    _Indexes;\n+\t  return this->__call(__arg, __tuple, _Indexes());\n+\t}\n \n     private:\n       // Invokes the underlying function object __arg by unpacking all\n       // of the arguments in the tuple. \n       template<typename _CVArg, typename... _Args, int... _Indexes>\n-      typename result_of<_CVArg(_Args...)>::type\n-      __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n-             const _Index_tuple<_Indexes...>&) const volatile\n-      {\n-        return __arg(_GLIBCXX_TR1::get<_Indexes>(__tuple)...);\n-      }\n+        typename result_of<_CVArg(_Args...)>::type\n+        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+\t       const _Index_tuple<_Indexes...>&) const volatile\n+        {\n+\t  return __arg(_GLIBCXX_TR1::get<_Indexes>(__tuple)...);\n+\t}\n     };\n \n   /**\n@@ -1139,24 +1152,26 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       template<typename _Signature> class result;\n \n       template<typename _CVMu, typename _CVArg, typename _Tuple>\n-      class result<_CVMu(_CVArg, _Tuple)>\n-      {\n-        // Add a reference, if it hasn't already been done for us.\n-        // This allows us to be a little bit sloppy in constructing\n-        // the tuple that we pass to result_of<...>.\n-        typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value - 1),\n-                                             _Tuple>::type __base_type;\n+        class result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  // Add a reference, if it hasn't already been done for us.\n+\t  // This allows us to be a little bit sloppy in constructing\n+\t  // the tuple that we pass to result_of<...>.\n+\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n+\t\t\t\t\t\t- 1), _Tuple>::type\n+\t    __base_type;\n \n-      public:\n-        typedef typename add_reference<__base_type>::type type;\n-      };\n+\tpublic:\n+\t  typedef typename add_reference<__base_type>::type type;\n+\t};\n \n       template<typename _Tuple>\n-      typename result<_Mu(_Arg, _Tuple)>::type\n-      operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n-      {\n-        return ::std::_GLIBCXX_TR1::get<(is_placeholder<_Arg>::value - 1)>(__tuple);\n-      }\n+        typename result<_Mu(_Arg, _Tuple)>::type\n+        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile\n+        {\n+\t  return ::std::_GLIBCXX_TR1::get<(is_placeholder<_Arg>::value\n+\t\t\t\t\t   - 1)>(__tuple);\n+\t}\n     };\n \n   /**\n@@ -1173,15 +1188,16 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       template<typename _Signature> struct result;\n \n       template<typename _CVMu, typename _CVArg, typename _Tuple>\n-      struct result<_CVMu(_CVArg, _Tuple)>\n-      {\n-        typedef typename add_reference<_CVArg>::type type;\n-      };\n+        struct result<_CVMu(_CVArg, _Tuple)>\n+        {\n+\t  typedef typename add_reference<_CVArg>::type type;\n+\t};\n \n       // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n-      _CVArg& operator()(_CVArg& __arg, const _Tuple&) const volatile\n-      { return __arg; }\n+        _CVArg&\n+        operator()(_CVArg& __arg, const _Tuple&) const volatile\n+        { return __arg; }\n     };\n \n   /**\n@@ -1195,7 +1211,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     struct _Maybe_wrap_member_pointer\n     {\n       typedef _Tp type;\n-      static const _Tp& __do_wrap(const _Tp& __x) { return __x; }\n+      \n+      static const _Tp&\n+      __do_wrap(const _Tp& __x)\n+      { return __x; }\n     };\n \n   /**\n@@ -1209,7 +1228,10 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n     {\n       typedef _Mem_fn<_Tp _Class::*> type;\n-      static type __do_wrap(_Tp _Class::* __pm) { return type(__pm); }\n+      \n+      static type\n+      __do_wrap(_Tp _Class::* __pm)\n+      { return type(__pm); }\n     };\n \n   /**\n@@ -1222,7 +1244,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n    template<typename _Functor, typename... _Bound_args>\n     class _Bind<_Functor(_Bound_args...)>\n-      : public _Weak_result_type<_Functor>\n+    : public _Weak_result_type<_Functor>\n     {\n       typedef _Bind __self_type;\n       typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n@@ -1393,8 +1415,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n      public:\n       typedef _Result result_type;\n \n-      explicit _Bind_result(_Functor __f, _Bound_args... __bound_args)\n-        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+      explicit\n+      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n+      : _M_f(__f), _M_bound_args(__bound_args...) { }\n \n       // Call unqualified\n       template<typename... _Args>\n@@ -1412,7 +1435,6 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n         }\n \n-\n       // Call as volatile\n       template<typename... _Args>\n         result_type\n@@ -1421,7 +1443,6 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n         }\n \n-\n       // Call as const volatile\n       template<typename... _Args>\n         result_type\n@@ -1466,21 +1487,21 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     } \n \n   template<typename _Result, typename _Functor, typename... _ArgTypes>\n-  inline\n-  _Bind_result<_Result,\n-               typename _Maybe_wrap_member_pointer<_Functor>::type\n-                          (_ArgTypes...)>\n-  bind(_Functor __f, _ArgTypes... __args)\n-  {\n-    typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-    typedef typename __maybe_type::type __functor_type;\n-    typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n-      __result_type;\n-    return __result_type(__maybe_type::__do_wrap(__f), __args...);\n-  } \n+    inline\n+    _Bind_result<_Result,\n+\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n+                            (_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n+\t__result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    }\n \n-   template<typename _Result, typename _Signature>\n-     const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n+  template<typename _Result, typename _Signature>\n+    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n \n   /**\n    *  @brief Exception class thrown when class template function's\n@@ -1523,15 +1544,20 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     void (_Undefined_class::*_M_member_pointer)();\n   };\n \n-  union _Any_data {\n+  union _Any_data\n+  {\n     void*       _M_access()       { return &_M_pod_data[0]; }\n     const void* _M_access() const { return &_M_pod_data[0]; }\n \n-    template<typename _Tp> _Tp& _M_access()\n-    { return *static_cast<_Tp*>(_M_access()); }\n+    template<typename _Tp>\n+      _Tp&\n+      _M_access()\n+      { return *static_cast<_Tp*>(_M_access()); }\n \n-    template<typename _Tp> const _Tp& _M_access() const\n-    { return *static_cast<const _Tp*>(_M_access()); }\n+    template<typename _Tp>\n+      const _Tp&\n+      _M_access() const\n+      { return *static_cast<const _Tp*>(_M_access()); }\n \n     _Nocopy_types _M_unused;\n     char _M_pod_data[sizeof(_Nocopy_types)];\n@@ -1557,7 +1583,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   template<typename _Tp>\n     struct __is_location_invariant<_Simple_type_wrapper<_Tp> >\n-      : __is_location_invariant<_Tp>\n+    : __is_location_invariant<_Tp>\n     {\n     };\n \n@@ -1591,172 +1617,174 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     static const std::size_t _M_max_align = __alignof__(_Nocopy_types);\n \n     template<typename _Functor>\n-    class _Base_manager\n-    {\n-    protected:\n-      static const bool __stored_locally =\n+      class _Base_manager\n+      {\n+      protected:\n+\tstatic const bool __stored_locally =\n         (__is_location_invariant<_Functor>::value\n          && sizeof(_Functor) <= _M_max_size\n          && __alignof__(_Functor) <= _M_max_align\n          && (_M_max_align % __alignof__(_Functor) == 0));\n-      typedef integral_constant<bool, __stored_locally> _Local_storage;\n-\n-      // Retrieve a pointer to the function object\n-      static _Functor* _M_get_pointer(const _Any_data& __source)\n-      {\n-        const _Functor* __ptr =\n-          __stored_locally? &__source._M_access<_Functor>()\n-          /* have stored a pointer */ : __source._M_access<_Functor*>();\n-        return const_cast<_Functor*>(__ptr);\n-      }\n-\n-      // Clone a location-invariant function object that fits within\n-      // an _Any_data structure.\n-      static void\n-      _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n-      {\n-        new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n-      }\n-\n-      // Clone a function object that is not location-invariant or\n-      // that cannot fit into an _Any_data structure.\n-      static void\n-      _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n-      {\n-        __dest._M_access<_Functor*>() =\n-          new _Functor(*__source._M_access<_Functor*>());\n-      }\n-\n-      // Destroying a location-invariant object may still require\n-      // destruction.\n-      static void\n-      _M_destroy(_Any_data& __victim, true_type)\n-      {\n-        __victim._M_access<_Functor>().~_Functor();\n-      }\n-\n-      // Destroying an object located on the heap.\n-      static void\n-      _M_destroy(_Any_data& __victim, false_type)\n-      {\n-        delete __victim._M_access<_Functor*>();\n-      }\n-\n-    public:\n-      static bool\n-      _M_manager(_Any_data& __dest, const _Any_data& __source,\n-                 _Manager_operation __op)\n-      {\n-        switch (__op) {\n-        case __get_type_info:\n-          __dest._M_access<const type_info*>() = &typeid(_Functor);\n-          break;\n-\n-        case __get_functor_ptr:\n-          __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n-          break;\n-\n-        case __clone_functor:\n-          _M_clone(__dest, __source, _Local_storage());\n-          break;\n-\n-        case __destroy_functor:\n-          _M_destroy(__dest, _Local_storage());\n-          break;\n-        }\n-        return false;\n-      }\n-\n-      static void\n-      _M_init_functor(_Any_data& __functor, const _Functor& __f)\n-      {\n-        _M_init_functor(__functor, __f, _Local_storage());\n-      }\n-\n-      template<typename _Signature>\n-      static bool\n-      _M_not_empty_function(const function<_Signature>& __f)\n-      {\n-        return __f;\n-      }\n-\n-      template<typename _Tp>\n-      static bool\n-      _M_not_empty_function(const _Tp*& __fp)\n-      {\n-        return __fp;\n-      }\n-\n-      template<typename _Class, typename _Tp>\n-      static bool\n-      _M_not_empty_function(_Tp _Class::* const& __mp)\n-      {\n-        return __mp;\n-      }\n-\n-      template<typename _Tp>\n-      static bool\n-      _M_not_empty_function(const _Tp&)\n-      {\n-        return true;\n-      }\n-\n-    private:\n-      static void\n-      _M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n-      {\n-        new (__functor._M_access()) _Functor(__f);\n-      }\n-\n-      static void\n-      _M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n-      {\n-        __functor._M_access<_Functor*>() = new _Functor(__f);\n-      }\n-    };\n+\t\n+\ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n+\n+\t// Retrieve a pointer to the function object\n+\tstatic _Functor*\n+\t_M_get_pointer(const _Any_data& __source)\n+\t{\n+\t  const _Functor* __ptr =\n+\t    __stored_locally? &__source._M_access<_Functor>()\n+\t    /* have stored a pointer */ : __source._M_access<_Functor*>();\n+\t  return const_cast<_Functor*>(__ptr);\n+\t}\n+\n+\t// Clone a location-invariant function object that fits within\n+\t// an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)\n+\t{\n+\t  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());\n+\t}\n+\n+\t// Clone a function object that is not location-invariant or\n+\t// that cannot fit into an _Any_data structure.\n+\tstatic void\n+\t_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)\n+\t{\n+\t  __dest._M_access<_Functor*>() =\n+\t    new _Functor(*__source._M_access<_Functor*>());\n+\t}\n+\n+\t// Destroying a location-invariant object may still require\n+\t// destruction.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, true_type)\n+\t{\n+\t  __victim._M_access<_Functor>().~_Functor();\n+\t}\n+\t\n+\t// Destroying an object located on the heap.\n+\tstatic void\n+\t_M_destroy(_Any_data& __victim, false_type)\n+\t{\n+\t  delete __victim._M_access<_Functor*>();\n+\t}\n+\t\n+      public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+\n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n+\t      break;\n+\t      \n+\t    case __clone_functor:\n+\t      _M_clone(__dest, __source, _Local_storage());\n+\t      break;\n+\n+\t    case __destroy_functor:\n+\t      _M_destroy(__dest, _Local_storage());\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f)\n+\t{\n+\t  _M_init_functor(__functor, __f, _Local_storage());\n+\t}\n+\t\n+\ttemplate<typename _Signature>\n+\t  static bool\n+\t  _M_not_empty_function(const function<_Signature>& __f)\n+\t  {\n+\t    return __f;\n+\t  }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp*& __fp)\n+\t  {\n+\t    return __fp;\n+\t  }\n+\n+\ttemplate<typename _Class, typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(_Tp _Class::* const& __mp)\n+\t  {\n+\t    return __mp;\n+\t  }\n+\n+\ttemplate<typename _Tp>\n+\t  static bool\n+\t  _M_not_empty_function(const _Tp&)\n+\t  {\n+\t    return true;\n+\t  }\n+\n+      private:\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)\n+\t{\n+\t  new (__functor._M_access()) _Functor(__f);\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)\n+\t{\n+\t  __functor._M_access<_Functor*>() = new _Functor(__f);\n+\t}\n+      };\n \n     template<typename _Functor>\n-    class _Ref_manager : public _Base_manager<_Functor*>\n-    {\n-      typedef _Function_base::_Base_manager<_Functor*> _Base;\n-\n-    public:\n-      static bool\n-      _M_manager(_Any_data& __dest, const _Any_data& __source,\n-                 _Manager_operation __op)\n+      class _Ref_manager : public _Base_manager<_Functor*>\n       {\n-        switch (__op) {\n-        case __get_type_info:\n-          __dest._M_access<const type_info*>() = &typeid(_Functor);\n-          break;\n-\n-        case __get_functor_ptr:\n-          __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n-          return is_const<_Functor>::value;\n-          break;\n-\n-        default:\n-          _Base::_M_manager(__dest, __source, __op);\n-        }\n-        return false;\n-      }\n+\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n \n-      static void\n-      _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n-      {\n-        // TBD: Use address_of function instead\n-        _Base::_M_init_functor(__functor, &__f.get());\n-      }\n-    };\n+    public:\n+\tstatic bool\n+\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n+\t\t   _Manager_operation __op)\n+\t{\n+\t  switch (__op)\n+\t    {\n+\t    case __get_type_info:\n+\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t      break;\n+\t      \n+\t    case __get_functor_ptr:\n+\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n+\t      return is_const<_Functor>::value;\n+\t      break;\n+\t      \n+\t    default:\n+\t      _Base::_M_manager(__dest, __source, __op);\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tstatic void\n+\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n+\t{\n+\t  // TBD: Use address_of function instead\n+\t  _Base::_M_init_functor(__functor, &__f.get());\n+\t}\n+      };\n \n     _Function_base() : _M_manager(0) { }\n-\n+    \n     ~_Function_base()\n     {\n       if (_M_manager)\n-        {\n-          _M_manager(_M_functor, _M_functor, __destroy_functor);\n-        }\n+\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n     }\n \n \n@@ -1774,38 +1802,41 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   template<typename _Res, typename _Functor, typename... _ArgTypes>\n     class _Function_handler<_Res(_ArgTypes...), _Functor>\n-      : public _Function_base::_Base_manager<_Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n     {\n       typedef _Function_base::_Base_manager<_Functor> _Base;\n \n     public:\n-      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n         return (*_Base::_M_get_pointer(__functor))(__args...);\n       }\n     };\n \n   template<typename _Functor, typename... _ArgTypes>\n     class _Function_handler<void(_ArgTypes...), _Functor>\n-      : public _Function_base::_Base_manager<_Functor>\n+    : public _Function_base::_Base_manager<_Functor>\n     {\n       typedef _Function_base::_Base_manager<_Functor> _Base;\n \n      public:\n-      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n         (*_Base::_M_get_pointer(__functor))(__args...);\n       }\n     };\n \n   template<typename _Res, typename _Functor, typename... _ArgTypes>\n     class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n-      : public _Function_base::_Ref_manager<_Functor>\n+    : public _Function_base::_Ref_manager<_Functor>\n     {\n       typedef _Function_base::_Ref_manager<_Functor> _Base;\n \n      public:\n-      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n         return \n           __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n@@ -1814,12 +1845,13 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n   template<typename _Functor, typename... _ArgTypes>\n     class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n-      : public _Function_base::_Ref_manager<_Functor>\n+    : public _Function_base::_Ref_manager<_Functor>\n     {\n       typedef _Function_base::_Ref_manager<_Functor> _Base;\n \n      public:\n-      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n         __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n       }\n@@ -1828,313 +1860,323 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<typename _Class, typename _Member, typename _Res, \n            typename... _ArgTypes>\n     class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n-      : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n     {\n       typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n         _Base;\n \n      public:\n-      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static _Res\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        return _GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+        return _GLIBCXX_TR1::\n+\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n       }\n     };\n \n   template<typename _Class, typename _Member, typename... _ArgTypes>\n     class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-      : public _Function_base::_Base_manager<\n+    : public _Function_base::_Base_manager<\n                  _Simple_type_wrapper< _Member _Class::* > >\n     {\n       typedef _Member _Class::* _Functor;\n-      typedef _Simple_type_wrapper< _Functor > _Wrapper;\n+      typedef _Simple_type_wrapper<_Functor> _Wrapper;\n       typedef _Function_base::_Base_manager<_Wrapper> _Base;\n \n      public:\n       static bool\n       _M_manager(_Any_data& __dest, const _Any_data& __source,\n                  _Manager_operation __op)\n       {\n-        switch (__op) {\n-        case __get_type_info:\n-          __dest._M_access<const type_info*>() = &typeid(_Functor);\n-          break;\n-\n-        case __get_functor_ptr:\n-          __dest._M_access<_Functor*>() =\n-            &_Base::_M_get_pointer(__source)->__value;\n-          break;\n-\n-        default:\n-          _Base::_M_manager(__dest, __source, __op);\n-        }\n+        switch (__op)\n+\t  {\n+\t  case __get_type_info:\n+\t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n+\t    break;\n+\t    \n+\t  case __get_functor_ptr:\n+\t    __dest._M_access<_Functor*>() =\n+\t      &_Base::_M_get_pointer(__source)->__value;\n+\t    break;\n+\t    \n+\t  default:\n+\t    _Base::_M_manager(__dest, __source, __op);\n+\t  }\n         return false;\n       }\n \n-      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      static void\n+      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        _GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+        _GLIBCXX_TR1::\n+\t  mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n       }\n     };\n \n   template<typename _Res, typename... _ArgTypes>\n-  class function<_Res(_ArgTypes...)>\n+    class function<_Res(_ArgTypes...)>\n     : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n       private _Function_base\n-  {\n-    /**\n-     *  @if maint\n-     *  This class is used to implement the safe_bool idiom.\n-     *  @endif\n-     */\n-    struct _Hidden_type\n     {\n-      _Hidden_type* _M_bool;\n-    };\n+      /**\n+       *  @if maint\n+       *  This class is used to implement the safe_bool idiom.\n+       *  @endif\n+       */\n+      struct _Hidden_type\n+      {\n+\t_Hidden_type* _M_bool;\n+      };\n \n-    /**\n-     *  @if maint\n-     *  This typedef is used to implement the safe_bool idiom.\n-     *  @endif\n-     */\n-    typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n-\n-    typedef _Res _Signature_type(_ArgTypes...);\n-\n-    struct _Useless {};\n-\n-   public:\n-    typedef _Res result_type;\n-\n-    // [3.7.2.1] construct/copy/destroy\n-\n-    /**\n-     *  @brief Default construct creates an empty function call wrapper.\n-     *  @post @c !(bool)*this\n-     */\n-    function() : _Function_base() { }\n-\n-    /**\n-     *  @brief Default construct creates an empty function call wrapper.\n-     *  @post @c !(bool)*this\n-     */\n-    function(_M_clear_type*) : _Function_base() { }\n-\n-    /**\n-     *  @brief %Function copy constructor.\n-     *  @param x A %function object with identical call signature.\n-     *  @pre @c (bool)*this == (bool)x\n-     *\n-     *  The newly-created %function contains a copy of the target of @a\n-     *  x (if it has one).\n-     */\n-    function(const function& __x);\n-\n-    /**\n-     *  @brief Builds a %function that targets a copy of the incoming\n-     *  function object.\n-     *  @param f A %function object that is callable with parameters of\n-     *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-     *  to @c Res.\n-     *\n-     *  The newly-created %function object will target a copy of @a\n-     *  f. If @a f is @c reference_wrapper<F>, then this function\n-     *  object will contain a reference to the function object @c\n-     *  f.get(). If @a f is a NULL function pointer or NULL\n-     *  pointer-to-member, the newly-created object will be empty.\n-     *\n-     *  If @a f is a non-NULL function pointer or an object of type @c\n-     *  reference_wrapper<F>, this function will not throw.\n-     */\n-    template<typename _Functor>\n-      function(_Functor __f,\n-               typename __gnu_cxx::__enable_if<\n-                         !is_integral<_Functor>::value, _Useless>::__type\n-                 = _Useless());\n-\n-    /**\n-     *  @brief %Function assignment operator.\n-     *  @param x A %function with identical call signature.\n-     *  @post @c (bool)*this == (bool)x\n-     *  @returns @c *this\n-     *\n-     *  The target of @a x is copied to @c *this. If @a x has no\n-     *  target, then @c *this will be empty.\n-     *\n-     *  If @a x targets a function pointer or a reference to a function\n-     *  object, then this operation will not throw an exception.\n-     */\n-    function& operator=(const function& __x)\n+      /**\n+       *  @if maint\n+       *  This typedef is used to implement the safe_bool idiom.\n+       *  @endif\n+       */\n+      typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n+\n+      typedef _Res _Signature_type(_ArgTypes...);\n+      \n+      struct _Useless {};\n+      \n+    public:\n+      typedef _Res result_type;\n+      \n+      // [3.7.2.1] construct/copy/destroy\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function() : _Function_base() { }\n+      \n+      /**\n+       *  @brief Default construct creates an empty function call wrapper.\n+       *  @post @c !(bool)*this\n+       */\n+      function(_M_clear_type*) : _Function_base() { }\n+      \n+      /**\n+       *  @brief %Function copy constructor.\n+       *  @param x A %function object with identical call signature.\n+       *  @pre @c (bool)*this == (bool)x\n+       *\n+       *  The newly-created %function contains a copy of the target of @a\n+       *  x (if it has one).\n+       */\n+      function(const function& __x);\n+      \n+      /**\n+       *  @brief Builds a %function that targets a copy of the incoming\n+       *  function object.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *\n+       *  The newly-created %function object will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, the newly-created object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        function(_Functor __f,\n+                 typename __gnu_cxx::__enable_if<\n+                           !is_integral<_Functor>::value, _Useless>::__type\n+                   = _Useless());\n+\n+      /**\n+       *  @brief %Function assignment operator.\n+       *  @param x A %function with identical call signature.\n+       *  @post @c (bool)*this == (bool)x\n+       *  @returns @c *this\n+       *\n+       *  The target of @a x is copied to @c *this. If @a x has no\n+       *  target, then @c *this will be empty.\n+       *\n+       *  If @a x targets a function pointer or a reference to a function\n+       *  object, then this operation will not throw an exception.\n+       */\n+      function&\n+      operator=(const function& __x)\n       {\n         function(__x).swap(*this);\n         return *this;\n       }\n \n-    /**\n-     *  @brief %Function assignment to zero.\n-     *  @post @c !(bool)*this\n-     *  @returns @c *this\n-     *\n-     *  The target of @a *this is deallocated, leaving it empty.\n-     */\n-    function& operator=(_M_clear_type*)\n+      /**\n+       *  @brief %Function assignment to zero.\n+       *  @post @c !(bool)*this\n+       *  @returns @c *this\n+       *\n+       *  The target of @a *this is deallocated, leaving it empty.\n+       */\n+      function&\n+      operator=(_M_clear_type*)\n       {\n-        if (_M_manager) {\n-          _M_manager(_M_functor, _M_functor, __destroy_functor);\n-          _M_manager = 0;\n-          _M_invoker = 0;\n-        }\n+        if (_M_manager)\n+\t  {\n+\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n+\t    _M_manager = 0;\n+\t    _M_invoker = 0;\n+\t  }\n         return *this;\n       }\n \n-    /**\n-     *  @brief %Function assignment to a new target.\n-     *  @param f A %function object that is callable with parameters of\n-     *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-     *  to @c Res.\n-     *  @return @c *this\n-     *\n-     *  This  %function object wrapper will target a copy of @a\n-     *  f. If @a f is @c reference_wrapper<F>, then this function\n-     *  object will contain a reference to the function object @c\n-     *  f.get(). If @a f is a NULL function pointer or NULL\n-     *  pointer-to-member, @c this object will be empty.\n-     *\n-     *  If @a f is a non-NULL function pointer or an object of type @c\n-     *  reference_wrapper<F>, this function will not throw.\n-     */\n-    template<typename _Functor>\n-      typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n-                                      function&>::__type\n-      operator=(_Functor __f)\n+      /**\n+       *  @brief %Function assignment to a new target.\n+       *  @param f A %function object that is callable with parameters of\n+       *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+       *  to @c Res.\n+       *  @return @c *this\n+       *\n+       *  This  %function object wrapper will target a copy of @a\n+       *  f. If @a f is @c reference_wrapper<F>, then this function\n+       *  object will contain a reference to the function object @c\n+       *  f.get(). If @a f is a NULL function pointer or NULL\n+       *  pointer-to-member, @c this object will be empty.\n+       *\n+       *  If @a f is a non-NULL function pointer or an object of type @c\n+       *  reference_wrapper<F>, this function will not throw.\n+       */\n+      template<typename _Functor>\n+        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+\t                                function&>::__type\n+\toperator=(_Functor __f)\n+\t{\n+\t  function(__f).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      // [3.7.2.2] function modifiers\n+      \n+      /**\n+       *  @brief Swap the targets of two %function objects.\n+       *  @param f A %function with identical call signature.\n+       *\n+       *  Swap the targets of @c this function object and @a f. This\n+       *  function will not throw an exception.\n+       */\n+      void swap(function& __x)\n       {\n-        function(__f).swap(*this);\n-        return *this;\n+\t_Any_data __old_functor = _M_functor;\n+\t_M_functor = __x._M_functor;\n+\t__x._M_functor = __old_functor;\n+\t_Manager_type __old_manager = _M_manager;\n+\t_M_manager = __x._M_manager;\n+\t__x._M_manager = __old_manager;\n+\t_Invoker_type __old_invoker = _M_invoker;\n+\t_M_invoker = __x._M_invoker;\n+\t__x._M_invoker = __old_invoker;\n       }\n-\n-    // [3.7.2.2] function modifiers\n-\n-    /**\n-     *  @brief Swap the targets of two %function objects.\n-     *  @param f A %function with identical call signature.\n-     *\n-     *  Swap the targets of @c this function object and @a f. This\n-     *  function will not throw an exception.\n-     */\n-    void swap(function& __x)\n-    {\n-      _Any_data __old_functor = _M_functor;\n-      _M_functor = __x._M_functor;\n-      __x._M_functor = __old_functor;\n-      _Manager_type __old_manager = _M_manager;\n-      _M_manager = __x._M_manager;\n-      __x._M_manager = __old_manager;\n-      _Invoker_type __old_invoker = _M_invoker;\n-      _M_invoker = __x._M_invoker;\n-      __x._M_invoker = __old_invoker;\n-    }\n-\n-    // [3.7.2.3] function capacity\n-\n-    /**\n-     *  @brief Determine if the %function wrapper has a target.\n-     *\n-     *  @return @c true when this %function object contains a target,\n-     *  or @c false when it is empty.\n-     *\n-     *  This function will not throw an exception.\n-     */\n-    operator _Safe_bool() const\n+      \n+      // [3.7.2.3] function capacity\n+\n+      /**\n+       *  @brief Determine if the %function wrapper has a target.\n+       *\n+       *  @return @c true when this %function object contains a target,\n+       *  or @c false when it is empty.\n+       *\n+       *  This function will not throw an exception.\n+       */\n+      operator _Safe_bool() const\n       {\n         if (_M_empty())\n-          {\n-            return 0;\n-          }\n-        else\n-          {\n-            return &_Hidden_type::_M_bool;\n-          }\n+\t  return 0;\n+\telse\n+\t  return &_Hidden_type::_M_bool;\n       }\n \n-    // [3.7.2.4] function invocation\n-\n-    /**\n-     *  @brief Invokes the function targeted by @c *this.\n-     *  @returns the result of the target.\n-     *  @throws bad_function_call when @c !(bool)*this\n-     *\n-     *  The function call operator invokes the target function object\n-     *  stored by @c this.\n-     */\n-    _Res operator()(_ArgTypes... __args) const;\n-\n-    // [3.7.2.5] function target access\n-    /**\n-     *  @brief Determine the type of the target of this function object\n-     *  wrapper.\n-     *\n-     *  @returns the type identifier of the target function object, or\n-     *  @c typeid(void) if @c !(bool)*this.\n-     *\n-     *  This function will not throw an exception.\n-     */\n-    const type_info& target_type() const;\n-\n-    /**\n-     *  @brief Access the stored target function object.\n-     *\n-     *  @return Returns a pointer to the stored target function object,\n-     *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n-     *  pointer.\n-     *\n-     * This function will not throw an exception.\n-     */\n-    template<typename _Functor>       _Functor* target();\n-\n-    /**\n-     *  @overload\n-     */\n-    template<typename _Functor> const _Functor* target() const;\n-\n-   private:\n-    // [3.7.2.6] undefined operators\n-    template<typename _Function>\n-      void operator==(const function<_Function>&) const;\n-    template<typename _Function>\n-      void operator!=(const function<_Function>&) const;\n-\n-    typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n-    _Invoker_type _M_invoker;\n+      // [3.7.2.4] function invocation\n+\n+      /**\n+       *  @brief Invokes the function targeted by @c *this.\n+       *  @returns the result of the target.\n+       *  @throws bad_function_call when @c !(bool)*this\n+       *\n+       *  The function call operator invokes the target function object\n+       *  stored by @c this.\n+       */\n+      _Res operator()(_ArgTypes... __args) const;\n+      \n+      // [3.7.2.5] function target access\n+      /**\n+       *  @brief Determine the type of the target of this function object\n+       *  wrapper.\n+       *\n+       *  @returns the type identifier of the target function object, or\n+       *  @c typeid(void) if @c !(bool)*this.\n+       *\n+       *  This function will not throw an exception.\n+       */\n+      const type_info& target_type() const;\n+      \n+      /**\n+       *  @brief Access the stored target function object.\n+       *\n+       *  @return Returns a pointer to the stored target function object,\n+       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  pointer.\n+       *\n+       * This function will not throw an exception.\n+       */\n+      template<typename _Functor>       _Functor* target();\n+      \n+      /**\n+       *  @overload\n+       */\n+      template<typename _Functor> const _Functor* target() const;\n+      \n+    private:\n+      // [3.7.2.6] undefined operators\n+      template<typename _Function>\n+\tvoid operator==(const function<_Function>&) const;\n+      template<typename _Function>\n+\tvoid operator!=(const function<_Function>&) const;\n+\n+      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+      _Invoker_type _M_invoker;\n   };\n \n   template<typename _Res, typename... _ArgTypes>\n-    function<_Res(_ArgTypes...)>::function(const function& __x)\n-      : _Function_base()\n-    {\n-      if (__x) {\n-        _M_invoker = __x._M_invoker;\n-        _M_manager = __x._M_manager;\n-        __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n-      }\n+    function<_Res(_ArgTypes...)>::\n+    function(const function& __x)\n+    : _Function_base()\n+    {\n+      if (__x)\n+\t{\n+\t  _M_invoker = __x._M_invoker;\n+\t  _M_manager = __x._M_manager;\n+\t  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+\t}\n     }\n \n   template<typename _Res, typename... _ArgTypes>\n-  template<typename _Functor>\n-    function<_Res(_ArgTypes...)>\n-    ::function(_Functor __f,\n-               typename __gnu_cxx::__enable_if<\n-                         !is_integral<_Functor>::value, _Useless>::__type)\n+    template<typename _Functor>\n+      function<_Res(_ArgTypes...)>::\n+      function(_Functor __f,\n+\t       typename __gnu_cxx::__enable_if<\n+                       !is_integral<_Functor>::value, _Useless>::__type)\n       : _Function_base()\n-  {\n-    typedef _Function_handler<_Signature_type, _Functor> _My_handler;\n-    if (_My_handler::_M_not_empty_function(__f)) {\n-      _M_invoker = &_My_handler::_M_invoke;\n-      _M_manager = &_My_handler::_M_manager;\n-      _My_handler::_M_init_functor(_M_functor, __f);\n-    }\n-  }\n+      {\n+\ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+\n+\tif (_My_handler::_M_not_empty_function(__f))\n+\t  {\n+\t    _M_invoker = &_My_handler::_M_invoke;\n+\t    _M_manager = &_My_handler::_M_manager;\n+\t    _My_handler::_M_init_functor(_M_functor, __f);\n+\t  }\n+      }\n \n   template<typename _Res, typename... _ArgTypes>\n-    _Res function<_Res(_ArgTypes...)>::operator()(_ArgTypes... __args) const\n+    _Res\n+    function<_Res(_ArgTypes...)>::\n+    operator()(_ArgTypes... __args) const\n     {\n       if (_M_empty())\n         {\n@@ -2148,7 +2190,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     }\n \n   template<typename _Res, typename... _ArgTypes>\n-    const type_info& function<_Res(_ArgTypes...)>::target_type() const\n+    const type_info&\n+    function<_Res(_ArgTypes...)>::\n+    target_type() const\n     {\n       if (_M_manager)\n         {\n@@ -2157,45 +2201,43 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n           return *__typeinfo_result._M_access<const type_info*>();\n         }\n       else\n-        {\n-          return typeid(void);\n-        }\n+\treturn typeid(void);\n     }\n \n   template<typename _Res, typename... _ArgTypes>\n-  template<typename _Functor>\n-    _Functor* function<_Res(_ArgTypes...)>::target()\n-    {\n-      if (typeid(_Functor) == target_type() && _M_manager)\n-        {\n-          _Any_data __ptr;\n-          if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-              && !is_const<_Functor>::value)\n-            return 0;\n-          else\n-            return __ptr._M_access<_Functor*>();\n-        }\n-      else\n-        {\n-          return 0;\n-        }\n-    }\n+    template<typename _Functor>\n+      _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target()\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+\t\t&& !is_const<_Functor>::value)\n+\t      return 0;\n+\t    else\n+\t      return __ptr._M_access<_Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n \n   template<typename _Res, typename... _ArgTypes>\n-  template<typename _Functor>\n-    const _Functor* function<_Res(_ArgTypes...)>::target() const\n-    {\n-      if (typeid(_Functor) == target_type() && _M_manager)\n-        {\n-          _Any_data __ptr;\n-          _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-          return __ptr._M_access<const _Functor*>();\n-        }\n-      else\n-        {\n-          return 0;\n-        }\n-    }\n+    template<typename _Functor>\n+      const _Functor*\n+      function<_Res(_ArgTypes...)>::\n+      target() const\n+      {\n+\tif (typeid(_Functor) == target_type() && _M_manager)\n+\t  {\n+\t    _Any_data __ptr;\n+\t    _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+\t    return __ptr._M_access<const _Functor*>();\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n \n   // [3.7.2.7] null pointer comparisons\n \n@@ -2209,7 +2251,7 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<typename _Signature>\n     inline bool\n     operator==(const function<_Signature>& __f, _M_clear_type*)\n-    {\n+    { \n       return !__f;\n     }\n "}]}