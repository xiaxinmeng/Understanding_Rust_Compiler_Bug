{"sha": "e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4ZTMxMDgxNWE4ZWYyZmExZTlhYzk2NmFlYWJiZTBmZDljODFjZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-06-08T21:54:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-06-08T21:54:11Z"}, "message": "basic-block.h: Improve comments.\n\n\t* basic-block.h: Improve comments.\n\t* except.c (expand_eh_region_end_allowed): Remove redundant call\n\tto do_pending_stack_adjust.\n\t* flow.c (life_analysis): Fix typo in comment.\n\t(calculate_global_regs_live): Add documentation.\n\t(mark_set_1): Likewise.\n\t(debug_regset): Likewise.\n\t* doc/rtl.texi (cond_exec): Document it.\n\nFrom-SVN: r43049", "tree": {"sha": "1200ebcccf1a834fa2af1fcfc027b24023f08174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1200ebcccf1a834fa2af1fcfc027b24023f08174"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/comments", "author": null, "committer": null, "parents": [{"sha": "1acc845ecb30195392ff0007ad932a6b746baac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1acc845ecb30195392ff0007ad932a6b746baac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1acc845ecb30195392ff0007ad932a6b746baac5"}], "stats": {"total": 88, "additions": 75, "deletions": 13}, "files": [{"sha": "e6f8e986f643a7d3d3ea6fff6d8c5e7f2c678d3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "patch": "@@ -1,3 +1,14 @@\n+2001-06-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* basic-block.h: Improve comments.\n+\t* except.c (expand_eh_region_end_allowed): Remove redundant call\n+\tto do_pending_stack_adjust.\n+\t* flow.c (life_analysis): Fix typo in comment.\n+\t(calculate_global_regs_live): Add documentation.\n+\t(mark_set_1): Likewise.\n+\t(debug_regset): Likewise.\n+\t* doc/rtl.texi (cond_exec): Document it.\n+\n Fri Jun  8 21:52:51 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (CONST_COSTS): set cost of constants representable in"}, {"sha": "c5e30d968057e3cd7e1943dbdfb77853f9479c80", "filename": "gcc/basic-block.h", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "patch": "@@ -1,5 +1,5 @@\n /* Define control and data flow tables, and regsets.\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -141,7 +141,20 @@ typedef struct edge_def {\n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n \n-/* Basic blocks need not start with a label nor end with a jump insn.\n+/* A basic block is a sequence of instructions with only entry and\n+   only one exit.  If any one of the instructions are executed, they\n+   will all be executed, and in sequence from first to last.\n+\n+   There may be COND_EXEC instructions in the basic block.  The\n+   COND_EXEC *instructions* will be executed -- but if the condition\n+   is false the conditionally executed *expressions* will of course\n+   not be executed.  We don't consider the conditionally executed\n+   expression (which might have side-effects) to be in a separate\n+   basic block because the program counter will always be at the same\n+   location after the COND_EXEC instruction, regardless of whether the\n+   condition is true or not.\n+\n+   Basic blocks need not start with a label nor end with a jump insn.\n    For example, a previous basic block may just \"conditionally fall\"\n    into the succeeding basic block, and the last basic block need not\n    end with a jump insn.  Block 0 is a descendant of the entry block.\n@@ -161,12 +174,21 @@ typedef struct basic_block_def {\n   /* The edges into and out of the block.  */\n   edge pred, succ;\n \n-  /* Liveness info.  Note that in SSA form, global_live_at_start does\n-     not reflect the use of regs in phi functions, since the liveness\n-     of these regs may depend on which edge was taken into the block.  */\n+  /* Liveness info.  */\n+\n+  /* The registers that are modified within this in block.  */\n   regset local_set;\n+  /* The registers that are conditionally modified within this block.\n+     In other words, registers that are set only as part of a\n+     COND_EXEC.  */\n   regset cond_local_set;\n+  /* The registers that are live on entry to this block.\n+\n+     Note that in SSA form, global_live_at_start does not reflect the\n+     use of regs in phi functions, since the liveness of these regs\n+     may depend on which edge was taken into the block.  */\n   regset global_live_at_start;\n+  /* The registers that are live on exit from this block.  */\n   regset global_live_at_end;\n \n   /* Auxiliary info specific to a pass.  */"}, {"sha": "e3dd607717ea700cf4f24b694a3b0df78e0a1c6c", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "patch": "@@ -2201,6 +2201,13 @@ but it is ok then because no further optimization remains to be done.\n However, the definition of the macro @code{NOTICE_UPDATE_CC}, if\n any, must deal with such insns if you define any peephole optimizations.\n \n+@findex cond_exec\n+@item (cond_exec [@var{cond} @var{expr}])\n+Represents a conditionally executed expression.  The @var{expr} is\n+executed only if the @var{cond} is non-zero.  The @var{cond} expression\n+must not have side-effects, but the @var{expr} may very well have\n+side-effects.\n+\n @findex sequence\n @item (sequence [@var{insns} @dots{}])\n Represents a sequence of insns.  Each of the @var{insns} that appears\n@@ -2685,7 +2692,7 @@ An expression for the side effect performed by this insn.  This must be\n one of the following codes: @code{set}, @code{call}, @code{use},\n @code{clobber}, @code{return}, @code{asm_input}, @code{asm_output},\n @code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec},\n-@code{unspec_volatile}, @code{parallel}, or @code{sequence}.  If it is a @code{parallel},\n+@code{unspec_volatile}, @code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a @code{parallel},\n each element of the @code{parallel} must be one these codes, except that\n @code{parallel} expressions cannot be nested and @code{addr_vec} and\n @code{addr_diff_vec} are not permitted inside a @code{parallel} expression."}, {"sha": "24e70799de7c3452c1d6d945db0881e12e8cc363", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "patch": "@@ -857,10 +857,6 @@ expand_eh_region_end_allowed (allowed, failure)\n      throws a different exception, that it will be processed by the\n      correct region.  */\n \n-  /* If there are any pending stack adjustments, we must emit them\n-     before we branch -- otherwise, we won't know how much adjustment\n-     is required later.  */\n-  do_pending_stack_adjust ();\n   around_label = gen_label_rtx ();\n   emit_jump (around_label);\n "}, {"sha": "77783aa9696a02d6b37038403136be8d9ae7cd65", "filename": "gcc/flow.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e68e310815a8ef2fa1e9ac966aeabbe0fd9c81cf", "patch": "@@ -2859,7 +2859,7 @@ life_analysis (f, file, flags)\n   {\n     rtx insn;\n \n-    /* Search for any REG_LABEL notes whih reference deleted labels.  */\n+    /* Search for any REG_LABEL notes which reference deleted labels.  */\n     for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n       {\n \trtx inote = find_reg_note (insn, REG_LABEL, NULL_RTX);\n@@ -3385,6 +3385,24 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   if (blocks_out)\n     sbitmap_zero (blocks_out);\n \n+  /* We work through the queue until there are no more blocks.  What\n+     is live at the end of this block is precisely the union of what\n+     is live at the beginning of all its successors.  So, we set its\n+     GLOBAL_LIVE_AT_END field based on the GLOBAL_LIVE_AT_START field\n+     for its successors.  Then, we compute GLOBAL_LIVE_AT_START for\n+     this block by walking through the instructions in this block in\n+     reverse order and updating as we go.  If that changed\n+     GLOBAL_LIVE_AT_START, we add the predecessors of the block to the\n+     queue; they will now need to recalculate GLOBAL_LIVE_AT_END.\n+\n+     We are guaranteed to terminate, because GLOBAL_LIVE_AT_START\n+     never shrinks.  If a register appears in GLOBAL_LIVE_AT_START, it\n+     must either be live at the end of the block, or used within the\n+     block.  In the latter case, it will certainly never disappear\n+     from GLOBAL_LIVE_AT_START.  In the former case, the register\n+     could go away only if it disappeared from GLOBAL_LIVE_AT_START\n+     for one of the successor blocks.  By induction, that cannot\n+     occur.  */\n   while (qhead != qtail)\n     {\n       int rescan, changed;\n@@ -3396,7 +3414,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \tqhead = queue;\n       bb->aux = NULL;\n \n-      /* Begin by propogating live_at_start from the successor blocks.  */\n+      /* Begin by propagating live_at_start from the successor blocks.  */\n       CLEAR_REG_SET (new_live_at_end);\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n@@ -4609,7 +4627,11 @@ mark_set_regs (pbi, x, insn)\n     }\n }\n \n-/* Process a single SET rtx, X.  */\n+/* Process a single set, which appears in INSN.  REG (which may not\n+   actually be a REG, it may also be a SUBREG, PARALLEL, etc.) is\n+   being set using the CODE (which may be SET, CLOBBER, or COND_EXEC).\n+   If the set is conditional (because it appear in a COND_EXEC), COND\n+   will be the condition.  */\n \n static void\n mark_set_1 (pbi, code, reg, cond, insn, flags)\n@@ -6258,6 +6280,10 @@ dump_regset (r, outf)\n     });\n }\n \n+/* Print a human-reaable representation of R on the standard error\n+   stream.  This function is designed to be used from within the\n+   debugger.  */\n+\n void\n debug_regset (r)\n      regset r;"}]}