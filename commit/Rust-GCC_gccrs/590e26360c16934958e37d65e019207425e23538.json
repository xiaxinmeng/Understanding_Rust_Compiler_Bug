{"sha": "590e26360c16934958e37d65e019207425e23538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwZTI2MzYwYzE2OTM0OTU4ZTM3ZDY1ZTAxOTIwNzQyNWUyMzUzOA==", "commit": {"author": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2015-03-03T17:44:01Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gcc.gnu.org", "date": "2015-03-03T17:44:01Z"}, "message": "Implement call0 ABI for xtensa\n\ncall0 is an ABI that doesn't use register windows.\n\n2015-03-03  Max Filippov  <jcmvbkbc@gmail.com>\n\ngcc/\n\t* config/xtensa/constraints.md (\"a\" constraint): Include stack\n\tpointer in case of call0 ABI.\n\t(\"q\" constraint): Make empty in case of call0 ABI.\n\t(\"D\" constraint): Include stack pointer in case of call0 ABI.\n\t* config/xtensa/xtensa-protos.h (xtensa_set_return_address,\n\txtensa_expand_epilogue, xtensa_regno_to_class): Add new function\n\tprototypes.\n\t* config/xtensa/xtensa.c (xtensa_callee_save_size): New\n\tvariable.\n\t(xtensa_regno_to_class): Make it a local variable in the\n\tfunction xtensa_regno_to_class.\n\t(xtensa_function_epilogue, TARGET_ASM_FUNCTION_EPILOGUE): Remove\n\tmacro, function prototype and implementation.\n\t(reg_nonleaf_alloc_order): Make it a local variable in the\n\tfunction order_regs_for_local_alloc.\n\t(xtensa_conditional_register_usage): New function.\n\t(TARGET_CONDITIONAL_REGISTER_USAGE): Define macro.\n\t(xtensa_valid_move): Allow direct moves to stack pointer\n\tregister in call0 ABI.\n\t(xtensa_setup_frame_addresses): Only spill register windows in\n\twindowed ABI.\n\t(xtensa_emit_call): Emit call(x)8 or call(x)0 in windowed and\n\tcall0 ABI respectively.\n\t(xtensa_function_arg_1): Only mark a7 register for copying in\n\twindowed ABI.\n\t(xtensa_call_save_reg): New function.\n\t(compute_frame_size): Add space for callee saved register\n\tstorage to the frame size in call0 ABI.\n\t(xtensa_expand_prologue): Generate code to set up stack frame\n\tand save callee-saved registers in call0 ABI.\n\t(xtensa_expand_epilogue): New function.\n\t(xtensa_set_return_address): New function.\n\t(xtensa_return_addr): Calculate return address in call0 ABI.\n\t(xtensa_builtin_saveregs): Only mark a7 register for copying and\n\temit copying code in windowed ABI.\n\t(order_regs_for_local_alloc): Add preferred register allocation\n\torder for non-leaf function in call0 ABI.\n\t(xtensa_static_chain): Add atatic chain passing for call0 ABI.\n\t(xtensa_asm_trampoline_template): Add trampoline generation for\n\tcall0 ABI.\n\t(xtensa_trampoline_init): Add trampoline initialization for\n\tcall0 ABI.\n\t(xtensa_conditional_register_usage, xtensa_regno_to_class): New\n\tfunctions.\n\t* config/xtensa/xtensa.h (TARGET_WINDOWED_ABI): New macro.\n\t(TARGET_CPU_CPP_BUILTINS): Add built-in define for call0 ABI.\n\t(CALL_USED_REGISTERS): Modify to encode both windowed and call0\n\tABI call-used registers.\n\t(HARD_FRAME_POINTER_REGNUM): Add frame pointer for call0 ABI.\n\t(INCOMING_REGNO, OUTGOING_REGNO): Use argument unchanged in\n\tcall0 ABI.\n\t(REG_CLASS_CONTENTS): Include all registers into the preferred\n\treload registers set, adjust the set in the\n\txtensa_conditional_register_usage.\n\t(xtensa_regno_to_class): Drop variable declaration.\n\t(REGNO_REG_CLASS): Redefine to use xtensa_regno_to_class\n\tfunction.\n\t(WINDOW_SIZE): Define as 8 or 0 for windowed and call0 ABI\n\trespectively.\n\t(FUNCTION_PROFILER): Add _mcount call for call0 ABI.\n\t(TRAMPOLINE_SIZE): Define trampoline size for call0 ABI.\n\t(RETURN_ADDR_IN_PREVIOUS_FRAME): Define to 0 in call0 ABI.\n\t(ASM_OUTPUT_POOL_PROLOGUE): Always generate literal pool\n\tlocation in call0 ABI.\n\t(EH_RETURN_STACKADJ_RTX): New definition, use a10 for passing\n\tstack adjustment size when handling exception.\n\t(CRT_CALL_STATIC_FUNCTION): Add definition for call0 ABI.\n\t* config/xtensa/xtensa.md (A9_REG, UNSPECV_BLOCKAGE): New\n\tdefinitions.\n\t(\"return\" pattern): Generate ret.n/ret in call0 ABI.\n\t(\"epilogue\" pattern): Expand epilogue.\n\t(\"nonlocal_goto\" pattern): Use default in call0 ABI.\n\t(\"eh_return\" pattern): Move implementation to eh_set_a0_windowed,\n\temit eh_set_a0_* depending on ABI.\n\t(\"eh_set_a0_windowed\" pattern): Former eh_return pattern.\n\t(\"eh_set_a0_call0\", \"blockage\"): New patterns.\n\nlibgcc/\n\t* config/xtensa/lib2funcs.S (__xtensa_libgcc_window_spill,\n\t__xtensa_nonlocal_goto): Don't compile for call0 ABI.\n\t(__xtensa_sync_caches): Only use entry and retw in windowed ABI,\n\tuse ret in call0 ABI.\n\t* config/xtensa/t-windowed: New file.\n\t* libgcc/config/xtensa/t-xtensa (LIB2ADDEH): Move to t-windowed.\n\t* libgcc/configure: Regenerated.\n\t* libgcc/configure.ac: Check if xtensa target is configured for\n\twindowed ABI and thus needs to use custom unwind code.\n\nFrom-SVN: r221158", "tree": {"sha": "9be5f05236a1e486da98109a8e4cd76a6753f556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be5f05236a1e486da98109a8e4cd76a6753f556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/590e26360c16934958e37d65e019207425e23538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590e26360c16934958e37d65e019207425e23538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590e26360c16934958e37d65e019207425e23538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590e26360c16934958e37d65e019207425e23538/comments", "author": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d76b082e8a606d14211b2d5070901c9c87c71b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d76b082e8a606d14211b2d5070901c9c87c71b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d76b082e8a606d14211b2d5070901c9c87c71b42"}], "stats": {"total": 833, "additions": 679, "deletions": 154}, "files": [{"sha": "5c1bb2701934e059503a9db5ca41b3db6c63a1d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -1,3 +1,83 @@\n+2015-03-03  Max Filippov  <jcmvbkbc@gmail.com>\n+\n+\tImplement call0 ABI for xtensa\n+\t* config/xtensa/constraints.md (\"a\" constraint): Include stack\n+\tpointer in case of call0 ABI.\n+\t(\"q\" constraint): Make empty in case of call0 ABI.\n+\t(\"D\" constraint): Include stack pointer in case of call0 ABI.\n+\t* config/xtensa/xtensa-protos.h (xtensa_set_return_address,\n+\txtensa_expand_epilogue, xtensa_regno_to_class): Add new function\n+\tprototypes.\n+\t* config/xtensa/xtensa.c (xtensa_callee_save_size): New\n+\tvariable.\n+\t(xtensa_regno_to_class): Make it a local variable in the\n+\tfunction xtensa_regno_to_class.\n+\t(xtensa_function_epilogue, TARGET_ASM_FUNCTION_EPILOGUE): Remove\n+\tmacro, function prototype and implementation.\n+\t(reg_nonleaf_alloc_order): Make it a local variable in the\n+\tfunction order_regs_for_local_alloc.\n+\t(xtensa_conditional_register_usage): New function.\n+\t(TARGET_CONDITIONAL_REGISTER_USAGE): Define macro.\n+\t(xtensa_valid_move): Allow direct moves to stack pointer\n+\tregister in call0 ABI.\n+\t(xtensa_setup_frame_addresses): Only spill register windows in\n+\twindowed ABI.\n+\t(xtensa_emit_call): Emit call(x)8 or call(x)0 in windowed and\n+\tcall0 ABI respectively.\n+\t(xtensa_function_arg_1): Only mark a7 register for copying in\n+\twindowed ABI.\n+\t(xtensa_call_save_reg): New function.\n+\t(compute_frame_size): Add space for callee saved register\n+\tstorage to the frame size in call0 ABI.\n+\t(xtensa_expand_prologue): Generate code to set up stack frame\n+\tand save callee-saved registers in call0 ABI.\n+\t(xtensa_expand_epilogue): New function.\n+\t(xtensa_set_return_address): New function.\n+\t(xtensa_return_addr): Calculate return address in call0 ABI.\n+\t(xtensa_builtin_saveregs): Only mark a7 register for copying and\n+\temit copying code in windowed ABI.\n+\t(order_regs_for_local_alloc): Add preferred register allocation\n+\torder for non-leaf function in call0 ABI.\n+\t(xtensa_static_chain): Add atatic chain passing for call0 ABI.\n+\t(xtensa_asm_trampoline_template): Add trampoline generation for\n+\tcall0 ABI.\n+\t(xtensa_trampoline_init): Add trampoline initialization for\n+\tcall0 ABI.\n+\t(xtensa_conditional_register_usage, xtensa_regno_to_class): New\n+\tfunctions.\n+\t* config/xtensa/xtensa.h (TARGET_WINDOWED_ABI): New macro.\n+\t(TARGET_CPU_CPP_BUILTINS): Add built-in define for call0 ABI.\n+\t(CALL_USED_REGISTERS): Modify to encode both windowed and call0\n+\tABI call-used registers.\n+\t(HARD_FRAME_POINTER_REGNUM): Add frame pointer for call0 ABI.\n+\t(INCOMING_REGNO, OUTGOING_REGNO): Use argument unchanged in\n+\tcall0 ABI.\n+\t(REG_CLASS_CONTENTS): Include all registers into the preferred\n+\treload registers set, adjust the set in the\n+\txtensa_conditional_register_usage.\n+\t(xtensa_regno_to_class): Drop variable declaration.\n+\t(REGNO_REG_CLASS): Redefine to use xtensa_regno_to_class\n+\tfunction.\n+\t(WINDOW_SIZE): Define as 8 or 0 for windowed and call0 ABI\n+\trespectively.\n+\t(FUNCTION_PROFILER): Add _mcount call for call0 ABI.\n+\t(TRAMPOLINE_SIZE): Define trampoline size for call0 ABI.\n+\t(RETURN_ADDR_IN_PREVIOUS_FRAME): Define to 0 in call0 ABI.\n+\t(ASM_OUTPUT_POOL_PROLOGUE): Always generate literal pool\n+\tlocation in call0 ABI.\n+\t(EH_RETURN_STACKADJ_RTX): New definition, use a10 for passing\n+\tstack adjustment size when handling exception.\n+\t(CRT_CALL_STATIC_FUNCTION): Add definition for call0 ABI.\n+\t* config/xtensa/xtensa.md (A9_REG, UNSPECV_BLOCKAGE): New\n+\tdefinitions.\n+\t(\"return\" pattern): Generate ret.n/ret in call0 ABI.\n+\t(\"epilogue\" pattern): Expand epilogue.\n+\t(\"nonlocal_goto\" pattern): Use default in call0 ABI.\n+\t(\"eh_return\" pattern): Move implementation to eh_set_a0_windowed,\n+\temit eh_set_a0_* depending on ABI.\n+\t(\"eh_set_a0_windowed\" pattern): Former eh_return pattern.\n+\t(\"eh_set_a0_call0\", \"blockage\"): New patterns.\n+\n 2015-03-03  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/65287"}, {"sha": "30f4c1f696de6cf0d1acfc9e341ee2fc67c37b69", "filename": "gcc/config/xtensa/constraints.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fconstraints.md?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -19,7 +19,7 @@\n \n ;; Register constraints.\n \n-(define_register_constraint \"a\" \"GR_REGS\"\n+(define_register_constraint \"a\" \"TARGET_WINDOWED_ABI ? GR_REGS : AR_REGS\"\n  \"General-purpose AR registers @code{a0}-@code{a15},\n   except @code{a1} (@code{sp}).\")\n \n@@ -36,7 +36,7 @@\n  \"Floating-point registers @code{f0}-@code{f15}; only available if the\n   Xtensa Floating-Pointer Coprocessor is configured.\")\n \n-(define_register_constraint \"q\" \"SP_REG\"\n+(define_register_constraint \"q\" \"TARGET_WINDOWED_ABI ? SP_REG : NO_REGS\"\n  \"@internal\n   The stack pointer (register @code{a1}).\")\n \n@@ -53,7 +53,7 @@\n   General-purpose AR registers, but only if the Xtensa 16-Bit Integer\n   Multiply Option is configured.\")\n \n-(define_register_constraint \"D\" \"TARGET_DENSITY ? GR_REGS: NO_REGS\"\n+(define_register_constraint \"D\" \"TARGET_DENSITY ? (TARGET_WINDOWED_ABI ? GR_REGS : AR_REGS) : NO_REGS\"\n  \"@internal\n   General-purpose AR registers, but only if the Xtensa Code Density\n   Option is configured.\")"}, {"sha": "6a5362547d50d0b597b162cbe8f3c04c16519fa1", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -61,13 +61,16 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, int);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern void xtensa_output_literal (FILE *, rtx, machine_mode, int);\n+extern void xtensa_set_return_address (rtx, rtx);\n extern rtx xtensa_return_addr (int, rtx);\n #endif /* RTX_CODE */\n \n extern void xtensa_setup_frame_addresses (void);\n extern int xtensa_dbx_register_number (int);\n extern long compute_frame_size (int);\n extern void xtensa_expand_prologue (void);\n+extern void xtensa_expand_epilogue (void);\n extern void order_regs_for_local_alloc (void);\n+extern enum reg_class xtensa_regno_to_class (int regno);\n \n #endif /* !__XTENSA_PROTOS_H__ */"}, {"sha": "eb039bac56a2eaa5e83a0d3dbd5ce2a71dfba185", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 439, "deletions": 122, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -118,6 +118,8 @@ char xtensa_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n /* Current frame size calculated by compute_frame_size.  */\n unsigned xtensa_current_frame_size;\n+/* Callee-save area size in the current frame calculated by compute_frame_size. */\n+int xtensa_callee_save_size;\n \n /* Largest block move to handle in-line.  */\n #define LARGEST_MOVE_RATIO 15\n@@ -144,21 +146,6 @@ const char xtensa_leaf_regs[FIRST_PSEUDO_REGISTER] =\n   1\n };\n \n-/* Map hard register number to register class */\n-const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER] =\n-{\n-  RL_REGS,\tSP_REG,\t\tRL_REGS,\tRL_REGS,\n-  RL_REGS,\tRL_REGS,\tRL_REGS,\tGR_REGS,\n-  RL_REGS,\tRL_REGS,\tRL_REGS,\tRL_REGS,\n-  RL_REGS,\tRL_REGS,\tRL_REGS,\tRL_REGS,\n-  AR_REGS,\tAR_REGS,\tBR_REGS,\n-  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  ACC_REG,\n-};\n-\n static void xtensa_option_override (void);\n static enum internal_test map_test_to_internal_test (enum rtx_code);\n static rtx gen_int_relational (enum rtx_code, rtx, rtx, int *);\n@@ -171,7 +158,6 @@ static rtx xtensa_legitimize_address (rtx, rtx, machine_mode);\n static bool xtensa_mode_dependent_address_p (const_rtx, addr_space_t);\n static bool xtensa_return_in_msb (const_tree);\n static void printx (FILE *, signed int);\n-static void xtensa_function_epilogue (FILE *, HOST_WIDE_INT);\n static rtx xtensa_builtin_saveregs (void);\n static bool xtensa_legitimate_address_p (machine_mode, rtx, bool);\n static unsigned int xtensa_multibss_section_type_flags (tree, const char *,\n@@ -224,17 +210,9 @@ static const char *xtensa_invalid_within_doloop (const rtx_insn *);\n static bool xtensa_member_type_forces_blk (const_tree,\n \t\t\t\t\t   machine_mode mode);\n \n-static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n-  REG_ALLOC_ORDER;\n-\f\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+static void xtensa_conditional_register_usage (void);\n \n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE xtensa_function_epilogue\n+\f\n \n /* These hooks specify assembly directives for creating certain kinds\n    of integer object.  */\n@@ -355,6 +333,9 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_INVALID_WITHIN_DOLOOP\n #define TARGET_INVALID_WITHIN_DOLOOP xtensa_invalid_within_doloop\n \n+#undef TARGET_CONDITIONAL_REGISTER_USAGE\n+#define TARGET_CONDITIONAL_REGISTER_USAGE xtensa_conditional_register_usage\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -522,9 +503,10 @@ xtensa_valid_move (machine_mode mode, rtx *operands)\n \n       /* The stack pointer can only be assigned with a MOVSP opcode.  */\n       if (dst_regnum == STACK_POINTER_REGNUM)\n-\treturn (mode == SImode\n-\t\t&& register_operand (operands[1], mode)\n-\t\t&& !ACC_REG_P (xt_true_regnum (operands[1])));\n+\treturn !TARGET_WINDOWED_ABI\n+\t  || (mode == SImode\n+\t      && register_operand (operands[1], mode)\n+\t      && !ACC_REG_P (xt_true_regnum (operands[1])));\n \n       if (!ACC_REG_P (dst_regnum))\n \treturn true;\n@@ -1665,9 +1647,10 @@ xtensa_setup_frame_addresses (void)\n   /* Set flag to cause TARGET_FRAME_POINTER_REQUIRED to return true.  */\n   cfun->machine->accesses_prev_frame = 1;\n \n-  emit_library_call\n-    (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_libgcc_window_spill\"),\n-     LCT_NORMAL, VOIDmode, 0);\n+  if (TARGET_WINDOWED_ABI)\n+    emit_library_call\n+      (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_libgcc_window_spill\"),\n+       LCT_NORMAL, VOIDmode, 0);\n }\n \n \n@@ -1825,11 +1808,11 @@ xtensa_emit_call (int callop, rtx *operands)\n   rtx tgt = operands[callop];\n \n   if (GET_CODE (tgt) == CONST_INT)\n-    sprintf (result, \"call8\\t0x%lx\", INTVAL (tgt));\n+    sprintf (result, \"call%d\\t0x%lx\", WINDOW_SIZE, INTVAL (tgt));\n   else if (register_operand (tgt, VOIDmode))\n-    sprintf (result, \"callx8\\t%%%d\", callop);\n+    sprintf (result, \"callx%d\\t%%%d\", WINDOW_SIZE, callop);\n   else\n-    sprintf (result, \"call8\\t%%%d\", callop);\n+    sprintf (result, \"call%d\\t%%%d\", WINDOW_SIZE, callop);\n \n   return result;\n }\n@@ -2174,7 +2157,7 @@ xtensa_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   regno = regbase + *arg_words;\n \n   if (cum->incoming && regno <= A7_REG && regno + words > A7_REG)\n-    cfun->machine->need_a7_copy = true;\n+    cfun->machine->need_a7_copy = TARGET_WINDOWED_ABI;\n \n   return gen_rtx_REG (mode, regno);\n }\n@@ -2641,6 +2624,22 @@ xtensa_output_literal (FILE *file, rtx x, machine_mode mode, int labelno)\n     }\n }\n \n+static bool\n+xtensa_call_save_reg(int regno)\n+{\n+  if (TARGET_WINDOWED_ABI)\n+    return false;\n+\n+  if (regno == A0_REG)\n+    return crtl->profile || !crtl->is_leaf || crtl->calls_eh_return ||\n+      df_regs_ever_live_p (regno);\n+\n+  if (crtl->calls_eh_return && regno >= 2 && regno < 4)\n+    return true;\n+\n+  return !fixed_regs[regno] && !call_used_regs[regno] &&\n+    df_regs_ever_live_p (regno);\n+}\n \n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.  */\n@@ -2651,14 +2650,25 @@ xtensa_output_literal (FILE *file, rtx x, machine_mode mode, int labelno)\n long\n compute_frame_size (int size)\n {\n+  int regno;\n+\n   /* Add space for the incoming static chain value.  */\n   if (cfun->static_chain_decl != NULL)\n     size += (1 * UNITS_PER_WORD);\n \n+  xtensa_callee_save_size = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+    {\n+      if (xtensa_call_save_reg(regno))\n+\txtensa_callee_save_size += UNITS_PER_WORD;\n+    }\n+\n   xtensa_current_frame_size =\n     XTENSA_STACK_ALIGN (size\n+\t\t\t+ xtensa_callee_save_size\n \t\t\t+ crtl->outgoing_args_size\n \t\t\t+ (WINDOW_SIZE * UNITS_PER_WORD));\n+  xtensa_callee_save_size = XTENSA_STACK_ALIGN (xtensa_callee_save_size);\n   return xtensa_current_frame_size;\n }\n \n@@ -2686,23 +2696,103 @@ void\n xtensa_expand_prologue (void)\n {\n   HOST_WIDE_INT total_size;\n-  rtx size_rtx;\n-  rtx_insn *insn;\n+  rtx_insn *insn = NULL;\n   rtx note_rtx;\n \n+\n   total_size = compute_frame_size (get_frame_size ());\n-  size_rtx = GEN_INT (total_size);\n \n-  if (total_size < (1 << (12+3)))\n-    insn = emit_insn (gen_entry (size_rtx));\n+  if (TARGET_WINDOWED_ABI)\n+    {\n+      if (total_size < (1 << (12+3)))\n+\tinsn = emit_insn (gen_entry (GEN_INT (total_size)));\n+      else\n+\t{\n+\t  /* Use a8 as a temporary since a0-a7 may be live.  */\n+\t  rtx tmp_reg = gen_rtx_REG (Pmode, A8_REG);\n+\t  emit_insn (gen_entry (GEN_INT (MIN_FRAME_SIZE)));\n+\t  emit_move_insn (tmp_reg, GEN_INT (total_size - MIN_FRAME_SIZE));\n+\t  emit_insn (gen_subsi3 (tmp_reg, stack_pointer_rtx, tmp_reg));\n+\t  insn = emit_insn (gen_movsi (stack_pointer_rtx, tmp_reg));\n+\t}\n+    }\n   else\n     {\n-      /* Use a8 as a temporary since a0-a7 may be live.  */\n-      rtx tmp_reg = gen_rtx_REG (Pmode, A8_REG);\n-      emit_insn (gen_entry (GEN_INT (MIN_FRAME_SIZE)));\n-      emit_move_insn (tmp_reg, GEN_INT (total_size - MIN_FRAME_SIZE));\n-      emit_insn (gen_subsi3 (tmp_reg, stack_pointer_rtx, tmp_reg));\n-      insn = emit_insn (gen_movsi (stack_pointer_rtx, tmp_reg));\n+      int regno;\n+      HOST_WIDE_INT offset = 0;\n+\n+      /* -128 is a limit of single addi instruction. */\n+      if (total_size > 0 && total_size <= 128)\n+\t{\n+\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-total_size)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  note_rtx = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t -total_size));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t  offset = total_size - UNITS_PER_WORD;\n+\t}\n+      else if (xtensa_callee_save_size)\n+\t{\n+\t  /* 1020 is maximal s32i offset, if the frame is bigger than that\n+\t   * we move sp to the end of callee-saved save area, save and then\n+\t   * move it to its final location. */\n+\t  if (total_size > 1024)\n+\t    {\n+\t      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (-xtensa_callee_save_size)));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      note_rtx = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t     -xtensa_callee_save_size));\n+\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t      offset = xtensa_callee_save_size - UNITS_PER_WORD;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+\t      emit_move_insn (tmp_reg, GEN_INT (total_size));\n+\t      insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n+\t\t\t\t\t    stack_pointer_rtx, tmp_reg));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      note_rtx = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t     -total_size));\n+\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t      offset = total_size - UNITS_PER_WORD;\n+\t    }\n+\t}\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t{\n+\t  if (xtensa_call_save_reg(regno))\n+\t    {\n+\t      rtx x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));\n+\t      rtx mem = gen_frame_mem (SImode, x);\n+\t      rtx reg = gen_rtx_REG (SImode, regno);\n+\n+\t      offset -= UNITS_PER_WORD;\n+\t      insn = emit_move_insn (mem, reg);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t    gen_rtx_SET (VOIDmode, mem, reg));\n+\t    }\n+\t}\n+      if (total_size > 1024)\n+\t{\n+\t  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+\t  emit_move_insn (tmp_reg, GEN_INT (total_size -\n+\t\t\t\t\t    xtensa_callee_save_size));\n+\t  insn = emit_insn (gen_subsi3 (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, tmp_reg));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  note_rtx = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t xtensa_callee_save_size -\n+\t\t\t\t\t\t total_size));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t}\n     }\n \n   if (frame_pointer_needed)\n@@ -2731,38 +2821,147 @@ xtensa_expand_prologue (void)\n \t    }\n \t}\n       else\n-\tinsn = emit_insn (gen_movsi (hard_frame_pointer_rtx,\n-\t\t\t\t     stack_pointer_rtx));\n-    }\n-\n-  /* Create a note to describe the CFA.  Because this is only used to set\n-     DW_AT_frame_base for debug info, don't bother tracking changes through\n-     each instruction in the prologue.  It just takes up space.  */\n-  note_rtx = gen_rtx_SET (VOIDmode, (frame_pointer_needed\n-\t\t\t\t     ? hard_frame_pointer_rtx\n-\t\t\t\t     : stack_pointer_rtx),\n-\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t -total_size));\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n-}\n-\n+        {\n+\t  insn = emit_insn (gen_movsi (hard_frame_pointer_rtx,\n+\t\t\t\t       stack_pointer_rtx));\n+\t  if (!TARGET_WINDOWED_ABI)\n+\t    {\n+\t      note_rtx = gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t    }\n+\t}\n+    }\n \n-/* Clear variables at function end.  */\n+  if (TARGET_WINDOWED_ABI)\n+    {\n+      /* Create a note to describe the CFA.  Because this is only used to set\n+\t DW_AT_frame_base for debug info, don't bother tracking changes through\n+\t each instruction in the prologue.  It just takes up space.  */\n+      note_rtx = gen_rtx_SET (VOIDmode, (frame_pointer_needed\n+\t\t\t\t\t ? hard_frame_pointer_rtx\n+\t\t\t\t\t : stack_pointer_rtx),\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     -total_size));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+    }\n+}\n \n void\n-xtensa_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n-\t\t\t  HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+xtensa_expand_epilogue (void)\n {\n+  if (!TARGET_WINDOWED_ABI)\n+    {\n+      int regno;\n+      HOST_WIDE_INT offset;\n+\n+      if (xtensa_current_frame_size > (frame_pointer_needed ? 127 : 1024))\n+\t{\n+\t  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+\t  emit_move_insn (tmp_reg, GEN_INT (xtensa_current_frame_size -\n+\t\t\t\t\t    xtensa_callee_save_size));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_needed ?\n+\t\t\t\t hard_frame_pointer_rtx : stack_pointer_rtx,\n+\t\t\t\t tmp_reg));\n+\t  offset = xtensa_callee_save_size - UNITS_PER_WORD;\n+\t}\n+      else\n+\t{\n+\t  if (frame_pointer_needed)\n+\t    emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n+\t  offset = xtensa_current_frame_size - UNITS_PER_WORD;\n+\t}\n+\n+      /* Prevent reordering of saved a0 update and loading it back from\n+\t the save area.  */\n+      if (crtl->calls_eh_return)\n+\temit_insn (gen_blockage ());\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t{\n+\t  if (xtensa_call_save_reg(regno))\n+\t    {\n+\t      rtx x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));\n+\n+\t      offset -= UNITS_PER_WORD;\n+\t      emit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t      gen_frame_mem (SImode, x));\n+\t    }\n+\t}\n+\n+      if (xtensa_current_frame_size > 0)\n+\t{\n+\t  if (frame_pointer_needed || /* always reachable with addi */\n+\t      xtensa_current_frame_size > 1024 ||\n+\t      xtensa_current_frame_size <= 127)\n+\t    {\n+\t      if (xtensa_current_frame_size <= 127)\n+\t\toffset = xtensa_current_frame_size;\n+\t      else\n+\t\toffset = xtensa_callee_save_size;\n+\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (offset)));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+\t      emit_move_insn (tmp_reg, GEN_INT (xtensa_current_frame_size));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     tmp_reg));\n+\t    }\n+\t}\n+\n+      if (crtl->calls_eh_return)\n+\temit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  EH_RETURN_STACKADJ_RTX));\n+    }\n   xtensa_current_frame_size = 0;\n+  xtensa_callee_save_size = 0;\n+  emit_jump_insn (gen_return ());\n }\n \n+void\n+xtensa_set_return_address (rtx address, rtx scratch)\n+{\n+  HOST_WIDE_INT total_size = compute_frame_size (get_frame_size ());\n+  rtx frame = frame_pointer_needed ?\n+    hard_frame_pointer_rtx : stack_pointer_rtx;\n+  rtx a0_addr = plus_constant (Pmode, frame,\n+\t\t\t       total_size - UNITS_PER_WORD);\n+  rtx note = gen_rtx_SET (VOIDmode,\n+\t\t\t  gen_frame_mem (SImode, a0_addr),\n+\t\t\t  gen_rtx_REG (SImode, A0_REG));\n+  rtx insn;\n+\n+  if (total_size > 1024) {\n+    emit_move_insn (scratch, GEN_INT (total_size - UNITS_PER_WORD));\n+    emit_insn (gen_addsi3 (scratch, frame, scratch));\n+    a0_addr = scratch;\n+  }\n+\n+  insn = emit_move_insn (gen_frame_mem (SImode, a0_addr), address);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n+}\n \n rtx\n xtensa_return_addr (int count, rtx frame)\n {\n   rtx result, retaddr, curaddr, label;\n \n+  if (!TARGET_WINDOWED_ABI)\n+    {\n+      if (count != 0)\n+\treturn const0_rtx;\n+\n+      return get_hard_reg_initial_val (Pmode, A0_REG);\n+    }\n+\n   if (count == -1)\n     retaddr = gen_rtx_REG (Pmode, A0_REG);\n   else\n@@ -2879,14 +3078,14 @@ xtensa_builtin_saveregs (void)\n   set_mem_alias_set (gp_regs, get_varargs_alias_set ());\n \n   /* Now store the incoming registers.  */\n-  cfun->machine->need_a7_copy = true;\n+  cfun->machine->need_a7_copy = TARGET_WINDOWED_ABI;\n   cfun->machine->vararg_a7 = true;\n   move_block_from_reg (GP_ARG_FIRST + arg_words,\n \t\t       adjust_address (gp_regs, BLKmode,\n \t\t\t\t       arg_words * UNITS_PER_WORD),\n \t\t       gp_left);\n-  gcc_assert (cfun->machine->vararg_a7_copy != 0);\n-  emit_insn_before (cfun->machine->vararg_a7_copy, get_insns ());\n+  if (cfun->machine->vararg_a7_copy != 0)\n+    emit_insn_before (cfun->machine->vararg_a7_copy, get_insns ());\n \n   return XEXP (gp_regs, 0);\n }\n@@ -3272,7 +3471,19 @@ order_regs_for_local_alloc (void)\n {\n   if (!leaf_function_p ())\n     {\n-      memcpy (reg_alloc_order, reg_nonleaf_alloc_order,\n+      static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n+\tREG_ALLOC_ORDER;\n+      static const int reg_nonleaf_alloc_order_call0[FIRST_PSEUDO_REGISTER] =\n+\t{\n+\t  11, 10,  9,  8,  7,  6,  5,  4,  3,  2, 12, 13, 14, 15,\n+\t  18,\n+\t  19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+\t  0,  1, 16, 17,\n+\t  35,\n+\t};\n+\n+      memcpy (reg_alloc_order, TARGET_WINDOWED_ABI ?\n+\t      reg_nonleaf_alloc_order : reg_nonleaf_alloc_order_call0,\n \t      FIRST_PSEUDO_REGISTER * sizeof (int));\n     }\n   else\n@@ -3642,9 +3853,14 @@ xtensa_function_value_regno_p (const unsigned int regno)\n static rtx\n xtensa_static_chain (const_tree ARG_UNUSED (fndecl_or_type), bool incoming_p)\n {\n-  rtx base = incoming_p ? arg_pointer_rtx : stack_pointer_rtx;\n-  return gen_frame_mem (Pmode, plus_constant (Pmode, base,\n-\t\t\t\t\t      -5 * UNITS_PER_WORD));\n+  if (TARGET_WINDOWED_ABI)\n+    {\n+      rtx base = incoming_p ? arg_pointer_rtx : stack_pointer_rtx;\n+      return gen_frame_mem (Pmode, plus_constant (Pmode, base,\n+\t\t\t\t\t\t  -5 * UNITS_PER_WORD));\n+    }\n+  else\n+    return gen_rtx_REG (Pmode, A8_REG);\n }\n \n \n@@ -3662,65 +3878,109 @@ xtensa_asm_trampoline_template (FILE *stream)\n   bool use_call0 = (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS);\n \n   fprintf (stream, \"\\t.begin no-transform\\n\");\n-  fprintf (stream, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\n \n-  if (use_call0)\n+  if (TARGET_WINDOWED_ABI)\n     {\n-      /* Save the return address.  */\n-      fprintf (stream, \"\\tmov\\ta10, a0\\n\");\n+      fprintf (stream, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\n \n-      /* Use a CALL0 instruction to skip past the constants and in the\n-\t process get the PC into A0.  This allows PC-relative access to\n-\t the constants without relying on L32R.  */\n-      fprintf (stream, \"\\tcall0\\t.Lskipconsts\\n\");\n-    }\n-  else\n-    fprintf (stream, \"\\tj\\t.Lskipconsts\\n\");\n+      if (use_call0)\n+\t{\n+\t  /* Save the return address.  */\n+\t  fprintf (stream, \"\\tmov\\ta10, a0\\n\");\n \n-  fprintf (stream, \"\\t.align\\t4\\n\");\n-  fprintf (stream, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\n-  fprintf (stream, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\n-  fprintf (stream, \".Lskipconsts:\\n\");\n+\t  /* Use a CALL0 instruction to skip past the constants and in the\n+\t     process get the PC into A0.  This allows PC-relative access to\n+\t     the constants without relying on L32R.  */\n+\t  fprintf (stream, \"\\tcall0\\t.Lskipconsts\\n\");\n+\t}\n+      else\n+\tfprintf (stream, \"\\tj\\t.Lskipconsts\\n\");\n \n-  /* Load the static chain and function address from the trampoline.  */\n-  if (use_call0)\n-    {\n-      fprintf (stream, \"\\taddi\\ta0, a0, 3\\n\");\n-      fprintf (stream, \"\\tl32i\\ta9, a0, 0\\n\");\n-      fprintf (stream, \"\\tl32i\\ta8, a0, 4\\n\");\n+      fprintf (stream, \"\\t.align\\t4\\n\");\n+      fprintf (stream, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\n+      fprintf (stream, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\n+      fprintf (stream, \".Lskipconsts:\\n\");\n+\n+      /* Load the static chain and function address from the trampoline.  */\n+      if (use_call0)\n+\t{\n+\t  fprintf (stream, \"\\taddi\\ta0, a0, 3\\n\");\n+\t  fprintf (stream, \"\\tl32i\\ta9, a0, 0\\n\");\n+\t  fprintf (stream, \"\\tl32i\\ta8, a0, 4\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (stream, \"\\tl32r\\ta9, .Lchainval\\n\");\n+\t  fprintf (stream, \"\\tl32r\\ta8, .Lfnaddr\\n\");\n+\t}\n+\n+      /* Store the static chain.  */\n+      fprintf (stream, \"\\ts32i\\ta9, sp, %d\\n\", MIN_FRAME_SIZE - 20);\n+\n+      /* Set the proper stack pointer value.  */\n+      fprintf (stream, \"\\tl32i\\ta9, a8, 0\\n\");\n+      fprintf (stream, \"\\textui\\ta9, a9, %d, 12\\n\",\n+\t       TARGET_BIG_ENDIAN ? 8 : 12);\n+      fprintf (stream, \"\\tslli\\ta9, a9, 3\\n\");\n+      fprintf (stream, \"\\taddi\\ta9, a9, %d\\n\", -MIN_FRAME_SIZE);\n+      fprintf (stream, \"\\tsub\\ta9, sp, a9\\n\");\n+      fprintf (stream, \"\\tmovsp\\tsp, a9\\n\");\n+\n+      if (use_call0)\n+\t/* Restore the return address.  */\n+\tfprintf (stream, \"\\tmov\\ta0, a10\\n\");\n+\n+      /* Jump to the instruction following the ENTRY.  */\n+      fprintf (stream, \"\\taddi\\ta8, a8, 3\\n\");\n+      fprintf (stream, \"\\tjx\\ta8\\n\");\n+\n+      /* Pad size to a multiple of TRAMPOLINE_ALIGNMENT.  */\n+      if (use_call0)\n+\tfprintf (stream, \"\\t.byte\\t0\\n\");\n+      else\n+\tfprintf (stream, \"\\tnop\\n\");\n     }\n   else\n     {\n-      fprintf (stream, \"\\tl32r\\ta9, .Lchainval\\n\");\n-      fprintf (stream, \"\\tl32r\\ta8, .Lfnaddr\\n\");\n-    }\n-\n-  /* Store the static chain.  */\n-  fprintf (stream, \"\\ts32i\\ta9, sp, %d\\n\", MIN_FRAME_SIZE - 20);\n-\n-  /* Set the proper stack pointer value.  */\n-  fprintf (stream, \"\\tl32i\\ta9, a8, 0\\n\");\n-  fprintf (stream, \"\\textui\\ta9, a9, %d, 12\\n\",\n-\t   TARGET_BIG_ENDIAN ? 8 : 12);\n-  fprintf (stream, \"\\tslli\\ta9, a9, 3\\n\");\n-  fprintf (stream, \"\\taddi\\ta9, a9, %d\\n\", -MIN_FRAME_SIZE);\n-  fprintf (stream, \"\\tsub\\ta9, sp, a9\\n\");\n-  fprintf (stream, \"\\tmovsp\\tsp, a9\\n\");\n+      if (use_call0)\n+\t{\n+\t  /* Save the return address.  */\n+\t  fprintf (stream, \"\\tmov\\ta10, a0\\n\");\n \n-  if (use_call0)\n-    /* Restore the return address.  */\n-    fprintf (stream, \"\\tmov\\ta0, a10\\n\");\n+\t  /* Use a CALL0 instruction to skip past the constants and in the\n+\t     process get the PC into A0.  This allows PC-relative access to\n+\t     the constants without relying on L32R.  */\n+\t  fprintf (stream, \"\\tcall0\\t.Lskipconsts\\n\");\n+\t}\n+      else\n+\tfprintf (stream, \"\\tj\\t.Lskipconsts\\n\");\n \n-  /* Jump to the instruction following the ENTRY.  */\n-  fprintf (stream, \"\\taddi\\ta8, a8, 3\\n\");\n-  fprintf (stream, \"\\tjx\\ta8\\n\");\n+      fprintf (stream, \"\\t.align\\t4\\n\");\n+      fprintf (stream, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\n+      fprintf (stream, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\n+      fprintf (stream, \".Lskipconsts:\\n\");\n \n-  /* Pad size to a multiple of TRAMPOLINE_ALIGNMENT.  */\n-  if (use_call0)\n-    fprintf (stream, \"\\t.byte\\t0\\n\");\n-  else\n-    fprintf (stream, \"\\tnop\\n\");\n+      /* Load the static chain and function address from the trampoline.  */\n+      if (use_call0)\n+\t{\n+\t  fprintf (stream, \"\\taddi\\ta0, a0, 3\\n\");\n+\t  fprintf (stream, \"\\tl32i\\ta8, a0, 0\\n\");\n+\t  fprintf (stream, \"\\tl32i\\ta9, a0, 4\\n\");\n+\t  fprintf (stream, \"\\tmov\\ta0, a10\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (stream, \"\\tl32r\\ta8, .Lchainval\\n\");\n+\t  fprintf (stream, \"\\tl32r\\ta9, .Lfnaddr\\n\");\n+\t}\n+      fprintf (stream, \"\\tjx\\ta9\\n\");\n \n+      /* Pad size to a multiple of TRAMPOLINE_ALIGNMENT.  */\n+      if (use_call0)\n+\tfprintf (stream, \"\\t.byte\\t0\\n\");\n+      else\n+\tfprintf (stream, \"\\tnop\\n\");\n+    }\n   fprintf (stream, \"\\t.end no-transform\\n\");\n }\n \n@@ -3729,8 +3989,19 @@ xtensa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)\n {\n   rtx func = XEXP (DECL_RTL (fndecl), 0);\n   bool use_call0 = (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS);\n-  int chain_off = use_call0 ? 12 : 8;\n-  int func_off = use_call0 ? 16 : 12;\n+  int chain_off;\n+  int func_off;\n+\n+  if (TARGET_WINDOWED_ABI)\n+    {\n+      chain_off = use_call0 ? 12 : 8;\n+      func_off = use_call0 ? 16 : 12;\n+    }\n+  else\n+    {\n+      chain_off = use_call0 ? 8 : 4;\n+      func_off = use_call0 ? 12 : 8;\n+    }\n \n   emit_block_move (m_tramp, assemble_trampoline_template (),\n \t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n@@ -3989,4 +4260,50 @@ xtensa_reorg (void)\n   xtensa_reorg_loops ();\n }\n \n+/* Update register usage after having seen the compiler flags.  */\n+\n+static void\n+xtensa_conditional_register_usage (void)\n+{\n+  unsigned i, c_mask;\n+\n+  c_mask = TARGET_WINDOWED_ABI ? (1 << 1) : (1 << 2);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      /* Set/reset conditionally defined registers from\n+\t CALL_USED_REGISTERS initializer.  */\n+      if (call_used_regs[i] > 1)\n+\tcall_used_regs[i] = !!(call_used_regs[i] & c_mask);\n+    }\n+\n+  /* Remove hard FP register from the preferred reload registers set.  */\n+  CLEAR_HARD_REG_BIT (reg_class_contents[(int)RL_REGS],\n+\t\t      HARD_FRAME_POINTER_REGNUM);\n+}\n+\n+/* Map hard register number to register class */\n+\n+enum reg_class xtensa_regno_to_class (int regno)\n+{\n+  static const enum reg_class regno_to_class[FIRST_PSEUDO_REGISTER] =\n+    {\n+      RL_REGS,\tSP_REG,\t\tRL_REGS,\tRL_REGS,\n+      RL_REGS,\tRL_REGS,\tRL_REGS,\tRL_REGS,\n+      RL_REGS,\tRL_REGS,\tRL_REGS,\tRL_REGS,\n+      RL_REGS,\tRL_REGS,\tRL_REGS,\tRL_REGS,\n+      AR_REGS,\tAR_REGS,\tBR_REGS,\n+      FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+      FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+      FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+      FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+      ACC_REG,\n+    };\n+\n+  if (regno == HARD_FRAME_POINTER_REGNUM)\n+    return GR_REGS;\n+  else\n+    return regno_to_class[regno];\n+}\n+\n #include \"gt-xtensa.h\""}, {"sha": "011411c09bf66fd6af232eb72605354b1d425b06", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -66,6 +66,7 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_ABSOLUTE_LITERALS XSHAL_USE_ABSOLUTE_LITERALS\n #define TARGET_THREADPTR\tXCHAL_HAVE_THREADPTR\n #define TARGET_LOOPS\t        XCHAL_HAVE_LOOPS\n+#define TARGET_WINDOWED_ABI\t(XSHAL_ABI == XTHAL_ABI_WINDOWED)\n \n #define TARGET_DEFAULT \\\n   ((XCHAL_HAVE_L32R\t? 0 : MASK_CONST16) |\t\t\t\t\\\n@@ -83,7 +84,8 @@ extern unsigned xtensa_current_frame_size;\n     builtin_assert (\"machine=xtensa\");\t\t\t\t\t\\\n     builtin_define (\"__xtensa__\");\t\t\t\t\t\\\n     builtin_define (\"__XTENSA__\");\t\t\t\t\t\\\n-    builtin_define (\"__XTENSA_WINDOWED_ABI__\");\t\t\t\t\\\n+    builtin_define (TARGET_WINDOWED_ABI ?\t\t\t\t\\\n+\t\t    \"__XTENSA_WINDOWED_ABI__\" : \"__XTENSA_CALL0_ABI__\");\\\n     builtin_define (TARGET_BIG_ENDIAN ? \"__XTENSA_EB__\" : \"__XTENSA_EL__\"); \\\n     if (!TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n       builtin_define (\"__XTENSA_SOFT_FLOAT__\");\t\t\t\t\\\n@@ -238,10 +240,18 @@ extern unsigned xtensa_current_frame_size;\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n+   Aside from that, you can include as many other registers as you like.\n+\n+   The value encoding is the following:\n+   1: register is used by all ABIs;\n+   bit 1 is set: register is used by windowed ABI;\n+   bit 2 is set: register is used by call0 ABI.\n+\n+   Proper values are computed in TARGET_CONDITIONAL_REGISTER_USAGE.  */\n+\n #define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 2,\t\t\t\\\n   1, 1, 1,\t\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1,\t\t\t\t\t\t\t\t\t\\\n@@ -341,7 +351,8 @@ extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 1)\n \n /* Base register for access to local variables of the function.  */\n-#define HARD_FRAME_POINTER_REGNUM (GP_REG_FIRST + 7)\n+#define HARD_FRAME_POINTER_REGNUM (GP_REG_FIRST + \\\n+\t\t\t\t   (TARGET_WINDOWED_ABI ? 7 : 15))\n \n /* The register number of the frame pointer register, which is used to\n    access automatic variables in the stack frame.  For Xtensa, this\n@@ -366,14 +377,16 @@ extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    we use a fixed window size of 8.  */\n \n #define INCOMING_REGNO(OUT)\t\t\t\t\t\t\\\n-  ((GP_REG_P (OUT) &&\t\t\t\t\t\t\t\\\n-    ((unsigned) ((OUT) - GP_REG_FIRST) >= WINDOW_SIZE)) ?\t\t\\\n-   (OUT) - WINDOW_SIZE : (OUT))\n+  (TARGET_WINDOWED_ABI ?\t\t\t\t\t\t\\\n+   ((GP_REG_P (OUT) &&\t\t\t\t\t\t\t\\\n+     ((unsigned) ((OUT) - GP_REG_FIRST) >= WINDOW_SIZE)) ?\t\t\\\n+    (OUT) - WINDOW_SIZE : (OUT)) : (OUT))\n \n #define OUTGOING_REGNO(IN)\t\t\t\t\t\t\\\n-  ((GP_REG_P (IN) &&\t\t\t\t\t\t\t\\\n-    ((unsigned) ((IN) - GP_REG_FIRST) < WINDOW_SIZE)) ?\t\t\t\\\n-   (IN) + WINDOW_SIZE : (IN))\n+  (TARGET_WINDOWED_ABI ?\t\t\t\t\t\t\\\n+   ((GP_REG_P (IN) &&\t\t\t\t\t\t\t\\\n+     ((unsigned) ((IN) - GP_REG_FIRST) < WINDOW_SIZE)) ?\t\t\\\n+    (IN) + WINDOW_SIZE : (IN)) : (IN))\n \n \n /* Define the classes of registers for register constraints in the\n@@ -422,7 +435,7 @@ enum reg_class\n   { 0xfff80000, 0x00000007 }, /* floating-point registers */ \\\n   { 0x00000000, 0x00000008 }, /* MAC16 accumulator */ \\\n   { 0x00000002, 0x00000000 }, /* stack pointer register */ \\\n-  { 0x0000ff7d, 0x00000000 }, /* preferred reload registers */ \\\n+  { 0x0000fffd, 0x00000000 }, /* preferred reload registers */ \\\n   { 0x0000fffd, 0x00000000 }, /* general-purpose registers */ \\\n   { 0x0003ffff, 0x00000000 }, /* integer registers */ \\\n   { 0xffffffff, 0x0000000f }  /* all registers */ \\\n@@ -432,9 +445,7 @@ enum reg_class\n    register REGNO.  In general there is more that one such class;\n    choose a class which is \"minimal\", meaning that no smaller class\n    also contains the register.  */\n-extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n-\n-#define REGNO_REG_CLASS(REGNO) xtensa_regno_to_class[ (REGNO) ]\n+#define REGNO_REG_CLASS(REGNO) xtensa_regno_to_class (REGNO)\n \n /* Use the Xtensa AR register file for base registers.\n    No index registers.  */\n@@ -497,7 +508,7 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n #define STACK_BOUNDARY 128\n \n /* Use a fixed register window size of 8.  */\n-#define WINDOW_SIZE 8\n+#define WINDOW_SIZE (TARGET_WINDOWED_ABI ? 8 : 0)\n \n /* Symbolic macros for the registers used to return integer, floating\n    point, and values of coprocessor and user-defined modes.  */\n@@ -561,19 +572,23 @@ typedef struct xtensa_args\n     fprintf (FILE, \"\\t%s\\ta10, a0\\n\", TARGET_DENSITY ? \"mov.n\" : \"mov\"); \\\n     if (flag_pic)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tmovi\\ta8, _mcount@PLT\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tcallx8\\ta8\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tmovi\\ta%d, _mcount@PLT\\n\", WINDOW_SIZE);\t\\\n+\tfprintf (FILE, \"\\tcallx%d\\ta%d\\n\", WINDOW_SIZE, WINDOW_SIZE);\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tcall8\\t_mcount\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall%d\\t_mcount\\n\", WINDOW_SIZE);\t\t\\\n   } while (0)\n \n /* Stack pointer value doesn't matter at exit.  */\n #define EXIT_IGNORE_STACK 1\n \n /* Size in bytes of the trampoline, as an integer.  Make sure this is\n    a multiple of TRAMPOLINE_ALIGNMENT to avoid -Wpadded warnings.  */\n-#define TRAMPOLINE_SIZE (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS ? 60 : 52)\n+#define TRAMPOLINE_SIZE (TARGET_WINDOWED_ABI ? \\\n+\t\t\t (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS ? \\\n+\t\t\t  60 : 52) : \\\n+\t\t\t (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS ? \\\n+\t\t\t  32 : 24))\n \n /* Alignment required for trampolines, in bits.  */\n #define TRAMPOLINE_ALIGNMENT 32\n@@ -615,7 +630,7 @@ typedef struct xtensa_args\n \n /* Define this if the return address of a particular stack frame is\n    accessed from the frame pointer of the previous stack frame.  */\n-#define RETURN_ADDR_IN_PREVIOUS_FRAME 1\n+#define RETURN_ADDR_IN_PREVIOUS_FRAME TARGET_WINDOWED_ABI\n \n /* A C expression whose value is RTL representing the value of the\n    return address for the frame COUNT steps up from the current\n@@ -770,7 +785,7 @@ typedef struct xtensa_args\n /* Define output to appear before the constant pool.  */\n #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, FUNDECL, SIZE)          \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    if ((SIZE) > 0)\t\t\t\t\t\t\t\\\n+    if ((SIZE) > 0 || !TARGET_WINDOWED_ABI)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tresolve_unique_section ((FUNDECL), 0, flag_function_sections);\t\\\n \tswitch_to_section (function_section (FUNDECL));\t\t\t\\\n@@ -805,6 +820,8 @@ typedef struct xtensa_args\n       | DW_EH_PE_pcrel | DW_EH_PE_sdata4)\t\t\t\t\\\n    : DW_EH_PE_absptr)\n \n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, GP_REG_FIRST + 10)\n+\n /* Emit a PC-relative relocation.  */\n #define ASM_OUTPUT_DWARF_PCREL(FILE, SIZE, LABEL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -818,8 +835,16 @@ typedef struct xtensa_args\n    a MOVI and let the assembler relax it -- for the .init and .fini\n    sections, the assembler knows to put the literal in the right\n    place.  */\n+#if defined(__XTENSA_WINDOWED_ABI__)\n #define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n     asm (SECTION_OP \"\\n\\\n \tmovi\\ta8, \" USER_LABEL_PREFIX #FUNC \"\\n\\\n \tcallx8\\ta8\\n\" \\\n \tTEXT_SECTION_ASM_OP);\n+#elif defined(__XTENSA_CALL0_ABI__)\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n+    asm (SECTION_OP \"\\n\\\n+\tmovi\\ta0, \" USER_LABEL_PREFIX #FUNC \"\\n\\\n+\tcallx0\\ta0\\n\" \\\n+\tTEXT_SECTION_ASM_OP);\n+#endif"}, {"sha": "6d84384c950266a65be15786b4ba7bd9c7d73b65", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -24,6 +24,7 @@\n   (A1_REG\t\t1)\n   (A7_REG\t\t7)\n   (A8_REG\t\t8)\n+  (A9_REG\t\t9)\n \n   (UNSPEC_NOP\t\t2)\n   (UNSPEC_PLT\t\t3)\n@@ -44,6 +45,7 @@\n   (UNSPECV_S32C1I\t5)\n   (UNSPECV_EH_RETURN\t6)\n   (UNSPECV_SET_TP\t7)\n+  (UNSPECV_BLOCKAGE\t8)\n ])\n \n ;; This code iterator allows signed and unsigned widening multiplications\n@@ -1658,9 +1660,11 @@\n (define_insn \"return\"\n   [(return)\n    (use (reg:SI A0_REG))]\n-  \"reload_completed\"\n+  \"(TARGET_WINDOWED_ABI || !xtensa_current_frame_size) && reload_completed\"\n {\n-  return (TARGET_DENSITY ? \"retw.n\" : \"retw\");\n+  return TARGET_WINDOWED_ABI ?\n+      (TARGET_DENSITY ? \"retw.n\" : \"retw\") :\n+      (TARGET_DENSITY ? \"ret.n\" : \"ret\");\n }\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n@@ -1681,7 +1685,7 @@\n   [(return)]\n   \"\"\n {\n-  emit_jump_insn (gen_return ());\n+  xtensa_expand_epilogue ();\n   DONE;\n })\n \n@@ -1700,7 +1704,7 @@\n    (match_operand:SI 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"general_operand\" \"\")\n    (match_operand:SI 3 \"\" \"\")]\n-  \"\"\n+  \"TARGET_WINDOWED_ABI\"\n {\n   xtensa_expand_nonlocal_goto (operands);\n   DONE;\n@@ -1713,7 +1717,18 @@\n ;; already been applied to the handler, but the generic version doesn't\n ;; allow us to frob it quite enough, so we just frob here.\n \n-(define_insn_and_split \"eh_return\"\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\"))]\n+  \"\"\n+{\n+  if (TARGET_WINDOWED_ABI)\n+    emit_insn (gen_eh_set_a0_windowed (operands[0]));\n+  else\n+    emit_insn (gen_eh_set_a0_call0 (operands[0]));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"eh_set_a0_windowed\"\n   [(set (reg:SI A0_REG)\n \t(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n \t\t\t    UNSPECV_EH_RETURN))\n@@ -1726,6 +1741,29 @@\n    (set (reg:SI A0_REG) (rotatert:SI (match_dup 1) (const_int 2)))]\n   \"\")\n \n+(define_insn_and_split \"eh_set_a0_call0\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t    UNSPECV_EH_RETURN)\n+   (clobber (match_scratch:SI 1 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  xtensa_set_return_address (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"nop\")])\n+\n ;; Setting up a frame pointer is tricky for Xtensa because GCC doesn't\n ;; know if a frame pointer is required until the reload pass, and\n ;; because there may be an incoming argument value in the hard frame"}, {"sha": "49eee7a24a43fe3cb88a156875468ce5fc92dc30", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -1,3 +1,16 @@\n+2015-03-03  Max Filippov  <jcmvbkbc@gmail.com>\n+\t\n+\tImplement call0 ABI for xtensa\n+\t* config/xtensa/lib2funcs.S (__xtensa_libgcc_window_spill,\n+\t__xtensa_nonlocal_goto): Don't compile for call0 ABI.\n+\t(__xtensa_sync_caches): Only use entry and retw in windowed ABI,\n+\tuse ret in call0 ABI.\n+\t* config/xtensa/t-windowed: New file.\n+\t* libgcc/config/xtensa/t-xtensa (LIB2ADDEH): Move to t-windowed.\n+\t* libgcc/configure: Regenerated.\n+\t* libgcc/configure.ac: Check if xtensa target is configured for\n+\twindowed ABI and thus needs to use custom unwind code.\n+\n 2015-02-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libgcc/64885"}, {"sha": "4d451c8c71c8952e54baa0107a77252e5a18ac4a", "filename": "libgcc/config/xtensa/lib2funcs.S", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fxtensa%2Flib2funcs.S?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -29,6 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    current register window.  This is used to set up the stack so that\n    arbitrary frames can be accessed.  */\n \n+#if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n \t.align\t4\n \t.global\t__xtensa_libgcc_window_spill\n \t.type\t__xtensa_libgcc_window_spill,@function\n@@ -38,6 +39,7 @@ __xtensa_libgcc_window_spill:\n \tsyscall\n \tretw\n \t.size\t__xtensa_libgcc_window_spill, .-__xtensa_libgcc_window_spill\n+#endif\n \n \n /* __xtensa_nonlocal_goto: This code does all the hard work of a\n@@ -51,6 +53,7 @@ __xtensa_libgcc_window_spill:\n   This function never returns to its caller but instead goes directly\n   to the address of the specified goto handler.  */\n \n+#if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n \t.align\t4\n \t.global\t__xtensa_nonlocal_goto\n \t.type\t__xtensa_nonlocal_goto,@function\n@@ -128,6 +131,7 @@ __xtensa_nonlocal_goto:\n \n \tretw\n \t.size\t__xtensa_nonlocal_goto, .-__xtensa_nonlocal_goto\n+#endif\n \n \n /* __xtensa_sync_caches: This function is called after writing a trampoline\n@@ -154,7 +158,9 @@ __xtensa_nonlocal_goto:\n \t.global\t__xtensa_sync_caches\n \t.type\t__xtensa_sync_caches,@function\n __xtensa_sync_caches:\n+#if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n \tentry \tsp, 32\n+#endif\n #if XCHAL_DCACHE_SIZE > 0\n \t/* Flush the trampoline from the data cache.  */\n \textui\ta4, a2, 0, XCHAL_DCACHE_LINEWIDTH\n@@ -182,5 +188,9 @@ __xtensa_sync_caches:\n \tbnez\ta4, .Licache_loop\n #endif\n \tisync\n+#if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n \tretw\n+#else\n+\tret\n+#endif\n \t.size\t__xtensa_sync_caches, .-__xtensa_sync_caches"}, {"sha": "9daf738ff57a96dde0d2e64dcf8909901e2f2088", "filename": "libgcc/config/xtensa/linux-unwind.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fxtensa%2Flinux-unwind.h?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -52,6 +52,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define ENTRY_BYTE 0x36\n #endif\n \n+#ifdef __XTENSA_WINDOWED_ABI__\n #define MD_FALLBACK_FRAME_STATE_FOR xtensa_fallback_frame_state\n \n static _Unwind_Reason_Code\n@@ -94,4 +95,6 @@ xtensa_fallback_frame_state (struct _Unwind_Context *context,\n   return _URC_NO_REASON;\n }\n \n+#endif /* __XTENSA_WINDOWED_ABI__ */\n+\n #endif /* ifdef inhibit_libc  */"}, {"sha": "7d9e9db0487eef6b9ee1fb7492bfc180dcc3ca0d", "filename": "libgcc/config/xtensa/t-windowed", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Ft-windowed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Ft-windowed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fxtensa%2Ft-windowed?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -0,0 +1,2 @@\n+LIB2ADDEH = $(srcdir)/config/xtensa/unwind-dw2-xtensa.c \\\n+   $(srcdir)/unwind-dw2-fde.c $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c"}, {"sha": "ed3eb84a71b884183599352c9d3449c835b2faf6", "filename": "libgcc/config/xtensa/t-xtensa", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Ft-xtensa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfig%2Fxtensa%2Ft-xtensa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fxtensa%2Ft-xtensa?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -11,6 +11,3 @@ LIB1ASMFUNCS = _mulsi3 _divsi3 _modsi3 _udivsi3 _umodsi3 \\\n \t_truncdfsf2 _extendsfdf2\n \n LIB2ADD = $(srcdir)/config/xtensa/lib2funcs.S\n-\n-LIB2ADDEH = $(srcdir)/config/xtensa/unwind-dw2-xtensa.c \\\n-   $(srcdir)/unwind-dw2-fde.c $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c"}, {"sha": "9d567f9d48c4ad0db74c0066d2ef2ac8f2f392fb", "filename": "libgcc/configure", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -4810,6 +4810,27 @@ EOF\n   ;;\n esac\n \n+# Check if xtensa target is configured for windowed ABI and thus needs to use\n+# custom unwind code.\n+# This is after config.host so we can augment tmake_file.\n+case ${host} in\n+xtensa*-*)\n+  cat > conftest.c <<EOF\n+\t#ifdef __XTENSA_CALL0_ABI__\n+\t#error\n+\t#endif\n+EOF\n+  if { ac_try='${CC-cc} -E -o conftest.i conftest.c 1>&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }; then\n+      tmake_file=\"${tmake_file} xtensa/t-windowed\"\n+  fi\n+  ;;\n+esac\n+\n # Check for visibility support.  This is after config.host so that\n # we can check for asm_hidden_op.\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __attribute__((visibility(\\\"hidden\\\")))\" >&5"}, {"sha": "1c405e8dfe5a298967dc74fafd8dae43e83a6f11", "filename": "libgcc/configure.ac", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590e26360c16934958e37d65e019207425e23538/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=590e26360c16934958e37d65e019207425e23538", "patch": "@@ -436,6 +436,22 @@ EOF\n   ;;\n esac\n \n+# Check if xtensa target is configured for windowed ABI and thus needs to use\n+# custom unwind code.\n+# This is after config.host so we can augment tmake_file.\n+case ${host} in\n+xtensa*-*)\n+  cat > conftest.c <<EOF\n+\t#ifdef __XTENSA_CALL0_ABI__\n+\t#error\n+\t#endif\n+EOF\n+  if AC_TRY_COMMAND(${CC-cc} -E -o conftest.i conftest.c 1>&AS_MESSAGE_LOG_FD); then\n+      tmake_file=\"${tmake_file} xtensa/t-windowed\"\n+  fi\n+  ;;\n+esac\n+\n # Check for visibility support.  This is after config.host so that\n # we can check for asm_hidden_op.\n AC_CACHE_CHECK([for __attribute__((visibility(\"hidden\")))],"}]}