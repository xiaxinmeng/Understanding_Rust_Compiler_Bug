{"sha": "c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg0NmVlZGQ1NmE1ZWNmMjgyMzNkNWU4ZmU5MzhkNDRiM2FkZDVmMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-18T07:14:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-18T07:14:18Z"}, "message": "[Ada] Document the introduction of the Object_Size attribute in Ada 2020\n\n2019-12-18  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads (Handling of Type'Size Value): Add references to the\n\tintroduction of Object_Size in Ada 2020.\n\t* sem_eval.adb (Subtypes_Statically_Match): Likewise.\n\nFrom-SVN: r279506", "tree": {"sha": "1d342309c18862abcafec929c907c5c73b5f9233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d342309c18862abcafec929c907c5c73b5f9233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/comments", "author": null, "committer": null, "parents": [{"sha": "af552cd02f23d3aa90268f0d91008545d4d8ddd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af552cd02f23d3aa90268f0d91008545d4d8ddd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af552cd02f23d3aa90268f0d91008545d4d8ddd2"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "2b845d4cb571bec642832f7c30a40a51551a5b08", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "patch": "@@ -1,3 +1,9 @@\n+2019-12-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Handling of Type'Size Value): Add references to the\n+\tintroduction of Object_Size in Ada 2020.\n+\t* sem_eval.adb (Subtypes_Statically_Match): Likewise.\n+\n 2019-12-18  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch3.adb (Derive_Subprogram): Do not set the"}, {"sha": "cb0736aa08552127d549d8fbf4d9789eb611a8f4", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "patch": "@@ -132,19 +132,23 @@ package Einfo is\n --  default size of objects, creates chaos, and major incompatibilities in\n --  existing code.\n \n+--  The Ada 2020 RM acknowledges it and adopts GNAT's Object_Size attribute\n+--  for determining the default size of objects, but stops short of applying\n+--  it universally like GNAT. Indeed the notable exceptions are nonaliased\n+--  stand-alone objects, which are not covered by Object_Size in Ada 2020.\n+\n --  We proceed as follows, for discrete and fixed-point subtypes, we have\n --  two separate sizes for each subtype:\n \n --    The Object_Size, which is used for determining the default size of\n --    objects and components. This size value can be referred to using the\n --    Object_Size attribute. The phrase \"is used\" here means that it is\n---    the basis of the determination of the size. The backend is free to\n+--    the basis of the determination of the size. The back end is free to\n --    pad this up if necessary for efficiency, e.g. an 8-bit stand-alone\n --    character might be stored in 32 bits on a machine with no efficient\n --    byte access instructions such as the Alpha.\n \n---    The default rules for the value of Object_Size for fixed-point and\n---    discrete types are as follows:\n+--    The default rules for the value of Object_Size are as follows:\n \n --       The Object_Size for base subtypes reflect the natural hardware\n --       size in bits (see Ttypes and Cstand for integer types). For\n@@ -158,9 +162,11 @@ package Einfo is\n --       base type, and the Object_Size of a derived first subtype is copied\n --       from the parent first subtype.\n \n---    The Value_Size which is the number of bits required to store a value\n+--    The Ada 2020 RM defined attribute Object_Size uses this implementation.\n+\n+--    The Value_Size, which is the number of bits required to store a value\n --    of the type. This size can be referred to using the Value_Size\n---    attribute. This value is used to determine how tightly to pack\n+--    attribute. This value is used for determining how tightly to pack\n --    records or arrays with components of this type, and also affects\n --    the semantics of unchecked conversion (unchecked conversions where\n --    the Value_Size values differ generate a warning, and are potentially\n@@ -182,7 +188,7 @@ package Einfo is\n --       dynamic bounds, it is assumed that the value can range down or up\n --       to the corresponding bound of the ancestor.\n \n---    The RM defined attribute Size corresponds to the Value_Size attribute.\n+--    The Ada 95 RM defined attribute Size is identified with Value_Size.\n \n --    The Size attribute may be defined for a first-named subtype. This sets\n --    the Value_Size of the first-named subtype to the given value, and the\n@@ -194,14 +200,15 @@ package Einfo is\n --    subtypes. The Value_Size of any other static subtypes is not affected.\n \n --    Value_Size and Object_Size may be explicitly set for any subtype using\n---    an attribute definition clause. Note that the use of these attributes\n---    can cause the RM 13.1(14) rule to be violated. If two access types\n---    reference aliased objects whose subtypes have differing Object_Size\n---    values as a result of explicit attribute definition clauses, then it\n---    is erroneous to convert from one access subtype to the other.\n-\n---    At the implementation level, Esize stores the Object_Size and the\n---    RM_Size field stores the Value_Size (and hence the value of the\n+--    an attribute definition clause. Note that the use of such a clause can\n+--    cause the RM 13.1(14) rule to be violated, in Ada 95 and 2020 for the\n+--    Value_Size attribute, but only in Ada 95 for the Object_Size attribute.\n+--    If access types reference aliased objects whose subtypes have differing\n+--    Object_Size values as a result of explicit attribute definition clauses,\n+--    then it is erroneous to convert from one access subtype to the other.\n+\n+--    At the implementation level, the Esize field stores the Object_Size\n+--    and the RM_Size field stores the Value_Size (hence the value of the\n --    Size attribute, which, as noted above, is equivalent to Value_Size).\n \n --  To get a feel for the difference, consider the following examples (note"}, {"sha": "a08284759f83bf7d24c5acf91408fd078cea471d", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c846eedd56a5ecf28233d5e8fe938d44b3add5f3/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=c846eedd56a5ecf28233d5e8fe938d44b3add5f3", "patch": "@@ -5905,7 +5905,8 @@ package body Sem_Eval is\n    --  In addition, in GNAT, the object size (Esize) values of the types must\n    --  match if they are set (unless checking an actual for a formal derived\n    --  type). The use of 'Object_Size can cause this to be false even if the\n-   --  types would otherwise match in the RM sense.\n+   --  types would otherwise match in the Ada 95 RM sense, but this deviation\n+   --  is adopted by AI12-059 which introduces Object_Size in Ada 2020.\n \n    function Subtypes_Statically_Match\n      (T1                      : Entity_Id;\n@@ -5921,8 +5922,6 @@ package body Sem_Eval is\n       --  No match if sizes different (from use of 'Object_Size). This test\n       --  is excluded if Formal_Derived_Matching is True, as the base types\n       --  can be different in that case and typically have different sizes.\n-      --  ??? Frontend_Layout_On_Target used to set Esizes but this is no\n-      --  longer the case, consider removing the last test below.\n \n       elsif not Formal_Derived_Matching\n         and then Known_Static_Esize (T1)"}]}