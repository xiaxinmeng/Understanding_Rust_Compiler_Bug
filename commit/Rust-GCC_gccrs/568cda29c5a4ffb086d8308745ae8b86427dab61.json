{"sha": "568cda29c5a4ffb086d8308745ae8b86427dab61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY4Y2RhMjljNWE0ZmZiMDg2ZDgzMDg3NDVhZThiODY0MjdkYWI2MQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-09-05T12:41:16Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-09-05T12:41:16Z"}, "message": "ipa-prop.c (remove_described_reference): Accept missing references, return false if that hppens, otherwise return true.\n\n2013-09-05  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (remove_described_reference): Accept missing references,\n\treturn false if that hppens, otherwise return true.\n\t(cgraph_node_for_jfunc): New function.\n\t(try_decrement_rdesc_refcount): Likewise.\n\t(try_make_edge_direct_simple_call): Use them.\n\t(ipa_edge_removal_hook): Remove references from rdescs.\n\t(ipa_edge_duplication_hook): Clone rdescs and their references\n\twhen the new edge has the same caller as the old one.\n\t* cgraph.c (cgraph_resolve_speculation): Remove speculative\n\treference before removing any edges.\n\ntestsuite/\n\t* g++.dg/ipa/remref-1.C: New test.\n\t* g++.dg/ipa/remref-2.C: Likewise.\n\nFrom-SVN: r202281", "tree": {"sha": "90881c22dd3aedd23f522f30c644b2f07bc9ddb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90881c22dd3aedd23f522f30c644b2f07bc9ddb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/568cda29c5a4ffb086d8308745ae8b86427dab61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568cda29c5a4ffb086d8308745ae8b86427dab61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/568cda29c5a4ffb086d8308745ae8b86427dab61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568cda29c5a4ffb086d8308745ae8b86427dab61/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a200acb0519af47612f0e92c86c07ec69a6ae81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a200acb0519af47612f0e92c86c07ec69a6ae81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a200acb0519af47612f0e92c86c07ec69a6ae81"}], "stats": {"total": 194, "additions": 182, "deletions": 12}, "files": [{"sha": "d7b6bfa6728ed63fb21b50e30cf9a6d46087df39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -1,3 +1,16 @@\n+2013-09-05  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (remove_described_reference): Accept missing references,\n+\treturn false if that hppens, otherwise return true.\n+\t(cgraph_node_for_jfunc): New function.\n+\t(try_decrement_rdesc_refcount): Likewise.\n+\t(try_make_edge_direct_simple_call): Use them.\n+\t(ipa_edge_removal_hook): Remove references from rdescs.\n+\t(ipa_edge_duplication_hook): Clone rdescs and their references\n+\twhen the new edge has the same caller as the old one.\n+\t* cgraph.c (cgraph_resolve_speculation): Remove speculative\n+\treference before removing any edges.\n+\n 2013-09-05  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (thumb2_emit_strd_push): Rewrite to use pre-decrement on"}, {"sha": "f12bf1ba4be9809052285034d64e3dd5d61118fd", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -1225,13 +1225,13 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n     edge->frequency = CGRAPH_FREQ_MAX;\n   edge->speculative = false;\n   e2->speculative = false;\n+  ipa_remove_reference (ref);\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n     cgraph_remove_edge (e2);\n   else\n     cgraph_remove_node_and_inline_clones (e2->callee, NULL);\n   if (edge->caller->call_site_hash)\n     cgraph_update_edge_in_call_site_hash (edge);\n-  ipa_remove_reference (ref);\n   return edge;\n }\n "}, {"sha": "f9f8e2d773e9934c49ed699884b3f91194376563", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 90, "deletions": 11, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -2496,9 +2496,10 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n }\n \n /* Remove a reference to SYMBOL from the list of references of a node given by\n-   reference description RDESC.  */\n+   reference description RDESC.  Return true if the reference has been\n+   successfully found and removed.  */\n \n-static void\n+static bool\n remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n {\n   struct ipa_ref *to_del;\n@@ -2507,12 +2508,15 @@ remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n   origin = rdesc->cs;\n   to_del = ipa_find_reference ((symtab_node) origin->caller, symbol,\n \t\t\t       origin->call_stmt, origin->lto_stmt_uid);\n-  gcc_assert (to_del);\n+  if (!to_del)\n+    return false;\n+\n   ipa_remove_reference (to_del);\n   if (dump_file)\n     fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n \t     xstrdup (cgraph_node_name (origin->caller)),\n \t     origin->caller->symbol.order, xstrdup (symtab_node_name (symbol)));\n+  return true;\n }\n \n /* If JFUNC has a reference description with refcount different from\n@@ -2529,6 +2533,45 @@ jfunc_rdesc_usable (struct ipa_jump_func *jfunc)\n     return NULL;\n }\n \n+/* If the value of constant jump function JFUNC is an address of a function\n+   declaration, return the associated call graph node.  Otherwise return\n+   NULL.  */\n+\n+static cgraph_node *\n+cgraph_node_for_jfunc (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n+  tree cst = ipa_get_jf_constant (jfunc);\n+  if (TREE_CODE (cst) != ADDR_EXPR\n+      || TREE_CODE (TREE_OPERAND (cst, 0)) != FUNCTION_DECL)\n+    return NULL;\n+\n+  return cgraph_get_node (TREE_OPERAND (cst, 0));\n+}\n+\n+\n+/* If JFUNC is a constant jump function with a usable rdesc, decrement its\n+   refcount and if it hits zero, remove reference to SYMBOL from the caller of\n+   the edge specified in the rdesc.  Return false if either the symbol or the\n+   reference could not be found, otherwise return true.  */\n+\n+static bool\n+try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n+{\n+  struct ipa_cst_ref_desc *rdesc;\n+  if (jfunc->type == IPA_JF_CONST\n+      && (rdesc = jfunc_rdesc_usable (jfunc))\n+      && --rdesc->refcount == 0)\n+    {\n+      symtab_node symbol = (symtab_node) cgraph_node_for_jfunc (jfunc);\n+      if (!symbol)\n+\treturn false;\n+\n+      return remove_described_reference (symbol, rdesc);\n+    }\n+  return true;\n+}\n+\n /* Try to find a destination for indirect edge IE that corresponds to a simple\n    call or a call of a member function pointer and where the destination is a\n    pointer formal parameter described by jump function JFUNC.  If it can be\n@@ -2544,7 +2587,6 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   tree target;\n   bool agg_contents = ie->indirect_info->agg_contents;\n   bool speculative = ie->speculative;\n-  struct ipa_cst_ref_desc *rdesc;\n \n   if (ie->indirect_info->agg_contents)\n     target = ipa_find_agg_cst_for_param (&jfunc->agg,\n@@ -2557,11 +2599,16 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   cs = ipa_make_edge_direct_to_target (ie, target);\n \n   /* FIXME: speculative edges can be handled.  */\n-  if (cs && !agg_contents && !speculative\n-      && jfunc->type == IPA_JF_CONST\n-      && (rdesc = jfunc_rdesc_usable (jfunc))\n-      && --rdesc->refcount == 0)\n-    remove_described_reference ((symtab_node) cs->callee, rdesc);\n+  if (cs && !agg_contents && !speculative)\n+    {\n+      bool ok;\n+      gcc_checking_assert (cs->callee\n+\t\t\t   && (jfunc->type != IPA_JF_CONST\n+\t\t\t       || !cgraph_node_for_jfunc (jfunc)\n+\t\t\t       || cs->callee == cgraph_node_for_jfunc (jfunc)));\n+      ok = try_decrement_rdesc_refcount (jfunc);\n+      gcc_checking_assert (ok);\n+    }\n \n   return cs;\n }\n@@ -2817,7 +2864,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t      if (n)\n \t\t{\n \t\t  struct cgraph_node *clone;\n-\t\t  remove_described_reference ((symtab_node) n, rdesc);\n+\t\t  bool ok;\n+\t\t  ok = remove_described_reference ((symtab_node) n, rdesc);\n+\t\t  gcc_checking_assert (ok);\n \n \t\t  clone = cs->caller;\n \t\t  while (clone->global.inlined_to\n@@ -2960,9 +3009,21 @@ ipa_set_node_agg_value_chain (struct cgraph_node *node,\n static void\n ipa_edge_removal_hook (struct cgraph_edge *cs, void *data ATTRIBUTE_UNUSED)\n {\n-  /* During IPA-CP updating we can be called on not-yet analyze clones.  */\n+  struct ipa_edge_args *args;\n+\n+  /* During IPA-CP updating we can be called on not-yet analyzed clones.  */\n   if (vec_safe_length (ipa_edge_args_vector) <= (unsigned)cs->uid)\n     return;\n+\n+  args = IPA_EDGE_REF (cs);\n+  if (args->jump_functions)\n+    {\n+      struct ipa_jump_func *jf;\n+      int i;\n+      FOR_EACH_VEC_ELT (*args->jump_functions, i, jf)\n+\ttry_decrement_rdesc_refcount (jf);\n+    }\n+\n   ipa_free_edge_args_substructures (IPA_EDGE_REF (cs));\n }\n \n@@ -3007,6 +3068,24 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \n \t  if (!src_rdesc)\n \t    dst_jf->value.constant.rdesc = NULL;\n+\t  else if (src->caller == dst->caller)\n+\t    {\n+\t      struct ipa_ref *ref;\n+\t      symtab_node n = (symtab_node) cgraph_node_for_jfunc (src_jf);\n+\t      gcc_checking_assert (n);\n+\t      ref = ipa_find_reference ((symtab_node) src->caller, n,\n+\t\t\t\t\tsrc->call_stmt, src->lto_stmt_uid);\n+\t      gcc_checking_assert (ref);\n+\t      ipa_clone_ref (ref, (symtab_node) dst->caller, ref->stmt);\n+\n+\t      gcc_checking_assert (ipa_refdesc_pool);\n+\t      struct ipa_cst_ref_desc *dst_rdesc\n+\t\t= (struct ipa_cst_ref_desc *) pool_alloc (ipa_refdesc_pool);\n+\t      dst_rdesc->cs = dst;\n+\t      dst_rdesc->refcount = src_rdesc->refcount;\n+\t      dst_rdesc->next_duplicate = NULL;\n+\t      dst_jf->value.constant.rdesc = dst_rdesc;\n+\t    }\n \t  else if (src_rdesc->cs == src)\n \t    {\n \t      struct ipa_cst_ref_desc *dst_rdesc;"}, {"sha": "5431d212acccddf616b06b31a7d546810ef1c2bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -1,3 +1,8 @@\n+2013-09-05  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/remref-1.C: New test.\n+\t* g++.dg/ipa/remref-2.C: Likewise.\n+\n 2013-09-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/24926"}, {"sha": "c25c425e9b76a3d1727e140b1f08380941d4b7ec", "filename": "gcc/testsuite/g++.dg/ipa/remref-1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-1.C?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -0,0 +1,36 @@\n+/* Verify that indirect-inlining induced removal of referenes will not remove\n+   too many references in presence of speculative devirtualization.  */\n+/* { dg-do link } */\n+/* { dg-options \"-O3 -fno-early-inlining\"  } */\n+\n+class A\n+{\n+  public:\n+  virtual void foo(void (*)(void));\n+};\n+\n+static\n+void b(void)\n+{\n+}\n+\n+void\n+A::foo(void (*back)(void))\n+{\n+  back();\n+}\n+\n+class A *a;\n+\n+void __attribute__ ((noinline, noclone))\n+allocate_a ()\n+{\n+  a = new A();\n+}\n+\n+main()\n+{\n+  allocate_a();\n+  for (int i=0; i<10000;i++)\n+    a->foo(b);\n+}"}, {"sha": "06bc71a5b00454d47b9e36cbafb98ab02b02b93e", "filename": "gcc/testsuite/g++.dg/ipa/remref-2.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/568cda29c5a4ffb086d8308745ae8b86427dab61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fremref-2.C?ref=568cda29c5a4ffb086d8308745ae8b86427dab61", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that we survive creation and deletion of references to facilitate\n+   reference removal while also doing (unsuccessful) speculative\n+   devirtualization.  */\n+/* { dg-do link } */\n+/* { dg-options \"-O3 -fno-early-inlining\"  } */\n+\n+class A\n+{\n+  public:\n+  virtual void __attribute__ ((noinline)) foo(void (*)(void));\n+};\n+\n+static\n+void b(void)\n+{\n+}\n+\n+void  __attribute__ ((noinline))\n+A::foo(void (*back)(void))\n+{\n+  back();\n+}\n+\n+class A *a;\n+\n+void __attribute__ ((noinline, noclone))\n+allocate_a ()\n+{\n+  a = new A();\n+}\n+\n+main()\n+{\n+  allocate_a();\n+  for (int i=0; i<10000;i++)\n+    a->foo(b);\n+}"}]}