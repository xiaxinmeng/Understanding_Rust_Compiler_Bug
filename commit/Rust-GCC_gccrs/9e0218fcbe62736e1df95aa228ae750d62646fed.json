{"sha": "9e0218fcbe62736e1df95aa228ae750d62646fed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUwMjE4ZmNiZTYyNzM2ZTFkZjk1YWEyMjhhZTc1MGQ2MjY0NmZlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2016-03-16T21:23:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-03-16T21:23:05Z"}, "message": "re PR target/70048 ([AArch64] Inefficient local array addressing)\n\nPR target/70048\n\n  * config/aarch64/aarch64.c (virt_or_elim_regno_p): New.\n  (aarch64_classify_address): Use it.\n  (aarch64_legitimize_address): Force all subexpressions of PLUS\n  into registers.  Simplify as (sfp+const)+reg or (reg+reg)+const.\n\nFrom-SVN: r234269", "tree": {"sha": "f67e47c0f76479d75186d52ccde098694b12252e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f67e47c0f76479d75186d52ccde098694b12252e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e0218fcbe62736e1df95aa228ae750d62646fed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0218fcbe62736e1df95aa228ae750d62646fed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0218fcbe62736e1df95aa228ae750d62646fed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0218fcbe62736e1df95aa228ae750d62646fed/comments", "author": null, "committer": null, "parents": [{"sha": "c5e003cfe45c37f8170c12b4037e8dda70dbfb94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e003cfe45c37f8170c12b4037e8dda70dbfb94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e003cfe45c37f8170c12b4037e8dda70dbfb94"}], "stats": {"total": 124, "additions": 54, "deletions": 70}, "files": [{"sha": "12e86013561f20e1236fb4d8848c747e636fb047", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0218fcbe62736e1df95aa228ae750d62646fed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0218fcbe62736e1df95aa228ae750d62646fed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e0218fcbe62736e1df95aa228ae750d62646fed", "patch": "@@ -1,3 +1,11 @@\n+2016-03-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/70048\n+\t* config/aarch64/aarch64.c (virt_or_elim_regno_p): New.\n+\t(aarch64_classify_address): Use it.\n+\t(aarch64_legitimize_address): Force all subexpressions of PLUS\n+\tinto registers.  Simplify as (sfp+const)+reg or (reg+reg)+const.\n+\n 2016-03-16  Jakub Jelinek  <jakub@redhat.com>\n \t    Richard Biener  <rguenth@suse.de>\n "}, {"sha": "12e498d238c2c1a41e3d8ae9dec874eb91d87d68", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 46, "deletions": 70, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0218fcbe62736e1df95aa228ae750d62646fed/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0218fcbe62736e1df95aa228ae750d62646fed/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9e0218fcbe62736e1df95aa228ae750d62646fed", "patch": "@@ -3847,6 +3847,18 @@ aarch64_mode_valid_for_sched_fusion_p (machine_mode mode)\n \t     && GET_MODE_SIZE (mode) == 8);\n }\n \n+/* Return true if REGNO is a virtual pointer register, or an eliminable\n+   \"soft\" frame register.  Like REGNO_PTR_FRAME_P except that we don't\n+   include stack_pointer or hard_frame_pointer.  */\n+static bool\n+virt_or_elim_regno_p (unsigned regno)\n+{\n+  return ((regno >= FIRST_VIRTUAL_REGISTER\n+\t   && regno <= LAST_VIRTUAL_POINTER_REGISTER)\n+\t  || regno == FRAME_POINTER_REGNUM\n+\t  || regno == ARG_POINTER_REGNUM);\n+}\n+\n /* Return true if X is a valid address for machine mode MODE.  If it is,\n    fill in INFO appropriately.  STRICT_P is true if REG_OK_STRICT is in\n    effect.  OUTER_CODE is PARALLEL for a load/store pair.  */\n@@ -3890,9 +3902,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \n       if (! strict_p\n \t  && REG_P (op0)\n-\t  && (op0 == virtual_stack_vars_rtx\n-\t      || op0 == frame_pointer_rtx\n-\t      || op0 == arg_pointer_rtx)\n+\t  && virt_or_elim_regno_p (REGNO (op0))\n \t  && CONST_INT_P (op1))\n \t{\n \t  info->type = ADDRESS_REG_IMM;\n@@ -4953,74 +4963,43 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n \n   if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n     {\n-      HOST_WIDE_INT offset = INTVAL (XEXP (x, 1));\n-      HOST_WIDE_INT base_offset;\n+      rtx base = XEXP (x, 0);\n+      rtx offset_rtx XEXP (x, 1);\n+      HOST_WIDE_INT offset = INTVAL (offset_rtx);\n \n-      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+      if (GET_CODE (base) == PLUS)\n \t{\n-\t  rtx op0 = XEXP (XEXP (x, 0), 0);\n-\t  rtx op1 = XEXP (XEXP (x, 0), 1);\n+\t  rtx op0 = XEXP (base, 0);\n+\t  rtx op1 = XEXP (base, 1);\n \n-\t  /* Address expressions of the form Ra + Rb + CONST.\n+\t  /* Force any scaling into a temp for CSE.  */\n+\t  op0 = force_reg (Pmode, op0);\n+\t  op1 = force_reg (Pmode, op1);\n \n-\t     If CONST is within the range supported by the addressing\n-\t     mode \"reg+offset\", do not split CONST and use the\n-\t     sequence\n-\t       Rt = Ra + Rb;\n-\t       addr = Rt + CONST.  */\n-\t  if (REG_P (op0) && REG_P (op1))\n-\t    {\n-\t      machine_mode addr_mode = GET_MODE (x);\n-\t      rtx base = gen_reg_rtx (addr_mode);\n-\t      rtx addr = plus_constant (addr_mode, base, offset);\n+\t  /* Let the pointer register be in op0.  */\n+\t  if (REG_POINTER (op1))\n+\t    std::swap (op0, op1);\n \n-\t      if (aarch64_legitimate_address_hook_p (mode, addr, false))\n-\t\t{\n-\t\t  emit_insn (gen_adddi3 (base, op0, op1));\n-\t\t  return addr;\n-\t\t}\n-\t    }\n-\t  /* Address expressions of the form Ra + Rb<<SCALE + CONST.\n-\n-\t     If Reg + Rb<<SCALE is a valid address expression, do not\n-\t     split CONST and use the sequence\n-\t       Rc = CONST;\n-\t       Rt = Ra + Rc;\n-\t       addr = Rt + Rb<<SCALE.\n-\n-\t     TODO: We really should split CONST out of memory referece\n-\t     because:\n-\t       a) We depend on GIMPLE optimizers to pick up common sub\n-\t\t  expression involving the scaling operation.\n-\t       b) The index Rb is likely a loop iv, it's better to split\n-\t\t  the CONST so that computation of new base Rt is a loop\n-\t\t  invariant and can be moved out of loop.  This is more\n-\t\t  important when the original base Ra is sfp related.\n-\n-\t     Unfortunately, GIMPLE optimizers (e.g., SLSR) can not handle\n-\t     this kind of CSE opportunity at the time of this change, we\n-\t     have to force register scaling expr out of memory ref now.  */\n-\t  else if (REG_P (op0) || REG_P (op1))\n+\t  /* If the pointer is virtual or frame related, then we know that\n+\t     virtual register instantiation or register elimination is going\n+\t     to apply a second constant.  We want the two constants folded\n+\t     together easily.  Therefore, emit as (OP0 + CONST) + OP1.  */\n+\t  if (virt_or_elim_regno_p (REGNO (op0)))\n \t    {\n-\t      machine_mode addr_mode = GET_MODE (x);\n-\t      rtx base = gen_reg_rtx (addr_mode);\n-\n-\t      /* Switch to make sure that register is in op0.  */\n-\t      if (REG_P (op1))\n-\t\tstd::swap (op0, op1);\n-\n-\t      rtx addr = plus_constant (addr_mode, base, offset);\n-\n-\t      if (aarch64_legitimate_address_hook_p (mode, addr, false))\n-\t\t{\n-\t\t  base = force_operand (gen_rtx_PLUS (addr_mode, op1, op0),\n-\t\t\t\t\tNULL_RTX);\n-\t\t  return plus_constant (addr_mode, base, offset);\n-\t\t}\n+\t      base = expand_binop (Pmode, add_optab, op0, offset_rtx,\n+\t\t\t\t   NULL_RTX, true, OPTAB_DIRECT);\n+\t      return gen_rtx_PLUS (Pmode, base, op1);\n \t    }\n+\n+\t  /* Otherwise, in order to encourage CSE (and thence loop strength\n+\t     reduce) scaled addresses, emit as (OP0 + OP1) + CONST.  */\n+\t  base = expand_binop (Pmode, add_optab, op0, op1,\n+\t\t\t       NULL_RTX, true, OPTAB_DIRECT);\n+\t  x = gen_rtx_PLUS (Pmode, base, offset_rtx);\n \t}\n \n       /* Does it look like we'll need a load/store-pair operation?  */\n+      HOST_WIDE_INT base_offset;\n       if (GET_MODE_SIZE (mode) > 16\n \t  || mode == TImode)\n \tbase_offset = ((offset + 64 * GET_MODE_SIZE (mode))\n@@ -5032,15 +5011,12 @@ aarch64_legitimize_address (rtx x, rtx /* orig_x  */, machine_mode mode)\n       else\n \tbase_offset = offset & ~0xfff;\n \n-      if (base_offset == 0)\n-\treturn x;\n-\n-      offset -= base_offset;\n-      rtx base_reg = gen_reg_rtx (Pmode);\n-      rtx val = force_operand (plus_constant (Pmode, XEXP (x, 0), base_offset),\n-\t\t\t   NULL_RTX);\n-      emit_move_insn (base_reg, val);\n-      x = plus_constant (Pmode, base_reg, offset);\n+      if (base_offset != 0)\n+\t{\n+\t  base = plus_constant (Pmode, base, base_offset);\n+\t  base = force_operand (base, NULL_RTX);\n+\t  return plus_constant (Pmode, base, offset - base_offset);\n+\t}\n     }\n \n   return x;"}]}