{"sha": "682b8f4ab735d79f65e8d1303908d4f463c92490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyYjhmNGFiNzM1ZDc5ZjY1ZThkMTMwMzkwOGQ0ZjQ2M2M5MjQ5MA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-03-11T21:53:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-03-11T21:53:27Z"}, "message": "Initial revision\n\nFrom-SVN: r50606", "tree": {"sha": "febe5a47ea34e9790474f53d3c7fcf15db94538b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/febe5a47ea34e9790474f53d3c7fcf15db94538b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/682b8f4ab735d79f65e8d1303908d4f463c92490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682b8f4ab735d79f65e8d1303908d4f463c92490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/682b8f4ab735d79f65e8d1303908d4f463c92490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682b8f4ab735d79f65e8d1303908d4f463c92490/comments", "author": null, "committer": null, "parents": [{"sha": "2eb018ff2cd172cfba39610bf797b682df4040b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb018ff2cd172cfba39610bf797b682df4040b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb018ff2cd172cfba39610bf797b682df4040b1"}], "stats": {"total": 971, "additions": 971, "deletions": 0}, "files": [{"sha": "c34370386936db13cd2855004ef474baa1eed7d8", "filename": "zlib/zlib.html", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682b8f4ab735d79f65e8d1303908d4f463c92490/zlib%2Fzlib.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682b8f4ab735d79f65e8d1303908d4f463c92490/zlib%2Fzlib.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.html?ref=682b8f4ab735d79f65e8d1303908d4f463c92490", "patch": "@@ -0,0 +1,971 @@\n+<html>\n+<head>\n+ <title>\n+ zlib general purpose compression library version 1.1.4\n+ </title>\n+</head>\n+<body bgcolor=\"White\" text=\"Black\" vlink=\"Red\" alink=\"Navy\" link=\"Red\">\n+<!-- background=\"zlibbg.gif\" -->\n+\n+<h1> zlib 1.1.4 Manual </h1>\n+<hr>\n+<a name=\"Contents\"><h2>Contents</h2>\n+<ol type=\"I\">\n+<li> <a href=\"#Prologue\">Prologue</a>\n+<li> <a href=\"#Introduction\">Introduction</a>\n+<li> <a href=\"#Utility functions\">Utility functions</a>\n+<li> <a href=\"#Basic functions\">Basic functions</a>\n+<li> <a href=\"#Advanced functions\">Advanced functions</a>\n+<li> <a href=\"#Constants\">Constants</a>\n+<li> <a href=\"#struct z_stream_s\">struct z_stream_s</a>\n+<li> <a href=\"#Checksum functions\">Checksum functions</a>\n+<li> <a href=\"#Misc\">Misc</a>\n+</ol>\n+<hr>\n+<a name=\"Prologue\"><h2> Prologue </h2>\n+  'zlib' general purpose compression library version 1.1.4, March 11th, 2002\n+  <p>\n+  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler\n+  <p>\n+  This software is provided 'as-is', without any express or implied\n+  warranty.  In no event will the authors be held liable for any damages\n+  arising from the use of this software.\n+  <p>\n+  Permission is granted to anyone to use this software for any purpose,\n+  including commercial applications, and to alter it and redistribute it\n+  freely, subject to the following restrictions:\n+  <ol>\n+   <li> The origin of this software must not be misrepresented ; you must not\n+     claim that you wrote the original software. If you use this software\n+     in a product, an acknowledgment in the product documentation would be\n+     appreciated but is not required.\n+   <li> Altered source versions must be plainly marked as such, and must not be\n+     misrepresented as being the original software.\n+   <li> This notice may not be removed or altered from any source distribution.\n+  </ol>\n+\n+  <dl>\n+  <dt>Jean-loup Gailly        \n+  <dd><a href=\"mailto:jloup@gzip.org\">jloup@gzip.org</a>\n+  <dt>Mark Adler\n+  <dd><a href=\"mailto:madler@alumni.caltech.edu\">madler@alumni.caltech.edu</a>\n+  </dl>\n+\n+  The data format used by the zlib library is described by RFCs (Request for\n+  Comments) 1950 to 1952 in the files\n+  <a href=\"ftp://ds.internic.net/rfc/rfc1950.txt\">\n+  ftp://ds.internic.net/rfc/rfc1950.txt </a>\n+  (zlib format), \n+  <a href=\"ftp://ds.internic.net/rfc/rfc1951.txt\">\n+  rfc1951.txt </a>\n+  (<a href=\"#deflate\">deflate</a> format) and \n+  <a href=\"ftp://ds.internic.net/rfc/rfc1952.txt\">\n+  rfc1952.txt </a>\n+  (gzip format).\n+  <p>\n+  This manual is converted from zlib.h by \n+  <a href=\"mailto:piaip@csie.ntu.edu.tw\"> piaip </a>\n+  <p>\n+  Visit <a href=\"http://ftp.cdrom.com/pub/infozip/zlib/\">\n+  http://ftp.cdrom.com/pub/infozip/zlib/</a> \n+  for the official zlib web page.\n+  <p>\n+\n+<hr>\n+<a name=\"Introduction\"><h2> Introduction </h2>\n+     The 'zlib' compression library provides in-memory compression and\n+  decompression functions, including integrity checks of the uncompressed\n+  data.  This version of the library supports only one compression method\n+  (deflation) but other algorithms will be added later and will have the same\n+  stream interface.\n+  <p>\n+\n+     Compression can be done in a single step if the buffers are large\n+  enough (for example if an input file is mmap'ed), or can be done by\n+  repeated calls of the compression function.  In the latter case, the\n+  application must provide more input and/or consume the output\n+  (providing more output space) before each call.\n+  <p>\n+\n+     The library also supports reading and writing files in gzip (.gz) format\n+  with an interface similar to that of stdio.\n+  <p>\n+\n+     The library does not install any signal handler. The decoder checks\n+  the consistency of the compressed data, so the library should never\n+  crash even in case of corrupted input.\n+  <p>\n+\n+<hr>\n+<a name=\"Utility functions\"><h2> Utility functions </h2>\n+     The following utility functions are implemented on top of the\n+   <a href=\"#Basic functions\">basic stream-oriented functions</a>. \n+   To simplify the interface, some\n+   default options are assumed (compression level and memory usage,\n+   standard memory allocation functions). The source code of these\n+   utility functions can easily be modified if you need special options.\n+<h3> Function list </h3>\n+<ul>\n+<li> int  <a href=\"#compress\">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);\n+<li> int  <a href=\"#compress2\">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);\n+<li> int  <a href=\"#uncompress\">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);\n+<li> typedef voidp gzFile;\n+<li>  gzFile  <a href=\"#gzopen\">gzopen</a>  (const char *path, const char *mode);\n+<li> gzFile  <a href=\"#gzdopen\">gzdopen</a>  (int fd, const char *mode);\n+<li> int  <a href=\"#gzsetparams\">gzsetparams</a> (gzFile file, int level, int strategy);\n+<li> int     <a href=\"#gzread\">gzread</a>  (gzFile file, voidp buf, unsigned len);\n+<li> int     <a href=\"#gzwrite\">gzwrite</a> (gzFile file, const voidp buf, unsigned len);\n+<li> int VA   <a href=\"#gzprintf\">gzprintf</a> (gzFile file, const char *format, ...);\n+<li> int  <a href=\"#gzputs\">gzputs</a> (gzFile file, const char *s);\n+<li> char *  <a href=\"#gzgets\">gzgets</a> (gzFile file, char *buf, int len);\n+<li> int     <a href=\"#gzputc\">gzputc</a> (gzFile file, int c);\n+<li> int     <a href=\"#gzgetc\">gzgetc</a> (gzFile file);\n+<li> int     <a href=\"#gzflush\">gzflush</a> (gzFile file, int flush);\n+<li> z_off_t     <a href=\"#gzseek\">gzseek</a> (gzFile file, z_off_t offset, int whence);\n+<li> z_off_t     <a href=\"#gztell\">gztell</a> (gzFile file);\n+<li> int     <a href=\"#gzrewind\">gzrewind</a> (gzFile file);\n+<li> int  <a href=\"#gzeof\">gzeof</a> (gzFile file);\n+<li> int     <a href=\"#gzclose\">gzclose</a> (gzFile file);\n+<li> const char *  <a href=\"#gzerror\">gzerror</a> (gzFile file, int *errnum);\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt> int  <a name=\"compress\">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>\n+<dd>\n+     Compresses the source buffer into the destination buffer.  sourceLen is\n+   the byte length of the source buffer. Upon entry, destLen is the total\n+   size of the destination buffer, which must be at least 0.1% larger than\n+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the\n+   compressed buffer.<p>\n+     This function can be used to <a href=\"#compress\">compress</a> a whole file at once if the\n+   input file is mmap'ed.<p>\n+     <a href=\"#compress\">compress</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output\n+   buffer.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"compress2\">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);</font>\n+<dd>\n+     Compresses the source buffer into the destination buffer. The level\n+   parameter has the same meaning as in <a href=\"#deflateInit\">deflateInit</a>.  sourceLen is the byte\n+   length of the source buffer. Upon entry, destLen is the total size of the\n+   destination buffer, which must be at least 0.1% larger than sourceLen plus\n+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n+   <p>\n+\n+     <a href=\"#compress2\">compress2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output buffer,\n+   <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the level parameter is invalid.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"uncompress\">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>\n+<dd>\n+     Decompresses the source buffer into the destination buffer.  sourceLen is\n+   the byte length of the source buffer. Upon entry, destLen is the total\n+   size of the destination buffer, which must be large enough to hold the\n+   entire uncompressed data. (The size of the uncompressed data must have\n+   been saved previously by the compressor and transmitted to the decompressor\n+   by some mechanism outside the scope of this compression library.)\n+   Upon exit, destLen is the actual size of the compressed buffer. <p>\n+     This function can be used to decompress a whole file at once if the\n+   input file is mmap'ed.\n+   <p>\n+\n+     <a href=\"#uncompress\">uncompress</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if there was not enough room in the output\n+   buffer, or <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the input data was corrupted.\n+   <p>\n+\n+<dt> typedef voidp gzFile;\n+<dd> <p>\n+\n+<font color=\"Blue\"><dt>  gzFile  <a name=\"gzopen\">gzopen</a>  (const char *path, const char *mode);</font>\n+<dd>\n+     Opens a gzip (.gz) file for reading or writing. The mode parameter\n+   is as in fopen (\"rb\" or \"wb\") but can also include a compression level\n+   (\"wb9\") or a strategy: 'f' for filtered data as in \"wb6f\", 'h' for\n+   Huffman only compression as in \"wb1h\". (See the description\n+   of <a href=\"#deflateInit2\">deflateInit2</a> for more information about the strategy parameter.)\n+   <p>\n+\n+     <a href=\"#gzopen\">gzopen</a> can be used to read a file which is not in gzip format ; in this\n+   case <a href=\"#gzread\">gzread</a> will directly read from the file without decompression.\n+   <p>\n+\n+     <a href=\"#gzopen\">gzopen</a> returns NULL if the file could not be opened or if there was\n+   insufficient memory to allocate the (de)compression <a href=\"#state\">state</a> ; errno\n+   can be checked to distinguish the two cases (if errno is zero, the\n+   zlib error is <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a>).\n+   <p>\n+\n+<font color=\"Blue\"><dt> gzFile  <a name=\"gzdopen\">gzdopen</a>  (int fd, const char *mode);</font>\n+<dd>\n+     <a href=\"#gzdopen\">gzdopen</a>() associates a gzFile with the file descriptor fd.  File\n+   descriptors are obtained from calls like open, dup, creat, pipe or\n+   fileno (in the file has been previously opened with fopen).\n+   The mode parameter is as in <a href=\"#gzopen\">gzopen</a>.\n+   <p>\n+     The next call of <a href=\"#gzclose\">gzclose</a> on the returned gzFile will also close the\n+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file\n+   descriptor fd. If you want to keep fd open, use <a href=\"#gzdopen\">gzdopen</a>(dup(fd), mode).\n+   <p>\n+     <a href=\"#gzdopen\">gzdopen</a> returns NULL if there was insufficient memory to allocate\n+   the (de)compression <a href=\"#state\">state</a>.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzsetparams\">gzsetparams</a> (gzFile file, int level, int strategy);</font>\n+<dd>\n+     Dynamically update the compression level or strategy. See the description\n+   of <a href=\"#deflateInit2\">deflateInit2</a> for the meaning of these parameters.\n+   <p>\n+     <a href=\"#gzsetparams\">gzsetparams</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the file was not\n+   opened for writing.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzread\">gzread</a>  (gzFile file, voidp buf, unsigned len);</font>\n+<dd>\n+     Reads the given number of uncompressed bytes from the compressed file.\n+   If the input file was not in gzip format, <a href=\"#gzread\">gzread</a> copies the given number\n+   of bytes into the buffer.\n+   <p>\n+     <a href=\"#gzread\">gzread</a> returns the number of uncompressed bytes actually read (0 for\n+   end of file, -1 for error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzwrite\">gzwrite</a> (gzFile file, const voidp buf, unsigned len);</font>\n+<dd>\n+     Writes the given number of uncompressed bytes into the compressed file.\n+   <a href=\"#gzwrite\">gzwrite</a> returns the number of uncompressed bytes actually written\n+   (0 in case of error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int VA   <a name=\"gzprintf\">gzprintf</a> (gzFile file, const char *format, ...);</font>\n+<dd>\n+     Converts, formats, and writes the args to the compressed file under\n+   control of the format string, as in fprintf. <a href=\"#gzprintf\">gzprintf</a> returns the number of\n+   uncompressed bytes actually written (0 in case of error).\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzputs\">gzputs</a> (gzFile file, const char *s);</font>\n+<dd>\n+      Writes the given null-terminated string to the compressed file, excluding\n+   the terminating null character.\n+   <p>\n+      <a href=\"#gzputs\">gzputs</a> returns the number of characters written, or -1 in case of error.\n+      <p>\n+\n+<font color=\"Blue\"><dt> char *  <a name=\"gzgets\">gzgets</a> (gzFile file, char *buf, int len);</font>\n+<dd>\n+      Reads bytes from the compressed file until len-1 characters are read, or\n+   a newline character is read and transferred to buf, or an end-of-file\n+   condition is encountered.  The string is then terminated with a null\n+   character.\n+   <p>\n+      <a href=\"#gzgets\">gzgets</a> returns buf, or <a href=\"#Z_NULL\">Z_NULL</a> in case of error.\n+      <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzputc\">gzputc</a> (gzFile file, int c);</font>\n+<dd>\n+      Writes c, converted to an unsigned char, into the compressed file.\n+   <a href=\"#gzputc\">gzputc</a> returns the value that was written, or -1 in case of error.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzgetc\">gzgetc</a> (gzFile file);</font>\n+<dd>\n+      Reads one byte from the compressed file. <a href=\"#gzgetc\">gzgetc</a> returns this byte\n+   or -1 in case of end of file or error.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzflush\">gzflush</a> (gzFile file, int flush);</font>\n+<dd>\n+     Flushes all pending output into the compressed file. The parameter\n+   flush is as in the <a href=\"#deflate\">deflate</a>() function. The return value is the zlib\n+   error number (see function <a href=\"#gzerror\">gzerror</a> below). <a href=\"#gzflush\">gzflush</a> returns <a href=\"#Z_OK\">Z_OK</a> if\n+   the flush parameter is <a href=\"#Z_FINISH\">Z_FINISH</a> and all output could be flushed.\n+   <p>\n+     <a href=\"#gzflush\">gzflush</a> should be called only when strictly necessary because it can\n+   degrade compression.\n+   <p>\n+\n+<font color=\"Blue\"><dt> z_off_t     <a name=\"gzseek\">gzseek</a> (gzFile file, z_off_t offset, int whence);</font>\n+<dd>\n+      Sets the starting position for the next <a href=\"#gzread\">gzread</a> or <a href=\"#gzwrite\">gzwrite</a> on the\n+   given compressed file. The offset represents a number of bytes in the\n+   uncompressed data stream. The whence parameter is defined as in lseek(2);\n+   the value SEEK_END is not supported.\n+   <p>\n+     If the file is opened for reading, this function is emulated but can be\n+   extremely slow. If the file is opened for writing, only forward seeks are\n+   supported ; <a href=\"#gzseek\">gzseek</a> then compresses a sequence of zeroes up to the new\n+   starting position.\n+   <p>\n+      <a href=\"#gzseek\">gzseek</a> returns the resulting offset location as measured in bytes from\n+   the beginning of the uncompressed stream, or -1 in case of error, in\n+   particular if the file is opened for writing and the new starting position\n+   would be before the current position.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzrewind\">gzrewind</a> (gzFile file);</font>\n+<dd>\n+     Rewinds the given file. This function is supported only for reading.\n+     <p>\n+   <a href=\"#gzrewind\">gzrewind</a>(file) is equivalent to (int)<a href=\"#gzseek\">gzseek</a>(file, 0L, SEEK_SET)\n+   <p>\n+\n+<font color=\"Blue\"><dt> z_off_t     <a name=\"gztell\">gztell</a> (gzFile file);</font>\n+<dd>\n+     Returns the starting position for the next <a href=\"#gzread\">gzread</a> or <a href=\"#gzwrite\">gzwrite</a> on the\n+   given compressed file. This position represents a number of bytes in the\n+   uncompressed data stream.\n+   <p>\n+\n+   <a href=\"#gztell\">gztell</a>(file) is equivalent to <a href=\"#gzseek\">gzseek</a>(file, 0L, SEEK_CUR)\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"gzeof\">gzeof</a> (gzFile file);</font>\n+<dd>\n+     Returns 1 when EOF has previously been detected reading the given\n+   input stream, otherwise zero.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int     <a name=\"gzclose\">gzclose</a> (gzFile file);</font>\n+<dd>\n+     Flushes all pending output if necessary, closes the compressed file\n+   and deallocates all the (de)compression <a href=\"#state\">state</a>. The return value is the zlib\n+   error number (see function <a href=\"#gzerror\">gzerror</a> below).\n+   <p>\n+\n+<font color=\"Blue\"><dt> const char *  <a name=\"gzerror\">gzerror</a> (gzFile file, int *errnum);</font>\n+<dd>\n+     Returns the error message for the last error which occurred on the\n+   given compressed file. errnum is set to zlib error number. If an\n+   error occurred in the file system and not in the compression library,\n+   errnum is set to <a href=\"#Z_ERRNO\">Z_ERRNO</a> and the application may consult errno\n+   to get the exact error code.\n+   <p>\n+</dl>\n+<hr>\n+<a name=\"Basic functions\"><h2> Basic functions </h2>\n+<h3> Function list </h3>\n+<ul>\n+<li>  const char *  <a href=\"#zlibVersion\">zlibVersion</a> (void);\n+<li>  int  <a href=\"#deflateInit\">deflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level);\n+<li>  int  <a href=\"#deflate\">deflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);\n+<li>  int  <a href=\"#deflateEnd\">deflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li>  int  <a href=\"#inflateInit\">inflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li>  int  <a href=\"#inflate\">inflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);\n+<li>  int  <a href=\"#inflateEnd\">inflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+</ul>\n+\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt>  const char *  <a name=\"zlibVersion\">zlibVersion</a> (void);</font>\n+<dd> The application can compare <a href=\"#zlibVersion\">zlibVersion</a> and ZLIB_VERSION for consistency.\n+   If the first character differs, the library code actually used is\n+   not compatible with the zlib.h header file used by the application.\n+   This check is automatically made by <a href=\"#deflateInit\">deflateInit</a> and <a href=\"#inflateInit\">inflateInit</a>.\n+   <p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateInit\">deflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level);</font>\n+<dd>\n+     Initializes the internal stream <a href=\"#state\">state</a> for compression. The fields\n+   <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by the caller.\n+   If <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> are set to <a href=\"#Z_NULL\">Z_NULL</a>, <a href=\"#deflateInit\">deflateInit</a> updates them to\n+   use default allocation functions.\n+   <p>\n+\n+     The compression level must be <a href=\"#Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a>, or between 0 and 9:\n+   1 gives best speed, 9 gives best compression, 0 gives no compression at\n+   all (the input data is simply copied a block at a time).\n+   <p>\n+\n+   <a href=\"#Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a> requests a default compromise between speed and\n+   compression (currently equivalent to level 6).\n+   <p>\n+\n+     <a href=\"#deflateInit\">deflateInit</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if level is not a valid compression level,\n+   <a href=\"#Z_VERSION_ERROR\">Z_VERSION_ERROR</a> if the zlib library version (<a href=\"#zlib_version\">zlib_version</a>) is incompatible\n+   with the version assumed by the caller (ZLIB_VERSION).\n+   <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#deflateInit\">deflateInit</a> does not\n+   perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"deflate\">deflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);</font>\n+<dd>\n+    <a href=\"#deflate\">deflate</a> compresses as much data as possible, and stops when the input\n+  buffer becomes empty or the output buffer becomes full. It may introduce some\n+  output latency (reading input without producing any output) except when\n+  forced to flush.<p>\n+\n+    The detailed semantics are as follows. <a href=\"#deflate\">deflate</a> performs one or both of the\n+  following actions:\n+\n+  <ul>\n+  <li> Compress more input starting at <a href=\"#next_in\">next_in</a> and update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a>\n+    accordingly. If not all input can be processed (because there is not\n+    enough room in the output buffer), <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> are updated and\n+    processing will resume at this point for the next call of <a href=\"#deflate\">deflate</a>().\n+\n+  <li> \n+    Provide more output starting at <a href=\"#next_out\">next_out</a> and update <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a>\n+    accordingly. This action is forced if the parameter flush is non zero.\n+    Forcing flush frequently degrades the compression ratio, so this parameter\n+    should be set only when necessary (in interactive applications).\n+    Some output may be provided even if flush is not set.\n+  </ul> <p>\n+\n+  Before the call of <a href=\"#deflate\">deflate</a>(), the application should ensure that at least\n+  one of the actions is possible, by providing more input and/or consuming\n+  more output, and updating <a href=\"#avail_in\">avail_in</a> or <a href=\"#avail_out\">avail_out</a> accordingly ; <a href=\"#avail_out\">avail_out</a>\n+  should never be zero before the call. The application can consume the\n+  compressed output when it wants, for example when the output buffer is full\n+  (<a href=\"#avail_out\">avail_out</a> == 0), or after each call of <a href=\"#deflate\">deflate</a>(). If <a href=\"#deflate\">deflate</a> returns <a href=\"#Z_OK\">Z_OK</a>\n+  and with zero <a href=\"#avail_out\">avail_out</a>, it must be called again after making room in the\n+  output buffer because there might be more output pending.\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, all pending output is\n+  flushed to the output buffer and the output is aligned on a byte boundary, so\n+  that the decompressor can get all input data available so far. (In particular\n+  <a href=\"#avail_in\">avail_in</a> is zero after the call if enough output space has been provided\n+  before the call.)  Flushing may degrade compression for some compression\n+  algorithms and so it should be used only when necessary.\n+  <p>\n+\n+    If flush is set to <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a>, all output is flushed as with\n+  <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, and the compression <a href=\"#state\">state</a> is reset so that decompression can\n+  restart from this point if previous compressed data has been damaged or if\n+  random access is desired. Using <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a> too often can seriously degrade\n+  the compression.\n+  <p>\n+\n+    If <a href=\"#deflate\">deflate</a> returns with <a href=\"#avail_out\">avail_out</a> == 0, this function must be called again\n+  with the same value of the flush parameter and more output space (updated\n+  <a href=\"#avail_out\">avail_out</a>), until the flush is complete (<a href=\"#deflate\">deflate</a> returns with non-zero\n+  <a href=\"#avail_out\">avail_out</a>).\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_FINISH\">Z_FINISH</a>, pending input is processed,\n+  pending output is flushed and <a href=\"#deflate\">deflate</a> returns with <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if there\n+  was enough output space ; if <a href=\"#deflate\">deflate</a> returns with <a href=\"#Z_OK\">Z_OK</a>, this function must be\n+  called again with <a href=\"#Z_FINISH\">Z_FINISH</a> and more output space (updated <a href=\"#avail_out\">avail_out</a>) but no\n+  more input data, until it returns with <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or an error. After\n+  <a href=\"#deflate\">deflate</a> has returned <a href=\"#Z_STREAM_END\">Z_STREAM_END</a>, the only possible operations on the\n+  stream are <a href=\"#deflateReset\">deflateReset</a> or <a href=\"#deflateEnd\">deflateEnd</a>.\n+  <p>\n+  \n+    <a href=\"#Z_FINISH\">Z_FINISH</a> can be used immediately after <a href=\"#deflateInit\">deflateInit</a> if all the compression\n+  is to be done in a single step. In this case, <a href=\"#avail_out\">avail_out</a> must be at least\n+  0.1% larger than <a href=\"#avail_in\">avail_in</a> plus 12 bytes.  If <a href=\"#deflate\">deflate</a> does not return\n+  <a href=\"#Z_STREAM_END\">Z_STREAM_END</a>, then it must be called again as described above.\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() sets strm-&gt <a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of all input read\n+  so far (that is, <a href=\"#total_in\">total_in</a> bytes).\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() may update <a href=\"#data_type\">data_type</a> if it can make a good guess about\n+  the input data type (<a href=\"#Z_ASCII\">Z_ASCII</a> or <a href=\"#Z_BINARY\">Z_BINARY</a>). In doubt, the data is considered\n+  binary. This field is only for information purposes and does not affect\n+  the compression algorithm in any manner.\n+  <p>\n+\n+    <a href=\"#deflate\">deflate</a>() returns <a href=\"#Z_OK\">Z_OK</a> if some progress has been made (more input\n+  processed or more output produced), <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if all input has been\n+  consumed and all output has been produced (only when flush is set to\n+  <a href=\"#Z_FINISH\">Z_FINISH</a>), <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream <a href=\"#state\">state</a> was inconsistent (for example\n+  if <a href=\"#next_in\">next_in</a> or <a href=\"#next_out\">next_out</a> was NULL), <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if no progress is possible\n+  (for example <a href=\"#avail_in\">avail_in</a> or <a href=\"#avail_out\">avail_out</a> was zero).\n+  <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"deflateEnd\">deflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     All dynamically allocated data structures for this stream are freed.\n+   This function discards any unprocessed input and does not flush any\n+   pending output.\n+   <p>\n+\n+     <a href=\"#deflateEnd\">deflateEnd</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the\n+   stream <a href=\"#state\">state</a> was inconsistent, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the stream was freed\n+   prematurely (some input or output was discarded). In the error case,\n+   <a href=\"#msg\">msg</a> may be set but then points to a static string (which must not be\n+   deallocated).\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateInit\">inflateInit</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>     \n+\tInitializes the internal stream <a href=\"#state\">state</a> for decompression. The fields\n+   <a href=\"#next_in\">next_in</a>, <a href=\"#avail_in\">avail_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by\n+   the caller. If <a href=\"#next_in\">next_in</a> is not <a href=\"#Z_NULL\">Z_NULL</a> and <a href=\"#avail_in\">avail_in</a> is large enough (the exact\n+   value depends on the compression method), <a href=\"#inflateInit\">inflateInit</a> determines the\n+   compression method from the zlib header and allocates all data structures\n+   accordingly ; otherwise the allocation will be deferred to the first call of\n+   <a href=\"#inflate\">inflate</a>.  If <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> are set to <a href=\"#Z_NULL\">Z_NULL</a>, <a href=\"#inflateInit\">inflateInit</a> updates them to\n+   use default allocation functions.\n+   <p>\n+\n+     <a href=\"#inflateInit\">inflateInit</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_VERSION_ERROR\">Z_VERSION_ERROR</a> if the zlib library version is incompatible with the\n+   version assumed by the caller.  <a href=\"#msg\">msg</a> is set to null if there is no error\n+   message. <a href=\"#inflateInit\">inflateInit</a> does not perform any decompression apart from reading\n+   the zlib header if present: this will be done by <a href=\"#inflate\">inflate</a>().  (So <a href=\"#next_in\">next_in</a> and\n+   <a href=\"#avail_in\">avail_in</a> may be modified, but <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> are unchanged.)\n+   <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflate\">inflate</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int flush);</font>\n+<dd>\n+    <a href=\"#inflate\">inflate</a> decompresses as much data as possible, and stops when the input\n+  buffer becomes empty or the output buffer becomes full. It may some\n+  introduce some output latency (reading input without producing any output)\n+  except when forced to flush.\n+  <p>\n+\n+  The detailed semantics are as follows. <a href=\"#inflate\">inflate</a> performs one or both of the\n+  following actions:\n+\n+  <ul>\n+  <li> Decompress more input starting at <a href=\"#next_in\">next_in</a> and update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a>\n+    accordingly. If not all input can be processed (because there is not\n+    enough room in the output buffer), <a href=\"#next_in\">next_in</a> is updated and processing\n+    will resume at this point for the next call of <a href=\"#inflate\">inflate</a>().\n+\n+  <li> Provide more output starting at <a href=\"#next_out\">next_out</a> and update <a href=\"#next_out\">next_out</a> and \n+    <a href=\"#avail_out\">avail_out</a> accordingly.  <a href=\"#inflate\">inflate</a>() provides as much output as possible, \n+    until there is no more input data or no more space in the output buffer \n+    (see below about the flush parameter).\n+  </ul> <p>\n+\n+  Before the call of <a href=\"#inflate\">inflate</a>(), the application should ensure that at least\n+  one of the actions is possible, by providing more input and/or consuming\n+  more output, and updating the next_* and avail_* values accordingly.\n+  The application can consume the uncompressed output when it wants, for\n+  example when the output buffer is full (<a href=\"#avail_out\">avail_out</a> == 0), or after each\n+  call of <a href=\"#inflate\">inflate</a>(). If <a href=\"#inflate\">inflate</a> returns <a href=\"#Z_OK\">Z_OK</a> and with zero <a href=\"#avail_out\">avail_out</a>, it\n+  must be called again after making room in the output buffer because there\n+  might be more output pending.\n+  <p>\n+\n+    If the parameter flush is set to <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>, <a href=\"#inflate\">inflate</a> flushes as much\n+  output as possible to the output buffer. The flushing behavior of <a href=\"#inflate\">inflate</a> is\n+  not specified for values of the flush parameter other than <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>\n+  and <a href=\"#Z_FINISH\">Z_FINISH</a>, but the current implementation actually flushes as much output\n+  as possible anyway.\n+  <p>\n+\n+    <a href=\"#inflate\">inflate</a>() should normally be called until it returns <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or an\n+  error. However if all decompression is to be performed in a single step\n+  (a single call of <a href=\"#inflate\">inflate</a>), the parameter flush should be set to\n+  <a href=\"#Z_FINISH\">Z_FINISH</a>. In this case all pending input is processed and all pending\n+  output is flushed ; <a href=\"#avail_out\">avail_out</a> must be large enough to hold all the\n+  uncompressed data. (The size of the uncompressed data may have been saved\n+  by the compressor for this purpose.) The next operation on this stream must\n+  be <a href=\"#inflateEnd\">inflateEnd</a> to deallocate the decompression <a href=\"#state\">state</a>. The use of <a href=\"#Z_FINISH\">Z_FINISH</a>\n+  is never required, but can be used to inform <a href=\"#inflate\">inflate</a> that a faster routine\n+  may be used for the single <a href=\"#inflate\">inflate</a>() call.\n+  <p>\n+\n+     If a preset dictionary is needed at this point (see <a href=\"#inflateSetDictionary\">inflateSetDictionary</a>\n+  below), <a href=\"#inflate\">inflate</a> sets strm-<a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of the\n+  dictionary chosen by the compressor and returns <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a> ; otherwise \n+  it sets strm-&gt <a href=\"#adler\">adler</a> to the <a href=\"#adler32\">adler32</a> checksum of all output produced\n+  so far (that is, <a href=\"#total_out\">total_out</a> bytes) and returns <a href=\"#Z_OK\">Z_OK</a>, <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> or\n+  an error code as described below. At the end of the stream, <a href=\"#inflate\">inflate</a>()\n+  checks that its computed <a href=\"#adler32\">adler32</a> checksum is equal to that saved by the\n+  compressor and returns <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> only if the checksum is correct.\n+  <p>\n+\n+    <a href=\"#inflate\">inflate</a>() returns <a href=\"#Z_OK\">Z_OK</a> if some progress has been made (more input processed\n+  or more output produced), <a href=\"#Z_STREAM_END\">Z_STREAM_END</a> if the end of the compressed data has\n+  been reached and all uncompressed output has been produced, <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a> if a\n+  preset dictionary is needed at this point, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the input data was\n+  corrupted (input stream not conforming to the zlib format or incorrect\n+  <a href=\"#adler32\">adler32</a> checksum), <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream structure was inconsistent\n+  (for example if <a href=\"#next_in\">next_in</a> or <a href=\"#next_out\">next_out</a> was NULL), <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+  enough memory, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a> if no progress is possible or if there was not\n+  enough room in the output buffer when <a href=\"#Z_FINISH\">Z_FINISH</a> is used. In the <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a>\n+  case, the application may then call <a href=\"#inflateSync\">inflateSync</a> to look for a good\n+  compression block.\n+  <p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateEnd\">inflateEnd</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     All dynamically allocated data structures for this stream are freed.\n+   This function discards any unprocessed input and does not flush any\n+   pending output.\n+   <p>\n+\n+     <a href=\"#inflateEnd\">inflateEnd</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream <a href=\"#state\">state</a>\n+   was inconsistent. In the error case, <a href=\"#msg\">msg</a> may be set but then points to a\n+   static string (which must not be deallocated).\n+</dl>\n+<hr>\n+<a name=\"Advanced functions\"><h2> Advanced functions </h2>\n+    The following functions are needed only in some special applications.\n+<h3> Function list </h3>\n+<ul>\n+<li>  int  <a href=\"#deflateInit2\">deflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm,\n+<li> int  <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);\n+<li> int  <a href=\"#deflateCopy\">deflateCopy</a> (<a href=\"#z_streamp\">z_streamp</a> dest, <a href=\"#z_streamp\">z_streamp</a> source);\n+<li> int  <a href=\"#deflateReset\">deflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li> int  <a href=\"#deflateParams\">deflateParams</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level, int strategy);\n+<li> int  <a href=\"#inflateInit2\">inflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  windowBits);\n+<li>  int  <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);\n+<li> int  <a href=\"#inflateSync\">inflateSync</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+<li> int  <a href=\"#inflateReset\">inflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);\n+\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt>  int  <a name=\"deflateInit2\">deflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  level, int  method, int  windowBits, int  memLevel, int  strategy);</font>\n+\n+<dd> This is another version of <a href=\"#deflateInit\">deflateInit</a> with more compression options. The\n+   fields <a href=\"#next_in\">next_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized before by\n+   the caller.<p>\n+\n+     The method parameter is the compression method. It must be <a href=\"#Z_DEFLATED\">Z_DEFLATED</a> in\n+   this version of the library.<p>\n+\n+     The windowBits parameter is the base two logarithm of the window size\n+   (the size of the history buffer).  It should be in the range 8..15 for this\n+   version of the library. Larger values of this parameter result in better\n+   compression at the expense of memory usage. The default value is 15 if\n+   <a href=\"#deflateInit\">deflateInit</a> is used instead.<p>\n+\n+     The memLevel parameter specifies how much memory should be allocated\n+   for the internal compression <a href=\"#state\">state</a>. memLevel=1 uses minimum memory but\n+   is slow and reduces compression ratio ; memLevel=9 uses maximum memory\n+   for optimal speed. The default value is 8. See zconf.h for total memory\n+   usage as a function of windowBits and memLevel.<p>\n+\n+     The strategy parameter is used to tune the compression algorithm. Use the\n+   value <a href=\"#Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a> for normal data, <a href=\"#Z_FILTERED\">Z_FILTERED</a> for data produced by a\n+   filter (or predictor), or <a href=\"#Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a> to force Huffman encoding only (no\n+   string match).  Filtered data consists mostly of small values with a\n+   somewhat random distribution. In this case, the compression algorithm is\n+   tuned to <a href=\"#compress\">compress</a> them better. The effect of <a href=\"#Z_FILTERED\">Z_FILTERED</a> is to force more\n+   Huffman coding and less string matching ; it is somewhat intermediate\n+   between Z_DEFAULT and <a href=\"#Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a>. The strategy parameter only affects\n+   the compression ratio but not the correctness of the compressed output even\n+   if it is not set appropriately.<p>\n+\n+      <a href=\"#deflateInit2\">deflateInit2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a parameter is invalid (such as an invalid\n+   method). <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#deflateInit2\">deflateInit2</a> does\n+   not perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().<p>\n+                            \n+<font color=\"Blue\"><dt> int  <a name=\"deflateSetDictionary\">deflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>\n+<dd>\n+     Initializes the compression dictionary from the given byte sequence\n+   without producing any compressed output. This function must be called\n+   immediately after <a href=\"#deflateInit\">deflateInit</a>, <a href=\"#deflateInit2\">deflateInit2</a> or <a href=\"#deflateReset\">deflateReset</a>, before any\n+   call of <a href=\"#deflate\">deflate</a>. The compressor and decompressor must use exactly the same\n+   dictionary (see <a href=\"#inflateSetDictionary\">inflateSetDictionary</a>).<p>\n+\n+     The dictionary should consist of strings (byte sequences) that are likely\n+   to be encountered later in the data to be compressed, with the most commonly\n+   used strings preferably put towards the end of the dictionary. Using a\n+   dictionary is most useful when the data to be compressed is short and can be\n+   predicted with good accuracy ; the data can then be compressed better than\n+   with the default empty dictionary.<p>\n+\n+     Depending on the size of the compression data structures selected by\n+   <a href=\"#deflateInit\">deflateInit</a> or <a href=\"#deflateInit2\">deflateInit2</a>, a part of the dictionary may in effect be\n+   discarded, for example if the dictionary is larger than the window size in\n+   <a href=\"#deflate\">deflate</a> or deflate2. Thus the strings most likely to be useful should be\n+   put at the end of the dictionary, not at the front.<p>\n+\n+     Upon return of this function, strm-&gt <a href=\"#adler\">adler</a> is set to the Adler32 value\n+   of the dictionary ; the decompressor may later use this value to determine\n+   which dictionary has been used by the compressor. (The Adler32 value\n+   applies to the whole dictionary even if only a subset of the dictionary is\n+   actually used by the compressor.)<p>\n+\n+     <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a\n+   parameter is invalid (such as NULL dictionary) or the stream <a href=\"#state\">state</a> is\n+   inconsistent (for example if <a href=\"#deflate\">deflate</a> has already been called for this stream\n+   or if the compression method is bsort). <a href=\"#deflateSetDictionary\">deflateSetDictionary</a> does not\n+   perform any compression: this will be done by <a href=\"#deflate\">deflate</a>().<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateCopy\">deflateCopy</a> (<a href=\"#z_streamp\">z_streamp</a> dest, <a href=\"#z_streamp\">z_streamp</a> source);</font>\n+<dd>\n+     Sets the destination stream as a complete copy of the source stream.<p>\n+\n+     This function can be useful when several compression strategies will be\n+   tried, for example when there are several ways of pre-processing the input\n+   data with a filter. The streams that will be discarded should then be freed\n+   by calling <a href=\"#deflateEnd\">deflateEnd</a>.  Note that <a href=\"#deflateCopy\">deflateCopy</a> duplicates the internal\n+   compression <a href=\"#state\">state</a> which can be quite large, so this strategy is slow and\n+   can consume lots of memory.<p>\n+\n+     <a href=\"#deflateCopy\">deflateCopy</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not\n+   enough memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source stream <a href=\"#state\">state</a> was inconsistent\n+   (such as <a href=\"#zalloc\">zalloc</a> being NULL). <a href=\"#msg\">msg</a> is left unchanged in both source and\n+   destination.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateReset\">deflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>     This function is equivalent to <a href=\"#deflateEnd\">deflateEnd</a> followed by <a href=\"#deflateInit\">deflateInit</a>,\n+   but does not free and reallocate all the internal compression <a href=\"#state\">state</a>.\n+   The stream will keep the same compression level and any other attributes\n+   that may have been set by <a href=\"#deflateInit2\">deflateInit2</a>.<p>\n+\n+      <a href=\"#deflateReset\">deflateReset</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent (such as <a href=\"#zalloc\">zalloc</a> or <a href=\"#state\">state</a> being NULL).<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"deflateParams\">deflateParams</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int level, int strategy);</font>\n+<dd>\n+     Dynamically update the compression level and compression strategy.  The\n+   interpretation of level and strategy is as in <a href=\"#deflateInit2\">deflateInit2</a>.  This can be\n+   used to switch between compression and straight copy of the input data, or\n+   to switch to a different kind of input data requiring a different\n+   strategy. If the compression level is changed, the input available so far\n+   is compressed with the old level (and may be flushed); the new level will\n+   take effect only at the next call of <a href=\"#deflate\">deflate</a>().<p>\n+\n+     Before the call of <a href=\"#deflateParams\">deflateParams</a>, the stream <a href=\"#state\">state</a> must be set as for\n+   a call of <a href=\"#deflate\">deflate</a>(), since the currently available input may have to\n+   be compressed and flushed. In particular, strm-&gt <a href=\"#avail_out\">avail_out</a> must be \n+   non-zero.<p>\n+\n+     <a href=\"#deflateParams\">deflateParams</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent or if a parameter was invalid, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a>\n+   if strm-&gtavail_out was zero.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateInit2\">inflateInit2</a> (<a href=\"#z_streamp\">z_streamp</a> strm, int  windowBits);</font>\n+\n+<dd>     This is another version of <a href=\"#inflateInit\">inflateInit</a> with an extra parameter. The\n+   fields <a href=\"#next_in\">next_in</a>, <a href=\"#avail_in\">avail_in</a>, <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and <a href=\"#opaque\">opaque</a> must be initialized\n+   before by the caller.<p>\n+\n+     The windowBits parameter is the base two logarithm of the maximum window\n+   size (the size of the history buffer).  It should be in the range 8..15 for\n+   this version of the library. The default value is 15 if <a href=\"#inflateInit\">inflateInit</a> is used\n+   instead. If a compressed stream with a larger window size is given as\n+   input, <a href=\"#inflate\">inflate</a>() will return with the error code <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> instead of\n+   trying to allocate a larger window.<p>\n+\n+      <a href=\"#inflateInit2\">inflateInit2</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_MEM_ERROR\">Z_MEM_ERROR</a> if there was not enough\n+   memory, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a parameter is invalid (such as a negative\n+   memLevel). <a href=\"#msg\">msg</a> is set to null if there is no error message.  <a href=\"#inflateInit2\">inflateInit2</a>\n+   does not perform any decompression apart from reading the zlib header if\n+   present: this will be done by <a href=\"#inflate\">inflate</a>(). (So <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> may be\n+   modified, but <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> are unchanged.)<p>\n+\n+<font color=\"Blue\"><dt>  int  <a name=\"inflateSetDictionary\">inflateSetDictionary</a> (<a href=\"#z_streamp\">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>\n+<dd>\n+     Initializes the decompression dictionary from the given uncompressed byte\n+   sequence. This function must be called immediately after a call of <a href=\"#inflate\">inflate</a>\n+   if this call returned <a href=\"#Z_NEED_DICT\">Z_NEED_DICT</a>. The dictionary chosen by the compressor\n+   can be determined from the Adler32 value returned by this call of\n+   <a href=\"#inflate\">inflate</a>. The compressor and decompressor must use exactly the same\n+   dictionary (see <a href=\"#deflateSetDictionary\">deflateSetDictionary</a>).<p>\n+\n+     <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if a\n+   parameter is invalid (such as NULL dictionary) or the stream <a href=\"#state\">state</a> is\n+   inconsistent, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if the given dictionary doesn't match the\n+   expected one (incorrect Adler32 value). <a href=\"#inflateSetDictionary\">inflateSetDictionary</a> does not\n+   perform any decompression: this will be done by subsequent calls of\n+   <a href=\"#inflate\">inflate</a>().<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateSync\">inflateSync</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+\n+<dd>    Skips invalid compressed data until a full flush point (see above the\n+  description of <a href=\"#deflate\">deflate</a> with <a href=\"#Z_FULL_FLUSH\">Z_FULL_FLUSH</a>) can be found, or until all\n+  available input is skipped. No output is provided.<p>\n+\n+    <a href=\"#inflateSync\">inflateSync</a> returns <a href=\"#Z_OK\">Z_OK</a> if a full flush point has been found, <a href=\"#Z_BUF_ERROR\">Z_BUF_ERROR</a>\n+  if no more input was provided, <a href=\"#Z_DATA_ERROR\">Z_DATA_ERROR</a> if no flush point has been found,\n+  or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the stream structure was inconsistent. In the success\n+  case, the application may save the current current value of <a href=\"#total_in\">total_in</a> which\n+  indicates where valid compressed data was found. In the error case, the\n+  application may repeatedly call <a href=\"#inflateSync\">inflateSync</a>, providing more input each time,\n+  until success or end of the input data.<p>\n+\n+<font color=\"Blue\"><dt> int  <a name=\"inflateReset\">inflateReset</a> (<a href=\"#z_streamp\">z_streamp</a> strm);</font>\n+<dd>\n+     This function is equivalent to <a href=\"#inflateEnd\">inflateEnd</a> followed by <a href=\"#inflateInit\">inflateInit</a>,\n+   but does not free and reallocate all the internal decompression <a href=\"#state\">state</a>.\n+   The stream will keep attributes that may have been set by <a href=\"#inflateInit2\">inflateInit2</a>.\n+   <p>\n+\n+      <a href=\"#inflateReset\">inflateReset</a> returns <a href=\"#Z_OK\">Z_OK</a> if success, or <a href=\"#Z_STREAM_ERROR\">Z_STREAM_ERROR</a> if the source\n+   stream <a href=\"#state\">state</a> was inconsistent (such as <a href=\"#zalloc\">zalloc</a> or <a href=\"#state\">state</a> being NULL).\n+   <p>\n+</dl>\n+\n+<hr>\n+<a name=\"Checksum functions\"><h2> Checksum functions </h2>\n+     These functions are not related to compression but are exported\n+   anyway because they might be useful in applications using the\n+   compression library.\n+<h3> Function list </h3>\n+<ul>\n+<li> uLong  <a href=\"#adler32\">adler32</a> (uLong <a href=\"#adler\">adler</a>, const Bytef *buf, uInt len);\n+<li> uLong  <a href=\"#crc32\">crc32</a>   (uLong crc, const Bytef *buf, uInt len);\n+</ul>\n+<h3> Function description </h3>\n+<dl>\n+<font color=\"Blue\"><dt> uLong  <a name=\"adler32\">adler32</a> (uLong <a href=\"#adler\">adler</a>, const Bytef *buf, uInt len);</font>\n+<dd>\n+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n+   return the updated checksum. If buf is NULL, this function returns\n+   the required initial value for the checksum.\n+   <p>\n+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed\n+   much faster. Usage example:\n+   <pre>\n+\n+     uLong <a href=\"#adler\">adler</a> = <a href=\"#adler32\">adler32</a>(0L, <a href=\"#Z_NULL\">Z_NULL</a>, 0);\n+\n+     while (read_buffer(buffer, length) != EOF) {\n+       <a href=\"#adler\">adler</a> = <a href=\"#adler32\">adler32</a>(<a href=\"#adler\">adler</a>, buffer, length);\n+     }\n+     if (<a href=\"#adler\">adler</a> != original_adler) error();\n+   </pre>\n+\n+<font color=\"Blue\"><dt> uLong  <a name=\"crc32\">crc32</a>   (uLong crc, const Bytef *buf, uInt len);</font>\n+<dd>\n+     Update a running crc with the bytes buf[0..len-1] and return the updated\n+   crc. If buf is NULL, this function returns the required initial value\n+   for the crc. Pre- and post-conditioning (one's complement) is performed\n+   within this function so it shouldn't be done by the application.\n+   Usage example:\n+   <pre>\n+\n+     uLong crc = <a href=\"#crc32\">crc32</a>(0L, <a href=\"#Z_NULL\">Z_NULL</a>, 0);\n+\n+     while (read_buffer(buffer, length) != EOF) {\n+       crc = <a href=\"#crc32\">crc32</a>(crc, buffer, length);\n+     }\n+     if (crc != original_crc) error();\n+   </pre>\n+</dl>\n+<hr>\n+<a name=\"struct z_stream_s\"><h2> struct z_stream_s </h2>\n+<font color=\"Blue\">\n+<a name=\"z_stream_s\">\n+<pre>\n+typedef struct z_stream_s {\n+    Bytef    *<a name=\"next_in\">next_in</a>;  /* next input byte */\n+    uInt     <a name=\"avail_in\">avail_in</a>;  /* number of bytes available at <a href=\"#next_in\">next_in</a> */\n+    uLong    <a name=\"total_in\">total_in</a>;  /* total nb of input bytes read so far */\n+\n+    Bytef    *<a name=\"next_out\">next_out</a>; /* next output byte should be put there */\n+    uInt     <a name=\"avail_out\">avail_out</a>; /* remaining free space at <a href=\"#next_out\">next_out</a> */\n+    uLong    <a name=\"total_out\">total_out</a>; /* total nb of bytes output so far */\n+\n+    char     *<a name=\"msg\">msg</a>;      /* last error message, NULL if no error */\n+    struct internal_state FAR *<a name=\"state\">state</a>; /* not visible by applications */\n+\n+    alloc_func <a name=\"zalloc\">zalloc</a>;  /* used to allocate the internal <a href=\"#state\">state</a> */\n+    free_func  <a name=\"zfree\">zfree</a>;   /* used to free the internal <a href=\"#state\">state</a> */\n+    voidpf     <a name=\"opaque\">opaque</a>;  /* private data object passed to <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> */\n+\n+    int     <a name=\"data_type\">data_type</a>;  /* best guess about the data type: ascii or binary */\n+    uLong   <a name=\"adler\">adler</a>;      /* <a href=\"#adler32\">adler32</a> value of the uncompressed data */\n+    uLong   <a name=\"reserved\">reserved</a>;   /* <a href=\"#reserved\">reserved</a> for future use */\n+} <a href=\"#z_stream_s\">z_stream</a> ;\n+\n+typedef <a href=\"#z_stream_s\">z_stream</a> FAR * <a name=\"z_streamp\">z_streamp</a>;  \ufffd \n+</pre>\n+</font>\n+   The application must update <a href=\"#next_in\">next_in</a> and <a href=\"#avail_in\">avail_in</a> when <a href=\"#avail_in\">avail_in</a> has\n+   dropped to zero. It must update <a href=\"#next_out\">next_out</a> and <a href=\"#avail_out\">avail_out</a> when <a href=\"#avail_out\">avail_out</a>\n+   has dropped to zero. The application must initialize <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a> and\n+   <a href=\"#opaque\">opaque</a> before calling the init function. All other fields are set by the\n+   compression library and must not be updated by the application. <p>\n+\n+   The <a href=\"#opaque\">opaque</a> value provided by the application will be passed as the first\n+   parameter for calls of <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a>. This can be useful for custom\n+   memory management. The compression library attaches no meaning to the\n+   <a href=\"#opaque\">opaque</a> value. <p>\n+\n+   <a href=\"#zalloc\">zalloc</a> must return <a href=\"#Z_NULL\">Z_NULL</a> if there is not enough memory for the object.\n+   If zlib is used in a multi-threaded application, <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> must be\n+   thread safe. <p>\n+\n+   On 16-bit systems, the functions <a href=\"#zalloc\">zalloc</a> and <a href=\"#zfree\">zfree</a> must be able to allocate\n+   exactly 65536 bytes, but will not be required to allocate more than this\n+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,\n+   pointers returned by <a href=\"#zalloc\">zalloc</a> for objects of exactly 65536 bytes *must*\n+   have their offset normalized to zero. The default allocation function\n+   provided by this library ensures this (see zutil.c). To reduce memory\n+   requirements and avoid any allocation of 64K objects, at the expense of\n+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).\n+   <p>\n+\n+   The fields <a href=\"#total_in\">total_in</a> and <a href=\"#total_out\">total_out</a> can be used for statistics or\n+   progress reports. After compression, <a href=\"#total_in\">total_in</a> holds the total size of\n+   the uncompressed data and may be saved for use in the decompressor\n+   (particularly if the decompressor wants to decompress everything in\n+   a single step). <p>\n+\n+<hr>\n+<a name=\"Constants\"><h2> Constants </h2>\n+<font color=\"Blue\">\n+<pre>\n+#define <a name=\"Z_NO_FLUSH\">Z_NO_FLUSH</a>      0\n+#define <a name=\"Z_PARTIAL_FLUSH\">Z_PARTIAL_FLUSH</a> 1 \n+\t/* will be removed, use <a href=\"#Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a> instead */\n+#define <a name=\"Z_SYNC_FLUSH\">Z_SYNC_FLUSH</a>    2\n+#define <a name=\"Z_FULL_FLUSH\">Z_FULL_FLUSH</a>    3\n+#define <a name=\"Z_FINISH\">Z_FINISH</a>        4\n+/* Allowed flush values ; see <a href=\"#deflate\">deflate</a>() below for details */\n+\n+#define <a name=\"Z_OK\">Z_OK</a>            0\n+#define <a name=\"Z_STREAM_END\">Z_STREAM_END</a>    1\n+#define <a name=\"Z_NEED_DICT\">Z_NEED_DICT</a>     2\n+#define <a name=\"Z_ERRNO\">Z_ERRNO</a>        (-1)\n+#define <a name=\"Z_STREAM_ERROR\">Z_STREAM_ERROR</a> (-2)\n+#define <a name=\"Z_DATA_ERROR\">Z_DATA_ERROR</a>   (-3)\n+#define <a name=\"Z_MEM_ERROR\">Z_MEM_ERROR</a>    (-4)\n+#define <a name=\"Z_BUF_ERROR\">Z_BUF_ERROR</a>    (-5)\n+#define <a name=\"Z_VERSION_ERROR\">Z_VERSION_ERROR</a> (-6)\n+/* Return codes for the compression/decompression functions. Negative\n+ * values are errors, positive values are used for special but normal events.\n+ */\n+\n+#define <a name=\"Z_NO_COMPRESSION\">Z_NO_COMPRESSION</a>         0\n+#define <a name=\"Z_BEST_SPEED\">Z_BEST_SPEED</a>             1\n+#define <a name=\"Z_BEST_COMPRESSION\">Z_BEST_COMPRESSION</a>       9\n+#define <a name=\"Z_DEFAULT_COMPRESSION\">Z_DEFAULT_COMPRESSION</a>  (-1)\n+/* compression levels */\n+\n+#define <a name=\"Z_FILTERED\">Z_FILTERED</a>            1\n+#define <a name=\"Z_HUFFMAN_ONLY\">Z_HUFFMAN_ONLY</a>        2\n+#define <a name=\"Z_DEFAULT_STRATEGY\">Z_DEFAULT_STRATEGY</a>    0\n+/* compression strategy ; see <a href=\"#deflateInit2\">deflateInit2</a>() below for details */\n+\n+#define <a name=\"Z_BINARY\">Z_BINARY</a>   0\n+#define <a name=\"Z_ASCII\">Z_ASCII</a>    1\n+#define <a name=\"Z_UNKNOWN\">Z_UNKNOWN</a>  2\n+/* Possible values of the <a href=\"#data_type\">data_type</a> field */\n+\n+#define <a name=\"Z_DEFLATED\">Z_DEFLATED</a>   8\n+/* The <a href=\"#deflate\">deflate</a> compression method (the only one supported in this version) */\n+\n+#define <a name=\"Z_NULL\">Z_NULL</a>  0  /* for initializing <a href=\"#zalloc\">zalloc</a>, <a href=\"#zfree\">zfree</a>, <a href=\"#opaque\">opaque</a> */\n+\n+#define <a name=\"zlib_version\">zlib_version</a> <a href=\"#zlibVersion\">zlibVersion</a>()\n+/* for compatibility with versions less than 1.0.2 */\n+</pre>\n+</font>\n+\n+<hr>\n+<a name=\"Misc\"><h2> Misc </h2>\n+ <a href=\"#deflateInit\">deflateInit</a> and <a href=\"#inflateInit\">inflateInit</a> are macros to allow checking the zlib version\n+ and the compiler's view of <a href=\"#z_stream_s\">z_stream</a>.\n+ <p>\n+ Other functions:\n+ <dl>\n+ <font color=\"Blue\"><dt> const char   *  <a name=\"zError\">zError</a>           (int err);</font>\n+ <font color=\"Blue\"><dt> int             <a name=\"inflateSyncPoint\">inflateSyncPoint</a> (<a href=\"#z_streamp\">z_streamp</a> z);</font>\n+ <font color=\"Blue\"><dt> const uLongf *  <a name=\"get_crc_table\">get_crc_table</a>    (void);</font>\n+ </dl>\n+ <hr>\n+ <font size=\"-1\">\n+ Last update: Wed Oct 13 20:42:34 1999<br>\n+ piapi@csie.ntu.edu.tw\n+ </font>\n+\n+</body>\n+</html>"}]}