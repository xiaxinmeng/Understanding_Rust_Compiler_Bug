{"sha": "c5caa35076b08db79b363624678265ec9a1d1ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjYWEzNTA3NmIwOGRiNzliMzYzNjI0Njc4MjY1ZWM5YTFkMWVjOQ==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T22:22:23Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T22:22:23Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1529", "tree": {"sha": "565b477659da1e477cb7d67aec583ae8882af37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/565b477659da1e477cb7d67aec583ae8882af37d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5caa35076b08db79b363624678265ec9a1d1ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5caa35076b08db79b363624678265ec9a1d1ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5caa35076b08db79b363624678265ec9a1d1ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5caa35076b08db79b363624678265ec9a1d1ec9/comments", "author": null, "committer": null, "parents": [{"sha": "00b0e2a77eb26ae4a0e0302e3a81b7b6d0c95b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b0e2a77eb26ae4a0e0302e3a81b7b6d0c95b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b0e2a77eb26ae4a0e0302e3a81b7b6d0c95b33"}], "stats": {"total": 70, "additions": 62, "deletions": 8}, "files": [{"sha": "882274122655450d01ec318d61207c48ce5eb9c5", "filename": "gcc/integrate.c", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c5caa35076b08db79b363624678265ec9a1d1ec9", "patch": "@@ -66,6 +66,7 @@ static rtx copy_for_inline ();\n static void copy_decl_rtls ();\n \n static tree copy_decl_tree ();\n+static tree copy_decl_list ();\n \n /* Return the constant equivalent of a given rtx, or 0 if none.  */\n static rtx const_equiv ();\n@@ -479,11 +480,15 @@ save_for_inline_copying (fndecl)\n      whose space has been freed.  */\n \n   DECL_INITIAL (fndecl) = copy_decl_tree (DECL_INITIAL (fndecl));\n+  DECL_ARGUMENTS (fndecl) = copy_decl_list (DECL_ARGUMENTS (fndecl));\n \n   /* Now copy each DECL_RTL which is a MEM,\n      so it is safe to modify their addresses.  */\n   copy_decl_rtls (DECL_INITIAL (fndecl));\n \n+  /* The fndecl node acts as its own progenitor, so mark it as such.  */\n+  DECL_ABSTRACT_ORIGIN (fndecl) = fndecl;\n+\n   /* Now copy the chain of insns.  Do this twice.  The first copy the insn\n      itself and its body.  The second time copy of REG_NOTES.  This is because\n      a REG_NOTE may have a forward pointer to another insn.  */\n@@ -550,6 +555,40 @@ save_for_inline_copying (fndecl)\n   set_new_first_and_last_insn (first_insn, last_insn);\n }\n \n+/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.\n+   For example, this can copy a list made of TREE_LIST nodes.  While copying,\n+   for each node copied which doesn't already have is DECL_ABSTRACT_ORIGIN\n+   set to some non-zero value, set the DECL_ABSTRACT_ORIGIN of the copy to\n+   point to the corresponding (abstract) original node.  */\n+\n+static tree\n+copy_decl_list (list)\n+     tree list;\n+{\n+  tree head;\n+  register tree prev, next;\n+\n+  if (list == 0)\n+    return 0;\n+\n+  head = prev = copy_node (list);\n+  if (DECL_ABSTRACT_ORIGIN (head) == NULL_TREE)\n+    DECL_ABSTRACT_ORIGIN (head) = list;\n+  next = TREE_CHAIN (list);\n+  while (next)\n+    {\n+      register tree copy;\n+\n+      copy = copy_node (next);\n+      if (DECL_ABSTRACT_ORIGIN (copy) == NULL_TREE)\n+\tDECL_ABSTRACT_ORIGIN (copy) = next;\n+      TREE_CHAIN (prev) = copy;\n+      prev = copy;\n+      next = TREE_CHAIN (next);\n+    }\n+  return head;\n+}\n+\n /* Make a copy of the entire tree of blocks BLOCK, and return it.  */\n \n static tree\n@@ -558,7 +597,7 @@ copy_decl_tree (block)\n {\n   tree t, vars, subblocks;\n \n-  vars = copy_list (BLOCK_VARS (block));\n+  vars = copy_decl_list (BLOCK_VARS (block));\n   subblocks = 0;\n \n   /* Process all subblocks.  */\n@@ -1655,7 +1694,7 @@ integrate_parm_decls (args, map, arg_vector)\n       /* These args would always appear unused, if not for this.  */\n       TREE_USED (decl) = 1;\n       /* Prevent warning for shadowing with these.  */\n-      DECL_FROM_INLINE (decl) = 1;\n+      DECL_ABSTRACT_ORIGIN (decl) = tail;\n       pushdecl (decl);\n       /* Fully instantiate the address with the equivalent form so that the\n \t debugging information contains the actual register, instead of the\n@@ -1715,7 +1754,7 @@ integrate_decl_tree (let, level, map)\n       /* These args would always appear unused, if not for this.  */\n       TREE_USED (d) = 1;\n       /* Prevent warning for shadowing with these.  */\n-      DECL_FROM_INLINE (d) = 1;\n+      DECL_ABSTRACT_ORIGIN (d) = t;\n       pushdecl (d);\n     }\n "}, {"sha": "b7c9e660d23a567cdeb5aeae53bc25854628d967", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=c5caa35076b08db79b363624678265ec9a1d1ec9", "patch": "@@ -329,8 +329,6 @@ print_node (file, prefix, node, indent)\n \tfputs (\" bit-field\", file);\n       if (DECL_VIRTUAL_P (node))\n \tfputs (\" virtual\", file);\n-      if (DECL_FROM_INLINE (node))\n-\tfputs (\" from_inline\", file);\n       if (DECL_IGNORED_P (node))\n \tfputs (\" ignored\", file);\n       if (DECL_IN_SYSTEM_HEADER (node))\n@@ -368,6 +366,8 @@ print_node (file, prefix, node, indent)\n       if (TREE_CODE (node) == FIELD_DECL)\n \tprint_node (file, \"bitpos\", DECL_FIELD_BITPOS (node), indent + 4);\n       print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n+      print_node_brief (file, \"abstract_origin\",\n+\t\t\tDECL_ABSTRACT_ORIGIN (node), indent + 4);\n \n       print_node (file, \"arguments\", DECL_ARGUMENTS (node), indent + 4);\n       print_node (file, \"result\", DECL_RESULT (node), indent + 4);"}, {"sha": "72ef3f6f1fd4112826f5b6a9ab7d3676ff11bede", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5caa35076b08db79b363624678265ec9a1d1ec9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c5caa35076b08db79b363624678265ec9a1d1ec9", "patch": "@@ -725,14 +725,28 @@ struct tree_type\n /* Every ..._DECL node gets a unique number.  */\n #define DECL_UID(NODE) ((NODE)->decl.uid)\n \n-/* Nonzero in a VAR_DECL or PARM_DECL means this decl was made by inlining;\n+/* For any sort of a ..._DECL node, this points to the original (abstract)\n+   decl node which this decl is an instance of, or else it is NULL indicating\n+   that this decl is not an instance of some other decl.  */\n+#define DECL_ABSTRACT_ORIGIN(NODE) ((NODE)->decl.abstract_origin)\n+\n+/* Nonzero for any sort of ..._DECL node means this decl node represents\n+   an inline instance of some original (abstract) decl from an inline function;\n    suppress any warnings about shadowing some other variable.  */\n-#define DECL_FROM_INLINE(NODE) ((NODE)->decl.from_inline_flag)\n+#define DECL_FROM_INLINE(NODE) (DECL_ABSTRACT_ORIGIN (NODE) != (tree) 0)\n \n /* Nonzero if a _DECL means that the name of this decl should be ignored\n    for symbolic debug purposes.  */\n #define DECL_IGNORED_P(NODE) ((NODE)->decl.ignored_flag)\n \n+/* Nonzero for a given ..._DECL node means that this node represents an\n+   \"abstract instance\" of the given declaration (e.g. in the original\n+   declaration of an inline function).  When generating symbolic debugging\n+   information, we musn't try to generate any address information for nodes\n+   marked as \"abstract instances\" because we don't actually generate\n+   any code or allocate any data space for such instances.  */\n+#define DECL_ABSTRACT(NODE) ((NODE)->decl.abstract_flag)\n+\n /* Nonzero if a _DECL means that no warnings should be generated just\n    because this decl is unused.  */\n #define DECL_IN_SYSTEM_HEADER(NODE) ((NODE)->decl.in_system_header_flag)\n@@ -812,8 +826,8 @@ struct tree_decl\n   unsigned inline_flag : 1;\n   unsigned bit_field_flag : 1;\n   unsigned virtual_flag : 1;\n-  unsigned from_inline_flag : 1;\n   unsigned ignored_flag : 1;\n+  unsigned abstract_flag : 1;\n \n   unsigned in_system_header_flag : 1;\n   /* room for seven more */\n@@ -832,6 +846,7 @@ struct tree_decl\n   union tree_node *arguments;\n   union tree_node *result;\n   union tree_node *initial;\n+  union tree_node *abstract_origin;\n   /* The PRINT_NAME field is marked for death.  */\n   char *print_name;\n   union tree_node *assembler_name;"}]}