{"sha": "c586192c7d0f9f5264179a7af8e48022b1a089de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4NjE5MmM3ZDBmOWY1MjY0MTc5YTdhZjhlNDgwMjJiMWEwODlkZQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-11T21:39:33Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-11T21:39:33Z"}, "message": "basic-block.h (split_block, [...]): New prototypes.\n\n\t* basic-block.h (split_block, update_bb_for_insn): New prototypes.\n\t* flow.c (split_block, update_bb_for_insn): New functions.\n\nFrom-SVN: r36332", "tree": {"sha": "7796676bb81a15db338a06d19873c310279fa30d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7796676bb81a15db338a06d19873c310279fa30d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c586192c7d0f9f5264179a7af8e48022b1a089de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c586192c7d0f9f5264179a7af8e48022b1a089de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c586192c7d0f9f5264179a7af8e48022b1a089de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c586192c7d0f9f5264179a7af8e48022b1a089de/comments", "author": null, "committer": null, "parents": [{"sha": "a5e5cf67cc0fc6f5947ac5428ce650c763f4f5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e5cf67cc0fc6f5947ac5428ce650c763f4f5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e5cf67cc0fc6f5947ac5428ce650c763f4f5f4"}], "stats": {"total": 125, "additions": 125, "deletions": 0}, "files": [{"sha": "5b75fc83f9a65ee38132d8d418024877bf209653", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c586192c7d0f9f5264179a7af8e48022b1a089de", "patch": "@@ -1,3 +1,8 @@\n+2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* basic-block.h (split_block, update_bb_for_insn): New prototypes.\n+\t* flow.c (split_block, update_bb_for_insn): New functions.\n+\n 2000-09-11  Richard Henderson  <rth@cygnus.com>\n \n \t* cse.c (fold_rtx): Honor NO_FUNCTION_CSE."}, {"sha": "79e3c5e97fdb38b5f0bf1ef966bdabec3e7f50a8", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c586192c7d0f9f5264179a7af8e48022b1a089de", "patch": "@@ -235,11 +235,13 @@ extern varray_type basic_block_for_insn;\n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n \n extern void compute_bb_for_insn\t\tPARAMS ((int));\n+extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n extern void set_block_for_insn\t\tPARAMS ((rtx, basic_block));\n extern void set_block_num\t\tPARAMS ((rtx, int));\n \n extern void free_basic_block_vars\tPARAMS ((int));\n \n+extern edge split_block\t\t\tPARAMS ((basic_block, rtx));\n extern basic_block split_edge\t\tPARAMS ((edge));\n extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n extern void commit_edge_insertions\tPARAMS ((void));"}, {"sha": "545f248d5492ab9cf42fc3dd1556975e9a838de7", "filename": "gcc/flow.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c586192c7d0f9f5264179a7af8e48022b1a089de/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c586192c7d0f9f5264179a7af8e48022b1a089de", "patch": "@@ -1420,6 +1420,102 @@ mark_critical_edges ()\n     }\n }\n \f\n+/* Split a block BB after insn INSN creating a new fallthru edge.\n+   Return the new edge.  Note that to keep other parts of the compiler happy,\n+   this function renumbers all the basic blocks so that the new\n+   one has a number one greater than the block split.  */\n+\n+edge\n+split_block (bb, insn)\n+     basic_block bb;\n+     rtx insn;\n+{\n+  basic_block new_bb;\n+  edge new_edge;\n+  edge e;\n+  rtx bb_note;\n+  int i, j;\n+\n+  if (BLOCK_FOR_INSN (insn) != bb)\n+    abort ();\n+\n+  /* There is no point splitting the block after its end.  */\n+  if (bb->end == insn)\n+    return 0;\n+\n+  /* Create the new structures.  */\n+  new_bb = (basic_block) obstack_alloc (function_obstack, sizeof (*new_bb));\n+  new_edge = (edge) xcalloc (1, sizeof (*new_edge));\n+  n_edges++;\n+\n+  memset (new_bb, 0, sizeof (*new_bb));\n+\n+  new_bb->head = NEXT_INSN (insn);\n+  new_bb->end = bb->end;\n+  bb->end = insn;\n+\n+  new_bb->succ = bb->succ;\n+  bb->succ = new_edge;\n+  new_bb->pred = new_edge;\n+  new_bb->count = bb->count;\n+  new_bb->loop_depth = bb->loop_depth;\n+\n+  new_edge->src = bb;\n+  new_edge->dest = new_bb;\n+  new_edge->flags = EDGE_FALLTHRU;\n+  new_edge->probability = REG_BR_PROB_BASE;\n+  new_edge->count = bb->count;\n+\n+  /* Redirect the src of the successor edges of bb to point to new_bb.  */\n+  for (e = new_bb->succ; e; e = e->succ_next)\n+    e->src = new_bb;\n+  \n+  /* Place the new block just after the block being split.  */\n+  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\n+  /* Some parts of the compiler expect blocks to be number in\n+     sequential order so insert the new block immediately after the\n+     block being split..  */\n+  j = bb->index;\n+  for (i = n_basic_blocks - 1; i > j + 1; --i)\n+    {\n+      basic_block tmp = BASIC_BLOCK (i - 1);\n+      BASIC_BLOCK (i) = tmp;\n+      tmp->index = i;\n+    }\n+\n+  BASIC_BLOCK (i) = new_bb;\n+  new_bb->index = i;\n+\n+  /* Create the basic block note.  */\n+  bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n+\t\t\t      new_bb->head);\n+  NOTE_BASIC_BLOCK (bb_note) = new_bb;\n+  new_bb->head = bb_note;\n+\n+  update_bb_for_insn (new_bb);\n+\n+  if (bb->global_live_at_start)\n+    {\n+      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (function_obstack);\n+      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n+\n+      /* We now have to calculate which registers are live at the end\n+\t of the split basic block and at the start of the new basic\n+\t block.  Start with those registers that are known to be live\n+\t at the end of the original basic block and get\n+\t propagate_block to determine which registers are live.  */\n+      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_end);\n+      propagate_block (new_bb, new_bb->global_live_at_start, NULL, 0);\n+      COPY_REG_SET (new_bb->global_live_at_end, \n+\t\t    new_bb->global_live_at_start);\n+    }\n+\n+  return new_edge;\n+}\n+\n+\n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n \n@@ -6425,6 +6521,28 @@ count_or_remove_death_notes (blocks, kill)\n   return count;\n }\n \n+\n+/* Update insns block within BB.  */\n+\n+void \n+update_bb_for_insn (bb)\n+     basic_block bb;\n+{\n+  rtx insn;\n+\n+  if (! basic_block_for_insn)\n+    return;\n+\n+  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+    {\n+      set_block_for_insn (insn, bb);\n+\n+      if (insn == bb->end)\n+\tbreak;\n+    }\n+}\n+\n+\n /* Record INSN's block as BB.  */\n \n void"}]}