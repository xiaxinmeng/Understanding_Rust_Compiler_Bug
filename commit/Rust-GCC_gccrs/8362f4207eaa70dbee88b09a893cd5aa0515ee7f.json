{"sha": "8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM2MmY0MjA3ZWFhNzBkYmVlODhiMDlhODkzY2Q1YWEwNTE1ZWU3Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-26T12:36:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-26T12:36:35Z"}, "message": "i386.c (struct machine_function): Add save_varrargs_registers.\n\n\t* i386.c (struct machine_function): Add save_varrargs_registers.\n\t(ix86_save_varrargs_registers): New macro.\n\t(ix86_frame_layout): Support 64bit; support red zones and varrargs area.\n\t(ix86_expand_prologue): Likewise.\n\t(ix86_emit_epilogue_esp_adjustement): Likewise.\n\t(ix86_expand_epilogue): Likewise.\n\t* i386.md (pro_epilogue_adjust_stack): Turn to expander; support 64bit.\n\t(pro_epilogue_adjust_stack_1): New insn.\n\t(pro_epilogue_adjust_stack_rex64): Likewise.\n\t* i386.h (MASK_NO_RED_ZONE): New constant.\n\t(TARGET_RED_ZONE): New macro.\n\t(TARGET_OPTIONS): Add \"red-zone\" and \"no-red-zone\"\n\t(RED_ZONE_SIZE): New constant.\n\t(RED_ZONE_RESERVE): New constant.\n\nFrom-SVN: r40846", "tree": {"sha": "a20a91b60dc63fff8194a25f5fd90ad81a145397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a20a91b60dc63fff8194a25f5fd90ad81a145397"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/comments", "author": null, "committer": null, "parents": [{"sha": "788bf0e34ebec318ef42f6a7ffd9e8632756908a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/788bf0e34ebec318ef42f6a7ffd9e8632756908a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/788bf0e34ebec318ef42f6a7ffd9e8632756908a"}], "stats": {"total": 184, "additions": 170, "deletions": 14}, "files": [{"sha": "db3c86df5d559fa0d1a30dc056bf0c87d8c67f88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "patch": "@@ -1,3 +1,20 @@\n+Mon Mar 26 14:35:18 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (struct machine_function): Add save_varrargs_registers.\n+\t(ix86_save_varrargs_registers): New macro.\n+\t(ix86_frame_layout): Support 64bit; support red zones and varrargs area.\n+\t(ix86_expand_prologue): Likewise.\n+\t(ix86_emit_epilogue_esp_adjustement): Likewise.\n+\t(ix86_expand_epilogue): Likewise.\n+\t* i386.md (pro_epilogue_adjust_stack): Turn to expander; support 64bit.\n+\t(pro_epilogue_adjust_stack_1): New insn.\n+\t(pro_epilogue_adjust_stack_rex64): Likewise.\n+\t* i386.h (MASK_NO_RED_ZONE): New constant.\n+\t(TARGET_RED_ZONE): New macro.\n+\t(TARGET_OPTIONS): Add \"red-zone\" and \"no-red-zone\"\n+\t(RED_ZONE_SIZE): New constant.\n+\t(RED_ZONE_RESERVE): New constant.\n+\n 2001-03-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* toplev.c (set_float_handler): Use memcpy, not bcopy."}, {"sha": "b12d625652377a535d3dcf4953c794cc576d380c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "patch": "@@ -442,15 +442,19 @@ struct rtx_def *ix86_compare_op0 = NULL_RTX;\n struct rtx_def *ix86_compare_op1 = NULL_RTX;\n \n #define MAX_386_STACK_LOCALS 2\n+/* Size of the register save area.  */\n+#define X86_64_VARARGS_SIZE (REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)\n \n /* Define the structure for the machine field in struct function.  */\n struct machine_function\n {\n   rtx stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n+  int save_varrargs_registers;\n   int accesses_prev_frame;\n };\n \n #define ix86_stack_locals (cfun->machine->stack_locals)\n+#define ix86_save_varrargs_registers (cfun->machine->save_varrargs_registers)\n \n /* Structure describing stack frame layout.\n    Stack grows downward:\n@@ -475,9 +479,11 @@ struct ix86_frame\n {\n   int nregs;\n   int padding1;\n+  int va_arg_size;\n   HOST_WIDE_INT frame;\n   int padding2;\n   int outgoing_arguments_size;\n+  int red_zone_size;\n \n   HOST_WIDE_INT to_allocate;\n   /* The offsets relative to ARG_POINTER.  */\n@@ -2338,6 +2344,15 @@ ix86_compute_frame_layout (frame)\n   /* Register save area */\n   offset += frame->nregs * UNITS_PER_WORD;\n \n+  /* Va-arg area */\n+  if (ix86_save_varrargs_registers)\n+    {\n+      offset += X86_64_VARARGS_SIZE;\n+      frame->va_arg_size = X86_64_VARARGS_SIZE;\n+    }\n+  else\n+    frame->va_arg_size = 0;\n+\n   /* Align start of frame for local function.  */\n   frame->padding1 = ((offset + stack_alignment_needed - 1)\n \t\t     & -stack_alignment_needed) - offset;\n@@ -2370,15 +2385,28 @@ ix86_compute_frame_layout (frame)\n   /* Size prologue needs to allocate.  */\n   frame->to_allocate =\n     (size + frame->padding1 + frame->padding2\n-     + frame->outgoing_arguments_size);\n+     + frame->outgoing_arguments_size + frame->va_arg_size);\n \n+  if (TARGET_64BIT && TARGET_RED_ZONE && current_function_sp_is_unchanging\n+      && current_function_is_leaf)\n+    {\n+      frame->red_zone_size = frame->to_allocate;\n+      if (frame->red_zone_size > RED_ZONE_SIZE - RED_ZONE_RESERVE)\n+\tframe->red_zone_size = RED_ZONE_SIZE - RED_ZONE_RESERVE;\n+    }\n+  else\n+    frame->red_zone_size = 0;\n+  frame->to_allocate -= frame->red_zone_size;\n+  frame->stack_pointer_offset -= frame->red_zone_size;\n #if 0\n   fprintf (stderr, \"nregs: %i\\n\", frame->nregs);\n   fprintf (stderr, \"size: %i\\n\", size);\n   fprintf (stderr, \"alignment1: %i\\n\", stack_alignment_needed);\n   fprintf (stderr, \"padding1: %i\\n\", frame->padding1);\n+  fprintf (stderr, \"va_arg: %i\\n\", frame->va_arg_size);\n   fprintf (stderr, \"padding2: %i\\n\", frame->padding2);\n   fprintf (stderr, \"to_allocate: %i\\n\", frame->to_allocate);\n+  fprintf (stderr, \"red_zone_size: %i\\n\", frame->red_zone_size);\n   fprintf (stderr, \"frame_pointer_offset: %i\\n\", frame->frame_pointer_offset);\n   fprintf (stderr, \"hard_frame_pointer_offset: %i\\n\",\n \t   frame->hard_frame_pointer_offset);\n@@ -2438,8 +2466,12 @@ ix86_expand_prologue ()\n \t\t\t  (stack_pointer_rtx, stack_pointer_rtx,\n \t\t           GEN_INT (-frame.to_allocate), hard_frame_pointer_rtx));\n       else\n-        insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (-frame.to_allocate)));\n+\tif (TARGET_64BIT)\n+\t  insn = emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-frame.to_allocate)));\n+        else\n+\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-frame.to_allocate)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n@@ -2448,6 +2480,9 @@ ix86_expand_prologue ()\n \n       rtx arg0, sym;\n \n+      if (TARGET_64BIT)\n+\tabort();\n+\n       arg0 = gen_rtx_REG (SImode, 0);\n       emit_move_insn (arg0, GEN_INT (frame.to_allocate));\n \n@@ -2489,8 +2524,12 @@ ix86_emit_epilogue_esp_adjustment (tsize)\n \t\t\t\t\t      GEN_INT (tsize),\n \t\t\t\t\t      hard_frame_pointer_rtx));\n   else\n-    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t   GEN_INT (tsize)));\n+    if (TARGET_64BIT)\n+      emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (tsize)));\n+    else\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (tsize)));\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register\n@@ -2563,18 +2602,20 @@ ix86_expand_epilogue (emit_return)\n \tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx, offset);\n \n       if (!frame_pointer_needed)\n-\tix86_emit_epilogue_esp_adjustment (frame.to_allocate\n-\t\t\t\t\t   + frame.nregs * UNITS_PER_WORD);\n+\tix86_emit_epilogue_esp_adjustment (frame.to_allocate + frame.nregs * UNITS_PER_WORD);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_size)\n-\temit_insn (gen_leave ());\n+\temit_insn (TARGET_64BIT ? gen_leave_rex64 () : gen_leave ());\n       else\n \t{\n \t  emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t\t\t    hard_frame_pointer_rtx,\n \t\t\t\t\t\t    const0_rtx,\n \t\t\t\t\t\t    hard_frame_pointer_rtx));\n-\t  emit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_popdi1 (hard_frame_pointer_rtx));\n+\t  else\n+\t    emit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n \t}\n     }\n   else\n@@ -2595,9 +2636,19 @@ ix86_expand_epilogue (emit_return)\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (ix86_save_reg (regno))\n-\t  emit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n+\t  {\n+\t    if (TARGET_64BIT)\n+\t      emit_insn (gen_popdi1 (gen_rtx_REG (Pmode, regno)));\n+\t    else\n+\t      emit_insn (gen_popsi1 (gen_rtx_REG (Pmode, regno)));\n+\t  }\n       if (frame_pointer_needed)\n-\temit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_popdi1 (hard_frame_pointer_rtx));\n+\t  else\n+\t    emit_insn (gen_popsi1 (hard_frame_pointer_rtx));\n+\t}\n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */\n@@ -2616,6 +2667,10 @@ ix86_expand_epilogue (emit_return)\n \t{\n \t  rtx ecx = gen_rtx_REG (SImode, 2);\n \n+\t  /* There are is no \"pascal\" calling convention in 64bit ABI.  */\n+\t  if (TARGET_64BIT)\n+\t    abort();\n+\n \t  emit_insn (gen_popsi1 (ecx));\n \t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, popc));\n \t  emit_jump_insn (gen_return_indirect_internal (ecx));"}, {"sha": "1552b413efce98dda5bba80c01685aad8c7fc4bb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "patch": "@@ -120,6 +120,7 @@ extern int target_flags;\n #define MASK_128BIT_LONG_DOUBLE 0x00080000\t/* long double size is 128bit */\n #define MASK_MIX_SSE_I387\t0x00100000\t/* Mix SSE and i387 instructions */\n #define MASK_64BIT\t\t0x00200000\t/* Produce 64bit code */\n+#define MASK_NO_RED_ZONE\t0x00400000\t/* Do not use red zone */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -250,6 +251,8 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n #define TARGET_MIX_SSE_I387 ((target_flags & MASK_MIX_SSE_I387) != 0)\n #define TARGET_MMX ((target_flags & MASK_MMX) != 0)\n \n+#define TARGET_RED_ZONE (!(target_flags & MASK_NO_RED_ZONE))\n+\n #define TARGET_SWITCHES\t\t\t\t\t\t\t      \\\n { { \"80387\",\t\t\t MASK_80387, N_(\"Use hardware fp\") },\t      \\\n   { \"no-80387\",\t\t\t-MASK_80387, N_(\"Do not use hardware fp\") },  \\\n@@ -338,6 +341,10 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n     N_(\"Generate 64bit x86-64 code\") },\t\t\t\t\t      \\\n   { \"32\",\t\t\t-MASK_64BIT,\t\t\t\t      \\\n     N_(\"Generate 32bit i386 code\") },\t\t\t\t\t      \\\n+  { \"red-zone\",\t\t\t-MASK_NO_RED_ZONE,\t\t\t      \\\n+    N_(\"Use red-zone in the x86-64 code\") },\t\t\t\t      \\\n+  { \"no-red-zone\",\t\tMASK_NO_RED_ZONE,\t\t\t      \\\n+    N_(\"do not use red-zone in the x86-64 code\") },\t\t\t      \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n   { \"\", TARGET_DEFAULT, 0 }}\n \n@@ -3106,6 +3113,10 @@ enum cmodel {\n   CM_SMALL_PIC\n };\n \n+/* Size of the RED_ZONE area.  */\n+#define RED_ZONE_SIZE 128\n+/* Reserved area of the red zone for temporaries.  */\n+#define RED_ZONE_RESERVE 8\n /* Valud of -mcmodel specified by user.  */\n extern const char *ix86_cmodel_string;\n extern enum cmodel ix86_cmodel;"}, {"sha": "6a23023f2795e6d43ae8ead10290e6107c241ec1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 76, "deletions": 3, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8362f4207eaa70dbee88b09a893cd5aa0515ee7f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8362f4207eaa70dbee88b09a893cd5aa0515ee7f", "patch": "@@ -6885,7 +6885,7 @@\n \t(zero_extend:DI\n \t  (minus:SI (match_dup 1)\n \t\t    (match_dup 2))))]\n-  \"ix86_match_ccmode (insn, CCmode)\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\n    && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sub{q}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n@@ -13028,6 +13028,18 @@\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"leave_rex64\"\n+  [(set (reg:DI 7) (reg:DI 6))\n+   (set (reg:DI 6) (mem:DI (pre_dec:DI (reg:DI 7))))]\n+  \"TARGET_64BIT\"\n+  \"leave\"\n+  [(set_attr \"length_immediate\" \"0\")\n+   (set_attr \"length\" \"1\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"ppro_uops\" \"few\")])\n \f\n (define_expand \"ffssi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\") \n@@ -15367,15 +15379,32 @@\n ;; [(set (mem (plus (reg ebp) (const_int -160000))) (const_int 0))]\n ;;\n ;; in proper program order.\n+(define_expand \"pro_epilogue_adjust_stack\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t\t   (plus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t\t\t    (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n+\t      (set (match_operand:SI 3 \"register_operand\" \"+r,r\")\n+\t\t   (match_dup 3))\n+\t      (clobber (reg:CC 17))])]\n+ \"\"\n+ \"\n+{\n+  if (TARGET_64BIT)\n+    {\n+      emit_insn (gen_pro_epilogue_adjust_stack_rex64 (operands[0], operands[1],\n+\t\t\t\t\t\t      operands[2], operands[3]));\n+      DONE;\n+    }\n+}\")\n \n-(define_insn \"pro_epilogue_adjust_stack\"\n+(define_insn \"*pro_epilogue_adjust_stack_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n \t         (match_operand:SI 2 \"immediate_operand\" \"i,i\")))\n    (set (match_operand:SI 3 \"register_operand\" \"+r,r\")\n \t(match_dup 3))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   switch (get_attr_type (insn))\n@@ -15411,6 +15440,50 @@\n \t      (const_string \"lea\")))\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"pro_epilogue_adjust_stack_rex64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n+\t\t (match_operand:DI 2 \"x86_64_immediate_operand\" \"e,e\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"+r,r\")\n+\t(match_dup 3))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_IMOV:\n+      return \\\"mov{q}\\\\t{%1, %0|%0, %1}\\\";\n+\n+    case TYPE_ALU:\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t          && INTVAL (operands[2]) != -128)))\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n+\t}\n+      return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n+\n+    case TYPE_LEA:\n+      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      return \\\"lea{q}\\\\t{%a2, %0|%0, %a2}\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set (attr \"type\")\n+\t(cond [(eq_attr \"alternative\" \"0\")\n+\t\t (const_string \"alu\")\n+\t       (match_operand:DI 2 \"const0_operand\" \"\")\n+\t\t (const_string \"imov\")\n+\t      ]\n+\t      (const_string \"lea\")))\n+   (set_attr \"mode\" \"DI\")])\n+\n+\n ;; Placeholder for the conditional moves.  This one is split eighter to SSE\n ;; based moves emulation or to usual cmove sequence.  Little bit unfortunate\n ;; fact is that compares supported by the cmp??ss instructions are exactly"}]}