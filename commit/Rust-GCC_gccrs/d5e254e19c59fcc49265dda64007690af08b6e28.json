{"sha": "d5e254e19c59fcc49265dda64007690af08b6e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlMjU0ZTE5YzU5ZmNjNDkyNjVkZGE2NDAwNzY5MGFmMDhiNmUyOA==", "commit": {"author": {"name": "Ilya Enkovich", "email": "ilya.enkovich@intel.com", "date": "2014-11-05T12:42:03Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2014-11-05T12:42:03Z"}, "message": "ipa-chkp.c: New.\n\ngcc/\n\n2014-11-05  Ilya Enkovich  <ilya.enkovich@intel.com>\n\n\t* ipa-chkp.c: New.\n\t* ipa-chkp.h: New.\n\t* tree-chkp.c: New.\n\t* tree-chkp.h: New.\n\t* tree-chkp-opt.c: New.\n\t* rtl-chkp.c: New.\n\t* rtl-chkp.h: New.\n\t* Makefile.in (OBJS): Add ipa-chkp.o, rtl-chkp.o, tree-chkp.o\n\ttree-chkp-opt.o.\n\t(GTFILES): Add tree-chkp.c.\n\t* mode-classes.def (MODE_POINTER_BOUNDS): New.\n\t* tree.def (POINTER_BOUNDS_TYPE): New.\n\t* genmodes.c (complete_mode): Support MODE_POINTER_BOUNDS.\n\t(POINTER_BOUNDS_MODE): New.\n\t(make_pointer_bounds_mode): New.\n\t* machmode.h (POINTER_BOUNDS_MODE_P): New.\n\t* stor-layout.c (int_mode_for_mode): Support MODE_POINTER_BOUNDS.\n\t(layout_type): Support POINTER_BOUNDS_TYPE.\n\t* tree-pretty-print.c (dump_generic_node): Support POINTER_BOUNDS_TYPE.\n\t* tree-core.h (tree_index): Add TI_POINTER_BOUNDS_TYPE.\n\t* tree.c (build_int_cst_wide): Support POINTER_BOUNDS_TYPE.\n\t(type_contains_placeholder_1): Likewise.\n\t(build_common_tree_nodes): Initialize\n\tpointer_bounds_type_node.\n\t* tree.h (POINTER_BOUNDS_TYPE_P): New.\n\t(pointer_bounds_type_node): New.\n\t(POINTER_BOUNDS_P): New.\n\t(BOUNDED_TYPE_P): New.\n\t(BOUNDED_P): New.\n\t(CALL_WITH_BOUNDS_P): New.\n\t* gimple.h (gf_mask): Add GF_CALL_WITH_BOUNDS.\n\t(gimple_call_with_bounds_p): New.\n\t(gimple_call_set_with_bounds): New.\n\t(gimple_return_retbnd): New.\n\t(gimple_return_set_retbnd): New\n\t* gimple.c (gimple_build_return): Increase number of ops\n\tfor return statement.\n\t(gimple_build_call_from_tree): Propagate CALL_WITH_BOUNDS_P\n\tflag.\n\t* gimple-pretty-print.c (dump_gimple_return): Print second op.\n\t* rtl.h (CALL_EXPR_WITH_BOUNDS_P): New.\n\t* gimplify.c (gimplify_init_constructor): Avoid infinite\n\tloop during gimplification of bounds initializer.\n\t* calls.c: Include tree-chkp.h, rtl-chkp.h, bitmap.h.\n\t(special_function_p): Use original decl name when analyzing\n\tinstrumentation clone.\n\t(arg_data): Add fields special_slot, pointer_arg and\n\tpointer_offset.\n\t(store_bounds): New.\n\t(emit_call_1): Propagate instrumentation flag for CALL.\n\t(initialize_argument_information): Compute pointer_arg,\n\tpointer_offset and special_slot for pointer bounds arguments.\n\t(finalize_must_preallocate): Preallocate when storing bounds\n\tin bounds table.\n\t(compute_argument_addresses): Skip pointer bounds.\n\t(expand_call): Store bounds into tables separately.  Return\n\tresult joined with resulting bounds.\n\t* cfgexpand.c: Include tree-chkp.h, rtl-chkp.h.\n\t(expand_call_stmt): Propagate bounds flag for CALL_EXPR.\n\t(expand_return): Add returned bounds arg.  Handle returned bounds.\n\t(expand_gimple_stmt_1): Adjust to new expand_return signature.\n\t(gimple_expand_cfg): Reset rtx bounds map.\n\t* expr.c: Include tree-chkp.h, rtl-chkp.h.\n\t(expand_assignment): Handle returned bounds.\n\t(store_expr_with_bounds): New.  Replaces store_expr with new bounds\n\ttarget argument.  Handle bounds returned by calls.\n\t(store_expr): Now wraps store_expr_with_bounds.\n\t* expr.h (store_expr_with_bounds): New.\n\t* function.c: Include tree-chkp.h, rtl-chkp.h.\n\t(bounds_parm_data): New.\n\t(use_register_for_decl): Do not registerize decls used for bounds\n\tstores and loads.\n\t(assign_parms_augmented_arg_list): Add bounds of the result\n\tstructure pointer as the second argument.\n\t(assign_parm_find_entry_rtl): Mark bounds are never passed on\n\tthe stack.\n\t(assign_parm_is_stack_parm): Likewise.\n\t(assign_parm_load_bounds): New.\n\t(assign_bounds): New.\n\t(assign_parms): Load bounds and determine a location for\n\treturned bounds.\n\t(diddle_return_value_1): New.\n\t(diddle_return_value): Handle returned bounds.\n\t* function.h (rtl_data): Add field for returned bounds.\n\t* varasm.c: Include tree-chkp.h.\n\t(output_constant): Support POINTER_BOUNDS_TYPE.\n\t(output_constant_pool_2): Support MODE_POINTER_BOUNDS.\n\t(ultimate_transparent_alias_target): Move up.\n\t(make_decl_rtl): For instrumented function use\n\tname of the original decl.\n\t(assemble_start_function): Mark function as global\n\tin case it is instrumentation clone of the global\n\tfunction.\n\t(do_assemble_alias): Follow transparent alias chain\n\tfor identifier.  Check if original alias is public.\n\t(maybe_assemble_visibility): Use visibility of the\n\toriginal function for instrumented version.\n\t(default_unique_section): Likewise.\n\t* emit-rtl.c (immed_double_const): Support MODE_POINTER_BOUNDS.\n\t(init_emit_once): Build pointer bounds zero constants.\n\t* explow.c (trunc_int_for_mode): Support MODE_POINTER_BOUNDS.\n\t* target.def (builtin_chkp_function): New.\n\t(chkp_bound_type): New.\n\t(chkp_bound_mode): New.\n\t(chkp_make_bounds_constant): New.\n\t(chkp_initialize_bounds): New.\n\t(load_bounds_for_arg): New.\n\t(store_bounds_for_arg): New.\n\t(load_returned_bounds): New.\n\t(store_returned_bounds): New.\n\t(chkp_function_value_bounds): New.\n\t(setup_incoming_vararg_bounds): New.\n\t(function_arg): Update hook description with new possible return\n\tvalue CONST_INT.\n\t* targhooks.h (default_load_bounds_for_arg): New.\n\t(default_store_bounds_for_arg): New.\n\t(default_load_returned_bounds): New.\n\t(default_store_returned_bounds): New.\n\t(default_chkp_bound_type): New.\n\t(default_chkp_bound_mode): New.\n\t(default_builtin_chkp_function): New.\n\t(default_chkp_function_value_bounds): New.\n\t(default_chkp_make_bounds_constant): New.\n\t(default_chkp_initialize_bounds): New.\n\t(default_setup_incoming_vararg_bounds): New.\n\t* targhooks.c (default_load_bounds_for_arg): New.\n\t(default_store_bounds_for_arg): New.\n\t(default_load_returned_bounds): New.\n\t(default_store_returned_bounds): New.\n\t(default_chkp_bound_type): New.\n\t(default_chkp_bound_mode); New.\n\t(default_builtin_chkp_function): New.\n\t(default_chkp_function_value_bounds): New.\n\t(default_chkp_make_bounds_constant): New.\n\t(default_chkp_initialize_bounds): New.\n\t(default_setup_incoming_vararg_bounds): New.\n\t* builtin-types.def (BT_BND): New.\n\t(BT_FN_PTR_CONST_PTR): New.\n\t(BT_FN_CONST_PTR_CONST_PTR): New.\n\t(BT_FN_BND_CONST_PTR): New.\n\t(BT_FN_CONST_PTR_BND): New.\n\t(BT_FN_PTR_CONST_PTR_SIZE): New.\n\t(BT_FN_PTR_CONST_PTR_CONST_PTR): New.\n\t(BT_FN_VOID_PTRPTR_CONST_PTR): New.\n\t(BT_FN_VOID_CONST_PTR_SIZE): New.\n\t(BT_FN_VOID_PTR_BND): New.\n\t(BT_FN_CONST_PTR_CONST_PTR_CONST_PTR): New.\n\t(BT_FN_BND_CONST_PTR_SIZE): New.\n\t(BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE): New.\n\t(BT_FN_VOID_CONST_PTR_BND_CONST_PTR): New.\n\t* chkp-builtins.def: New.\n\t* builtins.def: include chkp-builtins.def.\n\t(DEF_CHKP_BUILTIN): New.\n\t* builtins.c: Include tree-chkp.h and rtl-chkp.h.\n\t(expand_builtin): Support BUILT_IN_CHKP_INIT_PTR_BOUNDS,\n\tBUILT_IN_CHKP_NULL_PTR_BOUNDS, BUILT_IN_CHKP_COPY_PTR_BOUNDS,\n\tBUILT_IN_CHKP_CHECK_PTR_LBOUNDS, BUILT_IN_CHKP_CHECK_PTR_UBOUNDS,\n\tBUILT_IN_CHKP_CHECK_PTR_BOUNDS, BUILT_IN_CHKP_SET_PTR_BOUNDS,\n\tBUILT_IN_CHKP_NARROW_PTR_BOUNDS, BUILT_IN_CHKP_STORE_PTR_BOUNDS,\n\tBUILT_IN_CHKP_GET_PTR_LBOUND, BUILT_IN_CHKP_GET_PTR_UBOUND,\n\tBUILT_IN_CHKP_BNDMK, BUILT_IN_CHKP_BNDSTX, BUILT_IN_CHKP_BNDCL,\n\tBUILT_IN_CHKP_BNDCU, BUILT_IN_CHKP_BNDLDX, BUILT_IN_CHKP_BNDRET,\n\tBUILT_IN_CHKP_INTERSECT, BUILT_IN_CHKP_NARROW,\n\tBUILT_IN_CHKP_EXTRACT_LOWER, BUILT_IN_CHKP_EXTRACT_UPPER.\n\t(std_expand_builtin_va_start): Init bounds for va_list.\n\t* cppbuiltin.c (define_builtin_macros_for_compilation_flags): Add\n\t__CHKP__ macro when Pointer Bounds Checker is on.\n\t* params.def (PARAM_CHKP_MAX_CTOR_SIZE): New.\n\t* passes.def (pass_ipa_chkp_versioning): New.\n\t(pass_early_local_passes): Renamed to pass_build_ssa_passes.\n\t(pass_fixup_cfg): Moved to pass_chkp_instrumentation_passes.\n\t(pass_chkp_instrumentation_passes): New.\n\t(pass_ipa_chkp_produce_thunks): New.\n\t(pass_local_optimization_passes): New.\n\t(pass_chkp_opt): New.\n\t* tree-pass.h (make_pass_ipa_chkp_versioning): New.\n\t(make_pass_ipa_chkp_produce_thunks): New.\n\t(make_pass_chkp): New.\n\t(make_pass_chkp_opt): New.\n\t(make_pass_early_local_passes): Renamed to ...\n\t(make_pass_build_ssa_passes): This.\n\t(make_pass_chkp_instrumentation_passes): New.\n\t(make_pass_local_optimization_passes): New.\n\t* passes.c (pass_manager::execute_early_local_passes): Execute\n\tearly passes in three steps.\n\t(execute_all_early_local_passes): Renamed to ...\n\t(execute_build_ssa_passes): This.\n\t(pass_data_early_local_passes): Renamed to ...\n\t(pass_data_build_ssa_passes): This.\n\t(pass_early_local_passes): Renamed to ...\n\t(pass_build_ssa_passes): This.\n\t(pass_data_chkp_instrumentation_passes): New.\n\t(pass_chkp_instrumentation_passes): New.\n\t(pass_data_local_optimization_passes): New.\n\t(pass_local_optimization_passes): New.\n\t(make_pass_early_local_passes): Renamed to ...\n\t(make_pass_build_ssa_passes): This.\n\t(make_pass_chkp_instrumentation_passes): New.\n\t(make_pass_local_optimization_passes): New.\n\t* c-family/c.opt (fcheck-pointer-bounds): New.\n\t(fchkp-check-incomplete-type): New.\n\t(fchkp-zero-input-bounds-for-main): New.\n\t(fchkp-first-field-has-own-bounds): New.\n\t(fchkp-narrow-bounds): New.\n\t(fchkp-narrow-to-innermost-array): New.\n\t(fchkp-optimize): New.\n\t(fchkp-use-fast-string-functions): New.\n\t(fchkp-use-nochk-string-functions): New.\n\t(fchkp-use-static-bounds): New.\n\t(fchkp-use-static-const-bounds): New.\n\t(fchkp-treat-zero-dynamic-size-as-infinite): New.\n\t(fchkp-check-read): New.\n\t(fchkp-check-write): New.\n\t(fchkp-store-bounds): New.\n\t(fchkp-instrument-calls): New.\n\t(fchkp-instrument-marked-only): New.\n\t(Wchkp): New.\n\t* c-family/c-common.c (handle_bnd_variable_size_attribute): New.\n\t(handle_bnd_legacy): New.\n\t(handle_bnd_instrument): New.\n\t(c_common_attribute_table): Add bnd_variable_size, bnd_legacy\n\tand bnd_instrument.  Fix documentation.\n\t(c_common_format_attribute_table): Likewsie.\n\t* toplev.c: include tree-chkp.h.\n\t(process_options): Check Pointer Bounds Checker is supported.\n\t(compile_file): Add chkp_finish_file call.\n\t* ipa-cp.c (initialize_node_lattices): Use cgraph_local_p\n\tto handle instrumentation clones properly.\n\t(propagate_constants_accross_call): Do not propagate\n\tthrough instrumentation thunks.\n\t* ipa-pure-const.c (propagate_pure_const): Support\n\tIPA_REF_CHKP.\n\t* ipa-inline.c (early_inliner): Check edge has summary allocated.\n\t* ipa-split.c: Include tree-chkp.h.\n\t(find_retbnd): New.\n\t(split_part_set_ssa_name_p): New.\n\t(consider_split): Do not split retbnd and retval\n\tproducers.\n\t(insert_bndret_call_after): new.\n\t(split_function): Propagate Pointer Bounds Checker\n\tinstrumentation marks and handle returned bounds.\n\t* tree-ssa-sccvn.h (vn_reference_op_struct): Transform opcode\n\tinto bit field and add with_bounds field.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_call): Set\n\twith_bounds field for instrumented calls.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Restore\n\tCALL_WITH_BOUNDS_P flag for calls.\n\t* tree-ssa-ccp.c: Include tree-chkp.h.\n\t(insert_clobber_before_stack_restore): Handle\n\tBUILT_IN_CHKP_BNDRET calls.\n\t* tree-ssa-dce.c: Include tree-chkp.h.\n\t(propagate_necessity): For free call fed by alloc check\n\tbounds are also provided by the same alloc.\n\t(eliminate_unnecessary_stmts): Handle BUILT_IN_CHKP_BNDRET\n\tused by free calls.\n\t* tree-inline.c: Include tree-chkp.h.\n\t(declare_return_variable): Add arg holding\n\treturned bounds slot.  Create and initialize returned bounds var.\n\t(remap_gimple_stmt): Handle returned bounds.\n\tReturn sequence of statements instead of a single statement.\n\t(insert_init_stmt): Add declaration.\n\t(remap_gimple_seq): Adjust to new remap_gimple_stmt signature.\n\t(copy_bb): Adjust to changed return type of remap_gimple_stmt.\n\tProperly handle bounds in va_arg_pack and va_arg_pack_len.\n\t(expand_call_inline): Handle returned bounds.  Add bounds copy\n\tfor generated mem to mem assignments.\n\t* tree-inline.h (copy_body_data): Add fields retbnd and\n\tassign_stmts.\n\t* value-prof.c: Include tree-chkp.h.\n\t(gimple_ic): Support returned bounds.\n\t* ipa.c (cgraph_build_static_cdtor_1): Support contructors\n\twith \"chkp ctor\" and \"bnd_legacy\" attributes.\n\t(symtab_remove_unreachable_nodes): Keep initial values for\n\tpointer bounds to be used for checks eliminations.\n\t(process_references): Handle IPA_REF_CHKP.\n\t(walk_polymorphic_call_targets): Likewise.\n\t* ipa-visibility.c (cgraph_externally_visible_p): Mark\n\tinstrumented 'main' as externally visible.\n\t(function_and_variable_visibility): Filter instrumentation\n\tthunks.\n\t* cgraph.h (cgraph_thunk_info): Add add_pointer_bounds_args\n\tfield.\n\t(cgraph_node): Add instrumented_version, orig_decl and\n\tinstrumentation_clone fields.\n\t(symtab_node::get_alias_target): Allow IPA_REF_CHKP reference.\n\t(varpool_node): Add need_bounds_init field.\n\t(cgraph_local_p): New.\n\t* cgraph.c: Include tree-chkp.h.\n\t(cgraph_node::remove): Fix instrumented_version\n\tof the referenced node if any.\n\t(cgraph_node::dump): Dump instrumentation_clone and\n\tinstrumented_version fields.\n\t(cgraph_node::verify_node): Check correctness of IPA_REF_CHKP\n\treferences and instrumentation thunks.\n\t(cgraph_can_remove_if_no_direct_calls_and_refs_p): Keep\n\tall not instrumented instrumentation clones alive.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Support\n\treturned bounds.\n\t* cgraphbuild.c (rebuild_cgraph_edges): Rebuild IPA_REF_CHKP\n\treference.\n\t(cgraph_rebuild_references): Likewise.\n\t* cgraphunit.c: Include tree-chkp.h.\n\t(assemble_thunks_and_aliases): Skip thunks calling instrumneted\n\tfunction version.\n\t(varpool_finalize_decl): Register statically initialized decls\n\tin Pointer Bounds Checker.\n\t(walk_polymorphic_call_targets): Do not mark generated call to\n\t__builtin_unreachable as with_bounds.\n\t(output_weakrefs): If there are both instrumented and original\n\tversions, output only one of them.\n\t(cgraph_node::expand_thunk): Set with_bounds flag\n\tfor created call statement.\n\t* ipa-ref.h (ipa_ref_use): Add IPA_REF_CHKP.\n\t(ipa_ref): increase size of use field.\n\t* symtab.c (ipa_ref_use_name): Add element for IPA_REF_CHKP.\n\t* varpool.c (dump_varpool_node): Dump need_bounds_init field.\n\t(ctor_for_folding): Do not fold constant bounds vars.\n\t* lto-streamer.h (LTO_minor_version): Change minor version from\n\t0 to 1.\n\t* lto-cgraph.c (compute_ltrans_boundary): Keep initial values for\n\tpointer bounds.\n\t(lto_output_node): Output instrumentation_clone,\n\tthunk.add_pointer_bounds_args and orig_decl field.\n\t(lto_output_ref): Adjust to new ipa_ref::use field size.\n\t(input_overwrite_node): Read instrumentation_clone field.\n\t(input_node): Read thunk.add_pointer_bounds_args and orig_decl\n\tfields.\n\t(input_ref): Adjust to new ipa_ref::use field size.\n\t(input_cgraph_1): Compute instrumented_version fields and restore\n\tIDENTIFIER_TRANSPARENT_ALIAS chains.\n\t(lto_output_varpool_node): Output\n\tneed_bounds_init value.\n\t(input_varpool_node): Read need_bounds_init value.\n\t* lto-partition.c (add_symbol_to_partition_1): Keep original\n\tand instrumented versions together.\n\t(privatize_symbol_name): Restore transparent alias chain if required.\n\t(add_references_to_partition): Add references to pointer bounds vars.\n\t* dbxout.c (dbxout_type): Ignore POINTER_BOUNDS_TYPE.\n\t* dwarf2out.c (gen_subprogram_die): Ignore bound args.\n\t(gen_type_die_with_usage): Skip pointer bounds.\n\t(dwarf2out_global_decl): Likewise.\n\t(is_base_type): Support POINTER_BOUNDS_TYPE.\n\t(gen_formal_types_die): Skip pointer bounds.\n\t(gen_decl_die): Likewise.\n\t* var-tracking.c (vt_add_function_parameters): Skip\n\tbounds parameters.\n\t* ipa-icf.c (sem_function::merge): Do not merge when instrumentation\n\tthunk still exists.\n\t(sem_variable::merge): Reset need_bounds_init flag.\n\t* doc/extend.texi: Document Pointer Bounds Checker built-in functions\n\tand attributes.\n\t* doc/tm.texi.in (TARGET_LOAD_BOUNDS_FOR_ARG): New.\n\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n\t(TARGET_LOAD_RETURNED_BOUNDS): New.\n\t(TARGET_STORE_RETURNED_BOUNDS): New.\n\t(TARGET_CHKP_FUNCTION_VALUE_BOUNDS): New.\n\t(TARGET_SETUP_INCOMING_VARARG_BOUNDS): New.\n\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n\t(TARGET_CHKP_BOUND_TYPE): New.\n\t(TARGET_CHKP_BOUND_MODE): New.\n\t(TARGET_CHKP_MAKE_BOUNDS_CONSTANT): New.\n\t(TARGET_CHKP_INITIALIZE_BOUNDS): New.\n\t* doc/tm.texi: Regenerated.\n\t* doc/rtl.texi (MODE_POINTER_BOUNDS): New.\n\t(BND32mode): New.\n\t(BND64mode): New.\n\t* doc/invoke.texi (-mmpx): New.\n\t(-mno-mpx): New.\n\t(chkp-max-ctor-size): New.\n\t* config/i386/constraints.md (w): New.\n\t(Ti): New.\n\t(Tb): New.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n\t* config/i386/i386-modes.def (BND32): New.\n\t(BND64): New.\n\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n\t* config/i386/i386.c: Include tree-chkp.h, rtl-chkp.h, tree-iterator.h.\n\t(regclass_map): Add bound registers.\n\t(dbx_register_map): Likewise.\n\t(dbx64_register_map): Likewise.\n\t(svr4_dbx_register_map): Likewise.\n\t(isa_opts): Add -mmpx.\n\t(PTA_MPX): New.\n\t(ix86_option_override_internal): Support MPX ISA.\n\t(ix86_conditional_register_usage): Support bound registers.\n\t(ix86_code_end): Add MPX bnd prefix.\n\t(output_set_got): Likewise.\n\t(print_reg): Avoid prefixes for bound registers.\n\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n\t(ix86_print_operand_punct_valid_p): Likewise.\n\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n\tUNSPEC_BNDLDX_ADDR.\n\t(ix86_output_call_insn): Add MPX bnd prefix to branch instructions.\n\t(ix86_class_likely_spilled_p): Add bound regs support.\n\t(ix86_hard_regno_mode_ok): Likewise.\n\t(x86_order_regs_for_local_alloc): Likewise.\n\t(ix86_bnd_prefixed_insn_p): New.\n\t(ix86_builtins): Add\n\tIX86_BUILTIN_BNDMK, IX86_BUILTIN_BNDSTX,\n\tIX86_BUILTIN_BNDLDX, IX86_BUILTIN_BNDCL,\n\tIX86_BUILTIN_BNDCU, IX86_BUILTIN_BNDRET,\n\tIX86_BUILTIN_BNDNARROW, IX86_BUILTIN_BNDINT,\n\tIX86_BUILTIN_SIZEOF, IX86_BUILTIN_BNDLOWER,\n\tIX86_BUILTIN_BNDUPPER.\n\t(builtin_isa): Add leaf_p and nothrow_p fields.\n\t(def_builtin): Initialize leaf_p and nothrow_p.\n\t(ix86_add_new_builtins): Handle leaf_p and nothrow_p\n\tflags.\n\t(bdesc_mpx): New.\n\t(bdesc_mpx_const): New.\n\t(ix86_init_mpx_builtins): New.\n\t(ix86_init_builtins): Call ix86_init_mpx_builtins.\n\t(ix86_emit_cmove): New.\n\t(ix86_emit_move_max): New.\n\t(ix86_expand_builtin): Expand IX86_BUILTIN_BNDMK,\n\tIX86_BUILTIN_BNDSTX, IX86_BUILTIN_BNDLDX,\n\tIX86_BUILTIN_BNDCL, IX86_BUILTIN_BNDCU,\n\tIX86_BUILTIN_BNDRET, IX86_BUILTIN_BNDNARROW,\n\tIX86_BUILTIN_BNDINT, IX86_BUILTIN_SIZEOF,\n\tIX86_BUILTIN_BNDLOWER, IX86_BUILTIN_BNDUPPER.\n\t(ix86_function_value_bounds): New.\n\t(ix86_builtin_mpx_function): New.\n\t(ix86_get_arg_address_for_bt): New.\n\t(ix86_load_bounds): New.\n\t(ix86_store_bounds): New.\n\t(ix86_load_returned_bounds): New.\n\t(ix86_store_returned_bounds): New.\n\t(ix86_mpx_bound_mode): New.\n\t(ix86_make_bounds_constant): New.\n\t(ix86_initialize_bounds):\n\t(TARGET_LOAD_BOUNDS_FOR_ARG): New.\n\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n\t(TARGET_LOAD_RETURNED_BOUNDS): New.\n\t(TARGET_STORE_RETURNED_BOUNDS): New.\n\t(TARGET_CHKP_BOUND_MODE): New.\n\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n\t(TARGET_CHKP_FUNCTION_VALUE_BOUNDS): New.\n\t(TARGET_CHKP_MAKE_BOUNDS_CONSTANT): New.\n\t(TARGET_CHKP_INITIALIZE_BOUNDS): New.\n\t(ix86_option_override_internal): Do not\n\tsupport x32 with MPX.\n\t(init_cumulative_args): Init stdarg, bnd_regno, bnds_in_bt\n\tand force_bnd_pass.\n\t(function_arg_advance_32): Return number of used integer\n\tregisters.\n\t(function_arg_advance_64): Likewise.\n\t(function_arg_advance_ms_64): Likewise.\n\t(ix86_function_arg_advance): Handle pointer bounds.\n\t(ix86_function_arg): Likewise.\n\t(ix86_function_value_regno_p): Mark fisrt bounds registers as\n\tpossible function value.\n\t(ix86_function_value_1): Handle pointer bounds type/mode\n\t(ix86_return_in_memory): Likewise.\n\t(ix86_print_operand): Analyse insn to decide abounf \"bnd\" prefix.\n\t(ix86_expand_call): Generate returned bounds.\n\t(ix86_setup_incoming_vararg_bounds): New.\n\t(ix86_va_start): Initialize bounds for pointers in va_list.\n\t(TARGET_SETUP_INCOMING_VARARG_BOUNDS): New.\n\t* config/i386/i386.h (TARGET_MPX): New.\n\t(TARGET_MPX_P): New.\n\t(FIRST_PSEUDO_REGISTER): Fix to new value.\n\t(FIXED_REGISTERS): Add bound registers.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(REG_ALLOC_ORDER): Likewise.\n\t(HARD_REGNO_NREGS): Likewise.\n\t(VALID_BND_REG_MODE): New.\n\t(FIRST_BND_REG): New.\n\t(LAST_BND_REG): New.\n\t(reg_class): Add BND_REGS.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(BND_REGNO_P): New.\n\t(ANY_BND_REG_P): New.\n\t(BNDmode): New.\n\t(HI_REGISTER_NAMES): Add bound registers.\n\t(ix86_args): Add bnd_regno, bnds_in_bt,\tforce_bnd_pass and\n\tstdarg fields.\n\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n\t(UNSPEC_BNDMK_ADDR): New.\n\t(UNSPEC_BNDSTX): New.\n\t(UNSPEC_BNDLDX): New.\n\t(UNSPEC_BNDLDX_ADDR): New.\n\t(UNSPEC_BNDCL): New.\n\t(UNSPEC_BNDCU): New.\n\t(UNSPEC_BNDCN): New.\n\t(UNSPEC_MPX_FENCE): New.\n\t(UNSPEC_SIZEOF): New.\n\t(BND0_REG): New.\n\t(BND1_REG): New.\n\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(length_immediate): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(prefix_rep): Check for bnd prefix.\n\t(prefix_0f): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(length_nobnd): New.\n\t(length): Use length_nobnd when specified.\n\t(memory): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(BND): New.\n\t(bnd_ptr): New.\n\t(BNDCHECK): New.\n\t(bndcheck): New.\n\t(*jcc_1): Add MPX bnd prefix.\n\t(*jcc_2): Likewise.\n\t(jump): Likewise.\n\t(*indirect_jump): Likewise.\n\t(*tablejump_1): Likewise.\n\t(simple_return_internal): Likewise.\n\t(simple_return_internal_long): Likewise.\n\t(simple_return_pop_internal): Likewise.\n\t(simple_return_indirect_internal): Likewise.\n\t(<mode>_mk): New.\n\t(*<mode>_mk): New.\n\t(mov<mode>): New.\n\t(*mov<mode>_internal_mpx): New.\n\t(<mode>_<bndcheck>): New.\n\t(*<mode>_<bndcheck>): New.\n\t(<mode>_ldx): New.\n\t(*<mode>_ldx): New.\n\t(<mode>_stx): New.\n\t(*<mode>_stx): New.\n\tmove_size_reloc_<mode>): New.\n\t* config/i386/predicates.md (address_mpx_no_base_operand): New.\n\t(address_mpx_no_index_operand): New.\n\t(bnd_mem_operator): New.\n\t(symbol_operand): New.\n\t(x86_64_immediate_size_operand): New.\n\t* config/i386/i386.opt (mmpx): New.\n\t* config/i386/i386-builtin-types.def (BND): New.\n\t(ULONG): New.\n\t(BND_FTYPE_PCVOID_ULONG): New.\n\t(VOID_FTYPE_BND_PCVOID): New.\n\t(VOID_FTYPE_PCVOID_PCVOID_BND): New.\n\t(BND_FTYPE_PCVOID_PCVOID): New.\n\t(BND_FTYPE_PCVOID): New.\n\t(BND_FTYPE_BND_BND): New.\n\t(PVOID_FTYPE_PVOID_PVOID_ULONG): New.\n\t(PVOID_FTYPE_PCVOID_BND_ULONG): New.\n\t(ULONG_FTYPE_VOID): New.\n\t(PVOID_FTYPE_BND): New.\n\ngcc/testsuite/\n\n2014-11-05  Ilya Enkovich  <ilya.enkovich@intel.com>\n\n\t* gcc.target/i386/chkp-builtins-1.c: New.\n\t* gcc.target/i386/chkp-builtins-2.c: New.\n\t* gcc.target/i386/chkp-builtins-3.c: New.\n\t* gcc.target/i386/chkp-builtins-4.c: New.\n\t* gcc.target/i386/chkp-remove-bndint-1.c: New.\n\t* gcc.target/i386/chkp-remove-bndint-2.c: New.\n\t* gcc.target/i386/chkp-const-check-1.c: New.\n\t* gcc.target/i386/chkp-const-check-2.c: New.\n\t* gcc.target/i386/chkp-lifetime-1.c: New.\n\t* gcc.dg/pr37858.c: Replace early_local_cleanups pass name\n\twith build_ssa_passes.\n\nFrom-SVN: r217125", "tree": {"sha": "df7b4d3afe0e30fdad56e3feeb2db22600eaaec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df7b4d3afe0e30fdad56e3feeb2db22600eaaec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e254e19c59fcc49265dda64007690af08b6e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e254e19c59fcc49265dda64007690af08b6e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e254e19c59fcc49265dda64007690af08b6e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e254e19c59fcc49265dda64007690af08b6e28/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "433e4164339f18d0b8798968444a56b681b5232c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433e4164339f18d0b8798968444a56b681b5232c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/433e4164339f18d0b8798968444a56b681b5232c"}], "stats": {"total": 11558, "additions": 11266, "deletions": 292}, "files": [{"sha": "e6351f49a7681cc3c341477159127c6bc8c68b08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 541, "deletions": 0, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1,3 +1,544 @@\n+2014-11-05  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\n+\t* ipa-chkp.c: New.\n+\t* ipa-chkp.h: New.\n+\t* tree-chkp.c: New.\n+\t* tree-chkp.h: New.\n+\t* tree-chkp-opt.c: New.\n+\t* rtl-chkp.c: New.\n+\t* rtl-chkp.h: New.\n+\t* Makefile.in (OBJS): Add ipa-chkp.o, rtl-chkp.o, tree-chkp.o\n+\ttree-chkp-opt.o.\n+\t(GTFILES): Add tree-chkp.c.\n+\t* mode-classes.def (MODE_POINTER_BOUNDS): New.\n+\t* tree.def (POINTER_BOUNDS_TYPE): New.\n+\t* genmodes.c (complete_mode): Support MODE_POINTER_BOUNDS.\n+\t(POINTER_BOUNDS_MODE): New.\n+\t(make_pointer_bounds_mode): New.\n+\t* machmode.h (POINTER_BOUNDS_MODE_P): New.\n+\t* stor-layout.c (int_mode_for_mode): Support MODE_POINTER_BOUNDS.\n+\t(layout_type): Support POINTER_BOUNDS_TYPE.\n+\t* tree-pretty-print.c (dump_generic_node): Support POINTER_BOUNDS_TYPE.\n+\t* tree-core.h (tree_index): Add TI_POINTER_BOUNDS_TYPE.\n+\t* tree.c (build_int_cst_wide): Support POINTER_BOUNDS_TYPE.\n+\t(type_contains_placeholder_1): Likewise.\n+\t(build_common_tree_nodes): Initialize\n+\tpointer_bounds_type_node.\n+\t* tree.h (POINTER_BOUNDS_TYPE_P): New.\n+\t(pointer_bounds_type_node): New.\n+\t(POINTER_BOUNDS_P): New.\n+\t(BOUNDED_TYPE_P): New.\n+\t(BOUNDED_P): New.\n+\t(CALL_WITH_BOUNDS_P): New.\n+\t* gimple.h (gf_mask): Add GF_CALL_WITH_BOUNDS.\n+\t(gimple_call_with_bounds_p): New.\n+\t(gimple_call_set_with_bounds): New.\n+\t(gimple_return_retbnd): New.\n+\t(gimple_return_set_retbnd): New\n+\t* gimple.c (gimple_build_return): Increase number of ops\n+\tfor return statement.\n+\t(gimple_build_call_from_tree): Propagate CALL_WITH_BOUNDS_P\n+\tflag.\n+\t* gimple-pretty-print.c (dump_gimple_return): Print second op.\n+\t* rtl.h (CALL_EXPR_WITH_BOUNDS_P): New.\n+\t* gimplify.c (gimplify_init_constructor): Avoid infinite\n+\tloop during gimplification of bounds initializer.\n+\t* calls.c: Include tree-chkp.h, rtl-chkp.h, bitmap.h.\n+\t(special_function_p): Use original decl name when analyzing\n+\tinstrumentation clone.\n+\t(arg_data): Add fields special_slot, pointer_arg and\n+\tpointer_offset.\n+\t(store_bounds): New.\n+\t(emit_call_1): Propagate instrumentation flag for CALL.\n+\t(initialize_argument_information): Compute pointer_arg,\n+\tpointer_offset and special_slot for pointer bounds arguments.\n+\t(finalize_must_preallocate): Preallocate when storing bounds\n+\tin bounds table.\n+\t(compute_argument_addresses): Skip pointer bounds.\n+\t(expand_call): Store bounds into tables separately.  Return\n+\tresult joined with resulting bounds.\n+\t* cfgexpand.c: Include tree-chkp.h, rtl-chkp.h.\n+\t(expand_call_stmt): Propagate bounds flag for CALL_EXPR.\n+\t(expand_return): Add returned bounds arg.  Handle returned bounds.\n+\t(expand_gimple_stmt_1): Adjust to new expand_return signature.\n+\t(gimple_expand_cfg): Reset rtx bounds map.\n+\t* expr.c: Include tree-chkp.h, rtl-chkp.h.\n+\t(expand_assignment): Handle returned bounds.\n+\t(store_expr_with_bounds): New.  Replaces store_expr with new bounds\n+\ttarget argument.  Handle bounds returned by calls.\n+\t(store_expr): Now wraps store_expr_with_bounds.\n+\t* expr.h (store_expr_with_bounds): New.\n+\t* function.c: Include tree-chkp.h, rtl-chkp.h.\n+\t(bounds_parm_data): New.\n+\t(use_register_for_decl): Do not registerize decls used for bounds\n+\tstores and loads.\n+\t(assign_parms_augmented_arg_list): Add bounds of the result\n+\tstructure pointer as the second argument.\n+\t(assign_parm_find_entry_rtl): Mark bounds are never passed on\n+\tthe stack.\n+\t(assign_parm_is_stack_parm): Likewise.\n+\t(assign_parm_load_bounds): New.\n+\t(assign_bounds): New.\n+\t(assign_parms): Load bounds and determine a location for\n+\treturned bounds.\n+\t(diddle_return_value_1): New.\n+\t(diddle_return_value): Handle returned bounds.\n+\t* function.h (rtl_data): Add field for returned bounds.\n+\t* varasm.c: Include tree-chkp.h.\n+\t(output_constant): Support POINTER_BOUNDS_TYPE.\n+\t(output_constant_pool_2): Support MODE_POINTER_BOUNDS.\n+\t(ultimate_transparent_alias_target): Move up.\n+\t(make_decl_rtl): For instrumented function use\n+\tname of the original decl.\n+\t(assemble_start_function): Mark function as global\n+\tin case it is instrumentation clone of the global\n+\tfunction.\n+\t(do_assemble_alias): Follow transparent alias chain\n+\tfor identifier.  Check if original alias is public.\n+\t(maybe_assemble_visibility): Use visibility of the\n+\toriginal function for instrumented version.\n+\t(default_unique_section): Likewise.\n+\t* emit-rtl.c (immed_double_const): Support MODE_POINTER_BOUNDS.\n+\t(init_emit_once): Build pointer bounds zero constants.\n+\t* explow.c (trunc_int_for_mode): Support MODE_POINTER_BOUNDS.\n+\t* target.def (builtin_chkp_function): New.\n+\t(chkp_bound_type): New.\n+\t(chkp_bound_mode): New.\n+\t(chkp_make_bounds_constant): New.\n+\t(chkp_initialize_bounds): New.\n+\t(load_bounds_for_arg): New.\n+\t(store_bounds_for_arg): New.\n+\t(load_returned_bounds): New.\n+\t(store_returned_bounds): New.\n+\t(chkp_function_value_bounds): New.\n+\t(setup_incoming_vararg_bounds): New.\n+\t(function_arg): Update hook description with new possible return\n+\tvalue CONST_INT.\n+\t* targhooks.h (default_load_bounds_for_arg): New.\n+\t(default_store_bounds_for_arg): New.\n+\t(default_load_returned_bounds): New.\n+\t(default_store_returned_bounds): New.\n+\t(default_chkp_bound_type): New.\n+\t(default_chkp_bound_mode): New.\n+\t(default_builtin_chkp_function): New.\n+\t(default_chkp_function_value_bounds): New.\n+\t(default_chkp_make_bounds_constant): New.\n+\t(default_chkp_initialize_bounds): New.\n+\t(default_setup_incoming_vararg_bounds): New.\n+\t* targhooks.c (default_load_bounds_for_arg): New.\n+\t(default_store_bounds_for_arg): New.\n+\t(default_load_returned_bounds): New.\n+\t(default_store_returned_bounds): New.\n+\t(default_chkp_bound_type): New.\n+\t(default_chkp_bound_mode); New.\n+\t(default_builtin_chkp_function): New.\n+\t(default_chkp_function_value_bounds): New.\n+\t(default_chkp_make_bounds_constant): New.\n+\t(default_chkp_initialize_bounds): New.\n+\t(default_setup_incoming_vararg_bounds): New.\n+\t* builtin-types.def (BT_BND): New.\n+\t(BT_FN_PTR_CONST_PTR): New.\n+\t(BT_FN_CONST_PTR_CONST_PTR): New.\n+\t(BT_FN_BND_CONST_PTR): New.\n+\t(BT_FN_CONST_PTR_BND): New.\n+\t(BT_FN_PTR_CONST_PTR_SIZE): New.\n+\t(BT_FN_PTR_CONST_PTR_CONST_PTR): New.\n+\t(BT_FN_VOID_PTRPTR_CONST_PTR): New.\n+\t(BT_FN_VOID_CONST_PTR_SIZE): New.\n+\t(BT_FN_VOID_PTR_BND): New.\n+\t(BT_FN_CONST_PTR_CONST_PTR_CONST_PTR): New.\n+\t(BT_FN_BND_CONST_PTR_SIZE): New.\n+\t(BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE): New.\n+\t(BT_FN_VOID_CONST_PTR_BND_CONST_PTR): New.\n+\t* chkp-builtins.def: New.\n+\t* builtins.def: include chkp-builtins.def.\n+\t(DEF_CHKP_BUILTIN): New.\n+\t* builtins.c: Include tree-chkp.h and rtl-chkp.h.\n+\t(expand_builtin): Support BUILT_IN_CHKP_INIT_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_NULL_PTR_BOUNDS, BUILT_IN_CHKP_COPY_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_CHECK_PTR_LBOUNDS, BUILT_IN_CHKP_CHECK_PTR_UBOUNDS,\n+\tBUILT_IN_CHKP_CHECK_PTR_BOUNDS, BUILT_IN_CHKP_SET_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_NARROW_PTR_BOUNDS, BUILT_IN_CHKP_STORE_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_GET_PTR_LBOUND, BUILT_IN_CHKP_GET_PTR_UBOUND,\n+\tBUILT_IN_CHKP_BNDMK, BUILT_IN_CHKP_BNDSTX, BUILT_IN_CHKP_BNDCL,\n+\tBUILT_IN_CHKP_BNDCU, BUILT_IN_CHKP_BNDLDX, BUILT_IN_CHKP_BNDRET,\n+\tBUILT_IN_CHKP_INTERSECT, BUILT_IN_CHKP_NARROW,\n+\tBUILT_IN_CHKP_EXTRACT_LOWER, BUILT_IN_CHKP_EXTRACT_UPPER.\n+\t(std_expand_builtin_va_start): Init bounds for va_list.\n+\t* cppbuiltin.c (define_builtin_macros_for_compilation_flags): Add\n+\t__CHKP__ macro when Pointer Bounds Checker is on.\n+\t* params.def (PARAM_CHKP_MAX_CTOR_SIZE): New.\n+\t* passes.def (pass_ipa_chkp_versioning): New.\n+\t(pass_early_local_passes): Renamed to pass_build_ssa_passes.\n+\t(pass_fixup_cfg): Moved to pass_chkp_instrumentation_passes.\n+\t(pass_chkp_instrumentation_passes): New.\n+\t(pass_ipa_chkp_produce_thunks): New.\n+\t(pass_local_optimization_passes): New.\n+\t(pass_chkp_opt): New.\n+\t* tree-pass.h (make_pass_ipa_chkp_versioning): New.\n+\t(make_pass_ipa_chkp_produce_thunks): New.\n+\t(make_pass_chkp): New.\n+\t(make_pass_chkp_opt): New.\n+\t(make_pass_early_local_passes): Renamed to ...\n+\t(make_pass_build_ssa_passes): This.\n+\t(make_pass_chkp_instrumentation_passes): New.\n+\t(make_pass_local_optimization_passes): New.\n+\t* passes.c (pass_manager::execute_early_local_passes): Execute\n+\tearly passes in three steps.\n+\t(execute_all_early_local_passes): Renamed to ...\n+\t(execute_build_ssa_passes): This.\n+\t(pass_data_early_local_passes): Renamed to ...\n+\t(pass_data_build_ssa_passes): This.\n+\t(pass_early_local_passes): Renamed to ...\n+\t(pass_build_ssa_passes): This.\n+\t(pass_data_chkp_instrumentation_passes): New.\n+\t(pass_chkp_instrumentation_passes): New.\n+\t(pass_data_local_optimization_passes): New.\n+\t(pass_local_optimization_passes): New.\n+\t(make_pass_early_local_passes): Renamed to ...\n+\t(make_pass_build_ssa_passes): This.\n+\t(make_pass_chkp_instrumentation_passes): New.\n+\t(make_pass_local_optimization_passes): New.\n+\t* c-family/c.opt (fcheck-pointer-bounds): New.\n+\t(fchkp-check-incomplete-type): New.\n+\t(fchkp-zero-input-bounds-for-main): New.\n+\t(fchkp-first-field-has-own-bounds): New.\n+\t(fchkp-narrow-bounds): New.\n+\t(fchkp-narrow-to-innermost-array): New.\n+\t(fchkp-optimize): New.\n+\t(fchkp-use-fast-string-functions): New.\n+\t(fchkp-use-nochk-string-functions): New.\n+\t(fchkp-use-static-bounds): New.\n+\t(fchkp-use-static-const-bounds): New.\n+\t(fchkp-treat-zero-dynamic-size-as-infinite): New.\n+\t(fchkp-check-read): New.\n+\t(fchkp-check-write): New.\n+\t(fchkp-store-bounds): New.\n+\t(fchkp-instrument-calls): New.\n+\t(fchkp-instrument-marked-only): New.\n+\t(Wchkp): New.\n+\t* c-family/c-common.c (handle_bnd_variable_size_attribute): New.\n+\t(handle_bnd_legacy): New.\n+\t(handle_bnd_instrument): New.\n+\t(c_common_attribute_table): Add bnd_variable_size, bnd_legacy\n+\tand bnd_instrument.  Fix documentation.\n+\t(c_common_format_attribute_table): Likewsie.\n+\t* toplev.c: include tree-chkp.h.\n+\t(process_options): Check Pointer Bounds Checker is supported.\n+\t(compile_file): Add chkp_finish_file call.\n+\t* ipa-cp.c (initialize_node_lattices): Use cgraph_local_p\n+\tto handle instrumentation clones properly.\n+\t(propagate_constants_accross_call): Do not propagate\n+\tthrough instrumentation thunks.\n+\t* ipa-pure-const.c (propagate_pure_const): Support\n+\tIPA_REF_CHKP.\n+\t* ipa-inline.c (early_inliner): Check edge has summary allocated.\n+\t* ipa-split.c: Include tree-chkp.h.\n+\t(find_retbnd): New.\n+\t(split_part_set_ssa_name_p): New.\n+\t(consider_split): Do not split retbnd and retval\n+\tproducers.\n+\t(insert_bndret_call_after): new.\n+\t(split_function): Propagate Pointer Bounds Checker\n+\tinstrumentation marks and handle returned bounds.\n+\t* tree-ssa-sccvn.h (vn_reference_op_struct): Transform opcode\n+\tinto bit field and add with_bounds field.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_call): Set\n+\twith_bounds field for instrumented calls.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Restore\n+\tCALL_WITH_BOUNDS_P flag for calls.\n+\t* tree-ssa-ccp.c: Include tree-chkp.h.\n+\t(insert_clobber_before_stack_restore): Handle\n+\tBUILT_IN_CHKP_BNDRET calls.\n+\t* tree-ssa-dce.c: Include tree-chkp.h.\n+\t(propagate_necessity): For free call fed by alloc check\n+\tbounds are also provided by the same alloc.\n+\t(eliminate_unnecessary_stmts): Handle BUILT_IN_CHKP_BNDRET\n+\tused by free calls.\n+\t* tree-inline.c: Include tree-chkp.h.\n+\t(declare_return_variable): Add arg holding\n+\treturned bounds slot.  Create and initialize returned bounds var.\n+\t(remap_gimple_stmt): Handle returned bounds.\n+\tReturn sequence of statements instead of a single statement.\n+\t(insert_init_stmt): Add declaration.\n+\t(remap_gimple_seq): Adjust to new remap_gimple_stmt signature.\n+\t(copy_bb): Adjust to changed return type of remap_gimple_stmt.\n+\tProperly handle bounds in va_arg_pack and va_arg_pack_len.\n+\t(expand_call_inline): Handle returned bounds.  Add bounds copy\n+\tfor generated mem to mem assignments.\n+\t* tree-inline.h (copy_body_data): Add fields retbnd and\n+\tassign_stmts.\n+\t* value-prof.c: Include tree-chkp.h.\n+\t(gimple_ic): Support returned bounds.\n+\t* ipa.c (cgraph_build_static_cdtor_1): Support contructors\n+\twith \"chkp ctor\" and \"bnd_legacy\" attributes.\n+\t(symtab_remove_unreachable_nodes): Keep initial values for\n+\tpointer bounds to be used for checks eliminations.\n+\t(process_references): Handle IPA_REF_CHKP.\n+\t(walk_polymorphic_call_targets): Likewise.\n+\t* ipa-visibility.c (cgraph_externally_visible_p): Mark\n+\tinstrumented 'main' as externally visible.\n+\t(function_and_variable_visibility): Filter instrumentation\n+\tthunks.\n+\t* cgraph.h (cgraph_thunk_info): Add add_pointer_bounds_args\n+\tfield.\n+\t(cgraph_node): Add instrumented_version, orig_decl and\n+\tinstrumentation_clone fields.\n+\t(symtab_node::get_alias_target): Allow IPA_REF_CHKP reference.\n+\t(varpool_node): Add need_bounds_init field.\n+\t(cgraph_local_p): New.\n+\t* cgraph.c: Include tree-chkp.h.\n+\t(cgraph_node::remove): Fix instrumented_version\n+\tof the referenced node if any.\n+\t(cgraph_node::dump): Dump instrumentation_clone and\n+\tinstrumented_version fields.\n+\t(cgraph_node::verify_node): Check correctness of IPA_REF_CHKP\n+\treferences and instrumentation thunks.\n+\t(cgraph_can_remove_if_no_direct_calls_and_refs_p): Keep\n+\tall not instrumented instrumentation clones alive.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Support\n+\treturned bounds.\n+\t* cgraphbuild.c (rebuild_cgraph_edges): Rebuild IPA_REF_CHKP\n+\treference.\n+\t(cgraph_rebuild_references): Likewise.\n+\t* cgraphunit.c: Include tree-chkp.h.\n+\t(assemble_thunks_and_aliases): Skip thunks calling instrumneted\n+\tfunction version.\n+\t(varpool_finalize_decl): Register statically initialized decls\n+\tin Pointer Bounds Checker.\n+\t(walk_polymorphic_call_targets): Do not mark generated call to\n+\t__builtin_unreachable as with_bounds.\n+\t(output_weakrefs): If there are both instrumented and original\n+\tversions, output only one of them.\n+\t(cgraph_node::expand_thunk): Set with_bounds flag\n+\tfor created call statement.\n+\t* ipa-ref.h (ipa_ref_use): Add IPA_REF_CHKP.\n+\t(ipa_ref): increase size of use field.\n+\t* symtab.c (ipa_ref_use_name): Add element for IPA_REF_CHKP.\n+\t* varpool.c (dump_varpool_node): Dump need_bounds_init field.\n+\t(ctor_for_folding): Do not fold constant bounds vars.\n+\t* lto-streamer.h (LTO_minor_version): Change minor version from\n+\t0 to 1.\n+\t* lto-cgraph.c (compute_ltrans_boundary): Keep initial values for\n+\tpointer bounds.\n+\t(lto_output_node): Output instrumentation_clone,\n+\tthunk.add_pointer_bounds_args and orig_decl field.\n+\t(lto_output_ref): Adjust to new ipa_ref::use field size.\n+\t(input_overwrite_node): Read instrumentation_clone field.\n+\t(input_node): Read thunk.add_pointer_bounds_args and orig_decl\n+\tfields.\n+\t(input_ref): Adjust to new ipa_ref::use field size.\n+\t(input_cgraph_1): Compute instrumented_version fields and restore\n+\tIDENTIFIER_TRANSPARENT_ALIAS chains.\n+\t(lto_output_varpool_node): Output\n+\tneed_bounds_init value.\n+\t(input_varpool_node): Read need_bounds_init value.\n+\t* lto-partition.c (add_symbol_to_partition_1): Keep original\n+\tand instrumented versions together.\n+\t(privatize_symbol_name): Restore transparent alias chain if required.\n+\t(add_references_to_partition): Add references to pointer bounds vars.\n+\t* dbxout.c (dbxout_type): Ignore POINTER_BOUNDS_TYPE.\n+\t* dwarf2out.c (gen_subprogram_die): Ignore bound args.\n+\t(gen_type_die_with_usage): Skip pointer bounds.\n+\t(dwarf2out_global_decl): Likewise.\n+\t(is_base_type): Support POINTER_BOUNDS_TYPE.\n+\t(gen_formal_types_die): Skip pointer bounds.\n+\t(gen_decl_die): Likewise.\n+\t* var-tracking.c (vt_add_function_parameters): Skip\n+\tbounds parameters.\n+\t* ipa-icf.c (sem_function::merge): Do not merge when instrumentation\n+\tthunk still exists.\n+\t(sem_variable::merge): Reset need_bounds_init flag.\n+\t* doc/extend.texi: Document Pointer Bounds Checker built-in functions\n+\tand attributes.\n+\t* doc/tm.texi.in (TARGET_LOAD_BOUNDS_FOR_ARG): New.\n+\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n+\t(TARGET_LOAD_RETURNED_BOUNDS): New.\n+\t(TARGET_STORE_RETURNED_BOUNDS): New.\n+\t(TARGET_CHKP_FUNCTION_VALUE_BOUNDS): New.\n+\t(TARGET_SETUP_INCOMING_VARARG_BOUNDS): New.\n+\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n+\t(TARGET_CHKP_BOUND_TYPE): New.\n+\t(TARGET_CHKP_BOUND_MODE): New.\n+\t(TARGET_CHKP_MAKE_BOUNDS_CONSTANT): New.\n+\t(TARGET_CHKP_INITIALIZE_BOUNDS): New.\n+\t* doc/tm.texi: Regenerated.\n+\t* doc/rtl.texi (MODE_POINTER_BOUNDS): New.\n+\t(BND32mode): New.\n+\t(BND64mode): New.\n+\t* doc/invoke.texi (-mmpx): New.\n+\t(-mno-mpx): New.\n+\t(chkp-max-ctor-size): New.\n+\t* config/i386/constraints.md (w): New.\n+\t(Ti): New.\n+\t(Tb): New.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n+\t* config/i386/i386-modes.def (BND32): New.\n+\t(BND64): New.\n+\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n+\t* config/i386/i386.c: Include tree-chkp.h, rtl-chkp.h, tree-iterator.h.\n+\t(regclass_map): Add bound registers.\n+\t(dbx_register_map): Likewise.\n+\t(dbx64_register_map): Likewise.\n+\t(svr4_dbx_register_map): Likewise.\n+\t(isa_opts): Add -mmpx.\n+\t(PTA_MPX): New.\n+\t(ix86_option_override_internal): Support MPX ISA.\n+\t(ix86_conditional_register_usage): Support bound registers.\n+\t(ix86_code_end): Add MPX bnd prefix.\n+\t(output_set_got): Likewise.\n+\t(print_reg): Avoid prefixes for bound registers.\n+\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n+\t(ix86_print_operand_punct_valid_p): Likewise.\n+\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n+\tUNSPEC_BNDLDX_ADDR.\n+\t(ix86_output_call_insn): Add MPX bnd prefix to branch instructions.\n+\t(ix86_class_likely_spilled_p): Add bound regs support.\n+\t(ix86_hard_regno_mode_ok): Likewise.\n+\t(x86_order_regs_for_local_alloc): Likewise.\n+\t(ix86_bnd_prefixed_insn_p): New.\n+\t(ix86_builtins): Add\n+\tIX86_BUILTIN_BNDMK, IX86_BUILTIN_BNDSTX,\n+\tIX86_BUILTIN_BNDLDX, IX86_BUILTIN_BNDCL,\n+\tIX86_BUILTIN_BNDCU, IX86_BUILTIN_BNDRET,\n+\tIX86_BUILTIN_BNDNARROW, IX86_BUILTIN_BNDINT,\n+\tIX86_BUILTIN_SIZEOF, IX86_BUILTIN_BNDLOWER,\n+\tIX86_BUILTIN_BNDUPPER.\n+\t(builtin_isa): Add leaf_p and nothrow_p fields.\n+\t(def_builtin): Initialize leaf_p and nothrow_p.\n+\t(ix86_add_new_builtins): Handle leaf_p and nothrow_p\n+\tflags.\n+\t(bdesc_mpx): New.\n+\t(bdesc_mpx_const): New.\n+\t(ix86_init_mpx_builtins): New.\n+\t(ix86_init_builtins): Call ix86_init_mpx_builtins.\n+\t(ix86_emit_cmove): New.\n+\t(ix86_emit_move_max): New.\n+\t(ix86_expand_builtin): Expand IX86_BUILTIN_BNDMK,\n+\tIX86_BUILTIN_BNDSTX, IX86_BUILTIN_BNDLDX,\n+\tIX86_BUILTIN_BNDCL, IX86_BUILTIN_BNDCU,\n+\tIX86_BUILTIN_BNDRET, IX86_BUILTIN_BNDNARROW,\n+\tIX86_BUILTIN_BNDINT, IX86_BUILTIN_SIZEOF,\n+\tIX86_BUILTIN_BNDLOWER, IX86_BUILTIN_BNDUPPER.\n+\t(ix86_function_value_bounds): New.\n+\t(ix86_builtin_mpx_function): New.\n+\t(ix86_get_arg_address_for_bt): New.\n+\t(ix86_load_bounds): New.\n+\t(ix86_store_bounds): New.\n+\t(ix86_load_returned_bounds): New.\n+\t(ix86_store_returned_bounds): New.\n+\t(ix86_mpx_bound_mode): New.\n+\t(ix86_make_bounds_constant): New.\n+\t(ix86_initialize_bounds):\n+\t(TARGET_LOAD_BOUNDS_FOR_ARG): New.\n+\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n+\t(TARGET_LOAD_RETURNED_BOUNDS): New.\n+\t(TARGET_STORE_RETURNED_BOUNDS): New.\n+\t(TARGET_CHKP_BOUND_MODE): New.\n+\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n+\t(TARGET_CHKP_FUNCTION_VALUE_BOUNDS): New.\n+\t(TARGET_CHKP_MAKE_BOUNDS_CONSTANT): New.\n+\t(TARGET_CHKP_INITIALIZE_BOUNDS): New.\n+\t(ix86_option_override_internal): Do not\n+\tsupport x32 with MPX.\n+\t(init_cumulative_args): Init stdarg, bnd_regno, bnds_in_bt\n+\tand force_bnd_pass.\n+\t(function_arg_advance_32): Return number of used integer\n+\tregisters.\n+\t(function_arg_advance_64): Likewise.\n+\t(function_arg_advance_ms_64): Likewise.\n+\t(ix86_function_arg_advance): Handle pointer bounds.\n+\t(ix86_function_arg): Likewise.\n+\t(ix86_function_value_regno_p): Mark fisrt bounds registers as\n+\tpossible function value.\n+\t(ix86_function_value_1): Handle pointer bounds type/mode\n+\t(ix86_return_in_memory): Likewise.\n+\t(ix86_print_operand): Analyse insn to decide abounf \"bnd\" prefix.\n+\t(ix86_expand_call): Generate returned bounds.\n+\t(ix86_setup_incoming_vararg_bounds): New.\n+\t(ix86_va_start): Initialize bounds for pointers in va_list.\n+\t(TARGET_SETUP_INCOMING_VARARG_BOUNDS): New.\n+\t* config/i386/i386.h (TARGET_MPX): New.\n+\t(TARGET_MPX_P): New.\n+\t(FIRST_PSEUDO_REGISTER): Fix to new value.\n+\t(FIXED_REGISTERS): Add bound registers.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER): Likewise.\n+\t(HARD_REGNO_NREGS): Likewise.\n+\t(VALID_BND_REG_MODE): New.\n+\t(FIRST_BND_REG): New.\n+\t(LAST_BND_REG): New.\n+\t(reg_class): Add BND_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(BND_REGNO_P): New.\n+\t(ANY_BND_REG_P): New.\n+\t(BNDmode): New.\n+\t(HI_REGISTER_NAMES): Add bound registers.\n+\t(ix86_args): Add bnd_regno, bnds_in_bt,\tforce_bnd_pass and\n+\tstdarg fields.\n+\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n+\t(UNSPEC_BNDMK_ADDR): New.\n+\t(UNSPEC_BNDSTX): New.\n+\t(UNSPEC_BNDLDX): New.\n+\t(UNSPEC_BNDLDX_ADDR): New.\n+\t(UNSPEC_BNDCL): New.\n+\t(UNSPEC_BNDCU): New.\n+\t(UNSPEC_BNDCN): New.\n+\t(UNSPEC_MPX_FENCE): New.\n+\t(UNSPEC_SIZEOF): New.\n+\t(BND0_REG): New.\n+\t(BND1_REG): New.\n+\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(length_immediate): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(prefix_rep): Check for bnd prefix.\n+\t(prefix_0f): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(length_nobnd): New.\n+\t(length): Use length_nobnd when specified.\n+\t(memory): Support mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(BND): New.\n+\t(bnd_ptr): New.\n+\t(BNDCHECK): New.\n+\t(bndcheck): New.\n+\t(*jcc_1): Add MPX bnd prefix.\n+\t(*jcc_2): Likewise.\n+\t(jump): Likewise.\n+\t(*indirect_jump): Likewise.\n+\t(*tablejump_1): Likewise.\n+\t(simple_return_internal): Likewise.\n+\t(simple_return_internal_long): Likewise.\n+\t(simple_return_pop_internal): Likewise.\n+\t(simple_return_indirect_internal): Likewise.\n+\t(<mode>_mk): New.\n+\t(*<mode>_mk): New.\n+\t(mov<mode>): New.\n+\t(*mov<mode>_internal_mpx): New.\n+\t(<mode>_<bndcheck>): New.\n+\t(*<mode>_<bndcheck>): New.\n+\t(<mode>_ldx): New.\n+\t(*<mode>_ldx): New.\n+\t(<mode>_stx): New.\n+\t(*<mode>_stx): New.\n+\tmove_size_reloc_<mode>): New.\n+\t* config/i386/predicates.md (address_mpx_no_base_operand): New.\n+\t(address_mpx_no_index_operand): New.\n+\t(bnd_mem_operator): New.\n+\t(symbol_operand): New.\n+\t(x86_64_immediate_size_operand): New.\n+\t* config/i386/i386.opt (mmpx): New.\n+\t* config/i386/i386-builtin-types.def (BND): New.\n+\t(ULONG): New.\n+\t(BND_FTYPE_PCVOID_ULONG): New.\n+\t(VOID_FTYPE_BND_PCVOID): New.\n+\t(VOID_FTYPE_PCVOID_PCVOID_BND): New.\n+\t(BND_FTYPE_PCVOID_PCVOID): New.\n+\t(BND_FTYPE_PCVOID): New.\n+\t(BND_FTYPE_BND_BND): New.\n+\t(PVOID_FTYPE_PVOID_PVOID_ULONG): New.\n+\t(PVOID_FTYPE_PCVOID_BND_ULONG): New.\n+\t(ULONG_FTYPE_VOID): New.\n+\t(PVOID_FTYPE_BND): New.\n+\n 2014-11-05  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* passes.def (pass_compute_alignments, pass_duplicate_computed_gotos,"}, {"sha": "2c3f02e8953bddc88fd5882e8e3d89f15309e2fe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1262,6 +1262,7 @@ OBJS = \\\n \tincpath.o \\\n \tinit-regs.o \\\n \tinternal-fn.o \\\n+\tipa-chkp.o \\\n \tipa-cp.o \\\n \tipa-devirt.o \\\n \tipa-polymorphic-call.o \\\n@@ -1340,6 +1341,7 @@ OBJS = \\\n \treload1.o \\\n \treorg.o \\\n \tresource.o \\\n+\trtl-chkp.o \\\n \trtl-error.o \\\n \trtl.o \\\n \trtlhash.o \\\n@@ -1399,6 +1401,8 @@ OBJS = \\\n \ttree-outof-ssa.o \\\n \ttree-parloops.o \\\n \ttree-phinodes.o \\\n+\ttree-chkp.o \\\n+\ttree-chkp-opt.o \\\n \ttree-predcom.o \\\n \ttree-pretty-print.o \\\n \ttree-profile.o \\\n@@ -2282,6 +2286,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/gimple.h \\\n   $(srcdir)/gimple-ssa.h \\\n+  $(srcdir)/tree-chkp.c \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n   $(srcdir)/tree-cfg.c \\\n   $(srcdir)/tree-dfa.c \\"}, {"sha": "84514404cf2ae735401e04cffa914c1b8101c91b", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -123,6 +123,8 @@ DEF_PRIMITIVE_TYPE (BT_I4, builtin_type_for_size (BITS_PER_UNIT*4, 1))\n DEF_PRIMITIVE_TYPE (BT_I8, builtin_type_for_size (BITS_PER_UNIT*8, 1))\n DEF_PRIMITIVE_TYPE (BT_I16, builtin_type_for_size (BITS_PER_UNIT*16, 1))\n \n+DEF_PRIMITIVE_TYPE (BT_BND, pointer_bounds_type_node)\n+\n DEF_POINTER_TYPE (BT_PTR_CONST_STRING, BT_CONST_STRING)\n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n@@ -224,6 +226,10 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)\n DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_BND_CONST_PTR, BT_BND, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_BND, BT_CONST_PTR, BT_BND)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -337,6 +343,13 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRPTR_CONST_PTR, BT_VOID, BT_PTR_PTR, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_CONST_PTR_SIZE, BT_VOID, BT_CONST_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_BND, BT_VOID, BT_PTR, BT_BND)\n+DEF_FUNCTION_TYPE_2 (BT_FN_CONST_PTR_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BND_CONST_PTR_SIZE, BT_BND, BT_CONST_PTR, BT_SIZE)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -420,6 +433,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTRPTR_SIZE_SIZE, BT_INT, BT_PTR_PTR, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_BND_CONST_PTR, BT_VOID, BT_CONST_PTR, BT_BND, BT_CONST_PTR)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)"}, {"sha": "71fbf09caa73325227d179e1cef8f75448af5d36", "filename": "gcc/builtins.c", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -66,6 +66,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"ubsan.h\"\n #include \"cilk.h\"\n+#include \"ipa-ref.h\"\n+#include \"lto-streamer.h\"\n+#include \"cgraph.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n \n static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n@@ -4324,6 +4329,13 @@ std_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   rtx va_r = expand_expr (valist, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   convert_move (va_r, nextarg, 0);\n+\n+  /* We do not have any valid bounds for the pointer, so\n+     just store zero bounds for it.  */\n+  if (chkp_function_instrumented_p (current_function_decl))\n+    chkp_expand_bounds_reset_for_mem (valist,\n+\t\t\t\t      make_tree (TREE_TYPE (valist),\n+\t\t\t\t\t\t nextarg));\n }\n \n /* Expand EXP, a call to __builtin_va_start.  */\n@@ -5791,7 +5803,19 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       && fcode != BUILT_IN_EXECVE\n       && fcode != BUILT_IN_ALLOCA\n       && fcode != BUILT_IN_ALLOCA_WITH_ALIGN\n-      && fcode != BUILT_IN_FREE)\n+      && fcode != BUILT_IN_FREE\n+      && fcode != BUILT_IN_CHKP_SET_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_INIT_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_NULL_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_COPY_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_NARROW_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_STORE_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_CHECK_PTR_LBOUNDS\n+      && fcode != BUILT_IN_CHKP_CHECK_PTR_UBOUNDS\n+      && fcode != BUILT_IN_CHKP_CHECK_PTR_BOUNDS\n+      && fcode != BUILT_IN_CHKP_GET_PTR_LBOUND\n+      && fcode != BUILT_IN_CHKP_GET_PTR_UBOUND\n+      && fcode != BUILT_IN_CHKP_BNDRET)\n     return expand_call (exp, target, ignore);\n \n   /* The built-in function expanders test for target == const0_rtx\n@@ -5825,6 +5849,8 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \t}\n     }\n \n+  gcc_assert (!CALL_WITH_BOUNDS_P (exp));\n+\n   switch (fcode)\n     {\n     CASE_FLT_FN (BUILT_IN_FABS):\n@@ -6829,6 +6855,51 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       expand_builtin_cilk_pop_frame (exp);\n       return const0_rtx;\n \n+    case BUILT_IN_CHKP_INIT_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_NULL_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_COPY_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_CHECK_PTR_LBOUNDS:\n+    case BUILT_IN_CHKP_CHECK_PTR_UBOUNDS:\n+    case BUILT_IN_CHKP_CHECK_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_SET_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_NARROW_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_STORE_PTR_BOUNDS:\n+    case BUILT_IN_CHKP_GET_PTR_LBOUND:\n+    case BUILT_IN_CHKP_GET_PTR_UBOUND:\n+      /* We allow user CHKP builtins if Pointer Bounds\n+\t Checker is off.  */\n+      if (!chkp_function_instrumented_p (current_function_decl))\n+\t{\n+\t  if (fcode == BUILT_IN_CHKP_SET_PTR_BOUNDS\n+\t      || fcode == BUILT_IN_CHKP_NARROW_PTR_BOUNDS\n+\t      || fcode == BUILT_IN_CHKP_INIT_PTR_BOUNDS\n+\t      || fcode == BUILT_IN_CHKP_NULL_PTR_BOUNDS\n+\t      || fcode == BUILT_IN_CHKP_COPY_PTR_BOUNDS)\n+\t    return expand_normal (CALL_EXPR_ARG (exp, 0));\n+\t  else if (fcode == BUILT_IN_CHKP_GET_PTR_LBOUND)\n+\t    return expand_normal (size_zero_node);\n+\t  else if (fcode == BUILT_IN_CHKP_GET_PTR_UBOUND)\n+\t    return expand_normal (size_int (-1));\n+\t  else\n+\t    return const0_rtx;\n+\t}\n+      /* FALLTHROUGH */\n+\n+    case BUILT_IN_CHKP_BNDMK:\n+    case BUILT_IN_CHKP_BNDSTX:\n+    case BUILT_IN_CHKP_BNDCL:\n+    case BUILT_IN_CHKP_BNDCU:\n+    case BUILT_IN_CHKP_BNDLDX:\n+    case BUILT_IN_CHKP_BNDRET:\n+    case BUILT_IN_CHKP_INTERSECT:\n+    case BUILT_IN_CHKP_NARROW:\n+    case BUILT_IN_CHKP_EXTRACT_LOWER:\n+    case BUILT_IN_CHKP_EXTRACT_UPPER:\n+      /* Software implementation of Pointer Bounds Checker is NYI.\n+\t Target support is required.  */\n+      error (\"Your target platform does not support -fcheck-pointer-bounds\");\n+      break;\n+\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }"}, {"sha": "552becc357183b52317e2ff5889bb465e0d03449", "filename": "gcc/builtins.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -183,6 +183,12 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_FN_INT_VAR, BT_LAST, \\\n   \t       false, false, false, ATTRS, false, flag_cilkplus) \n \n+/* Builtin used by the implementation of Pointer Bounds Checker.  */\n+#undef DEF_CHKP_BUILTIN\n+#define DEF_CHKP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+\t       true, true, false, ATTRS, true, true)\n+\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -878,3 +884,6 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n \n /* Cilk Plus builtins.  */\n #include \"cilkplus.def\"\n+\n+/* Pointer Bounds Checker builtins.  */\n+#include \"chkp-builtins.def\""}, {"sha": "ed723146ac615c06f56030412444ac258f8ff983", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -391,6 +391,9 @@ static tree handle_omp_declare_simd_attribute (tree *, tree, tree, int,\n static tree handle_omp_declare_target_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n static tree handle_designated_init_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_bnd_variable_size_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_bnd_legacy (tree *, tree, tree, int, bool *);\n+static tree handle_bnd_instrument (tree *, tree, tree, int, bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n@@ -623,7 +626,12 @@ const struct c_common_resword c_common_reswords[] =\n const unsigned int num_c_common_reswords =\n   sizeof c_common_reswords / sizeof (struct c_common_resword);\n \n-/* Table of machine-independent attributes common to all C-like languages.  */\n+/* Table of machine-independent attributes common to all C-like languages.\n+\n+   All attributes referencing arguments should be additionally processed\n+   in chkp_copy_function_type_adding_bounds for correct instrumentation\n+   by Pointer Bounds Checker.\n+   Current list of processed common attributes: nonnull.  */\n const struct attribute_spec c_common_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n@@ -790,12 +798,22 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_assume_aligned_attribute, false },\n   { \"designated_init\",        0, 0, false, true, false,\n \t\t\t      handle_designated_init_attribute, false },\n+  { \"bnd_variable_size\",      0, 0, true,  false, false,\n+\t\t\t      handle_bnd_variable_size_attribute, false },\n+  { \"bnd_legacy\",             0, 0, true, false, false,\n+\t\t\t      handle_bnd_legacy, false },\n+  { \"bnd_instrument\",         0, 0, true, false, false,\n+\t\t\t      handle_bnd_instrument, false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n /* Give the specifications for the format attributes, used by C and all\n-   descendants.  */\n+   descendants.\n \n+   All attributes referencing arguments should be additionally processed\n+   in chkp_copy_function_type_adding_bounds for correct instrumentation\n+   by Pointer Bounds Checker.\n+   Current list of processed format attributes: format, format_arg.  */\n const struct attribute_spec c_common_format_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n@@ -8258,6 +8276,54 @@ handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n   return NULL_TREE;\n }\n \n+/* Handle a \"bnd_variable_size\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_bnd_variable_size_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t\t    int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FIELD_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"bnd_legacy\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_bnd_legacy (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"bnd_instrument\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_bnd_instrument (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"warn_unused\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "66c62fb6424367224c8da0008e19f9644e74a8b8", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -323,6 +323,10 @@ Wchar-subscripts\n C ObjC C++ ObjC++ Var(warn_char_subscripts) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about subscripts whose type is \\\"char\\\"\n \n+Wchkp\n+C ObjC C++ ObjC++ Var(warn_chkp) Warning EnabledBy(Wall)\n+Warn about memory access errors found by Pointer Bounds Checker\n+\n Wclobbered\n C ObjC C++ ObjC++ Var(warn_clobbered) Warning EnabledBy(Wextra)\n Warn about variables that might be changed by \\\"longjmp\\\" or \\\"vfork\\\"\n@@ -950,6 +954,84 @@ fcanonical-system-headers\n C ObjC C++ ObjC++\n Where shorter, use canonicalized paths to systems headers.\n \n+fcheck-pointer-bounds\n+Common Report Var(flag_check_pointer_bounds)\n+Add Pointer Bounds Checker instrumentation.  fchkp-* flags are used to\n+control instrumentation.  Currently available for C, C++ and ObjC.\n+\n+fchkp-check-incomplete-type\n+C ObjC C++ ObjC++ Report Var(flag_chkp_incomplete_type) Init(1)\n+Generate pointer bounds checks for variables with incomplete type\n+\n+fchkp-zero-input-bounds-for-main\n+C ObjC C++ ObjC++ Report Var(flag_chkp_zero_input_bounds_for_main) Init(0)\n+Use zero bounds for all incoming arguments in 'main' function.  It helps when\n+instrumented binaries are used with legacy libs.\n+\n+fchkp-first-field-has-own-bounds\n+C ObjC C++ ObjC++ RejectNegative Report Var(flag_chkp_first_field_has_own_bounds)\n+Forces Pointer Bounds Checker to use narrowed bounds for address of the first\n+field in the structure.  By default pointer to the first field has the same\n+bounds as pointer to the whole structure.\n+\n+fchkp-narrow-bounds\n+C ObjC C++ ObjC++ Report Var(flag_chkp_narrow_bounds) Init(1)\n+Control how Pointer Bounds Checker handle pointers to object fields.  When\n+narrowing is on, field bounds are used.  Otherwise full object bounds are used.\n+\n+fchkp-narrow-to-innermost-array\n+C ObjC C++ ObjC++ RejectNegative Report Var(flag_chkp_narrow_to_innermost_arrray)\n+Forces Pointer Bounds Checker to use bounds of the innermost arrays in case of\n+nested static arryas access.  By default outermost array is used.\n+\n+fchkp-optimize\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_optimize) Init(-1)\n+Allow Pointer Bounds Checker optimizations.  By default allowed\n+on optimization levels >0.\n+\n+fchkp-use-fast-string-functions\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_use_fast_string_functions) Init(0)\n+Allow to use *_nobnd versions of string functions by Pointer Bounds Checker.\n+\n+fchkp-use-nochk-string-functions\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_use_nochk_string_functions) Init(0)\n+Allow to use *_nochk versions of string functions by Pointer Bounds Checker.\n+\n+fchkp-use-static-bounds\n+C ObjC C++ ObjC++ Report Var(flag_chkp_use_static_bounds) Init(1)\n+Use statically initialized variable for vars bounds instead of\n+generating them each time it is required.\n+\n+fchkp-use-static-const-bounds\n+C ObjC C++ ObjC++ Report Var(flag_chkp_use_static_const_bounds) Init(-1)\n+Use statically initialized variable for constant bounds instead of\n+generating them each time it is required.\n+\n+fchkp-treat-zero-dynamic-size-as-infinite\n+C ObjC C++ ObjC++ Report Var(flag_chkp_zero_dynamic_size_as_infinite) Init(0)\n+With this option zero size obtained dynamically for objects with\n+incomplete type will be treated as infinite.\n+\n+fchkp-check-read\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_check_read) Init(1)\n+Generate checks for all read accesses to memory.\n+\n+fchkp-check-write\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_check_write) Init(1)\n+Generate checks for all write accesses to memory.\n+\n+fchkp-store-bounds\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_store_bounds) Init(1)\n+Generate bounds stores for pointer writes.\n+\n+fchkp-instrument-calls\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_instrument_calls) Init(1)\n+Generate bounds passing for calls.\n+\n+fchkp-instrument-marked-only\n+C ObjC C++ ObjC++ LTO Report Var(flag_chkp_instrument_marked_only) Init(0)\n+Instrument only functions marked with bnd_instrument attribute.\n+\n fcilkplus\n C ObjC C++ ObjC++ LTO Report Var(flag_cilkplus) Init(0)\n Enable Cilk Plus"}, {"sha": "43ac5d2f6b34ff8fc8a1a830210e821ea99a73c9", "filename": "gcc/calls.c", "status": "modified", "additions": 221, "deletions": 15, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"timevar.h\"\n #include \"sbitmap.h\"\n+#include \"bitmap.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"hash-map.h\"\n@@ -61,6 +62,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -88,6 +91,15 @@ struct arg_data\n   /* If REG is a PARALLEL, this is a copy of VALUE pulled into the correct\n      form for emit_group_move.  */\n   rtx parallel_value;\n+  /* If value is passed in neither reg nor stack, this field holds a number\n+     of a special slot to be used.  */\n+  rtx special_slot;\n+  /* For pointer bounds hold an index of parm bounds are bound to.  -1 if\n+     there is no such pointer.  */\n+  int pointer_arg;\n+  /* If pointer_arg refers a structure, then pointer_offset holds an offset\n+     of a pointer in this structure.  */\n+  int pointer_offset;\n   /* If REG was promoted from the actual mode of the argument expression,\n      indicates whether the promotion is sign- or zero-extended.  */\n   int unsignedp;\n@@ -145,6 +157,7 @@ static void emit_call_1 (rtx, tree, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n \t\t\t cumulative_args_t);\n static void precompute_register_parameters (int, struct arg_data *, int *);\n+static void store_bounds (struct arg_data *, struct arg_data *);\n static int store_one_arg (struct arg_data *, rtx, int, int, int);\n static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n static int finalize_must_preallocate (int, int, struct arg_data *,\n@@ -409,6 +422,10 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n       && MEM_EXPR (funmem) != NULL_TREE)\n     set_mem_expr (XEXP (call, 0), MEM_EXPR (funmem));\n \n+  /* Mark instrumented calls.  */\n+  if (call && fntree)\n+    CALL_EXPR_WITH_BOUNDS_P (call) = CALL_WITH_BOUNDS_P (fntree);\n+\n   /* Put the register usage information there.  */\n   add_function_usage_to (call_insn, call_fusage);\n \n@@ -515,8 +532,16 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n static int\n special_function_p (const_tree fndecl, int flags)\n {\n-  if (fndecl && DECL_NAME (fndecl)\n-      && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n+  tree name_decl = DECL_NAME (fndecl);\n+\n+  /* For instrumentation clones we want to derive flags\n+     from the original name.  */\n+  if (cgraph_node::get (fndecl)\n+      && cgraph_node::get (fndecl)->instrumentation_clone)\n+    name_decl = DECL_NAME (cgraph_node::get (fndecl)->orig_decl);\n+\n+  if (fndecl && name_decl\n+      && IDENTIFIER_LENGTH (name_decl) <= 17\n       /* Exclude functions not at the file scope, or not `extern',\n \t since they are not the magic functions we would otherwise\n \t think they are.\n@@ -528,16 +553,16 @@ special_function_p (const_tree fndecl, int flags)\n \t  || TREE_CODE (DECL_CONTEXT (fndecl)) == TRANSLATION_UNIT_DECL)\n       && TREE_PUBLIC (fndecl))\n     {\n-      const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+      const char *name = IDENTIFIER_POINTER (name_decl);\n       const char *tname = name;\n \n       /* We assume that alloca will always be called by name.  It\n \t makes no sense to pass it as a pointer-to-function to\n \t anything that does not understand its behavior.  */\n-      if (((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n+      if (((IDENTIFIER_LENGTH (name_decl) == 6\n \t    && name[0] == 'a'\n \t    && ! strcmp (name, \"alloca\"))\n-\t   || (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n+\t   || (IDENTIFIER_LENGTH (name_decl) == 16\n \t       && name[0] == '_'\n \t       && ! strcmp (name, \"__builtin_alloca\"))))\n \tflags |= ECF_MAY_BE_ALLOCA;\n@@ -1126,23 +1151,86 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   args_size->constant = 0;\n   args_size->var = 0;\n \n+  bitmap_obstack_initialize (NULL);\n+\n   /* In this loop, we consider args in the order they are written.\n      We fill up ARGS from the back.  */\n \n   i = num_actuals - 1;\n   {\n-    int j = i;\n+    int j = i, ptr_arg = -1;\n     call_expr_arg_iterator iter;\n     tree arg;\n+    bitmap slots = NULL;\n \n     if (struct_value_addr_value)\n       {\n \targs[j].tree_value = struct_value_addr_value;\n \tj--;\n+\n+\t/* If we pass structure address then we need to\n+\t   create bounds for it.  Since created bounds is\n+\t   a call statement, we expand it right here to avoid\n+\t   fixing all other places where it may be expanded.  */\n+\tif (CALL_WITH_BOUNDS_P (exp))\n+\t  {\n+\t    args[j].value = gen_reg_rtx (targetm.chkp_bound_mode ());\n+\t    args[j].tree_value\n+\t      = chkp_make_bounds_for_struct_addr (struct_value_addr_value);\n+\t    expand_expr_real (args[j].tree_value, args[j].value, VOIDmode,\n+\t\t\t      EXPAND_NORMAL, 0, false);\n+\t    args[j].pointer_arg = j + 1;\n+\t    j--;\n+\t  }\n       }\n     FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n       {\n \ttree argtype = TREE_TYPE (arg);\n+\n+\t/* Remember last param with pointer and associate it\n+\t   with following pointer bounds.  */\n+\tif (CALL_WITH_BOUNDS_P (exp)\n+\t    && chkp_type_has_pointer (argtype))\n+\t  {\n+\t    if (slots)\n+\t      BITMAP_FREE (slots);\n+\t    ptr_arg = j;\n+\t    if (!BOUNDED_TYPE_P (argtype))\n+\t      {\n+\t\tslots = BITMAP_ALLOC (NULL);\n+\t\tchkp_find_bound_slots (argtype, slots);\n+\t      }\n+\t  }\n+\telse if (POINTER_BOUNDS_TYPE_P (argtype))\n+\t  {\n+\t    /* We expect bounds in instrumented calls only.\n+\t       Otherwise it is a sign we lost flag due to some optimization\n+\t       and may emit call args incorrectly.  */\n+\t    gcc_assert (CALL_WITH_BOUNDS_P (exp));\n+\n+\t    /* For structures look for the next available pointer.  */\n+\t    if (ptr_arg != -1 && slots)\n+\t      {\n+\t\tunsigned bnd_no = bitmap_first_set_bit (slots);\n+\t\targs[j].pointer_offset =\n+\t\t  bnd_no * POINTER_SIZE / BITS_PER_UNIT;\n+\n+\t\tbitmap_clear_bit (slots, bnd_no);\n+\n+\t\t/* Check we have no more pointers in the structure.  */\n+\t\tif (bitmap_empty_p (slots))\n+\t\t  BITMAP_FREE (slots);\n+\t      }\n+\t    args[j].pointer_arg = ptr_arg;\n+\n+\t    /* Check we covered all pointers in the previous\n+\t       non bounds arg.  */\n+\t    if (!slots)\n+\t      ptr_arg = -1;\n+\t  }\n+\telse\n+\t  ptr_arg = -1;\n+\n \tif (targetm.calls.split_complex_arg\n \t    && argtype\n \t    && TREE_CODE (argtype) == COMPLEX_TYPE\n@@ -1157,8 +1245,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  args[j].tree_value = arg;\n \tj--;\n       }\n+\n+    if (slots)\n+      BITMAP_FREE (slots);\n   }\n \n+  bitmap_obstack_release (NULL);\n+\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n     {\n@@ -1292,6 +1385,12 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       args[i].reg = targetm.calls.function_arg (args_so_far, mode, type,\n \t\t\t\t\t\targpos < n_named_args);\n \n+      if (args[i].reg && CONST_INT_P (args[i].reg))\n+\t{\n+\t  args[i].special_slot = args[i].reg;\n+\t  args[i].reg = NULL;\n+\t}\n+\n       /* If this is a sibling call and the machine has register windows, the\n \t register window has to be unwinded before calling the routine, so\n \t arguments have to go into the incoming registers.  */\n@@ -1325,10 +1424,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  || (args[i].pass_on_stack && args[i].reg != 0))\n \t*must_preallocate = 1;\n \n+      /* No stack allocation and padding for bounds.  */\n+      if (POINTER_BOUNDS_P (args[i].tree_value))\n+\t;\n       /* Compute the stack-size of this argument.  */\n-      if (args[i].reg == 0 || args[i].partial != 0\n-\t  || reg_parm_stack_space > 0\n-\t  || args[i].pass_on_stack)\n+      else if (args[i].reg == 0 || args[i].partial != 0\n+\t       || reg_parm_stack_space > 0\n+\t       || args[i].pass_on_stack)\n \tlocate_and_pad_parm (mode, type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t     1,\n@@ -1542,6 +1644,12 @@ finalize_must_preallocate (int must_preallocate, int num_actuals,\n \t    partial_seen = 1;\n \t  else if (partial_seen && args[i].reg == 0)\n \t    must_preallocate = 1;\n+\t  /* We preallocate in case there are bounds passed\n+\t     in the bounds table to have precomputed address\n+\t     for bounds association.  */\n+\t  else if (POINTER_BOUNDS_P (args[i].tree_value)\n+\t\t   && !args[i].reg)\n+\t    must_preallocate = 1;\n \n \t  if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n \t      && (TREE_CODE (args[i].tree_value) == CALL_EXPR\n@@ -1593,6 +1701,10 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t      && args[i].partial == 0)\n \t    continue;\n \n+\t  /* Pointer Bounds are never passed on the stack.  */\n+\t  if (POINTER_BOUNDS_P (args[i].tree_value))\n+\t    continue;\n+\n \t  if (CONST_INT_P (offset))\n \t    addr = plus_constant (Pmode, arg_reg, INTVAL (offset));\n \t  else\n@@ -2215,6 +2327,8 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Register in which non-BLKmode value will be returned,\n      or 0 if no value or if value is BLKmode.  */\n   rtx valreg;\n+  /* Register(s) in which bounds are returned.  */\n+  rtx valbnd = NULL;\n   /* Address where we should return a BLKmode value;\n      0 if value not BLKmode.  */\n   rtx structure_value_addr = 0;\n@@ -2473,7 +2587,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n       structure_value_addr_value =\n \tmake_tree (build_pointer_type (TREE_TYPE (funtype)), temp);\n-      structure_value_addr_parm = 1;\n+      structure_value_addr_parm = CALL_WITH_BOUNDS_P (exp) ? 2 : 1;\n     }\n \n   /* Count the arguments and set NUM_ACTUALS.  */\n@@ -2991,15 +3105,28 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* Figure out the register where the value, if any, will come back.  */\n       valreg = 0;\n+      valbnd = 0;\n       if (TYPE_MODE (rettype) != VOIDmode\n \t  && ! structure_value_addr)\n \t{\n \t  if (pcc_struct_value)\n-\t    valreg = hard_function_value (build_pointer_type (rettype),\n-\t\t\t\t\t  fndecl, NULL, (pass == 0));\n+\t    {\n+\t      valreg = hard_function_value (build_pointer_type (rettype),\n+\t\t\t\t\t    fndecl, NULL, (pass == 0));\n+\t      if (CALL_WITH_BOUNDS_P (exp))\n+\t\tvalbnd = targetm.calls.\n+\t\t  chkp_function_value_bounds (build_pointer_type (rettype),\n+\t\t\t\t\t      fndecl, (pass == 0));\n+\t    }\n \t  else\n-\t    valreg = hard_function_value (rettype, fndecl, fntype,\n-\t\t\t\t\t  (pass == 0));\n+\t    {\n+\t      valreg = hard_function_value (rettype, fndecl, fntype,\n+\t\t\t\t\t    (pass == 0));\n+\t      if (CALL_WITH_BOUNDS_P (exp))\n+\t\tvalbnd = targetm.calls.chkp_function_value_bounds (rettype,\n+\t\t\t\t\t\t\t\t   fndecl,\n+\t\t\t\t\t\t\t\t   (pass == 0));\n+\t    }\n \n \t  /* If VALREG is a PARALLEL whose first member has a zero\n \t     offset, use that.  This is for targets such as m68k that\n@@ -3040,7 +3167,10 @@ expand_call (tree exp, rtx target, int ignore)\n \n       for (i = 0; i < num_actuals; i++)\n \t{\n-\t  if (args[i].reg == 0 || args[i].pass_on_stack)\n+\t  /* Delay bounds until all other args are stored.  */\n+\t  if (POINTER_BOUNDS_P (args[i].tree_value))\n+\t    continue;\n+\t  else if (args[i].reg == 0 || args[i].pass_on_stack)\n \t    {\n \t      rtx_insn *before_arg = get_last_insn ();\n \n@@ -3093,6 +3223,17 @@ expand_call (tree exp, rtx target, int ignore)\n \t\tsibcall_failure = 1;\n \t    }\n \n+      /* Store all bounds not passed in registers.  */\n+      for (i = 0; i < num_actuals; i++)\n+\t{\n+\t  if (POINTER_BOUNDS_P (args[i].tree_value)\n+\t      && !args[i].reg)\n+\t    store_bounds (&args[i],\n+\t\t\t  args[i].pointer_arg == -1\n+\t\t\t  ? NULL\n+\t\t\t  : &args[args[i].pointer_arg]);\n+\t}\n+\n       /* If register arguments require space on the stack and stack space\n \t was not preallocated, allocate stack space here for arguments\n \t passed in registers.  */\n@@ -3497,6 +3638,9 @@ expand_call (tree exp, rtx target, int ignore)\n \n   free (stack_usage_map_buf);\n \n+  /* Join result with returned bounds so caller may use them if needed.  */\n+  target = chkp_join_splitted_slot (target, valbnd);\n+\n   return target;\n }\n \n@@ -4366,6 +4510,68 @@ emit_library_call_value (rtx orgfun, rtx value,\n   return result;\n }\n \f\n+\n+/* Store pointer bounds argument ARG  into Bounds Table entry\n+   associated with PARM.  */\n+static void\n+store_bounds (struct arg_data *arg, struct arg_data *parm)\n+{\n+  rtx slot = NULL, ptr = NULL, addr = NULL;\n+\n+  /* We may pass bounds not associated with any pointer.  */\n+  if (!parm)\n+    {\n+      gcc_assert (arg->special_slot);\n+      slot = arg->special_slot;\n+      ptr = const0_rtx;\n+    }\n+  /* Find pointer associated with bounds and where it is\n+     passed.  */\n+  else\n+    {\n+      if (!parm->reg)\n+\t{\n+\t  gcc_assert (!arg->special_slot);\n+\n+\t  addr = adjust_address (parm->stack, Pmode, arg->pointer_offset);\n+\t}\n+      else if (REG_P (parm->reg))\n+\t{\n+\t  gcc_assert (arg->special_slot);\n+\t  slot = arg->special_slot;\n+\n+\t  if (MEM_P (parm->value))\n+\t    addr = adjust_address (parm->value, Pmode, arg->pointer_offset);\n+\t  else if (REG_P (parm->value))\n+\t    ptr = gen_rtx_SUBREG (Pmode, parm->value, arg->pointer_offset);\n+\t  else\n+\t    {\n+\t      gcc_assert (!arg->pointer_offset);\n+\t      ptr = parm->value;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (GET_CODE (parm->reg) == PARALLEL);\n+\n+\t  gcc_assert (arg->special_slot);\n+\t  slot = arg->special_slot;\n+\n+\t  if (parm->parallel_value)\n+\t    ptr = chkp_get_value_with_offs (parm->parallel_value,\n+\t\t\t\t\t    GEN_INT (arg->pointer_offset));\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* Expand bounds.  */\n+  if (!arg->value)\n+    arg->value = expand_normal (arg->tree_value);\n+\n+  targetm.calls.store_bounds_for_arg (ptr, addr, arg->value, slot);\n+}\n+\n /* Store a single argument for a function call\n    into the register or memory area where it must be passed.\n    *ARG describes the argument value and where to pass it."}, {"sha": "2df8ce3ba84b8da974fdbbfeaf3c4f6412c32772", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -90,6 +90,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"output.h\"\n #include \"builtins.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n@@ -2316,6 +2318,7 @@ expand_call_stmt (gimple stmt)\n     CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n   CALL_EXPR_VA_ARG_PACK (exp) = gimple_call_va_arg_pack_p (stmt);\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n+  CALL_WITH_BOUNDS_P (exp) = gimple_call_with_bounds_p (stmt);\n \n   /* Ensure RTL is created for debug args.  */\n   if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n@@ -3126,11 +3129,12 @@ expand_value_return (rtx val)\n    from the current function.  */\n \n static void\n-expand_return (tree retval)\n+expand_return (tree retval, tree bounds)\n {\n   rtx result_rtl;\n   rtx val = 0;\n   tree retval_rhs;\n+  rtx bounds_rtl;\n \n   /* If function wants no value, give it none.  */\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n@@ -3156,6 +3160,56 @@ expand_return (tree retval)\n \n   result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n \n+  /* Put returned bounds to the right place.  */\n+  bounds_rtl = DECL_BOUNDS_RTL (DECL_RESULT (current_function_decl));\n+  if (bounds_rtl)\n+    {\n+      rtx addr, bnd;\n+\n+      if (bounds)\n+\t{\n+\t  bnd = expand_normal (bounds);\n+\t  targetm.calls.store_returned_bounds (bounds_rtl, bnd);\n+\t}\n+      else if (REG_P (bounds_rtl))\n+\t{\n+\t  addr = expand_normal (build_fold_addr_expr (retval_rhs));\n+\t  addr = gen_rtx_MEM (Pmode, addr);\n+\t  bnd = targetm.calls.load_bounds_for_arg (addr, NULL, NULL);\n+\t  targetm.calls.store_returned_bounds (bounds_rtl, bnd);\n+\t}\n+      else\n+\t{\n+\t  int n;\n+\n+\t  gcc_assert (GET_CODE (bounds_rtl) == PARALLEL);\n+\n+\t  addr = expand_normal (build_fold_addr_expr (retval_rhs));\n+\t  addr = gen_rtx_MEM (Pmode, addr);\n+\n+\t  for (n = 0; n < XVECLEN (bounds_rtl, 0); n++)\n+\t    {\n+\t      rtx offs = XEXP (XVECEXP (bounds_rtl, 0, n), 1);\n+\t      rtx slot = XEXP (XVECEXP (bounds_rtl, 0, n), 0);\n+\t      rtx from = adjust_address (addr, Pmode, INTVAL (offs));\n+\t      rtx bnd = targetm.calls.load_bounds_for_arg (from, NULL, NULL);\n+\t      targetm.calls.store_returned_bounds (slot, bnd);\n+\t    }\n+\t}\n+    }\n+  else if (chkp_function_instrumented_p (current_function_decl)\n+\t   && !BOUNDED_P (retval_rhs)\n+\t   && chkp_type_has_pointer (TREE_TYPE (retval_rhs))\n+\t   && TREE_CODE (retval_rhs) != RESULT_DECL)\n+    {\n+      rtx addr = expand_normal (build_fold_addr_expr (retval_rhs));\n+      addr = gen_rtx_MEM (Pmode, addr);\n+\n+      gcc_assert (MEM_P (result_rtl));\n+\n+      chkp_copy_bounds_for_stack_parm (result_rtl, addr, TREE_TYPE (retval_rhs));\n+    }\n+\n   /* If we are returning the RESULT_DECL, then the value has already\n      been stored into it, so we don't have to do anything special.  */\n   if (TREE_CODE (retval_rhs) == RESULT_DECL)\n@@ -3261,7 +3315,7 @@ expand_gimple_stmt_1 (gimple stmt)\n       if (!op0)\n \texpand_null_return ();\n       else\n-\texpand_return (op0);\n+\texpand_return (op0, gimple_return_retbnd (stmt));\n       break;\n \n     case GIMPLE_ASSIGN:\n@@ -5654,6 +5708,9 @@ pass_expand::execute (function *fun)\n \n   rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n+  if (chkp_function_instrumented_p (current_function_decl))\n+    chkp_reset_rtl_bounds ();\n+\n   insn_locations_init ();\n   if (!DECL_IS_BUILTIN (current_function_decl))\n     {"}, {"sha": "7216b89718436157bfab5339129192328daabbcf", "filename": "gcc/cgraph.c", "status": "modified", "additions": 112, "deletions": 1, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -80,6 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"profile.h\"\n #include \"params.h\"\n+#include \"tree-chkp.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -1344,6 +1345,33 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  e->speculative = false;\n \t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,\n \t\t\t\t\t\t     false);\n+\n+\t  /* Fix edges for BUILT_IN_CHKP_BNDRET calls attached to the\n+\t     processed call stmt.  */\n+\t  if (gimple_call_with_bounds_p (new_stmt)\n+\t      && gimple_call_lhs (new_stmt)\n+\t      && chkp_retbnd_call_by_val (gimple_call_lhs (e2->call_stmt)))\n+\t    {\n+\t      tree dresult = gimple_call_lhs (new_stmt);\n+\t      tree iresult = gimple_call_lhs (e2->call_stmt);\n+\t      gimple dbndret = chkp_retbnd_call_by_val (dresult);\n+\t      gimple ibndret = chkp_retbnd_call_by_val (iresult);\n+\t      struct cgraph_edge *iedge\n+\t\t= e2->caller->cgraph_node::get_edge (ibndret);\n+\t      struct cgraph_edge *dedge;\n+\n+\t      if (dbndret)\n+\t\t{\n+\t\t  dedge = iedge->caller->create_edge (iedge->callee,\n+\t\t\t\t\t\t      dbndret, e->count,\n+\t\t\t\t\t\t      e->frequency);\n+\t\t  dedge->frequency = compute_call_stmt_bb_frequency\n+\t\t    (dedge->caller->decl, gimple_bb (dedge->call_stmt));\n+\t\t}\n+\t      iedge->frequency = compute_call_stmt_bb_frequency\n+\t\t(iedge->caller->decl, gimple_bb (iedge->call_stmt));\n+\t    }\n+\n \t  e->frequency = compute_call_stmt_bb_frequency\n \t\t\t   (e->caller->decl, gimple_bb (e->call_stmt));\n \t  e2->frequency = compute_call_stmt_bb_frequency\n@@ -1776,6 +1804,12 @@ cgraph_node::remove (void)\n       call_site_hash = NULL;\n     }\n \n+  if (instrumented_version)\n+    {\n+      instrumented_version->instrumented_version = NULL;\n+      instrumented_version = NULL;\n+    }\n+\n   symtab->release_symbol (this, uid);\n }\n \n@@ -2027,6 +2061,11 @@ cgraph_node::dump (FILE *f)\n       if (edge->indirect_info->polymorphic)\n \tedge->indirect_info->context.dump (f);\n     }\n+\n+  if (instrumentation_clone)\n+    fprintf (f, \"  Is instrumented version.\\n\");\n+  else if (instrumented_version)\n+    fprintf (f, \"  Has instrumented version.\\n\");\n }\n \n /* Dump call graph node NODE to stderr.  */\n@@ -2389,6 +2428,12 @@ bool\n cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n {\n   gcc_assert (!global.inlined_to);\n+  /* Instrumentation clones should not be removed before\n+     instrumentation happens.  New callers may appear after\n+     instrumentation.  */\n+  if (instrumentation_clone\n+      && !chkp_function_instrumented_p (decl))\n+    return false;\n   /* Extern inlines can always go, we will use the external definition.  */\n   if (DECL_EXTERNAL (decl))\n     return true;\n@@ -2825,7 +2870,9 @@ cgraph_node::verify_node (void)\n           error_found = true;\n \t}\n       for (i = 0; iterate_reference (i, ref); i++)\n-\tif (ref->use != IPA_REF_ALIAS)\n+\tif (ref->use == IPA_REF_CHKP)\n+\t  ;\n+\telse if (ref->use != IPA_REF_ALIAS)\n \t  {\n \t    error (\"Alias has non-alias reference\");\n \t    error_found = true;\n@@ -2843,6 +2890,64 @@ cgraph_node::verify_node (void)\n \t    error_found = true;\n \t  }\n     }\n+\n+  /* Check instrumented version reference.  */\n+  if (instrumented_version\n+      && instrumented_version->instrumented_version != this)\n+    {\n+      error (\"Instrumentation clone does not reference original node\");\n+      error_found = true;\n+    }\n+\n+  /* Cannot have orig_decl for not instrumented nodes.  */\n+  if (!instrumentation_clone && orig_decl)\n+    {\n+      error (\"Not instrumented node has non-NULL original declaration\");\n+      error_found = true;\n+    }\n+\n+  /* If original not instrumented node still exists then we may check\n+     original declaration is set properly.  */\n+  if (instrumented_version\n+      && orig_decl\n+      && orig_decl != instrumented_version->decl)\n+    {\n+      error (\"Instrumented node has wrong original declaration\");\n+      error_found = true;\n+    }\n+\n+  /* Check all nodes have chkp reference to their instrumented versions.  */\n+  if (analyzed\n+      && instrumented_version\n+      && !instrumentation_clone)\n+    {\n+      bool ref_found = false;\n+      int i;\n+      struct ipa_ref *ref;\n+\n+      for (i = 0; iterate_reference (i, ref); i++)\n+\tif (ref->use == IPA_REF_CHKP)\n+\t  {\n+\t    if (ref_found)\n+\t      {\n+\t\terror (\"Node has more than one chkp reference\");\n+\t\terror_found = true;\n+\t      }\n+\t    if (ref->referred != instrumented_version)\n+\t      {\n+\t\terror (\"Wrong node is referenced with chkp reference\");\n+\t\terror_found = true;\n+\t      }\n+\t    ref_found = true;\n+\t  }\n+\n+      if (!ref_found)\n+\t{\n+\t  error (\"Analyzed node has no reference to instrumented version\");\n+\t  error_found = true;\n+\t}\n+    }\n+\n   if (analyzed && thunk.thunk_p)\n     {\n       if (!callees)\n@@ -2860,6 +2965,12 @@ cgraph_node::verify_node (void)\n \t  error (\"Thunk is not supposed to have body\");\n           error_found = true;\n         }\n+      if (thunk.add_pointer_bounds_args\n+\t  && !instrumented_version->semantically_equivalent_p (callees->callee))\n+\t{\n+\t  error (\"Instrumentation thunk has wrong edge callee\");\n+          error_found = true;\n+\t}\n     }\n   else if (analyzed && gimple_has_body_p (decl)\n \t   && !TREE_ASM_WRITTEN (decl)"}, {"sha": "e2becb96d5656557aae2d8ae179741ea6dc8820e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -543,6 +543,7 @@ struct GTY(()) cgraph_thunk_info {\n   tree alias;\n   bool this_adjusting;\n   bool virtual_offset_p;\n+  bool add_pointer_bounds_args;\n   /* Set to true when alias node is thunk.  */\n   bool thunk_p;\n };\n@@ -1187,6 +1188,13 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   cgraph_node *prev_sibling_clone;\n   cgraph_node *clones;\n   cgraph_node *clone_of;\n+  /* If instrumentation_clone is 1 then instrumented_version points\n+     to the original function used to make instrumented version.\n+     Otherwise points to instrumented version of the function.  */\n+  cgraph_node *instrumented_version;\n+  /* If instrumentation_clone is 1 then orig_decl is the original\n+     function declaration.  */\n+  tree orig_decl;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   hash_table<cgraph_edge_hasher> *GTY(()) call_site_hash;\n@@ -1249,6 +1257,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned calls_comdat_local : 1;\n   /* True if node has been created by merge operation in IPA-ICF.  */\n   unsigned icf_merged: 1;\n+  /* True when function is clone created for Pointer Bounds Checker\n+     instrumentation.  */\n+  unsigned instrumentation_clone : 1;\n };\n \n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n@@ -1658,6 +1669,10 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n \n+  /* Set when variable has statically initialized pointer\n+     or is a static bounds variable and needs initalization.  */\n+  unsigned need_bounds_init : 1;\n+\n   /* Set if the variable is dynamically initialized, except for\n      function local statics.   */\n   unsigned dynamically_initialized : 1;\n@@ -2181,6 +2196,8 @@ symtab_node::get_alias_target (void)\n {\n   ipa_ref *ref = NULL;\n   iterate_reference (0, ref);\n+  if (ref->use == IPA_REF_CHKP)\n+    iterate_reference (1, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   return ref->referred;\n }\n@@ -2756,4 +2773,17 @@ ipa_polymorphic_call_context::useless_p () const\n {\n   return (!outer_type && !speculative_outer_type);\n }\n+\n+/* Return true if NODE is local.  Instrumentation clones are counted as local\n+   only when original function is local.  */\n+\n+static inline bool\n+cgraph_local_p (cgraph_node *node)\n+{\n+  if (!node->instrumentation_clone || !node->instrumented_version)\n+    return node->local.local;\n+\n+  return node->local.local && node->instrumented_version->local.local;\n+}\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "c72ceab3c921116f415dea99d865ced5350ea846", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -472,6 +472,10 @@ cgraph_edge::rebuild_edges (void)\n   record_eh_tables (node, cfun);\n   gcc_assert (!node->global.inlined_to);\n \n+  if (node->instrumented_version\n+      && !node->instrumentation_clone)\n+    node->create_reference (node->instrumented_version, IPA_REF_CHKP, NULL);\n+\n   return 0;\n }\n \n@@ -504,6 +508,10 @@ cgraph_edge::rebuild_references (void)\n \tnode->record_stmt_references (gsi_stmt (gsi));\n     }\n   record_eh_tables (node, cfun);\n+\n+  if (node->instrumented_version\n+      && !node->instrumentation_clone)\n+    node->create_reference (node->instrumented_version, IPA_REF_CHKP, NULL);\n }\n \n namespace {"}, {"sha": "d2e884745947ca130ddbe309a64325e3d2045263", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -223,6 +223,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-nested.h\"\n #include \"gimplify.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-chkp.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n@@ -802,6 +803,9 @@ varpool_node::finalize_decl (tree decl)\n       || (!flag_toplevel_reorder\n \t&& symtab->state == EXPANSION))\n     node->assemble_decl ();\n+\n+  if (DECL_INITIAL (decl))\n+    chkp_register_var_initializer (decl);\n }\n \n /* EDGE is an polymorphic call.  Mark all possible targets as reachable\n@@ -875,6 +879,11 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \n \t  edge->make_direct (target);\n \t  edge->redirect_call_stmt_to_callee ();\n+\n+\t  /* Call to __builtin_unreachable shouldn't be instrumented.  */\n+\t  if (!targets.length ())\n+\t    gimple_call_set_with_bounds (edge->call_stmt, false);\n+\n \t  if (symtab->dump_file)\n \t    {\n \t      fprintf (symtab->dump_file,\n@@ -1584,6 +1593,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n       callees->call_stmt = call;\n       gimple_call_set_from_thunk (call, true);\n+      gimple_call_set_with_bounds (call, instrumentation_clone);\n       if (restmp)\n \t{\n           gimple_call_set_lhs (call, restmp);\n@@ -1680,7 +1690,8 @@ cgraph_node::assemble_thunks_and_aliases (void)\n   ipa_ref *ref;\n \n   for (e = callers; e;)\n-    if (e->caller->thunk.thunk_p)\n+    if (e->caller->thunk.thunk_p\n+\t&& !e->caller->thunk.add_pointer_bounds_args)\n       {\n \tcgraph_node *thunk = e->caller;\n \n@@ -2087,9 +2098,13 @@ void\n symbol_table::output_weakrefs (void)\n {\n   symtab_node *node;\n+  cgraph_node *cnode;\n   FOR_EACH_SYMBOL (node)\n     if (node->alias\n         && !TREE_ASM_WRITTEN (node->decl)\n+\t&& (!(cnode = dyn_cast <cgraph_node *> (node))\n+\t    || !cnode->instrumented_version\n+\t    || !TREE_ASM_WRITTEN (cnode->instrumented_version->decl))\n \t&& node->weakref)\n       {\n \ttree target;"}, {"sha": "cae0332304206252ca9976e2f5b5f667bc779011", "filename": "gcc/chkp-builtins.def", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fchkp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fchkp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fchkp-builtins.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,71 @@\n+/* This file contains the definitions and documentation for the\n+   builtins used in the GNU compiler.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Before including this file, you should define macros:\n+\n+      DEF_BUILTIN_STUB(ENUM, NAME)\n+      DEF_CHKP_BUILTIN(ENUM, NAME, TYPE, ATTRS)\n+\n+   See builtins.def for details.  */\n+\n+/* Following builtins are used by compiler for Pointer Bounds Checker\n+   instrumentation.  Currently these generic builtins are not\n+   implemented and target has to provide his own version.  See\n+   builtin_chkp_function target hook documentation for more details.  */\n+DEF_BUILTIN_STUB (BUILT_IN_CHKP_INTERSECT, \"__chkp_intersect\")\n+DEF_BUILTIN_STUB (BUILT_IN_CHKP_SIZEOF, \"__chkp_sizeof\")\n+DEF_BUILTIN_STUB (BUILT_IN_CHKP_NARROW, \"__chkp_narrow\")\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDCL, \"__chkp_bndcl\", BT_FN_VOID_PTR_BND, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDCU, \"__chkp_bndcu\", BT_FN_VOID_PTR_BND, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDSTX, \"__chkp_bndstx\", BT_FN_VOID_CONST_PTR_BND_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDLDX, \"__chkp_bndldx\", BT_FN_CONST_PTR_CONST_PTR_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDRET, \"__chkp_bndret\", BT_FN_BND_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BNDMK, \"__chkp_bndmk\", BT_FN_BND_CONST_PTR_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_EXTRACT_LOWER, \"__chkp_extract_lower\", BT_FN_CONST_PTR_BND, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_EXTRACT_UPPER, \"__chkp_extract_upper\", BT_FN_CONST_PTR_BND, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+/* Pointer Bounds Checker builtins for users.\n+   All builtins calls are expanded in the\n+   Pointer Bounds Checker pass.  */\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_SET_PTR_BOUNDS, \"__bnd_set_ptr_bounds\", BT_FN_PTR_CONST_PTR_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_INIT_PTR_BOUNDS, \"__bnd_init_ptr_bounds\", BT_FN_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_NULL_PTR_BOUNDS, \"__bnd_null_ptr_bounds\", BT_FN_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_COPY_PTR_BOUNDS, \"__bnd_copy_ptr_bounds\", BT_FN_PTR_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_NARROW_PTR_BOUNDS, \"__bnd_narrow_ptr_bounds\", BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_STORE_PTR_BOUNDS, \"__bnd_store_ptr_bounds\", BT_FN_VOID_PTRPTR_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_LBOUNDS, \"__bnd_chk_ptr_lbounds\", BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_UBOUNDS, \"__bnd_chk_ptr_ubounds\", BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_BOUNDS, \"__bnd_chk_ptr_bounds\", BT_FN_VOID_CONST_PTR_SIZE, ATTR_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_GET_PTR_LBOUND, \"__bnd_get_ptr_lbound\", BT_FN_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_GET_PTR_UBOUND, \"__bnd_get_ptr_ubound\", BT_FN_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+/* Pointer Bounds Checker specific versions of string functions.  */\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOBND, \"chkp_memcpy_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOCHK, \"chkp_memcpy_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK, \"chkp_memcpy_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOBND, \"chkp_memmove_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOCHK, \"chkp_memmove_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOBND_NOCHK, \"chkp_memmove_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOBND, \"chkp_mempcpy_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOCHK, \"chkp_mempcpy_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK, \"chkp_mempcpy_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOBND, \"chkp_memset_nobnd\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOCHK, \"chkp_memset_nochk\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOBND_NOCHK, \"chkp_memset_nobnd_nochk\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)"}, {"sha": "4e07d705001ce1c0324066f7aa803fabe8804e55", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;           H\n-;;;           h j            w  z\n+;;;           h j               z\n \n ;; Integer register constraints.\n ;; It is not necessary to define 'r' here.\n@@ -94,6 +94,9 @@\n (define_register_constraint \"v\" \"TARGET_SSE ? ALL_SSE_REGS : NO_REGS\"\n  \"Any EVEX encodable SSE register (@code{%xmm0-%xmm31}).\")\n \n+(define_register_constraint \"w\" \"TARGET_MPX ? BND_REGS : NO_REGS\"\n+ \"@internal Any bound register.\")\n+\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  z\tFirst SSE register.\n ;;  i\tSSE2 inter-unit moves to SSE register enabled\n@@ -253,6 +256,8 @@\n ;; T prefix is used for different address constraints\n ;;   v - VSIB address\n ;;   s - address with no segment register\n+;;   i - address with no index and no rip\n+;;   b - address with no base and no rip\n \n (define_address_constraint \"Tv\"\n   \"VSIB address operand\"\n@@ -261,3 +266,11 @@\n (define_address_constraint \"Ts\"\n   \"Address operand without segment register\"\n   (match_operand 0 \"address_no_seg_operand\"))\n+\n+(define_address_constraint \"Ti\"\n+  \"MPX address operand without index\"\n+  (match_operand 0 \"address_mpx_no_index_operand\"))\n+\n+(define_address_constraint \"Tb\"\n+  \"MPX address operand without base\"\n+  (match_operand 0 \"address_mpx_no_base_operand\"))"}, {"sha": "864d0ea23a7bd0074acb8470c433def11b3b659b", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -47,6 +47,7 @@ DEF_PRIMITIVE_TYPE (UCHAR, unsigned_char_type_node)\n DEF_PRIMITIVE_TYPE (QI, char_type_node)\n DEF_PRIMITIVE_TYPE (HI, intHI_type_node)\n DEF_PRIMITIVE_TYPE (SI, intSI_type_node)\n+DEF_PRIMITIVE_TYPE (BND, pointer_bounds_type_node)\n # ??? Logically this should be intDI_type_node, but that maps to \"long\"\n # with 64-bit, and that's not how the emmintrin.h is written.  Again, \n # changing this would change name mangling.\n@@ -61,6 +62,7 @@ DEF_PRIMITIVE_TYPE (USHORT, short_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (INT, integer_type_node)\n DEF_PRIMITIVE_TYPE (UINT, unsigned_type_node)\n DEF_PRIMITIVE_TYPE (UNSIGNED, unsigned_type_node)\n+DEF_PRIMITIVE_TYPE (ULONG, long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (LONGLONG, long_long_integer_type_node)\n DEF_PRIMITIVE_TYPE (ULONGLONG, long_long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (UINT8, unsigned_char_type_node)\n@@ -1242,3 +1244,15 @@ DEF_FUNCTION_TYPE_ALIAS (V2DI_FTYPE_V2DI_V2DI, TF)\n DEF_FUNCTION_TYPE_ALIAS (V4SF_FTYPE_V4SF_V4SF, TF)\n DEF_FUNCTION_TYPE_ALIAS (V4SI_FTYPE_V4SI_V4SI, TF)\n DEF_FUNCTION_TYPE_ALIAS (V8HI_FTYPE_V8HI_V8HI, TF)\n+\n+# MPX builtins\n+DEF_FUNCTION_TYPE (BND, PCVOID, ULONG)\n+DEF_FUNCTION_TYPE (VOID, PCVOID, BND)\n+DEF_FUNCTION_TYPE (VOID, PCVOID, BND, PCVOID)\n+DEF_FUNCTION_TYPE (BND, PCVOID, PCVOID)\n+DEF_FUNCTION_TYPE (BND, PCVOID)\n+DEF_FUNCTION_TYPE (BND, BND, BND)\n+DEF_FUNCTION_TYPE (PVOID, PVOID, PVOID, ULONG)\n+DEF_FUNCTION_TYPE (PVOID, PCVOID, BND, ULONG)\n+DEF_FUNCTION_TYPE (ULONG, VOID)\n+DEF_FUNCTION_TYPE (PVOID, BND)"}, {"sha": "0a0775dbbccc08bc43774a6b1aeb26cd10a3ef3f", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -405,6 +405,8 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__XSAVEC__\");\n   if (isa_flag & OPTION_MASK_ISA_XSAVES)\n     def_or_undef (parse_in, \"__XSAVES__\");\n+  if (isa_flag & OPTION_MASK_ISA_MPX)\n+    def_or_undef (parse_in, \"__MPX__\");\n }\n \n \f"}, {"sha": "37752386cb559959d57a501d57ba5f39a90422da", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -90,6 +90,9 @@ VECTOR_MODE (INT, QI, 12);    /*                  V12QI */\n VECTOR_MODE (INT, QI, 14);    /*                  V14QI */\n VECTOR_MODE (INT, HI, 6);     /*                   V6HI */\n \n+POINTER_BOUNDS_MODE (BND32, 8);\n+POINTER_BOUNDS_MODE (BND64, 16);\n+\n INT_MODE (OI, 32);\n INT_MODE (XI, 64);\n "}, {"sha": "d14a107e8c282f44cd5a76ae3ae0c636ba756dc9", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -232,6 +232,8 @@ extern void ix86_expand_sse2_mulv4si3 (rtx, rtx, rtx);\n extern void ix86_expand_sse2_mulvxdi3 (rtx, rtx, rtx);\n extern void ix86_expand_sse2_abs (rtx, rtx);\n \n+extern bool ix86_bnd_prefixed_insn_p (rtx);\n+\n /* In i386-c.c  */\n extern void ix86_target_macros (void);\n extern void ix86_register_pragmas (void);"}, {"sha": "8f03aa25e1e794dfc1a2022ac9c1cd556ac862ba", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1086, "deletions": 20, "changes": 1106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -99,6 +99,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"shrink-wrap.h\"\n #include \"builtins.h\"\n #include \"rtl-iter.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n static rtx legitimize_dllimport_symbol (rtx, bool);\n static rtx legitimize_pe_coff_extern_decl (rtx, bool);\n@@ -2145,6 +2148,8 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* Mask registers.  */\n   MASK_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n   MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n+  /* MPX bound registers */\n+  BND_REGS, BND_REGS, BND_REGS, BND_REGS,\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -2161,6 +2166,7 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n+  101, 102, 103, 104,\t\t\t/* bound registers */\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -2177,6 +2183,7 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n   75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n   118, 119, 120, 121, 122, 123, 124, 125, /* Mask registers */\n+  126, 127, 128, 129,\t\t\t/* bound registers */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -2245,6 +2252,7 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n+  101, 102, 103, 104,\t\t\t/* bound registers */\n };\n \n /* Define parameter passing and return registers.  */\n@@ -2646,6 +2654,7 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mclflushopt\",   OPTION_MASK_ISA_CLFLUSHOPT },\n     { \"-mxsavec\",\tOPTION_MASK_ISA_XSAVEC },\n     { \"-mxsaves\",\tOPTION_MASK_ISA_XSAVES },\n+    { \"-mmpx\",          OPTION_MASK_ISA_MPX },\n   };\n \n   /* Flag options.  */\n@@ -3135,6 +3144,7 @@ ix86_option_override_internal (bool main_args_p,\n #define PTA_AVX512ER\t\t(HOST_WIDE_INT_1 << 41)\n #define PTA_AVX512PF\t\t(HOST_WIDE_INT_1 << 42)\n #define PTA_AVX512CD\t\t(HOST_WIDE_INT_1 << 43)\n+#define PTA_MPX\t\t\t(HOST_WIDE_INT_1 << 44)\n #define PTA_SHA\t\t\t(HOST_WIDE_INT_1 << 45)\n #define PTA_PREFETCHWT1\t\t(HOST_WIDE_INT_1 << 46)\n #define PTA_CLFLUSHOPT\t\t(HOST_WIDE_INT_1 << 47)\n@@ -3720,12 +3730,21 @@ ix86_option_override_internal (bool main_args_p,\n \tif (processor_alias_table[i].flags & PTA_AVX512VL\n \t    && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512VL))\n \t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512VL;\n+        if (processor_alias_table[i].flags & PTA_MPX\n+            && !(opts->x_ix86_isa_flags_explicit & OPTION_MASK_ISA_MPX))\n+          opts->x_ix86_isa_flags |= OPTION_MASK_ISA_MPX;\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n \n \tbreak;\n       }\n \n+  if (TARGET_X32 && (opts->x_ix86_isa_flags & OPTION_MASK_ISA_MPX))\n+    error (\"Intel MPX does not support x32\");\n+\n+  if (TARGET_X32 && (ix86_isa_flags & OPTION_MASK_ISA_MPX))\n+    error (\"Intel MPX does not support x32\");\n+\n   if (!strcmp (opts->x_ix86_arch_string, \"generic\"))\n     error (\"generic CPU can be used only for %stune=%s %s\",\n \t   prefix, suffix, sw);\n@@ -4388,6 +4407,11 @@ ix86_conditional_register_usage (void)\n       for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n     }\n+\n+  /* If MPX is disabled, squash the registers.  */\n+  if (! TARGET_MPX)\n+    for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n+      fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n }\n \n \f\n@@ -6286,10 +6310,15 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n      FIXME: once typesytem is fixed, we won't need this code anymore.  */\n   if (i && i->local && i->can_change_signature)\n     fntype = TREE_TYPE (fndecl);\n+  cum->stdarg = stdarg_p (fntype);\n   cum->maybe_vaarg = (fntype\n \t\t      ? (!prototype_p (fntype) || stdarg_p (fntype))\n \t\t      : !libname);\n \n+  cum->bnd_regno = FIRST_BND_REG;\n+  cum->bnds_in_bt = 0;\n+  cum->force_bnd_pass = 0;\n+\n   if (!TARGET_64BIT)\n     {\n       /* If there are variable arguments, then we won't pass anything\n@@ -7224,13 +7253,17 @@ construct_container (machine_mode mode, machine_mode orig_mode,\n \n /* Update the data in CUM to advance over an argument of mode MODE\n    and data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.)  */\n+   may not be available.)\n \n-static void\n+   Return a number of integer regsiters advanced over.  */\n+\n+static int\n function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t const_tree type, HOST_WIDE_INT bytes,\n \t\t\t HOST_WIDE_INT words)\n {\n+  int res = 0;\n+\n   switch (mode)\n     {\n     default:\n@@ -7248,7 +7281,8 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n       cum->words += words;\n       cum->nregs -= words;\n       cum->regno += words;\n-\n+      if (cum->nregs >= 0)\n+\tres = words;\n       if (cum->nregs <= 0)\n \t{\n \t  cum->nregs = 0;\n@@ -7319,9 +7353,11 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t}\n       break;\n     }\n+\n+  return res;\n }\n \n-static void\n+static int\n function_arg_advance_64 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t const_tree type, HOST_WIDE_INT words, bool named)\n {\n@@ -7330,7 +7366,7 @@ function_arg_advance_64 (CUMULATIVE_ARGS *cum, machine_mode mode,\n   /* Unnamed 512 and 256bit vector mode parameters are passed on stack.  */\n   if (!named && (VALID_AVX512F_REG_MODE (mode)\n \t\t || VALID_AVX256_REG_MODE (mode)))\n-    return;\n+    return 0;\n \n   if (!examine_argument (mode, type, 0, &int_nregs, &sse_nregs)\n       && sse_nregs <= cum->sse_nregs && int_nregs <= cum->nregs)\n@@ -7339,16 +7375,18 @@ function_arg_advance_64 (CUMULATIVE_ARGS *cum, machine_mode mode,\n       cum->sse_nregs -= sse_nregs;\n       cum->regno += int_nregs;\n       cum->sse_regno += sse_nregs;\n+      return int_nregs;\n     }\n   else\n     {\n       int align = ix86_function_arg_boundary (mode, type) / BITS_PER_WORD;\n       cum->words = (cum->words + align - 1) & ~(align - 1);\n       cum->words += words;\n+      return 0;\n     }\n }\n \n-static void\n+static int\n function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n \t\t\t    HOST_WIDE_INT words)\n {\n@@ -7360,7 +7398,9 @@ function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n     {\n       cum->nregs -= 1;\n       cum->regno += 1;\n+      return 1;\n     }\n+  return 0;\n }\n \n /* Update the data in CUM to advance over an argument of mode MODE and\n@@ -7373,6 +7413,7 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   HOST_WIDE_INT bytes, words;\n+  int nregs;\n \n   if (mode == BLKmode)\n     bytes = int_size_in_bytes (type);\n@@ -7383,12 +7424,51 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   if (type)\n     mode = type_natural_mode (type, NULL, false);\n \n+  if ((type && POINTER_BOUNDS_TYPE_P (type))\n+      || POINTER_BOUNDS_MODE_P (mode))\n+    {\n+      /* If we pass bounds in BT then just update remained bounds count.  */\n+      if (cum->bnds_in_bt)\n+\t{\n+\t  cum->bnds_in_bt--;\n+\t  return;\n+\t}\n+\n+      /* Update remained number of bounds to force.  */\n+      if (cum->force_bnd_pass)\n+\tcum->force_bnd_pass--;\n+\n+      cum->bnd_regno++;\n+\n+      return;\n+    }\n+\n+  /* The first arg not going to Bounds Tables resets this counter.  */\n+  cum->bnds_in_bt = 0;\n+  /* For unnamed args we always pass bounds to avoid bounds mess when\n+     passed and received types do not match.  If bounds do not follow\n+     unnamed arg, still pretend required number of bounds were passed.  */\n+  if (cum->force_bnd_pass)\n+    {\n+      cum->bnd_regno += cum->force_bnd_pass;\n+      cum->force_bnd_pass = 0;\n+    }\n+\n   if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)\n-    function_arg_advance_ms_64 (cum, bytes, words);\n+    nregs = function_arg_advance_ms_64 (cum, bytes, words);\n   else if (TARGET_64BIT)\n-    function_arg_advance_64 (cum, mode, type, words, named);\n+    nregs = function_arg_advance_64 (cum, mode, type, words, named);\n   else\n-    function_arg_advance_32 (cum, mode, type, bytes, words);\n+    nregs = function_arg_advance_32 (cum, mode, type, bytes, words);\n+\n+  /* For stdarg we expect bounds to be passed for each value passed\n+     in register.  */\n+  if (cum->stdarg)\n+    cum->force_bnd_pass = nregs;\n+  /* For pointers passed in memory we expect bounds passed in Bounds\n+     Table.  */\n+  if (!nregs)\n+    cum->bnds_in_bt = chkp_type_bounds_count (type);\n }\n \n /* Define where to put the arguments to a function.\n@@ -7623,6 +7703,23 @@ ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n   HOST_WIDE_INT bytes, words;\n   rtx arg;\n \n+  /* All pointer bounds argumntas are handled separately here.  */\n+  if ((type && POINTER_BOUNDS_TYPE_P (type))\n+      || POINTER_BOUNDS_MODE_P (mode))\n+    {\n+      /* Return NULL if bounds are forced to go in Bounds Table.  */\n+      if (cum->bnds_in_bt)\n+\targ = NULL;\n+      /* Return the next available bound reg if any.  */\n+      else if (cum->bnd_regno <= LAST_BND_REG)\n+\targ = gen_rtx_REG (BNDmode, cum->bnd_regno);\n+      /* Return the next special slot number otherwise.  */\n+      else\n+\targ = GEN_INT (cum->bnd_regno - LAST_BND_REG - 1);\n+\n+      return arg;\n+    }\n+\n   if (mode == BLKmode)\n     bytes = int_size_in_bytes (type);\n   else\n@@ -7896,6 +7993,9 @@ ix86_function_value_regno_p (const unsigned int regno)\n     case SI_REG:\n       return TARGET_64BIT && ix86_abi != MS_ABI;\n \n+    case FIRST_BND_REG:\n+      return chkp_function_instrumented_p (current_function_decl);\n+\n       /* Complex values are returned in %st(0)/%st(1) pair.  */\n     case ST0_REG:\n     case ST1_REG:\n@@ -8072,7 +8172,10 @@ ix86_function_value_1 (const_tree valtype, const_tree fntype_or_decl,\n     fn = fntype_or_decl;\n   fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n \n-  if (TARGET_64BIT && ix86_function_type_abi (fntype) == MS_ABI)\n+  if ((valtype && POINTER_BOUNDS_TYPE_P (valtype))\n+      || POINTER_BOUNDS_MODE_P (mode))\n+    return gen_rtx_REG (BNDmode, FIRST_BND_REG);\n+  else if (TARGET_64BIT && ix86_function_type_abi (fntype) == MS_ABI)\n     return function_value_ms_64 (orig_mode, mode, valtype);\n   else if (TARGET_64BIT)\n     return function_value_64 (orig_mode, mode, valtype);\n@@ -8090,6 +8193,57 @@ ix86_function_value (const_tree valtype, const_tree fntype_or_decl, bool)\n   return ix86_function_value_1 (valtype, fntype_or_decl, orig_mode, mode);\n }\n \n+/*  Return an RTX representing a place where a function returns\n+    or recieves pointer bounds or NULL if no bounds are returned.\n+\n+    VALTYPE is a data type of a value returned by the function.\n+\n+    FN_DECL_OR_TYPE is a tree node representing FUNCTION_DECL\n+    or FUNCTION_TYPE of the function.\n+\n+    If OUTGOING is false, return a place in which the caller will\n+    see the return value.  Otherwise, return a place where a\n+    function returns a value.  */\n+\n+static rtx\n+ix86_function_value_bounds (const_tree valtype,\n+\t\t\t    const_tree fntype_or_decl ATTRIBUTE_UNUSED,\n+\t\t\t    bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  rtx res = NULL_RTX;\n+\n+  if (BOUNDED_TYPE_P (valtype))\n+    res = gen_rtx_REG (BNDmode, FIRST_BND_REG);\n+  else if (chkp_type_has_pointer (valtype))\n+    {\n+      bitmap slots;\n+      rtx bounds[2];\n+      bitmap_iterator bi;\n+      unsigned i, bnd_no = 0;\n+\n+      bitmap_obstack_initialize (NULL);\n+      slots = BITMAP_ALLOC (NULL);\n+      chkp_find_bound_slots (valtype, slots);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (slots, 0, i, bi)\n+\t{\n+\t  rtx reg = gen_rtx_REG (BNDmode, FIRST_BND_REG + bnd_no);\n+\t  rtx offs = GEN_INT (i * POINTER_SIZE / BITS_PER_UNIT);\n+\t  gcc_assert (bnd_no < 2);\n+\t  bounds[bnd_no++] = gen_rtx_EXPR_LIST (VOIDmode, reg, offs);\n+\t}\n+\n+      res = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (bnd_no, bounds));\n+\n+      BITMAP_FREE (slots);\n+      bitmap_obstack_release (NULL);\n+    }\n+  else\n+    res = NULL_RTX;\n+\n+  return res;\n+}\n+\n /* Pointer function arguments and return values are promoted to\n    word_mode.  */\n \n@@ -8136,6 +8290,9 @@ ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   const machine_mode mode = type_natural_mode (type, NULL, true);\n   HOST_WIDE_INT size;\n \n+  if (POINTER_BOUNDS_TYPE_P (type))\n+    return false;\n+\n   if (TARGET_64BIT)\n     {\n       if (ix86_function_type_abi (fntype) == MS_ABI)\n@@ -8451,6 +8608,71 @@ ix86_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n     setup_incoming_varargs_64 (&next_cum);\n }\n \n+static void\n+ix86_setup_incoming_vararg_bounds (cumulative_args_t cum_v,\n+\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   tree type,\n+\t\t\t\t   int *pretend_size ATTRIBUTE_UNUSED,\n+\t\t\t\t   int no_rtl)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  CUMULATIVE_ARGS next_cum;\n+  tree fntype;\n+  rtx save_area;\n+  int bnd_reg, i, max;\n+\n+  gcc_assert (!no_rtl);\n+\n+  /* Do nothing if we use plain pointer to argument area.  */\n+  if (!TARGET_64BIT || cum->call_abi == MS_ABI)\n+    return;\n+\n+  fntype = TREE_TYPE (current_function_decl);\n+\n+  /* For varargs, we do not want to skip the dummy va_dcl argument.\n+     For stdargs, we do want to skip the last named argument.  */\n+  next_cum = *cum;\n+  if (stdarg_p (fntype))\n+    ix86_function_arg_advance (pack_cumulative_args (&next_cum), mode, type,\n+\t\t\t       true);\n+  save_area = frame_pointer_rtx;\n+\n+  max = cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n+  if (max > X86_64_REGPARM_MAX)\n+    max = X86_64_REGPARM_MAX;\n+\n+  bnd_reg = cum->bnd_regno + cum->force_bnd_pass;\n+  if (chkp_function_instrumented_p (current_function_decl))\n+    for (i = cum->regno; i < max; i++)\n+      {\n+\trtx addr = plus_constant (Pmode, save_area, i * UNITS_PER_WORD);\n+\trtx reg = gen_rtx_REG (DImode,\n+\t\t\t       x86_64_int_parameter_registers[i]);\n+\trtx ptr = reg;\n+\trtx bounds;\n+\n+\tif (bnd_reg <= LAST_BND_REG)\n+\t  bounds = gen_rtx_REG (BNDmode, bnd_reg);\n+\telse\n+\t  {\n+\t    rtx ldx_addr =\n+\t      plus_constant (Pmode, arg_pointer_rtx,\n+\t\t\t     (LAST_BND_REG - bnd_reg) * GET_MODE_SIZE (Pmode));\n+\t    bounds = gen_reg_rtx (BNDmode);\n+\t    emit_insn (BNDmode == BND64mode\n+\t\t       ? gen_bnd64_ldx (bounds, ldx_addr, ptr)\n+\t\t       : gen_bnd32_ldx (bounds, ldx_addr, ptr));\n+\t  }\n+\n+\temit_insn (BNDmode == BND64mode\n+\t\t   ? gen_bnd64_stx (addr, ptr, bounds)\n+\t\t   : gen_bnd32_stx (addr, ptr, bounds));\n+\n+\tbnd_reg++;\n+      }\n+}\n+\n+\n /* Checks if TYPE is of kind va_list char *.  */\n \n static bool\n@@ -8525,6 +8747,13 @@ ix86_va_start (tree valist, rtx nextarg)\n \t\t\t       crtl->args.arg_offset_rtx,\n \t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  convert_move (va_r, next, 0);\n+\n+\t  /* Store zero bounds for va_list.  */\n+\t  if (chkp_function_instrumented_p (current_function_decl))\n+\t    chkp_expand_bounds_reset_for_mem (valist,\n+\t\t\t\t\t      make_tree (TREE_TYPE (valist),\n+\t\t\t\t\t\t\t next));\n+\n \t}\n       return;\n     }\n@@ -8578,6 +8807,11 @@ ix86_va_start (tree valist, rtx nextarg)\n   t = make_tree (type, ovf_rtx);\n   if (words != 0)\n     t = fold_build_pointer_plus_hwi (t, words * UNITS_PER_WORD);\n+\n+  /* Store zero bounds for overflow area pointer.  */\n+  if (chkp_function_instrumented_p (current_function_decl))\n+    chkp_expand_bounds_reset_for_mem (ovf, t);\n+\n   t = build2 (MODIFY_EXPR, type, ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -8590,6 +8824,11 @@ ix86_va_start (tree valist, rtx nextarg)\n       t = make_tree (type, frame_pointer_rtx);\n       if (!ix86_varargs_gpr_size)\n \tt = fold_build_pointer_plus_hwi (t, -8 * X86_64_REGPARM_MAX);\n+\n+      /* Store zero bounds for save area pointer.  */\n+      if (chkp_function_instrumented_p (current_function_decl))\n+\tchkp_expand_bounds_reset_for_mem (sav, t);\n+\n       t = build2 (MODIFY_EXPR, type, sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -9343,7 +9582,7 @@ ix86_code_end (void)\n       xops[0] = gen_rtx_REG (Pmode, regno);\n       xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n       output_asm_insn (\"mov%z0\\t{%1, %0|%0, %1}\", xops);\n-      fputs (\"\\tret\\n\", asm_out_file);\n+      output_asm_insn (\"%!ret\", NULL);\n       final_end_function ();\n       init_insn_lengths ();\n       free_after_compilation (cfun);\n@@ -9401,7 +9640,7 @@ output_set_got (rtx dest, rtx label)\n \n       xops[2] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n       xops[2] = gen_rtx_MEM (QImode, xops[2]);\n-      output_asm_insn (\"call\\t%X2\", xops);\n+      output_asm_insn (\"%!call\\t%X2\", xops);\n \n #if TARGET_MACHO\n       /* Output the Mach-O \"canonical\" pic base label name (\"Lxx$pb\") here.\n@@ -12584,6 +12823,10 @@ darwin_local_data_pic (rtx disp)\n static bool\n ix86_legitimate_constant_p (machine_mode, rtx x)\n {\n+  /* Pointer bounds constants are not valid.  */\n+  if (POINTER_BOUNDS_MODE_P (GET_MODE (x)))\n+    return false;\n+\n   switch (GET_CODE (x))\n     {\n     case CONST:\n@@ -14833,7 +15076,7 @@ print_reg (rtx x, int code, FILE *file)\n     case 8:\n     case 4:\n     case 12:\n-      if (! ANY_FP_REG_P (x) && ! ANY_MASK_REG_P (x))\n+      if (! ANY_FP_REG_P (x) && ! ANY_MASK_REG_P (x) && ! ANY_BND_REG_P (x))\n \tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n@@ -14922,6 +15165,7 @@ print_reg (rtx x, int code, FILE *file)\n    ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n    @ -- print a segment register of thread base pointer load\n    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n+   ! -- print MPX prefix for jxx/call/ret instructions if required.\n  */\n \n void\n@@ -15464,6 +15708,11 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    fputs (\"addr32 \", file);\n \t  return;\n \n+\tcase '!':\n+\t  if (ix86_bnd_prefixed_insn_p (current_output_insn))\n+\t    fputs (\"bnd \", file);\n+\t  return;\n+\n \tdefault:\n \t    output_operand_lossage (\"invalid operand code '%c'\", code);\n \t}\n@@ -15606,7 +15855,7 @@ static bool\n ix86_print_operand_punct_valid_p (unsigned char code)\n {\n   return (code == '@' || code == '*' || code == '+' || code == '&'\n-\t  || code == ';' || code == '~' || code == '^');\n+\t  || code == ';' || code == '~' || code == '^' || code == '!');\n }\n \f\n /* Print a memory operand whose address is ADDR.  */\n@@ -15636,6 +15885,25 @@ ix86_print_operand_address (FILE *file, rtx addr)\n       ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n       code = 'q';\n     }\n+  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDMK_ADDR)\n+    {\n+      ok = ix86_decompose_address (XVECEXP (addr, 0, 1), &parts);\n+      gcc_assert (parts.base == NULL_RTX || parts.index == NULL_RTX);\n+      if (parts.base != NULL_RTX)\n+\t{\n+\t  parts.index = parts.base;\n+\t  parts.scale = 1;\n+\t}\n+      parts.base = XVECEXP (addr, 0, 0);\n+      addr = XVECEXP (addr, 0, 0);\n+    }\n+  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDLDX_ADDR)\n+    {\n+      ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n+      gcc_assert (parts.index == NULL_RTX);\n+      parts.index = XVECEXP (addr, 0, 1);\n+      addr = XVECEXP (addr, 0, 0);\n+    }\n   else\n     ok = ix86_decompose_address (addr, &parts);\n \n@@ -25151,8 +25419,21 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     }\n \n   call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n+\n   if (retval)\n-    call = gen_rtx_SET (VOIDmode, retval, call);\n+    {\n+      /* We should add bounds as destination register in case\n+\t pointer with bounds may be returned.  */\n+      if (TARGET_MPX && SCALAR_INT_MODE_P (GET_MODE (retval)))\n+\t{\n+\t  rtx b0 = gen_rtx_REG (BND64mode, FIRST_BND_REG);\n+\t  rtx b1 = gen_rtx_REG (BND64mode, FIRST_BND_REG + 1);\n+\t  retval = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (3, retval, b0, b1));\n+\t  chkp_put_regs_to_expr_list (retval);\n+\t}\n+\n+      call = gen_rtx_SET (VOIDmode, retval, call);\n+    }\n   vec[vec_len++] = call;\n \n   if (pop)\n@@ -25199,13 +25480,13 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n   if (SIBLING_CALL_P (insn))\n     {\n       if (direct_p)\n-\txasm = \"jmp\\t%P0\";\n+\txasm = \"%!jmp\\t%P0\";\n       /* SEH epilogue detection requires the indirect branch case\n \t to include REX.W.  */\n       else if (TARGET_SEH)\n-\txasm = \"rex.W jmp %A0\";\n+\txasm = \"%!rex.W jmp %A0\";\n       else\n-\txasm = \"jmp\\t%A0\";\n+\txasm = \"%!jmp\\t%A0\";\n \n       output_asm_insn (xasm, &call_op);\n       return \"\";\n@@ -25242,9 +25523,9 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n     }\n \n   if (direct_p)\n-    xasm = \"call\\t%P0\";\n+    xasm = \"%!call\\t%P0\";\n   else\n-    xasm = \"call\\t%A0\";\n+    xasm = \"%!call\\t%A0\";\n \n   output_asm_insn (xasm, &call_op);\n \n@@ -29959,6 +30240,19 @@ enum ix86_builtins\n   IX86_BUILTIN_XABORT,\n   IX86_BUILTIN_XTEST,\n \n+  /* MPX */\n+  IX86_BUILTIN_BNDMK,\n+  IX86_BUILTIN_BNDSTX,\n+  IX86_BUILTIN_BNDLDX,\n+  IX86_BUILTIN_BNDCL,\n+  IX86_BUILTIN_BNDCU,\n+  IX86_BUILTIN_BNDRET,\n+  IX86_BUILTIN_BNDNARROW,\n+  IX86_BUILTIN_BNDINT,\n+  IX86_BUILTIN_SIZEOF,\n+  IX86_BUILTIN_BNDLOWER,\n+  IX86_BUILTIN_BNDUPPER,\n+\n   /* BMI instructions.  */\n   IX86_BUILTIN_BEXTR32,\n   IX86_BUILTIN_BEXTR64,\n@@ -30036,6 +30330,8 @@ struct builtin_isa {\n   enum ix86_builtin_func_type tcode; /* type to use in the declaration */\n   HOST_WIDE_INT isa;\t\t/* isa_flags this builtin is defined for */\n   bool const_p;\t\t\t/* true if the declaration is constant */\n+  bool leaf_p;\t\t\t/* true if the declaration has leaf attribute */\n+  bool nothrow_p;\t\t/* true if the declaration has nothrow attribute */\n   bool set_and_not_built_p;\n };\n \n@@ -30087,6 +30383,8 @@ def_builtin (HOST_WIDE_INT mask, const char *name,\n \t  ix86_builtins[(int) code] = NULL_TREE;\n \t  ix86_builtins_isa[(int) code].tcode = tcode;\n \t  ix86_builtins_isa[(int) code].name = name;\n+\t  ix86_builtins_isa[(int) code].leaf_p = false;\n+\t  ix86_builtins_isa[(int) code].nothrow_p = false;\n \t  ix86_builtins_isa[(int) code].const_p = false;\n \t  ix86_builtins_isa[(int) code].set_and_not_built_p = true;\n \t}\n@@ -30137,6 +30435,11 @@ ix86_add_new_builtins (HOST_WIDE_INT isa)\n \t  ix86_builtins[i] = decl;\n \t  if (ix86_builtins_isa[i].const_p)\n \t    TREE_READONLY (decl) = 1;\n+\t  if (ix86_builtins_isa[i].leaf_p)\n+\t    DECL_ATTRIBUTES (decl) = build_tree_list (get_identifier (\"leaf\"),\n+\t\t\t\t\t\t      NULL_TREE);\n+\t  if (ix86_builtins_isa[i].nothrow_p)\n+\t    TREE_NOTHROW (decl) = 1;\n \t}\n     }\n }\n@@ -32558,6 +32861,27 @@ static const struct builtin_description bdesc_round_args[] =\n   { OPTION_MASK_ISA_AVX512DQ, CODE_FOR_avx512dq_rangepv8df_mask_round, \"__builtin_ia32_rangepd512_mask\", IX86_BUILTIN_RANGEPD512, UNKNOWN, (int) V8DF_FTYPE_V8DF_V8DF_INT_V8DF_QI_INT },\n };\n \n+/* Bultins for MPX.  */\n+static const struct builtin_description bdesc_mpx[] =\n+{\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndstx\", IX86_BUILTIN_BNDSTX, UNKNOWN, (int) VOID_FTYPE_PCVOID_BND_PCVOID },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndcl\", IX86_BUILTIN_BNDCL, UNKNOWN, (int) VOID_FTYPE_PCVOID_BND },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndcu\", IX86_BUILTIN_BNDCU, UNKNOWN, (int) VOID_FTYPE_PCVOID_BND },\n+};\n+\n+/* Const builtins for MPX.  */\n+static const struct builtin_description bdesc_mpx_const[] =\n+{\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndmk\", IX86_BUILTIN_BNDMK, UNKNOWN, (int) BND_FTYPE_PCVOID_ULONG },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndldx\", IX86_BUILTIN_BNDLDX, UNKNOWN, (int) BND_FTYPE_PCVOID_PCVOID },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_narrow_bounds\", IX86_BUILTIN_BNDNARROW, UNKNOWN, (int) PVOID_FTYPE_PCVOID_BND_ULONG },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndint\", IX86_BUILTIN_BNDINT, UNKNOWN, (int) BND_FTYPE_BND_BND },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_sizeof\", IX86_BUILTIN_SIZEOF, UNKNOWN, (int) ULONG_FTYPE_VOID },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndlower\", IX86_BUILTIN_BNDLOWER, UNKNOWN, (int) PVOID_FTYPE_BND },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndupper\", IX86_BUILTIN_BNDUPPER, UNKNOWN, (int) PVOID_FTYPE_BND },\n+  { OPTION_MASK_ISA_MPX, (enum insn_code)0, \"__builtin_ia32_bndret\", IX86_BUILTIN_BNDRET, UNKNOWN, (int) BND_FTYPE_PCVOID },\n+};\n+\n /* FMA4 and XOP.  */\n #define MULTI_ARG_4_DF2_DI_I\tV2DF_FTYPE_V2DF_V2DF_V2DI_INT\n #define MULTI_ARG_4_DF2_DI_I1\tV4DF_FTYPE_V4DF_V4DF_V4DI_INT\n@@ -33559,6 +33883,67 @@ ix86_init_mmx_sse_builtins (void)\n     }\n }\n \n+static void\n+ix86_init_mpx_builtins ()\n+{\n+  const struct builtin_description * d;\n+  enum ix86_builtin_func_type ftype;\n+  tree decl;\n+  size_t i;\n+\n+  for (i = 0, d = bdesc_mpx;\n+       i < ARRAY_SIZE (bdesc_mpx);\n+       i++, d++)\n+    {\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      ftype = (enum ix86_builtin_func_type) d->flag;\n+      decl = def_builtin (d->mask, d->name, ftype, d->code);\n+\n+      /* With no leaf and nothrow flags for MPX builtins\n+\t abnormal edges may follow its call when setjmp\n+\t presents in the function.  Since we may have a lot\n+\t of MPX builtins calls it causes lots of useless\n+\t edges and enormous PHI nodes.  To avoid this we mark\n+\t MPX builtins as leaf and nothrow.  */\n+      if (decl)\n+\t{\n+\t  DECL_ATTRIBUTES (decl) = build_tree_list (get_identifier (\"leaf\"),\n+\t\t\t\t\t\t    NULL_TREE);\n+\t  TREE_NOTHROW (decl) = 1;\n+\t}\n+      else\n+\t{\n+\t  ix86_builtins_isa[(int)d->code].leaf_p = true;\n+\t  ix86_builtins_isa[(int)d->code].nothrow_p = true;\n+\t}\n+    }\n+\n+  for (i = 0, d = bdesc_mpx_const;\n+       i < ARRAY_SIZE (bdesc_mpx_const);\n+       i++, d++)\n+    {\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      ftype = (enum ix86_builtin_func_type) d->flag;\n+      decl = def_builtin_const (d->mask, d->name, ftype, d->code);\n+\n+      if (decl)\n+\t{\n+\t  DECL_ATTRIBUTES (decl) = build_tree_list (get_identifier (\"leaf\"),\n+\t\t\t\t\t\t    NULL_TREE);\n+\t  TREE_NOTHROW (decl) = 1;\n+\t}\n+      else\n+\t{\n+\t  ix86_builtins_isa[(int)d->code].leaf_p = true;\n+\t  ix86_builtins_isa[(int)d->code].nothrow_p = true;\n+\t}\n+    }\n+}\n+\n /* This adds a condition to the basic_block NEW_BB in function FUNCTION_DECL\n    to return a pointer to VERSION_DECL if the outcome of the expression\n    formed by PREDICATE_CHAIN is true.  This function will be called during\n@@ -35097,6 +35482,7 @@ ix86_init_builtins (void)\n \n   ix86_init_tm_builtins ();\n   ix86_init_mmx_sse_builtins ();\n+  ix86_init_mpx_builtins ();\n \n   if (TARGET_LP64)\n     ix86_init_builtins_va_builtins_abi ();\n@@ -37723,6 +38109,37 @@ ix86_expand_vec_set_builtin (tree exp)\n   return target;\n }\n \n+/* Emit conditional move of SRC to DST with condition\n+   OP1 CODE OP2.  */\n+static void\n+ix86_emit_cmove (rtx dst, rtx src, enum rtx_code code, rtx op1, rtx op2)\n+{\n+  rtx t;\n+\n+  if (TARGET_CMOVE)\n+    {\n+      t = ix86_expand_compare (code, op1, op2);\n+      emit_insn (gen_rtx_SET (VOIDmode, dst,\n+\t\t\t      gen_rtx_IF_THEN_ELSE (GET_MODE (dst), t,\n+\t\t\t\t\t\t    src, dst)));\n+    }\n+  else\n+    {\n+      rtx nomove = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (op1, op2, reverse_condition (code),\n+\t\t\t       const0_rtx, GET_MODE (op1), 1, nomove);\n+      emit_move_insn (dst, src);\n+      emit_label (nomove);\n+    }\n+}\n+\n+/* Choose max of DST and SRC and put it to DST.  */\n+static void\n+ix86_emit_move_max (rtx dst, rtx src)\n+{\n+  ix86_emit_cmove (dst, src, LTU, dst, src);\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -37788,6 +38205,343 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \n   switch (fcode)\n     {\n+    case IX86_BUILTIN_BNDMK:\n+      if (!target\n+\t  || GET_MODE (target) != BNDmode\n+\t  || !register_operand (target, BNDmode))\n+\ttarget = gen_reg_rtx (BNDmode);\n+\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+\n+      if (!register_operand (op0, Pmode))\n+\top0 = ix86_zero_extend_to_Pmode (op0);\n+      if (!register_operand (op1, Pmode))\n+\top1 = ix86_zero_extend_to_Pmode (op1);\n+\n+      /* Builtin arg1 is size of block but instruction op1 should\n+\t be (size - 1).  */\n+      op1 = expand_simple_binop (Pmode, PLUS, op1, constm1_rtx,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+\n+      emit_insn (BNDmode == BND64mode\n+                 ? gen_bnd64_mk (target, op0, op1)\n+                 : gen_bnd32_mk (target, op0, op1));\n+      return target;\n+\n+    case IX86_BUILTIN_BNDSTX:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n+\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+      op2 = expand_normal (arg2);\n+\n+      if (!register_operand (op0, Pmode))\n+\top0 = ix86_zero_extend_to_Pmode (op0);\n+      if (!register_operand (op1, BNDmode))\n+\top1 = copy_to_mode_reg (BNDmode, op1);\n+      if (!register_operand (op2, Pmode))\n+\top2 = ix86_zero_extend_to_Pmode (op2);\n+\n+      emit_insn (BNDmode == BND64mode\n+                 ? gen_bnd64_stx (op2, op0, op1)\n+                 : gen_bnd32_stx (op2, op0, op1));\n+      return 0;\n+\n+    case IX86_BUILTIN_BNDLDX:\n+      if (!target\n+\t  || GET_MODE (target) != BNDmode\n+\t  || !register_operand (target, BNDmode))\n+\ttarget = gen_reg_rtx (BNDmode);\n+\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+\n+      if (!register_operand (op0, Pmode))\n+\top0 = ix86_zero_extend_to_Pmode (op0);\n+      if (!register_operand (op1, Pmode))\n+\top1 = ix86_zero_extend_to_Pmode (op1);\n+\n+      emit_insn (BNDmode == BND64mode\n+\t\t ? gen_bnd64_ldx (target, op0, op1)\n+\t\t : gen_bnd32_ldx (target, op0, op1));\n+      return target;\n+\n+    case IX86_BUILTIN_BNDCL:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+\n+      if (!register_operand (op0, Pmode))\n+\top0 = ix86_zero_extend_to_Pmode (op0);\n+      if (!register_operand (op1, BNDmode))\n+\top1 = copy_to_mode_reg (BNDmode, op1);\n+\n+      emit_insn (BNDmode == BND64mode\n+                 ? gen_bnd64_cl (op1, op0)\n+                 : gen_bnd32_cl (op1, op0));\n+      return 0;\n+\n+    case IX86_BUILTIN_BNDCU:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+\n+      op0 = expand_normal (arg0);\n+      op1 = expand_normal (arg1);\n+\n+      if (!register_operand (op0, Pmode))\n+\top0 = ix86_zero_extend_to_Pmode (op0);\n+      if (!register_operand (op1, BNDmode))\n+\top1 = copy_to_mode_reg (BNDmode, op1);\n+\n+      emit_insn (BNDmode == BND64mode\n+                 ? gen_bnd64_cu (op1, op0)\n+                 : gen_bnd32_cu (op1, op0));\n+      return 0;\n+\n+    case IX86_BUILTIN_BNDRET:\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      gcc_assert (TREE_CODE (arg0) == SSA_NAME);\n+      target = chkp_get_rtl_bounds (arg0);\n+\n+      /* If no bounds were specified for returned value,\n+\t then use INIT bounds.  It usually happens when\n+\t some built-in function is expanded.  */\n+      if (!target)\n+\t{\n+\t  rtx t1 = gen_reg_rtx (Pmode);\n+\t  rtx t2 = gen_reg_rtx (Pmode);\n+\t  target = gen_reg_rtx (BNDmode);\n+\t  emit_move_insn (t1, const0_rtx);\n+\t  emit_move_insn (t2, constm1_rtx);\n+\t  emit_insn (BNDmode == BND64mode\n+\t\t     ? gen_bnd64_mk (target, t1, t2)\n+\t\t     : gen_bnd32_mk (target, t1, t2));\n+\t}\n+\n+      gcc_assert (target && REG_P (target));\n+      return target;\n+\n+    case IX86_BUILTIN_BNDNARROW:\n+      {\n+\trtx m1, m1h1, m1h2, lb, ub, t1;\n+\n+\t/* Return value and lb.  */\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\t/* Bounds.  */\n+\targ1 = CALL_EXPR_ARG (exp, 1);\n+\t/* Size.  */\n+\targ2 = CALL_EXPR_ARG (exp, 2);\n+\n+\tlb = expand_normal (arg0);\n+\top1 = expand_normal (arg1);\n+\top2 = expand_normal (arg2);\n+\n+\t/* Size was passed but we need to use (size - 1) as for bndmk.  */\n+\top2 = expand_simple_binop (Pmode, PLUS, op2, constm1_rtx,\n+\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+\n+\t/* Add LB to size and inverse to get UB.  */\n+\top2 = expand_simple_binop (Pmode, PLUS, op2, lb,\n+\t\t\t\t   op2, 1, OPTAB_DIRECT);\n+\tub = expand_simple_unop (Pmode, NOT, op2, op2, 1);\n+\n+\tif (!register_operand (lb, Pmode))\n+\t  lb = ix86_zero_extend_to_Pmode (lb);\n+\tif (!register_operand (ub, Pmode))\n+\t  ub = ix86_zero_extend_to_Pmode (ub);\n+\n+\t/* We need to move bounds to memory before any computations.  */\n+\tif (MEM_P (op1))\n+\t  m1 = op1;\n+\telse\n+\t  {\n+\t    m1 = assign_386_stack_local (BNDmode, SLOT_TEMP);\n+\t    emit_move_insn (m1, op1);\n+\t  }\n+\n+\t/* Generate mem expression to be used for access to LB and UB.  */\n+\tm1h1 = adjust_address (m1, Pmode, 0);\n+\tm1h2 = adjust_address (m1, Pmode, GET_MODE_SIZE (Pmode));\n+\n+\tt1 = gen_reg_rtx (Pmode);\n+\n+\t/* Compute LB.  */\n+\temit_move_insn (t1, m1h1);\n+\tix86_emit_move_max (t1, lb);\n+\temit_move_insn (m1h1, t1);\n+\n+\t/* Compute UB.  UB is stored in 1's complement form.  Therefore\n+\t   we also use max here.  */\n+\temit_move_insn (t1, m1h2);\n+\tix86_emit_move_max (t1, ub);\n+\temit_move_insn (m1h2, t1);\n+\n+\top2 = gen_reg_rtx (BNDmode);\n+\temit_move_insn (op2, m1);\n+\n+\treturn chkp_join_splitted_slot (lb, op2);\n+      }\n+\n+    case IX86_BUILTIN_BNDINT:\n+      {\n+\trtx res, rh1, rh2, lb1, lb2, ub1, ub2;\n+\n+\tif (!target\n+\t    || GET_MODE (target) != BNDmode\n+\t    || !register_operand (target, BNDmode))\n+\t  target = gen_reg_rtx (BNDmode);\n+\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\targ1 = CALL_EXPR_ARG (exp, 1);\n+\n+\top0 = expand_normal (arg0);\n+\top1 = expand_normal (arg1);\n+\n+\tres = assign_386_stack_local (BNDmode, SLOT_TEMP);\n+\trh1 = adjust_address (res, Pmode, 0);\n+\trh2 = adjust_address (res, Pmode, GET_MODE_SIZE (Pmode));\n+\n+\t/* Put first bounds to temporaries.  */\n+\tlb1 = gen_reg_rtx (Pmode);\n+\tub1 = gen_reg_rtx (Pmode);\n+\tif (MEM_P (op0))\n+\t  {\n+\t    emit_move_insn (lb1, adjust_address (op0, Pmode, 0));\n+\t    emit_move_insn (ub1, adjust_address (op0, Pmode,\n+\t\t\t\t\t\t GET_MODE_SIZE (Pmode)));\n+\t  }\n+\telse\n+\t  {\n+\t    emit_move_insn (res, op0);\n+\t    emit_move_insn (lb1, rh1);\n+\t    emit_move_insn (ub1, rh2);\n+\t  }\n+\n+\t/* Put second bounds to temporaries.  */\n+\tlb2 = gen_reg_rtx (Pmode);\n+\tub2 = gen_reg_rtx (Pmode);\n+\tif (MEM_P (op1))\n+\t  {\n+\t    emit_move_insn (lb2, adjust_address (op1, Pmode, 0));\n+\t    emit_move_insn (ub2, adjust_address (op1, Pmode,\n+\t\t\t\t\t\t GET_MODE_SIZE (Pmode)));\n+\t  }\n+\telse\n+\t  {\n+\t    emit_move_insn (res, op1);\n+\t    emit_move_insn (lb2, rh1);\n+\t    emit_move_insn (ub2, rh2);\n+\t  }\n+\n+\t/* Compute LB.  */\n+\tix86_emit_move_max (lb1, lb2);\n+\temit_move_insn (rh1, lb1);\n+\n+\t/* Compute UB.  UB is stored in 1's complement form.  Therefore\n+\t   we also use max here.  */\n+\tix86_emit_move_max (ub1, ub2);\n+\temit_move_insn (rh2, ub1);\n+\n+\temit_move_insn (target, res);\n+\n+\treturn target;\n+      }\n+\n+    case IX86_BUILTIN_SIZEOF:\n+      {\n+\ttree name;\n+\trtx symbol;\n+\n+\tif (!target\n+\t    || GET_MODE (target) != Pmode\n+\t    || !register_operand (target, Pmode))\n+\t  target = gen_reg_rtx (Pmode);\n+\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\tgcc_assert (TREE_CODE (arg0) == VAR_DECL);\n+\n+\tname = DECL_ASSEMBLER_NAME (arg0);\n+\tsymbol = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (name));\n+\n+\temit_insn (Pmode == SImode\n+\t\t   ? gen_move_size_reloc_si (target, symbol)\n+\t\t   : gen_move_size_reloc_di (target, symbol));\n+\n+\treturn target;\n+      }\n+\n+    case IX86_BUILTIN_BNDLOWER:\n+      {\n+\trtx mem, hmem;\n+\n+\tif (!target\n+\t    || GET_MODE (target) != Pmode\n+\t    || !register_operand (target, Pmode))\n+\t  target = gen_reg_rtx (Pmode);\n+\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\top0 = expand_normal (arg0);\n+\n+\t/* We need to move bounds to memory first.  */\n+\tif (MEM_P (op0))\n+\t  mem = op0;\n+\telse\n+\t  {\n+\t    mem = assign_386_stack_local (BNDmode, SLOT_TEMP);\n+\t    emit_move_insn (mem, op0);\n+\t  }\n+\n+\t/* Generate mem expression to access LB and load it.  */\n+\thmem = adjust_address (mem, Pmode, 0);\n+\temit_move_insn (target, hmem);\n+\n+\treturn target;\n+      }\n+\n+    case IX86_BUILTIN_BNDUPPER:\n+      {\n+\trtx mem, hmem, res;\n+\n+\tif (!target\n+\t    || GET_MODE (target) != Pmode\n+\t    || !register_operand (target, Pmode))\n+\t  target = gen_reg_rtx (Pmode);\n+\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\top0 = expand_normal (arg0);\n+\n+\t/* We need to move bounds to memory first.  */\n+\tif (MEM_P (op0))\n+\t  mem = op0;\n+\telse\n+\t  {\n+\t    mem = assign_386_stack_local (BNDmode, SLOT_TEMP);\n+\t    emit_move_insn (mem, op0);\n+\t  }\n+\n+\t/* Generate mem expression to access UB.  */\n+\thmem = adjust_address (mem, Pmode, GET_MODE_SIZE (Pmode));\n+\n+\t/* We need to inverse all bits of UB.  */\n+\tres = expand_simple_unop (Pmode, NOT, hmem, target, 1);\n+\n+\tif (res != target)\n+\t  emit_move_insn (target, res);\n+\n+\treturn target;\n+      }\n+\n     case IX86_BUILTIN_MASKMOVQ:\n     case IX86_BUILTIN_MASKMOVDQU:\n       icode = (fcode == IX86_BUILTIN_MASKMOVQ\n@@ -39072,6 +39826,193 @@ static tree ix86_get_builtin (enum ix86_builtins code)\n     return NULL_TREE;\n }\n \n+/* Return function decl for target specific builtin\n+   for given MPX builtin passed i FCODE.  */\n+static tree\n+ix86_builtin_mpx_function (unsigned fcode)\n+{\n+  switch (fcode)\n+    {\n+    case BUILT_IN_CHKP_BNDMK:\n+      return ix86_builtins[IX86_BUILTIN_BNDMK];\n+\n+    case BUILT_IN_CHKP_BNDSTX:\n+      return ix86_builtins[IX86_BUILTIN_BNDSTX];\n+\n+    case BUILT_IN_CHKP_BNDLDX:\n+      return ix86_builtins[IX86_BUILTIN_BNDLDX];\n+\n+    case BUILT_IN_CHKP_BNDCL:\n+      return ix86_builtins[IX86_BUILTIN_BNDCL];\n+\n+    case BUILT_IN_CHKP_BNDCU:\n+      return ix86_builtins[IX86_BUILTIN_BNDCU];\n+\n+    case BUILT_IN_CHKP_BNDRET:\n+      return ix86_builtins[IX86_BUILTIN_BNDRET];\n+\n+    case BUILT_IN_CHKP_INTERSECT:\n+      return ix86_builtins[IX86_BUILTIN_BNDINT];\n+\n+    case BUILT_IN_CHKP_NARROW:\n+      return ix86_builtins[IX86_BUILTIN_BNDNARROW];\n+\n+    case BUILT_IN_CHKP_SIZEOF:\n+      return ix86_builtins[IX86_BUILTIN_SIZEOF];\n+\n+    case BUILT_IN_CHKP_EXTRACT_LOWER:\n+      return ix86_builtins[IX86_BUILTIN_BNDLOWER];\n+\n+    case BUILT_IN_CHKP_EXTRACT_UPPER:\n+      return ix86_builtins[IX86_BUILTIN_BNDUPPER];\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Helper function for ix86_load_bounds and ix86_store_bounds.\n+\n+   Return an address to be used to load/store bounds for pointer\n+   passed in SLOT.\n+\n+   SLOT_NO is an integer constant holding number of a target\n+   dependent special slot to be used in case SLOT is not a memory.\n+\n+   SPECIAL_BASE is a pointer to be used as a base of fake address\n+   to access special slots in Bounds Table.  SPECIAL_BASE[-1],\n+   SPECIAL_BASE[-2] etc. will be used as fake pointer locations.  */\n+\n+static rtx\n+ix86_get_arg_address_for_bt (rtx slot, rtx slot_no, rtx special_base)\n+{\n+  rtx addr = NULL;\n+\n+  /* NULL slot means we pass bounds for pointer not passed to the\n+     function at all.  Register slot means we pass pointer in a\n+     register.  In both these cases bounds are passed via Bounds\n+     Table.  Since we do not have actual pointer stored in memory,\n+     we have to use fake addresses to access Bounds Table.  We\n+     start with (special_base - sizeof (void*)) and decrease this\n+     address by pointer size to get addresses for other slots.  */\n+  if (!slot || REG_P (slot))\n+    {\n+      gcc_assert (CONST_INT_P (slot_no));\n+      addr = plus_constant (Pmode, special_base,\n+\t\t\t    -(INTVAL (slot_no) + 1) * GET_MODE_SIZE (Pmode));\n+    }\n+  /* If pointer is passed in a memory then its address is used to\n+     access Bounds Table.  */\n+  else if (MEM_P (slot))\n+    {\n+      addr = XEXP (slot, 0);\n+      if (!register_operand (addr, Pmode))\n+\taddr = copy_addr_to_reg (addr);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return addr;\n+}\n+\n+/* Expand pass uses this hook to load bounds for function parameter\n+   PTR passed in SLOT in case its bounds are not passed in a register.\n+\n+   If SLOT is a memory, then bounds are loaded as for regular pointer\n+   loaded from memory.  PTR may be NULL in case SLOT is a memory.\n+   In such case value of PTR (if required) may be loaded from SLOT.\n+\n+   If SLOT is NULL or a register then SLOT_NO is an integer constant\n+   holding number of the target dependent special slot which should be\n+   used to obtain bounds.\n+\n+   Return loaded bounds.  */\n+\n+static rtx\n+ix86_load_bounds (rtx slot, rtx ptr, rtx slot_no)\n+{\n+  rtx reg = gen_reg_rtx (BNDmode);\n+  rtx addr;\n+\n+  /* Get address to be used to access Bounds Table.  Special slots start\n+     at the location of return address of the current function.  */\n+  addr = ix86_get_arg_address_for_bt (slot, slot_no, arg_pointer_rtx);\n+\n+  /* Load pointer value from a memory if we don't have it.  */\n+  if (!ptr)\n+    {\n+      gcc_assert (MEM_P (slot));\n+      ptr = copy_addr_to_reg (slot);\n+    }\n+\n+  emit_insn (BNDmode == BND64mode\n+\t     ? gen_bnd64_ldx (reg, addr, ptr)\n+\t     : gen_bnd32_ldx (reg, addr, ptr));\n+\n+  return reg;\n+}\n+\n+/* Expand pass uses this hook to store BOUNDS for call argument PTR\n+   passed in SLOT in case BOUNDS are not passed in a register.\n+\n+   If SLOT is a memory, then BOUNDS are stored as for regular pointer\n+   stored in memory.  PTR may be NULL in case SLOT is a memory.\n+   In such case value of PTR (if required) may be loaded from SLOT.\n+\n+   If SLOT is NULL or a register then SLOT_NO is an integer constant\n+   holding number of the target dependent special slot which should be\n+   used to store BOUNDS.  */\n+\n+static void\n+ix86_store_bounds (rtx ptr, rtx slot, rtx bounds, rtx slot_no)\n+{\n+  rtx addr;\n+\n+  /* Get address to be used to access Bounds Table.  Special slots start\n+     at the location of return address of a called function.  */\n+  addr = ix86_get_arg_address_for_bt (slot, slot_no, stack_pointer_rtx);\n+\n+  /* Load pointer value from a memory if we don't have it.  */\n+  if (!ptr)\n+    {\n+      gcc_assert (MEM_P (slot));\n+      ptr = copy_addr_to_reg (slot);\n+    }\n+\n+  gcc_assert (POINTER_BOUNDS_MODE_P (GET_MODE (bounds)));\n+  if (!register_operand (bounds, BNDmode))\n+    bounds = copy_to_mode_reg (BNDmode, bounds);\n+\n+  emit_insn (BNDmode == BND64mode\n+\t     ? gen_bnd64_stx (addr, ptr, bounds)\n+\t     : gen_bnd32_stx (addr, ptr, bounds));\n+}\n+\n+/* Load and return bounds returned by function in SLOT.  */\n+\n+static rtx\n+ix86_load_returned_bounds (rtx slot)\n+{\n+  rtx res;\n+\n+  gcc_assert (REG_P (slot));\n+  res = gen_reg_rtx (BNDmode);\n+  emit_move_insn (res, slot);\n+\n+  return res;\n+}\n+\n+/* Store BOUNDS returned by function into SLOT.  */\n+\n+static void\n+ix86_store_returned_bounds (rtx slot, rtx bounds)\n+{\n+  gcc_assert (REG_P (slot));\n+  emit_move_insn (slot, bounds);\n+}\n+\n /* Returns a function decl for a vectorized version of the builtin function\n    with builtin function code FN and the result vector type TYPE, or NULL_TREE\n    if it is not available.  */\n@@ -40192,6 +41133,7 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n       case SSE_FIRST_REG:\n       case FP_TOP_REG:\n       case FP_SECOND_REG:\n+      case BND_REGS:\n \treturn true;\n \n       default:\n@@ -40539,6 +41481,8 @@ ix86_hard_regno_mode_ok (int regno, machine_mode mode)\n   if (MASK_REGNO_P (regno))\n     return (VALID_MASK_REG_MODE (mode)\n \t    || (TARGET_AVX512BW && VALID_MASK_AVX512BW_MODE (mode)));\n+  if (BND_REGNO_P (regno))\n+    return VALID_BND_REG_MODE (mode);\n   if (SSE_REGNO_P (regno))\n     {\n       /* We implement the move patterns for all vector modes into and\n@@ -41370,6 +42314,10 @@ x86_order_regs_for_local_alloc (void)\n    for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n+   /* MPX bound registers.  */\n+   for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n+     reg_alloc_order [pos++] = i;\n+\n    /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -48559,6 +49507,27 @@ ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n \t\t       gen_rtx_MULT (mode, op1, op2));\n }\n \n+/* Return 1 if control tansfer instruction INSN\n+   should be encoded with bnd prefix.\n+   If insn is NULL then return 1 when control\n+   transfer instructions should be prefixed with\n+   bnd by default for current function.  */\n+\n+bool\n+ix86_bnd_prefixed_insn_p (rtx insn)\n+{\n+  /* For call insns check special flag.  */\n+  if (insn && CALL_P (insn))\n+    {\n+      rtx call = get_call_rtx_from (insn);\n+      if (call)\n+\treturn CALL_EXPR_WITH_BOUNDS_P (call);\n+    }\n+\n+  /* All other insns are prefixed only if function is instrumented.  */\n+  return chkp_function_instrumented_p (current_function_decl);\n+}\n+\n /* Calculate integer abs() using only SSE2 instructions.  */\n \n void\n@@ -50163,6 +51132,73 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n \t\t    atomic_feraiseexcept_call);\n }\n \n+/* Return mode to be used for bounds or VOIDmode\n+   if bounds are not supported.  */\n+\n+static enum machine_mode\n+ix86_mpx_bound_mode ()\n+{\n+  /* Do not support pointer checker if MPX\n+     is not enabled.  */\n+  if (!TARGET_MPX)\n+    {\n+      if (flag_check_pointer_bounds)\n+\twarning (0, \"Pointer Checker requires MPX support on this target.\"\n+\t\t \" Use -mmpx options to enable MPX.\");\n+      return VOIDmode;\n+    }\n+\n+  return BNDmode;\n+}\n+\n+/*  Return constant used to statically initialize constant bounds.\n+\n+    This function is used to create special bound values.  For now\n+    only INIT bounds and NONE bounds are expected.  More special\n+    values may be added later.  */\n+\n+static tree\n+ix86_make_bounds_constant (HOST_WIDE_INT lb, HOST_WIDE_INT ub)\n+{\n+  tree low = lb ? build_minus_one_cst (pointer_sized_int_node)\n+    : build_zero_cst (pointer_sized_int_node);\n+  tree high = ub ? build_zero_cst (pointer_sized_int_node)\n+    : build_minus_one_cst (pointer_sized_int_node);\n+\n+  /* This function is supposed to be used to create INIT and\n+     NONE bounds only.  */\n+  gcc_assert ((lb == 0 && ub == -1)\n+\t      || (lb == -1 && ub == 0));\n+\n+  return build_complex (NULL, low, high);\n+}\n+\n+/* Generate a list of statements STMTS to initialize pointer bounds\n+   variable VAR with bounds LB and UB.  Return the number of generated\n+   statements.  */\n+\n+static int\n+ix86_initialize_bounds (tree var, tree lb, tree ub, tree *stmts)\n+{\n+  tree bnd_ptr = build_pointer_type (pointer_sized_int_node);\n+  tree lhs, modify, var_p;\n+\n+  ub = build1 (BIT_NOT_EXPR, pointer_sized_int_node, ub);\n+  var_p = fold_convert (bnd_ptr, build_fold_addr_expr (var));\n+\n+  lhs = build1 (INDIRECT_REF, pointer_sized_int_node, var_p);\n+  modify = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, lb);\n+  append_to_statement_list (modify, stmts);\n+\n+  lhs = build1 (INDIRECT_REF, pointer_sized_int_node,\n+\t\tbuild2 (POINTER_PLUS_EXPR, bnd_ptr, var_p,\n+\t\t\tTYPE_SIZE_UNIT (pointer_sized_int_node)));\n+  modify = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, ub);\n+  append_to_statement_list (modify, stmts);\n+\n+  return 2;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n@@ -50588,6 +51624,36 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #undef TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS\n #define TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS true\n \n+#undef TARGET_LOAD_BOUNDS_FOR_ARG\n+#define TARGET_LOAD_BOUNDS_FOR_ARG ix86_load_bounds\n+\n+#undef TARGET_STORE_BOUNDS_FOR_ARG\n+#define TARGET_STORE_BOUNDS_FOR_ARG ix86_store_bounds\n+\n+#undef TARGET_LOAD_RETURNED_BOUNDS\n+#define TARGET_LOAD_RETURNED_BOUNDS ix86_load_returned_bounds\n+\n+#undef TARGET_STORE_RETURNED_BOUNDS\n+#define TARGET_STORE_RETURNED_BOUNDS ix86_store_returned_bounds\n+\n+#undef TARGET_CHKP_BOUND_MODE\n+#define TARGET_CHKP_BOUND_MODE ix86_mpx_bound_mode\n+\n+#undef TARGET_BUILTIN_CHKP_FUNCTION\n+#define TARGET_BUILTIN_CHKP_FUNCTION ix86_builtin_mpx_function\n+\n+#undef TARGET_CHKP_FUNCTION_VALUE_BOUNDS\n+#define TARGET_CHKP_FUNCTION_VALUE_BOUNDS ix86_function_value_bounds\n+\n+#undef TARGET_CHKP_MAKE_BOUNDS_CONSTANT\n+#define TARGET_CHKP_MAKE_BOUNDS_CONSTANT ix86_make_bounds_constant\n+\n+#undef TARGET_CHKP_INITIALIZE_BOUNDS\n+#define TARGET_CHKP_INITIALIZE_BOUNDS ix86_initialize_bounds\n+\n+#undef TARGET_SETUP_INCOMING_VARARG_BOUNDS\n+#define TARGET_SETUP_INCOMING_VARARG_BOUNDS ix86_setup_incoming_vararg_bounds\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "53dfd223cda98fa78f93bbdedcac1bad903504ab", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -144,6 +144,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_XSAVEOPT_P(x)\tTARGET_ISA_XSAVEOPT_P(x)\n #define TARGET_PREFETCHWT1\tTARGET_ISA_PREFETCHWT1\n #define TARGET_PREFETCHWT1_P(x)\tTARGET_ISA_PREFETCHWT1_P(x)\n+#define TARGET_MPX\tTARGET_ISA_MPX\n+#define TARGET_MPX_P(x)\tTARGET_ISA_MPX_P(x)\n \n #define TARGET_LP64\tTARGET_ABI_64\n #define TARGET_LP64_P(x)\tTARGET_ABI_64_P(x)\n@@ -943,7 +945,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    eliminated during reloading in favor of either the stack or frame\n    pointer.  */\n \n-#define FIRST_PSEUDO_REGISTER 77\n+#define FIRST_PSEUDO_REGISTER 81\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -975,7 +977,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n /*  k0,  k1, k2, k3, k4, k5, k6, k7*/\t\t\t\t\\\n-     0,  0,   0,  0,  0,  0,  0,  0 }\n+     0,  0,   0,  0,  0,  0,  0,  0,\t\t\t\t\\\n+/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n+     0,  0,  0,  0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -1009,7 +1013,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n  /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1 }\n+     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n+/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n+     1,  1,  1,  1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -1025,7 +1031,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n-   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }\n+   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,  \\\n+   78, 79, 80 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -1046,8 +1053,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    applied to them.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO)\t\t\t\t\\\n-   || MMX_REGNO_P (REGNO) || MASK_REGNO_P (REGNO)\t\t\t\\\n+  (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n+   || MASK_REGNO_P (REGNO) || BND_REGNO_P (REGNO)\t\t\t\\\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n@@ -1102,6 +1109,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    || (MODE) == V2SImode || (MODE) == SImode\t\t\t\t\\\n    || (MODE) == V4HImode || (MODE) == V8QImode)\n \n+#define VALID_BND_REG_MODE(MODE) \\\n+  (TARGET_64BIT ? (MODE) == BND64mode : (MODE) == BND32mode)\n+\n #define VALID_DFP_MODE_P(MODE) \\\n   ((MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode)\n \n@@ -1210,6 +1220,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define FIRST_MASK_REG  (LAST_EXT_REX_SSE_REG + 1) /*69*/\n #define LAST_MASK_REG   (FIRST_MASK_REG + 7) /*76*/\n \n+#define FIRST_BND_REG  (LAST_MASK_REG + 1) /*77*/\n+#define LAST_BND_REG   (FIRST_BND_REG + 3) /*80*/\n+\n /* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n@@ -1292,6 +1305,7 @@ enum reg_class\n   SSE_FIRST_REG,\n   SSE_REGS,\n   EVEX_SSE_REGS,\n+  BND_REGS,\n   ALL_SSE_REGS,\n   MMX_REGS,\n   FP_TOP_SSE_REGS,\n@@ -1349,6 +1363,7 @@ enum reg_class\n    \"SSE_FIRST_REG\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n    \"EVEX_SSE_REGS\",\t\t\t\\\n+   \"BND_REGS\",\t\t\t\t\\\n    \"ALL_SSE_REGS\",\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n    \"FP_TOP_SSE_REGS\",\t\t\t\\\n@@ -1368,37 +1383,38 @@ enum reg_class\n    TARGET_CONDITIONAL_REGISTER_USAGE.  */\n \n #define REG_CLASS_CONTENTS                                              \\\n-{     { 0x00,       0x0,   0x0 },                                       \\\n-      { 0x01,       0x0,   0x0 },       /* AREG */                      \\\n-      { 0x02,       0x0,   0x0 },       /* DREG */                      \\\n-      { 0x04,       0x0,   0x0 },       /* CREG */                      \\\n-      { 0x08,       0x0,   0x0 },       /* BREG */                      \\\n-      { 0x10,       0x0,   0x0 },       /* SIREG */                     \\\n-      { 0x20,       0x0,   0x0 },       /* DIREG */                     \\\n-      { 0x03,       0x0,   0x0 },       /* AD_REGS */                   \\\n-      { 0x0f,       0x0,   0x0 },       /* Q_REGS */                    \\\n-  { 0x1100f0,    0x1fe0,   0x0 },       /* NON_Q_REGS */                \\\n-      { 0x7f,    0x1fe0,   0x0 },       /* INDEX_REGS */                \\\n-  { 0x1100ff,       0x0,   0x0 },       /* LEGACY_REGS */               \\\n-      { 0x07,       0x0,   0x0 },       /* CLOBBERED_REGS */            \\\n-  { 0x1100ff,    0x1fe0,   0x0 },       /* GENERAL_REGS */              \\\n-     { 0x100,       0x0,   0x0 },       /* FP_TOP_REG */                \\\n-    { 0x0200,       0x0,   0x0 },       /* FP_SECOND_REG */             \\\n-    { 0xff00,       0x0,   0x0 },       /* FLOAT_REGS */                \\\n-  { 0x200000,       0x0,   0x0 },       /* SSE_FIRST_REG */             \\\n-{ 0x1fe00000,  0x1fe000,   0x0 },       /* SSE_REGS */                  \\\n-       { 0x0,0xffe00000,  0x1f },       /* EVEX_SSE_REGS */             \\\n-{ 0x1fe00000,0xffffe000,  0x1f },       /* ALL_SSE_REGS */              \\\n-{ 0xe0000000,      0x1f,   0x0 },       /* MMX_REGS */                  \\\n-{ 0x1fe00100,0xffffe000,  0x1f },       /* FP_TOP_SSE_REG */            \\\n-{ 0x1fe00200,0xffffe000,  0x1f },       /* FP_SECOND_SSE_REG */         \\\n-{ 0x1fe0ff00,0xffffe000,  0x1f },       /* FLOAT_SSE_REGS */            \\\n-{   0x11ffff,    0x1fe0,   0x0 },       /* FLOAT_INT_REGS */            \\\n-{ 0x1ff100ff,0xffffffe0,  0x1f },       /* INT_SSE_REGS */              \\\n-{ 0x1ff1ffff,0xffffffe0,  0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n-       { 0x0,       0x0,0x1fc0 },       /* MASK_EVEX_REGS */           \\\n-       { 0x0,       0x0,0x1fe0 },       /* MASK_REGS */                 \\\n-{ 0xffffffff,0xffffffff,0x1fff }                                        \\\n+{     { 0x00,       0x0,    0x0 },                                       \\\n+      { 0x01,       0x0,    0x0 },       /* AREG */                      \\\n+      { 0x02,       0x0,    0x0 },       /* DREG */                      \\\n+      { 0x04,       0x0,    0x0 },       /* CREG */                      \\\n+      { 0x08,       0x0,    0x0 },       /* BREG */                      \\\n+      { 0x10,       0x0,    0x0 },       /* SIREG */                     \\\n+      { 0x20,       0x0,    0x0 },       /* DIREG */                     \\\n+      { 0x03,       0x0,    0x0 },       /* AD_REGS */                   \\\n+      { 0x0f,       0x0,    0x0 },       /* Q_REGS */                    \\\n+  { 0x1100f0,    0x1fe0,    0x0 },       /* NON_Q_REGS */                \\\n+      { 0x7f,    0x1fe0,    0x0 },       /* INDEX_REGS */                \\\n+  { 0x1100ff,       0x0,    0x0 },       /* LEGACY_REGS */               \\\n+      { 0x07,       0x0,    0x0 },       /* CLOBBERED_REGS */            \\\n+  { 0x1100ff,    0x1fe0,    0x0 },       /* GENERAL_REGS */              \\\n+     { 0x100,       0x0,    0x0 },       /* FP_TOP_REG */                \\\n+    { 0x0200,       0x0,    0x0 },       /* FP_SECOND_REG */             \\\n+    { 0xff00,       0x0,    0x0 },       /* FLOAT_REGS */                \\\n+  { 0x200000,       0x0,    0x0 },       /* SSE_FIRST_REG */             \\\n+{ 0x1fe00000,  0x1fe000,    0x0 },       /* SSE_REGS */                  \\\n+       { 0x0,0xffe00000,   0x1f },       /* EVEX_SSE_REGS */             \\\n+       { 0x0,       0x0,0x1e000 },       /* BND_REGS */\t\t\t \\\n+{ 0x1fe00000,0xffffe000,   0x1f },       /* ALL_SSE_REGS */              \\\n+{ 0xe0000000,      0x1f,    0x0 },       /* MMX_REGS */                  \\\n+{ 0x1fe00100,0xffffe000,   0x1f },       /* FP_TOP_SSE_REG */            \\\n+{ 0x1fe00200,0xffffe000,   0x1f },       /* FP_SECOND_SSE_REG */         \\\n+{ 0x1fe0ff00,0xffffe000,   0x1f },       /* FLOAT_SSE_REGS */            \\\n+{   0x11ffff,    0x1fe0,    0x0 },       /* FLOAT_INT_REGS */            \\\n+{ 0x1ff100ff,0xffffffe0,   0x1f },       /* INT_SSE_REGS */              \\\n+{ 0x1ff1ffff,0xffffffe0,   0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n+       { 0x0,       0x0, 0x1fc0 },       /* MASK_EVEX_REGS */           \\\n+       { 0x0,       0x0, 0x1fe0 },       /* MASK_REGS */                 \\\n+{ 0xffffffff,0xffffffff, 0x1fff }                                        \\\n }\n \n /* The same information, inverted:\n@@ -1475,6 +1491,9 @@ enum reg_class\n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n+#define BND_REGNO_P(N) IN_RANGE ((N), FIRST_BND_REG, LAST_BND_REG)\n+#define ANY_BND_REG_P(X) (REG_P (X) && BND_REGNO_P (REGNO (X)))\n+\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS INDEX_REGS\n@@ -1644,6 +1663,10 @@ typedef struct ix86_args {\n   int float_in_sse;\t\t/* Set to 1 or 2 for 32bit targets if\n \t\t\t\t   SFmode/DFmode arguments should be passed\n \t\t\t\t   in SSE registers.  Otherwise 0.  */\n+  int bnd_regno;                /* next available bnd register number */\n+  int bnds_in_bt;               /* number of bounds expected in BT.  */\n+  int force_bnd_pass;           /* number of bounds expected for stdarg arg.  */\n+  int stdarg;                   /* Set to 1 if function is stdarg.  */\n   enum calling_abi call_abi;\t/* Set to SYSV_ABI for sysv abi. Otherwise\n  \t\t\t\t   MS_ABI for ms abi.  */\n } CUMULATIVE_ARGS;\n@@ -1921,6 +1944,9 @@ do {\t\t\t\t\t\t\t\\\n    between pointers and any other objects of this machine mode.  */\n #define Pmode (ix86_pmode == PMODE_DI ? DImode : SImode)\n \n+/* Specify the machine mode that bounds have.  */\n+#define BNDmode (ix86_pmode == PMODE_DI ? BND64mode : BND32mode)\n+\n /* A C expression whose value is zero if pointers that need to be extended\n    from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and\n    greater then zero if they are zero-extended and less then zero if the\n@@ -2031,7 +2057,8 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n  \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\",\t\t\t\t\t\\\n- \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\" }\n+ \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\",\t\t\t\\\n+ \"bnd0\", \"bnd1\", \"bnd2\", \"bnd3\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n "}, {"sha": "7e26c693d678f204be5e349af8b44d6aff88d607", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 239, "deletions": 20, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -63,6 +63,7 @@\n ;; ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n ;; @ -- print a segment register of thread base pointer load\n ;; ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n+;; ! -- print MPX prefix for jxx/call/ret instructions if required.\n \n (define_c_enum \"unspec\" [\n   ;; Relocation specifiers\n@@ -78,6 +79,7 @@\n   UNSPEC_PLTOFF\n   UNSPEC_MACHOPIC_OFFSET\n   UNSPEC_PCREL\n+  UNSPEC_SIZEOF\n \n   ;; Prologue support\n   UNSPEC_STACK_ALLOC\n@@ -182,6 +184,16 @@\n \n   ;; For AVX512F support\n   UNSPEC_KMOV\n+\n+  UNSPEC_BNDMK\n+  UNSPEC_BNDMK_ADDR\n+  UNSPEC_BNDSTX\n+  UNSPEC_BNDLDX\n+  UNSPEC_BNDLDX_ADDR\n+  UNSPEC_BNDCL\n+  UNSPEC_BNDCU\n+  UNSPEC_BNDCN\n+  UNSPEC_MPX_FENCE\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -365,6 +377,8 @@\n    (MASK5_REG\t\t\t74)\n    (MASK6_REG\t\t\t75)\n    (MASK7_REG\t\t\t76)\n+   (BND0_REG\t\t\t77)\n+   (BND1_REG\t\t\t78)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -399,7 +413,8 @@\n    ssecvt,ssecvt1,sseicvt,sseins,\n    sseshuf,sseshuf1,ssemuladd,sse4arg,\n    lwp,mskmov,msklog,\n-   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\"\n+   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft,\n+   mpxmov,mpxmk,mpxchk,mpxld,mpxst\"\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n@@ -435,7 +450,8 @@\n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n   (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave,\n-\t\t\t  bitmanip,imulx,msklog,mskmov\")\n+\t\t\t  bitmanip,imulx,msklog,mskmov,mpxmk,mpxmov,mpxchk,\n+\t\t\t  mpxld,mpxst\")\n \t   (const_int 0)\n \t (eq_attr \"unit\" \"i387,sse,mmx\")\n \t   (const_int 0)\n@@ -490,13 +506,17 @@\n \t   (const_int 0)\n \t (and (eq_attr \"unit\" \"sse\") (eq_attr \"mode\" \"SF,DF\"))\n \t   (const_int 1)\n+\t (and (eq_attr \"type\" \"ibr,call,callv\")\n+\t      (match_test \"ix86_bnd_prefixed_insn_p (insn)\"))\n+\t   (const_int 1)\n \t]\n \t(const_int 0)))\n \n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n   (if_then_else\n-    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov\")\n+    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov,\n+\t\t\t  mpxmk,mpxmov,mpxchk,mpxld,mpxst\")\n \t (eq_attr \"unit\" \"sse,mmx\"))\n     (const_int 1)\n     (const_int 0)))\n@@ -599,12 +619,19 @@\n \t ]\n \t (const_int 1)))\n \n+;; When this attribute is set, calculate total insn length from\n+;; length_nobnd attribute, prefixed with eventual bnd prefix byte\n+(define_attr \"length_nobnd\" \"\" (const_int 0))\n+\n ;; The (bounding maximum) length of an instruction in bytes.\n ;; ??? fistp and frndint are in fact fldcw/{fistp,frndint}/fldcw sequences.\n ;; Later we may want to split them and compute proper length as for\n ;; other insns.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"other,multi,fistp,frndint\")\n+  (cond [(eq_attr \"length_nobnd\" \"!0\")\n+\t   (plus (symbol_ref (\"ix86_bnd_prefixed_insn_p (insn)\"))\n+\t\t (attr \"length_nobnd\"))\n+\t (eq_attr \"type\" \"other,multi,fistp,frndint\")\n \t   (const_int 16)\n \t (eq_attr \"type\" \"fcmp\")\n \t   (const_int 4)\n@@ -645,12 +672,16 @@\n (define_attr \"memory\" \"none,load,store,both,unknown\"\n   (cond [(eq_attr \"type\" \"other,multi,str,lwp\")\n \t   (const_string \"unknown\")\n-\t (eq_attr \"type\" \"lea,fcmov,fpspc\")\n+\t (eq_attr \"type\" \"lea,fcmov,fpspc,mpxmk,mpxchk\")\n \t   (const_string \"none\")\n \t (eq_attr \"type\" \"fistp,leave\")\n \t   (const_string \"both\")\n \t (eq_attr \"type\" \"frndint\")\n \t   (const_string \"load\")\n+\t (eq_attr \"type\" \"mpxld\")\n+\t   (const_string \"load\")\n+\t (eq_attr \"type\" \"mpxst\")\n+\t   (const_string \"store\")\n \t (eq_attr \"type\" \"push\")\n \t   (if_then_else (match_operand 1 \"memory_operand\")\n \t     (const_string \"both\")\n@@ -696,7 +727,7 @@\n \t\t   fmov,fcmp,fsgn,\n \t\t   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,\n \t\t   sselog1,sseshuf1,sseadd1,sseiadd1,sseishft1,\n-\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog\")\n+\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog,mpxmov\")\n \t      (match_operand 2 \"memory_operand\"))\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\" \"icmov,ssemuladd,sse4arg\")\n@@ -964,6 +995,21 @@\n (define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n \t\t\t    (DI \"TARGET_64BIT\")])\n \n+;; Bound modes.\n+(define_mode_iterator BND [(BND32 \"!TARGET_LP64\")\n+\t\t\t   (BND64 \"TARGET_LP64\")])\n+\n+;; Pointer mode corresponding to bound mode.\n+(define_mode_attr bnd_ptr [(BND32 \"SI\") (BND64 \"DI\")])\n+\n+;; MPX check types\n+(define_int_iterator BNDCHECK [UNSPEC_BNDCL UNSPEC_BNDCU UNSPEC_BNDCN])\n+\n+;; Check name\n+(define_int_attr bndcheck [(UNSPEC_BNDCL \"cl\")\n+\t\t\t   (UNSPEC_BNDCU \"cu\")\n+\t\t\t   (UNSPEC_BNDCN \"cn\")])\n+\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n@@ -10832,10 +10878,10 @@\n \t\t      (label_ref (match_operand 0))\n \t\t      (pc)))]\n   \"\"\n-  \"%+j%C1\\t%l0\"\n+  \"%!%+j%C1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -10850,10 +10896,10 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0))))]\n   \"\"\n-  \"%+j%c1\\t%l0\"\n+  \"%!%+j%c1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11291,9 +11337,9 @@\n   [(set (pc)\n \t(label_ref (match_operand 0)))]\n   \"\"\n-  \"jmp\\t%l0\"\n+  \"%!jmp\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n-   (set (attr \"length\")\n+   (set (attr \"length_nobnd\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11313,7 +11359,7 @@\n (define_insn \"*indirect_jump\"\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rBw\"))]\n   \"\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -11362,7 +11408,7 @@\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rBw\"))\n    (use (label_ref (match_operand 1)))]\n   \"\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \f\n@@ -11907,8 +11953,8 @@\n (define_insn \"simple_return_internal\"\n   [(simple_return)]\n   \"reload_completed\"\n-  \"ret\"\n-  [(set_attr \"length\" \"1\")\n+  \"%!ret\"\n+  [(set_attr \"length_nobnd\" \"1\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11920,7 +11966,12 @@\n   [(simple_return)\n    (unspec [(const_int 0)] UNSPEC_REP)]\n   \"reload_completed\"\n-  \"rep%; ret\"\n+{\n+  if (ix86_bnd_prefixed_insn_p (insn))\n+    return \"%!ret\";\n+\n+  return \"rep%; ret\";\n+}\n   [(set_attr \"length\" \"2\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n@@ -11931,8 +11982,8 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"const_int_operand\"))]\n   \"reload_completed\"\n-  \"ret\\t%0\"\n-  [(set_attr \"length\" \"3\")\n+  \"%!ret\\t%0\"\n+  [(set_attr \"length_nobnd\" \"3\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"2\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11941,7 +11992,7 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"reload_completed\"\n-  \"jmp\\t%A0\"\n+  \"%!jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -18611,6 +18662,174 @@\n    (set_attr \"atom_sse_attr\" \"fence\")\n    (set_attr \"memory\" \"unknown\")])\n \n+;; MPX instructions\n+\n+(define_expand \"<mode>_mk\"\n+  [(set (match_operand:BND 0 \"register_operand\")\n+    (unspec:BND\n+      [(mem:<bnd_ptr>\n+       (match_par_dup 3\n+        [(match_operand:<bnd_ptr> 1 \"register_operand\")\n+\t (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\")]))]\n+      UNSPEC_BNDMK))]\n+  \"TARGET_MPX\"\n+{\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n+\t\t\t\t\t\t  operands[2]),\n+                                UNSPEC_BNDMK_ADDR);\n+})\n+\n+(define_insn \"*<mode>_mk\"\n+  [(set (match_operand:BND 0 \"register_operand\" \"=w\")\n+    (unspec:BND\n+      [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+        [(unspec:<bnd_ptr>\n+\t   [(match_operand:<bnd_ptr> 1 \"register_operand\" \"r\")\n+            (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\" \"Tb\")]\n+\t   UNSPEC_BNDMK_ADDR)])]\n+      UNSPEC_BNDMK))]\n+  \"TARGET_MPX\"\n+  \"bndmk\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"mpxmk\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:BND 0 \"general_operand\")\n+        (match_operand:BND 1 \"general_operand\"))]\n+  \"TARGET_MPX\"\n+{\n+  ix86_expand_move (<MODE>mode, operands);DONE;\n+})\n+\n+(define_insn \"*mov<mode>_internal_mpx\"\n+  [(set (match_operand:BND 0 \"nonimmediate_operand\" \"=w,m\")\n+        (match_operand:BND 1 \"general_operand\" \"wm,w\"))]\n+  \"TARGET_MPX\"\n+  \"bndmov\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mpxmov\")])\n+\n+(define_expand \"<mode>_<bndcheck>\"\n+  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\")\n+                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\")] BNDCHECK)\n+              (set (match_dup 2)\n+                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+{\n+  operands[2] = gen_rtx_MEM (BLKmode, operands[1]);\n+  MEM_VOLATILE_P (operands[2]) = 1;\n+})\n+\n+(define_insn \"*<mode>_<bndcheck>\"\n+  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\" \"w\")\n+                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\" \"Ts\")] BNDCHECK)\n+              (set (match_operand:BLK 2 \"bnd_mem_operator\")\n+                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+  \"bnd<bndcheck>\\t{%a1, %0|%0, %a1}\"\n+  [(set_attr \"type\" \"mpxchk\")])\n+\n+(define_expand \"<mode>_ldx\"\n+  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\")\n+                       (unspec:BND\n+\t\t         [(mem:<bnd_ptr>\n+\t\t\t   (match_par_dup 3\n+\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\")\n+\t                      (match_operand:<bnd_ptr> 2 \"register_operand\")]))]\n+\t\t\t UNSPEC_BNDLDX))\n+              (use (mem:BLK (match_dup 1)))])]\n+  \"TARGET_MPX\"\n+{\n+  /* Avoid registers which connot be used as index.  */\n+  if (!index_register_operand (operands[2], Pmode))\n+    {\n+      rtx temp = gen_reg_rtx (Pmode);\n+      emit_move_insn (temp, operands[2]);\n+      operands[2] = temp;\n+    }\n+\n+  /* If it was a register originally then it may have\n+     mode other than Pmode.  We need to extend in such\n+     case because bndldx may work only with Pmode regs.  */\n+  if (GET_MODE (operands[2]) != Pmode)\n+    operands[2] = ix86_zero_extend_to_Pmode (operands[2]);\n+\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n+                                                  operands[2]),\n+\t\t\t\tUNSPEC_BNDLDX_ADDR);\n+})\n+\n+(define_insn \"*<mode>_ldx\"\n+  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\" \"=w\")\n+                       (unspec:BND\n+\t\t         [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+\t\t\t   [(unspec:<bnd_ptr>\n+\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\" \"Ti\")\n+\t                      (match_operand:<bnd_ptr> 2 \"register_operand\" \"l\")]\n+\t\t\t    UNSPEC_BNDLDX_ADDR)])]\n+\t\t\t UNSPEC_BNDLDX))\n+              (use (mem:BLK (match_dup 1)))])]\n+  \"TARGET_MPX\"\n+  \"bndldx\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"mpxld\")])\n+\n+(define_expand \"<mode>_stx\"\n+  [(parallel [(unspec [(mem:<bnd_ptr>\n+\t\t\t (match_par_dup 3\n+\t\t\t   [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\")\n+\t                    (match_operand:<bnd_ptr> 1 \"register_operand\")]))\n+\t               (match_operand:BND 2 \"register_operand\")] UNSPEC_BNDSTX)\n+              (set (match_dup 4)\n+                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+{\n+  /* Avoid registers which connot be used as index.  */\n+  if (!index_register_operand (operands[1], Pmode))\n+    {\n+      rtx temp = gen_reg_rtx (Pmode);\n+      emit_move_insn (temp, operands[1]);\n+      operands[1] = temp;\n+    }\n+\n+  /* If it was a register originally then it may have\n+     mode other than Pmode.  We need to extend in such\n+     case because bndstx may work only with Pmode regs.  */\n+  if (GET_MODE (operands[1]) != Pmode)\n+    operands[1] = ix86_zero_extend_to_Pmode (operands[1]);\n+\n+  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[0],\n+                                                  operands[1]),\n+\t\t\t\tUNSPEC_BNDLDX_ADDR);\n+  operands[4] = gen_rtx_MEM (BLKmode, operands[0]);\n+  MEM_VOLATILE_P (operands[4]) = 1;\n+})\n+\n+(define_insn \"*<mode>_stx\"\n+  [(parallel [(unspec [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n+\t\t\t [(unspec:<bnd_ptr>\n+\t\t\t  [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\" \"Ti\")\n+\t                   (match_operand:<bnd_ptr> 1 \"register_operand\" \"l\")]\n+\t\t\t UNSPEC_BNDLDX_ADDR)])\n+\t               (match_operand:BND 2 \"register_operand\" \"w\")] UNSPEC_BNDSTX)\n+              (set (match_operand:BLK 4 \"bnd_mem_operator\")\n+                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n+  \"TARGET_MPX\"\n+  \"bndstx\\t{%2, %3|%3, %2}\"\n+  [(set_attr \"type\" \"mpxst\")])\n+\n+(define_insn \"move_size_reloc_<mode>\"\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n+       (unspec:SWI48\n+        [(match_operand:SWI48 1 \"symbol_operand\")]\n+        UNSPEC_SIZEOF))]\n+  \"TARGET_MPX\"\n+{\n+  if (x86_64_immediate_size_operand (operands[1], VOIDmode))\n+    return \"mov{l}\\t{%1@SIZE, %k0|%k0, %1@SIZE}\";\n+  else\n+    return \"movabs{q}\\t{%1@SIZE, %0|%0, %1@SIZE}\";\n+}\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "5dfa9bf8b96779c724b1c61acb76853a5f485127", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -814,6 +814,10 @@ mrtm\n Target Report Mask(ISA_RTM) Var(ix86_isa_flags) Save\n Support RTM built-in functions and code generation\n \n+mmpx\n+Target Report Mask(ISA_MPX) Var(ix86_isa_flags) Save\n+Support MPX code generation\n+\n mstack-protector-guard=\n Target RejectNegative Joined Enum(stack_protector_guard) Var(ix86_stack_protector_guard) Init(SSP_TLS)\n Use given stack-protector guard"}, {"sha": "bdcdf180995433757f796e18f2963648d6129623", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -124,6 +124,10 @@\n        (match_test \"TARGET_64BIT\")\n        (match_test \"REGNO (op) > BX_REG\")))\n \n+;; Return true if VALUE is symbol reference\n+(define_predicate \"symbol_operand\"\n+  (match_code \"symbol_ref\"))\n+\n ;; Return true if VALUE can be stored in a sign extended immediate field.\n (define_predicate \"x86_64_immediate_operand\"\n   (match_code \"const_int,symbol_ref,label_ref,const\")\n@@ -336,6 +340,14 @@\n   return false;\n })\n \n+;; Return true if size of VALUE can be stored in a sign\n+;; extended immediate field.\n+(define_predicate \"x86_64_immediate_size_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (ior (not (match_test \"TARGET_64BIT\"))\n+\t    (match_test \"ix86_cmodel == CM_SMALL\")\n+\t    (match_test \"ix86_cmodel == CM_KERNEL\"))))\n+\n ;; Return true if OP is general operand representable on x86_64.\n (define_predicate \"x86_64_general_operand\"\n   (if_then_else (match_test \"TARGET_64BIT\")\n@@ -1006,9 +1018,74 @@\n   return true;\n })\n \n+;; Return true if op is valid MPX address operand without base\n+(define_predicate \"address_mpx_no_base_operand\"\n+  (match_operand 0 \"address_operand\")\n+{\n+  struct ix86_address parts;\n+  int ok;\n+\n+  ok = ix86_decompose_address (op, &parts);\n+  gcc_assert (ok);\n+\n+  if (parts.index && parts.base)\n+    return false;\n+\n+  if (parts.seg != SEG_DEFAULT)\n+    return false;\n+\n+  /* Do not support (%rip).  */\n+  if (parts.disp && flag_pic && TARGET_64BIT\n+      && SYMBOLIC_CONST (parts.disp))\n+    {\n+      if (GET_CODE (parts.disp) != CONST\n+\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n+\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n+\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n+\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n+\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF))\n+\treturn false;\n+    }\n+\n+  return true;\n+})\n+\n+;; Return true if op is valid MPX address operand without index\n+(define_predicate \"address_mpx_no_index_operand\"\n+  (match_operand 0 \"address_operand\")\n+{\n+  struct ix86_address parts;\n+  int ok;\n+\n+  ok = ix86_decompose_address (op, &parts);\n+  gcc_assert (ok);\n+\n+  if (parts.index)\n+    return false;\n+\n+  if (parts.seg != SEG_DEFAULT)\n+    return false;\n+\n+  /* Do not support (%rip).  */\n+  if (parts.disp && flag_pic && TARGET_64BIT\n+      && SYMBOLIC_CONST (parts.disp)\n+      && (GET_CODE (parts.disp) != CONST\n+\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n+\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n+\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n+\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n+\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF)))\n+    return false;\n+\n+  return true;\n+})\n+\n (define_predicate \"vsib_mem_operator\"\n   (match_code \"mem\"))\n \n+(define_predicate \"bnd_mem_operator\"\n+  (match_code \"mem\"))\n+\n ;; Return true if the rtx is known to be at least 32 bits aligned.\n (define_predicate \"aligned_operand\"\n   (match_operand 0 \"general_operand\")"}, {"sha": "3fc2f8adb83496cf25bc5bed8fc7b2e7add324a9", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -107,6 +107,9 @@ define_builtin_macros_for_compilation_flags (cpp_reader *pfile)\n \t\t\tflag_finite_math_only);\n   if (flag_cilkplus)\n     cpp_define (pfile, \"__cilk=200\");\n+\n+  if (flag_check_pointer_bounds)\n+    cpp_define (pfile, \"__CHKP__\");\n }\n \n "}, {"sha": "aa15a395aad226000329905ce16a22f4fdb34eb4", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -2325,6 +2325,10 @@ dbxout_type (tree type, int full)\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n+    case POINTER_BOUNDS_TYPE:\n+      /* No debug info for pointer bounds type supported yet.  */\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "cba38847e67bab3c58684832d109892df4f1d87b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 218, "deletions": 5, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -79,6 +79,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * x86 specific memory model extensions for transactional memory:: x86 memory models.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n+* Pointer Bounds Checker builtins:: Built-in functions for Pointer Bounds Checker.\n * Cilk Plus Builtins::  Built-in functions for the Cilk Plus language extension.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n@@ -2180,7 +2181,8 @@ attributes are currently defined for functions on all targets:\n @code{returns_nonnull}, @code{gnu_inline},\n @code{externally_visible}, @code{hot}, @code{cold}, @code{artificial},\n @code{no_sanitize_address}, @code{no_address_safety_analysis},\n-@code{no_sanitize_undefined}, @code{no_reorder},\n+@code{no_sanitize_undefined}, @code{no_reorder}, @code{bnd_legacy},\n+@code{bnd_instrument},\n @code{error} and @code{warning}.\n Several other attributes are defined for functions on particular\n target systems.  Other attributes, including @code{section} are\n@@ -3702,6 +3704,18 @@ The @code{no_sanitize_undefined} attribute on functions is used\n to inform the compiler that it should not check for undefined behavior\n in the function when compiling with the @option{-fsanitize=undefined} option.\n \n+@item bnd_legacy\n+@cindex @code{bnd_legacy} function attribute\n+The @code{bnd_legacy} attribute on functions is used to inform\n+compiler that function should not be instrumented when compiled\n+with @option{-fcheck-pointer-bounds} option.\n+\n+@item bnd_instrument\n+@cindex @code{bnd_instrument} function attribute\n+The @code{bnd_instrument} attribute on functions is used to inform\n+compiler that function should be instrumented when compiled\n+with @option{-fchkp-instrument-marked-only} option.\n+\n @item regparm (@var{number})\n @cindex @code{regparm} attribute\n @cindex functions that are passed arguments in registers on the 386\n@@ -5642,11 +5656,11 @@ placed in either the @code{.bss_below100} section or the\n The keyword @code{__attribute__} allows you to specify special\n attributes of @code{struct} and @code{union} types when you define\n such types.  This keyword is followed by an attribute specification\n-inside double parentheses.  Seven attributes are currently defined for\n+inside double parentheses.  Eight attributes are currently defined for\n types: @code{aligned}, @code{packed}, @code{transparent_union},\n-@code{unused}, @code{deprecated}, @code{visibility}, and\n-@code{may_alias}.  Other attributes are defined for functions\n-(@pxref{Function Attributes}), labels (@pxref{Label \n+@code{unused}, @code{deprecated}, @code{visibility}, @code{may_alias}\n+and @code{bnd_variable_size}.  Other attributes are defined for\n+functions (@pxref{Function Attributes}), labels (@pxref{Label \n Attributes}) and for variables (@pxref{Variable Attributes}).\n \n You may also specify any one of these attributes with @samp{__}\n@@ -5952,6 +5966,35 @@ initialization will result in future breakage.\n GCC emits warnings based on this attribute by default; use\n @option{-Wno-designated-init} to suppress them.\n \n+@item bnd_variable_size\n+When applied to a structure field, this attribute tells Pointer\n+Bounds Checker that the size of this field should not be computed\n+using static type information.  It may be used to mark variable\n+sized static array fields placed at the end of a structure.\n+\n+@smallexample\n+struct S\n+@{\n+  int size;\n+  char data[1];\n+@}\n+S *p = (S *)malloc (sizeof(S) + 100);\n+p->data[10] = 0; //Bounds violation\n+@end smallexample\n+\n+By using an attribute for a field we may avoid bound violation\n+we most probably do not want to see:\n+\n+@smallexample\n+struct S\n+@{\n+  int size;\n+  char data[1] __attribute__((bnd_variable_size));\n+@}\n+S *p = (S *)malloc (sizeof(S) + 100);\n+p->data[10] = 0; //OK\n+@end smallexample\n+\n @end table\n \n To specify multiple attributes, separate them by commas within the\n@@ -8610,6 +8653,176 @@ format string @var{fmt}.  If the compiler is able to optimize them to\n @code{fputc} etc.@: functions, it does, otherwise the checking function\n is called and the @var{flag} argument passed to it.\n \n+@node Pointer Bounds Checker builtins\n+@section Pointer Bounds Checker Built-in Functions\n+@findex __builtin___bnd_set_ptr_bounds\n+@findex __builtin___bnd_narrow_ptr_bounds\n+@findex __builtin___bnd_copy_ptr_bounds\n+@findex __builtin___bnd_init_ptr_bounds\n+@findex __builtin___bnd_null_ptr_bounds\n+@findex __builtin___bnd_store_ptr_bounds\n+@findex __builtin___bnd_chk_ptr_lbounds\n+@findex __builtin___bnd_chk_ptr_ubounds\n+@findex __builtin___bnd_chk_ptr_bounds\n+@findex __builtin___bnd_get_ptr_lbound\n+@findex __builtin___bnd_get_ptr_ubound\n+\n+GCC provides a set of built-in functions to control Pointer Bounds Checker\n+instrumentation.  Note that all Pointer Bounds Checker builtins are allowed\n+to use even if you compile with Pointer Bounds Checker off.  The builtins\n+behavior may differ in such case as documented below.\n+\n+@deftypefn {Built-in Function} void * __builtin___bnd_set_ptr_bounds (const void * @var{q}, size_t @var{size})\n+\n+This built-in function returns a new pointer with the value of @var{q}, and\n+associate it with the bounds [@var{q}, @var{q}+@var{size}-1].  With Pointer\n+Bounds Checker off built-in function just returns the first argument.\n+\n+@smallexample\n+extern void *__wrap_malloc (size_t n)\n+@{\n+  void *p = (void *)__real_malloc (n);\n+  if (!p) return __builtin___bnd_null_ptr_bounds (p);\n+  return __builtin___bnd_set_ptr_bounds (p, n);\n+@}\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void * __builtin___bnd_narrow_ptr_bounds (const void * @var{p}, const void * @var{q}, size_t  @var{size})\n+\n+This built-in function returns a new pointer with the value of @var{p}\n+and associate it with the narrowed bounds formed by the intersection\n+of bounds associated with @var{q} and the [@var{p}, @var{p} + @var{size} - 1].\n+With Pointer Bounds Checker off built-in function just returns the first\n+argument.\n+\n+@smallexample\n+void init_objects (object *objs, size_t size)\n+@{\n+  size_t i;\n+  /* Initialize objects one-by-one passing pointers with bounds of an object,\n+     not the full array of objects.  */\n+  for (i = 0; i < size; i++)\n+    init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs, sizeof(object)));\n+@}\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void * __builtin___bnd_copy_ptr_bounds (const void * @var{q}, const void * @var{r})\n+\n+This built-in function returns a new pointer with the value of @var{q},\n+and associate it with the bounds already associated with pointer @var{r}.\n+With Pointer Bounds Checker off built-in function just returns the first\n+argument.\n+\n+@smallexample\n+/* Here is a way to get pointer to object's field but\n+   still with the full object's bounds.  */\n+int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_filed, objptr);\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void * __builtin___bnd_init_ptr_bounds (const void * @var{q})\n+\n+This built-in function returns a new pointer with the value of @var{q}, and\n+associate it with INIT (allowing full memory access) bounds. With Pointer\n+Bounds Checker off built-in function just returns the first argument.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void * __builtin___bnd_null_ptr_bounds (const void * @var{q})\n+\n+This built-in function returns a new pointer with the value of @var{q}, and\n+associate it with NULL (allowing no memory access) bounds. With Pointer\n+Bounds Checker off built-in function just returns the first argument.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin___bnd_store_ptr_bounds (const void ** @var{ptr_addr}, const void * @var{ptr_val})\n+\n+This built-in function stores the bounds associated with pointer @var{ptr_val}\n+and location @var{ptr_addr} into Bounds Table.  This can be useful to propagate\n+bounds from legacy code without touching the associated pointer's memory when\n+pointers were copied as integers.  With Pointer Bounds Checker off built-in\n+function call is ignored.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_lbounds (const void * @var{q})\n+\n+This built-in function checks if the pointer @var{q} is within the lower\n+bound of its associated bounds.  With Pointer Bounds Checker off built-in\n+function call is ignored.\n+\n+@smallexample\n+extern void *__wrap_memset (void *dst, int c, size_t len)\n+@{\n+  if (len > 0)\n+    @{\n+      __builtin___bnd_chk_ptr_lbounds (dst);\n+      __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);\n+      __real_memset (dst, c, len);\n+    @}\n+  return dst;\n+@}\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_ubounds (const void * @var{q})\n+\n+This built-in function checks if the pointer @var{q} is within the upper\n+bound of its associated bounds.  With Pointer Bounds Checker off built-in\n+function call is ignored.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_bounds (const void * @var{q}, size_t @var{size})\n+\n+This built-in function checks if [@var{q}, @var{q} + @var{size} - 1] is within\n+the lower and upper bounds associated with @var{q}.  With Pointer Bounds Checker\n+off built-in function call is ignored.\n+\n+@smallexample\n+extern void *__wrap_memcpy (void *dst, const void *src, size_t n)\n+@{\n+  if (n > 0)\n+    @{\n+      __bnd_chk_ptr_bounds (dst, n);\n+      __bnd_chk_ptr_bounds (src, n);\n+      __real_memcpy (dst, src, n);\n+    @}\n+  return dst;\n+@}\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} const void * __builtin___bnd_get_ptr_lbound (const void * @var{q})\n+\n+This built-in function returns the lower bound (which is a pointer) associated\n+with the pointer @var{q}.  This is at least useful for debugging using printf.\n+With Pointer Bounds Checker off built-in function returns 0.\n+\n+@smallexample\n+void *lb = __builtin___bnd_get_ptr_lbound (q);\n+void *ub = __builtin___bnd_get_ptr_ubound (q);\n+printf (\"q = %p  lb(q) = %p  ub(q) = %p\", q, lb, ub);\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} const void * __builtin___bnd_get_ptr_ubound (const void * @var{q})\n+\n+This built-in function returns the upper bound (which is a pointer) associated\n+with the pointer @var{q}.  With Pointer Bounds Checker off built-in function\n+returns -1.\n+\n+@end deftypefn\n+\n @node Cilk Plus Builtins\n @section Cilk Plus C/C++ language extension Built-in Functions.\n "}, {"sha": "b7c8001b044d164037f34815c625775c22e0d2bb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -682,7 +682,7 @@ Objective-C and Objective-C++ Dialects}.\n -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma -mprefetchwt1 @gol\n -mclflushopt -mxsavec -mxsaves @gol\n -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt @gol\n--mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mthreads @gol\n+-mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mmpx -mthreads @gol\n -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mmemcpy-strategy=@var{strategy} -mmemset-strategy=@var{strategy}\n@@ -10561,6 +10561,12 @@ is greater or equal to this number, use callbacks instead of inline checks.\n E.g. to disable inline code use\n @option{--param asan-instrumentation-with-call-threshold=0}.\n \n+@item chkp-max-ctor-size\n+Static constructors generated by Pointer Bounds Checker may become very\n+large and significantly increase compile time at optimization level\n+@option{-O1} and higher.  This parameter is a maximum nubmer of statements\n+in a single generated constructor.  Default value is 5000.\n+\n @end table\n @end table\n \n@@ -15774,6 +15780,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-xsavec\n @itemx -mxsaves\n @itemx -mno-xsaves\n+@itemx -mmpx\n+@itemx -mno-mpx\n @opindex mmmx\n @opindex mno-mmx\n @opindex msse\n@@ -15783,7 +15791,7 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n These switches enable or disable the use of instructions in the MMX, SSE,\n SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD,\n SHA, AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM,\n-BMI, BMI2, FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, or 3DNow!@:\n+BMI, BMI2, FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, MPX or 3DNow!@:\n extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and"}, {"sha": "dd29e00f90b6a431bef8f0e68643cceeb7f780e4", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1296,6 +1296,12 @@ These modes stand for a complex number represented as a pair of integer\n values.  The integer values are in @code{QImode}, @code{HImode},\n @code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},\n respectively.\n+\n+@findex BND32mode\n+@findex BND64mode\n+@item BND32mode BND64mode\n+These modes stand for bounds for pointer of 32 and 64 bit size respectively.\n+Mode size is double pointer mode size.\n @end table\n \n The machine description defines @code{Pmode} as a C macro which expands\n@@ -1383,6 +1389,12 @@ any @code{CC_MODE} modes listed in the @file{@var{machine}-modes.def}.\n @xref{Jump Patterns},\n also see @ref{Condition Code}.\n \n+@findex MODE_POINTER_BOUNDS\n+@item MODE_POINTER_BOUNDS\n+Pointer bounds modes.  Used to represent values of pointer bounds type.\n+Operations in these modes may be executed as NOPs depending on hardware\n+features and environment setup.\n+\n @findex MODE_RANDOM\n @item MODE_RANDOM\n This is a catchall mode class for modes which don't fit into the above"}, {"sha": "1bb31830ce1ab9b7645b5cbccc5c30e18dc5d16e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -3843,6 +3843,12 @@ The return value is usually either a @code{reg} RTX for the hard\n register in which to pass the argument, or zero to pass the argument\n on the stack.\n \n+The return value can be a @code{const_int} which means argument is\n+passed in a target specific slot with specified number.  Target hooks\n+should be used to store or load argument in such case.  See\n+@code{TARGET_STORE_BOUNDS_FOR_ARG} and @code{TARGET_LOAD_BOUNDS_FOR_ARG}\n+for more information.\n+\n The value of the expression can also be a @code{parallel} RTX@.  This is\n used when an argument is passed in multiple locations.  The mode of the\n @code{parallel} should be the mode of the entire argument.  The\n@@ -4979,6 +4985,49 @@ defined, then define this hook to return @code{true} if\n Otherwise, you should not define this hook.\n @end deftypefn\n \n+@deftypefn {Target Hook} rtx TARGET_LOAD_BOUNDS_FOR_ARG (rtx @var{slot}, rtx @var{arg}, rtx @var{slot_no})\n+This hook is used by expand pass to emit insn to load bounds of\n+@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\n+bounds of @var{arg} are not passed in register.  If @var{slot} is a\n+memory, then bounds are loaded as for regular pointer loaded from\n+memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\n+constant holding number of the target dependent special slot which\n+should be used to obtain bounds.  Hook returns RTX holding loaded bounds.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_STORE_BOUNDS_FOR_ARG (rtx @var{arg}, rtx @var{slot}, rtx @var{bounds}, rtx @var{slot_no})\n+This hook is used by expand pass to emit insns to store @var{bounds} of\n+@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\n+@var{bounds} of @var{arg} are not passed in register.  If @var{slot} is a\n+memory, then @var{bounds} are stored as for regular pointer stored in\n+memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\n+constant holding number of the target dependent special slot which\n+should be used to store @var{bounds}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_LOAD_RETURNED_BOUNDS (rtx @var{slot})\n+This hook is used by expand pass to emit insn to load bounds\n+returned by function call in @var{slot}.  Hook returns RTX holding\n+loaded bounds.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_STORE_RETURNED_BOUNDS (rtx @var{slot}, rtx @var{bounds})\n+This hook is used by expand pass to emit insn to store @var{bounds}\n+returned by function call into @var{slot}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_CHKP_FUNCTION_VALUE_BOUNDS (const_tree @var{ret_type}, const_tree @var{fn_decl_or_type}, bool @var{outgoing})\n+Define this to return an RTX representing the place where a function\n+returns bounds for returned pointers.  Arguments meaning is similar to\n+@code{TARGET_FUNCTION_VALUE}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARG_BOUNDS (cumulative_args_t @var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n+Use it to store bounds for anonymous register arguments stored\n+into the stack.  Arguments meaning is similar to\n+@code{TARGET_SETUP_INCOMING_VARARGS}.\n+@end deftypefn\n+\n @node Trampolines\n @section Trampolines for Nested Functions\n @cindex trampolines for nested functions\n@@ -10754,6 +10803,93 @@ ignored.  This function should return the result of the call to the\n built-in function.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_BUILTIN_CHKP_FUNCTION (unsigned @var{fcode})\n+This hook allows target to redefine built-in functions used by\n+Pointer Bounds Checker for code instrumentation.  Hook should return\n+fndecl of function implementing generic builtin whose code is\n+passed in @var{fcode}.  Currently following built-in functions are\n+obtained using this hook:\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndmk (const void *@var{lb}, size_t @var{size})\n+Function code - BUILT_IN_CHKP_BNDMK.  This built-in function is used\n+by Pointer Bounds Checker to create bound values.  @var{lb} holds low\n+bound of the resulting bounds.  @var{size} holds size of created bounds.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __chkp_bndstx (const void *@var{ptr}, __bounds_type @var{b}, const void **@var{loc})\n+Function code - @code{BUILT_IN_CHKP_BNDSTX}.  This built-in function is used\n+by Pointer Bounds Checker to store bounds @var{b} for pointer @var{ptr}\n+when @var{ptr} is stored by address @var{loc}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndldx (const void **@var{loc}, const void *@var{ptr})\n+Function code - @code{BUILT_IN_CHKP_BNDLDX}.  This built-in function is used\n+by Pointer Bounds Checker to get bounds of pointer @var{ptr} loaded by\n+address @var{loc}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __chkp_bndcl (const void *@var{ptr}, __bounds_type @var{b})\n+Function code - @code{BUILT_IN_CHKP_BNDCL}.  This built-in function is used\n+by Pointer Bounds Checker to perform check for pointer @var{ptr} against\n+lower bound of bounds @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __chkp_bndcu (const void *@var{ptr}, __bounds_type @var{b})\n+Function code - @code{BUILT_IN_CHKP_BNDCU}.  This built-in function is used\n+by Pointer Bounds Checker to perform check for pointer @var{ptr} against\n+upper bound of bounds @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndret (void *@var{ptr})\n+Function code - @code{BUILT_IN_CHKP_BNDRET}.  This built-in function is used\n+by Pointer Bounds Checker to obtain bounds returned by a call statement.\n+@var{ptr} passed to built-in is @code{SSA_NAME} returned by the call.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} __bounds_type __chkp_intersect (__bounds_type @var{b1}, __bounds_type @var{b2})\n+Function code - @code{BUILT_IN_CHKP_INTERSECT}.  This built-in function\n+returns intersection of bounds @var{b1} and @var{b2}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} __bounds_type __chkp_narrow (const void *@var{ptr}, __bounds_type @var{b}, size_t @var{s})\n+Function code - @code{BUILT_IN_CHKP_NARROW}.  This built-in function\n+returns intersection of bounds @var{b} and\n+[@var{ptr}, @var{ptr} + @var{s} - @code{1}].\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} size_t __chkp_sizeof (const void *@var{ptr})\n+Function code - @code{BUILT_IN_CHKP_SIZEOF}.  This built-in function\n+returns size of object referenced by @var{ptr}. @var{ptr} is always\n+@code{ADDR_EXPR} of @code{VAR_DECL}.  This built-in is used by\n+Pointer Bounds Checker when bounds of object cannot be computed statically\n+(e.g. object has incomplete type).\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} const void *__chkp_extract_lower (__bounds_type @var{b})\n+Function code - @code{BUILT_IN_CHKP_EXTRACT_LOWER}.  This built-in function\n+returns lower bound of bounds @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} const void *__chkp_extract_upper (__bounds_type @var{b})\n+Function code - @code{BUILT_IN_CHKP_EXTRACT_UPPER}.  This built-in function\n+returns upper bound of bounds @var{b}.\n+@end deftypefn\n+@end deftypefn\n+@deftypefn {Target Hook} tree TARGET_CHKP_BOUND_TYPE (void)\n+Return type to be used for bounds\n+@end deftypefn\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_CHKP_BOUND_MODE (void)\n+Return mode to be used for bounds.\n+@end deftypefn\n+@deftypefn {Target Hook} tree TARGET_CHKP_MAKE_BOUNDS_CONSTANT (HOST_WIDE_INT @var{lb}, HOST_WIDE_INT @var{ub})\n+Return constant used to statically initialize constant bounds\n+with specified lower bound @var{lb} and upper bounds @var{ub}.\n+@end deftypefn\n+@deftypefn {Target Hook} int TARGET_CHKP_INITIALIZE_BOUNDS (tree @var{var}, tree @var{lb}, tree @var{ub}, tree *@var{stmts})\n+Generate a list of statements @var{stmts} to initialize pointer\n+bounds variable @var{var} with bounds @var{lb} and @var{ub}.  Return\n+the number of generated statements.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_RESOLVE_OVERLOADED_BUILTIN (unsigned int @var{loc}, tree @var{fndecl}, void *@var{arglist})\n Select a replacement for a machine specific built-in function that\n was set up by @samp{TARGET_INIT_BUILTINS}.  This is done"}, {"sha": "bf1595c6a2e4807c35530e3cfeb9b16f6a6921d5", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -3862,6 +3862,18 @@ These machine description macros help implement varargs:\n \n @hook TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n \n+@hook TARGET_LOAD_BOUNDS_FOR_ARG\n+\n+@hook TARGET_STORE_BOUNDS_FOR_ARG\n+\n+@hook TARGET_LOAD_RETURNED_BOUNDS\n+\n+@hook TARGET_STORE_RETURNED_BOUNDS\n+\n+@hook TARGET_CHKP_FUNCTION_VALUE_BOUNDS\n+\n+@hook TARGET_SETUP_INCOMING_VARARG_BOUNDS\n+\n @node Trampolines\n @section Trampolines for Nested Functions\n @cindex trampolines for nested functions\n@@ -7930,6 +7942,12 @@ to by @var{ce_info}.\n \n @hook TARGET_EXPAND_BUILTIN\n \n+@hook TARGET_BUILTIN_CHKP_FUNCTION\n+@hook TARGET_CHKP_BOUND_TYPE\n+@hook TARGET_CHKP_BOUND_MODE\n+@hook TARGET_CHKP_MAKE_BOUNDS_CONSTANT\n+@hook TARGET_CHKP_INITIALIZE_BOUNDS\n+\n @hook TARGET_RESOLVE_OVERLOADED_BUILTIN\n \n @hook TARGET_FOLD_BUILTIN"}, {"sha": "b16883fceb780544090a7f803454842afe9373db", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -10391,6 +10391,7 @@ is_base_type (tree type)\n     case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n+    case POINTER_BOUNDS_TYPE:\n       return 1;\n \n     case ARRAY_TYPE:\n@@ -17813,18 +17814,21 @@ gen_formal_types_die (tree function_or_method_type, dw_die_ref context_die)\n \tbreak;\n \n       /* Output a (nameless) DIE to represent the formal parameter itself.  */\n-      parm_die = gen_formal_parameter_die (formal_type, NULL,\n-\t\t\t\t\t   true /* Emit name attribute.  */,\n-\t\t\t\t\t   context_die);\n-      if (TREE_CODE (function_or_method_type) == METHOD_TYPE\n-\t  && link == first_parm_type)\n+      if (!POINTER_BOUNDS_TYPE_P (formal_type))\n \t{\n-\t  add_AT_flag (parm_die, DW_AT_artificial, 1);\n-\t  if (dwarf_version >= 3 || !dwarf_strict)\n-\t    add_AT_die_ref (context_die, DW_AT_object_pointer, parm_die);\n+\t  parm_die = gen_formal_parameter_die (formal_type, NULL,\n+\t\t\t\t\t       true /* Emit name attribute.  */,\n+\t\t\t\t\t       context_die);\n+\t  if (TREE_CODE (function_or_method_type) == METHOD_TYPE\n+\t      && link == first_parm_type)\n+\t    {\n+\t      add_AT_flag (parm_die, DW_AT_artificial, 1);\n+\t      if (dwarf_version >= 3 || !dwarf_strict)\n+\t\tadd_AT_die_ref (context_die, DW_AT_object_pointer, parm_die);\n+\t    }\n+\t  else if (arg && DECL_ARTIFICIAL (arg))\n+\t    add_AT_flag (parm_die, DW_AT_artificial, 1);\n \t}\n-      else if (arg && DECL_ARTIFICIAL (arg))\n-\tadd_AT_flag (parm_die, DW_AT_artificial, 1);\n \n       link = TREE_CHAIN (link);\n       if (arg)\n@@ -18598,7 +18602,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t    gen_formal_parameter_pack_die (generic_decl_parm,\n \t\t\t\t\t   parm, subr_die,\n \t\t\t\t\t   &parm);\n-\t  else if (parm)\n+\t  else if (parm && !POINTER_BOUNDS_P (parm))\n \t    {\n \t      dw_die_ref parm_die = gen_decl_die (parm, NULL, subr_die);\n \n@@ -18610,6 +18614,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n \t      parm = DECL_CHAIN (parm);\n \t    }\n+\t  else if (parm)\n+\t    parm = DECL_CHAIN (parm);\n \n \t  if (generic_decl_parm)\n \t    generic_decl_parm = DECL_CHAIN (generic_decl_parm);\n@@ -20103,6 +20109,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n+    case POINTER_BOUNDS_TYPE:\n       /* No DIEs needed for fundamental types.  */\n       break;\n \n@@ -20584,6 +20591,12 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n   if (DECL_P (decl_or_origin) && DECL_IGNORED_P (decl_or_origin))\n     return NULL;\n \n+  /* Ignore pointer bounds decls.  */\n+  if (DECL_P (decl_or_origin)\n+      && TREE_TYPE (decl_or_origin)\n+      && POINTER_BOUNDS_P (decl_or_origin))\n+    return NULL;\n+\n   switch (TREE_CODE (decl_or_origin))\n     {\n     case ERROR_MARK:\n@@ -20791,7 +20804,8 @@ dwarf2out_global_decl (tree decl)\n      declarations, file-scope (extern) function declarations (which\n      had no corresponding body) and file-scope tagged type declarations\n      and definitions which have not yet been forced out.  */\n-  if (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n+  if ((TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n+      && !POINTER_BOUNDS_P (decl))\n     dwarf2out_decl (decl);\n }\n "}, {"sha": "04f677eb608da65feae8153155bf59c7bbde9e10", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -640,7 +640,8 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, machine_mode mode)\n \t\t  || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n \t\t  /* We can get a 0 for an error mark.  */\n \t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT);\n+\t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n+\t\t  || GET_MODE_CLASS (mode) == MODE_POINTER_BOUNDS);\n \n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \treturn gen_int_mode (i0, mode);\n@@ -6129,6 +6130,14 @@ init_emit_once (void)\n   if (STORE_FLAG_VALUE == 1)\n     const_tiny_rtx[1][(int) BImode] = const1_rtx;\n \n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_POINTER_BOUNDS);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      wide_int wi_zero = wi::zero (GET_MODE_PRECISION (mode));\n+      const_tiny_rtx[0][mode] = immed_wide_int_const (wi_zero, mode);\n+    }\n+\n   pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);\n   ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);\n   simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);"}, {"sha": "6ae015cea66d53e2e219d5b156773f7e285c1a64", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -59,7 +59,8 @@ trunc_int_for_mode (HOST_WIDE_INT c, machine_mode mode)\n   int width = GET_MODE_PRECISION (mode);\n \n   /* You want to truncate to a _what_?  */\n-  gcc_assert (SCALAR_INT_MODE_P (mode));\n+  gcc_assert (SCALAR_INT_MODE_P (mode)\n+\t      || POINTER_BOUNDS_MODE_P (mode));\n \n   /* Canonicalize BImode to 0 and STORE_FLAG_VALUE.  */\n   if (mode == BImode)"}, {"sha": "f824cef3894f985ea983c243ade30a12af8fc4f9", "filename": "gcc/expr.c", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -79,6 +79,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-address.h\"\n #include \"cfgexpand.h\"\n #include \"builtins.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -5006,9 +5008,14 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t    || TREE_CODE (to) == SSA_NAME))\n     {\n       rtx value;\n+      rtx bounds;\n \n       push_temp_slots ();\n       value = expand_normal (from);\n+\n+      /* Split value and bounds to store them separately.  */\n+      chkp_split_slot (value, &value, &bounds);\n+\n       if (to_rtx == 0)\n \tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n@@ -5042,6 +5049,15 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n \t  emit_move_insn (to_rtx, value);\n \t}\n+\n+      /* Store bounds if required.  */\n+      if (bounds\n+\t  && (BOUNDED_P (to) || chkp_type_has_pointer (TREE_TYPE (to))))\n+\t{\n+\t  gcc_assert (MEM_P (to_rtx));\n+\t  chkp_emit_bounds_store (bounds, value, to_rtx);\n+\t}\n+\n       preserve_temp_slots (to_rtx);\n       pop_temp_slots ();\n       return;\n@@ -5117,7 +5133,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   /* Compute FROM and store the value in the rtx we got.  */\n \n   push_temp_slots ();\n-  result = store_expr (from, to_rtx, 0, nontemporal);\n+  result = store_expr_with_bounds (from, to_rtx, 0, nontemporal, to);\n   preserve_temp_slots (result);\n   pop_temp_slots ();\n   return;\n@@ -5154,10 +5170,14 @@ emit_storent_insn (rtx to, rtx from)\n    If CALL_PARAM_P is nonzero, this is a store into a call param on the\n    stack, and block moves may need to be treated specially.\n \n-   If NONTEMPORAL is true, try using a nontemporal store instruction.  */\n+   If NONTEMPORAL is true, try using a nontemporal store instruction.\n+\n+   If BTARGET is not NULL then computed bounds of EXP are\n+   associated with BTARGET.  */\n \n rtx\n-store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n+store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n+\t\t\tbool nontemporal, tree btarget)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n@@ -5178,8 +5198,8 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t part.  */\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n \t\t   call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n-      return store_expr (TREE_OPERAND (exp, 1), target, call_param_p,\n-\t\t\t nontemporal);\n+      return store_expr_with_bounds (TREE_OPERAND (exp, 1), target,\n+\t\t\t\t     call_param_p, nontemporal, btarget);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n     {\n@@ -5193,13 +5213,13 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);\n-      store_expr (TREE_OPERAND (exp, 1), target, call_param_p,\n-\t\t  nontemporal);\n+      store_expr_with_bounds (TREE_OPERAND (exp, 1), target, call_param_p,\n+\t\t\t      nontemporal, btarget);\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n-      store_expr (TREE_OPERAND (exp, 2), target, call_param_p,\n-\t\t  nontemporal);\n+      store_expr_with_bounds (TREE_OPERAND (exp, 2), target, call_param_p,\n+\t\t\t      nontemporal, btarget);\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n@@ -5251,6 +5271,19 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       temp = expand_expr (exp, inner_target, VOIDmode,\n \t\t\t  call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n \n+      /* Handle bounds returned by call.  */\n+      if (TREE_CODE (exp) == CALL_EXPR)\n+\t{\n+\t  rtx bounds;\n+\t  chkp_split_slot (temp, &temp, &bounds);\n+\t  if (bounds && btarget)\n+\t    {\n+\t      gcc_assert (TREE_CODE (btarget) == SSA_NAME);\n+\t      rtx tmp = targetm.calls.load_returned_bounds (bounds);\n+\t      chkp_set_rtl_bounds (btarget, tmp);\n+\t    }\n+\t}\n+\n       /* If TEMP is a VOIDmode constant, use convert_modes to make\n \t sure that we properly convert it.  */\n       if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)\n@@ -5332,6 +5365,19 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n \t\t\t       &alt_rtl, false);\n+\n+      /* Handle bounds returned by call.  */\n+      if (TREE_CODE (exp) == CALL_EXPR)\n+\t{\n+\t  rtx bounds;\n+\t  chkp_split_slot (temp, &temp, &bounds);\n+\t  if (bounds && btarget)\n+\t    {\n+\t      gcc_assert (TREE_CODE (btarget) == SSA_NAME);\n+\t      rtx tmp = targetm.calls.load_returned_bounds (bounds);\n+\t      chkp_set_rtl_bounds (btarget, tmp);\n+\t    }\n+\t}\n     }\n \n   /* If TEMP is a VOIDmode constant and the mode of the type of EXP is not\n@@ -5496,6 +5542,13 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \n   return NULL_RTX;\n }\n+\n+/* Same as store_expr_with_bounds but ignoring bounds of EXP.  */\n+rtx\n+store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n+{\n+  return store_expr_with_bounds (exp, target, call_param_p, nontemporal, NULL);\n+}\n \f\n /* Return true if field F of structure TYPE is a flexible array.  */\n "}, {"sha": "a188b6d6863ae2d6b3e724f2acb291bba2dbb061", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -272,6 +272,7 @@ extern void expand_assignment (tree, tree, bool);\n    and storing the value into TARGET.\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n+extern rtx store_expr_with_bounds (tree, rtx, int, bool, tree);\n extern rtx store_expr (tree, rtx, int, bool);\n \n /* Given an rtx that may include add and multiply operations,"}, {"sha": "0ffff5b77bc997215af22403db7e1c0fd09ee06c", "filename": "gcc/function.c", "status": "modified", "additions": 248, "deletions": 20, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -78,6 +78,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"shrink-wrap.h\"\n #include \"toplev.h\"\n #include \"rtl-iter.h\"\n+#include \"tree-chkp.h\"\n+#include \"rtl-chkp.h\"\n \n /* So we can assign to cfun in this file.  */\n #undef cfun\n@@ -2101,6 +2103,14 @@ use_register_for_decl (const_tree decl)\n   if (TREE_ADDRESSABLE (decl))\n     return false;\n \n+  /* Decl is implicitly addressible by bound stores and loads\n+     if it is an aggregate holding bounds.  */\n+  if (chkp_function_instrumented_p (current_function_decl)\n+      && TREE_TYPE (decl)\n+      && !BOUNDED_P (decl)\n+      && chkp_type_has_pointer (TREE_TYPE (decl)))\n+    return false;\n+\n   /* Only register-like things go in registers.  */\n   if (DECL_MODE (decl) == BLKmode)\n     return false;\n@@ -2221,6 +2231,15 @@ struct assign_parm_data_one\n   BOOL_BITFIELD loaded_in_reg : 1;\n };\n \n+struct bounds_parm_data\n+{\n+  assign_parm_data_one parm_data;\n+  tree bounds_parm;\n+  tree ptr_parm;\n+  rtx ptr_entry;\n+  int bound_no;\n+};\n+\n /* A subroutine of assign_parms.  Initialize ALL.  */\n \n static void\n@@ -2332,6 +2351,23 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n       fnargs.safe_insert (0, decl);\n \n       all->function_result_decl = decl;\n+\n+      /* If function is instrumented then bounds of the\n+\t passed structure address is the second argument.  */\n+      if (chkp_function_instrumented_p (fndecl))\n+\t{\n+\t  decl = build_decl (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t     PARM_DECL, get_identifier (\".result_bnd\"),\n+\t\t\t     pointer_bounds_type_node);\n+\t  DECL_ARG_TYPE (decl) = pointer_bounds_type_node;\n+\t  DECL_ARTIFICIAL (decl) = 1;\n+\t  DECL_NAMELESS (decl) = 1;\n+\t  TREE_CONSTANT (decl) = 1;\n+\n+\t  DECL_CHAIN (decl) = DECL_CHAIN (all->orig_fnargs);\n+\t  DECL_CHAIN (all->orig_fnargs) = decl;\n+\t  fnargs.safe_insert (1, decl);\n+\t}\n     }\n \n   /* If the target wants to split complex arguments into scalars, do so.  */\n@@ -2472,7 +2508,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n      it came in a register so that REG_PARM_STACK_SPACE isn't skipped.\n      In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 0\n      as it was the previous time.  */\n-  in_regs = entry_parm != 0;\n+  in_regs = (entry_parm != 0) || POINTER_BOUNDS_TYPE_P (data->passed_type);\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n   in_regs = true;\n #endif\n@@ -2561,8 +2597,12 @@ static bool\n assign_parm_is_stack_parm (struct assign_parm_data_all *all,\n \t\t\t   struct assign_parm_data_one *data)\n {\n+  /* Bounds are never passed on the stack to keep compatibility\n+     with not instrumented code.  */\n+  if (POINTER_BOUNDS_TYPE_P (data->passed_type))\n+    return false;\n   /* Trivially true if we've no incoming register.  */\n-  if (data->entry_parm == NULL)\n+  else if (data->entry_parm == NULL)\n     ;\n   /* Also true if we're partially in registers and partially not,\n      since we've arranged to drop the entire argument on the stack.  */\n@@ -3371,6 +3411,123 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n     }\n }\n \n+/* Load bounds of PARM from bounds table.  */\n+static void\n+assign_parm_load_bounds (struct assign_parm_data_one *data,\n+\t\t\t tree parm,\n+\t\t\t rtx entry,\n+\t\t\t unsigned bound_no)\n+{\n+  bitmap_iterator bi;\n+  unsigned i, offs = 0;\n+  int bnd_no = -1;\n+  rtx slot = NULL, ptr = NULL;\n+\n+  if (parm)\n+    {\n+      bitmap slots;\n+      bitmap_obstack_initialize (NULL);\n+      slots = BITMAP_ALLOC (NULL);\n+      chkp_find_bound_slots (TREE_TYPE (parm), slots);\n+      EXECUTE_IF_SET_IN_BITMAP (slots, 0, i, bi)\n+\t{\n+\t  if (bound_no)\n+\t    bound_no--;\n+\t  else\n+\t    {\n+\t      bnd_no = i;\n+\t      break;\n+\t    }\n+\t}\n+      BITMAP_FREE (slots);\n+      bitmap_obstack_release (NULL);\n+    }\n+\n+  /* We may have bounds not associated with any pointer.  */\n+  if (bnd_no != -1)\n+    offs = bnd_no * POINTER_SIZE / BITS_PER_UNIT;\n+\n+  /* Find associated pointer.  */\n+  if (bnd_no == -1)\n+    {\n+      /* If bounds are not associated with any bounds,\n+\t then it is passed in a register or special slot.  */\n+      gcc_assert (data->entry_parm);\n+      ptr = const0_rtx;\n+    }\n+  else if (MEM_P (entry))\n+    slot = adjust_address (entry, Pmode, offs);\n+  else if (REG_P (entry))\n+    ptr = gen_rtx_REG (Pmode, REGNO (entry) + bnd_no);\n+  else if (GET_CODE (entry) == PARALLEL)\n+    ptr = chkp_get_value_with_offs (entry, GEN_INT (offs));\n+  else\n+    gcc_unreachable ();\n+  data->entry_parm = targetm.calls.load_bounds_for_arg (slot, ptr,\n+\t\t\t\t\t\t\tdata->entry_parm);\n+}\n+\n+/* Assign RTL expressions to the function's bounds parameters BNDARGS.  */\n+\n+static void\n+assign_bounds (vec<bounds_parm_data> &bndargs,\n+\t       struct assign_parm_data_all &all)\n+{\n+  unsigned i, pass, handled = 0;\n+  bounds_parm_data *pbdata;\n+\n+  if (!bndargs.exists ())\n+    return;\n+\n+  /* We make few passes to store input bounds.  Firstly handle bounds\n+     passed in registers.  After that we load bounds passed in special\n+     slots.  Finally we load bounds from Bounds Table.  */\n+  for (pass = 0; pass < 3; pass++)\n+    FOR_EACH_VEC_ELT (bndargs, i, pbdata)\n+      {\n+\t/* Pass 0 => regs only.  */\n+\tif (pass == 0\n+\t    && (!pbdata->parm_data.entry_parm\n+\t\t|| GET_CODE (pbdata->parm_data.entry_parm) != REG))\n+\t  continue;\n+\t/* Pass 1 => slots only.  */\n+\telse if (pass == 1\n+\t\t && (!pbdata->parm_data.entry_parm\n+\t\t     || GET_CODE (pbdata->parm_data.entry_parm) == REG))\n+\t  continue;\n+\t/* Pass 2 => BT only.  */\n+\telse if (pass == 2\n+\t\t && pbdata->parm_data.entry_parm)\n+\t  continue;\n+\n+\tif (!pbdata->parm_data.entry_parm\n+\t    || GET_CODE (pbdata->parm_data.entry_parm) != REG)\n+\t  assign_parm_load_bounds (&pbdata->parm_data, pbdata->ptr_parm,\n+\t\t\t\t   pbdata->ptr_entry, pbdata->bound_no);\n+\n+\tset_decl_incoming_rtl (pbdata->bounds_parm,\n+\t\t\t       pbdata->parm_data.entry_parm, false);\n+\n+\tif (assign_parm_setup_block_p (&pbdata->parm_data))\n+\t  assign_parm_setup_block (&all, pbdata->bounds_parm,\n+\t\t\t\t   &pbdata->parm_data);\n+\telse if (pbdata->parm_data.passed_pointer\n+\t\t || use_register_for_decl (pbdata->bounds_parm))\n+\t  assign_parm_setup_reg (&all, pbdata->bounds_parm,\n+\t\t\t\t &pbdata->parm_data);\n+\telse\n+\t  assign_parm_setup_stack (&all, pbdata->bounds_parm,\n+\t\t\t\t   &pbdata->parm_data);\n+\n+\t/* Count handled bounds to make sure we miss nothing.  */\n+\thandled++;\n+      }\n+\n+  gcc_assert (handled == bndargs.length ());\n+\n+  bndargs.release ();\n+}\n+\n /* Assign RTL expressions to the function's parameters.  This may involve\n    copying them into registers and using those registers as the DECL_RTL.  */\n \n@@ -3380,7 +3537,11 @@ assign_parms (tree fndecl)\n   struct assign_parm_data_all all;\n   tree parm;\n   vec<tree> fnargs;\n-  unsigned i;\n+  unsigned i, bound_no = 0;\n+  tree last_arg = NULL;\n+  rtx last_arg_entry = NULL;\n+  vec<bounds_parm_data> bndargs = vNULL;\n+  bounds_parm_data bdata;\n \n   crtl->args.internal_arg_pointer\n     = targetm.calls.internal_arg_pointer ();\n@@ -3422,9 +3583,6 @@ assign_parms (tree fndecl)\n \t    }\n \t}\n \n-      if (cfun->stdarg && !DECL_CHAIN (parm))\n-\tassign_parms_setup_varargs (&all, &data, false);\n-\n       /* Find out where the parameter arrives in this function.  */\n       assign_parm_find_entry_rtl (&all, &data);\n \n@@ -3434,7 +3592,15 @@ assign_parms (tree fndecl)\n \t  assign_parm_find_stack_rtl (parm, &data);\n \t  assign_parm_adjust_entry_rtl (&data);\n \t}\n-\n+      if (!POINTER_BOUNDS_TYPE_P (data.passed_type))\n+\t{\n+\t  /* Remember where last non bounds arg was passed in case\n+\t     we have to load associated bounds for it from Bounds\n+\t     Table.  */\n+\t  last_arg = parm;\n+\t  last_arg_entry = data.entry_parm;\n+\t  bound_no = 0;\n+\t}\n       /* Record permanently how this parm was passed.  */\n       if (data.passed_pointer)\n \t{\n@@ -3446,20 +3612,63 @@ assign_parms (tree fndecl)\n       else\n \tset_decl_incoming_rtl (parm, data.entry_parm, false);\n \n+      /* Boudns should be loaded in the particular order to\n+\t have registers allocated correctly.  Collect info about\n+\t input bounds and load them later.  */\n+      if (POINTER_BOUNDS_TYPE_P (data.passed_type))\n+\t{\n+\t  /* Expect bounds in instrumented functions only.  */\n+\t  gcc_assert (chkp_function_instrumented_p (fndecl));\n+\n+\t  bdata.parm_data = data;\n+\t  bdata.bounds_parm = parm;\n+\t  bdata.ptr_parm = last_arg;\n+\t  bdata.ptr_entry = last_arg_entry;\n+\t  bdata.bound_no = bound_no;\n+\t  bndargs.safe_push (bdata);\n+\t}\n+      else\n+\t{\n+\t  assign_parm_adjust_stack_rtl (&data);\n+\n+\t  if (assign_parm_setup_block_p (&data))\n+\t    assign_parm_setup_block (&all, parm, &data);\n+\t  else if (data.passed_pointer || use_register_for_decl (parm))\n+\t    assign_parm_setup_reg (&all, parm, &data);\n+\t  else\n+\t    assign_parm_setup_stack (&all, parm, &data);\n+\t}\n+\n+      if (cfun->stdarg && !DECL_CHAIN (parm))\n+\t{\n+\t  int pretend_bytes = 0;\n+\n+\t  assign_parms_setup_varargs (&all, &data, false);\n+\n+\t  if (chkp_function_instrumented_p (fndecl))\n+\t    {\n+\t      /* We expect this is the last parm.  Otherwise it is wrong\n+\t\t to assign bounds right now.  */\n+\t      gcc_assert (i == (fnargs.length () - 1));\n+\t      assign_bounds (bndargs, all);\n+\t      targetm.calls.setup_incoming_vararg_bounds (all.args_so_far,\n+\t\t\t\t\t\t\t  data.promoted_mode,\n+\t\t\t\t\t\t\t  data.passed_type,\n+\t\t\t\t\t\t\t  &pretend_bytes,\n+\t\t\t\t\t\t\t  false);\n+\t    }\n+\t}\n+\n       /* Update info on where next arg arrives in registers.  */\n       targetm.calls.function_arg_advance (all.args_so_far, data.promoted_mode,\n \t\t\t\t\t  data.passed_type, data.named_arg);\n \n-      assign_parm_adjust_stack_rtl (&data);\n-\n-      if (assign_parm_setup_block_p (&data))\n-\tassign_parm_setup_block (&all, parm, &data);\n-      else if (data.passed_pointer || use_register_for_decl (parm))\n-\tassign_parm_setup_reg (&all, parm, &data);\n-      else\n-\tassign_parm_setup_stack (&all, parm, &data);\n+      if (POINTER_BOUNDS_TYPE_P (data.passed_type))\n+\tbound_no++;\n     }\n \n+  assign_bounds (bndargs, all);\n+\n   if (targetm.calls.split_complex_arg)\n     assign_parms_unsplit_complex (&all, fnargs);\n \n@@ -3585,6 +3794,10 @@ assign_parms (tree fndecl)\n \n \t  real_decl_rtl = targetm.calls.function_value (TREE_TYPE (decl_result),\n \t\t\t\t\t\t\tfndecl, true);\n+\t  if (chkp_function_instrumented_p (fndecl))\n+\t    crtl->return_bnd\n+\t      = targetm.calls.chkp_function_value_bounds (TREE_TYPE (decl_result),\n+\t\t\t\t\t\t\t  fndecl, true);\n \t  REG_FUNCTION_VALUE_P (real_decl_rtl) = 1;\n \t  /* The delay slot scheduler assumes that crtl->return_rtx\n \t     holds the hard register containing the return value, not a\n@@ -4815,6 +5028,14 @@ expand_function_start (tree subr)\n       /* Set DECL_REGISTER flag so that expand_function_end will copy the\n \t result to the real return register(s).  */\n       DECL_REGISTER (DECL_RESULT (subr)) = 1;\n+\n+      if (chkp_function_instrumented_p (current_function_decl))\n+\t{\n+\t  tree return_type = TREE_TYPE (DECL_RESULT (subr));\n+\t  rtx bounds = targetm.calls.chkp_function_value_bounds (return_type,\n+\t\t\t\t\t\t\t\t subr, 1);\n+\t  SET_DECL_BOUNDS_RTL (DECL_RESULT (subr), bounds);\n+\t}\n     }\n \n   /* Initialize rtx for parameters and local variables.\n@@ -4918,14 +5139,11 @@ expand_dummy_function_end (void)\n   in_dummy_function = false;\n }\n \n-/* Call DOIT for each hard register used as a return value from\n-   the current function.  */\n+/* Helper for diddle_return_value.  */\n \n void\n-diddle_return_value (void (*doit) (rtx, void *), void *arg)\n+diddle_return_value_1 (void (*doit) (rtx, void *), void *arg, rtx outgoing)\n {\n-  rtx outgoing = crtl->return_rtx;\n-\n   if (! outgoing)\n     return;\n \n@@ -4945,6 +5163,16 @@ diddle_return_value (void (*doit) (rtx, void *), void *arg)\n     }\n }\n \n+/* Call DOIT for each hard register used as a return value from\n+   the current function.  */\n+\n+void\n+diddle_return_value (void (*doit) (rtx, void *), void *arg)\n+{\n+  diddle_return_value_1 (doit, arg, crtl->return_rtx);\n+  diddle_return_value_1 (doit, arg, crtl->return_bnd);\n+}\n+\n static void\n do_clobber_return_reg (rtx reg, void *arg ATTRIBUTE_UNUSED)\n {"}, {"sha": "326e24b201a9f75adfb9d17f6b44123dad3b8726", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -246,6 +246,9 @@ struct GTY(()) rtl_data {\n      result in a register, current_function_return_rtx will always be\n      the hard register containing the result.  */\n   rtx return_rtx;\n+  /* If nonxero, an RTL expression for the lcoation at which the current\n+     function returns bounds for its result.  */\n+  rtx return_bnd;\n \n   /* Vector of initial-value pairs.  Each pair consists of a pseudo\n      register of approprite mode that stores the initial value a hard"}, {"sha": "30fb4fc745571c66c2efce0f0655d2f527a455ac", "filename": "gcc/genmodes.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -336,6 +336,7 @@ complete_mode (struct mode_data *m)\n       break;\n \n     case MODE_INT:\n+    case MODE_POINTER_BOUNDS:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n     case MODE_FRACT:\n@@ -537,6 +538,19 @@ make_special_mode (enum mode_class cl, const char *name,\n   new_mode (cl, name, file, line);\n }\n \n+#define POINTER_BOUNDS_MODE(N, Y) \\\n+  make_pointer_bounds_mode (#N, Y, __FILE__, __LINE__)\n+\n+static void ATTRIBUTE_UNUSED\n+make_pointer_bounds_mode (const char *name,\n+\t\t\t  unsigned int bytesize,\n+\t\t\t  const char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (MODE_POINTER_BOUNDS, name, file, line);\n+  m->bytesize = bytesize;\n+}\n+\n+\n #define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1U, Y)\n #define FRACTIONAL_INT_MODE(N, B, Y) \\\n   make_int_mode (#N, B, Y, __FILE__, __LINE__)"}, {"sha": "33b85d289659db386accfb2dd3cfb924cc681b19", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -567,11 +567,12 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n static void\n dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n-  tree t;\n+  tree t, t2;\n \n   t = gimple_return_retval (gs);\n+  t2 = gimple_return_retbnd (gs);\n   if (flags & TDF_RAW)\n-    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, t);\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T %T>\", gs, t, t2);\n   else\n     {\n       pp_string (buffer, \"return\");\n@@ -580,6 +581,11 @@ dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t  pp_space (buffer);\n \t  dump_generic_node (buffer, t, spc, flags, false);\n \t}\n+      if (t2)\n+\t{\n+\t  pp_string (buffer, \", \");\n+\t  dump_generic_node (buffer, t2, spc, flags, false);\n+\t}\n       pp_semicolon (buffer);\n     }\n }"}, {"sha": "62f172b5a688149a3af0961689fe95094e2bd050", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -191,7 +191,7 @@ gimple_build_with_ops_stat (enum gimple_code code, unsigned subcode,\n gimple\n gimple_build_return (tree retval)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 1);\n+  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 2);\n   if (retval)\n     gimple_return_set_retval (s, retval);\n   return s;\n@@ -378,6 +378,7 @@ gimple_build_call_from_tree (tree t)\n   gimple_call_set_va_arg_pack (call, CALL_EXPR_VA_ARG_PACK (t));\n   gimple_call_set_nothrow (call, TREE_NOTHROW (t));\n   gimple_set_no_warning (call, TREE_NO_WARNING (t));\n+  gimple_call_set_with_bounds (call, CALL_WITH_BOUNDS_P (t));\n \n   return call;\n }"}, {"sha": "c7aaa815b819720de9a406482867b011f44a1cae", "filename": "gcc/gimple.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -91,6 +91,7 @@ enum gf_mask {\n     GF_CALL_ALLOCA_FOR_VAR\t= 1 << 5,\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n+    GF_CALL_WITH_BOUNDS \t= 1 << 8,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_FOR_KIND_MASK\t= 7 << 0,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n@@ -2453,6 +2454,31 @@ gimple_call_internal_p (const_gimple gs)\n }\n \n \n+/* Return true if call GS is marked as instrumented by\n+   Pointer Bounds Checker.  */\n+\n+static inline bool\n+gimple_call_with_bounds_p (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  return (gs->subcode & GF_CALL_WITH_BOUNDS) != 0;\n+}\n+\n+\n+/* If INSTRUMENTED_P is true, marm statement GS as instrumented by\n+   Pointer Bounds Checker.  */\n+\n+static inline void\n+gimple_call_set_with_bounds (gimple gs, bool with_bounds)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  if (with_bounds)\n+    gs->subcode |= GF_CALL_WITH_BOUNDS;\n+  else\n+    gs->subcode &= ~GF_CALL_WITH_BOUNDS;\n+}\n+\n+\n /* Return the target of internal call GS.  */\n \n static inline enum internal_fn\n@@ -5555,6 +5581,26 @@ gimple_return_set_retval (gimple gs, tree retval)\n }\n \n \n+/* Return the return bounds for GIMPLE_RETURN GS.  */\n+\n+static inline tree\n+gimple_return_retbnd (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_RETURN);\n+  return gimple_op (gs, 1);\n+}\n+\n+\n+/* Set RETVAL to be the return bounds for GIMPLE_RETURN GS.  */\n+\n+static inline void\n+gimple_return_set_retbnd (gimple gs, tree retval)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_RETURN);\n+  gimple_set_op (gs, 1, retval);\n+}\n+\n+\n /* Returns true when the gimple statement STMT is any of the OpenMP types.  */\n \n #define CASE_GIMPLE_OMP\t\t\t\t\\"}, {"sha": "f5afc0da292b3062c946223287b911e440f65f01", "filename": "gcc/gimplify.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -3862,10 +3862,19 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   individual element initialization.  Also don't do this for small\n \t   all-zero initializers (which aren't big enough to merit\n \t   clearing), and don't try to make bitwise copies of\n-\t   TREE_ADDRESSABLE types.  */\n+\t   TREE_ADDRESSABLE types.\n+\n+\t   We cannot apply such transformation when compiling chkp static\n+\t   initializer because creation of initializer image in the memory\n+\t   will require static initialization of bounds for it.  It should\n+\t   result in another gimplification of similar initializer and we\n+\t   may fall into infinite loop.  */\n \tif (valid_const_initializer\n \t    && !(cleared || num_nonzero_elements == 0)\n-\t    && !TREE_ADDRESSABLE (type))\n+\t    && !TREE_ADDRESSABLE (type)\n+\t    && (!current_function_decl\n+\t\t|| !lookup_attribute (\"chkp ctor\",\n+\t\t\t\t      DECL_ATTRIBUTES (current_function_decl))))\n \t  {\n \t    HOST_WIDE_INT size = int_size_in_bytes (type);\n \t    unsigned int align;"}, {"sha": "f910583907d34f89d81b37c124acd94c3d27ab5d", "filename": "gcc/ipa-chkp.c", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,647 @@\n+/* Pointer Bounds Checker IPA passes.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"stringpool.h\"\n+#include \"bitmap.h\"\n+#include \"gimple-expr.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"function.h\"\n+#include \"is-a.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"predict.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"ipa-ref.h\"\n+#include \"lto-streamer.h\"\n+#include \"cgraph.h\"\n+#include \"tree-chkp.h\"\n+#include \"ipa-chkp.h\"\n+#include <string>\n+\n+/*  Pointer Bounds Checker has two IPA passes to support code instrumentation.\n+\n+    In instrumented code each pointer is provided with bounds.  For input\n+    pointer parameters it means we also have bounds passed.  For calls it\n+    means we have additional bounds arguments for pointer arguments.\n+\n+    To have all IPA optimizations working correctly we have to express\n+    dataflow between passed and received bounds explicitly via additional\n+    entries in function declaration arguments list and in function type.\n+    Since we may have both instrumented and not instrumented code at the\n+    same time, we cannot replace all original functions with their\n+    instrumented variants.  Therefore we create clones (versions) instead.\n+\n+    Instrumentation clones creation is a separate IPA pass which is a part\n+    of early local passes.  Clones are created after SSA is built (because\n+    instrumentation pass works on SSA) and before any transformations\n+    which may change pointer flow and therefore lead to incorrect code\n+    instrumentation (possibly causing false bounds check failures).\n+\n+    Instrumentation clones have pointer bounds arguments added right after\n+    pointer arguments.  Clones have assembler name of the original\n+    function with suffix added.  New assembler name is in transparent\n+    alias chain with the original name.  Thus we expect all calls to the\n+    original and instrumented functions look similar in assembler.\n+\n+    During instrumentation versioning pass we create instrumented versions\n+    of all function with body and also for all their aliases and thunks.\n+    Clones for functions with no body are created on demand (usually\n+    during call instrumentation).\n+\n+    Original and instrumented function nodes are connected with IPA\n+    reference IPA_REF_CHKP.  It is mostly done to have reachability\n+    analysis working correctly.  We may have no references to the\n+    instrumented function in the code but it still should be counted\n+    as reachable if the original function is reachable.\n+\n+    When original function bodies are not needed anymore we release\n+    them and transform functions into a special kind of thunks.  Each\n+    thunk has a call edge to the instrumented version.  These thunks\n+    help to keep externally visible instrumented functions visible\n+    when linker resolution files are used.  Linker has no info about\n+    connection between original and instrumented function and\n+    therefore we may wrongly decide (due to difference in assembler\n+    names) that instrumented function version is local and can be\n+    removed.  */\n+\n+#define CHKP_BOUNDS_OF_SYMBOL_PREFIX \"__chkp_bounds_of_\"\n+\n+/* Build a clone of FNDECL with a modified name.  */\n+\n+static tree\n+chkp_build_instrumented_fndecl (tree fndecl)\n+{\n+  tree new_decl = copy_node (fndecl);\n+  tree new_name;\n+  std::string s;\n+\n+  /* called_as_built_in checks DECL_NAME to identify calls to\n+     builtins.  We want instrumented calls to builtins to be\n+     recognized by called_as_built_in.  Therefore use original\n+     DECL_NAME for cloning with no prefixes.  */\n+  s = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  s += \".chkp\";\n+  DECL_NAME (new_decl) = get_identifier (s.c_str ());\n+\n+  /* References to the original and to the instrumented version\n+     should look the same in the output assembly.  And we cannot\n+     use the same assembler name for the instrumented version\n+     because it conflicts with decl merging algorithms in LTO.\n+     Achieve the result by using transparent alias name for the\n+     instrumented version.  */\n+  s = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+  s += \".chkp\";\n+  new_name = get_identifier (s.c_str ());\n+  IDENTIFIER_TRANSPARENT_ALIAS (new_name) = 1;\n+  TREE_CHAIN (new_name) = DECL_ASSEMBLER_NAME (fndecl);\n+  SET_DECL_ASSEMBLER_NAME (new_decl, new_name);\n+\n+  /* For functions with body versioning will make a copy of arguments.\n+     For functions with no body we need to do it here.  */\n+  if (!gimple_has_body_p (fndecl))\n+    DECL_ARGUMENTS (new_decl) = copy_list (DECL_ARGUMENTS (fndecl));\n+\n+  /* We are going to modify attributes list and therefore should\n+     make own copy.  */\n+  DECL_ATTRIBUTES (new_decl) = copy_list (DECL_ATTRIBUTES (fndecl));\n+\n+  return new_decl;\n+}\n+\n+\n+/* Fix operands of attribute from ATTRS list named ATTR_NAME.\n+   Integer operands are replaced with values according to\n+   INDEXES map having LEN elements.  For operands out of len\n+   we just add DELTA.  */\n+\n+static void\n+chkp_map_attr_arg_indexes (tree attrs, const char *attr_name,\n+\t\t\t   unsigned *indexes, int len, int delta)\n+{\n+  tree attr = lookup_attribute (attr_name, attrs);\n+  tree op;\n+\n+  if (!attr)\n+    return;\n+\n+  TREE_VALUE (attr) = copy_list (TREE_VALUE (attr));\n+  for (op = TREE_VALUE (attr); op; op = TREE_CHAIN (op))\n+    {\n+      int idx;\n+\n+      if (TREE_CODE (TREE_VALUE (op)) != INTEGER_CST)\n+\tcontinue;\n+\n+      idx = TREE_INT_CST_LOW (TREE_VALUE (op));\n+\n+      /* If idx exceeds indexes length then we just\n+\t keep it at the same distance from the last\n+\t known arg.  */\n+      if (idx > len)\n+\tidx += delta;\n+      else\n+\tidx = indexes[idx - 1] + 1;\n+      TREE_VALUE (op) = build_int_cst (TREE_TYPE (TREE_VALUE (op)), idx);\n+    }\n+}\n+\n+/* Make a copy of function type ORIG_TYPE adding pointer\n+   bounds as additional arguments.  */\n+\n+tree\n+chkp_copy_function_type_adding_bounds (tree orig_type)\n+{\n+  tree type;\n+  tree arg_type, attrs, t;\n+  unsigned len = list_length (TYPE_ARG_TYPES (orig_type));\n+  unsigned *indexes = XALLOCAVEC (unsigned, len);\n+  unsigned idx = 0, new_idx = 0;\n+\n+  for (arg_type = TYPE_ARG_TYPES (orig_type);\n+       arg_type;\n+       arg_type = TREE_CHAIN (arg_type))\n+    if (TREE_VALUE (arg_type) == void_type_node)\n+      continue;\n+    else if (BOUNDED_TYPE_P (TREE_VALUE (arg_type))\n+\t     || pass_by_reference (NULL, TYPE_MODE (TREE_VALUE (arg_type)),\n+\t\t\t\t   TREE_VALUE (arg_type), true)\n+\t     || chkp_type_has_pointer (TREE_VALUE (arg_type)))\n+      break;\n+\n+  /* We may use original type if there are no bounds passed.  */\n+  if (!arg_type)\n+    return orig_type;\n+\n+  type = copy_node (orig_type);\n+  TYPE_ARG_TYPES (type) = copy_list (TYPE_ARG_TYPES (type));\n+\n+  for (arg_type = TYPE_ARG_TYPES (type);\n+       arg_type;\n+       arg_type = TREE_CHAIN (arg_type))\n+    {\n+      indexes[idx++] = new_idx++;\n+\n+      /* pass_by_reference returns 1 for void type,\n+\t so check for it first.  */\n+      if (TREE_VALUE (arg_type) == void_type_node)\n+\tcontinue;\n+      else if (BOUNDED_TYPE_P (TREE_VALUE (arg_type))\n+\t       || pass_by_reference (NULL, TYPE_MODE (TREE_VALUE (arg_type)),\n+\t\t\t\t     TREE_VALUE (arg_type), true))\n+\t{\n+\t  tree new_type = build_tree_list (NULL_TREE,\n+\t\t\t\t\t   pointer_bounds_type_node);\n+\t  TREE_CHAIN (new_type) = TREE_CHAIN (arg_type);\n+\t  TREE_CHAIN (arg_type) = new_type;\n+\n+\t  arg_type = TREE_CHAIN (arg_type);\n+\t  new_idx++;\n+\t}\n+      else if (chkp_type_has_pointer (TREE_VALUE (arg_type)))\n+\t{\n+\t  bitmap slots = BITMAP_ALLOC (NULL);\n+\t  bitmap_iterator bi;\n+\t  unsigned bnd_no;\n+\n+\t  chkp_find_bound_slots (TREE_VALUE (arg_type), slots);\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (slots, 0, bnd_no, bi)\n+\t    {\n+\t      tree new_type = build_tree_list (NULL_TREE,\n+\t\t\t\t\t       pointer_bounds_type_node);\n+\t      TREE_CHAIN (new_type) = TREE_CHAIN (arg_type);\n+\t      TREE_CHAIN (arg_type) = new_type;\n+\n+\t      arg_type = TREE_CHAIN (arg_type);\n+\t      new_idx++;\n+\t    }\n+\t  BITMAP_FREE (slots);\n+\t}\n+    }\n+\n+  /* If function type has attribute with arg indexes then\n+     we have to copy it fixing attribute ops.  Map for\n+     fixing is in indexes array.  */\n+  attrs = TYPE_ATTRIBUTES (type);\n+  if (lookup_attribute (\"nonnull\", attrs)\n+      || lookup_attribute (\"format\", attrs)\n+      || lookup_attribute (\"format_arg\", attrs))\n+    {\n+      int delta = new_idx - len;\n+      attrs = copy_list (TYPE_ATTRIBUTES (type));\n+      chkp_map_attr_arg_indexes (attrs, \"nonnull\", indexes, len, delta);\n+      chkp_map_attr_arg_indexes (attrs, \"format\", indexes, len, delta);\n+      chkp_map_attr_arg_indexes (attrs, \"format_arg\", indexes, len, delta);\n+      TYPE_ATTRIBUTES (type) = attrs;\n+    }\n+\n+  t = TYPE_MAIN_VARIANT (orig_type);\n+  if (orig_type != t)\n+    {\n+      TYPE_MAIN_VARIANT (type) = t;\n+      TYPE_NEXT_VARIANT (type) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = type;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (type) = type;\n+      TYPE_NEXT_VARIANT (type) = NULL;\n+    }\n+\n+\n+  return type;\n+}\n+\n+/* For given function FNDECL add bounds arguments to arguments\n+   list.  */\n+\n+static void\n+chkp_add_bounds_params_to_function (tree fndecl)\n+{\n+  tree arg;\n+\n+  for (arg = DECL_ARGUMENTS (fndecl); arg; arg = DECL_CHAIN (arg))\n+    if (BOUNDED_P (arg))\n+      {\n+\tstd::string new_name = CHKP_BOUNDS_OF_SYMBOL_PREFIX;\n+\ttree new_arg;\n+\n+\tif (DECL_NAME (arg))\n+\t  new_name += IDENTIFIER_POINTER (DECL_NAME (arg));\n+\telse\n+\t  {\n+\t    char uid[25];\n+\t    snprintf (uid, 25, \"D.%u\", DECL_UID (arg));\n+\t    new_name += uid;\n+\t  }\n+\n+\tnew_arg = build_decl (DECL_SOURCE_LOCATION (arg), PARM_DECL,\n+\t\t\t      get_identifier (new_name.c_str ()),\n+\t\t\t      pointer_bounds_type_node);\n+\tDECL_ARG_TYPE (new_arg) = pointer_bounds_type_node;\n+\tDECL_CONTEXT (new_arg) = DECL_CONTEXT (arg);\n+\tDECL_ARTIFICIAL (new_arg) = 1;\n+\tDECL_CHAIN (new_arg) = DECL_CHAIN (arg);\n+\tDECL_CHAIN (arg) = new_arg;\n+\n+\targ = DECL_CHAIN (arg);\n+\n+      }\n+    else if (chkp_type_has_pointer (TREE_TYPE (arg)))\n+      {\n+\ttree orig_arg = arg;\n+\tbitmap slots = BITMAP_ALLOC (NULL);\n+\tbitmap_iterator bi;\n+\tunsigned bnd_no;\n+\n+\tchkp_find_bound_slots (TREE_TYPE (arg), slots);\n+\n+\tEXECUTE_IF_SET_IN_BITMAP (slots, 0, bnd_no, bi)\n+\t  {\n+\t    std::string new_name = CHKP_BOUNDS_OF_SYMBOL_PREFIX;\n+\t    tree new_arg;\n+\t    char offs[25];\n+\n+\t    if (DECL_NAME (orig_arg))\n+\t      new_name += IDENTIFIER_POINTER (DECL_NAME (orig_arg));\n+\t    else\n+\t      {\n+\t\tsnprintf (offs, 25, \"D.%u\", DECL_UID (arg));\n+\t\tnew_name += offs;\n+\t      }\n+\t    snprintf (offs, 25, \"__%u\", bnd_no * POINTER_SIZE / BITS_PER_UNIT);\n+\n+\t    new_arg = build_decl (DECL_SOURCE_LOCATION (orig_arg),\n+\t\t\t\t  PARM_DECL,\n+\t\t\t\t  get_identifier (new_name.c_str ()),\n+\t\t\t\t  pointer_bounds_type_node);\n+\t    DECL_ARG_TYPE (new_arg) = pointer_bounds_type_node;\n+\t    DECL_CONTEXT (new_arg) = DECL_CONTEXT (orig_arg);\n+\t    DECL_ARTIFICIAL (new_arg) = 1;\n+\t    DECL_CHAIN (new_arg) = DECL_CHAIN (arg);\n+\t    DECL_CHAIN (arg) = new_arg;\n+\n+\t    arg = DECL_CHAIN (arg);\n+\t  }\n+\tBITMAP_FREE (slots);\n+      }\n+\n+  TREE_TYPE (fndecl) =\n+    chkp_copy_function_type_adding_bounds (TREE_TYPE (fndecl));\n+}\n+\n+/* Return clone created for instrumentation of NODE or NULL.  */\n+\n+cgraph_node *\n+chkp_maybe_create_clone (tree fndecl)\n+{\n+  cgraph_node *node = cgraph_node::get_create (fndecl);\n+  cgraph_node *clone = node->instrumented_version;\n+\n+  gcc_assert (!node->instrumentation_clone);\n+\n+  if (!clone)\n+    {\n+      tree new_decl = chkp_build_instrumented_fndecl (fndecl);\n+      struct cgraph_edge *e;\n+      struct ipa_ref *ref;\n+      int i;\n+\n+      clone = node->create_version_clone (new_decl, vNULL, NULL);\n+      clone->externally_visible = node->externally_visible;\n+      clone->local = node->local;\n+      clone->address_taken = node->address_taken;\n+      clone->thunk = node->thunk;\n+      clone->alias = node->alias;\n+      clone->weakref = node->weakref;\n+      clone->cpp_implicit_alias = node->cpp_implicit_alias;\n+      clone->instrumented_version = node;\n+      clone->orig_decl = fndecl;\n+      clone->instrumentation_clone = true;\n+      node->instrumented_version = clone;\n+\n+      if (gimple_has_body_p (fndecl))\n+\t{\n+\t  /* If function will not be instrumented, then it's instrumented\n+\t     version is a thunk for the original.  */\n+\t  if (lookup_attribute (\"bnd_legacy\", DECL_ATTRIBUTES (fndecl))\n+\t      || (flag_chkp_instrument_marked_only\n+\t\t  && !lookup_attribute (\"bnd_instrument\", DECL_ATTRIBUTES (fndecl))))\n+\t    {\n+\t      clone->thunk.thunk_p = true;\n+\t      clone->thunk.add_pointer_bounds_args = true;\n+\t      clone->create_edge (node, NULL, 0, CGRAPH_FREQ_BASE);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree_function_versioning (fndecl, new_decl, NULL, false,\n+\t\t\t\t\tNULL, false, NULL, NULL);\n+\t      clone->lowered = true;\n+\t    }\n+\t}\n+\n+      /* New params are inserted after versioning because it\n+\t actually copies args list from the original decl.  */\n+      chkp_add_bounds_params_to_function (new_decl);\n+\n+      /* Clones have the same comdat group as originals.  */\n+      if (node->same_comdat_group\n+\t  || DECL_ONE_ONLY (node->decl))\n+\tclone->add_to_same_comdat_group (node);\n+\n+      if (gimple_has_body_p (fndecl))\n+\tsymtab->call_cgraph_insertion_hooks (clone);\n+\n+      /* Clone all aliases.  */\n+      for (i = 0; node->iterate_referring (i, ref); i++)\n+\tif (ref->use == IPA_REF_ALIAS)\n+\t  {\n+\t    struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+\t    struct cgraph_node *chkp_alias\n+\t      = chkp_maybe_create_clone (alias->decl);\n+\t    chkp_alias->create_reference (clone, IPA_REF_ALIAS, NULL);\n+\t  }\n+\n+      /* Clone all thunks.  */\n+      for (e = node->callers; e; e = e->next_caller)\n+\tif (e->caller->thunk.thunk_p)\n+\t  {\n+\t    struct cgraph_node *thunk\n+\t      = chkp_maybe_create_clone (e->caller->decl);\n+\t    /* Redirect thunk clone edge to the node clone.  */\n+\t    thunk->callees->redirect_callee (clone);\n+\t  }\n+\n+      /* For aliases and thunks we should make sure target is cloned\n+\t to have proper references and edges.  */\n+      if (node->thunk.thunk_p)\n+\tchkp_maybe_create_clone (node->callees->callee->decl);\n+      else if (node->alias)\n+\t{\n+\t  struct cgraph_node *target;\n+\n+\t  ref = node->ref_list.first_reference ();\n+\t  if (ref)\n+\t    chkp_maybe_create_clone (ref->referred->decl);\n+\n+\t  if (node->alias_target)\n+\t    {\n+\t      if (TREE_CODE (node->alias_target) == FUNCTION_DECL)\n+\t\t{\n+\t\t  target = chkp_maybe_create_clone (node->alias_target);\n+\t\t  clone->alias_target = target->decl;\n+\t\t}\n+\t      else\n+\t\tclone->alias_target = node->alias_target;\n+\t    }\n+\t}\n+\n+      /* Add IPA reference.  It's main role is to keep instrumented\n+\t version reachable while original node is reachable.  */\n+      ref = node->create_reference (clone, IPA_REF_CHKP, NULL);\n+    }\n+\n+  return clone;\n+}\n+\n+/* Create clone for all functions to be instrumented.  */\n+\n+static unsigned int\n+chkp_versioning (void)\n+{\n+  struct cgraph_node *node;\n+\n+  bitmap_obstack_initialize (NULL);\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      if (!node->instrumentation_clone\n+\t  && !node->instrumented_version\n+\t  && !node->alias\n+\t  && !node->thunk.thunk_p\n+\t  && !lookup_attribute (\"bnd_legacy\", DECL_ATTRIBUTES (node->decl))\n+\t  && (!flag_chkp_instrument_marked_only\n+\t      || lookup_attribute (\"bnd_instrument\",\n+\t\t\t\t   DECL_ATTRIBUTES (node->decl)))\n+\t  /* No builtins instrumentation for now.  */\n+\t  && DECL_BUILT_IN_CLASS (node->decl) == NOT_BUILT_IN)\n+\tchkp_maybe_create_clone (node->decl);\n+    }\n+\n+  /* Mark all aliases and thunks of functions with no instrumented\n+     version as legacy function.  */\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      if (!node->instrumentation_clone\n+\t  && !node->instrumented_version\n+\t  && (node->alias || node->thunk.thunk_p)\n+\t  && !lookup_attribute (\"bnd_legacy\", DECL_ATTRIBUTES (node->decl)))\n+\tDECL_ATTRIBUTES (node->decl)\n+\t  = tree_cons (get_identifier (\"bnd_legacy\"), NULL,\n+\t\t       DECL_ATTRIBUTES (node->decl));\n+    }\n+\n+  bitmap_obstack_release (NULL);\n+\n+  return 0;\n+}\n+\n+/* In this pass we remove bodies of functions having\n+   instrumented version.  Functions with removed bodies\n+   become a special kind of thunks to provide a connection\n+   between calls to the original version and instrumented\n+   function.  */\n+\n+static unsigned int\n+chkp_produce_thunks (void)\n+{\n+  struct cgraph_node *node;\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      if (!node->instrumentation_clone\n+\t  && node->instrumented_version\n+\t  && gimple_has_body_p (node->decl)\n+\t  && gimple_has_body_p (node->instrumented_version->decl))\n+\t{\n+\t  node->release_body ();\n+\t  node->remove_callees ();\n+\t  node->remove_all_references ();\n+\n+\t  node->thunk.thunk_p = true;\n+\t  node->thunk.add_pointer_bounds_args = true;\n+\t  node->create_edge (node->instrumented_version, NULL,\n+\t\t\t     0, CGRAPH_FREQ_BASE);\n+\t  node->create_reference (node->instrumented_version,\n+\t\t\t       IPA_REF_CHKP, NULL);\n+\t}\n+    }\n+\n+  /* Mark instrumentation clones created for aliases and thunks\n+     as insttrumented so they could be removed as unreachable\n+     now.  */\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      if (node->instrumentation_clone\n+\t  && (node->alias || node->thunk.thunk_p)\n+\t  && !chkp_function_instrumented_p (node->decl))\n+\tchkp_function_mark_instrumented (node->decl);\n+    }\n+\n+  symtab->remove_unreachable_nodes (true, dump_file);\n+\n+  return 0;\n+}\n+\n+const pass_data pass_data_ipa_chkp_versioning =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"chkp_versioning\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0 /* todo_flags_finish */\n+};\n+\n+const pass_data pass_data_ipa_chkp_produce_thunks =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"chkp_cleanup\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0 /* todo_flags_finish */\n+};\n+\n+class pass_ipa_chkp_versioning : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_chkp_versioning (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_chkp_versioning, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual opt_pass * clone ()\n+    {\n+      return new pass_ipa_chkp_versioning (m_ctxt);\n+    }\n+\n+  virtual bool gate (function *)\n+    {\n+      return flag_check_pointer_bounds;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return chkp_versioning ();\n+    }\n+\n+}; // class pass_ipa_chkp_versioning\n+\n+class pass_ipa_chkp_produce_thunks : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_chkp_produce_thunks (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_chkp_produce_thunks, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual opt_pass * clone ()\n+    {\n+      return new pass_ipa_chkp_produce_thunks (m_ctxt);\n+    }\n+\n+  virtual bool gate (function *)\n+    {\n+      return flag_check_pointer_bounds;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return chkp_produce_thunks ();\n+    }\n+\n+}; // class pass_chkp_produce_thunks\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_chkp_versioning (gcc::context *ctxt)\n+{\n+  return new pass_ipa_chkp_versioning (ctxt);\n+}\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_chkp_produce_thunks (gcc::context *ctxt)\n+{\n+  return new pass_ipa_chkp_produce_thunks (ctxt);\n+}"}, {"sha": "d4ad113893a5564dd064df5a0764f4ff3ef091f0", "filename": "gcc/ipa-chkp.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,26 @@\n+/* Declaration of interface functions of Pointer Bounds Checker.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_IPA_CHKP_H\n+#define GCC_IPA_CHKP_H\n+\n+extern tree chkp_copy_function_type_adding_bounds (tree orig_type);\n+extern cgraph_node *chkp_maybe_create_clone (tree fndecl);\n+\n+#endif /* GCC_IPA_CHKP_H */"}, {"sha": "47f9f5cea093fa834d70de7ee0a0254087113688", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -716,7 +716,7 @@ initialize_node_lattices (struct cgraph_node *node)\n   int i;\n \n   gcc_checking_assert (node->has_gimple_body_p ());\n-  if (!node->local.local)\n+  if (!cgraph_local_p (node))\n     {\n       /* When cloning is allowed, we can assume that externally visible\n \t functions are not called.  We will compensate this by cloning\n@@ -1464,6 +1464,24 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   if (parms_count == 0)\n     return false;\n \n+  /* No propagation through instrumentation thunks is available yet.\n+     It should be possible with proper mapping of call args and\n+     instrumented callee params in the propagation loop below.  But\n+     this case mostly occurs when legacy code calls instrumented code\n+     and it is not a primary target for optimizations.\n+     We detect instrumentation thunks in aliases and thunks chain by\n+     checking instrumentation_clone flag for chain source and target.\n+     Going through instrumentation thunks we always have it changed\n+     from 0 to 1 and all other nodes do not change it.  */\n+  if (!cs->callee->instrumentation_clone\n+      && callee->instrumentation_clone)\n+    {\n+      for (i = 0; i < parms_count; i++)\n+\tret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,\n+\t\t\t\t\t\t\t\t i));\n+      return ret;\n+    }\n+\n   /* If this call goes through a thunk we must not propagate to the first (0th)\n      parameter.  However, we might need to uncover a thunk from below a series\n      of aliases first.  */"}, {"sha": "84cc0ca0ba18266152892d34221ca8aa24bf51f0", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -579,7 +579,8 @@ sem_function::merge (sem_item *alias_item)\n       redirect_callers\n \t= (!original_discardable\n \t   && alias->get_availability () > AVAIL_INTERPOSABLE\n-\t   && original->get_availability () > AVAIL_INTERPOSABLE);\n+\t   && original->get_availability () > AVAIL_INTERPOSABLE\n+\t   && !alias->instrumented_version);\n     }\n   else\n     {\n@@ -1200,6 +1201,7 @@ sem_variable::merge (sem_item *alias_item)\n       alias->analyzed = false;\n \n       DECL_INITIAL (alias->decl) = NULL;\n+      alias->need_bounds_init = false;\n       alias->remove_all_references ();\n \n       varpool_node::create_alias (alias_var->decl, decl);"}, {"sha": "534b330319306708370dda9feef1d072a1e86bb0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -2453,11 +2453,15 @@ early_inliner (function *fun)\n \t     info that might be cleared out for newly discovered edges.  */\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n-\t      struct inline_edge_summary *es = inline_edge_summary (edge);\n-\t      es->call_stmt_size\n-\t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-\t      es->call_stmt_time\n-\t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t      /* We have no summary for new bound store calls yet.  */\n+\t      if (inline_edge_summary_vec.length () > (unsigned)edge->uid)\n+\t\t{\n+\t\t  struct inline_edge_summary *es = inline_edge_summary (edge);\n+\t\t  es->call_stmt_size\n+\t\t    = estimate_num_insns (edge->call_stmt, &eni_size_weights);\n+\t\t  es->call_stmt_time\n+\t\t    = estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t\t}\n \t      if (edge->callee->decl\n \t\t  && !gimple_check_call_matching_types (\n \t\t      edge->call_stmt, edge->callee->decl, false))"}, {"sha": "d6999fa6712ece5f3f6ef1d45c24f728f71014e3", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1326,6 +1326,7 @@ propagate_pure_const (void)\n \t\t    fprintf (dump_file, \"    global var write\\n\");\n \t\t  break;\n \t\tcase IPA_REF_ADDR:\n+\t\tcase IPA_REF_CHKP:\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();"}, {"sha": "ed75c008599eb84081fbb3574497e6badb3e1238", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -32,7 +32,8 @@ enum GTY(()) ipa_ref_use\n   IPA_REF_LOAD,\n   IPA_REF_STORE,\n   IPA_REF_ADDR,\n-  IPA_REF_ALIAS\n+  IPA_REF_ALIAS,\n+  IPA_REF_CHKP\n };\n \n /* Record of reference in callgraph or varpool.  */\n@@ -57,7 +58,7 @@ struct GTY(()) ipa_ref\n   gimple stmt;\n   unsigned int lto_stmt_uid;\n   unsigned int referred_index;\n-  ENUM_BITFIELD (ipa_ref_use) use:2;\n+  ENUM_BITFIELD (ipa_ref_use) use:3;\n   unsigned int speculative:1;\n };\n "}, {"sha": "98dbc63e2fb08e6738a864f847448ac2ef05fc34", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -127,6 +127,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"ipa-inline.h\"\n #include \"cfgloop.h\"\n+#include \"tree-chkp.h\"\n \n /* Per basic block info.  */\n \n@@ -168,6 +169,7 @@ struct split_point best_split_point;\n static bitmap forbidden_dominators;\n \n static tree find_retval (basic_block return_bb);\n+static tree find_retbnd (basic_block return_bb);\n \n /* Callback for walk_stmt_load_store_addr_ops.  If T is non-SSA automatic\n    variable, check it if it is present in bitmap passed via DATA.  */\n@@ -413,6 +415,21 @@ dominated_by_forbidden (basic_block bb)\n   return false;\n }\n \n+/* For give split point CURRENT and return block RETURN_BB return 1\n+   if ssa name VAL is set by split part and 0 otherwise.  */\n+static bool\n+split_part_set_ssa_name_p (tree val, struct split_point *current,\n+\t\t\t   basic_block return_bb)\n+{\n+  if (TREE_CODE (val) != SSA_NAME)\n+    return false;\n+\n+  return (!SSA_NAME_IS_DEFAULT_DEF (val)\n+\t  && (bitmap_bit_p (current->split_bbs,\n+\t\t\t    gimple_bb (SSA_NAME_DEF_STMT (val))->index)\n+\t      || gimple_bb (SSA_NAME_DEF_STMT (val)) == return_bb));\n+}\n+\n /* We found an split_point CURRENT.  NON_SSA_VARS is bitmap of all non ssa\n    variables used and RETURN_BB is return basic block.\n    See if we can split function here.  */\n@@ -430,6 +447,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   unsigned int i;\n   int incoming_freq = 0;\n   tree retval;\n+  tree retbnd;\n   bool back_edge = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -618,10 +636,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n        = bitmap_bit_p (non_ssa_vars, DECL_UID (SSA_NAME_VAR (retval)));\n   else if (TREE_CODE (retval) == SSA_NAME)\n     current->split_part_set_retval\n-      = (!SSA_NAME_IS_DEFAULT_DEF (retval)\n-\t && (bitmap_bit_p (current->split_bbs,\n-\t\t\t  gimple_bb (SSA_NAME_DEF_STMT (retval))->index)\n-\t     || gimple_bb (SSA_NAME_DEF_STMT (retval)) == return_bb));\n+      = split_part_set_ssa_name_p (retval, current, return_bb);\n   else if (TREE_CODE (retval) == PARM_DECL)\n     current->split_part_set_retval = false;\n   else if (TREE_CODE (retval) == VAR_DECL\n@@ -631,6 +646,29 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   else\n     current->split_part_set_retval = true;\n \n+  /* See if retbnd used by return bb is computed by header or split part.  */\n+  retbnd = find_retbnd (return_bb);\n+  if (retbnd)\n+    {\n+      bool split_part_set_retbnd\n+\t= split_part_set_ssa_name_p (retbnd, current, return_bb);\n+\n+      /* If we have both return value and bounds then keep their definitions\n+\t in a single function.  We use SSA names to link returned bounds and\n+\t value and therefore do not handle cases when result is passed by\n+\t reference (which should not be our case anyway since bounds are\n+\t returned for pointers only).  */\n+      if ((DECL_BY_REFERENCE (DECL_RESULT (current_function_decl))\n+\t   && current->split_part_set_retval)\n+\t  || split_part_set_retbnd != current->split_part_set_retval)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Refused: split point splits return value and bounds\\n\");\n+\t  return;\n+\t}\n+    }\n+\n   /* split_function fixes up at most one PHI non-virtual PHI node in return_bb,\n      for the return value.  If there are other PHIs, give up.  */\n   if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -753,6 +791,18 @@ find_retval (basic_block return_bb)\n   return NULL;\n }\n \n+/* Given return basic block RETURN_BB, see where return bounds are really\n+   stored.  */\n+static tree\n+find_retbnd (basic_block return_bb)\n+{\n+  gimple_stmt_iterator bsi;\n+  for (bsi = gsi_last_bb (return_bb); !gsi_end_p (bsi); gsi_prev (&bsi))\n+    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+      return gimple_return_retbnd (gsi_stmt (bsi));\n+  return NULL;\n+}\n+\n /* Callback for walk_stmt_load_store_addr_ops.  If T is non-SSA automatic\n    variable, mark it as used in bitmap passed via DATA.\n    Return true when access to T prevents splitting the function.  */\n@@ -1123,6 +1173,19 @@ find_split_points (int overall_time, int overall_size)\n   BITMAP_FREE (current.ssa_names_to_pass);\n }\n \n+/* Build and insert initialization of returned bounds RETBND\n+   for returned value RETVAL.  Statements are inserted after\n+   a statement pointed by GSI and GSI is modified to point to\n+   the last inserted statement.  */\n+\n+static void\n+insert_bndret_call_after (tree retbnd, tree retval, gimple_stmt_iterator *gsi)\n+{\n+  tree fndecl = targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDRET);\n+  gimple bndret = gimple_build_call (fndecl, 1, retval);\n+  gimple_call_set_lhs (bndret, retbnd);\n+  gsi_insert_after (gsi, bndret, GSI_CONTINUE_LINKING);\n+}\n /* Split function at SPLIT_POINT.  */\n \n static void\n@@ -1139,8 +1202,9 @@ split_function (struct split_point *split_point)\n   gimple call;\n   edge e;\n   edge_iterator ei;\n-  tree retval = NULL, real_retval = NULL;\n+  tree retval = NULL, real_retval = NULL, retbnd = NULL;\n   bool split_part_return_p = false;\n+  bool with_bounds = chkp_function_instrumented_p (current_function_decl);\n   gimple last_stmt = NULL;\n   unsigned int i;\n   tree arg, ddef;\n@@ -1289,6 +1353,12 @@ split_function (struct split_point *split_point)\n       DECL_BUILT_IN_CLASS (node->decl) = NOT_BUILT_IN;\n       DECL_FUNCTION_CODE (node->decl) = (enum built_in_function) 0;\n     }\n+\n+  /* If the original function is instrumented then it's\n+     part is also instrumented.  */\n+  if (with_bounds)\n+    chkp_function_mark_instrumented (node->decl);\n+\n   /* If the original function is declared inline, there is no point in issuing\n      a warning for the non-inlinable part.  */\n   DECL_NO_INLINE_WARNING_P (node->decl) = 1;\n@@ -1323,6 +1393,7 @@ split_function (struct split_point *split_point)\n \targs_to_pass[i] = arg;\n       }\n   call = gimple_build_call_vec (node->decl, args_to_pass);\n+  gimple_call_set_with_bounds (call, with_bounds);\n   gimple_set_block (call, DECL_INITIAL (current_function_decl));\n   args_to_pass.release ();\n \n@@ -1429,6 +1500,7 @@ split_function (struct split_point *split_point)\n       if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  real_retval = retval = find_retval (return_bb);\n+\t  retbnd = find_retbnd (return_bb);\n \n \t  if (real_retval && split_point->split_part_set_retval)\n \t    {\n@@ -1473,6 +1545,21 @@ split_function (struct split_point *split_point)\n \t\t\t  }\n \t\t      update_stmt (gsi_stmt (bsi));\n \t\t    }\n+\n+\t\t  /* Replace retbnd with new one.  */\n+\t\t  if (retbnd)\n+\t\t    {\n+\t\t      gimple_stmt_iterator bsi;\n+\t\t      for (bsi = gsi_last_bb (return_bb); !gsi_end_p (bsi);\n+\t\t\t   gsi_prev (&bsi))\n+\t\t\tif (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+\t\t\t  {\n+\t\t\t    retbnd = copy_ssa_name (retbnd, call);\n+\t\t\t    gimple_return_set_retbnd (gsi_stmt (bsi), retbnd);\n+\t\t\t    update_stmt (gsi_stmt (bsi));\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n \t\t}\n \t      if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n \t\t{\n@@ -1494,6 +1581,9 @@ split_function (struct split_point *split_point)\n \t\t      gsi_insert_after (&gsi, cpy, GSI_NEW_STMT);\n \t\t      retval = tem;\n \t\t    }\n+\t\t  /* Build bndret call to obtain returned bounds.  */\n+\t\t  if (retbnd)\n+\t\t    insert_bndret_call_after (retbnd, retval, &gsi);\n \t\t  gimple_call_set_lhs (call, retval);\n \t\t  update_stmt (call);\n \t\t}\n@@ -1512,6 +1602,10 @@ split_function (struct split_point *split_point)\n \t    {\n \t      retval = DECL_RESULT (current_function_decl);\n \n+\t      if (chkp_function_instrumented_p (current_function_decl)\n+\t\t  && BOUNDED_P (retval))\n+\t\tretbnd = create_tmp_reg (pointer_bounds_type_node, NULL);\n+\n \t      /* We use temporary register to hold value when aggregate_value_p\n \t\t is false.  Similarly for DECL_BY_REFERENCE we must avoid extra\n \t\t copy.  */\n@@ -1535,6 +1629,9 @@ split_function (struct split_point *split_point)\n \t        gimple_call_set_lhs (call, retval);\n \t    }\n           gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+\t  /* Build bndret call to obtain returned bounds.  */\n+\t  if (retbnd)\n+\t    insert_bndret_call_after (retbnd, retval, &gsi);\n \t  ret = gimple_build_return (retval);\n \t  gsi_insert_after (&gsi, ret, GSI_NEW_STMT);\n \t}"}, {"sha": "210777d9b2db1281104aba2d46e4c91a27635629", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -270,6 +270,10 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n   if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n \n+  if (node->instrumentation_clone\n+      && MAIN_NAME_P (DECL_NAME (node->orig_decl)))\n+    return true;\n+\n   return false;\n }\n \n@@ -554,6 +558,7 @@ function_and_variable_visibility (bool whole_program)\n \t}\n \n       if (node->thunk.thunk_p\n+\t  && !node->thunk.add_pointer_bounds_args\n \t  && TREE_PUBLIC (node->decl))\n \t{\n \t  struct cgraph_node *decl_node = node;"}, {"sha": "a6086d808b0770a74f751bb5ffae601b67e45d8f", "filename": "gcc/ipa.c", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -226,7 +226,13 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t  if (inline_summary_vec)\n \t    inline_update_overall_summary (node);\n \t  else if (edge->call_stmt)\n-\t    edge->redirect_call_stmt_to_callee ();\n+\t    {\n+\t      edge->redirect_call_stmt_to_callee ();\n+\n+\t      /* Call to __builtin_unreachable shouldn't be instrumented.  */\n+\t      if (!targets.length ())\n+\t\tgimple_call_set_with_bounds (edge->call_stmt, false);\n+\t    }\n \t}\n     }\n }\n@@ -507,6 +513,12 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      node->remove_from_same_comdat_group ();\n \t      node->remove_all_references ();\n \t      changed = true;\n+\t      if (node->thunk.thunk_p\n+\t\t  && node->thunk.add_pointer_bounds_args)\n+\t\t{\n+\t\t  node->thunk.thunk_p = false;\n+\t\t  node->thunk.add_pointer_bounds_args = false;\n+\t\t}\n \t    }\n \t}\n       else\n@@ -556,7 +568,8 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      changed = true;\n \t    }\n \t  /* Keep body if it may be useful for constant folding.  */\n-\t  if ((init = ctor_for_folding (vnode->decl)) == error_mark_node)\n+\t  if ((init = ctor_for_folding (vnode->decl)) == error_mark_node\n+\t      && !POINTER_BOUNDS_P (vnode->decl))\n \t    vnode->remove_initializer ();\n \t  else\n \t    DECL_INITIAL (vnode->decl) = init;\n@@ -581,7 +594,10 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t&& !node->used_from_other_partition)\n       {\n \tif (!node->call_for_symbol_thunks_and_aliases\n-\t  (has_addr_references_p, NULL, true))\n+\t    (has_addr_references_p, NULL, true)\n+\t    && (!node->instrumentation_clone\n+\t\t|| !node->instrumented_version\n+\t\t|| !node->instrumented_version->address_taken))\n \t  {\n \t    if (file)\n \t      fprintf (file, \" %s\", node->name ());\n@@ -644,6 +660,8 @@ process_references (varpool_node *vnode,\n \tprocess_references (dyn_cast<varpool_node *> (ref->referring), written,\n \t\t\t    address_taken, read, explicit_refs);\n \tbreak;\n+      case IPA_REF_CHKP:\n+\tgcc_unreachable ();\n       }\n }\n \n@@ -782,9 +800,11 @@ make_pass_ipa_free_inline_summary (gcc::context *ctxt)\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must\n-   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n-   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n-   initialization priority for this constructor or destructor. \n+   be one of 'I' (for a constructor), 'D' (for a destructor), 'P'\n+   (for chp static vars constructor) or 'B' (for chkp static bounds\n+   constructor).  BODY is a STATEMENT_LIST containing GENERIC\n+   statements.  PRIORITY is the initialization priority for this\n+   constructor or destructor.\n \n    FINAL specify whether the externally visible name for collect2 should\n    be produced. */\n@@ -843,6 +863,20 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final)\n       DECL_STATIC_CONSTRUCTOR (decl) = 1;\n       decl_init_priority_insert (decl, priority);\n       break;\n+    case 'P':\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"chkp ctor\"),\n+\t\t\t\t\t  NULL,\n+\t\t\t\t\t  NULL_TREE);\n+      decl_init_priority_insert (decl, priority);\n+      break;\n+    case 'B':\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"bnd_legacy\"),\n+\t\t\t\t\t  NULL,\n+\t\t\t\t\t  NULL_TREE);\n+      decl_init_priority_insert (decl, priority);\n+      break;\n     case 'D':\n       DECL_STATIC_DESTRUCTOR (decl) = 1;\n       decl_fini_priority_insert (decl, priority);\n@@ -860,9 +894,11 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final)\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must\n-   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n-   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n-   initialization priority for this constructor or destructor.  */\n+   be one of 'I' (for a constructor), 'D' (for a destructor), 'P'\n+   (for chkp static vars constructor) or 'B' (for chkp static bounds\n+   constructor).  BODY is a STATEMENT_LIST containing GENERIC\n+   statements.  PRIORITY is the initialization priority for this\n+   constructor or destructor.  */\n \n void\n cgraph_build_static_cdtor (char which, tree body, int priority)"}, {"sha": "da1f0e446822f33d6e9b39b7148b2f7df37d80aa", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -552,6 +552,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n+  bp_pack_value (&bp, node->instrumentation_clone, 1);\n   streamer_write_bitpack (&bp);\n   streamer_write_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n@@ -560,7 +561,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream\n \t (ob->main_stream,\n \t  1 + (node->thunk.this_adjusting != 0) * 2\n-\t  + (node->thunk.virtual_offset_p != 0) * 4);\n+\t  + (node->thunk.virtual_offset_p != 0) * 4\n+\t  + (node->thunk.add_pointer_bounds_args != 0) * 8);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n@@ -569,6 +571,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     streamer_write_hwi_stream (ob->main_stream, node->get_init_priority ());\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     streamer_write_hwi_stream (ob->main_stream, node->get_fini_priority ());\n+\n+  if (node->instrumentation_clone)\n+    lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->orig_decl);\n }\n \n /* Output the varpool NODE to OB. \n@@ -623,6 +628,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n     }\n   bp_pack_value (&bp, node->tls_model, 3);\n   bp_pack_value (&bp, node->used_by_single_function, 1);\n+  bp_pack_value (&bp, node->need_bounds_init, 1);\n   streamer_write_bitpack (&bp);\n \n   group = node->get_comdat_group ();\n@@ -667,7 +673,7 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n   struct cgraph_node *node;\n \n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, ref->use, 2);\n+  bp_pack_value (&bp, ref->use, 3);\n   bp_pack_value (&bp, ref->speculative, 1);\n   streamer_write_bitpack (&bp);\n   nref = lto_symtab_encoder_lookup (encoder, ref->referred);\n@@ -875,7 +881,8 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\tvnode)\n-\t      && vnode->ctor_useable_for_folding_p ())\n+\t      && (vnode->ctor_useable_for_folding_p ()\n+\t\t  || POINTER_BOUNDS_P (vnode->decl)))\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n \t      create_references (encoder, vnode);\n@@ -1093,6 +1100,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n+  node->instrumentation_clone = bp_unpack_value (bp, 1);\n   gcc_assert (flag_ltrans\n \t      || (!node->in_other_partition\n \t\t  && !node->used_from_other_partition));\n@@ -1215,6 +1223,7 @@ input_node (struct lto_file_decl_data *file_data,\n       node->thunk.this_adjusting = (type & 2);\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n+      node->thunk.add_pointer_bounds_args = (type & 8);\n     }\n   if (node->alias && !node->analyzed && node->weakref)\n     node->alias_target = get_alias_symbol (node->decl);\n@@ -1223,6 +1232,14 @@ input_node (struct lto_file_decl_data *file_data,\n     node->set_init_priority (streamer_read_hwi (ib));\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     node->set_fini_priority (streamer_read_hwi (ib));\n+\n+  if (node->instrumentation_clone)\n+    {\n+      decl_index = streamer_read_uhwi (ib);\n+      fn_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+      node->orig_decl = fn_decl;\n+    }\n+\n   return node;\n }\n \n@@ -1282,6 +1299,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     node->alias_target = get_alias_symbol (node->decl);\n   node->tls_model = (enum tls_model)bp_unpack_value (&bp, 3);\n   node->used_by_single_function = (enum tls_model)bp_unpack_value (&bp, 1);\n+  node->need_bounds_init = bp_unpack_value (&bp, 1);\n   group = read_identifier (ib);\n   if (group)\n     {\n@@ -1319,7 +1337,7 @@ input_ref (struct lto_input_block *ib,\n   struct ipa_ref *ref;\n \n   bp = streamer_read_bitpack (ib);\n-  use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n+  use = (enum ipa_ref_use) bp_unpack_value (&bp, 3);\n   speculative = (enum ipa_ref_use) bp_unpack_value (&bp, 1);\n   node = nodes[streamer_read_hwi (ib)];\n   ref = referring_node->create_reference (node, use);\n@@ -1462,6 +1480,22 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t      = dyn_cast<cgraph_node *> (nodes[ref]);\n \t  else\n \t    cnode->global.inlined_to = NULL;\n+\n+\t  /* Compute instrumented_version.  */\n+\t  if (cnode->instrumentation_clone)\n+\t    {\n+\t      gcc_assert (cnode->orig_decl);\n+\n+\t      cnode->instrumented_version = cgraph_node::get (cnode->orig_decl);\n+\t      if (cnode->instrumented_version)\n+\t\tcnode->instrumented_version->instrumented_version = cnode;\n+\n+\t      /* Restore decl names reference.  */\n+\t      if (IDENTIFIER_TRANSPARENT_ALIAS (DECL_ASSEMBLER_NAME (cnode->decl))\n+\t\t  && !TREE_CHAIN (DECL_ASSEMBLER_NAME (cnode->decl)))\n+\t\tTREE_CHAIN (DECL_ASSEMBLER_NAME (cnode->decl))\n+\t\t  = DECL_ASSEMBLER_NAME (cnode->orig_decl);\n+\t    }\n \t}\n \n       ref = (int) (intptr_t) node->same_comdat_group;"}, {"sha": "0e1a95bf9188592a4ec2323c7d7fee90173c3e30", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -108,8 +108,9 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node *> (ref->referred)\n-\t     && dyn_cast <varpool_node *> (ref->referred)\n-\t       ->ctor_useable_for_folding_p ()\n+\t     && (dyn_cast <varpool_node *> (ref->referred)\n+\t\t ->ctor_useable_for_folding_p ()\n+\t\t || POINTER_BOUNDS_P (ref->referred->decl))\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)\n@@ -176,6 +177,11 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n       for (e = cnode->callers; e; e = e->next_caller)\n \tif (e->caller->thunk.thunk_p)\n \t  add_symbol_to_partition_1 (part, e->caller);\n+\n+      /* Instrumented version is actually the same function.\n+\t Therefore put it into the same partition.  */\n+      if (cnode->instrumented_version)\n+\tadd_symbol_to_partition_1 (part, cnode->instrumented_version);\n     }\n \n   add_references_to_partition (part, node);\n@@ -782,6 +788,7 @@ privatize_symbol_name (symtab_node *node)\n {\n   tree decl = node->decl;\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  cgraph_node *cnode;\n \n   /* Our renaming machinery do not handle more than one change of assembler name.\n      We should not need more than one anyway.  */\n@@ -812,6 +819,18 @@ privatize_symbol_name (symtab_node *node)\n     lto_record_renamed_decl (node->lto_file_data, name,\n \t\t\t     IDENTIFIER_POINTER\n \t\t\t     (DECL_ASSEMBLER_NAME (decl)));\n+  /* We could change name which is a target of transparent alias\n+     chain of instrumented function name.  Fix alias chain if so  .*/\n+  if ((cnode = dyn_cast <cgraph_node *> (node))\n+      && !cnode->instrumentation_clone\n+      && cnode->instrumented_version\n+      && cnode->instrumented_version->orig_decl == decl)\n+    {\n+      tree iname = DECL_ASSEMBLER_NAME (cnode->instrumented_version->decl);\n+\n+      gcc_assert (IDENTIFIER_TRANSPARENT_ALIAS (iname));\n+      TREE_CHAIN (iname) = DECL_ASSEMBLER_NAME (decl);\n+    }\n   if (symtab->dump_file)\n     fprintf (symtab->dump_file,\n \t    \"Privatizing symbol name: %s -> %s\\n\","}, {"sha": "52a4e7c52241396fee8d490e342a0ca939e06000", "filename": "gcc/machmode.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -174,6 +174,9 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n    || CLASS == MODE_ACCUM                      \\\n    || CLASS == MODE_UACCUM)\n \n+#define POINTER_BOUNDS_MODE_P(MODE)      \\\n+  (GET_MODE_CLASS (MODE) == MODE_POINTER_BOUNDS)\n+\n /* Get the size in bytes and bits of an object of mode MODE.  */\n \n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];"}, {"sha": "b645484724cafbc8b84ed98c4065c795730afcd5", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n   DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n   DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */    \\\n+  DEF_MODE_CLASS (MODE_POINTER_BOUNDS), /* bounds */                       \\\n   DEF_MODE_CLASS (MODE_FRACT),\t\t/* signed fractional number */\t   \\\n   DEF_MODE_CLASS (MODE_UFRACT),\t\t/* unsigned fractional number */   \\\n   DEF_MODE_CLASS (MODE_ACCUM),\t\t/* signed accumulator */\t   \\"}, {"sha": "73f5643031e419fc75627616d1124bd09da11b8a", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1107,6 +1107,12 @@ DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,\n \t  \"Maximum number of nested calls to search for control dependencies \"\n \t  \"during uninitialized variable analysis\",\n \t  1000, 1, 0)\n+\n+DEFPARAM (PARAM_CHKP_MAX_CTOR_SIZE,\n+\t  \"chkp-max-ctor-size\",\n+\t  \"Maximum number of statements to be included into a single static \"\n+\t  \"constructor generated by Pointer Bounds Checker\",\n+\t  5000, 100, 0)\n /*\n \n Local variables:"}, {"sha": "5e91a79414ab73010dab4eeac7ee36f6bced84b4", "filename": "gcc/passes.c", "status": "modified", "additions": 83, "deletions": 11, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -140,7 +140,9 @@ opt_pass::opt_pass (const pass_data &data, context *ctxt)\n void\n pass_manager::execute_early_local_passes ()\n {\n-  execute_pass_list (cfun, pass_early_local_passes_1->sub);\n+  execute_pass_list (cfun, pass_build_ssa_passes_1->sub);\n+  execute_pass_list (cfun, pass_chkp_instrumentation_passes_1->sub);\n+  execute_pass_list (cfun, pass_local_optimization_passes_1->sub);\n }\n \n unsigned int\n@@ -332,7 +334,7 @@ finish_optimization_passes (void)\n }\n \n static unsigned int\n-execute_all_early_local_passes (void)\n+execute_build_ssa_passes (void)\n {\n   /* Once this pass (and its sub-passes) are complete, all functions\n      will be in SSA form.  Technically this state change is happening\n@@ -347,10 +349,10 @@ execute_all_early_local_passes (void)\n \n namespace {\n \n-const pass_data pass_data_early_local_passes =\n+const pass_data pass_data_build_ssa_passes =\n {\n   SIMPLE_IPA_PASS, /* type */\n-  \"early_local_cleanups\", /* name */\n+  \"build_ssa_passes\", /* name */\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_EARLY_LOCAL, /* tv_id */\n   0, /* properties_required */\n@@ -362,11 +364,11 @@ const pass_data pass_data_early_local_passes =\n   0, /* todo_flags_finish */\n };\n \n-class pass_early_local_passes : public simple_ipa_opt_pass\n+class pass_build_ssa_passes : public simple_ipa_opt_pass\n {\n public:\n-  pass_early_local_passes (gcc::context *ctxt)\n-    : simple_ipa_opt_pass (pass_data_early_local_passes, ctxt)\n+  pass_build_ssa_passes (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_build_ssa_passes, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -378,17 +380,87 @@ class pass_early_local_passes : public simple_ipa_opt_pass\n \n   virtual unsigned int execute (function *)\n     {\n-      return execute_all_early_local_passes ();\n+      return execute_build_ssa_passes ();\n     }\n \n-}; // class pass_early_local_passes\n+}; // class pass_build_ssa_passes\n+\n+const pass_data pass_data_chkp_instrumentation_passes =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"chkp_passes\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_chkp_instrumentation_passes : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_chkp_instrumentation_passes (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_chkp_instrumentation_passes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      /* Don't bother doing anything if the program has errors.  */\n+      return (!seen_error () && !in_lto_p);\n+    }\n+\n+}; // class pass_chkp_instrumentation_passes\n+\n+const pass_data pass_data_local_optimization_passes =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"opt_local_passes\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_local_optimization_passes : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_local_optimization_passes (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_local_optimization_passes, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      /* Don't bother doing anything if the program has errors.  */\n+      return (!seen_error () && !in_lto_p);\n+    }\n+\n+}; // class pass_local_optimization_passes\n \n } // anon namespace\n \n simple_ipa_opt_pass *\n-make_pass_early_local_passes (gcc::context *ctxt)\n+make_pass_build_ssa_passes (gcc::context *ctxt)\n+{\n+  return new pass_build_ssa_passes (ctxt);\n+}\n+\n+simple_ipa_opt_pass *\n+make_pass_chkp_instrumentation_passes (gcc::context *ctxt)\n+{\n+  return new pass_chkp_instrumentation_passes (ctxt);\n+}\n+\n+simple_ipa_opt_pass *\n+make_pass_local_optimization_passes (gcc::context *ctxt)\n {\n-  return new pass_early_local_passes (ctxt);\n+  return new pass_local_optimization_passes (ctxt);\n }\n \n namespace {"}, {"sha": "2305d670663de3dba18fe9ef71cafec216d6d18e", "filename": "gcc/passes.def", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -49,14 +49,27 @@ along with GCC; see the file COPYING3.  If not see\n   INSERT_PASSES_AFTER (all_small_ipa_passes)\n   NEXT_PASS (pass_ipa_free_lang_data);\n   NEXT_PASS (pass_ipa_function_and_variable_visibility);\n-  NEXT_PASS (pass_early_local_passes);\n-  PUSH_INSERT_PASSES_WITHIN (pass_early_local_passes)\n+  NEXT_PASS (pass_ipa_chkp_versioning);\n+  NEXT_PASS (pass_build_ssa_passes);\n+  PUSH_INSERT_PASSES_WITHIN (pass_build_ssa_passes)\n       NEXT_PASS (pass_fixup_cfg);\n       NEXT_PASS (pass_init_datastructures);\n-\n       NEXT_PASS (pass_build_ssa);\n       NEXT_PASS (pass_ubsan);\n       NEXT_PASS (pass_early_warn_uninitialized);\n+  POP_INSERT_PASSES ()\n+\n+  NEXT_PASS (pass_chkp_instrumentation_passes);\n+  PUSH_INSERT_PASSES_WITHIN (pass_chkp_instrumentation_passes)\n+      NEXT_PASS (pass_fixup_cfg);\n+      NEXT_PASS (pass_chkp);\n+      NEXT_PASS (pass_rebuild_cgraph_edges);\n+  POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_ipa_chkp_produce_thunks);\n+\n+  NEXT_PASS (pass_local_optimization_passes);\n+  PUSH_INSERT_PASSES_WITHIN (pass_local_optimization_passes)\n+      NEXT_PASS (pass_fixup_cfg);\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n       NEXT_PASS (pass_inline_parameters);\n       NEXT_PASS (pass_early_inline);\n@@ -78,13 +91,13 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_early_ipa_sra);\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_convert_switch);\n-          NEXT_PASS (pass_cleanup_eh);\n-          NEXT_PASS (pass_profile);\n-          NEXT_PASS (pass_local_pure_const);\n+\t  NEXT_PASS (pass_cleanup_eh);\n+\t  NEXT_PASS (pass_profile);\n+\t  NEXT_PASS (pass_local_pure_const);\n \t  /* Split functions creates parts that are not run through\n \t     early optimizations again.  It is thus good idea to do this\n-\t     late.  */\n-          NEXT_PASS (pass_split_functions);\n+\t      late.  */\n+\t  NEXT_PASS (pass_split_functions);\n       POP_INSERT_PASSES ()\n       NEXT_PASS (pass_release_ssa_names);\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n@@ -154,6 +167,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_fre);\n       NEXT_PASS (pass_merge_phi);\n       NEXT_PASS (pass_vrp);\n+      NEXT_PASS (pass_chkp_opt);\n       NEXT_PASS (pass_dce);\n       NEXT_PASS (pass_call_cdce);\n       NEXT_PASS (pass_cselim);"}, {"sha": "2d56ba29f4efd3362da7cac6d5367234a4aed485", "filename": "gcc/rtl-chkp.c", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-chkp.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,307 @@\n+/* RTL manipulation functions exported by Pointer Bounds Checker.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"expr.h\"\n+#include \"target.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"is-a.h\"\n+#include \"predict.h\"\n+#include \"basic-block.h\"\n+#include \"tree.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimple.h\"\n+#include \"bitmap.h\"\n+#include \"rtl-chkp.h\"\n+#include \"tree-chkp.h\"\n+#include \"hash-map.h\"\n+\n+static hash_map<tree, rtx> *chkp_rtx_bounds_map;\n+\n+/* Get bounds rtx associated with NODE via\n+   chkp_set_rtl_bounds call.  */\n+rtx\n+chkp_get_rtl_bounds (tree node)\n+{\n+  rtx *slot;\n+\n+  if (!chkp_rtx_bounds_map)\n+    return NULL_RTX;\n+\n+  slot = chkp_rtx_bounds_map->get (node);\n+  return slot ? *slot : NULL_RTX;\n+}\n+\n+/* Associate bounds rtx VAL with NODE.  */\n+void\n+chkp_set_rtl_bounds (tree node, rtx val)\n+{\n+  if (!chkp_rtx_bounds_map)\n+    chkp_rtx_bounds_map = new hash_map<tree, rtx>;\n+\n+  chkp_rtx_bounds_map->put (node, val);\n+}\n+\n+/* Reset all bounds stored via chkp_set_rtl_bounds.  */\n+void\n+chkp_reset_rtl_bounds ()\n+{\n+  if (!chkp_rtx_bounds_map)\n+    return;\n+\n+  delete chkp_rtx_bounds_map;\n+  chkp_rtx_bounds_map = NULL;\n+}\n+\n+/* Split SLOT identifying slot for function value or\n+   argument into two parts SLOT_VAL and SLOT_BND.\n+   First is the slot for regular value and the other one is\n+   for bounds.  */\n+void\n+chkp_split_slot (rtx slot, rtx *slot_val, rtx *slot_bnd)\n+{\n+  int i;\n+  int val_num = 0;\n+  int bnd_num = 0;\n+  rtx *val_tmps;\n+  rtx *bnd_tmps;\n+\n+  *slot_bnd = 0;\n+\n+  if (!slot\n+      || GET_CODE (slot) != PARALLEL)\n+    {\n+      *slot_val = slot;\n+      return;\n+    }\n+\n+  val_tmps = XALLOCAVEC (rtx, XVECLEN (slot, 0));\n+  bnd_tmps = XALLOCAVEC (rtx, XVECLEN (slot, 0));\n+\n+  for (i = 0; i < XVECLEN (slot, 0); i++)\n+    {\n+      rtx elem = XVECEXP (slot, 0, i);\n+      rtx reg = GET_CODE (elem) == EXPR_LIST ? XEXP (elem, 0) : elem;\n+\n+      if (!reg)\n+\tcontinue;\n+\n+      if (POINTER_BOUNDS_MODE_P (GET_MODE (reg)) || CONST_INT_P (reg))\n+\tbnd_tmps[bnd_num++] = elem;\n+      else\n+\tval_tmps[val_num++] = elem;\n+    }\n+\n+  gcc_assert (val_num);\n+\n+  if (!bnd_num)\n+    {\n+      *slot_val = slot;\n+      return;\n+    }\n+\n+  if ((GET_CODE (val_tmps[0]) == EXPR_LIST) || (val_num > 1))\n+    *slot_val = gen_rtx_PARALLEL (GET_MODE (slot),\n+\t\t\t\t  gen_rtvec_v (val_num, val_tmps));\n+  else\n+    *slot_val = val_tmps[0];\n+\n+  if ((GET_CODE (bnd_tmps[0]) == EXPR_LIST) || (bnd_num > 1))\n+    *slot_bnd = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t  gen_rtvec_v (bnd_num, bnd_tmps));\n+  else\n+    *slot_bnd = bnd_tmps[0];\n+}\n+\n+/* Join previously splitted to VAL and BND rtx for function\n+   value or argument and return it.  */\n+rtx\n+chkp_join_splitted_slot (rtx val, rtx bnd)\n+{\n+  rtx res;\n+  int i, n = 0;\n+\n+  if (!bnd)\n+    return val;\n+\n+  if (GET_CODE (val) == PARALLEL)\n+    n += XVECLEN (val, 0);\n+  else\n+    n++;\n+\n+  if (GET_CODE (bnd) == PARALLEL)\n+    n += XVECLEN (bnd, 0);\n+  else\n+    n++;\n+\n+  res = gen_rtx_PARALLEL (GET_MODE (val), rtvec_alloc (n));\n+\n+  n = 0;\n+\n+  if (GET_CODE (val) == PARALLEL)\n+    for (i = 0; i < XVECLEN (val, 0); i++)\n+      XVECEXP (res, 0, n++) = XVECEXP (val, 0, i);\n+  else\n+    XVECEXP (res, 0, n++) = val;\n+\n+  if (GET_CODE (bnd) == PARALLEL)\n+    for (i = 0; i < XVECLEN (bnd, 0); i++)\n+      XVECEXP (res, 0, n++) = XVECEXP (bnd, 0, i);\n+  else\n+    XVECEXP (res, 0, n++) = bnd;\n+\n+  return res;\n+}\n+\n+/* If PAR is PARALLEL holding registers then transform\n+   it into PARALLEL holding EXPR_LISTs of those regs\n+   and zero constant (similar to how function value\n+   on multiple registers looks like).  */\n+void\n+chkp_put_regs_to_expr_list (rtx par)\n+{\n+  int n;\n+\n+  if (GET_CODE (par) != PARALLEL\n+      || GET_CODE (XVECEXP (par, 0, 0)) == EXPR_LIST)\n+    return;\n+\n+  for (n = 0; n < XVECLEN (par, 0); n++)\n+    XVECEXP (par, 0, n) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     XVECEXP (par, 0, n),\n+\t\t\t\t\t     const0_rtx);\n+}\n+\n+/*  Search rtx PAR describing function return value for an\n+    item related to value at offset OFFS and return it.\n+    Return NULL if item was not found.  */\n+rtx\n+chkp_get_value_with_offs (rtx par, rtx offs)\n+{\n+  int n;\n+\n+  gcc_assert (GET_CODE (par) == PARALLEL);\n+\n+  for (n = 0; n < XVECLEN (par, 0); n++)\n+    {\n+      rtx par_offs = XEXP (XVECEXP (par, 0, n), 1);\n+      if (INTVAL (offs) == INTVAL (par_offs))\n+\treturn XEXP (XVECEXP (par, 0, n), 0);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Emit instructions to store BOUNDS for pointer VALUE\n+   stored in MEM.\n+   Function is used by expand to pass bounds for args\n+   passed on stack.  */\n+void\n+chkp_emit_bounds_store (rtx bounds, rtx value, rtx mem)\n+{\n+  gcc_assert (MEM_P (mem));\n+\n+  if (REG_P (bounds) || CONST_INT_P (bounds))\n+    {\n+      rtx ptr;\n+\n+      if (REG_P (value))\n+\tptr = value;\n+      else\n+\t{\n+\t  rtx slot = adjust_address (value, Pmode, 0);\n+\t  ptr = gen_reg_rtx (Pmode);\n+\t  emit_move_insn (ptr, slot);\n+\t}\n+\n+      if (CONST_INT_P (bounds))\n+\tbounds = targetm.calls.load_bounds_for_arg (value, ptr, bounds);\n+\n+      targetm.calls.store_bounds_for_arg (ptr, mem,\n+\t\t\t\t\t  bounds, NULL);\n+    }\n+  else\n+    {\n+      int i;\n+\n+      gcc_assert (GET_CODE (bounds) == PARALLEL);\n+      gcc_assert (GET_CODE (value) == PARALLEL || MEM_P (value) || REG_P (value));\n+\n+      for (i = 0; i < XVECLEN (bounds, 0); i++)\n+\t{\n+\t  rtx reg = XEXP (XVECEXP (bounds, 0, i), 0);\n+\t  rtx offs = XEXP (XVECEXP (bounds, 0, i), 1);\n+\t  rtx slot = adjust_address (mem, Pmode, INTVAL (offs));\n+\t  rtx ptr;\n+\n+\t  if (GET_CODE (value) == PARALLEL)\n+\t    ptr = chkp_get_value_with_offs (value, offs);\n+\t  else if (MEM_P (value))\n+\t    {\n+\t      rtx tmp = adjust_address (value, Pmode, INTVAL (offs));\n+\t      ptr = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (ptr, tmp);\n+\t    }\n+\t  else\n+\t    ptr = gen_rtx_SUBREG (Pmode, value, INTVAL (offs));\n+\n+\t  targetm.calls.store_bounds_for_arg (ptr, slot, reg, NULL);\n+\t}\n+    }\n+}\n+\n+/* Emit code to copy bounds for structure VALUE of type TYPE\n+   copied to SLOT.  */\n+void\n+chkp_copy_bounds_for_stack_parm (rtx slot, rtx value, tree type)\n+{\n+  bitmap have_bound;\n+  bitmap_iterator bi;\n+  unsigned i;\n+  rtx tmp = NULL, bnd;\n+\n+  gcc_assert (TYPE_SIZE (type));\n+  gcc_assert (MEM_P (value));\n+  gcc_assert (MEM_P (slot));\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (type));\n+\n+  bitmap_obstack_initialize (NULL);\n+  have_bound = BITMAP_ALLOC (NULL);\n+  chkp_find_bound_slots (type, have_bound);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (have_bound, 0, i, bi)\n+    {\n+      rtx ptr = adjust_address (value, Pmode, i * POINTER_SIZE / 8);\n+      rtx to = adjust_address (slot, Pmode, i * POINTER_SIZE / 8);\n+\n+      if (!tmp)\n+\ttmp = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (tmp, ptr);\n+      bnd = targetm.calls.load_bounds_for_arg (ptr, tmp, NULL);\n+      targetm.calls.store_bounds_for_arg (tmp, to, bnd, NULL);\n+    }\n+\n+  BITMAP_FREE (have_bound);\n+  bitmap_obstack_release (NULL);\n+}"}, {"sha": "5b77db90460d68fa57e4336bfc54ef8704f395dc", "filename": "gcc/rtl-chkp.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-chkp.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,38 @@\n+/* Declaration of interface functions of Pointer Bounds Checker.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RTL_CHKP_H\n+#define GCC_RTL_CHKP_H\n+\n+#define DECL_BOUNDS_RTL(NODE) (chkp_get_rtl_bounds (DECL_WRTL_CHECK (NODE)))\n+\n+#define SET_DECL_BOUNDS_RTL(NODE, VAL) \\\n+  (chkp_set_rtl_bounds (DECL_WRTL_CHECK (NODE), VAL))\n+\n+extern rtx chkp_get_rtl_bounds (tree node);\n+extern void chkp_set_rtl_bounds (tree node, rtx val);\n+extern void chkp_reset_rtl_bounds ();\n+extern void chkp_split_slot (rtx slot, rtx *slot_val, rtx *slot_bnd);\n+extern rtx chkp_join_splitted_slot (rtx val, rtx bnd);\n+extern rtx chkp_get_value_with_offs (rtx par, rtx offs);\n+extern void chkp_copy_bounds_for_stack_parm (rtx slot, rtx value, tree type);\n+extern void chkp_emit_bounds_store (rtx bounds, rtx value, rtx mem);\n+extern void chkp_put_regs_to_expr_list (rtx par);\n+\n+#endif /* GCC_RTL_CHKP_H */"}, {"sha": "c697d553e95e664239eadb2886770cff15efcea4", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -297,7 +297,8 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n      In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a CONCAT is VAL_EXPR_IS_COPIED in var-tracking.c.\n      1 in a VALUE is SP_BASED_VALUE_P in cselib.c.\n-     1 in a SUBREG generated by LRA for reload insns.  */\n+     1 in a SUBREG generated by LRA for reload insns.\n+     1 in a CALL for calls instrumented by Pointer Bounds Checker.  */\n   unsigned int jump : 1;\n   /* In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a MEM if it cannot trap.\n@@ -2206,6 +2207,10 @@ do {\t\t\t\t\t\t\t\t        \\\n #define LRA_SUBREG_P(RTX)\t\\\n   (RTL_FLAG_CHECK1 (\"LRA_SUBREG_P\", (RTX), SUBREG)->jump)\n \n+/* True if call is instrumented by Pointer Bounds Checker.  */\n+#define CALL_EXPR_WITH_BOUNDS_P(RTX) \\\n+  (RTL_FLAG_CHECK1 (\"CALL_EXPR_WITH_BOUNDS_P\", (RTX), CALL)->jump)\n+\n /* Access various components of an ASM_OPERANDS rtx.  */\n \n #define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)"}, {"sha": "431b20715c38ebac222208cae6d466f415413aa2", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -409,6 +409,7 @@ int_mode_for_mode (machine_mode mode)\n     case MODE_VECTOR_ACCUM:\n     case MODE_VECTOR_UFRACT:\n     case MODE_VECTOR_UACCUM:\n+    case MODE_POINTER_BOUNDS:\n       mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n       break;\n \n@@ -2228,6 +2229,11 @@ layout_type (tree type)\n       SET_TYPE_MODE (type, VOIDmode);\n       break;\n \n+    case POINTER_BOUNDS_TYPE:\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n+      break;\n+\n     case OFFSET_TYPE:\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE_UNITS);"}, {"sha": "29839e676f003cdf406d6059282bc035e112e4a5", "filename": "gcc/symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"calls.h\"\n \n-static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n+static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\",\"chkp\"};\n \n const char * const ld_plugin_symbol_resolution_names[]=\n {"}, {"sha": "d460516ffe6e70e9a832ef5f09da3749fe96e48a", "filename": "gcc/target.def", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -2066,6 +2066,107 @@ built-in function.\",\n  (tree exp, rtx target, rtx subtarget, machine_mode mode, int ignore),\n  default_expand_builtin)\n \n+DEFHOOK\n+(builtin_chkp_function,\n+ \"This hook allows target to redefine built-in functions used by\\n\\\n+Pointer Bounds Checker for code instrumentation.  Hook should return\\n\\\n+fndecl of function implementing generic builtin whose code is\\n\\\n+passed in @var{fcode}.  Currently following built-in functions are\\n\\\n+obtained using this hook:\\n\\\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndmk (const void *@var{lb}, size_t @var{size})\\n\\\n+Function code - BUILT_IN_CHKP_BNDMK.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to create bound values.  @var{lb} holds low\\n\\\n+bound of the resulting bounds.  @var{size} holds size of created bounds.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} void __chkp_bndstx (const void *@var{ptr}, __bounds_type @var{b}, const void **@var{loc})\\n\\\n+Function code - @code{BUILT_IN_CHKP_BNDSTX}.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to store bounds @var{b} for pointer @var{ptr}\\n\\\n+when @var{ptr} is stored by address @var{loc}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndldx (const void **@var{loc}, const void *@var{ptr})\\n\\\n+Function code - @code{BUILT_IN_CHKP_BNDLDX}.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to get bounds of pointer @var{ptr} loaded by\\n\\\n+address @var{loc}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} void __chkp_bndcl (const void *@var{ptr}, __bounds_type @var{b})\\n\\\n+Function code - @code{BUILT_IN_CHKP_BNDCL}.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to perform check for pointer @var{ptr} against\\n\\\n+lower bound of bounds @var{b}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} void __chkp_bndcu (const void *@var{ptr}, __bounds_type @var{b})\\n\\\n+Function code - @code{BUILT_IN_CHKP_BNDCU}.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to perform check for pointer @var{ptr} against\\n\\\n+upper bound of bounds @var{b}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} __bounds_type __chkp_bndret (void *@var{ptr})\\n\\\n+Function code - @code{BUILT_IN_CHKP_BNDRET}.  This built-in function is used\\n\\\n+by Pointer Bounds Checker to obtain bounds returned by a call statement.\\n\\\n+@var{ptr} passed to built-in is @code{SSA_NAME} returned by the call.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} __bounds_type __chkp_intersect (__bounds_type @var{b1}, __bounds_type @var{b2})\\n\\\n+Function code - @code{BUILT_IN_CHKP_INTERSECT}.  This built-in function\\n\\\n+returns intersection of bounds @var{b1} and @var{b2}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} __bounds_type __chkp_narrow (const void *@var{ptr}, __bounds_type @var{b}, size_t @var{s})\\n\\\n+Function code - @code{BUILT_IN_CHKP_NARROW}.  This built-in function\\n\\\n+returns intersection of bounds @var{b} and\\n\\\n+[@var{ptr}, @var{ptr} + @var{s} - @code{1}].\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} size_t __chkp_sizeof (const void *@var{ptr})\\n\\\n+Function code - @code{BUILT_IN_CHKP_SIZEOF}.  This built-in function\\n\\\n+returns size of object referenced by @var{ptr}. @var{ptr} is always\\n\\\n+@code{ADDR_EXPR} of @code{VAR_DECL}.  This built-in is used by\\n\\\n+Pointer Bounds Checker when bounds of object cannot be computed statically\\n\\\n+(e.g. object has incomplete type).\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} const void *__chkp_extract_lower (__bounds_type @var{b})\\n\\\n+Function code - @code{BUILT_IN_CHKP_EXTRACT_LOWER}.  This built-in function\\n\\\n+returns lower bound of bounds @var{b}.\\n\\\n+@end deftypefn\\n\\\n+\\n\\\n+@deftypefn {Built-in Function} const void *__chkp_extract_upper (__bounds_type @var{b})\\n\\\n+Function code - @code{BUILT_IN_CHKP_EXTRACT_UPPER}.  This built-in function\\n\\\n+returns upper bound of bounds @var{b}.\\n\\\n+@end deftypefn\",\n+ tree, (unsigned fcode),\n+ default_builtin_chkp_function)\n+\n+DEFHOOK\n+(chkp_bound_type,\n+ \"Return type to be used for bounds\",\n+ tree, (void),\n+ default_chkp_bound_type)\n+\n+DEFHOOK\n+(chkp_bound_mode,\n+ \"Return mode to be used for bounds.\",\n+ enum machine_mode, (void),\n+ default_chkp_bound_mode)\n+\n+DEFHOOK\n+(chkp_make_bounds_constant,\n+ \"Return constant used to statically initialize constant bounds\\n\\\n+with specified lower bound @var{lb} and upper bounds @var{ub}.\",\n+ tree, (HOST_WIDE_INT lb, HOST_WIDE_INT ub),\n+ default_chkp_make_bounds_constant)\n+\n+DEFHOOK\n+(chkp_initialize_bounds,\n+ \"Generate a list of statements @var{stmts} to initialize pointer\\n\\\n+bounds variable @var{var} with bounds @var{lb} and @var{ub}.  Return\\n\\\n+the number of generated statements.\",\n+ int, (tree var, tree lb, tree ub, tree *stmts),\n+ default_chkp_initialize_bounds)\n+\n /* Select a replacement for a target-specific builtin.  This is done\n    *before* regular type checking, and so allows the target to\n    implement a crude form of function overloading.  The result is a\n@@ -3843,6 +3944,54 @@ not generate any instructions in this case.\",\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_varargs)\n \n+DEFHOOK\n+(load_bounds_for_arg,\n+ \"This hook is used by expand pass to emit insn to load bounds of\\n\\\n+@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\\n\\\n+bounds of @var{arg} are not passed in register.  If @var{slot} is a\\n\\\n+memory, then bounds are loaded as for regular pointer loaded from\\n\\\n+memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\\n\\\n+constant holding number of the target dependent special slot which\\n\\\n+should be used to obtain bounds.  Hook returns RTX holding loaded bounds.\",\n+ rtx, (rtx slot, rtx arg, rtx slot_no),\n+ default_load_bounds_for_arg)\n+\n+DEFHOOK\n+(store_bounds_for_arg,\n+ \"This hook is used by expand pass to emit insns to store @var{bounds} of\\n\\\n+@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\\n\\\n+@var{bounds} of @var{arg} are not passed in register.  If @var{slot} is a\\n\\\n+memory, then @var{bounds} are stored as for regular pointer stored in\\n\\\n+memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\\n\\\n+constant holding number of the target dependent special slot which\\n\\\n+should be used to store @var{bounds}.\",\n+ void, (rtx arg, rtx slot, rtx bounds, rtx slot_no),\n+ default_store_bounds_for_arg)\n+\n+DEFHOOK\n+(load_returned_bounds,\n+ \"This hook is used by expand pass to emit insn to load bounds\\n\\\n+returned by function call in @var{slot}.  Hook returns RTX holding\\n\\\n+loaded bounds.\",\n+ rtx, (rtx slot),\n+ default_load_returned_bounds)\n+\n+DEFHOOK\n+(store_returned_bounds,\n+ \"This hook is used by expand pass to emit insn to store @var{bounds}\\n\\\n+returned by function call into @var{slot}.\",\n+ void, (rtx slot, rtx bounds),\n+ default_store_returned_bounds)\n+\n+DEFHOOK\n+(setup_incoming_vararg_bounds,\n+ \"Use it to store bounds for anonymous register arguments stored\\n\\\n+into the stack.  Arguments meaning is similar to\\n\\\n+@code{TARGET_SETUP_INCOMING_VARARGS}.\",\n+ void, (cumulative_args_t args_so_far, enum machine_mode mode, tree type,\n+\tint *pretend_args_size, int second_time),\n+ default_setup_incoming_vararg_bounds)\n+\n DEFHOOK\n (strict_argument_naming,\n  \"Define this hook to return @code{true} if the location where a function\\n\\\n@@ -3986,6 +4135,12 @@ The return value is usually either a @code{reg} RTX for the hard\\n\\\n register in which to pass the argument, or zero to pass the argument\\n\\\n on the stack.\\n\\\n \\n\\\n+The return value can be a @code{const_int} which means argument is\\n\\\n+passed in a target specific slot with specified number.  Target hooks\\n\\\n+should be used to store or load argument in such case.  See\\n\\\n+@code{TARGET_STORE_BOUNDS_FOR_ARG} and @code{TARGET_LOAD_BOUNDS_FOR_ARG}\\n\\\n+for more information.\\n\\\n+\\n\\\n The value of the expression can also be a @code{parallel} RTX@.  This is\\n\\\n used when an argument is passed in multiple locations.  The mode of the\\n\\\n @code{parallel} should be the mode of the entire argument.  The\\n\\\n@@ -4120,6 +4275,15 @@ aggregate data types, because these are returned in another way.  See\\n\\\n  rtx, (const_tree ret_type, const_tree fn_decl_or_type, bool outgoing),\n  default_function_value)\n \n+/* Return the rtx for bounds of returned pointer.  */\n+DEFHOOK\n+(chkp_function_value_bounds,\n+ \"Define this to return an RTX representing the place where a function\\n\\\n+returns bounds for returned pointers.  Arguments meaning is similar to\\n\\\n+@code{TARGET_FUNCTION_VALUE}.\",\n+ rtx, (const_tree ret_type, const_tree fn_decl_or_type, bool outgoing),\n+ default_chkp_function_value_bounds)\n+\n /* Return the rtx for the result of a libcall of mode MODE,\n    calling the function FN_NAME.  */\n DEFHOOK"}, {"sha": "316001687cee31a034efb6a6ff6310b2f0352bcf", "filename": "gcc/targhooks.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1700,6 +1700,36 @@ default_member_type_forces_blk (const_tree, machine_mode)\n   return false;\n }\n \n+rtx\n+default_load_bounds_for_arg (rtx addr ATTRIBUTE_UNUSED,\n+\t\t\t     rtx ptr ATTRIBUTE_UNUSED,\n+\t\t\t     rtx bnd ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+default_store_bounds_for_arg (rtx val ATTRIBUTE_UNUSED,\n+\t\t\t      rtx addr ATTRIBUTE_UNUSED,\n+\t\t\t      rtx bounds ATTRIBUTE_UNUSED,\n+\t\t\t      rtx to ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+rtx\n+default_load_returned_bounds (rtx slot ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+default_store_returned_bounds (rtx slot ATTRIBUTE_UNUSED,\n+\t\t\t       rtx bounds ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Default version of canonicalize_comparison.  */\n \n void\n@@ -1824,6 +1854,62 @@ std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   return build_va_arg_indirect_ref (addr);\n }\n \n+tree\n+default_chkp_bound_type (void)\n+{\n+  tree res = make_node (POINTER_BOUNDS_TYPE);\n+  TYPE_PRECISION (res) = TYPE_PRECISION (size_type_node) * 2;\n+  TYPE_NAME (res) = get_identifier (\"__bounds_type\");\n+  SET_TYPE_MODE (res, targetm.chkp_bound_mode ());\n+  layout_type (res);\n+  return res;\n+}\n+\n+enum machine_mode\n+default_chkp_bound_mode (void)\n+{\n+  return VOIDmode;\n+}\n+\n+tree\n+default_builtin_chkp_function (unsigned int fcode ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n+rtx\n+default_chkp_function_value_bounds (const_tree ret_type ATTRIBUTE_UNUSED,\n+\t\t\t\t    const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t\t\t    bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+tree\n+default_chkp_make_bounds_constant (HOST_WIDE_INT lb ATTRIBUTE_UNUSED,\n+\t\t\t\t   HOST_WIDE_INT ub ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n+int\n+default_chkp_initialize_bounds (tree var ATTRIBUTE_UNUSED,\n+\t\t\t\ttree lb ATTRIBUTE_UNUSED,\n+\t\t\t\ttree ub ATTRIBUTE_UNUSED,\n+\t\t\t\ttree *stmts ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+void\n+default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE_UNUSED,\n+\t\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t      tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t      int *pretend_arg_size ATTRIBUTE_UNUSED,\n+\t\t\t\t      int second_time ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* An implementation of TARGET_CAN_USE_DOLOOP_P for targets that do\n    not support nested low-overhead loops.  */\n "}, {"sha": "faadd23c887cdef6517602801810756ce5d41ed8", "filename": "gcc/targhooks.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -221,4 +221,20 @@ extern bool can_use_doloop_if_innermost (const widest_int &,\n \t\t\t\t\t const widest_int &,\n \t\t\t\t\t unsigned int, bool);\n \n+extern rtx default_load_bounds_for_arg (rtx, rtx, rtx);\n+extern void default_store_bounds_for_arg (rtx, rtx, rtx, rtx);\n+extern rtx default_load_returned_bounds (rtx);\n+extern void default_store_returned_bounds (rtx,rtx);\n+extern tree default_chkp_bound_type (void);\n+extern enum machine_mode default_chkp_bound_mode (void);\n+extern tree default_builtin_chkp_function (unsigned int);\n+extern rtx default_chkp_function_value_bounds (const_tree, const_tree, bool);\n+extern tree default_chkp_make_bounds_constant (HOST_WIDE_INT lb, HOST_WIDE_INT ub);\n+extern int default_chkp_initialize_bounds (tree var, tree lb, tree ub,\n+\t\t\t\t\t   tree *stmts);\n+extern void default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  int *pretend_arg_size ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  int second_time ATTRIBUTE_UNUSED);\n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "e25b7b1c9e04042dd59da2a60d96b205f2e2df4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1,3 +1,17 @@\n+2014-11-05  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\n+\t* gcc.target/i386/chkp-builtins-1.c: New.\n+\t* gcc.target/i386/chkp-builtins-2.c: New.\n+\t* gcc.target/i386/chkp-builtins-3.c: New.\n+\t* gcc.target/i386/chkp-builtins-4.c: New.\n+\t* gcc.target/i386/chkp-remove-bndint-1.c: New.\n+\t* gcc.target/i386/chkp-remove-bndint-2.c: New.\n+\t* gcc.target/i386/chkp-const-check-1.c: New.\n+\t* gcc.target/i386/chkp-const-check-2.c: New.\n+\t* gcc.target/i386/chkp-lifetime-1.c: New.\n+\t* gcc.dg/pr37858.c: Replace early_local_cleanups pass name\n+\twith build_ssa_passes.\n+\n 2014-11-05  Alex Velenko  <Alex.Velenko@arm.com>\n \n \t* gcc.dg/asr-div1.c: New testcase."}, {"sha": "577b661503afb61b8681f10082417a1de0409a4b", "filename": "gcc/testsuite/gcc.dg/pr37858.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1,12 +1,12 @@\n /* PR middle-end/37858 */\n /* ??? With -dv removed, this test is a bit silly.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-early_local_cleanups\" } */\n+/* { dg-options \"-O2 -fdump-ipa-build_ssa_passes\" } */\n \n int\n main (void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-ipa-dump \"early_local_cleanups\" } } */\n+/* { dg-final { cleanup-ipa-dump \"build_ssa_passes\" } } */"}, {"sha": "bcc1198b5b1def0472145cd7ee68ce4971a5ac25", "filename": "gcc/testsuite/gcc.target/i386/chkp-builtins-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-1.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -fdump-tree-chkp\" } */\n+/* { dg-final { scan-tree-dump-not \"bnd_init_ptr_bounds\" \"chkp\" } } */\n+\n+void *\n+chkp_test (void *p)\n+{\n+  return __builtin___bnd_init_ptr_bounds (p);\n+}"}, {"sha": "1f4a244ee92dd1d854a73cff36108bad79e80d02", "filename": "gcc/testsuite/gcc.target/i386/chkp-builtins-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-2.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -fdump-tree-chkp\" } */\n+/* { dg-final { scan-tree-dump-not \"bnd_copy_ptr_bounds\" \"chkp\" } } */\n+\n+void *\n+chkp_test (void *p, void *q)\n+{\n+  return __builtin___bnd_copy_ptr_bounds (p, q);\n+}"}, {"sha": "ea54ede3c5784faa78615f15b6571e13a9dffd97", "filename": "gcc/testsuite/gcc.target/i386/chkp-builtins-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-3.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -fdump-tree-chkp\" } */\n+/* { dg-final { scan-tree-dump-not \"bnd_set_ptr_bounds\" \"chkp\" } } */\n+\n+void *\n+chkp_test (void *p)\n+{\n+  return __builtin___bnd_set_ptr_bounds (p, 10);\n+}"}, {"sha": "cee780b2371ff349d66e5dcf1dabc76af6f49d2e", "filename": "gcc/testsuite/gcc.target/i386/chkp-builtins-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-builtins-4.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -fdump-tree-chkp\" } */\n+/* { dg-final { scan-tree-dump-not \"bnd_null_ptr_bounds\" \"chkp\" } } */\n+\n+void *\n+chkp_test (void *p)\n+{\n+  return __builtin___bnd_null_ptr_bounds (p);\n+}"}, {"sha": "2cd5af1f626368d36f00d930df77dc66a1d99953", "filename": "gcc/testsuite/gcc.target/i386/chkp-const-check-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-1.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt\" } */\n+/* { dg-final { scan-tree-dump-not \"bndcl\" \"chkpopt\" } } */\n+/* { dg-final { scan-tree-dump-not \"bndcu\" \"chkpopt\" } } */\n+\n+\n+int test (int *p)\n+{\n+  p = (int *)__builtin___bnd_set_ptr_bounds (p, sizeof (int));\n+  return *p;\n+}"}, {"sha": "98497f958a1b07afa29c9332ddb0fd7f88120350", "filename": "gcc/testsuite/gcc.target/i386/chkp-const-check-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-const-check-2.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -O2 -Wchkp\" } */\n+\n+int test (int *p)\n+{\n+  p = (int *)__builtin___bnd_set_ptr_bounds (p, sizeof (int));\n+  return *(p + 1); /* { dg-warning \"memory access check always fail\" \"\" } */\n+}"}, {"sha": "bcecdd032c1310a1a3124f5f8cf491575392d31f", "filename": "gcc/testsuite/gcc.target/i386/chkp-lifetime-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-lifetime-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-lifetime-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-lifetime-1.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-chkpopt-details\" } */\n+/* { dg-final { scan-tree-dump \"Moving creation of \\[^ \\]+ down to its use\" \"chkpopt\" } } */\n+\n+extern int arr[];\n+\n+int test (int i)\n+{\n+  int res;\n+  if (i >= 0)\n+    res = arr[i];\n+  else\n+    res = -i;\n+  return res;\n+}"}, {"sha": "db710041f87e1d1eb50ee8b58f499d73a96b831d", "filename": "gcc/testsuite/gcc.target/i386/chkp-remove-bndint-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-1.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \"bndint\" \"optimized\" } } */\n+\n+\n+struct S\n+{\n+  int a;\n+  int b;\n+  int c;\n+};\n+\n+int test (struct S *ps)\n+{\n+  int *pi = &ps->b;\n+  return *pi;\n+}"}, {"sha": "c97ac2778931ca11269bed316ae3d535f5578c56", "filename": "gcc/testsuite/gcc.target/i386/chkp-remove-bndint-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-remove-bndint-2.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx -O2 -fdump-tree-optimized -Wchkp\" } */\n+/* { dg-final { scan-tree-dump-not \"bndint\" \"optimized\" } } */\n+\n+\n+struct S\n+{\n+  int a;\n+  int b;\n+  int c;\n+};\n+\n+int test (struct S *ps)\n+{\n+  int *pi = &ps->b;\n+  return *(pi + 1); /* { dg-warning \"memory access check always fail\" \"\" } */\n+}"}, {"sha": "9c75dd8e39ed98b91f8ddd74757bc21ab7bb7880", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -97,6 +97,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcse.h\"\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n+#include \"tree-chkp.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n@@ -597,6 +598,9 @@ compile_file (void)\n       if (flag_sanitize & SANITIZE_THREAD)\n \ttsan_finish_file ();\n \n+      if (flag_check_pointer_bounds)\n+\tchkp_finish_file ();\n+\n       output_shared_constant_pool ();\n       output_object_blocks ();\n       finish_tm_clone_pairs ();\n@@ -1309,6 +1313,12 @@ process_options (void)\n \t   \"and -ftree-loop-linear)\");\n #endif\n \n+  if (flag_check_pointer_bounds)\n+    {\n+      if (targetm.chkp_bound_mode () == VOIDmode)\n+\terror (\"-fcheck-pointer-bounds is not supported for this target\");\n+    }\n+\n   /* One region RA really helps to decrease the code size.  */\n   if (flag_ira_region == IRA_REGION_AUTODETECT)\n     flag_ira_region"}, {"sha": "383c66fcaa5e917a8cf8fe0f5ca20c7e5e926cf3", "filename": "gcc/tree-chkp-opt.c", "status": "added", "additions": 1100, "deletions": 0, "changes": 1100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp-opt.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,1100 @@\n+/* Pointer Bounds Checker optimization pass.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-core.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-pass.h\"\n+#include \"is-a.h\"\n+#include \"cfgloop.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-ssa-address.h\"\n+#include \"tree-ssa.h\"\n+#include \"predict.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimple.h\"\n+#include \"tree-phinodes.h\"\n+#include \"gimple-ssa.h\"\n+#include \"ssa-iterators.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify.h\"\n+#include \"gimplify-me.h\"\n+#include \"expr.h\"\n+#include \"tree-chkp.h\"\n+#include \"diagnostic.h\"\n+\n+enum check_type\n+{\n+  CHECK_LOWER_BOUND,\n+  CHECK_UPPER_BOUND\n+};\n+\n+struct pol_item\n+{\n+  tree cst;\n+  tree var;\n+};\n+\n+struct address_t\n+{\n+  vec<struct pol_item> pol;\n+};\n+\n+/* Structure to hold check informtation.  */\n+struct check_info\n+{\n+  /* Type of the check.  */\n+  check_type type;\n+  /* Address used for the check.  */\n+  address_t addr;\n+  /* Bounds used for the check.  */\n+  tree bounds;\n+  /* Check statement.  Can be NULL for removed checks.  */\n+  gimple stmt;\n+};\n+\n+/* Structure to hold checks information for BB.  */\n+struct bb_checks\n+{\n+  vec<struct check_info, va_heap, vl_ptr> checks;\n+};\n+\n+static void chkp_collect_value (tree ssa_name, address_t &res);\n+\n+#define chkp_bndmk_fndecl \\\n+  (targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDMK))\n+#define chkp_intersect_fndecl \\\n+  (targetm.builtin_chkp_function (BUILT_IN_CHKP_INTERSECT))\n+#define chkp_checkl_fndecl \\\n+  (targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDCL))\n+#define chkp_checku_fndecl \\\n+  (targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDCU))\n+\n+static vec<struct bb_checks, va_heap, vl_ptr> check_infos = vNULL;\n+\n+/* Comparator for pol_item structures I1 and I2 to be used\n+   to find items with equal var.  Also used for polynomial\n+   sorting.  */\n+static int\n+chkp_pol_item_compare (const void *i1, const void *i2)\n+{\n+  const struct pol_item *p1 = (const struct pol_item *)i1;\n+  const struct pol_item *p2 = (const struct pol_item *)i2;\n+\n+  if (p1->var == p2->var)\n+    return 0;\n+  else if (p1->var > p2->var)\n+    return 1;\n+  else\n+    return -1;\n+}\n+\n+/* Find polynomial item in ADDR with var equal to VAR\n+   and return its index.  Return -1 if item was not\n+   found.  */\n+static int\n+chkp_pol_find (address_t &addr, tree var)\n+{\n+  int left = 0;\n+  int right = addr.pol.length () - 1;\n+  int n;\n+\n+  while (right >= left)\n+    {\n+      n = (left + right) / 2;\n+\n+      if (addr.pol[n].var == var\n+\t  || (var && addr.pol[n].var\n+\t      && TREE_CODE (var) == ADDR_EXPR\n+\t      && TREE_CODE (addr.pol[n].var) == ADDR_EXPR\n+\t      && TREE_OPERAND (var, 0) == TREE_OPERAND (addr.pol[n].var, 0)))\n+\treturn n;\n+      else if (addr.pol[n].var > var)\n+\tright = n - 1;\n+      else\n+\tleft = n + 1;\n+    }\n+\n+  return -1;\n+}\n+\n+/* Return constant CST extended to size type.  */\n+static tree\n+chkp_extend_const (tree cst)\n+{\n+  if (TYPE_PRECISION (TREE_TYPE (cst)) < TYPE_PRECISION (size_type_node))\n+    return build_int_cst_type (size_type_node, tree_to_shwi (cst));\n+\n+  return cst;\n+}\n+\n+/* Add polynomial item CST * VAR to ADDR.  */\n+static void\n+chkp_add_addr_item (address_t &addr, tree cst, tree var)\n+{\n+  int n = chkp_pol_find (addr, var);\n+\n+  cst = chkp_extend_const (cst);\n+\n+  if (n < 0)\n+    {\n+      struct pol_item item;\n+      item.cst = cst;\n+      item.var = var;\n+\n+      addr.pol.safe_push (item);\n+      addr.pol.qsort (&chkp_pol_item_compare);\n+    }\n+  else\n+    {\n+      addr.pol[n].cst = fold_build2 (PLUS_EXPR, TREE_TYPE (addr.pol[n].cst),\n+\t\t\t\t     addr.pol[n].cst, cst);\n+      if (TREE_CODE (addr.pol[n].cst) == INTEGER_CST\n+\t  && integer_zerop (addr.pol[n].cst))\n+\taddr.pol.ordered_remove (n);\n+    }\n+}\n+\n+/* Subtract polynomial item CST * VAR from ADDR.  */\n+static void\n+chkp_sub_addr_item (address_t &addr, tree cst, tree var)\n+{\n+  int n = chkp_pol_find (addr, var);\n+\n+  cst = chkp_extend_const (cst);\n+\n+  if (n < 0)\n+    {\n+      struct pol_item item;\n+      item.cst = fold_build2 (MINUS_EXPR, TREE_TYPE (cst),\n+\t\t\t      integer_zero_node, cst);\n+      item.var = var;\n+\n+      addr.pol.safe_push (item);\n+      addr.pol.qsort (&chkp_pol_item_compare);\n+    }\n+  else\n+    {\n+      addr.pol[n].cst = fold_build2 (MINUS_EXPR, TREE_TYPE (addr.pol[n].cst),\n+\t\t\t\t     addr.pol[n].cst, cst);\n+      if (TREE_CODE (addr.pol[n].cst) == INTEGER_CST\n+\t  && integer_zerop (addr.pol[n].cst))\n+\taddr.pol.ordered_remove (n);\n+    }\n+}\n+\n+/* Add address DELTA to ADDR.  */\n+static void\n+chkp_add_addr_addr (address_t &addr, address_t &delta)\n+{\n+  unsigned int i;\n+  for (i = 0; i < delta.pol.length (); i++)\n+    chkp_add_addr_item (addr, delta.pol[i].cst, delta.pol[i].var);\n+}\n+\n+/* Subtract address DELTA from ADDR.  */\n+static void\n+chkp_sub_addr_addr (address_t &addr, address_t &delta)\n+{\n+  unsigned int i;\n+  for (i = 0; i < delta.pol.length (); i++)\n+    chkp_sub_addr_item (addr, delta.pol[i].cst, delta.pol[i].var);\n+}\n+\n+/* Mutiply address ADDR by integer constant MULT.  */\n+static void\n+chkp_mult_addr (address_t &addr, tree mult)\n+{\n+  unsigned int i;\n+  for (i = 0; i < addr.pol.length (); i++)\n+    addr.pol[i].cst = fold_build2 (MULT_EXPR, TREE_TYPE (addr.pol[i].cst),\n+\t\t\t\t   addr.pol[i].cst, mult);\n+}\n+\n+/* Return 1 if we may prove ADDR has a constant value with\n+   determined sign, which is put into *SIGN.  Otherwise\n+   return 0.  */\n+static bool\n+chkp_is_constant_addr (const address_t &addr, int *sign)\n+{\n+  *sign = 0;\n+\n+  if (addr.pol.length () == 0)\n+    return true;\n+  else if (addr.pol.length () > 1)\n+    return false;\n+  else if (addr.pol[0].var)\n+    return false;\n+  else if (integer_zerop (addr.pol[0].cst))\n+    *sign = 0;\n+  else if  (tree_int_cst_sign_bit (addr.pol[0].cst))\n+    *sign = -1;\n+  else\n+    *sign = 1;\n+\n+  return true;\n+}\n+\n+/* Dump ADDR into dump_file.  */\n+static void\n+chkp_print_addr (const address_t &addr)\n+{\n+  unsigned int n = 0;\n+  for (n = 0; n < addr.pol.length (); n++)\n+    {\n+      if (n > 0)\n+\tfprintf (dump_file, \" + \");\n+\n+      if (addr.pol[n].var == NULL_TREE)\n+\tprint_generic_expr (dump_file, addr.pol[n].cst, 0);\n+      else\n+\t{\n+\t  if (TREE_CODE (addr.pol[n].cst) != INTEGER_CST\n+\t      || !integer_onep (addr.pol[n].cst))\n+\t    {\n+\t      print_generic_expr (dump_file, addr.pol[n].cst, 0);\n+\t      fprintf (dump_file, \" * \");\n+\t    }\n+\t  print_generic_expr (dump_file, addr.pol[n].var, 0);\n+\t}\n+    }\n+}\n+\n+/* Compute value of PTR and put it into address RES.\n+   PTR has to be ADDR_EXPR.  */\n+static void\n+chkp_collect_addr_value (tree ptr, address_t &res)\n+{\n+  tree obj = TREE_OPERAND (ptr, 0);\n+  address_t addr;\n+\n+  switch (TREE_CODE (obj))\n+    {\n+    case INDIRECT_REF:\n+      chkp_collect_value (TREE_OPERAND (obj, 0), res);\n+      break;\n+\n+    case MEM_REF:\n+      chkp_collect_value (TREE_OPERAND (obj, 0), res);\n+      addr.pol.create (0);\n+      chkp_collect_value (TREE_OPERAND (obj, 1), addr);\n+      chkp_add_addr_addr (res, addr);\n+      addr.pol.release ();\n+      break;\n+\n+    case ARRAY_REF:\n+      chkp_collect_value (build_fold_addr_expr (TREE_OPERAND (obj, 0)), res);\n+      addr.pol.create (0);\n+      chkp_collect_value (TREE_OPERAND (obj, 1), addr);\n+      chkp_mult_addr (addr, array_ref_element_size (obj));\n+      chkp_add_addr_addr (res, addr);\n+      addr.pol.release ();\n+      break;\n+\n+    case COMPONENT_REF:\n+      {\n+\ttree str = TREE_OPERAND (obj, 0);\n+\ttree field = TREE_OPERAND (obj, 1);\n+\tchkp_collect_value (build_fold_addr_expr (str), res);\n+\taddr.pol.create (0);\n+\tchkp_collect_value (component_ref_field_offset (obj), addr);\n+\tchkp_add_addr_addr (res, addr);\n+\taddr.pol.release ();\n+\tif (DECL_FIELD_BIT_OFFSET (field))\n+\t  {\n+\t    addr.pol.create (0);\n+\t    chkp_collect_value (fold_build2 (TRUNC_DIV_EXPR, size_type_node,\n+\t\t\t\t\t     DECL_FIELD_BIT_OFFSET (field),\n+\t\t\t\t\t     size_int (BITS_PER_UNIT)),\n+\t\t\t   addr);\n+\t    chkp_add_addr_addr (res, addr);\n+\t    addr.pol.release ();\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      chkp_add_addr_item (res, integer_one_node, ptr);\n+      break;\n+    }\n+}\n+\n+/* Compute value of PTR and put it into address RES.  */\n+static void\n+chkp_collect_value (tree ptr, address_t &res)\n+{\n+  gimple def_stmt;\n+  enum gimple_code code;\n+  enum tree_code rhs_code;\n+  address_t addr;\n+  tree rhs1;\n+\n+  if (TREE_CODE (ptr) == INTEGER_CST)\n+    {\n+      chkp_add_addr_item (res, ptr, NULL);\n+      return;\n+    }\n+  else if (TREE_CODE (ptr) == ADDR_EXPR)\n+    {\n+      chkp_collect_addr_value (ptr, res);\n+      return;\n+    }\n+  else if (TREE_CODE (ptr) != SSA_NAME)\n+    {\n+      chkp_add_addr_item (res, integer_one_node, ptr);\n+      return;\n+    }\n+\n+  /* Now we handle the case when polynomial is computed\n+     for SSA NAME.  */\n+  def_stmt = SSA_NAME_DEF_STMT (ptr);\n+  code = gimple_code (def_stmt);\n+\n+  /* Currently we do not walk through statements other\n+     than assignment.  */\n+  if (code != GIMPLE_ASSIGN)\n+    {\n+      chkp_add_addr_item (res, integer_one_node, ptr);\n+      return;\n+    }\n+\n+  rhs_code = gimple_assign_rhs_code (def_stmt);\n+  rhs1 = gimple_assign_rhs1 (def_stmt);\n+\n+  switch (rhs_code)\n+    {\n+    case SSA_NAME:\n+    case INTEGER_CST:\n+    case ADDR_EXPR:\n+      chkp_collect_value (rhs1, res);\n+      break;\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+      chkp_collect_value (rhs1, res);\n+      addr.pol.create (0);\n+      chkp_collect_value (gimple_assign_rhs2 (def_stmt), addr);\n+      chkp_add_addr_addr (res, addr);\n+      addr.pol.release ();\n+      break;\n+\n+    case MINUS_EXPR:\n+      chkp_collect_value (rhs1, res);\n+      addr.pol.create (0);\n+      chkp_collect_value (gimple_assign_rhs2 (def_stmt), addr);\n+      chkp_sub_addr_addr (res, addr);\n+      addr.pol.release ();\n+      break;\n+\n+    case MULT_EXPR:\n+      if (TREE_CODE (rhs1) == SSA_NAME\n+\t  && TREE_CODE (gimple_assign_rhs2 (def_stmt)) == INTEGER_CST)\n+\t{\n+\t  chkp_collect_value (rhs1, res);\n+\t  chkp_mult_addr (res, gimple_assign_rhs2 (def_stmt));\n+\t}\n+      else if (TREE_CODE (gimple_assign_rhs2 (def_stmt)) == SSA_NAME\n+\t       && TREE_CODE (rhs1) == INTEGER_CST)\n+\t{\n+\t  chkp_collect_value (gimple_assign_rhs2 (def_stmt), res);\n+\t  chkp_mult_addr (res, rhs1);\n+\t}\n+      else\n+\tchkp_add_addr_item (res, integer_one_node, ptr);\n+      break;\n+\n+    default:\n+      chkp_add_addr_item (res, integer_one_node, ptr);\n+      break;\n+    }\n+}\n+\n+/* Fill check_info structure *CI with information about\n+   check STMT.  */\n+static void\n+chkp_fill_check_info (gimple stmt, struct check_info *ci)\n+{\n+  ci->addr.pol.create (0);\n+  ci->bounds = gimple_call_arg (stmt, 1);\n+  chkp_collect_value (gimple_call_arg (stmt, 0), ci->addr);\n+  ci->type = (gimple_call_fndecl (stmt) == chkp_checkl_fndecl\n+\t     ? CHECK_LOWER_BOUND\n+\t     : CHECK_UPPER_BOUND);\n+  ci->stmt = stmt;\n+}\n+\n+/* Release structures holding check information\n+   for current function.  */\n+static void\n+chkp_release_check_info (void)\n+{\n+  unsigned int n, m;\n+\n+  if (check_infos.exists ())\n+    {\n+      for (n = 0; n < check_infos.length (); n++)\n+\t{\n+\t  for (m = 0; m < check_infos[n].checks.length (); m++)\n+\t    if (check_infos[n].checks[m].addr.pol.exists ())\n+\t      check_infos[n].checks[m].addr.pol.release ();\n+\t  check_infos[n].checks.release ();\n+\t}\n+      check_infos.release ();\n+    }\n+}\n+\n+/* Create structures to hold check information\n+   for current function.  */\n+static void\n+chkp_init_check_info (void)\n+{\n+  struct bb_checks empty_bbc;\n+  int n;\n+\n+  empty_bbc.checks = vNULL;\n+\n+  chkp_release_check_info ();\n+\n+  check_infos.create (last_basic_block_for_fn (cfun));\n+  for (n = 0; n < last_basic_block_for_fn (cfun); n++)\n+    {\n+      check_infos.safe_push (empty_bbc);\n+      check_infos.last ().checks.create (0);\n+    }\n+}\n+\n+/* Find all checks in current function and store info about them\n+   in check_infos.  */\n+static void\n+chkp_gather_checks_info (void)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator i;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Gathering information about checks...\\n\");\n+\n+  chkp_init_check_info ();\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      struct bb_checks *bbc = &check_infos[bb->index];\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Searching checks in BB%d...\\n\", bb->index);\n+\n+      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+        {\n+\t  gimple stmt = gsi_stmt (i);\n+\n+\t  if (gimple_code (stmt) != GIMPLE_CALL)\n+\t    continue;\n+\n+\t  if (gimple_call_fndecl (stmt) == chkp_checkl_fndecl\n+\t      || gimple_call_fndecl (stmt) == chkp_checku_fndecl)\n+\t    {\n+\t      struct check_info ci;\n+\n+\t      chkp_fill_check_info (stmt, &ci);\n+\t      bbc->checks.safe_push (ci);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Adding check information:\\n\");\n+\t\t  fprintf (dump_file, \"  bounds: \");\n+\t\t  print_generic_expr (dump_file, ci.bounds, 0);\n+\t\t  fprintf (dump_file, \"\\n  address: \");\n+\t\t  chkp_print_addr (ci.addr);\n+\t\t  fprintf (dump_file, \"\\n  check: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Return 1 if check CI against BOUNDS always pass,\n+   -1 if check CI against BOUNDS always fails and\n+   0 if we cannot compute check result.  */\n+static int\n+chkp_get_check_result (struct check_info *ci, tree bounds)\n+{\n+  gimple bnd_def;\n+  address_t bound_val;\n+  int sign, res = 0;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Trying to compute result of the check\\n\");\n+      fprintf (dump_file, \"  check: \");\n+      print_gimple_stmt (dump_file, ci->stmt, 0, 0);\n+      fprintf (dump_file, \"  address: \");\n+      chkp_print_addr (ci->addr);\n+      fprintf (dump_file, \"\\n  bounds: \");\n+      print_generic_expr (dump_file, bounds, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (TREE_CODE (bounds) != SSA_NAME)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: bounds tree code is not ssa_name\\n\");\n+      return 0;\n+    }\n+\n+  bnd_def = SSA_NAME_DEF_STMT (bounds);\n+  /* Currently we handle cases when bounds are result of bndmk\n+     or loaded static bounds var.  */\n+  if (gimple_code (bnd_def) == GIMPLE_CALL\n+      && gimple_call_fndecl (bnd_def) == chkp_bndmk_fndecl)\n+    {\n+      bound_val.pol.create (0);\n+      chkp_collect_value (gimple_call_arg (bnd_def, 0), bound_val);\n+      if (ci->type == CHECK_UPPER_BOUND)\n+\t{\n+\t  address_t size_val;\n+\t  size_val.pol.create (0);\n+\t  chkp_collect_value (gimple_call_arg (bnd_def, 1), size_val);\n+\t  chkp_add_addr_addr (bound_val, size_val);\n+\t  size_val.pol.release ();\n+\t  chkp_add_addr_item (bound_val, integer_minus_one_node, NULL);\n+\t}\n+    }\n+  else if (gimple_code (bnd_def) == GIMPLE_ASSIGN\n+\t   && gimple_assign_rhs1 (bnd_def) == chkp_get_zero_bounds_var ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: always pass with zero bounds\\n\");\n+      return 1;\n+    }\n+  else if (gimple_code (bnd_def) == GIMPLE_ASSIGN\n+\t   && gimple_assign_rhs1 (bnd_def) == chkp_get_none_bounds_var ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: always fails with none bounds\\n\");\n+      return -1;\n+    }\n+  else if (gimple_code (bnd_def) == GIMPLE_ASSIGN\n+\t   && TREE_CODE (gimple_assign_rhs1 (bnd_def)) == VAR_DECL)\n+    {\n+      tree bnd_var = gimple_assign_rhs1 (bnd_def);\n+      tree var;\n+      tree size;\n+\n+      if (!DECL_INITIAL (bnd_var)\n+\t  || DECL_INITIAL (bnd_var) == error_mark_node)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  result: cannot compute bounds\\n\");\n+\t  return 0;\n+\t}\n+\n+      gcc_assert (TREE_CODE (DECL_INITIAL (bnd_var)) == ADDR_EXPR);\n+      var = TREE_OPERAND (DECL_INITIAL (bnd_var), 0);\n+\n+      bound_val.pol.create (0);\n+      chkp_collect_value (DECL_INITIAL (bnd_var), bound_val);\n+      if (ci->type == CHECK_UPPER_BOUND)\n+\t{\n+\t  if (TREE_CODE (var) == VAR_DECL)\n+\t    {\n+\t      if (DECL_SIZE (var)\n+\t\t  && !chkp_variable_size_type (TREE_TYPE (var)))\n+\t\tsize = DECL_SIZE_UNIT (var);\n+\t      else\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  result: cannot compute bounds\\n\");\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (TREE_CODE (var) == STRING_CST);\n+\t      size = build_int_cst (size_type_node,\n+\t\t\t\t    TREE_STRING_LENGTH (var));\n+\t    }\n+\n+\t  address_t size_val;\n+\t  size_val.pol.create (0);\n+\t  chkp_collect_value (size, size_val);\n+\t  chkp_add_addr_addr (bound_val, size_val);\n+\t  size_val.pol.release ();\n+\t  chkp_add_addr_item (bound_val, integer_minus_one_node, NULL);\n+\t}\n+    }\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: cannot compute bounds\\n\");\n+      return 0;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  bound value: \");\n+      chkp_print_addr (bound_val);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  chkp_sub_addr_addr (bound_val, ci->addr);\n+\n+  if (!chkp_is_constant_addr (bound_val, &sign))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: cannot compute result\\n\");\n+\n+      res = 0;\n+    }\n+  else if (sign == 0\n+\t   || (ci->type == CHECK_UPPER_BOUND && sign > 0)\n+\t   || (ci->type == CHECK_LOWER_BOUND && sign < 0))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: always pass\\n\");\n+\n+      res = 1;\n+    }\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  result: always fail\\n\");\n+\n+      res = -1;\n+    }\n+\n+  bound_val.pol.release ();\n+\n+  return res;\n+}\n+\n+/* Try to compare bounds value and address value\n+   used in the check CI.  If we can prove that check\n+   always pass then remove it.  */\n+static void\n+chkp_remove_check_if_pass (struct check_info *ci)\n+{\n+  int result = 0;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Trying to remove check: \");\n+      print_gimple_stmt (dump_file, ci->stmt, 0, 0);\n+    }\n+\n+  result = chkp_get_check_result (ci, ci->bounds);\n+\n+  if (result == 1)\n+    {\n+      gimple_stmt_iterator i = gsi_for_stmt (ci->stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  action: delete check (always pass)\\n\");\n+\n+      gsi_remove (&i, true);\n+      unlink_stmt_vdef (ci->stmt);\n+      release_defs (ci->stmt);\n+      ci->stmt = NULL;\n+    }\n+  else if (result == -1)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  action: keep check (always fail)\\n\");\n+      warning_at (gimple_location (ci->stmt), OPT_Wchkp,\n+\t\t  \"memory access check always fail\");\n+    }\n+  else if (result == 0)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  action: keep check (cannot compute result)\\n\");\n+    }\n+}\n+\n+/* For bounds used in CI check if bounds are produced by\n+   intersection and we may use outer bounds instead.  If\n+   transformation is possible then fix check statement and\n+   recompute its info.  */\n+static void\n+chkp_use_outer_bounds_if_possible (struct check_info *ci)\n+{\n+  gimple bnd_def;\n+  tree bnd1, bnd2, bnd_res = NULL;\n+  int check_res1, check_res2;\n+\n+  if (TREE_CODE (ci->bounds) != SSA_NAME)\n+    return;\n+\n+  bnd_def = SSA_NAME_DEF_STMT (ci->bounds);\n+  if (gimple_code (bnd_def) != GIMPLE_CALL\n+      || gimple_call_fndecl (bnd_def) != chkp_intersect_fndecl)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Check if bounds intersection is redundant: \\n\");\n+      fprintf (dump_file, \"  check: \");\n+      print_gimple_stmt (dump_file, ci->stmt, 0, 0);\n+      fprintf (dump_file, \"  intersection: \");\n+      print_gimple_stmt (dump_file, bnd_def, 0, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  bnd1 = gimple_call_arg (bnd_def, 0);\n+  bnd2 = gimple_call_arg (bnd_def, 1);\n+\n+  check_res1 = chkp_get_check_result (ci, bnd1);\n+  check_res2 = chkp_get_check_result (ci, bnd2);\n+  if (check_res1 == 1)\n+    bnd_res = bnd2;\n+  else if (check_res1 == -1)\n+    bnd_res = bnd1;\n+  else if (check_res2 == 1)\n+    bnd_res = bnd1;\n+  else if (check_res2 == -1)\n+    bnd_res = bnd2;\n+\n+  if (bnd_res)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  action: use \");\n+\t  print_generic_expr (dump_file, bnd2, 0);\n+\t  fprintf (dump_file, \" instead of \");\n+\t  print_generic_expr (dump_file, ci->bounds, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      ci->bounds = bnd_res;\n+      gimple_call_set_arg (ci->stmt, 1, bnd_res);\n+      update_stmt (ci->stmt);\n+      chkp_fill_check_info (ci->stmt, ci);\n+    }\n+}\n+\n+/*  Try to find checks whose bounds were produced by intersection\n+    which does not affect check result.  In such check outer bounds\n+    are used instead.  It allows to remove excess intersections\n+    and helps to compare checks.  */\n+static void\n+chkp_remove_excess_intersections (void)\n+{\n+  basic_block bb;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Searching for redundant bounds intersections...\\n\");\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      struct bb_checks *bbc = &check_infos[bb->index];\n+      unsigned int no;\n+\n+      /* Iterate through all found checks in BB.  */\n+      for (no = 0; no < bbc->checks.length (); no++)\n+\tif (bbc->checks[no].stmt)\n+\t  chkp_use_outer_bounds_if_possible (&bbc->checks[no]);\n+    }\n+}\n+\n+/*  Try to remove all checks which are known to alwyas pass.  */\n+static void\n+chkp_remove_constant_checks (void)\n+{\n+  basic_block bb;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Searching for redundant checks...\\n\");\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      struct bb_checks *bbc = &check_infos[bb->index];\n+      unsigned int no;\n+\n+      /* Iterate through all found checks in BB.  */\n+      for (no = 0; no < bbc->checks.length (); no++)\n+\tif (bbc->checks[no].stmt)\n+\t  chkp_remove_check_if_pass (&bbc->checks[no]);\n+    }\n+}\n+\n+/* Intrumentation pass inserts most of bounds creation code\n+   in the header of the function.  We want to move bounds\n+   creation closer to bounds usage to reduce bounds lifetime.\n+   We also try to avoid bounds creation code on paths where\n+   bounds are not used.  */\n+static void\n+chkp_reduce_bounds_lifetime (void)\n+{\n+  basic_block bb = FALLTHRU_EDGE (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n+  gimple_stmt_iterator i;\n+\n+  for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n+    {\n+      gimple dom_use, use_stmt, stmt = gsi_stmt (i);\n+      basic_block dom_bb;\n+      ssa_op_iter iter;\n+      imm_use_iterator use_iter;\n+      use_operand_p use_p;\n+      tree op;\n+      bool want_move = false;\n+      bool deps = false;\n+\n+      if (gimple_code (stmt) == GIMPLE_CALL\n+\t  && gimple_call_fndecl (stmt) == chkp_bndmk_fndecl)\n+\twant_move = true;\n+\n+      if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t  && POINTER_BOUNDS_P (gimple_assign_lhs (stmt))\n+\t  && gimple_assign_rhs_code (stmt) == VAR_DECL)\n+\twant_move = true;\n+\n+      if (!want_move)\n+\t{\n+\t  gsi_next (&i);\n+\t  continue;\n+\t}\n+\n+      /* Check we do not increase other values lifetime.  */\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  op = USE_FROM_PTR (use_p);\n+\n+\t  if (TREE_CODE (op) == SSA_NAME\n+\t      && gimple_code (SSA_NAME_DEF_STMT (op)) != GIMPLE_NOP)\n+\t    {\n+\t      deps = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (deps)\n+\t{\n+\t  gsi_next (&i);\n+\t  continue;\n+\t}\n+\n+      /* Check all usages of bounds.  */\n+      if (gimple_code (stmt) == GIMPLE_CALL)\n+\top = gimple_call_lhs (stmt);\n+      else\n+\t{\n+\t  gcc_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n+\t  op = gimple_assign_lhs (stmt);\n+\t}\n+\n+      dom_use = NULL;\n+      dom_bb = NULL;\n+\n+      FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, op)\n+\t{\n+\t  if (dom_bb &&\n+\t      dominated_by_p (CDI_DOMINATORS,\n+\t\t\t      dom_bb, gimple_bb (use_stmt)))\n+\t    {\n+\t      dom_use = use_stmt;\n+\t      dom_bb = NULL;\n+\t    }\n+\t  else if (dom_bb)\n+\t    dom_bb = nearest_common_dominator (CDI_DOMINATORS, dom_bb,\n+\t\t\t\t\t       gimple_bb (use_stmt));\n+\t  else if (!dom_use)\n+\t    dom_use = use_stmt;\n+\t  else if (stmt_dominates_stmt_p (use_stmt, dom_use))\n+\t    dom_use = use_stmt;\n+\t  else if (!stmt_dominates_stmt_p (dom_use, use_stmt)\n+\t\t   /* If dom_use and use_stmt are PHI nodes in one BB\n+\t\t      then it is OK to keep any of them as dom_use.\n+\t\t      stmt_dominates_stmt_p returns 0 for such\n+\t\t      combination, so check it here manually.  */\n+\t\t   && (gimple_code (dom_use) != GIMPLE_PHI\n+\t\t       || gimple_code (use_stmt) != GIMPLE_PHI\n+\t\t       || gimple_bb (use_stmt) != gimple_bb (dom_use))\n+\t\t   )\n+\t    {\n+\t      dom_bb = nearest_common_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t gimple_bb (use_stmt),\n+\t\t\t\t\t\t gimple_bb (dom_use));\n+\t      dom_use = NULL;\n+\t    }\n+\t}\n+\n+      /* In case there is a single use, just move bounds\n+\t creation to the use.  */\n+      if (dom_use || dom_bb)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Moving creation of \");\n+\t      print_generic_expr (dump_file, op, 0);\n+\t      fprintf (dump_file, \" down to its use.\\n\");\n+\t    }\n+\n+\t  if (dom_use && gimple_code (dom_use) == GIMPLE_PHI)\n+\t    {\n+\t      dom_bb = get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\tgimple_bb (dom_use));\n+\t      dom_use = NULL;\n+\t    }\n+\n+\t  if (dom_bb == bb\n+\t      || (dom_use && gimple_bb (dom_use) == bb))\n+\t    {\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Cannot move statement bacause there is no \"\n+\t\t\t     \"suitable dominator block other than entry block.\\n\");\n+\n+\t\t  gsi_next (&i);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (dom_bb)\n+\t\t{\n+\t\t  gimple_stmt_iterator last = gsi_last_bb (dom_bb);\n+\t\t  if (!gsi_end_p (last) && stmt_ends_bb_p (gsi_stmt (last)))\n+\t\t    gsi_move_before (&i, &last);\n+\t\t  else\n+\t\t    gsi_move_after (&i, &last);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gimple_stmt_iterator gsi = gsi_for_stmt (dom_use);\n+\t\t  gsi_move_before (&i, &gsi);\n+\t\t}\n+\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+      else\n+\tgsi_next (&i);\n+    }\n+}\n+\n+/* Initilize checker optimization pass.  */\n+static void\n+chkp_opt_init (void)\n+{\n+  check_infos.create (0);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n+  /* With LTO constant bounds vars may be not initialized by now.\n+     Get constant bounds vars to handle their assignments during\n+     optimizations.  */\n+  chkp_get_zero_bounds_var ();\n+  chkp_get_none_bounds_var ();\n+}\n+\n+/* Finalise checker optimization  pass.  */\n+static void\n+chkp_opt_fini (void)\n+{\n+  chkp_fix_cfg ();\n+}\n+\n+/* Checker optimization pass function.  */\n+static unsigned int\n+chkp_opt_execute (void)\n+{\n+  chkp_opt_init();\n+\n+  chkp_gather_checks_info ();\n+\n+  chkp_remove_excess_intersections ();\n+\n+  chkp_remove_constant_checks ();\n+\n+  chkp_reduce_bounds_lifetime ();\n+\n+  chkp_release_check_info ();\n+\n+  chkp_opt_fini ();\n+\n+  return 0;\n+}\n+\n+/* Pass gate.  */\n+static bool\n+chkp_opt_gate (void)\n+{\n+  return chkp_function_instrumented_p (cfun->decl)\n+    && (flag_chkp_optimize > 0\n+\t|| (flag_chkp_optimize == -1 && optimize > 0));\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_chkp_opt =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"chkpopt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa | PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_il\n+  | TODO_update_ssa /* todo_flags_finish */\n+};\n+\n+class pass_chkp_opt : public gimple_opt_pass\n+{\n+public:\n+  pass_chkp_opt (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_chkp_opt, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual opt_pass * clone ()\n+    {\n+      return new pass_chkp_opt (m_ctxt);\n+    }\n+\n+  virtual bool gate (function *)\n+    {\n+      return chkp_opt_gate ();\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return chkp_opt_execute ();\n+    }\n+\n+}; // class pass_chkp_opt\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_chkp_opt (gcc::context *ctxt)\n+{\n+  return new pass_chkp_opt (ctxt);\n+}"}, {"sha": "df7d425fe66bdb0cf70458158fd061256c39fc4f", "filename": "gcc/tree-chkp.c", "status": "added", "additions": 4252, "deletions": 0, "changes": 4252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28"}, {"sha": "a349baf618fd167a6f3b66b9c503216dc5ca97fe", "filename": "gcc/tree-chkp.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-chkp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -0,0 +1,58 @@\n+/* Declaration of interface functions of Pointer Bounds Checker.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_CHKP_H\n+#define GCC_TREE_CHKP_H\n+\n+#define DECL_BOUNDS(NODE) (chkp_get_bounds (DECL_WRTL_CHECK (NODE)))\n+\n+#define SET_DECL_BOUNDS(NODE, VAL) \\\n+  (chkp_set_bounds (DECL_WRTL_CHECK (NODE), VAL))\n+\n+extern tree chkp_get_bounds (tree node);\n+extern void chkp_set_bounds (tree node, tree val);\n+extern bool chkp_register_var_initializer (tree var);\n+extern void chkp_finish_file (void);\n+extern bool chkp_type_has_pointer (const_tree type);\n+extern unsigned chkp_type_bounds_count (const_tree type);\n+extern tree chkp_make_bounds_for_struct_addr (tree ptr);\n+extern tree chkp_get_zero_bounds_var (void);\n+extern tree chkp_get_none_bounds_var (void);\n+extern void chkp_check_mem_access (tree first, tree last, tree bounds,\n+\t\t\t\t   gimple_stmt_iterator iter,\n+\t\t\t\t   location_t location,\n+\t\t\t\t   tree dirflag);\n+extern void chkp_fix_cfg (void);\n+extern bool chkp_variable_size_type (tree type);\n+extern tree chkp_build_make_bounds_call (tree lb, tree size);\n+extern tree chkp_build_bndldx_call (tree addr, tree ptr);\n+extern tree chkp_build_bndstx_call (tree addr, tree ptr, tree bounds);\n+extern void chkp_find_bound_slots (const_tree type, bitmap res);\n+extern void chkp_build_bndstx (tree addr, tree ptr, tree bounds,\n+\t\t\t       gimple_stmt_iterator *gsi);\n+extern gimple chkp_retbnd_call_by_val (tree val);\n+extern bool chkp_function_instrumented_p (tree fndecl);\n+extern void chkp_function_mark_instrumented (tree fndecl);\n+extern void chkp_copy_bounds_for_assign (gimple assign,\n+\t\t\t\t\t struct cgraph_edge *edge);\n+extern bool chkp_gimple_call_builtin_p (gimple call,\n+\t\t\t\t\tenum built_in_function code);\n+extern void chkp_expand_bounds_reset_for_mem (tree mem, tree ptr);\n+\n+#endif /* GCC_TREE_CHKP_H */"}, {"sha": "f8ee8ccb7481bf152cd6c822bfdaaca8ca678280", "filename": "gcc/tree-core.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -464,6 +464,8 @@ enum tree_index {\n   TI_FILEPTR_TYPE,\n   TI_POINTER_SIZED_TYPE,\n \n+  TI_POINTER_BOUNDS_TYPE,\n+\n   TI_DFLOAT32_TYPE,\n   TI_DFLOAT64_TYPE,\n   TI_DFLOAT128_TYPE,"}, {"sha": "8cb951095c40d0da2f0c00a8a93a2f1449059051", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 194, "deletions": 41, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -80,6 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cfgloop.h\"\n #include \"builtins.h\"\n+#include \"tree-chkp.h\"\n \n #include \"rtl.h\"\t/* FIXME: For asm_str_count.  */\n \n@@ -143,7 +144,8 @@ eni_weights eni_time_weights;\n \n /* Prototypes.  */\n \n-static tree declare_return_variable (copy_body_data *, tree, tree, basic_block);\n+static tree declare_return_variable (copy_body_data *, tree, tree, tree,\n+\t\t\t\t     basic_block);\n static void remap_block (tree *, copy_body_data *);\n static void copy_bind_expr (tree *, int *, copy_body_data *);\n static void declare_inline_vars (tree, tree);\n@@ -152,8 +154,9 @@ static void prepend_lexical_block (tree current_block, tree new_block);\n static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n-static gimple remap_gimple_stmt (gimple, copy_body_data *);\n+static gimple_seq remap_gimple_stmt (gimple, copy_body_data *);\n static bool delete_unreachable_blocks_update_callgraph (copy_body_data *id);\n+static void insert_init_stmt (copy_body_data *, basic_block, gimple);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n@@ -793,8 +796,8 @@ remap_gimple_seq (gimple_seq body, copy_body_data *id)\n \n   for (si = gsi_start (body); !gsi_end_p (si); gsi_next (&si))\n     {\n-      gimple new_stmt = remap_gimple_stmt (gsi_stmt (si), id);\n-      gimple_seq_add_stmt (&new_body, new_stmt);\n+      gimple_seq new_stmts = remap_gimple_stmt (gsi_stmt (si), id);\n+      gimple_seq_add_seq (&new_body, new_stmts);\n     }\n \n   return new_body;\n@@ -1296,12 +1299,13 @@ remap_eh_region_tree_nr (tree old_t_nr, copy_body_data *id)\n /* Helper for copy_bb.  Remap statement STMT using the inlining\n    information in ID.  Return the new statement copy.  */\n \n-static gimple\n+static gimple_seq\n remap_gimple_stmt (gimple stmt, copy_body_data *id)\n {\n   gimple copy = NULL;\n   struct walk_stmt_info wi;\n   bool skip_first = false;\n+  gimple_seq stmts = NULL;\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n      inlining context.  Our output for these trees is completely\n@@ -1316,6 +1320,17 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n   if (gimple_code (stmt) == GIMPLE_RETURN && id->transform_return_to_modify)\n     {\n       tree retval = gimple_return_retval (stmt);\n+      tree retbnd = gimple_return_retbnd (stmt);\n+      tree bndslot = id->retbnd;\n+\n+      if (retbnd && bndslot)\n+\t{\n+\t  gimple bndcopy = gimple_build_assign (bndslot, retbnd);\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  wi.info = id;\n+\t  walk_gimple_op (bndcopy, remap_gimple_op_r, &wi);\n+\t  gimple_seq_add_stmt (&stmts, bndcopy);\n+\t}\n \n       /* If we're returning something, just turn that into an\n \t assignment into the equivalent of the original RESULT_DECL.\n@@ -1333,9 +1348,18 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t\t\t\t      retval);\n \t  /* id->retvar is already substituted.  Skip it on later remapping.  */\n \t  skip_first = true;\n+\n+\t  /* We need to copy bounds if return structure with pointers into\n+\t     instrumented function.  */\n+\t  if (chkp_function_instrumented_p (id->dst_fn)\n+\t      && !bndslot\n+\t      && !BOUNDED_P (id->retvar)\n+\t      && chkp_type_has_pointer (TREE_TYPE (id->retvar)))\n+\t    id->assign_stmts.safe_push (copy);\n+\n \t}\n       else\n-\treturn gimple_build_nop ();\n+\treturn stmts;\n     }\n   else if (gimple_has_substatements (stmt))\n     {\n@@ -1499,7 +1523,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t      value = *n;\n \t      STRIP_TYPE_NOPS (value);\n \t      if (TREE_CONSTANT (value) || TREE_READONLY (value))\n-\t\treturn gimple_build_nop ();\n+\t\treturn NULL;\n \t    }\n \t}\n \n@@ -1516,7 +1540,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t      if (gimple_bb (def_stmt)\n \t\t  && !bitmap_bit_p (id->blocks_to_copy,\n \t\t\t\t    gimple_bb (def_stmt)->index))\n-\t\treturn gimple_build_nop ();\n+\t\treturn NULL;\n \t    }\n \t}\n \n@@ -1526,15 +1550,17 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t\t\t\t\t  gimple_debug_bind_get_value (stmt),\n \t\t\t\t\t  stmt);\n \t  id->debug_stmts.safe_push (copy);\n-\t  return copy;\n+\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  return stmts;\n \t}\n       if (gimple_debug_source_bind_p (stmt))\n \t{\n \t  copy = gimple_build_debug_source_bind\n \t\t   (gimple_debug_source_bind_get_var (stmt),\n \t\t    gimple_debug_source_bind_get_value (stmt), stmt);\n \t  id->debug_stmts.safe_push (copy);\n-\t  return copy;\n+\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  return stmts;\n \t}\n \n       /* Create a new deep copy of the statement.  */\n@@ -1613,7 +1639,10 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n     }\n \n   if (gimple_debug_bind_p (copy) || gimple_debug_source_bind_p (copy))\n-    return copy;\n+    {\n+      gimple_seq_add_stmt (&stmts, copy);\n+      return stmts;\n+    }\n \n   /* Remap all the operands in COPY.  */\n   memset (&wi, 0, sizeof (wi));\n@@ -1631,7 +1660,8 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n       gimple_set_vuse (copy, NULL_TREE);\n     }\n \n-  return copy;\n+  gimple_seq_add_stmt (&stmts, copy);\n+  return stmts;\n }\n \n \n@@ -1672,36 +1702,59 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n+      gimple_seq stmts;\n       gimple stmt = gsi_stmt (gsi);\n       gimple orig_stmt = stmt;\n+      gimple_stmt_iterator stmts_gsi;\n+      bool stmt_added = false;\n \n       id->regimplify = false;\n-      stmt = remap_gimple_stmt (stmt, id);\n-      if (gimple_nop_p (stmt))\n+      stmts = remap_gimple_stmt (stmt, id);\n+\n+      if (gimple_seq_empty_p (stmts))\n \tcontinue;\n \n-      gimple_duplicate_stmt_histograms (cfun, stmt, id->src_cfun, orig_stmt);\n       seq_gsi = copy_gsi;\n \n-      /* With return slot optimization we can end up with\n-\t non-gimple (foo *)&this->m, fix that here.  */\n-      if (is_gimple_assign (stmt)\n-\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n-\t  && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n+      for (stmts_gsi = gsi_start (stmts);\n+\t   !gsi_end_p (stmts_gsi); )\n \t{\n-\t  tree new_rhs;\n-\t  new_rhs = force_gimple_operand_gsi (&seq_gsi,\n-\t\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t      true, NULL, false,\n-\t\t\t\t\t      GSI_CONTINUE_LINKING);\n-\t  gimple_assign_set_rhs1 (stmt, new_rhs);\n-\t  id->regimplify = false;\n-\t}\n+\t  stmt = gsi_stmt (stmts_gsi);\n \n-      gsi_insert_after (&seq_gsi, stmt, GSI_NEW_STMT);\n+\t  /* Advance iterator now before stmt is moved to seq_gsi.  */\n+\t  gsi_next (&stmts_gsi);\n \n-      if (id->regimplify)\n-\tgimple_regimplify_operands (stmt, &seq_gsi);\n+\t  if (gimple_nop_p (stmt))\n+\t      continue;\n+\n+\t  gimple_duplicate_stmt_histograms (cfun, stmt, id->src_cfun,\n+\t\t\t\t\t    orig_stmt);\n+\n+\t  /* With return slot optimization we can end up with\n+\t     non-gimple (foo *)&this->m, fix that here.  */\n+\t  if (is_gimple_assign (stmt)\n+\t      && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+\t      && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n+\t    {\n+\t      tree new_rhs;\n+\t      new_rhs = force_gimple_operand_gsi (&seq_gsi,\n+\t\t\t\t\t\t  gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t\t  true, NULL, false,\n+\t\t\t\t\t\t  GSI_CONTINUE_LINKING);\n+\t      gimple_assign_set_rhs1 (stmt, new_rhs);\n+\t      id->regimplify = false;\n+\t    }\n+\n+\t  gsi_insert_after (&seq_gsi, stmt, GSI_NEW_STMT);\n+\n+\t  if (id->regimplify)\n+\t    gimple_regimplify_operands (stmt, &seq_gsi);\n+\n+\t  stmt_added = true;\n+\t}\n+\n+      if (!stmt_added)\n+\tcontinue;\n \n       /* If copy_basic_block has been empty at the start of this iteration,\n \t call gsi_start_bb again to get at the newly added statements.  */\n@@ -1728,13 +1781,29 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      gimple new_call;\n \t      vec<tree> argarray;\n \t      size_t nargs = gimple_call_num_args (id->gimple_call);\n-\t      size_t n;\n+\t      size_t n, i, nargs_to_copy;\n+\t      bool remove_bounds = false;\n \n \t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n \n+\t      /* Bounds should be removed from arg pack in case\n+\t\t we handle not instrumented call in instrumented\n+\t\t function.  */\n+\t      nargs_to_copy = nargs;\n+\t      if (gimple_call_with_bounds_p (id->gimple_call)\n+\t\t  && !gimple_call_with_bounds_p (stmt))\n+\t\t{\n+\t\t  for (i = gimple_call_num_args (id->gimple_call) - nargs;\n+\t\t       i < gimple_call_num_args (id->gimple_call);\n+\t\t       i++)\n+\t\t    if (POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n+\t\t      nargs_to_copy--;\n+\t\t  remove_bounds = true;\n+\t\t}\n+\n \t      /* Create the new array of arguments.  */\n-\t      n = nargs + gimple_call_num_args (stmt);\n+\t      n = nargs_to_copy + gimple_call_num_args (stmt);\n \t      argarray.create (n);\n \t      argarray.safe_grow_cleared (n);\n \n@@ -1743,11 +1812,26 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      gimple_call_arg_ptr (stmt, 0),\n \t\t      gimple_call_num_args (stmt) * sizeof (tree));\n \n-\t      /* Append the arguments passed in '...'  */\n-\t      memcpy (argarray.address () + gimple_call_num_args (stmt),\n-\t\t      gimple_call_arg_ptr (id->gimple_call, 0)\n-\t\t\t+ (gimple_call_num_args (id->gimple_call) - nargs),\n-\t\t      nargs * sizeof (tree));\n+\t      if (remove_bounds)\n+\t\t{\n+\t\t  /* Append the rest of arguments removing bounds.  */\n+\t\t  unsigned cur = gimple_call_num_args (stmt);\n+\t\t  i = gimple_call_num_args (id->gimple_call) - nargs;\n+\t\t  for (i = gimple_call_num_args (id->gimple_call) - nargs;\n+\t\t       i < gimple_call_num_args (id->gimple_call);\n+\t\t       i++)\n+\t\t    if (!POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n+\t\t      argarray[cur++] = gimple_call_arg (id->gimple_call, i);\n+\t\t  gcc_assert (cur == n);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Append the arguments passed in '...'  */\n+\t\t  memcpy (argarray.address () + gimple_call_num_args (stmt),\n+\t\t\t  gimple_call_arg_ptr (id->gimple_call, 0)\n+\t\t\t  + (gimple_call_num_args (id->gimple_call) - nargs),\n+\t\t\t  nargs * sizeof (tree));\n+\t\t}\n \n \t      new_call = gimple_build_call_vec (gimple_call_fn (stmt),\n \t\t\t\t\t\targarray);\n@@ -1773,13 +1857,20 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t    {\n \t      /* __builtin_va_arg_pack_len () should be replaced by\n \t\t the number of anonymous arguments.  */\n-\t      size_t nargs = gimple_call_num_args (id->gimple_call);\n+\t      size_t nargs = gimple_call_num_args (id->gimple_call), i;\n \t      tree count, p;\n \t      gimple new_stmt;\n \n \t      for (p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n \t\tnargs--;\n \n+\t      /* For instrumented calls we should ignore bounds.  */\n+\t      for (i = gimple_call_num_args (id->gimple_call) - nargs;\n+\t\t   i < gimple_call_num_args (id->gimple_call);\n+\t\t   i++)\n+\t\tif (POINTER_BOUNDS_P (gimple_call_arg (id->gimple_call, i)))\n+\t\t  nargs--;\n+\n \t      count = build_int_cst (integer_type_node, nargs);\n \t      new_stmt = gimple_build_assign (gimple_call_lhs (stmt), count);\n \t      gsi_replace (&copy_gsi, new_stmt, false);\n@@ -3128,12 +3219,14 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n    is set only for CALL_EXPR_RETURN_SLOT_OPT.  MODIFY_DEST, if non-null,\n    was the LHS of the MODIFY_EXPR to which this call is the RHS.\n \n+   RETURN_BOUNDS holds a destination for returned bounds.\n+\n    The return value is a (possibly null) value that holds the result\n    as seen by the caller.  */\n \n static tree\n declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n-\t\t\t basic_block entry_bb)\n+\t\t\t tree return_bounds, basic_block entry_bb)\n {\n   tree callee = id->src_fn;\n   tree result = DECL_RESULT (callee);\n@@ -3313,6 +3406,19 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n   /* Remember this so we can ignore it in remap_decls.  */\n   id->retvar = var;\n \n+  /* If returned bounds are used, then make var for them.  */\n+  if (return_bounds)\n+  {\n+    tree bndtemp = create_tmp_var (pointer_bounds_type_node, \"retbnd\");\n+    DECL_SEEN_IN_BIND_EXPR_P (bndtemp) = 1;\n+    TREE_NO_WARNING (bndtemp) = 1;\n+    declare_inline_vars (id->block, bndtemp);\n+\n+    id->retbnd = bndtemp;\n+    insert_init_stmt (id, entry_bb,\n+\t\t      gimple_build_assign (bndtemp, chkp_get_zero_bounds_var ()));\n+  }\n+\n   return use;\n }\n \n@@ -4144,6 +4250,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   hash_map<tree, tree> *st = NULL;\n   tree return_slot;\n   tree modify_dest;\n+  tree return_bounds = NULL;\n   location_t saved_location;\n   struct cgraph_edge *cg_edge;\n   cgraph_inline_failed_t reason;\n@@ -4152,6 +4259,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   gimple_stmt_iterator gsi, stmt_gsi;\n   bool successfully_inlined = FALSE;\n   bool purge_dead_abnormal_edges;\n+  unsigned int i;\n \n   /* Set input_location here so we get the right instantiation context\n      if we call instantiate_decl from inlinable_function_p.  */\n@@ -4240,6 +4348,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \n   /* We will be inlining this callee.  */\n   id->eh_lp_nr = lookup_stmt_eh_lp (stmt);\n+  id->assign_stmts.create (0);\n \n   /* Update the callers EH personality.  */\n   if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl))\n@@ -4361,6 +4470,24 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     {\n       modify_dest = gimple_call_lhs (stmt);\n \n+      /* Remember where to copy returned bounds.  */\n+      if (gimple_call_with_bounds_p (stmt)\n+\t  && TREE_CODE (modify_dest) == SSA_NAME)\n+\t{\n+\t  gimple retbnd = chkp_retbnd_call_by_val (modify_dest);\n+\t  if (retbnd)\n+\t    {\n+\t      return_bounds = gimple_call_lhs (retbnd);\n+\t      /* If returned bounds are not used then just\n+\t\t remove unused call.  */\n+\t      if (!return_bounds)\n+\t\t{\n+\t\t  gimple_stmt_iterator iter = gsi_for_stmt (retbnd);\n+\t\t  gsi_remove (&iter, true);\n+\t\t}\n+\t    }\n+\t}\n+\n       /* The function which we are inlining might not return a value,\n \t in which case we should issue a warning that the function\n \t does not return a value.  In that case the optimizers will\n@@ -4391,7 +4518,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     }\n \n   /* Declare the return variable for the function.  */\n-  use_retvar = declare_return_variable (id, return_slot, modify_dest, bb);\n+  use_retvar = declare_return_variable (id, return_slot, modify_dest,\n+\t\t\t\t\treturn_bounds, bb);\n \n   /* Add local vars in this inlined callee to caller.  */\n   add_local_variables (id->src_cfun, cfun, id);\n@@ -4443,6 +4571,12 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       stmt = gimple_build_assign (gimple_call_lhs (stmt), use_retvar);\n       gsi_replace (&stmt_gsi, stmt, false);\n       maybe_clean_or_replace_eh_stmt (old_stmt, stmt);\n+\n+      /* Copy bounds if we copy structure with bounds.  */\n+      if (chkp_function_instrumented_p (id->dst_fn)\n+\t  && !BOUNDED_P (use_retvar)\n+\t  && chkp_type_has_pointer (TREE_TYPE (use_retvar)))\n+\tid->assign_stmts.safe_push (stmt);\n     }\n   else\n     {\n@@ -4474,6 +4608,20 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n         gsi_remove (&stmt_gsi, true);\n     }\n \n+  /* Put returned bounds into the correct place if required.  */\n+  if (return_bounds)\n+    {\n+      gimple old_stmt = SSA_NAME_DEF_STMT (return_bounds);\n+      gimple new_stmt = gimple_build_assign (return_bounds, id->retbnd);\n+      gimple_stmt_iterator bnd_gsi = gsi_for_stmt (old_stmt);\n+      unlink_stmt_vdef (old_stmt);\n+      gsi_replace (&bnd_gsi, new_stmt, false);\n+      maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt);\n+      cgraph_update_edges_for_call_stmt (old_stmt,\n+\t\t\t\t\t gimple_call_fndecl (old_stmt),\n+\t\t\t\t\t new_stmt);\n+    }\n+\n   if (purge_dead_abnormal_edges)\n     {\n       gimple_purge_dead_eh_edges (return_block);\n@@ -4490,6 +4638,11 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       TREE_USED (gimple_assign_rhs1 (stmt)) = 1;\n     }\n \n+  /* Copy bounds for all generated assigns that need it.  */\n+  for (i = 0; i < id->assign_stmts.length (); i++)\n+    chkp_copy_bounds_for_assign (id->assign_stmts[i], cg_edge);\n+  id->assign_stmts.release ();\n+\n   /* Output the inlining info for this abstract function, since it has been\n      inlined.  If we don't do this now, we can lose the information about the\n      variables in the function when the blocks get blown away as soon as we"}, {"sha": "9eb75c7fc9657f70912b4e580c8c59d3f00bb8e5", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -63,6 +63,12 @@ struct copy_body_data\n   /* The VAR_DECL for the return value.  */\n   tree retvar;\n \n+  /* The VAR_DECL for the return bounds.  */\n+  tree retbnd;\n+\n+  /* Assign statements that need bounds copy.  */\n+  vec<gimple> assign_stmts;\n+\n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n   hash_map<tree, tree> *decl_map;"}, {"sha": "a3efdd84b081a81e7de678eb80d00861105e40a3", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -332,6 +332,10 @@ extern void register_pass (register_pass_info *);\n extern void register_pass (opt_pass* pass, pass_positioning_ops pos,\n \t\t\t   const char* ref_pass_name, int ref_pass_inst_number);\n \n+extern simple_ipa_opt_pass *make_pass_ipa_chkp_versioning (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_chkp_produce_thunks (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_chkp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_chkp_opt (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_asan (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_asan_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tsan (gcc::context *ctxt);\n@@ -451,7 +455,9 @@ extern simple_ipa_opt_pass\n extern simple_ipa_opt_pass *make_pass_ipa_tree_profile (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_auto_profile (gcc::context *ctxt);\n \n-extern simple_ipa_opt_pass *make_pass_early_local_passes (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_build_ssa_passes (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_chkp_instrumentation_passes (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_local_optimization_passes (gcc::context *ctxt);\n \n extern ipa_opt_pass_d *make_pass_ipa_whole_program_visibility (gcc::context\n \t\t\t\t\t\t\t       *ctxt);"}, {"sha": "b8abd144f59c25acbe0b9b5c16a6441c7af85397", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -894,6 +894,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case VOID_TYPE:\n+    case POINTER_BOUNDS_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:"}, {"sha": "52d85036e1ff20afb701ae0d9a90e06537658747", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -164,6 +164,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"wide-int-print.h\"\n #include \"builtins.h\"\n+#include \"tree-chkp.h\"\n \n \n /* Possible lattice values.  */\n@@ -1945,6 +1946,8 @@ insert_clobber_before_stack_restore (tree saved_val, tree var,\n     else if (gimple_assign_ssa_name_copy_p (stmt))\n       insert_clobber_before_stack_restore (gimple_assign_lhs (stmt), var,\n \t\t\t\t\t   visited);\n+    else if (chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDRET))\n+      continue;\n     else\n       gcc_assert (is_gimple_debug (stmt));\n }"}, {"sha": "923a0341fad582b971f2fea75276cdb9acb9f31a", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"tree-chkp.h\"\n \n static struct stmt_stats\n {\n@@ -792,7 +793,21 @@ propagate_necessity (bool aggressive)\n \t\t  && (DECL_FUNCTION_CODE (def_callee) == BUILT_IN_ALIGNED_ALLOC\n \t\t      || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_MALLOC\n \t\t      || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))\n-\t\tcontinue;\n+\t\t{\n+\t\t  gimple bounds_def_stmt;\n+\t\t  tree bounds;\n+\n+\t\t  /* For instrumented calls we should also check used\n+\t\t     bounds are returned by the same allocation call.  */\n+\t\t  if (!gimple_call_with_bounds_p (stmt)\n+\t\t      || ((bounds = gimple_call_arg (stmt, 1))\n+\t\t\t  && TREE_CODE (bounds) == SSA_NAME\n+\t\t\t  && (bounds_def_stmt = SSA_NAME_DEF_STMT (bounds))\n+\t\t\t  && chkp_gimple_call_builtin_p (bounds_def_stmt,\n+\t\t\t\t\t\t\t BUILT_IN_CHKP_BNDRET)\n+\t\t\t  && gimple_call_arg (bounds_def_stmt, 0) == ptr))\n+\t\t    continue;\n+\t\t}\n \t    }\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n@@ -1219,6 +1234,23 @@ eliminate_unnecessary_stmts (void)\n \t\t      && !gimple_plf (def_stmt, STMT_NECESSARY))\n \t\t    gimple_set_plf (stmt, STMT_NECESSARY, false);\n \t\t}\n+\t      /* We did not propagate necessity for free calls fed\n+\t\t by allocation function to allow unnecessary\n+\t\t alloc-free sequence elimination.  For instrumented\n+\t\t calls it also means we did not mark bounds producer\n+\t\t as necessary and it is time to do it in case free\n+\t\t call is not removed.  */\n+\t      if (gimple_call_with_bounds_p (stmt))\n+\t\t{\n+\t\t  gimple bounds_def_stmt;\n+\t\t  tree bounds = gimple_call_arg (stmt, 1);\n+\t\t  gcc_assert (TREE_CODE (bounds) == SSA_NAME);\n+\t\t  bounds_def_stmt = SSA_NAME_DEF_STMT (bounds);\n+\t\t  if (bounds_def_stmt\n+\t\t      && !gimple_plf (bounds_def_stmt, STMT_NECESSARY))\n+\t\t    gimple_set_plf (bounds_def_stmt, STMT_NECESSARY,\n+\t\t\t\t    gimple_plf (stmt, STMT_NECESSARY));\n+\t\t}\n \t    }\n \n \t  /* If GSI is not necessary then remove it.  */\n@@ -1249,7 +1281,9 @@ eliminate_unnecessary_stmts (void)\n \t\t\t  && DECL_FUNCTION_CODE (call) != BUILT_IN_CALLOC\n \t\t\t  && DECL_FUNCTION_CODE (call) != BUILT_IN_ALLOCA\n \t\t\t  && (DECL_FUNCTION_CODE (call)\n-\t\t\t      != BUILT_IN_ALLOCA_WITH_ALIGN))))\n+\t\t\t      != BUILT_IN_ALLOCA_WITH_ALIGN)))\n+\t\t  /* Avoid doing so for bndret calls for the same reason.  */\n+\t\t  && !chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDRET))\n \t\t{\n \t\t  something_changed = true;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "776dacf206bf9ee9d136de88683ab33b596baa38", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -2517,6 +2517,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t\t\t\t   (TREE_CODE (fn) == FUNCTION_DECL\n \t\t\t\t    ? build_fold_addr_expr (fn) : fn),\n \t\t\t\t   nargs, args);\n+\tif (currop->with_bounds)\n+\t  CALL_WITH_BOUNDS_P (folded) = true;\n \tfree (args);\n \tif (sc)\n \t  CALL_EXPR_STATIC_CHAIN (folded) = sc;"}, {"sha": "6968df6c273a40afbb948a48352047759bcfde95", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1160,6 +1160,8 @@ copy_reference_ops_from_call (gimple call,\n   if (stmt_could_throw_p (call) && (lr = lookup_stmt_eh_lp (call)) > 0)\n     temp.op2 = size_int (lr);\n   temp.off = -1;\n+  if (gimple_call_with_bounds_p (call))\n+    temp.with_bounds = 1;\n   result->safe_push (temp);\n \n   /* Copy the call arguments.  As they can be references as well,"}, {"sha": "3b93d320f7ce4d0e2ee69b5cfd07ee5cd4f4620e", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -80,7 +80,9 @@ typedef const struct vn_phi_s *const_vn_phi_t;\n \n typedef struct vn_reference_op_struct\n {\n-  enum tree_code opcode;\n+  ENUM_BITFIELD(tree_code) opcode : 16;\n+  /* 1 for instrumented calls.  */\n+  unsigned with_bounds : 1;\n   /* Constant offset this op adds or -1 if it is variable.  */\n   HOST_WIDE_INT off;\n   tree type;"}, {"sha": "c7c4c418461733d56d5493333d9492307e6fb5cb", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -1339,7 +1339,8 @@ wide_int_to_tree (tree type, const wide_int_ref &pcst)\n \n \tcase POINTER_TYPE:\n \tcase REFERENCE_TYPE:\n-\t  /* Cache NULL pointer.  */\n+\tcase POINTER_BOUNDS_TYPE:\n+\t  /* Cache NULL pointer and zero bounds.  */\n \t  if (hwi == 0)\n \t    {\n \t      limit = 1;\n@@ -3413,6 +3414,7 @@ type_contains_placeholder_1 (const_tree type)\n   switch (TREE_CODE (type))\n     {\n     case VOID_TYPE:\n+    case POINTER_BOUNDS_TYPE:\n     case COMPLEX_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n@@ -9729,6 +9731,8 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n   void_type_node = make_node (VOID_TYPE);\n   layout_type (void_type_node);\n \n+  pointer_bounds_type_node = targetm.chkp_bound_type ();\n+\n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;"}, {"sha": "91359a2387689a3dae1e26adf3cb60d1edb91bf0", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -31,7 +31,11 @@ along with GCC; see the file COPYING3.  If not see\n    These tree codes have been sorted so that the macros in tree.h that\n    check for various tree codes are optimized into range checks.  This\n    gives a measurable performance improvement.  When adding a new\n-   code, consider its placement in relation to the other codes.  */\n+   code, consider its placement in relation to the other codes.\n+\n+   When adding a new tree code which might appear as GIMPLE_ASSIGN RHS\n+   code, proper handler in chkp_compute_bounds_for_assignment may\n+   be required.  */\n \n /* Any erroneous construct is parsed into a node of this type.\n    This type of node is accepted without complaint in all contexts\n@@ -232,6 +236,11 @@ DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", tcc_type, 0)\n /* The void type in C */\n DEFTREECODE (VOID_TYPE, \"void_type\", tcc_type, 0)\n \n+/* Type to hold bounds for a pointer.\n+   Has TYPE_PRECISION component to specify number of bits used\n+   by this type.  */\n+DEFTREECODE (POINTER_BOUNDS_TYPE, \"pointer_bounds_type\", tcc_type, 0)\n+\n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected."}, {"sha": "d9fe0c288e132f1478a10446de4750b845e8f21c", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -560,6 +560,21 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Nonzero if this type is a complete type.  */\n #define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n \n+/* Nonzero if this type is a pointer bounds type.  */\n+#define POINTER_BOUNDS_TYPE_P(NODE) \\\n+  (TREE_CODE (NODE) == POINTER_BOUNDS_TYPE)\n+\n+/* Nonzero if this node has a pointer bounds type.  */\n+#define POINTER_BOUNDS_P(NODE) \\\n+  (POINTER_BOUNDS_TYPE_P (TREE_TYPE (NODE)))\n+\n+/* Nonzero if this type supposes bounds existence.  */\n+#define BOUNDED_TYPE_P(type) (POINTER_TYPE_P (type))\n+\n+/* Nonzero for objects with bounded type.  */\n+#define BOUNDED_P(node) \\\n+  BOUNDED_TYPE_P (TREE_TYPE (node))\n+\n /* Nonzero if this type is the (possibly qualified) void type.  */\n #define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)\n \n@@ -836,6 +851,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_ALLOCA_FOR_VAR_P(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n+/* In a CALL_EXPR, means call was instrumented by Pointer Bounds Checker.  */\n+#define CALL_WITH_BOUNDS_P(NODE) (CALL_EXPR_CHECK (NODE)->base.deprecated_flag)\n+\n /* In a type, nonzero means that all objects of the type are guaranteed by the\n    language or front-end to be properly aligned, so we can indicate that a MEM\n    of this type is aligned at least to the alignment of the type, even if it\n@@ -3284,6 +3302,8 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define complex_double_type_node\tglobal_trees[TI_COMPLEX_DOUBLE_TYPE]\n #define complex_long_double_type_node\tglobal_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]\n \n+#define pointer_bounds_type_node        global_trees[TI_POINTER_BOUNDS_TYPE]\n+\n #define void_type_node\t\t\tglobal_trees[TI_VOID_TYPE]\n /* The C type `void *'.  */\n #define ptr_type_node\t\t\tglobal_trees[TI_PTR_TYPE]"}, {"sha": "1b203e8aef17429c42be403ba16eca40831b86d2", "filename": "gcc/value-prof.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -74,6 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-nested.h\"\n #include \"params.h\"\n+#include \"tree-chkp.h\"\n \n /* In this file value profile based optimizations are placed.  Currently the\n    following optimizations are implemented (for more detailed descriptions\n@@ -1382,7 +1383,7 @@ gimple\n gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n \t   int prob, gcov_type count, gcov_type all)\n {\n-  gimple dcall_stmt, load_stmt, cond_stmt;\n+  gimple dcall_stmt, load_stmt, cond_stmt, iretbnd_stmt = NULL;\n   tree tmp0, tmp1, tmp;\n   basic_block cond_bb, dcall_bb, icall_bb, join_bb = NULL;\n   tree optype = build_pointer_type (void_type_node);\n@@ -1396,6 +1397,9 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   cond_bb = gimple_bb (icall_stmt);\n   gsi = gsi_for_stmt (icall_stmt);\n \n+  if (gimple_call_with_bounds_p (icall_stmt) && gimple_call_lhs (icall_stmt))\n+    iretbnd_stmt = chkp_retbnd_call_by_val (gimple_call_lhs (icall_stmt));\n+\n   tmp0 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   tmp1 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   tmp = unshare_expr (gimple_call_fn (icall_stmt));\n@@ -1488,6 +1492,50 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n       gimple_call_set_lhs (dcall_stmt,\n \t\t\t   duplicate_ssa_name (result, dcall_stmt));\n       add_phi_arg (phi, gimple_call_lhs (dcall_stmt), e_dj, UNKNOWN_LOCATION);\n+\n+      /* If indirect call has following BUILT_IN_CHKP_BNDRET\n+\t call then we need to make it's copy for the direct\n+\t call.  */\n+      if (iretbnd_stmt)\n+\t{\n+\t  if (gimple_call_lhs (iretbnd_stmt))\n+\t    {\n+\t      gimple copy;\n+\n+\t      gimple_set_vdef (iretbnd_stmt, NULL_TREE);\n+\t      gimple_set_vuse (iretbnd_stmt, NULL_TREE);\n+\t      update_stmt (iretbnd_stmt);\n+\n+\t      result = gimple_call_lhs (iretbnd_stmt);\n+\t      phi = create_phi_node (result, join_bb);\n+\n+\t      copy = gimple_copy (iretbnd_stmt);\n+\t      gimple_call_set_arg (copy, 0,\n+\t\t\t\t   gimple_call_lhs (dcall_stmt));\n+\t      gimple_call_set_lhs (copy, duplicate_ssa_name (result, copy));\n+\t      gsi_insert_on_edge (e_dj, copy);\n+\t      add_phi_arg (phi, gimple_call_lhs (copy),\n+\t\t\t   e_dj, UNKNOWN_LOCATION);\n+\n+\t      gimple_call_set_arg (iretbnd_stmt, 0,\n+\t\t\t\t   gimple_call_lhs (icall_stmt));\n+\t      gimple_call_set_lhs (iretbnd_stmt,\n+\t\t\t\t   duplicate_ssa_name (result, iretbnd_stmt));\n+\t      psi = gsi_for_stmt (iretbnd_stmt);\n+\t      gsi_remove (&psi, false);\n+\t      gsi_insert_on_edge (e_ij, iretbnd_stmt);\n+\t      add_phi_arg (phi, gimple_call_lhs (iretbnd_stmt),\n+\t\t\t   e_ij, UNKNOWN_LOCATION);\n+\n+\t      gsi_commit_one_edge_insert (e_dj, NULL);\n+\t      gsi_commit_one_edge_insert (e_ij, NULL);\n+\t    }\n+\t  else\n+\t    {\n+\t      psi = gsi_for_stmt (iretbnd_stmt);\n+\t      gsi_remove (&psi, true);\n+\t    }\n+\t}\n     }\n \n   /* Build an EH edge for the direct call if necessary.  */"}, {"sha": "302968e8625f30ab6ac980f21f8df0c4365513e9", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -9813,7 +9813,8 @@ vt_add_function_parameters (void)\n \n   for (parm = DECL_ARGUMENTS (current_function_decl);\n        parm; parm = DECL_CHAIN (parm))\n-    vt_add_function_parameter (parm);\n+    if (!POINTER_BOUNDS_P (parm))\n+      vt_add_function_parameter (parm);\n \n   if (DECL_HAS_VALUE_EXPR_P (DECL_RESULT (current_function_decl)))\n     {"}, {"sha": "40eeb5ed2c234f49b78eaf39b2f225c5179c65ae", "filename": "gcc/varasm.c", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"asan.h\"\n #include \"rtl-iter.h\"\n+#include \"tree-chkp.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -1243,6 +1244,30 @@ use_blocks_for_decl_p (tree decl)\n   return targetm.use_blocks_for_decl_p (decl);\n }\n \n+/* Follow the IDENTIFIER_TRANSPARENT_ALIAS chain starting at *ALIAS\n+   until we find an identifier that is not itself a transparent alias.\n+   Modify the alias passed to it by reference (and all aliases on the\n+   way to the ultimate target), such that they do not have to be\n+   followed again, and return the ultimate target of the alias\n+   chain.  */\n+\n+static inline tree\n+ultimate_transparent_alias_target (tree *alias)\n+{\n+  tree target = *alias;\n+\n+  if (IDENTIFIER_TRANSPARENT_ALIAS (target))\n+    {\n+      gcc_assert (TREE_CHAIN (target));\n+      target = ultimate_transparent_alias_target (&TREE_CHAIN (target));\n+      gcc_assert (! IDENTIFIER_TRANSPARENT_ALIAS (target)\n+\t\t  && ! TREE_CHAIN (target));\n+      *alias = target;\n+    }\n+\n+  return target;\n+}\n+\n /* Create the DECL_RTL for a VAR_DECL or FUNCTION_DECL.  DECL should\n    have static storage duration.  In other words, it should not be an\n    automatic variable, including PARM_DECLs.\n@@ -1257,6 +1282,7 @@ make_decl_rtl (tree decl)\n {\n   const char *name = 0;\n   int reg_number;\n+  tree id;\n   rtx x;\n \n   /* Check that we are not being given an automatic variable.  */\n@@ -1314,7 +1340,12 @@ make_decl_rtl (tree decl)\n       return;\n     }\n \n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  id = DECL_ASSEMBLER_NAME (decl);\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && cgraph_node::get (decl)\n+      && cgraph_node::get (decl)->instrumentation_clone)\n+    ultimate_transparent_alias_target (&id);\n+  name = IDENTIFIER_POINTER (id);\n \n   if (name[0] != '*' && TREE_CODE (decl) != FUNCTION_DECL\n       && DECL_REGISTER (decl))\n@@ -1748,7 +1779,10 @@ assemble_start_function (tree decl, const char *fnname)\n \n   /* Make function name accessible from other files, if appropriate.  */\n \n-  if (TREE_PUBLIC (decl))\n+  if (TREE_PUBLIC (decl)\n+      || (cgraph_node::get (decl)->instrumentation_clone\n+\t  && cgraph_node::get (decl)->instrumented_version\n+\t  && TREE_PUBLIC (cgraph_node::get (decl)->instrumented_version->decl)))\n     {\n       notice_global_symbol (decl);\n \n@@ -2438,30 +2472,6 @@ mark_decl_referenced (tree decl)\n }\n \n \n-/* Follow the IDENTIFIER_TRANSPARENT_ALIAS chain starting at *ALIAS\n-   until we find an identifier that is not itself a transparent alias.\n-   Modify the alias passed to it by reference (and all aliases on the\n-   way to the ultimate target), such that they do not have to be\n-   followed again, and return the ultimate target of the alias\n-   chain.  */\n-\n-static inline tree\n-ultimate_transparent_alias_target (tree *alias)\n-{\n-  tree target = *alias;\n-\n-  if (IDENTIFIER_TRANSPARENT_ALIAS (target))\n-    {\n-      gcc_assert (TREE_CHAIN (target));\n-      target = ultimate_transparent_alias_target (&TREE_CHAIN (target));\n-      gcc_assert (! IDENTIFIER_TRANSPARENT_ALIAS (target)\n-\t\t  && ! TREE_CHAIN (target));\n-      *alias = target;\n-    }\n-\n-  return target;\n-}\n-\n /* Output to FILE (an assembly file) a reference to NAME.  If NAME\n    starts with a *, the rest of NAME is output verbatim.  Otherwise\n    NAME is transformed in a target-specific way (usually by the\n@@ -3778,6 +3788,7 @@ output_constant_pool_2 (machine_mode mode, rtx x, unsigned int align)\n     case MODE_UFRACT:\n     case MODE_ACCUM:\n     case MODE_UACCUM:\n+    case MODE_POINTER_BOUNDS:\n       assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n       break;\n \n@@ -4677,6 +4688,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n     case FIXED_POINT_TYPE:\n+    case POINTER_BOUNDS_TYPE:\n     case NULLPTR_TYPE:\n       if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,\n \t\t\t\t\t   EXPAND_INITIALIZER),\n@@ -5510,6 +5522,8 @@ vec<alias_pair, va_gc> *alias_pairs;\n void\n do_assemble_alias (tree decl, tree target)\n {\n+  tree id;\n+\n   /* Emulated TLS had better not get this var.  */\n   gcc_assert (!(!targetm.have_tls\n \t\t&& TREE_CODE (decl) == VAR_DECL\n@@ -5518,12 +5532,16 @@ do_assemble_alias (tree decl, tree target)\n   if (TREE_ASM_WRITTEN (decl))\n     return;\n \n+  id = DECL_ASSEMBLER_NAME (decl);\n+  ultimate_transparent_alias_target (&id);\n+\n   /* We must force creation of DECL_RTL for debug info generation, even though\n      we don't use it here.  */\n   make_decl_rtl (decl);\n \n   TREE_ASM_WRITTEN (decl) = 1;\n   TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)) = 1;\n+  TREE_ASM_WRITTEN (id) = 1;\n \n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n     {\n@@ -5534,7 +5552,7 @@ do_assemble_alias (tree decl, tree target)\n \n #ifdef ASM_OUTPUT_WEAKREF\n       ASM_OUTPUT_WEAKREF (asm_out_file, decl,\n-\t\t\t  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t\t  IDENTIFIER_POINTER (id),\n \t\t\t  IDENTIFIER_POINTER (target));\n #else\n       if (!TARGET_SUPPORTS_WEAK)\n@@ -5548,9 +5566,16 @@ do_assemble_alias (tree decl, tree target)\n     }\n \n #ifdef ASM_OUTPUT_DEF\n+  tree orig_decl = decl;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && cgraph_node::get (decl)->instrumentation_clone\n+      && cgraph_node::get (decl)->instrumented_version)\n+    orig_decl = cgraph_node::get (decl)->instrumented_version->decl;\n+\n   /* Make name accessible from other files, if appropriate.  */\n \n-  if (TREE_PUBLIC (decl))\n+  if (TREE_PUBLIC (decl) || TREE_PUBLIC (orig_decl))\n     {\n       globalize_decl (decl);\n       maybe_assemble_visibility (decl);\n@@ -5560,7 +5585,7 @@ do_assemble_alias (tree decl, tree target)\n #if defined (ASM_OUTPUT_TYPE_DIRECTIVE)\n       if (targetm.has_ifunc_p ())\n \tASM_OUTPUT_TYPE_DIRECTIVE\n-\t  (asm_out_file, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t  (asm_out_file, IDENTIFIER_POINTER (id),\n \t   IFUNC_ASM_TYPE);\n       else\n #endif\n@@ -5572,15 +5597,15 @@ do_assemble_alias (tree decl, tree target)\n   ASM_OUTPUT_DEF_FROM_DECLS (asm_out_file, decl, target);\n # else\n   ASM_OUTPUT_DEF (asm_out_file,\n-\t\t  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t  IDENTIFIER_POINTER (id),\n \t\t  IDENTIFIER_POINTER (target));\n # endif\n #elif defined (ASM_OUTPUT_WEAK_ALIAS) || defined (ASM_WEAKEN_DECL)\n   {\n     const char *name;\n     tree *p, t;\n \n-    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+    name = IDENTIFIER_POINTER (id);\n # ifdef ASM_WEAKEN_DECL\n     ASM_WEAKEN_DECL (asm_out_file, decl, name, IDENTIFIER_POINTER (target));\n # else\n@@ -5589,7 +5614,8 @@ do_assemble_alias (tree decl, tree target)\n     /* Remove this function from the pending weak list so that\n        we do not emit multiple .weak directives for it.  */\n     for (p = &weak_decls; (t = *p) ; )\n-      if (DECL_ASSEMBLER_NAME (decl) == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))\n+      if (DECL_ASSEMBLER_NAME (decl) == DECL_ASSEMBLER_NAME (TREE_VALUE (t))\n+\t  || id == DECL_ASSEMBLER_NAME (TREE_VALUE (t)))\n \t*p = TREE_CHAIN (t);\n       else\n \tp = &TREE_CHAIN (t);\n@@ -5598,8 +5624,7 @@ do_assemble_alias (tree decl, tree target)\n        list, for the same reason.  */\n     for (p = &weakref_targets; (t = *p) ; )\n       {\n-\tif (DECL_ASSEMBLER_NAME (decl)\n-\t    == ultimate_transparent_alias_target (&TREE_VALUE (t)))\n+\tif (id == ultimate_transparent_alias_target (&TREE_VALUE (t)))\n \t  *p = TREE_CHAIN (t);\n \telse\n \t  p = &TREE_CHAIN (t);\n@@ -5865,6 +5890,12 @@ maybe_assemble_visibility (tree decl)\n {\n   enum symbol_visibility vis = DECL_VISIBILITY (decl);\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && cgraph_node::get (decl)\n+      && cgraph_node::get (decl)->instrumentation_clone\n+      && cgraph_node::get (decl)->instrumented_version)\n+    vis = DECL_VISIBILITY (cgraph_node::get (decl)->instrumented_version->decl);\n+\n   if (vis != VISIBILITY_DEFAULT)\n     {\n       targetm.asm_out.assemble_visibility (decl, vis);\n@@ -6435,6 +6466,7 @@ default_unique_section (tree decl, int reloc)\n   bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;\n   const char *prefix, *name, *linkonce;\n   char *string;\n+  tree id;\n \n   switch (categorize_decl_for_section (decl, reloc))\n     {\n@@ -6484,7 +6516,9 @@ default_unique_section (tree decl, int reloc)\n       gcc_unreachable ();\n     }\n \n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  id = DECL_ASSEMBLER_NAME (decl);\n+  ultimate_transparent_alias_target (&id);\n+  name = IDENTIFIER_POINTER (id);\n   name = targetm.strip_name_encoding (name);\n \n   /* If we're using one_only, then there needs to be a .gnu.linkonce"}, {"sha": "5bfb0a7c8676d6ed03eb9c5b3f9ac11aa0729cdf", "filename": "gcc/varpool.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e254e19c59fcc49265dda64007690af08b6e28/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=d5e254e19c59fcc49265dda64007690af08b6e28", "patch": "@@ -221,6 +221,8 @@ varpool_node::dump (FILE *f)\n     fprintf (f, \" output\");\n   if (used_by_single_function)\n     fprintf (f, \" used-by-single-function\");\n+  if (need_bounds_init)\n+    fprintf (f, \" need-bounds-init\");\n   if (TREE_READONLY (decl))\n     fprintf (f, \" read-only\");\n   if (ctor_useable_for_folding_p ())\n@@ -390,6 +392,12 @@ ctor_for_folding (tree decl)\n       && TREE_CODE (decl) != CONST_DECL)\n     return error_mark_node;\n \n+  /* Static constant bounds are created to be\n+     used instead of constants and therefore\n+     do not let folding it.  */\n+  if (POINTER_BOUNDS_P (decl))\n+    return error_mark_node;\n+\n   if (TREE_CODE (decl) == CONST_DECL\n       || DECL_IN_CONSTANT_POOL (decl))\n     return DECL_INITIAL (decl);"}]}