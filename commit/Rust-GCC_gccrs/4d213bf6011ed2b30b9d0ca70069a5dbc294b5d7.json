{"sha": "4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQyMTNiZjYwMTFlZDJiMzBiOWQwY2E3MDA2OWE1ZGJjMjk0YjVkNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-26T08:33:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-26T08:33:48Z"}, "message": "store-merging: Fix coalesce_immediate_stores [PR93820]\n\nThe following testcase is miscompiled in 8+.\nThe problem is that check_no_overlap has a special case for INTEGER_CST\nmarked stores (i.e. stores of constants), if both all currenly merged stores\nand the one under consideration for merging with them are marked that way,\nit anticipates that other INTEGER_CST marked stores that overlap with those\nand precede those (have smaller info->order) could be merged with those and\ndoesn't punt for them.\nIn PR86844 and PR87859 fixes I've then added quite large code that is\nperformed after check_no_overlap and tries to find out if we need and can\nmerge further INTEGER_CST marked stores, or need to punt.\nUnfortunately, that code is there only in the overlapping case code and\nthe testcase below shows that we really need it even in the adjacent store\ncase.  After sort_by_bitpos we have:\nbitpos\twidth\torder\trhs_code\n96\t32\t3\tINTEGER_CST\n128\t32\t1\tINTEGER_CST\n128\t128\t2\tINTEGER_CST\n192\t32\t0\tMEM_REF\nBecause of the missing PR86844/PR87859-ish code in the adjacent store\ncase, we merge the adjacent (memory wise) stores 96/32/3 and 128/32/1,\nand then we consider the 128-bit store which is in program-order in between\nthem, but in this case we punt, because the merging would extend the\nmerged store region from bitpos 96 and 64-bits to bitpos 96 and 160-bits\nand that has an overlap with an incompatible store (the MEM_REF one).\nThe problem is that we can't really punt this way, because the 128-bit\nstore is in between those two we've merged already, so either we manage\nto merge even that one together with the others, or would need to avoid\nalready merging the 96/32/3 and 128/32/1 stores together.\nNow, rather than copying around the PR86844/PR87859 code to the other spot,\nwe can actually just use the overlapping code, merge_overlapping is really\na superset of merge_into, so that is what the patch does.  If doing\nadjacent store merge for rhs_code other than INTEGER_CST, I believe the\ncurrent code is already fine, check_no_overlap in that case doesn't make\nthe exception and will punt if there is some earlier (smaller order)\nnon-mergeable overlapping store.  There is just one case that could be\nproblematic, if the merged_store has BIT_INSERT_EXPRs in them and the\nnew store is a constant store (INTEGER_CST rhs_code), then check_no_overlap\nwould do the exception and still would allow the special case.  But we\nreally shouldn't have the special case in that case, so this patch also\nchanges check_no_overlap to just have a bool whether we should have the\nspecial case or not.\n\nNote, as I said in the PR, for GCC11 we could consider performing some kind\nof cheap DSE during the store merging (perhaps guarded with flag_tree_dse).\nAnd another thing to consider is only consider as problematic non-mergeable\nstores that not only have order smaller than last_order as currently, but\nalso have order larger than first_order, as in this testcase if we actually\nignored (not merged with anything at all) the 192/32/0 store, because it is\nnot in between the other stores we'd merge, it would be fine to merge the\nother 3 stores, though of course the testcase can be easily adjusted by\nputting the 192/32 store after the 128/32 store and then this patch would be\nstill needed.  Though, I think I'd need more time thinking this over.\n\n2020-02-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/93820\n\t* gimple-ssa-store-merging.c (check_no_overlap): Change RHS_CODE\n\targument to ALL_INTEGER_CST_P boolean.\n\t(imm_store_chain_info::try_coalesce_bswap): Adjust caller.\n\t(imm_store_chain_info::coalesce_immediate_stores): Likewise.  Handle\n\tadjacent INTEGER_CST store into merged_store->only_constants like\n\toverlapping one.\n\n\t* gcc.dg/pr93820.c: New test.", "tree": {"sha": "d1870db352caf46793e7ad8562c4f329b1d92cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1870db352caf46793e7ad8562c4f329b1d92cdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de338f001eb2a821f40e599bd55119d43e0ae7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de338f001eb2a821f40e599bd55119d43e0ae7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de338f001eb2a821f40e599bd55119d43e0ae7e"}], "stats": {"total": 66, "additions": 56, "deletions": 10}, "files": [{"sha": "f3da501ef110f172bcc1aaa775deda170baaf1e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "patch": "@@ -1,3 +1,13 @@\n+2020-02-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93820\n+\t* gimple-ssa-store-merging.c (check_no_overlap): Change RHS_CODE\n+\targument to ALL_INTEGER_CST_P boolean.\n+\t(imm_store_chain_info::try_coalesce_bswap): Adjust caller.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Likewise.  Handle\n+\tadjacent INTEGER_CST store into merged_store->only_constants like\n+\toverlapping one.\n+\n 2020-02-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/93912"}, {"sha": "c5dc1a81debf90d742202266723e7ca52f481984", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "patch": "@@ -2370,8 +2370,9 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)\n /* Check if there are any stores in M_STORE_INFO after index I\n    (where M_STORE_INFO must be sorted by sort_by_bitpos) that overlap\n    a potential group ending with END that have their order\n-   smaller than LAST_ORDER.  RHS_CODE is the kind of store in the\n-   group.  Return true if there are no such stores.\n+   smaller than LAST_ORDER.  ALL_INTEGER_CST_P is true if\n+   all the stores already merged and the one under consideration\n+   have rhs_code of INTEGER_CST.  Return true if there are no such stores.\n    Consider:\n      MEM[(long long int *)p_28] = 0;\n      MEM[(long long int *)p_28 + 8B] = 0;\n@@ -2394,13 +2395,13 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)\n    the MEM[(long long int *)p_28 + 8B] = 0; would now be before it,\n    so we need to refuse merging MEM[(long long int *)p_28 + 8B] = 0;\n    into the group.  That way it will be its own store group and will\n-   not be touched.  If RHS_CODE is INTEGER_CST and there are overlapping\n+   not be touched.  If ALL_INTEGER_CST_P and there are overlapping\n    INTEGER_CST stores, those are mergeable using merge_overlapping,\n    so don't return false for those.  */\n \n static bool\n check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,\n-\t\t  enum tree_code rhs_code, unsigned int last_order,\n+\t\t  bool all_integer_cst_p, unsigned int last_order,\n \t\t  unsigned HOST_WIDE_INT end)\n {\n   unsigned int len = m_store_info.length ();\n@@ -2410,7 +2411,7 @@ check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,\n       if (info->bitpos >= end)\n \tbreak;\n       if (info->order < last_order\n-\t  && (rhs_code != INTEGER_CST || info->rhs_code != INTEGER_CST))\n+\t  && (!all_integer_cst_p || info->rhs_code != INTEGER_CST))\n \treturn false;\n     }\n   return true;\n@@ -2563,7 +2564,7 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))\n     return false;\n \n-  if (!check_no_overlap (m_store_info, last, LROTATE_EXPR, last_order, end))\n+  if (!check_no_overlap (m_store_info, last, false, last_order, end))\n     return false;\n \n   /* Don't handle memory copy this way if normal non-bswap processing\n@@ -2713,7 +2714,14 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t       |---store 2---|\n \t Overlapping stores.  */\n       else if (IN_RANGE (info->bitpos, merged_store->start,\n-\t\t\t merged_store->start + merged_store->width - 1))\n+\t\t\t merged_store->start + merged_store->width - 1)\n+\t       /* |---store 1---||---store 2---|\n+\t\t  Handle also the consecutive INTEGER_CST stores case here,\n+\t\t  as we have here the code to deal with overlaps.  */\n+\t       || (info->bitregion_start <= merged_store->bitregion_end\n+\t\t   && info->rhs_code == INTEGER_CST\n+\t\t   && merged_store->only_constants\n+\t\t   && merged_store->can_be_merged_into (info)))\n \t{\n \t  /* Only allow overlapping stores of constants.  */\n \t  if (info->rhs_code == INTEGER_CST\n@@ -2725,8 +2733,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      unsigned HOST_WIDE_INT end\n \t\t= MAX (merged_store->start + merged_store->width,\n \t\t       info->bitpos + info->bitsize);\n-\t      if (check_no_overlap (m_store_info, i, INTEGER_CST,\n-\t\t\t\t    last_order, end))\n+\t      if (check_no_overlap (m_store_info, i, true, last_order, end))\n \t\t{\n \t\t  /* check_no_overlap call above made sure there are no\n \t\t     overlapping stores with non-INTEGER_CST rhs_code\n@@ -2879,7 +2886,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      std::swap (info->ops[0], info->ops[1]);\n \t      info->ops_swapped_p = true;\n \t    }\n-\t  if (check_no_overlap (m_store_info, i, info->rhs_code,\n+\t  if (check_no_overlap (m_store_info, i, false,\n \t\t\t\tMAX (merged_store->last_order, info->order),\n \t\t\t\tMAX (merged_store->start + merged_store->width,\n \t\t\t\t     info->bitpos + info->bitsize)))"}, {"sha": "53a2a4ca9762075c208398e782fbaf06fb88c212", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "patch": "@@ -1,5 +1,8 @@\n 2020-02-26  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/93820\n+\t* gcc.dg/pr93820.c: New test.\n+\n \tPR c++/93905\n \t* g++.dg/cpp0x/pr93905.C: New test.\n "}, {"sha": "98d8c20a178f80525a3ca20732cfee89565e7ac9", "filename": "gcc/testsuite/gcc.dg/pr93820.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93820.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93820.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93820.c?ref=4d213bf6011ed2b30b9d0ca70069a5dbc294b5d7", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/93820 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-dse\" } */\n+\n+typedef int v4si __attribute__((vector_size(4 * sizeof (int))));\n+int a[10];\n+\n+__attribute__((noipa)) int\n+foo (int *p)\n+{\n+  a[6] = *p;\n+  a[4] = 1;\n+  *(((v4si *)&a[0]) + 1) = (v4si) { 0, 0, 0, 0 };\n+  a[3] = 0;\n+}\n+\n+int\n+main ()\n+{\n+  int i = 0;\n+  foo (&i);\n+  for (i = 0; i < 10; i++)\n+    if (a[i])\n+      __builtin_abort ();\n+  return 0;\n+}"}]}