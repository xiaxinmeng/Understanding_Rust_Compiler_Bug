{"sha": "1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0NTdhYTQ1ZDQwMmRmN2ZiZjFkYmQ4MThmNmQzOGE0YzQ0N2FhYQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-12-10T20:26:05Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-12-10T20:26:05Z"}, "message": "real.h (HONOR_NANS): Replace macro with 3 overloaded declarations.\n\n2014-12-10  Marc Glisse  <marc.glisse@inria.fr>\n\n\t* real.h (HONOR_NANS): Replace macro with 3 overloaded declarations.\n\t* real.c: Include rtl.h and options.h.\n\t(HONOR_NANS): Define three overloads.\n\t* builtins.c (fold_builtin_classify, fold_builtin_unordered_cmp):\n\tSimplify argument of HONOR_NANS.\n\t* fold-const.c (combine_comparisons, fold_truth_not_expr,\n\tfold_cond_expr_with_comparison, merge_truthop_with_opposite_arm,\n\tfold_comparison, fold_binary_loc): Likewise.\n\t* ifcvt.c (noce_try_move, noce_try_minmax): Likewise.\n\t* ipa-inline-analysis.c (add_clause,\n\tset_cond_stmt_execution_predicate): Likewise.\n\t* match.pd: Likewise.\n\t* rtlanal.c (may_trap_p_1): Likewise.\n\t* simplify-rtx.c (simplify_const_relational_operation): Likewise.\n\t* tree-if-conv.c (parse_predicate): Likewise.\n\t* tree-ssa-ccp.c (valid_lattice_transition): Likewise.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n\t* tree-ssa-phiopt.c (minmax_replacement, neg_replacement): Likewise.\n\t* tree-ssa-reassoc.c (eliminate_using_constants): Likewise.\n\t* tree-ssa-tail-merge.c (gimple_equal_p): Likewise.\n\nFrom-SVN: r218605", "tree": {"sha": "e0456a7b658d50a8d4d9e6f5d4d8aa1587c2f272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0456a7b658d50a8d4d9e6f5d4d8aa1587c2f272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c4967b998b0171712d7a208c6bb68528a5449a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4967b998b0171712d7a208c6bb68528a5449a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4967b998b0171712d7a208c6bb68528a5449a1"}], "stats": {"total": 151, "additions": 96, "deletions": 55}, "files": [{"sha": "5ffca8465f6f56cac9bfea574a6cca47577df96f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -1,3 +1,26 @@\n+2014-12-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* real.h (HONOR_NANS): Replace macro with 3 overloaded declarations.\n+\t* real.c: Include rtl.h and options.h.\n+\t(HONOR_NANS): Define three overloads.\n+\t* builtins.c (fold_builtin_classify, fold_builtin_unordered_cmp):\n+\tSimplify argument of HONOR_NANS.\n+\t* fold-const.c (combine_comparisons, fold_truth_not_expr,\n+\tfold_cond_expr_with_comparison, merge_truthop_with_opposite_arm,\n+\tfold_comparison, fold_binary_loc): Likewise.\n+\t* ifcvt.c (noce_try_move, noce_try_minmax): Likewise.\n+\t* ipa-inline-analysis.c (add_clause,\n+\tset_cond_stmt_execution_predicate): Likewise.\n+\t* match.pd: Likewise.\n+\t* rtlanal.c (may_trap_p_1): Likewise.\n+\t* simplify-rtx.c (simplify_const_relational_operation): Likewise.\n+\t* tree-if-conv.c (parse_predicate): Likewise.\n+\t* tree-ssa-ccp.c (valid_lattice_transition): Likewise.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n+\t* tree-ssa-phiopt.c (minmax_replacement, neg_replacement): Likewise.\n+\t* tree-ssa-reassoc.c (eliminate_using_constants): Likewise.\n+\t* tree-ssa-tail-merge.c (gimple_equal_p): Likewise.\n+\n 2014-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/62021"}, {"sha": "0d3198118c0b0d1ae6161f6f4cc603c53bba60bc", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -9607,7 +9607,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n       }\n \n     case BUILT_IN_ISFINITE:\n-      if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg)))\n+      if (!HONOR_NANS (arg)\n \t  && !HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n \treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n \n@@ -9620,7 +9620,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n       return NULL_TREE;\n \n     case BUILT_IN_ISNAN:\n-      if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg))))\n+      if (!HONOR_NANS (arg))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)\n@@ -9748,13 +9748,12 @@ fold_builtin_unordered_cmp (location_t loc, tree fndecl, tree arg0, tree arg1,\n \n   if (unordered_code == UNORDERED_EXPR)\n     {\n-      if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+      if (!HONOR_NANS (arg0))\n \treturn omit_two_operands_loc (loc, type, integer_zero_node, arg0, arg1);\n       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg0, arg1);\n     }\n \n-  code = HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))) ? unordered_code\n-\t\t\t\t\t\t   : ordered_code;\n+  code = HONOR_NANS (arg0) ? unordered_code : ordered_code;\n   return fold_build1_loc (loc, TRUTH_NOT_EXPR, type,\n \t\t      fold_build2_loc (loc, code, type, arg0, arg1));\n }"}, {"sha": "0d947ae9a996df9b111f500ad21ac354f2626042", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -2592,7 +2592,7 @@ combine_comparisons (location_t loc,\n \t\t     enum tree_code rcode, tree truth_type,\n \t\t     tree ll_arg, tree lr_arg)\n {\n-  bool honor_nans = HONOR_NANS (element_mode (ll_arg));\n+  bool honor_nans = HONOR_NANS (ll_arg);\n   enum comparison_code lcompcode = comparison_to_compcode (lcode);\n   enum comparison_code rcompcode = comparison_to_compcode (rcode);\n   int compcode;\n@@ -3376,7 +3376,7 @@ fold_truth_not_expr (location_t loc, tree arg)\n \t  && code != NE_EXPR && code != EQ_EXPR)\n \treturn NULL_TREE;\n \n-      code = invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (op_type)));\n+      code = invert_tree_comparison (code, HONOR_NANS (op_type));\n       if (code == ERROR_MARK)\n \treturn NULL_TREE;\n \n@@ -4988,7 +4988,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t     operand which will be used if they are equal first\n \t     so that we can convert this back to the\n \t     corresponding COND_EXPR.  */\n-\t  if (!HONOR_NANS (element_mode (arg1)))\n+\t  if (!HONOR_NANS (arg1))\n \t    {\n \t      comp_op0 = fold_convert_loc (loc, comp_type, comp_op0);\n \t      comp_op1 = fold_convert_loc (loc, comp_type, comp_op1);\n@@ -5004,7 +5004,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \tcase GT_EXPR:\n \tcase UNGE_EXPR:\n \tcase UNGT_EXPR:\n-\t  if (!HONOR_NANS (element_mode (arg1)))\n+\t  if (!HONOR_NANS (arg1))\n \t    {\n \t      comp_op0 = fold_convert_loc (loc, comp_type, comp_op0);\n \t      comp_op1 = fold_convert_loc (loc, comp_type, comp_op1);\n@@ -5017,12 +5017,12 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t    }\n \t  break;\n \tcase UNEQ_EXPR:\n-\t  if (!HONOR_NANS (element_mode (arg1)))\n+\t  if (!HONOR_NANS (arg1))\n \t    return pedantic_non_lvalue_loc (loc,\n \t\t\t\t\tfold_convert_loc (loc, type, arg2));\n \t  break;\n \tcase LTGT_EXPR:\n-\t  if (!HONOR_NANS (element_mode (arg1)))\n+\t  if (!HONOR_NANS (arg1))\n \t    return pedantic_non_lvalue_loc (loc,\n \t\t\t\t\tfold_convert_loc (loc, type, arg1));\n \t  break;\n@@ -5317,7 +5317,7 @@ merge_truthop_with_opposite_arm (location_t loc, tree op, tree cmpop,\n \t}\n     }\n \n-  inv_code = invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (type)));\n+  inv_code = invert_tree_comparison (code, HONOR_NANS (type));\n   if (inv_code == rhs_code\n       && operand_equal_p (TREE_OPERAND (rhs, 0), TREE_OPERAND (cmpop, 0), 0)\n       && operand_equal_p (TREE_OPERAND (rhs, 1), TREE_OPERAND (cmpop, 1), 0))\n@@ -9254,22 +9254,22 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \tcase EQ_EXPR:\n \t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (element_mode (arg0)))\n+\t      || ! HONOR_NANS (arg0))\n \t    return constant_boolean_node (1, type);\n \t  break;\n \n \tcase GE_EXPR:\n \tcase LE_EXPR:\n \t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (element_mode (arg0)))\n+\t      || ! HONOR_NANS (arg0))\n \t    return constant_boolean_node (1, type);\n \t  return fold_build2_loc (loc, EQ_EXPR, type, arg0, arg1);\n \n \tcase NE_EXPR:\n \t  /* For NE, we can only do this simplification if integer\n \t     or we don't honor IEEE floating point NaNs.  */\n \t  if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      && HONOR_NANS (element_mode (arg0)))\n+\t      && HONOR_NANS (arg0))\n \t    break;\n \t  /* ... fall through ...  */\n \tcase GT_EXPR:\n@@ -10748,7 +10748,7 @@ fold_binary_loc (location_t loc,\n \t  /* Fold z * +-I to __complex__ (-+__imag z, +-__real z).\n \t     This is not the same for NaNs or if signed zeros are\n \t     involved.  */\n-\t  if (!HONOR_NANS (element_mode (arg0))\n+\t  if (!HONOR_NANS (arg0)\n               && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n \t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t      && TREE_CODE (arg1) == COMPLEX_CST\n@@ -11680,7 +11680,7 @@ fold_binary_loc (location_t loc,\n \t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n \t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n-\t      if (! HONOR_NANS (element_mode (arg00))\n+\t      if (! HONOR_NANS (arg00)\n \t\t  && ! HONOR_INFINITIES (element_mode (arg00))\n \t\t  && operand_equal_p (arg00, arg01, 0))\n \t\t{\n@@ -11700,7 +11700,7 @@ fold_binary_loc (location_t loc,\n \t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n \t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n-\t      if (! HONOR_NANS (element_mode (arg00))\n+\t      if (! HONOR_NANS (arg00)\n \t\t  && ! HONOR_INFINITIES (element_mode (arg00))\n \t\t  && operand_equal_p (arg00, arg01, 0))\n \t\t{\n@@ -12842,7 +12842,7 @@ fold_binary_loc (location_t loc,\n \t    }\n \n \t  /* Convert (X - c) <= X to true.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1)))\n+\t  if (!HONOR_NANS (arg1)\n \t      && code == LE_EXPR\n \t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n@@ -12857,7 +12857,7 @@ fold_binary_loc (location_t loc,\n \t    }\n \n \t  /* Convert (X + c) >= X to true.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1)))\n+\t  if (!HONOR_NANS (arg1)\n \t      && code == GE_EXPR\n \t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n@@ -13064,7 +13064,7 @@ fold_binary_loc (location_t loc,\n       strict_overflow_p = false;\n       if (code == GE_EXPR\n \t  && (integer_zerop (arg1)\n-\t      || (! HONOR_NANS (element_mode (arg0))\n+\t      || (! HONOR_NANS (arg0)\n \t\t  && real_zerop (arg1)))\n \t  && tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p))\n \t{"}, {"sha": "f7a922425823c4d931d9d6c77e3e8643addff7c0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -1062,7 +1062,7 @@ noce_try_move (struct noce_if_info *if_info)\n \n   /* This optimization isn't valid if either A or B could be a NaN\n      or a signed zero.  */\n-  if (HONOR_NANS (GET_MODE (if_info->x))\n+  if (HONOR_NANS (if_info->x)\n       || HONOR_SIGNED_ZEROS (GET_MODE (if_info->x)))\n     return FALSE;\n \n@@ -1955,7 +1955,7 @@ noce_try_minmax (struct noce_if_info *if_info)\n      they will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n      to get the target to tell us...  */\n   if (HONOR_SIGNED_ZEROS (GET_MODE (if_info->x))\n-      || HONOR_NANS (GET_MODE (if_info->x)))\n+      || HONOR_NANS (if_info->x))\n     return FALSE;\n \n   cond = noce_get_alt_condition (if_info, if_info->a, &earliest);"}, {"sha": "fb4e81ebba44bd701ff99fdca55f4a8b10151851", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -379,9 +379,8 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n \t\t&& cc1->val == cc2->val\n \t\t&& cc2->code != IS_NOT_CONSTANT\n \t\t&& cc2->code != CHANGED\n-\t\t&& cc1->code == invert_tree_comparison\n-\t\t\t\t(cc2->code,\n-\t\t\t\t HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n+\t\t&& cc1->code == invert_tree_comparison (cc2->code,\n+\t\t\t\t\t\t\tHONOR_NANS (cc1->val)))\n \t      return;\n \t  }\n     }\n@@ -1762,9 +1761,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   if (unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n     {\n       code = gimple_cond_code (last);\n-      inverted_code\n-\t= invert_tree_comparison (code,\n-\t\t\t\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+      inverted_code = invert_tree_comparison (code, HONOR_NANS (op));\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{"}, {"sha": "4ccb41a2366e1341d8cd95bd67578e921f50c1fb", "filename": "gcc/match.pd", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -73,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n    is volatile.  */\n (simplify\n  (minus @0 @0)\n- (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (element_mode (type)))\n+ (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (type))\n   { build_zero_cst (type); }))\n \n (simplify\n@@ -86,8 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n    negative value by 0 gives -0, not +0.  */\n (simplify\n  (mult @0 real_zerop@1)\n- (if (!HONOR_NANS (element_mode (type))\n-      && !HONOR_SIGNED_ZEROS (element_mode (type)))\n+ (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (element_mode (type)))\n   @1))\n \n /* In IEEE floating point, x*1 is not equivalent to x for snans.\n@@ -150,7 +149,7 @@ along with GCC; see the file COPYING3.  If not see\n (simplify\n  (rdiv @0 @0)\n  (if (FLOAT_TYPE_P (type)\n-      && ! HONOR_NANS (element_mode (type))\n+      && ! HONOR_NANS (type)\n       && ! HONOR_INFINITIES (element_mode (type)))\n   { build_one_cst (type); }))\n \n@@ -159,7 +158,7 @@ along with GCC; see the file COPYING3.  If not see\n (simplify\n  (rdiv:c @0 (negate @0))\n  (if (FLOAT_TYPE_P (type)\n-      && ! HONOR_NANS (element_mode (type))\n+      && ! HONOR_NANS (type)\n       && ! HONOR_INFINITIES (element_mode (type)))\n   { build_minus_one_cst (type); }))\n \n@@ -905,15 +904,15 @@ along with GCC; see the file COPYING3.  If not see\n       a computed operator in the replacement tree thus we have\n       to play the trick below.  */\n    (with { enum tree_code ic = invert_tree_comparison\n-             (cmp, HONOR_NANS (element_mode (@0))); }\n+             (cmp, HONOR_NANS (@0)); }\n     (if (ic == icmp)\n      (icmp @0 @1))\n     (if (ic == ncmp)\n      (ncmp @0 @1)))))\n  (simplify\n   (bit_xor (cmp @0 @1) integer_truep)\n   (with { enum tree_code ic = invert_tree_comparison\n-            (cmp, HONOR_NANS (element_mode (@0))); }\n+            (cmp, HONOR_NANS (@0)); }\n    (if (ic == icmp)\n     (icmp @0 @1))\n    (if (ic == ncmp)"}, {"sha": "9ba847a6869468fb4ff37d5b350dd0cc79d9e943", "filename": "gcc/real.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -30,6 +30,8 @@\n #include \"tm_p.h\"\n #include \"dfp.h\"\n #include \"wide-int.h\"\n+#include \"rtl.h\"\n+#include \"options.h\"\n \n /* The floating point model used internally is not exactly IEEE 754\n    compliant, and close to the description in the ISO C99 standard,\n@@ -4982,3 +4984,25 @@ get_max_float (const struct real_format *fmt, char *buf, size_t len)\n \n   gcc_assert (strlen (buf) < len);\n }\n+\n+/* True if mode M has a NaN representation and\n+   the treatment of NaN operands is important.  */\n+\n+bool\n+HONOR_NANS (machine_mode m)\n+{\n+  return MODE_HAS_NANS (m) && !flag_finite_math_only;\n+}\n+\n+bool\n+HONOR_NANS (const_tree t)\n+{\n+  return HONOR_NANS (element_mode (t));\n+}\n+\n+bool\n+HONOR_NANS (const_rtx x)\n+{\n+    return HONOR_NANS (GET_MODE (x));\n+}\n+"}, {"sha": "bfdd1e619e0534cdfb8da8a02fe313af6774e2f7", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -200,8 +200,9 @@ extern const struct real_format *\n    x * 0 into 0, are not correct for NaN operands, and are normally\n    disabled for modes with NaNs.  The user can ask for them to be\n    done anyway using the -funsafe-math-optimizations switch.  */\n-#define HONOR_NANS(MODE) \\\n-  (MODE_HAS_NANS (MODE) && !flag_finite_math_only)\n+extern bool HONOR_NANS (machine_mode);\n+extern bool HONOR_NANS (const_tree);\n+extern bool HONOR_NANS (const_rtx);\n \n /* Like HONOR_NANs, but true if we honor signaling NaNs (or sNaNs).  */\n #define HONOR_SNANS(MODE) (flag_signaling_nans && HONOR_NANS (MODE))"}, {"sha": "e04dea8574102c5b6c5dee0b1e2c73b0a8dafba0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -2552,12 +2552,12 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \t when COMPARE is used, though many targets do make this distinction.\n \t For instance, sparc uses CCFPE for compares which generate exceptions\n \t and CCFP for compares which do not generate exceptions.  */\n-      if (HONOR_NANS (GET_MODE (x)))\n+      if (HONOR_NANS (x))\n \treturn 1;\n       /* But often the compare has some CC mode, so check operand\n \t modes as well.  */\n-      if (HONOR_NANS (GET_MODE (XEXP (x, 0)))\n-\t  || HONOR_NANS (GET_MODE (XEXP (x, 1))))\n+      if (HONOR_NANS (XEXP (x, 0))\n+\t  || HONOR_NANS (XEXP (x, 1)))\n \treturn 1;\n       break;\n \n@@ -2573,7 +2573,7 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \n     case FIX:\n       /* Conversion of floating point might trap.  */\n-      if (flag_trapping_math && HONOR_NANS (GET_MODE (XEXP (x, 0))))\n+      if (flag_trapping_math && HONOR_NANS (XEXP (x, 0)))\n \treturn 1;\n       break;\n "}, {"sha": "5afbc023d923ddfcba8529970495dc1bd4dbfb90", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -4754,7 +4754,7 @@ simplify_const_relational_operation (enum rtx_code code,\n      result except if they have side-effects.  Even with NaNs we know\n      the result of unordered comparisons and, if signaling NaNs are\n      irrelevant, also the result of LT/GT/LTGT.  */\n-  if ((! HONOR_NANS (GET_MODE (trueop0))\n+  if ((! HONOR_NANS (trueop0)\n        || code == UNEQ || code == UNLE || code == UNGE\n        || ((code == LT || code == GT || code == LTGT)\n \t   && ! HONOR_SNANS (GET_MODE (trueop0))))"}, {"sha": "2ec7774d52db40801d681e842a243b1f7474ef10", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -311,7 +311,7 @@ parse_predicate (tree cond, tree *op0, tree *op1)\n \t  enum tree_code code = parse_predicate (op, op0, op1);\n \n \t  return code == ERROR_MARK ? ERROR_MARK\n-\t    : invert_tree_comparison (code, HONOR_NANS (TYPE_MODE (type)));\n+\t    : invert_tree_comparison (code, HONOR_NANS (type));\n \t}\n \n       return ERROR_MARK;"}, {"sha": "65a5b78d08e2e9dc7fd4add7dc15f251999b5ea6", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -458,13 +458,13 @@ valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n      to non-NaN.  */\n   tree type = TREE_TYPE (new_val.value);\n   if (SCALAR_FLOAT_TYPE_P (type)\n-      && !HONOR_NANS (TYPE_MODE (type)))\n+      && !HONOR_NANS (type))\n     {\n       if (REAL_VALUE_ISNAN (TREE_REAL_CST (old_val.value)))\n \treturn true;\n     }\n   else if (VECTOR_FLOAT_TYPE_P (type)\n-\t   && !HONOR_NANS (TYPE_MODE (TREE_TYPE (type))))\n+\t   && !HONOR_NANS (type))\n     {\n       for (unsigned i = 0; i < VECTOR_CST_NELTS (old_val.value); ++i)\n \tif (!REAL_VALUE_ISNAN\n@@ -475,7 +475,7 @@ valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n       return true;\n     }\n   else if (COMPLEX_FLOAT_TYPE_P (type)\n-\t   && !HONOR_NANS (TYPE_MODE (TREE_TYPE (type))))\n+\t   && !HONOR_NANS (type))\n     {\n       if (!REAL_VALUE_ISNAN (TREE_REAL_CST (TREE_REALPART (old_val.value)))\n \t  && !operand_equal_p (TREE_REALPART (old_val.value),"}, {"sha": "72b834b13d7ba9548c41bc066c02e0fee6e408a5", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -519,12 +519,12 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n       /* Invert comparisons if necessary (and possible).  */\n       if (inner_inv)\n \tinner_cond_code = invert_tree_comparison (inner_cond_code,\n-\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (inner_cond)))));\n+\t  HONOR_NANS (gimple_cond_lhs (inner_cond)));\n       if (inner_cond_code == ERROR_MARK)\n \treturn false;\n       if (outer_inv)\n \touter_cond_code = invert_tree_comparison (outer_cond_code,\n-\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (outer_cond)))));\n+\t  HONOR_NANS (gimple_cond_lhs (outer_cond)));\n       if (outer_cond_code == ERROR_MARK)\n \treturn false;\n       /* Don't return false so fast, try maybe_fold_or_comparisons?  */"}, {"sha": "b4febee06eca2b229fedaddb5af5e5d4ef276063", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -932,7 +932,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n   type = TREE_TYPE (PHI_RESULT (phi));\n \n   /* The optimization may be unsafe due to NaNs.  */\n-  if (HONOR_NANS (TYPE_MODE (type)))\n+  if (HONOR_NANS (type))\n     return false;\n \n   cond = as_a <gcond *> (last_stmt (cond_bb));\n@@ -1355,8 +1355,7 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n      that's cheapest.  */\n   if (invert)\n     {\n-      bool honor_nans\n-\t= HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (cond))));\n+      bool honor_nans = HONOR_NANS (gimple_cond_lhs (cond));\n       enum tree_code new_code = invert_tree_comparison (cond_code, honor_nans);\n \n       /* If invert_tree_comparison was successful, then use its return"}, {"sha": "81502925cbd1d41abda47d441fb8223058ea13a3", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -966,7 +966,7 @@ eliminate_using_constants (enum tree_code opcode,\n \tcase MULT_EXPR:\n \t  if (integer_zerop (oelast->op)\n \t      || (FLOAT_TYPE_P (type)\n-\t\t  && !HONOR_NANS (TYPE_MODE (type))\n+\t\t  && !HONOR_NANS (type)\n \t\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n \t\t  && real_zerop (oelast->op)))\n \t    {"}, {"sha": "6299796e191b30c263672e1bd204985df9d18f44", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b457aa45d402df7fbf1dbd818f6d38a4c447aaa/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=1b457aa45d402df7fbf1dbd818f6d38a4c447aaa", "patch": "@@ -1197,8 +1197,7 @@ gimple_equal_p (same_succ same_succ, gimple s1, gimple s2)\n \t\t  != bitmap_bit_p (same_succ->inverse, bb2->index));\n       if (inv_cond)\n \t{\n-\t  bool honor_nans\n-\t    = HONOR_NANS (TYPE_MODE (TREE_TYPE (gimple_cond_lhs (s1))));\n+\t  bool honor_nans = HONOR_NANS (t1);\n \t  code2 = invert_tree_comparison (code2, honor_nans);\n \t}\n       return code1 == code2;"}]}