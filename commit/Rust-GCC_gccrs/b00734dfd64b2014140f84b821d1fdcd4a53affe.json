{"sha": "b00734dfd64b2014140f84b821d1fdcd4a53affe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAwNzM0ZGZkNjRiMjAxNDE0MGY4NGI4MjFkMWZkY2Q0YTUzYWZmZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-20T08:40:52Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-20T08:40:52Z"}, "message": "re PR tree-optimization/63677 (Failure to constant fold with vectorization.)\n\n2014-11-20   Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63677\n\t* tree-ssa-dom.c: Include gimplify.h for unshare_expr.\n\t(avail_exprs_stack): Make a vector of pairs.\n\t(struct hash_expr_elt): Replace stmt member with vop member.\n\t(expr_elt_hasher::equal): Simplify.\n\t(initialize_hash_element): Adjust.\n\t(initialize_hash_element_from_expr): Likewise.\n\t(dom_opt_dom_walker::thread_across_edge): Likewise.\n\t(record_cond): Likewise.\n\t(dom_opt_dom_walker::before_dom_children): Likewise.\n\t(print_expr_hash_elt): Likewise.\n\t(remove_local_expressions_from_table): Restore previous state\n\tif requested.\n\t(record_equivalences_from_stmt): Record &x + CST as constant\n\t&MEM[&x, CST] for further propagation.\n\t(vuse_eq): New function.\n\t(lookup_avail_expr): For loads use the alias oracle to see\n\twhether a candidate from the expr hash is usable.\n\t(avail_expr_hash): Do not hash VUSEs.\n\n\t* gcc.dg/tree-ssa/ssa-dom-cse-2.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-dom-cse-3.c: Likewise.\n\nFrom-SVN: r217827", "tree": {"sha": "5d4a056252b3e804e9604d0f82ccc69c816b9ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d4a056252b3e804e9604d0f82ccc69c816b9ff2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b00734dfd64b2014140f84b821d1fdcd4a53affe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00734dfd64b2014140f84b821d1fdcd4a53affe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00734dfd64b2014140f84b821d1fdcd4a53affe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00734dfd64b2014140f84b821d1fdcd4a53affe/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07dc4e8707bd1e631b42a7375e368505d107cc9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07dc4e8707bd1e631b42a7375e368505d107cc9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07dc4e8707bd1e631b42a7375e368505d107cc9d"}], "stats": {"total": 260, "additions": 203, "deletions": 57}, "files": [{"sha": "56668b06272e3809be664ad1697d6bfb8a43efdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b00734dfd64b2014140f84b821d1fdcd4a53affe", "patch": "@@ -1,3 +1,25 @@\n+2014-11-20   Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63677\n+\t* tree-ssa-dom.c: Include gimplify.h for unshare_expr.\n+\t(avail_exprs_stack): Make a vector of pairs.\n+\t(struct hash_expr_elt): Replace stmt member with vop member.\n+\t(expr_elt_hasher::equal): Simplify.\n+\t(initialize_hash_element): Adjust.\n+\t(initialize_hash_element_from_expr): Likewise.\n+\t(dom_opt_dom_walker::thread_across_edge): Likewise.\n+\t(record_cond): Likewise.\n+\t(dom_opt_dom_walker::before_dom_children): Likewise.\n+\t(print_expr_hash_elt): Likewise.\n+\t(remove_local_expressions_from_table): Restore previous state\n+\tif requested.\n+\t(record_equivalences_from_stmt): Record &x + CST as constant\n+\t&MEM[&x, CST] for further propagation.\n+\t(vuse_eq): New function.\n+\t(lookup_avail_expr): For loads use the alias oracle to see\n+\twhether a candidate from the expr hash is usable.\n+\t(avail_expr_hash): Do not hash VUSEs.\n+\n 2014-11-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/59593"}, {"sha": "2e637f0c81a6bf7bccb7f713175e1467e668abe2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b00734dfd64b2014140f84b821d1fdcd4a53affe", "patch": "@@ -1,3 +1,9 @@\n+2014-11-20   Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63677\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-2.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-dom-cse-3.c: Likewise.\n+\n 2014-11-20  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR sanitizer/63845"}, {"sha": "2a1a40843124965164a52f44e9e126c0b95a6764", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-2.c?ref=b00734dfd64b2014140f84b821d1fdcd4a53affe", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-tree-fre -fno-tree-pre -fdump-tree-optimized\" } */\n+\n+int\n+foo ()\n+{\n+  const int a[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  int i, sum;\n+\n+  sum = 0;\n+  for (i = 0; i < sizeof (a) / sizeof (*a); i++)\n+    sum += a[i];\n+\n+  return sum;\n+}\n+\n+/* After late unrolling the above loop completely DOM should be\n+   able to optimize this to return 28.  */\n+\n+/* { dg-final { scan-tree-dump \"return 28;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a93eb3c2613ea9106ee3f9ea764f0f24f794e170", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-3.c?ref=b00734dfd64b2014140f84b821d1fdcd4a53affe", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fno-tree-fre -fdump-tree-dom1\" } */\n+\n+extern void abort (void);\n+\n+int a;\n+int __attribute__((noinline))\n+foo (int b)\n+{\n+  a = 0;\n+  if (b)\n+    {\n+      a = 1;\n+      return a;\n+    }\n+  /* DOM should be able to CSE both loads here, forwarding 0 and 1\n+     to the PHI feeding the return.  */\n+  return a;\n+}\n+\n+int\n+main()\n+{\n+  if (foo (0) != 0\n+      || foo (1) != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"= PHI <\\[01\\]\\\\\\(.\\\\\\), \\[01\\]\\\\\\(.\\\\\\)>\" \"dom1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */"}, {"sha": "60be376e740b38754e9a89e5b7a86393ba3a6a51", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 123, "deletions": 57, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00734dfd64b2014140f84b821d1fdcd4a53affe/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b00734dfd64b2014140f84b821d1fdcd4a53affe", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-dom.h\"\n #include \"inchash.h\"\n+#include \"gimplify.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -139,7 +140,7 @@ struct edge_info\n    marker.  */\n typedef struct expr_hash_elt * expr_hash_elt_t;\n \n-static vec<expr_hash_elt_t> avail_exprs_stack;\n+static vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > avail_exprs_stack;\n \n /* Structure for entries in the expression hash table.  */\n \n@@ -151,8 +152,9 @@ struct expr_hash_elt\n   /* The expression (rhs) we want to record.  */\n   struct hashable_expr expr;\n \n-  /* The stmt pointer if this element corresponds to a statement.  */\n-  gimple stmt;\n+  /* The virtual operand associated with the nearest dominating stmt\n+     loading from or storing to expr.  */\n+  tree vop;\n \n   /* The hash value for RHS.  */\n   hashval_t hash;\n@@ -187,36 +189,23 @@ expr_elt_hasher::hash (const value_type &p)\n inline bool\n expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n-  gimple stmt1 = p1->stmt;\n   const struct hashable_expr *expr1 = &p1->expr;\n   const struct expr_hash_elt *stamp1 = p1->stamp;\n-  gimple stmt2 = p2->stmt;\n   const struct hashable_expr *expr2 = &p2->expr;\n   const struct expr_hash_elt *stamp2 = p2->stamp;\n \n   /* This case should apply only when removing entries from the table.  */\n   if (stamp1 == stamp2)\n     return true;\n \n-  /* FIXME tuples:\n-     We add stmts to a hash table and them modify them. To detect the case\n-     that we modify a stmt and then search for it, we assume that the hash\n-     is always modified by that change.\n-     We have to fully check why this doesn't happen on trunk or rewrite\n-     this in a more  reliable (and easier to understand) way. */\n-  if (((const struct expr_hash_elt *)p1)->hash\n-      != ((const struct expr_hash_elt *)p2)->hash)\n+  if (p1->hash != p2->hash)\n     return false;\n \n   /* In case of a collision, both RHS have to be identical and have the\n      same VUSE operands.  */\n   if (hashable_expr_equal_p (expr1, expr2)\n       && types_compatible_p (expr1->type, expr2->type))\n-    {\n-      /* Note that STMT1 and/or STMT2 may be NULL.  */\n-      return ((stmt1 ? gimple_vuse (stmt1) : NULL_TREE)\n-\t      == (stmt2 ? gimple_vuse (stmt2) : NULL_TREE));\n-    }\n+    return true;\n \n   return false;\n }\n@@ -387,7 +376,7 @@ initialize_hash_element (gimple stmt, tree lhs,\n     gcc_unreachable ();\n \n   element->lhs = lhs;\n-  element->stmt = stmt;\n+  element->vop = gimple_vuse (stmt);\n   element->hash = avail_expr_hash (element);\n   element->stamp = element;\n }\n@@ -429,7 +418,7 @@ initialize_hash_element_from_expr (struct hashable_expr *expr,\n {\n   element->expr = *expr;\n   element->lhs = lhs;\n-  element->stmt = NULL;\n+  element->vop = NULL_TREE;\n   element->hash = avail_expr_hash (element);\n   element->stamp = element;\n }\n@@ -681,10 +670,7 @@ add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n static void\n print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n {\n-  if (element->stmt)\n-    fprintf (stream, \"STMT \");\n-  else\n-    fprintf (stream, \"COND \");\n+  fprintf (stream, \"STMT \");\n \n   if (element->lhs)\n     {\n@@ -758,13 +744,14 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n         }\n         break;\n     }\n-  fprintf (stream, \"\\n\");\n \n-  if (element->stmt)\n+  if (element->vop)\n     {\n-      fprintf (stream, \"          \");\n-      print_gimple_stmt (stream, element->stmt, 0, 0);\n+      fprintf (stream, \" with \");\n+      print_generic_expr (stream, element->vop, 0);\n     }\n+\n+  fprintf (stream, \"\\n\");\n }\n \n /* Delete variable sized pieces of the expr_hash_elt ELEMENT.  */\n@@ -1067,10 +1054,11 @@ remove_local_expressions_from_table (void)\n   /* Remove all the expressions made available in this block.  */\n   while (avail_exprs_stack.length () > 0)\n     {\n-      expr_hash_elt_t victim = avail_exprs_stack.pop ();\n+      std::pair<expr_hash_elt_t, expr_hash_elt_t> victim\n+\t= avail_exprs_stack.pop ();\n       expr_hash_elt **slot;\n \n-      if (victim == NULL)\n+      if (victim.first == NULL)\n \tbreak;\n \n       /* This must precede the actual removal from the hash table,\n@@ -1079,12 +1067,18 @@ remove_local_expressions_from_table (void)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n         {\n           fprintf (dump_file, \"<<<< \");\n-          print_expr_hash_elt (dump_file, victim);\n+          print_expr_hash_elt (dump_file, victim.first);\n         }\n \n-      slot = avail_exprs->find_slot (victim, NO_INSERT);\n-      gcc_assert (slot && *slot == victim);\n-      avail_exprs->clear_slot (slot);\n+      slot = avail_exprs->find_slot (victim.first, NO_INSERT);\n+      gcc_assert (slot && *slot == victim.first);\n+      if (victim.second != NULL)\n+\t{\n+\t  free_expr_hash_elt (*slot);\n+\t  *slot = victim.second;\n+\t}\n+      else\n+\tavail_exprs->clear_slot (slot);\n     }\n }\n \n@@ -1171,7 +1165,8 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n \n   /* Push a marker on both stacks so we can unwind the tables back to their\n      current state.  */\n-  avail_exprs_stack.safe_push (NULL);\n+  avail_exprs_stack.safe_push\n+    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n   const_and_copies_stack.safe_push (NULL_TREE);\n \n   /* Traversing E may result in equivalences we can utilize.  */\n@@ -1412,7 +1407,8 @@ record_cond (cond_equivalence *p)\n           print_expr_hash_elt (dump_file, element);\n         }\n \n-      avail_exprs_stack.safe_push (element);\n+      avail_exprs_stack.safe_push\n+\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element, NULL));\n     }\n   else\n     free_expr_hash_elt (element);\n@@ -1972,7 +1968,8 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n-  avail_exprs_stack.safe_push (NULL);\n+  avail_exprs_stack.safe_push\n+    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n   const_and_copies_stack.safe_push (NULL_TREE);\n \n   record_equivalences_from_incoming_edge (bb);\n@@ -1983,7 +1980,8 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   /* Create equivalences from redundant PHIs.  PHIs are only truly\n      redundant when they exist in the same block, so push another\n      marker and unwind right afterwards.  */\n-  avail_exprs_stack.safe_push (NULL);\n+  avail_exprs_stack.safe_push\n+    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     eliminate_redundant_computations (&gsi);\n   remove_local_expressions_from_table ();\n@@ -2193,6 +2191,32 @@ record_equivalences_from_stmt (gimple stmt, int may_optimize_p)\n       }\n     }\n \n+  /* Make sure we can propagate &x + CST.  */\n+  if (lhs_code == SSA_NAME\n+      && gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n+      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR\n+      && TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST)\n+    {\n+      tree op0 = gimple_assign_rhs1 (stmt);\n+      tree op1 = gimple_assign_rhs2 (stmt);\n+      tree new_rhs\n+\t= build_fold_addr_expr (fold_build2 (MEM_REF,\n+\t\t\t\t\t     TREE_TYPE (TREE_TYPE (op0)),\n+\t\t\t\t\t     unshare_expr (op0),\n+\t\t\t\t\t     fold_convert (ptr_type_node,\n+\t\t\t\t\t\t\t   op1)));\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"==== ASGN \");\n+\t  print_generic_expr (dump_file, lhs, 0);\n+\t  fprintf (dump_file, \" = \");\n+\t  print_generic_expr (dump_file, new_rhs, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      set_ssa_name_value (lhs, new_rhs);\n+    }\n+\n   /* A memory store, even an aliased store, creates a useful\n      equivalence.  By exchanging the LHS and RHS, creating suitable\n      vops and recording the result in the available expression table,\n@@ -2512,6 +2536,26 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n     }\n }\n \n+/* Helper for walk_non_aliased_vuses.  Determine if we arrived at\n+   the desired memory state.  */\n+\n+static void *\n+vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n+{\n+  tree vuse2 = (tree) data;\n+  if (vuse1 == vuse2)\n+    return data;\n+\n+  /* This bounds the stmt walks we perform on reference lookups\n+     to O(1) instead of O(N) where N is the number of dominating\n+     stores leading to a candidate.  We re-use the SCCVN param\n+     for this as it is basically the same complexity.  */\n+  if (cnt > (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))\n+    return (void *)-1;\n+\n+  return NULL;\n+}\n+\n /* Search for an existing instance of STMT in the AVAIL_EXPRS table.\n    If found, return its LHS. Otherwise insert STMT in the table and\n    return NULL_TREE.\n@@ -2570,15 +2614,52 @@ lookup_avail_expr (gimple stmt, bool insert)\n           print_expr_hash_elt (dump_file, element2);\n         }\n \n-      avail_exprs_stack.safe_push (element2);\n+      avail_exprs_stack.safe_push\n+\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element2, NULL));\n       return NULL_TREE;\n     }\n-  else\n-    free_expr_hash_elt_contents (&element);\n+\n+  /* If we found a redundant memory operation do an alias walk to\n+     check if we can re-use it.  */\n+  if (gimple_vuse (stmt) != (*slot)->vop)\n+    {\n+      tree vuse1 = (*slot)->vop;\n+      tree vuse2 = gimple_vuse (stmt);\n+      /* If we have a load of a register and a candidate in the\n+\t hash with vuse1 then try to reach its stmt by walking\n+\t up the virtual use-def chain using walk_non_aliased_vuses.\n+\t But don't do this when removing expressions from the hash.  */\n+      ao_ref ref;\n+      if (!(vuse1 && vuse2\n+\t    && gimple_assign_single_p (stmt)\n+\t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)), true)\n+\t    && walk_non_aliased_vuses (&ref, vuse2,\n+\t\t\t\t       vuse_eq, NULL, vuse1) != NULL))\n+\t{\n+\t  struct expr_hash_elt *element2 = XNEW (struct expr_hash_elt);\n+\t  *element2 = element;\n+\t  element2->stamp = element2;\n+\n+\t  /* Insert the expr into the hash by replacing the current\n+\t     entry and recording the value to restore in the\n+\t     aval_exprs_stack.  */\n+\t  avail_exprs_stack.safe_push (std::make_pair (element2, *slot));\n+\t  *slot = element2;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"2>>> \");\n+\t      print_expr_hash_elt (dump_file, *slot);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  free_expr_hash_elt_contents (&element);\n \n   /* Extract the LHS of the assignment so that it can be used as the current\n      definition of another variable.  */\n-  lhs = ((struct expr_hash_elt *)*slot)->lhs;\n+  lhs = (*slot)->lhs;\n \n   /* See if the LHS appears in the CONST_AND_COPIES table.  If it does, then\n      use the value from the const_and_copies table.  */\n@@ -2606,26 +2687,11 @@ lookup_avail_expr (gimple stmt, bool insert)\n static hashval_t\n avail_expr_hash (const void *p)\n {\n-  gimple stmt = ((const struct expr_hash_elt *)p)->stmt;\n   const struct hashable_expr *expr = &((const struct expr_hash_elt *)p)->expr;\n-  tree vuse;\n   inchash::hash hstate;\n \n   inchash::add_hashable_expr (expr, hstate);\n \n-  /* If the hash table entry is not associated with a statement, then we\n-     can just hash the expression and not worry about virtual operands\n-     and such.  */\n-  if (!stmt)\n-    return hstate.end ();\n-\n-  /* Add the SSA version numbers of the vuse operand.  This is important\n-     because compound variables like arrays are not renamed in the\n-     operands.  Rather, the rename is done on the virtual variable\n-     representing all the elements of the array.  */\n-  if ((vuse = gimple_vuse (stmt)))\n-    inchash::add_expr (vuse, hstate);\n-\n   return hstate.end ();\n }\n "}]}