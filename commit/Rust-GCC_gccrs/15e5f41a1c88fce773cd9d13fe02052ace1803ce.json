{"sha": "15e5f41a1c88fce773cd9d13fe02052ace1803ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlNWY0MWExYzg4ZmNlNzczY2Q5ZDEzZmUwMjA1MmFjZTE4MDNjZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-10T10:05:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-10T11:10:09Z"}, "message": "More PRE TLC\n\nThis makes get_expr_value_id cheap and completes the\nconstant value-id simplification by turning the constant_value_expressions\ninto a direct map instead of a set of pre_exprs for the value.\n\n2020-11-10  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (pre_expr_d::value_id): Add.\n\t(constant_value_expressions): Turn into an array of pre_expr.\n\t(get_or_alloc_expr_for_nary): New function.\n\t(get_or_alloc_expr_for_reference): Likewise.\n\t(add_to_value): For constant values only ever add a single\n\tCONSTANT.\n\t(get_expr_value_id): Return the new value_id member.\n\t(vn_valnum_from_value_id): Split out and simplify constant\n\tvalue id handling.\n\t(get_or_alloc_expr_for_constant): Set the value_id member.\n\t(phi_translate_1): Use get_or_alloc_expr_for_*.\n\t(compute_avail): Likewise.\n\t(bitmap_find_leader): Simplify constant value id handling.", "tree": {"sha": "e104c348b0375b059b57dc4ac488cba4b3d65602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e104c348b0375b059b57dc4ac488cba4b3d65602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e5f41a1c88fce773cd9d13fe02052ace1803ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e5f41a1c88fce773cd9d13fe02052ace1803ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e5f41a1c88fce773cd9d13fe02052ace1803ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e5f41a1c88fce773cd9d13fe02052ace1803ce/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9693749b963030b7e82f94829b8bc4a61802dd85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9693749b963030b7e82f94829b8bc4a61802dd85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9693749b963030b7e82f94829b8bc4a61802dd85"}], "stats": {"total": 183, "additions": 89, "deletions": 94}, "files": [{"sha": "160f3b4593a4253bf2a671564d761966dea57a7d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 89, "deletions": 94, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5f41a1c88fce773cd9d13fe02052ace1803ce/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5f41a1c88fce773cd9d13fe02052ace1803ce/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=15e5f41a1c88fce773cd9d13fe02052ace1803ce", "patch": "@@ -256,6 +256,7 @@ typedef struct pre_expr_d : nofree_ptr_hash <pre_expr_d>\n {\n   enum pre_expr_kind kind;\n   unsigned int id;\n+  unsigned value_id;\n   location_t loc;\n   pre_expr_union u;\n \n@@ -422,11 +423,65 @@ get_or_alloc_expr_for_name (tree name)\n   result = pre_expr_pool.allocate ();\n   result->kind = NAME;\n   result->loc = UNKNOWN_LOCATION;\n+  result->value_id = VN_INFO (name)->value_id;\n   PRE_EXPR_NAME (result) = name;\n   alloc_expression_id (result);\n   return result;\n }\n \n+/* Given an NARY, get or create a pre_expr to represent it.  */\n+\n+static pre_expr\n+get_or_alloc_expr_for_nary (vn_nary_op_t nary,\n+\t\t\t    location_t loc = UNKNOWN_LOCATION)\n+{\n+  struct pre_expr_d expr;\n+  pre_expr result;\n+  unsigned int result_id;\n+\n+  expr.kind = NARY;\n+  expr.id = 0;\n+  PRE_EXPR_NARY (&expr) = nary;\n+  result_id = lookup_expression_id (&expr);\n+  if (result_id != 0)\n+    return expression_for_id (result_id);\n+\n+  result = pre_expr_pool.allocate ();\n+  result->kind = NARY;\n+  result->loc = loc;\n+  result->value_id = nary->value_id;\n+  PRE_EXPR_NARY (result) = nary;\n+  alloc_expression_id (result);\n+  return result;\n+}\n+\n+/* Given an REFERENCE, get or create a pre_expr to represent it.  */\n+\n+static pre_expr\n+get_or_alloc_expr_for_reference (vn_reference_t reference,\n+\t\t\t\t location_t loc = UNKNOWN_LOCATION)\n+{\n+  struct pre_expr_d expr;\n+  pre_expr result;\n+  unsigned int result_id;\n+\n+  expr.kind = REFERENCE;\n+  expr.id = 0;\n+  PRE_EXPR_REFERENCE (&expr) = reference;\n+  result_id = lookup_expression_id (&expr);\n+  if (result_id != 0)\n+    return expression_for_id (result_id);\n+\n+  result = pre_expr_pool.allocate ();\n+  result->kind = REFERENCE;\n+  result->loc = loc;\n+  result->value_id = reference->value_id;\n+  PRE_EXPR_REFERENCE (result) = reference;\n+  alloc_expression_id (result);\n+  return result;\n+}\n+\n+\n /* An unordered bitmap set.  One bitmap tracks values, the other,\n    expressions.  */\n typedef class bitmap_set\n@@ -444,9 +499,9 @@ typedef class bitmap_set\n \n /* Mapping from value id to expressions with that value_id.  */\n static vec<bitmap> value_expressions;\n-/* ???  We want to just record a single expression for each constant\n-   value, one of kind CONSTANT.  */\n-static vec<bitmap> constant_value_expressions;\n+/* We just record a single expression for each constant value,\n+   one of kind CONSTANT.  */\n+static vec<pre_expr> constant_value_expressions;\n \n \n /* This structure is used to keep track of statistics on what\n@@ -640,35 +695,33 @@ phi_trans_add (expr_pred_trans_t *entry, pre_expr e, basic_block pred)\n static void\n add_to_value (unsigned int v, pre_expr e)\n {\n-  bitmap set;\n-\n   gcc_checking_assert (get_expr_value_id (e) == v);\n \n   if (value_id_constant_p (v))\n     {\n+      if (e->kind != CONSTANT)\n+\treturn;\n+\n       if (-v >= constant_value_expressions.length ())\n \tconstant_value_expressions.safe_grow_cleared (-v + 1);\n \n-      set = constant_value_expressions[-v];\n-      if (!set)\n-\t{\n-\t  set = BITMAP_ALLOC (&grand_bitmap_obstack);\n-\t  constant_value_expressions[-v] = set;\n-\t}\n+      pre_expr leader = constant_value_expressions[-v];\n+      if (!leader)\n+\tconstant_value_expressions[-v] = e;\n     }\n   else\n     {\n       if (v >= value_expressions.length ())\n \tvalue_expressions.safe_grow_cleared (v + 1);\n \n-      set = value_expressions[v];\n+      bitmap set = value_expressions[v];\n       if (!set)\n \t{\n \t  set = BITMAP_ALLOC (&grand_bitmap_obstack);\n \t  value_expressions[v] = set;\n \t}\n+      bitmap_set_bit (set, get_or_alloc_expression_id (e));\n     }\n-  bitmap_set_bit (set, get_or_alloc_expression_id (e));\n }\n \n /* Create a new bitmap set and return it.  */\n@@ -687,50 +740,33 @@ bitmap_set_new (void)\n static unsigned int\n get_expr_value_id (pre_expr expr)\n {\n-  unsigned int id;\n-  switch (expr->kind)\n-    {\n-    case CONSTANT:\n-      id = get_constant_value_id (PRE_EXPR_CONSTANT (expr));\n-      break;\n-    case NAME:\n-      id = VN_INFO (PRE_EXPR_NAME (expr))->value_id;\n-      break;\n-    case NARY:\n-      gcc_assert (!PRE_EXPR_NARY (expr)->predicated_values);\n-      id = PRE_EXPR_NARY (expr)->value_id;\n-      break;\n-    case REFERENCE:\n-      id = PRE_EXPR_REFERENCE (expr)->value_id;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n   /* ???  We cannot assert that expr has a value-id (it can be 0), because\n      we assign value-ids only to expressions that have a result\n      in set_hashtable_value_ids.  */\n-  return id;\n+  return expr->value_id;\n }\n \n /* Return a VN valnum (SSA name or constant) for the PRE value-id VAL.  */\n \n static tree\n vn_valnum_from_value_id (unsigned int val)\n {\n+  if (value_id_constant_p (val))\n+    {\n+      pre_expr vexpr = constant_value_expressions[-val];\n+      if (vexpr)\n+\treturn PRE_EXPR_CONSTANT (vexpr);\n+      return NULL_TREE;\n+    }\n+\n+  bitmap exprset = value_expressions[val];\n   bitmap_iterator bi;\n   unsigned int i;\n-  bitmap exprset;\n-  if (value_id_constant_p (val))\n-    exprset = constant_value_expressions[-val];\n-  else\n-    exprset = value_expressions[val];\n   EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n     {\n       pre_expr vexpr = expression_for_id (i);\n       if (vexpr->kind == NAME)\n \treturn VN_INFO (PRE_EXPR_NAME (vexpr))->valnum;\n-      else if (vexpr->kind == CONSTANT)\n-\treturn PRE_EXPR_CONSTANT (vexpr);\n     }\n   return NULL_TREE;\n }\n@@ -1102,7 +1138,6 @@ static pre_expr\n get_or_alloc_expr_for_constant (tree constant)\n {\n   unsigned int result_id;\n-  unsigned int value_id;\n   struct pre_expr_d expr;\n   pre_expr newexpr;\n \n@@ -1117,8 +1152,8 @@ get_or_alloc_expr_for_constant (tree constant)\n   newexpr->loc = UNKNOWN_LOCATION;\n   PRE_EXPR_CONSTANT (newexpr) = constant;\n   alloc_expression_id (newexpr);\n-  value_id = get_or_alloc_constant_value_id (constant);\n-  add_to_value (value_id, newexpr);\n+  newexpr->value_id = get_or_alloc_constant_value_id (constant);\n+  add_to_value (newexpr->value_id, newexpr);\n   return newexpr;\n }\n \n@@ -1475,28 +1510,17 @@ phi_translate_1 (bitmap_set_t dest,\n \t    if (result && is_gimple_min_invariant (result))\n \t      return get_or_alloc_expr_for_constant (result);\n \n-\t    expr = pre_expr_pool.allocate ();\n-\t    expr->kind = NARY;\n-\t    expr->id = 0;\n-\t    expr->loc = expr_loc;\n-\t    if (nary && !nary->predicated_values)\n-\t      {\n-\t\tPRE_EXPR_NARY (expr) = nary;\n-\t\tnew_val_id = nary->value_id;\n-\t\tget_or_alloc_expression_id (expr);\n-\t      }\n-\t    else\n+\t    if (!nary || nary->predicated_values)\n \t      {\n \t\tnew_val_id = get_next_value_id ();\n \t\tnary = vn_nary_op_insert_pieces (newnary->length,\n \t\t\t\t\t\t newnary->opcode,\n \t\t\t\t\t\t newnary->type,\n \t\t\t\t\t\t &newnary->op[0],\n \t\t\t\t\t\t result, new_val_id);\n-\t\tPRE_EXPR_NARY (expr) = nary;\n-\t\tget_or_alloc_expression_id (expr);\n \t      }\n-\t    add_to_value (new_val_id, expr);\n+\t    expr = get_or_alloc_expr_for_nary (nary, expr_loc);\n+\t    add_to_value (get_expr_value_id (expr), expr);\n \t  }\n \treturn expr;\n       }\n@@ -1628,11 +1652,6 @@ phi_translate_1 (bitmap_set_t dest,\n \t\treturn NULL;\n \t      }\n \n-\t    expr = pre_expr_pool.allocate ();\n-\t    expr->kind = REFERENCE;\n-\t    expr->id = 0;\n-\t    expr->loc = expr_loc;\n-\n \t    if (newref)\n \t      new_val_id = newref->value_id;\n \t    else\n@@ -1649,8 +1668,7 @@ phi_translate_1 (bitmap_set_t dest,\n \t\t\t\t\t\t     result, new_val_id);\n \t\tnewoperands = vNULL;\n \t      }\n-\t    PRE_EXPR_REFERENCE (expr) = newref;\n-\t    get_or_alloc_expression_id (expr);\n+\t    expr = get_or_alloc_expr_for_reference (newref, expr_loc);\n \t    add_to_value (new_val_id, expr);\n \t  }\n \tnewoperands.release ();\n@@ -1782,19 +1800,8 @@ static pre_expr\n bitmap_find_leader (bitmap_set_t set, unsigned int val)\n {\n   if (value_id_constant_p (val))\n-    {\n-      unsigned int i;\n-      bitmap_iterator bi;\n-      bitmap exprset = constant_value_expressions[-val];\n+    return constant_value_expressions[-val];\n \n-      EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n-\t{\n-\t  pre_expr expr = expression_for_id (i);\n-\t  if (expr->kind == CONSTANT)\n-\t    return expr;\n-\t}\n-      gcc_unreachable ();\n-    }\n   if (bitmap_set_contains_value (set, val))\n     {\n       /* Rather than walk the entire bitmap of expressions, and see\n@@ -3932,13 +3939,8 @@ compute_avail (void)\n \t\t    || gimple_bb (SSA_NAME_DEF_STMT\n \t\t\t\t    (gimple_vuse (stmt))) != block)\n \t\t  {\n-\t\t    result = pre_expr_pool.allocate ();\n-\t\t    result->kind = REFERENCE;\n-\t\t    result->id = 0;\n-\t\t    result->loc = gimple_location (stmt);\n-\t\t    PRE_EXPR_REFERENCE (result) = ref;\n-\n-\t\t    get_or_alloc_expression_id (result);\n+\t\t    result = get_or_alloc_expr_for_reference\n+\t\t\t       (ref, gimple_location (stmt));\n \t\t    add_to_value (get_expr_value_id (result), result);\n \t\t    bitmap_value_insert_into_set (EXP_GEN (block), result);\n \t\t  }\n@@ -3973,11 +3975,8 @@ compute_avail (void)\n \t\t\t  && vn_nary_may_trap (nary))\n \t\t\tcontinue;\n \n-\t\t      result = pre_expr_pool.allocate ();\n-\t\t      result->kind = NARY;\n-\t\t      result->id = 0;\n-\t\t      result->loc = gimple_location (stmt);\n-\t\t      PRE_EXPR_NARY (result) = nary;\n+\t\t      result = get_or_alloc_expr_for_nary\n+\t\t\t\t (nary, gimple_location (stmt));\n \t\t      break;\n \t\t    }\n \n@@ -4098,19 +4097,15 @@ compute_avail (void)\n \t\t\t}\n \t\t      operands.release ();\n \n-\t\t      result = pre_expr_pool.allocate ();\n-\t\t      result->kind = REFERENCE;\n-\t\t      result->id = 0;\n-\t\t      result->loc = gimple_location (stmt);\n-\t\t      PRE_EXPR_REFERENCE (result) = ref;\n+\t\t      result = get_or_alloc_expr_for_reference\n+\t\t\t\t (ref, gimple_location (stmt));\n \t\t      break;\n \t\t    }\n \n \t\t  default:\n \t\t    continue;\n \t\t  }\n \n-\t\tget_or_alloc_expression_id (result);\n \t\tadd_to_value (get_expr_value_id (result), result);\n \t\tbitmap_value_insert_into_set (EXP_GEN (block), result);\n \t\tcontinue;"}]}