{"sha": "de17c25fdeaaf1349606d744b4e9b79e5f12af72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUxN2MyNWZkZWFhZjEzNDk2MDZkNzQ0YjRlOWI3OWU1ZjEyYWY3Mg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-02-13T21:31:35Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-02-13T21:31:35Z"}, "message": "re PR target/19019 (GCC ldouble format incompatibility with XLC long double)\n\n        PR target/19019\n        * config/rs6000/aix.h ({TARGET,MASK}_XL_CALL): Rename to\n        {TARGET,MASK}_XL_COMPAT.\n        (SUBTARGET_SWITCHES): Rename xl-call to xl-compat.  Use\n        MASK_XL_COMPAT.\n        * config/rs6000/beos.h ({TARGET,MASK}_XL_CALL): Remove.\n        * config/rs6000/rs6000.c (function_arg): Change TARGET_XL_CALL to\n        TARGET_XL_COMPAT.\n        (rs6000_arg_partial_bytes): Same.\n        (rs6000_generate_compare): Generate PARALLEL for compare if TFmode\n        and XL compatibility enabled.\n        * config/rs6000/rs6000.h (TARGET_XL_CALL): Rename to TARGET_XL_COMPAT.\n        * config/rs6000/rs6000.md (cmptf_internal1): Add !TARGET_XL_COMPAT\n        test to final condition.\n        (cmptf_internal2): New.\n        * doc/invoke.texi (RS/6000 Subtarget Options): Change xl-call to\n        xl-compat.  Add TFmode information to description.\n\nFrom-SVN: r94991", "tree": {"sha": "bf91ebcde9a914d0a4787212474b788cb969d2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf91ebcde9a914d0a4787212474b788cb969d2b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de17c25fdeaaf1349606d744b4e9b79e5f12af72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de17c25fdeaaf1349606d744b4e9b79e5f12af72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de17c25fdeaaf1349606d744b4e9b79e5f12af72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de17c25fdeaaf1349606d744b4e9b79e5f12af72/comments", "author": null, "committer": null, "parents": [{"sha": "4fa0972f8e4d9ded2e62059c9c241b91e99bbe5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa0972f8e4d9ded2e62059c9c241b91e99bbe5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fa0972f8e4d9ded2e62059c9c241b91e99bbe5e"}], "stats": {"total": 165, "additions": 130, "deletions": 35}, "files": [{"sha": "697588ca1e0368cc0e4b970ae7d727d3759c0a7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -1,3 +1,23 @@\n+2005-02-13  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR target/19019\n+\t* config/rs6000/aix.h ({TARGET,MASK}_XL_CALL): Rename to\n+\t{TARGET,MASK}_XL_COMPAT.\n+\t(SUBTARGET_SWITCHES): Rename xl-call to xl-compat.  Use\n+\tMASK_XL_COMPAT.\n+\t* config/rs6000/beos.h ({TARGET,MASK}_XL_CALL): Remove.\n+\t* config/rs6000/rs6000.c (function_arg): Change TARGET_XL_CALL to\n+\tTARGET_XL_COMPAT.\n+\t(rs6000_arg_partial_bytes): Same.\n+\t(rs6000_generate_compare): Generate PARALLEL for compare if TFmode\n+\tand XL compatibility enabled.\n+\t* config/rs6000/rs6000.h (TARGET_XL_CALL): Rename to TARGET_XL_COMPAT.\n+\t* config/rs6000/rs6000.md (cmptf_internal1): Add !TARGET_XL_COMPAT\n+\ttest to final condition.\n+\t(cmptf_internal2): New.\n+\t* doc/invoke.texi (RS/6000 Subtarget Options): Change xl-call to\n+\txl-compat.  Add TFmode information to description.\n+\n 2005-02-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* flags.h, read-rtl.c, tree-ssa-live.h: Update copyright."}, {"sha": "d8a0f69b724144e32b25809ecba701fcc9163464", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -194,15 +194,15 @@\n #define JUMP_TABLES_IN_TEXT_SECTION 1\n \n /* Enable AIX XL compiler calling convention breakage compatibility.  */\n-#undef TARGET_XL_CALL\n-#define MASK_XL_CALL\t\t0x40000000\n-#define\tTARGET_XL_CALL\t\t(target_flags & MASK_XL_CALL)\n+#undef TARGET_XL_COMPAT\n+#define MASK_XL_COMPAT\t\t0x40000000\n+#define\tTARGET_XL_COMPAT\t(target_flags & MASK_XL_COMPAT)\n #undef  SUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES\t\t\\\n-  {\"xl-call\", \t\tMASK_XL_CALL,\t\t\t\t\t\\\n-   N_(\"Always pass floating-point arguments in memory\") },\t\t\\\n-  {\"no-xl-call\",\t- MASK_XL_CALL,\t\t\t\t\t\\\n-   N_(\"Don't always pass floating-point arguments in memory\") },\t\\\n+  {\"xl-compat\", \tMASK_XL_COMPAT,\t\t\t\t\t\\\n+   N_(\"Conform more closely to IBM XLC semantics\") },\t\t\\\n+  {\"no-xl-compat\",\t- MASK_XL_COMPAT,\t\t\t\t\t\\\n+   N_(\"Default GCC semantics that differ from IBM XLC\") },\t\\\n   SUBSUBTARGET_SWITCHES\n #define SUBSUBTARGET_SWITCHES \n "}, {"sha": "a9e88ac2f3227a3e2b4fea2a18948add64c2a343", "filename": "gcc/config/rs6000/beos.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Fbeos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Fbeos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fbeos.h?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -23,18 +23,6 @@\n #undef  TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (BeOS/PowerPC)\");\n \n-/* Enable AIX XL compiler calling convention breakage compatibility.  */\n-#define MASK_XL_CALL\t\t0x40000000\n-#define\tTARGET_XL_CALL\t\t(target_flags & MASK_XL_CALL)\n-#undef  SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES\t\t\\\n-  {\"xl-call\", \t\tMASK_XL_CALL,\t\t\t\t\t\\\n-   N_(\"Always pass floating-point arguments in memory\") },\t\t\\\n-  {\"no-xl-call\",\t- MASK_XL_CALL,\t\t\t\t\t\\\n-   N_(\"Don't always pass floating-point arguments in memory\") },\t\\\n-  {\"threads\",\t\t0},\t\t\t\t\t\t\\\n-  {\"pe\",\t\t0},\n-\n #undef ASM_SPEC\n #define ASM_SPEC \"-u %(asm_cpu)\"\n "}, {"sha": "4d327fd71b1e49902b0aa7c4fb7abe75a39f1ee9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -5604,7 +5604,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  needs_psave = (type\n \t\t\t && (cum->nargs_prototype <= 0\n \t\t\t     || (DEFAULT_ABI == ABI_AIX\n-\t\t\t\t && TARGET_XL_CALL\n+\t\t\t\t && TARGET_XL_COMPAT\n \t\t\t\t && align_words >= GP_ARG_NUM_REG)));\n \n \t  if (!needs_psave && mode == fmode)\n@@ -5712,7 +5712,7 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && !(type\n \t   && (cum->nargs_prototype <= 0\n \t       || (DEFAULT_ABI == ABI_AIX\n-\t\t   && TARGET_XL_CALL\n+\t\t   && TARGET_XL_COMPAT\n \t\t   && align_words >= GP_ARG_NUM_REG))))\n     {\n       if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3) > FP_ARG_MAX_REG + 1)\n@@ -11458,10 +11458,34 @@ rs6000_generate_compare (enum rtx_code code)\n       emit_insn (cmp);\n     }\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, compare_result,\n-\t\t\t    gen_rtx_COMPARE (comp_mode,\n-\t\t\t\t\t     rs6000_compare_op0,\n-\t\t\t\t\t     rs6000_compare_op1)));\n+    {\n+      /* Generate XLC-compatible TFmode compare as PARALLEL with extra\n+\t CLOBBERs to match cmptf_internal2 pattern.  */\n+      if (comp_mode == CCFPmode && TARGET_XL_COMPAT\n+\t  && GET_MODE (rs6000_compare_op0) == TFmode\n+\t  && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+\t  && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128)\n+\temit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t  gen_rtvec (9,\n+\t\t     gen_rtx_SET (VOIDmode,\n+\t\t\t\t  compare_result,\n+\t\t\t\t  gen_rtx_COMPARE (comp_mode,\n+\t\t\t\t\t\t   rs6000_compare_op0,\n+\t\t\t\t\t\t   rs6000_compare_op1)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)),\n+\t\t     gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (DFmode)))));\n+      else\n+\temit_insn (gen_rtx_SET (VOIDmode, compare_result,\n+\t\t\t\tgen_rtx_COMPARE (comp_mode,\n+\t\t\t\t\t\t rs6000_compare_op0,\n+\t\t\t\t\t\t rs6000_compare_op1)));\n+    }\n \n   /* Some kinds of FP comparisons need an OR operation;\n      under flag_unsafe_math_optimizations we don't bother.  */"}, {"sha": "1a2d12df2ce79e4cfb995d72daacd3f080dfff1d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -262,7 +262,7 @@ extern int target_flags;\n #define TARGET_POWERPC64\t(target_flags & MASK_POWERPC64)\n #endif\n \n-#define TARGET_XL_CALL 0\n+#define TARGET_XL_COMPAT 0\n \n /* Run-time compilation parameters selecting different hardware subsets.\n "}, {"sha": "515bb056cae89f4ebcc289fc1be7e6cf37b026f5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -11364,11 +11364,70 @@\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"f\")\n \t\t      (match_operand:TF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN) && !TARGET_XL_COMPAT\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n   \"fcmpu %0,%1,%2\\;bne %0,$+8\\;fcmpu %0,%L1,%L2\"\n   [(set_attr \"type\" \"fpcompare\")\n    (set_attr \"length\" \"12\")])\n+\n+(define_insn_and_split \"*cmptf_internal2\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"f\")\n+\t\t      (match_operand:TF 2 \"gpc_reg_operand\" \"f\")))\n+    (clobber (match_scratch:DF 3 \"=f\"))\n+    (clobber (match_scratch:DF 4 \"=f\"))\n+    (clobber (match_scratch:DF 5 \"=f\"))\n+    (clobber (match_scratch:DF 6 \"=f\"))\n+    (clobber (match_scratch:DF 7 \"=f\"))\n+    (clobber (match_scratch:DF 8 \"=f\"))\n+    (clobber (match_scratch:DF 9 \"=f\"))\n+    (clobber (match_scratch:DF 10 \"=f\"))]\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN) && TARGET_XL_COMPAT\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3) (match_dup 13))\n+   (set (match_dup 4) (match_dup 14))\n+   (set (match_dup 9) (abs:DF (match_dup 5)))\n+   (set (match_dup 0) (compare:CCFP (match_dup 9) (match_dup 3)))\n+   (set (pc) (if_then_else (ne (match_dup 0) (const_int 0))\n+\t\t\t   (label_ref (match_dup 11))\n+\t\t\t   (pc)))\n+   (set (match_dup 0) (compare:CCFP (match_dup 5) (match_dup 7)))\n+   (set (pc) (label_ref (match_dup 12)))\n+   (match_dup 11)\n+   (set (match_dup 10) (minus:DF (match_dup 5) (match_dup 7)))\n+   (set (match_dup 9) (minus:DF (match_dup 6) (match_dup 8)))\n+   (set (match_dup 9) (plus:DF (match_dup 10) (match_dup 9)))\n+   (set (match_dup 0) (compare:CCFP (match_dup 7) (match_dup 4)))\n+   (match_dup 12)]\n+{\n+  REAL_VALUE_TYPE rv;\n+  const int lo_word = FLOAT_WORDS_BIG_ENDIAN ? GET_MODE_SIZE (DFmode) : 0;\n+  const int hi_word = FLOAT_WORDS_BIG_ENDIAN ? 0 : GET_MODE_SIZE (DFmode);\n+\n+  operands[5] = simplify_gen_subreg (DFmode, operands[1], TFmode, hi_word);\n+  operands[6] = simplify_gen_subreg (DFmode, operands[1], TFmode, lo_word);\n+  operands[7] = simplify_gen_subreg (DFmode, operands[2], TFmode, hi_word);\n+  operands[8] = simplify_gen_subreg (DFmode, operands[2], TFmode, lo_word);\n+  operands[11] = gen_label_rtx ();\n+  operands[12] = gen_label_rtx ();\n+  real_inf (&rv);\n+  operands[13] = force_const_mem (DFmode,\n+\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (rv, DFmode));\n+  operands[14] = force_const_mem (DFmode,\n+\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (dconst0,\n+\t\t\t\t\t\t\t\tDFmode));\n+  if (TARGET_TOC)\n+    {\n+      operands[13] = gen_const_mem (DFmode,\n+\t\t\t\t    create_TOC_reference (XEXP (operands[13], 0)));\n+      operands[14] = gen_const_mem (DFmode,\n+\t\t\t\t    create_TOC_reference (XEXP (operands[14], 0)));\n+      set_mem_alias_set (operands[13], get_TOC_alias_set ());\n+      set_mem_alias_set (operands[14], get_TOC_alias_set ());\n+    }\n+})\n \f\n ;; Now we have the scc insns.  We can do some combinations because of the\n ;; way the machine works."}, {"sha": "a93c8f0ca423f579c56907da561d06318cc7e203", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de17c25fdeaaf1349606d744b4e9b79e5f12af72/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=de17c25fdeaaf1349606d744b4e9b79e5f12af72", "patch": "@@ -602,7 +602,7 @@ See RS/6000 and PowerPC Options.\n -mpowerpc-gfxopt  -mno-powerpc-gfxopt @gol\n -mnew-mnemonics  -mold-mnemonics @gol\n -mfull-toc   -mminimal-toc  -mno-fp-in-toc  -mno-sum-in-toc @gol\n--m64  -m32  -mxl-call  -mno-xl-call  -mpe @gol\n+-m64  -m32  -mxl-compat  -mno-xl-compat  -mpe @gol\n -malign-power  -malign-natural @gol\n -msoft-float  -mhard-float  -mmultiple  -mno-multiple @gol\n -mstring  -mno-string  -mupdate  -mno-update @gol\n@@ -10501,13 +10501,17 @@ Specifying @option{-maix64} implies @option{-mpowerpc64} and\n @option{-mpowerpc}, while @option{-maix32} disables the 64-bit ABI and\n implies @option{-mno-powerpc64}.  GCC defaults to @option{-maix32}.\n \n-@item -mxl-call\n-@itemx -mno-xl-call\n-@opindex mxl-call\n-@opindex mno-xl-call\n-On AIX, pass floating-point arguments to prototyped functions beyond the\n-register save area (RSA) on the stack in addition to argument FPRs.  The\n-AIX calling convention was extended but not initially documented to\n+@item -mxl-compat\n+@itemx -mno-xl-compat\n+@opindex mxl-compat\n+@opindex mno-xl-compat\n+Produce code that conforms more closely to IBM XLC semantics when using\n+AIX-compatible ABI.  Pass floating-point arguments to prototyped\n+functions beyond the register save area (RSA) on the stack in addition\n+to argument FPRs.  Do not assume that most significant double in 128\n+bit long double value is properly rounded when comparing values.\n+\n+The AIX calling convention was extended but not initially documented to\n handle an obscure K&R C case of calling a function that takes the\n address of its arguments with fewer arguments than declared.  AIX XL\n compilers access floating point arguments which do not fit in the"}]}