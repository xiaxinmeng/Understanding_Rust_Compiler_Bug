{"sha": "de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0YmY2Y2I5NDFlZTY4MGIyMmU0ZjVmN2JmM2ZkNDIwMjNmZmNlOQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gnat.com", "date": "2001-10-30T21:16:50Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-10-30T21:16:50Z"}, "message": "ali-util.adb (Initialize_Checksum): Use out-mode instead of in out.\n\n\t* ali-util.adb (Initialize_Checksum): Use out-mode instead of in out.\n\tFound due to GCC 3.0 warning of using uninitialized value.\n\n\t* layout.adb:\n\t(Get_Max_Size): Use variant record for tracking value/expression.\n\t Makes logic clearer and prevents warnings for uninitialized variables.\n\t(Layout_Array_Type): Use variant record for tracking value/expression.\n\t Makes logic clearer and prevents warnings for uninitialized variables.\n\nFrom-SVN: r46652", "tree": {"sha": "c0b3deed66bc4091f9be0dbe6d916285a650cc86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0b3deed66bc4091f9be0dbe6d916285a650cc86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/comments", "author": null, "committer": null, "parents": [{"sha": "f5e44987a6f7e1028e5b959935fd33768548357f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e44987a6f7e1028e5b959935fd33768548357f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e44987a6f7e1028e5b959935fd33768548357f"}], "stats": {"total": 173, "additions": 97, "deletions": 76}, "files": [{"sha": "a075fd9289fb99d8fd967faf1b9b42fc9838d20a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "patch": "@@ -1,3 +1,14 @@\n+2001-10-30  Geert Bosch <bosch@gnat.com>\n+\n+\t* ali-util.adb (Initialize_Checksum): Use out-mode instead of in out. \n+\tFound due to GCC 3.0 warning of using uninitialized value.\n+\t\n+\t* layout.adb:\n+\t(Get_Max_Size): Use variant record for tracking value/expression.\n+\t Makes logic clearer and prevents warnings for uninitialized variables.\n+\t(Layout_Array_Type): Use variant record for tracking value/expression.\n+\t Makes logic clearer and prevents warnings for uninitialized variables.\n+\n 2001-10-30  Robert Dewar <dewar@gnat.com>\n \n \t* lib.adb: Minor reformatting"}, {"sha": "6b1829d067f0bc4434fb86856dca1031c71d96ce", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "patch": "@@ -50,7 +50,7 @@ package body ALI.Util is\n    --  generate code, so it is not necessary to worry about making the right\n    --  sequence of calls in any error situation.\n \n-   procedure Initialize_Checksum (Csum : in out Word);\n+   procedure Initialize_Checksum (Csum : out Word);\n    --  Sets initial value of Csum before any calls to Accumulate_Checksum\n \n    -------------------------\n@@ -286,7 +286,7 @@ package body ALI.Util is\n    -- Initialize_Checksum --\n    -------------------------\n \n-   procedure Initialize_Checksum (Csum : in out Word) is\n+   procedure Initialize_Checksum (Csum : out Word) is\n    begin\n       System.CRC32.Initialize (System.CRC32.CRC32 (Csum));\n    end Initialize_Checksum;"}, {"sha": "f4c1754c2325f99dc4c13dd6a96599921e12a4d3", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 84, "deletions": 74, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=de4bf6cb941ee680b22e4f5f7bf3fd42023ffce9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n --            Copyright (C) 2001 Free Software Foundation, Inc.             --\n --                                                                          --\n@@ -579,20 +579,22 @@ package body Layout is\n       Len  : Node_Id;\n \n       type Val_Status_Type is (Const, Dynamic);\n+\n+      type Val_Type (Status : Val_Status_Type := Const) is\n+         record\n+            case Status is\n+               when Const   => Val : Uint;\n+               when Dynamic => Nod : Node_Id;\n+            end case;\n+         end record;\n       --  Shows the status of the value so far. Const means that the value\n-      --  is constant, and Sval is the current constant value. Dynamic means\n-      --  that the value is dynamic, and in this case Snod is the Node_Id of\n+      --  is constant, and Val is the current constant value. Dynamic means\n+      --  that the value is dynamic, and in this case Nod is the Node_Id of\n       --  the expression to compute the value.\n \n-      Val_Status : Val_Status_Type;\n-      --  Indicate status of value so far\n-\n-      Sval : Uint := Uint_0;\n-      --  Calculated value so far if Val_Status = Const\n-      --  (initialized to prevent junk warning)\n-\n-      Snod : Node_Id;\n-      --  Expression value so far if Val_Status = Dynamic\n+      Size : Val_Type;\n+      --  Calculated value so far if Size.Status = Const,\n+      --  or expression value so far if Size.Status = Dynamic.\n \n       SU_Convert_Required : Boolean := False;\n       --  This is set to True if the final result must be converted from\n@@ -644,12 +646,10 @@ package body Layout is\n       --  Initialize status from component size\n \n       if Known_Static_Component_Size (E) then\n-         Val_Status := Const;\n-         Sval := Component_Size (E);\n+         Size := (Const, Component_Size (E));\n \n       else\n-         Val_Status := Dynamic;\n-         Snod := Expr_From_SO_Ref (Loc, Component_Size (E));\n+         Size := (Dynamic, Expr_From_SO_Ref (Loc, Component_Size (E)));\n       end if;\n \n       --  Loop through indices\n@@ -678,8 +678,8 @@ package body Layout is\n \n             --  Current value is constant, evolve value\n \n-            if Val_Status = Const then\n-               Sval := Sval * S;\n+            if Size.Status = Const then\n+               Size.Val := Size.Val * S;\n \n             --  Current value is dynamic\n \n@@ -695,9 +695,9 @@ package body Layout is\n                   SU_Convert_Required := False;\n                end if;\n \n-               Snod :=\n+               Size.Nod :=\n                  Assoc_Multiply (Loc,\n-                   Left_Opnd  => Snod,\n+                   Left_Opnd  => Size.Nod,\n                    Right_Opnd =>\n                      Make_Integer_Literal (Loc, Intval => S));\n             end if;\n@@ -712,24 +712,25 @@ package body Layout is\n             --  we want to do the SU conversion after computing the size in\n             --  this case.\n \n-            if Val_Status = Const then\n-               Val_Status := Dynamic;\n+            if Size.Status = Const then\n \n                --  If the current value is a multiple of the storage unit,\n                --  then most certainly we can do the conversion now, simply\n                --  by dividing the current value by the storage unit value.\n                --  If this works, we set SU_Convert_Required to False.\n \n-               if Sval mod SSU = 0 then\n-                  Snod := Make_Integer_Literal (Loc, Sval / SSU);\n+               if Size.Val mod SSU = 0 then\n+\n+                  Size :=\n+                    (Dynamic, Make_Integer_Literal (Loc, Size.Val / SSU));\n                   SU_Convert_Required := False;\n \n                --  Otherwise, we go ahead and convert the value in bits,\n                --  and set SU_Convert_Required to True to ensure that the\n                --  final value is indeed properly converted.\n \n                else\n-                  Snod := Make_Integer_Literal (Loc, Sval);\n+                  Size := (Dynamic, Make_Integer_Literal (Loc, Size.Val));\n                   SU_Convert_Required := True;\n                end if;\n             end if;\n@@ -771,8 +772,8 @@ package body Layout is\n       --  Here after processing all bounds to set sizes. If the value is\n       --  a constant, then it is bits, and we just return the value.\n \n-      if Val_Status = Const then\n-         return Make_Integer_Literal (Loc, Sval);\n+      if Size.Status = Const then\n+         return Make_Integer_Literal (Loc, Size.Val);\n \n       --  Case where the value is dynamic\n \n@@ -781,18 +782,18 @@ package body Layout is\n \n          if SU_Convert_Required then\n \n-            --  The expression required is (Snod + SU - 1) / SU\n+            --  The expression required is (Size.Nod + SU - 1) / SU\n \n-            Snod :=\n+            Size.Nod :=\n               Make_Op_Divide (Loc,\n                 Left_Opnd =>\n                   Make_Op_Add (Loc,\n-                    Left_Opnd  => Snod,\n+                    Left_Opnd  => Size.Nod,\n                     Right_Opnd => Make_Integer_Literal (Loc, SSU - 1)),\n                 Right_Opnd => Make_Integer_Literal (Loc, SSU));\n          end if;\n \n-         return Snod;\n+         return Size.Nod;\n       end if;\n    end Get_Max_Size;\n \n@@ -838,33 +839,40 @@ package body Layout is\n       --  question, and whose body is the expression.\n \n       type Val_Status_Type is (Const, Dynamic, Discrim);\n-      --  Shows the status of the value so far. Const means that the value\n-      --  is constant, and Sval is the current constant value. Dynamic means\n-      --  that the value is dynamic, and in this case Snod is the Node_Id of\n-      --  the expression to compute the value, and Discrim means that at least\n-      --  one bound is a discriminant, in which case Snod is the expression so\n-      --  far (which will be the body of the function).\n \n-      Val_Status : Val_Status_Type;\n-      --  Indicate status of value so far\n-\n-      Sval : Uint := Uint_0;\n-      --  Calculated value so far if Val_Status = Const\n-      --  Initialized to prevent junk warning\n-\n-      Snod : Node_Id;\n-      --  Expression value so far if Val_Status /= Const\n-\n-      Vtyp : Entity_Id;\n-      --  Variant record type for the formal parameter of the discriminant\n-      --  function V if Val_Status = Discrim.\n+      type Val_Type (Status : Val_Status_Type := Const) is\n+         record\n+            case Status is\n+               when Const =>\n+                  Val : Uint;\n+                  --  Calculated value so far if Val_Status = Const\n+\n+               when Dynamic | Discrim =>\n+                  Nod : Node_Id;\n+                  --  Expression value so far if Val_Status /= Const\n+\n+            end case;\n+         end record;\n+      --  Records the value or expression computed so far. Const means that\n+      --  the value is constant, and Val is the current constant value.\n+      --  Dynamic means that the value is dynamic, and in this case Nod is\n+      --  the Node_Id of the expression to compute the value, and Discrim\n+      --  means that at least one bound is a discriminant, in which case Nod\n+      --  is the expression so far (which will be the body of the function).\n+\n+      Size : Val_Type;\n+      --  Value of size computed so far. See comments above.\n+\n+      Vtyp : Entity_Id := Empty;\n+      --  Variant record type for the formal parameter of the\n+      --  discriminant function V if Status = Discrim.\n \n       SU_Convert_Required : Boolean := False;\n       --  This is set to True if the final result must be converted from\n       --  bits to storage units (rounding up to a storage unit boundary).\n \n       procedure Discrimify (N : in out Node_Id);\n-      --  If N represents a discriminant, then the Val_Status is set to\n+      --  If N represents a discriminant, then the Size.Status is set to\n       --  Discrim, and Vtyp is set. The parameter N is replaced with the\n       --  proper expression to extract the discriminant value from V.\n \n@@ -882,9 +890,9 @@ package body Layout is\n          then\n             Set_Size_Depends_On_Discriminant (E);\n \n-            if Val_Status /= Discrim then\n-               Val_Status := Discrim;\n+            if Size.Status /= Discrim then\n                Decl := Parent (Parent (Entity (N)));\n+               Size := (Discrim, Size.Nod);\n                Vtyp := Defining_Identifier (Decl);\n             end if;\n \n@@ -939,12 +947,10 @@ package body Layout is\n       --  Initialize status from component size\n \n       if Known_Static_Component_Size (E) then\n-         Val_Status := Const;\n-         Sval := Component_Size (E);\n+         Size := (Const, Component_Size (E));\n \n       else\n-         Val_Status := Dynamic;\n-         Snod := Expr_From_SO_Ref (Loc, Component_Size (E));\n+         Size := (Dynamic, Expr_From_SO_Ref (Loc, Component_Size (E)));\n       end if;\n \n       --  Loop to process array indices\n@@ -972,8 +978,8 @@ package body Layout is\n \n             --  If constant, evolve value\n \n-            if Val_Status = Const then\n-               Sval := Sval * S;\n+            if Size.Status = Const then\n+               Size.Val := Size.Val * S;\n \n             --  Current value is dynamic\n \n@@ -991,9 +997,9 @@ package body Layout is\n \n                --  Now go ahead and evolve the expression\n \n-               Snod :=\n+               Size.Nod :=\n                  Assoc_Multiply (Loc,\n-                   Left_Opnd  => Snod,\n+                   Left_Opnd  => Size.Nod,\n                    Right_Opnd =>\n                      Make_Integer_Literal (Loc, Intval => S));\n             end if;\n@@ -1008,24 +1014,24 @@ package body Layout is\n             --  we want to do the SU conversion after computing the size in\n             --  this case.\n \n-            if Val_Status = Const then\n-               Val_Status := Dynamic;\n+            if Size.Status = Const then\n \n                --  If the current value is a multiple of the storage unit,\n                --  then most certainly we can do the conversion now, simply\n                --  by dividing the current value by the storage unit value.\n                --  If this works, we set SU_Convert_Required to False.\n \n-               if Sval mod SSU = 0 then\n-                  Snod := Make_Integer_Literal (Loc, Sval / SSU);\n+               if Size.Val mod SSU = 0 then\n+                  Size :=\n+                    (Dynamic, Make_Integer_Literal (Loc, Size.Val / SSU));\n                   SU_Convert_Required := False;\n \n                --  Otherwise, we go ahead and convert the value in bits,\n                --  and set SU_Convert_Required to True to ensure that the\n                --  final value is indeed properly converted.\n \n                else\n-                  Snod := Make_Integer_Literal (Loc, Sval);\n+                  Size := (Dynamic, Make_Integer_Literal (Loc, Size.Val));\n                   SU_Convert_Required := True;\n                end if;\n             end if;\n@@ -1073,9 +1079,9 @@ package body Layout is\n \n             --  At this stage, Len has the expression for the length\n \n-            Snod :=\n+            Size.Nod :=\n               Assoc_Multiply (Loc,\n-                Left_Opnd  => Snod,\n+                Left_Opnd  => Size.Nod,\n                 Right_Opnd => Len);\n          end if;\n \n@@ -1086,8 +1092,8 @@ package body Layout is\n       --  a constant, then it is bits, and the only thing we need to do\n       --  is to check against explicit given size and do alignment adjust.\n \n-      if Val_Status = Const then\n-         Set_And_Check_Static_Size (E, Sval, Sval);\n+      if Size.Status = Const then\n+         Set_And_Check_Static_Size (E, Size.Val, Size.Val);\n          Adjust_Esize_Alignment (E);\n \n       --  Case where the value is dynamic\n@@ -1097,21 +1103,25 @@ package body Layout is\n \n          if SU_Convert_Required then\n \n-            --  The expression required is (Snod + SU - 1) / SU\n+            --  The expression required is (Size.Nod + SU - 1) / SU\n \n-            Snod :=\n+            Size.Nod :=\n               Make_Op_Divide (Loc,\n                 Left_Opnd =>\n                   Make_Op_Add (Loc,\n-                    Left_Opnd  => Snod,\n+                    Left_Opnd  => Size.Nod,\n                     Right_Opnd => Make_Integer_Literal (Loc, SSU - 1)),\n                 Right_Opnd => Make_Integer_Literal (Loc, SSU));\n          end if;\n \n          --  Now set the dynamic size (the Value_Size is always the same\n          --  as the Object_Size for arrays whose length is dynamic).\n \n-         Set_Esize (E, SO_Ref_From_Expr (Snod, Insert_Typ, Vtyp));\n+         --  ??? If Size.Status = Dynamic, Vtyp will not have been set.\n+         --  The added initialization sets it to Empty now, but is this\n+         --  correct?\n+\n+         Set_Esize (E, SO_Ref_From_Expr (Size.Nod, Insert_Typ, Vtyp));\n          Set_RM_Size (E, Esize (E));\n       end if;\n    end Layout_Array_Type;"}]}